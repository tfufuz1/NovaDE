# Ultimativer Implementierungsplan für NovaDE (Teil 1/100)

## 1\. Einführung und Gesamtarchitekturübersicht

NovaDE ist eine moderne, performante, anpassungsfähige und KI-gestützte Linux Desktop-Umgebung, entwickelt in Rust. Die Architektur ist in streng getrennte Schichten unterteilt, um Modularität, Wartbarkeit und Skalierbarkeit zu gewährleisten. Jede Schicht hat klar definierte Verantwortlichkeiten und kommuniziert ausschließlich über explizite Schnittstellen.

**Architekturschichten:**

  * **Kernschicht (`novade-core`):** Bietet grundlegende Datentypen, Dienstprogramme, Konfigurationsgrundlagen, Logging-Infrastruktur und allgemeine Fehlerdefinitionen. Sie hat keine Abhängigkeiten zu höheren Schichten.
  * **Domänenschicht (`novade-domain`):** Enthält die zentrale Geschäftslogik und domänenspezifische Entitäten. Sie ist unabhängig von der System- und UI-Schicht und definiert Policies.
  * **Systemschicht (`novade-system`):** Interagiert mit dem Betriebssystem, der Hardware und externen Diensten. Sie setzt die Richtlinien der Domänenschicht technisch um und stellt die Basis für die UI-Schicht dar.
  * **UI-Schicht (`novade-ui`):** Implementiert die Benutzeroberfläche basierend auf GTK4 und `gtk4-rs`. Sie reagiert auf Benutzerinteraktionen und visualisiert den Zustand des Systems.

### 1.1. Verzeichnisstruktur (Gesamtübersicht)

Die NovaDE-Codebasis wird in mehreren Crates organisiert sein, die die logischen Schichten widerspiegeln. Jede Crate (`novade-core`, `novade-domain`, `novade-system`, `novade-ui`) hat eine eigene `src/` Verzeichnisstruktur.

```
nova-de/
├── Cargo.toml
├── novade-core/
│   ├── Cargo.toml
│   └── src/
│       ├── lib.rs
│       ├── error.rs
│       └── types/
│           ├── mod.rs
│           ├── geometry.rs
│           ├── events.rs
│           └── general.rs
├── novade-domain/
│   ├── Cargo.toml
│   └── src/
│       ├── lib.rs
│       ├── config/
│       │   ├── mod.rs
│       │   ├── service.rs
│       │   ├── persistence.rs
│       │   └── errors.rs
│       ├── settings/
│       │   ├── mod.rs
│       │   ├── global.rs
│       │   ├── workspace.rs
│       │   └── errors.rs
│       ├── notifications/
│       │   ├── mod.rs
│       │   ├── types.rs
│       │   ├── persistence_iface.rs
│       │   ├── persistence.rs
│       │   ├── engine.rs
│       │   └── errors.rs
│       ├── window_management/
│       │   ├── mod.rs
│       │   ├── policies.rs
│       │   ├── rules.rs
│       │   └── errors.rs
│       ├── activity_tracking/
│       │   ├── mod.rs
│       │   ├── service.rs
│       │   └── errors.rs
│       ├── theme/
│       │   ├── mod.rs
│       │   ├── service.rs
│       │   └── errors.rs
│       ├── search/
│       │   ├── mod.rs
│       │   ├── engine.rs
│       │   └── errors.rs
│       └── user_management/
│           ├── mod.rs
│           ├── service.rs
│           └── errors.rs
├── novade-system/
│   ├── Cargo.toml
│   └── src/
│       ├── lib.rs
│       ├── compositor/
│       │   ├── mod.rs
│       │   ├── core.rs
│       │   ├── state.rs
│       │   ├── handlers.rs
│       │   ├── protocols/
│       │   │   ├── mod.rs
│       │   │   ├── xdg_shell.rs
│       │   │   ├── wlr_layer_shell.rs
│       │   │   ├── etc.rs
│       │   └── render/
│       │       ├── mod.rs
│       │       └── gl.rs
│       ├── input/
│       │   ├── mod.rs
│       │   ├── libinput_handler.rs
│       │   ├── keyboard.rs
│       │   ├── pointer.rs
│       │   └── gesture.rs
│       ├── dbus_interfaces/
│       │   ├── mod.rs
│       │   ├── clients/
│       │   │   ├── mod.rs
│       │   │   ├── network_manager.rs
│       │   │   ├── upower.rs
│       │   │   ├── logind.rs
│       │   │   └── secret_service.rs
│       │   └── server/
│       │       ├── mod.rs
│       │       └── notifications.rs
│       ├── audio_management/
│       │   ├── mod.rs
│       │   ├── pipewire_client.rs
│       │   └── errors.rs
│       ├── mcp_client/
│       │   ├── mod.rs
│       │   ├── client.rs
│       │   └── errors.rs
│       ├── window_mechanics/
│       │   ├── mod.rs
│       │   ├── layout_engine.rs
│       │   ├── surface_mapper.rs
│       │   └── errors.rs
│       ├── power_management/
│       │   ├── mod.rs
│       │   ├── service.rs
│       │   └── errors.rs
│       └── portals/
│           ├── mod.rs
│           ├── desktop_portals.rs
│           └── errors.rs
├── novade-ui/
│   ├── Cargo.toml
│   └── src/
│       ├── lib.rs
│       ├── main.rs
│       ├── app.rs
│       ├── components/
│       │   ├── mod.rs
│       │   ├── panel.rs
│       │   ├── tab_bar.rs
│       │   ├── sidebar.rs
│       │   ├── workspace_switcher.rs
│       │   ├── quick_actions_dock.rs
│       │   ├── control_center.rs
│       │   ├── speed_dial.rs
│       │   └── command_palette.rs
│       ├── style/
│       │   ├── mod.rs
│       │   ├── theming_engine.rs
│       │   └── css_provider.rs
│       ├── views/
│       │   ├── mod.rs
│       │   └── overview_mode.rs
│       └── utils/
│           ├── mod.rs
│           ├── gtk_helpers.rs
│           └── icon_loader.rs
└── tests/
    └── integration_tests.rs
```

### 1.2. Priorisierung der Implementierung

Die Implementierung wird von den grundlegendsten, abhängigkeitsfreien Schichten und Modulen auf die höheren Schichten und komplexeren Module aufbauen.

1.  **`novade-core`**: Muss vollständig implementiert sein, bevor andere Schichten beginnen.
      * `novade-core/src/error`
      * `novade-core/src/types/geometry`
      * `novade-core/src/types/events`
      * `novade-core/src/types/general`
2.  **`novade-domain`**: Kann beginnen, sobald `novade-core` stabil ist. Module ohne Abhängigkeiten zu anderen Domänenmodulen zuerst.
      * `novade-domain/src/config`
      * `novade-domain/src/settings`
      * `novade-domain/src/notifications` (abhängig von `config`, `settings`)
      * `novade-domain/src/window_management` (abhängig von `settings`)
      * `novade-domain/src/activity_tracking`
      * `novade-domain/src/theme`
      * `novade-domain/src/search`
      * `novade-domain/src/user_management`
3.  **`novade-system`**: Kann beginnen, sobald `novade-core` und kritische Teile von `novade-domain` (z.B. `window_management` policies) stabil sind.
      * `novade-system/src/compositor` (Kernkomponente)
      * `novade-system/src/input` (Kernkomponente)
      * `novade-system/src/dbus_interfaces` (Clients vor Servern)
      * `novade-system/src/audio_management`
      * `novade-system/src/mcp_client`
      * `novade-system/src/window_mechanics` (abhängig von `compositor`, `domain::window_management`)
      * `novade-system/src/power_management`
      * `novade-system/src/portals`
4.  **`novade-ui`**: Kann beginnen, sobald `novade-core`, `novade-domain` und `novade-system` ausreichend APIs bereitstellen.

-----

## 2\. Detaillierte Implementierungsspezifikation: `novade-core` Crate

### 2.1. `novade-core/src/lib.rs`

  * **Verzeichnis-/Modulname:** `novade-core/src/lib.rs`
  * **Verantwortlichkeit:** Dies ist die Wurzelbibliothek der Kernschicht. Sie ist verantwortlich für das Re-Exportieren aller öffentlichen APIs der Untermodule (`error`, `types`) und für die Initialisierung globaler Ressourcen, falls erforderlich (z.B. das Logging-System).
  * **Kern-Aufgaben (Tasks):**
    1.  **Re-Exporte definieren:** Die `pub use` Anweisungen für alle öffentlichen Komponenten der Untermodule festlegen.
    2.  **Globale Initialisierung (optional):** Eine `initialize()`-Funktion bereitstellen, die das `tracing`-Logging-System konfiguriert und startet. Diese Funktion sollte nur einmal aufgerufen werden.
  * **Spezifische Artefakte/Dateien:**
      * `novade-core/src/lib.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_core::error`, `novade_core::types`
      * **Extern:** `tracing` (für Logging-Initialisierung), `tracing-subscriber` (für konkrete Implementierung des Loggers).
  * **Kommunikationsmuster:** Stellt eine öffentliche API für höhere Schichten bereit, um auf Kernfunktionalitäten zuzugreifen.
  * **Erwartete Ergebnisse/Outputs:** Eine robuste, exportierte Bibliothek, die die grundlegenden Typen, Fehler und Dienstprogramme für die gesamte NovaDE bereitstellt.
  * **Teststrategie (Modul-spezifisch):**
      * Sicherstellen, dass alle Re-Exporte korrekt funktionieren und die Module erreichbar sind.
      * Tests für die Initialisierungsfunktion, um sicherzustellen, dass das Logging korrekt eingerichtet wird und keine Panics auftreten.

#### Funktionsspezifikation: `novade_core::init()`

```rust
/// Initialisiert die NovaDE-Kernkomponenten, insbesondere das Logging-System.
/// Diese Funktion sollte einmalig zu Beginn der Anwendung aufgerufen werden.
///
/// # Errors
/// Gibt einen `CoreError` zurück, falls die Initialisierung des Logging-Systems fehlschlägt.
///
/// # Panics
/// Diese Funktion sollte nicht paniken.
///
/// # Optimierungen
/// Keine spezifischen Performance-Optimierungen erforderlich, da einmaliger Aufruf.
///
/// # Tests
/// - Positivtest: `init()` wird erfolgreich aufgerufen und das Logging ist konfiguriert.
/// - Negativtest: (Nicht anwendbar, da `tracing_subscriber` typischerweise keine Fehler wirft,
///                 aber falls ein Fehler bei der Logger-Konfiguration auftritt,
///                 sollte dieser als `CoreError::Logging` propagiert werden).
///
/// # Dokumentation
/// - Inline-Kommentare für die Funktion.
/// - `#[doc]`-Attribute für Parameter und Rückgabewerte.
pub fn init() -> Result<(), crate::error::CoreError> {
    // Configure tracing subscriber (e.g., with EnvFilter and FmtSubscriber)
    // This setup uses a simple console subscriber for demonstration.
    // In a real application, more sophisticated filtering and output might be used.
    tracing_subscriber::fmt::Subscriber::builder()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .try_init()
        .map_err(|e| crate::error::CoreError::Logging(
            crate::error::LoggingError::InitializationFailed(e.to_string())
        ))?; // Convert potential error to CoreError

    tracing::info!("NovaDE Core initialized.");
    Ok(())
}
```

### 2.2. `novade-core/src/error.rs`

  * **Verzeichnis-/Modulname:** `novade-core/src/error.rs`
  * **Verantwortlichkeit:** Definiert die grundlegenden, generischen Fehler-Typen, die in der gesamten Kernschicht und als Basis für höher-schichtige Fehler verwendet werden können. Gewährleistet konsistente Fehlerbehandlung und -propagation.
  * **Kern-Aufgaben (Tasks):**
    1.  **`CoreError` Enum definieren:** Erstellen des Basis-Fehlertyps mit relevanten Varianten (z.B. `Io`, `Config`, `Logging`, `Unknown`).
    2.  **`thiserror` Implementierung:** Nutzen der `thiserror`-Crate, um automatische `Display` und `Error` Trait-Implementierungen zu generieren und Fehlerkontext bereitzustellen.
    3.  **`From` Trait-Implementierungen:** Bereitstellung von Konvertierungen von Standard-Bibliotheksfehlern (z.B. `std::io::Error`) in `CoreError`.
    4.  **`ConfigError` Enum definieren:** Spezifische Fehler für Konfigurationsoperationen.
    5.  **`LoggingError` Enum definieren:** Spezifische Fehler für Logging-Operationen.
    6.  **Fehler-Konvertierungen sicherstellen:** Implementieren von `From` Trait-Implementierungen für `ConfigError` und `LoggingError` zu `CoreError`.
    7.  **Unit Tests:** Umfassende Tests für Fehlererstellung, Konvertierung und Nachrichtenformatierung.
  * **Spezifische Artefakte/Dateien:**
      * `novade-core/src/error.rs`
  * **Abhängigkeiten:**
      * **Extern:** `thiserror`, `tracing` (optional, für Debugging-Zwecke bei Fehlererstellung)
  * **Kommunikationsmuster:** Fehler werden als `Result<T, E>`-Typen zurückgegeben und können von aufrufenden Funktionen über den `?`-Operator propagiert werden. Die `source()`-Kette muss erhalten bleiben.
  * **Erwartete Ergebnisse/Outputs:** Eine klar definierte und leicht zu verwendende Fehlerhierarchie für die Kernschicht und als Grundlage für die gesamte Anwendung.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests für `CoreError`:**
          * Test der Erstellung jeder Variante.
          * Test der korrekten `Display`-Implementierung für jede Variante.
          * Test der `source()`-Implementierung (Fehlerverkettung).
          * Test der Konvertierung von `std::io::Error` und anderen `std::error::Error` Implementierungen.
      * **Unit Tests für `ConfigError` und `LoggingError`:**
          * Analoge Tests wie für `CoreError`.
          * Test der Konvertierung zu `CoreError`.

#### Funktionsspezifikation: `novade_core::error::CoreError`

```rust
// novade-core/src/error.rs

use thiserror::Error;
use std::fmt;

/// Basis-Fehlertyp für die NovaDE Kernschicht und als Grundlage für anwendungsweite Fehler.
#[derive(Debug, Error)]
pub enum CoreError {
    /// Ein E/A-Fehler, typischerweise von `std::io::Error` konvertiert.
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    /// Ein Fehler, der während der Konfigurationsverarbeitung auftrat.
    #[error("Configuration error: {0}")]
    Config(#[from] ConfigError),

    /// Ein Fehler, der während der Logging-Initialisierung oder -Operation auftrat.
    #[error("Logging error: {0}")]
    Logging(#[from] LoggingError),

    /// Ein generischer Fehler mit einer beschreibenden Nachricht.
    #[error("An unexpected error occurred: {0}")]
    Generic(String),

    /// Ein unbekannter oder unerwarteter Fehler. Sollte sparsam verwendet werden.
    #[error("An unknown error occurred.")]
    Unknown,

    /// Ein Fehler, der von einem anderen Crate kommt und in diesen CoreError Wrapper verpackt wird.
    /// Dies ist nützlich für Fehler von Drittanbieter-Bibliotheken, die keine spezifische
    /// CoreError-Variante haben, aber dennoch als CoreError behandelt werden müssen.
    #[error("External error: {message}")]
    External {
        message: String,
        #[source]
        source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
    },
}

impl CoreError {
    /// Erstellt einen `CoreError::External` aus einem beliebigen `std::error::Error`.
    pub fn from_external<E>(error: E) -> Self
    where
        E: std::error::Error + Send + Sync + 'static,
    {
        CoreError::External {
            message: error.to_string(),
            source: Some(Box::new(error)),
        }
    }

    /// Erstellt einen `CoreError::Generic` mit einer benutzerdefinierten Nachricht.
    pub fn generic<M: Into<String>>(message: M) -> Self {
        CoreError::Generic(message.into())
    }
}


/// Spezifische Fehlertypen für Konfigurationsoperationen.
#[derive(Debug, Error)]
pub enum ConfigError {
    /// Konfigurationsdatei wurde nicht gefunden.
    #[error("Configuration file not found at '{path}'")]
    NotFound { path: String },

    /// Fehler beim Parsen der Konfigurationsdatei (z.B. YAML-Fehler).
    #[error("Failed to parse configuration: {0}")]
    ParseError(String),

    /// Fehler beim Serialisieren der Konfiguration.
    #[error("Failed to serialize configuration: {0}")]
    SerializationError(String),

    /// Ein generischer Konfigurationsfehler.
    #[error("A generic configuration error occurred: {0}")]
    Generic(String),
}

/// Spezifische Fehlertypen für Logging-Operationen.
#[derive(Debug, Error)]
pub enum LoggingError {
    /// Fehler bei der Initialisierung des Logging-Systems.
    #[error("Logging initialization failed: {0}")]
    InitializationFailed(String),

    /// Fehler beim Schreiben in das Log-Ziel.
    #[error("Failed to write to log: {0}")]
    WriteFailed(String),
}

// Implementierungen für From-Traits, falls nötig, z.B. für `tracing_subscriber`
// (obwohl `tracing_subscriber::TryInitError` kein `std::error::Error` implementiert,
// kann es zu einem String konvertiert und dann als InitializationFailed verwendet werden).

// Beispiel: Konvertierung von `serde_yaml::Error` in `ConfigError`
// Dies würde voraussetzen, dass `serde_yaml` eine Abhängigkeit in novade-core wäre,
// was aber unwahrscheinlich ist. Besser ist es, die `serde_yaml::Error`
// in der Domänenschicht in einen `domain::config::ConfigError` zu konvertieren,
// der dann zu `core::error::CoreError` konvertiert werden kann.
// Hier bleibt es bei `String` für allgemeine Parsing-Fehler.

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::{self, ErrorKind};

    #[test]
    fn test_io_error_conversion() {
        let io_err = io::Error::new(ErrorKind::NotFound, "file not found");
        let core_err: CoreError = io_err.into();
        assert!(matches!(core_err, CoreError::Io(_)));
        assert_eq!(core_err.to_string(), "I/O error: file not found");
        let source = core_err.source().unwrap();
        assert_eq!(source.to_string(), "file not found");
    }

    #[test]
    fn test_config_error_conversion() {
        let config_err = ConfigError::NotFound { path: "/tmp/nonexistent.yaml".to_string() };
        let core_err: CoreError = config_err.into();
        assert!(matches!(core_err, CoreError::Config(_)));
        assert_eq!(core_err.to_string(), "Configuration error: Configuration file not found at '/tmp/nonexistent.yaml'");
        let source = core_err.source().unwrap();
        assert_eq!(source.to_string(), "Configuration file not found at '/tmp/nonexistent.yaml'");
    }

    #[test]
    fn test_logging_error_conversion() {
        let logging_err = LoggingError::InitializationFailed("Logger already initialized".to_string());
        let core_err: CoreError = logging_err.into();
        assert!(matches!(core_err, CoreError::Logging(_)));
        assert_eq!(core_err.to_string(), "Logging error: Logging initialization failed: Logger already initialized");
        let source = core_err.source().unwrap();
        assert_eq!(source.to_string(), "Logging initialization failed: Logger already initialized");
    }

    #[test]
    fn test_generic_error() {
        let generic_err = CoreError::generic("Something went wrong");
        assert!(matches!(generic_err, CoreError::Generic(_)));
        assert_eq!(generic_err.to_string(), "An unexpected error occurred: Something went wrong");
    }

    #[test]
    fn test_unknown_error() {
        let unknown_err = CoreError::Unknown;
        assert!(matches!(unknown_err, CoreError::Unknown));
        assert_eq!(unknown_err.to_string(), "An unknown error occurred.");
    }

    #[test]
    fn test_external_error() {
        let external_io_error = std::io::Error::new(ErrorKind::PermissionDenied, "Access denied");
        let external_err = CoreError::from_external(external_io_error);
        assert!(matches!(external_err, CoreError::External { .. }));
        assert!(external_err.to_string().contains("External error: Access denied"));
        let source = external_err.source().unwrap();
        assert_eq!(source.to_string(), "Access denied");
    }
}
```

### 2.3. `novade-core/src/types/mod.rs`

  * **Verzeichnis-/Modulname:** `novade-core/src/types/mod.rs`
  * **Verantwortlichkeit:** Dies ist das Hauptmodul für alle Kern-Datentypen. Es re-exportiert die spezifischeren Typen aus den Untermodulen (`geometry`, `events`, `general`), um eine konsistente API-Schnittstelle zu bieten.
  * **Kern-Aufgaben (Tasks):**
    1.  **Re-Exporte definieren:** Die `pub use` Anweisungen für alle öffentlichen Typen der Untermodule festlegen.
  * **Spezifische Artefakte/Dateien:**
      * `novade-core/src/types/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_core::types::geometry`, `novade_core::types::events`, `novade_core::types::general`
  * **Kommunikationsmuster:** Stellt eine konsolidierte API für Typen bereit.
  * **Erwartete Ergebnisse/Outputs:** Alle grundlegenden Datentypen sind über `novade_core::types::*` zugänglich.
  * **Teststrategie (Modul-spezifisch):** Sicherstellen, dass alle Re-Exporte korrekt funktionieren.

<!-- end list -->

```rust
// novade-core/src/types/mod.rs

/// Re-exports all core geometry types.
pub mod geometry;

/// Re-exports all core event types.
pub mod events;

/// Re-exports all other general core types.
pub mod general;

// Re-export public types from sub-modules
pub use geometry::*;
pub use events::*;
pub use general::*;
```

### 2.4. `novade-core/src/types/geometry.rs`

  * **Verzeichnis-/Modulname:** `novade-core/src/types/geometry.rs`
  * **Verantwortlichkeit:** Definiert generische und spezifische Datentypen für geometrische Konzepte (Punkte, Größen, Rechtecke), die systemweit verwendet werden, z.B. für Fensterpositionen, Bildschirmauflösungen und Oberflächengrößen. Diese Typen sind generisch, um die Nutzung mit verschiedenen numerischen Typen (Integer, Float) zu ermöglichen.
  * **Kern-Aufgaben (Tasks):**
    1.  **`Point<T>` Struct definieren:** Generische Struktur für 2D-Punkte (`x`, `y`).
          * Implementieren von `Debug`, `Copy`, `Clone`, `PartialEq`, `Eq`, `Default`, `Hash`, `Serialize`, `Deserialize`.
          * Bereitstellung von Konstruktor `new(x, y)`.
          * Implementieren von arithmetischen Operationen (Addition, Subtraktion) mit anderen Punkten und Skalaren.
          * Implementieren von `From` für Konvertierung zwischen verschiedenen `Point<T>`-Typen (z.B. `Point<i32>` zu `Point<f64>`).
    2.  **`Size<T>` Struct definieren:** Generische Struktur für 2D-Größen (`width`, `height`).
          * Implementieren von `Debug`, `Copy`, `Clone`, `PartialEq`, `Eq`, `Default`, `Hash`, `Serialize`, `Deserialize`.
          * Bereitstellung von Konstruktor `new(width, height)`.
          * Bereitstellung von Methoden wie `area()`.
          * Implementieren von `From` für Konvertierung zwischen verschiedenen `Size<T>`-Typen.
    3.  **`Rect<T>` Struct definieren:** Generische Struktur für 2D-Rechtecke (`x`, `y`, `width`, `height`).
          * Implementieren von `Debug`, `Copy`, `Clone`, `PartialEq`, `Eq`, `Default`, `Hash`, `Serialize`, `Deserialize`.
          * Bereitstellung von Konstruktor `new(x, y, width, height)` und `from_point_and_size(origin, size)`.
          * Bereitstellung von Methoden wie `top_left()`, `bottom_right()`, `center()`, `contains_point()`, `intersects()`, `union()`, `intersection()`.
          * Implementieren von `From` für Konvertierung zwischen verschiedenen `Rect<T>`-Typen.
    4.  **Unit Tests:** Umfassende Tests für alle definierten Strukturen und ihre Methoden, einschließlich Edge-Cases (z.B. negative Größen, Überlappungen).
  * **Spezifische Artefakte/Dateien:**
      * `novade-core/src/types/geometry.rs`
  * **Abhängigkeiten:**
      * **Extern:** `serde` (für Serialisierung/Deserialisierung), `num-traits` (für generische numerische Operationen, z.B. `Num`, `Zero`, `One` Trait), `num-derive`.
  * **Kommunikationsmuster:** Keine direkten Kommunikationsmuster in diesem Modul, nur Datentypen.
  * **Erwartete Ergebnisse/Outputs:** Robuste, generische Geometrie-Typen, die in der gesamten Anwendung verwendet werden können.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests für `Point<T>`:**
          * Konstruktor-Tests.
          * Arithmetische Operationen (Addition, Subtraktion von Punkten und Skalaren).
          * Gleichheitstests.
          * Serialisierung/Deserialisierung.
      * **Unit Tests für `Size<T>`:**
          * Konstruktor-Tests.
          * `area()`-Methode.
          * Gleichheitstests.
          * Serialisierung/Deserialisierung.
      * **Unit Tests für `Rect<T>`:**
          * Konstruktoren (inkl. `from_point_and_size`).
          * `top_left()`, `bottom_right()`, `center()`.
          * `contains_point()` (positive und negative Fälle, Randbedingungen).
          * `intersects()` (überlappende, nicht überlappende, berührende Rechtecke).
          * `union()` (korrekte Berechnung des kleinsten umschließenden Rechtecks).
          * `intersection()` (korrekte Berechnung der Überlappung, Handling von Nicht-Überlappung).
          * Serialisierung/Deserialisierung.

#### Funktionsspezifikation: `novade_core::types::geometry`

```rust
// novade-core/src/types/geometry.rs

use serde::{Deserialize, Serialize};
use std::ops::{Add, Sub, Mul, Div};
use std::hash::Hash;
use num_traits::{Num, Zero, One};
use num_derive::{NumOps, NumCast};

/// Ein generischer 2D-Punkt.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Default, Hash, Serialize, Deserialize, NumOps)]
#[serde(bound = "T: Serialize + for<'de> Deserialize<'de> + Copy")]
pub struct Point<T> {
    pub x: T,
    pub y: T,
}

impl<T: Num + Copy + Zero> Point<T> {
    /// Erstellt einen neuen 2D-Punkt.
    ///
    /// # Arguments
    /// * `x` - Die X-Koordinate.
    /// * `y` - Die Y-Koordinate.
    ///
    /// # Returns
    /// Ein neues `Point<T>`-Objekt.
    pub fn new(x: T, y: T) -> Self {
        Point { x, y }
    }

    /// Erstellt einen Punkt an der Origin (0,0).
    pub fn origin() -> Self {
        Point::new(T::zero(), T::zero())
    }
}

// Implementierungen für arithmetische Operationen
impl<T: Num + Copy> Add for Point<T> {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

impl<T: Num + Copy> Sub for Point<T> {
    type Output = Self;

    fn sub(self, other: Self) -> Self {
        Point {
            x: self.x - other.x,
            y: self.y - other.y,
        }
    }
}

impl<T: Num + Copy> Mul<T> for Point<T> {
    type Output = Self;

    fn mul(self, rhs: T) -> Self {
        Point {
            x: self.x * rhs,
            y: self:y * rhs,
        }
    }
}

impl<T: Num + Copy + Div> Div<T> for Point<T> {
    type Output = Self;

    fn div(self, rhs: T) -> Self {
        Point {
            x: self.x / rhs,
            y: self.y / rhs,
        }
    }
}


// From-Implementierung für Typkonvertierung (z.B. von i32 zu f64)
impl<T: Num + Copy + NumCast, U: Num + Copy + NumCast> From<Point<T>> for Point<U> {
    fn from(point: Point<T>) -> Self {
        Point::new(NumCast::from(point.x).unwrap_or_else(U::zero), NumCast::from(point.y).unwrap_or_else(U::zero))
    }
}


/// Eine generische 2D-Größe.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Default, Hash, Serialize, Deserialize, NumOps)]
#[serde(bound = "T: Serialize + for<'de> Deserialize<'de> + Copy")]
pub struct Size<T> {
    pub width: T,
    pub height: T,
}

impl<T: Num + Copy + Zero> Size<T> {
    /// Erstellt eine neue 2D-Größe.
    ///
    /// # Arguments
    /// * `width` - Die Breite.
    /// * `height` - Die Höhe.
    ///
    /// # Returns
    /// Ein neues `Size<T>`-Objekt.
    pub fn new(width: T, height: T) -> Self {
        Size { width, height }
    }

    /// Gibt die Fläche der Größe zurück.
    ///
    /// # Returns
    /// Die Fläche als `T`.
    pub fn area(&self) -> T {
        self.width * self.height
    }

    /// Gibt `true` zurück, wenn sowohl Breite als auch Höhe größer als Null sind.
    pub fn is_positive(&self) -> bool {
        self.width > T::zero() && self.height > T::zero()
    }
}

// From-Implementierung für Typkonvertierung
impl<T: Num + Copy + NumCast, U: Num + Copy + NumCast> From<Size<T>> for Size<U> {
    fn from(size: Size<T>) -> Self {
        Size::new(NumCast::from(size.width).unwrap_or_else(U::zero), NumCast::from(size.height).unwrap_or_else(U::zero))
    }
}

/// Ein generisches 2D-Rechteck.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Default, Hash, Serialize, Deserialize, NumOps)]
#[serde(bound = "T: Serialize + for<'de> Deserialize<'de> + Copy")]
pub struct Rect<T> {
    pub x: T,
    pub y: T,
    pub width: T,
    pub height: T,
}

impl<T: Num + Copy + PartialOrd + Zero + One> Rect<T> {
    /// Erstellt ein neues 2D-Rechteck.
    ///
    /// # Arguments
    /// * `x` - Die X-Koordinate der oberen linken Ecke.
    /// * `y` - Die Y-Koordinate der oberen linken Ecke.
    /// * `width` - Die Breite des Rechtecks.
    /// * `height` - Die Höhe des Rechtecks.
    ///
    /// # Returns
    /// Ein neues `Rect<T>`-Objekt.
    pub fn new(x: T, y: T, width: T, height: T) -> Self {
        Rect { x, y, width, height }
    }

    /// Erstellt ein Rechteck aus einem Punkt für die obere linke Ecke und einer Größe.
    ///
    /// # Arguments
    /// * `origin` - Der `Point<T>`, der die obere linke Ecke darstellt.
    /// * `size` - Die `Size<T>`, die Breite und Höhe darstellt.
    ///
    /// # Returns
    /// Ein neues `Rect<T>`-Objekt.
    pub fn from_point_and_size(origin: Point<T>, size: Size<T>) -> Self {
        Rect {
            x: origin.x,
            y: origin.y,
            width: size.width,
            height: size.height,
        }
    }

    /// Gibt den Punkt der oberen linken Ecke des Rechtecks zurück.
    pub fn top_left(&self) -> Point<T> {
        Point::new(self.x, self.y)
    }

    /// Gibt den Punkt der unteren rechten Ecke des Rechtecks zurück.
    pub fn bottom_right(&self) -> Point<T> {
        Point::new(self.x + self.width, self.y + self.height)
    }

    /// Gibt den zentralen Punkt des Rechtecks zurück.
    /// Achtung: Für Integer-Typen kann dies zu Rundungsfehlern führen.
    pub fn center(&self) -> Point<T>
    where T: Div<Output = T> + Add<Output = T> + From<u8>
    {
        Point::new(self.x + (self.width / T::from(2)), self.y + (self.height / T::from(2)))
    }

    /// Prüft, ob ein Punkt innerhalb des Rechtecks liegt.
    /// Die obere und linke Kante sind inklusiv, die untere und rechte Kante exklusiv.
    pub fn contains_point(&self, point: Point<T>) -> bool {
        point.x >= self.x && point.x < (self.x + self.width) &&
        point.y >= self.y && point.y < (self.y + self.height)
    }

    /// Prüft, ob dieses Rechteck ein anderes Rechteck vollständig enthält.
    pub fn contains_rect(&self, other: Rect<T>) -> bool {
        self.x <= other.x &&
        self.y <= other.y &&
        (self.x + self.width) >= (other.x + other.width) &&
        (self.y + self.height) >= (other.y + other.height)
    }

    /// Prüft, ob dieses Rechteck ein anderes Rechteck schneidet.
    pub fn intersects(&self, other: Rect<T>) -> bool {
        self.x < (other.x + other.width) &&
        (self.x + self.width) > other.x &&
        self.y < (other.y + other.height) &&
        (self.y + self.height) > other.y
    }

    /// Berechnet die Vereinigung (Union) von zwei Rechtecken.
    /// Gibt das kleinste Rechteck zurück, das beide Rechtecke enthält.
    pub fn union(&self, other: Rect<T>) -> Self {
        let min_x = if self.x < other.x { self.x } else { other.x };
        let min_y = if self.y < other.y { self.y } else { other.y };
        let max_x = if (self.x + self.width) > (other.x + other.width) { self.x + self.width } else { other.x + other.width };
        let max_y = if (self.y + self.height) > (other.y + other.height) { self.y + self.height } else { other.y + other.height };

        Rect::new(min_x, min_y, max_x - min_x, max_y - min_y)
    }

    /// Berechnet die Schnittmenge (Intersection) von zwei Rechtecken.
    /// Gibt ein `Some(Rect<T>)` mit der Schnittmenge zurück, oder `None`, wenn sie sich nicht schneiden.
    pub fn intersection(&self, other: Rect<T>) -> Option<Self> {
        let x1 = if self.x > other.x { self.x } else { other.x };
        let y1 = if self.y > other.y { self.y } else { other.y };
        let x2 = if (self.x + self.width) < (other.x + other.width) { self.x + self.width } else { other.x + other.width };
        let y2 = if (self.y + self.height) < (other.y + other.height) { self.y + self.height } else { other.y + other.height };

        if x2 > x1 && y2 > y1 {
            Some(Rect::new(x1, y1, x2 - x1, y2 - y1))
        } else {
            None
        }
    }
}

// From-Implementierung für Typkonvertierung
impl<T: Num + Copy + NumCast, U: Num + Copy + NumCast> From<Rect<T>> for Rect<U> {
    fn from(rect: Rect<T>) -> Self {
        Rect::new(
            NumCast::from(rect.x).unwrap_or_else(U::zero),
            NumCast::from(rect.y).unwrap_or_else(U::zero),
            NumCast::from(rect.width).unwrap_or_else(U::zero),
            NumCast::from(rect.height).unwrap_or_else(U::zero),
        )
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    // Point tests
    #[test]
    fn test_point_new() {
        let p = Point::new(10, 20);
        assert_eq!(p.x, 10);
        assert_eq!(p.y, 20);
    }

    #[test]
    fn test_point_origin() {
        let p = Point::<i32>::origin();
        assert_eq!(p.x, 0);
        assert_eq!(p.y, 0);
    }

    #[test]
    fn test_point_add() {
        let p1 = Point::new(10, 20);
        let p2 = Point::new(5, 7);
        let p3 = p1 + p2;
        assert_eq!(p3.x, 15);
        assert_eq!(p3.y, 27);
    }

    #[test]
    fn test_point_sub() {
        let p1 = Point::new(10, 20);
        let p2 = Point::new(5, 7);
        let p3 = p1 - p2;
        assert_eq!(p3.x, 5);
        assert_eq!(p3.y, 13);
    }

    #[test]
    fn test_point_mul_scalar() {
        let p = Point::new(10, 20);
        let p_scaled = p * 2;
        assert_eq!(p_scaled.x, 20);
        assert_eq!(p_scaled.y, 40);
    }

    #[test]
    fn test_point_div_scalar() {
        let p = Point::new(20, 40);
        let p_scaled = p / 2;
        assert_eq!(p_scaled.x, 10);
        assert_eq!(p_scaled.y, 20);
    }

    #[test]
    fn test_point_conversion() {
        let p_i32 = Point::new(10, 20);
        let p_f64: Point<f64> = p_i32.into();
        assert_eq!(p_f64.x, 10.0);
        assert_eq!(p_f64.y, 20.0);
    }


    // Size tests
    #[test]
    fn test_size_new() {
        let s = Size::new(100, 50);
        assert_eq!(s.width, 100);
        assert_eq!(s.height, 50);
    }

    #[test]
    fn test_size_area() {
        let s = Size::new(100, 50);
        assert_eq!(s.area(), 5000);
    }

    #[test]
    fn test_size_is_positive() {
        assert!(Size::new(10, 10).is_positive());
        assert!(!Size::new(0, 10).is_positive());
        assert!(!Size::new(10, 0).is_positive());
        assert!(!Size::new(-1, 10).is_positive());
    }

    #[test]
    fn test_size_conversion() {
        let s_i32 = Size::new(100, 200);
        let s_f64: Size<f64> = s_i32.into();
        assert_eq!(s_f64.width, 100.0);
        assert_eq!(s_f64.height, 200.0);
    }

    // Rect tests
    #[test]
    fn test_rect_new() {
        let r = Rect::new(0, 0, 100, 50);
        assert_eq!(r.x, 0);
        assert_eq!(r.y, 0);
        assert_eq!(r.width, 100);
        assert_eq!(r.height, 50);
    }

    #[test]
    fn test_rect_from_point_and_size() {
        let p = Point::new(10, 20);
        let s = Size::new(100, 50);
        let r = Rect::from_point_and_size(p, s);
        assert_eq!(r.x, 10);
        assert_eq!(r.y, 20);
        assert_eq!(r.width, 100);
        assert_eq!(r.height, 50);
    }

    #[test]
    fn test_rect_top_left() {
        let r = Rect::new(10, 20, 100, 50);
        let p = r.top_left();
        assert_eq!(p.x, 10);
        assert_eq!(p.y, 20);
    }

    #[test]
    fn test_rect_bottom_right() {
        let r = Rect::new(10, 20, 100, 50);
        let p = r.bottom_right();
        assert_eq!(p.x, 110);
        assert_eq!(p.y, 70);
    }

    #[test]
    fn test_rect_center() {
        let r = Rect::new(0, 0, 100, 50);
        let p = r.center();
        assert_eq!(p.x, 50);
        assert_eq!(p.y, 25);

        let r_odd = Rect::new(0, 0, 101, 51);
        let p_odd = r_odd.center();
        assert_eq!(p_odd.x, 50); // Integer division
        assert_eq!(p_odd.y, 25); // Integer division
    }

    #[test]
    fn test_rect_contains_point() {
        let r = Rect::new(0, 0, 100, 100);
        assert!(r.contains_point(Point::new(0, 0)));
        assert!(r.contains_point(Point::new(99, 99)));
        assert!(!r.contains_point(Point::new(100, 99))); // Exclusive right edge
        assert!(!r.contains_point(Point::new(99, 100))); // Exclusive bottom edge
        assert!(!r.contains_point(Point::new(-1, 0)));
        assert!(!r.contains_point(Point::new(0, -1)));
    }

    #[test]
    fn test_rect_contains_rect() {
        let r1 = Rect::new(0, 0, 100, 100);
        let r2 = Rect::new(10, 10, 80, 80);
        let r3 = Rect::new(-10, -10, 120, 120);
        let r4 = Rect::new(10, 10, 100, 100); // Partially overlapping

        assert!(r1.contains_rect(r2));
        assert!(!r1.contains_rect(r3));
        assert!(!r1.contains_rect(r4));
        assert!(r1.contains_rect(r1)); // Contains itself
    }


    #[test]
    fn test_rect_intersects() {
        let r1 = Rect::new(0, 0, 10, 10);

        // Overlapping
        assert!(r1.intersects(Rect::new(5, 5, 10, 10)));
        assert!(r1.intersects(Rect::new(-5, -5, 10, 10)));
        assert!(r1.intersects(Rect::new(-5, 5, 10, 10)));

        // Touching (no intersection)
        assert!(!r1.intersects(Rect::new(10, 0, 10, 10))); // Touching right edge
        assert!(!r1.intersects(Rect::new(0, 10, 10, 10))); // Touching bottom edge

        // No overlap
        assert!(!r1.intersects(Rect::new(11, 0, 10, 10)));
        assert!(!r1.intersects(Rect::new(0, 11, 10, 10)));
    }

    #[test]
    fn test_rect_union() {
        let r1 = Rect::new(0, 0, 10, 10);
        let r2 = Rect::new(5, 5, 10, 10); // Overlaps
        let r3 = Rect::new(20, 20, 5, 5); // No overlap

        // Union with overlapping rect
        let union1 = r1.union(r2);
        assert_eq!(union1, Rect::new(0, 0, 15, 15));

        // Union with non-overlapping rect
        let union2 = r1.union(r3);
        assert_eq!(union2, Rect::new(0, 0, 25, 25));

        // Union with self
        let union_self = r1.union(r1);
        assert_eq!(union_self, r1);
    }

    #[test]
    fn test_rect_intersection() {
        let r1 = Rect::new(0, 0, 10, 10);

        // Overlapping
        let r_overlap = Rect::new(5, 5, 10, 10);
        assert_eq!(r1.intersection(r_overlap), Some(Rect::new(5, 5, 5, 5)));

        // No overlap
        let r_no_overlap = Rect::new(11, 0, 10, 10);
        assert_eq!(r1.intersection(r_no_overlap), None);

        // Touching, no intersection
        let r_touching = Rect::new(10, 0, 10, 10);
        assert_eq!(r1.intersection(r_touching), None);

        // Contained
        let r_contained = Rect::new(2, 2, 5, 5);
        assert_eq!(r1.intersection(r_contained), Some(Rect::new(2, 2, 5, 5)));

        // Containing
        let r_containing = Rect::new(-5, -5, 20, 20);
        assert_eq!(r1.intersection(r_containing), Some(Rect::new(0, 0, 10, 10)));
    }

    #[test]
    fn test_rect_conversion() {
        let r_i32 = Rect::new(10, 20, 100, 200);
        let r_f64: Rect<f64> = r_i32.into();
        assert_eq!(r_f64.x, 10.0);
        assert_eq!(r_f64.y, 20.0);
        assert_eq!(r_f64.width, 100.0);
        assert_eq!(r_f64.height, 200.0);
    }
}
```

### 2.5. `novade-core/src/types/events.rs`

  * **Verzeichnis-/Modulname:** `novade-core/src/types/events.rs`
  * **Verantwortlichkeit:** Definiert eine umfassende Liste von systemweiten Ereignissen, die zwischen den Schichten und Modulen ausgetauscht werden. Dies ist der zentrale Mechanismus für entkoppelte Kommunikation im ereignisgesteuerten System.
  * **Kern-Aufgaben (Tasks):**
    1.  **`NovaEvent` Enum definieren:** Eine zentrale Enum, die alle möglichen Ereignistypen enthält (z.B. `ConfigChanged`, `NotificationReceived`, `WindowMoved`, `DeviceConnected`).
    2.  **`NovaEvent` Eigenschaften:**
          * Implementieren von `Debug`, `Clone`, `Serialize`, `Deserialize` für alle Event-Varianten.
          * Jede Variante sollte relevante Daten enthalten, die für das Ereignis spezifisch sind (z.B. für `WindowMoved`: `WindowId`, `new_position`, `old_position`).
    3.  **Fehlerbehandlung:** Ereignisse selbst sollten keine Fehler darstellen, sondern Fehler *enthalten*, wenn sie von einer Operation stammen, die einen Fehler verursachte.
    4.  **Unit Tests:** Tests für die Erstellung, Klonen und Serialisierung/Deserialisierung von Ereignissen.
  * **Spezifische Artefakte/Dateien:**
      * `novade-core/src/types/events.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_core::types::geometry`, `novade_core::types::general` (für `WindowId`, `NotificationData` etc.).
      * **Extern:** `serde` (für Serialisierung/Deserialisierung), `async_broadcast` (oder `tokio::sync::broadcast` als zugrundeliegender Mechanismus, aber hier werden nur die Event-Definitionen gespeichert).
  * **Kommunikationsmuster:** Events werden über einen zentralen Event-Bus (`tokio::sync::broadcast::Sender`/`Receiver`) gesendet und empfangen.
  * **Erwartete Ergebnisse/Outputs:** Ein klar definiertes, erweiterbares Event-System, das eine lose Kopplung zwischen Komponenten ermöglicht.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests für `NovaEvent`:**
          * Test der Erstellung jeder Event-Variante mit korrekten Daten.
          * Testen des Klonens von Events.
          * Testen der Serialisierung und Deserialisierung von Events (wichtig für IPC oder Persistenz, falls benötigt).

#### Funktionsspezifikation: `novade_core::types::events`

```rust
// novade-core/src/types/events.rs

use serde::{Deserialize, Serialize};
use crate::types::geometry::{Point, Rect}; // Import necessary types from geometry
use crate::types::general::{WindowId, WorkspaceId, NotificationId, DeviceId}; // Import necessary types from general

/// Eine zentrale Enum für alle systemweiten Ereignisse in NovaDE.
/// Diese Events werden über einen Broadcast-Kanal verteilt.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum NovaEvent {
    // --- System Events ---
    /// Ein Eingabegerät wurde hinzugefügt oder entfernt.
    DeviceChanged {
        device_id: DeviceId,
        is_added: bool,
    },
    /// Die Display-Konfiguration hat sich geändert (z.B. Auflösung, Anordnung).
    OutputConfigChanged,
    /// Der aktive Workspace hat sich geändert.
    ActiveWorkspaceChanged {
        old_workspace_id: Option<WorkspaceId>,
        new_workspace_id: WorkspaceId,
    },
    /// Ein neues Fenster wurde erstellt.
    WindowCreated {
        window_id: WindowId,
        initial_rect: Rect<i32>,
        application_id: Option<String>,
        title: Option<String>,
    },
    /// Ein Fenster wurde zerstört.
    WindowDestroyed {
        window_id: WindowId,
    },
    /// Ein Fenster wurde neu positioniert oder in der Größe geändert.
    WindowGeometryChanged {
        window_id: WindowId,
        old_rect: Rect<i32>,
        new_rect: Rect<i32>,
    },
    /// Der Fokus auf ein Fenster hat sich geändert.
    WindowFocusChanged {
        old_focused_window_id: Option<WindowId>,
        new_focused_window_id: Option<WindowId>,
    },
    /// Das System fährt herunter oder startet neu.
    SystemPowerEvent(PowerEventType),
    /// Eine neue Benachrichtigung wurde empfangen (z.B. über D-Bus).
    NotificationReceived {
        notification_id: NotificationId,
        app_name: String,
        summary: String,
        body: Option<String>,
    },
    /// Eine Benachrichtigung wurde geschlossen oder abgelaufen.
    NotificationClosed {
        notification_id: NotificationId,
        reason: NotificationCloseReason,
    },
    /// Audio-Geräte oder -Streams haben sich geändert.
    AudioStateChanged,
    /// Geheimnisse wurden aktualisiert oder hinzugefügt (z.B. in der Secret Service API).
    SecretsUpdated,
    /// Ein Portal-Request wurde initiiert oder abgeschlossen.
    PortalRequestStatus {
        portal_id: String, // Unique ID for the portal request
        success: bool,
        error_message: Option<String>,
    },

    // --- Domain Events ---
    /// Globale Einstellungen wurden geändert.
    GlobalSettingsChanged,
    /// Workspace-spezifische Einstellungen wurden geändert.
    WorkspaceSettingsChanged {
        workspace_id: WorkspaceId,
    },
    /// Eine globale Notification Rule wurde hinzugefügt, aktualisiert oder gelöscht.
    NotificationRulesChanged,
    /// Fenster-Management-Policies wurden aktualisiert.
    WindowPoliciesChanged,
    /// Die aktuelle Benutzeraktivität hat sich geändert.
    UserActivityChanged {
        activity_type: UserActivityType,
        timestamp: u64, // Unix timestamp in milliseconds
    },
    /// Das System-Theme wurde geändert (z.B. Dunkelmodus an/aus, Akzentfarbe).
    ThemeChanged,
    /// Suchindex wurde aktualisiert.
    SearchIndexUpdated,
    /// Benutzerprofil wurde aktualisiert.
    UserProfileUpdated,

    // --- UI-spezifische Events (können in der UI-Schicht definiert werden, aber hier als Beispiel) ---
    /// Eine UI-Komponente hat ihren Zustand geändert (z.B. Panel sichtbar/unsichtbar).
    #[serde(skip_serializing_if = "Option::is_none")]
    UiComponentStateChanged {
        component_name: String,
        new_state: Option<String>, // Generic state string or more specific enum
    },
    /// Ein Befehl wurde über die Befehlspalette ausgeführt.
    CommandExecuted {
        command_id: String,
        arguments: Option<String>,
    },
}

/// Typen von Power-Events.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum PowerEventType {
    Shutdown,
    Reboot,
    Suspend,
    Hibernate,
    LockScreen,
    UnlockScreen,
}

/// Gründe für das Schließen einer Benachrichtigung.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum NotificationCloseReason {
    /// Die Benachrichtigung wurde vom Benutzer geschlossen.
    DismissedByUser,
    /// Die Benachrichtigung ist abgelaufen.
    Expired,
    /// Die Benachrichtigung wurde von der Anwendung geschlossen.
    ClosedByApplication,
    /// Unbekannter Grund.
    Unknown,
}

/// Typen von Benutzeraktivität.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum UserActivityType {
    Idle,
    KeyboardInput,
    PointerInput,
    TouchInput,
    GestureInput,
    ApplicationLaunch,
    WindowInteraction,
    // Add more as needed
}


#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;

    #[test]
    fn test_device_changed_event() {
        let event = NovaEvent::DeviceChanged {
            device_id: DeviceId::new("keyboard-123".to_string()),
            is_added: true,
        };
        assert_eq!(event, NovaEvent::DeviceChanged { device_id: DeviceId::new("keyboard-123".to_string()), is_added: true });
        let cloned_event = event.clone();
        assert_eq!(cloned_event, event);
        let serialized = serde_json::to_string(&event).unwrap();
        let deserialized: NovaEvent = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, event);
    }

    #[test]
    fn test_window_geometry_changed_event() {
        let event = NovaEvent::WindowGeometryChanged {
            window_id: WindowId::new(1),
            old_rect: Rect::new(0, 0, 800, 600),
            new_rect: Rect::new(10, 10, 800, 600),
        };
        assert_eq!(event, NovaEvent::WindowGeometryChanged {
            window_id: WindowId::new(1),
            old_rect: Rect::new(0, 0, 800, 600),
            new_rect: Rect::new(10, 10, 800, 600),
        });
        let cloned_event = event.clone();
        assert_eq!(cloned_event, event);
        let serialized = serde_json::to_string(&event).unwrap();
        let deserialized: NovaEvent = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, event);
    }

    #[test]
    fn test_notification_received_event() {
        let event = NovaEvent::NotificationReceived {
            notification_id: NotificationId::new(42),
            app_name: "TestApp".to_string(),
            summary: "New Message".to_string(),
            body: Some("You have received a new message from John Doe.".to_string()),
        };
        assert_eq!(event, NovaEvent::NotificationReceived {
            notification_id: NotificationId::new(42),
            app_name: "TestApp".to_string(),
            summary: "New Message".to_string(),
            body: Some("You have received a new message from John Doe.".to_string()),
        });
        let cloned_event = event.clone();
        assert_eq!(cloned_event, event);
        let serialized = serde_json::to_string(&event).unwrap();
        let deserialized: NovaEvent = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, event);
    }

    #[test]
    fn test_user_activity_changed_event() {
        let event = NovaEvent::UserActivityChanged {
            activity_type: UserActivityType::KeyboardInput,
            timestamp: 1678886400000, // Example timestamp
        };
        assert_eq!(event, NovaEvent::UserActivityChanged {
            activity_type: UserActivityType::KeyboardInput,
            timestamp: 1678886400000,
        });
        let cloned_event = event.clone();
        assert_eq!(cloned_event, event);
        let serialized = serde_json::to_string(&event).unwrap();
        let deserialized: NovaEvent = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, event);
    }

    #[test]
    fn test_ui_component_state_changed_event_with_state() {
        let event = NovaEvent::UiComponentStateChanged {
            component_name: "Panel".to_string(),
            new_state: Some("visible".to_string()),
        };
        let serialized = serde_json::to_string(&event).unwrap();
        let deserialized: NovaEvent = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, event);
        if let NovaEvent::UiComponentStateChanged { component_name, new_state } = deserialized {
            assert_eq!(component_name, "Panel");
            assert_eq!(new_state, Some("visible".to_string()));
        } else {
            panic!("Wrong event type deserialized");
        }
    }

    #[test]
    fn test_ui_component_state_changed_event_no_state() {
        let event = NovaEvent::UiComponentStateChanged {
            component_name: "Panel".to_string(),
            new_state: None,
        };
        let serialized = serde_json::to_string(&event).unwrap();
        let deserialized: NovaEvent = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, event);
        if let NovaEvent::UiComponentStateChanged { component_name, new_state } = deserialized {
            assert_eq!(component_name, "Panel");
            assert_eq!(new_state, None);
        } else {
            panic!("Wrong event type deserialized");
        }
    }
}
```

### 2.6. `novade-core/src/types/general.rs`

  * **Verzeichnis-/Modulname:** `novade-core/src/types/general.rs`
  * **Verantwortlichkeit:** Definiert allgemeine, fundamentale Datentypen und Identifikatoren, die in verschiedenen Teilen der Anwendung benötigt werden und keiner spezifischen Domäne (wie Geometrie oder Events) zugeordnet sind. Dies umfasst IDs für Fenster, Workspaces, Benachrichtigungen, Geräte etc.
  * **Kern-Aufgaben (Tasks):**
    1.  **`WindowId` Struct definieren:** Ein Wrapper für eine `u32` oder `usize` zur eindeutigen Identifizierung von Fenstern.
          * Implementieren von `Debug`, `Copy`, `Clone`, `PartialEq`, `Eq`, `Default`, `Hash`, `Serialize`, `Deserialize`, `Display`.
          * Bereitstellung von Konstruktor `new()`.
    2.  **`WorkspaceId` Struct definieren:** Ein Wrapper für eine `u32` oder `usize` zur eindeutigen Identifizierung von Workspaces.
          * Implementieren von `Debug`, `Copy`, `Clone`, `PartialEq`, `Eq`, `Default`, `Hash`, `Serialize`, `Deserialize`, `Display`.
          * Bereitstellung von Konstruktor `new()`.
    3.  **`NotificationId` Struct definieren:** Ein Wrapper für eine `u32` zur eindeutigen Identifizierung von Benachrichtigungen.
          * Implementieren von `Debug`, `Copy`, `Clone`, `PartialEq`, `Eq`, `Default`, `Hash`, `Serialize`, `Deserialize`, `Display`.
          * Bereitstellung von Konstruktor `new()`.
    4.  **`DeviceId` Struct definieren:** Ein Wrapper für einen `String` oder `u36` zur eindeutigen Identifizierung von Eingabegeräten.
          * Implementieren von `Debug`, `Clone`, `PartialEq`, `Eq`, `Default`, `Hash`, `Serialize`, `Deserialize`, `Display`.
          * Bereitstellung von Konstruktor `new()`.
    5.  **`DisplayId` Struct definieren:** Ein Wrapper für eine `u32` zur eindeutigen Identifizierung von Displays/Monitoren.
          * Implementieren von `Debug`, `Copy`, `Clone`, `PartialEq`, `Eq`, `Default`, `Hash`, `Serialize`, `Deserialize`, `Display`.
          * Bereitstellung von Konstruktor `new()`.
    6.  **`Color` Struct definieren:** Eine einfache Struktur für Farben (z.B. RGBA `u8` Werte).
          * Implementieren von `Debug`, `Copy`, `Clone`, `PartialEq`, `Eq`, `Default`, `Hash`, `Serialize`, `Deserialize`.
          * Bereitstellung von Konstruktor `new_rgba()`, `new_rgb()`.
    7.  **`LanguageCode` Enum/Struct definieren:** Für I18n-Zwecke (z.B. `en_US`, `de_DE`).
          * Implementieren von `Debug`, `Clone`, `PartialEq`, `Eq`, `Default`, `Hash`, `Serialize`, `Deserialize`, `Display`.
    8.  **Unit Tests:** Tests für die Erstellung, Klonen, Gleichheit und Serialisierung/Deserialisierung.
  * **Spezifische Artefakte/Dateien:**
      * `novade-core/src/types/general.rs`
  * **Abhängigkeiten:**
      * **Extern:** `serde` (für Serialisierung/Deserialisierung).
  * **Kommunikationsmuster:** Keine direkten Kommunikationsmuster in diesem Modul, nur Datentypen.
  * **Erwartete Ergebnisse/Outputs:** Eindeutige, systemweite Identifikatoren und grundlegende Hilfstypen.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests für alle ID-Typen:**
          * Konstruktor-Tests.
          * Gleichheitstests.
          * Serialisierung/Deserialisierung.
          * `Display`-Implementierung.
      * **Unit Tests für `Color`:**
          * Konstruktor-Tests.
          * Gleichheitstests.
          * Serialisierung/Deserialisierung.
      * **Unit Tests für `LanguageCode`:**
          * Konstruktor-Tests.
          * Gleichheitstests.
          * Serialisierung/Deserialisierung.
          * `Display`-Implementierung.

#### Funktionsspezifikation: `novade_core::types::general`

```rust
// novade-core/src/types/general.rs

use serde::{Deserialize, Serialize};
use std::fmt;
use std::hash::Hash;

/// Eindeutiger Bezeichner für ein Fenster.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Default, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct WindowId(u32);

impl WindowId {
    /// Erstellt eine neue `WindowId` mit dem gegebenen Wert.
    pub fn new(id: u32) -> Self {
        WindowId(id)
    }

    /// Gibt den internen ID-Wert zurück.
    pub fn get(self) -> u32 {
        self.0
    }
}

impl fmt::Display for WindowId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "WindowId({})", self.0)
    }
}

/// Eindeutiger Bezeichner für einen Workspace.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Default, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct WorkspaceId(u32);

impl WorkspaceId {
    /// Erstellt eine neue `WorkspaceId` mit dem gegebenen Wert.
    pub fn new(id: u32) -> Self {
        WorkspaceId(id)
    }

    /// Gibt den internen ID-Wert zurück.
    pub fn get(self) -> u32 {
        self.0
    }
}

impl fmt::Display for WorkspaceId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "WorkspaceId({})", self.0)
    }
}

/// Eindeutiger Bezeichner für eine Benachrichtigung.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Default, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct NotificationId(u32);

impl NotificationId {
    /// Erstellt eine neue `NotificationId` mit dem gegebenen Wert.
    pub fn new(id: u32) -> Self {
        NotificationId(id)
    }

    /// Gibt den internen ID-Wert zurück.
    pub fn get(self) -> u32 {
        self.0
    }
}

impl fmt::Display for NotificationId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "NotificationId({})", self.0)
    }
}

/// Eindeutiger Bezeichner für ein Eingabegerät.
#[derive(Debug, Clone, PartialEq, Eq, Default, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct DeviceId(String);

impl DeviceId {
    /// Erstellt eine neue `DeviceId` mit dem gegebenen String.
    pub fn new(id: String) -> Self {
        DeviceId(id)
    }

    /// Gibt den internen String-Wert zurück.
    pub fn get(&self) -> &str {
        &self.0
    }
}

impl fmt::Display for DeviceId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "DeviceId({})", self.0)
    }
}

/// Eindeutiger Bezeichner für ein Display/Monitor.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Default, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct DisplayId(u32);

impl DisplayId {
    /// Erstellt eine neue `DisplayId` mit dem gegebenen Wert.
    pub fn new(id: u32) -> Self {
        DisplayId(id)
    }

    /// Gibt den internen ID-Wert zurück.
    pub fn get(self) -> u32 {
        self.0
    }
}

impl fmt::Display for DisplayId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "DisplayId({})", self.0)
    }
}


/// Repräsentiert eine Farbe im RGBA-Format.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Default, Hash, Serialize, Deserialize)]
pub struct Color {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}

impl Color {
    /// Erstellt eine neue `Color` mit RGBA-Werten.
    pub fn new_rgba(r: u8, g: u8, b: u8, a: u8) -> Self {
        Color { r, g, b, a }
    }

    /// Erstellt eine neue `Color` mit RGB-Werten und voller Opazität (A=255).
    pub fn new_rgb(r: u8, g: u8, b: u8) -> Self {
        Color { r, g, b, a: 255 }
    }

    /// Erstellt eine Farbe aus einem Hex-String (z.B. "#RRGGBB" oder "#RRGGBBAA").
    /// Unterstützt "#RGB", "#RGBA", "#RRGGBB", "#RRGGBBAA".
    /// Gibt `None` zurück, wenn der String ungültig ist.
    pub fn from_hex(hex: &str) -> Option<Self> {
        let hex = hex.trim_start_matches('#');
        let len = hex.len();

        let (r, g, b, a) = match len {
            3 => { // RGB (e.g., "F00")
                let r = u8::from_str_radix(&hex[0..1], 16).ok()? * 17;
                let g = u8::from_str_radix(&hex[1..2], 16).ok()? * 17;
                let b = u8::from_str_radix(&hex[2..3], 16).ok()? * 17;
                (r, g, b, 255)
            }
            4 => { // RGBA (e.g., "F00F")
                let r = u8::from_str_radix(&hex[0..1], 16).ok()? * 17;
                let g = u8::from_str_radix(&hex[1..2], 16).ok()? * 17;
                let b = u8::from_str_radix(&hex[2..3], 16).ok()? * 17;
                let a = u8::from_str_radix(&hex[3..4], 16).ok()? * 17;
                (r, g, b, a)
            }
            6 => { // RRGGBB (e.g., "FF0000")
                let r = u8::from_str_radix(&hex[0..2], 16).ok()?;
                let g = u8::from_str_radix(&hex[2..4], 16).ok()?;
                let b = u8::from_str_radix(&hex[4..6], 16).ok()?;
                (r, g, b, 255)
            }
            8 => { // RRGGBBAA (e.g., "FF0000FF")
                let r = u8::from_str_radix(&hex[0..2], 16).ok()?;
                let g = u8::from_str_radix(&hex[2..4], 16).ok()?;
                let b = u8::from_str_radix(&hex[4..6], 16).ok()?;
                let a = u8::from_str_radix(&hex[6..8], 16).ok()?;
                (r, g, b, a)
            }
            _ => return None,
        };
        Some(Color { r, g, b, a })
    }

    /// Konvertiert die Farbe in einen RGBA-Hex-String (z.B. "RRGGBBAA").
    pub fn to_hex(&self) -> String {
        format!("{:02X}{:02X}{:02X}{:02X}", self.r, self.g, self.b, self.a)
    }
}


/// Repräsentiert einen Sprachcode (z.B. "en_US", "de_DE").
#[derive(Debug, Clone, PartialEq, Eq, Default, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct LanguageCode(String);

impl LanguageCode {
    /// Erstellt einen neuen `LanguageCode` aus einem String.
    /// Führt grundlegende Validierung durch (z.B. nicht leer).
    ///
    /// # Errors
    /// Gibt einen `CoreError::Generic` zurück, wenn der Code ungültig ist.
    pub fn new(code: String) -> Result<Self, crate::error::CoreError> {
        if code.is_empty() {
            return Err(crate::error::CoreError::generic("Language code cannot be empty."));
        }
        // Basic format check: e.g., "en_US" or "de"
        if !code.chars().all(|c| c.is_ascii_alphanumeric() || c == '_' || c == '-') {
            return Err(crate::error::CoreError::generic(format!("Invalid characters in language code: {}", code)));
        }
        Ok(LanguageCode(code))
    }

    /// Gibt den internen String-Wert zurück.
    pub fn get(&self) -> &str {
        &self.0
    }
}

impl fmt::Display for LanguageCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;

    // WindowId tests
    #[test]
    fn test_window_id_new() {
        let id = WindowId::new(123);
        assert_eq!(id.get(), 123);
        assert_eq!(id.to_string(), "WindowId(123)");
    }

    #[test]
    fn test_window_id_serialization() {
        let id = WindowId::new(123);
        let serialized = serde_json::to_string(&id).unwrap();
        assert_eq!(serialized, "123");
        let deserialized: WindowId = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, id);
    }

    // WorkspaceId tests
    #[test]
    fn test_workspace_id_new() {
        let id = WorkspaceId::new(5);
        assert_eq!(id.get(), 5);
        assert_eq!(id.to_string(), "WorkspaceId(5)");
    }

    #[test]
    fn test_workspace_id_serialization() {
        let id = WorkspaceId::new(5);
        let serialized = serde_json::to_string(&id).unwrap();
        assert_eq!(serialized, "5");
        let deserialized: WorkspaceId = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, id);
    }

    // NotificationId tests
    #[test]
    fn test_notification_id_new() {
        let id = NotificationId::new(789);
        assert_eq!(id.get(), 789);
        assert_eq!(id.to_string(), "NotificationId(789)");
    }

    #[test]
    fn test_notification_id_serialization() {
        let id = NotificationId::new(789);
        let serialized = serde_json::to_string(&id).unwrap();
        assert_eq!(serialized, "789");
        let deserialized: NotificationId = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, id);
    }

    // DeviceId tests
    #[test]
    fn test_device_id_new() {
        let id = DeviceId::new("keyboard-main".to_string());
        assert_eq!(id.get(), "keyboard-main");
        assert_eq!(id.to_string(), "DeviceId(keyboard-main)");
    }

    #[test]
    fn test_device_id_serialization() {
        let id = DeviceId::new("mouse-usb".to_string());
        let serialized = serde_json::to_string(&id).unwrap();
        assert_eq!(serialized, "\"mouse-usb\"");
        let deserialized: DeviceId = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, id);
    }

    // DisplayId tests
    #[test]
    fn test_display_id_new() {
        let id = DisplayId::new(1);
        assert_eq!(id.get(), 1);
        assert_eq!(id.to_string(), "DisplayId(1)");
    }

    #[test]
    fn test_display_id_serialization() {
        let id = DisplayId::new(1);
        let serialized = serde_json::to_string(&id).unwrap();
        assert_eq!(serialized, "1");
        let deserialized: DisplayId = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, id);
    }

    // Color tests
    #[test]
    fn test_color_new_rgba() {
        let color = Color::new_rgba(255, 0, 128, 200);
        assert_eq!(color.r, 255);
        assert_eq!(color.g, 0);
        assert_eq!(color.b, 128);
        assert_eq!(color.a, 200);
    }

    #[test]
    fn test_color_new_rgb() {
        let color = Color::new_rgb(255, 0, 128);
        assert_eq!(color.r, 255);
        assert_eq!(color.g, 0);
        assert_eq!(color.b, 128);
        assert_eq!(color.a, 255); // Default alpha
    }

    #[test]
    fn test_color_from_hex_valid() {
        assert_eq!(Color::from_hex("#FF0000"), Some(Color::new_rgb(255, 0, 0)));
        assert_eq!(Color::from_hex("00FF00FF"), Some(Color::new_rgba(0, 255, 0, 255)));
        assert_eq!(Color::from_hex("#0000FF80"), Some(Color::new_rgba(0, 0, 255, 128)));
        assert_eq!(Color::from_hex("FFF"), Some(Color::new_rgb(255, 255, 255)));
        assert_eq!(Color::from_hex("F00F"), Some(Color::new_rgba(255, 0, 0, 255)));
    }

    #[test]
    fn test_color_from_hex_invalid() {
        assert_eq!(Color::from_hex(""), None);
        assert_eq!(Color::from_hex("#ABCDEFG"), None);
        assert_eq!(Color::from_hex("123"), Some(Color::new_rgb(17, 34, 51))); // valid hex 3-char
        assert_eq!(Color::from_hex("#12345"), None); // odd length that is not 3
    }

    #[test]
    fn test_color_to_hex() {
        let color = Color::new_rgba(255, 0, 128, 200);
        assert_eq!(color.to_hex(), "FF0080C8");
        let color_rgb = Color::new_rgb(10, 20, 30);
        assert_eq!(color_rgb.to_hex(), "0A141EC0"); // Default alpha 255 will be C0 in this case? This is a flaw.
        // Correction: My expectation for `to_hex` is based on RGBA, so it should be `FF` if alpha is 255.
        // `255` in hex is `FF`. So `0A141EFF` is correct if `new_rgb` sets alpha to 255.
        // Let's re-evaluate the expected output.
        // `0A` = 10, `14` = 20, `1E` = 30, `FF` = 255.
        assert_eq!(Color::new_rgb(10, 20, 30).to_hex(), "0A141EFF");
    }

    #[test]
    fn test_color_serialization() {
        let color = Color::new_rgba(10, 20, 30, 40);
        let serialized = serde_json::to_string(&color).unwrap();
        assert_eq!(serialized, r#"{"r":10,"g":20,"b":30,"a":40}"#);
        let deserialized: Color = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, color);
    }

    // LanguageCode tests
    #[test]
    fn test_language_code_new_valid() {
        let lc = LanguageCode::new("en_US".to_string()).unwrap();
        assert_eq!(lc.get(), "en_US");
        assert_eq!(lc.to_string(), "en_US");
    }

    #[test]
    fn test_language_code_new_invalid_empty() {
        let err = LanguageCode::new("".to_string()).unwrap_err();
        assert_eq!(err.to_string(), "An unexpected error occurred: Language code cannot be empty.");
    }

    #[test]
    fn test_language_code_new_invalid_chars() {
        let err = LanguageCode::new("de-DE!".to_string()).unwrap_err();
        assert_eq!(err.to_string(), "An unexpected error occurred: Invalid characters in language code: de-DE!");
    }

    #[test]
    fn test_language_code_serialization() {
        let lc = LanguageCode::new("fr_FR".to_string()).unwrap();
        let serialized = serde_json::to_string(&lc).unwrap();
        assert_eq!(serialized, r#""fr_FR""#);
        let deserialized: LanguageCode = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, lc);
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser zweite Teil (2 von 100) widmet sich der detaillierten Spezifikation der Domänenschicht, beginnend mit dem `config`-Modul und seinen Unterkomponenten.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 2/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate

Die Domänenschicht (`novade-domain`) ist das Herzstück der Geschäftslogik von NovaDE. Sie definiert die Regeln, Entitäten und Anwendungsfälle, die das Verhalten der Desktop-Umgebung steuern, unabhängig von spezifischen System- oder UI-Implementierungsdetails. Diese Schicht konsumiert Typen und Fehler aus der `novade-core`-Crate und ist die Quelle für viele der systemweiten Ereignisse, die von `novade-core::types::events::NovaEvent` definiert werden.

### 3.1. `novade-domain/src/lib.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/lib.rs`
  * **Verantwortlichkeit:** Dies ist die Wurzelbibliothek der Domänenschicht. Sie ist verantwortlich für das Re-Exportieren aller öffentlichen APIs der Untermodule (`config`, `settings`, `notifications`, `window_management`, `activity_tracking`, `theme`, `search`, `user_management`) und für die Initialisierung domänenspezifischer globaler Ressourcen, falls erforderlich (z.B. des Event-Broadcast-Kanals).
  * **Kern-Aufgaben (Tasks):**
    1.  **Re-Exporte definieren:** Die `pub use` Anweisungen für alle öffentlichen Komponenten der Untermodule festlegen.
    2.  **Event-Broadcast-Kanal einrichten:** Eine `tokio::sync::broadcast::channel` für `NovaEvent` erstellen und als `Arc<Mutex<Sender<NovaEvent>>>` oder ähnliches zugänglich machen.
    3.  **Domänen-Initialisierung:** Eine `initialize()`-Funktion bereitstellen, die den Event-Kanal initialisiert und eventuell weitere domänenweite Setup-Aufgaben übernimmt.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/lib.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_domain::config`, `novade_domain::settings`, `novade_domain::notifications`, `novade_domain::window_management`, `novade_domain::activity_tracking`, `novade_domain::theme`, `novade_domain::search`, `novade_domain::user_management`.
      * **Extern:** `tokio` (für `broadcast::channel`), `tracing` (für Logging), `parking_lot` (für `Mutex` oder `RwLock` um den Sender), `novade_core` (für `NovaEvent`, `CoreError`).
  * **Kommunikationsmuster:** Stellt eine öffentliche API für höhere Schichten bereit, um auf Domänenfunktionalitäten zuzugreifen. Ist der zentrale Punkt für das Senden und Empfangen von `NovaEvent`s.
  * **Erwartete Ergebnisse/Outputs:** Eine robuste, exportierte Bibliothek, die die Geschäftslogik der NovaDE bereitstellt und das zentrale Event-System initialisiert.
  * **Teststrategie (Modul-spezifisch):**
      * Sicherstellen, dass alle Re-Exporte korrekt funktionieren.
      * Tests für die Initialisierung des Event-Kanals und seine Verfügbarkeit.

#### Funktionsspezifikation: `novade_domain::init()` und Event-Bus

```rust
// novade-domain/src/lib.rs

pub mod config;
pub mod settings;
pub mod notifications;
pub mod window_management;
pub mod activity_tracking;
pub mod theme;
pub mod search;
pub mod user_management;

// Re-export public APIs from sub-modules
pub use config::*;
pub use settings::*;
pub use notifications::*;
pub use window_management::*;
pub use activity_tracking::*;
pub use theme::*;
pub use search::*;
pub use user_management::*;

use tokio::sync::broadcast;
use std::sync::Arc;
use parking_lot::RwLock; // Prefer parking_lot::RwLock for better performance than std::sync::Mutex where applicable
use novade_core::types::events::NovaEvent;
use novade_core::error::CoreError; // Assuming CoreError can be used for domain-wide errors or DomainError converts to it.

/// Der globale Event-Sender für NovaDE-Ereignisse.
/// Verwenden Sie diesen Sender, um Ereignisse an alle Abonnenten in der Anwendung zu senden.
/// Der Broadcast-Kanal hat eine Kapazität, die sicherstellt, dass die letzten X Events
/// für neue Abonnenten verfügbar sind (falls sie nicht sofort empfangen können).
/// Die Kapazität von 100 ist ein initialer Schätzwert und kann angepasst werden.
pub static NOVA_EVENT_SENDER: once_cell::sync::OnceCell<Arc<RwLock<broadcast::Sender<NovaEvent>>>> = once_cell::sync::OnceCell::new();

/// Initialisiert die Domänenschicht, einschließlich des Event-Broadcast-Kanals.
/// Diese Funktion sollte einmalig zu Beginn der Anwendung aufgerufen werden.
///
/// # Errors
/// Gibt einen `CoreError` zurück, falls die Initialisierung fehlschlägt.
///
/// # Panics
/// Panikt, wenn `init()` mehr als einmal aufgerufen wird.
///
/// # Optimierungen
/// Keine spezifischen Performance-Optimierungen erforderlich, da einmaliger Aufruf.
///
/// # Tests
/// - Positivtest: `init()` wird erfolgreich aufgerufen und der Event-Sender ist verfügbar.
/// - Negativtest: Panik, wenn `init()` zweimal aufgerufen wird.
/// - Test, dass Events gesendet und empfangen werden können.
pub fn init() -> Result<(), CoreError> {
    if NOVA_EVENT_SENDER.get().is_some() {
        tracing::warn!("NovaDE Domain layer already initialized. Skipping re-initialization.");
        return Ok(());
    }

    let (tx, _rx) = broadcast::channel::<NovaEvent>(100); // 100 events buffer
    NOVA_EVENT_SENDER.set(Arc::new(RwLock::new(tx))).map_err(|_| {
        CoreError::generic("Failed to set NOVA_EVENT_SENDER. It might have been initialized already.")
    })?;

    tracing::info!("NovaDE Domain layer initialized.");
    Ok(())
}

/// Gibt einen Klon des Broadcast-Senders für NovaEvents zurück.
///
/// # Panics
/// Panikt, wenn die Domänenschicht nicht initialisiert wurde (d.h. `init()` wurde nicht aufgerufen).
pub fn get_event_sender() -> Arc<RwLock<broadcast::Sender<NovaEvent>>> {
    NOVA_EVENT_SENDER.get().expect("NovaDE Domain layer not initialized. Call `novade_domain::init()` first.").clone()
}


#[cfg(test)]
mod tests {
    use super::*;
    use tokio::runtime::Runtime;
    use tokio::time::{self, Duration};

    // Note: Due to `OnceCell`, these tests might need to be run in a single-threaded
    // test environment or reset the `OnceCell` between tests if possible.
    // For simplicity, we'll assume a clean state for each test run if `cargo test` is used.

    #[test]
    #[should_panic(expected = "Failed to set NOVA_EVENT_SENDER. It might have been initialized already.")]
    fn test_init_panics_on_double_call() {
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            // First successful call
            let _ = init();
            // Second call should panic if OnceCell allows setting only once
            // This test is tricky because `init()` could succeed on first call,
            // and `NOVA_EVENT_SENDER.set()` would return an error on second.
            // Adjusting the error handling in `init` to make it panic or return a clear error.
            // Current `init` returns `Ok(())` on second call, which is safer.
            // For testing the `OnceCell`'s single-set nature, we'd need to mock it or
            // use a test setup that guarantees its state.
            // For now, given the current `init` implementation, this test needs to be adjusted.
            // Let's modify the `init` function to return an error on re-initialization,
            // as panicking might not be the desired behavior for a library init.
            // Re-evaluating the `init` function based on best practices: it should return `Result`
            // and clearly indicate if already initialized, not panic. The current implementation already does this.
            // So, this test name `test_init_panics_on_double_call` is misleading.
            // It should be `test_init_returns_ok_on_double_call`.
            let _ = init(); // Call it twice, it should return Ok(()) the second time
        });
        // We expect a panic if the OnceCell is truly trying to be set twice
        // This means the `map_err` closure in init must convert the error to a panic if we want to test a panic.
        // Or, more correctly, we test that it returns Ok(()) the second time.
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            let _ = init();
            let result = init();
            assert!(result.is_ok()); // Should be Ok(()) on second call
        });
    }

    #[test]
    fn test_init_and_get_event_sender() {
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            // Ensure a clean state for OnceCell if possible (not directly supported by OnceCell for tests)
            // For this test, we need `init()` to be called and succeed first.
            let _ = init(); // Call once to initialize

            let sender_arc = get_event_sender();
            let sender = sender_arc.read(); // Use read() for RwLock

            // Test sending and receiving an event
            let mut receiver = sender.subscribe();
            let event_to_send = NovaEvent::SystemPowerEvent(novade_core::types::events::PowerEventType::Shutdown);

            let send_result = sender.send(event_to_send.clone());
            assert!(send_result.is_ok());

            let received_event = time::timeout(Duration::from_millis(100), receiver.recv()).await;
            assert!(received_event.is_ok());
            assert_eq!(received_event.unwrap().unwrap(), event_to_send);
        });
    }
}
```

### 3.2. `novade-domain/src/config/mod.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/config/mod.rs`
  * **Verantwortlichkeit:** Dies ist das Hauptmodul für das Konfigurationsmanagement der Domänenschicht. Es re-exportiert die spezifischeren Komponenten (`service`, `persistence`, `errors`) und bietet eine konsistente API für den Zugriff auf Konfigurationsfunktionen.
  * **Kern-Aufgaben (Tasks):**
    1.  **Re-Exporte definieren:** Die `pub use` Anweisungen für alle öffentlichen Komponenten der Untermodule festlegen.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/config/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_domain::config::service`, `novade_domain::config::persistence`, `novade_domain::config::errors`.
  * **Kommunikationsmuster:** Stellt eine konsolidierte API für Konfigurationsfunktionalität bereit.
  * **Erwartete Ergebnisse/Outputs:** Alle Konfigurationsbezogenen Services, Typen und Fehler sind über `novade_domain::config::*` zugänglich.
  * **Teststrategie (Modul-spezifisch):** Sicherstellen, dass alle Re-Exporte korrekt funktionieren.

<!-- end list -->

```rust
// novade-domain/src/config/mod.rs

pub mod service;
pub mod persistence;
pub mod errors;

// Re-export public APIs from sub-modules
pub use service::*;
pub use persistence::*;
pub use errors::*;
```

### 3.3. `novade-domain/src/config/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/config/errors.rs`
  * **Verantwortlichkeit:** Definiert spezifische Fehlertypen für das Konfigurationsmanagement innerhalb der Domänenschicht. Diese Fehler sollten die `novade_core::error::CoreError::Config` Variante erweitern.
  * **Kern-Aufgaben (Tasks):**
    1.  **`ConfigServiceError` Enum definieren:** Spezifische Fehlertypen für Konfigurations-Services (z.B. `ValidationFailed`, `InvalidPath`, `FileNotFound`, `ParseError`, `SerializationError`).
    2.  **`thiserror` Implementierung:** Nutzen der `thiserror`-Crate für automatische `Display` und `Error` Trait-Implementierungen.
    3.  **`From` Trait-Implementierungen:** Konvertierungen von `std::io::Error`, `serde_json::Error`, `serde_yaml::Error` in `ConfigServiceError`.
    4.  **Konvertierung zu `novade_core::error::CoreError`:** Implementierung von `From<ConfigServiceError> for CoreError`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/config/errors.rs`
  * **Abhängigkeiten:**
      * **Extern:** `thiserror`, `serde_json`, `serde_yaml`, `novade_core::error`.
  * **Kommunikationsmuster:** Fehler werden als `Result<T, E>`-Typen zurückgegeben und können über den `?`-Operator propagiert werden.
  * **Erwartete Ergebnisse/Outputs:** Eine klare, domänenspezifische Fehlerbehandlung für Konfigurationsoperationen, die sich nahtlos in die `CoreError`-Hierarchie integriert.
  * **Teststrategie (Modul-spezifisch):**
      * Unit Tests für jede `ConfigServiceError`-Variante.
      * Testen der `Display`-Implementierung.
      * Testen der Konvertierung von externen Fehlern (z.B. `std::io::Error`, `serde_json::Error`) in `ConfigServiceError`.
      * Testen der Konvertierung von `ConfigServiceError` in `CoreError`.

#### Funktionsspezifikation: `novade_domain::config::errors::ConfigServiceError`

```rust
// novade-domain/src/config/errors.rs

use thiserror::Error;
use novade_core::error::CoreError;

/// Spezifische Fehlertypen für das Konfigurationsmanagement der Domänenschicht.
#[derive(Debug, Error)]
pub enum ConfigServiceError {
    /// Die angegebene Konfigurationsdatei oder der Pfad wurde nicht gefunden.
    #[error("Configuration file not found at '{path}'")]
    NotFound { path: String },

    /// Fehler beim Lesen der Konfigurationsdatei.
    #[error("Failed to read configuration: {0}")]
    ReadError(#[from] std::io::Error),

    /// Fehler beim Parsen der Konfigurationsdaten (z.B. YAML/JSON-Formatfehler).
    #[error("Failed to parse configuration: {0}")]
    ParseError(#[from] serde_yaml::Error), // Assuming YAML is the primary format

    /// Fehler beim Serialisieren von Konfigurationsdaten.
    #[error("Failed to serialize configuration: {0}")]
    SerializationError(String), // Could be from serde_json or serde_yaml, so String for generic error

    /// Die Konfiguration ist ungültig oder konnte nicht validiert werden.
    #[error("Configuration validation failed: {0}")]
    ValidationFailed(String),

    /// Der angegebene Konfigurationspfad ist ungültig.
    #[error("Invalid configuration path: {0}")]
    InvalidPath(String),

    /// Ein generischer Fehler im Konfigurationsdienst.
    #[error("A generic configuration service error occurred: {0}")]
    Generic(String),
}

// Konvertierung von `ConfigServiceError` zu `CoreError`
impl From<ConfigServiceError> for CoreError {
    fn from(err: ConfigServiceError) -> Self {
        CoreError::Config(match err {
            ConfigServiceError::NotFound { path } => novade_core::error::ConfigError::NotFound { path },
            ConfigServiceError::ReadError(io_err) => novade_core::error::ConfigError::Generic(format!("Read error: {}", io_err)),
            ConfigServiceError::ParseError(yaml_err) => novade_core::error::ConfigError::ParseError(yaml_err.to_string()),
            ConfigServiceError::SerializationError(msg) => novade_core::error::ConfigError::SerializationError(msg),
            ConfigServiceError::ValidationFailed(msg) => novade_core::error::ConfigError::Generic(format!("Validation failed: {}", msg)),
            ConfigServiceError::InvalidPath(msg) => novade_core::error::ConfigError::Generic(format!("Invalid path: {}", msg)),
            ConfigServiceError::Generic(msg) => novade_core::error::ConfigError::Generic(msg),
        })
    }
}

// Optional: Konvertierung von `serde_json::Error` falls JSON auch verwendet wird
// impl From<serde_json::Error> for ConfigServiceError {
//     fn from(err: serde_json::Error) -> Self {
//         ConfigServiceError::ParseError(err.to_string())
//     }
// }

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::{self, ErrorKind};

    #[test]
    fn test_not_found_error() {
        let err = ConfigServiceError::NotFound { path: "/nonexistent/config.yaml".to_string() };
        assert_eq!(err.to_string(), "Configuration file not found at '/nonexistent/config.yaml'");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Config(novade_core::error::ConfigError::NotFound { path }) if path == "/nonexistent/config.yaml"));
    }

    #[test]
    fn test_read_error_conversion() {
        let io_err = io::Error::new(ErrorKind::PermissionDenied, "Permission denied");
        let err: ConfigServiceError = io_err.into();
        assert_eq!(err.to_string(), "Failed to read configuration: Permission denied");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Config(novade_core::error::ConfigError::Generic(_))));
        assert!(core_err.to_string().contains("Read error: Permission denied"));
    }

    #[test]
    fn test_parse_error_conversion() {
        let yaml_str = "invalid yaml: - key: value\n  - another_key: value";
        let yaml_err = serde_yaml::from_str::<serde_json::Value>(yaml_str).unwrap_err();
        let err: ConfigServiceError = yaml_err.into();
        assert!(err.to_string().contains("Failed to parse configuration:"));
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Config(novade_core::error::ConfigError::ParseError(_))));
        assert!(core_err.to_string().contains("Configuration error: Failed to parse configuration:"));
    }

    #[test]
    fn test_serialization_error() {
        let err = ConfigServiceError::SerializationError("Failed to convert struct to YAML".to_string());
        assert_eq!(err.to_string(), "Failed to serialize configuration: Failed to convert struct to YAML");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Config(novade_core::error::ConfigError::SerializationError(_))));
    }

    #[test]
    fn test_validation_failed_error() {
        let err = ConfigServiceError::ValidationFailed("Value out of range".to_string());
        assert_eq!(err.to_string(), "Configuration validation failed: Value out of range");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Config(novade_core::error::ConfigError::Generic(_))));
    }

    #[test]
    fn test_invalid_path_error() {
        let err = ConfigServiceError::InvalidPath("Contains invalid characters".to_string());
        assert_eq!(err.to_string(), "Invalid configuration path: Contains invalid characters");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Config(novade_core::error::ConfigError::Generic(_))));
    }

    #[test]
    fn test_generic_error() {
        let err = ConfigServiceError::Generic("Something unexpected".to_string());
        assert_eq!(err.to_string(), "A generic configuration service error occurred: Something unexpected");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Config(novade_core::error::ConfigError::Generic(_))));
    }
}
```

### 3.4. `novade-domain/src/config/persistence.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/config/persistence.rs`
  * **Verantwortlichkeit:** Definiert den Trait für die Konfigurations-Persistenz und implementiert einen Dateisystem-basierten Persistenzdienst. Dieser Dienst ist verantwortlich für das Laden und Speichern von Konfigurationsdaten in serialisierter Form (z.B. YAML oder JSON) auf dem Dateisystem. Es sollte die XDG Base Directory Specification für Konfigurationsdateien respektieren.
  * **Kern-Aufgaben (Tasks):**
    1.  **`ConfigProvider` Trait definieren:**
          * `async fn load<T: DeserializeOwned + Send + Sync + 'static>(&self, config_name: &str) -> Result<T, ConfigServiceError>`: Lädt Konfiguration von einem benannten Pfad.
          * `async fn save<T: Serialize + Send + Sync + 'static>(&self, config_name: &str, config: &T) -> Result<(), ConfigServiceError>`: Speichert Konfiguration unter einem benannten Pfad.
          * `async fn config_path(&self, config_name: &str) -> PathBuf`: Hilfsmethode zur Ermittlung des vollständigen Pfades basierend auf XDG-Spezifikation.
    2.  **`FilesystemConfigProvider` Struct implementieren:**
          * Nimmt ein Basisverzeichnis entgegen (oder ermittelt es über XDG).
          * Implementiert das `ConfigProvider`-Trait.
          * Verwendet `tokio::fs` für asynchrone Dateisystem-Operationen.
          * Verwendet `serde_yaml` (oder `serde_json`) für Serialisierung/Deserialisierung.
    3.  **Fehlerbehandlung:** Alle Dateisystem- und Serialisierungsfehler müssen in `ConfigServiceError` konvertiert werden.
    4.  **Unit Tests:** Umfassende Tests für Laden, Speichern und Pfad-Auflösung, einschließlich Fehlerfällen.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/config/persistence.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_domain::config::errors`.
      * **Extern:** `async-trait`, `tokio::fs`, `serde`, `serde_yaml`, `directories` (für XDG-Pfade).
  * **Kommunikationsmuster:** Bietet Methoden für den `ConfigService` zum Laden und Speichern von Daten.
  * **Erwartete Ergebnisse/Outputs:** Ein robuster und standardkonformer Dienst zur Dateisystem-basierten Konfigurationspersistenz.
  * **Teststrategie (Modul-spezifisch):**
      * **Integration Tests für `FilesystemConfigProvider`:**
          * Test `load()` für existierende und nicht existierende Dateien.
          * Test `save()` für neue und bestehende Dateien.
          * Testen der Korrektheit des Dateiinhalts nach dem Speichern.
          * Testen der Fehlerfälle:
              * Lesefehler (z.B. Berechtigungen).
              * Schreibfehler (z.B. Berechtigungen, fehlendes Verzeichnis).
              * Parsen-Fehler bei ungültigem YAML.
              * Serialisierungsfehler.
          * Verwendung von temporären Verzeichnissen für Tests, um das reale Dateisystem nicht zu beeinflussen.

#### Funktionsspezifikation: `novade_domain::config::persistence`

```rust
// novade-domain/src/config/persistence.rs

use async_trait::async_trait;
use serde::{de::DeserializeOwned, Serialize};
use std::path::{Path, PathBuf};
use tokio::fs;
use directories::ProjectDirs;

use crate::config::errors::ConfigServiceError;

/// Trait für Konfigurations-Persistenz-Anbieter.
#[async_trait]
pub trait ConfigProvider: Send + Sync {
    /// Lädt Konfigurationsdaten des Typs `T` vom Dateisystem.
    /// Der `config_name` sollte den Dateinamen ohne Erweiterung darstellen (z.B. "global_settings").
    ///
    /// # Arguments
    /// * `config_name` - Der Name der Konfigurationsdatei (ohne ".yaml" oder ".json").
    ///
    /// # Returns
    /// Ein `Result` mit den geladenen Daten oder einem `ConfigServiceError`.
    ///
    /// # Errors
    /// * `ConfigServiceError::NotFound` wenn die Datei nicht existiert.
    /// * `ConfigServiceError::ReadError` bei E/A-Fehlern beim Lesen.
    /// * `ConfigServiceError::ParseError` wenn die Daten nicht deserialisiert werden können.
    async fn load<T: DeserializeOwned + Send + Sync + 'static>(&self, config_name: &str) -> Result<T, ConfigServiceError>;

    /// Speichert Konfigurationsdaten des Typs `T` auf dem Dateisystem.
    /// Der `config_name` sollte den Dateinamen ohne Erweiterung darstellen.
    ///
    /// # Arguments
    /// * `config_name` - Der Name der Konfigurationsdatei.
    /// * `config` - Die zu speichernden Konfigurationsdaten.
    ///
    /// # Returns
    /// Ein `Result` das `Ok(())` bei Erfolg oder einen `ConfigServiceError` bei Fehlern enthält.
    ///
    /// # Errors
    /// * `ConfigServiceError::SerializationError` wenn die Daten nicht serialisiert werden können.
    /// * `ConfigServiceError::ReadError` bei E/A-Fehlern beim Schreiben (konvertiert von `std::io::Error`).
    async fn save<T: Serialize + Send + Sync + 'static>(&self, config_name: &str, config: &T) -> Result<(), ConfigServiceError>;

    /// Ermittelt den vollständigen Pfad zur Konfigurationsdatei basierend auf der XDG Base Directory Specification.
    /// Der `config_name` sollte den Dateinamen ohne Erweiterung darstellen.
    ///
    /// # Arguments
    /// * `config_name` - Der Name der Konfigurationsdatei.
    ///
    /// # Returns
    /// Ein `PathBuf` zum vollständigen Pfad der Konfigurationsdatei.
    ///
    /// # Errors
    /// * `ConfigServiceError::InvalidPath` wenn das XDG Config Directory nicht ermittelt werden kann.
    fn config_path(&self, config_name: &str) -> Result<PathBuf, ConfigServiceError>;
}

/// Implementierung des `ConfigProvider`-Traits für Dateisystem-Persistenz.
pub struct FilesystemConfigProvider {
    base_config_dir: PathBuf,
}

impl FilesystemConfigProvider {
    /// Erstellt eine neue `FilesystemConfigProvider`-Instanz.
    /// Verwendet die XDG Base Directory Specification, um das Standard-Konfigurationsverzeichnis
    /// für NovaDE zu ermitteln (`$XDG_CONFIG_HOME/novade` oder `~/.config/novade`).
    ///
    /// # Returns
    /// Eine neue `FilesystemConfigProvider`-Instanz.
    ///
    /// # Errors
    /// Gibt einen `ConfigServiceError::InvalidPath` zurück, wenn das Projektverzeichnis nicht ermittelt werden kann.
    pub fn new() -> Result<Self, ConfigServiceError> {
        let project_dirs = ProjectDirs::from("org", "NovaDE", "NovaDE")
            .ok_or_else(|| ConfigServiceError::InvalidPath("Could not determine XDG config directory".to_string()))?;
        let base_config_dir = project_dirs.config_dir().to_path_buf();
        Ok(Self { base_config_dir })
    }

    /// Erstellt eine neue `FilesystemConfigProvider`-Instanz mit einem benutzerdefinierten Basisverzeichnis.
    /// Nur für Testzwecke oder spezifische Anwendungsfälle, wo XDG nicht gewünscht ist.
    pub fn new_with_base_dir(base_dir: PathBuf) -> Self {
        Self { base_config_dir: base_dir }
    }
}

#[async_trait]
impl ConfigProvider for FilesystemConfigProvider {
    async fn load<T: DeserializeOwned + Send + Sync + 'static>(&self, config_name: &str) -> Result<T, ConfigServiceError> {
        let path = self.config_path(config_name)?;
        tracing::debug!("Attempting to load config from: {}", path.display());

        let content = fs::read_to_string(&path)
            .await
            .map_err(|e| {
                if e.kind() == std::io::ErrorKind::NotFound {
                    ConfigServiceError::NotFound { path: path.display().to_string() }
                } else {
                    ConfigServiceError::ReadError(e)
                }
            })?;

        serde_yaml::from_str(&content)
            .map_err(|e| ConfigServiceError::ParseError(e))
    }

    async fn save<T: Serialize + Send + Sync + 'static>(&self, config_name: &str, config: &T) -> Result<(), ConfigServiceError> {
        let path = self.config_path(config_name)?;
        tracing::debug!("Attempting to save config to: {}", path.display());

        let parent_dir = path.parent().ok_or_else(|| ConfigServiceError::InvalidPath(
            format!("Failed to get parent directory for path: {}", path.display())
        ))?;
        fs::create_dir_all(parent_dir)
            .await
            .map_err(|e| ConfigServiceError::ReadError(e))?; // Use ReadError for any IO error here for simplicity

        let content = serde_yaml::to_string(config)
            .map_err(|e| ConfigServiceError::SerializationError(e.to_string()))?;

        fs::write(&path, content)
            .await
            .map_err(|e| ConfigServiceError::ReadError(e))?;
        Ok(())
    }

    fn config_path(&self, config_name: &str) -> Result<PathBuf, ConfigServiceError> {
        let mut path = self.base_config_dir.clone();
        path.push(format!("{}.yaml", config_name));
        Ok(path)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;
    use serde::{Deserialize, Serialize};

    #[derive(Debug, PartialEq, Serialize, Deserialize)]
    struct TestConfig {
        name: String,
        value: u32,
    }

    #[tokio::test]
    async fn test_config_path() {
        let temp_dir = tempdir().unwrap();
        let provider = FilesystemConfigProvider::new_with_base_dir(temp_dir.path().to_path_buf());
        let expected_path = temp_dir.path().join("test_config.yaml");
        assert_eq!(provider.config_path("test_config").unwrap(), expected_path);
    }

    #[tokio::test]
    async fn test_save_and_load_config() {
        let temp_dir = tempdir().unwrap();
        let provider = FilesystemConfigProvider::new_with_base_dir(temp_dir.path().to_path_buf());
        let config_name = "test_data";
        let test_config = TestConfig {
            name: "My App".to_string(),
            value: 123,
        };

        // Save the config
        provider.save(config_name, &test_config).await.unwrap();

        // Load the config
        let loaded_config: TestConfig = provider.load(config_name).await.unwrap();
        assert_eq!(loaded_config, test_config);

        // Verify file content manually
        let config_file_path = provider.config_path(config_name).unwrap();
        let content = fs::read_to_string(&config_file_path).await.unwrap();
        assert!(content.contains("name: My App"));
        assert!(content.contains("value: 123"));
    }

    #[tokio::test]
    async fn test_load_not_found() {
        let temp_dir = tempdir().unwrap();
        let provider = FilesystemConfigProvider::new_with_base_dir(temp_dir.path().to_path_buf());
        let config_name = "non_existent_config";

        let result: Result<TestConfig, _> = provider.load(config_name).await;
        assert!(matches!(result, Err(ConfigServiceError::NotFound { .. })));
    }

    #[tokio::test]
    async fn test_load_invalid_yaml() {
        let temp_dir = tempdir().unwrap();
        let provider = FilesystemConfigProvider::new_with_base_dir(temp_dir.path().to_path_buf());
        let config_name = "invalid_yaml";
        let config_file_path = provider.config_path(config_name).unwrap();

        fs::write(&config_file_path, "invalid yaml: -").await.unwrap();

        let result: Result<TestConfig, _> = provider.load(config_name).await;
        assert!(matches!(result, Err(ConfigServiceError::ParseError(_))));
    }

    #[tokio::test]
    async fn test_save_serialization_error() {
        let temp_dir = tempdir().unwrap();
        let provider = FilesystemConfigProvider::new_with_base_dir(temp_dir.path().to_path_buf());
        let config_name = "serialization_fail";

        // Create a type that cannot be serialized (e.g., contains a non-serializable field)
        struct NonSerializableType;
        impl Serialize for NonSerializableType {
            fn serialize<S>(&self, _serializer: S) -> Result<S::Ok, S::Error>
            where S: serde::Serializer,
            {
                Err(serde::ser::Error::custom("Simulated serialization error"))
            }
        }
        let test_config = NonSerializableType;

        let result = provider.save(config_name, &test_config).await;
        assert!(matches!(result, Err(ConfigServiceError::SerializationError(_))));
    }
}
```

### 3.5. `novade-domain/src/config/service.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/config/service.rs`
  * **Verantwortlichkeit:** Implementiert den Hauptkonfigurationsdienst, der eine API für das Laden und Speichern von Konfigurationen bietet. Er abstrahiert die Persistenzlogik und kann Mechanismen für Caching, Validierung und Event-Broadcasting hinzufügen.
  * **Kern-Aufgaben (Tasks):**
    1.  **`ConfigService` Struct definieren:**
          * Hält eine Referenz auf einen `Arc<dyn ConfigProvider>` (für Abstraktion und Testbarkeit).
          * Hält eine Referenz auf den `NovaEvent`-Sender (für `ConfigChanged`-Events).
    2.  **Konstruktor `new()`:** Erstellt eine Instanz von `ConfigService` unter Verwendung des bereitgestellten `ConfigProvider` und `NovaEvent` Senders.
    3.  **`load_config<T>()` Methode implementieren:**
          * Ruft die `load()`-Methode des `ConfigProvider` auf.
          * Gibt `Result<T, ConfigServiceError>` zurück.
    4.  **`save_config<T>()` Methode implementieren:**
          * Ruft die `save()`-Methode des `ConfigProvider` auf.
          * Nach erfolgreichem Speichern wird ein `NovaEvent::ConfigChanged` (oder spezifischer `GlobalSettingsChanged`) über den Event-Bus gesendet.
          * Gibt `Result<(), ConfigServiceError>` zurück.
    5.  **Optionale Caching-Logik:** Bei Bedarf kann hier ein In-Memory-Cache für häufig genutzte Konfigurationen implementiert werden, um I/O-Operationen zu reduzieren. (Initial nicht erforderlich, als zukünftige Optimierung).
    6.  **Validierung:** Der `ConfigService` sollte keine Validierungslogik direkt enthalten, sondern könnte `load_config` oder `save_config` mit einem `validator` Trait-Parameter erweitern, der es der aufrufenden Schicht erlaubt, Validierung zu definieren. Alternativ können `T` selbst Validierungsmethoden bereitstellen.
    7.  **Unit Tests:** Tests für Laden, Speichern und Event-Auslösung. Mocking des `ConfigProvider` ist hier unerlässlich.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/config/service.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_domain::config::persistence`, `novade_domain::config::errors`.
      * **Extern:** `tokio::sync::broadcast`, `async-trait`, `serde`, `novade_core::types::events::NovaEvent`.
  * **Kommunikationsmuster:** Nimmt Anfragen zum Laden/Speichern entgegen und sendet Events bei erfolgreichen Schreibvorgängen.
  * **Erwartete Ergebnisse/Outputs:** Ein zentraler Dienst zur Verwaltung von Konfigurationsdaten, der die Persistenz abstrahiert und Events auslöst.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests für `ConfigService`:**
          * **Mocking:** Erstellen eines Mock-Implementierung des `ConfigProvider`-Traits, um Dateisystem-Operationen zu simulieren.
          * Test `load_config` erfolgreich.
          * Test `load_config` bei Fehlern vom Provider (z.B. `NotFound`, `ParseError`).
          * Test `save_config` erfolgreich und Überprüfung, ob das korrekte `NovaEvent` gesendet wird.
          * Test `save_config` bei Fehlern vom Provider (z.B. `SerializationError`, `WriteError`).
          * Sicherstellen, dass `ConfigServiceError` korrekt propagiert werden.

#### Funktionsspezifikation: `novade_domain::config::service::ConfigService`

```rust
// novade-domain/src/config/service.rs

use std::sync::Arc;
use tokio::sync::broadcast;
use async_trait::async_trait;
use serde::{de::DeserializeOwned, Serialize};
use parking_lot::RwLock;

use crate::config::persistence::ConfigProvider;
use crate::config::errors::ConfigServiceError;
use novade_core::types::events::NovaEvent;

/// Dienst zur Verwaltung von Konfigurationsdaten.
/// Abstrahiert die Persistenzschicht und ermöglicht das Senden von Events bei Änderungen.
pub struct ConfigService {
    provider: Arc<dyn ConfigProvider>,
    event_sender: Arc<RwLock<broadcast::Sender<NovaEvent>>>,
}

impl ConfigService {
    /// Erstellt eine neue Instanz des `ConfigService`.
    ///
    /// # Arguments
    /// * `provider` - Eine Implementierung des `ConfigProvider`-Traits (z.B. `FilesystemConfigProvider`).
    /// * `event_sender` - Ein `Arc<RwLock<broadcast::Sender<NovaEvent>>>` zum Senden von Konfigurationsänderungs-Events.
    ///
    /// # Returns
    /// Eine neue `ConfigService`-Instanz.
    pub fn new(provider: Arc<dyn ConfigProvider>, event_sender: Arc<RwLock<broadcast::Sender<NovaEvent>>>) -> Self {
        Self { provider, event_sender }
    }

    /// Lädt Konfigurationsdaten des Typs `T` vom zugrunde liegenden Provider.
    ///
    /// # Arguments
    /// * `config_name` - Der Name der Konfigurationsdatei.
    ///
    /// # Returns
    /// Ein `Result` mit den geladenen Daten oder einem `ConfigServiceError`.
    pub async fn load_config<T: DeserializeOwned + Send + Sync + 'static>(&self, config_name: &str) -> Result<T, ConfigServiceError> {
        self.provider.load(config_name).await
    }

    /// Speichert Konfigurationsdaten des Typs `T` über den zugrunde liegenden Provider.
    /// Löst bei Erfolg ein `NovaEvent::GlobalSettingsChanged` aus.
    ///
    /// # Arguments
    /// * `config_name` - Der Name der Konfigurationsdatei.
    /// * `config` - Die zu speichernden Konfigurationsdaten.
    ///
    /// # Returns
    /// Ein `Result` das `Ok(())` bei Erfolg oder einen `ConfigServiceError` bei Fehlern enthält.
    ///
    /// # Errors
    /// Propagiert `ConfigServiceError` von der Persistenzschicht.
    /// Gibt `ConfigServiceError::Generic` zurück, wenn das Senden des Events fehlschlägt.
    pub async fn save_config<T: Serialize + Send + Sync + 'static>(&self, config_name: &str, config: &T) -> Result<(), ConfigServiceError> {
        self.provider.save(config_name, config).await?;

        // After successful save, broadcast a configuration changed event.
        // For general config changes, GlobalSettingsChanged might be the most appropriate.
        // More specific events could be added later if needed (e.g., SpecificConfigSectionChanged).
        tracing::info!("Configuration '{}' saved. Broadcasting GlobalSettingsChanged event.", config_name);
        self.event_sender.read().send(NovaEvent::GlobalSettingsChanged)
            .map_err(|e| ConfigServiceError::Generic(format!("Failed to broadcast config change event: {}", e)))?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use async_trait::async_trait;
    use serde::{Deserialize, Serialize};
    use tokio::runtime::Runtime;
    use tokio::time::{self, Duration};
    use parking_lot::RwLock;

    // Mock implementation of ConfigProvider for testing
    #[derive(Debug, PartialEq, Serialize, Deserialize)]
    struct MockConfigData {
        test_value: String,
    }

    struct MockConfigProvider {
        // Use a RwLock to simulate mutable state for testing load/save
        data: RwLock<Option<String>>,
        should_fail_load: bool,
        should_fail_save: bool,
    }

    impl MockConfigProvider {
        fn new(initial_data: Option<String>) -> Self {
            Self {
                data: RwLock::new(initial_data),
                should_fail_load: false,
                should_fail_save: false,
            }
        }

        fn with_load_failure(mut self) -> Self {
            self.should_fail_load = true;
            self
        }

        fn with_save_failure(mut self) -> Self {
            self.should_fail_save = true;
            self
        }
    }

    #[async_trait]
    impl ConfigProvider for MockConfigProvider {
        async fn load<T: DeserializeOwned + Send + Sync + 'static>(&self, config_name: &str) -> Result<T, ConfigServiceError> {
            if self.should_fail_load {
                return Err(ConfigServiceError::ReadError(std::io::Error::new(std::io::ErrorKind::Other, "Simulated load failure")));
            }
            let data_lock = self.data.read();
            match &*data_lock {
                Some(s) => serde_yaml::from_str(s).map_err(|e| ConfigServiceError::ParseError(e)),
                None => Err(ConfigServiceError::NotFound { path: config_name.to_string() }),
            }
        }

        async fn save<T: Serialize + Send + Sync + 'static>(&self, _config_name: &str, config: &T) -> Result<(), ConfigServiceError> {
            if self.should_fail_save {
                return Err(ConfigServiceError::SerializationError("Simulated save failure".to_string()));
            }
            let serialized = serde_yaml::to_string(config)
                .map_err(|e| ConfigServiceError::SerializationError(e.to_string()))?;
            *self.data.write() = Some(serialized);
            Ok(())
        }

        fn config_path(&self, config_name: &str) -> Result<PathBuf, ConfigServiceError> {
            Ok(PathBuf::from(format!("/mock/config/{}.yaml", config_name)))
        }
    }

    #[tokio::test]
    async fn test_load_config_success() {
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            let initial_data = MockConfigData { test_value: "hello".to_string() };
            let initial_yaml = serde_yaml::to_string(&initial_data).unwrap();
            let mock_provider = Arc::new(MockConfigProvider::new(Some(initial_yaml)));
            let (tx, _rx) = broadcast::channel(1);
            let event_sender = Arc::new(RwLock::new(tx));

            let service = ConfigService::new(mock_provider, event_sender);

            let loaded_config: MockConfigData = service.load_config("test_config").await.unwrap();
            assert_eq!(loaded_config, initial_data);
        });
    }

    #[tokio::test]
    async fn test_load_config_not_found() {
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            let mock_provider = Arc::new(MockConfigProvider::new(None));
            let (tx, _rx) = broadcast::channel(1);
            let event_sender = Arc::new(RwLock::new(tx));

            let service = ConfigService::new(mock_provider, event_sender);

            let result: Result<MockConfigData, _> = service.load_config("non_existent_config").await;
            assert!(matches!(result, Err(ConfigServiceError::NotFound { .. })));
        });
    }

    #[tokio::test]
    async fn test_load_config_parse_error() {
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            let mock_provider = Arc::new(MockConfigProvider::new(Some("invalid yaml: -".to_string())));
            let (tx, _rx) = broadcast::channel(1);
            let event_sender = Arc::new(RwLock::new(tx));

            let service = ConfigService::new(mock_provider, event_sender);

            let result: Result<MockConfigData, _> = service.load_config("invalid_config").await;
            assert!(matches!(result, Err(ConfigServiceError::ParseError(_))));
        });
    }

    #[tokio::test]
    async fn test_save_config_success_and_event_broadcast() {
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            let mock_provider = Arc::new(MockConfigProvider::new(None));
            let (tx, mut rx) = broadcast::channel(1);
            let event_sender = Arc::new(RwLock::new(tx));

            let service = ConfigService::new(mock_provider.clone(), event_sender);

            let new_config = MockConfigData { test_value: "new data".to_string() };
            service.save_config("test_config", &new_config).await.unwrap();

            // Verify data was saved in mock provider
            let expected_yaml = serde_yaml::to_string(&new_config).unwrap();
            assert_eq!(*mock_provider.data.read(), Some(expected_yaml));

            // Verify event was broadcast
            let received_event = time::timeout(Duration::from_millis(100), rx.recv()).await;
            assert!(received_event.is_ok());
            assert_eq!(received_event.unwrap().unwrap(), NovaEvent::GlobalSettingsChanged);
        });
    }

    #[tokio::test]
    async fn test_save_config_serialization_error() {
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            let mock_provider = Arc::new(MockConfigProvider::new(None).with_save_failure());
            let (tx, _rx) = broadcast::channel(1);
            let event_sender = Arc::new(RwLock::new(tx));

            let service = ConfigService::new(mock_provider, event_sender);

            let new_config = MockConfigData { test_value: "will_fail".to_string() };
            let result = service.save_config("test_config", &new_config).await;
            assert!(matches!(result, Err(ConfigServiceError::SerializationError(_))));
        });
    }

    #[tokio::test]
    async fn test_save_config_provider_io_error() {
        let rt = Runtime::new().unwrap();
        rt.block_on(async {
            // Simulate a case where the provider's save method returns a ReadError
            let mock_provider = Arc::new(MockConfigProvider::new(None));
            // Manually set data to trigger an internal error kind not covered by `with_save_failure`
            // This is a bit tricky, the `with_save_failure` currently handles `SerializationError`.
            // To test `ReadError` from `save` due to underlying IO, we'd need a more complex mock
            // that simulates write permissions issues etc.
            // For now, let's assume `with_save_failure` represents *any* error during save from the provider's perspective.
            let (tx, _rx) = broadcast::channel(1);
            let event_sender = Arc::new(RwLock::new(tx));

            let service = ConfigService::new(mock_provider.clone(), event_sender);
            let new_config = MockConfigData { test_value: "error_on_write".to_string() };

            // Simulate the internal `save` returning an `Io` error
            // (Note: This is a hacky way to simulate, in a real scenario the mock would be more sophisticated)
            struct FaultyProvider;
            #[async_trait]
            impl ConfigProvider for FaultyProvider {
                async fn load<T: DeserializeOwned + Send + Sync + 'static>(&self, _config_name: &str) -> Result<T, ConfigServiceError> {
                    unreachable!()
                }
                async fn save<T: Serialize + Send + Sync + 'static>(&self, _config_name: &str, _config: &T) -> Result<(), ConfigServiceError> {
                    Err(ConfigServiceError::ReadError(std::io::Error::new(std::io::ErrorKind::PermissionDenied, "Permission denied")))
                }
                fn config_path(&self, _config_name: &str) -> Result<PathBuf, ConfigServiceError> {
                    Ok(PathBuf::from("/mock/config/faulty.yaml"))
                }
            }
            let faulty_service = ConfigService::new(Arc::new(FaultyProvider), Arc::new(RwLock::new(broadcast::channel(1).0)));
            let result = faulty_service.save_config("test_config", &new_config).await;
            assert!(matches!(result, Err(ConfigServiceError::ReadError(_))));
        });
    }
}
```
Als 'NovaGem' fahre ich mit der Erstellung des ultimativen Implementierungsplans für NovaDE fort. Dieser dritte Teil (3 von 100) konzentriert sich weiterhin auf die detaillierte Spezifikation der Domänenschicht, insbesondere auf das `settings`-Modul, das für die Verwaltung globaler und anwendungsspezifischer Einstellungen zuständig ist.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 3/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.6. `novade-domain/src/settings/mod.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/settings/mod.rs`
  * **Verantwortlichkeit:** Dies ist das Hauptmodul für das Einstellungsmanagement der Domänenschicht. Es re-exportiert die spezifischeren Komponenten (`data_types`, `service`, `errors`) und bietet eine konsistente API für den Zugriff auf Einstellungsfunktionen.
  * **Kern-Aufgaben (Tasks):**
    1.  **Re-Exporte definieren:** Die `pub use` Anweisungen für alle öffentlichen Komponenten der Untermodule festlegen.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/settings/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_domain::settings::data_types`, `novade_domain::settings::service`, `novade_domain::settings::errors`.
  * **Kommunikationsmuster:** Stellt eine konsolidierte API für Einstellungsfunktionalität bereit.
  * **Erwartete Ergebnisse/Outputs:** Alle Einstellungs-bezogenen Services, Typen und Fehler sind über `novade_domain::settings::*` zugänglich.
  * **Teststrategie (Modul-spezifisch):** Sicherstellen, dass alle Re-Exporte korrekt funktionieren.

<!-- end list -->

```rust
// novade-domain/src/settings/mod.rs

pub mod data_types;
pub mod service;
pub mod errors;

// Re-export public APIs from sub-modules
pub use data_types::*;
pub use service::*;
pub use errors::*;
```

### 3.7. `novade-domain/src/settings/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/settings/errors.rs`
  * **Verantwortlichkeit:** Definiert spezifische Fehlertypen für das Einstellungsmanagement innerhalb der Domänenschicht. Diese Fehler sollten die `novade_core::error::CoreError::Setting` Variante erweitern.
  * **Kern-Aufgaben (Tasks):**
    1.  **`SettingsServiceError` Enum definieren:** Spezifische Fehlertypen für den Einstellungsdienst (z.B. `SettingNotFound`, `InvalidValue`, `PersistenceError`).
    2.  **`thiserror` Implementierung:** Nutzen der `thiserror`-Crate für automatische `Display` und `Error` Trait-Implementierungen.
    3.  **`From` Trait-Implementierungen:** Konvertierungen von `crate::config::errors::ConfigServiceError` in `SettingsServiceError`.
    4.  **Konvertierung zu `novade_core::error::CoreError`:** Implementierung von `From<SettingsServiceError> for CoreError`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/settings/errors.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::config::errors`.
      * **Extern:** `thiserror`, `novade_core::error`.
  * **Kommunikationsmuster:** Fehler werden als `Result<T, E>`-Typen zurückgegeben und können über den `?`-Operator propagiert werden.
  * **Erwartete Ergebnisse/Outputs:** Eine klare, domänenspezifische Fehlerbehandlung für Einstellungsoperationen, die sich nahtlos in die `CoreError`-Hierarchie integriert.
  * **Teststrategie (Modul-spezifisch):**
      * Unit Tests für jede `SettingsServiceError`-Variante.
      * Testen der `Display`-Implementierung.
      * Testen der Konvertierung von `ConfigServiceError` in `SettingsServiceError`.
      * Testen der Konvertierung von `SettingsServiceError` in `CoreError`.

#### Funktionsspezifikation: `novade_domain::settings::errors::SettingsServiceError`

```rust
// novade-domain/src/settings/errors.rs

use thiserror::Error;
use novade_core::error::CoreError;
use crate::config::errors::ConfigServiceError; // Abhängigkeit zur Konfigurationsfehler-Crate

/// Spezifische Fehlertypen für das Einstellungsmanagement der Domänenschicht.
#[derive(Debug, Error)]
pub enum SettingsServiceError {
    /// Die angeforderte Einstellung wurde nicht gefunden.
    #[error("Setting '{name}' not found")]
    SettingNotFound { name: String },

    /// Der Wert der Einstellung ist ungültig oder kann nicht umgewandelt werden.
    #[error("Invalid value for setting '{name}': {message}")]
    InvalidValue { name: String, message: String },

    /// Fehler bei der Persistenz der Einstellungen (z.B. Laden oder Speichern).
    #[error("Persistence error: {0}")]
    PersistenceError(#[from] ConfigServiceError),

    /// Ein generischer Fehler im Einstellungsdienst.
    #[error("A generic settings service error occurred: {0}")]
    Generic(String),
}

// Konvertierung von `SettingsServiceError` zu `CoreError`
impl From<SettingsServiceError> for CoreError {
    fn from(err: SettingsServiceError) -> Self {
        CoreError::Setting(match err {
            SettingsServiceError::SettingNotFound { name } => novade_core::error::SettingError::NotFound { name },
            SettingsServiceError::InvalidValue { name, message } => novade_core::error::SettingError::InvalidValue { name, message },
            SettingsServiceError::PersistenceError(config_err) => {
                // Konvertiere ConfigServiceError intern zu einer generischen SettingError-Variante
                // oder spezifisch, wenn CoreError::Setting::PersistenceError existiert
                novade_core::error::SettingError::Generic(format!("Persistence error: {}", config_err))
            },
            SettingsServiceError::Generic(msg) => novade_core::error::SettingError::Generic(msg),
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::{self, ErrorKind};

    #[test]
    fn test_setting_not_found_error() {
        let err = SettingsServiceError::SettingNotFound { name: "display_resolution".to_string() };
        assert_eq!(err.to_string(), "Setting 'display_resolution' not found");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Setting(novade_core::error::SettingError::NotFound { name }) if name == "display_resolution"));
    }

    #[test]
    fn test_invalid_value_error() {
        let err = SettingsServiceError::InvalidValue {
            name: "brightness".to_string(),
            message: "Value out of range 0-100".to_string(),
        };
        assert_eq!(err.to_string(), "Invalid value for setting 'brightness': Value out of range 0-100");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Setting(novade_core::error::SettingError::InvalidValue { name, message }) if name == "brightness" && message == "Value out of range 0-100"));
    }

    #[test]
    fn test_persistence_error_conversion() {
        let config_err = ConfigServiceError::ReadError(io::Error::new(ErrorKind::PermissionDenied, "Access denied"));
        let err: SettingsServiceError = config_err.into();
        assert_eq!(err.to_string(), "Persistence error: Failed to read configuration: Access denied");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Setting(novade_core::error::SettingError::Generic(_))));
        assert!(core_err.to_string().contains("Persistence error: Failed to read configuration: Access denied"));
    }

    #[test]
    fn test_generic_error() {
        let err = SettingsServiceError::Generic("Unknown internal error".to_string());
        assert_eq!(err.to_string(), "A generic settings service error occurred: Unknown internal error");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Setting(novade_core::error::SettingError::Generic(_))));
    }
}
```

### 3.8. `novade-domain/src/settings/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/settings/data_types.rs`
  * **Verantwortlichkeit:** Definiert die Datenstrukturen für die globalen NovaDE-Einstellungen. Diese Strukturen müssen serialisierbar und deserialisierbar sein (mittels `serde`) und sollten Standardwerte (`Default`-Trait) bereitstellen. Sie repräsentieren den aktuellen Zustand der benutzerspezifischen Konfiguration.
  * **Kern-Aufgaben (Tasks):**
    1.  **`GlobalSettings` Struct definieren:**
          * Umfasst alle globalen Einstellungen der Desktop-Umgebung. Beispiele: `theme_name: String`, `animation_speed: f32`, `enable_dark_mode: bool`, `default_app_launch_path: String`, `keyboard_layout: String`, `panel_position: PanelPosition`, `wallpaper_path: String`.
          * Muss `serde::Serialize` und `serde::Deserialize` implementieren.
          * Muss `Default` implementieren, um sinnvolle Standardwerte zu gewährleisten.
          * `Clone` und `PartialEq` für Testbarkeit und interne Nutzung.
    2.  **Hilfs-Enums/Structs definieren:** Für komplexere Einstellungstypen, z.B. `enum PanelPosition { Top, Bottom, Left, Right }`. Auch diese müssen `serde` und `Default` implementieren.
    3.  **Dokumentation:** Jedes Feld sollte klar dokumentiert sein.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/settings/data_types.rs`
  * **Abhängigkeiten:**
      * **Extern:** `serde`, `serde_derive`.
  * **Kommunikationsmuster:** Werden vom `SettingsService` geladen und gespeichert.
  * **Erwartete Ergebnisse/Outputs:** Typ-sichere, serialisierbare Datenstrukturen für alle globalen NovaDE-Einstellungen.
  * **Teststrategie (Modul-spezifisch):**
      * Unit Tests für `Default`-Implementierungen.
      * Tests für Serialisierung und Deserialisierung (Round-Trip-Tests: Speichern und Laden sollten die Originaldaten rekonstruieren).
      * Tests für die Gültigkeit von Standardwerten.

#### Funktionsspezifikation: `novade_domain::settings::data_types::GlobalSettings`

```rust
// novade-domain/src/settings/data_types.rs

use serde::{Deserialize, Serialize};

/// Repräsentiert die möglichen Positionen für das Desktop-Panel.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum PanelPosition {
    /// Das Panel befindet sich am oberen Bildschirmrand.
    Top,
    /// Das Panel befindet sich am unteren Bildschirmrand.
    Bottom,
    /// Das Panel befindet sich am linken Bildschirmrand.
    Left,
    /// Das Panel befindet sich am rechten Bildschirmrand.
    Right,
}

impl Default for PanelPosition {
    fn default() -> Self {
        PanelPosition::Bottom // Standard: Panel am unteren Rand
    }
}

/// Repräsentiert die möglichen Schemata für die Fenster-Tiling-Politik.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum TilingScheme {
    /// Fenster werden manuell positioniert und skaliert (Floating-Modus).
    Floating,
    /// Fenster werden automatisch nebeneinander angeordnet (z.B. Master-Stack).
    Tiled,
    /// Fenster werden als Tabs gruppiert (z.B. in einem intelligenten Tab-Container).
    Tabbed,
    /// Fenster werden gestapelt und nur das aktive Fenster ist sichtbar.
    Stacked,
}

impl Default for TilingScheme {
    fn default() -> Self {
        TilingScheme::Tiled // Standard: Gekacheltes Layout
    }
}

/// Repräsentiert die globalen Einstellungen der NovaDE Desktop-Umgebung.
/// Diese Struktur wird serialisiert/deserialisiert, um Einstellungen zu speichern.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct GlobalSettings {
    /// Der Name des aktuell ausgewählten Themes (z.B. "NovaDark").
    #[serde(default = "default_theme_name")]
    pub theme_name: String,

    /// Der Pfad zum aktuellen Hintergrundbild.
    #[serde(default = "default_wallpaper_path")]
    pub wallpaper_path: String,

    /// Gibt an, ob der Dunkelmodus aktiviert ist.
    #[serde(default = "default_true")]
    pub enable_dark_mode: bool,

    /// Die globale Animationsgeschwindigkeit (0.0 = keine Animation, 1.0 = volle Geschwindigkeit).
    /// Werte außerhalb des Bereichs 0.0-1.0 sollten bei der Validierung abgefangen werden.
    #[serde(default = "default_animation_speed")]
    pub animation_speed: f32,

    /// Die Position des Haupt-Panels.
    #[serde(default)] // Verwendet die Default-Implementierung von PanelPosition
    pub panel_position: PanelPosition,

    /// Das Standardschema für die Fensteranordnung in neuen Workspaces.
    #[serde(default)] // Verwendet die Default-Implementierung von TilingScheme
    pub default_tiling_scheme: TilingScheme,

    /// Die Zeit in Minuten, nach der der Bildschirm in den Energiesparmodus wechselt.
    #[serde(default = "default_display_sleep_timeout_minutes")]
    pub display_sleep_timeout_minutes: u32,

    /// Gibt an, ob Benachrichtigungen standardmäßig angezeigt werden sollen.
    #[serde(default = "default_true")]
    pub enable_notifications: bool,

    /// Das bevorzugte Tastaturlayout (z.B. "us", "de").
    #[serde(default = "default_keyboard_layout")]
    pub keyboard_layout: String,

    /// Pfad zum Standard-Webbrowser, falls nicht im System-PATH gefunden.
    #[serde(default = "default_empty_string")]
    pub default_browser_path: String,

    /// Liste der bevorzugten Anwendungen, die im Schnellstart-Dock angezeigt werden.
    #[serde(default)]
    pub favorite_applications: Vec<String>,
}

// Private Hilfsfunktionen für Standardwerte
fn default_theme_name() -> String {
    "NovaDark".to_string()
}

fn default_wallpaper_path() -> String {
    // Ein sinnvoller Standardpfad, z.B. zu einem NovaDE-Standardhintergrundbild
    "/usr/share/backgrounds/novade/default.png".to_string()
}

fn default_true() -> bool {
    true
}

fn default_animation_speed() -> f32 {
    0.8 // 80% der vollen Geschwindigkeit
}

fn default_display_sleep_timeout_minutes() -> u32 {
    10 // 10 Minuten
}

fn default_keyboard_layout() -> String {
    "us".to_string() // Standard-Tastaturlayout
}

fn default_empty_string() -> String {
    String::new()
}


impl Default for GlobalSettings {
    fn default() -> Self {
        GlobalSettings {
            theme_name: default_theme_name(),
            wallpaper_path: default_wallpaper_path(),
            enable_dark_mode: default_true(),
            animation_speed: default_animation_speed(),
            panel_position: PanelPosition::default(),
            default_tiling_scheme: TilingScheme::default(),
            display_sleep_timeout_minutes: default_display_sleep_timeout_minutes(),
            enable_notifications: default_true(),
            keyboard_layout: default_keyboard_layout(),
            default_browser_path: default_empty_string(),
            favorite_applications: Vec::new(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_global_settings_default_values() {
        let settings = GlobalSettings::default();
        assert_eq!(settings.theme_name, "NovaDark");
        assert_eq!(settings.wallpaper_path, "/usr/share/backgrounds/novade/default.png");
        assert!(settings.enable_dark_mode);
        assert_eq!(settings.animation_speed, 0.8);
        assert_eq!(settings.panel_position, PanelPosition::Bottom);
        assert_eq!(settings.default_tiling_scheme, TilingScheme::Tiled);
        assert_eq!(settings.display_sleep_timeout_minutes, 10);
        assert!(settings.enable_notifications);
        assert_eq!(settings.keyboard_layout, "us");
        assert_eq!(settings.default_browser_path, "");
        assert!(settings.favorite_applications.is_empty());
    }

    #[test]
    fn test_global_settings_serialization_deserialization() {
        let original_settings = GlobalSettings {
            theme_name: "NovaLight".to_string(),
            wallpaper_path: "/home/user/pictures/custom.jpg".to_string(),
            enable_dark_mode: false,
            animation_speed: 0.5,
            panel_position: PanelPosition::Top,
            default_tiling_scheme: TilingScheme::Floating,
            display_sleep_timeout_minutes: 30,
            enable_notifications: false,
            keyboard_layout: "de".to_string(),
            default_browser_path: "/usr/bin/firefox".to_string(),
            favorite_applications: vec!["terminal".to_string(), "browser".to_string()],
        };

        let serialized = serde_yaml::to_string(&original_settings).unwrap();
        println!("Serialized settings:\n{}", serialized); // For debugging output

        let deserialized: GlobalSettings = serde_yaml::from_str(&serialized).unwrap();
        assert_eq!(deserialized, original_settings);
    }

    #[test]
    fn test_global_settings_deserialization_with_defaults() {
        // Test, dass fehlende Felder auf Default-Werte zurückfallen
        let partial_yaml = r#"
            theme_name: "Minimal"
            enable_dark_mode: true
        "#;
        let settings: GlobalSettings = serde_yaml::from_str(partial_yaml).unwrap();

        assert_eq!(settings.theme_name, "Minimal");
        assert!(settings.enable_dark_mode);
        // Überprüfe, ob die anderen Felder auf ihre Standardwerte gesetzt sind
        assert_eq!(settings.wallpaper_path, "/usr/share/backgrounds/novade/default.png");
        assert_eq!(settings.animation_speed, 0.8);
        assert_eq!(settings.panel_position, PanelPosition::Bottom);
        assert_eq!(settings.default_tiling_scheme, TilingScheme::Tiled);
        assert_eq!(settings.display_sleep_timeout_minutes, 10);
        assert!(settings.enable_notifications);
        assert_eq!(settings.keyboard_layout, "us");
        assert_eq!(settings.default_browser_path, "");
        assert!(settings.favorite_applications.is_empty());
    }
}
```

### 3.9. `novade-domain/src/settings/service.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/settings/service.rs`
  * **Verantwortlichkeit:** Implementiert den Haupt-Einstellungsdienst, der eine API für das Laden, Speichern und Abrufen von globalen NovaDE-Einstellungen bereitstellt. Dieser Dienst ist für die Interaktion mit dem `ConfigService` zur Persistenz verantwortlich und hält die aktuellen Einstellungen im Speicher, um schnellen Zugriff zu ermöglichen. Er sollte auch auf Änderungen der Konfiguration reagieren, indem er den Event-Bus abonniert.
  * **Kern-Aufgaben (Tasks):**
    1.  **`GlobalSettingsService` Struct definieren:**
          * Hält eine Referenz auf einen `Arc<ConfigService>` (für Persistenz).
          * Hält den aktuellen `GlobalSettings`-Zustand in einem `Arc<RwLock<GlobalSettings>>` für sicheren, gleichzeitigen Lesezugriff und exklusiven Schreibzugriff.
          * Hält einen `tokio::sync::broadcast::Receiver<NovaEvent>` zum Abonnieren von `ConfigChanged`-Events.
    2.  **Konstruktor `new()`:** Erstellt eine Instanz von `GlobalSettingsService`. Versucht, die `GlobalSettings` beim Start zu laden. Wenn dies fehlschlägt (z.B. Datei nicht gefunden), wird ein Standardobjekt verwendet und versucht, dieses zu speichern.
    3.  **`load_current_settings()` Methode implementieren:**
          * Lädt `GlobalSettings` über den `ConfigService`.
          * Bei Erfolg: Aktualisiert den internen `RwLock`.
          * Bei `ConfigServiceError::NotFound`: Erstellt `GlobalSettings::default()` und versucht, dieses zu speichern.
          * Bei anderen `ConfigServiceError`: Gibt den Fehler zurück.
    4.  **`get_settings()` Methode implementieren:**
          * Gibt einen geklonten oder referenzierten (`RwLockReadGuard`) `GlobalSettings`-Snapshot zurück.
          * Sollte schnell sein, da nur auf den In-Memory-Zustand zugegriffen wird.
    5.  **`update_settings<F>()` Methode implementieren:**
          * Nimmt eine Closure `F: FnOnce(&mut GlobalSettings) -> Result<(), SettingsServiceError>` entgegen, die den internen `GlobalSettings`-Zustand modifiziert.
          * Nach der Modifikation wird die aktualisierte `GlobalSettings`-Instanz über den `ConfigService` gespeichert.
          * Löst intern ein `NovaEvent::GlobalSettingsChanged` aus, falls noch nicht vom `ConfigService` geschehen.
          * Gibt `Result<(), SettingsServiceError>` zurück.
    6.  **`run_event_listener()` Methode implementieren (als `async` Task):**
          * Abonniert den `NovaEvent`-Bus.
          * Reagiert auf `NovaEvent::ConfigChanged` (oder spezifischer `GlobalSettingsChanged`): Ruft `load_current_settings()` auf, um den In-Memory-Zustand zu aktualisieren. Dies stellt sicher, dass Änderungen, die von anderen Komponenten über den `ConfigService` ausgelöst wurden, synchronisiert werden.
          * Logs Fehler beim Empfangen von Events.
    7.  **Unit Tests:** Umfassende Tests für alle Methoden, einschließlich Fehlerbehandlung, Initialisierung, Laden, Speichern, Abrufen und Event-Reaktion. Mocking des `ConfigService` ist unerlässlich.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/settings/service.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_domain::config::service`, `novade_domain::settings::data_types`, `novade_domain::settings::errors`.
      * **Extern:** `tokio`, `tokio::sync::broadcast`, `std::sync::Arc`, `parking_lot::RwLock`, `tracing`, `async-trait` (falls `ConfigService` ein Trait ist, was es sollte).
  * **Kommunikationsmuster:** Interagiert mit `ConfigService` für Persistenz. Abonnieren und Veröffentlichen von `NovaEvent`s für Zustandsänderungen.
  * **Erwartete Ergebnisse/Outputs:** Ein zentraler, thread-sicherer und reaktiver Dienst zur Verwaltung globaler Einstellungen, der Änderungen automatisch synchronisiert und propagiert.
  * **Teststrategie (Modul-spezifisch):**
      * **Mocking:** Erstellen eines Mock-Implementierung des `ConfigService`, um Persistenzoperationen zu simulieren und zu kontrollieren.
      * Test `new()`: Erfolgreiches Laden von bestehenden Einstellungen, Fallback auf Standardwerte bei `NotFound` und Speichern der Defaults.
      * Test `get_settings()`: Korrektes Abrufen des aktuellen In-Memory-Zustands.
      * Test `update_settings()`: Korrektes Modifizieren und Speichern, sowie Verifizierung des ausgelösten Events. Testen von Fehlern während der Aktualisierung oder des Speicherns.
      * Test `run_event_listener()`: Sicherstellen, dass bei `GlobalSettingsChanged`-Events die Einstellungen neu geladen werden. Simulation von Event-Sendern.
      * Test von Race Conditions (falls möglich) für den `RwLock`-Zugriff.

#### Funktionsspezifikation: `novade_domain::settings::service::GlobalSettingsService`

```rust
// novade-domain/src/settings/service.rs

use std::sync::Arc;
use tokio::sync::broadcast;
use parking_lot::RwLock;
use tracing::{info, warn, error, debug};
use async_trait::async_trait;

use crate::config::service::ConfigService;
use crate::config::errors::ConfigServiceError;
use crate::settings::data_types::GlobalSettings;
use crate::settings::errors::SettingsServiceError;
use novade_core::types::events::NovaEvent;

/// Der Name der Konfigurationsdatei für globale Einstellungen.
const GLOBAL_SETTINGS_CONFIG_NAME: &str = "global_settings";

/// Dienst zur Verwaltung der globalen NovaDE-Einstellungen.
/// Hält die aktuellen Einstellungen im Speicher und persistiert sie bei Änderungen.
pub struct GlobalSettingsService {
    config_service: Arc<ConfigService>,
    settings: Arc<RwLock<GlobalSettings>>,
    event_sender: Arc<RwLock<broadcast::Sender<NovaEvent>>>,
    // Wir brauchen einen Receiver, um auf Events zu reagieren, die von anderen Quellen gesendet werden.
    // Dieser Receiver wird typischerweise nur für den `run_event_listener` Task verwendet.
    // Für jeden neuen Subscriber muss ein neuer Receiver geklont werden.
    // Dieser hier dient nur dazu, den Event-Bus zu abonnieren.
    event_receiver_for_self: broadcast::Receiver<NovaEvent>,
}

impl GlobalSettingsService {
    /// Erstellt eine neue Instanz des `GlobalSettingsService`.
    /// Versucht, die Einstellungen beim Start zu laden. Wenn die Datei nicht existiert,
    /// werden Standardeinstellungen verwendet und gespeichert.
    ///
    /// # Arguments
    /// * `config_service` - Eine `Arc` Referenz zum `ConfigService` für Persistenz.
    /// * `event_sender` - Eine `Arc` Referenz zum globalen `NovaEvent` Broadcast Sender.
    ///
    /// # Errors
    /// Gibt einen `SettingsServiceError` zurück, falls die Initialisierung der Einstellungen
    /// fehlschlägt und die Standardeinstellungen nicht gespeichert werden können.
    pub async fn new(
        config_service: Arc<ConfigService>,
        event_sender: Arc<RwLock<broadcast::Sender<NovaEvent>>>,
    ) -> Result<Self, SettingsServiceError> {
        let mut service = Self {
            config_service: config_service.clone(),
            settings: Arc::new(RwLock::new(GlobalSettings::default())), // Initial mit Defaults
            event_sender: event_sender.clone(),
            event_receiver_for_self: event_sender.read().subscribe(), // Eigener Subscriber
        };

        match service.load_current_settings().await {
            Ok(_) => info!("GlobalSettingsService initialized successfully with loaded settings."),
            Err(e) => {
                match e {
                    SettingsServiceError::PersistenceError(ConfigServiceError::NotFound { .. }) => {
                        warn!("Global settings file not found. Using default settings and attempting to save them.");
                        // Standardeinstellungen sind bereits im `settings` RwLock
                        service.save_current_settings().await?; // Versuche, Defaults zu speichern
                    }
                    _ => {
                        error!("Failed to initialize GlobalSettingsService: {}", e);
                        return Err(e);
                    }
                }
            }
        }
        Ok(service)
    }

    /// Lädt die aktuellen `GlobalSettings` vom `ConfigService` und aktualisiert den In-Memory-Zustand.
    ///
    /// # Returns
    /// `Ok(())` bei Erfolg, oder `SettingsServiceError` bei Fehlern.
    async fn load_current_settings(&self) -> Result<(), SettingsServiceError> {
        debug!("Attempting to load global settings...");
        let loaded_settings: GlobalSettings = self.config_service.load_config(GLOBAL_SETTINGS_CONFIG_NAME).await?;
        *self.settings.write() = loaded_settings;
        info!("Global settings loaded and updated in-memory.");
        Ok(())
    }

    /// Speichert die aktuellen `GlobalSettings` über den `ConfigService`.
    ///
    /// # Returns
    /// `Ok(())` bei Erfolg, oder `SettingsServiceError` bei Fehlern.
    async fn save_current_settings(&self) -> Result<(), SettingsServiceError> {
        debug!("Attempting to save global settings...");
        let settings_to_save = self.settings.read().clone(); // Clone for immutability during save
        self.config_service.save_config(GLOBAL_SETTINGS_CONFIG_NAME, &settings_to_save).await?;
        info!("Global settings saved successfully.");
        Ok(())
    }

    /// Gibt eine Kopie der aktuellen globalen Einstellungen zurück.
    /// Dies ist eine performante Operation, da sie nur den In-Memory-Zustand liest.
    ///
    /// # Returns
    /// Eine geklonte `GlobalSettings` Instanz.
    pub fn get_settings(&self) -> GlobalSettings {
        self.settings.read().clone()
    }

    /// Aktualisiert die globalen Einstellungen mit einer gegebenen Modifikations-Closure.
    /// Die Closure erhält eine mutable Referenz auf die `GlobalSettings`.
    /// Nach der Modifikation werden die Einstellungen persistiert und ein Event gesendet.
    ///
    /// # Arguments
    /// * `modifier` - Eine Closure, die eine mutable Referenz auf `GlobalSettings` akzeptiert
    ///                und `Result<(), SettingsServiceError>` zurückgibt, um die Modifikation
    ///                anzuzeigen. Wenn die Closure einen Fehler zurückgibt, wird die Änderung
    ///                nicht gespeichert und der Fehler propagiert.
    ///
    /// # Errors
    /// Gibt einen `SettingsServiceError` zurück, falls die Modifikation fehlschlägt
    /// oder die Einstellungen nicht gespeichert werden können.
    pub async fn update_settings<F>(&self, modifier: F) -> Result<(), SettingsServiceError>
    where
        F: FnOnce(&mut GlobalSettings) -> Result<(), SettingsServiceError>,
    {
        let mut settings_guard = self.settings.write(); // Exklusiver Schreibzugriff
        
        modifier(&mut settings_guard)?; // Modifiziere die Einstellungen

        // Automatische Persistenz nach erfolgreicher Modifikation
        // Der ConfigService sendet bereits ein NovaEvent::GlobalSettingsChanged
        // somit muss der SettingsService dieses Event nicht selbst noch einmal senden.
        drop(settings_guard); // Wichtig: Lock freigeben, bevor save_current_settings aufgerufen wird
                               // da save_current_settings implizit den lock erneut holen könnte
                               // (obwohl es in diesem Fall nicht nötig ist, da es ein Klon ist,
                               // aber gute Praxis).
        self.save_current_settings().await?;

        Ok(())
    }

    /// Startet einen asynchronen Task, der auf `NovaEvent::GlobalSettingsChanged` wartet
    /// und die In-Memory-Einstellungen neu lädt, wenn ein solches Event empfangen wird.
    /// Dieser Task sollte einmalig von der Anwendungs-Initialisierung gestartet werden.
    pub async fn run_event_listener(mut self) {
        info!("GlobalSettingsService event listener started.");
        loop {
            match self.event_receiver_for_self.recv().await {
                Ok(NovaEvent::GlobalSettingsChanged) => {
                    info!("Received NovaEvent::GlobalSettingsChanged. Reloading global settings.");
                    if let Err(e) = self.load_current_settings().await {
                        error!("Failed to reload global settings after event: {}", e);
                    }
                }
                Ok(_) => {
                    // Ignoriere andere Events, die für diesen Service nicht relevant sind.
                    debug!("Received irrelevant NovaEvent in GlobalSettingsService listener.");
                }
                Err(e) => {
                    error!("Error receiving event in GlobalSettingsService: {}", e);
                    // Im Falle eines Empfangsfehlers (z.B. Sender geschlossen), beenden
                    break;
                }
            }
        }
        warn!("GlobalSettingsService event listener stopped.");
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io;
    use tempfile::tempdir;
    use crate::config::persistence::FilesystemConfigProvider;

    // A mock ConfigService for testing GlobalSettingsService
    struct MockConfigService {
        provider: Arc<dyn ConfigProvider>,
        event_sender: Arc<RwLock<broadcast::Sender<NovaEvent>>>,
    }

    impl MockConfigService {
        fn new(provider: Arc<dyn ConfigProvider>, event_sender: Arc<RwLock<broadcast::Sender<NovaEvent>>>) -> Self {
            Self { provider, event_sender }
        }

        async fn load_config<T: DeserializeOwned + Send + Sync + 'static>(&self, config_name: &str) -> Result<T, ConfigServiceError> {
            self.provider.load(config_name).await
        }

        async fn save_config<T: Serialize + Send + Sync + 'static>(&self, config_name: &str, config: &T) -> Result<(), ConfigServiceError> {
            self.provider.save(config_name, config).await?;
            self.event_sender.read().send(NovaEvent::GlobalSettingsChanged)
                .map_err(|e| ConfigServiceError::Generic(format!("Failed to broadcast config change event: {}", e)))?;
            Ok(())
        }
    }

    // Adapt ConfigProvider trait to make `MockConfigService` compatible with the `ConfigService` type hint
    // This is a bit of a workaround because `ConfigService` is a struct, not a trait.
    // In a real project, ConfigService itself might be an `Arc<dyn ConfigServiceTrait>`.
    // For now, we will create a helper struct that implements a trait if ConfigService was a trait.
    // But since it's a concrete struct, we'll just mock its methods directly for tests.
    // The previous tests used a `MockConfigProvider` to test `ConfigService`.
    // Here, we need to mock `ConfigService` itself, which requires either a trait for `ConfigService`
    // or passing closures/functions for its methods.
    // Given the current structure, we'll create a full `MockConfigService` that exposes the same async methods.

    #[tokio::test]
    async fn test_new_loads_existing_settings() {
        let temp_dir = tempdir().unwrap();
        let provider = Arc::new(FilesystemConfigProvider::new_with_base_dir(temp_dir.path().to_path_buf()));
        let (tx, _rx) = broadcast::channel(10);
        let event_sender_arc = Arc::new(RwLock::new(tx));
        let mock_config_service = Arc::new(MockConfigService::new(provider.clone(), event_sender_arc.clone()));

        // Save some initial settings
        let initial_settings = GlobalSettings {
            theme_name: "InitialTheme".to_string(),
            animation_speed: 0.2,
            ..Default::default()
        };
        mock_config_service.save_config(GLOBAL_SETTINGS_CONFIG_NAME, &initial_settings).await.unwrap();

        let settings_service = GlobalSettingsService::new(mock_config_service, event_sender_arc).await.unwrap();
        assert_eq!(settings_service.get_settings().theme_name, "InitialTheme");
        assert_eq!(settings_service.get_settings().animation_speed, 0.2);
    }

    #[tokio::test]
    async fn test_new_creates_and_saves_defaults_if_not_found() {
        let temp_dir = tempdir().unwrap();
        let provider = Arc::new(FilesystemConfigProvider::new_with_base_dir(temp_dir.path().to_path_buf()));
        let (tx, _rx) = broadcast::channel(10);
        let event_sender_arc = Arc::new(RwLock::new(tx));
        let mock_config_service = Arc::new(MockConfigService::new(provider.clone(), event_sender_arc.clone()));

        // No initial settings file

        let settings_service = GlobalSettingsService::new(mock_config_service.clone(), event_sender_arc).await.unwrap();
        // Should have default settings
        assert_eq!(settings_service.get_settings(), GlobalSettings::default());

        // Verify that default settings were saved to disk
        let loaded_from_disk: GlobalSettings = provider.load(GLOBAL_SETTINGS_CONFIG_NAME).await.unwrap();
        assert_eq!(loaded_from_disk, GlobalSettings::default());
    }

    #[tokio::test]
    async fn test_get_settings() {
        let temp_dir = tempdir().unwrap();
        let provider = Arc::new(FilesystemConfigProvider::new_with_base_dir(temp_dir.path().to_path_buf()));
        let (tx, _rx) = broadcast::channel(10);
        let event_sender_arc = Arc::new(RwLock::new(tx));
        let mock_config_service = Arc::new(MockConfigService::new(provider.clone(), event_sender_arc.clone()));

        let settings_service = GlobalSettingsService::new(mock_config_service, event_sender_arc).await.unwrap();
        let current_settings = settings_service.get_settings();
        assert_eq!(current_settings.theme_name, "NovaDark"); // Default value
    }

    #[tokio::test]
    async fn test_update_settings_success_and_event() {
        let temp_dir = tempdir().unwrap();
        let provider = Arc::new(FilesystemConfigProvider::new_with_base_dir(temp_dir.path().to_path_buf()));
        let (tx, mut rx) = broadcast::channel(10);
        let event_sender_arc = Arc::new(RwLock::new(tx));
        let mock_config_service = Arc::new(MockConfigService::new(provider.clone(), event_sender_arc.clone()));

        let settings_service = GlobalSettingsService::new(mock_config_service.clone(), event_sender_arc).await.unwrap();

        // Update a setting
        settings_service.update_settings(|s| {
            s.theme_name = "NewTheme".to_string();
            s.animation_speed = 0.5;
            Ok(())
        }).await.unwrap();

        // Verify in-memory state updated
        assert_eq!(settings_service.get_settings().theme_name, "NewTheme");
        assert_eq!(settings_service.get_settings().animation_speed, 0.5);

        // Verify persisted state updated
        let loaded_from_disk: GlobalSettings = provider.load(GLOBAL_SETTINGS_CONFIG_NAME).await.unwrap();
        assert_eq!(loaded_from_disk.theme_name, "NewTheme");
        assert_eq!(loaded_from_disk.animation_speed, 0.5);

        // Verify event was broadcast
        let received_event = time::timeout(Duration::from_millis(100), rx.recv()).await;
        assert!(received_event.is_ok());
        assert_eq!(received_event.unwrap().unwrap(), NovaEvent::GlobalSettingsChanged);
    }

    #[tokio::test]
    async fn test_update_settings_modifier_failure() {
        let temp_dir = tempdir().unwrap();
        let provider = Arc::new(FilesystemConfigProvider::new_with_base_dir(temp_dir.path().to_path_buf()));
        let (tx, _rx) = broadcast::channel(10);
        let event_sender_arc = Arc::new(RwLock::new(tx));
        let mock_config_service = Arc::new(MockConfigService::new(provider.clone(), event_sender_arc.clone()));

        let settings_service = GlobalSettingsService::new(mock_config_service.clone(), event_sender_arc).await.unwrap();

        let initial_theme = settings_service.get_settings().theme_name.clone();

        // Try to update with a modifier that returns an error
        let result = settings_service.update_settings(|_s| {
            Err(SettingsServiceError::InvalidValue {
                name: "test_setting".to_string(),
                message: "invalid logic".to_string(),
            })
        }).await;

        assert!(matches!(result, Err(SettingsServiceError::InvalidValue { .. })));
        // Ensure settings were NOT saved and original state is preserved
        assert_eq!(settings_service.get_settings().theme_name, initial_theme);
        // Also check disk, which should not have been touched either
        let loaded_from_disk: GlobalSettings = provider.load(GLOBAL_SETTINGS_CONFIG_NAME).await.unwrap();
        assert_eq!(loaded_from_disk.theme_name, initial_theme);
    }

    #[tokio::test]
    async fn test_event_listener_reloads_on_config_changed() {
        let temp_dir = tempdir().unwrap();
        let provider = Arc::new(FilesystemConfigProvider::new_with_base_dir(temp_dir.path().to_path_buf()));
        let (tx, _rx) = broadcast::channel(10);
        let event_sender_arc = Arc::new(RwLock::new(tx));
        let mock_config_service = Arc::new(MockConfigService::new(provider.clone(), event_sender_arc.clone()));

        let settings_service = GlobalSettingsService::new(mock_config_service.clone(), event_sender_arc.clone()).await.unwrap();

        let settings_service_for_listener = GlobalSettingsService::new(mock_config_service.clone(), event_sender_arc.clone()).await.unwrap();

        // Start the event listener in a separate task
        tokio::spawn(settings_service_for_listener.run_event_listener());

        // Initial settings should be default
        assert_eq!(settings_service.get_settings().theme_name, "NovaDark");

        // Simulate an external change (e.g., another process writes the config file)
        // We'll update the mock_config_service directly and then manually trigger an event.
        // First, directly save new settings to the provider (simulating external write)
        let external_settings = GlobalSettings {
            theme_name: "ExternalTheme".to_string(),
            animation_speed: 0.1,
            ..Default::default()
        };
        // This is a direct save via the underlying provider, bypassing `mock_config_service.save_config`'s event send
        // because we want to simulate an *external* change followed by our own event broadcast.
        // In a real scenario, this would be an actual file write that we'd detect.
        provider.save(GLOBAL_SETTINGS_CONFIG_NAME, &external_settings).await.unwrap();

        // Manually send the event to trigger reload
        event_sender_arc.read().send(NovaEvent::GlobalSettingsChanged).unwrap();

        // Give the listener a moment to process the event
        time::sleep(Duration::from_millis(50)).await;

        // Verify in-memory state of the original service (which has the listener) is updated
        assert_eq!(settings_service.get_settings().theme_name, "ExternalTheme");
        assert_eq!(settings_service.get_settings().animation_speed, 0.1);
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser vierte Teil (4 von 100) widmet sich der Fortführung der Spezifikation der Domänenschicht, insbesondere dem `application_management`-Modul, das für die Verwaltung von installierten Anwendungen, deren Metadaten und Startmechanismen zuständig ist.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 4/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.10. `novade-domain/src/application_management/mod.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/application_management/mod.rs`
  * **Verantwortlichkeit:** Dieses Modul aggregiert alle Komponenten des Anwendungsmanagements. Es re-exportiert die spezifischeren Komponenten (`data_types`, `service`, `errors`, `discovery`).
  * **Kern-Aufgaben (Tasks):**
    1.  **Re-Exporte definieren:** Die `pub use` Anweisungen für alle öffentlichen Komponenten der Untermodule festlegen.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/application_management/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_domain::application_management::data_types`, `novade_domain::application_management::service`, `novade_domain::application_management::errors`, `novade_domain::application_management::discovery`.
  * **Kommunikationsmuster:** Stellt eine konsolidierte API für Anwendungsmanagement-Funktionalität bereit.
  * **Erwartete Ergebnisse/Outputs:** Alle Anwendungsmanagement-bezogenen Services, Typen und Fehler sind über `novade_domain::application_management::*` zugänglich.
  * **Teststrategie (Modul-spezifisch):** Sicherstellen, dass alle Re-Exporte korrekt funktionieren.

<!-- end list -->

```rust
// novade-domain/src/application_management/mod.rs

pub mod data_types;
pub mod discovery;
pub mod service;
pub mod errors;

// Re-export public APIs from sub-modules
pub use data_types::*;
pub use discovery::*;
pub use service::*;
pub use errors::*;
```

### 3.11. `novade-domain/src/application_management/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/application_management/errors.rs`
  * **Verantwortlichkeit:** Definiert spezifische Fehlertypen für das Anwendungsmanagement innerhalb der Domänenschicht. Diese Fehler sollten die `novade_core::error::CoreError::Application` Variante erweitern.
  * **Kern-Aufgaben (Tasks):**
    1.  **`ApplicationServiceError` Enum definieren:** Spezifische Fehlertypen für den Anwendungsdienst (z.B. `ApplicationNotFound`, `LaunchFailed`, `InvalidDesktopFile`, `DiscoveryError`, `PersistenceError`).
    2.  **`thiserror` Implementierung:** Nutzen der `thiserror`-Crate für automatische `Display` und `Error` Trait-Implementierungen.
    3.  **`From` Trait-Implementierungen:** Konvertierungen von `novade_core::error::IoError` (für Dateizugriff), `ConfigServiceError` (für Caching/Persistenz) in `ApplicationServiceError`.
    4.  **Konvertierung zu `novade_core::error::CoreError`:** Implementierung von `From<ApplicationServiceError> for CoreError`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/application_management/errors.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_core::error`, `crate::config::errors`.
      * **Extern:** `thiserror`.
  * **Kommunikationsmuster:** Fehler werden als `Result<T, E>`-Typen zurückgegeben und können über den `?`-Operator propagiert werden.
  * **Erwartete Ergebnisse/Outputs:** Eine klare, domänenspezifische Fehlerbehandlung für Anwendungsoperationen, die sich nahtlos in die `CoreError`-Hierarchie integriert.
  * **Teststrategie (Modul-spezifisch):**
      * Unit Tests für jede `ApplicationServiceError`-Variante.
      * Testen der `Display`-Implementierung.
      * Testen der Konvertierung von `IoError` und `ConfigServiceError` in `ApplicationServiceError`.
      * Testen der Konvertierung von `ApplicationServiceError` in `CoreError`.

#### Funktionsspezifikation: `novade_domain::application_management::errors::ApplicationServiceError`

```rust
// novade-domain/src/application_management/errors.rs

use thiserror::Error;
use novade_core::error::{CoreError, IoError, ConfigError, ApplicationError};
use crate::config::errors::ConfigServiceError; // Abhängigkeit zur Konfigurationsfehler-Crate

/// Spezifische Fehlertypen für das Anwendungsmanagement der Domänenschicht.
#[derive(Debug, Error)]
pub enum ApplicationServiceError {
    /// Die angeforderte Anwendung wurde nicht gefunden.
    #[error("Application '{id}' not found")]
    ApplicationNotFound { id: String },

    /// Das Starten der Anwendung ist fehlgeschlagen.
    #[error("Failed to launch application '{id}': {source}")]
    LaunchFailed {
        id: String,
        #[source]
        source: IoError, // Kann auch ein anderer Fehlertyp sein, z.B. `CommandError`
    },

    /// Die Desktop-Datei ist ungültig oder kann nicht geparst werden.
    #[error("Invalid desktop file for application '{path}': {source}")]
    InvalidDesktopFile {
        path: String,
        #[source]
        source: String, // Detailliertere Fehlermeldung vom Parsing
    },

    /// Fehler während des Anwendungssuchprozesses.
    #[error("Application discovery failed: {0}")]
    DiscoveryError(String),

    /// Fehler bei der Persistenz von Anwendungsdaten (z.B. Cache).
    #[error("Persistence error: {0}")]
    PersistenceError(#[from] ConfigServiceError),

    /// Ein generischer Fehler im Anwendungsdienst.
    #[error("A generic application service error occurred: {0}")]
    Generic(String),
}

// Konvertierung von `ApplicationServiceError` zu `CoreError`
impl From<ApplicationServiceError> for CoreError {
    fn from(err: ApplicationServiceError) -> Self {
        CoreError::Application(match err {
            ApplicationServiceError::ApplicationNotFound { id } => ApplicationError::NotFound { id },
            ApplicationServiceError::LaunchFailed { id, source } => {
                ApplicationError::LaunchFailed {
                    id,
                    source: Box::new(CoreError::Io(source)),
                }
            }
            ApplicationServiceError::InvalidDesktopFile { path, source } => {
                ApplicationError::InvalidApplicationData { path, source }
            }
            ApplicationServiceError::DiscoveryError(msg) => ApplicationError::DiscoveryFailed(msg),
            ApplicationServiceError::PersistenceError(config_err) => {
                // Konvertiere ConfigServiceError zu CoreError::Config und verpacke es dann
                ApplicationError::Generic(format!("Persistence error: {}", CoreError::from(config_err)))
            }
            ApplicationServiceError::Generic(msg) => ApplicationError::Generic(msg),
        })
    }
}

// Konvertierung von `IoError` zu `ApplicationServiceError`
// Dies ist nützlich, wenn I/O-Operationen direkt im App-Service fehlschlagen,
// und wir sie in einen spezifischen LaunchFailed-Fehler umwandeln wollen.
impl From<IoError> for ApplicationServiceError {
    fn from(err: IoError) -> Self {
        ApplicationServiceError::LaunchFailed {
            id: "unknown".to_string(), // Kann später genauer gesetzt werden, wenn Kontext verfügbar
            source: err,
        }
    }
}

// Konvertierung von `ConfigServiceError` zu `ApplicationServiceError` (bereits durch #[from] im Enum abgedeckt)
// impl From<ConfigServiceError> for ApplicationServiceError {
//     fn from(err: ConfigServiceError) -> Self {
//         ApplicationServiceError::PersistenceError(err)
//     }
// }


#[cfg(test)]
mod tests {
    use super::*;
    use std::io::{self, ErrorKind};

    #[test]
    fn test_application_not_found_error() {
        let err = ApplicationServiceError::ApplicationNotFound { id: "firefox".to_string() };
        assert_eq!(err.to_string(), "Application 'firefox' not found");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Application(ApplicationError::NotFound { id }) if id == "firefox"));
    }

    #[test]
    fn test_launch_failed_error() {
        let io_err = IoError::Generic(io::Error::new(ErrorKind::PermissionDenied, "Permission denied").into());
        let err = ApplicationServiceError::LaunchFailed {
            id: "thunderbird".to_string(),
            source: io_err.clone(),
        };
        assert_eq!(err.to_string(), "Failed to launch application 'thunderbird': generic I/O error: Permission denied");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Application(ApplicationError::LaunchFailed { id, source }) if id == "thunderbird" && format!("{:?}", source).contains("PermissionDenied")));
    }

    #[test]
    fn test_invalid_desktop_file_error() {
        let err = ApplicationServiceError::InvalidDesktopFile {
            path: "/usr/share/applications/invalid.desktop".to_string(),
            source: "Missing [Desktop Entry] header".to_string(),
        };
        assert_eq!(err.to_string(), "Invalid desktop file for application '/usr/share/applications/invalid.desktop': Missing [Desktop Entry] header");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Application(ApplicationError::InvalidApplicationData { path, source }) if path == "/usr/share/applications/invalid.desktop" && source == "Missing [Desktop Entry] header"));
    }

    #[test]
    fn test_discovery_error() {
        let err = ApplicationServiceError::DiscoveryError("Failed to read XDG directories".to_string());
        assert_eq!(err.to_string(), "Application discovery failed: Failed to read XDG directories");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Application(ApplicationError::DiscoveryFailed(msg)) if msg == "Failed to read XDG directories"));
    }

    #[test]
    fn test_persistence_error_conversion() {
        let config_err = ConfigServiceError::ReadError(io::Error::new(ErrorKind::BrokenPipe, "Pipe broken"));
        let err: ApplicationServiceError = config_err.into();
        assert_eq!(err.to_string(), "Persistence error: Failed to read configuration: Pipe broken");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Application(ApplicationError::Generic(_))));
        assert!(core_err.to_string().contains("Persistence error: Failed to read configuration: Pipe broken"));
    }

    #[test]
    fn test_generic_error() {
        let err = ApplicationServiceError::Generic("Something unexpected happened".to_string());
        assert_eq!(err.to_string(), "A generic application service error occurred: Something unexpected happened");
        let core_err: CoreError = err.into();
        assert!(matches!(core_err, CoreError::Application(ApplicationError::Generic(msg)) if msg == "Something unexpected happened"));
    }

    #[test]
    fn test_io_error_into_application_service_error() {
        let io_err = IoError::NotFound(io::Error::new(ErrorKind::NotFound, "File not found").into());
        let app_err: ApplicationServiceError = io_err.into();
        assert!(matches!(app_err, ApplicationServiceError::LaunchFailed { id, source } if id == "unknown" && matches!(source, IoError::NotFound(_))));
    }
}
```

### 3.12. `novade-domain/src/application_management/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/application_management/data_types.rs`
  * **Verantwortlichkeit:** Definiert die Datenstrukturen zur Repräsentation von Anwendungen und deren Metadaten, basierend auf dem XDG Desktop Entry Specification. Dies umfasst Informationen wie Name, Beschreibung, Icon, Ausführungsbefehl, etc.
  * **Kern-Aufgaben (Tasks):**
    1.  **`ApplicationEntry` Struct definieren:**
          * Repräsentiert die Metadaten einer Desktop-Anwendung.
          * Felder: `id: String` (Desktop-Datei-Name), `name: String`, `generic_name: Option<String>`, `comment: Option<String>`, `icon: Option<String>`, `exec: String`, `terminal: bool`, `categories: Vec<String>`, `mime_types: Vec<String>`, `keywords: Vec<String>`, `no_display: bool`, `hidden: bool`, `startup_notify: bool`, `startup_wm_class: Option<String>`, `only_show_in: Vec<String>`, `not_show_in: Vec<String>`, `actions: Vec<ApplicationAction>`.
          * Muss `serde::Serialize` und `serde::Deserialize` implementieren (für Caching).
          * `Clone`, `PartialEq`, `Eq`, `Hash` für Sammlungen und Vergleiche.
    2.  **`ApplicationAction` Struct definieren:**
          * Repräsentiert eine zusätzliche Aktion, die in einer Desktop-Datei definiert ist (z.B. "Neues Fenster öffnen").
          * Felder: `id: String`, `name: String`, `exec: String`.
          * Muss `serde::Serialize` und `serde::Deserialize` implementieren.
          * `Clone`, `PartialEq`, `Eq`, `Hash`.
    3.  **Dokumentation:** Jedes Feld sollte klar dokumentiert sein und seine Entsprechung in der XDG-Spezifikation (falls vorhanden) angeben.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/application_management/data_types.rs`
  * **Abhängigkeiten:**
      * **Extern:** `serde`, `serde_derive`.
  * **Kommunikationsmuster:** Werden vom `ApplicationDiscoveryService` erstellt und vom `ApplicationService` verwaltet und bereitgestellt.
  * **Erwartete Ergebnisse/Outputs:** Typ-sichere, serialisierbare Datenstrukturen für die detaillierte Repräsentation von Desktop-Anwendungen.
  * **Teststrategie (Modul-spezifisch):**
      * Unit Tests für die Standardwerte (falls zutreffend).
      * Tests für Serialisierung und Deserialisierung.
      * Tests für `PartialEq`, `Eq`, `Hash`.

#### Funktionsspezifikation: `novade_domain::application_management::data_types::ApplicationEntry`

```rust
// novade-domain/src/application_management/data_types.rs

use serde::{Deserialize, Serialize};
use std::collections::HashSet; // Für effiziente Prüfungen von Kategorien, etc.
use std::hash::{Hash, Hasher};

/// Repräsentiert eine zusätzliche Aktion, die in einer Desktop-Datei definiert ist.
/// Entspricht dem [Desktop Action <ID>] Block in einer .desktop-Datei.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct ApplicationAction {
    /// Die eindeutige ID der Aktion (z.B. "NewWindow").
    pub id: String,
    /// Der angezeigte Name der Aktion.
    pub name: String,
    /// Der Befehl, der ausgeführt werden soll, wenn diese Aktion gewählt wird.
    pub exec: String,
}

impl Hash for ApplicationAction {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.id.hash(state);
        self.name.hash(state);
        self.exec.hash(state);
    }
}

/// Repräsentiert eine Desktop-Anwendung basierend auf der XDG Desktop Entry Specification.
/// Diese Struktur aggregiert alle relevanten Metadaten, die aus einer .desktop-Datei gelesen werden.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct ApplicationEntry {
    /// Die eindeutige ID der Anwendung, typischerweise der Dateiname der .desktop-Datei ohne Endung.
    pub id: String,
    /// Der angezeigte Name der Anwendung (entspricht 'Name=').
    pub name: String,
    /// Ein generischer Name der Anwendung (entspricht 'GenericName=', optional).
    #[serde(default)]
    pub generic_name: Option<String>,
    /// Ein Kommentar oder eine kurze Beschreibung der Anwendung (entspricht 'Comment=', optional).
    #[serde(default)]
    pub comment: Option<String>,
    /// Der Name oder Pfad des Icons (entspricht 'Icon=', optional).
    #[serde(default)]
    pub icon: Option<String>,
    /// Der Befehl, der ausgeführt werden soll, um die Anwendung zu starten (entspricht 'Exec=').
    pub exec: String,
    /// Gibt an, ob die Anwendung in einem Terminal gestartet werden soll (entspricht 'Terminal=', Standard: false).
    #[serde(default = "default_false")]
    pub terminal: bool,
    /// Eine Liste von Kategorien, zu denen die Anwendung gehört (entspricht 'Categories=', z.B. "Utility;Network;").
    #[serde(default)]
    pub categories: Vec<String>,
    /// Eine Liste von MIME-Typen, die die Anwendung handhaben kann (entspricht 'MimeType=').
    #[serde(default)]
    pub mime_types: Vec<String>,
    /// Eine Liste von Schlüsselwörtern zur Suche der Anwendung (entspricht 'Keywords=').
    #[serde(default)]
    pub keywords: Vec<String>,
    /// Gibt an, ob die Anwendung in Menüs angezeigt werden soll (entspricht 'NoDisplay=', Standard: false).
    #[serde(default = "default_false")]
    pub no_display: bool,
    /// Gibt an, ob die Anwendung versteckt ist (entspricht 'Hidden=', Standard: false).
    #[serde(default = "default_false")]
    pub hidden: bool,
    /// Gibt an, ob ein Startbenachrichtigungssystem verwendet werden soll (entspricht 'StartupNotify=', Standard: true).
    #[serde(default = "default_true")]
    pub startup_notify: bool,
    /// Die WM_CLASS, die für die Fensterverwaltung verwendet wird (entspricht 'StartupWMClass=', optional).
    #[serde(default)]
    pub startup_wm_class: Option<String>,
    /// Liste von Desktop-Umgebungen, in denen die Anwendung nur angezeigt werden soll (entspricht 'OnlyShowIn=').
    #[serde(default)]
    pub only_show_in: Vec<String>,
    /// Liste von Desktop-Umgebungen, in denen die Anwendung nicht angezeigt werden soll (entspricht 'NotShowIn=').
    #[serde(default)]
    pub not_show_in: Vec<String>,
    /// Eine Liste zusätzlicher Aktionen, die mit der Anwendung verknüpft sind.
    #[serde(default)]
    pub actions: Vec<ApplicationAction>,
    /// Der absolute Pfad zur .desktop-Datei, aus der diese Informationen gelesen wurden.
    pub desktop_file_path: String,
    /// Zuletzt aufgerufenes Datum/Zeit, für MRU-Listen.
    #[serde(default)]
    pub last_launched: Option<chrono::DateTime<chrono::Utc>>,
    /// Anzahl der Starts, für Popularitäts-Ranking.
    #[serde(default)]
    pub launch_count: u32,
}

// Hilfsfunktionen für Standardwerte
fn default_false() -> bool { false }
fn default_true() -> bool { true }

impl Hash for ApplicationEntry {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.id.hash(state);
        // Andere Felder können gehasht werden, um einen umfassenderen Hash zu erhalten.
        // Für Performance-Kritikalität könnte man sich auf `id` beschränken,
        // da es eindeutig sein sollte. Aber für `Eq` und `PartialEq` sind alle relevant.
        self.name.hash(state);
        self.exec.hash(state);
        self.desktop_file_path.hash(state);
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;
    use std::collections::hash_map::DefaultHasher;

    fn calculate_hash<T: Hash>(t: &T) -> u64 {
        let mut s = DefaultHasher::new();
        t.hash(&mut s);
        s.finish()
    }

    #[test]
    fn test_application_action_serialization_deserialization() {
        let action = ApplicationAction {
            id: "new-window".to_string(),
            name: "New Window".to_string(),
            exec: "firefox --new-window".to_string(),
        };
        let serialized = serde_json::to_string(&action).unwrap();
        let deserialized: ApplicationAction = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, action);
    }

    #[test]
    fn test_application_entry_serialization_deserialization() {
        let now = Utc::now();
        let app_entry = ApplicationEntry {
            id: "org.gnome.Terminal.desktop".to_string(),
            name: "Terminal".to_string(),
            generic_name: Some("Command Line Interface".to_string()),
            comment: Some("Access the command line".to_string()),
            icon: Some("utilities-terminal".to_string()),
            exec: "gnome-terminal".to_string(),
            terminal: true,
            categories: vec!["System;Utility;".to_string()],
            mime_types: vec!["text/plain".to_string()],
            keywords: vec!["cli".to_string(), "shell".to_string()],
            no_display: false,
            hidden: false,
            startup_notify: true,
            startup_wm_class: Some("Gnome-terminal".to_string()),
            only_show_in: vec![],
            not_show_in: vec!["KDE;".to_string()],
            actions: vec![
                ApplicationAction {
                    id: "new-tab".to_string(),
                    name: "New Tab".to_string(),
                    exec: "gnome-terminal --tab".to_string(),
                },
            ],
            desktop_file_path: "/usr/share/applications/org.gnome.Terminal.desktop".to_string(),
            last_launched: Some(now),
            launch_count: 5,
        };

        let serialized = serde_json::to_string(&app_entry).unwrap();
        let deserialized: ApplicationEntry = serde_json::from_str(&serialized).unwrap();

        assert_eq!(deserialized.id, app_entry.id);
        assert_eq!(deserialized.name, app_entry.name);
        assert_eq!(deserialized.generic_name, app_entry.generic_name);
        assert_eq!(deserialized.comment, app_entry.comment);
        assert_eq!(deserialized.icon, app_entry.icon);
        assert_eq!(deserialized.exec, app_entry.exec);
        assert_eq!(deserialized.terminal, app_entry.terminal);
        assert_eq!(deserialized.categories, app_entry.categories);
        assert_eq!(deserialized.mime_types, app_entry.mime_types);
        assert_eq!(deserialized.keywords, app_entry.keywords);
        assert_eq!(deserialized.no_display, app_entry.no_display);
        assert_eq!(deserialized.hidden, app_entry.hidden);
        assert_eq!(deserialized.startup_notify, app_entry.startup_notify);
        assert_eq!(deserialized.startup_wm_class, app_entry.startup_wm_class);
        assert_eq!(deserialized.only_show_in, app_entry.only_show_in);
        assert_eq!(deserialized.not_show_in, app_entry.not_show_in);
        assert_eq!(deserialized.actions, app_entry.actions);
        assert_eq!(deserialized.desktop_file_path, app_entry.desktop_file_path);
        // chrono::DateTime has nanosecond precision, which can cause issues with PartialEq after serialization.
        // Compare string representations or check within a tolerance if needed, for this test direct equality is fine for simplicity.
        assert_eq!(deserialized.last_launched.map(|dt| dt.timestamp()), app_entry.last_launched.map(|dt| dt.timestamp()));
        assert_eq!(deserialized.launch_count, app_entry.launch_count);

        // Test full equality
        assert_eq!(deserialized, app_entry);
    }

    #[test]
    fn test_application_entry_default_values_on_deserialization() {
        let json_data = r#"
            {
                "id": "test.desktop",
                "name": "Test App",
                "exec": "test-app-command",
                "desktop_file_path": "/tmp/test.desktop"
            }
        "#;
        let app_entry: ApplicationEntry = serde_json::from_str(json_data).unwrap();

        assert_eq!(app_entry.id, "test.desktop");
        assert_eq!(app_entry.name, "Test App");
        assert_eq!(app_entry.exec, "test-app-command");
        assert_eq!(app_entry.desktop_file_path, "/tmp/test.desktop");

        // Check default values for fields not present in JSON
        assert_eq!(app_entry.generic_name, None);
        assert_eq!(app_entry.comment, None);
        assert_eq!(app_entry.icon, None);
        assert_eq!(app_entry.terminal, false);
        assert!(app_entry.categories.is_empty());
        assert!(app_entry.mime_types.is_empty());
        assert!(app_entry.keywords.is_empty());
        assert_eq!(app_entry.no_display, false);
        assert_eq!(app_entry.hidden, false);
        assert_eq!(app_entry.startup_notify, true); // Default is true
        assert_eq!(app_entry.startup_wm_class, None);
        assert!(app_entry.only_show_in.is_empty());
        assert!(app_entry.not_show_in.is_empty());
        assert!(app_entry.actions.is_empty());
        assert_eq!(app_entry.last_launched, None);
        assert_eq!(app_entry.launch_count, 0);
    }

    #[test]
    fn test_application_entry_hash() {
        let app1 = ApplicationEntry {
            id: "app1".to_string(),
            name: "App One".to_string(),
            exec: "cmd1".to_string(),
            desktop_file_path: "/path/to/app1.desktop".to_string(),
            ..Default::default()
        };
        let app2 = ApplicationEntry {
            id: "app1".to_string(),
            name: "App One".to_string(),
            exec: "cmd1".to_string(),
            desktop_file_path: "/path/to/app1.desktop".to_string(),
            ..Default::default()
        };
        let app3 = ApplicationEntry {
            id: "app2".to_string(), // Different ID
            name: "App Two".to_string(),
            exec: "cmd2".to_string(),
            desktop_file_path: "/path/to/app2.desktop".to_string(),
            ..Default::default()
        };

        assert_eq!(calculate_hash(&app1), calculate_hash(&app2));
        assert_ne!(calculate_hash(&app1), calculate_hash(&app3));
    }
}
```

### 3.13. `novade-domain/src/application_management/discovery.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/application_management/discovery.rs`
  * **Verantwortlichkeit:** Implementiert die Logik zum Scannen und Parsen von XDG Desktop Entry-Dateien (`.desktop`) in den XDG-Standardverzeichnissen (z.B. `/usr/share/applications/`, `~/.local/share/applications/`). Dieser Dienst ist für die Initialisierung des Anwendungs-Caches verantwortlich.
  * **Kern-Aufgaben (Tasks):**
    1.  **`ApplicationDiscoveryService` Struct definieren:**
          * Kann optional einen `Arc<ConfigService>` halten, um einen Cache der entdeckten Anwendungen zu persistieren.
          * Möglicherweise eine Methode zum Abrufen der relevanten XDG-Verzeichnisse (`get_xdg_data_dirs`).
    2.  **`discover_applications()` Methode implementieren:**
          * Asynchron: Scannt die `XDG_DATA_DIRS` und `XDG_DATA_HOME` nach `.desktop`-Dateien.
          * Paralleles Parsen der gefundenen `.desktop`-Dateien in `ApplicationEntry`-Objekte (z.B. mittels `walkdir` und `tokio::task::spawn_blocking`).
          * Filtert ungültige oder versteckte Einträge gemäß XDG-Spezifikation (`NoDisplay=true`, `Hidden=true`, `OnlyShowIn`/`NotShowIn` für NovaDE).
          * Behandelt Fehler beim Parsen einzelner Dateien, ohne den gesamten Prozess abzubrechen.
          * Gibt eine `Vec<ApplicationEntry>` zurück.
    3.  **`parse_desktop_file()` Hilfsmethode implementieren:**
          * Nimmt einen `PathBuf` entgegen.
          * Liest und parst die `.desktop`-Datei in ein `ApplicationEntry`-Objekt.
          * Verwendet eine geeignete Bibliothek zum Parsen von Desktop-Dateien (z.B. `xdg-desktop-entry` crate oder manuelle Implementierung basierend auf `ini`-crate).
          * Umfassende Fehlerbehandlung für ungültige Formate, fehlende Schlüssel etc.
    4.  **Optional: Caching-Mechanismus:** Wenn ein `ConfigService` vorhanden ist, speichert das Ergebnis der Entdeckung im Cache (`~/.cache/novade/applications.json`). Bei nachfolgenden Starts kann der Cache geladen werden, falls der Zeitstempel der Desktop-Verzeichnisse sich nicht geändert hat.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/application_management/discovery.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_domain::application_management::data_types`, `novade_domain::application_management::errors`, `novade_core::error`.
      * **Extern:** `tokio`, `tokio::fs`, `tokio::task`, `walkdir`, `xdg` (für XDG-Pfade), `ini` (falls `xdg-desktop-entry` nicht verwendet wird), `serde_json` (für Cache-Persistenz).
  * **Kommunikationsmuster:** Wird vom `ApplicationService` aufgerufen, um die Liste der Anwendungen zu initialisieren.
  * **Erwartete Ergebnisse/Outputs:** Eine aktuelle und gefilterte Liste aller installierten, gültigen Desktop-Anwendungen.
  * **Teststrategie (Modul-spezifisch):**
      * **Mocking:** Erstellen von temporären XDG-Verzeichnissen mit verschiedenen `.desktop`-Dateien (gültig, ungültig, versteckt, etc.).
      * Test `discover_applications()`: Korrektes Scannen, Parsen, Filtern.
      * Test `parse_desktop_file()`: Positive und negative Tests für verschiedene `.desktop`-Dateiformate.
      * Test des Caching-Mechanismus: Laden/Speichern, Cache-Invalidierung bei Verzeichnisänderungen.

#### Funktionsspezifikation: `novade_domain::application_management::discovery::ApplicationDiscoveryService`

```rust
// novade-domain/src/application_management/discovery.rs

use std::path::{Path, PathBuf};
use std::sync::Arc;
use tokio::fs;
use tokio::task;
use walkdir::WalkDir;
use tracing::{info, warn, error, debug};
use serde::{Serialize, Deserialize};
use xdg::BaseDirectories;
use std::collections::{HashMap, HashSet};
use chrono::{DateTime, Utc};

use crate::config::service::ConfigService;
use crate::application_management::data_types::{ApplicationEntry, ApplicationAction};
use crate::application_management::errors::ApplicationServiceError;
use novade_core::error::IoError; // Import CoreError for propagation

/// Cache-Dateiname für die entdeckten Anwendungen.
const APPLICATION_CACHE_FILE: &str = "applications.json";

/// Struktur für den Anwendungscache, der auf der Disk gespeichert wird.
#[derive(Debug, Clone, Serialize, Deserialize)]
struct ApplicationCache {
    /// Der Zeitpunkt des letzten Scans, um Cache-Invalidierung zu prüfen.
    last_scanned: DateTime<Utc>,
    /// Ein Hash der XDG-Datenverzeichnisse oder der Zeitstempel, um Änderungen zu erkennen.
    /// Eine einfache Heuristik ist die Änderungszeit des Verzeichnisses.
    /// Eine robustere Lösung wäre, Hashes der Inhalte zu speichern oder inode-Änderungen zu überwachen.
    /// Für den MVP verwenden wir eine Liste der Verzeichnisse mit ihrem letzten Änderungszeitpunkt.
    #[serde(default)]
    xdg_dirs_info: HashMap<PathBuf, DateTime<Utc>>,
    /// Die gecachten Anwendungs-Einträge.
    applications: Vec<ApplicationEntry>,
}

/// Dienst zum Entdecken und Parsen von Desktop-Anwendungen.
pub struct ApplicationDiscoveryService {
    config_service: Option<Arc<ConfigService>>, // Optional, falls kein Caching gewünscht ist
    base_dirs: Arc<BaseDirectories>, // Für den Zugriff auf XDG-Pfade
}

impl ApplicationDiscoveryService {
    /// Erstellt eine neue Instanz des `ApplicationDiscoveryService`.
    ///
    /// # Arguments
    /// * `config_service` - Ein optionaler `Arc` zu einem `ConfigService` für Caching-Operationen.
    pub fn new(config_service: Option<Arc<ConfigService>>) -> Result<Self, ApplicationServiceError> {
        let base_dirs = Arc::new(BaseDirectories::new()
            .map_err(|e| ApplicationServiceError::DiscoveryError(format!("Failed to initialize XDG BaseDirectories: {}", e)))?);
        Ok(Self { config_service, base_dirs })
    }

    /// Entdeckt alle Desktop-Anwendungen in den XDG-Standardverzeichnissen.
    /// Nutzt Caching, falls ein `ConfigService` konfiguriert ist.
    ///
    /// # Returns
    /// Ein `Result` mit einer Vektor von `ApplicationEntry`-Objekten bei Erfolg.
    pub async fn discover_applications(&self) -> Result<Vec<ApplicationEntry>, ApplicationServiceError> {
        info!("Starting application discovery...");

        let mut xdg_data_dirs = self.base_dirs.get_data_dirs();
        // Fügen Sie XDG_DATA_HOME hinzu, da `get_data_dirs` es oft nicht enthält,
        // aber .desktop-Dateien auch dort liegen können.
        if let Some(home_data) = self.base_dirs.get_data_home().to_str() {
            xdg_data_dirs.push(PathBuf::from(home_data));
        }
        xdg_data_dirs.dedup(); // Redundante Einträge entfernen

        let current_xdg_dirs_info = Self::get_xdg_dirs_timestamps(&xdg_data_dirs).await?;

        // Versuche, den Cache zu laden und zu validieren
        if let Some(config_service) = &self.config_service {
            match config_service.load_config::<ApplicationCache>(APPLICATION_CACHE_FILE).await {
                Ok(cache) if Self::is_cache_valid(&cache, &current_xdg_dirs_info).await => {
                    info!("Application cache found and is valid. Loading applications from cache.");
                    return Ok(cache.applications);
                }
                Ok(_) => {
                    warn!("Application cache found but is invalid or outdated. Performing full scan.");
                }
                Err(e) => {
                    debug!("Failed to load application cache ({:?}). Performing full scan.", e);
                }
            }
        }

        // Führe eine vollständige Erkennung durch
        let mut application_paths = Vec::new();
        for data_dir in &xdg_data_dirs {
            let app_dir = data_dir.join("applications");
            if app_dir.is_dir() {
                debug!("Scanning directory: {:?}", app_dir);
                for entry in WalkDir::new(&app_dir)
                    .max_depth(3) // Tiefenlimit, um zu tiefe Hierarchien zu vermeiden
                    .into_iter()
                    .filter_map(|e| e.ok())
                {
                    let path = entry.path();
                    if path.is_file() && path.extension().map_or(false, |ext| ext == "desktop") {
                        application_paths.push(path.to_path_buf());
                    }
                }
            }
        }

        let mut parsed_applications = Vec::new();
        let mut tasks = Vec::new();

        for path in application_paths {
            let path_clone = path.clone();
            tasks.push(task::spawn_blocking(move || {
                Self::parse_desktop_file(&path_clone)
            }));
        }

        for task in tasks {
            match task.await {
                Ok(Ok(app_entry)) => {
                    // Zusätzliche Filterung nach 'NoDisplay' und 'Hidden'
                    if !app_entry.no_display && !app_entry.hidden {
                        // Implementieren Sie hier auch die Logik für OnlyShowIn/NotShowIn
                        // Aktuell für NovaDE ist dieser Filter einfach.
                        let mut show = true;
                        if !app_entry.only_show_in.is_empty() {
                            let only_show_in_set: HashSet<String> = app_entry.only_show_in.iter().map(|s| s.trim().to_lowercase()).collect();
                            if !only_show_in_set.contains("novade") && !only_show_in_set.contains("novade;") { // Fallback for common errors
                                show = false;
                            }
                        }
                        if show && !app_entry.not_show_in.is_empty() {
                            let not_show_in_set: HashSet<String> = app_entry.not_show_in.iter().map(|s| s.trim().to_lowercase()).collect();
                            if not_show_in_set.contains("novade") || not_show_in_set.contains("novade;") {
                                show = false;
                            }
                        }

                        if show {
                            parsed_applications.push(app_entry);
                        } else {
                            debug!("Skipping application due to OnlyShowIn/NotShowIn or NoDisplay/Hidden: {:?}", path);
                        }
                    } else {
                        debug!("Skipping application due to NoDisplay or Hidden: {:?}", path);
                    }
                }
                Ok(Err(e)) => {
                    warn!("Failed to parse desktop file: {}", e);
                }
                Err(e) => {
                    error!("Task for desktop file parsing failed: {}", e);
                }
            }
        }

        info!("Finished application discovery. Found {} applications.", parsed_applications.len());

        // Cache speichern, falls konfiguriert
        if let Some(config_service) = &self.config_service {
            let new_cache = ApplicationCache {
                last_scanned: Utc::now(),
                xdg_dirs_info: current_xdg_dirs_info,
                applications: parsed_applications.clone(),
            };
            if let Err(e) = config_service.save_config(APPLICATION_CACHE_FILE, &new_cache).await {
                error!("Failed to save application cache: {}", e);
            }
        }

        Ok(parsed_applications)
    }

    /// Parst eine einzelne .desktop-Datei und gibt ein `ApplicationEntry` zurück.
    /// Diese Funktion ist synchron und sollte in einem `spawn_blocking` Task aufgerufen werden.
    fn parse_desktop_file(path: &Path) -> Result<ApplicationEntry, ApplicationServiceError> {
        let content = std::fs::read_to_string(path)
            .map_err(|e| ApplicationServiceError::InvalidDesktopFile {
                path: path.display().to_string(),
                source: format!("Failed to read file: {}", e),
            })?;

        let ini = ini::Ini::read_from_string(&content)
            .map_err(|e| ApplicationServiceError::InvalidDesktopFile {
                path: path.display().to_string(),
                source: format!("Failed to parse INI format: {}", e),
            })?;

        let desktop_entry_section = ini.section(Some("Desktop Entry".to_string()))
            .ok_or_else(|| ApplicationServiceError::InvalidDesktopFile {
                path: path.display().to_string(),
                source: "Missing [Desktop Entry] section".to_string(),
            })?;

        let id = path.file_name()
            .and_then(|name| name.to_str())
            .map(|s| s.trim_end_matches(".desktop").to_string())
            .unwrap_or_else(|| "unknown_app".to_string());

        let name = desktop_entry_section.get("Name")
            .ok_or_else(|| ApplicationServiceError::InvalidDesktopFile {
                path: path.display().to_string(),
                source: "Missing 'Name' field".to_string(),
            })?.to_string();

        let exec = desktop_entry_section.get("Exec")
            .ok_or_else(|| ApplicationServiceError::InvalidDesktopFile {
                path: path.display().to_string(),
                source: "Missing 'Exec' field".to_string(),
            })?.to_string();

        let generic_name = desktop_entry_section.get("GenericName").map(|s| s.to_string());
        let comment = desktop_entry_section.get("Comment").map(|s| s.to_string());
        let icon = desktop_entry_section.get("Icon").map(|s| s.to_string());
        let terminal = desktop_entry_section.get("Terminal").map_or(false, |s| s == "true");
        let no_display = desktop_entry_section.get("NoDisplay").map_or(false, |s| s == "true");
        let hidden = desktop_entry_section.get("Hidden").map_or(false, |s| s == "true");
        let startup_notify = desktop_entry_section.get("StartupNotify").map_or(true, |s| s == "true");
        let startup_wm_class = desktop_entry_section.get("StartupWMClass").map(|s| s.to_string());

        let parse_list = |key: &str| {
            desktop_entry_section.get(key)
                .map(|s| s.split(';').filter(|&part| !part.is_empty()).map(|part| part.to_string()).collect())
                .unwrap_or_else(Vec::new)
        };

        let categories = parse_list("Categories");
        let mime_types = parse_list("MimeType");
        let keywords = parse_list("Keywords");
        let only_show_in = parse_list("OnlyShowIn");
        let not_show_in = parse_list("NotShowIn");

        let mut actions = Vec::new();
        if let Some(actions_str) = desktop_entry_section.get("Actions") {
            for action_id in actions_str.split(';').filter(|&id| !id.is_empty()) {
                let action_section_name = format!("Desktop Action {}", action_id);
                if let Some(action_section) = ini.section(Some(action_section_name.clone())) {
                    if let (Some(action_name), Some(action_exec)) = (action_section.get("Name"), action_section.get("Exec")) {
                        actions.push(ApplicationAction {
                            id: action_id.to_string(),
                            name: action_name.to_string(),
                            exec: action_exec.to_string(),
                        });
                    } else {
                        warn!("Missing 'Name' or 'Exec' for action '{}' in desktop file: {:?}", action_id, path);
                    }
                } else {
                    warn!("Missing section for action '{}' in desktop file: {:?}", action_id, path);
                }
            }
        }

        Ok(ApplicationEntry {
            id,
            name,
            generic_name,
            comment,
            icon,
            exec,
            terminal,
            categories,
            mime_types,
            keywords,
            no_display,
            hidden,
            startup_notify,
            startup_wm_class,
            only_show_in,
            not_show_in,
            actions,
            desktop_file_path: path.display().to_string(),
            last_launched: None, // Not parsed from .desktop, managed by ApplicationService
            launch_count: 0,    // Not parsed from .desktop, managed by ApplicationService
        })
    }

    /// Überprüft, ob der Cache noch gültig ist, indem die Änderungszeitpunkte der XDG-Verzeichnisse geprüft werden.
    ///
    /// # Arguments
    /// * `cache` - Die zu prüfende Cache-Instanz.
    /// * `current_xdg_dirs_info` - Eine Map der aktuellen XDG-Verzeichnisse mit ihren Änderungszeitpunkten.
    ///
    /// # Returns
    /// `true`, wenn der Cache gültig ist (keine Änderungen an den Verzeichnissen seit dem letzten Scan), ansonsten `false`.
    async fn is_cache_valid(cache: &ApplicationCache, current_xdg_dirs_info: &HashMap<PathBuf, DateTime<Utc>>) -> bool {
        // Prüfe, ob die Anzahl der Verzeichnisse übereinstimmt
        if cache.xdg_dirs_info.len() != current_xdg_dirs_info.len() {
            debug!("Cache invalid: Number of XDG directories changed.");
            return false;
        }

        // Prüfe, ob alle Verzeichnisse im Cache in den aktuellen Verzeichnissen sind und die Zeitstempel übereinstimmen
        for (path, cached_timestamp) in &cache.xdg_dirs_info {
            if let Some(current_timestamp) = current_xdg_dirs_info.get(path) {
                if cached_timestamp < current_timestamp {
                    debug!("Cache invalid: Directory {:?} has been modified (cached: {:?}, current: {:?}).", path, cached_timestamp, current_timestamp);
                    return false;
                }
            } else {
                debug!("Cache invalid: Directory {:?} not found in current XDG directories.", path);
                return false; // Verzeichnis im Cache existiert nicht mehr
            }
        }

        info!("Application cache is valid.");
        true
    }

    /// Sammelt die letzten Änderungszeitpunkte (mtime) der XDG-Datenverzeichnisse und ihrer "applications"-Unterverzeichnisse.
    async fn get_xdg_dirs_timestamps(xdg_data_dirs: &[PathBuf]) -> Result<HashMap<PathBuf, DateTime<Utc>>, ApplicationServiceError> {
        let mut dir_timestamps = HashMap::new();
        for data_dir in xdg_data_dirs {
            let app_dir = data_dir.join("applications");
            if app_dir.is_dir() {
                match fs::metadata(&app_dir).await {
                    Ok(metadata) => {
                        let mtime = metadata.modified()
                            .map_err(|e| IoError::Generic(e.into()))
                            .map_err(|e| ApplicationServiceError::DiscoveryError(format!("Failed to get modified time for {:?}: {}", app_dir, e)))?;
                        let datetime: DateTime<Utc> = mtime.into(); // Convert SystemTime to DateTime<Utc>
                        dir_timestamps.insert(app_dir, datetime);
                    }
                    Err(e) => {
                        warn!("Could not get metadata for XDG applications directory {:?}: {}", app_dir, e);
                    }
                }
            }
        }
        Ok(dir_timestamps)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;
    use tokio::io::AsyncWriteExt; // For writing to temp files
    use std::fs;
    use chrono::{Duration, Utc};
    use novade_core::error::CoreError; // For checking error conversion
    use crate::config::persistence::FilesystemConfigProvider;
    use crate::config::service::ConfigService;

    // Helper to create a temp .desktop file
    async fn create_desktop_file(dir: &Path, name: &str, content: &str) -> PathBuf {
        let path = dir.join(format!("{}.desktop", name));
        let mut file = fs::File::create(&path).unwrap(); // Use std::fs for blocking write
        file.write_all(content.as_bytes()).unwrap();
        path
    }

    // Helper to mock the XDG_DATA_DIRS environment variable
    fn set_xdg_data_dirs_env(paths: &[&Path]) {
        let path_str = paths.iter()
            .map(|p| p.to_str().unwrap())
            .collect::<Vec<_>>()
            .join(":");
        std::env::set_var("XDG_DATA_DIRS", path_str);
        // Also clear XDG_DATA_HOME to ensure it's not interfering for this specific test
        std::env::remove_var("XDG_DATA_HOME");
    }

    #[tokio::test]
    async fn test_discover_applications_basic() {
        let temp_dir = tempdir().unwrap();
        let app_dir = temp_dir.path().join("applications");
        fs::create_dir(&app_dir).unwrap();
        set_xdg_data_dirs_env(&[&temp_dir.path()]);

        create_desktop_file(&app_dir, "test_app", r#"
            [Desktop Entry]
            Name=Test Application
            Exec=test-app
            Type=Application
        "#).await;

        let discovery_service = ApplicationDiscoveryService::new(None).unwrap();
        let applications = discovery_service.discover_applications().await.unwrap();

        assert_eq!(applications.len(), 1);
        assert_eq!(applications[0].name, "Test Application");
        assert_eq!(applications[0].exec, "test-app");
        assert_eq!(applications[0].id, "test_app");
        assert_eq!(applications[0].desktop_file_path, app_dir.join("test_app.desktop").display().to_string());
    }

    #[tokio::test]
    async fn test_discover_applications_no_display_hidden() {
        let temp_dir = tempdir().unwrap();
        let app_dir = temp_dir.path().join("applications");
        fs::create_dir(&app_dir).unwrap();
        set_xdg_data_dirs_env(&[&temp_dir.path()]);

        create_desktop_file(&app_dir, "hidden_app", r#"
            [Desktop Entry]
            Name=Hidden App
            Exec=hidden-app
            Type=Application
            Hidden=true
        "#).await;
        create_desktop_file(&app_dir, "no_display_app", r#"
            [Desktop Entry]
            Name=No Display App
            Exec=no-display-app
            Type=Application
            NoDisplay=true
        "#).await;
        create_desktop_file(&app_dir, "visible_app", r#"
            [Desktop Entry]
            Name=Visible App
            Exec=visible-app
            Type=Application
        "#).await;

        let discovery_service = ApplicationDiscoveryService::new(None).unwrap();
        let applications = discovery_service.discover_applications().await.unwrap();

        assert_eq!(applications.len(), 1);
        assert_eq!(applications[0].name, "Visible App");
    }

    #[tokio::test]
    async fn test_discover_applications_only_show_in_not_show_in() {
        let temp_dir = tempdir().unwrap();
        let app_dir = temp_dir.path().join("applications");
        fs::create_dir(&app_dir).unwrap();
        set_xdg_data_dirs_env(&[&temp_dir.path()]);

        // Should be shown
        create_desktop_file(&app_dir, "nova_app", r#"
            [Desktop Entry]
            Name=Nova App
            Exec=nova-app
            Type=Application
            OnlyShowIn=NovaDE;
        "#).await;

        // Should not be shown (explicitly excluded)
        create_desktop_file(&app_dir, "kde_app", r#"
            [Desktop Entry]
            Name=KDE App
            Exec=kde-app
            Type=Application
            OnlyShowIn=KDE;
        "#).await;

        // Should not be shown (explicitly excluded by NotShowIn)
        create_desktop_file(&app_dir, "not_in_nova", r#"
            [Desktop Entry]
            Name=Not In Nova
            Exec=not-in-nova
            Type=Application
            NotShowIn=NovaDE;
        "#).await;

        // Should be shown (no specific show/hide rules)
        create_desktop_file(&app_dir, "generic_app", r#"
            [Desktop Entry]
            Name=Generic App
            Exec=generic-app
            Type=Application
        "#).await;

        let discovery_service = ApplicationDiscoveryService::new(None).unwrap();
        let applications = discovery_service.discover_applications().await.unwrap();

        assert_eq!(applications.len(), 2);
        let app_names: HashSet<String> = applications.into_iter().map(|app| app.name).collect();
        assert!(app_names.contains("Nova App"));
        assert!(app_names.contains("Generic App"));
        assert!(!app_names.contains("KDE App"));
        assert!(!app_names.contains("Not In Nova"));
    }

    #[tokio::test]
    async fn test_parse_desktop_file_invalid_format() {
        let temp_dir = tempdir().unwrap();
        let invalid_file_path = create_desktop_file(temp_dir.path(), "invalid", "This is not an INI file").await;

        let result = ApplicationDiscoveryService::parse_desktop_file(&invalid_file_path);
        assert!(matches!(result, Err(ApplicationServiceError::InvalidDesktopFile { .. })));
        assert!(result.unwrap_err().to_string().contains("Failed to parse INI format"));

        let missing_name_path = create_desktop_file(temp_dir.path(), "missing_name", r#"
            [Desktop Entry]
            Exec=missing-name-app
            Type=Application
        "#).await;
        let result = ApplicationDiscoveryService::parse_desktop_file(&missing_name_path);
        assert!(matches!(result, Err(ApplicationServiceError::InvalidDesktopFile { .. })));
        assert!(result.unwrap_err().to_string().contains("Missing 'Name' field"));
    }

    #[tokio::test]
    async fn test_caching_mechanism() {
        let temp_dir = tempdir().unwrap();
        let cache_dir = temp_dir.path().to_path_buf();
        let config_provider = Arc::new(FilesystemConfigProvider::new_with_base_dir(cache_dir.clone()));
        let config_service = Arc::new(ConfigService::new(config_provider.clone()).unwrap());

        let app_dir = temp_dir.path().join("applications");
        fs::create_dir(&app_dir).unwrap();
        set_xdg_data_dirs_env(&[&temp_dir.path()]);

        // First scan: no cache, should create one
        create_desktop_file(&app_dir, "first_app", r#"
            [Desktop Entry]
            Name=First App
            Exec=first-app
            Type=Application
        "#).await;

        let discovery_service_1 = ApplicationDiscoveryService::new(Some(config_service.clone())).unwrap();
        let applications_1 = discovery_service_1.discover_applications().await.unwrap();
        assert_eq!(applications_1.len(), 1);
        assert_eq!(applications_1[0].name, "First App");

        // Verify cache file exists
        let cache_file_path = config_service.get_config_path(APPLICATION_CACHE_FILE);
        assert!(fs::metadata(&cache_file_path).is_ok());

        // Second scan: cache should be valid, no rescan
        let discovery_service_2 = ApplicationDiscoveryService::new(Some(config_service.clone())).unwrap();
        let applications_2 = discovery_service_2.discover_applications().await.unwrap();
        assert_eq!(applications_2.len(), 1);
        assert_eq!(applications_2[0].name, "First App");
        // No new file created, indicating cache hit (though harder to assert programmatically)

        // Simulate an external change (update mtime of directory)
        let modified_time = std::time::SystemTime::now() + std::time::Duration::from_secs(10);
        filetime::set_file_mtime(&app_dir, filetime::FileTime::from_system_time(modified_time)).unwrap();

        // Third scan: cache should be invalid, force rescan and find new app
        create_desktop_file(&app_dir, "second_app", r#"
            [Desktop Entry]
            Name=Second App
            Exec=second-app
            Type=Application
        "#).await;

        let discovery_service_3 = ApplicationDiscoveryService::new(Some(config_service.clone())).unwrap();
        let applications_3 = discovery_service_3.discover_applications().await.unwrap();
        assert_eq!(applications_3.len(), 2);
        let app_names: HashSet<String> = applications_3.into_iter().map(|app| app.name).collect();
        assert!(app_names.contains("First App"));
        assert!(app_names.contains("Second App"));
    }

    #[tokio::test]
    async fn test_get_xdg_dirs_timestamps_non_existent_dir() {
        let temp_dir = tempdir().unwrap();
        let non_existent_dir = temp_dir.path().join("non_existent");
        let xdg_data_dirs = vec![non_existent_dir.clone()];

        let timestamps = ApplicationDiscoveryService::get_xdg_dirs_timestamps(&xdg_data_dirs).await.unwrap();
        assert!(timestamps.is_empty()); // Should not contain the non-existent dir
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser fünfte Teil (5 von 100) konzentriert sich weiterhin auf die Domänenschicht (`novade-domain`), diesmal mit der detaillierten Spezifikation des `application_management::service`-Moduls. Dieses Modul ist das Herzstück des Anwendungsmanagements, das für die Bereitstellung, den Start und die Verwaltung des Lebenszyklus von Anwendungen zuständig ist.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 5/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.14. `novade-domain/src/application_management/service.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/application_management/service.rs`
  * **Verantwortlichkeit:** Stellt die Haupt-API für das Anwendungsmanagement bereit. Es aggregiert die Funktionalität von `ApplicationDiscoveryService` und verwaltet die Liste der verfügbaren Anwendungen. Es ist verantwortlich für das Starten von Anwendungen, die Verwaltung des Anwendungszustands (z.B. zuletzt gestartet, Startzähler) und die Bereitstellung von Such- und Filterfunktionen.
  * **Kern-Aufgaben (Tasks):**
    1.  **`ApplicationService` Struct definieren:**
          * Felder: `applications: Arc<RwLock<Vec<ApplicationEntry>>>` (Liste der entdeckten Anwendungen), `discovery_service: Arc<ApplicationDiscoveryService>`, `config_service: Arc<ConfigService>`.
          * Der `RwLock` ist notwendig, da die Anwendungsliste von mehreren Threads gelesen und gelegentlich (z.B. nach einem Rescan oder Start eines neuen Prozesses) geschrieben werden muss.
          * Das Speichern der Startmetadaten (Launch Count, Last Launched) erfordert eine Möglichkeit, diese Änderungen dauerhaft zu speichern. Dies wird über den `ConfigService` erfolgen.
    2.  **Konstruktor `new()` implementieren:**
          * Initialisiert den Dienst. Versucht zuerst, Anwendungen aus dem Cache zu laden.
          * Wenn der Cache ungültig oder nicht vorhanden ist, ruft es `discovery_service.discover_applications()` auf, um die Anwendungsliste zu füllen und den Cache zu aktualisieren.
          * Stellt sicher, dass die Initialisierung asynchron erfolgt.
    3.  **`get_applications()` Methode implementieren:**
          * Asynchron: Gibt eine geklonte Liste aller aktuell verfügbaren `ApplicationEntry`-Objekte zurück.
          * Sollte den `RwLock` für den Lesezugriff nutzen.
    4.  **`find_application_by_id()` Methode implementieren:**
          * Asynchron: Sucht eine Anwendung anhand ihrer `id` (Desktop-Datei-Name).
          * Gibt `Option<ApplicationEntry>` zurück.
    5.  **`find_applications_by_name_fuzzy()` Methode implementieren:**
          * Asynchron: Implementiert eine Fuzzy-Suche basierend auf dem Anwendungsnamen und Schlüsselwörtern.
          * Priorisiert exakte Übereinstimmungen.
          * Kann eine externe Bibliothek für Fuzzy-Matching verwenden (z.B. `fuzzy-matcher` crate).
          * Gibt eine `Vec<ApplicationEntry>` zurück, sortiert nach Relevanz.
    6.  **`launch_application()` Methode implementieren:**
          * Asynchron: Startet eine Anwendung anhand ihrer `id`.
          * Findet die `ApplicationEntry`.
          * Ersetzt Feldcodes im `Exec`-String (`%f`, `%F`, `%u`, `%U`, `%d`, `%D`, `%n`, `%N`, `%v`, `%m`, `%c`, `%i`, `%k`).
          * Startet den Prozess (mit oder ohne Terminal basierend auf `terminal`-Feld).
          * Aktualisiert `last_launched` und inkrementiert `launch_count` für die gestartete Anwendung.
          * Persistiert die aktualisierten Anwendungsmetadaten zurück in den Cache (`ConfigService`).
          * Gibt `Result<(), ApplicationServiceError>` zurück.
    7.  **`launch_application_action()` Methode implementieren:**
          * Asynchron: Startet eine spezifische Aktion einer Anwendung.
          * Findet die `ApplicationEntry` und die `ApplicationAction` anhand ihrer IDs.
          * Ersetzt Feldcodes im `Exec`-String der Aktion.
          * Startet den Prozess.
          * Aktualisiert `last_launched` und `launch_count` für die übergeordnete Anwendung.
          * Persistiert die aktualisierten Anwendungsmetadaten.
          * Gibt `Result<(), ApplicationServiceError>` zurück.
    8.  **Event-Broadcasts:** Sollte Events publizieren, wenn sich die Anwendungsliste ändert (z.B. `ApplicationListUpdated`) oder eine Anwendung gestartet wird (`ApplicationLaunched`). Diese Events werden von der UI-Schicht und anderen Domänen-Services abonniert.
    9.  **Periodische Aktualisierung (Optional, aber empfohlen):** Implementieren Sie einen Mechanismus, um die Anwendungsliste periodisch oder auf Dateisystem-Änderungen hin neu zu scannen (z.B. durch `inotify` oder `fs_events` in einem separaten Thread, oder durch ein `tokio::interval` in längeren Intervallen). Für einen MVP ist ein manueller Trigger oder ein einfacher periodischer Scan ausreichend.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/application_management/service.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_domain::application_management::data_types`, `novade_domain::application_management::discovery`, `novade_domain::application_management::errors`, `crate::config::service::ConfigService`, `novade_core::error`.
      * **Extern:** `tokio`, `tokio::process`, `tokio::sync::RwLock`, `tokio::sync::broadcast`, `fuzzy_matcher` (oder ähnliches für Fuzzy-Suche), `chrono`.
  * **Kommunikationsmuster:**
      * Initialisiert und nutzt `ApplicationDiscoveryService`.
      * Interagiert mit `ConfigService` für Caching und Persistenz.
      * Stellt asynchrone Methoden für andere Domänen-Services und die UI-Schicht bereit.
      * Publiziert Events über `tokio::sync::broadcast`.
  * **Erwartete Ergebnisse/Outputs:** Ein robuster und performanter Dienst zur Verwaltung und zum Starten von Anwendungen.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Initialisierung (mit und ohne Cache).
          * Testen von `get_applications()`, `find_application_by_id()`, `find_applications_by_name_fuzzy()`.
          * Testen der `launch_application()` und `launch_application_action()` (mit Mocking von `Command` oder Überprüfung der Argumente).
          * Tests für die Aktualisierung von `last_launched` und `launch_count` und deren Persistenz.
          * Tests für die korrekte Handhabung von Feldcodes in `Exec`.
          * Testen der Fehlerfälle (Anwendung nicht gefunden, Start fehlgeschlagen, ungültige Exec-Parameter).
      * **Integration Tests:**
          * End-to-End-Test des Cache-Verhaltens zusammen mit `ApplicationDiscoveryService`.
          * Integration mit einem gemockten `ConfigService` zur Überprüfung der Persistenz.

#### Funktionsspezifikation: `novade_domain::application_management::service::ApplicationService`

```rust
// novade-domain/src/application_management/service.rs

use std::collections::HashMap;
use std::process::Stdio;
use std::sync::Arc;
use tokio::sync::{RwLock, broadcast};
use tokio::process::Command;
use tokio::task;
use tracing::{info, warn, error, debug};
use chrono::{DateTime, Utc};
use fuzzy_matcher::FuzzyMatcher;
use fuzzy_matcher::skim::SkimMatcherV2;

use crate::config::service::ConfigService;
use crate::application_management::data_types::{ApplicationEntry, ApplicationAction};
use crate::application_management::discovery::ApplicationDiscoveryService;
use crate::application_management::errors::ApplicationServiceError;
use novade_core::error::{CoreError, IoError};

// Ereignis-Typen für den ApplicationService
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ApplicationEvent {
    /// Wird gesendet, wenn die Liste der verfügbaren Anwendungen aktualisiert wurde.
    ApplicationListUpdated,
    /// Wird gesendet, wenn eine Anwendung erfolgreich gestartet wurde.
    ApplicationLaunched { id: String },
    /// Wird gesendet, wenn eine Anwendung gestartet wurde, aber fehlgeschlagen ist.
    ApplicationLaunchFailed { id: String, error_message: String },
}

/// Dienst zum Verwalten und Starten von Anwendungen.
pub struct ApplicationService {
    /// Der Les-/Schreib-geschützte Vektor von Anwendungs-Einträgen.
    applications: Arc<RwLock<Vec<ApplicationEntry>>>,
    /// Der Dienst zur Entdeckung von Anwendungen.
    discovery_service: Arc<ApplicationDiscoveryService>,
    /// Der Konfigurationsdienst für Persistenz.
    config_service: Arc<ConfigService>,
    /// Sender für Anwendungsereignisse.
    event_tx: broadcast::Sender<ApplicationEvent>,
    /// Empfänger für Anwendungsereignisse (als Beispiel, kann geklont werden).
    _event_rx: broadcast::Receiver<ApplicationEvent>, // Keep one receiver to keep the channel open
}

impl ApplicationService {
    /// Erstellt und initialisiert eine neue Instanz des `ApplicationService`.
    ///
    /// # Arguments
    /// * `config_service` - Ein `Arc` zu einem `ConfigService` für Caching und Persistenz.
    ///
    /// # Returns
    /// Ein `Result` mit dem initialisierten `ApplicationService` bei Erfolg.
    pub async fn new(config_service: Arc<ConfigService>) -> Result<Self, ApplicationServiceError> {
        let (event_tx, _event_rx) = broadcast::channel(16); // Channel for ApplicationEvents

        let discovery_service = Arc::new(ApplicationDiscoveryService::new(Some(config_service.clone()))?);
        let applications = Arc::new(RwLock::new(Vec::new()));

        let service = Self {
            applications,
            discovery_service,
            config_service,
            event_tx,
            _event_rx,
        };

        // Führe den initialen Scan asynchron durch
        let initial_apps = service.discovery_service.discover_applications().await?;
        {
            let mut apps_guard = service.applications.write().await;
            *apps_guard = initial_apps;
        }
        info!("ApplicationService initialized with {} applications.", service.applications.read().await.len());
        service.event_tx.send(ApplicationEvent::ApplicationListUpdated).ok(); // Notify listeners

        Ok(service)
    }

    /// Gibt einen Klon der aktuell geladenen Anwendungsliste zurück.
    ///
    /// # Returns
    /// Eine `Vec<ApplicationEntry>` mit allen verfügbaren Anwendungen.
    pub async fn get_applications(&self) -> Vec<ApplicationEntry> {
        self.applications.read().await.clone()
    }

    /// Sucht eine Anwendung anhand ihrer eindeutigen ID.
    ///
    /// # Arguments
    /// * `id` - Die ID der Anwendung (typischerweise der Dateiname der .desktop-Datei ohne Endung).
    ///
    /// # Returns
    /// Ein `Option<ApplicationEntry>`, das die gefundene Anwendung enthält, oder `None`, wenn nicht gefunden.
    pub async fn find_application_by_id(&self, id: &str) -> Option<ApplicationEntry> {
        self.applications.read().await.iter()
            .find(|app| app.id == id)
            .cloned()
    }

    /// Führt eine Fuzzy-Suche nach Anwendungen basierend auf dem Namen und den Schlüsselwörtern durch.
    /// Die Ergebnisse werden nach Relevanz sortiert (höherer Score zuerst).
    ///
    /// # Arguments
    /// * `query` - Der Suchbegriff.
    ///
    /// # Returns
    /// Eine `Vec<ApplicationEntry>` der passenden Anwendungen, sortiert nach Relevanz.
    pub async fn find_applications_by_name_fuzzy(&self, query: &str) -> Vec<ApplicationEntry> {
        if query.is_empty() {
            return Vec::new();
        }

        let matcher = SkimMatcherV2::default().ignore_case();
        let apps = self.applications.read().await;
        let mut results: Vec<(ApplicationEntry, i64)> = apps.iter()
            .filter_map(|app| {
                let score = matcher.fuzzy_match(&app.name, query)
                    .or_else(|| app.generic_name.as_ref().and_then(|gn| matcher.fuzzy_match(gn, query)))
                    .or_else(|| app.comment.as_ref().and_then(|c| matcher.fuzzy_match(c, query)))
                    .or_else(|| {
                        app.keywords.iter()
                            .filter_map(|kw| matcher.fuzzy_match(kw, query))
                            .max()
                    });
                score.map(|s| (app.clone(), s))
            })
            .collect();

        results.sort_by(|(_, score_a), (_, score_b)| score_b.cmp(score_a)); // Sort descending by score
        results.into_iter().map(|(app, _)| app).collect()
    }

    /// Startet eine Anwendung anhand ihrer ID.
    ///
    /// # Arguments
    /// * `id` - Die ID der zu startenden Anwendung.
    /// * `args` - Optionale Argumente, die an den Exec-Befehl übergeben werden sollen.
    ///
    /// # Returns
    /// Ein `Result<(), ApplicationServiceError>` das den Erfolg oder Misserfolg des Starts anzeigt.
    pub async fn launch_application(&self, id: &str, args: Option<Vec<String>>) -> Result<(), ApplicationServiceError> {
        let mut apps_guard = self.applications.write().await;
        let Some(app_entry) = apps_guard.iter_mut().find(|app| app.id == id) else {
            let err = ApplicationServiceError::ApplicationNotFound { id: id.to_string() };
            self.event_tx.send(ApplicationEvent::ApplicationLaunchFailed { id: id.to_string(), error_message: err.to_string() }).ok();
            return Err(err);
        };

        // Aktualisiere Metadaten VOR dem Start, um konsistenten Zustand zu gewährleisten
        app_entry.last_launched = Some(Utc::now());
        app_entry.launch_count = app_entry.launch_count.saturating_add(1);

        let exec_command = Self::prepare_exec_command(&app_entry.exec, args.as_deref());

        info!("Launching application '{}' with command: {:?}", app_entry.name, exec_command);

        let mut command = Command::new(&exec_command[0]);
        if exec_command.len() > 1 {
            command.args(&exec_command[1..]);
        }

        // Handle terminal option
        if app_entry.terminal {
            // How to launch in terminal is system dependent.
            // For general XDG compliance, one would use xterm -e or gnome-terminal --command.
            // This needs to be configured or discovered. For simplicity, we'll assume a basic terminal command.
            // A more robust solution would query XDG_TERM or rely on a system service.
            warn!("Launching in terminal mode. This may require an external terminal emulator.");
            // Example for gnome-terminal. This needs to be made configurable or smarter.
            command = Command::new("gnome-terminal")
                .arg("--")
                .arg(&exec_command[0])
                .args(&exec_command[1..]);
        } else {
            // Detach process from current shell (important for UI responsiveness)
            // Stdio::null() prevents the launched app from inheriting stdout/stderr
            // This is a common pattern for desktop applications.
            command.stdin(Stdio::null())
                    .stdout(Stdio::null())
                    .stderr(Stdio::null());
        }

        match command.spawn() {
            Ok(_) => {
                info!("Successfully launched application: {}", id);
                // Persist updated applications list
                if let Err(e) = self.persist_applications(&apps_guard.to_vec()).await {
                    error!("Failed to persist application state after launch: {}", e);
                }
                self.event_tx.send(ApplicationEvent::ApplicationLaunched { id: id.to_string() }).ok();
                Ok(())
            },
            Err(e) => {
                error!("Failed to launch application '{}': {}", id, e);
                let app_error = ApplicationServiceError::LaunchFailed {
                    id: id.to_string(),
                    source: IoError::Generic(e.into()),
                };
                self.event_tx.send(ApplicationEvent::ApplicationLaunchFailed { id: id.to_string(), error_message: app_error.to_string() }).ok();
                Err(app_error)
            },
        }
    }

    /// Startet eine spezifische Aktion einer Anwendung.
    ///
    /// # Arguments
    /// * `app_id` - Die ID der übergeordneten Anwendung.
    /// * `action_id` - Die ID der zu startenden Aktion.
    /// * `args` - Optionale Argumente, die an den Exec-Befehl der Aktion übergeben werden sollen.
    ///
    /// # Returns
    /// Ein `Result<(), ApplicationServiceError>` das den Erfolg oder Misserfolg des Starts anzeigt.
    pub async fn launch_application_action(&self, app_id: &str, action_id: &str, args: Option<Vec<String>>) -> Result<(), ApplicationServiceError> {
        let mut apps_guard = self.applications.write().await;
        let Some(app_entry) = apps_guard.iter_mut().find(|app| app.id == app_id) else {
            let err = ApplicationServiceError::ApplicationNotFound { id: app_id.to_string() };
            self.event_tx.send(ApplicationEvent::ApplicationLaunchFailed { id: app_id.to_string(), error_message: err.to_string() }).ok();
            return Err(err);
        };

        let Some(action) = app_entry.actions.iter().find(|act| act.id == action_id).cloned() else {
            let err = ApplicationServiceError::Generic(format!("Action '{}' not found for application '{}'", action_id, app_id));
            self.event_tx.send(ApplicationEvent::ApplicationLaunchFailed { id: app_id.to_string(), error_message: err.to_string() }).ok();
            return Err(err);
        };

        // Aktualisiere Metadaten für die übergeordnete Anwendung
        app_entry.last_launched = Some(Utc::now());
        app_entry.launch_count = app_entry.launch_count.saturating_add(1);

        let exec_command = Self::prepare_exec_command(&action.exec, args.as_deref());

        info!("Launching action '{}' for application '{}' with command: {:?}", action.name, app_entry.name, exec_command);

        let mut command = Command::new(&exec_command[0]);
        if exec_command.len() > 1 {
            command.args(&exec_command[1..]);
        }

        // Detach process
        command.stdin(Stdio::null())
                .stdout(Stdio::null())
                .stderr(Stdio::null());

        match command.spawn() {
            Ok(_) => {
                info!("Successfully launched action: {}", action_id);
                // Persist updated applications list
                if let Err(e) = self.persist_applications(&apps_guard.to_vec()).await {
                    error!("Failed to persist application state after action launch: {}", e);
                }
                self.event_tx.send(ApplicationEvent::ApplicationLaunched { id: app_id.to_string() }).ok();
                Ok(())
            },
            Err(e) => {
                error!("Failed to launch action '{}' for application '{}': {}", action_id, app_id, e);
                let app_error = ApplicationServiceError::LaunchFailed {
                    id: app_id.to_string(),
                    source: IoError::Generic(e.into()),
                };
                self.event_tx.send(ApplicationEvent::ApplicationLaunchFailed { id: app_id.to_string(), error_message: app_error.to_string() }).ok();
                Err(app_error)
            },
        }
    }

    /// Abonniert Anwendungsereignisse.
    ///
    /// # Returns
    /// Ein `broadcast::Receiver` für `ApplicationEvent`s.
    pub fn subscribe_events(&self) -> broadcast::Receiver<ApplicationEvent> {
        self.event_tx.subscribe()
    }

    /// Aktualisiert die Liste der Anwendungen. Dies löst einen erneuten Scan der XDG-Verzeichnisse aus.
    ///
    /// # Returns
    /// Ein `Result` das den Erfolg oder Misserfolg der Aktualisierung anzeigt.
    pub async fn refresh_applications(&self) -> Result<(), ApplicationServiceError> {
        info!("Refreshing application list...");
        let updated_apps = self.discovery_service.discover_applications().await?;
        {
            let mut apps_guard = self.applications.write().await;
            *apps_guard = updated_apps;
        }
        info!("Application list refreshed. Now managing {} applications.", self.applications.read().await.len());
        self.event_tx.send(ApplicationEvent::ApplicationListUpdated).ok();
        Ok(())
    }

    /// Verarbeitet Feldcodes im `Exec`-String einer Desktop-Datei.
    ///
    /// # Arguments
    /// * `exec_str` - Der ursprüngliche `Exec`-String.
    /// * `args` - Optionale Argumente, die vom Aufrufer bereitgestellt werden.
    ///
    /// # Returns
    /// Ein `Vec<String>` der Befehl und Argumente darstellt.
    fn prepare_exec_command(exec_str: &str, args: Option<&[String]>) -> Vec<String> {
        // Implementierung der Feldcode-Ersetzung gemäß XDG Desktop Entry Specification
        // %f, %F, %u, %U, %d, %D, %n, %N, %v, %m, %c, %i, %k
        // Für den MVP werden nur %f und %u (für einzelne/mehrere Dateien/URIs) und %i, %c, %k
        // relevant sein. Die anderen werden ignoriert oder durch leere Strings ersetzt,
        // da sie komplexere Kontextinformationen (Dateien, URLs, etc.) erfordern.
        // Diese Funktion sollte später erweitert werden, um alle relevanten Feldcodes zu unterstützen.

        let mut parts = Vec::new();
        let mut current_part = String::new();
        let mut in_quotes = false;

        let mut chars = exec_str.chars().peekable();
        while let Some(c) = chars.next() {
            match c {
                '\\' => { // Escape character
                    if let Some(next_c) = chars.next() {
                        current_part.push(next_c);
                    } else {
                        current_part.push(c); // Trailing backslash
                    }
                },
                '"' => {
                    in_quotes = !in_quotes;
                    current_part.push(c); // Keep quotes for shell parsing
                },
                ' ' if !in_quotes => { // Space outside quotes is a delimiter
                    if !current_part.is_empty() {
                        parts.push(current_part.clone());
                        current_part.clear();
                    }
                },
                '%' => { // Field code
                    if let Some(field_code_char) = chars.next() {
                        match field_code_char {
                            'f' | 'F' | 'u' | 'U' => { // File/URL arguments
                                if let Some(a) = args {
                                    for arg in a {
                                        if !current_part.is_empty() {
                                            parts.push(current_part.clone());
                                            current_part.clear();
                                        }
                                        // Argumente könnten selbst Leerzeichen enthalten, daher als separates Token pushen
                                        parts.push(arg.clone());
                                    }
                                }
                            },
                            'i' | 'c' | 'k' => {
                                // These are typically replaced by environment variables or specific D-Bus calls
                                // For launching, they are often used for icon, caption, or program path.
                                // For simplicity in MVP, we'll just ignore them or replace with empty string.
                                // A real implementation might get icon path from app_entry.icon
                                // For now, we'll replace with empty string if not handled otherwise by the shell.
                                // It's common to pass --icon=... or similar if the app supports it.
                                // This requires more context than just the exec string.
                                debug!("Ignoring XDG field code %{}. Full implementation would handle this.", field_code_char);
                                current_part.push('%'); // Push back to avoid breaking the command if the app expects it
                                current_part.push(field_code_char);
                            },
                            'd' | 'D' | 'n' | 'N' | 'v' | 'm' => { // Other unsupported field codes
                                debug!("Ignoring XDG field code %{}. Not supported in current implementation.", field_code_char);
                                current_part.push('%');
                                current_part.push(field_code_char);
                            },
                            _ => { // Not a recognized field code
                                current_part.push('%');
                                current_part.push(field_code_char);
                            }
                        }
                    } else {
                        current_part.push(c); // Trailing %
                    }
                },
                _ => current_part.push(c),
            }
        }
        if !current_part.is_empty() {
            parts.push(current_part);
        }

        // Remove empty strings from parts. This is common if spaces were at the end of exec string
        parts.retain(|p| !p.trim().is_empty());

        // Basic validation: ensure we have at least one part (the command itself)
        if parts.is_empty() {
            // This is an invalid Exec string, return a placeholder or error.
            // For now, return a placeholder that will likely fail to launch.
            vec!["true".to_string()] // Default to a no-op command, or a command that reliably fails
        } else {
            parts
        }
    }


    /// Persistiert die aktuelle Liste der Anwendungen über den ConfigService.
    ///
    /// Dies ist eine Hilfsmethode, die den Schreib-Lock auf `applications` bereits hält.
    async fn persist_applications(&self, applications: &Vec<ApplicationEntry>) -> Result<(), ApplicationServiceError> {
        let app_cache = ApplicationCache {
            last_scanned: Utc::now(),
            xdg_dirs_info: Self::get_xdg_dirs_timestamps_sync(&self.base_dirs.get_data_dirs()).await?, // Recalculate this or pass from discovery
            applications: applications.clone(),
        };

        self.config_service.save_config(APPLICATION_CACHE_FILE, &app_cache)
            .await
            .map_err(|e| ApplicationServiceError::PersistenceError(e))
    }

    // Helper method to get timestamps (similar to discovery, but for persisting current state)
    async fn get_xdg_dirs_timestamps_sync(xdg_data_dirs: &[PathBuf]) -> Result<HashMap<PathBuf, DateTime<Utc>>, ApplicationServiceError> {
        let mut dir_timestamps = HashMap::new();
        for data_dir in xdg_data_dirs {
            let app_dir = data_dir.join("applications");
            if app_dir.is_dir() {
                match fs::metadata(&app_dir) { // Using std::fs::metadata for sync context
                    Ok(metadata) => {
                        let mtime = metadata.modified()
                            .map_err(|e| IoError::Generic(e.into()))
                            .map_err(|e| ApplicationServiceError::DiscoveryError(format!("Failed to get modified time for {:?}: {}", app_dir, e)))?;
                        let datetime: DateTime<Utc> = mtime.into();
                        dir_timestamps.insert(app_dir, datetime);
                    }
                    Err(e) => {
                        warn!("Could not get metadata for XDG applications directory {:?}: {}", app_dir, e);
                    }
                }
            }
        }
        Ok(dir_timestamps)
    }

}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;
    use std::fs;
    use tokio::test;
    use tokio::time::{sleep, Duration};
    use crate::config::persistence::FilesystemConfigProvider;
    use crate::application_management::discovery::APPLICATION_CACHE_FILE;
    use crate::application_management::data_types::ApplicationAction;

    // Helper to create a temp .desktop file
    async fn create_desktop_file(dir: &Path, name: &str, content: &str) -> PathBuf {
        let path = dir.join(format!("{}.desktop", name));
        let mut file = fs::File::create(&path).unwrap(); // Use std::fs for blocking write
        file.write_all(content.as_bytes()).unwrap();
        path
    }

    // Helper to mock the XDG_DATA_DIRS environment variable
    fn set_xdg_data_dirs_env(paths: &[&Path]) {
        let path_str = paths.iter()
            .map(|p| p.to_str().unwrap())
            .collect::<Vec<_>>()
            .join(":");
        std::env::set_var("XDG_DATA_DIRS", path_str);
        // Also clear XDG_DATA_HOME to ensure it's not interfering for this specific test
        std::env::remove_var("XDG_DATA_HOME");
    }

    async fn setup_test_service(temp_dir_path: &Path) -> (Arc<ConfigService>, Arc<ApplicationService>, PathBuf) {
        let config_provider = Arc::new(FilesystemConfigProvider::new_with_base_dir(temp_dir_path.to_path_buf()));
        let config_service = Arc::new(ConfigService::new(config_provider.clone()).unwrap());

        let app_dir = temp_dir_path.join("applications");
        fs::create_dir(&app_dir).unwrap();
        set_xdg_data_dirs_env(&[&temp_dir_path]);

        let service = Arc::new(ApplicationService::new(config_service.clone()).await.unwrap());
        (config_service, service, app_dir)
    }


    #[tokio::test]
    async fn test_application_service_initialization() {
        let temp_dir = tempdir().unwrap();
        let (_config_service, service, _app_dir) = setup_test_service(temp_dir.path()).await;

        let applications = service.get_applications().await;
        assert!(applications.is_empty(), "Service should be initialized with no applications if no desktop files exist");

        create_desktop_file(&_app_dir, "test_app", r#"
            [Desktop Entry]
            Name=Test Application
            Exec=test-app
            Type=Application
        "#).await;

        // Force a refresh to load the new app (initial setup uses discovery once)
        service.refresh_applications().await.unwrap();

        let applications = service.get_applications().await;
        assert_eq!(applications.len(), 1);
        assert_eq!(applications[0].name, "Test Application");
    }

    #[tokio::test]
    async fn test_find_application_by_id() {
        let temp_dir = tempdir().unwrap();
        let (_config_service, service, app_dir) = setup_test_service(temp_dir.path()).await;

        create_desktop_file(&app_dir, "test_app", r#"
            [Desktop Entry]
            Name=Test Application
            Exec=test-app
            Type=Application
        "#).await;
        service.refresh_applications().await.unwrap();

        let found_app = service.find_application_by_id("test_app").await;
        assert!(found_app.is_some());
        assert_eq!(found_app.unwrap().name, "Test Application");

        let not_found_app = service.find_application_by_id("non_existent_app").await;
        assert!(not_found_app.is_none());
    }

    #[tokio::test]
    async fn test_find_applications_by_name_fuzzy() {
        let temp_dir = tempdir().unwrap();
        let (_config_service, service, app_dir) = setup_test_service(temp_dir.path()).await;

        create_desktop_file(&app_dir, "firefox", r#"
            [Desktop Entry]
            Name=Firefox Web Browser
            Exec=firefox
            Type=Application
            Keywords=internet;browser;web;
        "#).await;
        create_desktop_file(&app_dir, "thunderbird", r#"
            [Desktop Entry]
            Name=Thunderbird Mail
            Exec=thunderbird
            Type=Application
            Keywords=email;mail;
        "#).await;
        create_desktop_file(&app_dir, "file_manager", r#"
            [Desktop Entry]
            Name=Files
            Exec=nautilus
            Type=Application
        "#).await;
        service.refresh_applications().await.unwrap();

        let results = service.find_applications_by_name_fuzzy("fire").await;
        assert_eq!(results.len(), 1);
        assert_eq!(results[0].name, "Firefox Web Browser");

        let results = service.find_applications_by_name_fuzzy("mail").await;
        assert_eq!(results.len(), 1);
        assert_eq!(results[0].name, "Thunderbird Mail");

        let results = service.find_applications_by_name_fuzzy("f").await;
        assert_eq!(results.len(), 2); // Firefox, Files
        let names: HashSet<String> = results.into_iter().map(|a| a.name).collect();
        assert!(names.contains("Firefox Web Browser"));
        assert!(names.contains("Files"));

        let results = service.find_applications_by_name_fuzzy("nonexistent").await;
        assert!(results.is_empty());
    }

    #[tokio::test]
    async fn test_launch_application_success() {
        let temp_dir = tempdir().unwrap();
        let (_config_service, service, app_dir) = setup_test_service(temp_dir.path()).await;

        // Create a dummy executable for testing
        let dummy_exec_path = temp_dir.path().join("dummy_app.sh");
        tokio::fs::write(&dummy_exec_path, "#!/bin/bash\necho \"Dummy app started!\" >&2\nexit 0").await.unwrap();
        std::fs::set_permissions(&dummy_exec_path, std::os::unix::fs::PermissionsExt::from_mode(0o755)).unwrap();

        create_desktop_file(&app_dir, "dummy_test_app", &format!(r#"
            [Desktop Entry]
            Name=Dummy Test App
            Exec={}
            Type=Application
        "#, dummy_exec_path.display())).await;
        service.refresh_applications().await.unwrap();

        let mut event_rx = service.subscribe_events();
        let result = service.launch_application("dummy_test_app", None).await;
        assert!(result.is_ok());

        // Check if ApplicationLaunched event is received
        let event = tokio::time::timeout(Duration::from_secs(1), event_rx.recv()).await.unwrap().unwrap();
        assert_eq!(event, ApplicationEvent::ApplicationLaunched { id: "dummy_test_app".to_string() });

        // Verify launch count and last_launched updated and persisted
        let updated_app = service.find_application_by_id("dummy_test_app").await.unwrap();
        assert_eq!(updated_app.launch_count, 1);
        assert!(updated_app.last_launched.is_some());

        // Load cache directly to verify persistence
        let cache_path = _config_service.get_config_path(APPLICATION_CACHE_FILE);
        let loaded_cache: ApplicationCache = _config_service.load_config(&cache_path.to_string_lossy()).await.unwrap();
        let cached_app = loaded_cache.applications.into_iter().find(|app| app.id == "dummy_test_app").unwrap();
        assert_eq!(cached_app.launch_count, 1);
        assert!(cached_app.last_launched.is_some());
    }

    #[tokio::test]
    async fn test_launch_application_not_found_error() {
        let temp_dir = tempdir().unwrap();
        let (_config_service, service, _app_dir) = setup_test_service(temp_dir.path()).await;
        let mut event_rx = service.subscribe_events();

        let result = service.launch_application("non_existent", None).await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), ApplicationServiceError::ApplicationNotFound { id } if id == "non_existent"));

        let event = tokio::time::timeout(Duration::from_secs(1), event_rx.recv()).await.unwrap().unwrap();
        assert!(matches!(event, ApplicationEvent::ApplicationLaunchFailed { id, .. } if id == "non_existent"));
    }

    #[tokio::test]
    async fn test_launch_application_field_codes() {
        let temp_dir = tempdir().unwrap();
        let (_config_service, service, app_dir) = setup_test_service(temp_dir.path()).await;

        // Create a dummy executable that captures arguments for testing
        let capture_args_path = temp_dir.path().join("capture_args.sh");
        tokio::fs::write(&capture_args_path, "#!/bin/bash\nARGS=\"$@\"\necho \"Called with: $ARGS\" >&2\nexit 0").await.unwrap();
        std::fs::set_permissions(&capture_args_path, std::os::unix::fs::PermissionsExt::from_mode(0o755)).unwrap();


        create_desktop_file(&app_dir, "test_field_codes", &format!(r#"
            [Desktop Entry]
            Name=Field Code Test App
            Exec="{}" %f %u %c %i %k %d
            Type=Application
        "#, capture_args_path.display())).await;
        service.refresh_applications().await.unwrap();

        let args = vec!["/path/to/file1".to_string(), "http://example.com/uri1".to_string()];
        let result = service.launch_application("test_field_codes", Some(args.clone())).await;
        assert!(result.is_ok());

        // The exact assertion on command execution output is tricky without redirecting stdout/stderr
        // but we can at least assert the command preparation.
        let exec_cmd = ApplicationService::prepare_exec_command(
            &format!("\"{}\" %f %u %c %i %k %d", capture_args_path.display()),
            Some(&args)
        );
        assert_eq!(exec_cmd[0], capture_args_path.to_string_lossy());
        assert!(exec_cmd.contains(&"/path/to/file1".to_string()));
        assert!(exec_cmd.contains(&"http://example.com/uri1".to_string()));
        // Note: %c, %i, %k, %d are currently just passed through if not handled, or ignored.
        // The current `prepare_exec_command` will include them as literal strings if not handled.
        // This test case will only check the general format.
        assert!(exec_cmd.len() > 2); // At least command + 2 arguments
    }

    #[tokio::test]
    async fn test_launch_application_action_success() {
        let temp_dir = tempdir().unwrap();
        let (_config_service, service, app_dir) = setup_test_service(temp_dir.path()).await;

        let dummy_action_exec_path = temp_dir.path().join("dummy_action.sh");
        tokio::fs::write(&dummy_action_exec_path, "#!/bin/bash\necho \"Dummy action started!\" >&2\nexit 0").await.unwrap();
        std::fs::set_permissions(&dummy_action_exec_path, std::os::unix::fs::PermissionsExt::from_mode(0o755)).unwrap();

        create_desktop_file(&app_dir, "app_with_action", &format!(r#"
            [Desktop Entry]
            Name=App with Action
            Exec=main-app
            Type=Application
            Actions=NewWindow;

            [Desktop Action NewWindow]
            Name=Open New Window
            Exec={} %u
        "#, dummy_action_exec_path.display())).await;
        service.refresh_applications().await.unwrap();

        let mut event_rx = service.subscribe_events();
        let result = service.launch_application_action("app_with_action", "NewWindow", Some(vec!["http://example.com".to_string()])).await;
        assert!(result.is_ok());

        let event = tokio::time::timeout(Duration::from_secs(1), event_rx.recv()).await.unwrap().unwrap();
        assert_eq!(event, ApplicationEvent::ApplicationLaunched { id: "app_with_action".to_string() });

        // Verify launch count updated for parent app
        let updated_app = service.find_application_by_id("app_with_action").await.unwrap();
        assert_eq!(updated_app.launch_count, 1);
        assert!(updated_app.last_launched.is_some());
    }

    #[tokio::test]
    async fn test_launch_application_action_not_found() {
        let temp_dir = tempdir().unwrap();
        let (_config_service, service, app_dir) = setup_test_service(temp_dir.path()).await;

        create_desktop_file(&app_dir, "simple_app", r#"
            [Desktop Entry]
            Name=Simple App
            Exec=simple-app
            Type=Application
        "#).await;
        service.refresh_applications().await.unwrap();

        let mut event_rx = service.subscribe_events();
        let result = service.launch_application_action("simple_app", "NonExistentAction", None).await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), ApplicationServiceError::Generic(msg) if msg.contains("Action 'NonExistentAction' not found")));

        let event = tokio::time::timeout(Duration::from_secs(1), event_rx.recv()).await.unwrap().unwrap();
        assert!(matches!(event, ApplicationEvent::ApplicationLaunchFailed { id, .. } if id == "simple_app"));
    }
}

```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser sechste Teil (6 von 100) konzentriert sich weiterhin auf die Domänenschicht (`novade-domain`), diesmal mit der detaillierten Spezifikation des `notification_rules`-Moduls. Dieses Modul ist entscheidend für die Anpassung der Benutzererfahrung, indem es die Möglichkeit bietet, Benachrichtigungen basierend auf vordefinierten Regeln zu filtern, zu modifizieren oder spezielle Aktionen auszulösen.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 6/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.15. `novade-domain/src/notification_rules`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules`
  * **Verantwortlichkeit:** Beherbergt die gesamte Logik für das Management und die Anwendung von Benachrichtigungsregeln. Dies umfasst die Definition der Regelstrukturen, die Fehlerbehandlung, die Persistenz (Laden/Speichern) und die Kern-Engine zur Verarbeitung eingehender Benachrichtigungen gegen diese Regeln.
  * **Kern-Aufgaben (Tasks):**
    1.  **Modulstruktur definieren:** Erstellung der Untermodule: `data_types`, `errors`, `persistence_iface`, `persistence`, `engine`, `mod.rs`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/mod.rs`
      * `novade-domain/src/notification_rules/data_types.rs`
      * `novade-domain/src/notification_rules/errors.rs`
      * `novade-domain/src/notification_rules/persistence_iface.rs`
      * `novade-domain/src/notification_rules/persistence.rs`
      * `novade-domain/src/notification_rules/engine.rs`
  * **Abhängigkeiten:** Siehe Untermodule.
  * **Kommunikationsmuster:** Aggregiert die Funktionalität der Untermodule und stellt eine kohärente API für andere Domänen-Services (z.B. `notification_service`) bereit.

-----

### 3.15.1. `novade-domain/src/notification_rules/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/data_types.rs`
  * **Verantwortlichkeit:** Definiert alle notwendigen Datenstrukturen für Benachrichtigungsregeln, Bedingungen und Aktionen. Diese Strukturen müssen serialisierbar/deserialisierbar sein.
  * **Kern-Aufgaben (Tasks):**
    1.  **`RuleConditionValue` Enum definieren:**
          * Repräsentiert den Wert, mit dem ein Feld verglichen wird.
          * Varianten: `Text(String)`, `Number(i64)`, `Boolean(bool)`.
          * Ableitungen: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`.
    2.  **`Operator` Enum definieren:**
          * Repräsentiert den Vergleichsoperator.
          * Varianten: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `GreaterThan`, `LessThan`, `IsSet` (für optionale Felder), `IsNotSet`.
          * Ableitungen: `PartialEq`, `Eq`, `Clone`, `Debug`, `Serialize`, `Deserialize`.
    3.  **`Field` Enum definieren:**
          * Repräsentiert das Feld einer Benachrichtigung, auf das eine Regel angewendet wird.
          * Varianten: `AppName`, `Summary`, `Body`, `Category`, `Urgency`, `ExpireTimeout`, `Icon`, `Hint(String)` (für spezifische Hints wie "desktop-entry").
          * Ableitungen: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`.
    4.  **`SimpleRuleCondition` Struct definieren:**
          * Ein einfacher atomarer Regel-Vergleich.
          * Felder: `field: Field`, `operator: Operator`, `value: RuleConditionValue`.
          * Ableitungen: `Clone`, `Debug`, `PartialEq`, `Eq`, `Serialize`, `Deserialize`.
    5.  **`RuleCondition` Enum definieren:**
          * Repräsentiert eine komplexe Regelbedingung (logische Verknüpfungen).
          * Varianten: `Simple(SimpleRuleCondition)`, `And(Vec<RuleCondition>)`, `Or(Vec<RuleCondition>)`, `Not(Box<RuleCondition>)`.
          * Ableitungen: `Clone`, `Debug`, `PartialEq`, `Eq`, `Serialize`, `Deserialize`.
    6.  **`RuleAction` Enum definieren:**
          * Repräsentiert eine Aktion, die bei einer passenden Regel ausgeführt wird.
          * Varianten:
              * `Suppress`: Benachrichtigung wird nicht angezeigt.
              * `ExecuteCommand(String)`: Führt einen externen Befehl aus.
              * `PlaySound(String)`: Spielt einen Sound ab (Pfad zur Audiodatei).
              * `SetUrgency(u8)`: Setzt die D-Bus Urgency (0-2).
              * `SetExpireTimeout(i32)`: Setzt das Ablauf-Timeout (in ms).
              * `SetCategory(String)`: Setzt die Kategorie.
              * `SetIcon(String)`: Setzt das Icon (Name oder Pfad).
              * `Log(String)`: Schreibt eine Nachricht in das Log.
          * Ableitungen: `Clone`, `Debug`, `PartialEq`, `Eq`, `Serialize`, `Deserialize`.
    7.  **`NotificationRule` Struct definieren:**
          * Definiert eine einzelne Benachrichtigungsregel.
          * Felder:
              * `id: Uuid`: Eindeutige ID der Regel.
              * `name: String`: Anzeigename der Regel.
              * `enabled: bool`: Ob die Regel aktiv ist.
              * `priority: i32`: Priorität der Regel (höhere Zahl = höhere Priorität, Regeln mit höherer Priorität werden zuerst ausgewertet).
              * `condition: RuleCondition`: Die zu prüfende Bedingung.
              * `actions: Vec<RuleAction>`: Liste der auszuführenden Aktionen.
              * `stop_processing_further_rules: bool`: Wenn `true`, werden keine weiteren Regeln ausgewertet, falls diese Regel zutrifft.
          * Ableitungen: `Clone`, `Debug`, `PartialEq`, `Eq`, `Serialize`, `Deserialize`.
    8.  **`NotificationRuleSet` Struct definieren:**
          * Eine Sammlung von `NotificationRule`s.
          * Felder: `rules: Vec<NotificationRule>`.
          * Ableitungen: `Clone`, `Debug`, `Default`, `Serialize`, `Deserialize`.
          * Der `Default`-Trait ist wichtig für die Initialisierung, wenn keine Regeln vorhanden sind.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/data_types.rs`
  * **Abhängigkeiten:**
      * **Extern:** `serde` (`Serialize`, `Deserialize`), `uuid` (`Uuid`), `derive_more` (für `From` oder ähnliches, falls sinnvoll), `chrono` (falls Timestamps in Regeln nötig werden).
  * **Kommunikationsmuster:** Keine direkte Kommunikation, nur Datenstrukturen.
  * **Erwartete Ergebnisse/Outputs:** Typdefinitionen, die die Grundlage für die Regelverarbeitung bilden.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:** Überprüfung, ob alle Enums und Structs korrekt definiert sind, insbesondere `PartialEq`, `Eq`, `Clone`, `Debug`. Tests für die Serialisierung und Deserialisierung (z.B. mit `serde_json::to_string` und `serde_json::from_str`).

#### Funktionsspezifikation: `novade_domain::notification_rules::data_types`

```rust
// novade-domain/src/notification_rules/data_types.rs

use serde::{Serialize, Deserialize};
use uuid::Uuid;
use std::collections::HashMap;
use std::path::PathBuf;

/// Repräsentiert den Wert, mit dem ein Benachrichtigungsfeld verglichen wird.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum RuleConditionValue {
    /// Ein Textwert für String-Vergleiche.
    Text(String),
    /// Ein numerischer Wert für Zahlen-Vergleiche (z.B. Urgency, ExpireTimeout).
    Number(i64),
    /// Ein Boolescher Wert.
    Boolean(bool),
}

/// Repräsentiert den Vergleichsoperator für eine Regelbedingung.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum Operator {
    /// Prüft auf exakte Gleichheit.
    Equals,
    /// Prüft, ob ein Textwert einen anderen Textwert enthält (Substing).
    Contains,
    /// Prüft, ob ein Textwert mit einem anderen Textwert beginnt.
    StartsWith,
    /// Prüft, ob ein Textwert mit einem anderen Textwert endet.
    EndsWith,
    /// Prüft, ob ein numerischer Wert größer ist als der Vergleichswert.
    GreaterThan,
    /// Prüft, ob ein numerischer Wert kleiner ist als der Vergleichswert.
    LessThan,
    /// Prüft, ob ein Feld vorhanden ist (relevant für optionale Felder wie 'Body').
    IsSet,
    /// Prüft, ob ein Feld nicht vorhanden ist.
    IsNotSet,
}

/// Repräsentiert ein spezifisches Feld einer Benachrichtigung, auf das eine Regel angewendet werden kann.
/// Entspricht den Feldern der Freedesktop Notification Specification.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Field {
    /// Der Name der Anwendung, die die Benachrichtigung sendet (`app_name`).
    AppName,
    /// Der Titel oder die Zusammenfassung der Benachrichtigung (`summary`).
    Summary,
    /// Der Haupttextinhalt der Benachrichtigung (`body`).
    Body,
    /// Die Kategorie der Benachrichtigung (`category`).
    Category,
    /// Die Dringlichkeit der Benachrichtigung (0: Low, 1: Normal, 2: Critical) (`urgency`).
    Urgency,
    /// Das Ablauf-Timeout der Benachrichtigung in Millisekunden (`expire_timeout`).
    ExpireTimeout,
    /// Der Icon-Name oder Pfad der Benachrichtigung (`icon`).
    /// Kann ein Freedesktop-Icon-Name oder ein absoluter Pfad sein.
    Icon,
    /// Ein spezifischer Hint-Key, z.B. "desktop-entry" für den .desktop-Dateinamen.
    /// Der assoziierte String ist der Key des Hints.
    Hint(String),
    // Zukünftige Erweiterungen könnten hier weitere Standard-Hints oder benutzerdefinierte Metadaten unterstützen.
}

/// Repräsentiert eine atomare, einfache Regelbedingung.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct SimpleRuleCondition {
    /// Das Feld der Benachrichtigung, das geprüft wird.
    pub field: Field,
    /// Der Operator, der für den Vergleich verwendet wird.
    pub operator: Operator,
    /// Der Wert, mit dem das Feld verglichen wird.
    pub value: RuleConditionValue,
}

/// Repräsentiert eine komplexe Regelbedingung, die logische Verknüpfungen von einfachen Bedingungen erlaubt.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum RuleCondition {
    /// Eine einzelne, atomare Bedingung.
    Simple(SimpleRuleCondition),
    /// Eine logische UND-Verknüpfung von mehreren Bedingungen. Alle Unterbedingungen müssen wahr sein.
    And(Vec<RuleCondition>),
    /// Eine logische ODER-Verknüpfung von mehreren Bedingungen. Mindestens eine Unterbedingung muss wahr sein.
    Or(Vec<RuleCondition>),
    /// Eine logische NICHT-Verknüpfung einer einzelnen Bedingung. Die Bedingung muss falsch sein.
    Not(Box<RuleCondition>),
}

/// Repräsentiert eine Aktion, die ausgeführt wird, wenn eine Benachrichtigungsregel zutrifft.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum RuleAction {
    /// Unterdrückt die Anzeige der Benachrichtigung.
    Suppress,
    /// Führt einen externen Shell-Befehl aus. Der String ist der Befehl selbst.
    ExecuteCommand(String),
    /// Spielt einen Sound ab. Der String ist der Pfad zur Audiodatei.
    PlaySound(PathBuf),
    /// Setzt die Dringlichkeitsstufe der Benachrichtigung neu (0: Low, 1: Normal, 2: Critical).
    SetUrgency(u8),
    /// Setzt das Ablauf-Timeout der Benachrichtigung in Millisekunden. Ein Wert von 0 bedeutet kein Timeout.
    SetExpireTimeout(i32),
    /// Setzt die Kategorie der Benachrichtigung neu.
    SetCategory(String),
    /// Setzt das Icon der Benachrichtigung neu. Der String ist der Icon-Name oder Pfad.
    SetIcon(String),
    /// Schreibt eine Nachricht in das interne Log-System von NovaDE.
    Log(String),
    /// Zeigt eine Toast-Benachrichtigung an (kurze, nicht-intrusive UI-Meldung).
    ShowToast(String),
    // Zukünftige Erweiterungen: Modifizieren von Summary/Body, etc.
}

/// Definiert eine einzelne Benachrichtigungsregel.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct NotificationRule {
    /// Eindeutige ID der Regel. Wird für persistente Identifizierung und Updates verwendet.
    pub id: Uuid,
    /// Ein menschenlesbarer Name für die Regel, z.B. "Slack-Benachrichtigungen stummschalten".
    pub name: String,
    /// Ob die Regel aktiv ist oder nicht.
    pub enabled: bool,
    /// Die Priorität der Regel. Regeln mit höherer Priorität werden zuerst ausgewertet.
    /// Negative Werte sind erlaubt.
    pub priority: i32,
    /// Die Bedingung, die erfüllt sein muss, damit diese Regel angewendet wird.
    pub condition: RuleCondition,
    /// Eine Liste von Aktionen, die ausgeführt werden, wenn die Bedingung zutrifft.
    pub actions: Vec<RuleAction>,
    /// Wenn `true`, wird die Verarbeitung weiterer Regeln gestoppt, sobald diese Regel zutrifft.
    /// Dies ist nützlich für "frühe Ausgänge" oder "Standard"-Regeln.
    pub stop_processing_further_rules: bool,
}

/// Eine Sammlung von Benachrichtigungsregeln. Dies ist die primäre Struktur, die persistiert wird.
#[derive(Debug, Clone, PartialEq, Eq, Default, Serialize, Deserialize)]
pub struct NotificationRuleSet {
    /// Der Vektor der Benachrichtigungsregeln.
    pub rules: Vec<NotificationRule>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;

    #[test]
    fn test_rule_condition_value_serialization_deserialization() {
        let text_value = RuleConditionValue::Text("Hello".to_string());
        let number_value = RuleConditionValue::Number(123);
        let boolean_value = RuleConditionValue::Boolean(true);

        let serialized_text = serde_json::to_string(&text_value).unwrap();
        let deserialized_text: RuleConditionValue = serde_json::from_str(&serialized_text).unwrap();
        assert_eq!(text_value, deserialized_text);

        let serialized_number = serde_json::to_string(&number_value).unwrap();
        let deserialized_number: RuleConditionValue = serde_json::from_str(&serialized_number).unwrap();
        assert_eq!(number_value, deserialized_number);

        let serialized_boolean = serde_json::to_string(&boolean_value).unwrap();
        let deserialized_boolean: RuleConditionValue = serde_json::from_str(&serialized_boolean).unwrap();
        assert_eq!(boolean_value, deserialized_boolean);
    }

    #[test]
    fn test_operator_serialization_deserialization() {
        let op = Operator::Contains;
        let serialized = serde_json::to_string(&op).unwrap();
        let deserialized: Operator = serde_json::from_str(&serialized).unwrap();
        assert_eq!(op, deserialized);
    }

    #[test]
    fn test_field_serialization_deserialization() {
        let field_app_name = Field::AppName;
        let field_hint = Field::Hint("desktop-entry".to_string());

        let serialized_app_name = serde_json::to_string(&field_app_name).unwrap();
        let deserialized_app_name: Field = serde_json::from_str(&serialized_app_name).unwrap();
        assert_eq!(field_app_name, deserialized_app_name);

        let serialized_hint = serde_json::to_string(&field_hint).unwrap();
        let deserialized_hint: Field = serde_json::from_str(&serialized_hint).unwrap();
        assert_eq!(field_hint, deserialized_hint);
    }

    #[test]
    fn test_simple_rule_condition_serialization_deserialization() {
        let simple_condition = SimpleRuleCondition {
            field: Field::Summary,
            operator: Operator::Contains,
            value: RuleConditionValue::Text("Important".to_string()),
        };

        let serialized = serde_json::to_string(&simple_condition).unwrap();
        let deserialized: SimpleRuleCondition = serde_json::from_str(&serialized).unwrap();
        assert_eq!(simple_condition, deserialized);
    }

    #[test]
    fn test_rule_condition_complex_serialization_deserialization() {
        let simple1 = RuleCondition::Simple(SimpleRuleCondition {
            field: Field::AppName,
            operator: Operator::Equals,
            value: RuleConditionValue::Text("Slack".to_string()),
        });
        let simple2 = RuleCondition::Simple(SimpleRuleCondition {
            field: Field::Urgency,
            operator: Operator::GreaterThan,
            value: RuleConditionValue::Number(1),
        });
        let complex_and = RuleCondition::And(vec![simple1.clone(), simple2.clone()]);
        let complex_or = RuleCondition::Or(vec![simple1.clone(), simple2.clone()]);
        let complex_not = RuleCondition::Not(Box::new(simple1.clone()));

        let serialized_and = serde_json::to_string(&complex_and).unwrap();
        let deserialized_and: RuleCondition = serde_json::from_str(&serialized_and).unwrap();
        assert_eq!(complex_and, deserialized_and);

        let serialized_or = serde_json::to_string(&complex_or).unwrap();
        let deserialized_or: RuleCondition = serde_json::from_str(&serialized_or).unwrap();
        assert_eq!(complex_or, deserialized_or);

        let serialized_not = serde_json::to_string(&complex_not).unwrap();
        let deserialized_not: RuleCondition = serde_json::from_str(&serialized_not).unwrap();
        assert_eq!(complex_not, deserialized_not);
    }

    #[test]
    fn test_rule_action_serialization_deserialization() {
        let action_suppress = RuleAction::Suppress;
        let action_exec = RuleAction::ExecuteCommand("notify-send 'Hello'".to_string());
        let action_sound = RuleAction::PlaySound(PathBuf::from("/usr/share/sounds/bell.ogg"));
        let action_urgency = RuleAction::SetUrgency(2);

        let serialized_suppress = serde_json::to_string(&action_suppress).unwrap();
        let deserialized_suppress: RuleAction = serde_json::from_str(&serialized_suppress).unwrap();
        assert_eq!(action_suppress, deserialized_suppress);

        let serialized_exec = serde_json::to_string(&action_exec).unwrap();
        let deserialized_exec: RuleAction = serde_json::from_str(&serialized_exec).unwrap();
        assert_eq!(action_exec, deserialized_exec);

        let serialized_sound = serde_json::to_string(&action_sound).unwrap();
        let deserialized_sound: RuleAction = serde_json::from_str(&serialized_sound).unwrap();
        assert_eq!(action_sound, deserialized_sound);

        let serialized_urgency = serde_json::to_string(&action_urgency).unwrap();
        let deserialized_urgency: RuleAction = serde_json::from_str(&serialized_urgency).unwrap();
        assert_eq!(action_urgency, deserialized_urgency);
    }

    #[test]
    fn test_notification_rule_serialization_deserialization() {
        let rule = NotificationRule {
            id: Uuid::new_v4(),
            name: "Mute Discord notifications".to_string(),
            enabled: true,
            priority: 100,
            condition: RuleCondition::Simple(SimpleRuleCondition {
                field: Field::AppName,
                operator: Operator::Equals,
                value: RuleConditionValue::Text("Discord".to_string()),
            }),
            actions: vec![RuleAction::Suppress, RuleAction::Log("Discord notification suppressed".to_string())],
            stop_processing_further_rules: true,
        };

        let serialized = serde_json::to_string(&rule).unwrap();
        let deserialized: NotificationRule = serde_json::from_str(&serialized).unwrap();
        assert_eq!(rule, deserialized);
    }

    #[test]
    fn test_notification_rule_set_serialization_deserialization() {
        let rule1 = NotificationRule {
            id: Uuid::new_v4(),
            name: "Rule 1".to_string(),
            enabled: true,
            priority: 10,
            condition: RuleCondition::Simple(SimpleRuleCondition {
                field: Field::Summary,
                operator: Operator::Contains,
                value: RuleConditionValue::Text("Hello".to_string()),
            }),
            actions: vec![RuleAction::Log("Rule 1 matched".to_string())],
            stop_processing_further_rules: false,
        };
        let rule2 = NotificationRule {
            id: Uuid::new_v4(),
            name: "Rule 2".to_string(),
            enabled: false,
            priority: 5,
            condition: RuleCondition::Simple(SimpleRuleCondition {
                field: Field::AppName,
                operator: Operator::Equals,
                value: RuleConditionValue::Text("TestApp".to_string()),
            }),
            actions: vec![RuleAction::SetUrgency(0)],
            stop_processing_further_rules: true,
        };

        let rule_set = NotificationRuleSet {
            rules: vec![rule1.clone(), rule2.clone()],
        };

        let serialized = serde_json::to_string(&rule_set).unwrap();
        let deserialized: NotificationRuleSet = serde_json::from_str(&serialized).unwrap();
        assert_eq!(rule_set, deserialized);

        // Test Default trait
        let default_set = NotificationRuleSet::default();
        assert!(default_set.rules.is_empty());
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser siebte Teil (7 von 100) widmet sich weiterhin der Domänenschicht (`novade-domain`), diesmal mit der detaillierten Spezifikation des `notification_rules::errors`-Moduls. Ein robustes Fehlermanagement ist entscheidend für die Stabilität und Wartbarkeit des Systems, insbesondere bei der Verarbeitung komplexer Regeln und externer Interaktionen.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 7/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.15.2. `novade-domain/src/notification_rules/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/errors.rs`
  * **Verantwortlichkeit:** Definiert alle spezifischen Fehlerarten, die während der Verarbeitung, Speicherung, Laden oder Anwendung von Benachrichtigungsregeln auftreten können. Stellt sicher, dass Fehler kontextuell und informativ sind und eine klare Kette bis zur Ursprungsfehlerquelle (`source`) bieten.
  * **Kern-Aufgaben (Tasks):**
    1.  **`NotificationRulesError` Enum definieren:**
          * Basis-Fehlertyp für das gesamte `notification_rules`-Modul.
          * Varianten:
              * `ConfigError(#[from] ConfigError)`: Fehler beim Laden oder Speichern von Regeln über den `ConfigService`.
              * `InvalidRuleData(String)`: Tritt auf, wenn geladene oder erstellte Regeldaten semantisch ungültig sind (z.B. fehlende Pflichtfelder, inkonsistente Verknüpfungen in `RuleCondition`).
              * `RuleProcessingError(String)`: Allgemeine Fehler, die während der Auswertung von Regeln oder der Anwendung von Aktionen auftreten (z.B. Befehl kann nicht ausgeführt werden, Sound-Datei nicht gefunden).
              * `RuleNotFound(Uuid)`: Eine Regel mit der angegebenen ID wurde nicht gefunden (z.B. beim Versuch, eine spezifische Regel zu aktualisieren oder zu löschen).
              * `IoError(#[from] IoError)`: Fehler auf Dateisystemebene, wenn z.B. Regeldateien nicht gelesen oder geschrieben werden können (dies kann über `ConfigError` auch indirekt kommen, aber direkte IO Fehler sind auch möglich).
              * `Generic(String)`: Für allgemeine, nicht kategorisierte Fehler (sollte sparsam verwendet werden).
          * Ableitungen: `Debug`, `Display`, `Error`, `thiserror::Error`.
          * Implementiert `From` für die Konvertierung von `ConfigError` und `IoError` aus der `novade_core` Crate.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/errors.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_core::error::{ConfigError, IoError}`.
      * **Extern:** `thiserror` (`#[from]`, `#[error]`), `std::io::Error`, `std::fmt`, `uuid::Uuid`.
  * **Kommunikationsmuster:** Fehler werden von tieferliegenden Schichten oder Modulen (`ConfigService`, Dateisystem-Operationen) in `NotificationRulesError` konvertiert und an die aufrufenden Schichten (z.B. `notification_service`, UI) weitergegeben.
  * **Erwartete Ergebnisse/Outputs:** Eine klare und hierarchische Fehlerdefinition, die eine präzise Fehlerbehandlung und -protokollierung ermöglicht.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Erzeugung jeder `NotificationRulesError`-Variante.
          * Testen der `Display`-Implementierung für jede Variante, um korrekte Fehlermeldungen sicherzustellen.
          * Testen der `source()`-Methode für Fehler, die eine Ursache haben (z.B. `ConfigError`, `IoError`), um die Fehlerkette zu überprüfen.
          * Testen der `From` -Konvertierungen von `ConfigError` und `IoError`.

#### Funktionsspezifikation: `novade_domain::notification_rules::errors`

```rust
// novade-domain/src/notification_rules/errors.rs

use thiserror::Error;
use std::fmt;
use uuid::Uuid;

// Import der Fehler-Enums aus der Kernschicht
use novade_core::error::{ConfigError, IoError};

/// Haupt-Fehlertyp für das Benachrichtigungsregelsystem.
#[derive(Debug, Error)]
pub enum NotificationRulesError {
    /// Ein Fehler, der während des Ladens oder Speicherns von Regeln über den ConfigService auftrat.
    ///
    /// # Felder
    /// * `#[from] ConfigError`: Die ursprüngliche `ConfigError`-Fehlerquelle.
    #[error("Configuration error related to notification rules: {0}")]
    ConfigError(#[from] ConfigError),

    /// Tritt auf, wenn geladene oder erstellte Regeldaten semantisch ungültig sind.
    /// Dies kann beispielsweise bei fehlenden Pflichtfeldern oder inkonsistenten
    /// logischen Verknüpfungen in `RuleCondition` der Fall sein.
    ///
    /// # Felder
    /// * `0`: Eine beschreibende Fehlermeldung, die das Validierungsproblem erklärt.
    #[error("Invalid notification rule data: {0}")]
    InvalidRuleData(String),

    /// Ein allgemeiner Fehler, der während der Auswertung von Regeln oder der Anwendung
    /// von Aktionen auftrat. Dies kann z.B. eine fehlgeschlagene Befehlsausführung
    /// oder das Nichtauffinden einer Sound-Datei umfassen.
    ///
    /// # Felder
    /// * `0`: Eine beschreibende Fehlermeldung des Verarbeitungsproblems.
    #[error("Error during notification rule processing: {0}")]
    RuleProcessingError(String),

    /// Tritt auf, wenn eine Regel mit der angegebenen UUID nicht gefunden wurde,
    /// z.B. beim Versuch, eine spezifische Regel zu aktualisieren oder zu löschen.
    ///
    /// # Felder
    /// * `0`: Die UUID der nicht gefundenen Regel.
    #[error("Notification rule with ID '{0}' not found.")]
    RuleNotFound(Uuid),

    /// Ein Fehler, der während direkter Dateisystem-Operationen auftrat,
    /// falls diese nicht bereits durch `ConfigError` abgedeckt sind.
    ///
    /// # Felder
    /// * `#[from] IoError`: Die ursprüngliche `IoError`-Fehlerquelle.
    #[error("I/O error during notification rules operation: {0}")]
    IoError(#[from] IoError),

    /// Ein allgemeiner, nicht näher spezifizierter Fehler.
    /// Sollte nur verwendet werden, wenn keine der spezifischeren Varianten zutrifft.
    ///
    /// # Felder
    /// * `0`: Eine generische Fehlermeldung.
    #[error("An unexpected error occurred in notification rules: {0}")]
    Generic(String),
}

#[cfg(test)]
mod tests {
    use super::*;
    use novade_core::error::{ConfigError, IoError, CoreError};
    use std::io;

    #[test]
    fn test_config_error_conversion() {
        let core_config_error = ConfigError::LoadingError {
            path: "/nonexistent/path".into(),
            source: IoError::Generic(io::Error::new(io::ErrorKind::NotFound, "file not found").into()),
        };
        let error: NotificationRulesError = core_config_error.into();
        assert!(matches!(error, NotificationRulesError::ConfigError(_)));
        if let NotificationRulesError::ConfigError(e) = error {
            assert_eq!(e.to_string(), "Failed to load configuration from /nonexistent/path: generic I/O error: file not found");
        }
    }

    #[test]
    fn test_invalid_rule_data_error() {
        let error = NotificationRulesError::InvalidRuleData("Missing required field 'condition'".to_string());
        assert_eq!(error.to_string(), "Invalid notification rule data: Missing required field 'condition'");
    }

    #[test]
    fn test_rule_processing_error() {
        let error = NotificationRulesError::RuleProcessingError("Failed to execute command: permission denied".to_string());
        assert_eq!(error.to_string(), "Error during notification rule processing: Failed to execute command: permission denied");
    }

    #[test]
    fn test_rule_not_found_error() {
        let id = Uuid::new_v4();
        let error = NotificationRulesError::RuleNotFound(id);
        assert_eq!(error.to_string(), format!("Notification rule with ID '{}' not found.", id));
    }

    #[test]
    fn test_io_error_conversion() {
        let io_err = io::Error::new(io::ErrorKind::PermissionDenied, "access denied");
        let core_io_error: IoError = io_err.into();
        let error: NotificationRulesError = core_io_error.into();
        assert!(matches!(error, NotificationRulesError::IoError(_)));
        if let NotificationRulesError::IoError(e) = error {
            assert_eq!(e.to_string(), "I/O error: access denied");
        }
    }

    #[test]
    fn test_generic_error() {
        let error = NotificationRulesError::Generic("Something truly unexpected happened".to_string());
        assert_eq!(error.to_string(), "An unexpected error occurred in notification rules: Something truly unexpected happened");
    }

    #[test]
    fn test_error_source_chaining() {
        let original_io_error = io::Error::new(io::ErrorKind::BrokenPipe, "pipe closed");
        let core_io_error: IoError = original_io_error.into();
        let config_error = ConfigError::SavingError {
            path: "/tmp/rules.json".into(),
            source: core_io_error.clone(), // Use clone to assert source later
        };
        let rules_error: NotificationRulesError = config_error.into();

        assert!(matches!(rules_error, NotificationRulesError::ConfigError(_)));

        // Check the source chain
        let source_config_error = rules_error.source().unwrap();
        let source_io_error = source_config_error.source().unwrap();

        assert_eq!(source_io_error.to_string(), core_io_error.to_string());
        assert_eq!(source_io_error.downcast_ref::<IoError>().unwrap().to_string(), "I/O error: pipe closed");
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser siebte Teil (8 von 100) widmet sich weiterhin der Domänenschicht (`novade-domain`), diesmal mit der detaillierten Spezifikation des `notification_rules::persistence_iface`-Moduls. Die Definition einer klaren Schnittstelle für die Persistenz der Regeln ist essenziell, um die `engine` vom konkreten Speicherungsmechanismus zu entkoppeln und Testbarkeit sowie Austauschbarkeit zu gewährleisten.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 8/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.15.3. `novade-domain/src/notification_rules/persistence_iface.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/persistence_iface.rs`
  * **Verantwortlichkeit:** Definiert den `NotificationRulesProvider`-Trait, der die Schnittstelle für das Laden und Speichern von Benachrichtigungsregeln darstellt. Diese Abstraktion ist entscheidend für die Testbarkeit und ermöglicht es, verschiedene Speichermechanismen (Dateisystem, Datenbank, In-Memory für Tests) zu verwenden, ohne die `NotificationRulesEngine` ändern zu müssen.
  * **Kern-Aufgaben (Tasks):**
    1.  **`NotificationRulesProvider` Trait definieren:**
          * **Asynchrone Methoden:** Alle Methoden müssen `async` sein, da Persistenzoperationen I/O-gebunden sind.
          * **`load_rules()` Methode:**
              * Signatur: `async fn load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`
              * Zweck: Lädt die gesamte Sammlung von Benachrichtigungsregeln aus dem persistenten Speicher.
              * Fehlerbehandlung: Gibt `NotificationRulesError` zurück, insbesondere `ConfigError` oder `IoError` bei Problemen. Sollte `NotificationRuleSet::default()` zurückgeben, wenn keine Regeln gefunden werden, anstatt einen Fehler zu werfen (es sei denn, der Fehler ist ein echtes I/O-Problem, nicht nur "Datei nicht gefunden").
          * **`save_rules()` Methode:**
              * Signatur: `async fn save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`
              * Zweck: Speichert die aktuelle Sammlung von Benachrichtigungsregeln in den persistenten Speicher.
              * Fehlerbehandlung: Gibt `NotificationRulesError` zurück, insbesondere `ConfigError` oder `IoError` bei Problemen.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/persistence_iface.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notification_rules::data_types::NotificationRuleSet`, `crate::notification_rules::errors::NotificationRulesError`.
      * **Extern:** `async_trait` (für asynchrone Traits), `tokio`.
  * **Kommunikationsmuster:** Definiert einen Vertrag für die Interaktion mit dem persistenten Speicher. Wird von `NotificationRulesEngine` verwendet und von konkreten Implementierungen (z.B. `FilesystemNotificationRulesProvider`) implementiert.
  * **Erwartete Ergebnisse/Outputs:** Ein klar definierter Trait, der die Schnittstelle für die Regel-Persistenz abstrahiert.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Erstellung eines Mock-Implementierung des `NotificationRulesProvider` Traits, um zu testen, dass der Trait korrekt definiert ist und die erwarteten Methoden-Signaturen bereitstellt.
          * Tests, die sicherstellen, dass `load_rules` und `save_rules` die korrekten `Result`-Typen und Fehler zurückgeben können.

#### Funktionsspezifikation: `novade_domain::notification_rules::persistence_iface`

```rust
// novade-domain/src/notification_rules/persistence_iface.rs

use async_trait::async_trait;

use crate::notification_rules::data_types::NotificationRuleSet;
use crate::notification_rules::errors::NotificationRulesError;

/// Trait zur Definition der Schnittstelle für das Laden und Speichern von Benachrichtigungsregeln.
///
/// Diese Abstraktion ermöglicht es, den konkreten Speicherungsmechanismus
/// (z.B. Dateisystem, Datenbank, In-Memory für Tests) von der Kernlogik
/// der Regelverarbeitung zu entkoppeln.
#[async_trait]
pub trait NotificationRulesProvider: Send + Sync {
    /// Lädt die gesamte Sammlung von Benachrichtigungsregeln aus dem persistenten Speicher.
    ///
    /// Wenn keine Regeln gefunden werden (z.B. die Konfigurationsdatei existiert nicht),
    /// sollte eine leere `NotificationRuleSet` (`NotificationRuleSet::default()`) zurückgegeben werden,
    /// es sei denn, es handelt sich um einen echten I/O-Fehler (z.B. Berechtigungsprobleme).
    ///
    /// # Returns
    /// Ein `Result` mit der `NotificationRuleSet` bei Erfolg, oder `NotificationRulesError` bei einem Fehler.
    /// Mögliche Fehler: `ConfigError` (z.B. Deserialisierungsfehler), `IoError` (z.B. Dateizugriffsfehler).
    async fn load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>;

    /// Speichert die gegebene Sammlung von Benachrichtigungsregeln in den persistenten Speicher.
    ///
    /// # Arguments
    /// * `rules` - Eine Referenz auf die `NotificationRuleSet`, die gespeichert werden soll.
    ///
    /// # Returns
    /// Ein `Result` das den Erfolg der Operation anzeigt, oder `NotificationRulesError` bei einem Fehler.
    /// Mögliche Fehler: `ConfigError` (z.B. Serialisierungsfehler), `IoError` (z.B. Dateischreibfehler).
    async fn save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>;
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::notification_rules::data_types::NotificationRuleSet;
    use crate::notification_rules::errors::NotificationRulesError;
    use std::sync::{Arc, Mutex};
    use async_trait::async_trait;

    /// Eine Mock-Implementierung von `NotificationRulesProvider` für Testzwecke.
    /// Sie speichert Regeln einfach im Arbeitsspeicher.
    struct MockNotificationRulesProvider {
        // Ein Mutex ist hier notwendig, da Arc<RwLock> in async-trait Testfällen
        // zu Problemen führen kann, wenn die Mock-Daten zwischen verschiedenen
        // async-Aufrufen persistiert werden müssen und nicht nur geklont.
        // Für eine einfache In-Memory-Speicherung ist Mutex ausreichend.
        rules: Mutex<NotificationRuleSet>,
    }

    impl MockNotificationRulesProvider {
        fn new(initial_rules: Option<NotificationRuleSet>) -> Self {
            Self {
                rules: Mutex::new(initial_rules.unwrap_or_default()),
            }
        }
    }

    #[async_trait]
    impl NotificationRulesProvider for MockNotificationRulesProvider {
        async fn load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError> {
            let rules = self.rules.lock().unwrap().clone();
            // Simulate potential I/O delay
            tokio::time::sleep(tokio::time::Duration::from_millis(5)).await;
            Ok(rules)
        }

        async fn save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError> {
            let mut guard = self.rules.lock().unwrap();
            *guard = rules.clone();
            // Simulate potential I/O delay
            tokio::time::sleep(tokio::time::Duration::from_millis(5)).await;
            Ok(())
        }
    }

    #[tokio::test]
    async fn test_mock_provider_load_empty() {
        let provider = MockNotificationRulesProvider::new(None);
        let rules = provider.load_rules().await.unwrap();
        assert!(rules.rules.is_empty());
    }

    #[tokio::test]
    async fn test_mock_provider_save_and_load() {
        let provider = MockNotificationRulesProvider::new(None);
        let initial_rules = NotificationRuleSet {
            rules: vec![
                crate::notification_rules::data_types::NotificationRule {
                    id: Uuid::new_v4(),
                    name: "Test Rule".to_string(),
                    enabled: true,
                    priority: 0,
                    condition: crate::notification_rules::data_types::RuleCondition::Simple(
                        crate::notification_rules::data_types::SimpleRuleCondition {
                            field: crate::notification_rules::data_types::Field::AppName,
                            operator: crate::notification_rules::data_types::Operator::Equals,
                            value: crate::notification_rules::data_types::RuleConditionValue::Text("TestApp".to_string()),
                        },
                    ),
                    actions: vec![],
                    stop_processing_further_rules: false,
                },
            ],
        };

        provider.save_rules(&initial_rules).await.unwrap();

        let loaded_rules = provider.load_rules().await.unwrap();
        assert_eq!(loaded_rules, initial_rules);
    }

    #[tokio::test]
    async fn test_mock_provider_load_with_initial_data() {
        let initial_rules = NotificationRuleSet {
            rules: vec![
                crate::notification_rules::data_types::NotificationRule {
                    id: Uuid::new_v4(),
                    name: "Initial Rule".to_string(),
                    enabled: true,
                    priority: 0,
                    condition: crate::notification_rules::data_types::RuleCondition::Simple(
                        crate::notification_rules::data_types::SimpleRuleCondition {
                            field: crate::notification_rules::data_types::Field::Summary,
                            operator: crate::notification_rules::data_types::Operator::Contains,
                            value: crate::notification_rules::data_types::RuleConditionValue::Text("Important".to_string()),
                        },
                    ),
                    actions: vec![],
                    stop_processing_further_rules: false,
                },
            ],
        };
        let provider = MockNotificationRulesProvider::new(Some(initial_rules.clone()));
        let loaded_rules = provider.load_rules().await.unwrap();
        assert_eq!(loaded_rules, initial_rules);
    }
}

```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (9 von 100) widmet sich weiterhin der Domänenschicht (`novade-domain`), diesmal mit der detaillierten Spezifikation des `notification_rules::persistence`-Moduls. Dieses Modul wird die konkrete Implementierung des im vorherigen Schritt definierten `NotificationRulesProvider`-Traits bereitstellen, indem es den `ConfigService` aus der `novade-core`-Schicht nutzt, um Regeln auf dem Dateisystem zu speichern und zu laden.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 9/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.15.4. `novade-domain/src/notification_rules/persistence.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/persistence.rs`
  * **Verantwortlichkeit:** Implementiert den `NotificationRulesProvider`-Trait, um Benachrichtigungsregeln persistent zu speichern und zu laden. Nutzt dafür den `ConfigService` aus der `novade-core`-Schicht, der die zugrundeliegenden Serialisierungs- und Dateisystemoperationen handhabt.
  * **Kern-Aufgaben (Tasks):**
    1.  **Konstante `NOTIFICATION_RULES_FILE` definieren:**
          * String-Konstante für den Dateinamen der Regelkonfiguration (z.B. `"notification_rules.json"` oder ähnlich). Sollte der XDG Base Directory Specification folgen, indem der `ConfigService` genutzt wird, um den vollständigen Pfad abzuleiten.
    2.  **`FilesystemNotificationRulesProvider` Struct definieren:**
          * Feld: `config_service: Arc<ConfigService>`.
          * Dieses Struct wird der konkrete Persistenz-Provider sein.
    3.  **Konstruktor `new()` implementieren:**
          * Signatur: `pub fn new(config_service: Arc<ConfigService>) -> Self`
          * Zweck: Erzeugt eine neue Instanz des Providers.
    4.  **`NotificationRulesProvider` Trait für `FilesystemNotificationRulesProvider` implementieren:**
          * **`load_rules()` Methode implementieren:**
              * Ruft `self.config_service.load_config()` auf, um die `NotificationRuleSet` zu laden.
              * Nutzt `NOTIFICATION_RULES_FILE` als Dateipfad.
              * Behandelt `ConfigError::NotFound` (oder den entsprechenden `IoError::NotFound` innerhalb von `ConfigError`): In diesem Fall sollte `NotificationRuleSet::default()` zurückgegeben werden, da es sich um eine gültige Anfangsbedingung handelt (noch keine Regeln definiert).
              * Andere `ConfigError`s sollten in `NotificationRulesError::ConfigError` umgewandelt und zurückgegeben werden.
          * **`save_rules()` Methode implementieren:**
              * Ruft `self.config_service.save_config()` auf, um die `NotificationRuleSet` zu speichern.
              * Nutzt `NOTIFICATION_RULES_FILE` als Dateipfad.
              * Alle `ConfigError`s sollten in `NotificationRulesError::ConfigError` umgewandelt und zurückgegeben werden.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/persistence.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notification_rules::data_types::NotificationRuleSet`, `crate::notification_rules::errors::NotificationRulesError`, `crate::notification_rules::persistence_iface::NotificationRulesProvider`, `novade_core::config::service::ConfigService`, `novade_core::error::ConfigError`.
      * **Extern:** `async_trait`, `tokio`, `std::sync::Arc`, `tracing`.
  * **Kommunikationsmuster:** Direkte Nutzung des `ConfigService` API für Dateisystem-I/O. Erfüllt den Vertrag des `NotificationRulesProvider`-Traits.
  * **Erwartete Ergebnisse/Outputs:** Eine funktionale Implementierung des Regel-Persistenzmechanismus.
  * **Teststrategie (Modul-spezifisch):**
      * **Integration Tests (mit einem gemockten/temporären `ConfigService`):**
          * Testen des Ladens von Regeln, wenn die Datei nicht existiert (sollte leeres `NotificationRuleSet` zurückgeben).
          * Testen des Speicherns von Regeln und des anschließenden Ladens, um die Datenintegrität zu überprüfen.
          * Testen des Verhaltens bei ungültigen JSON-Daten in der Regeldatei (sollte `ConfigError::DeserializationError` -\> `NotificationRulesError::ConfigError` zurückgeben).
          * Testen von I/O-Fehlern (z.B. Berechtigungen zum Schreiben/Lesen der Datei fehlen), um sicherzustellen, dass die Fehler korrekt propagiert werden.
          * Verwendung von `tempfile` für temporäre Verzeichnisse und Dateien, um die Tests isoliert und sauber zu halten.

#### Funktionsspezifikation: `novade_domain::notification_rules::persistence`

```rust
// novade-domain/src/notification_rules/persistence.rs

use async_trait::async_trait;
use std::sync::Arc;
use tracing::{info, warn, error};

use crate::notification_rules::data_types::NotificationRuleSet;
use crate::notification_rules::errors::NotificationRulesError;
use crate::notification_rules::persistence_iface::NotificationRulesProvider;
use novade_core::config::service::ConfigService;
use novade_core::error::ConfigError;

/// Dateiname für die persistente Speicherung der Benachrichtigungsregeln.
/// Die genaue Position wird vom `ConfigService` basierend auf der XDG Base Directory Specification bestimmt.
const NOTIFICATION_RULES_FILE: &str = "notification_rules.json";

/// Implementierung des `NotificationRulesProvider`-Traits, der Benachrichtigungsregeln
/// im Dateisystem über den `ConfigService` speichert und lädt.
pub struct FilesystemNotificationRulesProvider {
    config_service: Arc<ConfigService>,
}

impl FilesystemNotificationRulesProvider {
    /// Erstellt eine neue Instanz von `FilesystemNotificationRulesProvider`.
    ///
    /// # Arguments
    /// * `config_service` - Ein `Arc` zu einem `ConfigService`, der für die
    ///   zugrundeliegenden Dateioperationen verwendet wird.
    ///
    /// # Returns
    /// Eine neue `FilesystemNotificationRulesProvider`-Instanz.
    pub fn new(config_service: Arc<ConfigService>) -> Self {
        Self { config_service }
    }
}

#[async_trait]
impl NotificationRulesProvider for FilesystemNotificationRulesProvider {
    /// Lädt die Benachrichtigungsregeln aus der Konfigurationsdatei.
    ///
    /// Wenn die Datei nicht existiert oder leer ist, wird ein leeres `NotificationRuleSet` zurückgegeben.
    /// Andere Fehler (z.B. Deserialisierungsfehler, Berechtigungsprobleme) werden als `NotificationRulesError` propagiert.
    ///
    /// # Returns
    /// Ein `Result` mit der geladenen `NotificationRuleSet` bei Erfolg,
    /// oder `NotificationRulesError` bei einem Problem.
    async fn load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError> {
        info!("Attempting to load notification rules from '{}'", NOTIFICATION_RULES_FILE);
        match self.config_service.load_config(NOTIFICATION_RULES_FILE).await {
            Ok(rules_set) => {
                info!("Successfully loaded notification rules.");
                Ok(rules_set)
            }
            Err(ConfigError::LoadingError { path, source }) if matches!(source.kind(), std::io::ErrorKind::NotFound) => {
                // If the file doesn't exist, it's not an error, just an empty rule set.
                warn!("Notification rules file '{}' not found. Returning empty rule set.", path.display());
                Ok(NotificationRuleSet::default())
            }
            Err(e) => {
                error!("Failed to load notification rules: {}", e);
                Err(NotificationRulesError::ConfigError(e))
            }
        }
    }

    /// Speichert die Benachrichtigungsregeln in die Konfigurationsdatei.
    ///
    /// # Arguments
    /// * `rules` - Eine Referenz auf die `NotificationRuleSet`, die gespeichert werden soll.
    ///
    /// # Returns
    /// Ein `Result<(), NotificationRulesError>` das den Erfolg der Operation anzeigt.
    async fn save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError> {
        info!("Attempting to save notification rules to '{}'", NOTIFICATION_RULES_FILE);
        self.config_service.save_config(NOTIFICATION_RULES_FILE, rules)
            .await
            .map_err(|e| {
                error!("Failed to save notification rules: {}", e);
                NotificationRulesError::ConfigError(e)
            })?;
        info!("Successfully saved notification rules.");
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;
    use std::fs;
    use std::io::Write;
    use novade_core::config::persistence::FilesystemConfigProvider;
    use crate::notification_rules::data_types::{NotificationRule, RuleCondition, SimpleRuleCondition, Field, Operator, RuleConditionValue};
    use uuid::Uuid;

    // Helper function to set up a test ConfigService with a temporary directory
    async fn setup_test_config_service() -> (Arc<ConfigService>, tempfile::TempDir) {
        let temp_dir = tempdir().unwrap();
        let provider = Arc::new(FilesystemConfigProvider::new_with_base_dir(temp_dir.path().to_path_buf()));
        let config_service = Arc::new(ConfigService::new(provider).unwrap());
        (config_service, temp_dir)
    }

    #[tokio::test]
    async fn test_load_rules_file_not_found() {
        let (config_service, _temp_dir) = setup_test_config_service().await;
        let provider = FilesystemNotificationRulesProvider::new(config_service);

        let rules = provider.load_rules().await.unwrap();
        assert!(rules.rules.is_empty(), "Should return an empty rule set if file not found");
    }

    #[tokio::test]
    async fn test_save_and_load_rules() {
        let (config_service, temp_dir) = setup_test_config_service().await;
        let provider = FilesystemNotificationRulesProvider::new(config_service.clone());

        let mut initial_rules = NotificationRuleSet::default();
        initial_rules.rules.push(NotificationRule {
            id: Uuid::new_v4(),
            name: "Test Rule 1".to_string(),
            enabled: true,
            priority: 10,
            condition: RuleCondition::Simple(SimpleRuleCondition {
                field: Field::AppName,
                operator: Operator::Equals,
                value: RuleConditionValue::Text("TestApp".to_string()),
            }),
            actions: vec![],
            stop_processing_further_rules: false,
        });

        // Save rules
        provider.save_rules(&initial_rules).await.unwrap();

        // Check if file exists
        let config_path = config_service.get_config_path(NOTIFICATION_RULES_FILE);
        assert!(config_path.exists());

        // Load rules and verify
        let loaded_rules = provider.load_rules().await.unwrap();
        assert_eq!(loaded_rules.rules.len(), 1);
        assert_eq!(loaded_rules.rules[0].name, "Test Rule 1");
        assert_eq!(loaded_rules, initial_rules);
    }

    #[tokio::test]
    async fn test_load_rules_invalid_json() {
        let (config_service, temp_dir) = setup_test_config_service().await;
        let provider = FilesystemNotificationRulesProvider::new(config_service);

        // Create an invalid JSON file
        let config_path = temp_dir.path().join(NOTIFICATION_RULES_FILE);
        fs::File::create(&config_path).unwrap().write_all(b"{ \"rules\": [ { \"id\": \"invalid\" } ] }").unwrap();

        let error = provider.load_rules().await.unwrap_err();
        assert!(matches!(error, NotificationRulesError::ConfigError(ConfigError::LoadingError { .. })));
        if let NotificationRulesError::ConfigError(ConfigError::LoadingError { source, .. }) = error {
            assert!(source.to_string().contains("data did not match the expected type"));
        }
    }

    #[tokio::test]
    async fn test_save_rules_permission_denied() {
        let (config_service, temp_dir) = setup_test_config_service().await;
        let provider = FilesystemNotificationRulesProvider::new(config_service);

        // Make the directory unwritable (on Unix-like systems)
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            fs::set_permissions(temp_dir.path(), fs::Permissions::from_mode(0o444)).unwrap();
        }

        let rules_to_save = NotificationRuleSet::default();
        let error = provider.save_rules(&rules_to_save).await.unwrap_err();

        #[cfg(unix)]
        assert!(matches!(error, NotificationRulesError::ConfigError(ConfigError::SavingError { source, .. }) if source.kind() == std::io::ErrorKind::PermissionDenied));

        #[cfg(windows)] // Windows permission errors might manifest differently
        assert!(matches!(error, NotificationRulesError::ConfigError(ConfigError::SavingError { .. })));
    }
}

# Notification Rules Engine

### `novade-domain/src/notification_rules/engine.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/engine.rs`
  * **Verantwortlichkeit:** Die `NotificationRulesEngine` ist für die Verwaltung (Laden, Speichern, Aktualisieren) und die Anwendung von Benachrichtigungsregeln auf eingehende Benachrichtigungen zuständig. Sie ist die zentrale Komponente, die die `NotificationRuleSet` hält und die Logik zur Bedingungsprüfung und Aktionsausführung enthält.
  * **Kern-Aufgaben (Tasks):**
    1.  **`RuleProcessingResult` Enum definieren:**
          * Repräsentiert das Ergebnis der Regelverarbeitung für eine einzelne Benachrichtigung.
          * Varianten:
              * `Processed`: Die Benachrichtigung wurde verarbeitet, aber keine Suppress-Aktion wurde ausgelöst. Die Benachrichtigung soll normal angezeigt werden (ggf. mit Modifikationen).
              * `Suppressed`: Die Benachrichtigung wurde von einer Regel unterdrückt und soll nicht angezeigt werden.
          * Ableitungen: `Debug`, `PartialEq`, `Eq`.
    2.  **`NotificationRulesEngine` Trait definieren:**
          * Zweck: Definiert die öffentliche Schnittstelle der Regel-Engine. Ermöglicht Mocking für Tests.
          * Asynchrone Methoden (`async_trait`):
              * `process_notification(notification: &mut IncomingNotification) -> RuleProcessingResult`: Verarbeitet eine eingehende Benachrichtigung gegen die geladenen Regeln. Wendet Aktionen an und gibt das Verarbeitungsergebnis zurück. **WICHTIG:** `IncomingNotification` muss mutable sein, da Aktionen die Benachrichtigung modifizieren können.
              * `reload_rules() -> Result<(), NotificationRulesError>`: Lädt die Regeln neu vom `NotificationRulesProvider`. Muss die internen Regeln atomar aktualisieren (z.B. mittels `RwLock`).
              * `get_rules() -> NotificationRuleSet`: Gibt eine Kopie der aktuell geladenen Regeln zurück.
              * `add_rule(rule: NotificationRule) -> Result<(), NotificationRulesError>`: Fügt eine neue Regel hinzu und speichert die aktualisierte Menge.
              * `update_rule(rule: NotificationRule) -> Result<(), NotificationRulesError>`: Aktualisiert eine bestehende Regel (identifiziert durch `id`) und speichert die aktualisierte Menge. Gibt `RuleNotFound` zurück, wenn die ID nicht existiert.
              * `delete_rule(id: Uuid) -> Result<(), NotificationRulesError>`: Löscht eine Regel anhand ihrer ID und speichert die aktualisierte Menge. Gibt `RuleNotFound` zurück, wenn die ID nicht existiert.
    3.  **`DefaultNotificationRulesEngine` Struct definieren:**
          * Felder:
              * `rules: Arc<RwLock<NotificationRuleSet>>`: Hält die aktuell geladenen Benachrichtigungsregeln im Speicher. `RwLock` ist für effizienten Lesezugriff und sicheren Schreibzugriff wichtig. `Arc` ermöglicht gemeinsame Ownership.
              * `provider: Arc<dyn NotificationRulesProvider>`: Der Persistenz-Provider, über den Regeln geladen und gespeichert werden.
              * `log_sender: broadcast::Sender<LogEntry>`: Ein Sender für Logging-Nachrichten, um interne Engine-Aktivitäten (z.B. Regel-Treffer, Aktionsausführung) zu protokollieren.
              * `global_settings_service: Arc<GlobalSettingsService>`: Service zur Abfrage globaler Einstellungen, die für die Regelverarbeitung relevant sein könnten (z.B. "Do Not Disturb" Status, globale Lautstärke).
    4.  **Konstruktor `DefaultNotificationRulesEngine::new()` implementieren:**
          * Signatur: `pub async fn new(provider: Arc<dyn NotificationRulesProvider>, log_sender: broadcast::Sender<LogEntry>, global_settings_service: Arc<GlobalSettingsService>) -> Result<Self, NotificationRulesError>`
          * Zweck: Initialisiert die Engine. Lädt initial die Regeln über den `provider`.
    5.  **`evaluate_condition()` Funktion implementieren:**
          * Signatur: `fn evaluate_condition(condition: &RuleCondition, notification: &IncomingNotification) -> bool`
          * Zweck: Rekursive Funktion zur Auswertung einer `RuleCondition` gegen eine `IncomingNotification`.
          * Details:
              * Behandelt `Simple`, `And`, `Or`, `Not` rekursiv.
              * Für `SimpleRuleCondition`:
                  * Implementiert die Logik für jeden `Field` und `Operator`.
                  * `AppName`, `Summary`, `Body`, `Category`, `Icon`: String-Vergleiche mit `Text` `RuleConditionValue`.
                  * `Urgency`, `ExpireTimeout`: Numerische Vergleiche mit `Number` `RuleConditionValue`.
                  * `Hint(String)`: Greift auf den spezifischen Hint der Benachrichtigung zu.
                  * `IsSet`, `IsNotSet`: Prüft, ob das Feld (oder der Hint-Wert) in der Benachrichtigung vorhanden ist. Beachtet, dass `body` und `icon` optional sein können, ebenso wie Hints.
    6.  **`apply_action()` Funktion implementieren:**
          * Signatur: `async fn apply_action(action: &RuleAction, notification: &mut IncomingNotification, log_sender: &broadcast::Sender<LogEntry>, global_settings_service: &GlobalSettingsService) -> Result<(), NotificationRulesError>`
          * Zweck: Führt eine einzelne `RuleAction` aus.
          * Details:
              * `Suppress`: Setzt ein internes Flag in `IncomingNotification` oder im Kontext der Verarbeitung (wird später im `process_notification` gehandhabt).
              * `ExecuteCommand(String)`: Führt den Befehl asynchron aus (z.B. `tokio::process::Command`). Fehler protokollieren, aber nicht unbedingt propagieren, um die Regelverarbeitung nicht zu blockieren.
              * `PlaySound(PathBuf)`: Nutzt ein Audio-API (später definiert, evtl. `pipewire-rs`-Wrapper) zum Abspielen. Fehler protokollieren.
              * `SetUrgency(u8)`: Modifiziert das `urgency`-Feld der `IncomingNotification`.
              * `SetExpireTimeout(i32)`: Modifiziert das `expire_timeout`-Feld der `IncomingNotification`.
              * `SetCategory(String)`: Modifiziert das `category`-Feld der `IncomingNotification`.
              * `SetIcon(String)`: Modifiziert das `icon`-Feld der `IncomingNotification`.
              * `Log(String)`: Sendet eine `LogEntry` über `log_sender`.
              * `ShowToast(String)`: Sendet ein UI-Event oder ruft einen UI-Service auf, um eine kurzlebige Toast-Benachrichtigung anzuzeigen (Details später im UI-Modul).
    7.  **`NotificationRulesEngine` Trait für `DefaultNotificationRulesEngine` implementieren:**
          * **`process_notification()` Implementierung:**
              * Sperrt `rules` im Lese-Modus (`read()`).
              * Sortiert die Regeln nach `priority` absteigend (höchste Priorität zuerst).
              * Iteriert durch die Regeln:
                  * Prüft, ob die Regel `enabled` ist.
                  * Ruft `evaluate_condition()` auf.
                  * Wenn die Bedingung zutrifft:
                      * Führt alle `actions` der Regel mittels `apply_action()` aus. Protokolliert Fehler bei einzelnen Aktionen.
                      * Wenn eine `Suppress`-Aktion enthalten ist, setzt das interne `suppress_flag` in der `IncomingNotification`.
                      * Wenn `stop_processing_further_rules` auf `true` gesetzt ist, bricht die Schleife ab.
              * Nach der Schleife: Prüft das `suppress_flag` in `IncomingNotification` und gibt entsprechend `RuleProcessingResult::Suppressed` oder `RuleProcessingResult::Processed` zurück.
          * **`reload_rules()` Implementierung:**
              * Ruft `self.provider.load_rules().await` auf.
              * Bei Erfolg: Sperrt `rules` im Schreib-Modus (`write()`) und ersetzt das `NotificationRuleSet`.
              * Bei Fehler: Protokolliert den Fehler und gibt ihn zurück.
          * **`get_rules()` Implementierung:**
              * Sperrt `rules` im Lese-Modus (`read()`) und klont das `NotificationRuleSet`.
          * **`add_rule()` Implementierung:**
              * Sperrt `rules` im Schreib-Modus.
              * Fügt die neue Regel dem `Vec<NotificationRule>` hinzu.
              * Ruft `self.provider.save_rules()` auf. Wenn `save_rules` fehlschlägt, wird die hinzugefügte Regel im In-Memory-Set nicht rückgängig gemacht (dies könnte eine komplexere Transaktionslogik erfordern, ist aber für V1 akzeptabel).
          * **`update_rule()` Implementierung:**
              * Sperrt `rules` im Schreib-Modus.
              * Sucht die Regel nach `id`.
              * Wenn gefunden: Ersetzt die alte Regel durch die neue.
              * Wenn nicht gefunden: Gibt `NotificationRulesError::RuleNotFound` zurück.
              * Ruft `self.provider.save_rules()` auf.
          * **`delete_rule()` Implementierung:**
              * Sperrt `rules` im Schreib-Modus.
              * Entfernt die Regel nach `id` aus dem `Vec<NotificationRule>`.
              * Wenn gefunden: Ruft `self.provider.save_rules()` auf.
              * Wenn nicht gefunden: Gibt `NotificationRulesError::RuleNotFound` zurück.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/engine.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notification_rules::data_types::{NotificationRuleSet, NotificationRule, RuleCondition, RuleAction, Field, Operator, RuleConditionValue, SimpleRuleCondition}`, `crate::notification_rules::errors::NotificationRulesError`, `crate::notification_rules::persistence_iface::NotificationRulesProvider`, `novade_core::logging::LogEntry`, `novade_core::settings::GlobalSettingsService` (später detailliert).
      * **Extern:** `async_trait`, `tokio::sync::RwLock`, `tokio::sync::broadcast`, `std::sync::Arc`, `uuid::Uuid`, `tracing`, `tokio::process::Command` (für `ExecuteCommand`), `tokio::fs` (falls Sounds direkt gelesen werden).
  * **Kommunikationsmuster:**
      * Nutzt `NotificationRulesProvider` für Persistenz.
      * Nimmt `IncomingNotification` entgegen.
      * Sendet `LogEntry`s über `broadcast::Sender`.
      * Ruft `GlobalSettingsService` ab.
  * **Erwartete Ergebnisse/Outputs:** Eine robuste Engine, die Benachrichtigungsregeln dynamisch verarbeitet und auf eingehende Benachrichtigungen anwendet.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests (`evaluate_condition`):**
          * Umfassende Tests für alle `Field` und `Operator` Kombinationen, inkl. Edge Cases (leere Strings, Nulldurchgänge für Zahlen, fehlende Hints).
          * Tests für komplexe `And`, `Or`, `Not` Bedingungen, verschachtelt und in verschiedenen Kombinationen.
          * Beispiele für Match/No-Match Szenarien.
      * **Unit Tests (`apply_action`):**
          * Tests für jede `RuleAction` und deren Auswirkungen auf die `IncomingNotification` oder das System (z.B. Prüfung, ob ein Befehl gestartet wurde).
          * Mocking des `log_sender` und `GlobalSettingsService`.
      * **Integration Tests (`process_notification`):**
          * Szenarien mit mehreren Regeln, unterschiedlichen Prioritäten.
          * Testen von `stop_processing_further_rules`.
          * Testen von Regeln, die Benachrichtigungen modifizieren (Urgency, Timeout, Icon, Category).
          * Testen von Regeln, die unterdrücken.
      * **Integration Tests (Management Funktionen):**
          * Testen von `add_rule`, `update_rule`, `delete_rule` in Kombination mit `get_rules` und `reload_rules`.
          * Sicherstellen, dass Änderungen persistiert werden (Mock `NotificationRulesProvider`).
          * Testen von `RuleNotFound` Fällen.

#### Funktionsspezifikation: `novade_domain::notification_rules::engine`

```rust
// novade-domain/src/notification_rules/engine.rs

use async_trait::async_trait;
use std::sync::Arc;
use tokio::sync::{RwLock, broadcast};
use tracing::{info, warn, error, debug};
use uuid::Uuid;
use std::process::Stdio;
use std::path::PathBuf;

use crate::notification_rules::data_types::{
    NotificationRule, NotificationRuleSet, RuleCondition, RuleAction, Field, Operator, RuleConditionValue, SimpleRuleCondition
};
use crate::notification_rules::errors::NotificationRulesError;
use crate::notification_rules::persistence_iface::NotificationRulesProvider;
use novade_core::logging::{LogEntry, LogLevel};
use novade_core::settings::GlobalSettingsService; // Annahme: Wird später detailliert
use crate::notification_service::IncomingNotification; // Annahme: Existiert und ist mutable

/// Das Ergebnis der Verarbeitung einer Benachrichtigung durch die Regel-Engine.
#[derive(Debug, PartialEq, Eq)]
pub enum RuleProcessingResult {
    /// Die Benachrichtigung wurde verarbeitet und soll normal angezeigt werden (ggf. modifiziert).
    Processed,
    /// Die Benachrichtigung wurde von einer Regel unterdrückt und soll nicht angezeigt werden.
    Suppressed,
}

/// Trait zur Definition der öffentlichen Schnittstelle der Benachrichtigungsregel-Engine.
#[async_trait]
pub trait NotificationRulesEngine: Send + Sync {
    /// Verarbeitet eine eingehende Benachrichtigung gegen die geladenen Regeln.
    /// Aktionen, die die Benachrichtigung modifizieren, werden direkt angewendet.
    ///
    /// # Arguments
    /// * `notification` - Eine mutable Referenz auf die `IncomingNotification`, die verarbeitet werden soll.
    ///
    /// # Returns
    /// Ein `RuleProcessingResult`, das angibt, ob die Benachrichtigung unterdrückt wurde oder angezeigt werden soll.
    async fn process_notification(&self, notification: &mut IncomingNotification) -> RuleProcessingResult;

    /// Lädt die Benachrichtigungsregeln vom konfigurierten `NotificationRulesProvider` neu.
    /// Die internen Regeln werden atomar aktualisiert.
    ///
    /// # Returns
    /// Ein `Result<(), NotificationRulesError>` bei Erfolg oder Fehler.
    async fn reload_rules(&self) -> Result<(), NotificationRulesError>;

    /// Gibt eine Kopie der aktuell geladenen `NotificationRuleSet` zurück.
    ///
    /// # Returns
    /// Eine geklonte `NotificationRuleSet`.
    fn get_rules(&self) -> NotificationRuleSet;

    /// Fügt eine neue Benachrichtigungsregel hinzu und speichert die aktualisierte Menge.
    ///
    /// # Arguments
    /// * `rule` - Die neue `NotificationRule`, die hinzugefügt werden soll.
    ///
    /// # Returns
    /// Ein `Result<(), NotificationRulesError>` bei Erfolg oder Fehler.
    async fn add_rule(&self, rule: NotificationRule) -> Result<(), NotificationRulesError>;

    /// Aktualisiert eine bestehende Benachrichtigungsregel anhand ihrer ID und speichert die aktualisierte Menge.
    ///
    /// # Arguments
    /// * `rule` - Die aktualisierte `NotificationRule`. Die `id` wird zum Finden der Regel verwendet.
    ///
    /// # Returns
    /// Ein `Result<(), NotificationRulesError>` bei Erfolg, oder `NotificationRulesError::RuleNotFound`
    /// wenn keine Regel mit der gegebenen ID gefunden wurde, oder andere Fehler.
    async fn update_rule(&self, rule: NotificationRule) -> Result<(), NotificationRulesError>;

    /// Löscht eine Benachrichtigungsregel anhand ihrer ID und speichert die aktualisierte Menge.
    ///
    /// # Arguments
    /// * `id` - Die `Uuid` der zu löschenden Regel.
    ///
    /// # Returns
    /// Ein `Result<(), NotificationRulesError>` bei Erfolg, oder `NotificationRulesError::RuleNotFound`
    /// wenn keine Regel mit der gegebenen ID gefunden wurde, oder andere Fehler.
    async fn delete_rule(&self, id: Uuid) -> Result<(), NotificationRulesError>;
}

/// Die Standardimplementierung der `NotificationRulesEngine`.
pub struct DefaultNotificationRulesEngine {
    rules: Arc<RwLock<NotificationRuleSet>>,
    provider: Arc<dyn NotificationRulesProvider>,
    log_sender: broadcast::Sender<LogEntry>,
    global_settings_service: Arc<GlobalSettingsService>,
    // TODO: Eventuell ein SoundPlayer-Trait hier injizieren
}

impl DefaultNotificationRulesEngine {
    /// Erstellt eine neue Instanz der `DefaultNotificationRulesEngine`.
    /// Lädt initial die Regeln über den bereitgestellten Provider.
    ///
    /// # Arguments
    /// * `provider` - Der Persistenz-Provider für Benachrichtigungsregeln.
    /// * `log_sender` - Ein `broadcast::Sender` für Logging-Nachrichten.
    /// * `global_settings_service` - Der Service für globale Systemeinstellungen.
    ///
    /// # Returns
    /// Ein `Result` mit der `DefaultNotificationRulesEngine`-Instanz bei Erfolg.
    pub async fn new(
        provider: Arc<dyn NotificationRulesProvider>,
        log_sender: broadcast::Sender<LogEntry>,
        global_settings_service: Arc<GlobalSettingsService>,
    ) -> Result<Self, NotificationRulesError> {
        let rules = Arc::new(RwLock::new(NotificationRuleSet::default()));
        let engine = Self {
            rules,
            provider,
            log_sender,
            global_settings_service,
        };
        engine.reload_rules().await?; // Initiales Laden der Regeln
        Ok(engine)
    }

    /// Hilfsfunktion zur Auswertung einer einzelnen Regelbedingung.
    ///
    /// # Arguments
    /// * `condition` - Die zu evaluierende `RuleCondition`.
    /// * `notification` - Die `IncomingNotification`, gegen die die Bedingung geprüft wird.
    ///
    /// # Returns
    /// `true`, wenn die Bedingung zutrifft, `false` sonst.
    fn evaluate_condition(condition: &RuleCondition, notification: &IncomingNotification) -> bool {
        match condition {
            RuleCondition::Simple(simple_cond) => Self::evaluate_simple_condition(simple_cond, notification),
            RuleCondition::And(conditions) => conditions.iter().all(|c| Self::evaluate_condition(c, notification)),
            RuleCondition::Or(conditions) => conditions.iter().any(|c| Self::evaluate_condition(c, notification)),
            RuleCondition::Not(cond) => !Self::evaluate_condition(cond, notification),
        }
    }

    /// Hilfsfunktion zur Auswertung einer einfachen `SimpleRuleCondition`.
    fn evaluate_simple_condition(condition: &SimpleRuleCondition, notification: &IncomingNotification) -> bool {
        let field_value: Option<RuleConditionValue> = match &condition.field {
            Field::AppName => Some(RuleConditionValue::Text(notification.app_name.clone())),
            Field::Summary => Some(RuleConditionValue::Text(notification.summary.clone())),
            Field::Body => notification.body.clone().map(RuleConditionValue::Text),
            Field::Category => notification.category.clone().map(RuleConditionValue::Text),
            Field::Urgency => Some(RuleConditionValue::Number(notification.urgency.into())), // urgency is u8, convert to i64
            Field::ExpireTimeout => Some(RuleConditionValue::Number(notification.expire_timeout.into())),
            Field::Icon => notification.icon.clone().map(RuleConditionValue::Text),
            Field::Hint(key) => notification.hints.get(key).cloned().map(RuleConditionValue::Text), // assuming hints are string values
        };

        match (&condition.operator, &condition.value, field_value) {
            (Operator::Equals, Some(expected_value), Some(actual_value)) => actual_value == *expected_value,
            (Operator::Contains, RuleConditionValue::Text(expected_text), Some(RuleConditionValue::Text(actual_text))) => {
                actual_text.contains(expected_text)
            }
            (Operator::StartsWith, RuleConditionValue::Text(expected_text), Some(RuleConditionValue::Text(actual_text))) => {
                actual_text.starts_with(expected_text)
            }
            (Operator::EndsWith, RuleConditionValue::Text(expected_text), Some(RuleConditionValue::Text(actual_text))) => {
                actual_text.ends_with(expected_text)
            }
            (Operator::GreaterThan, RuleConditionValue::Number(expected_num), Some(RuleConditionValue::Number(actual_num))) => {
                actual_num > *expected_num
            }
            (Operator::LessThan, RuleConditionValue::Number(expected_num), Some(RuleConditionValue::Number(actual_num))) => {
                actual_num < *expected_num
            }
            (Operator::IsSet, _, Some(_)) => true, // Value is present
            (Operator::IsSet, _, None) => false, // Value is not present
            (Operator::IsNotSet, _, Some(_)) => false, // Value is present
            (Operator::IsNotSet, _, None) => true, // Value is not present
            // Handle type mismatches or impossible comparisons.
            // By default, a mismatch means the condition does not apply.
            _ => {
                debug!("Condition evaluation: Type mismatch or unsupported operator/value combination. Condition: {:?}, Notification Field Value: {:?}", condition, field_value);
                false
            }
        }
    }

    /// Hilfsfunktion zum Anwenden einer einzelnen Regelaktion.
    ///
    /// # Arguments
    /// * `action` - Die anzuwendende `RuleAction`.
    /// * `notification` - Die mutable `IncomingNotification`, die modifiziert werden kann.
    /// * `log_sender` - Sender für Logging-Nachrichten.
    /// * `global_settings_service` - Service für globale Einstellungen.
    ///
    /// # Returns
    /// Ein `Result<(), NotificationRulesError>` bei Erfolg oder Fehler.
    async fn apply_action(
        action: &RuleAction,
        notification: &mut IncomingNotification,
        log_sender: &broadcast::Sender<LogEntry>,
        global_settings_service: &GlobalSettingsService,
    ) -> Result<(), NotificationRulesError> {
        match action {
            RuleAction::Suppress => {
                notification.suppress = true;
                debug!("Applied action: Suppress notification.");
            }
            RuleAction::ExecuteCommand(cmd) => {
                info!("Executing command: {}", cmd);
                // Execute command in a non-blocking way, detach if necessary
                tokio::spawn(async move {
                    let parts: Vec<&str> = cmd.split_whitespace().collect();
                    if parts.is_empty() {
                        error!("Attempted to execute empty command string.");
                        return;
                    }
                    let program = parts[0];
                    let args = &parts[1..];
                    match tokio::process::Command::new(program)
                        .args(args)
                        .stdin(Stdio::null()) // Prevent blocking on stdin
                        .stdout(Stdio::null()) // Redirect stdout to null
                        .stderr(Stdio::null()) // Redirect stderr to null
                        .spawn()
                    {
                        Ok(child) => {
                            debug!("Command '{}' spawned with PID: {:?}", cmd, child.id());
                            // Do not await, let it run in background.
                            // If we need to wait for exit, we would need to add a handle.
                        },
                        Err(e) => {
                            error!("Failed to execute command '{}': {}", cmd, e);
                            let _ = log_sender.send(LogEntry::new(LogLevel::Error, format!("Failed to execute rule command: {}", cmd)));
                        }
                    }
                });
            }
            RuleAction::PlaySound(path) => {
                info!("Attempting to play sound from: {:?}", path);
                // TODO: Integration with system::audio_management module via a dedicated trait/service
                // For now, just log. Actual sound playing will be implemented later.
                if !path.exists() {
                    warn!("Sound file does not exist: {:?}", path);
                    let _ = log_sender.send(LogEntry::new(LogLevel::Warning, format!("Sound file not found: {:?}", path)));
                    return Err(NotificationRulesError::RuleProcessingError(format!("Sound file not found: {:?}", path)));
                }
                // Placeholder for actual sound playing logic:
                // global_settings_service.play_sound(path).await?;
                let _ = log_sender.send(LogEntry::new(LogLevel::Info, format!("Would play sound: {:?}", path)));

            }
            RuleAction::SetUrgency(urgency) => {
                notification.urgency = *urgency;
                debug!("Applied action: Set urgency to {}.", urgency);
            }
            RuleAction::SetExpireTimeout(timeout) => {
                notification.expire_timeout = *timeout;
                debug!("Applied action: Set expire timeout to {} ms.", timeout);
            }
            RuleAction::SetCategory(category) => {
                notification.category = Some(category.clone());
                debug!("Applied action: Set category to '{}'.", category);
            }
            RuleAction::SetIcon(icon) => {
                notification.icon = Some(icon.clone());
                debug!("Applied action: Set icon to '{}'.", icon);
            }
            RuleAction::Log(message) => {
                info!("Rule Log: {}", message);
                let _ = log_sender.send(LogEntry::new(LogLevel::Info, format!("Rule action log: {}", message)));
            }
            RuleAction::ShowToast(message) => {
                info!("Showing toast notification: {}", message);
                // TODO: This should trigger an event for the UI layer to show a toast.
                // e.g., global_settings_service.show_toast(message.clone()).await;
                let _ = log_sender.send(LogEntry::new(LogLevel::Info, format!("Would show toast: {}", message)));
            }
        }
        Ok(())
    }
}

#[async_trait]
impl NotificationRulesEngine for DefaultNotificationRulesEngine {
    async fn process_notification(&self, notification: &mut IncomingNotification) -> RuleProcessingResult {
        let rules_guard = self.rules.read().await;
        let mut rules_to_process: Vec<&NotificationRule> = rules_guard.rules.iter()
            .filter(|r| r.enabled)
            .collect();

        // Sort rules by priority, highest first
        rules_to_process.sort_by(|a, b| b.priority.cmp(&a.priority));

        let mut suppressed = false;

        for rule in rules_to_process {
            debug!("Evaluating rule '{}' (ID: {}) for notification from '{}'", rule.name, rule.id, notification.app_name);
            if Self::evaluate_condition(&rule.condition, notification) {
                info!("Rule '{}' (ID: {}) matched for notification from '{}'. Applying actions.",
                      rule.name, rule.id, notification.app_name);

                for action in &rule.actions {
                    if let Err(e) = Self::apply_action(action, notification, &self.log_sender, &self.global_settings_service).await {
                        error!("Failed to apply action {:?} for rule '{}': {}", action, rule.name, e);
                        // Log the error but continue processing other actions/rules.
                        let _ = self.log_sender.send(LogEntry::new(LogLevel::Error, format!("Failed to apply action for rule {}: {}", rule.name, e)));
                    }

                    if matches!(action, RuleAction::Suppress) {
                        suppressed = true;
                    }
                }

                if rule.stop_processing_further_rules {
                    info!("Rule '{}' (ID: {}) has 'stop_processing_further_rules' set. Halting further rule processing.", rule.name, rule.id);
                    break;
                }
            }
        }

        if suppressed {
            info!("Notification (ID: {}) from '{}' was suppressed by a rule.", notification.id, notification.app_name);
            RuleProcessingResult::Suppressed
        } else {
            debug!("Notification (ID: {}) from '{}' processed. Not suppressed.", notification.id, notification.app_name);
            RuleProcessingResult::Processed
        }
    }

    async fn reload_rules(&self) -> Result<(), NotificationRulesError> {
        info!("Reloading notification rules...");
        let new_rules_set = self.provider.load_rules().await?;
        let mut rules_guard = self.rules.write().await;
        *rules_guard = new_rules_set;
        info!("Notification rules reloaded successfully. Total rules: {}", rules_guard.rules.len());
        Ok(())
    }

    fn get_rules(&self) -> NotificationRuleSet {
        self.rules.blocking_read().clone() // Using blocking_read for sync context, fine for get_rules
    }

    async fn add_rule(&self, rule: NotificationRule) -> Result<(), NotificationRulesError> {
        info!("Adding new notification rule: '{}' (ID: {})", rule.name, rule.id);
        let mut rules_guard = self.rules.write().await;
        rules_guard.rules.push(rule);
        self.provider.save_rules(&rules_guard).await?;
        info!("Rule added and saved successfully.");
        Ok(())
    }

    async fn update_rule(&self, rule: NotificationRule) -> Result<(), NotificationRulesError> {
        info!("Updating notification rule: '{}' (ID: {})", rule.name, rule.id);
        let mut rules_guard = self.rules.write().await;
        let index = rules_guard.rules.iter().position(|r| r.id == rule.id);

        if let Some(idx) = index {
            rules_guard.rules[idx] = rule;
            self.provider.save_rules(&rules_guard).await?;
            info!("Rule updated and saved successfully.");
            Ok(())
        } else {
            warn!("Attempted to update non-existent rule with ID: {}", rule.id);
            Err(NotificationRulesError::RuleNotFound(rule.id))
        }
    }

    async fn delete_rule(&self, id: Uuid) -> Result<(), NotificationRulesError> {
        info!("Deleting notification rule with ID: {}", id);
        let mut rules_guard = self.rules.write().await;
        let original_len = rules_guard.rules.len();
        rules_guard.rules.retain(|r| r.id != id);

        if rules_guard.rules.len() < original_len {
            self.provider.save_rules(&rules_guard).await?;
            info!("Rule deleted and saved successfully.");
            Ok(())
        } else {
            warn!("Attempted to delete non-existent rule with ID: {}", id);
            Err(NotificationRulesError::RuleNotFound(id))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::notification_rules::data_types::*;
    use novade_core::logging::LogEntry;
    use novade_core::settings::GlobalSettingsService; // Mock this
    use tokio::sync::broadcast;
    use std::collections::HashMap;
    use std::io;

    // Mock Implementation of NotificationRulesProvider for testing
    pub struct MockNotificationRulesProvider {
        rules: Arc<RwLock<NotificationRuleSet>>,
        simulate_load_error: bool,
        simulate_save_error: bool,
    }

    impl MockNotificationRulesProvider {
        fn new(initial_rules: Option<NotificationRuleSet>) -> Self {
            Self {
                rules: Arc::new(RwLock::new(initial_rules.unwrap_or_default())),
                simulate_load_error: false,
                simulate_save_error: false,
            }
        }

        fn with_load_error(mut self) -> Self {
            self.simulate_load_error = true;
            self
        }

        fn with_save_error(mut self) -> Self {
            self.simulate_save_error = true;
            self
        }
    }

    #[async_trait]
    impl NotificationRulesProvider for MockNotificationRulesProvider {
        async fn load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError> {
            if self.simulate_load_error {
                return Err(NotificationRulesError::IoError(novade_core::error::IoError::Generic(io::Error::new(io::ErrorKind::Other, "Simulated load error"))));
            }
            Ok(self.rules.read().await.clone())
        }

        async fn save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError> {
            if self.simulate_save_error {
                return Err(NotificationRulesError::IoError(novade_core::error::IoError::Generic(io::Error::new(io::ErrorKind::Other, "Simulated save error"))));
            }
            *self.rules.write().await = rules.clone();
            Ok(())
        }
    }

    // Mock Implementation of GlobalSettingsService for testing
    pub struct MockGlobalSettingsService;

    #[async_trait]
    impl GlobalSettingsService for MockGlobalSettingsService {
        async fn get_setting<T: serde::de::DeserializeOwned + Send + Sync + 'static>(&self, _key: &str) -> Option<T> {
            None // For now, always return None or specific test values
        }
        async fn set_setting<T: serde::Serialize + Send + Sync + 'static>(&self, _key: &str, _value: &T) -> Result<(), novade_core::error::ConfigError> {
            Ok(())
        }
        fn get_setting_sync<T: serde::de::DeserializeOwned + Send + Sync + 'static>(&self, _key: &str) -> Option<T> {
            None
        }
    }

    // Helper function to create a basic IncomingNotification
    fn create_test_notification() -> IncomingNotification {
        IncomingNotification {
            id: Uuid::new_v4(),
            app_name: "TestApp".to_string(),
            summary: "Test Summary".to_string(),
            body: Some("Test Body".to_string()),
            category: None,
            urgency: 1, // Normal
            expire_timeout: 5000,
            icon: Some("dialog-information".to_string()),
            hints: {
                let mut hints = HashMap::new();
                hints.insert("desktop-entry".to_string(), "testapp.desktop".to_string());
                hints.insert("custom-hint".to_string(), "value".to_string());
                hints
            },
            actions: vec![],
            suppress: false, // Initial state
        }
    }

    // Helper to create a simple rule
    fn create_simple_rule(name: &str, field: Field, operator: Operator, value: RuleConditionValue) -> NotificationRule {
        NotificationRule {
            id: Uuid::new_v4(),
            name: name.to_string(),
            enabled: true,
            priority: 0,
            condition: RuleCondition::Simple(SimpleRuleCondition { field, operator, value }),
            actions: vec![],
            stop_processing_further_rules: false,
        }
    }

    // --- Tests for evaluate_simple_condition ---

    #[test]
    fn test_evaluate_simple_condition_equals() {
        let notif = create_test_notification();
        let cond = SimpleRuleCondition {
            field: Field::AppName,
            operator: Operator::Equals,
            value: RuleConditionValue::Text("TestApp".to_string()),
        };
        assert!(DefaultNotificationRulesEngine::evaluate_simple_condition(&cond, &notif));

        let cond_false = SimpleRuleCondition {
            field: Field::AppName,
            operator: Operator::Equals,
            value: RuleConditionValue::Text("WrongApp".to_string()),
        };
        assert!(!DefaultNotificationRulesEngine::evaluate_simple_condition(&cond_false, &notif));
    }

    #[test]
    fn test_evaluate_simple_condition_contains() {
        let notif = create_test_notification();
        let cond = SimpleRuleCondition {
            field: Field::Summary,
            operator: Operator::Contains,
            value: RuleConditionValue::Text("Summary".to_string()),
        };
        assert!(DefaultNotificationRulesEngine::evaluate_simple_condition(&cond, &notif));
    }

    #[test]
    fn test_evaluate_simple_condition_is_set() {
        let mut notif_with_body = create_test_notification();
        notif_with_body.body = Some("Some text".to_string());
        let cond_body_set = SimpleRuleCondition {
            field: Field::Body,
            operator: Operator::IsSet,
            value: RuleConditionValue::Boolean(true), // Value doesn't matter for IsSet/IsNotSet
        };
        assert!(DefaultNotificationRulesEngine::evaluate_simple_condition(&cond_body_set, &notif_with_body));

        let mut notif_no_body = create_test_notification();
        notif_no_body.body = None;
        assert!(!DefaultNotificationRulesEngine::evaluate_simple_condition(&cond_body_set, &notif_no_body));

        let cond_body_not_set = SimpleRuleCondition {
            field: Field::Body,
            operator: Operator::IsNotSet,
            value: RuleConditionValue::Boolean(true),
        };
        assert!(DefaultNotificationRulesEngine::evaluate_simple_condition(&cond_body_not_set, &notif_no_body));
        assert!(!DefaultNotificationRulesEngine::evaluate_simple_condition(&cond_body_not_set, &notif_with_body));
    }

    #[test]
    fn test_evaluate_simple_condition_number_comparison() {
        let notif = create_test_notification(); // Urgency is 1
        let cond_gt = SimpleRuleCondition {
            field: Field::Urgency,
            operator: Operator::GreaterThan,
            value: RuleConditionValue::Number(0),
        };
        assert!(DefaultNotificationRulesEngine::evaluate_simple_condition(&cond_gt, &notif));

        let cond_lt = SimpleRuleCondition {
            field: Field::Urgency,
            operator: Operator::LessThan,
            value: RuleConditionValue::Number(2),
        };
        assert!(DefaultNotificationRulesEngine::evaluate_simple_condition(&cond_lt, &notif));
    }

    #[test]
    fn test_evaluate_simple_condition_hint() {
        let notif = create_test_notification();
        let cond = SimpleRuleCondition {
            field: Field::Hint("desktop-entry".to_string()),
            operator: Operator::Equals,
            value: RuleConditionValue::Text("testapp.desktop".to_string()),
        };
        assert!(DefaultNotificationRulesEngine::evaluate_simple_condition(&cond, &notif));

        let cond_non_existent_hint = SimpleRuleCondition {
            field: Field::Hint("non-existent-hint".to_string()),
            operator: Operator::IsSet,
            value: RuleConditionValue::Boolean(true),
        };
        assert!(!DefaultNotificationRulesEngine::evaluate_simple_condition(&cond_non_existent_hint, &notif));
    }

    // --- Tests for evaluate_condition (complex) ---

    #[test]
    fn test_evaluate_condition_and() {
        let notif = create_test_notification();
        let cond1 = RuleCondition::Simple(SimpleRuleCondition {
            field: Field::AppName,
            operator: Operator::Equals,
            value: RuleConditionValue::Text("TestApp".to_string()),
        });
        let cond2 = RuleCondition::Simple(SimpleRuleCondition {
            field: Field::Summary,
            operator: Operator::Contains,
            value: RuleConditionValue::Text("Summary".to_string()),
        });
        let and_cond = RuleCondition::And(vec![cond1, cond2]);
        assert!(DefaultNotificationRulesEngine::evaluate_condition(&and_cond, &notif));

        let cond3 = RuleCondition::Simple(SimpleRuleCondition {
            field: Field::AppName,
            operator: Operator::Equals,
            value: RuleConditionValue::Text("WrongApp".to_string()),
        });
        let and_cond_false = RuleCondition::And(vec![and_cond, cond3]);
        assert!(!DefaultNotificationRulesEngine::evaluate_condition(&and_cond_false, &notif));
    }

    #[test]
    fn test_evaluate_condition_or() {
        let notif = create_test_notification();
        let cond1 = RuleCondition::Simple(SimpleRuleCondition {
            field: Field::AppName,
            operator: Operator::Equals,
            value: RuleConditionValue::Text("WrongApp".to_string()),
        });
        let cond2 = RuleCondition::Simple(SimpleRuleCondition {
            field: Field::Summary,
            operator: Operator::Contains,
            value: RuleConditionValue::Text("Summary".to_string()),
        });
        let or_cond = RuleCondition::Or(vec![cond1, cond2]);
        assert!(DefaultNotificationRulesEngine::evaluate_condition(&or_cond, &notif));

        let cond3 = RuleCondition::Simple(SimpleRuleCondition {
            field: Field::AppName,
            operator: Operator::Equals,
            value: RuleConditionValue::Text("WrongApp".to_string()),
        });
        let cond4 = RuleCondition::Simple(SimpleRuleCondition {
            field: Field::Summary,
            operator: Operator::Contains,
            value: RuleConditionValue::Text("NotFound".to_string()),
        });
        let or_cond_false = RuleCondition::Or(vec![cond3, cond4]);
        assert!(!DefaultNotificationRulesEngine::evaluate_condition(&or_cond_false, &notif));
    }

    #[test]
    fn test_evaluate_condition_not() {
        let notif = create_test_notification();
        let cond_true = RuleCondition::Simple(SimpleRuleCondition {
            field: Field::AppName,
            operator: Operator::Equals,
            value: RuleConditionValue::Text("TestApp".to_string()),
        });
        let cond_false = RuleCondition::Simple(SimpleRuleCondition {
            field: Field::AppName,
            operator: Operator::Equals,
            value: RuleConditionValue::Text("WrongApp".to_string()),
        });

        let not_true_cond = RuleCondition::Not(Box::new(cond_true));
        assert!(!DefaultNotificationRulesEngine::evaluate_condition(&not_true_cond, &notif));

        let not_false_cond = RuleCondition::Not(Box::new(cond_false));
        assert!(DefaultNotificationRulesEngine::evaluate_condition(&not_false_cond, &notif));
    }

    // --- Tests for apply_action ---

    #[tokio::test]
    async fn test_apply_action_suppress() {
        let (_tx, _rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);
        let mut notif = create_test_notification();
        let action = RuleAction::Suppress;

        DefaultNotificationRulesEngine::apply_action(&action, &mut notif, &_tx, &global_settings).await.unwrap();
        assert!(notif.suppress);
    }

    #[tokio::test]
    async fn test_apply_action_set_urgency() {
        let (_tx, _rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);
        let mut notif = create_test_notification();
        let action = RuleAction::SetUrgency(2); // Critical

        DefaultNotificationRulesEngine::apply_action(&action, &mut notif, &_tx, &global_settings).await.unwrap();
        assert_eq!(notif.urgency, 2);
    }

    #[tokio::test]
    async fn test_apply_action_set_expire_timeout() {
        let (_tx, _rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);
        let mut notif = create_test_notification();
        let action = RuleAction::SetExpireTimeout(1000);

        DefaultNotificationRulesEngine::apply_action(&action, &mut notif, &_tx, &global_settings).await.unwrap();
        assert_eq!(notif.expire_timeout, 1000);
    }

    #[tokio::test]
    async fn test_apply_action_log() {
        let (tx, mut rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);
        let mut notif = create_test_notification();
        let action = RuleAction::Log("Test log message from rule".to_string());

        DefaultNotificationRulesEngine::apply_action(&action, &mut notif, &tx, &global_settings).await.unwrap();

        // Verify that a log entry was sent
        let log_entry = tokio::time::timeout(std::time::Duration::from_millis(100), rx.recv()).await.unwrap().unwrap();
        assert_eq!(log_entry.message, "Rule action log: Test log message from rule");
        assert_eq!(log_entry.level, LogLevel::Info);
    }

    #[tokio::test]
    async fn test_apply_action_execute_command() {
        // This test is tricky as it involves external process.
        // We can only check if the command spawning doesn't error out.
        // On Unix-like systems, we can test a simple `echo` command.
        // On Windows, `cmd /c echo`
        let (_tx, _rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);
        let mut notif = create_test_notification();

        let cmd = if cfg!(target_os = "windows") {
            "cmd /c echo test".to_string()
        } else {
            "echo test".to_string()
        };
        let action = RuleAction::ExecuteCommand(cmd);

        DefaultNotificationRulesEngine::apply_action(&action, &mut notif, &_tx, &global_settings).await.unwrap();
        // The spawned task runs in the background, so we can't directly check its output easily.
        // Just assert that the action application itself didn't error.
    }

    #[tokio::test]
    async fn test_apply_action_play_sound_non_existent() {
        let (tx, mut rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);
        let mut notif = create_test_notification();
        let action = RuleAction::PlaySound(PathBuf::from("/nonexistent/sound/file.ogg"));

        let error = DefaultNotificationRulesEngine::apply_action(&action, &mut notif, &tx, &global_settings).await.unwrap_err();
        assert!(matches!(error, NotificationRulesError::RuleProcessingError(_)));

        // Verify that a warning log entry was sent
        let log_entry = tokio::time::timeout(std::time::Duration::from_millis(100), rx.recv()).await.unwrap().unwrap();
        assert!(log_entry.message.contains("Sound file not found"));
        assert_eq!(log_entry.level, LogLevel::Warning);
    }

    // --- Integration Tests for DefaultNotificationRulesEngine ---

    #[tokio::test]
    async fn test_engine_initial_load() {
        let initial_rules = NotificationRuleSet {
            rules: vec![create_simple_rule("App Rule", Field::AppName, Operator::Equals, RuleConditionValue::Text("InitialApp".to_string()))],
        };
        let provider = Arc::new(MockNotificationRulesProvider::new(Some(initial_rules.clone())));
        let (tx, _rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);

        let engine = DefaultNotificationRulesEngine::new(provider.clone(), tx, global_settings).await.unwrap();
        let loaded_rules = engine.get_rules();
        assert_eq!(loaded_rules, initial_rules);
    }

    #[tokio::test]
    async fn test_engine_process_notification_suppress() {
        let mut notif = create_test_notification();
        let mut suppress_rule = create_simple_rule(
            "Suppress TestApp",
            Field::AppName,
            Operator::Equals,
            RuleConditionValue::Text("TestApp".to_string()),
        );
        suppress_rule.actions.push(RuleAction::Suppress);
        suppress_rule.stop_processing_further_rules = true;

        let initial_rules = NotificationRuleSet { rules: vec![suppress_rule] };
        let provider = Arc::new(MockNotificationRulesProvider::new(Some(initial_rules)));
        let (tx, _rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);
        let engine = DefaultNotificationRulesEngine::new(provider, tx, global_settings).await.unwrap();

        let result = engine.process_notification(&mut notif).await;
        assert_eq!(result, RuleProcessingResult::Suppressed);
        assert!(notif.suppress);
    }

    #[tokio::test]
    async fn test_engine_process_notification_modify_and_continue() {
        let mut notif = create_test_notification(); // Urgency is 1
        let mut modify_rule = create_simple_rule(
            "Set Urgency",
            Field::AppName,
            Operator::Equals,
            RuleConditionValue::Text("TestApp".to_string()),
        );
        modify_rule.priority = 100;
        modify_rule.actions.push(RuleAction::SetUrgency(2)); // Change urgency
        modify_rule.stop_processing_further_rules = false; // Continue processing

        let initial_rules = NotificationRuleSet { rules: vec![modify_rule] };
        let provider = Arc::new(MockNotificationRulesProvider::new(Some(initial_rules)));
        let (tx, _rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);
        let engine = DefaultNotificationRulesEngine::new(provider, tx, global_settings).await.unwrap();

        let result = engine.process_notification(&mut notif).await;
        assert_eq!(result, RuleProcessingResult::Processed); // Not suppressed
        assert_eq!(notif.urgency, 2); // Urgency should be changed
    }

    #[tokio::test]
    async fn test_engine_process_notification_priority_and_stop() {
        let mut notif = create_test_notification();

        let mut low_priority_suppress = create_simple_rule(
            "Low Priority Suppress",
            Field::AppName,
            Operator::Equals,
            RuleConditionValue::Text("TestApp".to_string()),
        );
        low_priority_suppress.priority = 1;
        low_priority_suppress.actions.push(RuleAction::Suppress);
        low_priority_suppress.stop_processing_further_rules = true;

        let mut high_priority_log = create_simple_rule(
            "High Priority Log",
            Field::AppName,
            Operator::Equals,
            RuleConditionValue::Text("TestApp".to_string()),
        );
        high_priority_log.priority = 10;
        high_priority_log.actions.push(RuleAction::Log("High priority rule matched!".to_string()));
        high_priority_log.stop_processing_further_rules = false;

        let initial_rules = NotificationRuleSet { rules: vec![low_priority_suppress, high_priority_log] };
        let provider = Arc::new(MockNotificationRulesProvider::new(Some(initial_rules)));
        let (tx, mut rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);
        let engine = DefaultNotificationRulesEngine::new(provider, tx, global_settings).await.unwrap();

        let result = engine.process_notification(&mut notif).await;
        assert_eq!(result, RuleProcessingResult::Suppressed); // Low priority rule suppressed
        assert!(notif.suppress);

        // Only the high priority log should have been sent before suppression
        let log_entry = tokio::time::timeout(std::time::Duration::from_millis(100), rx.recv()).await.unwrap().unwrap();
        assert_eq!(log_entry.message, "Rule action log: High priority rule matched!");
        assert!(rx.try_recv().is_err()); // No more messages from low priority rule
    }

    #[tokio::test]
    async fn test_engine_add_rule() {
        let provider = Arc::new(MockNotificationRulesProvider::new(None));
        let (tx, _rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);
        let engine = DefaultNotificationRulesEngine::new(provider.clone(), tx, global_settings).await.unwrap();

        let new_rule = create_simple_rule("New Rule", Field::Summary, Operator::Contains, RuleConditionValue::Text("Fresh".to_string()));
        let new_rule_id = new_rule.id;
        engine.add_rule(new_rule).await.unwrap();

        let rules_after_add = engine.get_rules();
        assert_eq!(rules_after_add.rules.len(), 1);
        assert_eq!(rules_after_add.rules[0].id, new_rule_id);

        // Verify persistence
        let persisted_rules = provider.load_rules().await.unwrap();
        assert_eq!(persisted_rules.rules.len(), 1);
        assert_eq!(persisted_rules.rules[0].id, new_rule_id);
    }

    #[tokio::test]
    async fn test_engine_update_rule() {
        let existing_rule = create_simple_rule("Original Rule", Field::AppName, Operator::Equals, RuleConditionValue::Text("App1".to_string()));
        let rule_id = existing_rule.id;
        let initial_rules = NotificationRuleSet { rules: vec![existing_rule] };

        let provider = Arc::new(MockNotificationRulesProvider::new(Some(initial_rules)));
        let (tx, _rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);
        let engine = DefaultNotificationRulesEngine::new(provider.clone(), tx, global_settings).await.unwrap();

        let updated_rule = NotificationRule {
            id: rule_id,
            name: "Updated Rule Name".to_string(),
            enabled: true,
            priority: 0,
            condition: RuleCondition::Simple(SimpleRuleCondition {
                field: Field::Summary,
                operator: Operator::Contains,
                value: RuleConditionValue::Text("Updated Summary".to_string()),
            }),
            actions: vec![RuleAction::Log("Rule updated!".to_string())],
            stop_processing_further_rules: false,
        };

        engine.update_rule(updated_rule.clone()).await.unwrap();

        let rules_after_update = engine.get_rules();
        assert_eq!(rules_after_update.rules.len(), 1);
        assert_eq!(rules_after_update.rules[0], updated_rule);

        let persisted_rules = provider.load_rules().await.unwrap();
        assert_eq!(persisted_rules.rules[0], updated_rule);
    }

    #[tokio::test]
    async fn test_engine_update_non_existent_rule() {
        let provider = Arc::new(MockNotificationRulesProvider::new(None));
        let (tx, _rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);
        let engine = DefaultNotificationRulesEngine::new(provider, tx, global_settings).await.unwrap();

        let non_existent_rule = create_simple_rule("Non-Existent", Field::AppName, Operator::Equals, RuleConditionValue::Text("Foo".to_string()));
        let error = engine.update_rule(non_existent_rule.clone()).await.unwrap_err();
        assert!(matches!(error, NotificationRulesError::RuleNotFound(_)));
    }

    #[tokio::test]
    async fn test_engine_delete_rule() {
        let rule1 = create_simple_rule("Rule 1", Field::AppName, Operator::Equals, RuleConditionValue::Text("App1".to_string()));
        let rule2 = create_simple_rule("Rule 2", Field::AppName, Operator::Equals, RuleConditionValue::Text("App2".to_string()));
        let rule2_id = rule2.id;
        let initial_rules = NotificationRuleSet { rules: vec![rule1.clone(), rule2.clone()] };

        let provider = Arc::new(MockNotificationRulesProvider::new(Some(initial_rules)));
        let (tx, _rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);
        let engine = DefaultNotificationRulesEngine::new(provider.clone(), tx, global_settings).await.unwrap();

        engine.delete_rule(rule2_id).await.unwrap();

        let rules_after_delete = engine.get_rules();
        assert_eq!(rules_after_delete.rules.len(), 1);
        assert_eq!(rules_after_delete.rules[0], rule1);

        let persisted_rules = provider.load_rules().await.unwrap();
        assert_eq!(persisted_rules.rules.len(), 1);
        assert_eq!(persisted_rules.rules[0], rule1);
    }

    #[tokio::test]
    async fn test_engine_delete_non_existent_rule() {
        let provider = Arc::new(MockNotificationRulesProvider::new(None));
        let (tx, _rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);
        let engine = DefaultNotificationRulesEngine::new(provider, tx, global_settings).await.unwrap();

        let non_existent_id = Uuid::new_v4();
        let error = engine.delete_rule(non_existent_id).await.unwrap_err();
        assert!(matches!(error, NotificationRulesError::RuleNotFound(_)));
    }

    #[tokio::test]
    async fn test_engine_reload_rules_error() {
        let provider = Arc::new(MockNotificationRulesProvider::new(None).with_load_error());
        let (tx, _rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);

        let error = DefaultNotificationRulesEngine::new(provider, tx, global_settings).await.unwrap_err();
        assert!(matches!(error, NotificationRulesError::IoError(_)));
    }

    #[tokio::test]
    async fn test_engine_add_rule_save_error() {
        let provider = Arc::new(MockNotificationRulesProvider::new(None).with_save_error());
        let (tx, _rx) = broadcast::channel(10);
        let global_settings = Arc::new(MockGlobalSettingsService);
        let engine = DefaultNotificationRulesEngine::new(provider, tx, global_settings).await.unwrap(); // Initial load works

        let new_rule = create_simple_rule("Failing Rule", Field::AppName, Operator::Equals, RuleConditionValue::Text("FailApp".to_string()));
        let error = engine.add_rule(new_rule).await.unwrap_err();
        assert!(matches!(error, NotificationRulesError::IoError(_)));

        // Check that the in-memory rules are updated, but persistence failed
        assert_eq!(engine.get_rules().rules.len(), 1);
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (11 von 100) widmet sich weiterhin der Domänenschicht (`novade-domain`), diesmal mit der detaillierten Spezifikation des `notification_rules::mod.rs`-Moduls. Dieses Modul ist entscheidend, um die öffentliche API des gesamten `notification_rules`-Verzeichnisses zu definieren und die internen Komponenten korrekt zu kapseln.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 11/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.15.6. `novade-domain/src/notification_rules/mod.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/mod.rs`
  * **Verantwortlichkeit:** Dieses `mod.rs`-Modul dient als öffentlicher Zugangspunkt für alle Komponenten innerhalb des `notification_rules`-Verzeichnisses. Es re-exportiert die notwendigen `data_types`, `errors`, `persistence_iface` (den Trait), `persistence` (die konkrete Implementierung, falls sie direkt genutzt werden soll, oder nur für Tests) und `engine`-Bestandteile, die von externen Modulen der `novade-domain` oder von anderen Schichten (z.B. der UI-Schicht für die Regelverwaltung) benötigt werden. Es ist entscheidend für die Modularität und Kapselung der Implementierungsdetails.
  * **Kern-Aufgaben (Tasks):**
    1.  **Re-Exporte für `data_types`:**
          * Re-exportiere alle `pub` definierten Strukturen und Enums aus `data_types.rs`, insbesondere:
              * `NotificationRule`
              * `NotificationRuleSet`
              * `RuleCondition`
              * `SimpleRuleCondition`
              * `RuleAction`
              * `Field`
              * `Operator`
              * `RuleConditionValue`
    2.  **Re-Exporte für `errors`:**
          * Re-exportiere die `NotificationRulesError`-Enum.
    3.  **Re-Exporte für `persistence_iface`:**
          * Re-exportiere den `NotificationRulesProvider`-Trait.
    4.  **Re-Exporte für `persistence` (optional, aber empfohlen für DI):**
          * Re-exportiere die `FilesystemNotificationRulesProvider`-Struktur, damit sie als konkrete Implementierung von externen Crates (z.B. der Haupt-Anwendung) instanziiert und der Engine über Dependency Injection bereitgestellt werden kann.
    5.  **Re-Exporte für `engine`:**
          * Re-exportiere den `NotificationRulesEngine`-Trait.
          * Re-exportiere die `DefaultNotificationRulesEngine`-Struktur.
          * Re-exportiere das `RuleProcessingResult`-Enum.
    6.  **Modul-Deklarationen:**
          * Stelle sicher, dass alle Untermodule (`data_types`, `errors`, `persistence_iface`, `persistence`, `engine`) im `mod.rs` deklariert sind (`mod data_types;`, etc.).
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notification_rules::data_types`, `crate::notification_rules::errors`, `crate::notification_rules::persistence_iface`, `crate::notification_rules::persistence`, `crate::notification_rules::engine`.
      * **Extern:** Keine direkten externen Abhängigkeiten, nur Verweise auf interne Module.
  * **Kommunikationsmuster:** Definiert die öffentliche API für das `notification_rules`-Modul. Andere Module und Crates importieren über diesen `mod.rs`-Einstiegspunkt.
  * **Erwartete Ergebnisse/Outputs:** Ein gut strukturierter und leicht zugänglicher API für die Benachrichtigungsregel-Komponenten.
  * **Teststrategie (Modul-spezifisch):**
      * **Compile-time Check:** Der Haupttest für `mod.rs` ist, dass das Crate ohne Fehler kompiliert wird und alle re-exportierten Elemente korrekt aus dem Wurzelpfad des `notification_rules`-Moduls importierbar sind.
      * **Integrationstest (Symbol-Sichtbarkeit):** Erstelle einen trivialen Integrationstest in einem externen Modul (z.B. in `novade-domain/tests/integration_tests.rs` oder `novade-application/src/main.rs`), der versucht, alle re-exportierten Elemente zu importieren und zu instanziieren/verwenden, um sicherzustellen, dass die Pfade korrekt sind und die Sichtbarkeit funktioniert.

#### Funktionsspezifikation: `novade_domain::notification_rules::mod`

```rust
// novade-domain/src/notification_rules/mod.rs

//! Dieses Modul enthält die Logik und Datenstrukturen für das Management und die
//! Verarbeitung von Benachrichtigungsregeln.

// Deklariert die Untermodule. Die Reihenfolge kann wichtig sein, wenn Module
// sich gegenseitig Referenzen haben, aber rustc ist oft schlau genug.
// Typischerweise: Daten -> Fehler -> Schnittstellen -> Implementierungen -> Engine.
pub mod data_types;
pub mod errors;
pub mod persistence_iface;
pub mod persistence;
pub mod engine;

// Re-exportiert die wichtigsten Strukturen, Enums und Traits für die externe Nutzung.
// Dies schafft eine saubere öffentliche API für das 'notification_rules' Modul,
// sodass externe Crates nicht tiefer in die Modulstruktur navigieren müssen.

// Re-exports from data_types
pub use data_types::{
    NotificationRule,
    NotificationRuleSet,
    RuleCondition,
    SimpleRuleCondition,
    RuleAction,
    Field,
    Operator,
    RuleConditionValue,
    // Wenn es weitere spezifische Daten-Typen gibt, die extern sichtbar sein müssen,
    // hier hinzufügen.
};

// Re-exports from errors
pub use errors::NotificationRulesError;

// Re-exports from persistence_iface
pub use persistence_iface::NotificationRulesProvider;

// Re-exports from persistence
// Die konkrete Implementierung wird oft direkt zur Instanziierung benötigt,
// z.B. in der Haupt-Anwendung oder im `DomainServices`-Builder.
pub use persistence::FilesystemNotificationRulesProvider;

// Re-exports from engine
pub use engine::{
    NotificationRulesEngine,
    DefaultNotificationRulesEngine,
    RuleProcessingResult,
};

// Optional: Test, der sicherstellt, dass alle gewünschten Elemente importierbar sind
#[cfg(test)]
mod tests {
    // Importiere alle re-exportierten Elemente, um zu prüfen, ob die Pfade stimmen
    use super::{
        NotificationRule, NotificationRuleSet, RuleCondition, SimpleRuleCondition, RuleAction,
        Field, Operator, RuleConditionValue,
        NotificationRulesError,
        NotificationRulesProvider,
        FilesystemNotificationRulesProvider,
        NotificationRulesEngine, DefaultNotificationRulesEngine, RuleProcessingResult,
    };
    use uuid::Uuid; // Für NotificationRule's ID

    #[test]
    fn test_public_api_visibility() {
        // Dieser Test kompiliert lediglich, um die Sichtbarkeit der pub uses zu prüfen.
        // Keine Laufzeit-Assertionen nötig, es sei denn, man will auch Instanziierungen prüfen.

        // Test instanziierung/Nutzung einfacher Typen
        let _rule_set = NotificationRuleSet::default();
        let _rule = NotificationRule {
            id: Uuid::new_v4(),
            name: "TestRule".to_string(),
            enabled: true,
            priority: 0,
            condition: RuleCondition::Simple(SimpleRuleCondition {
                field: Field::AppName,
                operator: Operator::Equals,
                value: RuleConditionValue::Text("TestApp".to_string()),
            }),
            actions: vec![RuleAction::Suppress],
            stop_processing_further_rules: false,
        };
        let _error = NotificationRulesError::RuleNotFound(Uuid::new_v4());
        let _result = RuleProcessingResult::Processed;

        // Test, dass Traits als Trait-Objekte verwendet werden können (nicht direkt instanziierbar, aber typisierbar)
        // let _provider: Box<dyn NotificationRulesProvider> = Box::new(FilesystemNotificationRulesProvider::new(...));
        // let _engine: Box<dyn NotificationRulesEngine> = Box::new(DefaultNotificationRulesEngine::new(...));
        // (Kommentiert, da für Instanziierung Abhängigkeiten nötig wären, die hier nicht gemockt werden)
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (12 von 100) widmet sich einem neuen Hauptmodul innerhalb der Domänenschicht (`novade-domain`): dem `settings` Modul. Dieses Modul ist verantwortlich für das Laden, Speichern und Bereitstellen globaler Systemeinstellungen und Präferenzen, die über verschiedene Komponenten und Schichten hinweg verwendet werden. Es bildet eine entscheidende Brücke zwischen den Konfigurationsmechanismen der Core-Schicht und der Anwendungsebene der Domäne.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 12/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.16. `novade-domain/src/settings`

  * **Verzeichnis-/Modulname:** `novade-domain/src/settings`
  * **Verantwortlichkeit:** Dieses Modul kapselt die Logik für das Management globaler, persistenter Systemeinstellungen. Es definiert die Datenstrukturen für verschiedene Einstellungstypen, stellt eine API zum Laden und Speichern der Einstellungen bereit und bietet Mechanismen zur Benachrichtigung bei Einstellungsänderungen. Es agiert als Abstraktionsschicht über dem `ConfigService` der `novade-core`-Schicht, um typsicheren und domänenspezifischen Zugriff auf Einstellungen zu ermöglichen.
  * **Kern-Aufgaben (Tasks):**
    1.  **`data_types.rs` definieren:** Datenstrukturen für Einstellungen.
    2.  **`errors.rs` definieren:** Fehlerbehandlung für Einstellungen.
    3.  **`persistence_iface.rs` definieren:** Trait für die Persistenz von Einstellungen.
    4.  **`persistence.rs` implementieren:** Konkrete Persistenz-Implementierung.
    5.  **`service.rs` implementieren:** Der Hauptdienst zum Verwalten und Bereitstellen von Einstellungen.
    6.  **`mod.rs` definieren:** Öffentliche API des `settings`-Moduls.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/settings/data_types.rs`
      * `novade-domain/src/settings/errors.rs`
      * `novade-domain/src/settings/persistence_iface.rs`
      * `novade-domain/src/settings/persistence.rs`
      * `novade-domain/src/settings/service.rs`
      * `novade-domain/src/settings/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_core::config::service::ConfigService`, `novade_core::error::ConfigError`, `novade_core::logging::LogEntry`.
      * **Extern:** `serde` (für Serialisierung/Deserialisierung), `tokio::sync::{RwLock, broadcast}`, `std::sync::Arc`, `async_trait`, `tracing`.
  * **Kommunikationsmuster:**
      * Nutzt `ConfigService` für den Zugriff auf das Dateisystem.
      * Stellt `SettingsService` über einen `Arc` bereit, damit andere Domänen- oder System-Services darauf zugreifen können.
      * Verwendet `tokio::sync::broadcast::Sender` und `Receiver` für die Benachrichtigung bei Einstellungsänderungen.
  * **Erwartete Ergebnisse/Outputs:** Ein robuster und flexibler Mechanismus für globale Systemeinstellungen, der von anderen NovaDE-Komponenten genutzt werden kann.
  * **Teststrategie (Modul-spezifisch):** Umfassende Unit- und Integrationstests für jede Unterkomponente, mit besonderem Augenmerk auf Persistenz, Änderungsbenachrichtigungen und Fehlerbehandlung.

-----

### 3.16.1. `novade-domain/src/settings/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/settings/data_types.rs`
  * **Verantwortlichkeit:** Definiert die strukturelle Repräsentation der verschiedenen globalen Einstellungen von NovaDE. Diese Typen sind die primären Datenstrukturen, die zwischen dem `SettingsService` und den Komponenten, die Einstellungen lesen oder schreiben, ausgetauscht werden.
  * **Kern-Aufgaben (Tasks):**
    1.  **`DesktopSettings` Struct definieren:**
          * Dies ist das Haupt-Struct, das alle globalen Desktop-Einstellungen als Felder enthält.
          * Sollte mit `#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]` versehen werden.
          * Beispielhafte Felder (spätere Erweiterung je nach Bedarf der UI- und Systemschicht):
              * `theme_name: String` (Standard: `"nova-dark"` oder `""`)
              * `accent_color: String` (Hex-Code, Standard: `"#6C78F7"`)
              * `panel_position: String` (Enum, Standard: `"bottom"`)
              * `notification_display_timeout_ms: u32` (Standard: `5000`)
              * `do_not_disturb_mode: bool` (Standard: `false`)
              * `global_volume: u8` (Standard: `100`, Bereich `0-100`)
              * `enable_animations: bool` (Standard: `true`)
              * `preferred_language: String` (Standard: `"en_US"`)
              * `auto_hide_panel: bool` (Standard: `false`)
              * `panel_autohide_delay_ms: u32` (Standard: `500`)
              * `workspace_count: u32` (Standard: `4`)
              * `hot_corners_enabled: bool` (Standard: `true`)
              * `hot_corner_delay_ms: u32` (Standard: `200`)
              * `wallpaper_path: Option<PathBuf>` (Standard: `None`)
              * `battery_low_threshold: u8` (Standard: `15`)
              * `battery_critical_threshold: u8` (Standard: `5`)
              * `use_dynamic_wallpaper: bool` (Standard: `false`)
              * `automatic_updates_enabled: bool` (Standard: `true`)
              * `telemetry_enabled: bool` (Standard: `false`)
              * `terminal_emulator: String` (Standard: `"gnome-terminal"`)
              * `file_manager: String` (Standard: `"nautilus"`)
              * `web_browser: String` (Standard: `"firefox"`)
              * `default_font_family: String` (Standard: `"Cantarell"`)
              * `font_size: u32` (Standard: `10`)
              * `keyboard_layout: String` (Standard: `"us"`)
              * `dark_mode: bool` (Standard: `true`)
              * `screenshot_save_dir: Option<PathBuf>` (Standard: `None`, XDG Pictures dir wird implizit genutzt)
              * `default_audio_output_device: Option<String>`
              * `default_audio_input_device: Option<String>`
              * `microphone_mute: bool` (Standard: `false`)
              * `speaker_mute: bool` (Standard: `false`)
              * `enable_desktop_icons: bool` (Standard: `true`)
              * `show_hidden_files: bool` (Standard: `false`)
    2.  **Hilfs-Enums/Structs (falls sinnvoll):** Für Felder wie `panel_position` könnte ein separates Enum (`PanelPosition { Top, Bottom, Left, Right }`) definiert werden, um Typsicherheit zu gewährleisten, wenn dies als String persistiert wird, kann es direkt als String in `DesktopSettings` bleiben.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/settings/data_types.rs`
  * **Abhängigkeiten:**
      * **Extern:** `serde::{Serialize, Deserialize}`, `std::path::PathBuf`.
  * **Kommunikationsmuster:** Keine direkten Kommunikationsmuster in dieser Datei; sie definiert nur die Datenstrukturen.
  * **Erwartete Ergebnisse/Outputs:** Robuste, serialisierbare und deserialisierbare Datenstrukturen für alle relevanten Desktop-Einstellungen.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Serialisierung und Deserialisierung von `DesktopSettings` zu und von JSON (oder YAML).
          * Prüfung der `Default`-Implementierung.
          * Tests mit allen Feldern gesetzt und mit `None` (falls `Option` verwendet).

#### Funktionsspezifikation: `novade_domain::settings::data_types`

```rust
// novade-domain/src/settings/data_types.rs

//! Definiert die Datenstrukturen für die globalen Systemeinstellungen von NovaDE.

use serde::{Serialize, Deserialize};
use std::path::PathBuf;

/// Repräsentiert alle globalen Desktop-Einstellungen von NovaDE.
///
/// Diese Struktur wird für die Serialisierung und Deserialisierung der
/// Benutzereinstellungen aus dem/in das Konfigurationsdateisystem verwendet.
/// Sie implementiert `Default`, um eine initiale Konfiguration bereitzustellen.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(default)] // Benutzt die Default-Implementierung für fehlende Felder beim Deserialisieren
pub struct DesktopSettings {
    /// Der Name des aktuell ausgewählten Desktop-Themas (z.B. "nova-dark").
    pub theme_name: String,
    /// Die Akzentfarbe im Hex-Code (z.B. "#6C78F7").
    pub accent_color: String,
    /// Die Position des Hauptpanels (z.B. "bottom", "top", "left", "right").
    /// Eine strenge Enumeration wird hier nicht erzwungen, um Flexibilität zu ermöglichen,
    /// kann aber auf UI-Ebene validiert werden.
    pub panel_position: String,
    /// Die Standard-Anzeigedauer für Benachrichtigungen in Millisekunden.
    pub notification_display_timeout_ms: u32,
    /// Gibt an, ob der "Bitte nicht stören"-Modus aktiviert ist.
    pub do_not_disturb_mode: bool,
    /// Die globale Systemlautstärke (0-100).
    pub global_volume: u8,
    /// Gibt an, ob UI-Animationen aktiviert sind.
    pub enable_animations: bool,
    /// Die bevorzugte Sprache des Benutzers (z.B. "en_US", "de_DE").
    pub preferred_language: String,
    /// Gibt an, ob das Panel automatisch ausgeblendet werden soll.
    pub auto_hide_panel: bool,
    /// Die Verzögerung in Millisekunden, bevor ein automatisch ausgeblendetes Panel
    /// nach Mausentfernung wieder verschwindet.
    pub panel_autohide_delay_ms: u32,
    /// Die Anzahl der verfügbaren Workspaces.
    pub workspace_count: u32,
    /// Gibt an, ob Hot Corners (aktive Ecken) aktiviert sind.
    pub hot_corners_enabled: bool,
    /// Die Verzögerung in Millisekunden, bevor eine Hot Corner Aktion ausgelöst wird.
    pub hot_corner_delay_ms: u32,
    /// Optionaler Pfad zum Desktop-Hintergrundbild.
    pub wallpaper_path: Option<PathBuf>,
    /// Der Schwellenwert in Prozent, bei dem eine "Batterie niedrig"-Benachrichtigung erscheint.
    pub battery_low_threshold: u8,
    /// Der Schwellenwert in Prozent, bei dem eine "Batterie kritisch"-Benachrichtigung erscheint.
    pub battery_critical_threshold: u8,
    /// Gibt an, ob dynamische Hintergrundbilder verwendet werden sollen.
    pub use_dynamic_wallpaper: bool,
    /// Gibt an, ob automatische System-Updates aktiviert sind.
    pub automatic_updates_enabled: bool,
    /// Gibt an, ob Telemetriedaten gesendet werden dürfen.
    pub telemetry_enabled: bool,
    /// Der bevorzugte Terminal-Emulator (z.B. "gnome-terminal", "alacritty").
    pub terminal_emulator: String,
    /// Der bevorzugte Dateimanager (z.B. "nautilus", "thunar").
    pub file_manager: String,
    /// Der bevorzugte Webbrowser (z.B. "firefox", "chromium").
    pub web_browser: String,
    /// Die bevorzugte Schriftfamilie.
    pub default_font_family: String,
    /// Die bevorzugte Schriftgröße.
    pub font_size: u32,
    /// Das bevorzugte Tastaturlayout (z.B. "us", "de").
    pub keyboard_layout: String,
    /// Gibt an, ob der dunkle Modus aktiviert ist.
    pub dark_mode: bool,
    /// Optionaler Pfad zum Speichern von Screenshots. Wenn `None`, wird der XDG Pictures-Ordner genutzt.
    pub screenshot_save_dir: Option<PathBuf>,
    /// Optional: Die ID des bevorzugten Audio-Ausgabegeräts.
    pub default_audio_output_device: Option<String>,
    /// Optional: Die ID des bevorzugten Audio-Eingabegeräts.
    pub default_audio_input_device: Option<String>,
    /// Gibt an, ob das Mikrofon stummgeschaltet ist.
    pub microphone_mute: bool,
    /// Gibt an, ob die Lautsprecher stummgeschaltet sind.
    pub speaker_mute: bool,
    /// Gibt an, ob Desktop-Icons angezeigt werden sollen.
    pub enable_desktop_icons: bool,
    /// Gibt an, ob versteckte Dateien in Dateimanagern angezeigt werden sollen.
    pub show_hidden_files: bool,
    // TODO: Weitere Einstellungen können hier im Laufe der Entwicklung hinzugefügt werden.
    // Beispiele: Login-Manager-Einstellungen, Netzwerk-Einstellungen (SSID-Prioritäten etc.),
    // Bluetooth-Einstellungen, Maus-/Touchpad-Einstellungen, Monitor-Konfigurationen,
    // Standardanwendungen für MIME-Typen, etc.
}

impl Default for DesktopSettings {
    /// Stellt die Standardwerte für die Desktop-Einstellungen bereit.
    /// Diese Werte werden verwendet, wenn keine gespeicherte Konfiguration gefunden wird
    /// oder wenn Felder beim Deserialisieren fehlen.
    fn default() -> Self {
        Self {
            theme_name: "nova-dark".to_string(),
            accent_color: "#6C78F7".to_string(), // Ein Nova-Blau
            panel_position: "bottom".to_string(),
            notification_display_timeout_ms: 5000,
            do_not_disturb_mode: false,
            global_volume: 75, // Standardlautstärke
            enable_animations: true,
            preferred_language: "en_US".to_string(),
            auto_hide_panel: false,
            panel_autohide_delay_ms: 500,
            workspace_count: 4,
            hot_corners_enabled: true,
            hot_corner_delay_ms: 200,
            wallpaper_path: None,
            battery_low_threshold: 15,
            battery_critical_threshold: 5,
            use_dynamic_wallpaper: false,
            automatic_updates_enabled: true,
            telemetry_enabled: false,
            terminal_emulator: "gnome-terminal".to_string(), // Standard
            file_manager: "nautilus".to_string(), // Standard
            web_browser: "firefox".to_string(), // Standard
            default_font_family: "Cantarell".to_string(),
            font_size: 10,
            keyboard_layout: "us".to_string(), // Standard
            dark_mode: true, // Standardmäßig dunkler Modus
            screenshot_save_dir: None,
            default_audio_output_device: None,
            default_audio_input_device: None,
            microphone_mute: false,
            speaker_mute: false,
            enable_desktop_icons: true,
            show_hidden_files: false,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;

    #[test]
    fn test_default_settings() {
        let settings = DesktopSettings::default();
        assert_eq!(settings.theme_name, "nova-dark");
        assert_eq!(settings.global_volume, 75);
        assert!(!settings.do_not_disturb_mode);
        assert_eq!(settings.wallpaper_path, None);
        assert_eq!(settings.workspace_count, 4);
    }

    #[test]
    fn test_serialize_deserialize_default() {
        let settings = DesktopSettings::default();
        let serialized = serde_json::to_string(&settings).unwrap();
        let deserialized: DesktopSettings = serde_json::from_str(&serialized).unwrap();
        assert_eq!(settings, deserialized);
    }

    #[test]
    fn test_serialize_deserialize_custom_values() {
        let mut settings = DesktopSettings::default();
        settings.theme_name = "light-theme".to_string();
        settings.do_not_disturb_mode = true;
        settings.wallpaper_path = Some(PathBuf::from("/path/to/my/wallpaper.jpg"));
        settings.global_volume = 50;
        settings.panel_position = "top".to_string();
        settings.hot_corners_enabled = false;
        settings.font_size = 12;

        let serialized = serde_json::to_string(&settings).unwrap();
        let deserialized: DesktopSettings = serde_json::from_str(&serialized).unwrap();
        assert_eq!(settings, deserialized);
        assert_eq!(deserialized.theme_name, "light-theme");
        assert!(deserialized.do_not_disturb_mode);
        assert_eq!(deserialized.wallpaper_path, Some(PathBuf::from("/path/to/my/wallpaper.jpg")));
        assert_eq!(deserialized.global_volume, 50);
        assert_eq!(deserialized.panel_position, "top");
        assert!(!deserialized.hot_corners_enabled);
        assert_eq!(deserialized.font_size, 12);
    }

    #[test]
    fn test_deserialize_with_missing_fields_uses_default() {
        // Simuliere eine ältere Konfigurationsdatei, die nicht alle Felder enthält.
        let old_json = r#"{
            "theme_name": "legacy-dark",
            "do_not_disturb_mode": true
        }"#;
        let deserialized: DesktopSettings = serde_json::from_str(old_json).unwrap();

        // Überprüfe, ob die explizit gesetzten Felder korrekt sind
        assert_eq!(deserialized.theme_name, "legacy-dark");
        assert!(deserialized.do_not_disturb_mode);

        // Überprüfe, ob die fehlenden Felder ihre Standardwerte haben
        assert_eq!(deserialized.global_volume, DesktopSettings::default().global_volume);
        assert_eq!(deserialized.wallpaper_path, DesktopSettings::default().wallpaper_path);
        assert_eq!(deserialized.workspace_count, DesktopSettings::default().workspace_count);
        assert_eq!(deserialized.enable_animations, DesktopSettings::default().enable_animations);
    }

    #[test]
    fn test_pathbuf_serialization() {
        let mut settings = DesktopSettings::default();
        let path = PathBuf::from("/home/user/backgrounds/nature.png");
        settings.wallpaper_path = Some(path.clone());

        let serialized = serde_json::to_string(&settings).unwrap();
        // println!("Serialized JSON: {}", serialized); // Zur Debugging-Hilfe

        // Überprüfe, dass der Pfad korrekt als String serialisiert wurde
        assert!(serialized.contains(r#""wallpaper_path":"/home/user/backgrounds/nature.png""#));

        let deserialized: DesktopSettings = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized.wallpaper_path, Some(path));
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (13 von 100) widmet sich weiterhin dem `settings`-Modul innerhalb der Domänenschicht (`novade-domain`), diesmal mit der detaillierten Spezifikation des `settings::errors.rs`-Moduls. Ein robustes Fehlermanagement ist entscheidend für die Stabilität und Wartbarkeit jeder Komponente, und dies gilt insbesondere für die Verwaltung von Systemeinstellungen.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 13/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.16.2. `novade-domain/src/settings/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/settings/errors.rs`
  * **Verantwortlichkeit:** Definiert eine umfassende Fehler-Enum (`SettingsError`) für alle Fehler, die innerhalb des `novade-domain::settings`-Moduls auftreten können. Dies umfasst Fehler beim Laden, Speichern, Validieren oder Anwenden von Einstellungen. Das Modul stellt sicher, dass Fehler kontextbezogen und konsistent über die Anwendung hinweg behandelt werden können, indem es `thiserror` für eine einfache Fehler-Definition und -Propagation nutzt.
  * **Kern-Aufgaben (Tasks):**
    1.  **`SettingsError` Enum definieren:**
          * Nutze `#[derive(thiserror::Error, Debug)]` für einfache Fehlerdefinitionen und automatische `Display`-Implementierungen.
          * Füge Varianten hinzu, die die verschiedenen Fehlerzustände im Einstellungsmanagement abbilden:
              * `#[error("Failed to load settings: {0}")] LoadError(#[from] novade_core::error::ConfigError)`: Fehler beim Laden der Einstellungen aus dem Konfigurationsservice. Nutzt `#[from]` für automatische Konvertierung von `ConfigError`.
              * `#[error("Failed to save settings: {0}")] SaveError(#[from] novade_core::error::ConfigError)`: Fehler beim Speichern der Einstellungen über den Konfigurationsservice. Nutzt `#[from]` für automatische Konvertierung von `ConfigError`.
              * `#[error("Setting key '{0}' not found or has incorrect type.")] NotFound(String)`: Tritt auf, wenn versucht wird, eine Einstellung abzurufen, die nicht existiert oder deren Typ nicht mit dem erwarteten Typ übereinstimmt (z.B. wenn eine Zahl erwartet wird, aber ein String gespeichert ist).
              * `#[error("Invalid setting value for key '{0}': {1}")] InvalidValue(String, String)`: Tritt auf, wenn ein Einstellungs-Wert semantisch ungültig ist (z.B. eine Lautstärke von 150). Der erste String ist der Schlüssel, der zweite die Begründung.
              * `#[error("Synchronization error with settings store: {0}")] SyncError(String)`: Für interne Synchronisationsfehler, z.B. wenn ein `RwLock` vergiftet wird oder unerwartete Zustände im internen Zustand auftreten.
              * `#[error("Internal service error: {0}")] Internal(String)`: Ein generischer Fehler für unerwartete interne Probleme.
              * `#[error("A broadcast channel send failed due to no receivers: {0}")] BroadcastSendError(String)`: Wenn eine Einstellungsänderung nicht an Abonnenten gesendet werden kann, weil keine Receiver existieren.
              * `#[error("Notification send error: {0}")] NotificationSendError(#[from] tokio::sync::broadcast::error::SendError<DesktopSettings>)`: Wenn ein Fehler beim Senden einer neuen `DesktopSettings`-Instanz über den Broadcast-Kanal auftritt. Dies sollte auftreten, wenn der Channel geschlossen wurde oder keine Listener mehr vorhanden sind.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/settings/errors.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_core::error::ConfigError`
      * **Extern:** `thiserror`, `tokio::sync::broadcast::error::SendError` (nur für die `NotificationSendError`-Variante).
  * **Kommunikationsmuster:** `SettingsError` wird von den `persistence` und `service` Modulen innerhalb des `settings` Verzeichnisses zurückgegeben und kann von aufrufenden Schichten (z.B. `novade-system` oder `novade-ui`) behandelt oder weiterpropagiert werden.
  * **Erwartete Ergebnisse/Outputs:** Eine klare, explizite und wartbare Fehlerbehandlungsstrategie für das Einstellungsmanagement.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Teste die Erstellung jeder `SettingsError`-Variante.
          * Überprüfe die korrekte Fehlermeldung (`.to_string()`).
          * Teste die automatische Konvertierung von `ConfigError` zu `LoadError` und `SaveError`.
          * Stellen Sie sicher, dass die `source()`-Kette für konvertierte Fehler korrekt ist.

#### Funktionsspezifikation: `novade_domain::settings::errors`

```rust
// novade-domain/src/settings/errors.rs

//! Definiert die Fehler-Enumeration für das globale Einstellungsmanagement von NovaDE.

use thiserror::Error;
use novade_core::error::ConfigError;
use tokio::sync::broadcast::error::SendError;

use crate::settings::data_types::DesktopSettings; // Importiere für SendError Typisierung

/// Repräsentiert alle möglichen Fehler, die im Einstellungsmanagement-Modul auftreten können.
#[derive(Error, Debug)]
pub enum SettingsError {
    /// Fehler beim Laden der Einstellungen aus dem Konfigurationsspeicher.
    /// Dies kann Dateisystemfehler, Deserialisierungsfehler oder Pfadfehler umfassen.
    #[error("Failed to load settings: {0}")]
    LoadError(#[from] ConfigError),

    /// Fehler beim Speichern der Einstellungen in den Konfigurationsspeicher.
    /// Dies kann Dateisystemfehler, Serialisierungsfehler oder Pfadfehler umfassen.
    #[error("Failed to save settings: {0}")]
    SaveError(#[from] ConfigError),

    /// Tritt auf, wenn versucht wird, eine Einstellung mit einem nicht existierenden Schlüssel
    /// abzurufen oder wenn der Wert unter dem Schlüssel nicht dem erwarteten Typ entspricht.
    #[error("Setting key '{0}' not found or has incorrect type.")]
    NotFound(String),

    /// Tritt auf, wenn ein Einstellungs-Wert semantisch ungültig ist (z.B. eine Zahl außerhalb des gültigen Bereichs).
    /// Der erste String ist der Schlüssel der Einstellung, der zweite eine detaillierte Begründung des Fehlers.
    #[error("Invalid setting value for key '{0}': {1}")]
    InvalidValue(String, String),

    /// Ein interner Synchronisationsfehler, z.B. wenn ein RwLock vergiftet wird oder
    /// ein unerwarteter inkonsistenter Zustand im internen Speicher auftritt.
    #[error("Synchronization error with settings store: {0}")]
    SyncError(String),

    /// Ein generischer interner Service-Fehler, der nicht spezifischer zugeordnet werden kann.
    #[error("Internal service error: {0}")]
    Internal(String),

    /// Fehler beim Senden einer Einstellungsänderung über einen Broadcast-Kanal,
    /// typischerweise weil keine Receiver mehr existieren oder der Kanal geschlossen wurde.
    #[error("Failed to send setting change notification: {0}")]
    NotificationSendError(#[from] SendError<DesktopSettings>),
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::{self, ErrorKind};

    #[test]
    fn test_load_error_from_config_error() {
        let io_err = io::Error::new(ErrorKind::NotFound, "config file missing");
        let config_err = ConfigError::IoError(io_err.into());
        let settings_err: SettingsError = config_err.into(); // Automatische Konvertierung

        assert!(matches!(settings_err, SettingsError::LoadError(_)));
        if let SettingsError::LoadError(e) = settings_err {
            assert_eq!(e.to_string(), "IO error: config file missing");
            // Überprüfe die Source-Kette
            assert!(e.source().is_some());
            assert_eq!(e.source().unwrap().to_string(), "config file missing");
        }
    }

    #[test]
    fn test_save_error_from_config_error() {
        let parse_err = serde_json::Error::custom("invalid json");
        let config_err = ConfigError::SerializationError(parse_err.into());
        let settings_err: SettingsError = config_err.into();

        assert!(matches!(settings_err, SettingsError::SaveError(_)));
        if let SettingsError::SaveError(e) = settings_err {
            assert_eq!(e.to_string(), "Serialization error: invalid json");
            assert!(e.source().is_some());
            assert_eq!(e.source().unwrap().to_string(), "invalid json");
        }
    }

    #[test]
    fn test_not_found_error() {
        let error = SettingsError::NotFound("theme_name".to_string());
        assert_eq!(error.to_string(), "Setting key 'theme_name' not found or has incorrect type.");
    }

    #[test]
    fn test_invalid_value_error() {
        let error = SettingsError::InvalidValue("global_volume".to_string(), "Value must be between 0 and 100".to_string());
        assert_eq!(error.to_string(), "Invalid setting value for key 'global_volume': Value must be between 0 and 100");
    }

    #[test]
    fn test_sync_error() {
        let error = SettingsError::SyncError("RwLock poisoned".to_string());
        assert_eq!(error.to_string(), "Synchronization error with settings store: RwLock poisoned");
    }

    #[test]
    fn test_internal_error() {
        let error = SettingsError::Internal("Unexpected state reached".to_string());
        assert_eq!(error.to_string(), "Internal service error: Unexpected state reached");
    }

    #[tokio::test]
    async fn test_notification_send_error() {
        let (tx, _rx) = tokio::sync::broadcast::channel::<DesktopSettings>(1);
        drop(_rx); // Schließe den Receiver, um einen SendError zu provozieren

        let settings = DesktopSettings::default();
        let send_result = tx.send(settings);
        let send_error = send_result.unwrap_err(); // Der Fehler ist vom Typ tokio::sync::broadcast::error::SendError
        let settings_err: SettingsError = send_error.into(); // Konvertiere

        assert!(matches!(settings_err, SettingsError::NotificationSendError(_)));
        if let SettingsError::NotificationSendError(e) = settings_err {
            // Die genaue Fehlermeldung von SendError kann variieren, aber wir können einen Teil prüfen.
            assert!(e.to_string().contains("channel closed"));
        }
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (14 von 100) widmet sich weiterhin dem `settings`-Modul innerhalb der Domänenschicht (`novade-domain`), diesmal mit der detaillierten Spezifikation des `settings::persistence_iface.rs`-Moduls. Die Abstraktion der Persistenzschicht durch einen Trait ist ein fundamentales Entwurfsmuster, das Flexibilität und Testbarkeit gewährleistet.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 14/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.16.3. `novade-domain/src/settings/persistence_iface.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/settings/persistence_iface.rs`
  * **Verantwortlichkeit:** Definiert den `SettingsProvider`-Trait, der die Schnittstelle für das Laden und Speichern der `DesktopSettings` kapselt. Dieser Trait ist entscheidend für die Dependency Inversion und ermöglicht es, verschiedene Persistenzmechanismen (z.B. Dateisystem, Datenbank, In-Memory für Tests) transparent auszutauschen, ohne die Kernlogik des `SettingsService` zu beeinflussen.
  * **Kern-Aufgaben (Tasks):**
    1.  **`SettingsProvider` Trait definieren:**
          * Der Trait muss `Send` und `Sync` sein, um in einem `Arc` oder `Box<dyn>` sicher über Threads hinweg verwendet werden zu können.
          * Der Trait muss `async_trait` verwenden, da die Implementierungen asynchrone I/O-Operationen ausführen werden.
          * Definiere die asynchrone Methode `load_settings()`.
          * Definiere die asynchrone Methode `save_settings()`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/settings/persistence_iface.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::settings::data_types::DesktopSettings`, `crate::settings::errors::SettingsError`.
      * **Extern:** `async_trait` (für asynchrone Trait-Methoden).
  * **Kommunikationsmuster:** Dieser Trait definiert den Vertrag für die Interaktion zwischen dem `SettingsService` (der diesen Trait verwendet) und der konkreten Persistenz-Implementierung (die diesen Trait implementiert).
  * **Erwartete Ergebnisse/Outputs:** Eine klar definierte, asynchrone Schnittstelle für die Persistenz von NovaDE-Einstellungen, die die Grundlage für eine flexible und testbare Architektur bildet.
  * **Teststrategie (Modul-spezifisch):**
      * **Keine Unit-Tests in dieser Datei:** Da es sich um einen reinen Trait handelt, gibt es hier keine ausführbare Logik zu testen. Die Implementierungen dieses Traits (z.B. `FilesystemSettingsProvider`) werden umfassend getestet, um die Einhaltung der Trait-Definition sicherzustellen. Der Test, dass der Trait kompiliert und korrekt definiert ist, reicht hier aus.

#### Funktionsspezifikation: `novade_domain::settings::persistence_iface`

```rust
// novade-domain/src/settings/persistence_iface.rs

//! Definiert den Trait für die Persistenz von NovaDE-Systemeinstellungen.
//!
//! Dieser Trait abstrahiert die Speicherung und das Laden der 'DesktopSettings',
//! wodurch die konkrete Implementierung austauschbar wird (z.B. Dateisystem,
//! Datenbank, Mock für Tests).

use async_trait::async_trait;
use crate::settings::data_types::DesktopSettings;
use crate::settings::errors::SettingsError;

/// Trait zur Abstraktion der Persistenzschicht für 'DesktopSettings'.
///
/// Implementierungen dieses Traits sind für das Speichern und Laden der
/// Desktop-Einstellungen verantwortlich. Sie müssen 'Send' und 'Sync' sein,
/// um thread-sicher in asynchronen Kontexten verwendet werden zu können.
#[async_trait]
pub trait SettingsProvider: Send + Sync {
    /// Lädt die 'DesktopSettings' aus dem konfigurierten Persistenzspeicher.
    ///
    /// # Returns
    /// - `Ok(DesktopSettings)`: Bei erfolgreichem Laden der Einstellungen.
    /// - `Err(SettingsError::LoadError)`: Wenn ein Fehler beim Laden auftritt.
    ///
    /// # Errors
    /// Gibt einen `SettingsError::LoadError` zurück, wenn:
    /// - Die Konfigurationsdatei nicht gefunden werden kann.
    /// - Die Daten in der Konfigurationsdatei nicht deserialisiert werden können.
    /// - Es andere I/O-bezogene Probleme gibt.
    async fn load_settings(&self) -> Result<DesktopSettings, SettingsError>;

    /// Speichert die bereitgestellten 'DesktopSettings' in den konfigurierten Persistenzspeicher.
    ///
    /// # Arguments
    /// * `settings` - Die zu speichernden 'DesktopSettings'.
    ///
    /// # Returns
    /// - `Ok(())`: Bei erfolgreichem Speichern der Einstellungen.
    /// - `Err(SettingsError::SaveError)`: Wenn ein Fehler beim Speichern auftritt.
    ///
    /// # Errors
    /// Gibt einen `SettingsError::SaveError` zurück, wenn:
    /// - Die Daten nicht serialisiert werden können.
    /// - Es ein Problem beim Schreiben in die Datei gibt (z.B. Berechtigungen, Speicherplatz).
    async fn save_settings(&self, settings: &DesktopSettings) -> Result<(), SettingsError>;
}

// Tests für Traits sind normalerweise nicht direkt in der Trait-Definition.
// Stattdessen werden Implementierungen dieses Traits getestet.
// Ein einfacher Kompilierungstest hier reicht aus.
#[cfg(test)]
mod tests {
    use super::*;
    use async_trait::async_trait;
    use crate::settings::data_types::DesktopSettings;
    use crate::settings::errors::SettingsError;
    use std::sync::{Arc, Mutex};

    // Eine Mock-Implementierung des Traits für Testzwecke
    struct MockSettingsProvider {
        // Optional: Zustand, um Load/Save-Verhalten zu simulieren
        #[allow(dead_code)]
        data: Mutex<DesktopSettings>,
        // Optional: Fehler, der simuliert werden soll
        #[allow(dead_code)]
        should_fail_load: bool,
        #[allow(dead_code)]
        should_fail_save: bool,
    }

    impl MockSettingsProvider {
        #[allow(dead_code)]
        fn new_mock_ok() -> Self {
            MockSettingsProvider {
                data: Mutex::new(DesktopSettings::default()),
                should_fail_load: false,
                should_fail_save: false,
            }
        }
        #[allow(dead_code)]
        fn new_mock_load_fail() -> Self {
            MockSettingsProvider {
                data: Mutex::new(DesktopSettings::default()),
                should_fail_load: true,
                should_fail_save: false,
            }
        }
        #[allow(dead_code)]
        fn new_mock_save_fail() -> Self {
            MockSettingsProvider {
                data: Mutex::new(DesktopSettings::default()),
                should_fail_load: false,
                should_fail_save: true,
            }
        }
    }

    #[async_trait]
    impl SettingsProvider for MockSettingsProvider {
        async fn load_settings(&self) -> Result<DesktopSettings, SettingsError> {
            if self.should_fail_load {
                Err(SettingsError::LoadError(novade_core::error::ConfigError::IoError(
                    std::io::Error::new(std::io::ErrorKind::Other, "Mock load error").into()
                )))
            } else {
                Ok(self.data.lock().unwrap().clone())
            }
        }

        async fn save_settings(&self, _settings: &DesktopSettings) -> Result<(), SettingsError> {
            if self.should_fail_save {
                Err(SettingsError::SaveError(novade_core::error::ConfigError::SerializationError(
                    "Mock save error".into()
                )))
            } else {
                Ok(())
            }
        }
    }

    #[tokio::test]
    async fn trait_is_object_safe() {
        // Dieser Test stellt sicher, dass der Trait als Trait-Objekt verwendet werden kann,
        // was wichtig für Dependency Injection ist.
        let provider: Box<dyn SettingsProvider> = Box::new(MockSettingsProvider::new_mock_ok());
        // Die Existenz des Box-Objekts ist der Test.
        assert!((provider.load_settings().await).is_ok());
    }

    #[tokio::test]
    async fn mock_provider_load_ok() {
        let provider = MockSettingsProvider::new_mock_ok();
        let settings = provider.load_settings().await.unwrap();
        assert_eq!(settings, DesktopSettings::default());
    }

    #[tokio::test]
    async fn mock_provider_load_fail() {
        let provider = MockSettingsProvider::new_mock_load_fail();
        let err = provider.load_settings().await.unwrap_err();
        assert!(matches!(err, SettingsError::LoadError(_)));
    }

    #[tokio::test]
    async fn mock_provider_save_ok() {
        let provider = MockSettingsProvider::new_mock_ok();
        let settings = DesktopSettings::default();
        let result = provider.save_settings(&settings).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn mock_provider_save_fail() {
        let provider = MockSettingsProvider::new_mock_save_fail();
        let settings = DesktopSettings::default();
        let err = provider.save_settings(&settings).await.unwrap_err();
        assert!(matches!(err, SettingsError::SaveError(_)));
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (15 von 100) widmet sich weiterhin dem `settings`-Modul innerhalb der Domänenschicht (`novade-domain`), diesmal mit der detaillierten Spezifikation des `settings::persistence.rs`-Moduls. Hier wird die konkrete Implementierung des `SettingsProvider`-Traits definiert, die für das tatsächliche Laden und Speichern der Einstellungen ins Dateisystem verantwortlich ist.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 15/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.16.4. `novade-domain/src/settings/persistence.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/settings/persistence.rs`
  * **Verantwortlichkeit:** Implementiert den `SettingsProvider`-Trait mittels des `ConfigServiceAsync` aus der `novade-core`-Schicht. Diese Struktur (`FilesystemSettingsProvider`) ist die primäre Persistenzlösung für die `DesktopSettings` und nutzt das Dateisystem (JSON-Format) für die Speicherung der Konfiguration. Sie kümmert sich um den Dateipfad, die Serialisierung/Deserialisierung und die Fehlerbehandlung auf Dateisystemebene.
  * **Kern-Aufgaben (Tasks):**
    1.  **`FilesystemSettingsProvider` Struct definieren:**
          * Sollte einen `Arc<dyn ConfigServiceAsync>` halten, um den Zugriff auf den Core-Konfigurationsdienst zu ermöglichen.
          * Benötigt einen festen `file_name` für die Einstellungen (z.B. `"desktop_settings.json"`).
          * Konstruktor `new(config_service: Arc<dyn ConfigServiceAsync>) -> Self` implementieren.
    2.  **`SettingsProvider` Trait für `FilesystemSettingsProvider` implementieren:**
          * **`load_settings()` Methode:**
              * Ruft `config_service.load_config()` mit dem Dateinamen auf.
              * Verwendet `serde_json` zum Deserialisieren der geladenen Daten in `DesktopSettings`.
              * Behandelt `ConfigError` und wandelt es in `SettingsError::LoadError` um.
              * Stellt sicher, dass bei einem `NotFound` Fehler (`ConfigError::NotFound`) oder Deserialisierungsfehler (wenn die Datei leer oder korrupt ist), die `DesktopSettings::default()` zurückgegeben wird, anstatt eines Fehlers. Dies ermöglicht eine "graceful degradation" und stellt sicher, dass die Anwendung immer mit Standardeinstellungen starten kann. Logge eine Warnung, wenn Standardwerte geladen werden.
              * **Algorithmus `load_settings`:**
                1.  Versuche, die Konfiguration über `self.config_service.load_config::<DesktopSettings>(SETTINGS_FILE_NAME).await` zu laden.
                2.  Wenn das Laden erfolgreich ist (`Ok(settings)`), gib `Ok(settings)` zurück.
                3.  Wenn ein `ConfigError::NotFound` auftritt:
                      * Logge eine Info-Nachricht: "Settings file not found. Loading default settings."
                      * Gib `Ok(DesktopSettings::default())` zurück.
                4.  Wenn ein `ConfigError::SerializationError` auftritt:
                      * Logge eine Warnung: "Failed to deserialize settings file. Using default settings. Error: {e}"
                      * Gib `Ok(DesktopSettings::default())` zurück.
                5.  Bei allen anderen `ConfigError`-Varianten (z.B. `IoError` mit anderen Fehlertypen, `PermissionDenied`):
                      * Wandle den `ConfigError` in einen `SettingsError::LoadError` um und gib `Err(settings_error)` zurück.
          * **`save_settings()` Methode:**
              * Ruft `config_service.save_config()` mit den `DesktopSettings` und dem Dateinamen auf.
              * Verwendet `serde_json` zum Serialisieren der `DesktopSettings`.
              * Behandelt `ConfigError` und wandelt es in `SettingsError::SaveError` um.
              * **Algorithmus `save_settings`:**
                1.  Versuche, die `settings` über `self.config_service.save_config(SETTINGS_FILE_NAME, settings).await` zu speichern.
                2.  Gib `Ok(())` bei Erfolg zurück.
                3.  Gib `Err(SettingsError::SaveError(e))` bei `ConfigError` zurück.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/settings/persistence.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::settings::data_types::DesktopSettings`, `crate::settings::errors::SettingsError`, `novade_core::config::service::ConfigServiceAsync`, `novade_core::error::ConfigError`.
      * **Extern:** `async_trait`, `std::sync::Arc`, `tracing` (für Logging).
  * **Kommunikationsmuster:** `FilesystemSettingsProvider` kommuniziert mit dem `ConfigServiceAsync` der `novade-core`-Schicht, um Lese- und Schreiboperationen auf dem Dateisystem durchzuführen.
  * **Erwartete Ergebnisse/Outputs:** Eine funktionierende Persistenzschicht für die Desktop-Einstellungen, die Konfigurationen zuverlässig lädt und speichert, und robuste Fehlerbehandlung (inkl. Fallback auf Standardwerte bei korrupten/fehlenden Dateien).
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests (mit Mocking von `ConfigServiceAsync`):**
          * Test, ob `load_settings` `DesktopSettings::default()` zurückgibt, wenn `ConfigServiceAsync::load_config` `ConfigError::NotFound` zurückgibt.
          * Test, ob `load_settings` `DesktopSettings::default()` zurückgibt, wenn `ConfigServiceAsync::load_config` `ConfigError::SerializationError` zurückgibt.
          * Test, ob `load_settings` einen `SettingsError::LoadError` zurückgibt, wenn `ConfigServiceAsync::load_config` einen anderen `ConfigError` (z.B. `IoError`) zurückgibt.
          * Test, ob `load_settings` erfolgreich die Einstellungen lädt, wenn `ConfigServiceAsync::load_config` erfolgreich ist.
          * Test, ob `save_settings` erfolgreich ist, wenn `ConfigServiceAsync::save_config` erfolgreich ist.
          * Test, ob `save_settings` einen `SettingsError::SaveError` zurückgibt, wenn `ConfigServiceAsync::save_config` fehlschlägt.

#### Funktionsspezifikation: `novade_domain::settings::persistence`

```rust
// novade-domain/src/settings/persistence.rs

//! Implementiert den 'SettingsProvider'-Trait für die Persistenz von NovaDE-Systemeinstellungen
//! mittels des `ConfigServiceAsync` und Dateisystem (JSON-Format).

use async_trait::async_trait;
use std::sync::Arc;
use tracing::{warn, info, error}; // Für Logging

use novade_core::config::service::ConfigServiceAsync;
use novade_core::error::ConfigError;

use crate::settings::data_types::DesktopSettings;
use crate::settings::errors::SettingsError;
use crate::settings::persistence_iface::SettingsProvider;

/// Der Dateiname für die Desktop-Einstellungen.
const SETTINGS_FILE_NAME: &str = "desktop_settings.json";

/// Implementierung des `SettingsProvider`-Traits, die das Dateisystem nutzt.
///
/// Diese Struktur kapselt die Logik für das Laden und Speichern der
/// `DesktopSettings` in einer JSON-Datei, unter Verwendung des `ConfigServiceAsync`
/// aus der Core-Schicht.
pub struct FilesystemSettingsProvider {
    config_service: Arc<dyn ConfigServiceAsync>,
}

impl FilesystemSettingsProvider {
    /// Erstellt eine neue Instanz von `FilesystemSettingsProvider`.
    ///
    /// # Arguments
    /// * `config_service` - Ein `Arc`-Pointer auf den `ConfigServiceAsync`,
    ///   der für die zugrundeliegenden Datei-I/O-Operationen verwendet wird.
    pub fn new(config_service: Arc<dyn ConfigServiceAsync>) -> Self {
        FilesystemSettingsProvider { config_service }
    }
}

#[async_trait]
impl SettingsProvider for FilesystemSettingsProvider {
    /// Lädt die `DesktopSettings` aus der Konfigurationsdatei.
    ///
    /// Wenn die Datei nicht existiert oder Deserialisierungsfehler auftreten,
    /// werden die `DesktopSettings::default()` zurückgegeben und eine Warnung geloggt.
    /// Andere I/O-Fehler oder Berechtigungsfehler werden als `SettingsError::LoadError` propagiert.
    async fn load_settings(&self) -> Result<DesktopSettings, SettingsError> {
        match self.config_service.load_config(SETTINGS_FILE_NAME).await {
            Ok(settings) => Ok(settings),
            Err(e) => {
                match e {
                    ConfigError::NotFound(_) => {
                        info!("Settings file '{}' not found. Loading default settings.", SETTINGS_FILE_NAME);
                        Ok(DesktopSettings::default())
                    }
                    ConfigError::SerializationError(_) => {
                        warn!(
                            "Failed to deserialize settings file '{}'. Using default settings. Error: {}",
                            SETTINGS_FILE_NAME, e
                        );
                        Ok(DesktopSettings::default())
                    }
                    _ => {
                        error!(
                            "Failed to load settings file '{}' due to a core configuration error: {}",
                            SETTINGS_FILE_NAME, e
                        );
                        // Alle anderen ConfigError-Varianten werden als LoadError propagiert
                        Err(SettingsError::LoadError(e))
                    }
                }
            }
        }
    }

    /// Speichert die bereitgestellten `DesktopSettings` in die Konfigurationsdatei.
    ///
    /// # Arguments
    /// * `settings` - Ein Referenz auf die zu speichernden `DesktopSettings`.
    ///
    /// # Errors
    /// Gibt `SettingsError::SaveError` zurück, wenn ein Fehler beim Serialisieren
    /// oder Schreiben der Datei auftritt.
    async fn save_settings(&self, settings: &DesktopSettings) -> Result<(), SettingsError> {
        self.config_service
            .save_config(SETTINGS_FILE_NAME, settings)
            .await
            .map_err(|e| {
                error!(
                    "Failed to save settings to file '{}' due to a core configuration error: {}",
                    SETTINGS_FILE_NAME, e
                );
                SettingsError::SaveError(e)
            })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use async_trait::async_trait;
    use novade_core::error::{ConfigError, CoreError};
    use std::io::{self, ErrorKind};
    use mockall::{automock, predicate::*}; // Für Mocking

    // Mock des ConfigServiceAsync
    #[automock]
    #[async_trait]
    impl ConfigServiceAsync for ConfigServiceAsync {
        async fn load_config<T: serde::de::DeserializeOwned + Send + 'static>(
            &self,
            _file_name: &str,
        ) -> Result<T, ConfigError> {
            unimplemented!() // Wird von Mockall überschrieben
        }
        async fn save_config<T: serde::Serialize + Send + Sync + 'static>(
            &self,
            _file_name: &str,
            _config: &T,
        ) -> Result<(), ConfigError> {
            unimplemented!() // Wird von Mockall überschrieben
        }
        async fn get_config_dir(&self, _app_name: &str) -> Result<PathBuf, CoreError> {
            unimplemented!()
        }
        async fn get_config_file_path(&self, _app_name: &str, _file_name: &str) -> Result<PathBuf, CoreError> {
            unimplemented!()
        }
    }


    #[tokio::test]
    async fn load_settings_returns_default_on_not_found_error() {
        let mut mock_config_service = MockConfigServiceAsync::new();
        mock_config_service
            .expect_load_config::<DesktopSettings>()
            .with(eq(SETTINGS_FILE_NAME))
            .times(1)
            .returning(|_| {
                Err(ConfigError::NotFound(
                    "File not found".to_string().into(),
                ))
            });

        let provider = FilesystemSettingsProvider::new(Arc::new(mock_config_service));
        let settings = provider.load_settings().await.unwrap();
        assert_eq!(settings, DesktopSettings::default());
    }

    #[tokio::test]
    async fn load_settings_returns_default_on_serialization_error() {
        let mut mock_config_service = MockConfigServiceAsync::new();
        mock_config_service
            .expect_load_config::<DesktopSettings>()
            .with(eq(SETTINGS_FILE_NAME))
            .times(1)
            .returning(|_| {
                Err(ConfigError::SerializationError(
                    "Invalid JSON".to_string().into(),
                ))
            });

        let provider = FilesystemSettingsProvider::new(Arc::new(mock_config_service));
        let settings = provider.load_settings().await.unwrap();
        assert_eq!(settings, DesktopSettings::default());
    }

    #[tokio::test]
    async fn load_settings_propagates_other_config_errors() {
        let mut mock_config_service = MockConfigServiceAsync::new();
        mock_config_service
            .expect_load_config::<DesktopSettings>()
            .with(eq(SETTINGS_FILE_NAME))
            .times(1)
            .returning(|_| {
                Err(ConfigError::IoError(
                    io::Error::new(ErrorKind::PermissionDenied, "Permission denied").into(),
                ))
            });

        let provider = FilesystemSettingsProvider::new(Arc::new(mock_config_service));
        let result = provider.load_settings().await;
        assert!(matches!(result, Err(SettingsError::LoadError(_))));
        if let Err(SettingsError::LoadError(e)) = result {
            assert!(matches!(e, ConfigError::IoError(_)));
        }
    }

    #[tokio::test]
    async fn load_settings_successfully() {
        let mut mock_config_service = MockConfigServiceAsync::new();
        let expected_settings = DesktopSettings {
            theme_name: "custom-theme".to_string(),
            global_volume: 80,
            ..Default::default()
        };
        mock_config_service
            .expect_load_config::<DesktopSettings>()
            .with(eq(SETTINGS_FILE_NAME))
            .times(1)
            .returning(move |_| Ok(expected_settings.clone()));

        let provider = FilesystemSettingsProvider::new(Arc::new(mock_config_service));
        let settings = provider.load_settings().await.unwrap();
        assert_eq!(settings.theme_name, "custom-theme");
        assert_eq!(settings.global_volume, 80);
    }

    #[tokio::test]
    async fn save_settings_successfully() {
        let mut mock_config_service = MockConfigServiceAsync::new();
        let settings_to_save = DesktopSettings {
            theme_name: "new-theme".to_string(),
            ..Default::default()
        };
        // Expect that save_config is called with the correct file name and settings
        mock_config_service
            .expect_save_config::<DesktopSettings>()
            .with(eq(SETTINGS_FILE_NAME), eq(settings_to_save.clone()))
            .times(1)
            .returning(|_, _| Ok(()));

        let provider = FilesystemSettingsProvider::new(Arc::new(mock_config_service));
        let result = provider.save_settings(&settings_to_save).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn save_settings_propagates_error() {
        let mut mock_config_service = MockConfigServiceAsync::new();
        let settings_to_save = DesktopSettings::default();
        mock_config_service
            .expect_save_config::<DesktopSettings>()
            .with(eq(SETTINGS_FILE_NAME), eq(settings_to_save.clone()))
            .times(1)
            .returning(|_, _| {
                Err(ConfigError::IoError(
                    io::Error::new(ErrorKind::PermissionDenied, "No write permission").into(),
                ))
            });

        let provider = FilesystemSettingsProvider::new(Arc::new(mock_config_service));
        let result = provider.save_settings(&settings_to_save).await;
        assert!(matches!(result, Err(SettingsError::SaveError(_))));
        if let Err(SettingsError::SaveError(e)) = result {
            assert!(matches!(e, ConfigError::IoError(_)));
        }
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (16 von 100) widmet sich weiterhin dem `settings`-Modul innerhalb der Domänenschicht (`novade-domain`), diesmal mit der detaillierten Spezifikation des `settings::service.rs`-Moduls. Der `SettingsService` ist die zentrale Entität dieses Moduls, die die Geschäftslogik für das Laden, Speichern, Zugreifen und Benachrichtigen über Änderungen an den globalen Desktop-Einstellungen kapselt.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 16/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.16.5. `novade-domain/src/settings/service.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/settings/service.rs`
  * **Verantwortlichkeit:** Implementiert den Kern der Einstellungsverwaltung. Der `SettingsService` ist eine asynchrone Singleton-ähnliche Komponente, die die aktuellen `DesktopSettings` im Speicher hält, Lade- und Speicheroperationen über den `SettingsProvider` (die Persistenzschicht) orchestriert und andere Komponenten über Änderungen an den Einstellungen benachrichtigt. Es ist der primäre Interaktionspunkt für andere Domänen- oder System-Services, die Einstellungen benötigen oder ändern wollen.
  * **Kern-Aufgaben (Tasks):**
    1.  **`SettingsService` Struct definieren:**
          * Felder:
              * `current_settings: Arc<RwLock<DesktopSettings>>`: Ein asynchrones Read-Write Lock, das die aktuell geladenen Einstellungen im Speicher schützt. `Arc` ermöglicht gemeinsame Besitzrechte.
              * `settings_provider: Arc<dyn SettingsProvider>`: Der Trait-Objekt-Pointer zur konkreten Persistenz-Implementierung. `Arc` für gemeinsame Nutzung.
              * `settings_change_tx: broadcast::Sender<DesktopSettings>`: Ein Tokio-Broadcast-Sender für die Benachrichtigung über Einstellungsänderungen.
    2.  **Konstruktor `new()` implementieren:**
          * Nimmt `settings_provider: Arc<dyn SettingsProvider>` als Argument.
          * Initialisiert `current_settings` mit einem `RwLock` und `DesktopSettings::default()`.
          * Initialisiert `settings_change_tx` und den zugehörigen `settings_change_rx` (der `rx` wird initial verworfen, da der Konstruktor den `tx` zurückgibt, um `subscribe()` darauf aufzurufen). Eine sinnvolle Kapazität für den Channel ist `4` oder `8`, da Einstellungsänderungen nicht extrem häufig sind und der neueste Wert entscheidend ist.
          * Logge, dass der Dienst initialisiert wurde.
    3.  **Asynchrone Methode `load_settings()` implementieren:**
          * Lädt Einstellungen vom `settings_provider`.
          * Bei Erfolg: Aktualisiert `current_settings` (mit `write().await`) und sendet die neuen Einstellungen über `settings_change_tx`.
          * Bei Fehler: Logge den Fehler und behandle ihn gemäß `SettingsError`. Beispielsweise, wenn ein `LoadError` auftritt, sollte der Dienst nicht abstürzen, sondern stattdessen die Standardeinstellungen beibehalten oder laden und den Fehler loggen.
          * **Algorithmus `load_settings`:**
            1.  Rufe `self.settings_provider.load_settings().await` auf.
            2.  Wenn `Ok(loaded_settings)`:
                  * Rufe `self.current_settings.write().await` auf, um einen exklusiven Schreibzugriff zu erhalten.
                  * Ersetze den Inhalt des Locks mit `loaded_settings.clone()`.
                  * Versuche, `loaded_settings.clone()` über `self.settings_change_tx.send(loaded_settings)` zu senden. Logge einen Fehler, falls der Send fehlschlägt (was bedeutet, dass es keine Listener gibt, aber der Dienst sollte weiterlaufen).
                  * Gib `Ok(())` zurück.
            3.  Wenn `Err(e)`:
                  * Logge den Fehler als `error!`.
                  * Gib `Err(e)` zurück.
    4.  **Asynchrone Methode `save_settings()` implementieren:**
          * Nimmt `new_settings: DesktopSettings` als Argument.
          * Validiert `new_settings` (z.B. Bereichsprüfungen, wenn nicht bereits in `DesktopSettings::default()` oder Setter-Methoden behandelt).
          * Aktualisiert `current_settings` (mit `write().await`).
          * Speichert die aktualisierten Einstellungen über `settings_provider`.
          * Sendet die aktualisierten Einstellungen über `settings_change_tx`.
          * **Algorithmus `save_settings`:**
            1.  Rufe `self.current_settings.write().await` auf, um einen exklusiven Schreibzugriff zu erhalten.
            2.  Ersetze den Inhalt des Locks mit `new_settings.clone()`.
            3.  Rufe `self.settings_provider.save_settings(&new_settings).await` auf.
            4.  Wenn `Ok(())`:
                  * Versuche, `new_settings.clone()` über `self.settings_change_tx.send(new_settings)` zu senden. Logge einen Fehler, falls der Send fehlschlägt.
                  * Gib `Ok(())` zurück.
            5.  Wenn `Err(e)`:
                  * Logge den Fehler als `error!`.
                  * Gib `Err(e)` zurück.
    5.  **Synchrone Methode `get_current_settings()` implementieren:**
          * Gibt eine geklonte Kopie der aktuell geladenen `DesktopSettings` zurück.
          * Benutzt `read().await` für `current_settings`.
          * **Algorithmus `get_current_settings`:**
            1.  Rufe `self.current_settings.read().await` auf, um einen Shared-Read-Zugriff zu erhalten.
            2.  Klone die Einstellungen und gib sie zurück.
    6.  **Methode `subscribe_to_changes()` implementieren:**
          * Gibt einen `broadcast::Receiver<DesktopSettings>` zurück, über den Clients Änderungen an den Einstellungen abonnieren können.
          * **Algorithmus `subscribe_to_changes`:**
            1.  Rufe `self.settings_change_tx.subscribe()` auf und gib den resultierenden `Receiver` zurück.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/settings/service.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::settings::data_types::DesktopSettings`, `crate::settings::errors::SettingsError`, `crate::settings::persistence_iface::SettingsProvider`.
      * **Extern:** `tokio::sync::{RwLock, broadcast}`, `std::sync::Arc`, `tracing`.
  * **Kommunikationsmuster:**
      * **Inbound:** Andere Services rufen `load_settings()`, `save_settings()` und `get_current_settings()` auf.
      * **Outbound:** Der Service ruft Methoden auf dem `SettingsProvider` auf. Sendet `DesktopSettings`-Instanzen über den `settings_change_tx`-Kanal an Abonnenten.
  * **Erwartete Ergebnisse/Outputs:**
      * Ein zentraler, thread-sicherer Service zum Verwalten von globalen Einstellungen.
      * Die Fähigkeit, Einstellungen zu laden, zu speichern und den aktuellen Zustand abzufragen.
      * Ein robuster Mechanismus zur Benachrichtigung von Änderungen, der es der UI und anderen Systemkomponenten ermöglicht, reaktiv auf Einstellungsänderungen zu reagieren.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests (mit Mocking von `SettingsProvider`):**
          * Test der `new()`-Funktion.
          * Test `load_settings`:
              * Erfolgreiches Laden und Aktualisieren von `current_settings`.
              * Überprüfung, ob `settings_change_tx` die neuen Einstellungen sendet.
              * Verhalten bei `LoadError` vom Provider (sollte Fehler loggen und propagieren, aber Dienst nicht abstürzen).
              * Verhalten bei `NotFound` und `SerializationError` vom Provider (sollte `DesktopSettings::default()` laden und loggen).
          * Test `save_settings`:
              * Erfolgreiches Speichern und Aktualisieren von `current_settings`.
              * Überprüfung, ob `settings_change_tx` die neuen Einstellungen sendet.
              * Verhalten bei `SaveError` vom Provider (sollte Fehler loggen und propagieren).
          * Test `get_current_settings`: Überprüfung, ob die korrekten, aktuell geladenen Einstellungen zurückgegeben werden.
          * Test `subscribe_to_changes`:
              * Sicherstellen, dass ein `Receiver` zurückgegeben wird.
              * Testen, ob der `Receiver` Updates empfängt, wenn `load_settings` oder `save_settings` aufgerufen werden.
              * Testen des Verhaltens mit mehreren Abonnenten.

#### Funktionsspezifikation: `novade_domain::settings::service`

```rust
// novade-domain/src/settings/service.rs

//! Implementiert den zentralen Service für das Management globaler Systemeinstellungen.
//!
//! Der 'SettingsService' ist verantwortlich für das Laden, Speichern, Caching und
//! Verteilen von Benachrichtigungen über Änderungen an den 'DesktopSettings'.

use std::sync::Arc;
use tokio::sync::{broadcast, RwLock};
use tracing::{info, warn, error}; // Für strukturiertes Logging

use crate::settings::data_types::DesktopSettings;
use crate::settings::errors::SettingsError;
use crate::settings::persistence_iface::SettingsProvider;

/// Die Größe des Broadcast-Kanals für Einstellungsänderungen.
/// Eine kleine Puffergröße ist ausreichend, da nur der neueste Wert relevant ist.
const SETTINGS_CHANGE_CHANNEL_CAPACITY: usize = 8;

/// Der zentrale Service für das Management von NovaDE-Systemeinstellungen.
///
/// Dieser Dienst ist thread-sicher und kann über `Arc` und `RwLock` von
/// verschiedenen Komponenten der Anwendung gemeinsam genutzt werden.
pub struct SettingsService {
    /// Die aktuell geladenen Desktop-Einstellungen, geschützt durch ein RwLock.
    current_settings: Arc<RwLock<DesktopSettings>>,
    /// Der Persistenz-Provider für das Laden und Speichern der Einstellungen.
    settings_provider: Arc<dyn SettingsProvider>,
    /// Sender für den Broadcast-Kanal, der Benachrichtigungen über Einstellungsänderungen sendet.
    settings_change_tx: broadcast::Sender<DesktopSettings>,
}

impl SettingsService {
    /// Erstellt eine neue Instanz des `SettingsService`.
    ///
    /// # Arguments
    /// * `settings_provider` - Ein `Arc`-Pointer auf die Implementierung des `SettingsProvider`-Traits,
    ///   die für die Persistenz der Einstellungen zuständig ist.
    ///
    /// # Returns
    /// Eine neue Instanz von `SettingsService`.
    pub fn new(settings_provider: Arc<dyn SettingsProvider>) -> Self {
        let (tx, _rx) = broadcast::channel(SETTINGS_CHANGE_CHANNEL_CAPACITY);
        info!("SettingsService initialized.");
        Self {
            current_settings: Arc::new(RwLock::new(DesktopSettings::default())), // Initial mit Standardeinstellungen
            settings_provider,
            settings_change_tx: tx,
        }
    }

    /// Lädt die Einstellungen aus dem Persistenzspeicher und aktualisiert den internen Zustand.
    ///
    /// Bei erfolgreichem Laden werden alle Abonnenten über die neuen Einstellungen benachrichtigt.
    /// Falls die Einstellungsdatei nicht gefunden wird oder deserialisiert werden kann,
    /// werden die Standardeinstellungen geladen und eine entsprechende Warnung geloggt.
    /// Andere Fehler beim Laden werden propagiert.
    ///
    /// # Errors
    /// Gibt einen `SettingsError` zurück, wenn ein nicht-behandelbarer Fehler beim Laden auftritt.
    pub async fn load_settings(&self) -> Result<(), SettingsError> {
        info!("Attempting to load settings...");
        match self.settings_provider.load_settings().await {
            Ok(loaded_settings) => {
                let mut current_settings_guard = self.current_settings.write().await;
                *current_settings_guard = loaded_settings.clone();
                info!("Settings loaded successfully.");

                // Benachrichtige Abonnenten über die Änderung
                if let Err(e) = self.settings_change_tx.send(loaded_settings) {
                    warn!("Failed to send settings change notification after load: {}", e);
                }
                Ok(())
            }
            Err(e) => {
                // Hier wird der Fehler geloggt, aber der Dienst bleibt aktiv.
                // Spezielle Fehler wie NotFound oder SerializationError werden vom Provider
                // bereits in Ok(Default::default()) umgewandelt. Somit sollte ein Err(e)
                // hier nur bei schwerwiegenderen Fehlern (z.B. Berechtigungen) auftreten.
                error!("Failed to load settings: {:?}", e);
                Err(e)
            }
        }
    }

    /// Speichert die bereitgestellten neuen Einstellungen in den Persistenzspeicher
    /// und aktualisiert den internen Zustand.
    ///
    /// Bei erfolgreichem Speichern werden alle Abonnenten über die neuen Einstellungen benachrichtigt.
    ///
    /// # Arguments
    /// * `new_settings` - Die `DesktopSettings`-Instanz, die gespeichert werden soll.
    ///
    /// # Errors
    /// Gibt einen `SettingsError` zurück, wenn ein Fehler beim Speichern auftritt.
    pub async fn save_settings(&self, new_settings: DesktopSettings) -> Result<(), SettingsError> {
        info!("Attempting to save settings...");
        // Validierung kann hier oder in Setter-Methoden auf DesktopSettings erfolgen
        // Der Einfachheit halber nehmen wir an, dass `new_settings` bereits gültig ist.

        // Zuerst den internen Zustand aktualisieren
        let mut current_settings_guard = self.current_settings.write().await;
        *current_settings_guard = new_settings.clone();
        drop(current_settings_guard); // Lock freigeben vor await call, falls der Provider blockiert

        // Dann die Änderungen persistieren
        match self.settings_provider.save_settings(&new_settings).await {
            Ok(()) => {
                info!("Settings saved successfully.");
                // Benachrichtige Abonnenten über die Änderung
                if let Err(e) = self.settings_change_tx.send(new_settings) {
                    warn!("Failed to send settings change notification after save: {}", e);
                }
                Ok(())
            }
            Err(e) => {
                error!("Failed to save settings: {:?}", e);
                Err(e)
            }
        }
    }

    /// Gibt eine geklonte Kopie der aktuell im Speicher gehaltenen `DesktopSettings` zurück.
    ///
    /// Diese Methode bietet einen synchronen Lesezugriff auf den aktuellen Einstellungszustand,
    /// ohne eine asynchrone Operation auszulösen.
    ///
    /// # Returns
    /// Eine geklonte Instanz von `DesktopSettings`.
    pub async fn get_current_settings(&self) -> DesktopSettings {
        let settings_guard = self.current_settings.read().await;
        settings_guard.clone()
    }

    /// Erstellt einen neuen `broadcast::Receiver` für Einstellungsänderungen.
    ///
    /// Jedes Mal, wenn die Einstellungen geladen oder gespeichert werden (und sich ändern),
    /// werden alle aktiven Receiver benachrichtigt.
    ///
    /// # Returns
    /// Ein `broadcast::Receiver<DesktopSettings>`, mit dem Änderungen abonniert werden können.
    pub fn subscribe_to_changes(&self) -> broadcast::Receiver<DesktopSettings> {
        self.settings_change_tx.subscribe()
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use async_trait::async_trait;
    use novade_core::error::{ConfigError, CoreError};
    use mockall::{automock, predicate::*};
    use std::io::{self, ErrorKind};
    use tokio::time::{timeout, Duration};

    // Mock des SettingsProvider
    #[automock]
    #[async_trait]
    impl SettingsProvider for SettingsProvider {
        async fn load_settings(&self) -> Result<DesktopSettings, SettingsError> {
            unimplemented!()
        }
        async fn save_settings(&self, _settings: &DesktopSettings) -> Result<(), SettingsError> {
            unimplemented!()
        }
    }

    #[tokio::test]
    async fn new_settings_service_initializes_with_default() {
        let mock_provider = Arc::new(MockSettingsProvider::new());
        let service = SettingsService::new(mock_provider);

        let current = service.get_current_settings().await;
        assert_eq!(current, DesktopSettings::default());
    }

    #[tokio::test]
    async fn load_settings_successful() {
        let mut mock_provider = MockSettingsProvider::new();
        let custom_settings = DesktopSettings {
            theme_name: "test-theme".to_string(),
            global_volume: 60,
            ..Default::default()
        };
        mock_provider
            .expect_load_settings()
            .times(1)
            .returning(move || Ok(custom_settings.clone()));

        let mock_provider_arc = Arc::new(mock_provider);
        let service = SettingsService::new(mock_provider_arc.clone());

        // Subscribe *before* loading to capture the broadcast
        let mut rx = service.subscribe_to_changes();

        // Perform the load operation
        let result = service.load_settings().await;
        assert!(result.is_ok());

        // Verify internal state updated
        let current = service.get_current_settings().await;
        assert_eq!(current.theme_name, "test-theme");
        assert_eq!(current.global_volume, 60);

        // Verify broadcast was sent
        let received_settings = timeout(Duration::from_millis(100), rx.recv()).await.unwrap().unwrap();
        assert_eq!(received_settings.theme_name, "test-theme");
    }

    #[tokio::test]
    async fn load_settings_handles_load_error() {
        let mut mock_provider = MockSettingsProvider::new();
        mock_provider
            .expect_load_settings()
            .times(1)
            .returning(|| {
                Err(SettingsError::LoadError(ConfigError::IoError(
                    io::Error::new(ErrorKind::PermissionDenied, "Access denied").into(),
                )))
            });

        let mock_provider_arc = Arc::new(mock_provider);
        let service = SettingsService::new(mock_provider_arc.clone());

        let initial_settings = service.get_current_settings().await;
        assert_eq!(initial_settings, DesktopSettings::default()); // Should be default initially

        let result = service.load_settings().await;
        assert!(matches!(result, Err(SettingsError::LoadError(_))));

        // Internal state should remain default or initial state on load error
        let current = service.get_current_settings().await;
        assert_eq!(current, DesktopSettings::default());
    }

    #[tokio::test]
    async fn save_settings_successful() {
        let mut mock_provider = MockSettingsProvider::new();
        let new_settings = DesktopSettings {
            theme_name: "saved-theme".to_string(),
            enable_animations: false,
            ..Default::default()
        };
        let new_settings_clone = new_settings.clone(); // Clone for the closure
        mock_provider
            .expect_save_settings()
            .with(eq(new_settings_clone.clone())) // Ensure mock expects the correct settings
            .times(1)
            .returning(|_| Ok(()));

        let mock_provider_arc = Arc::new(mock_provider);
        let service = SettingsService::new(mock_provider_arc.clone());

        let mut rx = service.subscribe_to_changes();

        let result = service.save_settings(new_settings.clone()).await;
        assert!(result.is_ok());

        // Verify internal state updated
        let current = service.get_current_settings().await;
        assert_eq!(current.theme_name, "saved-theme");
        assert!(!current.enable_animations);

        // Verify broadcast was sent
        let received_settings = timeout(Duration::from_millis(100), rx.recv()).await.unwrap().unwrap();
        assert_eq!(received_settings.theme_name, "saved-theme");
    }

    #[tokio::test]
    async fn save_settings_handles_save_error() {
        let mut mock_provider = MockSettingsProvider::new();
        let new_settings = DesktopSettings {
            theme_name: "fail-theme".to_string(),
            ..Default::default()
        };
        mock_provider
            .expect_save_settings()
            .times(1)
            .returning(|_| {
                Err(SettingsError::SaveError(ConfigError::SerializationError(
                    "Serialization failed".to_string().into(),
                )))
            });

        let mock_provider_arc = Arc::new(mock_provider);
        let service = SettingsService::new(mock_provider_arc.clone());

        // Although save fails, the in-memory state is updated first
        let result = service.save_settings(new_settings.clone()).await;
        assert!(matches!(result, Err(SettingsError::SaveError(_))));

        // Verify internal state was *still* updated despite save error
        let current = service.get_current_settings().await;
        assert_eq!(current.theme_name, "fail-theme");

        // No broadcast should happen if save fails and the internal state wasn't conceptually 'saved'
        // This is a design decision: if in-memory update happens before actual save, then broadcast happens.
        // If broadcast *only* happens on successful save, then move broadcast send to after `map_err`.
        // Current implementation broadcasts *after* internal state update, which is often desired for responsiveness,
        // even if disk write fails (user might still see the change in UI).
        // Let's ensure broadcast happens even if save fails, as per current code.
        let mut rx = service.subscribe_to_changes();
        let received_settings = timeout(Duration::from_millis(100), rx.recv()).await.unwrap().unwrap();
        assert_eq!(received_settings.theme_name, "fail-theme");
    }


    #[tokio::test]
    async fn get_current_settings_returns_correct_state() {
        let mock_provider = Arc::new(MockSettingsProvider::new());
        let service = SettingsService::new(mock_provider);

        let initial_settings = service.get_current_settings().await;
        assert_eq!(initial_settings, DesktopSettings::default());

        // Manually set some settings for testing
        let mut new_settings = DesktopSettings::default();
        new_settings.theme_name = "manual-theme".to_string();
        *service.current_settings.write().await = new_settings.clone();

        let fetched_settings = service.get_current_settings().await;
        assert_eq!(fetched_settings.theme_name, "manual-theme");
    }

    #[tokio::test]
    async fn subscribe_to_changes_receives_updates() {
        let mut mock_provider = MockSettingsProvider::new();
        mock_provider
            .expect_load_settings()
            .times(1)
            .returning(|| Ok(DesktopSettings::default())); // Mock initial load
        mock_provider
            .expect_save_settings()
            .times(2) // Expect two saves for two updates
            .returning(|_| Ok(()));

        let mock_provider_arc = Arc::new(mock_provider);
        let service = SettingsService::new(mock_provider_arc.clone());

        // First, load initial settings (this will trigger a broadcast)
        service.load_settings().await.unwrap();

        // Subscribe to changes *after* initial load, but before subsequent saves
        let mut rx1 = service.subscribe_to_changes();
        let mut rx2 = service.subscribe_to_changes();

        let settings1 = DesktopSettings {
            theme_name: "update1".to_string(),
            ..Default::default()
        };
        service.save_settings(settings1.clone()).await.unwrap();

        let received1_rx1 = timeout(Duration::from_millis(100), rx1.recv()).await.unwrap().unwrap();
        let received1_rx2 = timeout(Duration::from_millis(100), rx2.recv()).await.unwrap().unwrap();
        assert_eq!(received1_rx1.theme_name, "update1");
        assert_eq!(received1_rx2.theme_name, "update1");

        let settings2 = DesktopSettings {
            theme_name: "update2".to_string(),
            ..Default::default()
        };
        service.save_settings(settings2.clone()).await.unwrap();

        let received2_rx1 = timeout(Duration::from_millis(100), rx1.recv()).await.unwrap().unwrap();
        let received2_rx2 = timeout(Duration::from_millis(100), rx2.recv()).await.unwrap().unwrap();
        assert_eq!(received2_rx1.theme_name, "update2");
        assert_eq!(received2_rx2.theme_name, "update2");
    }

    #[tokio::test]
    async fn subscribe_to_changes_receives_latest_on_lag() {
        let mut mock_provider = MockSettingsProvider::new();
        mock_provider
            .expect_load_settings()
            .times(1)
            .returning(|| Ok(DesktopSettings::default()));
        mock_provider
            .expect_save_settings()
            .times(2)
            .returning(|_| Ok(()));

        let mock_provider_arc = Arc::new(mock_provider);
        let service = SettingsService::new(mock_provider_arc.clone());

        // Load initial settings
        service.load_settings().await.unwrap();

        let mut rx = service.subscribe_to_changes();

        // Send multiple updates rapidly
        let settings_a = DesktopSettings { theme_name: "A".to_string(), ..Default::default() };
        service.save_settings(settings_a.clone()).await.unwrap();
        let settings_b = DesktopSettings { theme_name: "B".to_string(), ..Default::default() };
        service.save_settings(settings_b.clone()).await.unwrap();
        let settings_c = DesktopSettings { theme_name: "C".to_string(), ..Default::default() };
        service.save_settings(settings_c.clone()).await.unwrap();

        // Due to `SETTINGS_CHANGE_CHANNEL_CAPACITY`, earlier messages might be dropped.
        // We should receive the latest available, or potentially a few preceding ones.
        // The broadcast channel's `recv` method on `lagged` ensures we don't miss the *latest* update.
        let received_c = timeout(Duration::from_millis(100), rx.recv()).await.unwrap().unwrap();
        assert_eq!(received_c.theme_name, "C"); // Should receive the latest
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (17 von 100) schließt das `settings`-Modul innerhalb der Domänenschicht (`novade-domain`) ab, indem er die `mod.rs`-Datei spezifiziert. Diese Datei ist entscheidend, da sie die öffentliche API des Moduls definiert und somit festlegt, welche Komponenten von außen sichtbar und nutzbar sind.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 17/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.16.6. `novade-domain/src/settings/mod.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/settings/mod.rs`
  * **Verantwortlichkeit:** Definiert die öffentliche Schnittstelle des `settings`-Moduls. Es re-exportiert die wichtigsten Typen, Traits und Services, die von anderen Teilen der `novade-domain`-Crate oder von der `novade-system`-Schicht benötigt werden.
  * **Kern-Aufgaben (Tasks):**
    1.  **Re-Exports definieren:**
          * Re-exportiere `DesktopSettings` aus `data_types.rs`.
          * Re-exportiere `SettingsError` aus `errors.rs`.
          * Re-exportiere `SettingsProvider` aus `persistence_iface.rs`.
          * Re-exportiere `FilesystemSettingsProvider` aus `persistence.rs`.
          * Re-exportiere `SettingsService` aus `service.rs`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/settings/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** `data_types`, `errors`, `persistence_iface`, `persistence`, `service` (alle innerhalb des `settings`-Moduls).
  * **Kommunikationsmuster:** Ermöglicht anderen Modulen und Crates den Zugriff auf die definierten Schnittstellen des `settings`-Moduls, ohne die interne Verzeichnisstruktur kennen zu müssen.
  * **Erwartete Ergebnisse/Outputs:** Eine saubere und zugängliche API für das Einstellungsmanagement.
  * **Teststrategie (Modul-spezifisch):**
      * **Kompilierungstest:** Stelle sicher, dass alle Re-Exports korrekt sind und das Modul ohne Fehler kompiliert. Es sind keine spezifischen Laufzeittests erforderlich, da dies eine reine Re-Export-Datei ist und die Funktionalität in den jeweiligen Untermodulen getestet wird.

#### Funktionsspezifikation: `novade_domain::settings::mod`

```rust
// novade-domain/src/settings/mod.rs

//! Das 'settings'-Modul von NovaDE ist verantwortlich für das Management globaler
//! Systemeinstellungen. Es bietet Funktionalität zum Laden, Speichern,
//! Abrufen und Abonnieren von Änderungen an den Desktop-Einstellungen.

// Öffentliche Re-Exports
pub mod data_types;
pub mod errors;
pub mod persistence_iface;
pub mod persistence;
pub mod service;

// Re-exportiere die wichtigsten Elemente, um sie unter `novade_domain::settings::*` verfügbar zu machen.
pub use self::data_types::DesktopSettings;
pub use self::errors::SettingsError;
pub use self::persistence_iface::SettingsProvider;
pub use self::persistence::FilesystemSettingsProvider;
pub use self::service::SettingsService;

// Mögliche zukünftige Erweiterungen:
// - Eine Makro-basierte Schnittstelle für typsicheren Zugriff auf einzelne Einstellungen
// - Ein Migrationstool für Einstellungsdateien bei Versionsupdates
// - Tools zur Validierung von Einstellungen über die Rust-Typen hinaus (z.B. Regex für Strings)

#[cfg(test)]
mod tests {
    // Es sind keine spezifischen Unit-Tests für `mod.rs` erforderlich,
    // da dessen Hauptfunktion das Re-Exportieren ist.
    // Ein erfolgreicher Kompilierungsprozess dieser Datei genügt als Test.

    // Wir können jedoch einfache Tests hinzufügen, um sicherzustellen, dass die Typen
    // über den Re-Export erreichbar sind.
    use super::*;

    #[test]
    fn test_desktop_settings_is_publicly_accessible() {
        let _settings = DesktopSettings::default();
        // Wenn dieser Test kompiliert, ist DesktopSettings korrekt re-exportiert.
        assert_eq!(_settings.theme_name, "nova-dark");
    }

    #[test]
    fn test_settings_error_is_publicly_accessible() {
        let _error = SettingsError::NotFound("some_key".to_string());
        // Wenn dieser Test kompiliert, ist SettingsError korrekt re-exportiert.
        assert_eq!(_error.to_string(), "Setting key 'some_key' not found or has incorrect type.");
    }

    #[test]
    fn test_settings_service_is_publicly_accessible() {
        // Da SettingsService einen SettingsProvider benötigt, mocken wir ihn.
        use mockall::{automock, predicate::*};
        use async_trait::async_trait;
        use std::sync::Arc;

        #[automock]
        #[async_trait]
        impl SettingsProvider for SettingsProvider {
            async fn load_settings(&self) -> Result<DesktopSettings, SettingsError> {
                Ok(DesktopSettings::default())
            }
            async fn save_settings(&self, _settings: &DesktopSettings) -> Result<(), SettingsError> {
                Ok(())
            }
        }

        let mock_provider = Arc::new(MockSettingsProvider::new());
        let _service = SettingsService::new(mock_provider);
        // Wenn dieser Test kompiliert, ist SettingsService korrekt re-exportiert.
        // Die Funktionalität wird in `service.rs` getestet.
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (18 von 100) leitet das nächste große Modul innerhalb der Domänenschicht (`novade-domain`) ein: das `notifications`-Modul. Dieses Modul ist entscheidend für die zentrale Verwaltung und Verarbeitung von Systembenachrichtigungen, die an den Benutzer gesendet werden sollen.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 18/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.17. `novade-domain/src/notifications`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notifications`
  * **Verantwortlichkeit:** Dieses Modul ist das Herzstück des Benachrichtigungssystems in NovaDE. Es ist verantwortlich für die Modellierung von Benachrichtigungsdaten, die Definition von Regeln für deren Verarbeitung (z.B. Filtern, Stummschalten, Hervorheben), die Speicherung dieser Regeln, die eigentliche Verarbeitungslogik sowie die Bereitstellung eines Services zur Interaktion mit externen Benachrichtigungsquellen und der UI. Es stellt sicher, dass Benachrichtigungen konsistent und gemäß den Benutzereinstellungen behandelt werden.
  * **Kern-Aufgaben (Tasks):**
    1.  **Definieren der grundlegenden Datenstrukturen:** Erstellung von Rust-Structs und Enums, die eine Benachrichtigung und die zugehörigen Regelstrukturen abbilden.
    2.  **Fehlerbehandlung:** Implementierung einer spezifischen Fehler-Enum für das Benachrichtigungsmodul.
    3.  **Persistenzschnittstelle:** Definition eines Traits für die Speicherung und das Laden von Benachrichtigungsregeln.
    4.  **Dateisystem-Persistenz:** Implementierung des Persistenz-Traits für das Dateisystem.
    5.  **Regel-Engine:** Entwicklung der Kernlogik zur Verarbeitung von Benachrichtigungen basierend auf definierten Regeln.
    6.  **Benachrichtigungs-Service:** Erstellung des übergeordneten Services, der alle Subkomponenten des Moduls koordiniert und eine API für externe Interaktionen bietet.
    7.  **Modul-Exposition:** Definition der öffentlichen API des gesamten `notifications`-Moduls.
  * **Unterverzeichnisse/Dateien:**
      * `novade-domain/src/notifications/data_types.rs`
      * `novade-domain/src/notifications/errors.rs`
      * `novade-domain/src/notifications/persistence_iface.rs`
      * `novade-domain/src/notifications/persistence.rs`
      * `novade-domain/src/notifications/engine.rs`
      * `novade-domain/src/notifications/service.rs`
      * `novade-domain/src/notifications/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_core::error`, `novade_core::config`, `novade_domain::settings` (für `SettingIsTrue` Regelbedingung).
      * **Extern:** `serde`, `chrono`, `uuid`, `tokio`, `tracing`, `async-trait`, `thiserror`, `regex`.
  * **Kommunikationsmuster:**
      * **Inbound:** Empfängt rohe Benachrichtigungsdaten von der `novade-system` Schicht (insbesondere von `dbus_interfaces::notifications_server`) oder intern von anderen Domänen-Services. Empfängt Anfragen zur Regelverwaltung von der UI.
      * **Outbound:** Sendet verarbeitete Benachrichtigungen an die `novade-ui` Schicht zur Anzeige. Ruft den `SettingsService` der Domänenschicht ab, um auf globale Einstellungen für Regelbedingungen zuzugreifen. Verwendet den `ConfigServiceAsync` aus `novade_core` für die Persistenz der Regeln.
  * **Erwartete Ergebnisse/Outputs:**
      * Ein robustes und konfigurierbares Benachrichtigungssystem, das eine feingranulare Kontrolle über die Anzeige von Benachrichtigungen ermöglicht.
      * Standardisierte Datenstrukturen für Benachrichtigungen und Regeln.
      * Eine effiziente Regelverarbeitungs-Engine.
      * APIs zum Senden, Empfangen und Verwalten von Benachrichtigungen und Regeln.
  * **Priorisierung:** Dieses Modul sollte nach dem `settings`-Modul implementiert werden, da die Benachrichtigungsregeln möglicherweise auf globale Systemeinstellungen (`DesktopSettings`) zugreifen müssen.

-----

### 3.17.1. `novade-domain/src/notifications/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notifications/data_types.rs`
  * **Verantwortlichkeit:** Definiert alle grundlegenden Datenstrukturen, die für die Repräsentation von Benachrichtigungen und die zugehörigen Verarbeitungsregeln benötigt werden. Dies umfasst die eigentliche `Notification` Struktur, sowie die verschiedenen Komponenten, die eine `NotificationRule` ausmachen (Bedingungen, Aktionen).
  * **Kern-Aufgaben (Tasks):**
    1.  **`Notification` Struct definieren:**
          * Repräsentiert eine eingehende Systembenachrichtigung.
          * Felder:
              * `id: Uuid`: Eindeutiger Bezeichner für die Benachrichtigung. Generiert beim Erhalt der Benachrichtigung.
              * `app_name: String`: Name der sendenden Anwendung (z.B. "Firefox", "System").
              * `replaces_id: Option<u32>`: Optional: ID einer bestehenden Benachrichtigung, die ersetzt werden soll (D-Bus Standard).
              * `app_icon: Option<String>`: Optional: Pfad zum Anwendungssymbol oder Icon-Name (z.B. "firefox", "/usr/share/icons/app.png").
              * `summary: String`: Kurzer Titel der Benachrichtigung.
              * `body: Option<String>`: Optional: Detaillierter Text der Benachrichtigung.
              * `actions: Vec<String>`: Liste von Aktions-IDs, die der Benutzer ausführen kann (D-Bus Standard).
              * `hints: HashMap<String, Value>`: Zusätzliche Metadaten (z.B. "urgency", "category"). Nutze `serde_json::Value` für Flexibilität, oder spezifischere Enums/Structs für bekannte Hints.
              * `expire_timeout: i32`: Verfallszeit in Millisekunden (-1 für kein Timeout).
              * `timestamp: DateTime<Utc>`: Zeitpunkt des Empfangs der Benachrichtigung.
              * `category: Option<String>`: Optional: Standardisierte Kategorie der Benachrichtigung (z.B. "device", "email", "im").
              * `urgency: UrgencyLevel`: Schweregrad der Benachrichtigung (Low, Normal, Critical).
              * `desktop_entry: Option<String>`: Optional: Name der .desktop-Datei der sendenden Anwendung (z.B. "firefox").
          * Ableitungen: `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `Default`.
    2.  **`UrgencyLevel` Enum definieren:**
          * Varianten: `Low`, `Normal`, `Critical`.
          * Ableitungen: `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `Default` (sollte `Normal` sein).
    3.  **`ConditionField` Enum definieren:**
          * Repräsentiert die Felder einer `Notification`, die in einer Regelbedingung verwendet werden können.
          * Varianten: `AppName`, `Summary`, `Body`, `Category`, `Urgency`, `DesktopEntry`.
          * Ableitungen: `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
    4.  **`Operator` Enum definieren:**
          * Repräsentiert die Vergleichsoperatoren für Regelbedingungen.
          * Varianten: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `MatchesRegex`, `IsGreaterThan`, `IsLessThan`, `SettingIsTrue`.
          * Ableitungen: `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
    5.  **`RuleConditionValue` Enum definieren:**
          * Repräsentiert den Wert, mit dem ein Feld verglichen wird.
          * Varianten: `String(String)`, `Integer(i32)`, `Urgency(UrgencyLevel)`, `Boolean(bool)`.
          * Ableitungen: `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
    6.  **`SimpleRuleCondition` Struct definieren:**
          * Eine einzelne, atomare Bedingung.
          * Felder:
              * `field: ConditionField`: Das Feld der Benachrichtigung, das geprüft wird.
              * `operator: Operator`: Der Vergleichsoperator.
              * `value: RuleConditionValue`: Der Wert, mit dem verglichen wird.
          * Ableitungen: `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
    7.  **`RuleCondition` Enum definieren:**
          * Ermöglicht die Kombination von Bedingungen (logische Verknüpfungen).
          * Varianten:
              * `Simple(SimpleRuleCondition)`: Eine einzelne Bedingung.
              * `And(Vec<RuleCondition>)`: Logisches AND aus mehreren Bedingungen.
              * `Or(Vec<RuleCondition>)`: Logisches OR aus mehreren Bedingungen.
              * `Not(Box<RuleCondition>)`: Logisches NOT einer Bedingung.
          * Ableitungen: `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
    8.  **`RuleAction` Enum definieren:**
          * Repräsentiert eine Aktion, die ausgeführt wird, wenn eine Regel greift.
          * Varianten:
              * `Suppress`: Unterdrückt die Anzeige der Benachrichtigung.
              * `PlaySound(String)`: Spielt einen Sound ab (Pfad zum Sound-Asset).
              * `SetUrgency(UrgencyLevel)`: Ändert den Schweregrad.
              * `Highlight`: Markiert die Benachrichtigung visuell (z.B. anderer Hintergrund).
              * `RunCommand(String)`: Führt einen externen Befehl aus.
              * `StopProcessingFurtherRules`: Beendet die Regelverarbeitung für diese Benachrichtigung.
              * `Log(String)`: Loggt eine benutzerdefinierte Nachricht.
          * Ableitungen: `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
    9.  **`NotificationRule` Struct definieren:**
          * Eine vollständige Benachrichtigungsregel.
          * Felder:
              * `id: Uuid`: Eindeutiger Bezeichner für die Regel.
              * `name: String`: Anzeigename der Regel.
              * `enabled: bool`: Gibt an, ob die Regel aktiv ist.
              * `priority: u32`: Priorität der Regel (niedriger Wert = höhere Priorität). Regeln werden nach Priorität absteigend sortiert und verarbeitet.
              * `conditions: RuleCondition`: Die Bedingungen, unter denen die Regel greift.
              * `actions: Vec<RuleAction>`: Die Aktionen, die ausgeführt werden, wenn die Bedingungen erfüllt sind.
          * Ableitungen: `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `Default`.
    10. **`NotificationRuleSet` Struct definieren:**
          * Eine Sammlung von `NotificationRule` Instanzen.
          * Felder:
              * `rules: Vec<NotificationRule>`: Die Liste der Regeln.
          * Ableitungen: `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `Default`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notifications/data_types.rs`
  * **Abhängigkeiten:**
      * **Extern:** `serde`, `serde_json` (für `Value` in hints), `uuid` (für `Uuid`), `chrono` (für `DateTime<Utc>`).
  * **Kommunikationsmuster:** Stellt die Datenschemata bereit, die von allen anderen Teilen des `notifications`-Moduls verwendet werden.
  * **Erwartete Ergebnisse/Outputs:**
      * Ein umfassender Satz von Datentypen zur Modellierung von Benachrichtigungen und deren Verarbeitungsregeln.
      * Sicherstellung der Serialisierbarkeit/Deserialisierbarkeit dieser Typen für Persistenz.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der `Default`-Implementierungen für alle relevanten Structs/Enums.
          * Testen der Serialisierung und Deserialisierung jeder Struktur und Enum zu/von JSON.
          * Testen der Gleichheits- und Hashing-Implementierungen (`PartialEq`, `Eq`, `Hash`).
          * Testen der Erstellung komplexer `RuleCondition` Enums (z.B. verschachtelte AND/OR-Bedingungen).
          * Test der `UrgencyLevel` Konvertierungen (falls Implementierung von `From` für u8/i32 oder ähnliches).

#### Funktionsspezifikation: `novade_domain::notifications::data_types`

```rust
// novade-domain/src/notifications/data_types.rs

//! Definiert die Datenstrukturen für Benachrichtigungen und deren Verarbeitungsregeln.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_json::Value; // Für flexible Hints
use std::collections::HashMap;
use uuid::Uuid;

/// Schweregrad einer Benachrichtigung.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")] // Für Konsistenz bei der Serialisierung
pub enum UrgencyLevel {
    Low,
    Normal,
    Critical,
}

impl Default for UrgencyLevel {
    fn default() -> Self {
        UrgencyLevel::Normal
    }
}

/// Repräsentiert eine eingehende Systembenachrichtigung.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Notification {
    /// Eindeutiger Bezeichner für die Benachrichtigung, generiert beim Empfang.
    pub id: Uuid,
    /// Name der sendenden Anwendung (z.B. "Firefox", "System").
    pub app_name: String,
    /// Optional: ID einer bestehenden Benachrichtigung, die ersetzt werden soll (D-Bus Standard).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replaces_id: Option<u32>,
    /// Optional: Pfad zum Anwendungssymbol oder Icon-Name (z.B. "firefox", "/usr/share/icons/app.png").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app_icon: Option<String>,
    /// Kurzer Titel der Benachrichtigung.
    pub summary: String,
    /// Optional: Detaillierter Text der Benachrichtigung.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// Liste von Aktions-IDs, die der Benutzer ausführen kann (D-Bus Standard).
    #[serde(default)]
    pub actions: Vec<String>,
    /// Zusätzliche Metadaten (z.B. "urgency", "category", "desktop-entry").
    /// Verwendet `serde_json::Value` für Flexibilität, da Hints variieren können.
    #[serde(default)]
    pub hints: HashMap<String, Value>,
    /// Verfallszeit in Millisekunden (-1 für kein Timeout).
    pub expire_timeout: i32,
    /// Zeitpunkt des Empfangs der Benachrichtigung (UTC).
    pub timestamp: DateTime<Utc>,
    /// Optional: Standardisierte Kategorie der Benachrichtigung (z.B. "device", "email", "im").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub category: Option<String>,
    /// Schweregrad der Benachrichtigung.
    #[serde(default)]
    pub urgency: UrgencyLevel,
    /// Optional: Name der .desktop-Datei der sendenden Anwendung (z.B. "firefox").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub desktop_entry: Option<String>,
}

impl Default for Notification {
    fn default() -> Self {
        Self {
            id: Uuid::new_v4(), // Eine neue UUID für jede Standard-Benachrichtigung
            app_name: String::new(),
            replaces_id: None,
            app_icon: None,
            summary: String::new(),
            body: None,
            actions: Vec::new(),
            hints: HashMap::new(),
            expire_timeout: -1, // Kein Timeout standardmäßig
            timestamp: Utc::now(),
            category: None,
            urgency: UrgencyLevel::Normal,
            desktop_entry: None,
        }
    }
}

/// Repräsentiert die Felder einer `Notification`, die in einer Regelbedingung verwendet werden können.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ConditionField {
    AppName,
    Summary,
    Body,
    Category,
    Urgency,
    DesktopEntry,
    // Zukünftige Felder: Source, IconName, ActionNames, HasBody, IsReplaced
}

/// Repräsentiert die Vergleichsoperatoren für Regelbedingungen.
///
/// `SettingIsTrue` ist ein spezieller Operator, der verwendet wird, um den Wert
/// einer globalen Systemeinstellung (aus `DesktopSettings`) abzufragen.
/// Der `RuleConditionValue` muss hier `Boolean(true)` sein, um die Bedingung zu erfüllen.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Operator {
    Equals,
    Contains,
    StartsWith,
    EndsWith,
    MatchesRegex,
    IsGreaterThan, // Nur für numerische Werte (z.B. UrgencyLevel)
    IsLessThan,    // Nur für numerische Werte (z.B. UrgencyLevel)
    SettingIsTrue, // Spezieller Operator für die Abfrage einer globalen Systemeinstellung
}

/// Repräsentiert den Wert, mit dem ein Feld verglichen wird.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(untagged)] // Für flexible Deserialisierung (versucht nacheinander die Varianten)
pub enum RuleConditionValue {
    String(String),
    Integer(i32),
    Urgency(UrgencyLevel),
    Boolean(bool), // Insbesondere für SettingIsTrue
}

/// Eine einzelne, atomare Bedingung für eine Benachrichtigungsregel.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct SimpleRuleCondition {
    pub field: ConditionField,
    pub operator: Operator,
    pub value: RuleConditionValue,
}

/// Ermöglicht die Kombination von Bedingungen (logische Verknüpfungen).
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(untagged)] // Für flexible Deserialisierung
pub enum RuleCondition {
    /// Eine einzelne atomare Bedingung.
    Simple(SimpleRuleCondition),
    /// Logisches AND aus mehreren Bedingungen. Alle Unterbedingungen müssen wahr sein.
    And(Vec<RuleCondition>),
    /// Logisches OR aus mehreren Bedingungen. Mindestens eine Unterbedingung muss wahr sein.
    Or(Vec<RuleCondition>),
    /// Logisches NOT einer Bedingung. Die Unterbedingung muss falsch sein.
    Not(Box<RuleCondition>),
}

/// Repräsentiert eine Aktion, die ausgeführt wird, wenn eine Regel greift.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum RuleAction {
    /// Unterdrückt die Anzeige der Benachrichtigung.
    Suppress,
    /// Spielt einen Sound ab (Pfad zum Sound-Asset).
    PlaySound(String),
    /// Ändert den Schweregrad der Benachrichtigung.
    SetUrgency(UrgencyLevel),
    /// Markiert die Benachrichtigung visuell (z.B. anderer Hintergrund in der UI).
    Highlight,
    /// Führt einen externen Shell-Befehl aus.
    RunCommand(String),
    /// Beendet die Regelverarbeitung für diese Benachrichtigung,
    /// nachdem diese Aktion und alle vorherigen Aktionen angewendet wurden.
    StopProcessingFurtherRules,
    /// Loggt eine benutzerdefinierte Nachricht im NovaDE-Log.
    Log(String),
}

/// Eine vollständige Benachrichtigungsregel.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct NotificationRule {
    /// Eindeutiger Bezeichner für die Regel.
    pub id: Uuid,
    /// Anzeigename der Regel (für UI).
    pub name: String,
    /// Gibt an, ob die Regel aktiv ist.
    pub enabled: bool,
    /// Priorität der Regel (niedriger Wert = höhere Priorität).
    /// Regeln werden nach Priorität absteigend sortiert und verarbeitet.
    pub priority: u32,
    /// Die Bedingungen, unter denen die Regel greift.
    pub conditions: RuleCondition,
    /// Die Aktionen, die ausgeführt werden, wenn die Bedingungen erfüllt sind.
    pub actions: Vec<RuleAction>,
}

impl Default for NotificationRule {
    fn default() -> Self {
        Self {
            id: Uuid::new_v4(),
            name: "New Rule".to_string(),
            enabled: true,
            priority: 100, // Standard-Priorität
            conditions: RuleCondition::Simple(SimpleRuleCondition {
                field: ConditionField::AppName,
                operator: Operator::Equals,
                value: RuleConditionValue::String("".to_string()),
            }),
            actions: Vec::new(),
        }
    }
}

/// Eine Sammlung von NotificationRule Instanzen, die den gesamten Regelsatz bilden.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
pub struct NotificationRuleSet {
    pub rules: Vec<NotificationRule>,
}


#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;

    #[test]
    fn test_urgency_level_default() {
        assert_eq!(UrgencyLevel::default(), UrgencyLevel::Normal);
    }

    #[test]
    fn test_urgency_level_serialization() {
        let low = UrgencyLevel::Low;
        assert_eq!(serde_json::to_string(&low).unwrap(), r#""low""#);
        let normal = UrgencyLevel::Normal;
        assert_eq!(serde_json::to_string(&normal).unwrap(), r#""normal""#);
        let critical = UrgencyLevel::Critical;
        assert_eq!(serde_json::to_string(&critical).unwrap(), r#""critical""#);
    }

    #[test]
    fn test_urgency_level_deserialization() {
        assert_eq!(serde_json::from_str::<UrgencyLevel>(r#""low""#).unwrap(), UrgencyLevel::Low);
        assert_eq!(serde_json::from_str::<UrgencyLevel>(r#""normal""#).unwrap(), UrgencyLevel::Normal);
        assert_eq!(serde_json::from_str::<UrgencyLevel>(r#""critical""#).unwrap(), UrgencyLevel::Critical);
    }

    #[test]
    fn test_notification_default() {
        let notif = Notification::default();
        assert_eq!(notif.app_name, "");
        assert_eq!(notif.expire_timeout, -1);
        assert_eq!(notif.urgency, UrgencyLevel::Normal);
        assert!(!notif.id.is_nil()); // Should have a valid UUID
    }

    #[test]
    fn test_notification_serialization_deserialization() {
        let mut notif = Notification::default();
        notif.app_name = "TestApp".to_string();
        notif.summary = "Hello World".to_string();
        notif.body = Some("This is a test notification.".to_string());
        notif.urgency = UrgencyLevel::Critical;
        notif.hints.insert("category".to_string(), Value::String("email".to_string()));

        let serialized = serde_json::to_string(&notif).unwrap();
        let deserialized: Notification = serde_json::from_str(&serialized).unwrap();

        assert_eq!(deserialized.app_name, "TestApp");
        assert_eq!(deserialized.summary, "Hello World");
        assert_eq!(deserialized.body, Some("This is a test notification.".to_string()));
        assert_eq!(deserialized.urgency, UrgencyLevel::Critical);
        assert_eq!(deserialized.hints["category"], Value::String("email".to_string()));
        assert_eq!(deserialized.id, notif.id); // UUID should be preserved
        // Note: timestamp precision might vary depending on JSON representation,
        // so direct equality check might fail if not handled carefully,
        // but for basic test, it often works.
        // For production, consider comparing timestamps with a tolerance.
    }

    #[test]
    fn test_condition_field_serialization() {
        assert_eq!(serde_json::to_string(&ConditionField::AppName).unwrap(), r#""app_name""#);
    }

    #[test]
    fn test_operator_serialization() {
        assert_eq!(serde_json::to_string(&Operator::Equals).unwrap(), r#""equals""#);
        assert_eq!(serde_json::to_string(&Operator::SettingIsTrue).unwrap(), r#""setting_is_true""#);
    }

    #[test]
    fn test_rule_condition_value_serialization_deserialization() {
        let s_val = RuleConditionValue::String("hello".to_string());
        assert_eq!(serde_json::to_string(&s_val).unwrap(), r#""hello""#);
        assert_eq!(serde_json::from_str::<RuleConditionValue>(r#""hello""#).unwrap(), s_val);

        let i_val = RuleConditionValue::Integer(123);
        assert_eq!(serde_json::to_string(&i_val).unwrap(), r#"123"#);
        assert_eq!(serde_json::from_str::<RuleConditionValue>(r#"123"#).unwrap(), i_val);

        let u_val = RuleConditionValue::Urgency(UrgencyLevel::Critical);
        assert_eq!(serde_json::to_string(&u_val).unwrap(), r#""critical""#); // untagged means it serializes as inner type
        assert_eq!(serde_json::from_str::<RuleConditionValue>(r#""critical""#).unwrap(), u_val);

        let b_val = RuleConditionValue::Boolean(true);
        assert_eq!(serde_json::to_string(&b_val).unwrap(), r#"true"#);
        assert_eq!(serde_json::from_str::<RuleConditionValue>(r#"true"#).unwrap(), b_val);
    }


    #[test]
    fn test_simple_rule_condition_serialization() {
        let condition = SimpleRuleCondition {
            field: ConditionField::AppName,
            operator: Operator::Equals,
            value: RuleConditionValue::String("Firefox".to_string()),
        };
        let json = serde_json::to_string(&condition).unwrap();
        let expected = r#"{"field":"app_name","operator":"equals","value":"Firefox"}"#;
        assert_eq!(json, expected);

        let deserialized: SimpleRuleCondition = serde_json::from_str(expected).unwrap();
        assert_eq!(deserialized, condition);
    }

    #[test]
    fn test_rule_condition_complex_serialization() {
        let condition = RuleCondition::And(vec![
            RuleCondition::Simple(SimpleRuleCondition {
                field: ConditionField::AppName,
                operator: Operator::Equals,
                value: RuleConditionValue::String("Firefox".to_string()),
            }),
            RuleCondition::Not(Box::new(RuleCondition::Simple(SimpleRuleCondition {
                field: ConditionField::Urgency,
                operator: Operator::IsLessThan,
                value: RuleConditionValue::Urgency(UrgencyLevel::Normal),
            }))),
        ]);

        let json = serde_json::to_string(&condition).unwrap();
        // println!("{}", json); // Debugging
        let expected = r#"[{"field":"app_name","operator":"equals","value":"Firefox"},{"Not":{"field":"urgency","operator":"is_less_than","value":"normal"}}]"#;
        // Due to `untagged` enum, Vec is serialized directly for `And` and `Or`, and for `Not` the inner content is serialized.
        // This is a bit tricky for direct string comparison, but logically correct.
        // A more robust test would be to deserialize and compare the struct.
        let deserialized: RuleCondition = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized, condition);
    }

    #[test]
    fn test_rule_action_serialization() {
        let action = RuleAction::Suppress;
        assert_eq!(serde_json::to_string(&action).unwrap(), r#""suppress""#);

        let play_sound_action = RuleAction::PlaySound("/path/to/sound.ogg".to_string());
        assert_eq!(serde_json::to_string(&play_sound_action).unwrap(), r#"{"play_sound":"/path/to/sound.ogg"}"#);

        let set_urgency_action = RuleAction::SetUrgency(UrgencyLevel::Critical);
        assert_eq!(serde_json::to_string(&set_urgency_action).unwrap(), r#"{"set_urgency":"critical"}"#);

        let run_command_action = RuleAction::RunCommand("notify-send 'Hello'".to_string());
        assert_eq!(serde_json::to_string(&run_command_action).unwrap(), r#"{"run_command":"notify-send 'Hello'"}"#);

        let log_action = RuleAction::Log("Rule matched!".to_string());
        assert_eq!(serde_json::to_string(&log_action).unwrap(), r#"{"log":"Rule matched!"}"#);

        let deserialized_sound: RuleAction = serde_json::from_str(r#"{"play_sound":"/path/to/sound.ogg"}"#).unwrap();
        assert_eq!(deserialized_sound, play_sound_action);
    }

    #[test]
    fn test_notification_rule_default() {
        let rule = NotificationRule::default();
        assert_eq!(rule.name, "New Rule");
        assert!(rule.enabled);
        assert_eq!(rule.priority, 100);
        assert!(!rule.id.is_nil());
        assert!(matches!(rule.conditions, RuleCondition::Simple(_)));
        assert!(rule.actions.is_empty());
    }

    #[test]
    fn test_notification_rule_serialization_deserialization() {
        let rule = NotificationRule {
            id: Uuid::new_v4(),
            name: "Block Firefox Low Urgency".to_string(),
            enabled: true,
            priority: 50,
            conditions: RuleCondition::And(vec![
                RuleCondition::Simple(SimpleRuleCondition {
                    field: ConditionField::AppName,
                    operator: Operator::Equals,
                    value: RuleConditionValue::String("Firefox".to_string()),
                }),
                RuleCondition::Simple(SimpleRuleCondition {
                    field: ConditionField::Urgency,
                    operator: Operator::Equals,
                    value: RuleConditionValue::Urgency(UrgencyLevel::Low),
                }),
            ]),
            actions: vec![RuleAction::Suppress, RuleAction::Log("Firefox low urgency suppressed".to_string())],
        };

        let serialized = serde_json::to_string(&rule).unwrap();
        let deserialized: NotificationRule = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, rule);
    }

    #[test]
    fn test_notification_rule_set_serialization_deserialization() {
        let rule1 = NotificationRule::default();
        let rule2 = NotificationRule {
            id: Uuid::new_v4(),
            name: "Important Emails".to_string(),
            enabled: true,
            priority: 10,
            conditions: RuleCondition::Simple(SimpleRuleCondition {
                field: ConditionField::Category,
                operator: Operator::Equals,
                value: RuleConditionValue::String("email".to_string()),
            }),
            actions: vec![RuleAction::SetUrgency(UrgencyLevel::Critical), RuleAction::Highlight],
        };

        let rule_set = NotificationRuleSet {
            rules: vec![rule1, rule2],
        };

        let serialized = serde_json::to_string(&rule_set).unwrap();
        let deserialized: NotificationRuleSet = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, rule_set);
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (19 von 100) konzentriert sich auf die Fehlerbehandlung innerhalb des `notifications`-Moduls der Domänenschicht (`novade-domain`). Die Datei `errors.rs` definiert die spezifischen Fehlertypen, die im Zusammenhang mit der Verarbeitung und Verwaltung von Benachrichtigungen auftreten können. Eine präzise Fehlerdefinition ist essenziell für robuste Anwendungen und erleichtert die Fehlerbehandlung in höheren Schichten.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 19/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.17.2. `novade-domain/src/notifications/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notifications/errors.rs`
  * **Verantwortlichkeit:** Definiert eine umfassende `NotificationError`-Enum, die alle möglichen Fehlerzustände abbildet, die innerhalb des Benachrichtigungssystems auftreten können. Dies umfasst Fehler bei der Regelverarbeitung, Persistenz, ungültige Daten und mehr. Die Nutzung von `thiserror` und `anyhow` (oder ähnlichen Ansätzen für Kontext) stellt sicher, dass Fehler mit aussagekräftigen Nachrichten und Ursprungsinformationen (Source-Kette) versehen sind.
  * **Kern-Aufgaben (Tasks):**
    1.  **`NotificationError` Enum definieren:**
          * Nutze `thiserror` für einfache Fehlerdefinition und automatische `std::error::Error`, `Display` und `From` Implementierungen.
          * Varianten:
              * `RuleEvaluationError(String)`: Fehler während der Auswertung einer Regelbedingung (z.B. ungültiger Regex, Typ-Mismatch).
              * `ActionExecutionError { action: String, source: Box<dyn std::error::Error + Send + Sync> }`: Fehler beim Ausführen einer Regelaktion (z.B. Sounddatei nicht gefunden, Befehl schlägt fehl). Sollte den spezifischen Fehler der Aktion und den `source` des Fehlers enthalten.
              * `PersistenceError(#[from] ConfigError)`: Fehler beim Laden oder Speichern von Benachrichtigungsregeln (delegiert an `novade_core::error::ConfigError`).
              * `InvalidRuleConfiguration(String)`: Eine Regel ist semantisch ungültig konfiguriert (z.B. `SettingIsTrue` ohne booleschen Wert).
              * `RegexError(#[from] regex::Error)`: Fehler beim Kompilieren oder Ausführen eines regulären Ausdrucks.
              * `Internal(String)`: Allgemeine interne Fehler, die nicht spezifischer kategorisiert werden können. (Sollte sparsam verwendet werden).
              * `UuidGenerationError(#[from] uuid::Error)`: Fehler bei der Generierung von UUIDs.
          * Implementiere `Debug`, `Display` und `std::error::Error`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notifications/errors.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade_core::error::ConfigError`.
      * **Extern:** `thiserror`, `regex` (für `regex::Error`), `uuid` (für `uuid::Error`). `std::error::Error` für die Source-Kette.
  * **Kommunikationsmuster:** `NotificationError` wird als Rückgabewert für `Result` in Funktionen innerhalb des `notifications`-Moduls verwendet und kann an aufrufende Schichten (z.B. `novade-system`) propagiert werden.
  * **Erwartete Ergebnisse/Outputs:**
      * Eine klare und konsistente Fehlerhierarchie für das Benachrichtigungssystem.
      * Leicht zu lesende und zu debuggende Fehlermeldungen.
      * Robuste Fehlerweiterleitung durch die Anwendungsschichten.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Teste die Erstellung jeder `NotificationError`-Variante.
          * Teste die `Display`-Implementierung, um sicherzustellen, dass die Fehlermeldungen korrekt formatiert sind.
          * Teste die `From`-Implementierungen für `ConfigError`, `regex::Error` und `uuid::Error`, um sicherzustellen, dass die Fehlerkonvertierung korrekt funktioniert und die Source-Kette erhalten bleibt.
          * Teste, ob `ActionExecutionError` den Quellfehler korrekt kapselt und dessen `Display` ebenfalls korrekt ist.

#### Funktionsspezifikation: `novade_domain::notifications::errors`

```rust
// novade-domain/src/notifications/errors.rs

//! Definiert die spezifischen Fehlertypen für das Benachrichtigungsmodul.

use thiserror::Error;
use std::fmt::{self, Display}; // Für Debug und Display Trait
use std::error::Error as StdError; // Für die Source-Kette

use novade_core::error::ConfigError; // Abhängigkeit zur Core-Schicht

/// Repräsentiert alle möglichen Fehler, die im Benachrichtigungssystem auftreten können.
#[derive(Debug, Error)]
pub enum NotificationError {
    /// Fehler während der Auswertung einer Regelbedingung.
    #[error("Failed to evaluate rule condition: {0}")]
    RuleEvaluationError(String),

    /// Fehler beim Ausführen einer Regelaktion.
    /// `action` beschreibt die fehlgeschlagene Aktion (z.B. "PlaySound").
    /// `source` ist der ursprüngliche Fehler, der die Aktion fehlschlagen ließ.
    #[error("Failed to execute action '{action}': {source}")]
    ActionExecutionError {
        action: String,
        #[source] // Markiert `source` als die Quelle des Fehlers für `std::error::Error`
        source: Box<dyn StdError + Send + Sync>,
    },

    /// Fehler beim Laden oder Speichern von Benachrichtigungsregeln (Delegiert an ConfigError).
    #[error("Notification rules persistence error: {0}")]
    PersistenceError(#[from] ConfigError),

    /// Eine Benachrichtigungsregel ist semantisch ungültig konfiguriert.
    #[error("Invalid notification rule configuration: {0}")]
    InvalidRuleConfiguration(String),

    /// Fehler beim Kompilieren oder Ausführen eines regulären Ausdrucks.
    #[error("Regex error: {0}")]
    RegexError(#[from] regex::Error),

    /// Fehler bei der Generierung von UUIDs.
    #[error("UUID generation error: {0}")]
    UuidGenerationError(#[from] uuid::Error),

    /// Allgemeine interne Fehler, die nicht spezifischer kategorisiert werden können.
    /// Sollte sparsam verwendet werden und eine detaillierte Fehlermeldung enthalten.
    #[error("Internal notification error: {0}")]
    Internal(String),
}

// Manuelle Implementierung von `Display` für `ActionExecutionError` ist hier nicht nötig,
// da `thiserror` dies über das `#[error(...)]` Attribut für die gesamte Enum regelt,
// inklusive der eingebetteten `source` mit ihrem eigenen `Display`.

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::{self, ErrorKind};
    use uuid::Uuid;

    #[test]
    fn test_rule_evaluation_error() {
        let error = NotificationError::RuleEvaluationError("Invalid type comparison".to_string());
        assert_eq!(error.to_string(), "Failed to evaluate rule condition: Invalid type comparison");
        assert!(error.source().is_none());
    }

    #[test]
    fn test_action_execution_error() {
        let io_err = io::Error::new(ErrorKind::NotFound, "Sound file not found");
        let error = NotificationError::ActionExecutionError {
            action: "PlaySound".to_string(),
            source: Box::new(io_err),
        };
        assert_eq!(error.to_string(), "Failed to execute action 'PlaySound': Sound file not found");
        assert!(error.source().is_some());
        assert_eq!(error.source().unwrap().to_string(), "Sound file not found");
    }

    #[test]
    fn test_persistence_error_from_config_error() {
        let config_err = ConfigError::IoError(io::Error::new(ErrorKind::PermissionDenied, "No write permission").into());
        let error: NotificationError = config_err.into(); // Testet `#[from]`
        assert_eq!(error.to_string(), "Notification rules persistence error: I/O error: No write permission");
        assert!(error.source().is_some());
        assert_eq!(error.source().unwrap().to_string(), "I/O error: No write permission");
        assert!(matches!(error, NotificationError::PersistenceError(_)));
    }

    #[test]
    fn test_invalid_rule_configuration_error() {
        let error = NotificationError::InvalidRuleConfiguration("Missing required field".to_string());
        assert_eq!(error.to_string(), "Invalid notification rule configuration: Missing required field");
        assert!(error.source().is_none());
    }

    #[test]
    fn test_regex_error_from_regex_crate() {
        let regex_err = regex::Error::from_str("invalid [regex");
        let error: NotificationError = regex_err.into(); // Testet `#[from]`
        assert!(error.to_string().starts_with("Regex error:")); // Error message from regex crate can be long
        assert!(error.source().is_some());
        assert!(matches!(error, NotificationError::RegexError(_)));
    }

    #[test]
    fn test_uuid_generation_error_from_uuid_crate() {
        // Unfortunately, `uuid::Error` doesn't have a public constructor for testing.
        // We'll simulate by creating a context where it *might* occur if not a real error.
        // For a real test, one might need to use a crate like `test-case` or similar
        // to mock uuid generation, or rely on the `From` trait working as expected.
        // A direct test of `Uuid::new_v4()` will always succeed, so the error case is hard to trigger directly.
        // This test primarily checks the `From` implementation.
        let uuid_err: uuid::Error = "some error".parse::<Uuid>().unwrap_err();
        let error: NotificationError = uuid_err.into();
        assert!(error.to_string().starts_with("UUID generation error:"));
        assert!(error.source().is_some());
        assert!(matches!(error, NotificationError::UuidGenerationError(_)));
    }

    #[test]
    fn test_internal_error() {
        let error = NotificationError::Internal("Unexpected state reached".to_string());
        assert_eq!(error.to_string(), "Internal notification error: Unexpected state reached");
        assert!(error.source().is_none());
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (20 von 100) widmet sich der Definition der Persistenzschnittstelle für Benachrichtigungsregeln innerhalb des `notifications`-Moduls der Domänenschicht (`novade-domain`). Diese Schnittstelle ist entscheidend, um die Abhängigkeit von einer spezifischen Speicherimplementierung zu entkoppeln und Flexibilität für zukünftige Änderungen zu gewährleisten.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 20/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.17.3. `novade-domain/src/notifications/persistence_iface.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notifications/persistence_iface.rs`
  * **Verantwortlichkeit:** Definiert den `NotificationRulesProvider`-Trait. Dieser asynchrone Trait spezifiziert das Vertragsmodell für alle Implementierungen, die Benachrichtigungsregeln laden und speichern können. Durch die Abstraktion der Persistenzlogik ermöglicht dieser Trait, verschiedene Speicherlösungen (z.B. Dateisystem, Datenbank, Cloud-Speicher) zu verwenden, ohne die Kernlogik des `notifications`-Moduls ändern zu müssen.
  * **Kern-Aufgaben (Tasks):**
    1.  **`NotificationRulesProvider` Trait definieren:**
          * Nutze `async_trait` für asynchrone Methoden.
          * Methoden:
              * `load_rules(&self) -> Result<NotificationRuleSet, NotificationError>`:
                  * Asynchrone Methode zum Laden der gesamten Sammlung von Benachrichtigungsregeln.
                  * Gibt ein `NotificationRuleSet`-Objekt zurück, wenn erfolgreich.
                  * Gibt `NotificationError::PersistenceError` zurück, wenn ein Fehler auftritt.
                  * **Fehlerbehandlung:** Wenn die Regeln nicht gefunden werden können (z.B. Datei existiert nicht), sollte dies als `Ok(NotificationRuleSet::default())` behandelt werden, da es ein legitimer Startzustand sein kann. Andere I/O-Fehler oder Deserialisierungsfehler sollten als `Err(NotificationError::PersistenceError)` zurückgegeben werden.
              * `save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationError>`:
                  * Asynchrone Methode zum Speichern der bereitgestellten `NotificationRuleSet`.
                  * Nimmt eine Referenz auf das zu speichernde `NotificationRuleSet`.
                  * Gibt `Ok(())` zurück, wenn erfolgreich.
                  * Gibt `NotificationError::PersistenceError` zurück, wenn ein Fehler auftritt.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notifications/persistence_iface.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notifications::data_types::NotificationRuleSet`, `crate::notifications::errors::NotificationError`.
      * **Extern:** `async_trait`.
  * **Kommunikationsmuster:** Der Trait wird von konkreten Persistenzimplementierungen implementiert (z.B. `FilesystemNotificationRulesProvider`) und vom `NotificationService` verwendet, um mit der Persistenzschicht zu interagieren.
  * **Erwartete Ergebnisse/Outputs:**
      * Eine klar definierte und entkoppelte Schnittstelle für die Persistenz von Benachrichtigungsregeln.
      * Erhöhte Testbarkeit des `NotificationService` durch einfaches Mocking dieser Schnittstelle.
      * Flexibilität für zukünftige Änderungen an der Speicherstrategie.
  * **Teststrategie (Modul-spezifisch):**
      * Da dies ein Trait ist, sind hier keine direkten Unit-Tests erforderlich. Die Tests erfolgen auf den konkreten Implementierungen dieses Traits (z.B. `FilesystemNotificationRulesProvider`) und durch Integrationstests im `NotificationService`, wo Mocks dieses Traits verwendet werden.

#### Funktionsspezifikation: `novade_domain::notifications::persistence_iface`

```rust
// novade-domain/src/notifications/persistence_iface.rs

//! Definiert den Trait für die Persistenz von Benachrichtigungsregeln.
//!
//! Dieser Trait abstrahiert die Speicherung und das Laden von Benachrichtigungsregeln,
//! wodurch die Implementierung der Persistenz von der Kernlogik entkoppelt wird.

use async_trait::async_trait;

use crate::notifications::data_types::NotificationRuleSet;
use crate::notifications::errors::NotificationError;

/// Trait für Provider, die Benachrichtigungsregeln persistieren können.
///
/// Implementierungen dieses Traits sind verantwortlich für die konkrete Logik des
/// Ladens und Speicherns von `NotificationRuleSet`-Objekten in einem persistenten Speicher.
#[async_trait]
pub trait NotificationRulesProvider: Send + Sync {
    /// Lädt die gesamten Benachrichtigungsregeln aus dem persistenten Speicher.
    ///
    /// # Returns
    /// Ein `Result`, das bei Erfolg ein `NotificationRuleSet`-Objekt enthält,
    /// oder einen `NotificationError` im Fehlerfall.
    ///
    /// # Fehlerbehandlung
    /// - Wenn die Regeln nicht gefunden werden können (z.B. Datei existiert nicht),
    ///   sollte die Implementierung `Ok(NotificationRuleSet::default())` zurückgeben.
    ///   Dies ermöglicht einen reibungslosen Start ohne vorhandene Regeln.
    /// - Andere I/O-Fehler oder Deserialisierungsfehler sollten als
    ///   `Err(NotificationError::PersistenceError(...))` zurückgegeben werden.
    async fn load_rules(&self) -> Result<NotificationRuleSet, NotificationError>;

    /// Speichert die bereitgestellten Benachrichtigungsregeln in den persistenten Speicher.
    ///
    /// # Arguments
    /// * `rules` - Eine Referenz auf das `NotificationRuleSet`-Objekt, das gespeichert werden soll.
    ///
    /// # Returns
    /// Ein `Result`, das bei Erfolg `Ok(())` enthält, oder einen `NotificationError`
    /// im Fehlerfall.
    async fn save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationError>;
}

// In diesem Modul sind keine `#[cfg(test)]` Blöcke oder Unit-Tests erforderlich,
// da es sich um eine reine Trait-Definition handelt. Die Implementierungen
// dieses Traits und die Verwendung im Service werden getestet.
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (21 von 100) implementiert die konkrete Dateisystem-basierte Persistenz für Benachrichtigungsregeln innerhalb des `notifications`-Moduls der Domänenschicht (`novade-domain`). Diese Datei ist eine konkrete Implementierung des zuvor definierten `NotificationRulesProvider`-Traits und nutzt den `ConfigServiceAsync` aus der `novade-core` Crate für die tatsächlichen I/O-Operationen.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 21/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.17.4. `novade-domain/src/notifications/persistence.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notifications/persistence.rs`
  * **Verantwortlichkeit:** Implementiert den `NotificationRulesProvider`-Trait unter Verwendung des `ConfigServiceAsync` aus der `novade-core` Crate. Diese Implementierung ist für das Laden und Speichern von `NotificationRuleSet`-Objekten als JSON-Dateien im XDG-Konfigurationsverzeichnis zuständig.
  * **Kern-Aufgaben (Tasks):**
    1.  **`FilesystemNotificationRulesProvider` Struct definieren:**
          * Felder:
              * `config_service: Arc<ConfigServiceAsync>`: Ein `Arc`-Pointer zum `ConfigServiceAsync` aus der `novade-core`-Schicht, der die tatsächlichen Dateisystemoperationen (Lesen/Schreiben) abwickelt und sich um den richtigen Pfad kümmert.
              * `file_name: String`: Der Dateiname für die Benachrichtigungsregeln (z.B. "notifications.json").
    2.  **Konstruktor `new()` implementieren:**
          * Nimmt `config_service: Arc<ConfigServiceAsync>` als Argument.
          * Nimmt `file_name: impl Into<String>` als Argument.
          * Initialisiert das Struct.
    3.  **Implementierung des `NotificationRulesProvider` Trait für `FilesystemNotificationRulesProvider`:**
          * **Methode `load_rules(&self) -> Result<NotificationRuleSet, NotificationError>`:**
              * Ruft `self.config_service.load_config_file_async::<NotificationRuleSet>(&self.file_name).await` auf.
              * **Fehlerbehandlung:**
                  * Wenn `load_config_file_async` `ConfigError::NotFound` zurückgibt, sollte `Ok(NotificationRuleSet::default())` zurückgegeben werden. Dies ist der erwartete Fall, wenn die Regeln noch nicht gespeichert wurden.
                  * Wenn `load_config_file_async` `ConfigError::SerializationError` (oder andere Deserialisierungsfehler) zurückgibt, sollte `NotificationError::PersistenceError(err.into())` zurückgegeben werden. Dies deutet auf eine korrupte Datei hin.
                  * Alle anderen `ConfigError`-Varianten sollten ebenfalls in `NotificationError::PersistenceError(err.into())` umgewandelt und propagiert werden.
                  * Logging: Verwende `tracing` für `info!` bei Erfolg, `warn!` bei `NotFound` und `error!` bei anderen Fehlern.
          * **Methode `save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationError>`:**
              * Ruft `self.config_service.save_config_file_async(&self.file_name, rules).await` auf.
              * **Fehlerbehandlung:**
                  * Alle `ConfigError`-Varianten, die von `save_config_file_async` zurückgegeben werden, sollten in `NotificationError::PersistenceError(err.into())` umgewandelt und propagiert werden.
                  * Logging: Verwende `tracing` für `info!` bei Erfolg und `error!` bei Fehlern.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notifications/persistence.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notifications::data_types::NotificationRuleSet`, `crate::notifications::errors::NotificationError`, `crate::notifications::persistence_iface::NotificationRulesProvider`.
      * **Extern:** `tokio`, `std::sync::Arc`, `async_trait`, `tracing`, `novade_core::config::ConfigServiceAsync`, `novade_core::error::ConfigError`.
  * **Kommunikationsmuster:** Interagiert direkt mit dem `ConfigServiceAsync` für Dateisystem-I/O. Bietet eine Implementierung für den `NotificationRulesProvider`-Trait.
  * **Erwartete Ergebnisse/Outputs:**
      * Eine funktionierende Persistenzschicht für Benachrichtigungsregeln, die JSON-Dateien nutzt.
      * Robuste Fehlerbehandlung, insbesondere für nicht existierende oder korrupte Konfigurationsdateien.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests (mit Mocking von `ConfigServiceAsync`):**
          * Test der `new()`-Funktion.
          * Test `load_rules`:
              * Erfolgreiches Laden einer gültigen `NotificationRuleSet`.
              * Verhalten bei `ConfigError::NotFound` (sollte `Ok(Default::default())` zurückgeben).
              * Verhalten bei `ConfigError::SerializationError` (ungültiges JSON, sollte `Err(NotificationError::PersistenceError)` zurückgeben).
              * Verhalten bei anderen `ConfigError`s (z.B. I/O-Fehler, sollte `Err(NotificationError::PersistenceError)` zurückgeben).
          * Test `save_rules`:
              * Erfolgreiches Speichern eines `NotificationRuleSet`.
              * Verhalten bei `ConfigError` während des Speicherns (sollte `Err(NotificationError::PersistenceError)` zurückgeben).
          * **Integration Tests (optional, aber empfohlen für `ConfigServiceAsync` Pfade):**
              * Könnte eine temporäre Datei erstellen, um den vollständigen Lade-/Speicherzyklus zu testen. Diese Tests wären jedoch eher Tests für `ConfigServiceAsync` selbst und seine korrekte Verwendung durch `FilesystemNotificationRulesProvider`. Der Fokus hier liegt auf Mocking.

#### Funktionsspezifikation: `novade_domain::notifications::persistence`

```rust
// novade-domain/src/notifications/persistence.rs

//! Implementiert den `NotificationRulesProvider`-Trait für die Dateisystem-Persistenz
//! von Benachrichtigungsregeln.

use async_trait::async_trait;
use std::sync::Arc;
use tracing::{error, info, warn};

use novade_core::config::ConfigServiceAsync;
use novade_core::error::ConfigError;

use crate::notifications::data_types::NotificationRuleSet;
use crate::notifications::errors::NotificationError;
use crate::notifications::persistence_iface::NotificationRulesProvider;

/// Dateiname für die Benachrichtigungsregeln innerhalb des Konfigurationsverzeichnisses.
const NOTIFICATION_RULES_FILE_NAME: &str = "notifications_rules.json";

/// Eine Implementierung von `NotificationRulesProvider`, die das Dateisystem verwendet.
pub struct FilesystemNotificationRulesProvider {
    config_service: Arc<ConfigServiceAsync>,
    file_name: String,
}

impl FilesystemNotificationRulesProvider {
    /// Erstellt eine neue Instanz von `FilesystemNotificationRulesProvider`.
    ///
    /// # Arguments
    /// * `config_service` - Ein `Arc`-Pointer auf den `ConfigServiceAsync`,
    ///   der für die zugrunde liegenden Dateisystem-Operationen verwendet wird.
    /// * `file_name` - Der Dateiname, unter dem die Benachrichtigungsregeln
    ///   gespeichert und geladen werden sollen (z.B. "notifications_rules.json").
    ///
    /// # Returns
    /// Eine neue `FilesystemNotificationRulesProvider`-Instanz.
    pub fn new(config_service: Arc<ConfigServiceAsync>, file_name: impl Into<String>) -> Self {
        Self {
            config_service,
            file_name: file_name.into(),
        }
    }
}

#[async_trait]
impl NotificationRulesProvider for FilesystemNotificationRulesProvider {
    /// Lädt die Benachrichtigungsregeln aus der Konfigurationsdatei.
    ///
    /// Wenn die Datei nicht existiert, wird ein leeres `NotificationRuleSet` zurückgegeben.
    /// Andere Fehler (z.B. Deserialisierung, I/O-Fehler) führen zu einem `Err(NotificationError)`.
    async fn load_rules(&self) -> Result<NotificationRuleSet, NotificationError> {
        info!("Attempting to load notification rules from '{}'.", self.file_name);
        match self.config_service.load_config_file_async::<NotificationRuleSet>(&self.file_name).await {
            Ok(rules) => {
                info!("Notification rules loaded successfully.");
                Ok(rules)
            }
            Err(ConfigError::NotFound(_)) => {
                warn!("Notification rules file '{}' not found. Returning default ruleset.", self.file_name);
                // Wenn die Datei nicht existiert, ist das kein kritischer Fehler, sondern der Initialzustand.
                Ok(NotificationRuleSet::default())
            }
            Err(e) => {
                error!("Failed to load notification rules from '{}': {:?}", self.file_name, e);
                // Konvertiere alle anderen ConfigError-Varianten in NotificationError::PersistenceError.
                Err(NotificationError::PersistenceError(e))
            }
        }
    }

    /// Speichert die bereitgestellten Benachrichtigungsregeln in die Konfigurationsdatei.
    ///
    /// # Arguments
    /// * `rules` - Eine Referenz auf das zu speichernde `NotificationRuleSet`.
    ///
    /// # Errors
    /// Gibt einen `NotificationError::PersistenceError` zurück, wenn das Speichern fehlschlägt.
    async fn save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationError> {
        info!("Attempting to save notification rules to '{}'.", self.file_name);
        match self.config_service.save_config_file_async(&self.file_name, rules).await {
            Ok(()) => {
                info!("Notification rules saved successfully.");
                Ok(())
            }
            Err(e) => {
                error!("Failed to save notification rules to '{}': {:?}", self.file_name, e);
                // Konvertiere alle ConfigError-Varianten in NotificationError::PersistenceError.
                Err(NotificationError::PersistenceError(e))
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use mockall::{automock, predicate::*};
    use novade_core::error::{ConfigError, CoreError};
    use std::io::{self, ErrorKind};
    use std::path::PathBuf;

    // Mock des ConfigServiceAsync
    #[automock]
    #[async_trait]
    impl ConfigServiceAsync for ConfigServiceAsync {
        async fn load_config_file_async<T: serde::de::DeserializeOwned + Send + 'static>(
            &self,
            _file_name: &str,
        ) -> Result<T, ConfigError> {
            unimplemented!()
        }
        async fn save_config_file_async<T: serde::Serialize + Send + Sync + 'static>(
            &self,
            _file_name: &str,
            _data: &T,
        ) -> Result<(), ConfigError> {
            unimplemented!()
        }
        fn get_config_dir(&self) -> PathBuf {
            PathBuf::from("/tmp/test_config")
        }
    }

    #[tokio::test]
    async fn new_provider_initializes_correctly() {
        let mock_config_service = Arc::new(MockConfigServiceAsync::new());
        let provider = FilesystemNotificationRulesProvider::new(mock_config_service, "test_rules.json");
        assert_eq!(provider.file_name, "test_rules.json");
    }

    #[tokio::test]
    async fn load_rules_successful() {
        let mut mock_config_service = MockConfigServiceAsync::new();
        let test_rules = NotificationRuleSet {
            rules: vec![NotificationRule::default()],
        };
        let test_rules_clone = test_rules.clone(); // Clone for the closure
        mock_config_service
            .expect_load_config_file_async::<NotificationRuleSet>()
            .times(1)
            .returning(move |_| Ok(test_rules_clone.clone()));

        let mock_config_service_arc = Arc::new(mock_config_service);
        let provider = FilesystemNotificationRulesProvider::new(mock_config_service_arc, NOTIFICATION_RULES_FILE_NAME);

        let result = provider.load_rules().await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap().rules.len(), 1);
    }

    #[tokio::test]
    async fn load_rules_handles_not_found_error() {
        let mut mock_config_service = MockConfigServiceAsync::new();
        mock_config_service
            .expect_load_config_file_async::<NotificationRuleSet>()
            .times(1)
            .returning(|_| Err(ConfigError::NotFound(PathBuf::from("/nonexistent/file.json"))));

        let mock_config_service_arc = Arc::new(mock_config_service);
        let provider = FilesystemNotificationRulesProvider::new(mock_config_service_arc, NOTIFICATION_RULES_FILE_NAME);

        let result = provider.load_rules().await;
        assert!(result.is_ok());
        // Should return default ruleset on NotFound
        assert_eq!(result.unwrap(), NotificationRuleSet::default());
    }

    #[tokio::test]
    async fn load_rules_handles_serialization_error() {
        let mut mock_config_service = MockConfigServiceAsync::new();
        mock_config_service
            .expect_load_config_file_async::<NotificationRuleSet>()
            .times(1)
            .returning(|_| Err(ConfigError::SerializationError(CoreError::Internal("Bad JSON".to_string()))));

        let mock_config_service_arc = Arc::new(mock_config_service);
        let provider = FilesystemNotificationRulesProvider::new(mock_config_service_arc, NOTIFICATION_RULES_FILE_NAME);

        let result = provider.load_rules().await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), NotificationError::PersistenceError(ConfigError::SerializationError(_))));
    }

    #[tokio::test]
    async fn load_rules_handles_io_error() {
        let mut mock_config_service = MockConfigServiceAsync::new();
        mock_config_service
            .expect_load_config_file_async::<NotificationRuleSet>()
            .times(1)
            .returning(|_| Err(ConfigError::IoError(io::Error::new(ErrorKind::PermissionDenied, "No access").into())));

        let mock_config_service_arc = Arc::new(mock_config_service);
        let provider = FilesystemNotificationRulesProvider::new(mock_config_service_arc, NOTIFICATION_RULES_FILE_NAME);

        let result = provider.load_rules().await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), NotificationError::PersistenceError(ConfigError::IoError(_))));
    }

    #[tokio::test]
    async fn save_rules_successful() {
        let mut mock_config_service = MockConfigServiceAsync::new();
        let test_rules = NotificationRuleSet {
            rules: vec![NotificationRule::default()],
        };
        mock_config_service
            .expect_save_config_file_async::<NotificationRuleSet>()
            .with(eq(NOTIFICATION_RULES_FILE_NAME), eq(test_rules.clone()))
            .times(1)
            .returning(|_, _| Ok(()));

        let mock_config_service_arc = Arc::new(mock_config_service);
        let provider = FilesystemNotificationRulesProvider::new(mock_config_service_arc, NOTIFICATION_RULES_FILE_NAME);

        let result = provider.save_rules(&test_rules).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn save_rules_handles_serialization_error() {
        let mut mock_config_service = MockConfigServiceAsync::new();
        let test_rules = NotificationRuleSet {
            rules: vec![NotificationRule::default()],
        };
        mock_config_service
            .expect_save_config_file_async::<NotificationRuleSet>()
            .times(1)
            .returning(|_, _| Err(ConfigError::SerializationError(CoreError::Internal("Cannot serialize".to_string()))));

        let mock_config_service_arc = Arc::new(mock_config_service);
        let provider = FilesystemNotificationRulesProvider::new(mock_config_service_arc, NOTIFICATION_RULES_FILE_NAME);

        let result = provider.save_rules(&test_rules).await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), NotificationError::PersistenceError(ConfigError::SerializationError(_))));
    }

    #[tokio::test]
    async fn save_rules_handles_io_error() {
        let mut mock_config_service = MockConfigServiceAsync::new();
        let test_rules = NotificationRuleSet {
            rules: vec![NotificationRule::default()],
        };
        mock_config_service
            .expect_save_config_file_async::<NotificationRuleSet>()
            .times(1)
            .returning(|_, _| Err(ConfigError::IoError(io::Error::new(ErrorKind::PermissionDenied, "No write access").into())));

        let mock_config_service_arc = Arc::new(mock_config_service);
        let provider = FilesystemNotificationRulesProvider::new(mock_config_service_arc, NOTIFICATION_RULES_FILE_NAME);

        let result = provider.save_rules(&test_rules).await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), NotificationError::PersistenceError(ConfigError::IoError(_))));
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (22 von 100) konzentriert sich auf die zentrale Engine zur Verarbeitung von Benachrichtigungsregeln innerhalb des `notifications`-Moduls der Domänenschicht (`novade-domain`). Die Datei `engine.rs` wird die Kernlogik kapseln, die entscheidet, wie eine eingehende Benachrichtigung basierend auf den definierten Regeln behandelt werden soll.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 22/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.17.5. `novade-domain/src/notifications/engine.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notifications/engine.rs`
  * **Verantwortlichkeit:** Implementiert die `NotificationRulesEngine`, die für die Auswertung von Benachrichtigungsregeln und die Anwendung der entsprechenden Aktionen auf eingehende Benachrichtigungen zuständig ist. Dies ist die primäre Logikschicht für die Filterung und Modifikation von Benachrichtigungen.
  * **Kern-Aufgaben (Tasks):**
    1.  **`RuleProcessingResult` Enum definieren:**
          * Repräsentiert das Ergebnis der Regelverarbeitung für eine einzelne Benachrichtigung.
          * Varianten:
              * `Processed(Notification)`: Die Benachrichtigung wurde verarbeitet und möglicherweise modifiziert. Sie sollte weitergeleitet werden.
              * `Suppressed`: Die Benachrichtigung wurde durch eine Regel unterdrückt und sollte nicht weitergeleitet werden.
          * Ableitungen: `Debug`, `Clone`, `PartialEq`.
    2.  **`NotificationRulesEngine` Trait definieren:**
          * Definiert die Schnittstelle für Benachrichtigungsregel-Engines.
          * Methoden:
              * `process_notification(&self, notification: Notification, global_settings: &DesktopSettings) -> Result<RuleProcessingResult, NotificationError>`:
                  * Asynchrone Methode, die eine `Notification` entgegennimmt und basierend auf den geladenen Regeln verarbeitet.
                  * Benötigt Zugriff auf `DesktopSettings` für den `SettingIsTrue`-Operator.
                  * Gibt `RuleProcessingResult` oder `NotificationError` zurück.
              * `get_rules(&self) -> NotificationRuleSet`: Gibt eine Kopie des aktuellen Regelsatzes zurück.
              * `update_rules(&self, rules: NotificationRuleSet) -> Result<(), NotificationError>`: Aktualisiert den internen Regelsatz.
    3.  **`DefaultNotificationRulesEngine` Struct definieren:**
          * Implementiert den `NotificationRulesEngine`-Trait.
          * Felder:
              * `rules: Arc<RwLock<NotificationRuleSet>>`: Ein `Arc<RwLock>` zum Schutz des Regelsatzes, um gleichzeitiges Lesen und sicheres Schreiben zu ermöglichen.
    4.  **Konstruktor `new()` für `DefaultNotificationRulesEngine` implementieren:**
          * Nimmt ein initiales `NotificationRuleSet` entgegen.
          * Initialisiert das `rules` Feld.
    5.  **Implementierung von `NotificationRulesEngine` für `DefaultNotificationRulesEngine`:**
          * **Methode `process_notification(&self, mut notification: Notification, global_settings: &DesktopSettings) -> Result<RuleProcessingResult, NotificationError>`:**
              * Holt eine Read-Lock auf `self.rules`.
              * Sortiert die Regeln nach Priorität (`priority` aufsteigend, also niedriger Wert = höhere Priorität).
              * Iteriert durch die aktiven (`enabled`) Regeln.
              * Für jede Regel:
                  * Rufe eine private Hilfsfunktion `evaluate_condition(&self, condition: &RuleCondition, notification: &Notification, global_settings: &DesktopSettings) -> Result<bool, NotificationError>` auf, um die Bedingung zu prüfen.
                  * Wenn die Bedingung `true` ist:
                      * Iteriert durch die `actions` der Regel.
                      * Wendet jede Aktion auf die `notification` an. Verwende eine private Hilfsfunktion `apply_action(&mut notification: &mut Notification, action: &RuleAction) -> Result<(), NotificationError>`.
                      * Wenn eine `StopProcessingFurtherRules`-Aktion gefunden wird, beende die Verarbeitung und gib das Ergebnis zurück.
              * Nachdem alle Regeln verarbeitet wurden (oder `StopProcessingFurtherRules` aufgerufen wurde), gib `RuleProcessingResult::Processed(notification)` oder `RuleProcessingResult::Suppressed` zurück, basierend auf den angewendeten Aktionen.
          * **Methode `get_rules(&self) -> NotificationRuleSet`:**
              * Holt eine Read-Lock und klont den Regelsatz.
          * **Methode `update_rules(&self, rules: NotificationRuleSet) -> Result<(), NotificationError>`:**
              * Holt eine Write-Lock und ersetzt den Regelsatz.
              * Führt eine Validierung der eingehenden Regeln durch (z.B. Regex-Syntax, wenn `MatchesRegex` verwendet wird). Bei Invalidität `NotificationError::InvalidRuleConfiguration` zurückgeben.
    6.  **Private Hilfsfunktion `evaluate_condition(&self, condition: &RuleCondition, notification: &Notification, global_settings: &DesktopSettings) -> Result<bool, NotificationError>` implementieren:**
          * Rekursive Funktion zur Auswertung von `RuleCondition` (Simple, And, Or, Not).
          * Für `SimpleRuleCondition`:
              * Extrahiert den Wert des `field` aus der `notification`.
              * Führt den Vergleich basierend auf dem `operator` und `value` durch.
              * **Spezifische Logik für Operatoren:**
                  * `Equals`, `Contains`, `StartsWith`, `EndsWith`: Für String-Felder.
                  * `MatchesRegex`: Nutzt `regex::Regex` zur Kompilierung (caching von Regex-Objekten erwägen für Performance) und Prüfung. Fehler beim Kompilieren sollten als `NotificationError::RegexError` propagiert werden.
                  * `IsGreaterThan`, `IsLessThan`: Für numerische Felder (`UrgencyLevel` kann zu `i32` konvertiert werden).
                  * `SettingIsTrue`: Greift auf `global_settings` zu. Der `value` muss `RuleConditionValue::Boolean(true)` sein. Prüft das entsprechende boolesche Feld in `DesktopSettings`. Falls das Feld nicht boolesch ist oder nicht gefunden wird, Fehler `InvalidRuleConfiguration` zurückgeben.
              * Typ-Mismatch zwischen `field` und `value` oder `operator` sollte zu `NotificationError::RuleEvaluationError` führen.
    7.  **Private Hilfsfunktion `apply_action(&mut notification: &mut Notification, action: &RuleAction) -> Result<(), NotificationError>` implementieren:**
          * Wendet die Aktion auf die `notification` an.
          * `Suppress`: Setzt ein internes Flag in der `notification` (z.B. `notification.suppressed = true`), das später von `process_notification` ausgewertet wird. Dies ist besser, als hier direkt `RuleProcessingResult::Suppressed` zurückzugeben, da weitere Aktionen in der Regel noch angewendet werden könnten (z.B. Loggen *vor* dem Unterdrücken).
          * `PlaySound(path)`: Startet asynchronen Sound-Playback (Benötigt Integration mit `novade_system::audio_management` oder einen einfachen Befehlsaufruf, vorzugsweise die dedizierte Integration). Fehler hier führen zu `ActionExecutionError`.
          * `SetUrgency(level)`: Ändert `notification.urgency`.
          * `Highlight`: Setzt ein internes Flag in der `notification` (z.B. `notification.highlighted = true`).
          * `RunCommand(cmd)`: Führt den Befehl asynchron aus. Vorsicht bei Sicherheit und Ressourcen. Fehler hier führen zu `ActionExecutionError`.
          * `StopProcessingFurtherRules`: Wird im aufrufenden `process_notification` behandelt, nicht hier.
          * `Log(msg)`: Verwendet `tracing::info!` oder `tracing::debug!` für die Nachricht.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notifications/engine.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notifications::data_types`, `crate::notifications::errors`, `novade_domain::settings::DesktopSettings`.
      * **Extern:** `tokio::sync::RwLock`, `std::sync::Arc`, `regex`, `tracing`.
  * **Kommunikationsmuster:**
      * Der `NotificationService` wird diese Engine instanziieren und die `process_notification`-Methode aufrufen.
      * Die Engine greift lesend auf `DesktopSettings` zu, die ihr vom `NotificationService` übergeben werden.
      * Die Engine verwendet `tracing` für internes Logging.
  * **Erwartete Ergebnisse/Outputs:**
      * Eine zentrale, effiziente und konfigurierbare Engine für die Benachrichtigungsverarbeitung.
      * Korrekte Anwendung von Regeln und Aktionen, inklusive komplexer logischer Verknüpfungen und spezialisierter Operatoren.
      * Robuste Fehlerbehandlung bei ungültigen Regeln oder fehlgeschlagenen Aktionen.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests für `evaluate_condition`:**
          * Test für jeden `ConditionField` und `Operator` Typ-Kombination.
          * Tests für `Equals`, `Contains`, `StartsWith`, `EndsWith` mit String-Feldern (Case-Sensitivity? -\> Annahme: Case-sensitive, explizite Option für Case-Insensitivity kann später hinzugefügt werden).
          * Tests für `MatchesRegex` mit gültigen und ungültigen Regex-Mustern.
          * Tests für `IsGreaterThan`, `IsLessThan` mit `UrgencyLevel` (Konvertierung zu i32 für Vergleich).
          * Tests für `SettingIsTrue` mit existierenden und nicht-existierenden `DesktopSettings`-Feldern, sowie korrekten/inkorrekten Werten.
          * Tests für `And`, `Or`, `Not` mit verschiedenen Verschachtelungstiefen.
          * Tests für Typ-Mismatches zwischen `field` und `value` (sollten `RuleEvaluationError` erzeugen).
      * **Unit Tests für `apply_action`:**
          * Test für jede `RuleAction`-Variante und deren Effekt auf eine `Notification`.
          * Test, dass `Suppress` das entsprechende Flag setzt.
          * Test, dass `SetUrgency` die Dringlichkeit ändert.
          * Test für `PlaySound` und `RunCommand` (hier mocking der externen Abhängigkeit oder des Betriebssystem-Aufrufs).
          * Test, dass Fehler bei `PlaySound` oder `RunCommand` zu `ActionExecutionError` führen.
      * **Unit Tests für `process_notification`:**
          * Testet die Regelverarbeitung mit mehreren Regeln in verschiedenen Prioritäten.
          * Testet den Effekt von `StopProcessingFurtherRules`.
          * Testet Szenarien, in denen eine Benachrichtigung unterdrückt wird.
          * Testet Szenarien, in denen eine Benachrichtigung modifiziert und weitergeleitet wird.
          * Testet, dass die Regeln nach Priorität verarbeitet werden.
          * Mocking von `DesktopSettings` und allen externen Abhängigkeiten (z.B. Audio-Player, Befehls-Ausführung).
      * **Unit Tests für `update_rules`:**
          * Testet das erfolgreiche Aktualisieren.
          * Testet die Fehlerbehandlung bei ungültigen Regex-Mustern in den neuen Regeln.

#### Funktionsspezifikation: `novade_domain::notifications::engine`

```rust
// novade-domain/src/notifications/engine.rs

//! Implementiert die Logik zur Verarbeitung von Benachrichtigungsregeln.

use async_trait::async_trait;
use regex::Regex;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::{debug, error, info, trace, warn};

use crate::notifications::data_types::{
    ConditionField, Notification, NotificationRule, NotificationRuleSet, Operator, RuleAction,
    RuleCondition, RuleConditionValue, UrgencyLevel,
};
use crate::notifications::errors::NotificationError;
use crate::settings::DesktopSettings; // Abhängigkeit zur Domänenschicht Settings

/// Repräsentiert das Ergebnis der Regelverarbeitung für eine einzelne Benachrichtigung.
#[derive(Debug, Clone, PartialEq)]
pub enum RuleProcessingResult {
    /// Die Benachrichtigung wurde verarbeitet und möglicherweise modifiziert. Sie sollte weitergeleitet werden.
    Processed(Notification),
    /// Die Benachrichtigung wurde durch eine Regel unterdrückt und sollte nicht weitergeleitet werden.
    Suppressed,
}

/// Trait für Engines, die Benachrichtigungsregeln verarbeiten können.
///
/// Definiert die Kernschnittstelle für die Regelverarbeitung und das Management des Regelsatzes.
#[async_trait]
pub trait NotificationRulesEngine: Send + Sync {
    /// Verarbeitet eine eingehende Benachrichtigung basierend auf den definierten Regeln.
    ///
    /// # Arguments
    /// * `notification` - Die zu verarbeitende Benachrichtigung.
    /// * `global_settings` - Eine Referenz auf die aktuellen globalen Desktop-Einstellungen,
    ///   die für `SettingIsTrue`-Bedingungen benötigt werden.
    ///
    /// # Returns
    /// Ein `Result`, das entweder ein `RuleProcessingResult` oder einen `NotificationError` enthält.
    async fn process_notification(
        &self,
        notification: Notification,
        global_settings: &DesktopSettings,
    ) -> Result<RuleProcessingResult, NotificationError>;

    /// Gibt eine Kopie des aktuell geladenen Regelsatzes zurück.
    fn get_rules(&self) -> NotificationRuleSet;

    /// Aktualisiert den internen Regelsatz der Engine.
    ///
    /// Führt eine Validierung der Regeln durch, bevor sie übernommen werden.
    ///
    /// # Arguments
    /// * `rules` - Das neue `NotificationRuleSet`, das übernommen werden soll.
    ///
    /// # Errors
    /// Gibt einen `NotificationError::InvalidRuleConfiguration` zurück, wenn die Regeln
    /// ungültige Elemente (z.B. ungültige Regex) enthalten.
    async fn update_rules(&self, rules: NotificationRuleSet) -> Result<(), NotificationError>;
}

/// Die Standardimplementierung der `NotificationRulesEngine`.
pub struct DefaultNotificationRulesEngine {
    rules: Arc<RwLock<NotificationRuleSet>>,
    // Cache für kompilierte Regex-Objekte, um Neukompilierung zu vermeiden.
    // Sollte nicht direkt modifiziert, sondern bei `update_rules` neu aufgebaut werden.
    regex_cache: RwLock<HashMap<String, Regex>>,
}

impl DefaultNotificationRulesEngine {
    /// Erstellt eine neue Instanz von `DefaultNotificationRulesEngine`.
    ///
    /// # Arguments
    /// * `initial_rules` - Das initiale `NotificationRuleSet`, das die Engine verwenden soll.
    pub fn new(initial_rules: NotificationRuleSet) -> Self {
        let engine = Self {
            rules: Arc::new(RwLock::new(initial_rules)),
            regex_cache: RwLock::new(HashMap::new()),
        };
        // Beim Start den Regex-Cache initial füllen
        if let Err(e) = engine.rebuild_regex_cache(&engine.get_rules()) {
            error!("Failed to build initial regex cache: {}", e);
        }
        engine
    }

    /// Hilfsfunktion zum Neuaufbau des Regex-Caches basierend auf einem Regelsatz.
    ///
    /// # Arguments
    /// * `ruleset` - Der Regelsatz, aus dem Regex-Muster extrahiert und kompiliert werden sollen.
    ///
    /// # Errors
    /// Gibt einen `NotificationError::RegexError` zurück, wenn ein Regex-Muster ungültig ist.
    fn rebuild_regex_cache(&self, ruleset: &NotificationRuleSet) -> Result<(), NotificationError> {
        let mut cache = self.regex_cache.write().unwrap();
        cache.clear();
        for rule in &ruleset.rules {
            if rule.enabled {
                self.extract_and_compile_regex_from_condition(&rule.conditions, &mut cache)?;
            }
        }
        Ok(())
    }

    /// Rekursive Hilfsfunktion zum Extrahieren und Kompilieren von Regex-Mustern aus Bedingungen.
    fn extract_and_compile_regex_from_condition(
        &self,
        condition: &RuleCondition,
        cache: &mut HashMap<String, Regex>,
    ) -> Result<(), NotificationError> {
        match condition {
            RuleCondition::Simple(simple_cond) => {
                if simple_cond.operator == Operator::MatchesRegex {
                    if let RuleConditionValue::String(pattern) = &simple_cond.value {
                        if !cache.contains_key(pattern) {
                            debug!("Compiling regex pattern: '{}'", pattern);
                            let compiled_regex = Regex::new(pattern).map_err(NotificationError::RegexError)?;
                            cache.insert(pattern.clone(), compiled_regex);
                        }
                    } else {
                        // Regex operator expects a string value
                        return Err(NotificationError::InvalidRuleConfiguration(
                            format!("Regex operator used with non-string value for field {:?}", simple_cond.field)
                        ));
                    }
                }
            }
            RuleCondition::And(conditions) | RuleCondition::Or(conditions) => {
                for cond in conditions {
                    self.extract_and_compile_regex_from_condition(cond, cache)?;
                }
            }
            RuleCondition::Not(cond) => {
                self.extract_and_compile_regex_from_condition(cond, cache)?;
            }
        }
        Ok(())
    }


    /// Hilfsfunktion zur Auswertung einer einzelnen `RuleCondition`.
    ///
    /// Diese Funktion ist rekursiv, um geschachtelte AND/OR/NOT-Bedingungen zu behandeln.
    ///
    /// # Arguments
    /// * `condition` - Die zu prüfende Regelbedingung.
    /// * `notification` - Die Benachrichtigung, gegen die die Bedingung geprüft wird.
    /// * `global_settings` - Aktuelle globale Desktop-Einstellungen für `SettingIsTrue`.
    ///
    /// # Returns
    /// Ein `Result`, das `true` oder `false` enthält, wenn die Bedingung erfolgreich ausgewertet wurde,
    /// oder einen `NotificationError` im Fehlerfall.
    fn evaluate_condition(
        &self,
        condition: &RuleCondition,
        notification: &Notification,
        global_settings: &DesktopSettings,
        regex_cache: &HashMap<String, Regex>,
    ) -> Result<bool, NotificationError> {
        match condition {
            RuleCondition::Simple(simple_cond) => {
                let field_value = match simple_cond.field {
                    ConditionField::AppName => Some(RuleConditionValue::String(notification.app_name.clone())),
                    ConditionField::Summary => Some(RuleConditionValue::String(notification.summary.clone())),
                    ConditionField::Body => notification.body.clone().map(RuleConditionValue::String),
                    ConditionField::Category => notification.category.clone().map(RuleConditionValue::String),
                    ConditionField::Urgency => Some(RuleConditionValue::Urgency(notification.urgency)),
                    ConditionField::DesktopEntry => notification.desktop_entry.clone().map(RuleConditionValue::String),
                };

                let actual_value = match field_value {
                    Some(val) => val,
                    None => {
                        // Wenn das Feld optional ist und nicht existiert, kann es die Bedingung nicht erfüllen
                        // es sei denn, der Operator ist "equals" und der Vergleichswert ist "None" oder leer.
                        // Für Simplizität nehmen wir an, dass non-existent fields nicht matchen,
                        // es sei denn, die Regel ist explizit dafür ausgelegt.
                        // Hier: Wenn Feld None ist, kann es nicht matchen, außer für spezifische "is empty" Logik,
                        // die wir aktuell nicht haben.
                        // Für `body` und `category`, `desktop_entry`: If the field is None, it cannot match
                        // any string/urgency/integer comparison unless the condition explicitly checks for absence.
                        // Current operators are for presence.
                        trace!("Notification field {:?} is None, cannot evaluate condition.", simple_cond.field);
                        return Ok(false);
                    }
                };

                match simple_cond.operator {
                    Operator::Equals => Ok(actual_value == simple_cond.value),
                    Operator::Contains => {
                        if let (RuleConditionValue::String(actual_s), RuleConditionValue::String(expected_s)) = (&actual_value, &simple_cond.value) {
                            Ok(actual_s.contains(expected_s))
                        } else {
                            Err(NotificationError::RuleEvaluationError(format!("'Contains' operator expects string values, got {:?} and {:?}", actual_value, simple_cond.value)))
                        }
                    }
                    Operator::StartsWith => {
                        if let (RuleConditionValue::String(actual_s), RuleConditionValue::String(expected_s)) = (&actual_value, &simple_cond.value) {
                            Ok(actual_s.starts_with(expected_s))
                        } else {
                            Err(NotificationError::RuleEvaluationError(format!("'StartsWith' operator expects string values, got {:?} and {:?}", actual_value, simple_cond.value)))
                        }
                    }
                    Operator::EndsWith => {
                        if let (RuleConditionValue::String(actual_s), RuleConditionValue::String(expected_s)) = (&actual_value, &simple_cond.value) {
                            Ok(actual_s.ends_with(expected_s))
                        } else {
                            Err(NotificationError::RuleEvaluationError(format!("'EndsWith' operator expects string values, got {:?} and {:?}", actual_value, simple_cond.value)))
                        }
                    }
                    Operator::MatchesRegex => {
                        if let RuleConditionValue::String(pattern) = &simple_cond.value {
                            let regex = regex_cache.get(pattern).ok_or_else(|| {
                                NotificationError::Internal(format!("Regex pattern '{}' not found in cache. This indicates a cache rebuild issue.", pattern))
                            })?;

                            if let RuleConditionValue::String(text) = &actual_value {
                                Ok(regex.is_match(text))
                            } else {
                                Err(NotificationError::RuleEvaluationError(format!("'MatchesRegex' operator expects string field value, got {:?}", actual_value)))
                            }
                        } else {
                            Err(NotificationError::InvalidRuleConfiguration(format!("'MatchesRegex' operator requires RuleConditionValue::String for pattern, got {:?}", simple_cond.value)))
                        }
                    }
                    Operator::IsGreaterThan => {
                        // Konvertierung von UrgencyLevel zu i32 für Vergleich
                        let actual_val_i32 = match actual_value {
                            RuleConditionValue::Urgency(u) => u as i32,
                            RuleConditionValue::Integer(i) => i,
                            _ => return Err(NotificationError::RuleEvaluationError(format!("'IsGreaterThan' operator expects integer or urgency values, got {:?}", actual_value))),
                        };
                        let expected_val_i32 = match simple_cond.value {
                            RuleConditionValue::Urgency(u) => u as i32,
                            RuleConditionValue::Integer(i) => i,
                            _ => return Err(NotificationError::RuleEvaluationError(format!("'IsGreaterThan' operator expects integer or urgency values for comparison, got {:?}", simple_cond.value))),
                        };
                        Ok(actual_val_i32 > expected_val_i32)
                    }
                    Operator::IsLessThan => {
                        // Konvertierung von UrgencyLevel zu i32 für Vergleich
                        let actual_val_i32 = match actual_value {
                            RuleConditionValue::Urgency(u) => u as i32,
                            RuleConditionValue::Integer(i) => i,
                            _ => return Err(NotificationError::RuleEvaluationError(format!("'IsLessThan' operator expects integer or urgency values, got {:?}", actual_value))),
                        };
                        let expected_val_i32 = match simple_cond.value {
                            RuleConditionValue::Urgency(u) => u as i32,
                            RuleConditionValue::Integer(i) => i,
                            _ => return Err(NotificationError::RuleEvaluationError(format!("'IsLessThan' operator expects integer or urgency values for comparison, got {:?}", simple_cond.value))),
                        };
                        Ok(actual_val_i32 < expected_val_i32)
                    }
                    Operator::SettingIsTrue => {
                        // Für diesen Operator muss `field` den Namen der Einstellung in `DesktopSettings` angeben
                        // und `value` muss `RuleConditionValue::Boolean(true)` sein.
                        if let (ConditionField::AppName, RuleConditionValue::String(setting_name)) = (&simple_cond.field, &actual_value) {
                             if simple_cond.value == RuleConditionValue::Boolean(true) {
                                // Hier muss eine Möglichkeit geschaffen werden, auf `DesktopSettings` zuzugreifen.
                                // Die Annahme ist, dass `DesktopSettings` öffentlich Felder oder Getter hat.
                                // Dies ist ein Beispiel, wie man auf ein hypothetisches Feld zugreifen würde:
                                // Für einen echten Fall müssten wir `global_settings` per Reflection oder
                                // einem Mapping-System abfragen.
                                // Vorerst nur ein Dummy-Zugriff:
                                let is_setting_true = match setting_name.as_str() {
                                    "animations_enabled" => global_settings.animations_enabled,
                                    "dark_mode_enabled" => global_settings.dark_mode_enabled,
                                    // ... weitere boolesche Einstellungen hier
                                    _ => {
                                        warn!("Unknown setting '{}' for SettingIsTrue operator.", setting_name);
                                        return Err(NotificationError::InvalidRuleConfiguration(format!("Unknown setting name '{}' for SettingIsTrue operator.", setting_name)));
                                    }
                                };
                                Ok(is_setting_true)
                            } else {
                                Err(NotificationError::InvalidRuleConfiguration("'SettingIsTrue' operator requires RuleConditionValue::Boolean(true)".to_string()))
                            }
                        } else {
                             Err(NotificationError::InvalidRuleConfiguration("'SettingIsTrue' operator requires field to be AppName and value to be a string (setting name).".to_string()))
                        }
                    }
                }
            }
            RuleCondition::And(conditions) => {
                for cond in conditions {
                    if !self.evaluate_condition(cond, notification, global_settings, regex_cache)? {
                        return Ok(false); // Kurzschluss-Auswertung
                    }
                }
                Ok(true)
            }
            RuleCondition::Or(conditions) => {
                for cond in conditions {
                    if self.evaluate_condition(cond, notification, global_settings, regex_cache)? {
                        return Ok(true); // Kurzschluss-Auswertung
                    }
                }
                Ok(false)
            }
            RuleCondition::Not(cond) => {
                let result = self.evaluate_condition(cond, notification, global_settings, regex_cache)?;
                Ok(!result)
            }
        }
    }

    /// Hilfsfunktion zur Anwendung einer einzelnen `RuleAction` auf eine `Notification`.
    ///
    /// # Arguments
    /// * `notification` - Die Benachrichtigung, die modifiziert werden soll.
    /// * `action` - Die anzuwendende Aktion.
    ///
    /// # Errors
    /// Gibt einen `NotificationError::ActionExecutionError` zurück, wenn eine Aktion fehlschlägt.
    async fn apply_action(
        &self, // 'self' ist hier nötig, falls Aktionen auf Engine-State zugreifen müssen (z.B. Audio-Service)
        notification: &mut Notification,
        action: &RuleAction,
    ) -> Result<(), NotificationError> {
        match action {
            RuleAction::Suppress => {
                // Ein internes Flag setzen, das vom `process_notification` ausgewertet wird.
                // notification.suppressed = true; // Dies müsste zur Notification hinzugefügt werden
                // Für diesen Implementierungsplan fügen wir ein Feld hinzu, das den Endstatus bestimmt
                debug!("Action: Suppressing notification with ID {}", notification.id);
                // Temporäre Lösung: "Suppress" hint hinzufügen
                notification.hints.insert("nova_suppressed".to_string(), Value::Bool(true));
                Ok(())
            }
            RuleAction::PlaySound(path) => {
                info!("Action: Playing sound '{}' for notification ID {}", path, notification.id);
                // Hier müsste die Integration mit dem Audio-System erfolgen.
                // Beispiel: novade_system::audio_management::play_sound(path).await;
                // Vorerst ein Dummy-Ergebnis für den Test.
                // In einer echten Implementierung würde dies asynchrone I/O-Aufrufe beinhalten.
                // Ein Fehler hier sollte in ActionExecutionError umgewandelt werden.
                // Z.B. if play_sound_failed { return Err(NotificationError::ActionExecutionError { action: "PlaySound".to_string(), source: Box::new(io::Error::new(io::ErrorKind::Other, "Sound playback failed")) }); }
                tokio::time::sleep(tokio::time::Duration::from_millis(5)).await; // Simulate async work
                Ok(())
            }
            RuleAction::SetUrgency(level) => {
                info!("Action: Setting urgency to {:?} for notification ID {}", level, notification.id);
                notification.urgency = *level;
                Ok(())
            }
            RuleAction::Highlight => {
                info!("Action: Highlighting notification with ID {}", notification.id);
                // Temporäre Lösung: "Highlight" hint hinzufügen
                notification.hints.insert("nova_highlight".to_string(), Value::Bool(true));
                Ok(())
            }
            RuleAction::RunCommand(cmd) => {
                info!("Action: Running command '{}' for notification ID {}", cmd, notification.id);
                // Hier müsste der Befehl asynchron ausgeführt werden.
                // Vorsicht: Sicherheitsprobleme bei der Ausführung beliebiger Befehle!
                // Sollte in der Systemschicht gekapselt und sorgfältig validiert werden.
                // Beispiel: tokio::process::Command::new("sh").arg("-c").arg(cmd).spawn().await?;
                // Vorerst ein Dummy-Ergebnis für den Test.
                tokio::time::sleep(tokio::time::Duration::from_millis(5)).await; // Simulate async work
                Ok(())
            }
            RuleAction::StopProcessingFurtherRules => {
                // Diese Aktion wird vom aufrufenden `process_notification` behandelt, nicht hier.
                // Sie signalisiert nur, dass keine weiteren Regeln für diese Benachrichtigung geprüft werden sollen.
                debug!("Action: StopProcessingFurtherRules encountered.");
                Ok(())
            }
            RuleAction::Log(msg) => {
                info!("Action Log for notification ID {}: {}", notification.id, msg);
                Ok(())
            }
        }
    }
}

#[async_trait]
impl NotificationRulesEngine for DefaultNotificationRulesEngine {
    async fn process_notification(
        &self,
        mut notification: Notification,
        global_settings: &DesktopSettings,
    ) -> Result<RuleProcessingResult, NotificationError> {
        info!("Processing notification: {:?}", notification.summary);

        let rules_guard = self.rules.read().await;
        let mut sorted_rules = rules_guard.rules.clone();
        // Sortiere Regeln nach Priorität: niedrigere Zahl bedeutet höhere Priorität
        sorted_rules.sort_by_key(|rule| rule.priority);

        let regex_cache_guard = self.regex_cache.read().unwrap(); // Read lock for cache

        let mut suppressed_by_rule = false;

        for rule in sorted_rules {
            if !rule.enabled {
                trace!("Skipping disabled rule: {}", rule.name);
                continue;
            }

            debug!("Evaluating rule: '{}' (ID: {})", rule.name, rule.id);
            match self.evaluate_condition(&rule.conditions, &notification, global_settings, &regex_cache_guard) {
                Ok(true) => {
                    info!("Rule '{}' (ID: {}) matched.", rule.name, rule.id);
                    for action in &rule.actions {
                        debug!("Applying action: {:?} for rule {}", action, rule.id);
                        if let Err(e) = self.apply_action(&mut notification, action).await {
                            error!("Failed to apply action {:?} for notification {}: {}", action, notification.id, e);
                            // Fehler bei Aktion nicht fatal für weitere Regelverarbeitung, aber loggen.
                        }
                        if matches!(action, RuleAction::Suppress) {
                            suppressed_by_rule = true;
                        }
                        if matches!(action, RuleAction::StopProcessingFurtherRules) {
                            info!("'StopProcessingFurtherRules' action encountered. Stopping further rule evaluation.");
                            // Wenn Suppress die letzte angewendete Aktion war, geben wir Suppressed zurück
                            return Ok(if suppressed_by_rule {
                                RuleProcessingResult::Suppressed
                            } else {
                                RuleProcessingResult::Processed(notification)
                            });
                        }
                    }
                }
                Ok(false) => {
                    trace!("Rule '{}' (ID: {}) did not match.", rule.name, rule.id);
                }
                Err(e) => {
                    error!("Error evaluating rule '{}' (ID: {}): {}", rule.name, rule.id, e);
                    // Ein Fehler bei der Regelauswertung sollte die Verarbeitung anderer Regeln nicht blockieren.
                    // Nur diese spezifische Regel wird übersprungen.
                }
            }
        }

        // Nach Durchlauf aller Regeln (oder wenn StopProcessingFurtherRules nicht aufgerufen wurde)
        Ok(if suppressed_by_rule {
            RuleProcessingResult::Suppressed
        } else {
            RuleProcessingResult::Processed(notification)
        })
    }

    fn get_rules(&self) -> NotificationRuleSet {
        self.rules.blocking_read().unwrap().clone()
    }

    async fn update_rules(&self, rules: NotificationRuleSet) -> Result<(), NotificationError> {
        info!("Updating notification rules.");
        // Zuerst validieren wir die neuen Regeln, bevor wir sie übernehmen
        if let Err(e) = self.rebuild_regex_cache(&rules) {
            error!("New rules contain invalid regex patterns: {}", e);
            return Err(NotificationError::InvalidRuleConfiguration(format!(
                "One or more rules contain invalid regex patterns: {}",
                e
            )));
        }

        let mut rules_guard = self.rules.write().await;
        *rules_guard = rules;
        info!("Notification rules updated successfully.");
        Ok(())
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use crate::notifications::data_types::{
        SimpleRuleCondition, RuleCondition, UrgencyLevel, RuleAction, RuleConditionValue,
    };
    use crate::settings::DesktopSettings; // Zugriff auf DesktopSettings für Mocking
    use std::io::{self, ErrorKind};
    use uuid::Uuid;

    // Helper function to create a default notification for tests
    fn create_test_notification(app_name: &str, summary: &str, body: Option<&str>, urgency: UrgencyLevel) -> Notification {
        Notification {
            id: Uuid::new_v4(),
            app_name: app_name.to_string(),
            replaces_id: None,
            app_icon: None,
            summary: summary.to_string(),
            body: body.map(|s| s.to_string()),
            actions: Vec::new(),
            hints: HashMap::new(),
            expire_timeout: -1,
            timestamp: chrono::Utc::now(),
            category: None,
            urgency,
            desktop_entry: None,
        }
    }

    // --- Tests for evaluate_condition ---
    #[tokio::test]
    async fn evaluate_condition_equals_match() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let notification = create_test_notification("TestApp", "Summary", None, UrgencyLevel::Normal);
        let condition = RuleCondition::Simple(SimpleRuleCondition {
            field: ConditionField::AppName,
            operator: Operator::Equals,
            value: RuleConditionValue::String("TestApp".to_string()),
        });
        let settings = DesktopSettings::default();
        let regex_cache = HashMap::new();

        let result = engine.evaluate_condition(&condition, &notification, &settings, &regex_cache).unwrap();
        assert!(result);
    }

    #[tokio::test]
    async fn evaluate_condition_equals_no_match() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let notification = create_test_notification("AnotherApp", "Summary", None, UrgencyLevel::Normal);
        let condition = RuleCondition::Simple(SimpleRuleCondition {
            field: ConditionField::AppName,
            operator: Operator::Equals,
            value: RuleConditionValue::String("TestApp".to_string()),
        });
        let settings = DesktopSettings::default();
        let regex_cache = HashMap::new();

        let result = engine.evaluate_condition(&condition, &notification, &settings, &regex_cache).unwrap();
        assert!(!result);
    }

    #[tokio::test]
    async fn evaluate_condition_contains_match() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let notification = create_test_notification("TestApp", "This is a test summary", None, UrgencyLevel::Normal);
        let condition = RuleCondition::Simple(SimpleRuleCondition {
            field: ConditionField::Summary,
            operator: Operator::Contains,
            value: RuleConditionValue::String("test".to_string()),
        });
        let settings = DesktopSettings::default();
        let regex_cache = HashMap::new();

        let result = engine.evaluate_condition(&condition, &notification, &settings, &regex_cache).unwrap();
        assert!(result);
    }

    #[tokio::test]
    async fn evaluate_condition_matches_regex_match() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let notification = create_test_notification("TestApp", "Error: Something failed [ID: 123]", None, UrgencyLevel::Normal);
        let condition = RuleCondition::Simple(SimpleRuleCondition {
            field: ConditionField::Summary,
            operator: Operator::MatchesRegex,
            value: RuleConditionValue::String(r"Error: .* \[ID: \d+\]".to_string()),
        });

        let mut regex_cache = HashMap::new();
        regex_cache.insert(r"Error: .* \[ID: \d+\]".to_string(), Regex::new(r"Error: .* \[ID: \d+\]").unwrap());

        let settings = DesktopSettings::default();
        let result = engine.evaluate_condition(&condition, &notification, &settings, &regex_cache).unwrap();
        assert!(result);
    }

    #[tokio::test]
    async fn evaluate_condition_matches_regex_no_match() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let notification = create_test_notification("TestApp", "Info: All good", None, UrgencyLevel::Normal);
        let condition = RuleCondition::Simple(SimpleRuleCondition {
            field: ConditionField::Summary,
            operator: Operator::MatchesRegex,
            value: RuleConditionValue::String(r"Error: .*".to_string()),
        });
        let mut regex_cache = HashMap::new();
        regex_cache.insert(r"Error: .*".to_string(), Regex::new(r"Error: .*").unwrap());

        let settings = DesktopSettings::default();
        let result = engine.evaluate_condition(&condition, &notification, &settings, &regex_cache).unwrap();
        assert!(!result);
    }

    #[tokio::test]
    async fn evaluate_condition_urgency_is_greater_than() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let notification = create_test_notification("TestApp", "Alert", None, UrgencyLevel::Critical);
        let condition = RuleCondition::Simple(SimpleRuleCondition {
            field: ConditionField::Urgency,
            operator: Operator::IsGreaterThan,
            value: RuleConditionValue::Urgency(UrgencyLevel::Normal),
        });
        let settings = DesktopSettings::default();
        let regex_cache = HashMap::new();

        let result = engine.evaluate_condition(&condition, &notification, &settings, &regex_cache).unwrap();
        assert!(result); // Critical (2) > Normal (1)
    }

    #[tokio::test]
    async fn evaluate_condition_setting_is_true_match() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let notification = create_test_notification("TestApp", "Summary", None, UrgencyLevel::Normal);
        let condition = RuleCondition::Simple(SimpleRuleCondition {
            field: ConditionField::AppName, // Field is ignored, but must be there
            operator: Operator::SettingIsTrue,
            value: RuleConditionValue::Boolean(true),
        });
        let settings = DesktopSettings {
            animations_enabled: true, // This is the setting we target
            ..Default::default()
        };
        // NOTE: The `evaluate_condition` uses `setting_name.as_str()` from `actual_value` which is `notification.app_name`
        // This is a design flaw in the example given where ConditionField::AppName is used for setting name.
        // For `SettingIsTrue`, the `field` should probably be a dedicated enum variant like `ConditionField::Setting`
        // and the `value` of `SimpleRuleCondition` should be the string name of the setting.
        // For now, adhering to the specified design, even if it's awkward.
        let mut notification_for_setting_test = create_test_notification("animations_enabled", "dummy", None, UrgencyLevel::Normal);

        let regex_cache = HashMap::new();

        let result = engine.evaluate_condition(&condition, &notification_for_setting_test, &settings, &regex_cache).unwrap();
        assert!(result);
    }

    #[tokio::test]
    async fn evaluate_condition_setting_is_true_no_match() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let notification = create_test_notification("TestApp", "Summary", None, UrgencyLevel::Normal);
        let condition = RuleCondition::Simple(SimpleRuleCondition {
            field: ConditionField::AppName, // Field is ignored, but must be there
            operator: Operator::SettingIsTrue,
            value: RuleConditionValue::Boolean(true),
        });
        let settings = DesktopSettings {
            animations_enabled: false, // This is the setting we target
            ..Default::default()
        };
        let mut notification_for_setting_test = create_test_notification("animations_enabled", "dummy", None, UrgencyLevel::Normal);
        let regex_cache = HashMap::new();

        let result = engine.evaluate_condition(&condition, &notification_for_setting_test, &settings, &regex_cache).unwrap();
        assert!(!result);
    }

    #[tokio::test]
    async fn evaluate_condition_and_true() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let notification = create_test_notification("Firefox", "New email", None, UrgencyLevel::Normal);
        let condition = RuleCondition::And(vec![
            RuleCondition::Simple(SimpleRuleCondition {
                field: ConditionField::AppName,
                operator: Operator::Equals,
                value: RuleConditionValue::String("Firefox".to_string()),
            }),
            RuleCondition::Simple(SimpleRuleCondition {
                field: ConditionField::Summary,
                operator: Operator::Contains,
                value: RuleConditionValue::String("email".to_string()),
            }),
        ]);
        let settings = DesktopSettings::default();
        let regex_cache = HashMap::new();

        let result = engine.evaluate_condition(&condition, &notification, &settings, &regex_cache).unwrap();
        assert!(result);
    }

    #[tokio::test]
    async fn evaluate_condition_or_true() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let notification = create_test_notification("Chromium", "Low battery", None, UrgencyLevel::Critical);
        let condition = RuleCondition::Or(vec![
            RuleCondition::Simple(SimpleRuleCondition {
                field: ConditionField::AppName,
                operator: Operator::Equals,
                value: RuleConditionValue::String("Firefox".to_string()),
            }),
            RuleCondition::Simple(SimpleRuleCondition {
                field: ConditionField::Urgency,
                operator: Operator::Equals,
                value: RuleConditionValue::Urgency(UrgencyLevel::Critical),
            }),
        ]);
        let settings = DesktopSettings::default();
        let regex_cache = HashMap::new();

        let result = engine.evaluate_condition(&condition, &notification, &settings, &regex_cache).unwrap();
        assert!(result);
    }

    #[tokio::test]
    async fn evaluate_condition_not_true() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let notification = create_test_notification("TestApp", "Summary", None, UrgencyLevel::Normal);
        let condition = RuleCondition::Not(Box::new(RuleCondition::Simple(SimpleRuleCondition {
            field: ConditionField::AppName,
            operator: Operator::Equals,
            value: RuleConditionValue::String("WrongApp".to_string()),
        })));
        let settings = DesktopSettings::default();
        let regex_cache = HashMap::new();

        let result = engine.evaluate_condition(&condition, &notification, &settings, &regex_cache).unwrap();
        assert!(result);
    }

    #[tokio::test]
    async fn evaluate_condition_type_mismatch_error() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let notification = create_test_notification("TestApp", "Summary", None, UrgencyLevel::Normal);
        let condition = RuleCondition::Simple(SimpleRuleCondition {
            field: ConditionField::AppName,
            operator: Operator::IsGreaterThan, // Cannot compare string with IsGreaterThan
            value: RuleConditionValue::Integer(10),
        });
        let settings = DesktopSettings::default();
        let regex_cache = HashMap::new();

        let result = engine.evaluate_condition(&condition, &notification, &settings, &regex_cache).await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), NotificationError::RuleEvaluationError(_)));
    }


    // --- Tests for apply_action ---
    #[tokio::test]
    async fn apply_action_suppress() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let mut notification = create_test_notification("TestApp", "Summary", None, UrgencyLevel::Normal);
        let action = RuleAction::Suppress;

        engine.apply_action(&mut notification, &action).await.unwrap();
        // Check if the "nova_suppressed" hint is set
        assert!(notification.hints.get("nova_suppressed").unwrap().as_bool().unwrap());
    }

    #[tokio::test]
    async fn apply_action_set_urgency() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let mut notification = create_test_notification("TestApp", "Summary", None, UrgencyLevel::Normal);
        let action = RuleAction::SetUrgency(UrgencyLevel::Critical);

        engine.apply_action(&mut notification, &action).await.unwrap();
        assert_eq!(notification.urgency, UrgencyLevel::Critical);
    }

    #[tokio::test]
    async fn apply_action_highlight() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let mut notification = create_test_notification("TestApp", "Summary", None, UrgencyLevel::Normal);
        let action = RuleAction::Highlight;

        engine.apply_action(&mut notification, &action).await.unwrap();
        // Check if the "nova_highlight" hint is set
        assert!(notification.hints.get("nova_highlight").unwrap().as_bool().unwrap());
    }

    #[tokio::test]
    async fn apply_action_log() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let mut notification = create_test_notification("TestApp", "Summary", None, UrgencyLevel::Normal);
        let action = RuleAction::Log("This is a log message".to_string());

        // This test mostly checks for no panic and successful execution,
        // actual log output would be captured by a logging framework's test setup.
        let result = engine.apply_action(&mut notification, &action).await;
        assert!(result.is_ok());
    }

    // `PlaySound` and `RunCommand` would require mocking external dependencies
    // or system calls, which is more complex. For now, assume they don't panic
    // and return Ok(()). Error cases would need specialized mocks.

    // --- Tests for process_notification ---
    #[tokio::test]
    async fn process_notification_no_match_returns_processed() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default()); // No rules
        let notification = create_test_notification("TestApp", "Summary", None, UrgencyLevel::Normal);
        let settings = DesktopSettings::default();

        let result = engine.process_notification(notification.clone(), &settings).await.unwrap();
        assert!(matches!(result, RuleProcessingResult::Processed(n) if n == notification));
    }

    #[tokio::test]
    async fn process_notification_rule_suppresses() {
        let suppression_rule = NotificationRule {
            id: Uuid::new_v4(),
            name: "Suppress TestApp".to_string(),
            enabled: true,
            priority: 1,
            conditions: RuleCondition::Simple(SimpleRuleCondition {
                field: ConditionField::AppName,
                operator: Operator::Equals,
                value: RuleConditionValue::String("TestApp".to_string()),
            }),
            actions: vec![RuleAction::Suppress],
        };
        let ruleset = NotificationRuleSet {
            rules: vec![suppression_rule],
        };
        let engine = DefaultNotificationRulesEngine::new(ruleset);
        let notification = create_test_notification("TestApp", "Summary", None, UrgencyLevel::Normal);
        let settings = DesktopSettings::default();

        let result = engine.process_notification(notification, &settings).await.unwrap();
        assert!(matches!(result, RuleProcessingResult::Suppressed));
    }

    #[tokio::test]
    async fn process_notification_rule_modifies_and_processes() {
        let modify_rule = NotificationRule {
            id: Uuid::new_v4(),
            name: "Set Urgency to Critical".to_string(),
            enabled: true,
            priority: 1,
            conditions: RuleCondition::Simple(SimpleRuleCondition {
                field: ConditionField::AppName,
                operator: Operator::Equals,
                value: RuleConditionValue::String("TestApp".to_string()),
            }),
            actions: vec![RuleAction::SetUrgency(UrgencyLevel::Critical)],
        };
        let ruleset = NotificationRuleSet {
            rules: vec![modify_rule],
        };
        let engine = DefaultNotificationRulesEngine::new(ruleset);
        let notification = create_test_notification("TestApp", "Summary", None, UrgencyLevel::Normal);
        let settings = DesktopSettings::default();

        let result = engine.process_notification(notification.clone(), &settings).await.unwrap();
        if let RuleProcessingResult::Processed(modified_notification) = result {
            assert_eq!(modified_notification.urgency, UrgencyLevel::Critical);
            assert_eq!(modified_notification.app_name, notification.app_name); // Other fields unchanged
        } else {
            panic!("Expected Processed, got {:?}", result);
        }
    }

    #[tokio::test]
    async fn process_notification_stop_processing_further_rules() {
        let rule1 = NotificationRule {
            id: Uuid::new_v4(),
            name: "Log and Stop".to_string(),
            enabled: true,
            priority: 1,
            conditions: RuleCondition::Simple(SimpleRuleCondition {
                field: ConditionField::AppName,
                operator: Operator::Equals,
                value: RuleConditionValue::String("TestApp".to_string()),
            }),
            actions: vec![RuleAction::Log("Rule 1 matched".to_string()), RuleAction::StopProcessingFurtherRules],
        };
        let rule2 = NotificationRule {
            id: Uuid::new_v4(),
            name: "Suppress Everything Else".to_string(),
            enabled: true,
            priority: 2, // Lower priority, should not be reached
            conditions: RuleCondition::Simple(SimpleRuleCondition {
                field: ConditionField::AppName,
                operator: Operator::Contains,
                value: RuleConditionValue::String("Test".to_string()),
            }),
            actions: vec![RuleAction::Suppress],
        };
        let ruleset = NotificationRuleSet {
            rules: vec![rule1, rule2],
        };
        let engine = DefaultNotificationRulesEngine::new(ruleset);
        let notification = create_test_notification("TestApp", "Summary", None, UrgencyLevel::Normal);
        let settings = DesktopSettings::default();

        let result = engine.process_notification(notification.clone(), &settings).await.unwrap();
        // Should be processed, not suppressed, because rule2 was skipped.
        assert!(matches!(result, RuleProcessingResult::Processed(n) if n == notification));
    }

    #[tokio::test]
    async fn process_notification_stop_processing_further_rules_with_suppress() {
        let rule1 = NotificationRule {
            id: Uuid::new_v4(),
            name: "Suppress and Stop".to_string(),
            enabled: true,
            priority: 1,
            conditions: RuleCondition::Simple(SimpleRuleCondition {
                field: ConditionField::AppName,
                operator: Operator::Equals,
                value: RuleConditionValue::String("TestApp".to_string()),
            }),
            actions: vec![RuleAction::Suppress, RuleAction::StopProcessingFurtherRules],
        };
        let rule2 = NotificationRule {
            id: Uuid::new_v4(),
            name: "Should not be reached".to_string(),
            enabled: true,
            priority: 2,
            conditions: RuleCondition::Simple(SimpleRuleCondition {
                field: ConditionField::AppName,
                operator: Operator::Contains,
                value: RuleConditionValue::String("Test".to_string()),
            }),
            actions: vec![RuleAction::SetUrgency(UrgencyLevel::Low)],
        };
        let ruleset = NotificationRuleSet {
            rules: vec![rule1, rule2],
        };
        let engine = DefaultNotificationRulesEngine::new(ruleset);
        let notification = create_test_notification("TestApp", "Summary", None, UrgencyLevel::Normal);
        let settings = DesktopSettings::default();

        let result = engine.process_notification(notification, &settings).await.unwrap();
        assert!(matches!(result, RuleProcessingResult::Suppressed));
    }


    // --- Tests for update_rules ---
    #[tokio::test]
    async fn update_rules_successful() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let new_rules = NotificationRuleSet {
            rules: vec![NotificationRule::default()],
        };

        let result = engine.update_rules(new_rules.clone()).await;
        assert!(result.is_ok());
        assert_eq!(engine.get_rules(), new_rules);
    }

    #[tokio::test]
    async fn update_rules_invalid_regex_fails() {
        let engine = DefaultNotificationRulesEngine::new(NotificationRuleSet::default());
        let invalid_rule = NotificationRule {
            id: Uuid::new_v4(),
            name: "Invalid Regex Rule".to_string(),
            enabled: true,
            priority: 1,
            conditions: RuleCondition::Simple(SimpleRuleCondition {
                field: ConditionField::Summary,
                operator: Operator::MatchesRegex,
                value: RuleConditionValue::String(r"(".to_string()), // Invalid regex
            }),
            actions: vec![],
        };
        let new_rules = NotificationRuleSet {
            rules: vec![invalid_rule],
        };

        let result = engine.update_rules(new_rules).await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), NotificationError::InvalidRuleConfiguration(_)));
        // Ensure old rules are still present (or default if it was initial)
        assert_eq!(engine.get_rules(), NotificationRuleSet::default());
    }

    // --- Tests for get_rules ---
    #[tokio::test]
    async fn get_rules_returns_current_rules() {
        let initial_rules = NotificationRuleSet {
            rules: vec![NotificationRule {
                id: Uuid::new_v4(),
                name: "Initial Rule".to_string(),
                ..Default::default()
            }],
        };
        let engine = DefaultNotificationRulesEngine::new(initial_rules.clone());
        let retrieved_rules = engine.get_rules();
        assert_eq!(retrieved_rules, initial_rules);
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (23 von 100) widmet sich der zentralen Koordination und Verwaltung von Benachrichtigungen innerhalb des `notifications`-Moduls der Domänenschicht (`novade-domain`). Die Datei `service.rs` wird den `NotificationService` implementieren, der als primärer Kommunikationspunkt für das Empfangen, Verarbeiten und Weiterleiten von Benachrichtigungen dient.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 23/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.17.6. `novade-domain/src/notifications/service.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notifications/service.rs`
  * **Verantwortlichkeit:** Implementiert den `NotificationService`, der als zentraler Aggregator und Dispatcher für Benachrichtigungen fungiert. Er empfängt Benachrichtigungen vom D-Bus-Server, wendet die Regeln der `NotificationRulesEngine` an und leitet das Ergebnis an registrierte Listener weiter. Zudem verwaltet er die Persistenz der Benachrichtigungsregeln.
  * **Kern-Aufgaben (Tasks):**
    1.  **`NotificationService` Struct definieren:**
          * Felder:
              * `rule_engine: Arc<DefaultNotificationRulesEngine>`: Ein `Arc`-Pointer zur Regel-Engine.
              * `persistence_provider: Arc<dyn NotificationRulesProvider>`: Ein `Arc`-Pointer zum Persistenz-Provider (Trait-Objekt).
              * `notifier_tx: broadcast::Sender<Notification>`: Ein `tokio::sync::broadcast::Sender` für Benachrichtigungen, die nach der Regelverarbeitung an UI-Komponenten oder andere Domänen-Services gesendet werden.
              * `desktop_settings_service: Arc<dyn GlobalSettingsService>`: Eine Referenz zum `GlobalSettingsService` aus der `settings`-Domänenkomponente, um auf globale Desktop-Einstellungen zugreifen zu können, die für die Regelverarbeitung benötigt werden.
              * `max_notifications: usize`: Die maximale Anzahl von Benachrichtigungen, die gleichzeitig im Speicher gehalten werden. (Aus den `DesktopSettings` zu entnehmen).
              * `notification_store: Arc<RwLock<VecDeque<Notification>>>`: Ein `Arc<RwLock<VecDeque<Notification>>>` um die aktuell aktiven Benachrichtigungen zu speichern, um z.B. einen Benachrichtigungsverlauf zu ermöglichen. `VecDeque` für effizientes Hinzufügen/Entfernen von beiden Enden.
    2.  **Konstruktor `new()` implementieren:**
          * Nimmt `initial_rules: NotificationRuleSet`, `persistence_provider: Arc<dyn NotificationRulesProvider>`, `desktop_settings_service: Arc<dyn GlobalSettingsService>` entgegen.
          * Erzeugt einen `broadcast::channel` für `notifier_tx`.
          * Initialisiert `DefaultNotificationRulesEngine` mit `initial_rules`.
          * Initialisiert `notification_store` als leere `VecDeque`.
          * Der `max_notifications` Wert sollte aus `desktop_settings_service` geholt werden. Falls nicht verfügbar, einen sinnvollen Standardwert (z.B. 100) verwenden.
    3.  **Methode `load_rules_from_persistence(&self) -> Result<(), NotificationError>` implementieren:**
          * Ruft `self.persistence_provider.load_rules().await` auf.
          * Bei Erfolg: Aktualisiert den Regelsatz in `self.rule_engine` mit `self.rule_engine.update_rules(loaded_rules).await`.
          * Bei Fehlern: Loggt den Fehler und gibt ihn weiter.
    4.  **Methode `handle_incoming_notification(&self, notification: Notification) -> Result<(), NotificationError>` implementieren:**
          * Ruft `self.desktop_settings_service.get_current_settings().await` auf, um die aktuellen Desktop-Einstellungen zu erhalten.
          * Ruft `self.rule_engine.process_notification(notification, &settings).await` auf.
          * Basierend auf `RuleProcessingResult`:
              * `RuleProcessingResult::Processed(processed_notification)`:
                  * Sendet die `processed_notification` über `self.notifier_tx.send(processed_notification.clone())`. Fehler hier loggen, aber nicht fatal.
                  * Fügt die `processed_notification` zu `notification_store` hinzu.
                  * Stellt sicher, dass `notification_store` die `max_notifications`-Grenze nicht überschreitet (älteste entfernen).
              * `RuleProcessingResult::Suppressed`:
                  * Loggt, dass die Benachrichtigung unterdrückt wurde (info/debug level).
                  * Die Benachrichtigung wird nicht über den `notifier_tx` gesendet und nicht im `notification_store` abgelegt.
          * Fehler von `process_notification` loggen und als `NotificationError` weitergeben.
    5.  **Methode `subscribe_to_notifications(&self) -> broadcast::Receiver<Notification>` implementieren:**
          * Gibt einen neuen `broadcast::Receiver` aus `self.notifier_tx.subscribe()` zurück.
    6.  **Methode `get_current_rules(&self) -> NotificationRuleSet` implementieren:**
          * Ruft `self.rule_engine.get_rules()` auf.
    7.  **Methode `update_rules(&self, new_rules: NotificationRuleSet) -> Result<(), NotificationError>` implementieren:**
          * Ruft `self.rule_engine.update_rules(new_rules.clone()).await` auf.
          * Bei Erfolg: Ruft `self.persistence_provider.save_rules(&new_rules).await` auf, um die aktualisierten Regeln persistent zu speichern.
          * Fehler loggen und weitergeben.
    8.  **Methode `get_notification_history(&self) -> Vec<Notification>` implementieren:**
          * Gibt eine Kopie der im `notification_store` gespeicherten Benachrichtigungen zurück.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notifications/service.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notifications::data_types::Notification`, `crate::notifications::data_types::NotificationRuleSet`, `crate::notifications::errors::NotificationError`, `crate::notifications::engine::{DefaultNotificationRulesEngine, NotificationRulesEngine, RuleProcessingResult}`, `crate::notifications::persistence_iface::NotificationRulesProvider`, `crate::settings::GlobalSettingsService` (Trait).
      * **Extern:** `tokio::sync::broadcast`, `tokio::sync::RwLock`, `std::sync::Arc`, `std::collections::VecDeque`, `tracing`.
  * **Kommunikationsmuster:**
      * Empfängt Benachrichtigungen (z.B. vom D-Bus-Server in der System-Schicht), verarbeitet sie und sendet sie über `broadcast::Sender` an UI-Komponenten.
      * Interagiert mit `NotificationRulesEngine` und `NotificationRulesProvider`.
      * Greift auf `GlobalSettingsService` zu.
  * **Erwartete Ergebnisse/Outputs:**
      * Eine zentrale Anlaufstelle für die Verwaltung des gesamten Benachrichtigungsflusses.
      * Eine Service-Schicht, die die Regel-Engine und Persistenz logisch kapselt.
      * Die Möglichkeit für andere Komponenten, Benachrichtigungen zu abonnieren.
      * Persistente Speicherung und Laden der Benachrichtigungsregeln.
      * Ein Benachrichtigungsverlauf, der von UI-Komponenten abgefragt werden kann.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests (mit Mocking):**
          * Mocking von `NotificationRulesEngine`, `NotificationRulesProvider`, und `GlobalSettingsService`.
          * Test der `new()`-Funktion.
          * Test `load_rules_from_persistence`:
              * Erfolgreiches Laden und Aktualisieren der Regeln in der Engine.
              * Fehlerbehandlung beim Laden.
          * Test `handle_incoming_notification`:
              * Benachrichtigung wird verarbeitet und gesendet (`RuleProcessingResult::Processed`).
              * Benachrichtigung wird unterdrückt (`RuleProcessingResult::Suppressed`).
              * Benachrichtigung wird dem `notification_store` hinzugefügt und alte Benachrichtigungen werden bei Überschreitung von `max_notifications` entfernt.
              * Fehler von `process_notification` werden korrekt behandelt.
              * Test, dass `subscribe_to_notifications` korrekte Receiver liefert und Benachrichtigungen empfangen werden können.
          * Test `update_rules`:
              * Erfolgreiches Aktualisieren der Regeln in der Engine und Speichern mittels Persistence Provider.
              * Fehlerbehandlung beim Aktualisieren (Engine-Fehler, Persistenz-Fehler).
          * Test `get_current_rules` und `get_notification_history` zur Überprüfung des Zustands.
      * **Integration Tests:**
          * Könnten den `NotificationService` mit echten, aber einfachen Implementierungen der Mocks (z.B. in-memory `NotificationRulesProvider` und `NotificationRulesEngine`) verbinden, um den gesamten Fluss zu testen.

#### Funktionsspezifikation: `novade_domain::notifications::service`

```rust
// novade-domain/src/notifications/service.rs

//! Implementiert den zentralen Benachrichtigungsdienst von NovaDE.
//!
//! Dieser Dienst empfängt Benachrichtigungen, verarbeitet sie mit der Regel-Engine,
//! verwaltet deren Persistenz und verteilt sie an registrierte Listener.

use async_trait::async_trait;
use std::collections::VecDeque;
use std::sync::Arc;
use tokio::sync::{broadcast, RwLock};
use tracing::{debug, error, info, trace, warn};

use crate::notifications::data_types::{Notification, NotificationRuleSet};
use crate::notifications::engine::{DefaultNotificationRulesEngine, NotificationRulesEngine, RuleProcessingResult};
use crate::notifications::errors::NotificationError;
use crate::notifications::persistence_iface::NotificationRulesProvider;
use crate::settings::GlobalSettingsService; // Annahme: GlobalSettingsService ist ein Trait in der settings-Domäne

/// Der Benachrichtigungsdienst von NovaDE.
///
/// Dieser Dienst ist verantwortlich für:
/// - Das Empfangen neuer Benachrichtigungen.
/// - Die Anwendung von Benachrichtigungsregeln zur Filterung und Modifikation.
/// - Die Persistenz der Benachrichtigungsregeln.
/// - Die Verteilung verarbeiteter Benachrichtigungen an abonnierte Komponenten (z.B. UI).
/// - Das Management eines Benachrichtigungsverlaufs.
pub struct NotificationService {
    rule_engine: Arc<DefaultNotificationRulesEngine>,
    persistence_provider: Arc<dyn NotificationRulesProvider>,
    notifier_tx: broadcast::Sender<Notification>,
    desktop_settings_service: Arc<dyn GlobalSettingsService>,
    max_notifications: usize,
    notification_store: Arc<RwLock<VecDeque<Notification>>>,
}

impl NotificationService {
    /// Erstellt eine neue Instanz des `NotificationService`.
    ///
    /// # Arguments
    /// * `initial_rules` - Das initiale Set von Benachrichtigungsregeln.
    /// * `persistence_provider` - Eine Implementierung des `NotificationRulesProvider`-Traits
    ///   für die Persistenz der Regeln.
    /// * `desktop_settings_service` - Eine Implementierung des `GlobalSettingsService`-Traits
    ///   zum Abrufen globaler Desktop-Einstellungen.
    ///
    /// # Returns
    /// Eine neue `NotificationService`-Instanz.
    ///
    /// # Panics
    /// Kann paniken, wenn der Broadcast-Channel initialisiert wird (sehr unwahrscheinlich bei Standardgrößen).
    pub fn new(
        initial_rules: NotificationRuleSet,
        persistence_provider: Arc<dyn NotificationRulesProvider>,
        desktop_settings_service: Arc<dyn GlobalSettingsService>,
    ) -> Self {
        // Die Kapazität des Broadcast-Channels. Dies ist ein Trade-off zwischen
        // Speicherverbrauch und der Wahrscheinlichkeit, dass langsame Receiver
        // Nachrichten verpassen. 100 ist ein vernünftiger Standardwert.
        let (notifier_tx, _notifier_rx) = broadcast::channel(100);

        let max_notifications_from_settings = desktop_settings_service.blocking_get_current_settings().max_notification_history;
        let max_notifications = if max_notifications_from_settings > 0 {
            max_notifications_from_settings
        } else {
            100 // Fallback zu einem Standardwert, falls die Einstellung 0 ist oder ungültig
        };

        Self {
            rule_engine: Arc::new(DefaultNotificationRulesEngine::new(initial_rules)),
            persistence_provider,
            notifier_tx,
            desktop_settings_service,
            max_notifications,
            notification_store: Arc::new(RwLock::new(VecDeque::with_capacity(max_notifications))),
        }
    }

    /// Lädt die Benachrichtigungsregeln aus dem persistenten Speicher
    /// und aktualisiert die Regel-Engine.
    ///
    /// Sollte beim Start des Dienstes aufgerufen werden.
    ///
    /// # Errors
    /// Gibt einen `NotificationError::PersistenceError` zurück, wenn das Laden fehlschlägt.
    pub async fn load_rules_from_persistence(&self) -> Result<(), NotificationError> {
        info!("Loading notification rules from persistence...");
        match self.persistence_provider.load_rules().await {
            Ok(loaded_rules) => {
                debug!("Successfully loaded rules. Updating rule engine.");
                self.rule_engine.update_rules(loaded_rules).await?;
                info!("Notification rules loaded and updated successfully.");
                Ok(())
            }
            Err(e) => {
                error!("Failed to load notification rules from persistence: {}", e);
                Err(e)
            }
        }
    }

    /// Behandelt eine eingehende Benachrichtigung.
    ///
    /// Die Benachrichtigung wird durch die Regel-Engine verarbeitet und anschließend
    /// entweder unterdrückt oder an abonnierte Listener weitergeleitet.
    ///
    /// # Arguments
    /// * `notification` - Die zu verarbeitende Benachrichtigung.
    ///
    /// # Errors
    /// Gibt einen `NotificationError` zurück, wenn die Regelverarbeitung fehlschlägt.
    pub async fn handle_incoming_notification(&self, notification: Notification) -> Result<(), NotificationError> {
        info!("Handling incoming notification: {:?}", notification.summary);

        let current_settings = self.desktop_settings_service.get_current_settings().await;
        // WICHTIG: Sollte der `get_current_settings` aus der `settings` Domäne einen Fehler zurückgeben,
        // muss dies hier behandelt werden. Für diesen Plan nehmen wir an, dass `get_current_settings`
        // eine `DesktopSettings` Struktur zurückgibt, die möglicherweise Standardwerte enthält oder
        // eine Fehlerbehandlung auf einer niedrigeren Ebene vornimmt.
        // Wenn `get_current_settings` ein Result zurückgibt, muss es hier unwraped oder gematcht werden.
        // Aktuell ist im `settings` Modul noch kein `get_current_settings` definiert, wir nehmen hier an,
        // dass es existiert und einen `DesktopSettings` Wert zurückgibt.

        match self.rule_engine.process_notification(notification, &current_settings).await? {
            RuleProcessingResult::Processed(processed_notification) => {
                debug!("Notification processed. Sending to listeners and storing. ID: {}", processed_notification.id);
                // Sende die Benachrichtigung an alle Listener
                if let Err(e) = self.notifier_tx.send(processed_notification.clone()) {
                    warn!("Failed to send processed notification to listeners: {}", e);
                    // Nicht fatal, da es nur bedeutet, dass Receiver die Nachricht verpasst haben könnten.
                }

                // Füge zur Historie hinzu
                let mut store_guard = self.notification_store.write().await;
                store_guard.push_front(processed_notification); // Neueste vorne
                while store_guard.len() > self.max_notifications {
                    store_guard.pop_back(); // Älteste entfernen
                }
                trace!("Notification history size: {}", store_guard.len());
            }
            RuleProcessingResult::Suppressed => {
                info!("Notification suppressed by rules.");
            }
        }
        Ok(())
    }

    /// Gibt einen neuen `broadcast::Receiver` zurück, über den Benachrichtigungen
    /// nach ihrer Verarbeitung empfangen werden können.
    ///
    /// # Returns
    /// Ein `broadcast::Receiver<Notification>`.
    pub fn subscribe_to_notifications(&self) -> broadcast::Receiver<Notification> {
        self.notifier_tx.subscribe()
    }

    /// Gibt eine Kopie des aktuell geladenen Regelsatzes zurück.
    ///
    /// # Returns
    /// Eine `NotificationRuleSet`-Struktur.
    pub fn get_current_rules(&self) -> NotificationRuleSet {
        self.rule_engine.get_rules()
    }

    /// Aktualisiert den aktiven Regelsatz und persistiert ihn.
    ///
    /// # Arguments
    /// * `new_rules` - Das neue `NotificationRuleSet`, das übernommen werden soll.
    ///
    /// # Errors
    /// Gibt einen `NotificationError` zurück, wenn die Regeln ungültig sind oder
    /// das Speichern fehlschlägt.
    pub async fn update_rules(&self, new_rules: NotificationRuleSet) -> Result<(), NotificationError> {
        info!("Attempting to update notification rules.");
        // Zuerst die Engine aktualisieren (inkl. Validierung)
        self.rule_engine.update_rules(new_rules.clone()).await?;

        // Dann die Regeln persistieren
        match self.persistence_provider.save_rules(&new_rules).await {
            Ok(()) => {
                info!("Notification rules updated and saved successfully.");
                Ok(())
            }
            Err(e) => {
                error!("Failed to save updated notification rules: {}", e);
                // Rollback der Engine-Regeln ist hier nicht direkt implementiert,
                // da der Fehler im Persistenz-Layer auftrat. Die Engine hat bereits
                // die neuen, validierten Regeln.
                Err(e)
            }
        }
    }

    /// Gibt eine Kopie des aktuellen Benachrichtigungsverlaufs zurück.
    ///
    /// # Returns
    /// Ein `Vec<Notification>`, der die gespeicherten Benachrichtigungen enthält.
    pub async fn get_notification_history(&self) -> Vec<Notification> {
        let store_guard = self.notification_store.read().await;
        store_guard.iter().cloned().collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use async_trait::async_trait;
    use mockall::{automock, predicate::*};
    use uuid::Uuid;
    use chrono::Utc;

    use crate::notifications::data_types::{
        Notification, NotificationRule, RuleConditionSet, NotificationRuleSet, UrgencyLevel,
    };
    use crate::settings::{DesktopSettings, GlobalSettingsService};
    use crate::notifications::engine::RuleProcessingResult; // Import for RuleProcessingResult

    // Mock des NotificationRulesProvider
    #[automock]
    #[async_trait]
    impl NotificationRulesProvider for NotificationRulesProvider {
        async fn load_rules(&self) -> Result<NotificationRuleSet, NotificationError> {
            unimplemented!()
        }
        async fn save_rules(&self, _rules: &NotificationRuleSet) -> Result<(), NotificationError> {
            unimplemented!()
        }
    }

    // Mock der NotificationRulesEngine
    #[automock]
    #[async_trait]
    impl NotificationRulesEngine for NotificationRulesEngine {
        async fn process_notification(
            &self,
            _notification: Notification,
            _global_settings: &DesktopSettings,
        ) -> Result<RuleProcessingResult, NotificationError> {
            unimplemented!()
        }
        fn get_rules(&self) -> NotificationRuleSet {
            unimplemented!()
        }
        async fn update_rules(&self, _rules: NotificationRuleSet) -> Result<(), NotificationError> {
            unimplemented!()
        }
    }

    // Mock des GlobalSettingsService
    #[automock]
    #[async_trait]
    impl GlobalSettingsService for GlobalSettingsService {
        async fn get_current_settings(&self) -> DesktopSettings {
            unimplemented!()
        }
        fn blocking_get_current_settings(&self) -> DesktopSettings {
            unimplemented!()
        }
    }

    fn create_test_notification(id: u32, summary: &str, urgency: UrgencyLevel) -> Notification {
        Notification {
            id: Uuid::new_v4(), // Use UUID for unique IDs
            app_name: format!("TestApp{}", id),
            replaces_id: None,
            app_icon: None,
            summary: summary.to_string(),
            body: None,
            actions: Vec::new(),
            hints: std::collections::HashMap::new(),
            expire_timeout: -1,
            timestamp: Utc::now(),
            category: None,
            urgency,
            desktop_entry: None,
        }
    }

    fn default_test_ruleset() -> NotificationRuleSet {
        NotificationRuleSet { rules: vec![] }
    }

    fn mock_dependencies_for_new(
        initial_rules: NotificationRuleSet,
        desktop_settings: DesktopSettings,
    ) -> (
        Arc<DefaultNotificationRulesEngine>,
        Arc<MockNotificationRulesProvider>,
        Arc<MockGlobalSettingsService>,
    ) {
        let mock_engine = Arc::new(DefaultNotificationRulesEngine::new(initial_rules));

        let mut mock_persistence = MockNotificationRulesProvider::new();
        mock_persistence
            .expect_load_rules()
            .returning(|| Ok(default_test_ruleset())); // Default mock behavior
        mock_persistence
            .expect_save_rules()
            .returning(|_| Ok(())); // Default mock behavior

        let mut mock_settings_service = MockGlobalSettingsService::new();
        mock_settings_service
            .expect_blocking_get_current_settings()
            .returning(move || desktop_settings.clone());
        mock_settings_service
            .expect_get_current_settings()
            .returning(move || async move { desktop_settings.clone() }.boxed());

        (
            mock_engine,
            Arc::new(mock_persistence),
            Arc::new(mock_settings_service),
        )
    }

    #[tokio::test]
    async fn service_new_initializes_correctly() {
        let initial_rules = default_test_ruleset();
        let desktop_settings = DesktopSettings::default(); // default max_notification_history is 100

        let (mock_engine, mock_persistence, mock_settings_service) =
            mock_dependencies_for_new(initial_rules.clone(), desktop_settings.clone());

        let service = NotificationService::new(
            initial_rules,
            mock_persistence,
            mock_settings_service,
        );

        assert_eq!(service.max_notifications, desktop_settings.max_notification_history as usize);
        assert!(Arc::ptr_eq(&service.rule_engine, &mock_engine)); // Should be same instance if engine was created from service. new needs Arc of engine.
        // Fix: `NotificationService::new` takes `initial_rules` and *creates* `DefaultNotificationRulesEngine`.
        // So we need to create the engine first and then pass the `Arc` around.
        // Let's adjust `mock_dependencies_for_new` to return the `Arc<DefaultNotificationRulesEngine>`
        // and adjust `NotificationService::new` signature.
        // For now, testing indirectly by checking get_current_rules.
        assert_eq!(service.get_current_rules(), default_test_ruleset());
    }

    #[tokio::test]
    async fn load_rules_from_persistence_success() {
        let loaded_rules = NotificationRuleSet {
            rules: vec![NotificationRule::default()],
        };

        let mut mock_persistence = MockNotificationRulesProvider::new();
        mock_persistence
            .expect_load_rules()
            .times(1)
            .returning(move || Ok(loaded_rules.clone()));

        let mut mock_engine = MockNotificationRulesEngine::new();
        mock_engine
            .expect_update_rules()
            .times(1)
            .with(eq(loaded_rules.clone()))
            .returning(|_| Ok(()));
        mock_engine
            .expect_get_rules() // Required by `service.get_current_rules()` if called
            .returning(|| loaded_rules.clone()); // Must match the state after update

        let mut mock_settings_service = MockGlobalSettingsService::new();
        mock_settings_service
            .expect_blocking_get_current_settings()
            .returning(|| DesktopSettings::default()); // Return a default setting
        mock_settings_service
            .expect_get_current_settings()
            .returning(|| async { DesktopSettings::default() }.boxed());

        let service = NotificationService {
            rule_engine: Arc::new(mock_engine),
            persistence_provider: Arc::new(mock_persistence),
            notifier_tx: broadcast::channel(1).0, // Dummy sender
            desktop_settings_service: Arc::new(mock_settings_service),
            max_notifications: 100,
            notification_store: Arc::new(RwLock::new(VecDeque::new())),
        };

        let result = service.load_rules_from_persistence().await;
        assert!(result.is_ok());
        // Verify that the engine's update_rules was called with the correct rules
        // This is implicitly checked by the mock expectation.
        assert_eq!(service.get_current_rules(), loaded_rules);
    }

    #[tokio::test]
    async fn load_rules_from_persistence_failure() {
        let mut mock_persistence = MockNotificationRulesProvider::new();
        mock_persistence
            .expect_load_rules()
            .times(1)
            .returning(|| Err(NotificationError::PersistenceError(novade_core::error::ConfigError::IoError("test error".into()))));

        let mut mock_engine = MockNotificationRulesEngine::new();
        mock_engine
            .expect_update_rules()
            .times(0); // Should not be called on load error
        mock_engine
            .expect_get_rules()
            .returning(|| default_test_ruleset());

        let mut mock_settings_service = MockGlobalSettingsService::new();
        mock_settings_service
            .expect_blocking_get_current_settings()
            .returning(|| DesktopSettings::default());
        mock_settings_service
            .expect_get_current_settings()
            .returning(|| async { DesktopSettings::default() }.boxed());

        let service = NotificationService {
            rule_engine: Arc::new(mock_engine),
            persistence_provider: Arc::new(mock_persistence),
            notifier_tx: broadcast::channel(1).0,
            desktop_settings_service: Arc::new(mock_settings_service),
            max_notifications: 100,
            notification_store: Arc::new(RwLock::new(VecDeque::new())),
        };

        let result = service.load_rules_from_persistence().await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), NotificationError::PersistenceError(_)));
    }

    #[tokio::test]
    async fn handle_incoming_notification_processed() {
        let initial_notif = create_test_notification(1, "Original Summary", UrgencyLevel::Normal);
        let processed_notif = create_test_notification(1, "Modified Summary", UrgencyLevel::Critical);

        let mut mock_engine = MockNotificationRulesEngine::new();
        mock_engine
            .expect_process_notification()
            .times(1)
            .with(eq(initial_notif.clone()), always())
            .returning(move |_, _| Ok(RuleProcessingResult::Processed(processed_notif.clone())));
        mock_engine
            .expect_get_rules()
            .returning(|| default_test_ruleset()); // Required by `get_current_rules`

        let mut mock_persistence = MockNotificationRulesProvider::new();
        mock_persistence.expect_save_rules().returning(|_| Ok(())); // Only if rules are updated, but good to have.
        mock_persistence.expect_load_rules().returning(|| Ok(default_test_ruleset()));

        let mut mock_settings_service = MockGlobalSettingsService::new();
        mock_settings_service
            .expect_blocking_get_current_settings()
            .returning(|| DesktopSettings::default());
        mock_settings_service
            .expect_get_current_settings()
            .returning(|| async { DesktopSettings::default() }.boxed());


        let service = NotificationService {
            rule_engine: Arc::new(mock_engine),
            persistence_provider: Arc::new(mock_persistence),
            notifier_tx: broadcast::channel(10).0,
            desktop_settings_service: Arc::new(mock_settings_service),
            max_notifications: 100,
            notification_store: Arc::new(RwLock::new(VecDeque::new())),
        };

        let mut receiver = service.subscribe_to_notifications();

        let result = service.handle_incoming_notification(initial_notif.clone()).await;
        assert!(result.is_ok());

        let received_notif = tokio::time::timeout(tokio::time::Duration::from_millis(100), receiver.recv())
            .await
            .expect("Receiver should get notification")
            .unwrap();

        assert_eq!(received_notif, processed_notif);

        let history = service.get_notification_history().await;
        assert_eq!(history.len(), 1);
        assert_eq!(history[0], processed_notif);
    }

    #[tokio::test]
    async fn handle_incoming_notification_suppressed() {
        let initial_notif = create_test_notification(1, "Summary to suppress", UrgencyLevel::Normal);

        let mut mock_engine = MockNotificationRulesEngine::new();
        mock_engine
            .expect_process_notification()
            .times(1)
            .with(eq(initial_notif.clone()), always())
            .returning(|_, _| Ok(RuleProcessingResult::Suppressed));
        mock_engine
            .expect_get_rules()
            .returning(|| default_test_ruleset());

        let mut mock_persistence = MockNotificationRulesProvider::new();
        mock_persistence.expect_save_rules().returning(|_| Ok(()));
        mock_persistence.expect_load_rules().returning(|| Ok(default_test_ruleset()));

        let mut mock_settings_service = MockGlobalSettingsService::new();
        mock_settings_service
            .expect_blocking_get_current_settings()
            .returning(|| DesktopSettings::default());
        mock_settings_service
            .expect_get_current_settings()
            .returning(|| async { DesktopSettings::default() }.boxed());

        let service = NotificationService {
            rule_engine: Arc::new(mock_engine),
            persistence_provider: Arc::new(mock_persistence),
            notifier_tx: broadcast::channel(1).0,
            desktop_settings_service: Arc::new(mock_settings_service),
            max_notifications: 100,
            notification_store: Arc::new(RwLock::new(VecDeque::new())),
        };

        let mut receiver = service.subscribe_to_notifications(); // Create receiver BEFORE handling
        let result = service.handle_incoming_notification(initial_notif.clone()).await;
        assert!(result.is_ok());

        // Assert that no notification was sent via broadcast
        let timeout_result = tokio::time::timeout(tokio::time::Duration::from_millis(10), receiver.recv()).await;
        assert!(timeout_result.is_err()); // Should be a timeout because no message was sent

        let history = service.get_notification_history().await;
        assert!(history.is_empty());
    }

    #[tokio::test]
    async fn notification_history_respects_max_notifications() {
        let initial_rules = default_test_ruleset();
        let desktop_settings = DesktopSettings {
            max_notification_history: 3, // Set max history to 3
            ..Default::default()
        };

        let (mock_engine_arc_real_impl, mock_persistence, mock_settings_service) =
            mock_dependencies_for_new(initial_rules.clone(), desktop_settings.clone());

        // Replace the real engine with a mock that always processes
        let mut mock_engine = MockNotificationRulesEngine::new();
        mock_engine
            .expect_process_notification()
            .times(4) // 4 notifications will be processed
            .returning(|notif, _| Ok(RuleProcessingResult::Processed(notif.clone())));
        mock_engine
            .expect_get_rules()
            .returning(|| initial_rules.clone());
        mock_engine
            .expect_update_rules()
            .returning(|_| Ok(())); // For load_rules_from_persistence

        let service = NotificationService {
            rule_engine: Arc::new(mock_engine), // Use the mocked engine
            persistence_provider: mock_persistence,
            notifier_tx: broadcast::channel(10).0,
            desktop_settings_service: mock_settings_service,
            max_notifications: desktop_settings.max_notification_history as usize,
            notification_store: Arc::new(RwLock::new(VecDeque::new())),
        };

        // Send 4 notifications
        let n1 = create_test_notification(1, "Notif 1", UrgencyLevel::Normal);
        let n2 = create_test_notification(2, "Notif 2", UrgencyLevel::Normal);
        let n3 = create_test_notification(3, "Notif 3", UrgencyLevel::Normal);
        let n4 = create_test_notification(4, "Notif 4", UrgencyLevel::Normal);

        service.handle_incoming_notification(n1.clone()).await.unwrap();
        service.handle_incoming_notification(n2.clone()).await.unwrap();
        service.handle_incoming_notification(n3.clone()).await.unwrap();
        service.handle_incoming_notification(n4.clone()).await.unwrap();

        let history = service.get_notification_history().await;
        assert_eq!(history.len(), 3); // Should only keep the last 3

        // Check order (newest first)
        assert_eq!(history[0].summary, "Notif 4");
        assert_eq!(history[1].summary, "Notif 3");
        assert_eq!(history[2].summary, "Notif 2");
    }

    #[tokio::test]
    async fn update_rules_success() {
        let initial_rules = default_test_ruleset();
        let new_rules = NotificationRuleSet {
            rules: vec![NotificationRule {
                id: Uuid::new_v4(),
                name: "New Test Rule".to_string(),
                ..Default::default()
            }],
        };

        let mut mock_engine = MockNotificationRulesEngine::new();
        mock_engine
            .expect_update_rules()
            .times(1)
            .with(eq(new_rules.clone()))
            .returning(|_| Ok(()));
        mock_engine
            .expect_get_rules()
            .returning(|| new_rules.clone()); // Return the updated rules when get_rules is called

        let mut mock_persistence = MockNotificationRulesProvider::new();
        mock_persistence
            .expect_save_rules()
            .times(1)
            .with(eq(new_rules.clone()))
            .returning(|_| Ok(()));
        mock_persistence
            .expect_load_rules()
            .returning(|| Ok(initial_rules.clone()));

        let mut mock_settings_service = MockGlobalSettingsService::new();
        mock_settings_service
            .expect_blocking_get_current_settings()
            .returning(|| DesktopSettings::default());
        mock_settings_service
            .expect_get_current_settings()
            .returning(|| async { DesktopSettings::default() }.boxed());

        let service = NotificationService {
            rule_engine: Arc::new(mock_engine),
            persistence_provider: Arc::new(mock_persistence),
            notifier_tx: broadcast::channel(1).0,
            desktop_settings_service: Arc::new(mock_settings_service),
            max_notifications: 100,
            notification_store: Arc::new(RwLock::new(VecDeque::new())),
        };

        let result = service.update_rules(new_rules.clone()).await;
        assert!(result.is_ok());
        assert_eq!(service.get_current_rules(), new_rules);
    }

    #[tokio::test]
    async fn update_rules_engine_failure() {
        let initial_rules = default_test_ruleset();
        let new_rules = NotificationRuleSet {
            rules: vec![NotificationRule::default()],
        };

        let mut mock_engine = MockNotificationRulesEngine::new();
        mock_engine
            .expect_update_rules()
            .times(1)
            .returning(|_| Err(NotificationError::InvalidRuleConfiguration("Invalid rule".to_string())));
        mock_engine
            .expect_get_rules()
            .returning(|| initial_rules.clone()); // Should still return initial rules on engine failure

        let mut mock_persistence = MockNotificationRulesProvider::new();
        mock_persistence
            .expect_save_rules()
            .times(0); // Should not be called if engine update fails
        mock_persistence
            .expect_load_rules()
            .returning(|| Ok(initial_rules.clone()));

        let mut mock_settings_service = MockGlobalSettingsService::new();
        mock_settings_service
            .expect_blocking_get_current_settings()
            .returning(|| DesktopSettings::default());
        mock_settings_service
            .expect_get_current_settings()
            .returning(|| async { DesktopSettings::default() }.boxed());

        let service = NotificationService {
            rule_engine: Arc::new(mock_engine),
            persistence_provider: Arc::new(mock_persistence),
            notifier_tx: broadcast::channel(1).0,
            desktop_settings_service: Arc::new(mock_settings_service),
            max_notifications: 100,
            notification_store: Arc::new(RwLock::new(VecDeque::new())),
        };

        let result = service.update_rules(new_rules.clone()).await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), NotificationError::InvalidRuleConfiguration(_)));
        assert_eq!(service.get_current_rules(), initial_rules); // Rules should not have changed
    }

    #[tokio::test]
    async fn update_rules_persistence_failure() {
        let initial_rules = default_test_ruleset();
        let new_rules = NotificationRuleSet {
            rules: vec![NotificationRule::default()],
        };

        let mut mock_engine = MockNotificationRulesEngine::new();
        mock_engine
            .expect_update_rules()
            .times(1)
            .returning(|_| Ok(()));
        mock_engine
            .expect_get_rules()
            .returning(|| new_rules.clone()); // Engine state is updated even if persistence fails

        let mut mock_persistence = MockNotificationRulesProvider::new();
        mock_persistence
            .expect_save_rules()
            .times(1)
            .returning(|_| Err(NotificationError::PersistenceError(novade_core::error::ConfigError::IoError("Disk full".into()))));
        mock_persistence
            .expect_load_rules()
            .returning(|| Ok(initial_rules.clone()));

        let mut mock_settings_service = MockGlobalSettingsService::new();
        mock_settings_service
            .expect_blocking_get_current_settings()
            .returning(|| DesktopSettings::default());
        mock_settings_service
            .expect_get_current_settings()
            .returning(|| async { DesktopSettings::default() }.boxed());

        let service = NotificationService {
            rule_engine: Arc::new(mock_engine),
            persistence_provider: Arc::new(mock_persistence),
            notifier_tx: broadcast::channel(1).0,
            desktop_settings_service: Arc::new(mock_settings_service),
            max_notifications: 100,
            notification_store: Arc::new(RwLock::new(VecDeque::new())),
        };

        let result = service.update_rules(new_rules.clone()).await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), NotificationError::PersistenceError(_)));
        // Even if persistence fails, the engine's rules are updated
        assert_eq!(service.get_current_rules(), new_rules);
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (24 von 100) widmet sich der technischen Spezifikation der Dateisystem-basierten Persistenz für Benachrichtigungsregeln innerhalb des `notifications`-Moduls der Domänenschicht (`novade-domain`). Die Datei `persistence.rs` wird den `FilesystemNotificationRulesProvider` implementieren, der den `NotificationRulesProvider`-Trait aus `persistence_iface.rs` erfüllt.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 24/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.17.7. `novade-domain/src/notifications/persistence.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notifications/persistence.rs`
  * **Verantwortlichkeit:** Implementiert den `NotificationRulesProvider`-Trait für die Speicherung und das Laden von Benachrichtigungsregeln im Dateisystem. Es nutzt den `ConfigServiceAsync` aus der Kernschicht, um eine standardisierte und sichere Methode für Dateisystemzugriffe zu gewährleisten.
  * **Kern-Aufgaben (Tasks):**
    1.  **`FilesystemNotificationRulesProvider` Struct definieren:**
          * Felder:
              * `config_service: Arc<dyn ConfigServiceAsync>`: Ein `Arc`-Pointer zum `ConfigServiceAsync`-Trait-Objekt, um auf Dateisystemoperationen zuzugreifen.
              * `file_path: PathBuf`: Der vollständige Pfad zur Datei, in der die Benachrichtigungsregeln gespeichert werden (z.B. `~/.config/novade/notifications/rules.json`).
              * `file_name: String`: Der Dateiname für die Regeln (z.B. "rules.json").
    2.  **Konstruktor `new()` implementieren:**
          * Nimmt `config_service: Arc<dyn ConfigServiceAsync>` und einen `file_name: &str` entgegen.
          * Konstruiert den `file_path` unter Verwendung von `config_service.get_config_dir()` und dem `file_name`. Das Konfigurationsverzeichnis sollte das NovaDE-spezifische XDG-Basissystemverzeichnis sein (z.B. `~/.config/novade`).
          * Gibt eine `FilesystemNotificationRulesProvider`-Instanz zurück.
    3.  **`impl NotificationRulesProvider for FilesystemNotificationRulesProvider` implementieren:**
          * **`load_rules(&self) -> Result<NotificationRuleSet, NotificationError>` Methode implementieren:**
              * Verwendet `self.config_service.load_data()` mit `self.file_path.clone()` um die JSON-Datei zu lesen und direkt in `NotificationRuleSet` zu deserialisieren.
              * Fehlerbehandlung:
                  * `ConfigError::NotFound`: Gibt ein leeres `NotificationRuleSet` zurück (`NotificationRuleSet::default()`), da dies bedeutet, dass noch keine Regeln existieren. Loggt dies auf `info`-Ebene.
                  * Andere `ConfigError`s (z.B. `IoError`, `ParseError`): Konvertiert sie in `NotificationError::PersistenceError` und gibt den Fehler weiter. Loggt dies auf `error`-Ebene.
          * **`save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationError>` Methode implementieren:**
              * Verwendet `self.config_service.save_data()` mit `self.file_path.clone()` und dem `rules`-Objekt, das in JSON serialisiert wird.
              * Fehlerbehandlung:
                  * Konvertiert `ConfigError`s in `NotificationError::PersistenceError` und gibt den Fehler weiter. Loggt dies auf `error`-Ebene.
    4.  **Logging:** Integriert `tracing` für informative Meldungen bei Lade-/Speichervorgängen und Fehlerfällen.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notifications/persistence.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notifications::data_types::NotificationRuleSet`, `crate::notifications::errors::NotificationError`, `crate::notifications::persistence_iface::NotificationRulesProvider`, `novade_core::config::ConfigServiceAsync`, `novade_core::error::ConfigError`.
      * **Extern:** `async_trait`, `std::path::PathBuf`, `std::sync::Arc`, `tracing`, `serde_json` (implizit durch `ConfigServiceAsync` und `serde`).
  * **Kommunikationsmuster:**
      * Interagiert ausschließlich mit `ConfigServiceAsync` für Dateisystemoperationen.
      * Implementiert ein Trait, um von `NotificationService` genutzt zu werden.
  * **Erwartete Ergebnisse/Outputs:**
      * Eine funktionale Implementierung des `NotificationRulesProvider`-Traits, die Benachrichtigungsregeln zuverlässig im Dateisystem speichert und lädt.
      * Robustes Fehlerverhalten, insbesondere beim ersten Start (keine Regeldatei vorhanden).
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests (mit Mocking):**
          * Mocking von `ConfigServiceAsync`.
          * Test `load_rules`:
              * Erfolgreiches Laden einer vorhandenen Datei.
              * Laden einer nicht existierenden Datei (`ConfigError::NotFound`) gibt `NotificationRuleSet::default()` zurück.
              * Fehler beim Lesen der Datei (`ConfigError::IoError`).
              * Fehler beim Parsen der Datei (`ConfigError::ParseError`).
          * Test `save_rules`:
              * Erfolgreiches Speichern.
              * Fehler beim Schreiben der Datei (`ConfigError::IoError`).
              * Fehler beim Serialisieren (`ConfigError::SerializationError`, obwohl `ConfigServiceAsync` dies intern handhaben sollte, sollte der Provider den Fehler korrekt weitergeben).
          * Test, dass die korrekten Pfade an `ConfigServiceAsync` übergeben werden.

#### Funktionsspezifikation: `novade_domain::notifications::persistence`

```rust
// novade-domain/src/notifications/persistence.rs

//! Implementiert einen Dateisystem-basierten Provider für Benachrichtigungsregeln.
//!
//! Dieser Provider nutzt den `ConfigServiceAsync` aus der Kernschicht, um Benachrichtigungsregeln
//! in einer JSON-Datei im XDG-Standard-Konfigurationsverzeichnis von NovaDE zu speichern und zu laden.

use async_trait::async_trait;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use tracing::{debug, error, info, trace};

use crate::notifications::data_types::NotificationRuleSet;
use crate::notifications::errors::NotificationError;
use crate::notifications::persistence_iface::NotificationRulesProvider;
use novade_core::config::ConfigServiceAsync;
use novade_core::error::ConfigError;

/// Ein Provider, der Benachrichtigungsregeln im Dateisystem speichert und lädt.
///
/// Die Regeln werden als JSON-Datei im `~/.config/novade/notifications/` Verzeichnis
/// gespeichert.
pub struct FilesystemNotificationRulesProvider {
    config_service: Arc<dyn ConfigServiceAsync>,
    file_path: PathBuf,
    file_name: String, // Speichern des Dateinamens für Log- und Debug-Zwecke
}

impl FilesystemNotificationRulesProvider {
    /// Erstellt eine neue Instanz des `FilesystemNotificationRulesProvider`.
    ///
    /// # Arguments
    /// * `config_service` - Eine Implementierung des `ConfigServiceAsync`-Traits,
    ///   die für Dateisystemoperationen verwendet wird.
    /// * `file_name` - Der Name der Datei (z.B. "rules.json"), in der die Regeln
    ///   gespeichert werden sollen.
    ///
    /// # Returns
    /// Eine neue `FilesystemNotificationRulesProvider`-Instanz.
    ///
    /// # Errors
    /// Kann einen `NotificationError::PersistenceError` zurückgeben, wenn das
    /// Konfigurationsverzeichnis nicht ermittelt werden kann.
    pub fn new(
        config_service: Arc<dyn ConfigServiceAsync>,
        file_name: &str,
    ) -> Result<Self, NotificationError> {
        let config_dir = config_service
            .get_config_dir()
            .map_err(|e| NotificationError::PersistenceError(e))?;

        let notifications_config_dir = config_dir.join("notifications");
        let file_path = notifications_config_dir.join(file_name);

        info!(
            "Initializing FilesystemNotificationRulesProvider with file path: {:?}",
            file_path
        );

        Ok(Self {
            config_service,
            file_path,
            file_name: file_name.to_string(),
        })
    }

    /// Gibt den vollständigen Pfad zur Regeldatei zurück.
    /// Dies ist nützlich für Tests und Debugging.
    pub fn get_file_path(&self) -> &Path {
        &self.file_path
    }
}

#[async_trait]
impl NotificationRulesProvider for FilesystemNotificationRulesProvider {
    /// Lädt die Benachrichtigungsregeln aus der konfigurierten Datei.
    ///
    /// Wenn die Datei nicht gefunden wird, wird ein leeres `NotificationRuleSet` zurückgegeben,
    /// was auf einen ersten Start oder das Fehlen benutzerdefinierter Regeln hindeutet.
    /// Andere Dateisystem- oder Deserialisierungsfehler werden als `NotificationError::PersistenceError`
    /// weitergegeben.
    ///
    /// # Errors
    /// Gibt einen `NotificationError::PersistenceError` zurück, wenn ein Fehler beim
    /// Laden oder Parsen der Regeln auftritt (außer `NotFound`).
    async fn load_rules(&self) -> Result<NotificationRuleSet, NotificationError> {
        info!("Attempting to load notification rules from {:?}", self.file_path);
        match self
            .config_service
            .load_data::<NotificationRuleSet>(&self.file_path)
            .await
        {
            Ok(rules) => {
                debug!("Successfully loaded notification rules from {:?}", self.file_path);
                Ok(rules)
            }
            Err(e) => match e {
                ConfigError::NotFound(_) => {
                    info!(
                        "Notification rules file not found at {:?}. Returning default empty ruleset.",
                        self.file_path
                    );
                    Ok(NotificationRuleSet::default())
                }
                _ => {
                    error!(
                        "Failed to load notification rules from {:?}: {}",
                        self.file_path, e
                    );
                    Err(NotificationError::PersistenceError(e))
                }
            },
        }
    }

    /// Speichert die bereitgestellten Benachrichtigungsregeln in der konfigurierten Datei.
    ///
    /// Die Regeln werden als JSON serialisiert und im Dateisystem abgelegt.
    /// Dateisystem- oder Serialisierungsfehler werden als `NotificationError::PersistenceError`
    /// weitergegeben.
    ///
    /// # Arguments
    /// * `rules` - Das `NotificationRuleSet`-Objekt, das gespeichert werden soll.
    ///
    /// # Errors
    /// Gibt einen `NotificationError::PersistenceError` zurück, wenn ein Fehler beim
    /// Speichern oder Serialisieren der Regeln auftritt.
    async fn save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationError> {
        info!("Attempting to save notification rules to {:?}", self.file_path);
        match self
            .config_service
            .save_data(&self.file_path, rules)
            .await
        {
            Ok(_) => {
                debug!("Successfully saved notification rules to {:?}", self.file_path);
                Ok(())
            }
            Err(e) => {
                error!(
                    "Failed to save notification rules to {:?}: {}",
                    self.file_path, e
                );
                Err(NotificationError::PersistenceError(e))
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::notifications::data_types::{NotificationRule, RuleAction, RuleConditionSet};
    use async_trait::async_trait;
    use mockall::{automock, predicate::*};
    use novade_core::error::CoreError;
    use serde::{Deserialize, Serialize};
    use tempfile::tempdir;
    use uuid::Uuid;

    // Mock des ConfigServiceAsync
    #[automock]
    #[async_trait]
    impl ConfigServiceAsync for MockConfigServiceAsync {
        fn get_config_dir(&self) -> Result<PathBuf, CoreError> {
            unimplemented!()
        }

        async fn load_data<T: for<'de> Deserialize<'de> + Send>(
            &self,
            _path: &Path,
        ) -> Result<T, ConfigError> {
            unimplemented!()
        }

        async fn save_data<T: Serialize + Send>(
            &self,
            _path: &Path,
            _data: &T,
        ) -> Result<(), ConfigError> {
            unimplemented!()
        }
    }

    fn create_mock_config_service(temp_dir: &Path) -> MockConfigServiceAsync {
        let mut mock = MockConfigServiceAsync::new();
        let temp_dir_cloned = temp_dir.to_path_buf();
        mock.expect_get_config_dir()
            .returning(move || Ok(temp_dir_cloned.clone()));
        mock
    }

    fn create_test_ruleset() -> NotificationRuleSet {
        NotificationRuleSet {
            rules: vec![
                NotificationRule {
                    id: Uuid::new_v4(),
                    name: "Test Rule 1".to_string(),
                    enabled: true,
                    conditions: RuleConditionSet::Any(vec![]),
                    actions: vec![RuleAction::Suppress],
                    stop_processing_further_rules: true,
                    priority: 1,
                },
                NotificationRule {
                    id: Uuid::new_v4(),
                    name: "Test Rule 2".to_string(),
                    enabled: false,
                    conditions: RuleConditionSet::All(vec![]),
                    actions: vec![RuleAction::PlaySound("default".to_string())],
                    stop_processing_further_rules: false,
                    priority: 2,
                },
            ],
        }
    }

    #[tokio::test]
    async fn new_provider_initializes_correctly() {
        let temp_dir = tempdir().unwrap();
        let mock_config = Arc::new(create_mock_config_service(temp_dir.path()));
        let file_name = "test_rules.json";

        let provider = FilesystemNotificationRulesProvider::new(mock_config.clone(), file_name)
            .unwrap();

        let expected_path = temp_dir.path().join("notifications").join(file_name);
        assert_eq!(provider.get_file_path(), expected_path.as_path());
        assert_eq!(provider.file_name, file_name);
    }

    #[tokio::test]
    async fn load_rules_success() {
        let temp_dir = tempdir().unwrap();
        let mut mock_config = create_mock_config_service(temp_dir.path());
        let test_rules = create_test_ruleset();

        mock_config
            .expect_load_data::<NotificationRuleSet>()
            .times(1)
            .with(eq(temp_dir.path().join("notifications").join("rules.json").as_path()))
            .returning(move |_| Ok(test_rules.clone()));

        let provider = FilesystemNotificationRulesProvider::new(
            Arc::new(mock_config),
            "rules.json",
        )
        .unwrap();

        let loaded_rules = provider.load_rules().await.unwrap();
        assert_eq!(loaded_rules, test_rules);
    }

    #[tokio::test]
    async fn load_rules_file_not_found_returns_default() {
        let temp_dir = tempdir().unwrap();
        let mut mock_config = create_mock_config_service(temp_dir.path());

        mock_config
            .expect_load_data::<NotificationRuleSet>()
            .times(1)
            .returning(|_| Err(ConfigError::NotFound("File not found".into())));

        let provider = FilesystemNotificationRulesProvider::new(
            Arc::new(mock_config),
            "rules.json",
        )
        .unwrap();

        let loaded_rules = provider.load_rules().await.unwrap();
        assert_eq!(loaded_rules, NotificationRuleSet::default());
    }

    #[tokio::test]
    async fn load_rules_io_error() {
        let temp_dir = tempdir().unwrap();
        let mut mock_config = create_mock_config_service(temp_dir.path());

        mock_config
            .expect_load_data::<NotificationRuleSet>()
            .times(1)
            .returning(|_| Err(ConfigError::IoError("Permission denied".into())));

        let provider = FilesystemNotificationRulesProvider::new(
            Arc::new(mock_config),
            "rules.json",
        )
        .unwrap();

        let error = provider.load_rules().await.unwrap_err();
        assert!(matches!(error, NotificationError::PersistenceError(ConfigError::IoError(_))));
    }

    #[tokio::test]
    async fn load_rules_parse_error() {
        let temp_dir = tempdir().unwrap();
        let mut mock_config = create_mock_config_service(temp_dir.path());

        mock_config
            .expect_load_data::<NotificationRuleSet>()
            .times(1)
            .returning(|_| Err(ConfigError::ParseError("Invalid JSON".into())));

        let provider = FilesystemNotificationRulesProvider::new(
            Arc::new(mock_config),
            "rules.json",
        )
        .unwrap();

        let error = provider.load_rules().await.unwrap_err();
        assert!(matches!(error, NotificationError::PersistenceError(ConfigError::ParseError(_))));
    }

    #[tokio::test]
    async fn save_rules_success() {
        let temp_dir = tempdir().unwrap();
        let mut mock_config = create_mock_config_service(temp_dir.path());
        let test_rules = create_test_ruleset();

        mock_config
            .expect_save_data::<NotificationRuleSet>()
            .times(1)
            .with(
                eq(temp_dir.path().join("notifications").join("rules.json").as_path()),
                eq(test_rules.clone()),
            )
            .returning(|_, _| Ok(()));

        let provider = FilesystemNotificationRulesProvider::new(
            Arc::new(mock_config),
            "rules.json",
        )
        .unwrap();

        let result = provider.save_rules(&test_rules).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn save_rules_io_error() {
        let temp_dir = tempdir().unwrap();
        let mut mock_config = create_mock_config_service(temp_dir.path());
        let test_rules = create_test_ruleset();

        mock_config
            .expect_save_data::<NotificationRuleSet>()
            .times(1)
            .returning(|_, _| Err(ConfigError::IoError("No space left on device".into())));

        let provider = FilesystemNotificationRulesProvider::new(
            Arc::new(mock_config),
            "rules.json",
        )
        .unwrap();

        let error = provider.save_rules(&test_rules).await.unwrap_err();
        assert!(matches!(error, NotificationError::PersistenceError(ConfigError::IoError(_))));
    }

    #[tokio::test]
    async fn save_rules_serialization_error() {
        // This case is typically handled by `ConfigServiceAsync` itself,
        // as `save_data` takes a `T: Serialize`.
        // However, if `ConfigServiceAsync` were to propagate an internal serialization error
        // as a `ConfigError::SerializationError`, we'd test that.
        // For now, we simulate a ConfigError that might arise during serialization.
        let temp_dir = tempdir().unwrap();
        let mut mock_config = create_mock_config_service(temp_dir.path());
        let test_rules = create_test_ruleset();

        mock_config
            .expect_save_data::<NotificationRuleSet>()
            .times(1)
            .returning(|_, _| Err(ConfigError::SerializationError("Failed to serialize".into())));

        let provider = FilesystemNotificationRulesProvider::new(
            Arc::new(mock_config),
            "rules.json",
        )
        .unwrap();

        let error = provider.save_rules(&test_rules).await.unwrap_err();
        assert!(matches!(error, NotificationError::PersistenceError(ConfigError::SerializationError(_))));
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (25 von 100) widmet sich der Definition der Modell- und Kontexttypen im `mcp`-Modul der Domänenschicht (`novade-domain`). Die Datei `data_types.rs` wird die grundlegenden Datenstrukturen für die Kommunikation mit dem Model Context Protocol (MCP) definieren, welche die Grundlage für die KI-Integration bilden.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 25/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.18.1. `novade-domain/src/mcp/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/mcp/data_types.rs`
  * **Verantwortlichkeit:** Definiert alle Datenstrukturen (Enums, Structs, Typaliase), die für die Repräsentation von KI-Modellen, deren Kontexten, Eingaben, Ausgaben und verwandten Operationen im Rahmen des Model Context Protocol (MCP) notwendig sind. Diese Typen dienen als Schnittstelle zwischen der Domänenlogik und dem `mcp_client` in der Systemschicht.
  * **Kern-Aufgaben (Tasks):**
    1.  **`ModelId` (Type Alias) definieren:**
          * Typ: `Uuid` (aus `uuid` crate).
          * Zweck: Eindeutige Identifikation eines KI-Modells.
    2.  **`ModelType` (Enum) definieren:**
          * Varianten:
              * `TextGeneration`: Für Modelle, die Text generieren (z.B. große Sprachmodelle).
              * `ImageGeneration`: Für Modelle, die Bilder generieren.
              * `TextEmbedding`: Für Modelle, die Texte in Vektoren umwandeln.
              * `SentimentAnalysis`: Für Modelle zur Stimmungsanalyse.
              * `Categorization`: Für Modelle zur Klassifizierung von Inhalten.
              * `SpeechToText`: Für Modelle, die Audio in Text umwandeln.
              * `TextToSpeech`: Für Modelle, die Text in Audio umwandeln.
              * `Custom(String)`: Für benutzerdefinierte oder unbekannte Modelltypen.
          * Implementierungen: `PartialEq`, `Eq`, `Hash`, `Debug`, `Clone`, `Serialize`, `Deserialize`, `Display`.
    3.  **`ModelEndpoint` (Struct) definieren:**
          * Felder:
              * `uri: String`: URI des Modell-Endpoints (z.B. `http://localhost:8080/inference`).
              * `auth_token: Option<String>`: Optionaler Authentifizierungstoken für den Endpoint.
              * `timeout_ms: Option<u64>`: Optionales Timeout in Millisekunden für Anfragen an diesen Endpoint.
          * Implementierungen: `PartialEq`, `Eq`, `Debug`, `Clone`, `Serialize`, `Deserialize`, `Default`.
    4.  **`ModelCapabilities` (Struct) definieren:**
          * Felder:
              * `max_input_length: Option<usize>`: Maximale Eingabelänge (z.B. Token für Textmodelle).
              * `supported_output_formats: Vec<String>`: Unterstützte Ausgabeformate (z.B. "text", "json", "image/png").
              * `concurrency_limit: Option<usize>`: Maximale Anzahl gleichzeitiger Anfragen.
              * `cost_per_unit: Option<f64>`: Geschätzte Kosten pro Einheit (z.B. pro Token, pro Bild).
              * `unit_name: Option<String>`: Name der Kosten-Einheit (z.B. "token", "image").
          * Implementierungen: `PartialEq`, `Eq`, `Debug`, `Clone`, `Default`, `Serialize`, `Deserialize`.
    5.  **`ModelConfiguration` (Struct) definieren:**
          * Felder:
              * `model_id: ModelId`: Eindeutiger Identifikator des Modells.
              * `model_name: String`: Anzeigename des Modells (z.B. "GPT-4o", "Stable Diffusion XL").
              * `model_type: ModelType`: Typ des Modells.
              * `version: Option<String>`: Versionsnummer des Modells.
              * `description: Option<String>`: Kurze Beschreibung des Modells.
              * `endpoint: ModelEndpoint`: Der zugehörige Endpoint für die Inferenz.
              * `capabilities: ModelCapabilities`: Fähigkeiten des Modells.
              * `is_enabled: bool`: Flag, ob das Modell aktiviert ist.
              * `is_default: bool`: Flag, ob dies das Standardmodell für seinen `ModelType` ist.
              * `creation_timestamp: i64`: Unix-Timestamp der Erstellung/Hinzufügung des Modells.
              * `last_modified_timestamp: i64`: Unix-Timestamp der letzten Änderung.
          * Implementierungen: `PartialEq`, `Eq`, `Debug`, `Clone`, `Serialize`, `Deserialize`, `Default`.
    6.  **`ModelContext` (Struct) definieren:**
          * Felder:
              * `context_id: Uuid`: Eindeutige ID des Kontextes.
              * `model_id: ModelId`: ID des Modells, zu dem dieser Kontext gehört.
              * `creation_timestamp: i64`: Unix-Timestamp der Kontexterstellung.
              * `last_accessed_timestamp: i64`: Unix-Timestamp des letzten Zugriffs.
              * `context_data: String`: Die eigentlichen Kontextdaten (z.B. Chat-Historie in JSON, Dokumentinhalt). Dies kann eine serialisierte Darstellung komplexerer Strukturen sein.
              * `context_type: String`: Typ des Kontextes (z.B. "chat\_history", "document", "code").
              * `metadata: std::collections::HashMap<String, String>`: Zusätzliche Metadaten.
          * Implementierungen: `PartialEq`, `Eq`, `Debug`, `Clone`, `Serialize`, `Deserialize`, `Default`.
    7.  **`ModelRequest` (Enum) definieren:**
          * Varianten:
              * `TextGeneration { prompt: String, max_tokens: Option<u32>, temperature: Option<f32>, context_id: Option<Uuid> }`: Anfrage für Textgenerierung.
              * `ImageGeneration { prompt: String, width: u32, height: u32, num_images: Option<u32>, context_id: Option<Uuid> }`: Anfrage für Bildgenerierung.
              * `TextEmbedding { text: String }`: Anfrage für Text-Embedding.
              * `SentimentAnalysis { text: String }`: Anfrage für Stimmungsanalyse.
              * `Categorization { text: String, categories: Vec<String> }`: Anfrage für Kategorisierung.
              * `SpeechToText { audio_data_base64: String, language: Option<String> }`: Anfrage für Spracherkennung (Base64-kodiert).
              * `TextToSpeech { text: String, voice: Option<String>, format: Option<String> }`: Anfrage für Text-zu-Sprache.
              * `Custom { model_type: ModelType, request_data: serde_json::Value, context_id: Option<Uuid> }`: Generische Anfrage.
          * Implementierungen: `Debug`, `Clone`, `Serialize`, `Deserialize`.
    8.  **`ModelResponse` (Enum) definieren:**
          * Varianten:
              * `TextGeneration { generated_text: String, usage_tokens: Option<u32> }`: Antwort auf Textgenerierung.
              * `ImageGeneration { image_data_base64: Vec<String> }`: Antwort auf Bildgenerierung (Liste von Base64-Strings).
              * `TextEmbedding { embedding: Vec<f32> }`: Antwort auf Text-Embedding.
              * `SentimentAnalysis { sentiment: String, score: f32 }`: Antwort auf Stimmungsanalyse.
              * `Categorization { categories: Vec<String>, scores: Vec<f32> }`: Antwort auf Kategorisierung.
              * `SpeechToText { transcribed_text: String }`: Antwort auf Spracherkennung.
              * `TextToSpeech { audio_data_base64: String, format: String }`: Antwort auf Text-zu-Sprache.
              * `Custom { model_type: ModelType, response_data: serde_json::Value }`: Generische Antwort.
          * Implementierungen: `Debug`, `Clone`, `Serialize`, `Deserialize`, `PartialEq` (für Tests).
    9.  **Implementierung von `Default` für `ModelConfiguration` und `ModelContext`**:
          * Für `ModelConfiguration`: sinnvolle Standardwerte (z.B. `ModelId::nil()`, leere Strings, `false` für `is_enabled`/`is_default`, aktuelle Zeitstempel).
          * Für `ModelContext`: sinnvolle Standardwerte (z.B. `Uuid::nil()`, leere Strings, aktuelle Zeitstempel).
    10. **Implementierung von `TryFrom<String>` für `ModelType`**: Ermöglicht die Umwandlung eines Strings (z.B. aus Konfiguration oder API-Input) in einen `ModelType`. Fehlerbehandlung für unbekannte Strings (führt zu `ModelType::Custom`).
    11. **Konsequente Verwendung von `Option<T>` für optionale Felder:** Dies ermöglicht Flexibilität und signalisiert klar das Vorhandensein oder Fehlen von Daten.
    12. **`serde` Derivierungen:** Alle Strukturen und Enums müssen `Serialize` und `Deserialize` ableiten, um eine einfache JSON-Serialisierung/Deserialisierung zu ermöglichen.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/mcp/data_types.rs`
  * **Abhängigkeiten:**
      * **Extern:** `uuid`, `serde`, `serde_json`, `chrono` (für Zeitstempel), `async_trait` (falls spezifische `impl`s benötigt werden, ansonsten nicht direkt in `data_types`), `std::collections::HashMap`, `std::fmt`.
  * **Kommunikationsmuster:**
      * Diese Datenstrukturen dienen als Transportobjekte. Sie werden serialisiert und über IPC (D-Bus) oder HTTP an KI-Modelle gesendet bzw. von diesen empfangen.
  * **Erwartete Ergebnisse/Outputs:**
      * Eine klare und umfassende Definition der Datenmodelle für die KI-Integration.
      * Typsichere Schnittstellen für MCP-Anfragen und -Antworten.
      * Einfache Serialisierbarkeit und Deserialisierbarkeit für die Kommunikation.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Test der Serialisierung und Deserialisierung aller `ModelType`, `ModelEndpoint`, `ModelCapabilities`, `ModelConfiguration`, `ModelContext`, `ModelRequest` und `ModelResponse` Varianten.
          * Test der `Default`-Implementierungen.
          * Test der `TryFrom<String>`-Implementierung für `ModelType`, inklusive Edge-Cases (unbekannte Strings).
          * Test der Gleichheit (`PartialEq`, `Eq`) für alle relevanten Typen.
          * Test der `Display` Implementierung für `ModelType`.

#### Funktionsspezifikation: `novade_domain::mcp::data_types`

```rust
// novade-domain/src/mcp/data_types.rs

//! Definiert die Datenstrukturen für die Interaktion mit KI-Modellen
//! über das Model Context Protocol (MCP).
//!
//! Diese Typen umfassen Modellkonfigurationen, Kontexte sowie Anfragen und Antworten
//! für verschiedene Arten von KI-Inferenz.

use chrono::Utc;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fmt::{self, Display};
use std::str::FromStr;
use uuid::Uuid;

/// Eindeutiger Identifikator für ein KI-Modell.
pub type ModelId = Uuid;

/// Repräsentiert die verschiedenen Typen von KI-Modellen, die NovaDE unterstützt.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum ModelType {
    /// Modelle zur Generierung von Text (z.B. LLMs).
    TextGeneration,
    /// Modelle zur Generierung von Bildern.
    ImageGeneration,
    /// Modelle zur Umwandlung von Text in numerische Vektoren (Embeddings).
    TextEmbedding,
    /// Modelle zur Analyse der Stimmung (positiv, negativ, neutral) eines Textes.
    SentimentAnalysis,
    /// Modelle zur Kategorisierung von Texten oder anderen Daten.
    Categorization,
    /// Modelle zur Umwandlung von gesprochener Sprache in Text.
    SpeechToText,
    /// Modelle zur Umwandlung von Text in gesprochene Sprache.
    TextToSpeech,
    /// Ein benutzerdefinierter oder unbekannter Modelltyp, der durch einen String repräsentiert wird.
    Custom(String),
}

impl Display for ModelType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ModelType::TextGeneration => write!(f, "textGeneration"),
            ModelType::ImageGeneration => write!(f, "imageGeneration"),
            ModelType::TextEmbedding => write!(f, "textEmbedding"),
            ModelType::SentimentAnalysis => write!(f, "sentimentAnalysis"),
            ModelType::Categorization => write!(f, "categorization"),
            ModelType::SpeechToText => write!(f, "speechToText"),
            ModelType::TextToSpeech => write!(f, "textToSpeech"),
            ModelType::Custom(s) => write!(f, "custom:{}", s),
        }
    }
}

impl FromStr for ModelType {
    type Err = String; // Kann jeden Fehler-Typ zurückgeben, String ist für Einfachheit ok

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(match s {
            "textGeneration" => ModelType::TextGeneration,
            "imageGeneration" => ModelType::ImageGeneration,
            "textEmbedding" => ModelType::TextEmbedding,
            "sentimentAnalysis" => ModelType::SentimentAnalysis,
            "categorization" => ModelType::Categorization,
            "speechToText" => ModelType::SpeechToText,
            "textToSpeech" => ModelType::TextToSpeech,
            s if s.starts_with("custom:") => ModelType::Custom(s.strip_prefix("custom:").unwrap().to_string()),
            _ => ModelType::Custom(s.to_string()), // Fallback for unknown strings
        })
    }
}


/// Definiert den Endpoint für die Kommunikation mit einem KI-Modell.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ModelEndpoint {
    /// Die URI des Modell-Endpoints (z.B. HTTP-URL oder D-Bus-Pfad).
    pub uri: String,
    /// Optionaler Authentifizierungstoken für den Endpoint.
    pub auth_token: Option<String>,
    /// Optionales Timeout in Millisekunden für Anfragen an diesen Endpoint.
    pub timeout_ms: Option<u64>,
}

impl Default for ModelEndpoint {
    fn default() -> Self {
        Self {
            uri: String::new(),
            auth_token: None,
            timeout_ms: Some(30_000), // Standard-Timeout von 30 Sekunden
        }
    }
}

/// Beschreibt die Fähigkeiten eines KI-Modells.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ModelCapabilities {
    /// Maximale Eingabelänge (z.B. Anzahl der Token für Textmodelle).
    pub max_input_length: Option<usize>,
    /// Liste der unterstützten Ausgabeformate (z.B. "text/plain", "image/png", "application/json").
    pub supported_output_formats: Vec<String>,
    /// Maximale Anzahl gleichzeitiger Anfragen, die das Modell verarbeiten kann.
    pub concurrency_limit: Option<usize>,
    /// Geschätzte Kosten pro Einheit der Nutzung (z.B. pro Token, pro Bild).
    pub cost_per_unit: Option<f64>,
    /// Name der Einheit für die Kosten (z.B. "token", "image", "request").
    pub unit_name: Option<String>,
}

impl Default for ModelCapabilities {
    fn default() -> Self {
        Self {
            max_input_length: None,
            supported_output_formats: vec!["text/plain".to_string()],
            concurrency_limit: Some(1),
            cost_per_unit: None,
            unit_name: None,
        }
    }
}

/// Repräsentiert die Konfiguration eines registrierten KI-Modells.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ModelConfiguration {
    /// Eindeutiger Identifikator des Modells.
    pub model_id: ModelId,
    /// Anzeigename des Modells (z.B. "GPT-4o", "Stable Diffusion XL").
    pub model_name: String,
    /// Der Typ des Modells.
    pub model_type: ModelType,
    /// Optionale Versionsnummer des Modells.
    pub version: Option<String>,
    /// Optionale kurze Beschreibung des Modells.
    pub description: Option<String>,
    /// Der Endpoint für die Inferenz dieses Modells.
    pub endpoint: ModelEndpoint,
    /// Die Fähigkeiten des Modells.
    pub capabilities: ModelCapabilities,
    /// Gibt an, ob das Modell aktiviert und für die Nutzung verfügbar ist.
    pub is_enabled: bool,
    /// Gibt an, ob dieses Modell das Standardmodell für seinen `ModelType` ist.
    pub is_default: bool,
    /// Unix-Timestamp (Sekunden seit Epoche) der Erstellung oder Hinzufügung des Modells.
    pub creation_timestamp: i64,
    /// Unix-Timestamp (Sekunden seit Epoche) der letzten Änderung der Modellkonfiguration.
    pub last_modified_timestamp: i64,
}

impl Default for ModelConfiguration {
    fn default() -> Self {
        let now = Utc::now().timestamp();
        Self {
            model_id: Uuid::nil(),
            model_name: String::new(),
            model_type: ModelType::Custom("unknown".to_string()),
            version: None,
            description: None,
            endpoint: ModelEndpoint::default(),
            capabilities: ModelCapabilities::default(),
            is_enabled: false,
            is_default: false,
            creation_timestamp: now,
            last_modified_timestamp: now,
        }
    }
}

/// Repräsentiert einen spezifischen Kontext oder eine Sitzung für KI-Modelle.
///
/// Dies ermöglicht es, eine Historie oder spezifische Daten über mehrere Anfragen
/// hinweg für ein Modell aufrechtzuerhalten.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ModelContext {
    /// Eindeutige ID des Kontextes.
    pub context_id: Uuid,
    /// ID des Modells, zu dem dieser Kontext gehört.
    pub model_id: ModelId,
    /// Unix-Timestamp (Sekunden seit Epoche) der Kontexterstellung.
    pub creation_timestamp: i64,
    /// Unix-Timestamp (Sekunden seit Epoche) des letzten Zugriffs auf diesen Kontext.
    pub last_accessed_timestamp: i64,
    /// Die eigentlichen Kontextdaten, typischerweise als serialisierter String (z.B. JSON für Chat-Historie).
    pub context_data: String,
    /// Typ des Kontextes (z.B. "chat_history", "document_summary", "code_snippet").
    pub context_type: String,
    /// Zusätzliche Metadaten zum Kontext.
    pub metadata: HashMap<String, String>,
}

impl Default for ModelContext {
    fn default() -> Self {
        let now = Utc::now().timestamp();
        Self {
            context_id: Uuid::new_v4(), // Kontexte sollten eine neue ID erhalten
            model_id: Uuid::nil(),
            creation_timestamp: now,
            last_accessed_timestamp: now,
            context_data: String::new(),
            context_type: "default".to_string(),
            metadata: HashMap::new(),
        }
    }
}

/// Repräsentiert eine Anfrage an ein KI-Modell.
///
/// Jede Variante entspricht einem spezifischen Inferenztyp.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum ModelRequest {
    /// Anfrage zur Generierung von Text.
    TextGeneration {
        /// Der Eingabe-Prompt für die Textgenerierung.
        prompt: String,
        /// Optionale maximale Anzahl der zu generierenden Token.
        max_tokens: Option<u32>,
        /// Optionale Temperatur für die Generierung (steuert Kreativität vs. Beständigkeit).
        temperature: Option<f32>,
        /// Optionale Kontext-ID, um die Anfrage einer bestehenden Sitzung zuzuordnen.
        context_id: Option<Uuid>,
    },
    /// Anfrage zur Generierung von Bildern.
    ImageGeneration {
        /// Der Text-Prompt für die Bildgenerierung.
        prompt: String,
        /// Gewünschte Breite des generierten Bildes.
        width: u32,
        /// Gewünschte Höhe des generierten Bildes.
        height: u32,
        /// Optionale Anzahl der zu generierenden Bilder.
        num_images: Option<u32>,
        /// Optionale Kontext-ID.
        context_id: Option<Uuid>,
    },
    /// Anfrage zur Erstellung eines Text-Embeddings.
    TextEmbedding {
        /// Der Text, für den ein Embedding erstellt werden soll.
        text: String,
    },
    /// Anfrage zur Stimmungsanalyse eines Textes.
    SentimentAnalysis {
        /// Der zu analysierende Text.
        text: String,
    },
    /// Anfrage zur Kategorisierung eines Textes.
    Categorization {
        /// Der zu kategorisierende Text.
        text: String,
        /// Eine Liste von Kategorien, in die der Text eingeordnet werden soll.
        categories: Vec<String>,
    },
    /// Anfrage zur Umwandlung von gesprochener Sprache in Text.
    SpeechToText {
        /// Base64-kodierte Audiodaten.
        audio_data_base64: String,
        /// Optionale Sprache des Audios (z.B. "en-US", "de-DE").
        language: Option<String>,
    },
    /// Anfrage zur Umwandlung von Text in gesprochene Sprache.
    TextToSpeech {
        /// Der zu sprechende Text.
        text: String,
        /// Optionale Stimme, die verwendet werden soll (z.B. "female_default", "male_enhanced").
        voice: Option<String>,
        /// Optionales Ausgabeformat des Audios (z.B. "audio/mpeg", "audio/wav").
        format: Option<String>,
    },
    /// Eine generische Anfrage für benutzerdefinierte oder zukünftige Modelltypen.
    Custom {
        /// Der spezifische Modelltyp für diese benutzerdefinierte Anfrage.
        model_type: ModelType,
        /// Die rohen Anfragedaten als JSON-Wert.
        request_data: serde_json::Value,
        /// Optionale Kontext-ID.
        context_id: Option<Uuid>,
    },
}

/// Repräsentiert die Antwort von einem KI-Modell.
///
/// Jede Variante entspricht einem spezifischen Inferenztyp.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum ModelResponse {
    /// Antwort der Textgenerierung.
    TextGeneration {
        /// Der vom Modell generierte Text.
        generated_text: String,
        /// Optionale Angabe der verbrauchten Token (für Kostenberechnung).
        usage_tokens: Option<u32>,
    },
    /// Antwort der Bildgenerierung.
    ImageGeneration {
        /// Liste von Base64-kodierten Bilddaten-Strings.
        image_data_base64: Vec<String>,
    },
    /// Antwort eines Text-Embeddings.
    TextEmbedding {
        /// Der generierte Embedding-Vektor.
        embedding: Vec<f32>,
    },
    /// Antwort der Stimmungsanalyse.
    SentimentAnalysis {
        /// Die erkannte Stimmung (z.B. "Positive", "Negative", "Neutral").
        sentiment: String,
        /// Ein numerischer Score für die Stimmung (z.B. -1.0 bis 1.0).
        score: f32,
    },
    /// Antwort der Kategorisierung.
    Categorization {
        /// Liste der erkannten Kategorien.
        categories: Vec<String>,
        /// Optionale Liste der zugehörigen Scores für jede Kategorie.
        scores: Vec<f32>,
    },
    /// Antwort der Spracherkennung.
    SpeechToText {
        /// Der transkribierte Text.
        transcribed_text: String,
    },
    /// Antwort der Text-zu-Sprache-Umwandlung.
    TextToSpeech {
        /// Base64-kodierte Audiodaten.
        audio_data_base64: String,
        /// Das Format der Audiodaten (z.B. "audio/mpeg").
        format: String,
    },
    /// Eine generische Antwort für benutzerdefinierte oder zukünftige Modelltypen.
    Custom {
        /// Der spezifische Modelltyp, zu dem diese Antwort gehört.
        model_type: ModelType,
        /// Die rohen Antwortdaten als JSON-Wert.
        response_data: serde_json::Value,
    },
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::{json, to_string_pretty};

    #[test]
    fn test_model_id_is_uuid() {
        let id = Uuid::new_v4();
        let model_id: ModelId = id; // Test type alias assignment
        assert_eq!(model_id, id);
    }

    #[test]
    fn test_model_type_serialization_deserialization() {
        let types = vec![
            ModelType::TextGeneration,
            ModelType::ImageGeneration,
            ModelType::TextEmbedding,
            ModelType::SentimentAnalysis,
            ModelType::Categorization,
            ModelType::SpeechToText,
            ModelType::TextToSpeech,
            ModelType::Custom("my_custom_type".to_string()),
        ];

        for model_type in types {
            let serialized = serde_json::to_string(&model_type).unwrap();
            let deserialized: ModelType = serde_json::from_str(&serialized).unwrap();
            assert_eq!(model_type, deserialized);
        }
    }

    #[test]
    fn test_model_type_display_and_from_str() {
        assert_eq!(ModelType::TextGeneration.to_string(), "textGeneration");
        assert_eq!(ModelType::Custom("test".to_string()).to_string(), "custom:test");

        assert_eq!(ModelType::from_str("textGeneration").unwrap(), ModelType::TextGeneration);
        assert_eq!(ModelType::from_str("custom:another").unwrap(), ModelType::Custom("another".to_string()));
        assert_eq!(ModelType::from_str("unknown_type").unwrap(), ModelType::Custom("unknown_type".to_string())); // Fallback
    }

    #[test]
    fn test_model_endpoint_serialization_deserialization() {
        let endpoint = ModelEndpoint {
            uri: "http://localhost:8080/model".to_string(),
            auth_token: Some("abc123def456".to_string()),
            timeout_ms: Some(5000),
        };
        let serialized = serde_json::to_string(&endpoint).unwrap();
        let deserialized: ModelEndpoint = serde_json::from_str(&serialized).unwrap();
        assert_eq!(endpoint, deserialized);

        let default_endpoint = ModelEndpoint::default();
        let serialized_default = serde_json::to_string(&default_endpoint).unwrap();
        let deserialized_default: ModelEndpoint = serde_json::from_str(&serialized_default).unwrap();
        assert_eq!(default_endpoint, deserialized_default);
        assert_eq!(default_endpoint.timeout_ms, Some(30_000));
    }

    #[test]
    fn test_model_capabilities_serialization_deserialization() {
        let capabilities = ModelCapabilities {
            max_input_length: Some(2048),
            supported_output_formats: vec!["text/plain".to_string(), "application/json".to_string()],
            concurrency_limit: Some(4),
            cost_per_unit: Some(0.002),
            unit_name: Some("token".to_string()),
        };
        let serialized = serde_json::to_string(&capabilities).unwrap();
        let deserialized: ModelCapabilities = serde_json::from_str(&serialized).unwrap();
        assert_eq!(capabilities, deserialized);

        let default_capabilities = ModelCapabilities::default();
        let serialized_default = serde_json::to_string(&default_capabilities).unwrap();
        let deserialized_default: ModelCapabilities = serde_json::from_str(&serialized_default).unwrap();
        assert_eq!(default_capabilities, deserialized_default);
    }

    #[test]
    fn test_model_configuration_serialization_deserialization() {
        let config = ModelConfiguration {
            model_id: Uuid::new_v4(),
            model_name: "Test GPT".to_string(),
            model_type: ModelType::TextGeneration,
            version: Some("1.0".to_string()),
            description: Some("A test language model.".to_string()),
            endpoint: ModelEndpoint::default(),
            capabilities: ModelCapabilities::default(),
            is_enabled: true,
            is_default: false,
            creation_timestamp: Utc::now().timestamp(),
            last_modified_timestamp: Utc::now().timestamp(),
        };
        let serialized = serde_json::to_string(&config).unwrap();
        let deserialized: ModelConfiguration = serde_json::from_str(&serialized).unwrap();
        assert_eq!(config, deserialized);

        let default_config = ModelConfiguration::default();
        let serialized_default = serde_json::to_string(&default_config).unwrap();
        let deserialized_default: ModelConfiguration = serde_json::from_str(&serialized_default).unwrap();
        assert_eq!(default_config.model_id, deserialized_default.model_id); // UUID will be random for default
        assert_eq!(default_config.model_name, deserialized_default.model_name);
        assert_eq!(default_config.model_type, deserialized_default.model_type);
        assert_eq!(default_config.is_enabled, deserialized_default.is_enabled);
        assert_eq!(default_config.creation_timestamp, deserialized_default.creation_timestamp);
    }

    #[test]
    fn test_model_context_serialization_deserialization() {
        let context = ModelContext {
            context_id: Uuid::new_v4(),
            model_id: Uuid::new_v4(),
            creation_timestamp: Utc::now().timestamp(),
            last_accessed_timestamp: Utc::now().timestamp(),
            context_data: r#"{"history": ["Hello", "Hi there"]}"#.to_string(),
            context_type: "chat_history".to_string(),
            metadata: HashMap::from([("user_id".to_string(), "123".to_string())]),
        };
        let serialized = serde_json::to_string(&context).unwrap();
        let deserialized: ModelContext = serde_json::from_str(&serialized).unwrap();
        assert_eq!(context, deserialized);

        let default_context = ModelContext::default();
        let serialized_default = serde_json::to_string(&default_context).unwrap();
        let deserialized_default: ModelContext = serde_json::from_str(&serialized_default).unwrap();
        assert_eq!(default_context.model_id, deserialized_default.model_id);
        assert_eq!(default_context.context_data, deserialized_default.context_data);
    }

    #[test]
    fn test_model_request_serialization_deserialization() {
        let requests = vec![
            ModelRequest::TextGeneration {
                prompt: "Write a short story.".to_string(),
                max_tokens: Some(100),
                temperature: Some(0.7),
                context_id: Some(Uuid::new_v4()),
            },
            ModelRequest::ImageGeneration {
                prompt: "A cat in space".to_string(),
                width: 512,
                height: 512,
                num_images: Some(1),
                context_id: None,
            },
            ModelRequest::TextEmbedding {
                text: "Hello world.".to_string(),
            },
            ModelRequest::SentimentAnalysis {
                text: "This is a great product!".to_string(),
            },
            ModelRequest::Categorization {
                text: "Rust programming language.".to_string(),
                categories: vec!["Programming".to_string(), "Technology".to_string()],
            },
            ModelRequest::SpeechToText {
                audio_data_base64: "AQIDBA==".to_string(),
                language: Some("en-US".to_string()),
            },
            ModelRequest::TextToSpeech {
                text: "Hello, NovaDE!".to_string(),
                voice: Some("nova".to_string()),
                format: Some("audio/mpeg".to_string()),
            },
            ModelRequest::Custom {
                model_type: ModelType::Custom("custom_processing".to_string()),
                request_data: json!({"data": [1,2,3], "param": "value"}),
                context_id: None,
            },
        ];

        for request in requests {
            let serialized = serde_json::to_string(&request).unwrap();
            let deserialized: ModelRequest = serde_json::from_str(&serialized).unwrap();
            // Note: ModelRequest does not derive PartialEq, so we can't directly compare.
            // We rely on successful serialization/deserialization and manual inspection.
            // For a robust test, one would implement PartialEq or compare fields individually.
            // For this exhaustive plan, we'll add PartialEq to ModelRequest (and Response) if possible.
            // As per instructions, I'll add PartialEq.
            assert_eq!(format!("{:?}", request), format!("{:?}", deserialized));
        }
    }

    #[test]
    fn test_model_response_serialization_deserialization() {
        let responses = vec![
            ModelResponse::TextGeneration {
                generated_text: "Once upon a time...".to_string(),
                usage_tokens: Some(50),
            },
            ModelResponse::ImageGeneration {
                image_data_base64: vec!["AQAB".to_string(), "BAQA".to_string()],
            },
            ModelResponse::TextEmbedding {
                embedding: vec![0.1, 0.2, 0.3],
            },
            ModelResponse::SentimentAnalysis {
                sentiment: "Positive".to_string(),
                score: 0.95,
            },
            ModelResponse::Categorization {
                categories: vec!["Tech".to_string(), "AI".to_string()],
                scores: vec![0.8, 0.7],
            },
            ModelResponse::SpeechToText {
                transcribed_text: "This is a test.".to_string(),
            },
            ModelResponse::TextToSpeech {
                audio_data_base64: "AQID".to_string(),
                format: "audio/wav".to_string(),
            },
            ModelResponse::Custom {
                model_type: ModelType::Custom("custom_output".to_string()),
                response_data: json!({"result": true, "status": "ok"}),
            },
        ];

        for response in responses {
            let serialized = serde_json::to_string_pretty(&response).unwrap();
            let deserialized: ModelResponse = serde_json::from_str(&serialized).unwrap();
            assert_eq!(response, deserialized);
        }
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (26 von 100) widmet sich der Definition der Fehlertypen für das Model Context Protocol (MCP) Modul in der Domänenschicht (`novade-domain`). Die Datei `errors.rs` wird spezifische Fehler definieren, die bei der Interaktion mit KI-Modellen oder dem MCP-Client auftreten können.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 26/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.18.2. `novade-domain/src/mcp/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/mcp/errors.rs`
  * **Verantwortlichkeit:** Definiert eine umfassende `McpError`-Enumeration, die alle möglichen Fehlerzustände abbildet, die bei Operationen im Kontext des Model Context Protocols (MCP) auftreten können. Dies umfasst Fehler bei der Modellverwaltung, Kontextverwaltung, Inferenzanfragen, Kommunikation mit dem `mcp_client` oder zugrunde liegenden Systemdiensten.
  * **Kern-Aufgaben (Tasks):**
    1.  **`McpError` (Enum) definieren:**
          * Nutzung von `thiserror` für einfache Fehlerableitung und Fehlermeldungen.
          * **Varianten:**
              * `ModelNotFound { model_id: uuid::Uuid }`: Wenn ein angefordertes Modell anhand seiner ID nicht gefunden werden kann.
                  * Meldung: `Model with ID '{model_id}' not found.`
              * `ContextNotFound { context_id: uuid::Uuid }`: Wenn ein angeforderter Kontext anhand seiner ID nicht gefunden werden kann.
                  * Meldung: `Model context with ID '{context_id}' not found.`
              * `InvalidModelConfiguration { model_id: uuid::Uuid, source: String }`: Wenn eine Modellkonfiguration ungültig ist (z.B. fehlende Pflichtfelder, ungültiges Format).
                  * Meldung: `Invalid configuration for model '{model_id}': {source}`
                  * `source` sollte eine detailliertere Fehlerbeschreibung enthalten.
              * `DeserializationError { source: serde_json::Error }`: Fehler beim Deserialisieren von Daten (z.B. JSON von `mcp_client`).
                  * Meldung: `Failed to deserialize data: {source}`
                  * Beinhaltet die Original `serde_json::Error`.
              * `SerializationError { source: serde_json::Error }`: Fehler beim Serialisieren von Daten (z.B. Request-Objekte zu JSON).
                  * Meldung: `Failed to serialize data: {source}`
                  * Beinhaltet die Original `serde_json::Error`.
              * `ClientCommunicationError { source: novade_core::error::ClientError }`: Fehler bei der Kommunikation mit dem MCP-Client (Systemschicht).
                  * Meldung: `Client communication error: {source}`
                  * Beinhaltet `ClientError` aus `novade_core`.
              * `InferenceError { model_id: uuid::Uuid, message: String }`: Ein Fehler, der vom KI-Modell während der Inferenz zurückgegeben wird.
                  * Meldung: `Inference error for model '{model_id}': {message}`
              * `UnsupportedModelType { model_type: crate::mcp::data_types::ModelType }`: Wenn eine Operation für den angegebenen `ModelType` nicht unterstützt wird.
                  * Meldung: `Operation not supported for model type '{model_type}'`
              * `CapabilityExceeded { model_id: uuid::Uuid, capability_name: String, current_value: String, limit_value: String }`: Wenn eine Anfrage die Kapazitäten des Modells überschreitet (z.B. zu lange Eingabe).
                  * Meldung: `Capability '{capability_name}' exceeded for model '{model_id}': current {current_value}, limit {limit_value}`
              * `RateLimitExceeded { model_id: uuid::Uuid, retry_after_seconds: Option<u64> }`: Wenn ein Ratenlimit des Modells oder Endpoints erreicht wurde.
                  * Meldung: `Rate limit exceeded for model '{model_id}'. {retry_msg}` (`retry_msg` sollte optional die Wartezeit enthalten).
              * `InternalError { message: String }`: Ein allgemeiner, nicht kategorisierter interner Fehler in der MCP-Domänenlogik.
                  * Meldung: `Internal MCP error: {message}`
              * `Other { message: String }`: Ein unspezifischer Fehler.
                  * Meldung: `An unexpected MCP error occurred: {message}`
          * Implementierungen: `Debug`, `Display`, `std::error::Error`.
    2.  **`From` Implementierungen:**
          * `impl From<serde_json::Error> for McpError`: Konvertiert `serde_json::Error` in `McpError::DeserializationError` oder `McpError::SerializationError` je nach Kontext (wird bei Verwendung von `?` automatisch abgeleitet, muss aber explizit für die `source` Attribute deklariert werden).
          * `impl From<novade_core::error::ClientError> for McpError`: Konvertiert `novade_core::error::ClientError` in `McpError::ClientCommunicationError`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/mcp/errors.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::mcp::data_types::ModelType`, `novade_core::error::ClientError`.
      * **Extern:** `thiserror`, `serde_json`, `uuid`, `std::error::Error`, `std::fmt`.
  * **Kommunikationsmuster:**
      * Diese Fehler werden von den MCP-Services der Domänenlogik zurückgegeben und können an höhere Schichten (z.B. UI) weitergegeben werden, um dort behandelt und dem Benutzer präsentiert zu werden.
  * **Erwartete Ergebnisse/Outputs:**
      * Eine robuste, erweiterbare und semantisch aussagekräftige Fehlerbehandlung für das MCP-Modul.
      * Klare Fehlermeldungen für Debugging und Benutzerrückmeldungen.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Erstellung jeder `McpError`-Variante.
          * Testen der korrekten Fehlermeldungsformatierung für jede Variante (`.to_string()`).
          * Testen der `From`-Implementierungen für `serde_json::Error` und `novade_core::error::ClientError`.
          * Sicherstellen, dass `source()`-Methoden korrekt die zugrunde liegenden Fehler zurückgeben.

#### Funktionsspezifikation: `novade_domain::mcp::errors`

```rust
// novade-domain/src/mcp/errors.rs

//! Definiert die Fehlertypen für das Model Context Protocol (MCP) Modul.
//!
//! Diese Fehler umfassen Probleme bei der Modell- und Kontextverwaltung,
//! Inferenzanfragen, sowie Kommunikationsprobleme mit dem MCP-Client.

use thiserror::Error;
use uuid::Uuid;

use crate::mcp::data_types::ModelType;
use novade_core::error::ClientError;

/// Repräsentiert alle möglichen Fehler, die im MCP-Modul auftreten können.
#[derive(Debug, Error)]
pub enum McpError {
    /// Ein angefordertes Modell wurde anhand seiner ID nicht gefunden.
    #[error("Model with ID '{model_id}' not found.")]
    ModelNotFound {
        /// Die ID des nicht gefundenen Modells.
        model_id: Uuid,
    },

    /// Ein angeforderter Kontext wurde anhand seiner ID nicht gefunden.
    #[error("Model context with ID '{context_id}' not found.")]
    ContextNotFound {
        /// Die ID des nicht gefundenen Kontextes.
        context_id: Uuid,
    },

    /// Die Konfiguration eines Modells ist ungültig.
    #[error("Invalid configuration for model '{model_id}': {source}")]
    InvalidModelConfiguration {
        /// Die ID des Modells mit der ungültigen Konfiguration.
        model_id: Uuid,
        /// Detaillierte Fehlerbeschreibung der Ungültigkeit.
        source: String, // String anstatt eines spezifischen Error-Typs für Flexibilität
    },

    /// Fehler beim Deserialisieren von Daten (z.B. JSON).
    #[error("Failed to deserialize data: {source}")]
    DeserializationError {
        /// Der ursprüngliche Deserialisierungsfehler.
        #[from]
        source: serde_json::Error,
    },

    /// Fehler beim Serialisieren von Daten (z.B. JSON).
    #[error("Failed to serialize data: {source}")]
    SerializationError {
        /// Der ursprüngliche Serialisierungsfehler.
        // `#[from]` kann hier auch verwendet werden, wenn die Konvertierung
        // automatisch erkannt werden soll, aber in diesem Kontext deutet es an,
        // dass es sich um einen Fehler BEIM Serialisieren handelt.
        source: serde_json::Error,
    },

    /// Fehler bei der Kommunikation mit dem MCP-Client (Systemschicht).
    #[error("Client communication error: {source}")]
    ClientCommunicationError {
        /// Der zugrunde liegende Client-Fehler aus der Core-Schicht.
        #[from]
        source: ClientError,
    },

    /// Ein Fehler, der vom KI-Modell während der Inferenz zurückgegeben wird.
    #[error("Inference error for model '{model_id}': {message}")]
    InferenceError {
        /// Die ID des Modells, das den Fehler verursacht hat.
        model_id: Uuid,
        /// Die Fehlermeldung vom KI-Modell.
        message: String,
    },

    /// Eine Operation wird für den angegebenen Modelltyp nicht unterstützt.
    #[error("Operation not supported for model type '{model_type}'")]
    UnsupportedModelType {
        /// Der Modelltyp, für den die Operation nicht unterstützt wird.
        model_type: ModelType,
    },

    /// Eine Anfrage überschreitet die definierten Fähigkeiten des Modells.
    #[error("Capability '{capability_name}' exceeded for model '{model_id}': current '{current_value}', limit '{limit_value}'")]
    CapabilityExceeded {
        /// Die ID des Modells, dessen Kapazität überschritten wurde.
        model_id: Uuid,
        /// Der Name der überschrittenen Fähigkeit (z.B. "max_input_length").
        capability_name: String,
        /// Der aktuelle Wert der Anfrage.
        current_value: String,
        /// Der erlaubte Grenzwert der Fähigkeit.
        limit_value: String,
    },

    /// Ein Ratenlimit des Modells oder Endpoints wurde erreicht.
    #[error("Rate limit exceeded for model '{model_id}'.{retry_message}")]
    RateLimitExceeded {
        /// Die ID des Modells, dessen Ratenlimit überschritten wurde.
        model_id: Uuid,
        /// Optionale Sekunden, nach denen ein erneuter Versuch unternommen werden kann.
        retry_after_seconds: Option<u64>,
        /// Intern generierte Meldung für den Display-Trait
        #[from]
        retry_message: RateLimitExceededMessage,
    },

    /// Ein allgemeiner, nicht kategorisierter interner Fehler in der MCP-Domänenlogik.
    #[error("Internal MCP error: {message}")]
    InternalError {
        /// Detaillierte Fehlermeldung.
        message: String,
    },

    /// Ein unspezifischer Fehler, der nicht in andere Kategorien passt.
    #[error("An unexpected MCP error occurred: {message}")]
    Other {
        /// Detaillierte Fehlermeldung.
        message: String,
    },
}

// Hilfs-Struktur für RateLimitExceeded-Meldung, um Logik im Error-Typ zu kapseln
#[derive(Debug)]
pub struct RateLimitExceededMessage(String);

impl From<Option<u64>> for RateLimitExceededMessage {
    fn from(retry_after_seconds: Option<u64>) -> Self {
        match retry_after_seconds {
            Some(secs) => RateLimitExceededMessage(format!(" Please retry after {} seconds.", secs)),
            None => RateLimitExceededMessage("".to_string()),
        }
    }
}

impl std::fmt::Display for RateLimitExceededMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::mcp::data_types::ModelType;
    use serde_json::json;
    use std::io;

    #[test]
    fn test_model_not_found_error() {
        let model_id = Uuid::new_v4();
        let err = McpError::ModelNotFound { model_id };
        assert_eq!(format!("{}", err), format!("Model with ID '{}' not found.", model_id));
        assert!(err.source().is_none());
    }

    #[test]
    fn test_context_not_found_error() {
        let context_id = Uuid::new_v4();
        let err = McpError::ContextNotFound { context_id };
        assert_eq!(format!("{}", err), format!("Model context with ID '{}' not found.", context_id));
        assert!(err.source().is_none());
    }

    #[test]
    fn test_invalid_model_configuration_error() {
        let model_id = Uuid::new_v4();
        let source = "Missing endpoint URI".to_string();
        let err = McpError::InvalidModelConfiguration { model_id, source: source.clone() };
        assert_eq!(format!("{}", err), format!("Invalid configuration for model '{}': {}", model_id, source));
        assert!(err.source().is_none());
    }

    #[test]
    fn test_deserialization_error_from_serde_json_error() {
        let json_err = serde_json::from_str::<serde_json::Value>("{invalid json").unwrap_err();
        let err: McpError = json_err.into(); // Uses #[from]
        assert!(matches!(err, McpError::DeserializationError { source: _ }));
        assert_eq!(format!("{}", err), format!("Failed to deserialize data: {}", err.source().unwrap()));
    }

    #[test]
    fn test_serialization_error_from_serde_json_error() {
        // Simulate a serialization error, e.g., if a custom Serialize impl failed
        #[derive(Debug, Serialize)]
        struct TestStruct;
        impl Serialize for TestStruct {
            fn serialize<S>(&self, _serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                Err(serde::ser::Error::custom("Simulated serialization error"))
            }
        }
        let json_err = serde_json::to_string(&TestStruct).unwrap_err();
        let err = McpError::SerializationError { source: json_err }; // Explicitly create this variant
        assert!(matches!(err, McpError::SerializationError { source: _ }));
        assert_eq!(format!("{}", err), format!("Failed to serialize data: {}", err.source().unwrap()));
    }


    #[test]
    fn test_client_communication_error_from_client_error() {
        let client_err = ClientError::IoError(io::Error::new(io::ErrorKind::PermissionDenied, "Access denied"));
        let err: McpError = client_err.into(); // Uses #[from]
        assert!(matches!(err, McpError::ClientCommunicationError { source: _ }));
        assert_eq!(format!("{}", err), format!("Client communication error: {}", err.source().unwrap()));
    }

    #[test]
    fn test_inference_error() {
        let model_id = Uuid::new_v4();
        let message = "Model output was garbled".to_string();
        let err = McpError::InferenceError { model_id, message: message.clone() };
        assert_eq!(format!("{}", err), format!("Inference error for model '{}': {}", model_id, message));
        assert!(err.source().is_none());
    }

    #[test]
    fn test_unsupported_model_type_error() {
        let model_type = ModelType::ImageGeneration;
        let err = McpError::UnsupportedModelType { model_type: model_type.clone() };
        assert_eq!(format!("{}", err), format!("Operation not supported for model type '{}'", model_type));
        assert!(err.source().is_none());
    }

    #[test]
    fn test_capability_exceeded_error() {
        let model_id = Uuid::new_v4();
        let capability_name = "max_input_length".to_string();
        let current_value = "5000".to_string();
        let limit_value = "2048".to_string();
        let err = McpError::CapabilityExceeded {
            model_id,
            capability_name: capability_name.clone(),
            current_value: current_value.clone(),
            limit_value: limit_value.clone(),
        };
        assert_eq!(
            format!("{}", err),
            format!(
                "Capability '{}' exceeded for model '{}': current '{}', limit '{}'",
                capability_name, model_id, current_value, limit_value
            )
        );
        assert!(err.source().is_none());
    }

    #[test]
    fn test_rate_limit_exceeded_error_with_retry() {
        let model_id = Uuid::new_v4();
        let retry_after_seconds = Some(60);
        let err = McpError::RateLimitExceeded { model_id, retry_after_seconds, retry_message: RateLimitExceededMessage::from(retry_after_seconds) };
        assert_eq!(
            format!("{}", err),
            format!("Rate limit exceeded for model '{}'. Please retry after 60 seconds.", model_id)
        );
        assert!(err.source().is_some()); // source is RateLimitExceededMessage
    }

    #[test]
    fn test_rate_limit_exceeded_error_no_retry() {
        let model_id = Uuid::new_v4();
        let retry_after_seconds = None;
        let err = McpError::RateLimitExceeded { model_id, retry_after_seconds, retry_message: RateLimitExceededMessage::from(retry_after_seconds) };
        assert_eq!(format!("{}", err), format!("Rate limit exceeded for model '{}'.", model_id));
        assert!(err.source().is_some()); // source is RateLimitExceededMessage
    }


    #[test]
    fn test_internal_error() {
        let message = "Unexpected logic path".to_string();
        let err = McpError::InternalError { message: message.clone() };
        assert_eq!(format!("{}", err), format!("Internal MCP error: {}", message));
        assert!(err.source().is_none());
    }

    #[test]
    fn test_other_error() {
        let message = "Something truly unforeseen happened".to_string();
        let err = McpError::Other { message: message.clone() };
        assert_eq!(format!("{}", err), format!("An unexpected MCP error occurred: {}", message));
        assert!(err.source().is_none());
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (27 von 100) widmet sich der Definition der Trait-Schnittstelle für den Model Context Protocol (MCP) Client in der Domänenschicht (`novade-domain`). Die Datei `mcp_client_iface.rs` wird den `McpClient`-Trait definieren, der die abstrakte Schnittstelle für die Interaktion mit dem MCP-Client in der Systemschicht bildet.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 27/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.18.3. `novade-domain/src/mcp/mcp_client_iface.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/mcp/mcp_client_iface.rs`
  * **Verantwortlichkeit:** Definiert die abstrakte Schnittstelle (`Trait`) für die Interaktion mit dem Model Context Protocol (MCP) Client, der in der Systemschicht implementiert wird. Dieser Trait ermöglicht es der Domänenlogik, KI-Modelle zu verwalten und Inferenzanfragen zu stellen, ohne die spezifischen Implementierungsdetails des zugrunde liegenden Kommunikationsprotokolls (z.B. D-Bus) zu kennen.
  * **Kern-Aufgaben (Tasks):**
    1.  **`McpClient` (Trait) definieren:**
          * Muss `async_trait` verwenden, da die Implementierungen asynchron sein werden.
          * **Methoden:**
              * **`register_model(&self, config: ModelConfiguration) -> Result<(), McpError>`:**
                  * Zweck: Registriert eine neue KI-Modellkonfiguration beim MCP-Client.
                  * Parameter: `config: ModelConfiguration` – Die zu registrierende Modellkonfiguration.
                  * Rückgabe: `Result<(), McpError>` – `Ok(())` bei Erfolg, `Err(McpError)` bei Fehlern (z.B. `InvalidModelConfiguration`, `ClientCommunicationError`).
              * **`update_model(&self, config: ModelConfiguration) -> Result<(), McpError>`:**
                  * Zweck: Aktualisiert eine bestehende KI-Modellkonfiguration.
                  * Parameter: `config: ModelConfiguration` – Die aktualisierte Modellkonfiguration.
                  * Rückgabe: `Result<(), McpError>` – `Ok(())` bei Erfolg, `Err(McpError)` (z.B. `ModelNotFound`, `InvalidModelConfiguration`, `ClientCommunicationError`).
              * **`unregister_model(&self, model_id: ModelId) -> Result<(), McpError>`:**
                  * Zweck: Entfernt ein registriertes KI-Modell.
                  * Parameter: `model_id: ModelId` – Die ID des zu entfernenden Modells.
                  * Rückgabe: `Result<(), McpError>` – `Ok(())` bei Erfolg, `Err(McpError)` (z.B. `ModelNotFound`, `ClientCommunicationError`).
              * **`get_model_configurations(&self) -> Result<Vec<ModelConfiguration>, McpError>`:**
                  * Zweck: Ruft alle registrierten Modellkonfigurationen ab.
                  * Parameter: Keine.
                  * Rückgabe: `Result<Vec<ModelConfiguration>, McpError>` – Eine Liste von Modellkonfigurationen bei Erfolg, `Err(McpError)` bei Fehlern (z.B. `ClientCommunicationError`, `DeserializationError`).
              * **`get_model_configuration(&self, model_id: ModelId) -> Result<ModelConfiguration, McpError>`:**
                  * Zweck: Ruft eine spezifische Modellkonfiguration ab.
                  * Parameter: `model_id: ModelId` – Die ID des abzurufenden Modells.
                  * Rückgabe: `Result<ModelConfiguration, McpError>` – Die Modellkonfiguration bei Erfolg, `Err(McpError)` (z.B. `ModelNotFound`, `ClientCommunicationError`, `DeserializationError`).
              * **`create_context(&self, model_id: ModelId, initial_data: Option<String>, context_type: String, metadata: Option<HashMap<String, String>>) -> Result<ModelContext, McpError>`:**
                  * Zweck: Erstellt einen neuen Kontext für ein spezifisches Modell.
                  * Parameter:
                      * `model_id: ModelId` – Die ID des Modells, für das der Kontext erstellt wird.
                      * `initial_data: Option<String>` – Optionale Startdaten für den Kontext (z.B. erster Prompt).
                      * `context_type: String` – Der Typ des Kontextes (z.B. "chat", "document").
                      * `metadata: Option<HashMap<String, String>>` – Optionale Metadaten.
                  * Rückgabe: `Result<ModelContext, McpError>` – Den erstellten Kontext bei Erfolg, `Err(McpError)` (z.B. `ModelNotFound`, `ClientCommunicationError`, `InternalError`).
              * **`update_context(&self, context: ModelContext) -> Result<(), McpError>`:**
                  * Zweck: Aktualisiert einen bestehenden Kontext.
                  * Parameter: `context: ModelContext` – Der zu aktualisierende Kontext.
                  * Rückgabe: `Result<(), McpError>` – `Ok(())` bei Erfolg, `Err(McpError)` (z.B. `ContextNotFound`, `ClientCommunicationError`).
              * **`get_context(&self, context_id: Uuid) -> Result<ModelContext, McpError>`:**
                  * Zweck: Ruft einen spezifischen Kontext ab.
                  * Parameter: `context_id: Uuid` – Die ID des abzurufenden Kontextes.
                  * Rückgabe: `Result<ModelContext, McpError>` – Den Kontext bei Erfolg, `Err(McpError)` (z.B. `ContextNotFound`, `ClientCommunicationError`, `DeserializationError`).
              * **`delete_context(&self, context_id: Uuid) -> Result<(), McpError>`:**
                  * Zweck: Löscht einen Kontext.
                  * Parameter: `context_id: Uuid` – Die ID des zu löschenden Kontextes.
                  * Rückgabe: `Result<(), McpError>` – `Ok(())` bei Erfolg, `Err(McpError)` (z.B. `ContextNotFound`, `ClientCommunicationError`).
              * **`perform_inference(&self, model_id: ModelId, request: ModelRequest) -> Result<ModelResponse, McpError>`:**
                  * Zweck: Führt eine Inferenzanfrage an ein KI-Modell aus.
                  * Parameter:
                      * `model_id: ModelId` – Die ID des Modells, das für die Inferenz verwendet werden soll.
                      * `request: ModelRequest` – Die Inferenzanfrage.
                  * Rückgabe: `Result<ModelResponse, McpError>` – Die Modellantwort bei Erfolg, `Err(McpError)` bei Fehlern (z.B. `ModelNotFound`, `InferenceError`, `ClientCommunicationError`, `CapabilityExceeded`, `RateLimitExceeded`).
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/mcp/mcp_client_iface.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::mcp::data_types::{ModelId, ModelConfiguration, ModelContext, ModelRequest, ModelResponse}`, `crate::mcp::errors::McpError`.
      * **Extern:** `async_trait`, `uuid::Uuid`, `std::collections::HashMap`.
  * **Kommunikationsmuster:**
      * Dieser Trait definiert die asynchrone Schnittstelle, die von den MCP-Services der Domänenschicht genutzt wird, um mit dem tatsächlichen MCP-Client in der Systemschicht zu kommunizieren. Die Implementierung dieses Traits in der Systemschicht wird die D-Bus-Kommunikation kapseln.
  * **Erwartete Ergebnisse/Outputs:**
      * Eine klare, asynchrone, typsichere und testbare Schnittstelle für die Interaktion mit dem MCP-Client.
      * Ermöglicht die Trennung der Domänenlogik von den Implementierungsdetails der Interprozesskommunikation.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Keine direkten Unit Tests für den Trait selbst.
          * Tests werden für Implementierungen des Traits (z.B. Mock-Implementierungen für Domänen-Tests oder die reale D-Bus-Implementierung in der Systemschicht) durchgeführt.
          * Sicherstellen, dass alle Methoden des Traits die erwarteten Parameter und Rückgabetypen haben.

#### Funktionsspezifikation: `novade_domain::mcp::mcp_client_iface`

```rust
// novade-domain/src/mcp/mcp_client_iface.rs

//! Definiert die Trait-Schnittstelle für den Model Context Protocol (MCP) Client.
//!
//! Dieser Trait abstrahiert die Interaktion mit dem tatsächlichen MCP-Client
//! (implementiert in der Systemschicht) und ermöglicht der Domänenlogik,
//! KI-Modelle zu verwalten und Inferenzanfragen zu stellen.

use async_trait::async_trait;
use std::collections::HashMap;
use uuid::Uuid;

use crate::mcp::data_types::{ModelConfiguration, ModelContext, ModelId, ModelRequest, ModelResponse};
use crate::mcp::errors::McpError;

/// Abstrakte Schnittstelle für die Interaktion mit dem Model Context Protocol (MCP) Client.
///
/// Implementierungen dieses Traits sind für die Kommunikation mit dem zugrunde liegenden
/// MCP-Dienst in der Systemschicht verantwortlich.
#[async_trait]
pub trait McpClient: Send + Sync {
    /// Registriert eine neue KI-Modellkonfiguration beim MCP-Client.
    ///
    /// # Arguments
    /// * `config` - Die vollständige `ModelConfiguration` des zu registrierenden Modells.
    ///
    /// # Errors
    /// * `McpError::InvalidModelConfiguration`: Wenn die bereitgestellte Konfiguration ungültig ist.
    /// * `McpError::ClientCommunicationError`: Wenn ein Fehler bei der Kommunikation mit dem Client auftritt.
    /// * Andere spezifische Fehler, die durch die Implementierung verursacht werden könnten.
    async fn register_model(&self, config: ModelConfiguration) -> Result<(), McpError>;

    /// Aktualisiert eine bestehende KI-Modellkonfiguration.
    ///
    /// Die `model_id` in der bereitgestellten `config` muss einem bereits registrierten Modell entsprechen.
    ///
    /// # Arguments
    /// * `config` - Die aktualisierte `ModelConfiguration`.
    ///
    /// # Errors
    /// * `McpError::ModelNotFound`: Wenn kein Modell mit der angegebenen ID gefunden wird.
    /// * `McpError::InvalidModelConfiguration`: Wenn die aktualisierte Konfiguration ungültig ist.
    /// * `McpError::ClientCommunicationError`: Wenn ein Fehler bei der Kommunikation mit dem Client auftritt.
    async fn update_model(&self, config: ModelConfiguration) -> Result<(), McpError>;

    /// Entfernt ein registriertes KI-Modell.
    ///
    /// Alle zugehörigen Kontexte könnten ebenfalls gelöscht werden, abhängig von der
    /// Implementierung des MCP-Dienstes.
    ///
    /// # Arguments
    /// * `model_id` - Die `ModelId` des zu entfernenden Modells.
    ///
    /// # Errors
    /// * `McpError::ModelNotFound`: Wenn kein Modell mit der angegebenen ID gefunden wird.
    /// * `McpError::ClientCommunicationError`: Wenn ein Fehler bei der Kommunikation mit dem Client auftritt.
    async fn unregister_model(&self, model_id: ModelId) -> Result<(), McpError>;

    /// Ruft alle registrierten Modellkonfigurationen ab.
    ///
    /// # Returns
    /// Eine `Vec<ModelConfiguration>` aller registrierten Modelle.
    ///
    /// # Errors
    /// * `McpError::ClientCommunicationError`: Wenn ein Fehler bei der Kommunikation mit dem Client auftritt.
    /// * `McpError::DeserializationError`: Wenn die empfangenen Daten nicht deserialisiert werden können.
    async fn get_model_configurations(&self) -> Result<Vec<ModelConfiguration>, McpError>;

    /// Ruft eine spezifische Modellkonfiguration ab.
    ///
    /// # Arguments
    /// * `model_id` - Die `ModelId` des abzurufenden Modells.
    ///
    /// # Returns
    /// Die `ModelConfiguration` des angeforderten Modells.
    ///
    /// # Errors
    /// * `McpError::ModelNotFound`: Wenn kein Modell mit der angegebenen ID gefunden wird.
    /// * `McpError::ClientCommunicationError`: Wenn ein Fehler bei der Kommunikation mit dem Client auftritt.
    /// * `McpError::DeserializationError`: Wenn die empfangenen Daten nicht deserialisiert werden können.
    async fn get_model_configuration(&self, model_id: ModelId) -> Result<ModelConfiguration, McpError>;

    /// Erstellt einen neuen Kontext für ein spezifisches Modell.
    ///
    /// Kontexte ermöglichen es, eine Sitzung oder Historie über mehrere Inferenzanfragen
    /// hinweg für ein Modell aufrechtzuerhalten.
    ///
    /// # Arguments
    /// * `model_id` - Die `ModelId` des Modells, für das der Kontext erstellt wird.
    /// * `initial_data` - Optionale Startdaten für den Kontext (z.B. der erste Prompt).
    /// * `context_type` - Der Typ des Kontextes (z.B. "chat_session", "document_summary").
    /// * `metadata` - Optionale zusätzliche Metadaten, die mit dem Kontext gespeichert werden.
    ///
    /// # Returns
    /// Die neu erstellte `ModelContext`-Instanz.
    ///
    /// # Errors
    /// * `McpError::ModelNotFound`: Wenn das angegebene Modell nicht existiert.
    /// * `McpError::ClientCommunicationError`: Wenn ein Fehler bei der Kommunikation mit dem Client auftritt.
    /// * `McpError::InternalError`: Bei einem unerwarteten internen Fehler des MCP-Dienstes.
    async fn create_context(
        &self,
        model_id: ModelId,
        initial_data: Option<String>,
        context_type: String,
        metadata: Option<HashMap<String, String>>,
    ) -> Result<ModelContext, McpError>;

    /// Aktualisiert einen bestehenden Kontext.
    ///
    /// Der `context_id` in der bereitgestellten `context`-Struktur muss existieren.
    ///
    /// # Arguments
    /// * `context` - Die zu aktualisierende `ModelContext`-Instanz.
    ///
    /// # Errors
    /// * `McpError::ContextNotFound`: Wenn kein Kontext mit der angegebenen ID gefunden wird.
    /// * `McpError::ClientCommunicationError`: Wenn ein Fehler bei der Kommunikation mit dem Client auftritt.
    async fn update_context(&self, context: ModelContext) -> Result<(), McpError>;

    /// Ruft einen spezifischen Kontext anhand seiner ID ab.
    ///
    /// # Arguments
    /// * `context_id` - Die `Uuid` des abzurufenden Kontextes.
    ///
    /// # Returns
    /// Die `ModelContext` des angeforderten Kontextes.
    ///
    /// # Errors
    /// * `McpError::ContextNotFound`: Wenn kein Kontext mit der angegebenen ID gefunden wird.
    /// * `McpError::ClientCommunicationError`: Wenn ein Fehler bei der Kommunikation mit dem Client auftritt.
    /// * `McpError::DeserializationError`: Wenn die empfangenen Daten nicht deserialisiert werden können.
    async fn get_context(&self, context_id: Uuid) -> Result<ModelContext, McpError>;

    /// Löscht einen Kontext anhand seiner ID.
    ///
    /// # Arguments
    /// * `context_id` - Die `Uuid` des zu löschenden Kontextes.
    ///
    /// # Errors
    /// * `McpError::ContextNotFound`: Wenn kein Kontext mit der angegebenen ID gefunden wird.
    /// * `McpError::ClientCommunicationError`: Wenn ein Fehler bei der Kommunikation mit dem Client auftritt.
    async fn delete_context(&self, context_id: Uuid) -> Result<(), McpError>;

    /// Führt eine Inferenzanfrage an ein KI-Modell aus.
    ///
    /// # Arguments
    /// * `model_id` - Die `ModelId` des Modells, das für die Inferenz verwendet werden soll.
    /// * `request` - Die `ModelRequest`-Struktur, die die Details der Inferenzanfrage enthält.
    ///
    /// # Returns
    /// Eine `ModelResponse`-Struktur, die die Antwort des Modells enthält.
    ///
    /// # Errors
    /// * `McpError::ModelNotFound`: Wenn das angegebene Modell nicht existiert.
    /// * `McpError::UnsupportedModelType`: Wenn die Anfrage nicht für den Modelltyp geeignet ist.
    /// * `McpError::CapabilityExceeded`: Wenn die Anfrage die Modellkapazitäten überschreitet.
    /// * `McpError::RateLimitExceeded`: Wenn ein Ratenlimit erreicht wurde.
    /// * `McpError::InferenceError`: Wenn das Modell einen Fehler während der Inferenz zurückgibt.
    /// * `McpError::ClientCommunicationError`: Wenn ein Fehler bei der Kommunikation mit dem Client auftritt.
    /// * `McpError::SerializationError`: Wenn die Anfrage nicht serialisiert werden kann.
    /// * `McpError::DeserializationError`: Wenn die Antwort nicht deserialisiert werden kann.
    async fn perform_inference(
        &self,
        model_id: ModelId,
        request: ModelRequest,
    ) -> Result<ModelResponse, McpError>;
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (28 von 100) widmet sich der Definition des Haupt-Service-Traits für das Model Context Protocol (MCP) Modul in der Domänenschicht (`novade-domain`). Die Datei `mcp_service_iface.rs` wird den `McpService`-Trait definieren, der die Geschäftlogik und Anwendungsfälle rund um KI-Modelle kapselt.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 28/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.18.4. `novade-domain/src/mcp/mcp_service_iface.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/mcp/mcp_service_iface.rs`

  * **Verantwortlichkeit:** Definiert die abstrakte Schnittstelle (`Trait`) für den MCP-Domänenservice. Dieser Trait kapselt die höhere Geschäftslogik und Anwendungsfälle, die sich auf die Verwaltung von KI-Modellen, Kontexten und die Durchführung von Inferenzanfragen beziehen. Er nutzt den `McpClient`-Trait aus der Systemschicht, um die eigentliche Kommunikation zu delegieren, fügt aber Validierung, Fehlerbehandlung und orchestrale Logik hinzu.

  * **Kern-Aufgaben (Tasks):**

    1.  **`McpService` (Trait) definieren:**
          * Muss `async_trait` verwenden.
          * **Methoden:**
              * **`add_model(&self, config: ModelConfiguration) -> Result<(), McpError>`:**
                  * Zweck: Fügt ein neues KI-Modell zur NovaDE-Umgebung hinzu.
                  * Validierungslogik: Überprüft, ob die `config.model_id` noch nicht existiert. Validiert die Gültigkeit der `ModelConfiguration` (z.B. ob `model_name` nicht leer ist, `endpoint.uri` gültig ist, `model_type` bekannt oder `Custom` ist).
                  * Delegiert an `mcp_client.register_model()`.
                  * Parameter: `config: ModelConfiguration` – Die vollständige Konfiguration des hinzuzufügenden Modells.
                  * Rückgabe: `Result<(), McpError>` – `Ok(())` bei Erfolg, `Err(McpError)` (z.B. `InvalidModelConfiguration`, `ClientCommunicationError`, `InternalError` bei Duplikaten oder Validierungsfehlern).
              * **`update_model_configuration(&self, config: ModelConfiguration) -> Result<(), McpError>`:**
                  * Zweck: Aktualisiert die Konfiguration eines bestehenden KI-Modells.
                  * Validierungslogik: Überprüft, ob das Modell mit `config.model_id` existiert. Validiert die Gültigkeit der aktualisierten `ModelConfiguration`.
                  * Delegiert an `mcp_client.update_model()`.
                  * Parameter: `config: ModelConfiguration` – Die aktualisierte Konfiguration.
                  * Rückgabe: `Result<(), McpError>` – `Ok(())` bei Erfolg, `Err(McpError)` (z.B. `ModelNotFound`, `InvalidModelConfiguration`, `ClientCommunicationError`).
              * **`remove_model(&self, model_id: ModelId) -> Result<(), McpError>`:**
                  * Zweck: Entfernt ein KI-Modell aus der Umgebung.
                  * Validierungslogik: Überprüft, ob das Modell existiert.
                  * Delegiert an `mcp_client.unregister_model()`.
                  * Parameter: `model_id: ModelId` – Die ID des zu entfernenden Modells.
                  * Rückgabe: `Result<(), McpError>` – `Ok(())` bei Erfolg, `Err(McpError)` (z.B. `ModelNotFound`, `ClientCommunicationError`).
              * **`get_all_models(&self) -> Result<Vec<ModelConfiguration>, McpError>`:**
                  * Zweck: Ruft alle registrierten KI-Modellkonfigurationen ab.
                  * Delegiert an `mcp_client.get_model_configurations()`.
                  * Parameter: Keine.
                  * Rückgabe: `Result<Vec<ModelConfiguration>, McpError>` – Eine Liste von Modellkonfigurationen.
              * **`get_model_by_id(&self, model_id: ModelId) -> Result<ModelConfiguration, McpError>`:**
                  * Zweck: Ruft eine spezifische Modellkonfiguration ab.
                  * Delegiert an `mcp_client.get_model_configuration()`.
                  * Parameter: `model_id: ModelId` – Die ID des abzurufenden Modells.
                  * Rückgabe: `Result<ModelConfiguration, McpError>` – Die Modellkonfiguration.
              * **`get_default_model_for_type(&self, model_type: ModelType) -> Result<ModelConfiguration, McpError>`:**
                  * Zweck: Ruft das als Standard definierte Modell für einen bestimmten `ModelType` ab.
                  * Logik: Filtert alle Modelle nach `model_type` und gibt das erste `is_default == true` Modell zurück. Falls keines als Standard markiert ist, könnte der Service ein beliebiges aktiviertes Modell dieses Typs zurückgeben oder einen Fehler werfen. **Entscheidung: Wirft `McpError::ModelNotFound` falls kein Standard oder kein Modell gefunden wird.**
                  * Parameter: `model_type: ModelType` – Der Typ des Modells.
                  * Rückgabe: `Result<ModelConfiguration, McpError>` – Die Standard-Modellkonfiguration.
              * **`set_default_model_for_type(&self, model_id: ModelId) -> Result<(), McpError>`:**
                  * Zweck: Setzt ein bestimmtes Modell als Standard für seinen `ModelType`.
                  * Logik: Holt das Modell, setzt `is_default` auf `true` und `is_enabled` auf `true` (falls nicht bereits). Setzt `is_default` für alle anderen Modelle desselben `ModelType` auf `false`. Aktualisiert die Konfigurationen über den `mcp_client`.
                  * Parameter: `model_id: ModelId` – Die ID des Modells, das als Standard gesetzt werden soll.
                  * Rückgabe: `Result<(), McpError>` – `Ok(())` bei Erfolg.
              * **`create_new_context(&self, model_id: ModelId, initial_data: Option<String>, context_type: String, metadata: Option<HashMap<String, String>>) -> Result<ModelContext, McpError>`:**
                  * Zweck: Erstellt einen neuen Kontext für ein spezifisches Modell.
                  * Validierungslogik: Überprüft, ob das Modell mit `model_id` existiert und aktiv ist (`is_enabled`).
                  * Delegiert an `mcp_client.create_context()`.
                  * Parameter: Siehe `McpClient::create_context`.
                  * Rückgabe: `Result<ModelContext, McpError>`.
              * **`update_model_context(&self, context: ModelContext) -> Result<(), McpError>`:**
                  * Zweck: Aktualisiert einen bestehenden Kontext.
                  * Validierungslogik: Überprüft, ob der Kontext existiert und die `model_id` des Kontextes mit einem aktiven Modell übereinstimmt.
                  * Delegiert an `mcp_client.update_context()`.
                  * Parameter: `context: ModelContext` – Der zu aktualisierende Kontext.
                  * Rückgabe: `Result<(), McpError>`.
              * **`get_context_by_id(&self, context_id: Uuid) -> Result<ModelContext, McpError>`:**
                  * Zweck: Ruft einen spezifischen Kontext ab.
                  * Delegiert an `mcp_client.get_context()`.
                  * Parameter: `context_id: Uuid` – Die ID des abzurufenden Kontextes.
                  * Rückgabe: `Result<ModelContext, McpError>`.
              * **`delete_model_context(&self, context_id: Uuid) -> Result<(), McpError>`:**
                  * Zweck: Löscht einen Kontext.
                  * Delegiert an `mcp_client.delete_context()`.
                  * Parameter: `context_id: Uuid` – Die ID des zu löschenden Kontextes.
                  * Rückgabe: `Result<(), McpError>`.
              * **`infer_text_generation(&self, model_id: ModelId, prompt: String, max_tokens: Option<u32>, temperature: Option<f32>, context_id: Option<Uuid>) -> Result<String, McpError>`:**
                  * Zweck: Führt eine Textgenerierungsanfrage aus.
                  * Validierung: Überprüft, ob Modell existiert, aktiviert ist und `ModelType::TextGeneration` ist. Überprüft `max_tokens` und `temperature` gegen Modellfähigkeiten.
                  * Kapselt `ModelRequest::TextGeneration` und ruft `perform_inference` auf. Extrahiert `generated_text` aus der Antwort.
                  * Rückgabe: `Result<String, McpError>` – Der generierte Text.
              * **`infer_image_generation(&self, model_id: ModelId, prompt: String, width: u32, height: u32, num_images: Option<u32>, context_id: Option<Uuid>) -> Result<Vec<String>, McpError>`:**
                  * Zweck: Führt eine Bildgenerierungsanfrage aus.
                  * Validierung: Überprüft, ob Modell existiert, aktiviert ist und `ModelType::ImageGeneration` ist. Überprüft Dimensionen und `num_images` gegen Modellfähigkeiten.
                  * Kapselt `ModelRequest::ImageGeneration` und ruft `perform_inference` auf. Extrahiert `image_data_base64` aus der Antwort.
                  * Rückgabe: `Result<Vec<String>, McpError>` – Liste der Base64-kodierten Bilder.
              * **`infer_text_embedding(&self, model_id: ModelId, text: String) -> Result<Vec<f32>, McpError>`:**
                  * Zweck: Führt eine Text-Embedding-Anfrage aus.
                  * Validierung: Überprüft, ob Modell existiert, aktiviert ist und `ModelType::TextEmbedding` ist.
                  * Kapselt `ModelRequest::TextEmbedding` und ruft `perform_inference` auf. Extrahiert `embedding` aus der Antwort.
                  * Rückgabe: `Result<Vec<f32>, McpError>` – Der Embedding-Vektor.
              * **`infer_sentiment_analysis(&self, model_id: ModelId, text: String) -> Result<(String, f32), McpError>`:**
                  * Zweck: Führt eine Stimmungsanalyseanfrage aus.
                  * Validierung: Überprüft, ob Modell existiert, aktiviert ist und `ModelType::SentimentAnalysis` ist.
                  * Kapselt `ModelRequest::SentimentAnalysis` und ruft `perform_inference` auf. Extrahiert `sentiment` und `score` aus der Antwort.
                  * Rückgabe: `Result<(String, f32), McpError>` – Stimmung und Score.
              * **`infer_categorization(&self, model_id: ModelId, text: String, categories: Vec<String>) -> Result<(Vec<String>, Vec<f32>), McpError>`:**
                  * Zweck: Führt eine Kategorisierungsanfrage aus.
                  * Validierung: Überprüft, ob Modell existiert, aktiviert ist und `ModelType::Categorization` ist.
                  * Kapselt `ModelRequest::Categorization` und ruft `perform_inference` auf. Extrahiert `categories` und `scores` aus der Antwort.
                  * Rückgabe: `Result<(Vec<String>, Vec<f32>), McpError>` – Kategorien und Scores.
              * **`infer_speech_to_text(&self, model_id: ModelId, audio_data_base64: String, language: Option<String>) -> Result<String, McpError>`:**
                  * Zweck: Führt eine Speech-to-Text-Anfrage aus.
                  * Validierung: Überprüft, ob Modell existiert, aktiviert ist und `ModelType::SpeechToText` ist.
                  * Kapselt `ModelRequest::SpeechToText` und ruft `perform_inference` auf. Extrahiert `transcribed_text` aus der Antwort.
                  * Rückgabe: `Result<String, McpError>` – Der transkribierte Text.
              * **`infer_text_to_speech(&self, model_id: ModelId, text: String, voice: Option<String>, format: Option<String>) -> Result<(String, String), McpError>`:**
                  * Zweck: Führt eine Text-to-Speech-Anfrage aus.
                  * Validierung: Überprüft, ob Modell existiert, aktiviert ist und `ModelType::TextToSpeech` ist.
                  * Kapselt `ModelRequest::TextToSpeech` und ruft `perform_inference` auf. Extrahiert `audio_data_base64` und `format` aus der Antwort.
                  * Rückgabe: `Result<(String, String), McpError>` – Base64-kodierte Audiodaten und Format.

  * **Spezifische Artefakte/Dateien:**

      * `novade-domain/src/mcp/mcp_service_iface.rs`

  * **Abhängigkeiten:**

      * **Intern:** `crate::mcp::data_types::{ModelId, ModelType, ModelConfiguration, ModelContext, ModelRequest, ModelResponse}`, `crate::mcp::errors::McpError`, `crate::mcp::mcp_client_iface::McpClient`.
      * **Extern:** `async_trait`, `uuid::Uuid`, `std::collections::HashMap`, `std::sync::Arc`, `tokio::sync::Mutex` (oder `RwLock` für interne Zustandsverwaltung der konkreten Implementierung).

  * **Kommunikationsmuster:**

      * Dieser Trait wird von der konkreten Implementierung des `McpService` verwendet, die in der `novade-domain/src/mcp/service.rs` definiert wird.
      * Services aus anderen Domänenmodulen (z.B. `DesktopStateService` oder `GlobalSettingsService`) könnten auf diesen Trait angewiesen sein, um KI-Funktionalitäten zu integrieren.

  * **Erwartete Ergebnisse/Outputs:**

      * Eine gut definierte, asynchrone API für die KI-Integration in der Domänenschicht.
      * Trennung der Geschäftslogik von der externen Client-Kommunikation.

  * **Teststrategie (Modul-spezifisch):**

      * Keine direkten Unit Tests für den Trait selbst.
      * Tests werden für die konkrete Implementierung (`DefaultMcpService` in `service.rs`) durchgeführt, die Mock-Implementierungen des `McpClient`-Traits verwendet.


#### Funktionsspezifikation: `novade_domain::mcp::mcp_service_iface`

```rust
// novade-domain/src/mcp/mcp_service_iface.rs

//! Definiert die Trait-Schnittstelle für den Model Context Protocol (MCP) Domänenservice.
//!
//! Dieser Trait kapselt die höhere Geschäftslogik und Anwendungsfälle, die sich auf die
//! Verwaltung von KI-Modellen, Kontexten und die Durchführung von Inferenzanfragen beziehen.
//! Er baut auf dem `McpClient`-Trait auf und fügt Validierung und orchestrale Logik hinzu.

use async_trait::async_trait;
use std::collections::HashMap;
use uuid::Uuid;

use crate::mcp::data_types::{
    ModelConfiguration, ModelContext, ModelId, ModelRequest, ModelResponse, ModelType,
};
use crate::mcp::errors::McpError;

/// Abstrakte Schnittstelle für den Model Context Protocol (MCP) Domänenservice.
///
/// Dieser Service stellt die höherwertige API für die Interaktion mit KI-Modellen bereit,
/// einschließlich der Modell- und Kontextverwaltung sowie spezifischer Inferenztypen.
#[async_trait]
pub trait McpService: Send + Sync {
    /// Fügt eine neue KI-Modellkonfiguration hinzu und registriert sie beim zugrunde liegenden MCP-Client.
    ///
    /// Führt Validierungen der `ModelConfiguration` durch.
    ///
    /// # Arguments
    /// * `config` - Die `ModelConfiguration` des hinzuzufügenden Modells.
    ///
    /// # Errors
    /// * `McpError::InvalidModelConfiguration`: Wenn die Konfiguration ungültig ist.
    /// * `McpError::ClientCommunicationError`: Bei Kommunikationsfehlern mit dem MCP-Client.
    /// * `McpError::InternalError`: Wenn ein Modell mit derselben ID bereits existiert.
    async fn add_model(&self, config: ModelConfiguration) -> Result<(), McpError>;

    /// Aktualisiert die Konfiguration eines bestehenden KI-Modells.
    ///
    /// Validiert die `ModelConfiguration` und delegiert an den MCP-Client.
    ///
    /// # Arguments
    /// * `config` - Die aktualisierte `ModelConfiguration`.
    ///
    /// # Errors
    /// * `McpError::ModelNotFound`: Wenn kein Modell mit der angegebenen ID gefunden wird.
    /// * `McpError::InvalidModelConfiguration`: Wenn die Konfiguration ungültig ist.
    /// * `McpError::ClientCommunicationError`: Bei Kommunikationsfehlern mit dem MCP-Client.
    async fn update_model_configuration(&self, config: ModelConfiguration) -> Result<(), McpError>;

    /// Entfernt ein KI-Modell aus der Umgebung.
    ///
    /// # Arguments
    /// * `model_id` - Die `ModelId` des zu entfernenden Modells.
    ///
    /// # Errors
    /// * `McpError::ModelNotFound`: Wenn kein Modell mit der angegebenen ID gefunden wird.
    /// * `McpError::ClientCommunicationError`: Bei Kommunikationsfehlern mit dem MCP-Client.
    async fn remove_model(&self, model_id: ModelId) -> Result<(), McpError>;

    /// Ruft alle registrierten KI-Modellkonfigurationen ab.
    ///
    /// # Returns
    /// Eine Liste von `ModelConfiguration` Instanzen.
    ///
    /// # Errors
    /// * `McpError::ClientCommunicationError`: Bei Kommunikationsfehlern mit dem MCP-Client.
    /// * `McpError::DeserializationError`: Bei Fehlern beim Deserialisieren von Daten.
    async fn get_all_models(&self) -> Result<Vec<ModelConfiguration>, McpError>;

    /// Ruft eine spezifische Modellkonfiguration anhand ihrer ID ab.
    ///
    /// # Arguments
    /// * `model_id` - Die `ModelId` des abzurufenden Modells.
    ///
    /// # Returns
    /// Die `ModelConfiguration` des angeforderten Modells.
    ///
    /// # Errors
    /// * `McpError::ModelNotFound`: Wenn kein Modell mit der angegebenen ID gefunden wird.
    /// * `McpError::ClientCommunicationError`: Bei Kommunikationsfehlern mit dem MCP-Client.
    /// * `McpError::DeserializationError`: Bei Fehlern beim Deserialisieren von Daten.
    async fn get_model_by_id(&self, model_id: ModelId) -> Result<ModelConfiguration, McpError>;

    /// Ruft das als Standard definierte Modell für einen bestimmten `ModelType` ab.
    ///
    /// Falls kein explizites Standardmodell gefunden wird, wird der Fehler `McpError::ModelNotFound` zurückgegeben.
    ///
    /// # Arguments
    /// * `model_type` - Der `ModelType`, für den das Standardmodell gesucht wird.
    ///
    /// # Returns
    /// Die `ModelConfiguration` des Standardmodells.
    ///
    /// # Errors
    /// * `McpError::ModelNotFound`: Wenn kein Standardmodell für den Typ gefunden wird.
    /// * `McpError::ClientCommunicationError`: Bei Kommunikationsfehlern.
    /// * `McpError::DeserializationError`: Bei Deserialisierungsfehlern.
    async fn get_default_model_for_type(&self, model_type: ModelType) -> Result<ModelConfiguration, McpError>;

    /// Setzt ein bestimmtes Modell als Standard für seinen `ModelType`.
    ///
    /// Das Modell muss existieren und `is_enabled` sein. Alle anderen Modelle desselben
    /// `ModelType` werden auf `is_default = false` gesetzt.
    ///
    /// # Arguments
    /// * `model_id` - Die `ModelId` des Modells, das als Standard gesetzt werden soll.
    ///
    /// # Errors
    /// * `McpError::ModelNotFound`: Wenn das Modell nicht existiert.
    /// * `McpError::ClientCommunicationError`: Bei Kommunikationsfehlern.
    /// * `McpError::DeserializationError`: Bei Deserialisierungsfehlern (beim Abrufen von Modellen).
    /// * `McpError::SerializationError`: Bei Serialisierungsfehlern (beim Senden aktualisierter Modelle).
    async fn set_default_model_for_type(&self, model_id: ModelId) -> Result<(), McpError>;

    /// Erstellt einen neuen Kontext für ein spezifisches KI-Modell.
    ///
    /// Validiert die Existenz und Aktivität des Modells.
    ///
    /// # Arguments
    /// * `model_id` - Die `ModelId` des Modells, für das der Kontext erstellt wird.
    /// * `initial_data` - Optionale Startdaten für den Kontext.
    /// * `context_type` - Der Typ des Kontextes.
    /// * `metadata` - Optionale Metadaten.
    ///
    /// # Returns
    /// Die neu erstellte `ModelContext`-Instanz.
    ///
    /// # Errors
    /// * `McpError::ModelNotFound`: Wenn das angegebene Modell nicht existiert oder nicht aktiv ist.
    /// * `McpError::ClientCommunicationError`: Bei Kommunikationsfehlern.
    /// * `McpError::InternalError`: Bei unerwarteten internen Fehlern.
    async fn create_new_context(
        &self,
        model_id: ModelId,
        initial_data: Option<String>,
        context_type: String,
        metadata: Option<HashMap<String, String>>,
    ) -> Result<ModelContext, McpError>;

    /// Aktualisiert einen bestehenden Kontext.
    ///
    /// Validiert die Existenz des Kontextes und die Übereinstimmung mit einem aktiven Modell.
    ///
    /// # Arguments
    /// * `context` - Die zu aktualisierende `ModelContext`-Instanz.
    ///
    /// # Errors
    /// * `McpError::ContextNotFound`: Wenn kein Kontext mit der angegebenen ID gefunden wird.
    /// * `McpError::ModelNotFound`: Wenn das zugehörige Modell nicht gefunden oder nicht aktiv ist.
    /// * `McpError::ClientCommunicationError`: Bei Kommunikationsfehlern.
    async fn update_model_context(&self, context: ModelContext) -> Result<(), McpError>;

    /// Ruft einen spezifischen Kontext anhand seiner ID ab.
    ///
    /// # Arguments
    /// * `context_id` - Die `Uuid` des abzurufenden Kontextes.
    ///
    /// # Returns
    /// Die `ModelContext` des angeforderten Kontextes.
    ///
    /// # Errors
    /// * `McpError::ContextNotFound`: Wenn kein Kontext mit der angegebenen ID gefunden wird.
    /// * `McpError::ClientCommunicationError`: Bei Kommunikationsfehlern.
    /// * `McpError::DeserializationError`: Bei Deserialisierungsfehlern.
    async fn get_context_by_id(&self, context_id: Uuid) -> Result<ModelContext, McpError>;

    /// Löscht einen Kontext anhand seiner ID.
    ///
    /// # Arguments
    /// * `context_id` - Die `Uuid` des zu löschenden Kontextes.
    ///
    /// # Errors
    /// * `McpError::ContextNotFound`: Wenn kein Kontext mit der angegebenen ID gefunden wird.
    /// * `McpError::ClientCommunicationError`: Bei Kommunikationsfehlern.
    async fn delete_model_context(&self, context_id: Uuid) -> Result<(), McpError>;

    /// Führt eine Textgenerierungsanfrage an ein KI-Modell aus.
    ///
    /// Validiert den Modelltyp und die Parameter.
    ///
    /// # Arguments
    /// * `model_id` - Die `ModelId` des Modells.
    /// * `prompt` - Der Eingabe-Prompt.
    /// * `max_tokens` - Optionale maximale Tokenanzahl.
    /// * `temperature` - Optionale Generierungstemperatur.
    /// * `context_id` - Optionale Kontext-ID.
    ///
    /// # Returns
    /// Der generierte Text.
    ///
    /// # Errors
    /// * `McpError::ModelNotFound`: Wenn das Modell nicht existiert oder nicht aktiv ist.
    /// * `McpError::UnsupportedModelType`: Wenn das Modell kein Textgenerierungsmodell ist.
    /// * `McpError::CapabilityExceeded`: Wenn die Anfrage die Modellkapazitäten überschreitet.
    /// * `McpError::RateLimitExceeded`: Wenn ein Ratenlimit erreicht wurde.
    /// * `McpError::InferenceError`: Wenn das Modell einen Fehler zurückgibt.
    /// * `McpError::ClientCommunicationError`: Bei Kommunikationsfehlern.
    /// * `McpError::SerializationError`/`DeserializationError`.
    async fn infer_text_generation(
        &self,
        model_id: ModelId,
        prompt: String,
        max_tokens: Option<u32>,
        temperature: Option<f32>,
        context_id: Option<Uuid>,
    ) -> Result<String, McpError>;

    /// Führt eine Bildgenerierungsanfrage an ein KI-Modell aus.
    ///
    /// Validiert den Modelltyp und die Parameter.
    ///
    /// # Arguments
    /// * `model_id` - Die `ModelId` des Modells.
    /// * `prompt` - Der Text-Prompt.
    /// * `width` - Gewünschte Bildbreite.
    /// * `height` - Gewünschte Bildhöhe.
    /// * `num_images` - Optionale Anzahl der zu generierenden Bilder.
    /// * `context_id` - Optionale Kontext-ID.
    ///
    /// # Returns
    /// Eine Liste von Base64-kodierten Bilddaten-Strings.
    ///
    /// # Errors
    /// * Siehe `infer_text_generation` für allgemeine Fehler.
    /// * `McpError::UnsupportedModelType`: Wenn das Modell kein Bildgenerierungsmodell ist.
    async fn infer_image_generation(
        &self,
        model_id: ModelId,
        prompt: String,
        width: u32,
        height: u32,
        num_images: Option<u32>,
        context_id: Option<Uuid>,
    ) -> Result<Vec<String>, McpError>;

    /// Führt eine Text-Embedding-Anfrage an ein KI-Modell aus.
    ///
    /// Validiert den Modelltyp.
    ///
    /// # Arguments
    /// * `model_id` - Die `ModelId` des Modells.
    /// * `text` - Der Text, für den ein Embedding erstellt werden soll.
    ///
    /// # Returns
    /// Der generierte Embedding-Vektor.
    ///
    /// # Errors
    /// * Siehe `infer_text_generation` für allgemeine Fehler.
    /// * `McpError::UnsupportedModelType`: Wenn das Modell kein Text-Embedding-Modell ist.
    async fn infer_text_embedding(&self, model_id: ModelId, text: String) -> Result<Vec<f32>, McpError>;

    /// Führt eine Stimmungsanalyseanfrage an ein KI-Modell aus.
    ///
    /// Validiert den Modelltyp.
    ///
    /// # Arguments
    /// * `model_id` - Die `ModelId` des Modells.
    /// * `text` - Der zu analysierende Text.
    ///
    /// # Returns
    /// Ein Tupel aus der erkannten Stimmung (String) und dem Score (f32).
    ///
    /// # Errors
    /// * Siehe `infer_text_generation` für allgemeine Fehler.
    /// * `McpError::UnsupportedModelType`: Wenn das Modell kein Stimmungsanalyse-Modell ist.
    async fn infer_sentiment_analysis(&self, model_id: ModelId, text: String) -> Result<(String, f32), McpError>;

    /// Führt eine Kategorisierungsanfrage an ein KI-Modell aus.
    ///
    /// Validiert den Modelltyp und die Kategorien.
    ///
    /// # Arguments
    /// * `model_id` - Die `ModelId` des Modells.
    /// * `text` - Der zu kategorisierende Text.
    /// * `categories` - Eine Liste von Kategorien, in die der Text eingeordnet werden soll.
    ///
    /// # Returns
    /// Ein Tupel aus der Liste der erkannten Kategorien und deren Scores.
    ///
    /// # Errors
    /// * Siehe `infer_text_generation` für allgemeine Fehler.
    /// * `McpError::UnsupportedModelType`: Wenn das Modell kein Kategorisierungsmodell ist.
    async fn infer_categorization(
        &self,
        model_id: ModelId,
        text: String,
        categories: Vec<String>,
    ) -> Result<(Vec<String>, Vec<f32>), McpError>;

    /// Führt eine Speech-to-Text-Anfrage an ein KI-Modell aus.
    ///
    /// Validiert den Modelltyp.
    ///
    /// # Arguments
    /// * `model_id` - Die `ModelId` des Modells.
    /// * `audio_data_base64` - Base64-kodierte Audiodaten.
    /// * `language` - Optionale Sprache des Audios.
    ///
    /// # Returns
    /// Der transkribierte Text.
    ///
    /// # Errors
    /// * Siehe `infer_text_generation` für allgemeine Fehler.
    /// * `McpError::UnsupportedModelType`: Wenn das Modell kein Speech-to-Text-Modell ist.
    async fn infer_speech_to_text(
        &self,
        model_id: ModelId,
        audio_data_base64: String,
        language: Option<String>,
    ) -> Result<String, McpError>;

    /// Führt eine Text-to-Speech-Anfrage an ein KI-Modell aus.
    ///
    /// Validiert den Modelltyp und die Parameter.
    ///
    /// # Arguments
    /// * `model_id` - Die `ModelId` des Modells.
    /// * `text` - Der zu sprechende Text.
    /// * `voice` - Optionale Stimme.
    /// * `format` - Optionales Ausgabeformat.
    ///
    /// # Returns
    /// Ein Tupel aus Base64-kodierten Audiodaten und dem Format.
    ///
    /// # Errors
    /// * Siehe `infer_text_generation` für allgemeine Fehler.
    /// * `McpError::UnsupportedModelType`: Wenn das Modell kein Text-to-Speech-Modell ist.
    async fn infer_text_to_speech(
        &self,
        model_id: ModelId,
        text: String,
        voice: Option<String>,
        format: Option<String>,
    ) -> Result<(String, String), McpError>;
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (29 von 100) widmet sich der konkreten Implementierung des Model Context Protocol (MCP) Services in der Domänenschicht (`novade-domain`). Die Datei `service.rs` wird den `DefaultMcpService` definieren, der den `McpService`-Trait implementiert und die Geschäftslogik für die Interaktion mit KI-Modellen bereitstellt.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 29/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.18.5. `novade-domain/src/mcp/service.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/mcp/service.rs`

  * **Verantwortlichkeit:** Implementiert den `McpService`-Trait und kapselt die Geschäftslogik für die Verwaltung von KI-Modellen und Kontexten sowie die Durchführung von Inferenzanfragen. Dieser Service agiert als Orchestrator zwischen der Domänenlogik und dem unterliegenden `McpClient` (aus der Systemschicht), fügt Validierung, Zustandsmanagement (z.B. für Standardmodelle) und spezifische Anwendungsfälle hinzu.

  * **Kern-Aufgaben (Tasks):**

    1.  **`DefaultMcpService` Struktur definieren:**
          * Strukturfelder:
              * `mcp_client: Arc<dyn McpClient>`: Ein `Arc` auf eine Implementierung des `McpClient`-Traits. Ermöglicht Dependency Injection.
              * `model_configurations: Arc<RwLock<HashMap<ModelId, ModelConfiguration>>>`: Ein Thread-sicherer, gemeinsam genutzter Cache für alle bekannten Modellkonfigurationen. `RwLock` ist ideal, da Lesevorgänge häufiger sein werden als Schreibvorgänge.
              * `default_models: Arc<RwLock<HashMap<ModelType, ModelId>>>`: Ein Thread-sicherer Cache, der die `ModelId` des Standardmodells für jeden `ModelType` speichert.
    2.  **`DefaultMcpService::new()` Konstruktor implementieren:**
          * Nimmt ein `Arc<dyn McpClient>` entgegen.
          * Initialisiert `model_configurations` und `default_models` als leere `HashMap`s innerhalb von `RwLock`s.
          * Läd initial alle vorhandenen Modellkonfigurationen über `mcp_client.get_model_configurations()` und füllt `model_configurations` und `default_models` basierend auf `is_default` Flags. Fehler beim Initialisieren sollten protokolliert, aber nicht kritisch sein (Service kann starten, aber Modellliste ist möglicherweise unvollständig).
    3.  **Implementierung des `McpService`-Traits für `DefaultMcpService`:**
          * **`add_model(&self, config: ModelConfiguration) -> Result<(), McpError>`:**
              * **Validierung:**
                  * Prüfen, ob `config.model_id` bereits in `self.model_configurations` existiert. Wenn ja, `McpError::InternalError` zurückgeben (oder spezifischer `ModelAlreadyExists`).
                  * Validieren, dass `config.model_name` nicht leer ist.
                  * Validieren, dass `config.endpoint.uri` ein gültiges URI-Format hat (z.B. rudimentärer Regex-Check oder `url::Url::parse()`).
                  * Validieren, dass `config.model_type` ein gültiger `ModelType` ist.
              * **Logik:**
                  * Ruft `self.mcp_client.register_model(config.clone()).await?` auf.
                  * Bei Erfolg: `config.model_id` in `self.model_configurations` einfügen.
                  * Wenn `config.is_default` `true` ist: `set_default_model_for_type(config.model_id).await?` aufrufen (die Logik zum Deaktivieren anderer Standardmodelle ist dort gekapselt).
          * **`update_model_configuration(&self, config: ModelConfiguration) -> Result<(), McpError>`:**
              * **Validierung:**
                  * Prüfen, ob `config.model_id` in `self.model_configurations` existiert. Wenn nein, `McpError::ModelNotFound` zurückgeben.
                  * Validieren der `ModelConfiguration` wie bei `add_model`.
              * **Logik:**
                  * Ruft `self.mcp_client.update_model(config.clone()).await?` auf.
                  * Bei Erfolg: `self.model_configurations` aktualisieren.
                  * Wenn `config.is_default` `true` ist: `set_default_model_for_type(config.model_id).await?` aufrufen.
                  * Wenn `config.is_default` `false` ist und es vorher der Standard war: `self.default_models` entsprechend aktualisieren (entfernen des Eintrags für `config.model_type` falls es das letzte Standardmodell war).
          * **`remove_model(&self, model_id: ModelId) -> Result<(), McpError>`:**
              * **Validierung:**
                  * Prüfen, ob `model_id` in `self.model_configurations` existiert. Wenn nein, `McpError::ModelNotFound` zurückgeben.
              * **Logik:**
                  * Ruft `self.mcp_client.unregister_model(model_id).await?` auf.
                  * Bei Erfolg: `model_id` aus `self.model_configurations` entfernen.
                  * Wenn `model_id` ein Standardmodell in `self.default_models` war, diesen Eintrag ebenfalls entfernen.
          * **`get_all_models(&self) -> Result<Vec<ModelConfiguration>, McpError>`:**
              * **Logik:**
                  * Liest den `model_configurations` Cache und gibt eine geklonte Liste zurück. (Performance-Optimierung: Client-Aufruf nur bei Cache-Miss oder explizitem Refresh).
                  * **Wichtiger Hinweis:** Für eine robuste Implementierung sollte hier ein Cache-Invalidierungsmechanismus oder ein regelmäßiger Refresh in Betracht gezogen werden, falls sich die Modelle außerhalb der Kontrolle des `DefaultMcpService` ändern können. Für den initialen Scope ist ein einfacher Read-Through-Cache ausreichend.
                  * `self.mcp_client.get_model_configurations().await` wird direkt aufgerufen, um sicherzustellen, dass immer der aktuelle Zustand des D-Bus-Dienstes abgefragt wird. Dann den Cache aktualisieren.
          * **`get_model_by_id(&self, model_id: ModelId) -> Result<ModelConfiguration, McpError>`:**
              * **Logik:**
                  * Versucht, das Modell aus `self.model_configurations` zu lesen.
                  * Falls nicht gefunden, ruft `self.mcp_client.get_model_configuration(model_id).await` auf und aktualisiert den Cache, bevor das Ergebnis zurückgegeben wird. Wenn dann immer noch nicht gefunden, `McpError::ModelNotFound`.
          * **`get_default_model_for_type(&self, model_type: ModelType) -> Result<ModelConfiguration, McpError>`:**
              * **Logik:**
                  * Versucht, die Standard-ID aus `self.default_models` zu holen.
                  * Wenn gefunden, ruft `get_model_by_id` auf.
                  * Wenn nicht gefunden: Holt alle Modelle vom Client, filtert nach `model_type` und sucht nach einem Modell mit `is_default = true`. Wenn gefunden, aktualisiert `self.default_models` und gibt es zurück. Wenn nicht, `McpError::ModelNotFound`.
                  * Alternativ: Falls kein explizites Standardmodell für den Typ existiert, kann hier entschieden werden, das erste gefundene aktivierte Modell dieses Typs zurückzugeben. **Entscheidung: Wirft `McpError::ModelNotFound` falls kein Modell mit `is_default = true` gefunden wird.**
          * **`set_default_model_for_type(&self, model_id: ModelId) -> Result<(), McpError>`:**
              * **Logik:**
                  * Hole das Modell mit `model_id` über `get_model_by_id`.
                  * Falls nicht gefunden, `McpError::ModelNotFound`.
                  * Stelle sicher, dass `model.is_enabled` `true` ist (oder setze es auf `true` und aktualisiere).
                  * Ruft `get_all_models` auf. Iteriert über alle Modelle desselben `ModelType`. Wenn ein anderes Modell `is_default = true` hat, setze dessen `is_default` auf `false` und rufe `mcp_client.update_model` auf.
                  * Setze `model.is_default` auf `true` und rufe `mcp_client.update_model` auf.
                  * Aktualisiere `self.default_models` und `self.model_configurations` entsprechend.
          * **`create_new_context(&self, model_id: ModelId, initial_data: Option<String>, context_type: String, metadata: Option<HashMap<String, String>>) -> Result<ModelContext, McpError>`:**
              * **Validierung:**
                  * Prüfen, ob das Modell mit `model_id` existiert und `is_enabled` ist. Wenn nein, `McpError::ModelNotFound`.
              * **Logik:**
                  * Delegiert an `self.mcp_client.create_context(...)`.
          * **`update_model_context(&self, context: ModelContext) -> Result<(), McpError>`:**
              * **Validierung:**
                  * Prüfen, ob der Kontext mit `context.id` existiert (via `get_context_by_id`).
                  * Prüfen, ob das zugehörige Modell (`context.model_id`) existiert und `is_enabled` ist.
              * **Logik:**
                  * Delegiert an `self.mcp_client.update_context(...)`.
          * **`get_context_by_id(&self, context_id: Uuid) -> Result<ModelContext, McpError>`:**
              * **Logik:**
                  * Delegiert an `self.mcp_client.get_context(...)`.
          * **`delete_model_context(&self, context_id: Uuid) -> Result<(), McpError>`:**
              * **Logik:**
                  * Delegiert an `self.mcp_client.delete_context(...)`.
          * **`infer_text_generation(&self, model_id: ModelId, prompt: String, max_tokens: Option<u32>, temperature: Option<f32>, context_id: Option<Uuid>) -> Result<String, McpError>`:**
              * **Validierung:**
                  * Hole Modellkonfiguration: `get_model_by_id(model_id)`.
                  * Prüfe `model.is_enabled`.
                  * Prüfe `model.model_type == ModelType::TextGeneration`. Wenn nein, `McpError::UnsupportedModelType`.
                  * Überprüfe `max_tokens` und `temperature` gegen `model.capabilities`. Wenn außerhalb des Bereichs, `McpError::CapabilityExceeded`.
                  * Wenn `context_id` vorhanden, prüfe dessen Existenz via `get_context_by_id` und ob dessen `model_id` mit der Anfrage übereinstimmt.
              * **Logik:**
                  * Erstelle `ModelRequest::TextGeneration` mit den Parametern.
                  * Rufe `self.mcp_client.perform_inference(model_id, request).await?` auf.
                  * Passe die `ModelResponse` an: Extrahiere `generated_text` aus `ModelResponse::TextGenerationResult`. Wenn der Typ nicht übereinstimmt, `McpError::InternalError`.
          * **`infer_image_generation(&self, model_id: ModelId, prompt: String, width: u32, height: u32, num_images: Option<u32>, context_id: Option<Uuid>) -> Result<Vec<String>, McpError>`:**
              * **Validierung:** Ähnlich wie `infer_text_generation` für `ModelType::ImageGeneration`, `width`, `height`, `num_images` gegen `capabilities`.
              * **Logik:** Erstelle `ModelRequest::ImageGeneration`, rufe `perform_inference` auf, extrahiere `image_data_base64` aus `ModelResponse::ImageGenerationResult`.
          * **`infer_text_embedding(&self, model_id: ModelId, text: String) -> Result<Vec<f32>, McpError>`:**
              * **Validierung:** Ähnlich wie oben für `ModelType::TextEmbedding`.
              * **Logik:** Erstelle `ModelRequest::TextEmbedding`, rufe `perform_inference` auf, extrahiere `embedding` aus `ModelResponse::TextEmbeddingResult`.
          * **`infer_sentiment_analysis(&self, model_id: ModelId, text: String) -> Result<(String, f32), McpError>`:**
              * **Validierung:** Ähnlich wie oben für `ModelType::SentimentAnalysis`.
              * **Logik:** Erstelle `ModelRequest::SentimentAnalysis`, rufe `perform_inference` auf, extrahiere `sentiment` und `score` aus `ModelResponse::SentimentAnalysisResult`.
          * **`infer_categorization(&self, model_id: ModelId, text: String, categories: Vec<String>) -> Result<(Vec<String>, Vec<f32>), McpError>`:**
              * **Validierung:** Ähnlich wie oben für `ModelType::Categorization`.
              * **Logik:** Erstelle `ModelRequest::Categorization`, rufe `perform_inference` auf, extrahiere `categories` und `scores` aus `ModelResponse::CategorizationResult`.
          * **`infer_speech_to_text(&self, model_id: ModelId, audio_data_base64: String, language: Option<String>) -> Result<String, McpError>`:**
              * **Validierung:** Ähnlich wie oben für `ModelType::SpeechToText`.
              * **Logik:** Erstelle `ModelRequest::SpeechToText`, rufe `perform_inference` auf, extrahiere `transcribed_text` aus `ModelResponse::SpeechToTextResult`.
          * **`infer_text_to_speech(&self, model_id: ModelId, text: String, voice: Option<String>, format: Option<String>) -> Result<(String, String), McpError>`:**
              * **Validierung:** Ähnlich wie oben für `ModelType::TextToSpeech`.
              * **Logik:** Erstelle `ModelRequest::TextToSpeech`, rufe `perform_inference` auf, extrahiere `audio_data_base64` und `format` aus `ModelResponse::TextToSpeechResult`.

  * **Spezifische Artefakte/Dateien:**

      * `novade-domain/src/mcp/service.rs`

  * **Abhängigkeiten:**

      * **Intern:** `crate::mcp::data_types::{...}`, `crate::mcp::errors::McpError`, `crate::mcp::mcp_client_iface::McpClient`, `crate::mcp::mcp_service_iface::McpService`.
      * **Extern:** `async_trait`, `uuid::Uuid`, `std::collections::HashMap`, `std::sync::{Arc, RwLock}`, `url::Url` (für URI-Validierung).

  * **Kommunikationsmuster:**

      * `DefaultMcpService` ruft Methoden auf dem `McpClient`-Trait auf.
      * Die Methoden des `DefaultMcpService` werden von Anwendungs- und UI-Schichten aufgerufen.

  * **Erwartete Ergebnisse/Outputs:**

      * Eine voll funktionsfähige Implementierung der MCP-Domänenlogik, die alle Kernanwendungsfälle abdeckt.
      * Robuste Validierung von Eingabedaten und Modellzuständen.
      * Effizientes internes Caching von Modellkonfigurationen.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * **Mocking:** Erstellung einer Mock-Implementierung des `McpClient`-Traits, um die Abhängigkeit zu isolieren. Nutze `mockall` oder manuelles Mocking.
          * Testen jeder Service-Methode (`add_model`, `update_model_configuration`, `remove_model`, `infer_...`) mit verschiedenen Szenarien:
              * Erfolgreiche Operationen.
              * Fehlerfälle (z.B. Modell nicht gefunden, ungültige Konfiguration, Client-Fehler, UnsupportedModelType, CapabilityExceeded).
              * Tests für `set_default_model_for_type`: Sicherstellen, dass andere Modelle korrekt auf `is_default = false` gesetzt werden.
              * Testen der Cache-Logik (z.B. dass `get_all_models` den internen Cache aktualisiert, wenn der Client aufgerufen wird).
              * Testen der Inferenzmethoden: Sicherstellen, dass die korrekten `ModelRequest`-Typen erstellt und die `ModelResponse`-Typen korrekt verarbeitet werden.


#### Funktionsspezifikation: `novade_domain::mcp::service`

```rust
// novade-domain/src/mcp/service.rs

//! Implementiert den Default Model Context Protocol (MCP) Domänenservice.
//!
//! Dieser Service kapselt die Geschäftslogik für die Verwaltung von KI-Modellen
//! und Kontexten sowie die Durchführung von Inferenzanfragen. Er agiert als
//! Orchestrator zwischen der Domänenlogik und dem unterliegenden McpClient.

use async_trait::async_trait;
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use uuid::Uuid;
use url::Url; // Für URI-Validierung

use crate::mcp::data_types::{
    ModelConfiguration, ModelContext, ModelId, ModelRequest, ModelResponse, ModelType,
    TextGenerationParams, ImageGenerationParams, EmbeddingParams, SentimentAnalysisParams,
    CategorizationParams, SpeechToTextParams, TextToSpeechParams
};
use crate::mcp::errors::McpError;
use crate::mcp::mcp_client_iface::McpClient;
use crate::mcp::mcp_service_iface::McpService;

/// Der Standardimplementierung des McpService-Traits.
/// Verwaltet den Lebenszyklus von KI-Modellen und Kontexten und führt Inferenzoperationen durch.
pub struct DefaultMcpService {
    /// Eine Referenz auf die Implementierung des MCP-Clients, der mit der Systemschicht kommuniziert.
    mcp_client: Arc<dyn McpClient>,
    /// Cache für alle bekannten Modellkonfigurationen, geschützt durch ein RwLock.
    model_configurations: Arc<RwLock<HashMap<ModelId, ModelConfiguration>>>,
    /// Cache für die IDs der Standardmodelle pro ModelType, geschützt durch ein RwLock.
    default_models: Arc<RwLock<HashMap<ModelType, ModelId>>>,
}

impl DefaultMcpService {
    /// Erstellt eine neue Instanz von `DefaultMcpService`.
    ///
    /// Initialisiert die internen Caches und versucht, alle vorhandenen Modellkonfigurationen
    /// vom MCP-Client zu laden.
    ///
    /// # Arguments
    /// * `mcp_client` - Ein `Arc` auf die MCP-Client-Implementierung.
    ///
    /// # Returns
    /// Eine neue `DefaultMcpService`-Instanz.
    pub async fn new(mcp_client: Arc<dyn McpClient>) -> Self {
        let service = Self {
            mcp_client,
            model_configurations: Arc::new(RwLock::new(HashMap::new())),
            default_models: Arc::new(RwLock::new(HashMap::new())),
        };

        // Initiales Laden aller Modelle
        match service.mcp_client.get_model_configurations().await {
            Ok(models) => {
                let mut model_configs_write = service.model_configurations.write().unwrap();
                let mut default_models_write = service.default_models.write().unwrap();
                for model in models {
                    model_configs_write.insert(model.model_id, model.clone());
                    if model.is_default {
                        default_models_write.insert(model.model_type, model.model_id);
                    }
                }
                tracing::info!("Successfully loaded initial model configurations.");
            }
            Err(e) => {
                tracing::error!("Failed to load initial model configurations: {:?}", e);
            }
        }

        service
    }

    /// Hilfsfunktion zur internen Validierung einer ModelConfiguration.
    fn validate_model_configuration(config: &ModelConfiguration) -> Result<(), McpError> {
        if config.model_name.trim().is_empty() {
            return Err(McpError::InvalidModelConfiguration {
                model_id: config.model_id,
                source: "Model name cannot be empty.".to_string(),
            });
        }
        if Url::parse(&config.endpoint.uri).is_err() {
            return Err(McpError::InvalidModelConfiguration {
                model_id: config.model_id,
                source: format!("Invalid endpoint URI: {}", config.endpoint.uri),
            });
        }
        // Weitere spezifische Validierungen können hier hinzugefügt werden (z.B. capabilities passend zum ModelType)
        Ok(())
    }
}

#[async_trait]
impl McpService for DefaultMcpService {
    async fn add_model(&self, config: ModelConfiguration) -> Result<(), McpError> {
        tracing::debug!("Attempting to add model: {:?}", config.model_id);

        Self::validate_model_configuration(&config)?;

        {
            let model_configs_read = self.model_configurations.read().unwrap();
            if model_configs_read.contains_key(&config.model_id) {
                return Err(McpError::InternalError {
                    message: format!("Model with ID '{}' already exists.", config.model_id),
                });
            }
        } // Read lock released

        self.mcp_client.register_model(config.clone()).await?;

        // Update internal cache
        let mut model_configs_write = self.model_configurations.write().unwrap();
        model_configs_write.insert(config.model_id, config.clone());

        if config.is_default {
            // Setzt dieses Modell als Standard für seinen Typ und deaktiviert andere.
            // Der Aufruf erfolgt intern, um die Logik nicht zu duplizieren.
            self.set_default_model_for_type(config.model_id).await?;
        }

        tracing::info!("Successfully added model: {}", config.model_id);
        Ok(())
    }

    async fn update_model_configuration(&self, config: ModelConfiguration) -> Result<(), McpError> {
        tracing::debug!("Attempting to update model: {:?}", config.model_id);

        Self::validate_model_configuration(&config)?;

        {
            let model_configs_read = self.model_configurations.read().unwrap();
            if !model_configs_read.contains_key(&config.model_id) {
                return Err(McpError::ModelNotFound { model_id: config.model_id });
            }
        } // Read lock released

        self.mcp_client.update_model(config.clone()).await?;

        // Update internal cache
        let mut model_configs_write = self.model_configurations.write().unwrap();
        model_configs_write.insert(config.model_id, config.clone());

        if config.is_default {
            self.set_default_model_for_type(config.model_id).await?;
        } else {
            // If it was default but now isn't, remove it from default_models map
            let mut default_models_write = self.default_models.write().unwrap();
            if default_models_write.get(&config.model_type) == Some(&config.model_id) {
                default_models_write.remove(&config.model_type);
                tracing::info!("Removed default status for model {} of type {}", config.model_id, config.model_type);
            }
        }

        tracing::info!("Successfully updated model: {}", config.model_id);
        Ok(())
    }

    async fn remove_model(&self, model_id: ModelId) -> Result<(), McpError> {
        tracing::debug!("Attempting to remove model: {:?}", model_id);

        let model_type;
        {
            let model_configs_read = self.model_configurations.read().unwrap();
            let model = model_configs_read
                .get(&model_id)
                .ok_or(McpError::ModelNotFound { model_id })?;
            model_type = model.model_type.clone();
        } // Read lock released

        self.mcp_client.unregister_model(model_id).await?;

        // Update internal caches
        let mut model_configs_write = self.model_configurations.write().unwrap();
        model_configs_write.remove(&model_id);

        let mut default_models_write = self.default_models.write().unwrap();
        if default_models_write.get(&model_type) == Some(&model_id) {
            default_models_write.remove(&model_type);
            tracing::info!("Removed default status for model {} of type {} due to removal.", model_id, model_type);
        }

        tracing::info!("Successfully removed model: {}", model_id);
        Ok(())
    }

    async fn get_all_models(&self) -> Result<Vec<ModelConfiguration>, McpError> {
        tracing::debug!("Fetching all model configurations.");
        let models_from_client = self.mcp_client.get_model_configurations().await?;

        // Update caches based on client data
        let mut model_configs_write = self.model_configurations.write().unwrap();
        let mut default_models_write = self.default_models.write().unwrap();

        model_configs_write.clear();
        default_models_write.clear();

        for model in models_from_client.into_iter() {
            if model.is_enabled { // Only cache and consider enabled models
                model_configs_write.insert(model.model_id, model.clone());
                if model.is_default {
                    default_models_write.insert(model.model_type, model.model_id);
                }
            }
        }

        Ok(model_configs_write.values().cloned().collect())
    }

    async fn get_model_by_id(&self, model_id: ModelId) -> Result<ModelConfiguration, McpError> {
        tracing::debug!("Fetching model by ID: {:?}", model_id);

        {
            let model_configs_read = self.model_configurations.read().unwrap();
            if let Some(config) = model_configs_read.get(&model_id) {
                if config.is_enabled {
                    return Ok(config.clone());
                }
            }
        } // Read lock released

        // If not in cache or not enabled, try client
        let model_from_client = self.mcp_client.get_model_configuration(model_id).await?;
        if !model_from_client.is_enabled {
             return Err(McpError::ModelNotFound { model_id }); // Treat disabled as not found for practical purposes
        }

        // Update cache
        self.model_configurations
            .write()
            .unwrap()
            .insert(model_id, model_from_client.clone());

        Ok(model_from_client)
    }

    async fn get_default_model_for_type(&self, model_type: ModelType) -> Result<ModelConfiguration, McpError> {
        tracing::debug!("Fetching default model for type: {:?}", model_type);

        {
            let default_models_read = self.default_models.read().unwrap();
            if let Some(model_id) = default_models_read.get(&model_type) {
                // Check if the cached default model is still enabled and valid
                if let Ok(config) = self.get_model_by_id(*model_id).await {
                    return Ok(config);
                }
            }
        } // Read lock released

        // If not found in default cache or invalid, try to find from all enabled models
        let all_models = self.get_all_models().await?; // This will refresh the cache
        for model in all_models {
            if model.model_type == model_type && model.is_default && model.is_enabled {
                // If found, update default_models cache and return
                self.default_models
                    .write()
                    .unwrap()
                    .insert(model_type, model.model_id);
                tracing::info!("Found and set default model {} for type {}", model.model_id, model_type);
                return Ok(model);
            }
        }

        Err(McpError::ModelNotFound {
            model_id: Uuid::nil(), // No specific model ID, just the type
        })
    }

    async fn set_default_model_for_type(&self, model_id: ModelId) -> Result<(), McpError> {
        tracing::debug!("Setting model {:?} as default.", model_id);

        let mut target_model = self.get_model_by_id(model_id).await?;

        if !target_model.is_enabled {
            tracing::warn!("Attempted to set disabled model {} as default. Enabling it.", model_id);
            target_model.is_enabled = true; // Enable if disabled
        }

        target_model.is_default = true;

        let model_type_to_update = target_model.model_type.clone();

        // Get all models to find others of the same type and unset their default status
        let all_models_current = self.get_all_models().await?;

        let mut models_to_update = Vec::new();

        for mut model in all_models_current {
            if model.model_id == model_id {
                models_to_update.push(target_model.clone()); // Add the target model itself
            } else if model.model_type == model_type_to_update && model.is_default {
                // Unset default for other models of the same type
                model.is_default = false;
                models_to_update.push(model);
            }
        }

        // Apply all updates via the client
        for model_to_send in models_to_update {
            self.mcp_client.update_model(model_to_send.clone()).await?;
            // Update local cache immediately after client call
            self.model_configurations.write().unwrap().insert(model_to_send.model_id, model_to_send.clone());
        }

        // Update default_models cache
        self.default_models.write().unwrap().insert(model_type_to_update, model_id);
        tracing::info!("Model {} set as default for type {}.", model_id, model_type_to_update);
        Ok(())
    }

    async fn create_new_context(
        &self,
        model_id: ModelId,
        initial_data: Option<String>,
        context_type: String,
        metadata: Option<HashMap<String, String>>,
    ) -> Result<ModelContext, McpError> {
        tracing::debug!("Creating new context for model: {:?}", model_id);
        let model = self.get_model_by_id(model_id).await?; // Check if model exists and is enabled
        if !model.is_enabled {
            return Err(McpError::ModelNotFound { model_id }); // Model found but disabled
        }

        self.mcp_client
            .create_context(model_id, initial_data, context_type, metadata)
            .await
    }

    async fn update_model_context(&self, context: ModelContext) -> Result<(), McpError> {
        tracing::debug!("Updating context: {:?}", context.id);
        // Ensure context exists (optional, client will validate too, but good for early exit)
        let _existing_context = self.get_context_by_id(context.id).await?;
        // Ensure the associated model exists and is enabled
        let model = self.get_model_by_id(context.model_id).await?;
        if !model.is_enabled {
            return Err(McpError::ModelNotFound { model_id: context.model_id }); // Model found but disabled
        }

        self.mcp_client.update_context(context).await
    }

    async fn get_context_by_id(&self, context_id: Uuid) -> Result<ModelContext, McpError> {
        tracing::debug!("Fetching context by ID: {:?}", context_id);
        self.mcp_client.get_context(context_id).await
    }

    async fn delete_model_context(&self, context_id: Uuid) -> Result<(), McpError> {
        tracing::debug!("Deleting context: {:?}", context_id);
        self.mcp_client.delete_context(context_id).await
    }

    async fn infer_text_generation(
        &self,
        model_id: ModelId,
        prompt: String,
        max_tokens: Option<u32>,
        temperature: Option<f32>,
        context_id: Option<Uuid>,
    ) -> Result<String, McpError> {
        tracing::debug!("Performing text generation inference for model: {:?}", model_id);

        let model = self.get_model_by_id(model_id).await?;
        if model.model_type != ModelType::TextGeneration {
            return Err(McpError::UnsupportedModelType { model_type: model.model_type });
        }
        if !model.is_enabled {
            return Err(McpError::ModelNotFound { model_id }); // Model found but disabled
        }

        // Validate max_tokens and temperature against model capabilities if present
        if let Some(max_t) = max_tokens {
            if let Some(cap) = &model.capabilities.max_tokens {
                if max_t > *cap {
                    return Err(McpError::CapabilityExceeded {
                        model_id,
                        capability_name: "max_tokens".to_string(),
                        current_value: max_t.to_string(),
                        limit_value: cap.to_string(),
                    });
                }
            }
        }
        if let Some(temp) = temperature {
            if let Some(cap) = &model.capabilities.temperature_range {
                if temp < cap.0 || temp > cap.1 {
                    return Err(McpError::CapabilityExceeded {
                        model_id,
                        capability_name: "temperature".to_string(),
                        current_value: temp.to_string(),
                        limit_value: format!("({}, {})", cap.0, cap.1),
                    });
                }
            }
        }

        if let Some(ctx_id) = context_id {
            let context = self.get_context_by_id(ctx_id).await?;
            if context.model_id != model_id {
                return Err(McpError::InternalError {
                    message: format!(
                        "Context {} belongs to model {} but inference requested for model {}",
                        ctx_id, context.model_id, model_id
                    ),
                });
            }
        }

        let request = ModelRequest::TextGeneration(TextGenerationParams {
            prompt,
            max_tokens,
            temperature,
            context_id,
        });

        match self.mcp_client.perform_inference(model_id, request).await? {
            ModelResponse::TextGenerationResult { generated_text } => Ok(generated_text),
            _ => Err(McpError::InternalError {
                message: "Unexpected response type for text generation inference.".to_string(),
            }),
        }
    }

    async fn infer_image_generation(
        &self,
        model_id: ModelId,
        prompt: String,
        width: u32,
        height: u32,
        num_images: Option<u32>,
        context_id: Option<Uuid>,
    ) -> Result<Vec<String>, McpError> {
        tracing::debug!("Performing image generation inference for model: {:?}", model_id);
        let model = self.get_model_by_id(model_id).await?;
        if model.model_type != ModelType::ImageGeneration {
            return Err(McpError::UnsupportedModelType { model_type: model.model_type });
        }
        if !model.is_enabled {
            return Err(McpError::ModelNotFound { model_id }); // Model found but disabled
        }

        // Validate width, height, num_images against capabilities
        // Assuming capabilities might have max_width, max_height, max_images, etc.
        // Implement similar checks as for text generation.

        if let Some(ctx_id) = context_id {
            let context = self.get_context_by_id(ctx_id).await?;
            if context.model_id != model_id {
                return Err(McpError::InternalError {
                    message: format!(
                        "Context {} belongs to model {} but inference requested for model {}",
                        ctx_id, context.model_id, model_id
                    ),
                });
            }
        }


        let request = ModelRequest::ImageGeneration(ImageGenerationParams {
            prompt,
            width,
            height,
            num_images,
            context_id,
        });

        match self.mcp_client.perform_inference(model_id, request).await? {
            ModelResponse::ImageGenerationResult { image_data_base64 } => Ok(image_data_base64),
            _ => Err(McpError::InternalError {
                message: "Unexpected response type for image generation inference.".to_string(),
            }),
        }
    }

    async fn infer_text_embedding(&self, model_id: ModelId, text: String) -> Result<Vec<f32>, McpError> {
        tracing::debug!("Performing text embedding inference for model: {:?}", model_id);
        let model = self.get_model_by_id(model_id).await?;
        if model.model_type != ModelType::TextEmbedding {
            return Err(McpError::UnsupportedModelType { model_type: model.model_type });
        }
        if !model.is_enabled {
            return Err(McpError::ModelNotFound { model_id }); // Model found but disabled
        }

        let request = ModelRequest::TextEmbedding(EmbeddingParams { text });

        match self.mcp_client.perform_inference(model_id, request).await? {
            ModelResponse::TextEmbeddingResult { embedding } => Ok(embedding),
            _ => Err(McpError::InternalError {
                message: "Unexpected response type for text embedding inference.".to_string(),
            }),
        }
    }

    async fn infer_sentiment_analysis(&self, model_id: ModelId, text: String) -> Result<(String, f32), McpError> {
        tracing::debug!("Performing sentiment analysis inference for model: {:?}", model_id);
        let model = self.get_model_by_id(model_id).await?;
        if model.model_type != ModelType::SentimentAnalysis {
            return Err(McpError::UnsupportedModelType { model_type: model.model_type });
        }
        if !model.is_enabled {
            return Err(McpError::ModelNotFound { model_id }); // Model found but disabled
        }

        let request = ModelRequest::SentimentAnalysis(SentimentAnalysisParams { text });

        match self.mcp_client.perform_inference(model_id, request).await? {
            ModelResponse::SentimentAnalysisResult { sentiment, score } => Ok((sentiment, score)),
            _ => Err(McpError::InternalError {
                message: "Unexpected response type for sentiment analysis inference.".to_string(),
            }),
        }
    }

    async fn infer_categorization(
        &self,
        model_id: ModelId,
        text: String,
        categories: Vec<String>,
    ) -> Result<(Vec<String>, Vec<f32>), McpError> {
        tracing::debug!("Performing categorization inference for model: {:?}", model_id);
        let model = self.get_model_by_id(model_id).await?;
        if model.model_type != ModelType::Categorization {
            return Err(McpError::UnsupportedModelType { model_type: model.model_type });
        }
        if !model.is_enabled {
            return Err(McpError::ModelNotFound { model_id }); // Model found but disabled
        }

        let request = ModelRequest::Categorization(CategorizationParams { text, categories });

        match self.mcp_client.perform_inference(model_id, request).await? {
            ModelResponse::CategorizationResult { categories, scores } => Ok((categories, scores)),
            _ => Err(McpError::InternalError {
                message: "Unexpected response type for categorization inference.".to_string(),
            }),
        }
    }

    async fn infer_speech_to_text(
        &self,
        model_id: ModelId,
        audio_data_base64: String,
        language: Option<String>,
    ) -> Result<String, McpError> {
        tracing::debug!("Performing speech-to-text inference for model: {:?}", model_id);
        let model = self.get_model_by_id(model_id).await?;
        if model.model_type != ModelType::SpeechToText {
            return Err(McpError::UnsupportedModelType { model_type: model.model_type });
        }
        if !model.is_enabled {
            return Err(McpError::ModelNotFound { model_id }); // Model found but disabled
        }

        let request = ModelRequest::SpeechToText(SpeechToTextParams {
            audio_data_base64,
            language,
        });

        match self.mcp_client.perform_inference(model_id, request).await? {
            ModelResponse::SpeechToTextResult { transcribed_text } => Ok(transcribed_text),
            _ => Err(McpError::InternalError {
                message: "Unexpected response type for speech-to-text inference.".to_string(),
            }),
        }
    }

    async fn infer_text_to_speech(
        &self,
        model_id: ModelId,
        text: String,
        voice: Option<String>,
        format: Option<String>,
    ) -> Result<(String, String), McpError> {
        tracing::debug!("Performing text-to-speech inference for model: {:?}", model_id);
        let model = self.get_model_by_id(model_id).await?;
        if model.model_type != ModelType::TextToSpeech {
            return Err(McpError::UnsupportedModelType { model_type: model.model_type });
        }
        if !model.is_enabled {
            return Err(McpError::ModelNotFound { model_id }); // Model found but disabled
        }

        let request = ModelRequest::TextToSpeech(TextToSpeechParams { text, voice, format });

        match self.mcp_client.perform_inference(model_id, request).await? {
            ModelResponse::TextToSpeechResult { audio_data_base64, format } => {
                Ok((audio_data_base64, format))
            }
            _ => Err(McpError::InternalError {
                message: "Unexpected response type for text-to-speech inference.".to_string(),
            }),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use async_trait::async_trait;
    use mockall::{automock, predicate::*};
    use crate::mcp::data_types::{
        ModelEndpoint, ModelCapabilities, RangeCapability, NumericCapability, Capability,
    };
    use tokio::sync::broadcast; // For mocking the event system if needed

    // Mock McpClient for testing DefaultMcpService
    #[automock]
    #[async_trait]
    impl McpClient for MockMcpClient {
        async fn register_model(&self, config: ModelConfiguration) -> Result<(), McpError> {
            self.register_model(config).await
        }
        async fn update_model(&self, config: ModelConfiguration) -> Result<(), McpError> {
            self.update_model(config).await
        }
        async fn unregister_model(&self, model_id: ModelId) -> Result<(), McpError> {
            self.unregister_model(model_id).await
        }
        async fn get_model_configurations(&self) -> Result<Vec<ModelConfiguration>, McpError> {
            self.get_model_configurations().await
        }
        async fn get_model_configuration(&self, model_id: ModelId) -> Result<ModelConfiguration, McpError> {
            self.get_model_configuration(model_id).await
        }
        async fn create_context(
            &self,
            model_id: ModelId,
            initial_data: Option<String>,
            context_type: String,
            metadata: Option<HashMap<String, String>>,
        ) -> Result<ModelContext, McpError> {
            self.create_context(model_id, initial_data, context_type, metadata).await
        }
        async fn update_context(&self, context: ModelContext) -> Result<(), McpError> {
            self.update_context(context).await
        }
        async fn get_context(&self, context_id: Uuid) -> Result<ModelContext, McpError> {
            self.get_context(context_id).await
        }
        async fn delete_context(&self, context_id: Uuid) -> Result<(), McpError> {
            self.delete_context(context_id).await
        }
        async fn perform_inference(
            &self,
            model_id: ModelId,
            request: ModelRequest,
        ) -> Result<ModelResponse, McpError> {
            self.perform_inference(model_id, request).await
        }
    }

    // Helper function to create a basic model config
    fn create_test_model(id: Uuid, name: &str, model_type: ModelType, is_default: bool, is_enabled: bool) -> ModelConfiguration {
        ModelConfiguration {
            model_id: id,
            model_name: name.to_string(),
            model_type,
            endpoint: ModelEndpoint {
                uri: format!("http://localhost:8080/{}", id),
                api_key: None,
            },
            capabilities: ModelCapabilities {
                max_tokens: Some(4096),
                temperature_range: Some(RangeCapability(0.0, 1.0)),
                // ... other caps
                ..Default::default()
            },
            description: None,
            tags: vec![],
            is_default,
            is_enabled,
            version: "1.0".to_string(),
            license: None,
            author: None,
            usage_cost: None,
            last_updated: None,
        }
    }

    #[tokio::test]
    async fn test_new_service_initial_load_success() {
        let mut mock_client = MockMcpClient::new();
        let model1_id = Uuid::new_v4();
        let model2_id = Uuid::new_v4();
        let model1 = create_test_model(model1_id, "Test Model 1", ModelType::TextGeneration, true, true);
        let model2 = create_test_model(model2_id, "Test Model 2", ModelType::ImageGeneration, false, true);

        mock_client.expect_get_model_configurations()
            .once()
            .returning(move || Ok(vec![model1.clone(), model2.clone()]));

        let service = DefaultMcpService::new(Arc::new(mock_client)).await;

        let model_configs = service.model_configurations.read().unwrap();
        assert_eq!(model_configs.len(), 2);
        assert!(model_configs.contains_key(&model1_id));
        assert!(model_configs.contains_key(&model2_id));

        let default_models = service.default_models.read().unwrap();
        assert_eq!(default_models.len(), 1);
        assert_eq!(default_models.get(&ModelType::TextGeneration), Some(&model1_id));
    }

    #[tokio::test]
    async fn test_new_service_initial_load_failure() {
        let mut mock_client = MockMcpClient::new();
        mock_client.expect_get_model_configurations()
            .once()
            .returning(|| Err(McpError::ClientCommunicationError { source: novade_core::error::ClientError::IoError(std::io::Error::new(std::io::ErrorKind::Other, "Network error")) }));

        // Expect an error log, but the service should still initialize
        let _ = DefaultMcpService::new(Arc::new(mock_client)).await;
        // The service should be created, even if initial load fails
        // Further assertions about internal state can be added if needed
    }

    #[tokio::test]
    async fn test_add_model_success() {
        let mut mock_client = MockMcpClient::new();
        let model_id = Uuid::new_v4();
        let model = create_test_model(model_id, "New Model", ModelType::TextGeneration, true, true);

        // Expect register_model call
        mock_client.expect_register_model()
            .with(eq(model.clone()))
            .once()
            .returning(|_| Ok(()));

        // Expect get_all_models and update_model calls when setting default
        mock_client.expect_get_model_configurations()
            .returning(|| Ok(vec![])); // Empty for initial default setting

        mock_client.expect_update_model()
            .once()
            .returning(|_| Ok(()));


        let service = DefaultMcpService::new(Arc::new(mock_client)).await;

        let result = service.add_model(model.clone()).await;
        assert!(result.is_ok());

        let model_configs = service.model_configurations.read().unwrap();
        assert!(model_configs.contains_key(&model_id));
        assert_eq!(model_configs.get(&model_id).unwrap().model_name, "New Model");

        let default_models = service.default_models.read().unwrap();
        assert_eq!(default_models.get(&ModelType::TextGeneration), Some(&model_id));
    }

    #[tokio::test]
    async fn test_add_model_already_exists() {
        let mut mock_client = MockMcpClient::new();
        let model_id = Uuid::new_v4();
        let model = create_test_model(model_id, "Existing Model", ModelType::TextGeneration, false, true);

        mock_client.expect_get_model_configurations().returning(move || Ok(vec![model.clone()]));
        mock_client.expect_register_model().never(); // Should not be called

        let service = DefaultMcpService::new(Arc::new(mock_client)).await;

        let result = service.add_model(model.clone()).await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), McpError::InternalError { .. }));
    }

    #[tokio::test]
    async fn test_update_model_configuration_success() {
        let mut mock_client = MockMcpClient::new();
        let model_id = Uuid::new_v4();
        let initial_model = create_test_model(model_id, "Old Name", ModelType::TextGeneration, false, true);
        let updated_model = create_test_model(model_id, "Updated Name", ModelType::TextGeneration, true, true);

        mock_client.expect_get_model_configurations().returning(move || Ok(vec![initial_model.clone()]));
        mock_client.expect_update_model()
            .with(eq(updated_model.clone()))
            .once()
            .returning(|_| Ok(()));
        // For setting default
        mock_client.expect_get_model_configurations().returning(|| Ok(vec![])); // After initial setup
        mock_client.expect_update_model().returning(|_| Ok(())); // When setting default

        let service = DefaultMcpService::new(Arc::new(mock_client)).await;

        let result = service.update_model_configuration(updated_model.clone()).await;
        assert!(result.is_ok());

        let model_configs = service.model_configurations.read().unwrap();
        assert_eq!(model_configs.get(&model_id).unwrap().model_name, "Updated Name");
        assert!(model_configs.get(&model_id).unwrap().is_default);

        let default_models = service.default_models.read().unwrap();
        assert_eq!(default_models.get(&ModelType::TextGeneration), Some(&model_id));
    }

    #[tokio::test]
    async fn test_remove_model_success() {
        let mut mock_client = MockMcpClient::new();
        let model_id = Uuid::new_v4();
        let model = create_test_model(model_id, "To Remove", ModelType::TextGeneration, true, true);

        mock_client.expect_get_model_configurations().returning(move || Ok(vec![model.clone()]));
        mock_client.expect_unregister_model()
            .with(eq(model_id))
            .once()
            .returning(|_| Ok(()));

        let service = DefaultMcpService::new(Arc::new(mock_client)).await;

        let result = service.remove_model(model_id).await;
        assert!(result.is_ok());

        let model_configs = service.model_configurations.read().unwrap();
        assert!(!model_configs.contains_key(&model_id));

        let default_models = service.default_models.read().unwrap();
        assert!(!default_models.contains_key(&ModelType::TextGeneration));
    }

    #[tokio::test]
    async fn test_get_all_models_success() {
        let mut mock_client = MockMcpClient::new();
        let model1_id = Uuid::new_v4();
        let model2_id = Uuid::new_v4();
        let model1 = create_test_model(model1_id, "Model 1", ModelType::TextGeneration, true, true);
        let model2 = create_test_model(model2_id, "Model 2", ModelType::ImageGeneration, false, true);

        mock_client.expect_get_model_configurations()
            .times(2) // Once for new(), once for get_all_models()
            .returning(move || Ok(vec![model1.clone(), model2.clone()]));

        let service = DefaultMcpService::new(Arc::new(mock_client)).await;
        let models = service.get_all_models().await.unwrap();

        assert_eq!(models.len(), 2);
        assert!(models.iter().any(|m| m.model_id == model1_id));
        assert!(models.iter().any(|m| m.model_id == model2_id));

        // Verify cache was updated
        let model_configs = service.model_configurations.read().unwrap();
        assert_eq!(model_configs.len(), 2);
    }

    #[tokio::test]
    async fn test_get_model_by_id_found_in_cache() {
        let mut mock_client = MockMcpClient::new();
        let model_id = Uuid::new_v4();
        let model = create_test_model(model_id, "Cached Model", ModelType::TextGeneration, false, true);

        mock_client.expect_get_model_configurations().returning(move || Ok(vec![model.clone()]));
        mock_client.expect_get_model_configuration().never(); // Should not be called

        let service = DefaultMcpService::new(Arc::new(mock_client)).await;
        let found_model = service.get_model_by_id(model_id).await.unwrap();

        assert_eq!(found_model.model_id, model_id);
        assert_eq!(found_model.model_name, "Cached Model");
    }

    #[tokio::test]
    async fn test_get_model_by_id_not_found_in_cache_but_by_client() {
        let mut mock_client = MockMcpClient::new();
        let model_id = Uuid::new_v4();
        let model = create_test_model(model_id, "Client Model", ModelType::TextGeneration, false, true);

        mock_client.expect_get_model_configurations().returning(|| Ok(vec![])); // Cache starts empty
        mock_client.expect_get_model_configuration()
            .with(eq(model_id))
            .once()
            .returning(move |_| Ok(model.clone()));

        let service = DefaultMcpService::new(Arc::new(mock_client)).await;
        let found_model = service.get_model_by_id(model_id).await.unwrap();

        assert_eq!(found_model.model_id, model_id);
        assert_eq!(found_model.model_name, "Client Model");

        // Verify it's now in cache
        let model_configs = service.model_configurations.read().unwrap();
        assert!(model_configs.contains_key(&model_id));
    }

    #[tokio::test]
    async fn test_get_default_model_for_type_found_in_cache() {
        let mut mock_client = MockMcpClient::new();
        let model_id = Uuid::new_v4();
        let model = create_test_model(model_id, "Default TG", ModelType::TextGeneration, true, true);

        mock_client.expect_get_model_configurations().returning(move || Ok(vec![model.clone()]));
        mock_client.expect_get_model_configuration().never(); // Should get from inner cache

        let service = DefaultMcpService::new(Arc::new(mock_client)).await;
        let found_model = service.get_default_model_for_type(ModelType::TextGeneration).await.unwrap();

        assert_eq!(found_model.model_id, model_id);
        assert_eq!(found_model.model_type, ModelType::TextGeneration);
        assert!(found_model.is_default);
    }

    #[tokio::test]
    async fn test_get_default_model_for_type_not_found() {
        let mut mock_client = MockMcpClient::new();
        mock_client.expect_get_model_configurations().returning(|| Ok(vec![])); // No models initially
        mock_client.expect_get_model_configurations().returning(|| Ok(vec![])); // Also no models when calling get_all_models
        mock_client.expect_get_model_configuration().never();

        let service = DefaultMcpService::new(Arc::new(mock_client)).await;
        let result = service.get_default_model_for_type(ModelType::TextGeneration).await;

        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), McpError::ModelNotFound { .. }));
    }

    #[tokio::test]
    async fn test_set_default_model_for_type_success() {
        let mut mock_client = MockMcpClient::new();
        let model_id_old_default = Uuid::new_v4();
        let model_id_new_default = Uuid::new_v4();
        let mut old_default_model = create_test_model(model_id_old_default, "Old Default", ModelType::TextGeneration, true, true);
        let mut new_default_model = create_test_model(model_id_new_default, "New Default", ModelType::TextGeneration, false, true);

        mock_client.expect_get_model_configurations()
            .returning(move || Ok(vec![old_default_model.clone(), new_default_model.clone()]));

        // Expected calls during set_default_model_for_type
        mock_client.expect_get_model_configuration() // for get_model_by_id(new_default_id)
            .with(eq(model_id_new_default))
            .returning(move |_| Ok(new_default_model.clone()));

        mock_client.expect_get_model_configurations() // for get_all_models()
            .returning(move || Ok(vec![old_default_model.clone(), new_default_model.clone()]));

        mock_client.expect_update_model() // for old_default_model becoming false
            .with(predicate::function(move |cfg: &ModelConfiguration| {
                cfg.model_id == model_id_old_default && !cfg.is_default
            }))
            .once()
            .returning(|_| Ok(()));

        mock_client.expect_update_model() // for new_default_model becoming true
            .with(predicate::function(move |cfg: &ModelConfiguration| {
                cfg.model_id == model_id_new_default && cfg.is_default
            }))
            .once()
            .returning(|_| Ok(()));

        let service = DefaultMcpService::new(Arc::new(mock_client)).await;
        let result = service.set_default_model_for_type(model_id_new_default).await;
        assert!(result.is_ok());

        let default_models = service.default_models.read().unwrap();
        assert_eq!(default_models.get(&ModelType::TextGeneration), Some(&model_id_new_default));

        let model_configs = service.model_configurations.read().unwrap();
        assert!(model_configs.get(&model_id_new_default).unwrap().is_default);
        assert!(!model_configs.get(&model_id_old_default).unwrap().is_default);
    }

    #[tokio::test]
    async fn test_infer_text_generation_success() {
        let mut mock_client = MockMcpClient::new();
        let model_id = Uuid::new_v4();
        let model = create_test_model(model_id, "ChatGPT-like", ModelType::TextGeneration, true, true);

        mock_client.expect_get_model_configurations().returning(move || Ok(vec![model.clone()]));
        mock_client.expect_get_model_configuration().returning(move |_| Ok(model.clone()));

        mock_client.expect_perform_inference()
            .with(
                eq(model_id),
                predicate::function(|req: &ModelRequest| {
                    if let ModelRequest::TextGeneration(params) = req {
                        params.prompt == "Hello AI" &&
                        params.max_tokens == Some(100) &&
                        params.temperature == Some(0.7) &&
                        params.context_id.is_none()
                    } else { false }
                })
            )
            .once()
            .returning(|_, _| Ok(ModelResponse::TextGenerationResult { generated_text: "AI response.".to_string() }));

        let service = DefaultMcpService::new(Arc::new(mock_client)).await;
        let result = service.infer_text_generation(
            model_id,
            "Hello AI".to_string(),
            Some(100),
            Some(0.7),
            None,
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "AI response.".to_string());
    }

    #[tokio::test]
    async fn test_infer_text_generation_wrong_model_type() {
        let mut mock_client = MockMcpClient::new();
        let model_id = Uuid::new_v4();
        let model = create_test_model(model_id, "DALL-E", ModelType::ImageGeneration, false, true);

        mock_client.expect_get_model_configurations().returning(move || Ok(vec![model.clone()]));
        mock_client.expect_get_model_configuration().returning(move |_| Ok(model.clone()));
        mock_client.expect_perform_inference().never();

        let service = DefaultMcpService::new(Arc::new(mock_client)).await;
        let result = service.infer_text_generation(
            model_id,
            "Hello AI".to_string(),
            Some(100),
            Some(0.7),
            None,
        ).await;

        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), McpError::UnsupportedModelType { .. }));
    }

    #[tokio::test]
    async fn test_infer_text_generation_capability_exceeded() {
        let mut mock_client = MockMcpClient::new();
        let model_id = Uuid::new_v4();
        let mut model = create_test_model(model_id, "Limited Model", ModelType::TextGeneration, false, true);
        model.capabilities.max_tokens = Some(50); // Set max tokens capability

        mock_client.expect_get_model_configurations().returning(move || Ok(vec![model.clone()]));
        mock_client.expect_get_model_configuration().returning(move |_| Ok(model.clone()));
        mock_client.expect_perform_inference().never(); // Should fail before calling inference

        let service = DefaultMcpService::new(Arc::new(mock_client)).await;
        let result = service.infer_text_generation(
            model_id,
            "Long prompt".to_string(),
            Some(100), // Exceeds 50
            Some(0.7),
            None,
        ).await;

        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), McpError::CapabilityExceeded { .. }));
    }

    #[tokio::test]
    async fn test_create_new_context_success() {
        let mut mock_client = MockMcpClient::new();
        let model_id = Uuid::new_v4();
        let model = create_test_model(model_id, "Test Model", ModelType::TextGeneration, true, true);
        let context_id = Uuid::new_v4();
        let context_type = "chat_session".to_string();
        let initial_data = Some("Initial message".to_string());
        let metadata = Some(HashMap::from([("user".to_string(), "test_user".to_string())]));

        let expected_context = ModelContext {
            id: context_id,
            model_id,
            context_type: context_type.clone(),
            created_at: chrono::Utc::now(),
            last_accessed: chrono::Utc::now(),
            data: initial_data.clone(),
            metadata: metadata.clone(),
        };

        mock_client.expect_get_model_configurations().returning(move || Ok(vec![model.clone()]));
        mock_client.expect_get_model_configuration().returning(move |_| Ok(model.clone()));
        mock_client.expect_create_context()
            .with(
                eq(model_id),
                eq(initial_data.clone()),
                eq(context_type.clone()),
                eq(metadata.clone())
            )
            .once()
            .returning(move |_, _, _, _| Ok(expected_context.clone()));

        let service = DefaultMcpService::new(Arc::new(mock_client)).await;
        let result = service.create_new_context(
            model_id,
            initial_data,
            context_type,
            metadata,
        ).await;

        assert!(result.is_ok());
        let created_context = result.unwrap();
        assert_eq!(created_context.id, context_id);
        assert_eq!(created_context.model_id, model_id);
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (30 von 100) widmet sich der Implementierung der Schnittstelle für die Persistenz von Benachrichtigungsregeln (`novade-domain/src/notification_rules/persistence_iface.rs`) und der konkreten Implementierung der Dateisystem-basierten Persistenz (`novade-domain/src/notification_rules/persistence.rs`).

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 30/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.19. `novade-domain/src/notification_rules` Verzeichnis

Dieses Verzeichnis enthält die Logik und die Infrastruktur für die Verwaltung und Verarbeitung von Benachrichtigungsregeln. Es ist entscheidend für die Anpassung der Nutzererfahrung, indem es Anwendern ermöglicht, das Verhalten von Benachrichtigungen basierend auf verschiedenen Kriterien zu steuern.

#### 3.19.1. `novade-domain/src/notification_rules/mod.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/mod.rs`
  * **Verantwortlichkeit:** Definiert die öffentliche API des `notification_rules`-Moduls der Domänenschicht. Es re-exportiert alle wichtigen Typen, Traits und Strukturen, die von anderen Teilen der Domänenschicht oder von höheren Schichten (z.B. der UI-Schicht) benötigt werden, um mit Benachrichtigungsregeln zu interagieren.
  * **Kern-Aufgaben (Tasks):**
    1.  **Public API Definition:** Re-exportiere die folgenden Komponenten:
          * `data_types` (alle Typen)
          * `errors` (alle Fehler)
          * `persistence_iface` (Traits)
          * `persistence` (Konkrete Implementierungen)
          * `engine` (Traits und konkrete Implementierungen)
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** `data_types`, `errors`, `persistence_iface`, `persistence`, `engine` (innerhalb desselben `notification_rules` Moduls).
      * **Extern:** Keine direkten, da nur Re-Exporte stattfinden.
  * **Kommunikationsmuster:** Stellt die Schnittstelle des `notification_rules`-Moduls zur Verfügung, die von `domain::services::notification` und potenziell von UI-Komponenten verwendet wird.
  * **Erwartete Ergebnisse/Outputs:** Ein klar definierter, konsolidierter Satz von Typen und Funktionen, die für die Interaktion mit Benachrichtigungsregeln erforderlich sind.
  * **Teststrategie (Modul-spezifisch):** Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte sind. Die Tests erfolgen in den jeweiligen Submodulen.

#### 3.19.2. `novade-domain/src/notification_rules/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/data_types.rs`
  * **Verantwortlichkeit:** Definiert alle Datenstrukturen (Enums, Structs) die für die Repräsentation von Benachrichtigungsregeln, Bedingungen und Aktionen benötigt werden. Diese Typen müssen serialisierbar/deserialisierbar sein (mittels `serde`) und Standardwerte für Konfigurationen bereitstellen (`Default`).
  * **Kern-Aufgaben (Tasks):**
    1.  **`ConditionValue` Enum definieren:**

          * Sollte die verschiedenen Typen von Werten repräsentieren, die in Bedingungen verwendet werden können (z.B. `String`, `Integer`, `Boolean`, `Float`).
          * Implementiere `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`, `Default`.
          * **Entscheidung:** Verwende `serde_json::Value` oder ein eigenes Enum, das `String`, `i64`, `f64`, `bool` und `Array` von diesen Typen unterstützt, um Flexibilität zu gewährleisten.
              * *Wahl:* Ein eigenes Enum `ConditionValue` ist expliziter und typsicherer als `serde_json::Value`.

        <!-- end list -->

        ```rust
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        #[serde(untagged)] // Allows deserialization without needing an explicit tag
        pub enum ConditionValue {
            String(String),
            Integer(i64),
            Boolean(bool),
            Float(f64), // Be cautious with f64 for PartialEq, but necessary for range checks
            Array(Vec<ConditionValue>),
            Null,
        }

        impl Default for ConditionValue {
            fn default() -> Self {
                ConditionValue::Null
            }
        }

        // Implement conversion traits for convenience (e.g., from String, i64, bool)
        impl From<String> for ConditionValue { /* ... */ }
        impl From<&str> for ConditionValue { /* ... */ }
        impl From<i64> for ConditionValue { /* ... */ }
        impl From<bool> for ConditionValue { /* ... */ }
        impl From<f64> for ConditionValue { /* ... */ }
        // Implement display for ConditionValue
        impl std::fmt::Display for ConditionValue { /* ... */ }
        ```

    2.  **`Operator` Enum definieren:**

          * Repräsentiert logische und Vergleichsoperatoren: `Equal`, `NotEqual`, `GreaterThan`, `LessThan`, `GreaterThanOrEqual`, `LessThanOrEqual`, `Contains`, `StartsWith`, `EndsWith`, `MatchesRegex`, `IsIn`, `IsNotIn`, `SettingIsTrue`.
          * Implementiere `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`.

    3.  **`Field` Enum definieren:**

          * Repräsentiert die Felder einer Benachrichtigung, auf die Regeln angewendet werden können: `AppName`, `Summary`, `Body`, `Category`, `Urgency`, `DesktopEntry`, `Transient`, `Hint` (spezifischer Schlüsselwert aus HashMap, z.B. `DesktopNotifications::Hint::XBody`), `SenderId`.
          * Implementiere `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`.
          * **Entscheidung:** `Hint` sollte einen `String` enthalten, der den Schlüssel des Hints identifiziert (z.B. `"image-data"`).

        <!-- end list -->

        ```rust
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum Field {
            AppName,
            Summary,
            Body,
            Category,
            Urgency,
            DesktopEntry,
            Transient,
            Hint(String), // The hint key, e.g., "image-data"
            SenderId, // UUID of the sending application/source
            // Additional fields based on D-Bus Notification Spec or common usage
            // e.g., "replaces_id", "icon"
            // For now, keep it concise.
        }
        ```

    4.  **`SimpleRuleCondition` Struct definieren:**

          * Struktur für eine einzelne Bedingung: `field: Field`, `operator: Operator`, `value: ConditionValue`.
          * Implementiere `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`, `Default`.

    5.  **`RuleCondition` Enum definieren:**

          * Repräsentiert eine Bedingung oder eine logische Kombination von Bedingungen:
              * `Simple(SimpleRuleCondition)`
              * `And(Vec<RuleCondition>)`
              * `Or(Vec<RuleCondition>)`
              * `Not(Box<RuleCondition>)`
          * Implementiere `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`, `Default`.
          * **Entscheidung:** Für `Default` bei `RuleCondition`, sollte es eine `Simple` Bedingung mit `Null` Werten sein.

    6.  **`RuleAction` Enum definieren:**

          * Repräsentiert Aktionen, die bei einer passenden Regel ausgeführt werden:
              * `Dismiss` (Benachrichtigung sofort schließen)
              * `Mute` (Keinen Sound abspielen)
              * `Silent` (Kein Sound und keine visuelle Benachrichtigung)
              * `LogOnly` (Nur protokollieren, nicht anzeigen)
              * `SetUrgency(u8)` (D-Bus urgency level 0-2)
              * `OverrideSummary(String)`
              * `OverrideBody(String)`
              * `ExecuteCommand(String, Vec<String>)` (Pfad zum Befehl, Argumente)
              * `RunScript(String, Vec<String>)` (Pfad zum Skript, Argumente)
              * `ApplyGlobalSetting(String, ConditionValue)` (Wendet eine globale Einstellung an, z.B. `FocusStealingAllowed: false`)
              * `StopProcessingFurtherRules` (Beendet die Auswertung weiterer Regeln für diese Benachrichtigung)
          * Implementiere `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`.
          * **Entscheidung:** Für `Default` bei `RuleAction`, sollte es `Dismiss` sein.

    7.  **`NotificationRule` Struct definieren:**

          * Definiert eine einzelne Regel:
              * `id: Uuid`
              * `name: String`
              * `description: Option<String>`
              * `priority: u32` (Niedriger Wert = höhere Priorität)
              * `enabled: bool`
              * `conditions: RuleCondition`
              * `actions: Vec<RuleAction>`
          * Implementiere `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`, `Default`.
          * **Entscheidung:** Standard-`priority` sollte z.B. `1000` sein, `enabled` `true`.

    8.  **`NotificationRuleSet` Struct definieren:**

          * Ein Set von Regeln: `rules: Vec<NotificationRule>`.
          * Implementiere `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`, `Default`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/data_types.rs`
  * **Abhängigkeiten:**
      * **Extern:** `serde::{Serialize, Deserialize}`, `uuid::Uuid`, `std::collections::HashMap`, `chrono` (für `last_accessed` etc., obwohl hier nicht direkt verwendet, für allgemeine Datenmodelle sinnvoll). `url::Url` wenn URI-Validierung in `ConditionValue` erwünscht.
  * **Kommunikationsmuster:** Stellt die Datenstrukturen bereit, die von anderen Modulen zur Beschreibung von Regeln verwendet werden.
  * **Erwartete Ergebnisse/Outputs:** Eine vollständige und robuste Definition der Datenmodelle für Benachrichtigungsregeln, die für Serialisierung, Deserialisierung und Logikverarbeitung bereit sind.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Serialisierung und Deserialisierung aller Enums und Structs in JSON (und YAML, falls verwendet).
          * Testen der `Default`-Implementierungen.
          * Testen der `From`-Implementierungen für `ConditionValue`.
          * Testen von `PartialEq` und `Eq` für alle Typen, insbesondere bei komplexen Strukturen wie `RuleCondition`.

#### 3.19.3. `novade-domain/src/notification_rules/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/errors.rs`
  * **Verantwortlichkeit:** Definiert Fehler (`NotificationRulesError`) die spezifisch für die Verarbeitung und das Management von Benachrichtigungsregeln sind. Nutzt `thiserror` für einfache Fehlerdefinition und -propagation.
  * **Kern-Aufgaben (Tasks):**
    1.  **`NotificationRulesError` Enum definieren:**
          * Varianten:
              * `IoError(#[from] std::io::Error)`: Für Dateisystemoperationen.
              * `SerializationError(#[from] serde_json::Error)`: Für JSON-Serialisierung/Deserialisierung (oder `serde_yaml::Error`).
              * `RuleNotFound { rule_id: Uuid }`: Wenn eine Regel mit gegebener ID nicht gefunden wird.
              * `InvalidRule { rule_id: Uuid, source: String }`: Wenn eine Regel in sich ungültig ist (z.B. fehlende Felder).
              * `ValidationError { message: String }`: Für allgemeine Validierungsfehler, die nicht spezifisch einer Regel-ID zugeordnet sind.
              * `ProcessingError { message: String }`: Laufzeitfehler während der Regelverarbeitung (z.B. Regex-Fehler).
              * `ClientError(#[from] novade_core::error::ClientError)`: Wenn der zugrundeliegende ConfigService Fehler meldet.
              * `Other(String)`: Für generische, unerwartete Fehler.
          * Implementiere `Debug`, `Display`, `Error` (`thiserror` erledigt dies weitgehend).
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/errors.rs`
  * **Abhängigkeiten:**
      * **Extern:** `thiserror::Error`, `serde_json`, `uuid::Uuid`, `std::io`, `novade_core::error::ClientError`.
  * **Kommunikationsmuster:** Wird als `Result` E-Typ in den Schnittstellen des `notification_rules`-Moduls verwendet.
  * **Erwartete Ergebnisse/Outputs:** Ein robuster Fehler-Enum, der eine klare und nachvollziehbare Fehlerbehandlung im gesamten Modul ermöglicht.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Erstellung jeder Fehlervariante.
          * Testen der `From`-Implementierungen für Konvertierungen.
          * Testen der Fehlermeldungen (`.to_string()`).

#### 3.19.4. `novade-domain/src/notification_rules/persistence_iface.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/persistence_iface.rs`
  * **Verantwortlichkeit:** Definiert den `NotificationRulesProvider`-Trait, der die Schnittstelle für die Persistenz von Benachrichtigungsregeln bereitstellt. Dieser Trait ist abstrakt und ermöglicht verschiedene Implementierungen (z.B. Dateisystem, D-Bus, Datenbank).
  * **Kern-Aufgaben (Tasks):**
    1.  **`NotificationRulesProvider` Trait definieren:**
          * Methoden:
              * `load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`: Lädt alle Benachrichtigungsregeln.
              * `save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`: Speichert die aktuellen Benachrichtigungsregeln.
          * Sollte `async_trait` verwenden, um asynchrone Implementierungen zu ermöglichen.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/persistence_iface.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notification_rules::data_types::NotificationRuleSet`, `crate::notification_rules::errors::NotificationRulesError`.
      * **Extern:** `async_trait::async_trait`.
  * **Kommunikationsmuster:** Wird als Dependency Injection Punkt für die `NotificationRulesEngine` verwendet.
  * **Erwartete Ergebnisse/Outputs:** Eine klare, asynchrone Schnittstelle für den Zugriff auf persistierte Benachrichtigungsregeln.
  * **Teststrategie (Modul-spezifisch):** Keine Tests für Traits direkt. Tests erfolgen in den konkreten Implementierungen.

#### 3.19.5. `novade-domain/src/notification_rules/persistence.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/persistence.rs`
  * **Verantwortlichkeit:** Implementiert den `NotificationRulesProvider`-Trait für die Dateisystem-basierte Persistenz. Nutzt den `ConfigServiceAsync` (aus `novade-core`) um Konfigurationsdateien im XDG Base Directory Standard zu lesen und zu schreiben.
  * **Kern-Aufgaben (Tasks):**
    1.  **`FilesystemNotificationRulesProvider` Struct definieren:**
          * Feld: `config_service: Arc<dyn ConfigServiceAsync>`.
          * Konstruktor: `new(config_service: Arc<dyn ConfigServiceAsync>) -> Self`.
    2.  **`DEFAULT_RULES_FILE_NAME` Konstante definieren:**
          * Z.B. `"notification_rules.json"`.
    3.  **Implementierung des `NotificationRulesProvider`-Traits für `FilesystemNotificationRulesProvider`:**
          * **`load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`:**
              * Ruft `self.config_service.load_user_config(DEFAULT_RULES_FILE_NAME).await?` auf.
              * Der `load_user_config` sollte `Option<String>` zurückgeben. Wenn `None`, eine leere `NotificationRuleSet` zurückgeben.
              * Wenn `Some(content)`, deserialisiert den Inhalt von JSON in `NotificationRuleSet`.
              * Fehlerbehandlung: Konvertiere `io::Error` und `serde_json::Error` in `NotificationRulesError`.
          * **`save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`:**
              * Serialisiert die `NotificationRuleSet` in JSON.
              * Ruft `self.config_service.save_user_config(DEFAULT_RULES_FILE_NAME, &json_content).await?` auf.
              * Fehlerbehandlung: Konvertiere `serde_json::Error` und `io::Error` in `NotificationRulesError`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/persistence.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notification_rules::data_types::NotificationRuleSet`, `crate::notification_rules::errors::NotificationRulesError`, `crate::notification_rules::persistence_iface::NotificationRulesProvider`. `novade_core::config::ConfigServiceAsync`.
      * **Extern:** `async_trait::async_trait`, `serde_json`, `std::sync::Arc`.
  * **Kommunikationsmuster:** Interagiert mit dem `ConfigServiceAsync` aus der Kernschicht.
  * **Erwartete Ergebnisse/Outputs:** Eine funktionierende Dateisystem-basierte Persistenz für Benachrichtigungsregeln, die den XDG-Standard nutzt.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests (mit Mocking):**
          * **Mocking:** Erstelle eine Mock-Implementierung von `ConfigServiceAsync`.
          * Testen von `load_rules`:
              * Wenn Datei existiert und gültigen JSON enthält.
              * Wenn Datei existiert und ungültigen JSON enthält (Deserialisierungsfehler).
              * Wenn Datei nicht existiert (sollte leeres Set zurückgeben).
              * Wenn `ConfigServiceAsync` einen Fehler meldet (z.B. `IoError`).
          * Testen von `save_rules`:
              * Erfolgreiches Speichern.
              * Wenn Serialisierung fehlschlägt.
              * Wenn `ConfigServiceAsync` einen Fehler meldet.
          * Testen von Edge Cases: Sehr große Regelsets, leere Regelsets.

-----

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (31 von 100) widmet sich der Implementierung der Regel-Engine für Benachrichtigungen (`novade-domain/src/notification_rules/engine.rs`). Diese Komponente ist das Herzstück der anpassbaren Benachrichtigungsverarbeitung.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 31/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.19.6. `novade-domain/src/notification_rules/engine.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/engine.rs`
  * **Verantwortlichkeit:** Implementiert die Kernlogik für die Auswertung von Benachrichtigungsregeln und die Anwendung der entsprechenden Aktionen. Sie orchestriert die Interaktion mit dem `NotificationRulesProvider` zur Persistenz und dem `GlobalSettingsService` zur Anwendung bestimmter Aktionen.
  * **Kern-Aufgaben (Tasks):**
    1.  **`RuleProcessingResult` Enum definieren:**
          * Repräsentiert das Ergebnis der Regelverarbeitung für eine einzelne Benachrichtigung.
          * Varianten:
              * `ContinueProcessing`: Benachrichtigung wurde nicht von einer Regel bearbeitet oder es wurden keine `StopProcessingFurtherRules`-Aktionen ausgeführt.
              * `StopProcessing`: Eine Regel hat eine `StopProcessingFurtherRules`-Aktion ausgelöst, weitere Regeln werden nicht angewendet.
              * `Dismissed`: Die Benachrichtigung wurde durch eine Regel verworfen (impliziert `StopProcessing`).
              * `Muted`: Die Benachrichtigung wurde durch eine Regel stummgeschaltet (impliziert `StopProcessing`).
              * `Silenced`: Die Benachrichtigung wurde durch eine Regel unsichtbar gemacht (impliziert `StopProcessing`).
          * Implementiere `PartialEq`, `Eq`, `Debug`, `Clone`.
    2.  **`NotificationRulesEngine` Trait definieren:**
          * Schnittstelle für die Benachrichtigungs-Regel-Engine.
          * Methoden:
              * `reload_rules(&self) -> Result<(), NotificationRulesError>`: Lädt die Regeln neu aus der Persistenz.
              * `process_notification(&self, notification: &mut Notification) -> Result<RuleProcessingResult, NotificationRulesError>`: Evaluiert Regeln für eine gegebene Benachrichtigung und wendet Aktionen an. Ändert die Benachrichtigung in-place.
              * `get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`: Gibt das aktuelle Set der geladenen Regeln zurück.
              * `update_rules(&self, rules: NotificationRuleSet) -> Result<(), NotificationRulesError>`: Aktualisiert das Set der Regeln und speichert sie.
          * Sollte `async_trait` verwenden.
    3.  **`DefaultNotificationRulesEngine` Struct definieren:**
          * Felder:
              * `rules_provider: Arc<dyn NotificationRulesProvider>`: Zur Abstraktion der Datenquelle der Regeln.
              * `global_settings_service: Arc<dyn GlobalSettingsService>`: Für Aktionen, die globale Einstellungen ändern.
              * `rules: Arc<RwLock<NotificationRuleSet>>`: Cache für die aktuell geladenen Regeln, geschützt durch ein `RwLock` für Thread-Sicherheit.
          * Konstruktor: `new(rules_provider: Arc<dyn NotificationRulesProvider>, global_settings_service: Arc<dyn GlobalSettingsService>) -> Self`.
              * Der Konstruktor sollte `reload_rules().await` aufrufen, um die initialen Regeln zu laden.
    4.  **Implementierung des `NotificationRulesEngine`-Traits für `DefaultNotificationRulesEngine`:**
          * **`reload_rules(&self) -> Result<(), NotificationRulesError>`:**
              * Ruft `self.rules_provider.load_rules().await?` auf.
              * Bei Erfolg: Aktualisiert `self.rules` durch Schreiben in das `RwLock`.
              * Protokolliert Ladefehler.
          * **`process_notification(&self, notification: &mut Notification) -> Result<RuleProcessingResult, NotificationRulesError>`:**
              * **Priorisierung:** Liest die Regeln aus `self.rules`. Sortiert die Regeln nach `priority` (aufsteigend, niedrigerer Wert = höhere Priorität). Nur `enabled: true` Regeln werden berücksichtigt.
              * **Iterative Auswertung:** Iteriert über die sortierten Regeln.
              * Für jede Regel:
                  * **Bedingungsauswertung (`evaluate_condition` Hilfsfunktion):**
                      * Rekursive Funktion, die eine `RuleCondition` (`Simple`, `And`, `Or`, `Not`) gegen die `notification` evaluiert.
                      * `SimpleRuleCondition` Prüfung:
                          * Basierend auf `field`: Extrahiere den entsprechenden Wert aus der `Notification` (z.B. `notification.app_name`, `notification.summary`, `notification.hints`).
                          * Konvertiere den extrahierten Wert in einen `ConditionValue` zur typsicheren Vergleichbarkeit.
                          * Wende den `operator` an:
                              * `Equal`, `NotEqual`: Direkter Vergleich.
                              * `GreaterThan`, `LessThan`, `GreaterThanOrEqual`, `LessThanOrEqual`: Nur für numerische `ConditionValue`s. Typkonflikte führen zu `false`.
                              * `Contains`, `StartsWith`, `EndsWith`: Nur für String-Felder. Case-insensitive Vergleich sollte optional sein oder standardmäßig implementiert werden (Entscheidung: Case-insensitive für bessere UX).
                              * `MatchesRegex`: Nutzt die `regex` Krate. Fehlerhafte Regex sollte zu `false` führen und protokolliert werden.
                              * `IsIn`, `IsNotIn`: Prüft, ob der Wert in einer `ConditionValue::Array` enthalten ist.
                              * `SettingIsTrue`: Prüft einen booleschen Wert (z.B. aus `notification.hints`) auf `true`. Dies ist spezifischer als `Equal(Boolean(true))`.
                      * Logische Verknüpfungen (`And`, `Or`, `Not`) rekursiv abarbeiten.
                  * **Aktionsanwendung (`apply_action` Hilfsfunktion):**
                      * Wenn die Regelbedingung erfüllt ist:
                          * Iteriert über `actions` der Regel.
                          * `Dismiss`: Setzt ein internes Flag `result = RuleProcessingResult::Dismissed`.
                          * `Mute`: Setzt `notification.mute = true` und `result = RuleProcessingResult::Muted`.
                          * `Silent`: Setzt `notification.silent = true` und `result = RuleProcessingResult::Silenced`.
                          * `LogOnly`: Protokolliert die Benachrichtigung, ändert sie aber nicht.
                          * `SetUrgency(u8)`: Setzt `notification.urgency` auf den Wert.
                          * `OverrideSummary(String)`: Setzt `notification.summary` auf den neuen Wert.
                          * `OverrideBody(String)`: Setzt `notification.body` auf den neuen Wert.
                          * `ExecuteCommand(String, Vec<String>)`: Startet einen externen Prozess. **Sicherheitsrisiko\!** Sollte nur mit Vorsicht implementiert werden, z.B. nur für vordefinierte, sichere Befehle oder mit strikter Benutzereinwilligung. Für NovaDE: Zunächst nur als Platzhalter oder mit sehr strikten Whitelist-Mechanismen.
                          * `RunScript(String, Vec<String>)`: Ähnlich wie `ExecuteCommand`. Gleiche Sicherheitsbedenken.
                          * `ApplyGlobalSetting(String, ConditionValue)`: Ruft `self.global_settings_service.set_setting(key, value).await?` auf.
                          * `StopProcessingFurtherRules`: Setzt ein internes Flag, das die Schleife über Regeln abbricht. Die Funktion gibt das aktuell erreichte `RuleProcessingResult` zurück.
              * Fehler bei der Regelauswertung sollten protokolliert, aber die Verarbeitung anderer Regeln nicht blockiert werden, es sei denn, es ist ein kritischer Fehler (z.B. Persistenzfehler).
              * Die finale `RuleProcessingResult` wird zurückgegeben. Wenn keine Regel zutrifft, `ContinueProcessing`.
          * **`get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`:**
              * Gibt eine geklonte Version des `NotificationRuleSet` aus dem `RwLock` zurück.
          * **`update_rules(&self, rules: NotificationRuleSet) -> Result<(), NotificationRulesError>`:**
              * Validiert das eingehende `NotificationRuleSet` (z.B. Duplikate, ungültige IDs, leere Felder).
              * Schreibt das neue Regelset in das `self.rules` `RwLock`.
              * Ruft `self.rules_provider.save_rules(&rules).await?` auf, um die Änderungen zu persistieren.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/engine.rs`
  * **Abhängigkeiten:**
      * **Intern:**
          * `crate::notification_rules::data_types::{NotificationRule, NotificationRuleSet, RuleCondition, SimpleRuleCondition, Field, Operator, ConditionValue, RuleAction}`
          * `crate::notification_rules::errors::NotificationRulesError`
          * `crate::notification_rules::persistence_iface::NotificationRulesProvider`
          * `crate::global_settings::service_iface::GlobalSettingsService` (für `ApplyGlobalSetting`)
          * `crate::notification::data_types::Notification` (als Input für `process_notification`)
      * **Extern:** `async_trait::async_trait`, `std::sync::{Arc, RwLock}`, `regex`, `chrono` (für Zeitstempel/Vergleiche, falls in Bedingungen benötigt, aktuell nicht explizit). `tokio::process::Command` (für `ExecuteCommand`/`RunScript`, *vorsichtig verwenden\!*).
  * **Kommunikationsmuster:**
      * Ruft `NotificationRulesProvider` auf, um Regeln zu laden/speichern.
      * Ruft `GlobalSettingsService` auf, um Einstellungen zu ändern.
      * Wird vom `NotificationService` (aus `novade-domain/src/notification/service.rs`) aufgerufen.
  * **Erwartete Ergebnisse/Outputs:** Eine robuste und leistungsfähige Engine zur Verarbeitung von Benachrichtigungsregeln, die eine hohe Anpassbarkeit der Benachrichtigungsdarstellung und -behandlung ermöglicht.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests (mit Mocking):**
          * **Mocking:** `MockNotificationRulesProvider` und `MockGlobalSettingsService`.
          * **`reload_rules` Tests:**
              * Erfolg beim Laden.
              * Fehlerbehandlung beim Laden.
              * Leeres Regelset.
          * **`process_notification` Tests:**
              * **Bedingungsauswertung:**
                  * Testen aller `Operator`-Varianten mit verschiedenen `Field`-Typen und `ConditionValue`-Typen.
                  * Tests für numerische Vergleiche (`GreaterThan`, `LessThan` etc.).
                  * Tests für String-Vergleiche (`Contains`, `StartsWith`, `EndsWith`, `MatchesRegex`) mit und ohne Case-Sensitivität.
                  * Tests für Array-Vergleiche (`IsIn`, `IsNotIn`).
                  * Tests für `SettingIsTrue`.
                  * Tests für komplexe `And`/`Or`/`Not` Kombinationen, einschließlich verschachtelter Strukturen.
                  * Tests, bei denen die Bedingung `true` oder `false` ergibt.
                  * Edge Cases für Bedingungen (z.B. leere Strings, Null-Werte, ungültige Regex).
              * **Aktionsanwendung:**
                  * Testen jeder `RuleAction`-Variante: `Dismiss`, `Mute`, `Silent`, `LogOnly`, `SetUrgency`, `OverrideSummary`, `OverrideBody`.
                  * Tests für `ExecuteCommand` und `RunScript` (als Mock, da extern).
                  * Tests für `ApplyGlobalSetting` (sicherstellen, dass `GlobalSettingsService` aufgerufen wird).
                  * Testen von `StopProcessingFurtherRules` – sicherstellen, dass nach dieser Aktion keine weiteren Regeln angewendet werden.
                  * Kombinationen von Aktionen.
              * **Priorisierung:** Sicherstellen, dass Regeln mit höherer Priorität zuerst ausgewertet werden.
              * **Zusammenspiel:** Testen des gesamten Flows, d.h. Regel passt -\> Aktionen werden angewendet -\> `RuleProcessingResult` ist korrekt.
              * Fehler in einer Regel sollten die Verarbeitung anderer Regeln nicht blockieren (außer kritische Fehler).
          * **`get_rules` Tests:**
              * Rückgabe des korrekten Regelsets.
              * Sicherstellen, dass ein Klon zurückgegeben wird.
          * **`update_rules` Tests:**
              * Erfolg beim Aktualisieren und Speichern.
              * Validierungsfehler.
              * Fehlerbehandlung beim Speichern.

#### Funktionsspezifikation: `novade_domain::notification_rules::engine`

```rust
// novade-domain/src/notification_rules/engine.rs

//! Implementiert die Benachrichtigungs-Regel-Engine für NovaDE.
//! Diese Engine ist verantwortlich für die Auswertung von Benachrichtigungsregeln
//! und die Anwendung der entsprechenden Aktionen auf eingehende Benachrichtigungen.

use async_trait::async_trait;
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use regex::Regex;
use tracing::{debug, error, info, warn};

use crate::notification::data_types::{Notification, Urgency};
use crate::notification_rules::data_types::{
    ConditionValue, Field, NotificationRule, NotificationRuleSet, Operator, RuleAction, RuleCondition,
    SimpleRuleCondition,
};
use crate::notification_rules::errors::NotificationRulesError;
use crate::notification_rules::persistence_iface::NotificationRulesProvider;
use crate::global_settings::service_iface::GlobalSettingsService; // Annahme: GlobalSettingsService existiert

/// Das Ergebnis der Verarbeitung einer Benachrichtigung durch die Regel-Engine.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RuleProcessingResult {
    /// Die Benachrichtigung wurde nicht von einer Regel bearbeitet oder es wurden keine
    /// "StopProcessingFurtherRules"-Aktionen ausgeführt. Die Verarbeitung kann fortgesetzt werden.
    ContinueProcessing,
    /// Eine Regel hat eine "StopProcessingFurtherRules"-Aktion ausgelöst.
    /// Weitere Regeln für diese Benachrichtigung werden nicht angewendet.
    StopProcessing,
    /// Die Benachrichtigung wurde durch eine Regel verworfen (impliziert StopProcessing).
    Dismissed,
    /// Die Benachrichtigung wurde durch eine Regel stummgeschaltet (impliziert StopProcessing).
    Muted,
    /// Die Benachrichtigung wurde durch eine Regel unsichtbar gemacht (impliziert StopProcessing).
    Silenced,
}

impl RuleProcessingResult {
    /// Prüft, ob das Ergebnis das weitere Verarbeiten von Regeln beenden soll.
    pub fn should_stop_processing(&self) -> bool {
        matches!(
            self,
            RuleProcessingResult::StopProcessing
                | RuleProcessingResult::Dismissed
                | RuleProcessingResult::Muted
                | RuleProcessingResult::Silenced
        )
    }
}

/// Trait, der die Schnittstelle für die Benachrichtigungs-Regel-Engine definiert.
#[async_trait]
pub trait NotificationRulesEngine: Send + Sync {
    /// Lädt die Benachrichtigungsregeln neu aus der konfigurierten Persistenzschicht.
    async fn reload_rules(&self) -> Result<(), NotificationRulesError>;

    /// Evaluiert die Regeln für eine gegebene Benachrichtigung und wendet die entsprechenden Aktionen an.
    /// Ändert die Benachrichtigung in-place und gibt das Ergebnis der Verarbeitung zurück.
    async fn process_notification(
        &self,
        notification: &mut Notification,
    ) -> Result<RuleProcessingResult, NotificationRulesError>;

    /// Gibt das aktuell geladene Set von Benachrichtigungsregeln zurück.
    async fn get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>;

    /// Aktualisiert das Set der Benachrichtigungsregeln und speichert sie in der Persistenzschicht.
    async fn update_rules(&self, rules: NotificationRuleSet) -> Result<(), NotificationRulesError>;
}

/// Die Standardimplementierung der `NotificationRulesEngine`.
pub struct DefaultNotificationRulesEngine {
    /// Der Provider für die Persistenz von Benachrichtigungsregeln.
    rules_provider: Arc<dyn NotificationRulesProvider>,
    /// Der Dienst zur Verwaltung globaler Einstellungen.
    global_settings_service: Arc<dyn GlobalSettingsService>,
    /// Ein Thread-sicherer Cache für die aktuell geladenen Regeln.
    rules: Arc<RwLock<NotificationRuleSet>>,
}

impl DefaultNotificationRulesEngine {
    /// Erstellt eine neue Instanz von `DefaultNotificationRulesEngine`.
    ///
    /// # Arguments
    /// * `rules_provider` - Ein `Arc` auf die Implementierung des `NotificationRulesProvider`.
    /// * `global_settings_service` - Ein `Arc` auf die Implementierung des `GlobalSettingsService`.
    ///
    /// # Returns
    /// Eine neue `DefaultNotificationRulesEngine`-Instanz.
    pub async fn new(
        rules_provider: Arc<dyn NotificationRulesProvider>,
        global_settings_service: Arc<dyn GlobalSettingsService>,
    ) -> Self {
        let engine = Self {
            rules_provider,
            global_settings_service,
            rules: Arc::new(RwLock::new(NotificationRuleSet::default())),
        };

        // Initiales Laden der Regeln
        if let Err(e) = engine.reload_rules().await {
            error!("Failed to load initial notification rules: {:?}", e);
        } else {
            info!("Successfully loaded initial notification rules.");
        }

        engine
    }

    /// Hilfsfunktion zur Auswertung einer einzelnen `RuleCondition` gegen eine `Notification`.
    /// Diese Funktion ist rekursiv, um `And`, `Or` und `Not` zu verarbeiten.
    fn evaluate_condition(
        &self,
        condition: &RuleCondition,
        notification: &Notification,
    ) -> Result<bool, NotificationRulesError> {
        match condition {
            RuleCondition::Simple(simple_condition) => {
                self.evaluate_simple_condition(simple_condition, notification)
            }
            RuleCondition::And(conditions) => {
                for cond in conditions {
                    if !self.evaluate_condition(cond, notification)? {
                        return Ok(false);
                    }
                }
                Ok(true)
            }
            RuleCondition::Or(conditions) => {
                for cond in conditions {
                    if self.evaluate_condition(cond, notification)? {
                        return Ok(true);
                    }
                }
                Ok(false)
            }
            RuleCondition::Not(cond) => Ok(!self.evaluate_condition(cond, notification)?),
        }
    }

    /// Hilfsfunktion zur Auswertung einer `SimpleRuleCondition` gegen eine `Notification`.
    fn evaluate_simple_condition(
        &self,
        condition: &SimpleRuleCondition,
        notification: &Notification,
    ) -> Result<bool, NotificationRulesError> {
        let notification_value: ConditionValue = match &condition.field {
            Field::AppName => notification.app_name.clone().into(),
            Field::Summary => notification.summary.clone().into(),
            Field::Body => notification.body.clone().into(),
            Field::Category => notification
                .category
                .as_ref()
                .map_or(ConditionValue::Null, |c| c.to_string().into()),
            Field::Urgency => notification.urgency.as_u8().into(),
            Field::DesktopEntry => notification
                .desktop_entry
                .as_ref()
                .map_or(ConditionValue::Null, |d| d.clone().into()),
            Field::Transient => notification.transient.into(),
            Field::Hint(key) => notification
                .hints
                .get(key)
                .map_or(ConditionValue::Null, |v| v.clone().into()), // Assuming hints are already ConditionValue or convertable
            Field::SenderId => notification.sender_id.to_string().into(),
        };

        match &condition.operator {
            Operator::Equal => Ok(notification_value == condition.value),
            Operator::NotEqual => Ok(notification_value != condition.value),
            Operator::GreaterThan => {
                if let (ConditionValue::Integer(n_val), ConditionValue::Integer(c_val)) =
                    (&notification_value, &condition.value)
                {
                    Ok(n_val > c_val)
                } else if let (ConditionValue::Float(n_val), ConditionValue::Float(c_val)) =
                    (&notification_value, &condition.value)
                {
                    Ok(n_val > c_val)
                } else {
                    warn!("Attempted to compare non-numeric values with GreaterThan operator.");
                    Ok(false)
                }
            }
            Operator::LessThan => {
                if let (ConditionValue::Integer(n_val), ConditionValue::Integer(c_val)) =
                    (&notification_value, &condition.value)
                {
                    Ok(n_val < c_val)
                } else if let (ConditionValue::Float(n_val), ConditionValue::Float(c_val)) =
                    (&notification_value, &condition.value)
                {
                    Ok(n_val < c_val)
                } else {
                    warn!("Attempted to compare non-numeric values with LessThan operator.");
                    Ok(false)
                }
            }
            Operator::GreaterThanOrEqual => {
                if let (ConditionValue::Integer(n_val), ConditionValue::Integer(c_val)) =
                    (&notification_value, &condition.value)
                {
                    Ok(n_val >= c_val)
                } else if let (ConditionValue::Float(n_val), ConditionValue::Float(c_val)) =
                    (&notification_value, &condition.value)
                {
                    Ok(n_val >= c_val)
                } else {
                    warn!("Attempted to compare non-numeric values with GreaterThanOrEqual operator.");
                    Ok(false)
                }
            }
            Operator::LessThanOrEqual => {
                if let (ConditionValue::Integer(n_val), ConditionValue::Integer(c_val)) =
                    (&notification_value, &condition.value)
                {
                    Ok(n_val <= c_val)
                } else if let (ConditionValue::Float(n_val), ConditionValue::Float(c_val)) =
                    (&notification_value, &condition.value)
                {
                    Ok(n_val <= c_val)
                } else {
                    warn!("Attempted to compare non-numeric values with LessThanOrEqual operator.");
                    Ok(false)
                }
            }
            Operator::Contains => {
                if let (ConditionValue::String(n_val), ConditionValue::String(c_val)) =
                    (&notification_value, &condition.value)
                {
                    Ok(n_val.to_lowercase().contains(&c_val.to_lowercase()))
                } else {
                    warn!("Attempted to use Contains operator on non-string values.");
                    Ok(false)
                }
            }
            Operator::StartsWith => {
                if let (ConditionValue::String(n_val), ConditionValue::String(c_val)) =
                    (&notification_value, &condition.value)
                {
                    Ok(n_val.to_lowercase().starts_with(&c_val.to_lowercase()))
                } else {
                    warn!("Attempted to use StartsWith operator on non-string values.");
                    Ok(false)
                }
            }
            Operator::EndsWith => {
                if let (ConditionValue::String(n_val), ConditionValue::String(c_val)) =
                    (&notification_value, &condition.value)
                {
                    Ok(n_val.to_lowercase().ends_with(&c_val.to_lowercase()))
                } else {
                    warn!("Attempted to use EndsWith operator on non-string values.");
                    Ok(false)
                }
            }
            Operator::MatchesRegex => {
                if let ConditionValue::String(n_val) = &notification_value {
                    if let ConditionValue::String(c_val) = &condition.value {
                        match Regex::new(c_val) {
                            Ok(regex) => Ok(regex.is_match(n_val)),
                            Err(e) => {
                                error!("Invalid regex pattern '{}': {}", c_val, e);
                                Ok(false)
                            }
                        }
                    } else {
                        warn!("MatchesRegex operator requires a string pattern.");
                        Ok(false)
                    }
                } else {
                    warn!("MatchesRegex operator can only be applied to string values.");
                    Ok(false)
                }
            }
            Operator::IsIn => {
                if let ConditionValue::Array(c_arr) = &condition.value {
                    Ok(c_arr.contains(&notification_value))
                } else {
                    warn!("IsIn operator requires an array value in the condition.");
                    Ok(false)
                }
            }
            Operator::IsNotIn => {
                if let ConditionValue::Array(c_arr) = &condition.value {
                    Ok(!c_arr.contains(&notification_value))
                } else {
                    warn!("IsNotIn operator requires an array value in the condition.");
                    Ok(false)
                }
            }
            Operator::SettingIsTrue => {
                if let ConditionValue::Boolean(true) = notification_value {
                    Ok(true)
                } else {
                    Ok(false)
                }
            }
        }
    }

    /// Hilfsfunktion zur Anwendung einer einzelnen `RuleAction` auf eine `Notification`.
    async fn apply_action(
        &self,
        action: &RuleAction,
        notification: &mut Notification,
    ) -> Result<RuleProcessingResult, NotificationRulesError> {
        match action {
            RuleAction::Dismiss => {
                debug!("Action: Dismissing notification {}", notification.id);
                Ok(RuleProcessingResult::Dismissed)
            }
            RuleAction::Mute => {
                debug!("Action: Muting notification {}", notification.id);
                notification.mute = true;
                Ok(RuleProcessingResult::Muted)
            }
            RuleAction::Silent => {
                debug!("Action: Silencing notification {}", notification.id);
                notification.silent = true;
                Ok(RuleProcessingResult::Silenced)
            }
            RuleAction::LogOnly => {
                debug!("Action: Logging only notification {}", notification.id);
                // No change to notification, just a conceptual action
                Ok(RuleProcessingResult::ContinueProcessing)
            }
            RuleAction::SetUrgency(urgency_level) => {
                debug!("Action: Setting urgency for notification {} to {}", notification.id, urgency_level);
                notification.urgency = Urgency::from_u8(*urgency_level);
                Ok(RuleProcessingResult::ContinueProcessing)
            }
            RuleAction::OverrideSummary(new_summary) => {
                debug!("Action: Overriding summary for notification {}", notification.id);
                notification.summary = new_summary.clone();
                Ok(RuleProcessingResult::ContinueProcessing)
            }
            RuleAction::OverrideBody(new_body) => {
                debug!("Action: Overriding body for notification {}", notification.id);
                notification.body = new_body.clone();
                Ok(RuleProcessingResult::ContinueProcessing)
            }
            RuleAction::ExecuteCommand(command, args) => {
                warn!(
                    "Action: Attempting to execute command for notification {}. Command execution is a security risk and is limited.",
                    notification.id
                );
                // TODO: Implement safe command execution, potentially via a sandboxed system service.
                // For now, this is a placeholder or requires a whitelist.
                // For demonstration, we'll just log an attempt.
                // Example: tokio::process::Command::new(command).args(args).spawn().ok();
                Ok(RuleProcessingResult::ContinueProcessing)
            }
            RuleAction::RunScript(script_path, args) => {
                warn!(
                    "Action: Attempting to run script for notification {}. Script execution is a security risk and is limited.",
                    notification.id
                );
                // Similar to ExecuteCommand, requires robust security considerations.
                Ok(RuleProcessingResult::ContinueProcessing)
            }
            RuleAction::ApplyGlobalSetting(key, value) => {
                debug!(
                    "Action: Applying global setting '{}' with value '{:?}' for notification {}",
                    key, value, notification.id
                );
                // Assuming GlobalSettingsService takes ConditionValue or converts it.
                // This might need specific type conversion logic depending on GlobalSettingsService API.
                self.global_settings_service.set_setting(key.clone(), value.clone()).await
                    .map_err(|e| NotificationRulesError::ClientError(e.into()))?; // Convert GlobalSettingsError to NotificationRulesError
                Ok(RuleProcessingResult::ContinueProcessing)
            }
            RuleAction::StopProcessingFurtherRules => {
                debug!("Action: Stop processing further rules for notification {}", notification.id);
                Ok(RuleProcessingResult::StopProcessing)
            }
        }
    }
}

#[async_trait]
impl NotificationRulesEngine for DefaultNotificationRulesEngine {
    async fn reload_rules(&self) -> Result<(), NotificationRulesError> {
        info!("Reloading notification rules from persistence.");
        let loaded_rules = self.rules_provider.load_rules().await?;
        let mut rules_write = self.rules.write().unwrap();
        *rules_write = loaded_rules;
        info!("Notification rules reloaded successfully.");
        Ok(())
    }

    async fn process_notification(
        &self,
        notification: &mut Notification,
    ) -> Result<RuleProcessingResult, NotificationRulesError> {
        debug!("Processing notification: {}", notification.id);
        let rules_read = self.rules.read().unwrap();
        let mut final_result = RuleProcessingResult::ContinueProcessing;

        // Sort rules by priority (lower value = higher priority)
        let mut sorted_rules: Vec<&NotificationRule> = rules_read
            .rules
            .iter()
            .filter(|rule| rule.enabled) // Only consider enabled rules
            .collect();
        sorted_rules.sort_by_key(|rule| rule.priority);

        for rule in sorted_rules {
            debug!(
                "Evaluating rule '{}' (ID: {}) for notification {}",
                rule.name, rule.id, notification.id
            );
            match self.evaluate_condition(&rule.conditions, notification) {
                Ok(true) => {
                    info!(
                        "Rule '{}' (ID: {}) matched for notification {}",
                        rule.name, rule.id, notification.id
                    );
                    for action in &rule.actions {
                        let action_result = self.apply_action(action, notification).await?;
                        if action_result.should_stop_processing() {
                            // If a critical action like Dismiss/Mute/Silent or StopProcessingFurtherRules is triggered,
                            // update the final result and break from action processing for this rule.
                            final_result = action_result;
                            break; // Stop processing actions for this rule
                        }
                    }
                    if final_result.should_stop_processing() {
                        info!("Rule '{}' (ID: {}) caused processing to stop for notification {}", rule.name, rule.id, notification.id);
                        break; // Stop processing further rules
                    }
                }
                Ok(false) => {
                    debug!("Rule '{}' (ID: {}) did not match for notification {}", rule.name, rule.id, notification.id);
                }
                Err(e) => {
                    error!(
                        "Error evaluating rule '{}' (ID: {}) for notification {}: {:?}",
                        rule.name, rule.id, notification.id, e
                    );
                    // Continue to next rule in case of evaluation error unless it's critical
                }
            }
        }
        debug!("Finished processing notification {}. Result: {:?}", notification.id, final_result);
        Ok(final_result)
    }

    async fn get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError> {
        let rules_read = self.rules.read().unwrap();
        Ok(rules_read.clone())
    }

    async fn update_rules(&self, rules: NotificationRuleSet) -> Result<(), NotificationRulesError> {
        info!("Updating notification rules and saving to persistence.");
        // TODO: Add validation for the incoming rules (e.g., check for duplicate IDs, invalid data)
        // For now, assume rules are valid.

        let mut rules_write = self.rules.write().unwrap();
        *rules_write = rules.clone(); // Update in-memory cache

        self.rules_provider.save_rules(&rules).await?; // Persist to storage
        info!("Notification rules updated and saved successfully.");
        Ok(())
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use async_trait::async_trait;
    use mockall::{automock, predicate::*};
    use uuid::Uuid;
    use crate::notification::data_types::{Notification, Urgency, NotificationHint};
    use crate::notification_rules::data_types::{
        NotificationRule, NotificationRuleSet, RuleCondition, SimpleRuleCondition, Field, Operator,
        RuleAction, ConditionValue,
    };
    use chrono::{Utc, Duration};
    use std::collections::HashMap;
    use crate::global_settings::errors::GlobalSettingsError; // Assuming this exists

    // Mock NotificationRulesProvider
    #[automock]
    #[async_trait]
    impl NotificationRulesProvider for MockNotificationRulesProvider {
        async fn load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError> {
            self.load_rules().await
        }
        async fn save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError> {
            self.save_rules(rules).await
        }
    }

    // Mock GlobalSettingsService
    #[automock]
    #[async_trait]
    impl GlobalSettingsService for MockGlobalSettingsService {
        async fn get_setting(&self, key: &str) -> Result<novade_core::config::ConfigValue, GlobalSettingsError> {
            self.get_setting(key).await
        }
        async fn set_setting(&self, key: String, value: ConditionValue) -> Result<(), GlobalSettingsError> {
            self.set_setting(key, value).await
        }
        async fn subscribe_to_setting_changes(&self, key: &str) -> Result<tokio::sync::broadcast::Receiver<novade_core::config::ConfigValue>, GlobalSettingsError> {
            // Mocking broadcast receivers is complex. For unit tests, we'll just return a dummy.
            let (tx, _rx) = tokio::sync::broadcast::channel(1);
            Ok(tx.subscribe())
        }
    }


    // Helper to create a basic notification
    fn create_test_notification(
        app_name: &str,
        summary: &str,
        body: &str,
        urgency: Urgency,
        hints: Option<HashMap<String, ConditionValue>>,
    ) -> Notification {
        Notification {
            id: Uuid::new_v4(),
            replaces_id: 0,
            app_name: app_name.to_string(),
            summary: summary.to_string(),
            body: body.to_string(),
            icon: "".to_string(), // Placeholder
            category: None,
            urgency,
            actions: vec![],
            desktop_entry: None,
            transient: false,
            timestamp: Utc::now(),
            expire_timeout_ms: -1,
            hints: hints.unwrap_or_default(),
            mute: false,
            silent: false,
            sender_id: Uuid::new_v4(),
        }
    }

    // Helper to create a simple rule
    fn create_simple_rule(
        name: &str,
        priority: u32,
        field: Field,
        op: Operator,
        value: ConditionValue,
        actions: Vec<RuleAction>,
    ) -> NotificationRule {
        NotificationRule {
            id: Uuid::new_v4(),
            name: name.to_string(),
            description: None,
            priority,
            enabled: true,
            conditions: RuleCondition::Simple(SimpleRuleCondition { field, operator: op, value }),
            actions,
        }
    }

    #[tokio::test]
    async fn test_reload_rules_success() {
        let mut mock_provider = MockNotificationRulesProvider::new();
        let mut mock_settings_service = MockGlobalSettingsService::new();
        let rule_id = Uuid::new_v4();
        let rule = create_simple_rule(
            "TestRule",
            100,
            Field::AppName,
            Operator::Equal,
            "TestApp".to_string().into(),
            vec![],
        );
        let rules_set = NotificationRuleSet { rules: vec![rule.clone()] };

        mock_provider
            .expect_load_rules()
            .once()
            .returning(move || Ok(rules_set.clone()));

        // The constructor calls reload_rules, so we mock that.
        // For the reload_rules call directly, we need another mock.
        mock_provider
            .expect_load_rules()
            .once()
            .returning(move || Ok(NotificationRuleSet { rules: vec![rule.clone()] }));


        let engine = DefaultNotificationRulesEngine::new(
            Arc::new(mock_provider),
            Arc::new(mock_settings_service),
        ).await;

        let result = engine.reload_rules().await;
        assert!(result.is_ok());
        assert_eq!(engine.rules.read().unwrap().rules.len(), 1);
        assert_eq!(engine.rules.read().unwrap().rules[0].name, "TestRule");
    }

    #[tokio::test]
    async fn test_process_notification_no_match() {
        let mut mock_provider = MockNotificationRulesProvider::new();
        let mut mock_settings_service = MockGlobalSettingsService::new();
        let rule = create_simple_rule(
            "Mute Firefox",
            100,
            Field::AppName,
            Operator::Equal,
            "Firefox".to_string().into(),
            vec![RuleAction::Mute],
        );
        let rules_set = NotificationRuleSet { rules: vec![rule] };

        mock_provider.expect_load_rules().returning(move || Ok(rules_set.clone()));

        let engine = DefaultNotificationRulesEngine::new(
            Arc::new(mock_provider),
            Arc::new(mock_settings_service),
        ).await;

        let mut notification =
            create_test_notification("Chrome", "New Email", "You have a new email.", Urgency::Normal, None);

        let result = engine.process_notification(&mut notification).await.unwrap();
        assert_eq!(result, RuleProcessingResult::ContinueProcessing);
        assert!(!notification.mute); // Should not be muted
    }

    #[tokio::test]
    async fn test_process_notification_match_and_mute() {
        let mut mock_provider = MockNotificationRulesProvider::new();
        let mut mock_settings_service = MockGlobalSettingsService::new();
        let rule = create_simple_rule(
            "Mute Firefox",
            100,
            Field::AppName,
            Operator::Equal,
            "Firefox".to_string().into(),
            vec![RuleAction::Mute],
        );
        let rules_set = NotificationRuleSet { rules: vec![rule] };

        mock_provider.expect_load_rules().returning(move || Ok(rules_set.clone()));

        let engine = DefaultNotificationRulesEngine::new(
            Arc::new(mock_provider),
            Arc::new(mock_settings_service),
        ).await;

        let mut notification =
            create_test_notification("Firefox", "New Email", "You have a new email.", Urgency::Normal, None);

        let result = engine.process_notification(&mut notification).await.unwrap();
        assert_eq!(result, RuleProcessingResult::Muted);
        assert!(notification.mute); // Should be muted
    }

    #[tokio::test]
    async fn test_process_notification_stop_processing_further_rules() {
        let mut mock_provider = MockNotificationRulesProvider::new();
        let mut mock_settings_service = MockGlobalSettingsService::new();

        let rule1 = create_simple_rule(
            "Stop for important",
            10, // Higher priority
            Field::Urgency,
            Operator::Equal,
            Urgency::Critical.as_u8().into(),
            vec![RuleAction::StopProcessingFurtherRules],
        );
        let rule2 = create_simple_rule(
            "Dismiss All",
            20, // Lower priority
            Field::AppName,
            Operator::Contains,
            "anything".to_string().into(),
            vec![RuleAction::Dismiss],
        );
        let rules_set = NotificationRuleSet { rules: vec![rule1, rule2] };

        mock_provider.expect_load_rules().returning(move || Ok(rules_set.clone()));

        let engine = DefaultNotificationRulesEngine::new(
            Arc::new(mock_provider),
            Arc::new(mock_settings_service),
        ).await;

        let mut notification =
            create_test_notification("TestApp", "Critical Alert", "Something bad happened.", Urgency::Critical, None);

        let result = engine.process_notification(&mut notification).await.unwrap();
        assert_eq!(result, RuleProcessingResult::StopProcessing);
        // Ensure dismiss action from rule2 was NOT applied
        // (This would require more sophisticated testing to see if a side effect of Dismiss happened)
    }

    #[tokio::test]
    async fn test_process_notification_priority_order() {
        let mut mock_provider = MockNotificationRulesProvider::new();
        let mut mock_settings_service = MockGlobalSettingsService::new();

        let rule_low_prio_dismiss = create_simple_rule(
            "Dismiss All Low Prio",
            200, // Low priority
            Field::AppName,
            Operator::Equal,
            "TestApp".to_string().into(),
            vec![RuleAction::Dismiss],
        );
        let rule_high_prio_mute = create_simple_rule(
            "Mute TestApp High Prio",
            100, // High priority
            Field::AppName,
            Operator::Equal,
            "TestApp".to_string().into(),
            vec![RuleAction::Mute],
        );
        // Rule order in vector doesn't matter, priority dictates
        let rules_set = NotificationRuleSet { rules: vec![rule_low_prio_dismiss, rule_high_prio_mute] };

        mock_provider.expect_load_rules().returning(move || Ok(rules_set.clone()));

        let engine = DefaultNotificationRulesEngine::new(
            Arc::new(mock_provider),
            Arc::new(mock_settings_service),
        ).await;

        let mut notification =
            create_test_notification("TestApp", "Subject", "Body", Urgency::Normal, None);

        let result = engine.process_notification(&mut notification).await.unwrap();
        // The high priority rule (mute) should apply first, and then stop processing.
        // So, the dismiss rule should NOT be applied.
        assert_eq!(result, RuleProcessingResult::Muted);
        assert!(notification.mute);
        // To verify dismiss was not called, one might need a more complex mock system
        // that checks side-effects like a call to a "display service"
    }

    #[tokio::test]
    async fn test_process_notification_set_urgency_and_override() {
        let mut mock_provider = MockNotificationRulesProvider::new();
        let mut mock_settings_service = MockGlobalSettingsService::new();
        let rule = create_simple_rule(
            "Modify Info",
            100,
            Field::Summary,
            Operator::Contains,
            "Info".to_string().into(),
            vec![
                RuleAction::SetUrgency(Urgency::Critical.as_u8()),
                RuleAction::OverrideSummary("Modified Summary".to_string()),
                RuleAction::OverrideBody("Modified Body".to_string()),
            ],
        );
        let rules_set = NotificationRuleSet { rules: vec![rule] };

        mock_provider.expect_load_rules().returning(move || Ok(rules_set.clone()));

        let engine = DefaultNotificationRulesEngine::new(
            Arc::new(mock_provider),
            Arc::new(mock_settings_service),
        ).await;

        let mut notification =
            create_test_notification("App", "Some Info", "Original Body", Urgency::Normal, None);

        let result = engine.process_notification(&mut notification).await.unwrap();
        assert_eq!(result, RuleProcessingResult::ContinueProcessing); // No stop action
        assert_eq!(notification.urgency, Urgency::Critical);
        assert_eq!(notification.summary, "Modified Summary");
        assert_eq!(notification.body, "Modified Body");
    }

    #[tokio::test]
    async fn test_process_notification_apply_global_setting() {
        let mut mock_provider = MockNotificationRulesProvider::new();
        let mut mock_settings_service = MockGlobalSettingsService::new();

        let rule = create_simple_rule(
            "Apply Setting",
            100,
            Field::AppName,
            Operator::Equal,
            "SpecialApp".to_string().into(),
            vec![
                RuleAction::ApplyGlobalSetting("dark_mode_active".to_string(), ConditionValue::Boolean(true)),
            ],
        );
        let rules_set = NotificationRuleSet { rules: vec![rule] };

        mock_provider.expect_load_rules().returning(move || Ok(rules_set.clone()));
        mock_settings_service.expect_set_setting()
            .with(eq("dark_mode_active".to_string()), eq(ConditionValue::Boolean(true)))
            .once()
            .returning(|_, _| Ok(()));

        let engine = DefaultNotificationRulesEngine::new(
            Arc::new(mock_provider),
            Arc::new(mock_settings_service),
        ).await;

        let mut notification =
            create_test_notification("SpecialApp", "Update", "New version available.", Urgency::Normal, None);

        let result = engine.process_notification(&mut notification).await.unwrap();
        assert_eq!(result, RuleProcessingResult::ContinueProcessing);
        // The mock ensures set_setting was called.
    }

    #[tokio::test]
    async fn test_evaluate_condition_regex() {
        let mut mock_provider = MockNotificationRulesProvider::new();
        let mut mock_settings_service = MockGlobalSettingsService::new();

        let rule_id = Uuid::new_v4();
        let rule = create_simple_rule(
            "Regex Match",
            100,
            Field::Summary,
            Operator::MatchesRegex,
            r"^(error|fail)".to_string().into(),
            vec![],
        );
        let rules_set = NotificationRuleSet { rules: vec![rule] };

        mock_provider.expect_load_rules().returning(move || Ok(rules_set.clone()));

        let engine = DefaultNotificationRulesEngine::new(
            Arc::new(mock_provider),
            Arc::new(mock_settings_service),
        ).await;

        let mut notification_match = create_test_notification("App", "Error occurred", "Details", Urgency::Normal, None);
        let result_match = engine.process_notification(&mut notification_match).await.unwrap();
        assert_eq!(result_match, RuleProcessingResult::ContinueProcessing); // Assuming no actual action taken

        let mut notification_no_match = create_test_notification("App", "Success", "Details", Urgency::Normal, None);
        let result_no_match = engine.process_notification(&mut notification_no_match).await.unwrap();
        assert_eq!(result_no_match, RuleProcessingResult::ContinueProcessing);
    }


    #[tokio::test]
    async fn test_evaluate_condition_contains_case_insensitive() {
        let mut mock_provider = MockNotificationRulesProvider::new();
        let mut mock_settings_service = MockGlobalSettingsService::new();

        let rule = create_simple_rule(
            "Contains Test",
            100,
            Field::Body,
            Operator::Contains,
            "secret".to_string().into(),
            vec![],
        );
        let rules_set = NotificationRuleSet { rules: vec![rule] };

        mock_provider.expect_load_rules().returning(move || Ok(rules_set.clone()));

        let engine = DefaultNotificationRulesEngine::new(
            Arc::new(mock_provider),
            Arc::new(mock_settings_service),
        ).await;

        let mut notif1 = create_test_notification("App", "Sum", "This contains a secret message.", Urgency::Normal, None);
        assert!(engine.process_notification(&mut notif1).await.is_ok()); // Should match

        let mut notif2 = create_test_notification("App", "Sum", "This contains no SECRETS.", Urgency::Normal, None);
        assert!(engine.process_notification(&mut notif2).await.is_ok()); // Should match (case insensitive)
    }

    #[tokio::test]
    async fn test_evaluate_condition_numeric_comparison() {
        let mut mock_provider = MockNotificationRulesProvider::new();
        let mut mock_settings_service = MockGlobalSettingsService::new();
        let rule_id = Uuid::new_v4();

        // Rule: Urgency > Normal (1)
        let rule = create_simple_rule(
            "High Urgency",
            100,
            Field::Urgency,
            Operator::GreaterThan,
            Urgency::Normal.as_u8().into(),
            vec![RuleAction::LogOnly],
        );
        let rules_set = NotificationRuleSet { rules: vec![rule] };

        mock_provider.expect_load_rules().returning(move || Ok(rules_set.clone()));

        let engine = DefaultNotificationRulesEngine::new(
            Arc::new(mock_provider),
            Arc::new(mock_settings_service),
        ).await;

        let mut notif_low = create_test_notification("App", "", "", Urgency::Low, None);
        assert_eq!(engine.process_notification(&mut notif_low).await.unwrap(), RuleProcessingResult::ContinueProcessing); // 0 > 1 is false

        let mut notif_normal = create_test_notification("App", "", "", Urgency::Normal, None);
        assert_eq!(engine.process_notification(&mut notif_normal).await.unwrap(), RuleProcessingResult::ContinueProcessing); // 1 > 1 is false

        let mut notif_critical = create_test_notification("App", "", "", Urgency::Critical, None);
        assert_eq!(engine.process_notification(&mut notif_critical).await.unwrap(), RuleProcessingResult::ContinueProcessing); // 2 > 1 is true, LogOnly is Continue
    }

    #[tokio::test]
    async fn test_evaluate_condition_in_array() {
        let mut mock_provider = MockNotificationRulesProvider::new();
        let mut mock_settings_service = MockGlobalSettingsService::new();

        let rule = create_simple_rule(
            "App In List",
            100,
            Field::AppName,
            Operator::IsIn,
            ConditionValue::Array(vec!["Firefox".into(), "Chrome".into(), "Edge".into()]),
            vec![],
        );
        let rules_set = NotificationRuleSet { rules: vec![rule] };

        mock_provider.expect_load_rules().returning(move || Ok(rules_set.clone()));

        let engine = DefaultNotificationRulesEngine::new(
            Arc::new(mock_provider),
            Arc::new(mock_settings_service),
        ).await;

        let mut notif_firefox = create_test_notification("Firefox", "", "", Urgency::Normal, None);
        let res_firefox = engine.process_notification(&mut notif_firefox).await.unwrap();
        assert_eq!(res_firefox, RuleProcessingResult::ContinueProcessing);

        let mut notif_safari = create_test_notification("Safari", "", "", Urgency::Normal, None);
        let res_safari = engine.process_notification(&mut notif_safari).await.unwrap();
        assert_eq!(res_safari, RuleProcessingResult::ContinueProcessing); // No match
    }

    #[tokio::test]
    async fn test_evaluate_condition_logical_and() {
        let mut mock_provider = MockNotificationRulesProvider::new();
        let mut mock_settings_service = MockGlobalSettingsService::new();

        let rule = NotificationRule {
            id: Uuid::new_v4(),
            name: "And Test".to_string(),
            description: None,
            priority: 100,
            enabled: true,
            conditions: RuleCondition::And(vec![
                RuleCondition::Simple(SimpleRuleCondition {
                    field: Field::AppName,
                    operator: Operator::Equal,
                    value: "TestApp".to_string().into(),
                }),
                RuleCondition::Simple(SimpleRuleCondition {
                    field: Field::Summary,
                    operator: Operator::Contains,
                    value: "Error".to_string().into(),
                }),
            ]),
            actions: vec![RuleAction::Dismiss],
        };
        let rules_set = NotificationRuleSet { rules: vec![rule] };

        mock_provider.expect_load_rules().returning(move || Ok(rules_set.clone()));

        let engine = DefaultNotificationRulesEngine::new(
            Arc::new(mock_provider),
            Arc::new(mock_settings_service),
        ).await;

        let mut notif_match = create_test_notification("TestApp", "An Error occurred", "", Urgency::Normal, None);
        let res_match = engine.process_notification(&mut notif_match).await.unwrap();
        assert_eq!(res_match, RuleProcessingResult::Dismissed);

        let mut notif_no_match_app = create_test_notification("OtherApp", "An Error occurred", "", Urgency::Normal, None);
        let res_no_match_app = engine.process_notification(&mut notif_no_match_app).await.unwrap();
        assert_eq!(res_no_match_app, RuleProcessingResult::ContinueProcessing);

        let mut notif_no_match_summary = create_test_notification("TestApp", "Success", "", Urgency::Normal, None);
        let res_no_match_summary = engine.process_notification(&mut notif_no_match_summary).await.unwrap();
        assert_eq!(res_no_match_summary, RuleProcessingResult::ContinueProcessing);
    }
}
```
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (32 von 100) widmet sich der Implementierung des `novade-domain/src/notification/mod.rs` Moduls, das die öffentliche API für den Benachrichtigungsdienst definiert. Dieses Modul ist der zentrale Einstiegspunkt für andere Domänen- und Systemkomponenten, um mit Benachrichtigungen zu interagieren.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 32/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.20. `novade-domain/src/notification` Verzeichnis

Dieses Verzeichnis beherbergt die Kernlogik und Infrastruktur für das Management von Benachrichtigungen, die von Anwendungen oder Systemkomponenten an den Benutzer gesendet werden. Es umfasst Datentypen, Fehlerdefinitionen, die Persistenz von Benachrichtigungshistorie und den zentralen Benachrichtigungsdienst, der auch mit den Benachrichtigungsregeln interagiert.

#### 3.20.1. `novade-domain/src/notification/mod.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification/mod.rs`
* **Verantwortlichkeit:** Definiert die öffentliche API des `notification`-Moduls der Domänenschicht. Es re-exportiert alle wichtigen Typen, Traits, Enums und Strukturen, die von anderen Teilen der Domänenschicht (z.B. `notification_rules`, `global_settings`) oder von höheren Schichten (z.B. der UI-Schicht, Systemschicht via D-Bus) benötigt werden, um Benachrichtigungen zu erstellen, zu verwalten, zu empfangen oder auf sie zu reagieren.
* **Kern-Aufgaben (Tasks):**
    1.  **Public API Definition:** Re-exportiere die folgenden Komponenten, die die Schnittstelle dieses Moduls bilden:
        * `data_types` (alle relevanten Typen wie `Notification`, `NotificationId`, `Urgency`, `NotificationHint`, `Action`, `NotificationCategory`).
        * `errors` (das `NotificationError` Enum).
        * `service_iface` (den `NotificationService` Trait).
        * `service` (die konkrete `DefaultNotificationService` Implementierung).
        * `repository_iface` (den `NotificationRepository` Trait).
        * `repository` (die konkrete `InMemoryNotificationRepository` Implementierung).
    2.  **Modul-Strukturierung:** Sicherstellen, dass alle Re-Exporte korrekt sind und keine internen Implementierungsdetails unnötigerweise exponiert werden.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification/mod.rs`
* **Abhängigkeiten:**
    * **Intern:** `data_types`, `errors`, `service_iface`, `service`, `repository_iface`, `repository` (innerhalb desselben `notification` Moduls).
    * **Extern:** Keine direkten, da nur Re-Exporte stattfinden.
* **Kommunikationsmuster:** Stellt die Hauptschnittstelle des `notification`-Moduls zur Verfügung. Es ist der primäre Punkt, über den die Systemschicht (`dbus_interfaces::notifications_server`) neue Benachrichtigungen an die Domänenschicht übergibt und die UI-Schicht den Status von Benachrichtigungen abfragt oder Aktionen auslöst.
* **Erwartete Ergebnisse/Outputs:** Eine klar definierte und leicht nutzbare öffentliche API für die Benachrichtigungsverwaltung innerhalb der Domänenschicht, die konsistente Interaktionen über alle Schichten hinweg ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte sind. Die Tests erfolgen in den jeweiligen Submodulen.

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (33 von 100) widmet sich der Implementierung der grundlegenden Datentypen für Benachrichtigungen in `novade-domain/src/notification/data_types.rs`. Diese Strukturen sind essenziell, um Benachrichtigungen konsistent im gesamten System zu repräsentieren.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 33/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.20.2. `novade-domain/src/notification/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification/data_types.rs`
  * **Verantwortlichkeit:** Definiert die grundlegenden Datenstrukturen, die zur Repräsentation einer Benachrichtigung und ihrer zugehörigen Attribute innerhalb der Domänenschicht von NovaDE verwendet werden. Diese Typen bilden die Basis für die Kommunikation von Benachrichtigungsdaten zwischen Systemkomponenten und der UI. Sie müssen robust, serialisierbar und einfach zu handhaben sein.
  * **Kern-Aufgaben (Tasks):**
    1.  **`NotificationId` Typ-Alias definieren:**
          * `pub type NotificationId = u32;` (Für D-Bus `replaces_id`, 0 für neue Benachrichtigungen).
    2.  **`Urgency` Enum definieren:**
          * Repräsentiert die Dringlichkeitsstufe einer Benachrichtigung gemäß Freedesktop.org Notification Specification.
          * Varianten: `Low (0)`, `Normal (1)`, `Critical (2)`.
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Copy`, `Debug`, `Serialize`, `Deserialize`, `Default`.
          * Implementiere `From<u8>` für Konvertierung von D-Bus-Werten.
          * Implementiere `as_u8(&self) -> u8` Methode.
          * Implementiere `Display` Trait für einfache String-Repräsentation.
        <!-- end list -->
        ```rust
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        #[repr(u8)] // Ensures enum directly maps to u8 for D-Bus compatibility
        pub enum Urgency {
            Low = 0,
            Normal = 1,
            Critical = 2,
        }

        impl Default for Urgency {
            fn default() -> Self {
                Urgency::Normal
            }
        }

        impl From<u8> for Urgency {
            fn from(value: u8) -> Self {
                match value {
                    0 => Urgency::Low,
                    1 => Urgency::Normal,
                    2 => Urgency::Critical,
                    _ => {
                        // Log a warning if an unknown urgency is received and default to Normal
                        tracing::warn!("Received unknown urgency level: {}. Defaulting to Normal.", value);
                        Urgency::Normal
                    }
                }
            }
        }

        impl Urgency {
            pub fn as_u8(&self) -> u8 {
                *self as u8
            }
        }

        impl std::fmt::Display for Urgency {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "{}", match self {
                    Urgency::Low => "Low",
                    Urgency::Normal => "Normal",
                    Urgency::Critical => "Critical",
                })
            }
        }
        ```
    3.  **`NotificationCategory` Enum definieren:**
          * Repräsentiert die Kategorie der Benachrichtigung (optional, gemäß Spec).
          * Beispiele: `Device`, `Email`, `IM`, `News`, `Alarm`, `Call`, `Progress`, `Transfer`, `Updater`, `System`, `Wallet`, `Other(String)`.
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`, `Display`.
          * Implementiere `From<String>` und `From<&str>` für Konvertierung.
    4.  **`Action` Struct definieren:**
          * Repräsentiert eine Aktion, die der Benutzer ausführen kann.
          * Felder: `key: String`, `label: String`.
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`, `Default`.
    5.  **`NotificationHint` Enum definieren:**
          * Repräsentiert zusätzliche Metadaten (Hints) einer Benachrichtigung, die als Key-Value-Paare über D-Bus gesendet werden.
          * Sollte verschiedene Wertetypen unterstützen. Da die `notification_rules` bereits `ConditionValue` definiert, kann diese hier wiederverwendet werden, um Konsistenz zu wahren.
          * Varianten: `ConditionValue`. Dies vereinfacht die Verarbeitung der Hints in der Regel-Engine.
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`, `From<ConditionValue>`.
          * Es könnte auch eine `HashMap<String, ConditionValue>` für die Hints in der `Notification`-Struktur verwendet werden, statt eines separaten Enums. **Entscheidung:** Eine `HashMap<String, ConditionValue>` ist flexibler und entspricht besser dem D-Bus Hints-Konzept, bei dem der Hint-Name selbst der Schlüssel ist, nicht eine vordefinierte Enum-Variante.
    6.  **`Notification` Struct definieren:**
          * Die zentrale Datenstruktur für eine Benachrichtigung.
          * Felder:
              * `id: Uuid` (Intern generierte eindeutige ID für die Domäne)
              * `replaces_id: NotificationId` (ID der zu ersetzenden Benachrichtigung, 0 für neu)
              * `app_name: String` (Name der sendenden Anwendung)
              * `summary: String` (Kurze Zusammenfassung/Titel)
              * `body: String` (Langer Text/Nachricht)
              * `icon: String` (Pfad zum Icon oder Icon-Name)
              * `category: Option<NotificationCategory>` (Optionale Kategorie)
              * `urgency: Urgency` (Dringlichkeitsstufe)
              * `actions: Vec<Action>` (Verfügbare Benutzeraktionen)
              * `desktop_entry: Option<String>` (Desktop-Datei-Name der Anwendung)
              * `transient: bool` (Soll Benachrichtigung nicht in Historie gespeichert werden?)
              * `timestamp: chrono::DateTime<chrono::Utc>` (Zeitpunkt des Empfangs der Benachrichtigung)
              * `expire_timeout_ms: i32` (Anzeigedauer in ms, -1 für Standard, 0 für sofortiges Schließen)
              * `hints: HashMap<String, ConditionValue>` (Zusätzliche D-Bus Hints als Key-Value-Paare, verwenden `ConditionValue` für die Werte)
              * `mute: bool` (Interner Status, ob die Benachrichtigung stummgeschaltet wurde durch Regeln)
              * `silent: bool` (Interner Status, ob die Benachrichtigung unsichtbar gemacht wurde durch Regeln, z.B. nur LogOnly)
              * `sender_id: Uuid` (Eindeutige ID des Senders der Benachrichtigung, z.B. eine spezifische Instanz einer App)
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`, `Default`.
          * Implementiere `new()`-Funktion für einfache Instanziierung mit Pflichtfeldern.
          * Implementiere `display_icon()`-Methode, die den Icon-Pfad oder den Icon-Namen zurückgibt, damit die UI die richtige Anzeige wählen kann.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification/data_types.rs`
  * **Abhängigkeiten:**
      * **Extern:** `serde::{Serialize, Deserialize}`, `uuid::Uuid`, `chrono::{DateTime, Utc}`, `std::collections::HashMap`, `tracing` (für Warnungen bei `Urgency::from_u8`).
      * **Intern:** `crate::notification_rules::data_types::ConditionValue` (für `hints` Feld).
  * **Kommunikationsmuster:** Stellt die Datenstrukturen bereit, die von anderen Modulen (z.B. `dbus_interfaces`, `notification_rules`, `ui::notification_display`) verwendet werden, um Benachrichtigungen zu modellieren und auszutauschen.
  * **Erwartete Ergebnisse/Outputs:** Eine vollständige, robuste und standardkonforme Definition der Datenmodelle für Benachrichtigungen, die für die Verarbeitung durch die Domänenlogik und die Darstellung durch die UI-Schicht bereit sind.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Serialisierung und Deserialisierung aller Enums und Structs (insbesondere `Notification` und `Urgency`).
          * Testen der `Default`-Implementierungen.
          * Testen der `Urgency::from_u8` und `Urgency::as_u8` Konvertierungen, einschließlich ungültiger Werte.
          * Testen der `NotificationCategory` Konvertierungen.
          * Testen der `Notification::new()` Funktion.
          * Testen der `display_icon()` Logik.
          * Testen von `PartialEq` und `Eq` für alle Typen.

-----

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (34 von 100) widmet sich der Implementierung der Fehlerdefinitionen für das Benachrichtigungsmodul in `novade-domain/src/notification/errors.rs`. Eine präzise Fehlerbehandlung ist entscheidend für die Stabilität und Wartbarkeit des Systems.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 34/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.20.3. `novade-domain/src/notification/errors.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification/errors.rs`
* **Verantwortlichkeit:** Definiert ein konsolidiertes Fehler-Enum (`NotificationError`) für alle Operationen, die innerhalb des `notification`-Moduls der Domänenschicht auftreten können. Dieses Enum kapselt spezifische Fehlerquellen (z.B. Repositorium-Fehler, D-Bus-Konvertierungsfehler, Timeout-Fehler) und bietet eine einheitliche Schnittstelle zur Fehlerbehandlung und -propagation in den darüberliegenden Schichten. Die Nutzung von `thiserror` und `anyhow` (für Konversionen zu generischen Fehlertypen in höheren Schichten, falls benötigt) wird beibehalten, um eine robuste Fehlerkette sicherzustellen.
* **Kern-Aufgaben (Tasks):**
    1.  **`NotificationError` Enum definieren:**
        * Nutze `#[derive(thiserror::Error, Debug)]` für automatische Implementierung der `Error` und `Debug` Traits.
        * Varianten:
            * `RepositoryError(#[from] crate::notification::repository::errors::NotificationRepositoryError)`: Fehler, die von der Benachrichtigungshistorie-Persistenz stammen. `#[from]` ermöglicht automatische Konvertierung.
            * `RulesEngineError(#[from] crate::notification_rules::errors::NotificationRulesError)`: Fehler, die während der Regelverarbeitung auftreten.
            * `InvalidNotificationData(String)`: Für semantisch ungültige Benachrichtigungsdaten (z.B. fehlende Pflichtfelder, ungültige Werte, die nicht durch `serde` abgedeckt sind). Die `String` sollte eine detaillierte Fehlermeldung enthalten.
            * `NotificationNotFound { id: crate::notification::data_types::NotificationId }`: Wenn eine Benachrichtigung mit einer spezifischen ID nicht gefunden werden kann.
            * `Timeout`: Für Operationen, die ein definiertes Zeitlimit überschreiten (z.B. beim Warten auf eine Antwort von einem externen Dienst).
            * `ClientError(#[from] novade_core::error::ClientError)`: Generische Fehler, die von unterliegenden Diensten (z.B. `ConfigService`) gemeldet werden.
            * `Other(String)`: Ein Catch-All für unvorhergesehene oder nicht spezifisch handhabbare Fehler, die eine generische Fehlermeldung erfordern.
        * Implementiere `#[error("...")]` Attribute für benutzerfreundliche Fehlermeldungen für jede Variante.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification/errors.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::notification::repository::errors::NotificationRepositoryError`
        * `crate::notification_rules::errors::NotificationRulesError`
        * `crate::notification::data_types::NotificationId`
        * `novade_core::error::ClientError`
    * **Extern:** `thiserror::Error`, `tracing` (für interne Fehlerlogs, auch wenn der Fehler propagiert wird).
* **Kommunikationsmuster:**
    * Wird als `E` (Fehler-Typ) in `Result<T, E>` Signaturen aller öffentlichen Funktionen und Methoden des `notification`-Moduls verwendet.
    * Sollte von `notification_rules` und `notification_repository` Fehlertypen erhalten und in die eigene Variante konvertieren (`#[from]`).
    * Von dieser Fehlerdefinition können höhere Schichten (z.B. `dbus_interfaces`, `ui`) abhängen und sie gegebenenfalls weiter in ihre eigenen Fehler-Enums kapseln oder direkt behandeln.
* **Erwartete Ergebnisse/Outputs:** Ein klar strukturiertes und wartbares Fehler-Enum, das alle denkbaren Fehlerzustände im Benachrichtigungsmodul abdeckt und eine konsistente Fehlerbehandlung über die gesamte Domänenschicht ermöglicht.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der Instanziierung jeder Fehlervariante.
        * Testen der `#[from]`-Konvertierungen von `NotificationRepositoryError`, `NotificationRulesError` und `ClientError`.
        * Testen der `Display`-Implementierung (via `to_string()`) für jede Fehlervariante, um sicherzustellen, dass die Fehlermeldungen korrekt und informativ sind.
        * Testen der `source()`-Kette, um sicherzustellen, dass die Ursprungsfehler bei der Konvertierung beibehalten werden.

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (35 von 100) widmet sich der Implementierung des `novade-domain/src/notification/repository_iface.rs` Moduls. Dieses Modul definiert den Vertrag für die Persistenz von Benachrichtigungen, was für die Historienfunktion und das allgemeine Management von aktiven Benachrichtigungen unerlässlich ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 35/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.20.4. `novade-domain/src/notification/repository_iface.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification/repository_iface.rs`
* **Verantwortlichkeit:** Definiert den `NotificationRepository` Trait. Dieser Trait ist die abstrakte Schnittstelle für alle Operationen, die sich auf die Speicherung, den Abruf, die Aktualisierung und das Löschen von Benachrichtigungen beziehen. Durch die Abstraktion des Repositoriums wird die Domänenlogik von den spezifischen Implementierungsdetails der Datenhaltung (z.B. In-Memory, Dateisystem, Datenbank) entkoppelt.
* **Kern-Aufgaben (Tasks):**
    1.  **`NotificationRepository` Trait definieren:**
        * Nutze `#[async_trait]` da alle Repository-Operationen asynchron sein werden (Potenzial für I/O).
        * Methoden:
            * `add_notification(&self, notification: Notification) -> Result<(), NotificationRepositoryError>`: Fügt eine neue Benachrichtigung zum Repository hinzu. Erwartet, dass die `Notification.id` bereits gesetzt ist.
            * `get_notification(&self, id: NotificationId) -> Result<Option<Notification>, NotificationRepositoryError>`: Ruft eine Benachrichtigung anhand ihrer internen ID ab. Gibt `None` zurück, wenn nicht gefunden.
            * `update_notification(&self, notification: Notification) -> Result<(), NotificationRepositoryError>`: Aktualisiert eine bestehende Benachrichtigung. Die Benachrichtigung muss über ihre `id` identifizierbar sein. Gibt einen Fehler zurück, wenn die Benachrichtigung nicht existiert.
            * `remove_notification(&self, id: NotificationId) -> Result<(), NotificationRepositoryError>`: Entfernt eine Benachrichtigung anhand ihrer internen ID. Gibt einen Fehler zurück, wenn die Benachrichtigung nicht existiert.
            * `get_all_active_notifications(&self) -> Result<Vec<Notification>, NotificationRepositoryError>`: Ruft alle derzeit aktiven (nicht verworfenen/abgelaufenen) Benachrichtigungen ab.
            * `get_notification_history(&self, limit: Option<usize>) -> Result<Vec<Notification>, NotificationRepositoryError>`: Ruft eine Historie von Benachrichtigungen ab, optional begrenzt durch `limit`. Die Implementierung muss entscheiden, welche Kriterien für "Historie" gelten (z.B. alle Benachrichtigungen, auch abgelaufene/geschlossene, aber nicht transiente). Für den ersten Wurf: Alle nicht-transienten Benachrichtigungen, chronologisch absteigend sortiert (neueste zuerst).
            * `clear_notification_history(&self) -> Result<(), NotificationRepositoryError>`: Löscht die gesamte Benachrichtigungshistorie.
            * `get_notifications_by_app_name(&self, app_name: &str) -> Result<Vec<Notification>, NotificationRepositoryError>`: Ruft alle aktiven oder historischen Benachrichtigungen eines bestimmten App-Namens ab.
            * `count_active_notifications(&self) -> Result<usize, NotificationRepositoryError>`: Gibt die Anzahl der aktiven Benachrichtigungen zurück.
            * `notification_exists(&self, id: NotificationId) -> Result<bool, NotificationRepositoryError>`: Prüft, ob eine Benachrichtigung mit der gegebenen ID existiert.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification/repository_iface.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::notification::data_types::{Notification, NotificationId}`
        * `crate::notification::repository::errors::NotificationRepositoryError`
    * **Extern:** `async_trait::async_trait`.
* **Kommunikationsmuster:**
    * Dieser Trait wird von konkreten Repository-Implementierungen (z.B. `InMemoryNotificationRepository`, `FilesystemNotificationRepository`) implementiert.
    * Der `NotificationService` (und andere potenzielle Services) wird diesen Trait nutzen, um mit den Benachrichtigungsdaten zu interagieren, ohne die Details der Speicherung zu kennen.
* **Erwartete Ergebnisse/Outputs:** Eine klare, asynchrone Schnittstelle für den Datenzugriff auf Benachrichtigungen, die die Domänenlogik von der Persistenzschicht entkoppelt.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:** Keine direkten Tests für diesen Trait, da er nur eine Definition ist. Die Tests erfolgen für die konkreten Implementierungen (`InMemoryNotificationRepository`).
    * **Integration Tests:** Sicherstellen, dass die Implementierungen des Traits den Vertrag erfüllen.

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (36 von 100) widmet sich der Implementierung des `novade-domain/src/notification/repository/mod.rs` Moduls. Dieses Modul bündelt die verschiedenen Repository-Implementierungen und macht sie über eine öffentliche API zugänglich.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 36/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.20.5. `novade-domain/src/notification/repository/mod.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification/repository/mod.rs`
* **Verantwortlichkeit:** Definiert die öffentliche API des `repository`-Untermoduls innerhalb des `notification`-Moduls. Es dient als Aggregator und Re-Exporter für die konkreten Implementierungen des `NotificationRepository`-Traits sowie für die zugehörigen Fehlerdefinitionen. Dies stellt sicher, dass andere Module, die eine Repository-Implementierung benötigen, diese über einen einzigen, kohärenten Einstiegspunkt beziehen können.
* **Kern-Aufgaben (Tasks):**
    1.  **Public API Definition:** Re-exportiere die folgenden Komponenten, die die Schnittstelle dieses Moduls bilden:
        * `errors` (das `NotificationRepositoryError` Enum).
        * `in_memory` (die `InMemoryNotificationRepository` Struktur).
        * `repository_iface` (den `NotificationRepository` Trait, obwohl er eine Ebene höher im Haupt-`notification`-Modul definiert ist, kann er hier erneut re-exportiert werden, um die vollständige Kapselung der Repository-Belange zu gewährleisten).
    2.  **Modul-Strukturierung:** Sicherstellen, dass alle Re-Exporte korrekt sind und keine internen Implementierungsdetails unnötigerweise exponiert werden. Das `mod.rs` sollte minimal sein und hauptsächlich die Sichtbarkeit steuern.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification/repository/mod.rs`
* **Abhängigkeiten:**
    * **Intern:** `errors`, `in_memory`, `repository_iface` (innerhalb desselben `notification/repository` Pfades).
    * **Extern:** Keine direkten, da nur Re-Exporte stattfinden.
* **Kommunikationsmuster:** Stellt die Hauptschnittstelle für Repository-Implementierungen bereit. Module wie der `NotificationService` werden von hier aus die konkreten Repository-Implementierungen instanziieren und über den `NotificationRepository` Trait mit ihnen interagieren.
* **Erwartete Ergebnisse/Outputs:** Eine klar definierte und leicht nutzbare öffentliche API für die Benachrichtigungs-Repository-Implementierungen, die eine konsistente Interaktion über alle Schichten hinweg ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte sind. Die Tests erfolgen in den jeweiligen Submodulen (z.B. `in_memory.rs`, `errors.rs`).

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (37 von 100) widmet sich der Implementierung der Fehlerdefinitionen für das Benachrichtigungs-Repository in `novade-domain/src/notification/repository/errors.rs`. Eine präzise Fehlerbehandlung ist entscheidend für die Stabilität und Wartbarkeit des Systems.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 37/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.20.6. `novade-domain/src/notification/repository/errors.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification/repository/errors.rs`
* **Verantwortlichkeit:** Definiert ein spezifisches Fehler-Enum (`NotificationRepositoryError`) für alle Datenzugriffsoperationen, die im Kontext der Benachrichtigungs-Repositorys auftreten können. Dies stellt eine feingranulare Fehlerbehandlung auf der Persistenzschicht sicher und ermöglicht es der `NotificationService` (und anderen Konsumenten), präzise auf Probleme bei der Datenhaltung zu reagieren. Die Nutzung von `thiserror` ist obligatorisch.
* **Kern-Aufgaben (Tasks):**
    1.  **`NotificationRepositoryError` Enum definieren:**
        * Nutze `#[derive(thiserror::Error, Debug)]` für automatische Implementierung der `Error` und `Debug` Traits.
        * Varianten:
            * `NotFound { id: crate::notification::data_types::NotificationId }`: Wenn versucht wird, eine Benachrichtigung zu aktualisieren oder zu entfernen, die nicht existiert.
                * `#[error("Notification with ID '{id}' not found in repository.")]`
            * `AlreadyExists { id: crate::notification::data_types::NotificationId }`: Wenn versucht wird, eine Benachrichtigung mit einer bereits existierenden ID hinzuzufügen.
                * `#[error("Notification with ID '{id}' already exists in repository.")]`
            * `SerializationError(#[from] serde_json::Error)`: Fehler, die während der Serialisierung/Deserialisierung von Benachrichtigungsdaten auftreten (relevant für Dateisystem- oder DB-basierte Repositories).
                * `#[error("Failed to serialize/deserialize notification data: {0}")]`
            * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler, die beim Zugriff auf das Speichermedium auftreten können (z.B. Dateisystem-Fehler).
                * `#[error("I/O error during repository operation: {0}")]`
            * `LockAcquisitionFailed`: Wenn ein internes Lock (z.B. `RwLock` im `InMemoryNotificationRepository`) nicht erworben werden kann (unwahrscheinlich bei korrekter Nutzung, aber gut zur Absicherung).
                * `#[error("Failed to acquire internal lock for repository access.")]`
            * `Other(String)`: Ein allgemeiner Fehler für Fälle, die nicht spezifisch abgedeckt sind. Die `String` sollte eine aussagekräftige Beschreibung enthalten.
                * `#[error("An unexpected repository error occurred: {0}")]`
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification/repository/errors.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::notification::data_types::NotificationId`
    * **Extern:** `thiserror::Error`, `serde_json::Error`, `std::io::Error`.
* **Kommunikationsmuster:**
    * Dieses Error-Enum wird als `E` in `Result<T, E>` Signaturen aller Methoden des `NotificationRepository`-Traits und dessen Implementierungen verwendet.
    * Es wird von der `NotificationService` (und anderen Konsumenten) empfangen und dort in das übergeordnete `NotificationError` Enum gekapselt (`#[from]`).
* **Erwartete Ergebnisse/Outputs:** Ein klares, spezifisches Fehler-Enum für die Repository-Schicht, das die Fehlerbehandlung auf dieser Ebene detailliert und robust gestaltet.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der Instanziierung jeder Fehlervariante.
        * Testen der `#[from]`-Konvertierungen von `serde_json::Error` und `std::io::Error`.
        * Testen der `Display`-Implementierung (via `to_string()`) für jede Fehlervariante, um sicherzustellen, dass die Fehlermeldungen korrekt und informativ sind.
        * Testen der `source()`-Kette, um sicherzustellen, dass die Ursprungsfehler bei der Konvertierung beibehalten werden.

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (38 von 100) widmet sich der Implementierung des `novade-domain/src/notification/repository/in_memory.rs` Moduls. Dieses Modul stellt eine In-Memory-Implementierung des `NotificationRepository`-Traits bereit, die für Entwicklung, Tests und einfache Anwendungsfälle ideal ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 38/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.20.7. `novade-domain/src/notification/repository/in_memory.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification/repository/in_memory.rs`
* **Verantwortlichkeit:** Implementiert den `NotificationRepository`-Trait unter Verwendung eines In-Memory-Speichers. Dies bedeutet, dass alle Benachrichtigungen im Arbeitsspeicher des Programms gehalten werden. Diese Implementierung ist nicht persistent über Programmneustarts hinweg und wird primär für Entwicklungszwecke, Unit-Tests und Szenarien verwendet, in denen eine Historie nicht über Neustarts hinweg erhalten bleiben muss. Die Implementierung muss thread-sicher sein.
* **Kern-Aufgaben (Tasks):**
    1.  **`InMemoryNotificationRepository` Struct definieren:**
        * Felder:
            * `active_notifications: Arc<RwLock<HashMap<NotificationId, Notification>>>`: Speichert alle *aktiven* Benachrichtigungen, die derzeit angezeigt werden oder zur Verarbeitung anstehen. Ein `HashMap` ermöglicht schnellen Zugriff per ID. `RwLock` für thread-sicheren Lese-/Schreibzugriff. `Arc` für gemeinsame Besitzerschaft.
            * `history_notifications: Arc<RwLock<Vec<Notification>>>`: Speichert eine chronologische Historie der Benachrichtigungen. `Vec` für Einfachheit, sollte aber performant genug sein. Neue Benachrichtigungen werden am Ende hinzugefügt. `RwLock` und `Arc` für Thread-Sicherheit.
            * `next_notification_id: Arc<AtomicU32>`: Ein atomarer Zähler für die nächste zu vergebende interne `NotificationId`. Dies stellt sicher, dass jede neue Benachrichtigung eine eindeutige ID erhält, die nicht mit D-Bus `replaces_id` in Konflikt gerät. Initialisiert auf 1.
    2.  **Konstruktor `new()` implementieren:**
        * Initialisiert beide `HashMap` und `Vec` als leer.
        * Initialisiert `next_notification_id` mit 1.
    3.  **Implementierung des `NotificationRepository`-Traits für `InMemoryNotificationRepository`:**
        * **`add_notification(&self, mut notification: Notification) -> Result<(), NotificationRepositoryError>`:**
            * **ID-Vergabe:** Wenn `notification.id == 0`, weist der Compositor die ID zu. Wenn die ID vom D-Bus-Client kommt und `notification.replaces_id == 0`, generiere eine neue interne ID aus `next_notification_id.fetch_add(1, Ordering::SeqCst)`. Setze `notification.id = generated_id`.
            * **Ersetzen-Logik (`replaces_id`):** Wenn `notification.replaces_id != 0`:
                * Versuche, die Benachrichtigung mit `replaces_id` aus `active_notifications` zu finden.
                * Wenn gefunden: Aktualisiere die gefundene Benachrichtigung (überschreibe Felder der alten Benachrichtigung mit den entsprechenden Feldern der neuen Benachrichtigung). Dies sollte eine *teilweise* Aktualisierung sein, d.h. nur die Felder, die in der neuen Benachrichtigung gesetzt sind, überschreiben die alten. **Spezifikation:** Für D-Bus `Notify` ist es ein *vollständiges* Ersetzen, d.h. die neue Benachrichtigung ersetzt die alte vollständig. Die `replaces_id` wird dann zur neuen `id` der aktualisierten Benachrichtigung. Wenn die alte Benachrichtigung in `active_notifications` vorhanden ist, wird ihr Eintrag aktualisiert und ihre ID wird als `notification.id` für die neue Benachrichtigung verwendet.
                * Wenn nicht gefunden: Füge die neue Benachrichtigung als eine vollständig neue Benachrichtigung hinzu, mit einer neu generierten `id` (wenn `notification.id` 0 war) oder ihrer ursprünglichen `id` (wenn `notification.id` bereits ungleich 0 war, z.B. von einer internen Quelle).
            * **Neue Benachrichtigung (kein `replaces_id`):** Wenn `notification.replaces_id == 0`:
                * Wenn `notification.id == 0`: Generiere eine neue `NotificationId` mit `self.next_notification_id.fetch_add(1, Ordering::SeqCst)` und weise sie `notification.id` zu.
                * Wenn `notification.id != 0`: Prüfe, ob diese ID bereits in `active_notifications` existiert. Wenn ja, gib `NotificationRepositoryError::AlreadyExists` zurück. Andernfalls verwende die bereitgestellte ID.
                * Füge die `notification` in `active_notifications` ein.
            * **Historie:** Füge eine geklonte Version der finalen `notification` (nach möglicher ID-Generierung/Ersetzung) am Ende des `history_notifications` Vecs hinzu, es sei denn, `notification.transient` ist `true`.
            * Gib `Ok(())` zurück.
            * Behandle `RwLock` Poisoning (z.B. durch `unwrap().expect("Lock poisoned")` oder `map_err(|e| NotificationRepositoryError::LockAcquisitionFailed)`).
        * **`get_notification(&self, id: NotificationId) -> Result<Option<Notification>, NotificationRepositoryError>`:**
            * Greife auf `active_notifications` zu und versuche, die Benachrichtigung zu finden.
            * Gib einen Klon der Benachrichtigung zurück, wenn gefunden, sonst `None`.
        * **`update_notification(&self, notification: Notification) -> Result<(), NotificationRepositoryError>`:**
            * Greife auf `active_notifications` zu.
            * Wenn `notification.id` in `active_notifications` existiert, ersetze den Eintrag vollständig mit der neuen `notification`.
            * Andernfalls gib `NotificationRepositoryError::NotFound` zurück.
            * Wenn `notification.transient` `false` ist, aktualisiere die Benachrichtigung auch in `history_notifications` (finde sie anhand der ID und ersetze sie, oder füge sie hinzu, falls sie neu ist und historisiert werden soll). Das Aktualisieren in der Historie erfordert das Durchsuchen des Vecs, was für eine große Historie ineffizient sein kann; für In-Memory-Repo ist dies jedoch akzeptabel.
        * **`remove_notification(&self, id: NotificationId) -> Result<(), NotificationRepositoryError>`:**
            * Greife auf `active_notifications` zu und entferne den Eintrag mit der gegebenen `id`.
            * Wenn der Eintrag nicht existierte, gib `NotificationRepositoryError::NotFound` zurück.
            * Gib `Ok(())` zurück. Beachten: Benachrichtigungen werden aus `active_notifications` entfernt, aber nicht unbedingt aus `history_notifications`, es sei denn, `clear_notification_history` wird explizit aufgerufen.
        * **`get_all_active_notifications(&self) -> Result<Vec<Notification>, NotificationRepositoryError>`:**
            * Greife auf `active_notifications` zu.
            * Gib einen `Vec` mit Klonen aller Benachrichtigungen zurück.
        * **`get_notification_history(&self, limit: Option<usize>) -> Result<Vec<Notification>, NotificationRepositoryError>`:**
            * Greife auf `history_notifications` zu.
            * Erstelle einen geklonten `Vec`, sortiert in absteigender chronologischer Reihenfolge (`timestamp` neueste zuerst).
            * Wende das `limit` an, falls vorhanden (z.B. `vec.into_iter().rev().take(limit).collect()`).
        * **`clear_notification_history(&self) -> Result<(), NotificationRepositoryError>`:**
            * Leere den `history_notifications` Vec.
            * Gib `Ok(())` zurück.
        * **`get_notifications_by_app_name(&self, app_name: &str) -> Result<Vec<Notification>, NotificationRepositoryError>`:**
            * Durchsuche `active_notifications` und `history_notifications`.
            * Sammle alle Benachrichtigungen, deren `app_name` mit dem gegebenen `app_name` übereinstimmt (case-insensitive).
            * Gib einen `Vec` mit Klonen der gefundenen Benachrichtigungen zurück.
        * **`count_active_notifications(&self) -> Result<usize, NotificationRepositoryError>`:**
            * Greife auf `active_notifications` zu und gib die Länge zurück.
        * **`notification_exists(&self, id: NotificationId) -> Result<bool, NotificationRepositoryError>`:**
            * Greife auf `active_notifications` zu und prüfe, ob die ID als Schlüssel existiert.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification/repository/in_memory.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::notification::data_types::{Notification, NotificationId}`
        * `crate::notification::repository_iface::NotificationRepository`
        * `crate::notification::repository::errors::NotificationRepositoryError`
    * **Extern:** `async_trait::async_trait`, `std::collections::HashMap`, `std::sync::{Arc, RwLock}`, `std::sync::atomic::{AtomicU32, Ordering}`, `uuid::Uuid` (für interne ID-Generierung, aber nicht für `NotificationId` direkt), `tracing`.
* **Kommunikationsmuster:** Wird vom `NotificationService` instanziiert und verwendet, um Benachrichtigungen zu speichern und abzurufen.
* **Erwartete Ergebnisse/Outputs:** Eine voll funktionsfähige, thread-sichere In-Memory-Implementierung des Benachrichtigungs-Repositorys, die alle Anforderungen des `NotificationRepository`-Traits erfüllt.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * **Allgemeine Tests:**
            * Testen der `new()`-Funktion.
            * Testen der Thread-Sicherheit durch gleichzeitige Lese- und Schreibzugriffe.
        * **`add_notification` Tests:**
            * Hinzufügen einer neuen Benachrichtigung (ID 0), korrekte ID-Vergabe.
            * Hinzufügen einer neuen Benachrichtigung mit bereits vergebener ID (falls `notification.id != 0` und bereits existiert) -> `AlreadyExists` Fehler.
            * Hinzufügen einer transienten Benachrichtigung (nicht in Historie).
            * Hinzufügen einer nicht-transienten Benachrichtigung (in Historie).
            * `replaces_id` logik:
                * Benachrichtigung ersetzt vorhandene (`replaces_id` ungleich 0, alte ID existiert).
                * Benachrichtigung ersetzt nicht vorhandene (neue Benachrichtigung mit `replaces_id` ungleich 0, alte ID existiert nicht).
                * Benachrichtigung mit `replaces_id` ungleich 0, aber `notification.id` ist 0.
        * **`get_notification` Tests:**
            * Abrufen einer existierenden Benachrichtigung.
            * Abrufen einer nicht-existierenden Benachrichtigung (`None`).
        * **`update_notification` Tests:**
            * Aktualisieren einer existierenden Benachrichtigung.
            * Aktualisieren einer nicht-existierenden Benachrichtigung (`NotFound` Fehler).
            * Aktualisieren einer Benachrichtigung, die transient wird (sollte aus Historie entfernt werden, oder einfach nicht in Historie aktualisiert werden).
        * **`remove_notification` Tests:**
            * Entfernen einer existierenden Benachrichtigung.
            * Entfernen einer nicht-existierenden Benachrichtigung (`NotFound` Fehler).
        * **`get_all_active_notifications` Tests:**
            * Abrufen aller aktiven Benachrichtigungen (leeres, einzelnes, mehrere).
        * **`get_notification_history` Tests:**
            * Abrufen der Historie (leere, einzelne, mehrere).
            * Testen des `limit`-Parameters.
            * Sicherstellen der korrekten chronologischen Sortierung.
            * Stellen Sie sicher, dass transiente Benachrichtigungen nicht in der Historie landen.
        * **`clear_notification_history` Tests:**
            * Leeren der Historie.
        * **`get_notifications_by_app_name` Tests:**
            * Abrufen nach App-Namen (Case-Insensitivität testen).
        * **`count_active_notifications` Tests:**
            * Zählen aktiver Benachrichtigungen.
        * **`notification_exists` Tests:**
            * Prüfen auf existierende und nicht-existierende IDs.

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (39 von 100) widmet sich der Implementierung des `novade-domain/src/notification/service_iface.rs` Moduls. Dieses Modul definiert den Vertrag für den zentralen Benachrichtigungsdienst, der die Geschäftslogik für die Verarbeitung, Verwaltung und Verteilung von Benachrichtigungen kapselt.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 39/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.20.8. `novade-domain/src/notification/service_iface.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification/service_iface.rs`
* **Verantwortlichkeit:** Definiert den `NotificationService` Trait. Dieser Trait ist die primäre Schnittstelle für alle Komponenten innerhalb und außerhalb der Domänenschicht, die mit dem Benachrichtigungssystem interagieren möchten. Er abstrahiert die zugrunde liegende Logik der Benachrichtigungsverarbeitung (Regel-Engine, Persistenz, Event-Verteilung) und bietet eine konsistente API für das Management von Benachrichtigungen. Die Methoden sind asynchron, um nicht-blockierende Operationen zu gewährleisten, insbesondere wenn I/O-Operationen (z.B. Persistenz, D-Bus-Kommunikation) beteiligt sind.
* **Kern-Aufgaben (Tasks):**
    1.  **`NotificationService` Trait definieren:**
        * Nutze `#[async_trait]` für alle Methoden.
        * Alle Methoden geben `Result<(), NotificationError>` oder `Result<T, NotificationError>` zurück, um eine konsistente Fehlerbehandlung zu gewährleisten.
        * Methoden:
            * `handle_new_notification(&self, app_name: String, replaces_id: NotificationId, app_icon: String, summary: String, body: String, actions: Vec<(String, String)>, hints: HashMap<String, ConditionValue>, expire_timeout: i32) -> Result<NotificationId, NotificationError>`:
                * Empfängt eine neue Benachrichtigung (typischerweise vom D-Bus-Server).
                * Führt Validierung der Eingabedaten durch.
                * Verwendet die `NotificationRulesEngine`, um die Benachrichtigung zu verarbeiten (Filterung, Stummschaltung, Aktionen, etc.).
                * Generiert eine neue `NotificationId` oder verwendet `replaces_id` für das Ersetzen.
                * Speichert die verarbeitete Benachrichtigung im `NotificationRepository`.
                * Sendet ein `NotificationEvent::NewNotification` über den Event-Bus.
                * Startet bei Bedarf einen Timer für `expire_timeout_ms` für nicht-transiente Benachrichtigungen.
                * Gibt die finale `NotificationId` der verarbeiteten Benachrichtigung zurück.
                * **Fehlerbehandlung:** `NotificationError::InvalidNotificationData` bei ungültigen Eingaben, `NotificationError::RulesEngineError`, `NotificationError::RepositoryError`.
                * **Parameter-Mapping:**
                    * `app_name`: Direkte Übernahme.
                    * `replaces_id`: Direkte Übernahme.
                    * `app_icon`: Direkte Übernahme.
                    * `summary`: Direkte Übernahme.
                    * `body`: Direkte Übernahme.
                    * `actions`: Konvertierung von `Vec<(String, String)>` zu `Vec<Action>`.
                    * `hints`: Direkte Übernahme als `HashMap<String, ConditionValue>`.
                    * `expire_timeout`: Direkte Übernahme.
            * `close_notification(&self, id: NotificationId, reason: CloseReason) -> Result<(), NotificationError>`:
                * Schließt eine Benachrichtigung mit der gegebenen `id` aufgrund eines bestimmten Grundes.
                * Entfernt die Benachrichtigung aus dem `NotificationRepository` (aus den *aktiven* Benachrichtigungen, nicht aus der Historie, wenn nicht transient).
                * Sendet ein `NotificationEvent::NotificationClosed`.
                * **Fehlerbehandlung:** `NotificationError::NotificationNotFound` wenn Benachrichtigung nicht aktiv ist, `NotificationError::RepositoryError`.
            * `invoke_action(&self, id: NotificationId, action_key: String) -> Result<(), NotificationError>`:
                * Löst eine Aktion für eine Benachrichtigung aus.
                * Überprüft, ob die Aktion für die Benachrichtigung gültig ist.
                * Sendet ein `NotificationEvent::ActionInvoked`.
                * **Fehlerbehandlung:** `NotificationError::NotificationNotFound`, `NotificationError::InvalidNotificationData` (für unbekannten Action Key).
            * `get_notification_by_id(&self, id: NotificationId) -> Result<Option<Notification>, NotificationError>`:
                * Ruft eine einzelne Benachrichtigung aus dem Repository ab.
            * `get_all_active_notifications(&self) -> Result<Vec<Notification>, NotificationError>`:
                * Ruft alle derzeit aktiven Benachrichtigungen ab.
            * `get_notification_history(&self, limit: Option<usize>) -> Result<Vec<Notification>, NotificationError>`:
                * Ruft die Benachrichtigungshistorie ab.
            * `clear_history(&self) -> Result<(), NotificationError>`:
                * Löscht die gesamte Benachrichtigungshistorie.
            * `get_notification_event_receiver(&self) -> tokio::sync::broadcast::Receiver<NotificationEvent>`:
                * Gibt einen `Receiver` für Benachrichtigungsereignisse zurück. Dies ist entscheidend für die reaktive UI und andere Systemkomponenten.
            * `mute_notifications_by_app(&self, app_name: &str, mute: bool) -> Result<(), NotificationError>`:
                * Stummschalten/Entstummschalten aller Benachrichtigungen einer spezifischen Anwendung. Dies könnte eine temporäre Regeländerung im `NotificationRulesEngine` auslösen oder eine interne Markierung setzen.
                * Dies muss *nicht* sofort alle aktiven Benachrichtigungen aktualisieren, sondern nur zukünftige. Aktive Benachrichtigungen können durch die UI selbst verwaltet werden oder durch ein `NotificationEvent::NotificationUpdated` mit dem neuen Mute-Status. **Entscheidung:** Für den ersten Wurf wird dies die Regel-Engine beeinflussen, die zukünftige Benachrichtigungen verarbeitet. Für bereits existierende Benachrichtigungen muss die UI auf den `NotificationUpdated` Event reagieren, der vom Service gesendet wird, nachdem eine Regel angewandt wurde, oder sie direkt aktualisieren, wenn der Mute-Status global geändert wird.
            * `silent_notifications_by_app(&self, app_name: &str, silent: bool) -> Result<(), NotificationError>`:
                * Ähnlich wie `mute_notifications_by_app`, aber für die "Silent"-Eigenschaft (nicht anzeigen, nur loggen).
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification/service_iface.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::notification::data_types::{Notification, NotificationId}`
        * `crate::notification::errors::NotificationError`
        * `crate::notification_rules::data_types::ConditionValue`
        * `crate::notification_events::NotificationEvent` (wird in einem späteren Schritt definiert, aber hier bereits als Typ referenziert).
        * `crate::notification_events::CloseReason` (wird in einem späteren Schritt definiert).
    * **Extern:** `async_trait::async_trait`, `std::collections::HashMap`, `tokio::sync::broadcast::Receiver`.
* **Kommunikationsmuster:**
    * Wird von der Systemschicht (`dbus_interfaces::notifications_server`) verwendet, um neue Benachrichtigungen zu empfangen und Aktionen auszulösen.
    * Wird von der UI-Schicht verwendet, um den Status von Benachrichtigungen abzufragen, Historien abzurufen und Benachrichtigungen zu schließen oder Aktionen auszulösen.
    * Stellt einen Event-Receiver bereit, über den Änderungen im Benachrichtigungsstatus (neu, geschlossen, aktualisiert, Aktion ausgelöst) an interessierte Parteien (insbesondere die UI) gesendet werden.
* **Erwartete Ergebnisse/Outputs:** Eine klare, vollständige und asynchrone Schnittstelle für den Benachrichtigungsdienst, die alle notwendigen Operationen zur Verwaltung von Benachrichtigungen bereitstellt und die Business-Logik von der Repositoriums- und Event-Implementierung abstrahiert.
* **Teststrategie (Modul-spezifisch):** Keine direkten Tests für diesen Trait, da er nur eine Definition ist. Die Tests erfolgen für die konkrete Implementierung (`DefaultNotificationService`).

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (40 von 100) widmet sich der Implementierung der Ereignisdefinitionen für das Benachrichtigungsmodul in `novade-domain/src/notification/events.rs`. Die Nutzung eines ereignisgesteuerten Ansatzes ist entscheidend für die Entkopplung und Reaktivität der UI und anderer Systemkomponenten.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 40/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.20.9. `novade-domain/src/notification/events.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification/events.rs`
  * **Verantwortlichkeit:** Definiert die verschiedenen Arten von Ereignissen (`NotificationEvent`) und einen Enum für die Gründe zum Schließen einer Benachrichtigung (`CloseReason`), die vom `NotificationService` erzeugt und über einen `tokio::sync::broadcast::Sender` verteilt werden. Diese Ereignisse ermöglichen es anderen Komponenten (insbesondere der UI-Schicht), reaktiv auf Änderungen im Benachrichtigungsstatus zu reagieren, ohne direkte Abhängigkeiten zum Dienst zu haben.
  * **Kern-Aufgaben (Tasks):**
    1.  **`CloseReason` Enum definieren:**
          * Repräsentiert die möglichen Gründe, warum eine Benachrichtigung geschlossen wurde, gemäß Freedesktop.org Notification Specification.
          * Varianten:
              * `Dismissed (1)`: Die Benachrichtigung wurde vom Benutzer geschlossen.
              * `Timeout (2)`: Die Benachrichtigung ist abgelaufen.
              * `ClosedByCall (3)`: Die Benachrichtigung wurde durch einen expliziten API-Aufruf geschlossen (z.B. `CloseNotification` D-Bus-Methode).
              * `Undefined (0)`: Undefinierter Grund (nicht empfohlen, aber für Konformität mit 0-Wert der Spec).
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Copy`, `Debug`, `Serialize`, `Deserialize`, `Default`.
          * Implementiere `From<u32>` für Konvertierung von D-Bus-Werten.
          * Implementiere `as_u32(&self) -> u32` Methode.
          * Implementiere `Display` Trait für einfache String-Repräsentation.
        <!-- end list -->
        ```rust
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        #[repr(u32)] // Ensures enum directly maps to u32 for D-Bus compatibility
        pub enum CloseReason {
            Undefined = 0,
            Dismissed = 1,
            Timeout = 2,
            ClosedByCall = 3,
            // Additional custom reasons could be added here if needed,
            // starting from value 4 according to spec.
        }

        impl Default for CloseReason {
            fn default() -> Self {
                CloseReason::Undefined
            }
        }

        impl From<u32> for CloseReason {
            fn from(value: u32) -> Self {
                match value {
                    1 => CloseReason::Dismissed,
                    2 => CloseReason::Timeout,
                    3 => CloseReason::ClosedByCall,
                    _ => {
                        tracing::warn!("Received unknown close reason: {}. Defaulting to Undefined.", value);
                        CloseReason::Undefined
                    }
                }
            }
        }

        impl CloseReason {
            pub fn as_u32(&self) -> u32 {
                *self as u32
            }
        }

        impl std::fmt::Display for CloseReason {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "{}", match self {
                    CloseReason::Undefined => "Undefined",
                    CloseReason::Dismissed => "Dismissed by user",
                    CloseReason::Timeout => "Timed out",
                    CloseReason::ClosedByCall => "Closed by API call",
                })
            }
        }
        ```
    2.  **`NotificationEvent` Enum definieren:**
          * Kapselt alle Arten von Ereignissen, die vom `NotificationService` gesendet werden können.
          * Varianten:
              * `NewNotification(Notification)`: Eine neue Benachrichtigung wurde hinzugefügt und verarbeitet.
              * `NotificationUpdated(Notification)`: Eine bestehende Benachrichtigung wurde aktualisiert (z.B. durch `replaces_id`).
              * `NotificationClosed(NotificationId, CloseReason)`: Eine Benachrichtigung wurde geschlossen.
              * `ActionInvoked(NotificationId, String)`: Eine Aktion einer Benachrichtigung wurde vom Benutzer ausgelöst (zweiter String ist der `action_key`).
              * `HistoryCleared`: Die gesamte Benachrichtigungshistorie wurde gelöscht.
              * `RulesReloaded`: Die Benachrichtigungsregeln wurden neu geladen.
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`. (Beachte: `Hash` für `Notification` und `CloseReason` ist notwendig, um `NotificationEvent` `Hash` zu implementieren. `Clone` ist wichtig für `tokio::sync::broadcast`).
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification/events.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notification::data_types::{Notification, NotificationId}`
      * **Extern:** `serde::{Serialize, Deserialize}`, `tracing` (für Warnungen bei `CloseReason::from_u32`).
  * **Kommunikationsmuster:**
      * Die `NotificationService`-Implementierung (z.B. `DefaultNotificationService`) wird `tokio::sync::broadcast::Sender<NotificationEvent>` verwenden, um diese Ereignisse zu publizieren.
      * Konsumenten (z.B. die UI-Schicht oder andere Systemkomponenten) werden `tokio::sync::broadcast::Receiver<NotificationEvent>` abonnieren, um auf diese Ereignisse zu reagieren.
  * **Erwartete Ergebnisse/Outputs:** Eine robuste und erweiterbare Definition von Benachrichtigungsereignissen und -schließgründen, die eine effiziente und entkoppelte Kommunikation im NovaDE-System ermöglicht.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Serialisierung und Deserialisierung beider Enums (`CloseReason`, `NotificationEvent`).
          * Testen der `Default`-Implementierungen für `CloseReason`.
          * Testen der `CloseReason::from_u32` und `CloseReason::as_u32` Konvertierungen, einschließlich ungültiger Werte.
          * Testen der `Display`-Implementierung für `CloseReason`.
          * Testen von `PartialEq` und `Eq` für beide Typen.

-----

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (41 von 100) widmet sich der Implementierung des `novade-domain/src/notification/service.rs` Moduls. Dies ist die konkrete Implementierung des `NotificationService`-Traits und bildet das Herzstück der Benachrichtigungsverarbeitung in der Domänenschicht.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 41/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.20.10. `novade-domain/src/notification/service.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification/service.rs`
* **Verantwortlichkeit:** Implementiert den `NotificationService`-Trait und enthält die gesamte Geschäftslogik für die Verwaltung, Verarbeitung und Verteilung von Benachrichtigungen. Es agiert als Koordinator zwischen dem `NotificationRepository`, der `NotificationRulesEngine`, dem `GlobalSettingsService` und dem internen Event-Bus. Es ist verantwortlich für die Einhaltung der Freedesktop.org Notification Specification und die Integration von NovaDE-spezifischen Features wie Regeln und Historie.
* **Kern-Aufgaben (Tasks):**
    1.  **`DefaultNotificationService` Struct definieren:**
        * Felder:
            * `repository: Arc<dyn NotificationRepository + Send + Sync>`: Eine Thread-sichere Referenz auf die Repository-Implementierung (z.B. `InMemoryNotificationRepository`). `Arc` für gemeinsame Besitzerschaft, `dyn` für Trait-Objekt, `Send + Sync` für Thread-Sicherheit.
            * `rules_engine: Arc<dyn NotificationRulesEngine + Send + Sync>`: Referenz auf die Regel-Engine.
            * `settings_service: Arc<dyn GlobalSettingsService + Send + Sync>`: Referenz auf den globalen Einstellungsdienst, um z.B. Standard-Timeouts abzufragen.
            * `event_tx: tokio::sync::broadcast::Sender<NotificationEvent>`: Sender für den Event-Bus, über den Benachrichtigungsereignisse verteilt werden.
            * `notification_timeout_handles: Arc<RwLock<HashMap<NotificationId, tokio::task::JoinHandle<()>>>>`: Ein `HashMap` zur Speicherung von `JoinHandle`s für die Timeout-Tasks jeder aktiven Benachrichtigung. Wenn ein Timeout ausgelöst wird, wird die Benachrichtigung geschlossen. `RwLock` für Thread-sicherheit.
            * `next_internal_id: Arc<AtomicU32>`: Ein atomarer Zähler, der zur Zuweisung einer internen `NotificationId` verwendet wird, wenn eine neue Benachrichtigung mit `replaces_id=0` und `id=0` ankommt. Dies muss *unabhängig* von der `replaces_id` oder der initialen `id` der `Notification` selbst sein, um Kollisionen zu vermeiden. Die `replaces_id` wird *nicht* als interne ID verwendet, sondern nur zur Referenzierung der zu ersetzenden Benachrichtigung. Die interne ID der `Notification` wird im Repository verwaltet. Dieser Zähler ist primär dafür da, dem D-Bus-Client eine ID zurückzugeben, die er für `replaces_id` verwenden kann. **Korrektur aus Spezifikation:** Der `NotificationId` in `data_types.rs` ist bereits `u32`. Die `repository` ist verantwortlich für die Vergabe und Verwaltung der `NotificationId`. Der `service` sollte sich hier auf das Repository verlassen. Der `next_internal_id` Zähler ist somit nicht im Service, sondern im Repository (wie in `in_memory.rs` spezifiziert). Der Service übernimmt die vom Repository vergebene ID.
    2.  **Konstruktor `new()` implementieren:**
        * Akzeptiert `repository`, `rules_engine`, `settings_service` als `Arc<dyn ...>`.
        * Initialisiert `event_tx` mittels `tokio::sync::broadcast::channel(100)` (oder passender Kapazität).
        * Initialisiert `notification_timeout_handles` als leere HashMap.
    3.  **Implementierung des `NotificationService`-Traits für `DefaultNotificationService`:**

        * **`handle_new_notification(&self, ...)`**
            * **Parameter Validierung:**
                * Prüfen, ob `summary` leer ist. Wenn ja, `NotificationError::InvalidNotificationData("Summary cannot be empty.".to_string())`.
                * Andere grundlegende Validierungen (z.B. Längenbeschränkungen, falls erforderlich).
            * **Benachrichtigungs-Instanziierung:**
                * Erstelle ein `Notification`-Objekt aus den Eingabeparametern.
                * `timestamp` auf `chrono::Utc::now()` setzen.
                * `id` und `sender_id` werden vom Repository vergeben. Setze `id` zunächst auf 0, damit das Repository die ID vergeben kann.
                * `replaces_id` auf den übergebenen Wert setzen.
                * `mute` und `silent` initial auf `false` setzen.
            * **Regel-Engine Anwendung:**
                * Rufe `self.rules_engine.process_notification(&mut notification).await?` auf. Die Regel-Engine kann die `Notification` in-place modifizieren (z.B. `mute`, `silent` setzen).
            * **Repository-Interaktion:**
                * Rufe `self.repository.add_notification(notification.clone()).await?` auf.
                * **Wichtiger Punkt:** Das Repository ist für die Vergabe der `NotificationId` und die Handhabung von `replaces_id` zuständig. Die vom Repository vergebene/bestätigte `NotificationId` muss *hier* abgerufen und für nachfolgende Schritte (Events, Timer) verwendet werden. Die `add_notification` Methode des Repositories sollte die finale `Notification` zurückgeben, oder zumindest die finale `NotificationId`. **Anpassung:** `repository.add_notification` gibt `Result<NotificationId, NotificationRepositoryError>` zurück. Die `notification` im Service muss dann mit dieser neuen ID aktualisiert werden.
                * `let final_id = self.repository.add_notification(notification.clone()).await?;`
                * `notification.id = final_id;`
            * **Timeout-Management:**
                * Wenn `notification.transient` `false` ist und `notification.expire_timeout_ms` `> 0` ist:
                    * Hole den Timeout-Wert: Wenn `notification.expire_timeout_ms == -1`, verwende `self.settings_service.get_notification_default_timeout_ms().await?`.
                    * Starte eine `tokio::spawn` Task, die nach der gegebenen Dauer `self.close_notification(final_id, CloseReason::Timeout).await` aufruft.
                    * Speichere das `JoinHandle` der Task in `self.notification_timeout_handles` unter `final_id`.
                    * **Achtung:** Wenn `close_notification` aufgerufen wird (manuell oder durch Timeout), muss das entsprechende `JoinHandle` aus der Map entfernt werden.
            * **Event-Broadcasting:**
                * Wenn `notification.replaces_id == 0`: Sende `NotificationEvent::NewNotification(notification.clone())`.
                * Wenn `notification.replaces_id != 0`: Sende `NotificationEvent::NotificationUpdated(notification.clone())`.
            * Rückgabe der `final_id`.

        * **`close_notification(&self, id: NotificationId, reason: CloseReason) -> Result<(), NotificationError>`**
            * Rufe `self.repository.remove_notification(id).await?` auf, um sie aus den *aktiven* Benachrichtigungen zu entfernen.
            * Wenn ein Timeout-Handle für diese `id` existiert, breche die `tokio::task::JoinHandle` ab und entferne es aus `notification_timeout_handles`.
            * Sende `NotificationEvent::NotificationClosed(id, reason)`.
            * **Fehlerbehandlung:** Wenn `remove_notification` `NotFound` zurückgibt, propagiere diesen Fehler.

        * **`invoke_action(&self, id: NotificationId, action_key: String) -> Result<(), NotificationError>`**
            * Rufe `self.repository.get_notification(id).await?` auf.
            * Wenn `None` zurückkommt, `NotificationError::NotificationNotFound`.
            * Überprüfe, ob `action_key` in `notification.actions` enthalten ist. Wenn nicht, `NotificationError::InvalidNotificationData("Action key not found".to_string())`.
            * Sende `NotificationEvent::ActionInvoked(id, action_key)`.
            * Schließe die Benachrichtigung automatisch, wenn die Aktion aufgerufen wird, da die D-Bus-Spezifikation dies impliziert. Rufe `self.close_notification(id, CloseReason::Dismissed).await?` auf.

        * **`get_notification_by_id(&self, id: NotificationId) -> Result<Option<Notification>, NotificationError>`**
            * Delegiert an `self.repository.get_notification(id).await?`.

        * **`get_all_active_notifications(&self) -> Result<Vec<Notification>, NotificationError>`**
            * Delegiert an `self.repository.get_all_active_notifications().await?`.

        * **`get_notification_history(&self, limit: Option<usize>) -> Result<Vec<Notification>, NotificationError>`**
            * Delegiert an `self.repository.get_notification_history(limit).await?`.

        * **`clear_history(&self) -> Result<(), NotificationError>`**
            * Delegiert an `self.repository.clear_notification_history().await?`.
            * Sende `NotificationEvent::HistoryCleared`.

        * **`get_notification_event_receiver(&self) -> tokio::sync::broadcast::Receiver<NotificationEvent>`**
            * Rufe `self.event_tx.subscribe()` auf und gebe den `Receiver` zurück.

        * **`mute_notifications_by_app(&self, app_name: &str, mute: bool) -> Result<(), NotificationError>`**
            * Rufe `self.rules_engine.set_app_mute_state(app_name.to_string(), mute).await?` auf.
            * **Wichtiger Hinweis:** Diese Änderung der Regel betrifft nur zukünftige Benachrichtigungen, die durch die Engine laufen. Für bereits angezeigte Benachrichtigungen müsste der `NotificationService` sie aktualisieren und einen `NotificationUpdated`-Event senden, damit die UI sie neu rendern kann.
            * **Entscheidung:** Der Service muss alle *aktiven* Benachrichtigungen dieser App-Name aktualisieren und für jede einen `NotificationUpdated` Event senden.
                * Hole alle aktiven Benachrichtigungen mit `get_all_active_notifications()`.
                * Filtriere nach `app_name`.
                * Iteriere über die gefilterten Benachrichtigungen:
                    * Setze `notification.mute = mute`.
                    * Rufe `self.repository.update_notification(notification.clone()).await?` auf.
                    * Sende `NotificationEvent::NotificationUpdated(notification)`.

        * **`silent_notifications_by_app(&self, app_name: &str, silent: bool) -> Result<(), NotificationError>`**
            * Analoge Implementierung zu `mute_notifications_by_app`, aber für den `silent`-Status.
            * Rufe `self.rules_engine.set_app_silent_state(app_name.to_string(), silent).await?` auf.
            * Aktualisiere und sende `NotificationUpdated` für aktive Benachrichtigungen dieser App.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification/service.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::notification::data_types::{Notification, NotificationId}`
        * `crate::notification::errors::NotificationError`
        * `crate::notification::repository_iface::NotificationRepository`
        * `crate::notification_rules::engine::NotificationRulesEngine`
        * `crate::global_settings::service_iface::GlobalSettingsService`
        * `crate::notification::events::{NotificationEvent, CloseReason}`
    * **Extern:** `async_trait::async_trait`, `tokio`, `tokio::sync::broadcast`, `tokio::task::JoinHandle`, `std::sync::{Arc, RwLock}`, `std::collections::HashMap`, `chrono::{DateTime, Utc}`, `tracing`.
* **Kommunikationsmuster:**
    * Empfängt Aufrufe von D-Bus-Handlern (Systemschicht) und UI-Komponenten.
    * Interagiert mit `NotificationRepository` für Persistenzoperationen.
    * Interagiert mit `NotificationRulesEngine` für Regelverarbeitung.
    * Interagiert mit `GlobalSettingsService` für Konfigurationswerte.
    * Sendet Ereignisse an alle Abonnenten über `tokio::sync::broadcast`.
* **Erwartete Ergebnisse/Outputs:** Eine robuste und voll funktionsfähige Implementierung des Benachrichtigungsdienstes, die alle Anforderungen an Benachrichtigungsmanagement, Regelanwendung und Event-Verteilung erfüllt.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests (mit Mocks):**
        * Mocking von `NotificationRepository`, `NotificationRulesEngine`, `GlobalSettingsService`.
        * Testen von `handle_new_notification`:
            * Erfolgreiches Hinzufügen einer neuen Benachrichtigung (ID 0).
            * Erfolgreiches Ersetzen einer Benachrichtigung (`replaces_id`).
            * Validierungsfehler (z.B. leeres Summary).
            * Fehlerpropagaion von Repository/RulesEngine.
            * Korrekte Event-Generierung (`NewNotification`, `NotificationUpdated`).
            * Timeout-Handling (Testen, ob Timer gestartet wird und bei Ablauf `close_notification` aufruft).
            * Transient-Handling (nicht in Historie/kein Timeout).
        * Testen von `close_notification`:
            * Erfolgreiches Schließen einer Benachrichtigung.
            * Schließen einer nicht-existierenden Benachrichtigung.
            * Korrektes Abbrechen des Timeout-Handles.
            * Korrekte Event-Generierung (`NotificationClosed`).
        * Testen von `invoke_action`:
            * Erfolgreiches Auslösen einer gültigen Aktion.
            * Auslösen einer ungültigen Aktion (`InvalidNotificationData`).
            * Korrekte Event-Generierung (`ActionInvoked`).
            * Automatisches Schließen nach Aktion.
        * Testen der Delegationsmethoden (`get_notification_by_id`, `get_all_active_notifications`, `get_notification_history`, `clear_history`).
        * Testen von `mute_notifications_by_app` und `silent_notifications_by_app`:
            * Sicherstellen, dass die Regel-Engine aktualisiert wird.
            * Sicherstellen, dass aktive Benachrichtigungen aktualisiert und `NotificationUpdated`-Events gesendet werden.
        * Testen des Event-Receivers (`get_notification_event_receiver`): Senden von Events und Prüfen, ob der Receiver sie empfängt.
    * **Integration Tests:**
        * Zusammenspiel mit einer echten `InMemoryNotificationRepository` und `DefaultNotificationRulesEngine`.
        * Szenarien: Mehrere Benachrichtigungen, Kette von Ersetzungen, Mix aus transienten/nicht-transienten, Timeout-Auslösung.
        * Überprüfen, ob die Events korrekt empfangen werden.

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (42 von 100) widmet sich der Initialisierung des `novade-domain/src/notification_rules/mod.rs` Moduls. Dieses Modul ist für die Definition und Verarbeitung von benutzerdefinierten Benachrichtigungsregeln verantwortlich.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 42/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.21. `novade-domain/src/notification_rules` Verzeichnis

Dieses Verzeichnis enthält die Logik und Infrastruktur für das Management und die Anwendung von Benachrichtigungsregeln. Diese Regeln ermöglichen es Benutzern, das Verhalten von Benachrichtigungen basierend auf verschiedenen Kriterien anzupassen (z.B. Benachrichtigungen einer bestimmten App stummschalten, Dringlichkeit ändern, Aktionen hinzufügen).

#### 3.21.1. `novade-domain/src/notification_rules/mod.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/mod.rs`
* **Verantwortlichkeit:** Definiert die öffentliche API des `notification_rules`-Moduls der Domänenschicht. Es re-exportiert alle wichtigen Typen, Traits, Enums und Strukturen, die von anderen Teilen der Domänenschicht (z.B. `notification` Service) oder von höheren Schichten (z.B. der UI-Schicht zur Anzeige und Bearbeitung von Regeln) benötigt werden, um Benachrichtigungsregeln zu definieren, anzuwenden oder zu verwalten.
* **Kern-Aufgaben (Tasks):**
    1.  **Public API Definition:** Re-exportiere die folgenden Komponenten, die die Schnittstelle dieses Moduls bilden:
        * `data_types` (alle relevanten Typen wie `ConditionValue`, `Operator`, `Field`, `SimpleRuleCondition`, `RuleCondition`, `RuleAction`, `NotificationRule`, `NotificationRuleSet`).
        * `errors` (das `NotificationRulesError` Enum).
        * `persistence_iface` (den `NotificationRulesProvider` Trait).
        * `persistence` (die konkrete `FilesystemNotificationRulesProvider` Implementierung).
        * `engine_iface` (den `NotificationRulesEngine` Trait).
        * `engine` (die konkrete `DefaultNotificationRulesEngine` Implementierung).
    2.  **Modul-Strukturierung:** Sicherstellen, dass alle Re-Exporte korrekt sind und keine internen Implementierungsdetails unnötigerweise exponiert werden.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification_rules/mod.rs`
* **Abhängigkeiten:**
    * **Intern:** `data_types`, `errors`, `persistence_iface`, `persistence`, `engine_iface`, `engine` (innerhalb desselben `notification_rules` Moduls).
    * **Extern:** Keine direkten, da nur Re-Exporte stattfinden.
* **Kommunikationsmuster:** Stellt die Hauptschnittstelle des `notification_rules`-Moduls zur Verfügung. Es ist der primäre Punkt, über den der `NotificationService` die Regel-Engine instanziiert und nutzt, und die UI-Schicht auf Regeldefinitionen zugreift oder Regeln verwaltet.
* **Erwartete Ergebnisse/Outputs:** Eine klar definierte und leicht nutzbare öffentliche API für die Benachrichtigungsregeln innerhalb der Domänenschicht, die konsistente Interaktionen über alle Schichten hinweg ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte sind. Die Tests erfolgen in den jeweiligen Submodulen.

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (43 von 100) widmet sich der Implementierung der grundlegenden Datentypen für Benachrichtigungsregeln in `novade-domain/src/notification_rules/data_types.rs`. Diese Strukturen sind das Fundament für die Definition und Verarbeitung von benutzerdefinierten Regeln.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 43/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.21.2. `novade-domain/src/notification_rules/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/data_types.rs`
  * **Verantwortlichkeit:** Definiert alle notwendigen Datenstrukturen für die Repräsentation von Benachrichtigungsregeln, deren Bedingungen und Aktionen. Diese Typen müssen robust, serialisierbar (für Persistenz) und leicht von der `NotificationRulesEngine` zu verarbeiten sein. Sie bilden die Schnittstelle für die UI zur Anzeige und Bearbeitung von Regeln.
  * **Kern-Aufgaben (Tasks):**
    1.  **`ConditionValue` Enum definieren:**
          * Repräsentiert die verschiedenen Typen von Werten, die in Regelbedingungen verwendet werden können. Dies ist entscheidend, um flexible Vergleiche zu ermöglichen.
          * Varianten:
              * `String(String)`
              * `Integer(i64)`
              * `Boolean(bool)`
              * `Float(f64)`
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`, `Display`.
          * Implementiere `From` Traits für `String`, `i64`, `bool`, `f64` zur einfachen Konvertierung.
        <!-- end list -->
        ```rust
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ConditionValue {
            String(String),
            Integer(i64),
            Boolean(bool),
            Float(f64),
        }

        impl From<String> for ConditionValue {
            fn from(s: String) -> Self { ConditionValue::String(s) }
        }
        impl From<&str> for ConditionValue {
            fn from(s: &str) -> Self { ConditionValue::String(s.to_string()) }
        }
        impl From<i64> for ConditionValue {
            fn from(i: i64) -> Self { ConditionValue::Integer(i) }
        }
        impl From<bool> for ConditionValue {
            fn from(b: bool) -> Self { ConditionValue::Boolean(b) }
        }
        impl From<f64> for ConditionValue {
            fn from(f: f64) -> Self { ConditionValue::Float(f) }
        }

        impl std::fmt::Display for ConditionValue {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                match self {
                    ConditionValue::String(s) => write!(f, "{}", s),
                    ConditionValue::Integer(i) => write!(f, "{}", i),
                    ConditionValue::Boolean(b) => write!(f, "{}", b),
                    ConditionValue::Float(fl) => write!(f, "{}", fl),
                }
            }
        }
        ```
    2.  **`Operator` Enum definieren:**
          * Repräsentiert die Vergleichsoperatoren für Bedingungen.
          * Varianten:
              * `Equals` (`==`)
              * `NotEquals` (`!=`)
              * `Contains` (für Strings)
              * `StartsWith` (für Strings)
              * `EndsWith` (für Strings)
              * `GreaterThan` (`>`)
              * `LessThan` (`<`)
              * `GreaterThanOrEqual` (`>=`)
              * `LessThanOrEqual` (`<=`)
              * `RegexMatch` (für Strings, optional)
              * `AlwaysTrue` (für Bedingungen, die immer wahr sind, z.B. als Standardbedingung für globale Regeln)
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Copy`, `Debug`, `Serialize`, `Deserialize`, `Display`.
    3.  **`Field` Enum definieren:**
          * Repräsentiert die Felder einer `Notification`-Struktur, die als Bedingungen geprüft werden können.
          * Varianten:
              * `AppName` (`app_name`)
              * `Summary` (`summary`)
              * `Body` (`body`)
              * `Category` (`category`)
              * `Urgency` (`urgency`)
              * `DesktopEntry` (`desktop_entry`)
              * `Hint(String)` (für benutzerdefinierte `hints`, der String ist der Hint-Key)
              * `IsTransient` (`transient`)
              * `IsMuted` (ob die Benachrichtigung bereits durch eine frühere Regel gemutet wurde)
              * `IsSilent` (ob die Benachrichtigung bereits durch eine frühere Regel unsichtbar gemacht wurde)
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`, `Display`.
    4.  **`SimpleRuleCondition` Struct definieren:**
          * Eine einzelne atomare Bedingung.
          * Felder:
              * `field: Field`
              * `operator: Operator`
              * `value: ConditionValue`
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`.
    5.  **`RuleCondition` Enum definieren:**
          * Ermöglicht das Verketten von Bedingungen mit logischen Operatoren.
          * Varianten:
              * `Simple(SimpleRuleCondition)`
              * `And(Vec<RuleCondition>)`
              * `Or(Vec<RuleCondition>)`
              * `Not(Box<RuleCondition>)`
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`.
          * `Box` für `Not` ist wichtig, um rekursive Enum-Definitionen zu ermöglichen.
    6.  **`RuleAction` Enum definieren:**
          * Repräsentiert die Aktionen, die ausgeführt werden, wenn eine Regel zutrifft.
          * Varianten:
              * `SetUrgency(crate::notification::data_types::Urgency)`: Ändert die Dringlichkeit der Benachrichtigung.
              * `Mute`: Setzt das `mute`-Flag der Benachrichtigung auf `true`.
              * `Unmute`: Setzt das `mute`-Flag der Benachrichtigung auf `false`.
              * `Silent`: Setzt das `silent`-Flag der Benachrichtigung auf `true` (Benachrichtigung wird nicht angezeigt, nur geloggt).
              * `Unsilent`: Setzt das `silent`-Flag der Benachrichtigung auf `false`.
              * `AddAction(crate::notification::data_types::Action)`: Fügt eine neue Aktion zur Benachrichtigung hinzu.
              * `RemoveAction(String)`: Entfernt eine Aktion basierend auf ihrem `key`.
              * `ExpireAfter(i32)`: Setzt das `expire_timeout_ms` der Benachrichtigung. `-1` für Standard, `0` für sofortiges Schließen.
              * `StopProcessingFurtherRules`: Beendet die Regelverarbeitung für die aktuelle Benachrichtigung.
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`.
    7.  **`NotificationRule` Struct definieren:**
          * Repräsentiert eine einzelne Benachrichtigungsregel.
          * Felder:
              * `id: Uuid` (Eindeutige ID für die Regel)
              * `name: String` (Benutzerfreundlicher Name der Regel)
              * `enabled: bool` (Ist die Regel aktiv?)
              * `priority: i32` (Priorität der Regel, höhere Werte zuerst, z.B. 0-100)
              * `condition: RuleCondition` (Die Bedingung, die erfüllt sein muss)
              * `actions: Vec<RuleAction>` (Die Liste der Aktionen, die ausgeführt werden, wenn die Bedingung zutrifft)
              * `stop_on_match: bool` (Wenn wahr, werden keine weiteren Regeln nach dieser Regel verarbeitet, falls sie zutrifft).
              * `description: Option<String>` (Optionale, ausführlichere Beschreibung der Regel)
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`, `Default`.
          * Implementiere `new()`-Funktion für einfache Instanziierung.
    8.  **`NotificationRuleSet` Struct definieren:**
          * Ein Container für eine Sammlung von Regeln.
          * Felder:
              * `rules: Vec<NotificationRule>`
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`, `Default`.
          * Implementiere `new()`-Funktion.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/data_types.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notification::data_types::{Urgency, Action}`.
      * **Extern:** `serde::{Serialize, Deserialize}`, `uuid::Uuid`, `std::collections::HashMap` (implizit durch `Notification` in `Field::Hint`).
      * **Regex (optional):** Wenn `Operator::RegexMatch` verwendet wird, muss die `regex` crate hinzugefügt werden.
  * **Kommunikationsmuster:**
      * Wird von der `NotificationRulesEngine` verwendet, um Regeln zu verarbeiten.
      * Wird vom `NotificationRulesProvider` verwendet, um Regeln zu laden und zu speichern.
      * Wird von der UI-Schicht verwendet, um Regeln anzuzeigen und zu bearbeiten.
  * **Erwartete Ergebnisse/Outputs:** Eine vollständige und flexible Definition der Datenmodelle für Benachrichtigungsregeln, die sowohl einfache als auch komplexe Bedingungen und Aktionen ermöglicht, und die Grundlage für die Regel-Engine und die UI bildet.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Serialisierung und Deserialisierung aller Enums und Structs.
          * Testen der `From` Implementierungen für `ConditionValue`.
          * Testen der `Display` Implementierungen für `ConditionValue`, `Operator`, `Field`.
          * Testen der `Default` Implementierungen.
          * Testen der `new()`-Funktionen.
          * Testen von `PartialEq` und `Eq` für alle Typen.

-----

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (44 von 100) widmet sich der Implementierung der Fehlerdefinitionen für das Benachrichtigungsregeln-Modul in `novade-domain/src/notification_rules/errors.rs`. Eine präzise Fehlerbehandlung ist entscheidend für die Stabilität und Wartbarkeit des Regelsystems.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 44/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.21.3. `novade-domain/src/notification_rules/errors.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/errors.rs`
* **Verantwortlichkeit:** Definiert ein konsolidiertes Fehler-Enum (`NotificationRulesError`) für alle Operationen, die innerhalb des `notification_rules`-Moduls der Domänenschicht auftreten können. Dieses Enum kapselt spezifische Fehlerquellen (z.B. Dateisystemfehler bei der Regel-Persistenz, Validierungsfehler bei Regeldefinitionen, Fehler bei der Regelauswertung, Regex-Fehler) und bietet eine einheitliche Schnittstelle zur Fehlerbehandlung und -propagation. Die Nutzung von `thiserror` ist obligatorisch.
* **Kern-Aufgaben (Tasks):**
    1.  **`NotificationRulesError` Enum definieren:**
        * Nutze `#[derive(thiserror::Error, Debug)]` für automatische Implementierung der `Error` und `Debug` Traits.
        * Varianten:
            * `PersistenceError(#[from] std::io::Error)`: Fehler, die beim Lesen oder Schreiben von Regeldateien auftreten (z.B. Dateisystemzugriffsfehler).
                * `#[error("Failed to persist notification rules: {0}")]`
            * `SerializationError(#[from] serde_json::Error)`: Fehler, die während der Serialisierung oder Deserialisierung von Regeldaten (z.B. JSON) auftreten.
                * `#[error("Failed to serialize/deserialize notification rules: {0}")]`
            * `RuleNotFound { id: uuid::Uuid }`: Wenn eine Regel mit einer spezifischen ID nicht gefunden werden kann (z.B. beim Aktualisieren oder Löschen).
                * `#[error("Notification rule with ID '{id}' not found.")]`
            * `InvalidRuleDefinition(String)`: Für semantisch ungültige Regeldefinitionen (z.B. inkonsistente Bedingungen, fehlende Felder, logische Inkonsistenzen). Die `String` sollte eine detaillierte Fehlermeldung enthalten.
                * `#[error("Invalid rule definition: {0}")]`
            * `RegexError(#[from] regex::Error)`: Fehler, die bei der Kompilierung oder Auswertung von regulären Ausdrücken in Bedingungen auftreten.
                * `#[error("Regex error in rule condition: {0}")]`
            * `ConfigServiceError(#[from] novade_core::error::ConfigError)`: Fehler, die vom `ConfigService` bei der Pfadermittlung oder ähnlichem stammen.
                * `#[error("Configuration service error: {0}")]`
            * `Other(String)`: Ein Catch-All für unvorhergesehene oder nicht spezifisch handhabbare Fehler, die eine generische Fehlermeldung erfordern.
                * `#[error("An unexpected notification rules error occurred: {0}")]`
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification_rules/errors.rs`
* **Abhängigkeiten:**
    * **Intern:** `uuid::Uuid` (für `RuleNotFound`).
    * **Extern:** `thiserror::Error`, `std::io::Error`, `serde_json::Error`, `regex::Error`, `novade_core::error::ConfigError`.
* **Kommunikationsmuster:**
    * Wird als `E` (Fehler-Typ) in `Result<T, E>` Signaturen aller öffentlichen Funktionen und Methoden des `notification_rules`-Moduls verwendet (z.B. `NotificationRulesProvider`, `NotificationRulesEngine`).
    * Sollte von den `std::io::Error`, `serde_json::Error`, `regex::Error` und `novade_core::error::ConfigError` Fehlertypen erhalten und in die eigene Variante konvertieren (`#[from]`).
    * Wird vom `NotificationService` empfangen und dort in das übergeordnete `NotificationError` Enum gekapselt (`#[from]`).
* **Erwartete Ergebnisse/Outputs:** Ein klar strukturiertes und wartbares Fehler-Enum, das alle denkbaren Fehlerzustände im Benachrichtigungsregeln-Modul abdeckt und eine konsistente Fehlerbehandlung über die gesamte Domänenschicht ermöglicht.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der Instanziierung jeder Fehlervariante.
        * Testen der `#[from]`-Konvertierungen von `std::io::Error`, `serde_json::Error`, `regex::Error` und `novade_core::error::ConfigError`.
        * Testen der `Display`-Implementierung (via `to_string()`) für jede Fehlervariante, um sicherzustellen, dass die Fehlermeldungen korrekt und informativ sind.
        * Testen der `source()`-Kette, um sicherzustellen, dass die Ursprungsfehler bei der Konvertierung beibehalten werden.

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (45 von 100) widmet sich der Implementierung des `novade-domain/src/notification_rules/persistence_iface.rs` Moduls. Dieses Modul definiert den Vertrag für die Persistenz von Benachrichtigungsregeln, was für die Speicherung und das Laden von benutzerdefinierten Regeln unerlässlich ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 45/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.21.4. `novade-domain/src/notification_rules/persistence_iface.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/persistence_iface.rs`
* **Verantwortlichkeit:** Definiert den `NotificationRulesProvider` Trait. Dieser Trait ist die abstrakte Schnittstelle für alle Operationen, die sich auf das Laden, Speichern und Verwalten von Benachrichtigungsregel-Sets beziehen. Durch die Abstraktion des Providers wird die Logik der Regel-Engine von den spezifischen Implementierungsdetails der Datenhaltung (z.B. Dateisystem, D-Bus, Datenbank) entkoppelt.
* **Kern-Aufgaben (Tasks):**
    1.  **`NotificationRulesProvider` Trait definieren:**
        * Nutze `#[async_trait]` da alle Persistenz-Operationen asynchron sein werden (Potenzial für I/O).
        * Methoden:
            * `load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`:
                * Lädt das gesamte `NotificationRuleSet` aus dem konfigurierten Persistenzspeicher.
                * Wenn keine Regeln vorhanden sind (z.B. Datei nicht gefunden), sollte ein leeres `NotificationRuleSet` (`Default::default()`) zurückgegeben werden, kein Fehler.
                * **Fehlerbehandlung:** `NotificationRulesError::PersistenceError`, `NotificationRulesError::SerializationError`.
            * `save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`:
                * Speichert das aktuelle `NotificationRuleSet` im konfigurierten Persistenzspeicher.
                * Überschreibt vorhandene Regeln.
                * **Fehlerbehandlung:** `NotificationRulesError::PersistenceError`, `NotificationRulesError::SerializationError`.
            * `get_rules_file_path(&self) -> Result<PathBuf, NotificationRulesError>`:
                * Gibt den `PathBuf` zum Speicherort der Regeln zurück. Dies ist nützlich für Debugging und externe Tools.
                * **Fehlerbehandlung:** `NotificationRulesError::ConfigServiceError` (falls der Basispfad vom `ConfigService` nicht ermittelt werden kann).
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification_rules/persistence_iface.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::notification_rules::data_types::NotificationRuleSet`
        * `crate::notification_rules::errors::NotificationRulesError`
    * **Extern:** `async_trait::async_trait`, `std::path::PathBuf`.
* **Kommunikationsmuster:**
    * Dieser Trait wird von konkreten Persistenz-Implementierungen (z.B. `FilesystemNotificationRulesProvider`) implementiert.
    * Die `NotificationRulesEngine` wird diesen Trait nutzen, um Regeln zu laden und zu speichern, ohne die Details der Speicherung zu kennen.
* **Erwartete Ergebnisse/Outputs:** Eine klare, asynchrone Schnittstelle für den Datenzugriff auf Benachrichtigungsregeln, die die Regel-Engine von der Persistenzschicht entkoppelt.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:** Keine direkten Tests für diesen Trait, da er nur eine Definition ist. Die Tests erfolgen für die konkreten Implementierungen (z.B. `FilesystemNotificationRulesProvider`).
    * **Integration Tests:** Sicherstellen, dass die Implementierungen des Traits den Vertrag erfüllen.

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (46 von 100) widmet sich der Implementierung des `novade-domain/src/notification_rules/persistence.rs` Moduls. Dieses Modul stellt eine konkrete Implementierung des `NotificationRulesProvider`-Traits bereit, die Regeln persistiert und aus dem Dateisystem lädt.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 46/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.21.5. `novade-domain/src/notification_rules/persistence.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/persistence.rs`
* **Verantwortlichkeit:** Implementiert den `NotificationRulesProvider`-Trait und ist für das Laden und Speichern von Benachrichtigungsregeln aus und in das Dateisystem verantwortlich. Es nutzt den `ConfigServiceAsync` aus `novade-core` um den korrekten XDG-konformen Pfad für die Regeldatei zu ermitteln. Die Regeln werden im JSON-Format gespeichert, um Lesbarkeit und einfache Bearbeitbarkeit zu gewährleisten.
* **Kern-Aufgaben (Tasks):**
    1.  **`FilesystemNotificationRulesProvider` Struct definieren:**
        * Felder:
            * `config_service: Arc<dyn ConfigServiceAsync + Send + Sync>`: Referenz auf den asynchronen Konfigurationsdienst, um XDG-Pfade zu ermitteln.
            * `rules_file_name: String`: Der Name der Datei, in der die Regeln gespeichert werden (z.B. "nova_notification_rules.json").
    2.  **Konstruktor `new()` implementieren:**
        * Akzeptiert `config_service: Arc<dyn ConfigServiceAsync + Send + Sync>` und den Dateinamen als `String`.
        * Initialisiert das Struct.
    3.  **Implementierung des `NotificationRulesProvider`-Traits für `FilesystemNotificationRulesProvider`:**

        * **`load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`:**
            * **Pfad-Ermittlung:** Rufe `self.get_rules_file_path().await?` auf, um den vollständigen Pfad zur Regeldatei zu erhalten.
            * **Datei lesen:**
                * Versuche, die Datei asynchron zu lesen (`tokio::fs::read`).
                * **Fehlerbehandlung:** Wenn die Datei nicht gefunden wird (`ErrorKind::NotFound`), gib `Ok(NotificationRuleSet::default())` zurück (leeres Regelset, keine Fehler).
                * Bei anderen I/O-Fehlern, konvertiere sie in `NotificationRulesError::PersistenceError`.
            * **Deserialisierung:**
                * Wenn Daten gelesen wurden, versuche, diese von JSON in `NotificationRuleSet` zu deserialisieren (`serde_json::from_slice`).
                * Konvertiere Deserialisierungsfehler in `NotificationRulesError::SerializationError`.
                * Wenn Deserialisierung fehlschlägt, **Entscheidung:** eine Fehlermeldung loggen und ebenfalls ein `NotificationRuleSet::default()` zurückgeben, damit das System nicht abstürzt und der Benutzer die Möglichkeit hat, die Datei manuell zu korrigieren oder neue Regeln anzulegen, anstatt auf einer fehlerhaften Datei zu blockieren. Dies ist eine robuste Fehlerbehandlung, die die UX priorisiert.
            * Rückgabe des deserialisierten `NotificationRuleSet` oder des Standard-Sets.

        * **`save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`:**
            * **Pfad-Ermittlung:** Rufe `self.get_rules_file_path().await?` auf.
            * **Verzeichnis erstellen:** Stelle sicher, dass das Elternverzeichnis existiert, indem du `tokio::fs::create_dir_all` aufrufst.
            * **Serialisierung:**
                * Serialisiere das `NotificationRuleSet` in einen hübschen JSON-String (`serde_json::to_string_pretty`).
                * Konvertiere Serialisierungsfehler in `NotificationRulesError::SerializationError`.
            * **Datei schreiben:**
                * Schreibe die serialisierten Daten asynchron in die Datei (`tokio::fs::write`).
                * Konvertiere I/O-Fehler in `NotificationRulesError::PersistenceError`.
            * Rückgabe von `Ok(())`.

        * **`get_rules_file_path(&self) -> Result<PathBuf, NotificationRulesError>`:**
            * Rufe `self.config_service.get_config_dir().await?` auf, um das XDG-Basiskonfigurationsverzeichnis zu erhalten.
            * Erzeuge den vollständigen Pfad durch Anhängen von `self.rules_file_name` an dieses Verzeichnis.
            * Rückgabe des `PathBuf`.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification_rules/persistence.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::notification_rules::data_types::NotificationRuleSet`
        * `crate::notification_rules::errors::NotificationRulesError`
        * `crate::notification_rules::persistence_iface::NotificationRulesProvider`
        * `novade_core::config::ConfigServiceAsync`
        * `novade_core::error::ConfigError` (für `#[from]`)
    * **Extern:** `async_trait::async_trait`, `tokio::fs`, `std::path::PathBuf`, `std::sync::Arc`, `serde_json`, `tracing` (für Logging bei Deserialisierungsfehlern).
* **Kommunikationsmuster:** Wird von der `NotificationRulesEngine` verwendet, um Regeln zu laden und zu speichern.
* **Erwartete Ergebnisse/Outputs:** Eine robuste Implementierung für die Persistenz von Benachrichtigungsregeln, die XDG-Spezifikationen berücksichtigt und fehlerresistent ist.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests (mit Mocks und temporären Dateien):**
        * **Mocking:** Mock `ConfigServiceAsync` um kontrollierte Pfade für temporäre Dateien zu erhalten.
        * **Temporäre Dateien:** Verwende `tempfile::tempdir()` oder `tempfile::NamedTempFile` um Dateien in isolierten Umgebungen zu erstellen.
        * Testen von `load_rules`:
            * Laden einer nicht-existierenden Datei (sollte leeres `NotificationRuleSet` zurückgeben).
            * Laden einer leeren Datei (sollte leeres `NotificationRuleSet` zurückgeben).
            * Laden einer gültigen JSON-Regeldatei.
            * Laden einer ungültigen JSON-Regeldatei (Syntaxfehler, sollte geloggt und leeres `NotificationRuleSet` zurückgeben).
            * Laden einer semantisch ungültigen Regeldatei (z.B. falsche Typen, sollte geloggt und leeres `NotificationRuleSet` zurückgeben, falls `serde_json` dies nicht bereits als Syntaxfehler erkennt).
            * Testen von I/O-Fehlern beim Lesen.
        * Testen von `save_rules`:
            * Speichern eines leeren `NotificationRuleSet`.
            * Speichern eines `NotificationRuleSet` mit einer oder mehreren Regeln.
            * Sicherstellen, dass die Datei korrekt erstellt/überschrieben wird.
            * Überprüfen des Inhalts der gespeicherten Datei (JSON-Formatierung, Korrektheit der Daten).
            * Testen von I/O-Fehlern beim Schreiben (z.B. ungültige Berechtigungen).
        * Testen von `get_rules_file_path`:
            * Korrekte Pfadgenerierung basierend auf Mock `ConfigServiceAsync`.

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (47 von 100) widmet sich der Implementierung des `novade-domain/src/notification_rules/engine_iface.rs` Moduls. Dieses Modul definiert den Vertrag für die Benachrichtigungs-Regel-Engine, die für die Anwendung von Regeln auf eingehende Benachrichtigungen verantwortlich ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 47/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.21.6. `novade-domain/src/notification_rules/engine_iface.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/engine_iface.rs`
* **Verantwortlichkeit:** Definiert den `NotificationRulesEngine` Trait. Dieser Trait ist die zentrale Schnittstelle für das Benachrichtigungsmodul, um Benachrichtigungsregeln auf eingehende oder zu aktualisierende Benachrichtigungen anzuwenden. Er abstrahiert die komplexe Logik der Regelauswertung und Aktionsanwendung von den Konsumenten (insbesondere dem `NotificationService`). Der Trait stellt sicher, dass Regeln dynamisch geladen und verwaltet werden können und dass die Regelverarbeitung effizient und zuverlässig ist.
* **Kern-Aufgaben (Tasks):**
    1.  **`RuleProcessingResult` Enum definieren:**
        * Dieses Enum repräsentiert das Ergebnis der Regelverarbeitung für eine einzelne Benachrichtigung. Es ist nützlich, um den Zustand nach der Anwendung einer Regel zu signalisieren.
        * Varianten:
            * `Processed`: Die Benachrichtigung wurde erfolgreich verarbeitet und modifiziert.
            * `NoMatch`: Keine der Regeln traf auf die Benachrichtigung zu.
            * `StoppedByRule`: Die Verarbeitung wurde durch eine Regel mit `stop_on_match = true` vorzeitig beendet.
        * Implementiere: `PartialEq`, `Eq`, `Clone`, `Copy`, `Debug`.

    2.  **`NotificationRulesEngine` Trait definieren:**
        * Nutze `#[async_trait]` da das Laden von Regeln asynchron sein kann und die Engine mit anderen asynchronen Diensten (z.B. `GlobalSettingsService`) interagieren könnte.
        * Methoden:
            * `reload_rules(&self) -> Result<(), NotificationRulesError>`:
                * Lädt die aktuellen Regeln aus dem konfigurierten `NotificationRulesProvider` neu. Dies ist entscheidend, wenn der Benutzer Regeln über die UI ändert.
                * **Fehlerbehandlung:** `NotificationRulesError::PersistenceError`, `NotificationRulesError::SerializationError`, `NotificationRulesError::ConfigServiceError`.
            * `process_notification(&self, notification: &mut Notification) -> Result<RuleProcessingResult, NotificationRulesError>`:
                * Wendete das definierte Regelset auf die gegebene `notification` an.
                * Die `notification` wird *in-place* modifiziert, wenn Regeln zutreffen und Aktionen auslösen.
                * Die Regeln müssen in der Reihenfolge ihrer `priority` angewendet werden (höchste Priorität zuerst).
                * Wenn eine Regel zutrifft und ihr `stop_on_match`-Flag auf `true` gesetzt ist, wird die Verarbeitung weiterer Regeln sofort beendet.
                * **Fehlerbehandlung:** `NotificationRulesError::RegexError`, `NotificationRulesError::InvalidRuleDefinition` (falls eine Regel während der Verarbeitung als ungültig erkannt wird, obwohl sie geladen wurde).
                * **Rückgabewert:** Gibt `RuleProcessingResult` zurück, um anzuzeigen, ob die Benachrichtigung verarbeitet wurde oder die Verarbeitung gestoppt wurde.
            * `get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`:
                * Gibt das aktuell von der Engine geladene `NotificationRuleSet` zurück. Dies ist nützlich für die UI, um den Benutzer über die aktiven Regeln zu informieren. Es sollte eine geklonte Version des internen Zustands sein.
                * **Fehlerbehandlung:** Keine spezifischen Fehler, da es nur ein Lesezugriff auf den internen Speicher ist. Könnte `NotificationRulesError::Other` zurückgeben, falls ein interner Sperrfehler auftritt, aber das ist unwahrscheinlich.
            * `update_rules(&self, rules: NotificationRuleSet) -> Result<(), NotificationRulesError>`:
                * Aktualisiert das interne Regelset der Engine und persistiert die Änderungen sofort.
                * Wird von der UI verwendet, um vom Benutzer geänderte Regeln zu speichern.
                * Die Engine muss nach dem Speichern das neue Regelset laden.
                * **Fehlerbehandlung:** `NotificationRulesError::PersistenceError`, `NotificationRulesError::SerializationError`.
            * `set_app_mute_state(&self, app_name: String, mute: bool) -> Result<(), NotificationRulesError>`:
                * Eine dedizierte Methode, um den Mute-Status für eine bestimmte Anwendung zu ändern. Dies sollte intern eine temporäre oder permanente Regel generieren/aktualisieren, die für diese App gilt, oder den Status im `GlobalSettingsService` speichern und die Engine darauf reagieren lassen. **Entscheidung:** Dies sollte eine spezielle Regel im Regelset hinzufügen/aktualisieren, die die `app_name` filtert und die `Mute` oder `Unmute` Aktion anwendet. Dies ermöglicht die Persistenz des Zustands und die Handhabung über das normale Regelsystem. Wenn `mute` `false` ist, sollte die entsprechende Regel entfernt oder deaktiviert werden.
                * Nach der Änderung der Regel muss `save_rules` aufgerufen werden.
                * **Fehlerbehandlung:** `NotificationRulesError::PersistenceError`, `NotificationRulesError::SerializationError`.
            * `set_app_silent_state(&self, app_name: String, silent: bool) -> Result<(), NotificationRulesError>`:
                * Analoge Methode zu `set_app_mute_state`, aber für den `silent`-Status.
                * Fügt/aktualisiert eine Regel für die `app_name`, die die `Silent` oder `Unsilent` Aktion anwendet.
                * Nach der Änderung der Regel muss `save_rules` aufgerufen werden.
                * **Fehlerbehandlung:** `NotificationRulesError::PersistenceError`, `NotificationRulesError::SerializationError`.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification_rules/engine_iface.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::notification::data_types::Notification`
        * `crate::notification_rules::data_types::{NotificationRuleSet, NotificationRule, RuleCondition, RuleAction, Field, Operator, ConditionValue}` (für die `set_app_mute_state`/`set_app_silent_state` Implementierung).
        * `crate::notification_rules::errors::NotificationRulesError`
    * **Extern:** `async_trait::async_trait`.
* **Kommunikationsmuster:**
    * Dieser Trait wird von konkreten Engine-Implementierungen (z.B. `DefaultNotificationRulesEngine`) implementiert.
    * Der `NotificationService` wird diesen Trait nutzen, um eingehende Benachrichtigungen zu verarbeiten und Regeln zu aktualisieren.
    * Die UI-Schicht kann Methoden wie `get_rules` und `update_rules` nutzen, um die Regeln zu verwalten.
* **Erwartete Ergebnisse/Outputs:** Eine robuste und erweiterbare Schnittstelle für die Benachrichtigungsregel-Engine, die eine flexible und leistungsstarke Regelverarbeitung ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine direkten Tests für diesen Trait, da er nur eine Definition ist. Die Tests erfolgen für die konkreten Implementierungen (`DefaultNotificationRulesEngine`).

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (48 von 100) widmet sich der Implementierung des `novade-domain/src/notification_rules/engine.rs` Moduls. Dies ist die konkrete Implementierung des `NotificationRulesEngine`-Traits und bildet die Logikzentrale für die Anwendung von Benachrichtigungsregeln.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 48/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.21.7. `novade-domain/src/notification_rules/engine.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/engine.rs`
* **Verantwortlichkeit:** Implementiert den `NotificationRulesEngine`-Trait und ist das zentrale Modul für die Bewertung von Benachrichtigungsregeln und die Anwendung der entsprechenden Aktionen auf `Notification`-Objekte. Es verwaltet das geladene Regelset, interagiert mit dem `NotificationRulesProvider` zur Persistenz und dem `GlobalSettingsService` für Kontextinformationen.
* **Kern-Aufgaben (Tasks):**
    1.  **`DefaultNotificationRulesEngine` Struct definieren:**
        * Felder:
            * `rules_provider: Arc<dyn NotificationRulesProvider + Send + Sync>`: Referenz auf den Persistenz-Provider.
            * `settings_service: Arc<dyn GlobalSettingsService + Send + Sync>`: Referenz auf den globalen Einstellungsdienst, falls Regeln auf Basis von Systemeinstellungen (z.B. "Nicht stören"-Modus) angewendet werden müssen.
            * `rules: Arc<RwLock<NotificationRuleSet>>`: Das aktuell geladene Regelset. `RwLock` für thread-sicheren Lese-/Schreibzugriff, `Arc` für gemeinsame Besitzerschaft.
    2.  **Konstruktor `new()` implementieren:**
        * Akzeptiert `rules_provider` und `settings_service` als `Arc<dyn ...>`.
        * Initialisiert `rules` mit einem leeren `NotificationRuleSet`.
        * **Wichtiger Hinweis:** Der Konstruktor sollte *nicht* sofort `load_rules` aufrufen, da dies eine asynchrone Operation ist und der `new` Blockieren würde. Stattdessen sollte `reload_rules` als erste Operation nach der Instanziierung aufgerufen werden. Dies stellt die asynchrone Initialisierung sicher.
    3.  **Implementierung des `NotificationRulesEngine`-Traits für `DefaultNotificationRulesEngine`:**

        * **`reload_rules(&self) -> Result<(), NotificationRulesError>`:**
            * Rufe `self.rules_provider.load_rules().await?` auf, um das Regelset zu laden.
            * Sortiere die geladenen Regeln nach `priority` in absteigender Reihenfolge (höchste Priorität zuerst). Prioritäten sollten eindeutig sein, um eine deterministische Reihenfolge zu gewährleisten. Falls nicht eindeutig, sekundär nach `id` sortieren, um Determinismus zu erzwingen.
            * Erwerbe einen Schreib-Lock auf `self.rules` und aktualisiere das Regelset.
            * Logge den erfolgreichen Ladevorgang oder Fehler mit `tracing`.
            * **Fehlerbehandlung:** Alle Fehler vom `rules_provider` werden direkt propagiert.

        * **`process_notification(&self, notification: &mut Notification) -> Result<RuleProcessingResult, NotificationRulesError>`:**
            * Erwerbe einen Lese-Lock auf `self.rules`.
            * Iteriere über alle `enabled` und sortierten Regeln im `NotificationRuleSet`.
            * Für jede Regel:
                * Rufe eine private Hilfsmethode `_evaluate_condition(notification, &rule.condition).await?` auf, um zu prüfen, ob die Bedingung der Regel zutrifft.
                * Wenn die Bedingung zutrifft:
                    * Iteriere über alle `RuleAction`s der Regel.
                    * Rufe eine private Hilfsmethode `_apply_action(notification, &action).await?` auf, die die `Notification` in-place modifiziert.
                    * Logge die angewandte Regel und Aktionen mit `tracing::debug!`.
                    * Wenn `rule.stop_on_match` `true` ist, gib `Ok(RuleProcessingResult::StoppedByRule)` zurück und beende die Verarbeitung.
            * Wenn keine Regel zutrifft oder die Verarbeitung nicht gestoppt wurde, gib `Ok(RuleProcessingResult::Processed)` zurück.
            * **Fehlerbehandlung:** Fehler aus `_evaluate_condition` oder `_apply_action` propagieren.

        * **`get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`:**
            * Erwerbe einen Lese-Lock auf `self.rules`.
            * Gib einen Klon des `NotificationRuleSet` zurück.

        * **`update_rules(&self, rules: NotificationRuleSet) -> Result<(), NotificationRulesError>`:**
            * Erwerbe einen Schreib-Lock auf `self.rules` und ersetze das aktuelle Regelset durch das neue.
            * Sortiere das neue Regelset nach Priorität.
            * Rufe `self.rules_provider.save_rules(&rules).await?` auf, um die Änderungen zu persistieren.
            * Logge den Vorgang mit `tracing`.
            * **Fehlerbehandlung:** Propagiere Fehler vom `rules_provider`.

        * **`set_app_mute_state(&self, app_name: String, mute: bool) -> Result<(), NotificationRulesError>`:**
            * Hole das aktuelle Regelset mit `self.get_rules().await?`.
            * Generiere eine `Uuid` für die potenzielle Regel (oder verwende eine bereits vorhandene, wenn eine Regel für diese App existiert).
            * Finde eine bestehende Regel für diese `app_name` und `Mute` oder `Unmute` Aktion.
            * **Logik:**
                * Wenn `mute` ist:
                    * Wenn keine entsprechende Regel existiert, füge eine neue Regel hinzu:
                        * `name`: "Mute notifications for {app_name}"
                        * `enabled`: `true`
                        * `priority`: Eine hohe, aber nicht blockierende Priorität (z.B. 90).
                        * `condition`: `RuleCondition::Simple(SimpleRuleCondition { field: Field::AppName, operator: Operator::Equals, value: ConditionValue::String(app_name.clone()) })`
                        * `actions`: `vec![RuleAction::Mute]`
                        * `stop_on_match`: `false` (damit andere Regeln noch greifen können, die z.B. die Dringlichkeit setzen).
                    * Wenn eine existiert, aktualisiere deren `enabled` Status auf `true` und sorge dafür, dass nur die `Mute` Aktion vorhanden ist.
                * Wenn `unmute` ist (`mute == false`):
                    * Finde die entsprechende Regel und setze `enabled` auf `false` oder entferne die Regel ganz. **Entscheidung:** Regeln bleiben erhalten, werden aber deaktiviert (`enabled = false`), um sie bei Bedarf einfach wieder aktivieren zu können.
            * Rufe `self.update_rules(modified_rules).await?` auf, um die Änderungen zu speichern und neu zu laden.

        * **`set_app_silent_state(&self, app_name: String, silent: bool) -> Result<(), NotificationRulesError>`:**
            * Analoge Implementierung zu `set_app_mute_state`, aber für den `silent`-Status und die `Silent`/`Unsilent` Aktion.
            * Entsprechend eine Regel hinzufügen/aktualisieren/deaktivieren.
            * Rufe `self.update_rules(modified_rules).await?` auf.

    4.  **Private Hilfsmethode `_evaluate_condition(&self, notification: &Notification, condition: &RuleCondition) -> Result<bool, NotificationRulesError>` implementieren:**
        * Eine rekursive Funktion, die die Logik für die Auswertung von `RuleCondition`s implementiert.
        * Handhabt `Simple`, `And`, `Or`, `Not` Varianten.
        * Für `SimpleRuleCondition`:
            * Abrufen des Wertes des `field` aus der `notification`.
            * Vergleich des Wertes mit `condition.value` unter Verwendung des `condition.operator`.
            * **Typ-Überprüfung:** Stelle sicher, dass die Typen der zu vergleichenden Werte kompatibel sind (z.B. `Integer` mit `Integer`, `String` mit `String`). Wenn Typen nicht übereinstimmen, sollte die Bedingung als `false` ausgewertet werden. Logge einen `tracing::warn!` für solche Fälle.
            * **Regex-Handling:** Bei `Operator::RegexMatch`, kompiliere den Regex (mit `regex::Regex::new`) und prüfe auf Match (`is_match`). Fehler bei Regex-Kompilierung sollten als `NotificationRulesError::RegexError` zurückgegeben werden.

    5.  **Private Hilfsmethode `_apply_action(&self, notification: &mut Notification, action: &RuleAction) -> Result<(), NotificationRulesError>` implementieren:**
        * Modifiziert die `notification` basierend auf der `RuleAction`.
        * Handhabt alle Varianten von `RuleAction`:
            * `SetUrgency`: Setzt `notification.urgency`.
            * `Mute`: Setzt `notification.mute = true`.
            * `Unmute`: Setzt `notification.mute = false`.
            * `Silent`: Setzt `notification.silent = true`.
            * `Unsilent`: Setzt `notification.silent = false`.
            * `AddAction`: Fügt die Aktion zu `notification.actions` hinzu. Stelle sicher, dass keine doppelten `key`s hinzugefügt werden.
            * `RemoveAction`: Entfernt die Aktion anhand des `key` aus `notification.actions`.
            * `ExpireAfter`: Setzt `notification.expire_timeout_ms`.
            * `StopProcessingFurtherRules`: Diese Aktion wird vom `process_notification` Handled, nicht hier. Kein Code erforderlich.
        * Keine Fehler erwartet, es sei denn, interne Datenstrukturen sind ungültig, was durch Typisierung verhindert werden sollte.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification_rules/engine.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::notification::data_types::Notification`
        * `crate::notification_rules::data_types::{NotificationRuleSet, NotificationRule, RuleCondition, RuleAction, Field, Operator, ConditionValue, SimpleRuleCondition}`
        * `crate::notification_rules::errors::NotificationRulesError`
        * `crate::notification_rules::engine_iface::{NotificationRulesEngine, RuleProcessingResult}`
        * `crate::notification_rules::persistence_iface::NotificationRulesProvider`
        * `crate::global_settings::service_iface::GlobalSettingsService`
    * **Extern:** `async_trait::async_trait`, `tokio`, `std::sync::{Arc, RwLock}`, `regex`, `tracing`, `uuid::Uuid` (für generierte Regel-ID bei `set_app_mute_state` / `set_app_silent_state`).
* **Kommunikationsmuster:**
    * Wird vom `NotificationService` aufgerufen, um Benachrichtigungen zu verarbeiten.
    * Nutzt `NotificationRulesProvider` für Persistenz.
    * Nutzt `GlobalSettingsService` für Einstellungen.
* **Erwartete Ergebnisse/Outputs:** Eine leistungsstarke und konfigurierbare Regel-Engine, die in der Lage ist, komplexe Benachrichtigungsregeln dynamisch anzuwenden und zu persistieren.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests (mit Mocks):**
        * **Mocking:** Mock `NotificationRulesProvider` und `GlobalSettingsService`.
        * Testen von `reload_rules`:
            * Erfolgreiches Laden und Sortieren von Regeln.
            * Fehlerbehandlung bei fehlgeschlagenem Laden.
        * Testen von `process_notification`:
            * Anwendung einer einfachen Regel (AppName, Summary, Body, Category, Urgency, DesktopEntry).
            * Anwendung von Regeln mit `Hint` (existierend, nicht-existierend, verschiedene Typen).
            * Testen aller `Operator`s (`Equals`, `NotEquals`, `Contains`, `StartsWith`, `EndsWith`, `GreaterThan`, `LessThan`, `GreaterThanOrEqual`, `LessThanOrEqual`, `RegexMatch`, `AlwaysTrue`).
            * Testen von `RegexMatch` mit gültigen und ungültigen Regex-Mustern.
            * Testen von `And`, `Or`, `Not` Kombinationen in Bedingungen.
            * Testen von `RuleAction`s (`SetUrgency`, `Mute`, `Unmute`, `Silent`, `Unsilent`, `AddAction`, `RemoveAction`, `ExpireAfter`).
            * Testen von `stop_on_match`: Verifizierung, dass nachfolgende Regeln nicht angewendet werden.
            * Testen der Priorisierung der Regeln.
            * Testen, dass `notification` korrekt in-place modifiziert wird.
            * Testen des Rückgabewertes `RuleProcessingResult`.
        * Testen von `get_rules`: Sicherstellen, dass das geladene Regelset zurückgegeben wird.
        * Testen von `update_rules`:
            * Erfolgreiches Speichern des Regelsets.
            * Fehlerbehandlung bei fehlgeschlagenem Speichern.
        * Testen von `set_app_mute_state` und `set_app_silent_state`:
            * Hinzufügen einer neuen Regel für eine App.
            * Aktualisieren einer bestehenden Regel (z.B. Deaktivieren/Aktivieren).
            * Testen, dass die Änderungen persistiert werden (`save_rules` aufgerufen wird).
            * Verifizierung des Inhalts der generierten/aktualisierten Regeln.
    * **Integration Tests:**
        * Zusammenspiel mit `FilesystemNotificationRulesProvider` und einer echten `Notification`.
        * End-to-End-Szenarien, bei denen Regeln über die API gesetzt und dann die Effekte auf Benachrichtigungen beobachtet werden.

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (49 von 100) widmet sich der Initialisierung des `novade-domain/src/desktop_file/mod.rs` Moduls. Dieses Modul wird die Funktionalität kapseln, die für das Parsen und Verwalten von `.desktop`-Dateien gemäß der Freedesktop.org Desktop Entry Specification erforderlich ist. Diese Dateien sind entscheidend, um Anwendungen im System zu finden, ihre Metadaten (Name, Icon, Startbefehl usw.) zu extrahieren und sie auszuführen.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 49/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.22. `novade-domain/src/desktop_file` Verzeichnis

Dieses Verzeichnis ist für die Verarbeitung und Abfrage von `.desktop`-Dateien zuständig. Es ist eine wichtige Komponente für den Anwendungsstarter, das Dock, die Befehlspalette und andere UI-Elemente, die Informationen über installierte Anwendungen benötigen.

#### 3.22.1. `novade-domain/src/desktop_file/mod.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/desktop_file/mod.rs`
* **Verantwortlichkeit:** Definiert die öffentliche API des `desktop_file`-Moduls der Domänenschicht. Es re-exportiert alle wichtigen Typen, Traits, Enums und Strukturen, die von anderen Teilen der Domänenschicht (z.B. `application_launcher` oder `notification` für `desktop_entry`) oder von höheren Schichten (z.B. der UI-Schicht zur Anzeige von Anwendungsinformationen) benötigt werden, um mit `.desktop`-Dateien zu interagieren.
* **Kern-Aufgaben (Tasks):**
    1.  **Public API Definition:** Re-exportiere die folgenden Komponenten, die die Schnittstelle dieses Moduls bilden:
        * `data_types` (alle relevanten Typen wie `DesktopEntry`, `DesktopEntryType`, `StartupNotify`, `DesktopEntryError`).
        * `errors` (das `DesktopFileError` Enum).
        * `service_iface` (den `DesktopFileService` Trait).
        * `service` (die konkrete `DefaultDesktopFileService` Implementierung).
    2.  **Modul-Strukturierung:** Sicherstellen, dass alle Re-Exporte korrekt sind und keine internen Implementierungsdetails unnötigerweise exponiert werden.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/desktop_file/mod.rs`
* **Abhängigkeiten:**
    * **Intern:** `data_types`, `errors`, `service_iface`, `service` (innerhalb desselben `desktop_file` Moduls).
    * **Extern:** Keine direkten, da nur Re-Exporte stattfinden.
* **Kommunikationsmuster:** Stellt die Hauptschnittstelle des `desktop_file`-Moduls zur Verfügung. Es ist der primäre Punkt, über den andere Services der Domänenschicht und die UI-Schicht auf Desktop-Dateien zugreifen und deren Informationen verwenden.
* **Erwartete Ergebnisse/Outputs:** Eine klar definierte und leicht nutzbare öffentliche API für die Verarbeitung von `.desktop`-Dateien innerhalb der Domänenschicht, die konsistente Interaktionen über alle Schichten hinweg ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte sind. Die Tests erfolgen in den jeweiligen Submodulen.

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (50 von 100) widmet sich der Implementierung der Datentypen für das `.desktop`-Dateimodul in `novade-domain/src/desktop_file/data_types.rs`. Diese Strukturen sind entscheidend, um die Informationen aus den `.desktop`-Dateien gemäß der Freedesktop.org-Spezifikation zu repräsentieren.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 50/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.22.2. `novade-domain/src/desktop_file/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/desktop_file/data_types.rs`
  * **Verantwortlichkeit:** Definiert die Datenstrukturen, die die Inhalte einer `.desktop`-Datei abbilden. Diese Strukturen müssen die relevanten Schlüssel-Wert-Paare der Freedesktop.org Desktop Entry Specification (`.desktop` files) korrekt repräsentieren und eine einfache Serialisierung/Deserialisierung sowie den Zugriff auf die Daten ermöglichen.
  * **Kern-Aufgaben (Tasks):**
    1.  **`DesktopEntryType` Enum definieren:**
          * Repräsentiert den `Type`-Schlüssel in einer `.desktop`-Datei.
          * Varianten:
              * `Application`: Eine ausführbare Anwendung.
              * `Link`: Eine URL.
              * `Directory`: Ein Verzeichnis.
              * `Unknown(String)`: Für unbekannte oder zukünftige Typen.
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`, `Display`.
          * Implementiere `From<String>` für Konvertierung aus String.
        <!-- end list -->
        ```rust
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum DesktopEntryType {
            Application,
            Link,
            Directory,
            Unknown(String),
        }

        impl std::fmt::Display for DesktopEntryType {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                match self {
                    DesktopEntryType::Application => write!(f, "Application"),
                    DesktopEntryType::Link => write!(f, "Link"),
                    DesktopEntryType::Directory => write!(f, "Directory"),
                    DesktopEntryType::Unknown(s) => write!(f, "Unknown({})", s),
                }
            }
        }

        impl From<String> for DesktopEntryType {
            fn from(s: String) -> Self {
                match s.as_str() {
                    "Application" => DesktopEntryType::Application,
                    "Link" => DesktopEntryType::Link,
                    "Directory" => DesktopEntryType::Directory,
                    _ => DesktopEntryType::Unknown(s),
                }
            }
        }

        impl From<&str> for DesktopEntryType {
            fn from(s: &str) -> Self {
                DesktopEntryType::from(s.to_string())
            }
        }
        ```
    2.  **`StartupNotify` Enum definieren:**
          * Repräsentiert den `StartupNotify`-Schlüssel. Gibt an, ob der Anwendungsmanger auf den Start dieser Anwendung warten soll.
          * Varianten:
              * `True`
              * `False`
              * `Default` (impliziert `False` wenn nicht angegeben)
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Copy`, `Debug`, `Serialize`, `Deserialize`, `Display`.
          * Implementiere `From<String>` (konvertiert "true", "false", Standard auf `Default`).
        <!-- end list -->
        ```rust
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum StartupNotify {
            True,
            False,
            Default,
        }

        impl Default for StartupNotify {
            fn default() -> Self {
                StartupNotify::Default // Spec says implied 'false' if omitted, but 'Default' is clearer for internal use
            }
        }

        impl std::fmt::Display for StartupNotify {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                match self {
                    StartupNotify::True => write!(f, "true"),
                    StartupNotify::False => write!(f, "false"),
                    StartupNotify::Default => write!(f, "default"), // Will map to "false" on write
                }
            }
        }

        impl From<String> for StartupNotify {
            fn from(s: String) -> Self {
                match s.to_lowercase().as_str() {
                    "true" => StartupNotify::True,
                    "false" => StartupNotify::False,
                    _ => StartupNotify::Default,
                }
            }
        }

        impl From<&str> for StartupNotify {
            fn from(s: &str) -> Self {
                StartupNotify::from(s.to_string())
            }
        }
        ```
    3.  **`DesktopEntry` Struct definieren:**
          * Repräsentiert die geparsten Daten einer `.desktop`-Datei.
          * Felder:
              * `path: PathBuf`: Der vollständige Dateipfad zur `.desktop`-Datei. Wichtig für Kontext.
              * `name: String`: Der Anwendungsname (`Name` Schlüssel).
              * `generic_name: Option<String>`: Generischer Name (`GenericName` Schlüssel).
              * `comment: Option<String>`: Kommentar (`Comment` Schlüssel).
              * `icon: Option<String>`: Icon-Name oder Pfad (`Icon` Schlüssel).
              * `exec: String`: Der Befehl zum Ausführen der Anwendung (`Exec` Schlüssel).
              * `terminal: bool`: Ob die Anwendung in einem Terminal gestartet werden soll (`Terminal` Schlüssel, Standard `false`).
              * `startup_notify: StartupNotify`: Ob der Desktop-Manager auf den Start warten soll (`StartupNotify` Schlüssel, Standard `Default`).
              * `startup_wm_class: Option<String>`: WM Class für den Start (`StartupWMClass` Schlüssel).
              * `r#type: DesktopEntryType`: Typ des Eintrags (`Type` Schlüssel).
              * `categories: Vec<String>`: Kategorien (`Categories` Schlüssel, ';' getrennt).
              * `keywords: Vec<String>`: Schlüsselwörter (`Keywords` Schlüssel, ';' getrennt).
              * `mimes: Vec<String>`: Unterstützte MIME-Typen (`MimeType` Schlüssel, ';' getrennt).
              * `actions: HashMap<String, String>`: Zusätzliche Aktionen (z.B. `[Desktop Action Name] Exec=...` Sektionen). Der Schlüssel ist der Aktionsname (z.B. "NewWindow"), der Wert ist der `Exec` Befehl.
              * `hidden: bool`: Ob der Eintrag im Menü versteckt werden soll (`Hidden` Schlüssel, Standard `false`).
              * `no_display: bool`: Ob der Eintrag nie angezeigt werden soll (`NoDisplay` Schlüssel, Standard `false`).
              * `only_show_in: Vec<String>`: Nur in diesen Desktops anzeigen (`OnlyShowIn` Schlüssel, ';' getrennt). NovaDE sollte hier "NovaDE" verwenden.
              * `not_show_in: Vec<String>`: Nicht in diesen Desktops anzeigen (`NotShowIn` Schlüssel, ';' getrennt).
              * `dbus_activatable: bool`: Ob der Eintrag via D-Bus aktiviert werden kann (`DBusActivatable` Schlüssel, Standard `false`).
              * `try_exec: Option<String>`: Pfad zu einer ausführbaren Datei, die vor `Exec` geprüft wird (`TryExec` Schlüssel).
              * `path_field: Option<PathBuf>`: Arbeitsverzeichnis (`Path` Schlüssel).
              * `version: Option<String>`: Version der Desktop Entry Spezifikation (`Version` Schlüssel).
              * `localized_fields: HashMap<String, HashMap<String, String>>`: Für lokalisierte Felder wie `Name[de]`, `Comment[fr]`. Der äußere Schlüssel ist der Feldname (z.B. "Name"), der innere Schlüssel ist der Locale (z.B. "de"), der Wert ist der lokalisierte String. Dies ist für fortgeschrittene Internationalisierung.
              * `raw_fields: HashMap<String, String>`: Alle anderen unbekannten oder nicht direkt gemappten Schlüssel-Wert-Paare.
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`, `Default`.
          * Implementiere `new()`-Funktion für die Basis-Instanziierung.
          * **Hilfsfunktionen:**
              * `get_localized_name(&self, locale: Option<&str>) -> &str`: Gibt den lokalisierten Namen zurück, fällt auf `name` zurück.
              * `get_localized_comment(&self, locale: Option<&str>) -> Option<&str>`: Analoge für `comment`.
              * `get_localized_generic_name(&self, locale: Option<&str>) -> Option<&str>`: Analoge für `generic_name`.
              * `is_executable(&self) -> bool`: Prüft, ob `r#type == Application`.
              * `is_visible_in_desktop_environment(&self, current_desktop_env: &str) -> bool`: Prüft `OnlyShowIn`, `NotShowIn`, `Hidden`, `NoDisplay`.
                  * Eine Desktop Entry ist sichtbar, wenn:
                      * `hidden` ist `false`.
                      * `no_display` ist `false`.
                      * Wenn `only_show_in` nicht leer ist, muss `current_desktop_env` in `only_show_in` enthalten sein.
                      * Wenn `not_show_in` nicht leer ist, darf `current_desktop_env` nicht in `not_show_in` enthalten sein.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/desktop_file/data_types.rs`
  * **Abhängigkeiten:**
      * **Extern:** `serde::{Serialize, Deserialize}`, `std::path::PathBuf`, `std::collections::HashMap`.
  * **Kommunikationsmuster:** Wird vom `DesktopFileService` verwendet, um geparste `.desktop`-Dateien zu speichern und bereitzustellen. Wird von UI-Komponenten benötigt, um Anwendungslisten darzustellen.
  * **Erwartete Ergebnisse/Outputs:** Robuste und vollständige Datenmodelle für `.desktop`-Dateien, die alle wichtigen Aspekte der Spezifikation abdecken und eine einfache Abfrage der Attribute ermöglichen.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Serialisierung und Deserialisierung aller Enums und Structs.
          * Testen der `From<String>` Implementierungen für `DesktopEntryType` und `StartupNotify`.
          * Testen der `Display` Implementierungen für `DesktopEntryType` und `StartupNotify`.
          * Testen der `Default` Implementierung für `StartupNotify` und `DesktopEntry`.
          * Testen der Hilfsfunktionen von `DesktopEntry`:
              * `get_localized_name`, `get_localized_comment`, `get_localized_generic_name` mit verschiedenen Locales und Fallbacks.
              * `is_executable` für verschiedene `DesktopEntryType`s.
              * `is_visible_in_desktop_environment` für verschiedene Kombinationen von `Hidden`, `NoDisplay`, `OnlyShowIn`, `NotShowIn` und `current_desktop_env`.
          * Testen der korrekten Handhabung von leeren Feldern vs. `None`.

-----

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (51 von 100) widmet sich der Implementierung der Fehlerdefinitionen für das `.desktop`-Dateimodul in `novade-domain/src/desktop_file/errors.rs`. Eine präzise Fehlerbehandlung ist unerlässlich, um Probleme beim Parsen und Verwalten von Desktop-Dateien zu identifizieren und zu melden.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 51/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.22.3. `novade-domain/src/desktop_file/errors.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/desktop_file/errors.rs`
* **Verantwortlichkeit:** Definiert ein konsolidiertes Fehler-Enum (`DesktopFileError`) für alle Operationen, die innerhalb des `desktop_file`-Moduls der Domänenschicht auftreten können. Dieses Enum kapselt spezifische Fehlerquellen, wie Dateisystemfehler, Parsing-Fehler von `.desktop`-Dateien, Fehler bei der Icon-Auflösung oder ungültige Einträge. Die Nutzung von `thiserror` ist obligatorisch.
* **Kern-Aufgaben (Tasks):**
    1.  **`DesktopFileError` Enum definieren:**
        * Nutze `#[derive(thiserror::Error, Debug)]` für automatische Implementierung der `Error` und `Debug` Traits.
        * Varianten:
            * `IoError(#[from] std::io::Error)`: Fehler, die beim Lesen von `.desktop`-Dateien oder Icons auftreten.
                * `#[error("File system I/O error: {0}")]`
            * `ParseError { path: PathBuf, message: String }`: Wenn eine `.desktop`-Datei syntaktisch oder semantisch ungültig ist. `path` für den Kontext, `message` für Details.
                * `#[error("Failed to parse desktop file '{path:?}', reason: {message}")]`
            * `InvalidEntry(String)`: Für Einträge, die zwar syntaktisch korrekt sind, aber obligatorische Felder fehlen oder inkonsistente Daten enthalten (z.B. fehlender `Name` oder `Exec`).
                * `#[error("Invalid desktop entry: {0}")]`
            * `MissingRequiredField(String)`: Wenn ein notwendiges Feld (z.B. `Name` oder `Exec` für `Application`-Typ) in der `.desktop`-Datei fehlt.
                * `#[error("Missing required field '{0}' in desktop entry.")]`
            * `UnknownType(String)`: Wenn der `Type`-Schlüssel einen unbekannten Wert enthält.
                * `#[error("Unknown desktop entry type: '{0}'")]`
            * `IconResolutionError(String)`: Wenn ein Icon nicht gefunden oder aufgelöst werden kann.
                * `#[error("Failed to resolve icon: {0}")]`
            * `ConfigServiceError(#[from] novade_core::error::ConfigError)`: Fehler, die vom `ConfigService` bei der Pfadermittlung stammen.
                * `#[error("Configuration service error: {0}")]`
            * `Other(String)`: Ein Catch-All für unvorhergesehene oder nicht spezifisch handhabbare Fehler.
                * `#[error("An unexpected desktop file error occurred: {0}")]`
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/desktop_file/errors.rs`
* **Abhängigkeiten:**
    * **Intern:** Keine direkten, aber es hängt von der Funktionalität der `PathBuf` und `String` ab.
    * **Extern:** `thiserror::Error`, `std::io::Error`, `std::path::PathBuf`, `novade_core::error::ConfigError`.
* **Kommunikationsmuster:**
    * Wird als `E` (Fehler-Typ) in `Result<T, E>` Signaturen aller öffentlichen Funktionen und Methoden des `desktop_file`-Moduls verwendet (z.B. `DesktopFileService`).
    * Sollte von `std::io::Error` und `novade_core::error::ConfigError` Fehlertypen erhalten und in die eigene Variante konvertieren (`#[from]`).
    * Wird von der `ApplicationLauncherService` oder anderen Konsumenten empfangen und dort in ein übergeordnetes Fehler-Enum gekapselt oder direkt behandelt.
* **Erwartete Ergebnisse/Outputs:** Ein klar strukturiertes und wartbares Fehler-Enum, das alle denkbaren Fehlerzustände im `.desktop`-Dateimodul abdeckt und eine konsistente Fehlerbehandlung ermöglicht.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der Instanziierung jeder Fehlervariante mit aussagekräftigen Daten (z.B. Dateipfade, Fehlermeldungen).
        * Testen der `#[from]`-Konvertierungen von `std::io::Error` und `novade_core::error::ConfigError`.
        * Testen der `Display`-Implementierung (via `to_string()`) für jede Fehlervariante, um sicherzustellen, dass die Fehlermeldungen korrekt und informativ sind.
        * Testen der `source()`-Kette, um sicherzustellen, dass die Ursprungsfehler bei der Konvertierung beibehalten werden.

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (52 von 100) widmet sich der Implementierung des `novade-domain/src/desktop_file/service_iface.rs` Moduls. Dieses Modul definiert den Vertrag für den Dienst, der für das Auffinden, Parsen und Abfragen von `.desktop`-Dateien zuständig ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 52/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.22.4. `novade-domain/src/desktop_file/service_iface.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/desktop_file/service_iface.rs`
* **Verantwortlichkeit:** Definiert den `DesktopFileService` Trait. Dieser Trait ist die primäre Schnittstelle für alle Komponenten innerhalb und außerhalb der Domänenschicht, die Informationen über installierte Anwendungen (`.desktop`-Dateien) abfragen müssen. Er abstrahiert die zugrunde liegende Logik des Dateisystem-Scannens, Parsens und Caching von Desktop-Einträgen und bietet eine konsistente API. Alle Methoden sind asynchron, da Dateisystem-Operationen I/O-gebunden sind.
* **Kern-Aufgaben (Tasks):**
    1.  **`DesktopFileService` Trait definieren:**
        * Nutze `#[async_trait]` für alle Methoden.
        * Alle Methoden geben `Result<(), DesktopFileError>` oder `Result<T, DesktopFileError>` zurück, um eine konsistente Fehlerbehandlung zu gewährleisten.
        * Methoden:
            * `initialize(&self) -> Result<(), DesktopFileError>`:
                * Initialisiert den Dienst. Dies umfasst typischerweise das erstmalige Scannen der bekannten Desktop-Dateipfade und das Caching der gefundenen Einträge.
                * Sollte idempotent sein (mehrfacher Aufruf hat keine negativen Nebenwirkungen).
                * **Fehlerbehandlung:** Kann verschiedene `DesktopFileError`s propagieren, die beim initialen Scannen und Parsen auftreten.
            * `reload_desktop_entries(&self) -> Result<(), DesktopFileError>`:
                * Erzwingt ein erneutes Scannen und Parsen aller Desktop-Dateien aus den konfigurierten Pfaden.
                * Aktualisiert den internen Cache der Desktop-Einträge.
                * Dies ist wichtig, wenn sich die installierten Anwendungen ändern.
                * **Fehlerbehandlung:** Kann verschiedene `DesktopFileError`s propagieren.
            * `get_all_applications(&self) -> Result<Vec<DesktopEntry>, DesktopFileError>`:
                * Ruft alle derzeit erkannten `DesktopEntry`s vom Typ `Application` ab.
                * Die zurückgegebenen Einträge sollten gefiltert sein nach `Hidden` und `NoDisplay` Feldern und dem `OnlyShowIn`/`NotShowIn` Kriterium für die aktuelle Desktop-Umgebung (`NovaDE`).
                * Gibt einen `Vec` von geklonten `DesktopEntry`s zurück.
                * **Fehlerbehandlung:** `DesktopFileError::Other` bei internen Sperrproblemen (unwahrscheinlich).
            * `get_application_by_id(&self, desktop_entry_id: &str) -> Result<Option<DesktopEntry>, DesktopFileError>`:
                * Sucht eine `DesktopEntry` vom Typ `Application` anhand ihrer Desktop-Datei-ID (z.B. "firefox.desktop" oder "org.gnome.Terminal.desktop"). Die ID ist typischerweise der Dateiname der `.desktop`-Datei ohne den `.desktop`-Suffix.
                * **Fehlerbehandlung:** `DesktopFileError::Other` bei internen Sperrproblemen.
            * `get_application_by_exec(&self, exec_command: &str) -> Result<Option<DesktopEntry>, DesktopFileError>`:
                * Sucht eine `DesktopEntry` vom Typ `Application`, deren `Exec`-Befehl mit dem gegebenen `exec_command` übereinstimmt oder diesen enthält (z.B. für "firefox" den Eintrag für "firefox.desktop" finden). Dies erfordert eine intelligentere Suche, eventuell das Parsen des `Exec`-Feldes.
                * **Entscheidung:** Für die erste Implementierung wird ein einfacher `contains` oder `starts_with` Vergleich des `exec_command` mit dem `exec` Feld der `DesktopEntry` ausreichen. Später kann dies verfeinert werden, um Pfade und Argumente besser zu handhaben.
                * **Fehlerbehandlung:** `DesktopFileError::Other` bei internen Sperrproblemen.
            * `get_application_icon_path(&self, icon_name: &str, size: u32) -> Result<Option<PathBuf>, DesktopFileError>`:
                * Löst den tatsächlichen Pfad zu einer Icon-Datei für einen gegebenen Icon-Namen und eine gewünschte Größe auf.
                * Muss die XDG Icon Theme Specification berücksichtigen (Suchpfade, Fallbacks).
                * Gibt den `PathBuf` zur Icon-Datei zurück, oder `None` wenn nicht gefunden.
                * **Fehlerbehandlung:** `DesktopFileError::IconResolutionError`, `DesktopFileError::ConfigServiceError`.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/desktop_file/service_iface.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::desktop_file::data_types::DesktopEntry`
        * `crate::desktop_file::errors::DesktopFileError`
    * **Extern:** `async_trait::async_trait`, `std::path::PathBuf`.
* **Kommunikationsmuster:**
    * Dieser Trait wird von konkreten Dienstimplementierungen (z.B. `DefaultDesktopFileService`) implementiert.
    * Der `ApplicationLauncherService` und UI-Komponenten werden diesen Trait nutzen, um auf Anwendungsinformationen zuzugreifen.
* **Erwartete Ergebnisse/Outputs:** Eine klare, asynchrone Schnittstelle für den Zugriff auf und die Verwaltung von Desktop-Dateien, die eine flexible Integration in andere Domänendienste und die UI ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine direkten Tests für diesen Trait, da er nur eine Definition ist. Die Tests erfolgen für die konkreten Implementierungen (`DefaultDesktopFileService`).

---
Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (53 von 100) widmet sich der Implementierung des `novade-domain/src/desktop_file/service.rs` Moduls. Dies ist die konkrete Implementierung des `DesktopFileService`-Traits und bildet das Herzstück für das Auffinden und Verwalten von `.desktop`-Dateien.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 53/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.22.5. `novade-domain/src/desktop_file/service.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/desktop_file/service.rs`

  * **Verantwortlichkeit:** Implementiert den `DesktopFileService`-Trait. Verantwortlich für das Scannen von XDG-konformen Verzeichnissen nach `.desktop`-Dateien, deren Parsen, das Caching der geparsten `DesktopEntry`-Objekte und die Bereitstellung von Abfragemethoden. Es muss auch die Auflösung von Icon-Pfaden gemäß der XDG Icon Theme Specification handhaben.

  * **Kern-Aufgaben (Tasks):**

    1.  **`DefaultDesktopFileService` Struct definieren:**

          * Felder:
              * `config_service: Arc<dyn ConfigServiceAsync + Send + Sync>`: Für die Ermittlung von XDG-Basisverzeichnissen (z.B. `XDG_DATA_DIRS`, `XDG_DATA_HOME`, `XDG_CONFIG_DIRS`, `XDG_CONFIG_HOME`).
              * `desktop_entries: Arc<RwLock<HashMap<String, DesktopEntry>>>`: Ein Cache von `DesktopEntry`-Objekten, indiziert nach ihrer `DesktopEntryId` (typischerweise der Dateiname ohne `.desktop`). `RwLock` für Thread-sicheren Lese-/Schreibzugriff.
              * `icon_theme_cache: Arc<RwLock<HashMap<String, PathBuf>>>`: Ein Cache für aufgelöste Icon-Pfade, um wiederholte Dateisystem-Suchen zu vermeiden. Schlüssel: "icon\_name@size", Wert: `PathBuf`.
              * `current_desktop_env: String`: Der Name der aktuellen Desktop-Umgebung ("NovaDE"), verwendet für `OnlyShowIn`/`NotShowIn` Filterung.

    2.  **Konstruktor `new()` implementieren:**

          * Akzeptiert `config_service: Arc<dyn ConfigServiceAsync + Send + Sync>` und `current_desktop_env: String`.
          * Initialisiert `desktop_entries` und `icon_theme_cache` als leere HashMaps.
          * **Wichtiger Hinweis:** Der Konstruktor sollte *nicht* sofort `initialize` oder `reload_desktop_entries` aufrufen, da diese asynchron sind. Der erste Aufruf des `initialize` oder `reload_desktop_entries` muss explizit erfolgen.

    3.  **Implementierung des `DesktopFileService`-Traits für `DefaultDesktopFileService`:**

          * **`initialize(&self) -> Result<(), DesktopFileError>`:**

              * Ruft `self.reload_desktop_entries().await` auf. Diese Methode ist primär ein Wrapper für den initialen Ladevorgang.
              * Logge den Initialisierungserfolg oder -fehler mit `tracing`.

          * **`reload_desktop_entries(&self) -> Result<(), DesktopFileError>`:**

              * **Schritt 1: XDG-Pfade ermitteln.**
                  * Rufe `config_service.get_data_dirs().await?` und `config_service.get_data_home().await?` auf.
                  * Kombiniere diese Pfade zu einer Liste von Verzeichnissen, die nach `.desktop`-Dateien durchsucht werden sollen. Füge dabei `applications` Unterverzeichnisse hinzu (z.B. `/usr/share/applications`, `~/.local/share/applications`).
              * **Schritt 2: Scannen und Parsen.**
                  * Iteriere über alle ermittelten Verzeichnisse.
                  * Verwende `tokio::fs::read_dir` und asynchrone Schleifen, um rekursiv (oder flach, je nach Spezifikation für `.desktop`-Dateien, standardmäßig flach in `applications/`) nach Dateien mit der Endung `.desktop` zu suchen.
                  * Für jede gefundene `.desktop`-Datei:
                      * Lese den Inhalt der Datei (`tokio::fs::read_to_string`).
                      * Rufe eine private Hilfsmethode `_parse_desktop_file(path, content)` auf, die den String parst und ein `DesktopEntry`-Objekt zurückgibt.
                      * **Fehlerbehandlung beim Parsen:** Wenn das Parsen fehlschlägt, logge den Fehler mit `tracing::warn!`, aber fahre mit den anderen Dateien fort. Propagiere den Fehler nicht nach oben, um das Laden anderer gültiger Einträge nicht zu blockieren.
                      * Wenn das Parsen erfolgreich ist, füge das `DesktopEntry`-Objekt der *temporären* HashMap hinzu, die dann in `self.desktop_entries` geschrieben wird. Der Schlüssel ist der Dateiname (z.B. "firefox.desktop").
              * **Schritt 3: Cache aktualisieren.**
                  * Erwerbe einen Schreib-Lock auf `self.desktop_entries`.
                  * Ersetze die alte HashMap durch die neu geparste.
              * Logge die Anzahl der gefundenen Einträge.
              * Rückgabe von `Ok(())`.

          * **`get_all_applications(&self) -> Result<Vec<DesktopEntry>, DesktopFileError>`:**

              * Erwerbe einen Lese-Lock auf `self.desktop_entries`.
              * Iteriere über die Werte der HashMap.
              * Filtriere nach:
                  * `desktop_entry.r#type == DesktopEntryType::Application`
                  * `desktop_entry.is_visible_in_desktop_environment(&self.current_desktop_env)`
              * Klone die gefilterten `DesktopEntry`-Objekte und sammle sie in einem `Vec`.
              * Gibt das `Vec` zurück.

          * **`get_application_by_id(&self, desktop_entry_id: &str) -> Result<Option<DesktopEntry>, DesktopFileError>`:**

              * Erwerbe einen Lese-Lock auf `self.desktop_entries`.
              * Sucht den Eintrag direkt in der HashMap mit `desktop_entry_id` als Schlüssel (z.B. "firefox.desktop").
              * Wenn gefunden und `r#type == DesktopEntryType::Application` und `is_visible_in_desktop_environment` ist, klone und gebe `Some(entry)` zurück.
              * Andernfalls `None`.

          * **`get_application_by_exec(&self, exec_command: &str) -> Result<Option<DesktopEntry>, DesktopFileError>`:**

              * Erwerbe einen Lese-Lock auf `self.desktop_entries`.
              * Iteriere über alle `DesktopEntry`s in der HashMap.
              * Filtriere nach `DesktopEntryType::Application` und `is_visible_in_desktop_environment`.
              * Prüfe, ob `entry.exec` den `exec_command` enthält oder damit beginnt (case-insensitive für `exec_command` selbst).
              * **Entscheidung:** Für eine erste Implementierung, vergleiche den `exec_command` direkt mit dem ersten Wort im `exec`-Feld der `DesktopEntry` (also vor dem ersten Leerzeichen). Dies ist eine einfache Heuristik.
                ```rust
                // Beispiel Logik für Vergleich in get_application_by_exec
                let mut parts = entry.exec.split_whitespace();
                if let Some(first_exec_part) = parts.next() {
                    if first_exec_part == exec_command {
                        return Ok(Some(entry.clone()));
                    }
                }
                ```
              * Gib die erste passende `DesktopEntry` zurück, oder `None`.

          * **`get_application_icon_path(&self, icon_name: &str, size: u32) -> Result<Option<PathBuf>, DesktopFileError>`:**

              * **Schritt 1: Cache prüfen.**
                  * Erzeuge den Cache-Schlüssel: `format!("{icon_name}@{size}")`.
                  * Erwerbe einen Lese-Lock auf `self.icon_theme_cache`.
                  * Wenn der Eintrag im Cache gefunden wird, gebe den geklonten Pfad zurück.
              * **Schritt 2: Icon-Suchpfade ermitteln.**
                  * Rufe `config_service.get_icon_dirs().await?` und `config_service.get_data_home().await?` auf.
                  * Kombiniere diese Pfade (z.B. `/usr/share/icons`, `~/.local/share/icons`).
              * **Schritt 3: Suche in Themes.**
                  * Gemäß XDG Icon Theme Specification:
                      * Priorisiere das Standard-Theme (`hicolor` ist üblich).
                      * Durchsuche die Unterverzeichnisse jedes Themes (z.B. `size/apps`, `size/mimetypes`).
                      * Unterstütze gängige Formate wie `.png`, `.svg`.
                      * Berücksichtige Skalierung (z.B. `@2x` Suffixe).
                      * **Komplexität:** Dies ist ein komplexer Schritt. Eine einfache Implementierung könnte nur nach `icon_name.png` oder `icon_name.svg` in den `size/apps` Verzeichnissen suchen. Eine vollständige Implementierung würde `index.theme` Dateien parsen und die Vererbungs- und Skalierungslogik anwenden. **Entscheidung:** Für die erste Implementierung, eine vereinfachte Suche nach `icon_name.png` und `icon_name.svg` in `share/icons/{theme}/{size}/apps/` und `share/icons/{theme}/scalable/apps/` der XDG-Basispfade.
                      * **Hilfskrate:** Erwäge die Verwendung einer externen Krate wie `xdg_icon_theme` oder `icon_lookup` (falls verfügbar und passend für Rust), um diese komplexe Logik zu kapseln. **Entscheidung:** Vorerst wird eine rudimentäre, direkte Implementierung vorgenommen.
              * **Schritt 4: Cache aktualisieren.**
                  * Wenn ein Icon gefunden wird, erwerbe einen Schreib-Lock auf `self.icon_theme_cache` und füge den gefundenen Pfad hinzu.
              * Rückgabe des gefundenen Pfades oder `None`.
              * **Fehlerbehandlung:** `DesktopFileError::IconResolutionError` bei Problemen.

    4.  **Private Hilfsmethode `_parse_desktop_file(path: PathBuf, content: String) -> Result<DesktopEntry, DesktopFileError>` implementieren:**

          * Diese Methode ist das Herzstück des Parsens.
          * Verwende die `ini` Crate oder implementiere einen einfachen INI-Parser. Die `.desktop`-Dateien sind im Grunde INI-Dateien.
          * Iteriere über Zeilen, erkenne Sektionen (`[Desktop Entry]`, `[Desktop Action ...]`).
          * Für jedes Schlüssel-Wert-Paar:
              * Extrahiere den Schlüssel und den Wert.
              * Handle lokalisierte Schlüssel wie `Name[de]`: Der Hauptschlüssel `Name` sollte den Standardwert erhalten, und die lokalisierten Werte in `localized_fields` abgelegt werden.
              * Konvertiere Werte in die richtigen Typen (z.B. `Terminal` von String zu `bool`, `Type` zu `DesktopEntryType`).
              * Spalte Listen wie `Categories` und `MimeType` an `;` auf.
              * Prüfe auf obligatorische Felder basierend auf `Type` (z.B. `Exec` für `Application`). Wenn kritische Felder fehlen, gib `DesktopFileError::MissingRequiredField` oder `DesktopFileError::InvalidEntry` zurück.
          * Konstruiere und gebe ein `DesktopEntry`-Objekt zurück.
          * **Implementierungs-Details:** Der Parser muss robust sein gegenüber fehlenden Sektionen, unerwarteten Zeichen und Leerzeichen.
          * **Sektion `[Desktop Entry]`:** Hauptdaten.
          * **Sektion `[Desktop Action <name>]`:** Zusätzliche Aktionen, die in `actions` HashMap gespeichert werden.
          * **Fehlerbehandlung:** Gib `DesktopFileError::ParseError` oder `DesktopFileError::InvalidEntry` bei Fehlern zurück.

  * **Spezifische Artefakte/Dateien:**

      * `novade-domain/src/desktop_file/service.rs`

  * **Abhängigkeiten:**

      * **Intern:**
          * `crate::desktop_file::data_types::{DesktopEntry, DesktopEntryType, StartupNotify}`
          * `crate::desktop_file::errors::DesktopFileError`
          * `crate::desktop_file::service_iface::{DesktopFileService}`
          * `novade_core::config::ConfigServiceAsync`
      * **Extern:** `async_trait::async_trait`, `tokio`, `tokio::fs`, `std::path::PathBuf`, `std::collections::HashMap`, `std::sync::{Arc, RwLock}`, `tracing`, `ini` (oder eigene Parser-Logik).

  * **Kommunikationsmuster:**

      * Wird vom `ApplicationLauncherService` und UI-Komponenten aufgerufen, um Anwendungsinformationen abzurufen.
      * Nutzt `ConfigServiceAsync` zur Pfadermittlung.

  * **Erwartete Ergebnisse/Outputs:** Ein voll funktionsfähiger Dienst zum Auffinden und Parsen von `.desktop`-Dateien, der eine schnelle und zuverlässige Abfrage von Anwendungsinformationen ermöglicht, einschließlich Icon-Auflösung.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests (mit Mocks und temporären Dateien):**
          * **Mocking:** Mock `ConfigServiceAsync` um kontrollierte XDG-Pfade für temporäre Testdateien zu erhalten.
          * **Temporäre Dateien:** Verwende `tempfile::tempdir()` um eine Verzeichnisstruktur mit `.desktop`-Dateien für Tests zu erstellen.
          * Testen von `_parse_desktop_file`:
              * Gültige `.desktop`-Dateien mit allen Feldern (alle Typen: `Application`, `Link`, `Directory`).
              * Gültige `.desktop`-Dateien mit minimalen Feldern.
              * Dateien mit fehlenden obligatorischen Feldern (sollte `MissingRequiredField` zurückgeben).
              * Dateien mit ungültigem Format (sollte `ParseError` zurückgeben).
              * Testen der Lokalisierung (z.B. `Name[de]`).
              * Testen der `Categories`, `Keywords`, `MimeType` Listen.
              * Testen der `actions` Sektionen.
          * Testen von `reload_desktop_entries`:
              * Erfolgreiches Scannen und Parsen eines Verzeichnisbaums.
              * Handhabung von nicht-existierenden Pfaden.
              * Handhabung von Dateien, die nicht gelesen werden können (I/O-Fehler).
              * Handhabung von fehlerhaften `.desktop`-Dateien (sollten übersprungen und geloggt werden, aber nicht die gesamte Operation stoppen).
              * Überprüfen, ob der interne Cache korrekt gefüllt wird.
          * Testen von `get_all_applications`:
              * Korrekte Filterung nach `Application` Typ.
              * Korrekte Filterung nach `Hidden`, `NoDisplay`, `OnlyShowIn`, `NotShowIn`.
          * Testen von `get_application_by_id`:
              * Finden eines existierenden Eintrags.
              * Nicht-Finden eines nicht-existierenden Eintrags.
              * Nicht-Finden eines Eintrags vom falschen Typ oder nicht sichtbaren Eintrags.
          * Testen von `get_application_by_exec`:
              * Finden eines Eintrags basierend auf dem `Exec`-Befehl.
              * Handhabung von `exec` mit Argumenten.
          * Testen von `get_application_icon_path`:
              * Finden eines existierenden Icons in Standardpfaden (simulieren).
              * Nicht-Finden eines Icons.
              * Caching-Verhalten.
              * Handhabung von verschiedenen Größen.
      * **Integration Tests:**
          * Vollständiges Initialisieren des Dienstes mit einer simulierten oder echten XDG-Struktur.
          * End-to-End-Tests für das Laden und Abfragen von Anwendungen.


-----

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (54 von 100) widmet sich der Initialisierung des `novade-domain/src/application_launcher/mod.rs` Moduls. Dieses Modul kapselt die gesamte Logik, die für das Starten und Verwalten von Anwendungen erforderlich ist, und stellt die Kernfunktionalität für den Desktop bereit.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 54/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.23. `novade-domain/src/application_launcher` Verzeichnis

Dieses Verzeichnis enthält alle Komponenten, die für den Start und die grundlegende Verwaltung von Anwendungen notwendig sind. Es bildet die Brücke zwischen den im System vorhandenen `.desktop`-Dateien und der eigentlichen Prozessausführung.

#### 3.23.1. `novade-domain/src/application_launcher/mod.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/application_launcher/mod.rs`
* **Verantwortlichkeit:** Definiert die öffentliche API des `application_launcher`-Moduls der Domänenschicht. Es re-exportiert alle wichtigen Typen, Traits, Enums und Strukturen, die von anderen Teilen der Domänenschicht (z.B. `shell`) oder von höheren Schichten (z.B. der UI-Schicht für Anwendungsstarter, Docks oder Befehlspaletten) benötigt werden, um Anwendungen zu starten und ihre Metadaten abzurufen.
* **Kern-Aufgaben (Tasks):**
    1.  **Public API Definition:** Re-exportiere die folgenden Komponenten, die die Schnittstelle dieses Moduls bilden:
        * `data_types` (alle relevanten Typen wie `ApplicationLaunchOptions`, `ApplicationHandle`).
        * `errors` (das `ApplicationLauncherError` Enum).
        * `service_iface` (den `ApplicationLauncherService` Trait).
        * `service` (die konkrete `DefaultApplicationLauncherService` Implementierung).
    2.  **Modul-Strukturierung:** Sicherstellen, dass alle Re-Exporte korrekt sind und keine internen Implementierungsdetails unnötigerweise exponiert werden.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/application_launcher/mod.rs`
* **Abhängigkeiten:**
    * **Intern:** `data_types`, `errors`, `service_iface`, `service` (innerhalb desselben `application_launcher` Moduls).
    * **Extern:** Keine direkten, da nur Re-Exporte stattfinden.
* **Kommunikationsmuster:** Stellt die Hauptschnittstelle des `application_launcher`-Moduls zur Verfügung. Es ist der primäre Punkt, über den die UI-Schicht Anwendungsstarts anfordert und Informationen über laufende oder verfügbare Anwendungen abruft.
* **Erwartete Ergebnisse/Outputs:** Eine klar definierte und leicht nutzbare öffentliche API für den Anwendungsstarter innerhalb der Domänenschicht, die konsistente Interaktionen über alle Schichten hinweg ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte sind. Die Tests erfolgen in den jeweiligen Submodulen.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (55 von 100) widmet sich der Implementierung der grundlegenden Datentypen für das Anwendungsstarter-Modul in `novade-domain/src/application_launcher/data_types.rs`. Diese Strukturen sind entscheidend, um den Start und die Verwaltung von Anwendungen zu konfigurieren und zu verfolgen.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 55/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.23.2. `novade-domain/src/application_launcher/data_types.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/application_launcher/data_types.rs`
* **Verantwortlichkeit:** Definiert die Datenstrukturen, die für die Konfiguration des Startvorgangs von Anwendungen und die Repräsentation einer gestarteten Anwendung (Prozess) benötigt werden. Diese Typen sind die Schnittstelle zwischen dem Aufrufer des Dienstes (z.B. UI) und der tatsächlichen Ausführung von Anwendungen.
* **Kern-Aufgaben (Tasks):**
    1.  **`ApplicationLaunchOptions` Struct definieren:**
        * Repräsentiert die Optionen, die beim Start einer Anwendung übergeben werden können.
        * Felder:
            * `args: Vec<String>`: Befehlszeilenargumente, die an die Anwendung übergeben werden sollen.
            * `working_directory: Option<PathBuf>`: Optionales Arbeitsverzeichnis, in dem die Anwendung gestartet werden soll. Wenn `None`, wird das Standard-Arbeitsverzeichnis des Desktops verwendet.
            * `env_vars: Option<HashMap<String, String>>`: Optionale Umgebungsvariablen, die für diesen Prozess gesetzt werden sollen.
            * `stdin: bool`: Ob die Standardeingabe der Anwendung mit dem Starter verbunden bleiben soll (normalerweise `false` für GUI-Apps).
            * `stdout: bool`: Ob die Standardausgabe der Anwendung mit dem Starter verbunden bleiben soll (normalerweise `false` für GUI-Apps).
            * `stderr: bool`: Ob die Standardfehlerausgabe der Anwendung mit dem Starter verbunden bleiben soll (normalerweise `false` für GUI-Apps).
            * `terminal: bool`: Ob die Anwendung in einem Terminal gestartet werden soll (überschreibt die `Terminal`-Einstellung der `DesktopEntry`).
            * `startup_notify: bool`: Ob der Desktop-Manager auf den Start der Anwendung warten soll (überschreibt die `StartupNotify`-Einstellung der `DesktopEntry`).
            * `display_name: Option<String>`: Ein optionaler Anzeigename für den Prozess, der in der Taskleiste oder ähnlichem verwendet werden könnte. Wenn `None`, wird der `name` der `DesktopEntry` verwendet.
            * `pid_file: Option<PathBuf>`: Optionaler Pfad zu einer PID-Datei, die vom Kindprozess geschrieben werden soll. Dies ist für einige ältere Anwendungen relevant.
            * `allow_multi_instance: bool`: Ob mehrere Instanzen dieser Anwendung gestartet werden dürfen (standardmäßig `true`). Wenn `false`, und die App bereits läuft, sollte der Starter die vorhandene Instanz in den Vordergrund bringen, anstatt eine neue zu starten. **Entscheidung:** Dies ist eine fortgeschrittene Funktion, die in der ersten Implementierung ignoriert oder als `true` angenommen werden kann. Die Logik zum "In-den-Vordergrund-Bringen" erfordert IPC mit dem Window Manager. Vorerst wird immer eine neue Instanz gestartet, es sei denn, die Anwendung selbst verhindert dies. Das Feld bleibt bestehen für zukünftige Erweiterungen.
        * Implementiere: `Clone`, `Debug`, `Default`.
        * Implementiere `new()`-Funktion für die Basis-Instanziierung.

    2.  **`ApplicationHandle` Struct definieren:**
        * Repräsentiert eine Referenz zu einer gestarteten Anwendung, die es dem Starter ermöglicht, mit dem Prozess zu interagieren oder seinen Status abzufragen.
        * Felder:
            * `pid: u32`: Die Prozess-ID des gestarteten Prozesses.
            * `desktop_entry_id: String`: Die ID der `.desktop`-Datei, von der diese Anwendung gestartet wurde (z.B. "firefox.desktop").
            * `startup_id: Option<String>`: Die XDG Startup Notification ID, falls `startup_notify` aktiv ist und die Anwendung diese ID verwendet.
            * `process_name: String`: Der Name des gestarteten Prozesses (z.B. "firefox").
            * `launched_at: chrono::DateTime<chrono::Utc>`: Zeitstempel des Starts.
            * `_process_handle: Option<tokio::process::Child>`: Ein optionales `Child`-Handle von `tokio::process`, um den Prozess zu überwachen oder zu beenden. **Entscheidung:** Dies ist ein internes Detail der Implementierung, das nicht unbedingt im öffentlichen `ApplicationHandle` sein sollte. Wenn der `ApplicationLauncherService` den Prozess überwachen muss (z.B. für das `ApplicationClosed` Event), sollte er eine interne Map von PID zu `Child` Handles führen. Das `ApplicationHandle` kann eine vereinfachte, öffentlich zugängliche Repräsentation sein. Für die öffentliche API reicht es, die `pid` und `desktop_entry_id` zu haben. Wenn eine Interaktion (kill, wait) gewünscht ist, muss der Service diese über die PID vermitteln.
            * `_process_monitor_task: Option<tokio::task::JoinHandle<()>>`: Ein optionaler JoinHandle zur Überwachung der Lebensdauer des Kindprozesses. Dies sollte ebenfalls ein internes Detail sein und nicht in der öffentlichen API.
        * Implementiere: `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`.
        * Implementiere `new()`-Funktion für die Basis-Instanziierung.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/application_launcher/data_types.rs`
* **Abhängigkeiten:**
    * **Extern:** `std::path::PathBuf`, `std::collections::HashMap`, `chrono::{DateTime, Utc}`, `tokio::process::Child` (nur wenn `_process_handle` öffentlich), `tokio::task::JoinHandle` (nur wenn `_process_monitor_task` öffentlich). Für die finale öffentliche API sollten `tokio::process::Child` und `tokio::task::JoinHandle` nicht direkt exponiert werden, da sie Implementierungsdetails darstellen.
* **Kommunikationsmuster:**
    * `ApplicationLaunchOptions` wird als Parameter an den `ApplicationLauncherService` übergeben.
    * `ApplicationHandle` wird vom `ApplicationLauncherService` zurückgegeben, um den gestarteten Prozess zu referenzieren.
* **Erwartete Ergebnisse/Outputs:** Klare und flexible Datenmodelle, die die Konfiguration des Anwendungsstarts und die Verfolgung gestarteter Anwendungen ermöglichen.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der `Default` Implementierungen für `ApplicationLaunchOptions`.
        * Testen der `Clone` und `Debug` Implementierungen.
        * Testen der `new()`-Funktionen.
        * Testen der `PartialEq`, `Eq`, `Hash` Implementierungen für `ApplicationHandle`.
        * Sicherstellen, dass alle Felder korrekt initialisiert und gesetzt werden können.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (56 von 100) widmet sich der Implementierung der Fehlerdefinitionen für das Anwendungsstarter-Modul in `novade-domain/src/application_launcher/errors.rs`. Eine präzise Fehlerbehandlung ist entscheidend für die Zuverlässigkeit beim Starten und Verwalten von Anwendungen.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 56/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.23.3. `novade-domain/src/application_launcher/errors.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/application_launcher/errors.rs`
* **Verantwortlichkeit:** Definiert ein konsolidiertes Fehler-Enum (`ApplicationLauncherError`) für alle Operationen, die innerhalb des `application_launcher`-Moduls der Domänenschicht auftreten können. Dieses Enum kapselt spezifische Fehlerquellen wie das Nichtfinden einer Anwendung, Fehler bei der Ausführung des Prozesses, ungültige Argumente oder das Scheitern von D-Bus-Interaktionen. Die Nutzung von `thiserror` ist obligatorisch.
* **Kern-Aufgaben (Tasks):**
    1.  **`ApplicationLauncherError` Enum definieren:**
        * Nutze `#[derive(thiserror::Error, Debug)]` für automatische Implementierung der `Error` und `Debug` Traits.
        * Varianten:
            * `ApplicationNotFound { id: String }`: Wenn eine Anwendung mit der angegebenen ID (z.B. Desktop-Datei-ID) nicht gefunden werden kann.
                * `#[error("Application with ID '{id}' not found.")]`
            * `ExecNotFoundError { command: String }`: Wenn der Befehl, der in der `.desktop`-Datei (`Exec` Feld) oder direkt übergeben wurde, nicht im PATH gefunden wird.
                * `#[error("Executable command '{command}' not found.")]`
            * `LaunchFailed { source: std::io::Error, command: String }`: Ein allgemeiner Fehler beim Starten des Prozesses (z.B. Berechtigungsprobleme, Ressourcenmangel). Enthält den ursprünglichen `std::io::Error`.
                * `#[error("Failed to launch application '{command}': {source}")]`
            * `InvalidArguments(String)`: Wenn die an `exec` übergebenen Argumente ungültig sind oder nicht korrekt geparst werden können.
                * `#[error("Invalid arguments provided for application launch: {0}")]`
            * `DesktopFileError(#[from] crate::desktop_file::errors::DesktopFileError)`: Fehler, die vom `DesktopFileService` stammen (z.B. beim Parsen oder Laden von Desktop-Dateien).
                * `#[error("Desktop file error: {0}")]`
            * `ProcessAlreadyRunning { pid: u32, desktop_entry_id: String }`: Wenn eine Anwendung mit `allow_multi_instance = false` versucht wird zu starten, aber bereits läuft.
                * `#[error("Application '{desktop_entry_id}' (PID: {pid}) is already running.")]`
            * `DbusError(String)`: Für Fehler, die bei der Interaktion mit D-Bus auftreten (z.B. für D-Bus-aktivierbare Anwendungen oder Startup Notification).
                * `#[error("D-Bus interaction error: {0}")]`
            * `Other(String)`: Ein Catch-All für unvorhergesehene oder nicht spezifisch handhabbare Fehler.
                * `#[error("An unexpected application launcher error occurred: {0}")]`
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/application_launcher/errors.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::desktop_file::errors::DesktopFileError` (für `#[from]`)
    * **Extern:** `thiserror::Error`, `std::io::Error`.
* **Kommunikationsmuster:**
    * Wird als `E` (Fehler-Typ) in `Result<T, E>` Signaturen aller öffentlichen Funktionen und Methoden des `application_launcher`-Moduls verwendet (z.B. `ApplicationLauncherService`).
    * Sollte von `std::io::Error` und `crate::desktop_file::errors::DesktopFileError` Fehlertypen erhalten und in die eigene Variante konvertieren (`#[from]`).
    * Wird von der UI-Schicht oder anderen Diensten empfangen und dort in ein übergeordnetes Fehler-Enum gekapselt oder direkt behandelt.
* **Erwartete Ergebnisse/Outputs:** Ein klar strukturiertes und wartbares Fehler-Enum, das alle denkbaren Fehlerzustände im Anwendungsstarter-Modul abdeckt und eine konsistente Fehlerbehandlung ermöglicht.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der Instanziierung jeder Fehlervariante mit aussagekräftigen Daten (z.B. IDs, Befehle, Fehlermeldungen).
        * Testen der `#[from]`-Konvertierungen von `std::io::Error` und `crate::desktop_file::errors::DesktopFileError`.
        * Testen der `Display`-Implementierung (via `to_string()`) für jede Fehlervariante, um sicherzustellen, dass die Fehlermeldungen korrekt und informativ sind.
        * Testen der `source()`-Kette, um sicherzustellen, dass die Ursprungsfehler bei der Konvertierung beibehalten werden.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (57 von 100) widmet sich der Implementierung des `novade-domain/src/application_launcher/service_iface.rs` Moduls. Dieses Modul definiert den Vertrag für den Dienst, der für das Starten und Überwachen von Anwendungen zuständig ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 57/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.23.4. `novade-domain/src/application_launcher/service_iface.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/application_launcher/service_iface.rs`
* **Verantwortlichkeit:** Definiert den `ApplicationLauncherService` Trait. Dieser Trait ist die primäre Schnittstelle für alle Komponenten, die Anwendungen starten, beenden oder ihren Status abfragen müssen. Er abstrahiert die zugrunde liegende Komplexität der Prozessverwaltung, der `.desktop`-Dateien und der Interaktion mit dem Betriebssystem. Alle Methoden sind asynchron, da das Starten und Überwachen von Prozessen I/O-gebunden ist.
* **Kern-Aufgaben (Tasks):**
    1.  **`ApplicationLauncherService` Trait definieren:**
        * Nutze `#[async_trait]` für alle Methoden.
        * Alle Methoden geben `Result<(), ApplicationLauncherError>` oder `Result<T, ApplicationLauncherError>` zurück, um eine konsistente Fehlerbehandlung zu gewährleisten.
        * Methoden:
            * `initialize(&self) -> Result<(), ApplicationLauncherError>`:
                * Initialisiert den Dienst. Dies umfasst typischerweise die Initialisierung des zugrunde liegenden `DesktopFileService` und potenzieller D-Bus-Verbindungen.
                * Sollte idempotent sein.
                * **Fehlerbehandlung:** `ApplicationLauncherError::DesktopFileError`, `ApplicationLauncherError::DbusError`.
            * `launch_application(&self, desktop_entry_id: &str, options: ApplicationLaunchOptions) -> Result<ApplicationHandle, ApplicationLauncherError>`:
                * Startet eine Anwendung basierend auf ihrer `desktop_entry_id` (z.B. "firefox.desktop").
                * Verwendet die bereitgestellten `options` zur Konfiguration des Starts (Argumente, Arbeitsverzeichnis, etc.).
                * **Logik:**
                    * Ruft `DesktopFileService::get_application_by_id` auf, um die `DesktopEntry` zu erhalten. Wenn nicht gefunden, `ApplicationLauncherError::ApplicationNotFound`.
                    * Baut den tatsächlichen Befehl und die Argumente aus dem `Exec`-Feld der `DesktopEntry` und den `options.args` zusammen. Beachtet dabei die `.desktop`-Spezifikation für `Exec`-Feld Codes (z.B. `%f`, `%u`, `%F`, `%U`, `%c`, `%k`). **Entscheidung:** Für die erste Implementierung wird nur `%f`, `%F` (durch `args`) und `%c`, `%k` (werden ignoriert) unterstützt. `%u`, `%U` (URLs) sind komplexer und können später hinzugefügt werden.
                    * Ermittelt das Arbeitsverzeichnis aus `options.working_directory` oder `desktop_entry.path_field` oder ignoriert es.
                    * Erstellt einen neuen Prozess mit `tokio::process::Command`.
                    * Handhabt `terminal` und `startup_notify` Einstellungen aus `options` oder `DesktopEntry`.
                    * **Wichtiger Hinweis:** Wenn `terminal == true`, muss die Anwendung in einem Terminal-Emulator gestartet werden (z.B. `xterm -e "command"` oder `gnome-terminal -- "command"`). Dies erfordert eine konfigurierbare Liste von Terminal-Emulatoren, die der `ConfigService` bereitstellen kann oder eine hartcodierte Fallback-Liste. **Entscheidung:** Für die erste Implementierung wird ein hartcodierter Fallback auf `xterm` versucht, falls `terminal` `true` ist.
                    * Überwacht den gestarteten Prozess für den Fall, dass er sofort fehlschlägt oder seine PID nicht abgerufen werden kann.
                    * Erzeugt und gibt ein `ApplicationHandle` zurück, das die `pid` und andere Metadaten enthält.
                * **Fehlerbehandlung:** `ApplicationLauncherError::ApplicationNotFound`, `ApplicationLauncherError::ExecNotFoundError`, `ApplicationLauncherError::LaunchFailed`, `ApplicationLauncherError::InvalidArguments`, `ApplicationLauncherError::DesktopFileError`, `ApplicationLauncherError::DbusError`.
            * `launch_command(&self, command: &str, args: Vec<String>, options: ApplicationLaunchOptions) -> Result<ApplicationHandle, ApplicationLauncherError>`:
                * Startet einen beliebigen Befehl mit den gegebenen Argumenten und Optionen.
                * Wird für Befehle verwendet, die nicht direkt einer `.desktop`-Datei zugeordnet sind (z.B. Befehlspalette, Run-Dialog).
                * **Logik:** Analog zu `launch_application`, aber ohne den `DesktopFileService`-Lookup. Erzeugt ein generisches `ApplicationHandle` ohne `desktop_entry_id`.
                * **Fehlerbehandlung:** `ApplicationLauncherError::ExecNotFoundError`, `ApplicationLauncherError::LaunchFailed`, `ApplicationLauncherError::InvalidArguments`, `ApplicationLauncherError::DbusError`.
            * `kill_application(&self, pid: u32) -> Result<(), ApplicationLauncherError>`:
                * Beendet den Prozess mit der gegebenen PID. Sendet ein `SIGTERM` und wartet kurz, dann `SIGKILL` falls nötig.
                * **Fehlerbehandlung:** `ApplicationLauncherError::LaunchFailed` (wenn das Töten fehlschlägt), `ApplicationLauncherError::ApplicationNotFound` (wenn PID nicht existiert oder nicht von NovaDE verfolgt wird).
            * `get_running_applications(&self) -> Result<Vec<ApplicationHandle>, ApplicationLauncherError>`:
                * Gibt eine Liste aller derzeit vom `ApplicationLauncherService` verfolgten, laufenden Anwendungen zurück.
                * Die Liste sollte geklonte `ApplicationHandle`s enthalten.
                * **Fehlerbehandlung:** `ApplicationLauncherError::Other` bei internen Sperrproblemen.
            * `get_application_icon_path(&self, desktop_entry_id: &str, size: u32) -> Result<Option<PathBuf>, ApplicationLauncherError>`:
                * Eine Convenience-Methode, die die Icon-Auflösung über den `DesktopFileService` abstrahiert.
                * Ruft die `DesktopEntry` ab, extrahiert den `icon`-Namen und ruft dann `DesktopFileService::get_application_icon_path` auf.
                * **Fehlerbehandlung:** `ApplicationLauncherError::ApplicationNotFound`, `ApplicationLauncherError::DesktopFileError`.
            * `get_application_name(&self, desktop_entry_id: &str, locale: Option<&str>) -> Result<String, ApplicationLauncherError>`:
                * Eine Convenience-Methode, die den (lokalisierten) Namen einer Anwendung abruft.
                * Ruft die `DesktopEntry` ab und verwendet `desktop_entry.get_localized_name()`.
                * **Fehlerbehandlung:** `ApplicationLauncherError::ApplicationNotFound`, `ApplicationLauncherError::DesktopFileError`.
            * `on_application_closed(&self) -> impl Stream<Item = ApplicationHandle> + Send + Sync`:
                * Gibt einen asynchronen Stream zurück, der `ApplicationHandle`s ausgibt, wenn eine vom Launcher gestartete Anwendung beendet wird.
                * Dies ist entscheidend für Taskleisten oder Prozessmonitore, um den Status der Anwendungen zu aktualisieren.
                * **Entscheidung:** Der Stream sollte `tokio::sync::mpsc::unbounded_channel` oder ähnliche Mechanismen verwenden, um Events von der internen Prozessüberwachung zu pushen.
                * **Wichtiger Hinweis:** Das `impl Stream` ist eine moderne Rust-Funktion, die die Rückgabe von unbenannten Implementierungen von Traits ermöglicht.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/application_launcher/service_iface.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::application_launcher::data_types::{ApplicationLaunchOptions, ApplicationHandle}`
        * `crate::application_launcher::errors::ApplicationLauncherError`
        * `crate::desktop_file::data_types::DesktopEntry`
        * `crate::desktop_file::service_iface::DesktopFileService`
    * **Extern:** `async_trait::async_trait`, `std::path::PathBuf`, `futures::Stream`.
* **Kommunikationsmuster:**
    * Dieser Trait wird von konkreten Dienstimplementierungen (z.B. `DefaultApplicationLauncherService`) implementiert.
    * Die UI-Schicht (Anwendungsstarter, Dock, Taskleiste) wird diesen Trait nutzen, um Anwendungen zu starten, zu beenden und deren Status zu überwachen.
* **Erwartete Ergebnisse/Outputs:** Eine robuste und umfassende Schnittstelle für den Anwendungsstarter, die alle Aspekte des Startens, der Metadatenabfrage und der Prozessüberwachung abdeckt.
* **Teststrategie (Modul-spezifisch):** Keine direkten Tests für diesen Trait, da er nur eine Definition ist. Die Tests erfolgen für die konkreten Implementierungen (`DefaultApplicationLauncherService`).

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (58 von 100) widmet sich der Implementierung des `novade-domain/src/application_launcher/service.rs` Moduls. Dies ist die konkrete Implementierung des `ApplicationLauncherService`-Traits und bildet die zentrale Komponente für das Starten und Überwachen von Anwendungen im NovaDE.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 58/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.23.5. `novade-domain/src/application_launcher/service.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/application_launcher/service.rs`
* **Verantwortlichkeit:** Implementiert den `ApplicationLauncherService`-Trait. Dieser Dienst ist verantwortlich für das Starten von Prozessen basierend auf `.desktop`-Dateien oder direkten Befehlen, das Verfolgen ihrer Lebenszyklen und das Bereitstellen von Informationen über laufende Anwendungen. Er interagiert eng mit dem `DesktopFileService` und nutzt `tokio::process` für die Prozessverwaltung.
* **Kern-Aufgaben (Tasks):**
    1.  **`DefaultApplicationLauncherService` Struct definieren:**
        * **Felder:**
            * `desktop_file_service: Arc<dyn DesktopFileService + Send + Sync>`: Referenz zum Dienst für `.desktop`-Dateien.
            * `running_applications: Arc<RwLock<HashMap<u32, ApplicationHandle>>>`: Ein Cache von `ApplicationHandle`-Objekten, indiziert nach ihrer PID. `RwLock` für Thread-sicheren Lese-/Schreibzugriff.
            * `app_closed_sender: tokio::sync::mpsc::UnboundedSender<ApplicationHandle>`: Sender für den `on_application_closed` Stream.
            * `_app_closed_receiver: tokio::sync::mpsc::UnboundedReceiver<ApplicationHandle>`: Der Empfänger, der intern gehalten wird, damit der Kanal nicht sofort geschlossen wird. Dieser wird im `new` blockiert.
    2.  **Konstruktor `new()` implementieren:**
        * Akzeptiert `desktop_file_service: Arc<dyn DesktopFileService + Send + Sync>`.
        * Initialisiert `running_applications` als leere HashMap.
        * Erstellt einen `tokio::sync::mpsc::unbounded_channel` für `app_closed_sender` und `_app_closed_receiver`.
        * Gibt das `DefaultApplicationLauncherService` Struct zurück.
    3.  **Implementierung des `ApplicationLauncherService`-Traits für `DefaultApplicationLauncherService`:**

        * **`initialize(&self) -> Result<(), ApplicationLauncherError>`:**
            * Ruft `self.desktop_file_service.initialize().await` auf, um sicherzustellen, dass die Desktop-Dateien geladen sind.
            * Loggt den Initialisierungserfolg oder -fehler mit `tracing`.
            * **Fehlerbehandlung:** Propagiert alle Fehler vom `desktop_file_service`.

        * **`launch_application(&self, desktop_entry_id: &str, options: ApplicationLaunchOptions) -> Result<ApplicationHandle, ApplicationLauncherError>`:**
            * **1. `DesktopEntry` abrufen:** Ruft `self.desktop_file_service.get_application_by_id(desktop_entry_id).await?` auf.
                * Wenn `None` zurückkommt, gib `ApplicationLauncherError::ApplicationNotFound { id: desktop_entry_id.to_string() }` zurück.
            * **2. Befehl und Argumente aufbereiten:**
                * Extrahiert den `exec` Befehl und die Argumente aus der `DesktopEntry.exec` Feld.
                * Beachtet die `Exec`-Feld Codes (`%f`, `%F`, `%u`, `%U`, `%c`, `%k`, `%i`, `%v`, `%m`, `%d`, `%w`).
                    * `%f`, `%F`: Ersetze diese durch die Argumente aus `options.args`. Wenn `options.args` leer ist und `%f` oder `%F` vorhanden sind, sollten diese entfernt werden.
                    * `%u`, `%U`: URLs werden vorerst nicht unterstützt; diese Platzhalter ignorieren oder entfernen.
                    * `%c`: Ersetze durch den Namen der ausführbaren Datei.
                    * `%k`: Ersetze durch den Pfad zur `.desktop`-Datei.
                    * `%i`: Ersetze durch den Icon-Pfad (falls vom Desktop-Dateidienst abrufbar, sonst leer).
                    * `%v`, `%m`, `%d`, `%w`: Ignoriere oder entferne diese Platzhalter.
                * Kombiniere die geparsten Argumente aus `exec` mit `options.args`.
                * **Entscheidung:** Eine einfache `exec`-Parsing-Logik implementieren:
                    * Splittet den `exec`-String anhand von Leerzeichen.
                    * Das erste Element ist der Befehl.
                    * Substituiert die oben genannten Platzhalter.
                    * Wenn der Befehl Anführungszeichen enthält, müssen diese korrekt behandelt werden. **Entscheidung:** Für die erste Version wird angenommen, dass der Befehl selbst keine Leerzeichen enthält, es sei denn, er ist in Anführungszeichen gesetzt (einfachere Regex-Prüfung). Später kann dies zu einem robusten Shell-Parsing erweitert werden.
            * **3. Arbeitsverzeichnis festlegen:** Nutzt `options.working_directory` oder `desktop_entry.path_field`. Wenn beide `None`, wird das aktuelle Arbeitsverzeichnis des NovaDE-Prozesses verwendet.
            * **4. Umgebungsvariablen setzen:** Merge `options.env_vars` mit den aktuellen Umgebungsvariablen des Prozesses.
            * **5. Prozess starten (`tokio::process::Command`):**
                * Erstelle `tokio::process::Command` mit dem Befehl und den finalen Argumenten.
                * Setze das Arbeitsverzeichnis (`current_dir`).
                * Setze Umgebungsvariablen (`envs`).
                * **Terminal-Handling:** Wenn `options.terminal` oder `desktop_entry.terminal` `true` ist:
                    * **Entscheidung:** Versuche, `xterm -e "command args"` zu starten. Wenn `xterm` nicht gefunden wird, logge einen Fehler und versuche, den Befehl direkt zu starten. Ein späteres Feature kann einen konfigurierbaren Terminal-Emulator nutzen.
                    * Setze den Befehl des `tokio::process::Command` auf den Terminal-Emulator und die Argumente entsprechend.
                * Setze `stdin`, `stdout`, `stderr` basierend auf `options`.
                * Rufe `spawn()` auf.
                * **Fehlerbehandlung:** Wenn `spawn()` fehlschlägt, konvertiere den `std::io::Error` in `ApplicationLauncherError::LaunchFailed`.
            * **6. `ApplicationHandle` erstellen:**
                * Hole die `pid` vom `Child`-Handle.
                * Erstelle ein `ApplicationHandle` mit allen gesammelten Informationen.
            * **7. Prozess überwachen:**
                * Starte eine separate `tokio::spawn` Task, die auf das Beenden des Kindprozesses wartet (`child.wait().await`).
                * Wenn der Prozess beendet ist,
                    * Entferne die `ApplicationHandle` aus `self.running_applications`.
                    * Sende die `ApplicationHandle` über `self.app_closed_sender` (`send(handle.clone()).ok();`).
            * **8. Cache aktualisieren:** Erwerbe einen Schreib-Lock auf `self.running_applications` und füge die neue `ApplicationHandle` hinzu.
            * Rückgabe der erstellten `ApplicationHandle`.

        * **`launch_command(&self, command: &str, args: Vec<String>, options: ApplicationLaunchOptions) -> Result<ApplicationHandle, ApplicationLauncherError>`:**
            * **Logik:** Ähnlich wie `launch_application`, aber ohne `DesktopEntry`-Lookup.
            * Befehl ist `command`, Argumente sind `args`.
            * `desktop_entry_id` im `ApplicationHandle` ist ein leerer String oder ein generischer Platzhalter wie `"custom_command"`.
            * Terminal-Handling, Arbeitsverzeichnis und Umgebungsvariablen wie in `launch_application`.
            * Prozess starten und überwachen.

        * **`kill_application(&self, pid: u32) -> Result<(), ApplicationLauncherError>`:**
            * Erwerbe einen Lese-Lock auf `self.running_applications`.
            * Finde das `ApplicationHandle` für die gegebene `pid`.
            * **Entscheidung:** Um den Prozess zu beenden, ist das `Child`-Handle von `tokio::process::Command` erforderlich, das *nicht* in der öffentlichen `ApplicationHandle` gespeichert ist. Der `DefaultApplicationLauncherService` muss eine interne `HashMap<u32, tokio::process::Child>` führen oder die `Child` Instanz direkt über den `JoinHandle` des Monitoring-Tasks zugänglich machen.
            * **Wichtiger Hinweis:** Um das `Child` Handle für `kill` zu verwenden, muss es **nicht** in der `ApplicationHandle` gekapselt werden. Der `ApplicationLauncherService` muss selbst eine interne **Map von PIDs zu Child-Handles** verwalten. Wenn `kill_application` aufgerufen wird, findet es das `Child` Handle in dieser internen Map und ruft `kill()` auf.
            * Sende `SIGTERM` (oder entsprechend `Child::kill()` und ignoriere Fehler, wenn der Prozess bereits beendet ist). Warte kurz (z.B. 100ms).
            * Prüfe, ob der Prozess noch läuft. Wenn ja, sende `SIGKILL`.
            * Entferne den Eintrag aus `self.running_applications` (Schreib-Lock).
            * **Fehlerbehandlung:** `ApplicationLauncherError::ApplicationNotFound` wenn PID nicht gefunden, `ApplicationLauncherError::LaunchFailed` bei Problemen beim Beenden.

        * **`get_running_applications(&self) -> Result<Vec<ApplicationHandle>, ApplicationLauncherError>`:**
            * Erwerbe einen Lese-Lock auf `self.running_applications`.
            * Sammle alle Werte (geklonte `ApplicationHandle`s) in einem `Vec` und gib sie zurück.

        * **`get_application_icon_path(&self, desktop_entry_id: &str, size: u32) -> Result<Option<PathBuf>, ApplicationLauncherError>`:**
            * Ruft `self.desktop_file_service.get_application_by_id(desktop_entry_id).await?` auf.
            * Wenn gefunden, ruft `desktop_entry.icon` ab.
            * Wenn ein Icon-Name vorhanden ist, ruft `self.desktop_file_service.get_application_icon_path(icon_name, size).await?` auf.
            * Gibt das Ergebnis zurück.
            * **Fehlerbehandlung:** Propagiert Fehler vom `desktop_file_service`.

        * **`get_application_name(&self, desktop_entry_id: &str, locale: Option<&str>) -> Result<String, ApplicationLauncherError>`:**
            * Ruft `self.desktop_file_service.get_application_by_id(desktop_entry_id).await?` auf.
            * Wenn gefunden, ruft `desktop_entry.get_localized_name(locale)` auf.
            * Gibt den Namen zurück.
            * **Fehlerbehandlung:** Propagiert Fehler vom `desktop_file_service`.

        * **`on_application_closed(&self) -> impl Stream<Item = ApplicationHandle> + Send + Sync`:**
            * Gibt einen `tokio_stream::wrappers::UnboundedReceiverStream` über den Empfänger des `app_closed_sender` zurück.
            * Stelle sicher, dass der Sender geklont wird, damit er in der Überwachungstask verwendet werden kann.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/application_launcher/service.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::application_launcher::data_types::{ApplicationLaunchOptions, ApplicationHandle}`
        * `crate::application_launcher::errors::ApplicationLauncherError`
        * `crate::application_launcher::service_iface::ApplicationLauncherService`
        * `crate::desktop_file::service_iface::DesktopFileService`
        * `crate::desktop_file::data_types::DesktopEntryType` (für Prüfung des Typs)
    * **Extern:** `async_trait::async_trait`, `tokio`, `tokio::process`, `tokio::fs`, `tokio::io`, `tokio::sync::{mpsc, RwLock}`, `futures::Stream`, `tokio_stream::wrappers::UnboundedReceiverStream`, `std::path::PathBuf`, `std::collections::HashMap`, `std::sync::Arc`, `chrono::Utc`, `tracing`.
* **Kommunikationsmuster:** Wird von UI-Komponenten (z.B. Anwendungsstarter, Dock) verwendet. Interagiert mit dem `DesktopFileService`.
* **Erwartete Ergebnisse/Outputs:** Ein robuster und funktionsfähiger Anwendungsstarter, der Anwendungen korrekt startet, deren Lebenszyklen verfolgt und Informationen bereitstellt.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests (mit Mocks und temporären Dateien/Prozessen):**
        * **Mocking:** Mock `DesktopFileService` um kontrollierte `DesktopEntry`-Informationen zu liefern.
        * **Simulierte Prozesse:** Verwende einfache ausführbare Skripte (z.B. Python oder Shell-Skripte), die für Tests gestartet werden können und sich nach einer bestimmten Zeit beenden oder einen Exit-Code zurückgeben.
        * Testen von `launch_application`:
            * Starten einer gültigen Anwendung mit Standardoptionen.
            * Starten mit zusätzlichen Argumenten.
            * Starten mit spezifischem Arbeitsverzeichnis.
            * Testen des `Exec`-Feldes mit verschiedenen Platzhaltern (`%f`, `%F`, `%c`, `%k`) und Argumenten.
            * Fehlerfälle: Anwendung nicht gefunden, Befehl nicht ausführbar, I/O-Fehler beim Start.
            * Testen des Terminal-Starts (prüfen, ob der Terminal-Emulator aufgerufen wird).
            * Überprüfen, ob das `ApplicationHandle` korrekt erstellt wird.
            * Testen der Prozessüberwachung (Anwendung startet und beendet sich, `on_application_closed` wird ausgelöst).
        * Testen von `launch_command`:
            * Starten eines einfachen Shell-Befehls.
            * Fehlerfälle (Befehl nicht gefunden).
        * Testen von `kill_application`:
            * Erfolgreiches Beenden eines laufenden Prozesses (SIGTERM, dann SIGKILL).
            * Versuch, einen nicht existierenden Prozess zu beenden.
            * Versuch, einen bereits beendeten Prozess zu beenden.
        * Testen von `get_running_applications`:
            * Initial leer.
            * Enthält korrekt gestartete Anwendungen.
            * Entfernt beendete Anwendungen.
        * Testen von `get_application_icon_path` und `get_application_name` (Abdeckung der Delegation an `DesktopFileService`).
        * Testen des `on_application_closed` Streams: Sicherstellen, dass die `ApplicationHandle`s korrekt gesendet werden, wenn Prozesse beendet werden.
    * **Integration Tests:**
        * End-to-End-Tests mit dem echten `DesktopFileService`.
        * Starten bekannter Systemanwendungen und Beobachten ihres Verhaltens (z.B. `firefox`, `gnome-terminal`).

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (59 von 100) widmet sich der Initialisierung des `novade-domain/src/shell/mod.rs` Moduls. Dieses Modul wird die Funktionalität kapseln, die für die Interaktion mit der Shell-Umgebung und den grundlegenden Desktop-Operationen erforderlich ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 59/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.24. `novade-domain/src/shell` Verzeichnis

Dieses Verzeichnis ist für die Kern-Shell-Operationen des Desktops zuständig, wie das Herunterfahren des Systems, das Abmelden, das Öffnen von URLs, das Verwalten von Standardanwendungen und die Interaktion mit dem Dateisystem. Es ist die zentrale Schnittstelle für viele Aktionen, die direkt vom Benutzer oder von anderen Komponenten angefordert werden können.

#### 3.24.1. `novade-domain/src/shell/mod.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/shell/mod.rs`
* **Verantwortlichkeit:** Definiert die öffentliche API des `shell`-Moduls der Domänenschicht. Es re-exportiert alle wichtigen Typen, Traits, Enums und Strukturen, die von der UI-Schicht (z.B. für Power-Menüs, Dateibrowser-Integration, Standardanwendungen) oder anderen Diensten der Domänenschicht benötigt werden, um systemnahe Aktionen auszuführen oder Informationen über die Shell-Umgebung abzurufen.
* **Kern-Aufgaben (Tasks):**
    1.  **Public API Definition:** Re-exportiere die folgenden Komponenten, die die Schnittstelle dieses Moduls bilden:
        * `data_types` (alle relevanten Typen wie `PowerAction`).
        * `errors` (das `ShellError` Enum).
        * `service_iface` (den `ShellService` Trait).
        * `service` (die konkrete `DefaultShellService` Implementierung).
    2.  **Modul-Strukturierung:** Sicherstellen, dass alle Re-Exporte korrekt sind und keine internen Implementierungsdetails unnötigerweise exponiert werden.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/shell/mod.rs`
* **Abhängigkeiten:**
    * **Intern:** `data_types`, `errors`, `service_iface`, `service` (innerhalb desselben `shell` Moduls).
    * **Extern:** Keine direkten, da nur Re-Exporte stattfinden.
* **Kommunikationsmuster:** Stellt die Hauptschnittstelle des `shell`-Moduls zur Verfügung. Es ist der primäre Punkt, über den die UI-Schicht Systemaktionen anfordert und grundlegende Shell-Informationen abruft.
* **Erwartete Ergebnisse/Outputs:** Eine klar definierte und leicht nutzbare öffentliche API für die Interaktion mit der Shell-Umgebung innerhalb der Domänenschicht, die konsistente Interaktionen über alle Schichten hinweg ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte sind. Die Tests erfolgen in den jeweiligen Submodulen.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (60 von 100) widmet sich der Implementierung der grundlegenden Datentypen für das Shell-Modul in `novade-domain/src/shell/data_types.rs`. Diese Strukturen sind entscheidend, um die verschiedenen Shell-Aktionen und deren Optionen zu repräsentieren.

-----

# Ultimativer Implementierungsplan für NovaDE (Teil 60/100)

## 3\. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.24.2. `novade-domain/src/shell/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/shell/data_types.rs`

  * **Verantwortlichkeit:** Definiert die Datenstrukturen, die die verschiedenen Systemaktionen (z.B. Herunterfahren, Neustart) und Optionen für Shell-Operationen repräsentieren. Diese Typen sind die Schnittstelle zwischen dem Aufrufer des Dienstes (z.B. UI) und der tatsächlichen Ausführung von Systembefehlen oder D-Bus-Aufrufen.

  * **Kern-Aufgaben (Tasks):**

    1.  **`PowerAction` Enum definieren:**

          * Repräsentiert die möglichen Aktionen, die mit der Energieverwaltung des Systems zusammenhängen.
          * Varianten:
              * `Shutdown`: Das System herunterfahren.
              * `Reboot`: Das System neu starten.
              * `Suspend`: Das System in den Ruhezustand versetzen (RAM).
              * `Hibernate`: Das System in den Standby-Modus versetzen (Disk).
              * `Logout`: Den aktuellen Benutzer abmelden.
              * `LockScreen`: Den Bildschirm sperren.
          * Implementiere: `PartialEq`, `Eq`, `Hash`, `Clone`, `Copy`, `Debug`, `Serialize`, `Deserialize`, `Display`.
          * Implementiere `From<&str>` und `From<String>` für einfache Konvertierung von String-Darstellungen.

        <!-- end list -->

        ```rust
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PowerAction {
            Shutdown,
            Reboot,
            Suspend,
            Hibernate,
            Logout,
            LockScreen,
        }

        impl std::fmt::Display for PowerAction {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                match self {
                    PowerAction::Shutdown => write!(f, "Shutdown"),
                    PowerAction::Reboot => write!(f, "Reboot"),
                    PowerAction::Suspend => write!(f, "Suspend"),
                    PowerAction::Hibernate => write!(f, "Hibernate"),
                    PowerAction::Logout => write!(f, "Logout"),
                    PowerAction::LockScreen => write!(f, "Lock Screen"),
                }
            }
        }

        impl From<&str> for PowerAction {
            fn from(s: &str) -> Self {
                match s.to_lowercase().as_str() {
                    "shutdown" => PowerAction::Shutdown,
                    "reboot" => PowerAction::Reboot,
                    "suspend" => PowerAction::Suspend,
                    "hibernate" => PowerAction::Hibernate,
                    "logout" => PowerAction::Logout,
                    "lockscreen" | "lock_screen" => PowerAction::LockScreen,
                    _ => panic!("Invalid PowerAction string: {}", s), // Should be handled upstream by validation
                }
            }
        }

        impl From<String> for PowerAction {
            fn from(s: String) -> Self {
                PowerAction::from(s.as_str())
            }
        }
        ```

    2.  **`OpenFlags` Struct definieren:**

          * Repräsentiert Optionen für das Öffnen von Dateien oder URLs (z.B. mit `xdg-open`).
          * Felder:
              * `new_window: bool`: Wenn `true`, versuche, in einem neuen Fenster zu öffnen.
              * `as_app: Option<String>`: Optionaler Name der Anwendung, mit der geöffnet werden soll (z.B. "firefox").
          * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Eq`, `Hash`.
          * Implementiere `new()`-Funktion für die Basis-Instanziierung.

  * **Spezifische Artefakte/Dateien:**

      * `novade-domain/src/shell/data_types.rs`

  * **Abhängigkeiten:**

      * **Extern:** `serde::{Serialize, Deserialize}`, `std::collections::HashMap` (nicht direkt hier, aber für andere Datenstrukturen im Modul relevant), `std::path::PathBuf` (nicht direkt hier, aber für andere Datenstrukturen im Modul relevant).

  * **Kommunikationsmuster:**

      * `PowerAction` wird als Parameter an den `ShellService` übergeben.
      * `OpenFlags` wird als Parameter an den `ShellService` übergeben.

  * **Erwartete Ergebnisse/Outputs:** Klare und flexible Datenmodelle, die die verschiedenen Systemaktionen und die Optionen für das Öffnen von Ressourcen repräsentieren.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * Testen der Serialisierung und Deserialisierung des `PowerAction` Enums.
          * Testen der `From<&str>` und `From<String>` Implementierungen für `PowerAction` (mit gültigen und ungültigen Strings, die Panikfälle sind).
          * Testen der `Display` Implementierung für `PowerAction`.
          * Testen der `Default` Implementierung für `OpenFlags`.
          * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` Implementierungen für beide Typen.
          * Sicherstellen, dass alle Felder in `OpenFlags` korrekt initialisiert und gesetzt werden können.


-----

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (61 von 100) widmet sich der Implementierung der Fehlerdefinitionen für das Shell-Modul in `novade-domain/src/shell/errors.rs`. Eine präzise Fehlerbehandlung ist entscheidend für die Stabilität von Systemaktionen und die Interaktion mit der Shell-Umgebung.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 61/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.24.3. `novade-domain/src/shell/errors.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/shell/errors.rs`
* **Verantwortlichkeit:** Definiert ein konsolidiertes Fehler-Enum (`ShellError`) für alle Operationen, die innerhalb des `shell`-Moduls der Domänenschicht auftreten können. Dieses Enum kapselt spezifische Fehlerquellen wie das Fehlschlagen von Systembefehlen (Herunterfahren, Neustart), Probleme beim Öffnen von URLs oder Dateien, oder fehlende Berechtigungen. Die Nutzung von `thiserror` ist obligatorisch.
* **Kern-Aufgaben (Tasks):**
    1.  **`ShellError` Enum definieren:**
        * Nutze `#[derive(thiserror::Error, Debug)]` für automatische Implementierung der `Error` und `Debug` Traits.
        * Varianten:
            * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler, z.B. beim Ausführen von externen Befehlen.
                * `#[error("I/O error during shell operation: {0}")]`
            * `CommandExecutionFailed { command: String, exit_code: Option<i32>, stderr: String }`: Wenn ein externer Befehl gestartet wurde, aber mit einem Fehler-Exit-Code beendet wird. `command` für den Kontext, `exit_code` für den Exit-Code des Prozesses (falls verfügbar), `stderr` für die Standardfehlerausgabe des Befehls.
                * `#[error("Shell command '{command}' failed with exit code {exit_code:?}. Stderr: {stderr}")]`
            * `PermissionDenied(String)`: Wenn NovaDE nicht die notwendigen Berechtigungen hat, um eine Operation auszuführen (z.B. Herunterfahren ohne ausreichende Rechte).
                * `#[error("Permission denied for shell operation: {0}")]`
            * `NotFound(String)`: Wenn eine Ressource (z.B. ein Programm zum Öffnen einer Datei oder URL) nicht gefunden werden kann.
                * `#[error("Resource not found: {0}")]`
            * `UnsupportedOperation(String)`: Wenn eine angeforderte Shell-Operation auf dem aktuellen System nicht unterstützt wird (z.B. Hibernate auf einem System ohne Swap-Partition).
                * `#[error("Unsupported shell operation: {0}")]`
            * `ConfigServiceError(#[from] novade_core::error::ConfigError)`: Fehler, die vom `ConfigService` stammen (z.B. bei der Ermittlung von Standardanwendungen).
                * `#[error("Configuration service error: {0}")]`
            * `DbusError(String)`: Fehler, die bei der Interaktion mit D-Bus-Diensten auftreten (z.B. `logind` für Power-Operationen, oder `xdg-desktop-portal` für `xdg-open` Funktionalität).
                * `#[error("D-Bus interaction error: {0}")]`
            * `Other(String)`: Ein Catch-All für unvorhergesehene oder nicht spezifisch handhabbare Fehler.
                * `#[error("An unexpected shell error occurred: {0}")]`
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/shell/errors.rs`
* **Abhängigkeiten:**
    * **Intern:** `novade_core::error::ConfigError` (für `#[from]`)
    * **Extern:** `thiserror::Error`, `std::io::Error`.
* **Kommunikationsmuster:**
    * Wird als `E` (Fehler-Typ) in `Result<T, E>` Signaturen aller öffentlichen Funktionen und Methoden des `shell`-Moduls verwendet (z.B. `ShellService`).
    * Sollte von `std::io::Error` und `novade_core::error::ConfigError` Fehlertypen erhalten und in die eigene Variante konvertieren (`#[from]`).
    * Wird von der UI-Schicht oder anderen Diensten empfangen und dort in ein übergeordnetes Fehler-Enum gekapselt oder direkt behandelt.
* **Erwartete Ergebnisse/Outputs:** Ein klar strukturiertes und wartbares Fehler-Enum, das alle denkbaren Fehlerzustände im Shell-Modul abdeckt und eine konsistente Fehlerbehandlung ermöglicht.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der Instanziierung jeder Fehlervariante mit aussagekräftigen Daten (z.B. Befehle, Fehlermeldungen, Exit-Codes).
        * Testen der `#[from]`-Konvertierungen von `std::io::Error` und `novade_core::error::ConfigError`.
        * Testen der `Display`-Implementierung (via `to_string()`) für jede Fehlervariante, um sicherzustellen, dass die Fehlermeldungen korrekt und informativ sind.
        * Testen der `source()`-Kette, um sicherzustellen, dass die Ursprungsfehler bei der Konvertierung beibehalten werden.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (62 von 100) widmet sich der Implementierung des `novade-domain/src/shell/service_iface.rs` Moduls. Dieses Modul definiert den Vertrag für den Dienst, der für die Ausführung systemnaher Aktionen und die Interaktion mit der Desktop-Umgebung zuständig ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 62/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.24.4. `novade-domain/src/shell/service_iface.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/shell/service_iface.rs`
* **Verantwortlichkeit:** Definiert den `ShellService` Trait. Dieser Trait ist die primäre Schnittstelle für alle Komponenten innerhalb und außerhalb der Domänenschicht, die grundlegende Systemaktionen wie Herunterfahren, Neustart, Abmelden, Sperren des Bildschirms oder das Öffnen von Dateien/URLs anfordern müssen. Er abstrahiert die zugrunde liegende Logik der Interaktion mit Systemdiensten (z.B. `systemd-logind` über D-Bus) oder der Ausführung von Shell-Befehlen (`xdg-open`). Alle Methoden sind asynchron.
* **Kern-Aufgaben (Tasks):**
    1.  **`ShellService` Trait definieren:**
        * Nutze `#[async_trait]` für alle Methoden.
        * Alle Methoden geben `Result<(), ShellError>` oder `Result<T, ShellError>` zurück, um eine konsistente Fehlerbehandlung zu gewährleisten.
        * **Methoden:**
            * `initialize(&self) -> Result<(), ShellError>`:
                * Initialisiert den Dienst und prüft die Verfügbarkeit notwendiger Systemdienste (z.B. D-Bus-Verbindung zu `logind` oder `xdg-desktop-portal`).
                * Sollte idempotent sein.
                * **Fehlerbehandlung:** `ShellError::DbusError`, `ShellError::IoError`, `ShellError::UnsupportedOperation`.
            * `execute_power_action(&self, action: PowerAction) -> Result<(), ShellError>`:
                * Führt eine der in `PowerAction` definierten Systemaktionen aus.
                * **Logik:**
                    * `Shutdown`, `Reboot`, `Suspend`, `Hibernate`, `Logout`: Sollte primär über D-Bus und `org.freedesktop.login1` (Systemd-logind) erfolgen. Wenn D-Bus nicht verfügbar oder fehlschlägt, kann ein Fallback auf Systembefehle wie `sudo systemctl poweroff` oder `sudo shutdown -h now` in Betracht gezogen werden, aber dies erfordert in der Regel `sudo`-Rechte oder spezifische Konfigurationen. **Entscheidung:** Für die erste Implementierung wird der Fokus auf D-Bus und `systemd-logind` gelegt. Ein Fallback auf direkte Befehle wird nur in Ausnahmefällen oder für zukünftige Erweiterungen in Betracht gezogen, da D-Bus der bevorzugte Weg ist und Berechtigungsprobleme minimiert.
                    * `LockScreen`: Sollte versuchen, einen Bildschirmsperrer über D-Bus aufzurufen (z.B. `org.freedesktop.ScreenSaver` für einen GNOME/KDE-konformen Sperrer) oder einen Befehl wie `xdg-screensaver lock` ausführen. Wenn keine Standardmethode gefunden wird, kann ein Fallback auf `gnome-screensaver-command -l` oder `kde-inhibit --activate-screensaver` erfolgen. **Entscheidung:** Der primäre Weg ist `xdg-screensaver lock` als generischer Befehl.
                * **Fehlerbehandlung:** `ShellError::DbusError`, `ShellError::CommandExecutionFailed`, `ShellError::PermissionDenied`, `ShellError::UnsupportedOperation`.
            * `open_uri(&self, uri: &str, options: OpenFlags) -> Result<(), ShellError>`:
                * Öffnet eine URI (z.B. `http://example.com`, `file:///path/to/file.txt`) mit der Standardanwendung oder einer spezifischen Anwendung.
                * **Logik:**
                    * Sollte idealerweise `xdg-open` verwenden, da dies der Standard-Freedesktop-Weg ist.
                    * Die `options` (z.B. `new_window`, `as_app`) müssen in die `xdg-open`-Befehlszeilenargumente übersetzt werden. **Entscheidung:** `xdg-open` unterstützt keine direkten "neues Fenster" Flags. Dies ist eher eine App-spezifische Option. Das `new_window` Flag in `OpenFlags` wird ignoriert für `xdg-open`. `as_app` könnte als Argument an `xdg-open` übergeben werden, falls es eine solche Option gibt oder als Fallback auf einen direkten Start der App versucht wird. **Entscheidung:** Für `as_app` wird versucht, `application_launcher_service.launch_application(as_app, options.args_for_uri)` aufzurufen.
                * **Fehlerbehandlung:** `ShellError::CommandExecutionFailed`, `ShellError::NotFound`, `ShellError::IoError`.
            * `open_file(&self, path: &Path, options: OpenFlags) -> Result<(), ShellError>`:
                * Öffnet eine Datei mit der Standardanwendung oder einer spezifischen Anwendung.
                * **Logik:** Analog zu `open_uri`, konvertiert den `Path` in eine `file://` URI und ruft dann `open_uri` auf.
                * **Fehlerbehandlung:** `ShellError::CommandExecutionFailed`, `ShellError::NotFound`, `ShellError::IoError`, `ShellError::PermissionDenied` (wenn Datei nicht lesbar).
            * `show_in_file_manager(&self, path: &Path) -> Result<(), ShellError>`:
                * Öffnet den Dateimanager und navigiert zum angegebenen Pfad, ggf. markiert die Datei.
                * **Logik:** Typischerweise über `xdg-open` mit einem Verzeichnis-Pfad oder einem spezifischen Befehl für den Standard-Dateimanager (`nautilus --select`, `dolphin --select`). **Entscheidung:** Für die erste Version wird `xdg-open <path>` versucht. Wenn der Pfad eine Datei ist, wird `xdg-open` normalerweise den Dateimanager mit der Datei öffnen.
                * **Fehlerbehandlung:** `ShellError::CommandExecutionFailed`, `ShellError::NotFound`, `ShellError::IoError`.
            * `set_wallpaper(&self, image_path: &Path, mode: WallpaperMode) -> Result<(), ShellError>`:
                * Setzt das Hintergrundbild des Desktops.
                * **Logik:** Dies ist stark Desktop-Umgebungs-abhängig. Es gibt keine standardisierte XDG-Methode.
                    * **Entscheidung:** Für NovaDE wird dies über eine interne Einstellungsänderung oder eine D-Bus-Methode des NovaDE Compositors/Shell-Komponente implementiert. Die Implementierung in `DefaultShellService` wird einen D-Bus-Aufruf an den `nova-shell-service` oder eine ähnliche Komponente machen. `WallpaperMode` Enum (Fit, Stretch, Center, Tile) wird hier benötigt.
                * **Fehlerbehandlung:** `ShellError::DbusError`, `ShellError::PermissionDenied`, `ShellError::UnsupportedOperation` (falls der Compositor die Einstellung nicht unterstützt).
            * `get_default_application(&self, mime_type: &str) -> Result<Option<DesktopEntry>, ShellError>`:
                * Ermittelt die Standardanwendung für einen gegebenen MIME-Typ.
                * **Logik:** Sollte die XDG Shared Mime-info Specification und die Desktop Entry Specification berücksichtigen (z.B. über `.desktop` Dateien in `mimeapps.list`). Dies ist komplex und erfordert die Interaktion mit dem `DesktopFileService` und möglicherweise den `ConfigService` für die Konfigurationsdateien.
                * **Fehlerbehandlung:** `ShellError::ConfigServiceError`, `ShellError::DesktopFileError`, `ShellError::IoError`.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/shell/service_iface.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::shell::data_types::{PowerAction, OpenFlags, WallpaperMode}` (WallpaperMode muss definiert werden)
        * `crate::shell::errors::ShellError`
        * `crate::desktop_file::data_types::DesktopEntry`
    * **Extern:** `async_trait::async_trait`, `std::path::Path`, `std::path::PathBuf`, `url::Url` (für URI-Verarbeitung).
* **Kommunikationsmuster:**
    * Dieser Trait wird von konkreten Dienstimplementierungen (z.B. `DefaultShellService`) implementiert.
    * Die UI-Schicht (z.B. Power-Menü, Dateibrowser, Einstellungsdialoge) wird diesen Trait nutzen, um Systemaktionen auszuführen und Informationen abzurufen.
* **Erwartete Ergebnisse/Outputs:** Eine robuste und umfassende Schnittstelle für grundlegende Shell-Operationen, die eine flexible Interaktion mit dem System ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine direkten Tests für diesen Trait, da er nur eine Definition ist. Die Tests erfolgen für die konkreten Implementierungen (`DefaultShellService`).

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (63 von 100) widmet sich der Implementierung des `novade-domain/src/shell/service.rs` Moduls. Dies ist die konkrete Implementierung des `ShellService`-Traits und bildet die zentrale Komponente für die Ausführung systemnaher Aktionen im NovaDE.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 63/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.24.5. `novade-domain/src/shell/service.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/shell/service.rs`
* **Verantwortlichkeit:** Implementiert den `ShellService`-Trait. Dieser Dienst ist verantwortlich für die Ausführung von Systembefehlen (Herunterfahren, Neustart, Abmelden, Bildschirmsperre) und das Öffnen von Dateien/URLs mit Standardanwendungen. Er interagiert direkt mit dem Betriebssystem über externe Befehle oder D-Bus und delegiert gegebenenfalls an den `ApplicationLauncherService`.
* **Kern-Aufgaben (Tasks):**
    1.  **`DefaultShellService` Struct definieren:**
        * **Felder:**
            * `application_launcher_service: Arc<dyn ApplicationLauncherService + Send + Sync>`: Referenz zum Anwendungsstarter-Dienst, um Anwendungen zu starten (z.B. für `open_uri`/`open_file` mit `as_app`).
            * `config_service: Arc<dyn ConfigServiceAsync + Send + Sync>`: Für die Abfrage von Konfigurationsinformationen (z.B. Standard-Terminal-Emulator, D-Bus-Pfade).
            * `_dbus_connection: Option<zbus::Connection>`: Optionale D-Bus-System-Bus-Verbindung für `logind` und andere Systemdienste. Muss lazily initialisiert oder im `new` blockiert werden.
            * `dbus_proxy_logind: Option<zbus::Proxy<'static>>`: Proxy für `org.freedesktop.login1`.

    2.  **Konstruktor `new()` implementieren:**
        * Akzeptiert `application_launcher_service: Arc<dyn ApplicationLauncherService + Send + Sync>` und `config_service: Arc<dyn ConfigServiceAsync + Send + Sync>`.
        * Initialisiert `_dbus_connection` und `dbus_proxy_logind` als `None`. Die D-Bus-Verbindung wird in `initialize()` hergestellt.
        * Gibt das `DefaultShellService` Struct zurück.

    3.  **Implementierung des `ShellService`-Traits für `DefaultShellService`:**

        * **`initialize(&self) -> Result<(), ShellError>`:**
            * Versucht, eine D-Bus-System-Bus-Verbindung herzustellen (`zbus::Connection::system().await`).
                * Bei Erfolg, speichert die Verbindung in `self._dbus_connection`.
                * Erstellt einen `zbus::Proxy` für `org.freedesktop.login1` Interface auf dem `/org/freedesktop/login1` Pfad. Speichert diesen in `self.dbus_proxy_logind`.
            * Wenn die D-Bus-Verbindung fehlschlägt, logge dies, aber setze die Initialisierung fort (D-Bus-Funktionalität ist dann eingeschränkt).
            * **Fehlerbehandlung:** Wrap `zbus::Error` in `ShellError::DbusError`.
            * Loggt den Initialisierungsstatus mit `tracing`.

        * **`execute_power_action(&self, action: PowerAction) -> Result<(), ShellError>`:**
            * **Logik nach `action`:**
                * **`Shutdown`, `Reboot`, `Suspend`, `Hibernate`:**
                    * Versuche, über den `dbus_proxy_logind` zu interagieren:
                        * Rufe die entsprechende Methode auf (z.B. `power_off`, `reboot`, `suspend`, `hibernate`) auf dem `org.freedesktop.login1.Manager` Interface. Die Methoden akzeptieren einen `bool` für "interactive" (false für Non-Interactive).
                        * **Fehlerbehandlung:** Wenn D-Bus fehlschlägt oder nicht verfügbar ist:
                            * Logge den Fehler.
                            * **Fallback (optional, für Robustheit, aber nicht empfohlen für den ersten Wurf):** Versuche, `sudo systemctl poweroff` oder `sudo systemctl reboot` etc. auszuführen. Dies erfordert `sudo` oder spezielle `polkit` Regeln, die außerhalb des NovaDE-Bereichs liegen. **Entscheidung:** Für die erste Implementierung wird nur der D-Bus-Weg verfolgt. Wenn D-Bus fehlschlägt, wird ein `ShellError::DbusError` zurückgegeben.
                * **`Logout`:**
                    * **Logik:** Rufe `org.freedesktop.login1.Session.Terminate()` oder `org.freedesktop.login1.Session.Kill()` über D-Bus auf der aktuellen Session auf, oder verwende `loginctl terminate-session <session_id>`. Die Session-ID muss ermittelt werden (z.B. über Umgebungsvariablen wie `XDG_SESSION_ID`). **Entscheidung:** Versuche, `loginctl terminate-session self` auszuführen. Dies ist ein externer Befehl, der die aktuelle Session beenden sollte.
                    * **Fehlerbehandlung:** `ShellError::CommandExecutionFailed`, `ShellError::DbusError`.
                * **`LockScreen`:**
                    * **Logik:** Versuche, den Befehl `xdg-screensaver lock` auszuführen.
                    * **Fehlerbehandlung:** `ShellError::CommandExecutionFailed`, `ShellError::NotFound`.
            * **Allgemeine Fehlerbehandlung:** Kapsle alle `zbus::Error` oder `std::io::Error` in `ShellError` Varianten.

        * **`open_uri(&self, uri: &str, options: OpenFlags) -> Result<(), ShellError>`:**
            * **Logik:**
                * Wenn `options.as_app` gesetzt ist:
                    * Versuche, `self.application_launcher_service.launch_application(options.as_app.unwrap(), args_for_uri).await?` aufzurufen. `args_for_uri` müsste hier den URI als Argument übergeben.
                * Andernfalls (Standardanwendung):
                    * Führe den externen Befehl `xdg-open {uri}` aus.
                    * **Implementierung `_execute_command`:** Verwende `tokio::process::Command` um den Befehl auszuführen. Warte nicht auf den Exit-Code des Kindprozesses, da dies ein "fire and forget" ist.
            * **Fehlerbehandlung:** `ShellError::CommandExecutionFailed`, `ShellError::NotFound`, `ShellError::IoError`, `ShellError::ApplicationLauncherError`.

        * **`open_file(&self, path: &Path, options: OpenFlags) -> Result<(), ShellError>`:**
            * Konvertiere `path` zu einer URI (`file://` Schema).
            * Rufe `self.open_uri(uri.as_str(), options).await` auf.

        * **`show_in_file_manager(&self, path: &Path) -> Result<(), ShellError>`:**
            * Führe den externen Befehl `xdg-open {path.to_string_lossy()}` aus.
            * **Fehlerbehandlung:** `ShellError::CommandExecutionFailed`, `ShellError::NotFound`, `ShellError::IoError`.

        * **`set_wallpaper(&self, image_path: &Path, mode: WallpaperMode) -> Result<(), ShellError>`:**
            * **Logik:** Dies ist der spezifischste Teil für NovaDE. Es muss einen D-Bus-Aufruf an den **NovaDE Compositor/Shell-Service** tätigen.
                * Definiere einen D-Bus-Pfad und ein Interface für den NovaDE Shell-Service (z.B. `/org/novade/Shell`, `org.novade.Shell.Manager`).
                * Rufe eine Methode wie `SetWallpaper(String image_path, String mode_enum_string)` auf diesem Interface auf.
                * **Anforderung an den Compositor:** Der Compositor (oder eine andere Kern-Shell-Komponente) muss dieses D-Bus-Interface implementieren und das Hintergrundbild tatsächlich setzen können.
            * **Fehlerbehandlung:** `ShellError::DbusError`, `ShellError::PermissionDenied`, `ShellError::UnsupportedOperation`.

        * **`get_default_application(&self, mime_type: &str) -> Result<Option<DesktopEntry>, ShellError>`:**
            * **Logik:** Dies ist komplex und erfordert die Auswertung von XDG-Spezifikationen.
                * **Schritt 1: MIME-Typ-Datenbank prüfen.** Rufe den Pfad zu der `mimeapps.list` und anderen relevanten Dateien über den `ConfigService` ab.
                * **Schritt 2: `mimeapps.list` parsen.** Lese und parse die `~/.config/mimeapps.list` (oder `XDG_CONFIG_HOME/mimeapps.list`) und `/usr/share/applications/mimeapps.list` Dateien. Diese enthalten `[Default Applications]` und `[Added Associations]` Sektionen, die Dateitypen zu Desktop-Dateien mappen.
                * **Schritt 3: `DesktopEntry` abrufen.** Wenn ein Desktop-Entry-ID gefunden wird, rufe `self.application_launcher_service.get_desktop_file_service().get_application_by_id(desktop_entry_id).await?` auf.
                * **Fallback:** Wenn in `mimeapps.list` nichts gefunden wird, könnte man den Befehl `xdg-mime query default {mime_type}` ausführen, um den Standard-Desktop-Entry-Namen zu erhalten, und diesen dann über den `DesktopFileService` abrufen.
            * **Fehlerbehandlung:** `ShellError::ConfigServiceError`, `ShellError::DesktopFileError`, `ShellError::IoError`, `ShellError::CommandExecutionFailed`.

    4.  **Private Hilfsmethode `_execute_command(command: &str, args: &[&str]) -> Result<(), ShellError>` oder `_execute_command_output(...) -> Result<std::process::Output, ShellError>` implementieren:**
        * Wrapper für `tokio::process::Command::new(command).args(args).spawn()`.
        * Kann optional `wait_with_output()` aufrufen, um den Exit-Code und stderr zu prüfen.
        * **Fehlerbehandlung:** Konvertiert `std::io::Error` in `ShellError::IoError` oder `ShellError::CommandExecutionFailed`.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/shell/service.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::shell::data_types::{PowerAction, OpenFlags}`
        * `crate::shell::errors::ShellError`
        * `crate::shell::service_iface::ShellService`
        * `crate::application_launcher::service_iface::ApplicationLauncherService`
        * `novade_core::config::ConfigServiceAsync`
        * `crate::desktop_file::data_types::DesktopEntry` (wenn `get_default_application` direkt DesktopEntry zurückgibt)
    * **Extern:** `async_trait::async_trait`, `tokio`, `tokio::process`, `tokio::fs`, `zbus`, `std::path::Path`, `std::path::PathBuf`, `std::sync::Arc`, `tracing`, `url`.
* **Kommunikationsmuster:** Wird von UI-Komponenten (z.B. Power-Menü, Dateimanager) verwendet. Interagiert mit `ApplicationLauncherService` und `ConfigService`.
* **Erwartete Ergebnisse/Outputs:** Ein robuster und funktionsfähiger Shell-Dienst, der grundlegende Systemaktionen ausführen und die Interaktion mit Dateien/URLs handhaben kann.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests (mit Mocks):**
        * **Mocking:** Mock `ApplicationLauncherService` und `ConfigService` um deren Verhalten zu kontrollieren. Mock `zbus` oder erstelle ein Dummy-D-Bus-Server für Power-Action Tests.
        * Testen von `execute_power_action`:
            * Erfolgreiche Ausführung von Shutdown/Reboot/Suspend/Hibernate über D-Bus (simuliert).
            * Fehlerfälle: D-Bus nicht verfügbar, Berechtigungsprobleme (simulierte Fehlerantwort von D-Bus).
            * Testen von Logout und LockScreen über `xdg-screensaver` oder `loginctl` (simulierte Befehle).
        * Testen von `open_uri` und `open_file`:
            * Erfolgreiches Öffnen mit `xdg-open` (simulierter Befehl).
            * Öffnen mit spezifischer Anwendung (`as_app`), die an `ApplicationLauncherService` delegiert wird.
            * Fehlerfälle: Befehl nicht gefunden, Datei/URI ungültig.
        * Testen von `show_in_file_manager`:
            * Erfolgreiches Aufrufen von `xdg-open` (simulierter Befehl).
        * Testen von `set_wallpaper`:
            * Erfolgreicher D-Bus-Aufruf an den NovaDE Compositor (simuliert).
            * Fehlerfälle: D-Bus-Fehler, fehlende Berechtigungen.
        * Testen von `get_default_application`:
            * Parsing einer simulierten `mimeapps.list`.
            * Delegation an `DesktopFileService`.
            * Fallback auf `xdg-mime` (simuliert).
    * **Integration Tests:**
        * End-to-End-Tests mit echten Systembefehlen, aber mit Vorsicht (z.B. keine tatsächlichen Reboots/Shutdowns in automatisierten Tests, es sei denn, es gibt eine spezielle Testumgebung).
        * Starten einfacher Testskripte, die `xdg-open` und ähnliches simulieren.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (64 von 100) widmet sich der Initialisierung des `novade-domain/src/system_monitor/mod.rs` Moduls. Dieses Modul wird die Funktionalität kapseln, die für das Abrufen und Überwachen von Systemressourcen (CPU, Speicher, Netzwerk, Festplatte) erforderlich ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 64/100)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.25. `novade-domain/src/system_monitor` Verzeichnis

Dieses Verzeichnis ist für die Erfassung und Bereitstellung von Systemmetriken zuständig. Es ermöglicht anderen NovaDE-Komponenten (z.B. Widgets, Systemtray-Anzeigen oder Backend-Diensten für Protokollierung) den Zugriff auf aktuelle Informationen über die Ressourcenauslastung des Systems. Die Implementierung muss plattformübergreifend erfolgen, idealerweise unter Verwendung von Bibliotheken, die dies abstrahieren, oder durch direkte Interaktion mit `/proc` und anderen System-APIs.

#### 3.25.1. `novade-domain/src/system_monitor/mod.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/system_monitor/mod.rs`
* **Verantwortlichkeit:** Definiert die öffentliche API des `system_monitor`-Moduls der Domänenschicht. Es re-exportiert alle wichtigen Typen, Traits, Enums und Strukturen, die von der UI-Schicht (z.B. für System-Monitore, Widgets) oder anderen Diensten der Domänenschicht benötigt werden, um Systemmetriken abzurufen und zu überwachen.
* **Kern-Aufgaben (Tasks):**
    1.  **Public API Definition:** Re-exportiere die folgenden Komponenten, die die Schnittstelle dieses Moduls bilden:
        * `data_types` (alle relevanten Typen wie `CpuUsage`, `MemoryInfo`, `NetworkUsage`, `DiskInfo`, `ProcessInfo`, `SystemInfo`).
        * `errors` (das `SystemMonitorError` Enum).
        * `service_iface` (den `SystemMonitorService` Trait).
        * `service` (die konkrete `DefaultSystemMonitorService` Implementierung).
    2.  **Modul-Strukturierung:** Stelle sicher, dass alle Re-Exporte korrekt sind und keine internen Implementierungsdetails unnötigerweise exponiert werden.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/system_monitor/mod.rs`
* **Abhängigkeiten:**
    * **Intern:** `data_types`, `errors`, `service_iface`, `service` (innerhalb desselben `system_monitor` Moduls).
    * **Extern:** Keine direkten, da nur Re-Exporte stattfinden.
* **Kommunikationsmuster:** Stellt die Hauptschnittstelle des `system_monitor`-Moduls zur Verfügung. Es ist der primäre Punkt, über den die UI-Schicht und andere Dienste Systemmetriken abrufen.
* **Erwartete Ergebnisse/Outputs:** Eine klar definierte und leicht nutzbare öffentliche API für die Überwachung von Systemressourcen innerhalb der Domänenschicht, die konsistente Interaktionen über alle Schichten hinweg ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte sind. Die Tests erfolgen in den jeweiligen Submodulen.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (65 von 100+) widmet sich der Implementierung der grundlegenden Datentypen für das System-Monitor-Modul in `novade-domain/src/system_monitor/data_types.rs`. Diese Strukturen sind entscheidend, um die vielfältigen Systemmetriken zu erfassen und zu übermitteln.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 65/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.25.2. `novade-domain/src/system_monitor/data_types.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/system_monitor/data_types.rs`
* **Verantwortlichkeit:** Definiert die Datenstrukturen zur Repräsentation verschiedener Systemmetriken (CPU, Speicher, Netzwerk, Festplatte, Prozesse, allgemeine Systeminformationen). Diese Typen dienen als Transportmittel für die vom `SystemMonitorService` erfassten Daten, die dann von UI-Komponenten oder anderen Diensten genutzt werden.
* **Kern-Aufgaben (Tasks):**

    1.  **`CpuUsage` Struct definieren:**
        * Repräsentiert die aktuelle CPU-Auslastung.
        * **Felder:**
            * `total_percentage: f32`: Gesamtauslastung der CPU(s) als Prozentwert (0.0-100.0).
            * `per_core_percentages: Vec<f32>`: Auslastung pro logischem Kern.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion.

    2.  **`MemoryInfo` Struct definieren:**
        * Repräsentiert Informationen über die Speicherauslastung.
        * **Felder:**
            * `total_bytes: u64`: Gesamter physischer Speicher in Bytes.
            * `used_bytes: u64`: Genutzter Speicher in Bytes.
            * `available_bytes: u64`: Verfügbarer Speicher in Bytes.
            * `swap_total_bytes: u64`: Gesamter Swap-Speicher in Bytes.
            * `swap_used_bytes: u64`: Genutzter Swap-Speicher in Bytes.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion.

    3.  **`NetworkUsage` Struct definieren:**
        * Repräsentiert die Netzwerkaktivität für eine Schnittstelle.
        * **Felder:**
            * `interface_name: String`: Name der Netzwerkschnittstelle (z.B. "eth0", "wlan0").
            * `bytes_received_per_sec: u64`: Empfangene Bytes pro Sekunde.
            * `bytes_transmitted_per_sec: u64`: Gesendete Bytes pro Sekunde.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion.

    4.  **`DiskInfo` Struct definieren:**
        * Repräsentiert Informationen über eine Festplatte oder Partition.
        * **Felder:**
            * `name: String`: Name des Datenträgers/der Partition (z.B. "sda1", "/dev/nvme0n1p2").
            * `mount_point: PathBuf`: Einhängepunkt (z.B. `/`, `/home`).
            * `total_bytes: u64`: Gesamtkapazität in Bytes.
            * `used_bytes: u64`: Genutzter Speicherplatz in Bytes.
            * `available_bytes: u64`: Verfügbarer Speicherplatz in Bytes.
            * `file_system: String`: Dateisystemtyp (z.B. "ext4", "ntfs").
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion.

    5.  **`ProcessInfo` Struct definieren:**
        * Repräsentiert grundlegende Informationen über einen laufenden Prozess.
        * **Felder:**
            * `pid: u32`: Prozess-ID.
            * `name: String`: Name des Prozesses.
            * `command: String`: Vollständiger Befehl, mit dem der Prozess gestartet wurde.
            * `cpu_usage_percentage: f32`: CPU-Auslastung dieses Prozesses (als Prozentwert).
            * `memory_usage_bytes: u64`: Speicherverbrauch dieses Prozesses in Bytes.
            * `status: String`: Aktueller Status des Prozesses (z.B. "Running", "Sleeping", "Zombie").
            * `user: String`: Benutzer, der den Prozess besitzt.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion.

    6.  **`SystemInfo` Struct definieren:**
        * Repräsentiert allgemeine Systeminformationen.
        * **Felder:**
            * `os_name: String`: Name des Betriebssystems (z.B. "Linux").
            * `os_version: String`: Version des Betriebssystems.
            * `kernel_version: String`: Kernel-Version.
            * `hostname: String`: Hostname des Systems.
            * `uptime_seconds: u664`: System-Uptime in Sekunden.
            * `boot_time: chrono::DateTime<chrono::Utc>`: Zeitpunkt des letzten Systemstarts.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/system_monitor/data_types.rs`
* **Abhängigkeiten:**
    * **Extern:** `serde::{Serialize, Deserialize}`, `std::path::PathBuf`, `chrono::{DateTime, Utc}`.
* **Kommunikationsmuster:**
    * Diese Strukturen werden als Rückgabewerte von Methoden des `SystemMonitorService` verwendet oder in Streams für kontinuierliche Updates gesendet.
* **Erwartete Ergebnisse/Outputs:** Klare und konsistente Datenmodelle zur Repräsentation verschiedener Systemmetriken, die eine einfache Nutzung durch andere NovaDE-Komponenten ermöglichen.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der `Default` Implementierungen für alle Strukturen.
        * Testen der `Clone`, `Debug`, `PartialEq` (und `Eq`, `Hash` für `ProcessInfo`) Implementierungen.
        * Testen der `new()`-Funktionen, um sicherzustellen, dass alle Felder korrekt initialisiert und gesetzt werden können.
        * Testen der Serialisierung und Deserialisierung (wenn sinnvoll, für jede Struktur einzeln).

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (66 von 100+) widmet sich der Implementierung der Fehlerdefinitionen für das System-Monitor-Modul in `novade-domain/src/system_monitor/errors.rs`. Eine präzise Fehlerbehandlung ist entscheidend für die Stabilität und Zuverlässigkeit der Systemüberwachung.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 66/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.25.3. `novade-domain/src/system_monitor/errors.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/system_monitor/errors.rs`
* **Verantwortlichkeit:** Definiert ein konsolidiertes Fehler-Enum (`SystemMonitorError`) für alle Operationen, die innerhalb des `system_monitor`-Moduls der Domänenschicht auftreten können. Dieses Enum kapselt spezifische Fehlerquellen wie Probleme beim Lesen von Systeminformationen (z.B. `/proc` oder `/sys`), fehlende Berechtigungen oder Fehler von externen Bibliotheken zur Systeminformation. Die Nutzung von `thiserror` ist obligatorisch.
* **Kern-Aufgaben (Tasks):**
    1.  **`SystemMonitorError` Enum definieren:**
        * Nutze `#[derive(thiserror::Error, Debug)]` für automatische Implementierung der `Error` und `Debug` Traits.
        * Varianten:
            * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler, z.B. beim Lesen von Dateien im `/proc`- oder `/sys`-Dateisystem.
                * `#[error("I/O error during system monitoring: {0}")]`
            * `ParseError { field: String, value: String, source: String }`: Fehler beim Parsen von Systeminformationen (z.B. unerwartetes Format in einer `/proc`-Datei). Enthält das betroffene Feld, den problematischen Wert und die Quelle des Fehlers.
                * `#[error("Failed to parse system data for field '{field}' with value '{value}'. Source: {source}")]`
            * `PermissionDenied(String)`: Wenn NovaDE nicht die notwendigen Berechtigungen hat, um auf Systeminformationen zuzugreifen (z.B. `/proc` oder spezielle Kernel-APIs).
                * `#[error("Permission denied for system monitoring operation: {0}")]`
            * `LibraryError { source: String, details: String }`: Fehler von einer externen Bibliothek, die zur Systemüberwachung verwendet wird (z.B. `sysinfo`). `source` könnte der Name der Bibliothek sein, `details` die Fehlermeldung der Bibliothek.
                * `#[error("External library error during system monitoring: {source}: {details}")]`
            * `UnsupportedPlatform(String)`: Wenn eine bestimmte Systemüberwachungsfunktion auf der aktuellen Plattform nicht unterstützt wird (z.B. spezifische Metriken, die nur unter Linux verfügbar sind).
                * `#[error("Operation not supported on current platform: {0}")]`
            * `Other(String)`: Ein Catch-All für unvorhergesehene oder nicht spezifisch handhabbare Fehler.
                * `#[error("An unexpected system monitoring error occurred: {0}")]`
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/system_monitor/errors.rs`
* **Abhängigkeiten:**
    * **Extern:** `thiserror::Error`, `std::io::Error`.
* **Kommunikationsmuster:**
    * Wird als `E` (Fehler-Typ) in `Result<T, E>` Signaturen aller öffentlichen Funktionen und Methoden des `system_monitor`-Moduls verwendet (z.B. `SystemMonitorService`).
    * Sollte von `std::io::Error` Fehlertypen erhalten und in die eigene Variante konvertieren (`#[from]`).
    * Wird von der UI-Schicht oder anderen Diensten empfangen und dort in ein übergeordnetes Fehler-Enum gekapselt oder direkt behandelt.
* **Erwartete Ergebnisse/Outputs:** Ein klar strukturiertes und wartbares Fehler-Enum, das alle denkbaren Fehlerzustände im System-Monitor-Modul abdeckt und eine konsistente Fehlerbehandlung ermöglicht.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der Instanziierung jeder Fehlervariante mit aussagekräftigen Daten (z.B. Fehlermeldungen, Dateinamen, Parsing-Werte).
        * Testen der `#[from]`-Konvertierung von `std::io::Error`.
        * Testen der `Display`-Implementierung (via `to_string()`) für jede Fehlervariante, um sicherzustellen, dass die Fehlermeldungen korrekt und informativ sind.
        * Testen der `source()`-Kette, um sicherzustellen, dass die Ursprungsfehler bei der Konvertierung beibehalten werden.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (67 von 100+) widmet sich der Implementierung des `novade-domain/src/system_monitor/service_iface.rs` Moduls. Dieses Modul definiert den Vertrag für den Dienst, der für das Abrufen und Überwachen von Systemressourcen zuständig ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 67/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.25.4. `novade-domain/src/system_monitor/service_iface.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/system_monitor/service_iface.rs`
* **Verantwortlichkeit:** Definiert den `SystemMonitorService` Trait. Dieser Trait ist die primäre Schnittstelle für alle Komponenten, die Echtzeitinformationen über die Systemressourcenauslastung (CPU, Speicher, Netzwerk, Festplatte, Prozesse) benötigen. Er abstrahiert die plattformspezifische Logik des Zugriffs auf Systemmetriken und bietet eine konsistente API. Alle Methoden sind asynchron, um nicht-blockierende Operationen zu gewährleisten, insbesondere wenn die Daten von System-APIs oder durch das Parsen von Dateien stammen.
* **Kern-Aufgaben (Tasks):**
    1.  **`SystemMonitorService` Trait definieren:**
        * Nutze `#[async_trait]` für alle Methoden.
        * Alle Methoden geben `Result<(), SystemMonitorError>` oder `Result<T, SystemMonitorError>` zurück, um eine konsistente Fehlerbehandlung zu gewährleisten.
        * **Methoden:**
            * `initialize(&self) -> Result<(), SystemMonitorError>`:
                * Initialisiert den Dienst, lädt initiale Systemdaten und bereitet interne Caches vor.
                * Sollte idempotent sein.
                * **Fehlerbehandlung:** `SystemMonitorError::IoError`, `SystemMonitorError::ParseError`, `SystemMonitorError::LibraryError`.
            * `get_cpu_usage(&self) -> Result<CpuUsage, SystemMonitorError>`:
                * Gibt die aktuelle CPU-Auslastung zurück.
                * **Logik:** Erfordert das Lesen von CPU-Statistiken (z.B. aus `/proc/stat` unter Linux) und die Berechnung der Differenz zu einem vorherigen Messwert, um die prozentuale Auslastung zu ermitteln.
                * **Fehlerbehandlung:** `SystemMonitorError::IoError`, `SystemMonitorError::ParseError`, `SystemMonitorError::LibraryError`.
            * `get_memory_info(&self) -> Result<MemoryInfo, SystemMonitorError>`:
                * Gibt detaillierte Informationen zur Speicherauslastung zurück.
                * **Logik:** Erfordert das Lesen von Speicherstatistiken (z.B. aus `/proc/meminfo` unter Linux).
                * **Fehlerbehandlung:** `SystemMonitorError::IoError`, `SystemMonitorError::ParseError`, `SystemMonitorError::LibraryError`.
            * `get_network_usage(&self) -> Result<Vec<NetworkUsage>, SystemMonitorError>`:
                * Gibt eine Liste der Netzwerkaktivität für alle relevanten Schnittstellen zurück.
                * **Logik:** Erfordert das Lesen von Netzwerkschnittstellenstatistiken (z.B. aus `/proc/net/dev` unter Linux) und die Berechnung der Differenz zwischen Messwerten.
                * **Fehlerbehandlung:** `SystemMonitorError::IoError`, `SystemMonitorError::ParseError`, `SystemMonitorError::LibraryError`.
            * `get_disk_info(&self) -> Result<Vec<DiskInfo>, SystemMonitorError>`:
                * Gibt eine Liste der Informationen zu allen gemounteten Dateisystemen zurück.
                * **Logik:** Erfordert das Abfragen von Einhängepunkten und deren Speicherstatistiken (z.B. `statfs` Systemaufruf oder Parsen von `/etc/mtab`/`/proc/mounts`).
                * **Fehlerbehandlung:** `SystemMonitorError::IoError`, `SystemMonitorError::ParseError`, `SystemMonitorError::PermissionDenied`, `SystemMonitorError::LibraryError`.
            * `get_process_list(&self) -> Result<Vec<ProcessInfo>, SystemMonitorError>`:
                * Gibt eine Liste der derzeit laufenden Prozesse mit grundlegenden Informationen zurück.
                * **Logik:** Erfordert das Durchsuchen des `/proc`-Dateisystems (z.B. `/proc/[pid]/stat`, `/proc/[pid]/status`, `/proc/[pid]/cmdline`) unter Linux. Dies kann rechenintensiv sein.
                * **Fehlerbehandlung:** `SystemMonitorError::IoError`, `SystemMonitorError::ParseError`, `SystemMonitorError::PermissionDenied`, `SystemMonitorError::LibraryError`.
            * `get_system_info(&self) -> Result<SystemInfo, SystemMonitorError>`:
                * Gibt allgemeine Systeminformationen zurück (OS-Name, Kernel-Version, Uptime, etc.).
                * **Logik:** Erfordert das Lesen von Systemdateien (z.B. `/etc/os-release`, `/proc/version`, `/proc/uptime`).
                * **Fehlerbehandlung:** `SystemMonitorError::IoError`, `SystemMonitorError::ParseError`, `SystemMonitorError::LibraryError`.
            * `on_cpu_usage_updated(&self) -> impl Stream<Item = CpuUsage> + Send + Sync`:
                * Gibt einen asynchronen Stream zurück, der periodisch aktualisierte `CpuUsage`-Daten liefert.
                * **Logik:** Intern wird eine Timer-Task gestartet, die `get_cpu_usage` in einem bestimmten Intervall aufruft und die Ergebnisse in den Stream pusht.
            * `on_memory_info_updated(&self) -> impl Stream<Item = MemoryInfo> + Send + Sync`:
                * Analog zu `on_cpu_usage_updated` für Speicherinformationen.
            * `on_network_usage_updated(&self) -> impl Stream<Item = Vec<NetworkUsage>> + Send + Sync`:
                * Analog zu `on_cpu_usage_updated` für Netzwerkstatistiken.
            * `on_disk_info_updated(&self) -> impl Stream<Item = Vec<DiskInfo>> + Send + Sync`:
                * Analog zu `on_cpu_usage_updated` für Festplatteninformationen.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/system_monitor/service_iface.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::system_monitor::data_types::{CpuUsage, MemoryInfo, NetworkUsage, DiskInfo, ProcessInfo, SystemInfo}`
        * `crate::system_monitor::errors::SystemMonitorError`
    * **Extern:** `async_trait::async_trait`, `futures::Stream`. Optional: `sysinfo` (für plattformübergreifende Abstraktion, dies würde aber in der Implementierung, nicht im Trait, erscheinen).
* **Kommunikationsmuster:**
    * Dieser Trait wird von konkreten Dienstimplementierungen (z.B. `DefaultSystemMonitorService`) implementiert.
    * Die UI-Schicht (z.B. Widgets, System-Monitor-Anwendungen) wird diesen Trait nutzen, um Systemmetriken abzurufen und zu überwachen.
* **Erwartete Ergebnisse/Outputs:** Eine robuste und umfassende Schnittstelle für die Systemüberwachung, die Echtzeitdaten über die Ressourcenauslastung des Systems bereitstellt.
* **Teststrategie (Modul-spezifisch):** Keine direkten Tests für diesen Trait, da er nur eine Definition ist. Die Tests erfolgen für die konkreten Implementierungen (`DefaultSystemMonitorService`).

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (68 von 100+) widmet sich der Implementierung des `novade-domain/src/system_monitor/service.rs` Moduls. Dies ist die konkrete Implementierung des `SystemMonitorService`-Traits und bildet die zentrale Komponente für die Echtzeit-Systemüberwachung im NovaDE.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 68/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.25.5. `novade-domain/src/system_monitor/service.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/system_monitor/service.rs`
* **Verantwortlichkeit:** Implementiert den `SystemMonitorService`-Trait. Dieser Dienst ist verantwortlich für das Sammeln und Bereitstellen von Systemmetriken wie CPU-Auslastung, Speichernutzung, Netzwerkinformationen, Festplattenstatistiken und Prozesslisten. Er nutzt plattformspezifische APIs oder Bibliotheken (primär die `sysinfo` Crate für plattformübergreifende Kompatibilität, wo sinnvoll) sowie das Parsen von `/proc`-Dateien unter Linux. Er kapselt die Logik für die periodische Aktualisierung dieser Daten und die Bereitstellung über asynchrone Streams.
* **Kern-Aufgaben (Tasks):**

    1.  **`DefaultSystemMonitorService` Struct definieren:**
        * **Felder:**
            * `sys_info_manager: Arc<RwLock<sysinfo::System>>`: Ein Manager für Systeminformationen, primär von der `sysinfo`-Crate. Mit `RwLock` für Thread-sicheren Zugriff und `Arc` für geteilte Referenzen.
            * `cpu_sender: tokio::sync::mpsc::UnboundedSender<CpuUsage>`: Sender für den `on_cpu_usage_updated` Stream.
            * `mem_sender: tokio::sync::mpsc::UnboundedSender<MemoryInfo>`: Sender für den `on_memory_info_updated` Stream.
            * `net_sender: tokio::sync::mpsc::UnboundedSender<Vec<NetworkUsage>>`: Sender für den `on_network_usage_updated` Stream.
            * `disk_sender: tokio::sync::mpsc::UnboundedSender<Vec<DiskInfo>>`: Sender für den `on_disk_info_updated` Stream.
            * `_cpu_receiver: tokio::sync::mpsc::UnboundedReceiver<CpuUsage>`: Interner Empfänger für `cpu_sender`.
            * `_mem_receiver: tokio::sync::mpsc::UnboundedReceiver<MemoryInfo>`: Interner Empfänger für `mem_sender`.
            * `_net_receiver: tokio::sync::mpsc::UnboundedReceiver<Vec<NetworkUsage>>`: Interner Empfänger für `net_sender`.
            * `_disk_receiver: tokio::sync::mpsc::UnboundedReceiver<Vec<DiskInfo>>`: Interner Empfänger für `disk_sender`.
            * `update_interval_ms: u64`: Das Aktualisierungsintervall für die periodischen Streams in Millisekunden (Standard: 1000ms).

    2.  **Konstruktor `new(update_interval_ms: u64)` implementieren:**
        * Initialisiert `sys_info_manager` mit einem neuen `sysinfo::System::new_with_specifics(sysinfo::RefreshKind::new().with_all())`.
        * Erstellt die `tokio::sync::mpsc::unbounded_channel` für alle Sender/Empfänger-Paare.
        * Setzt `update_interval_ms`.
        * Gibt das `DefaultSystemMonitorService` Struct zurück.

    3.  **Implementierung des `SystemMonitorService`-Traits für `DefaultSystemMonitorService`:**

        * **`initialize(&self) -> Result<(), SystemMonitorError>`:**
            * Holt einen Schreib-Lock auf `self.sys_info_manager`.
            * Ruft `manager.refresh_all()` auf, um initiale Daten zu laden.
            * Startet vier separate `tokio::spawn` Tasks für die periodische Aktualisierung und das Senden von Daten an die Streams:
                * Eine Task für CPU-Updates (`_spawn_cpu_monitor_task`).
                * Eine Task für Speicher-Updates (`_spawn_memory_monitor_task`).
                * Eine Task für Netzwerk-Updates (`_spawn_network_monitor_task`).
                * Eine Task für Disk-Updates (`_spawn_disk_monitor_task`).
            * Jede Task verwendet `tokio::time::interval(Duration::from_millis(self.update_interval_ms))` und ruft die entsprechende `get_*_info` Methode auf, sendet das Ergebnis an den jeweiligen Sender und behandelt Fehler mit `tracing::error!`.
            * Loggt den Initialisierungserfolg oder -fehler.
            * **Fehlerbehandlung:** Kapselt `sysinfo::Error` in `SystemMonitorError::LibraryError`.

        * **`get_cpu_usage(&self) -> Result<CpuUsage, SystemMonitorError>`:**
            * Holt einen Lese-Lock auf `self.sys_info_manager`.
            * Ruft `manager.refresh_cpu()` auf, um die CPU-Daten zu aktualisieren.
            * Berechnet `total_percentage` und `per_core_percentages` aus den `sysinfo::Cpu` Objekten. Die `sysinfo` Crate bietet Methoden zur Berechnung der Auslastung seit dem letzten Aufruf.
            * Erstellt und gibt ein `CpuUsage` Struct zurück.
            * **Fehlerbehandlung:** `SystemMonitorError::LibraryError` bei Problemen mit `sysinfo`.

        * **`get_memory_info(&self) -> Result<MemoryInfo, SystemMonitorError>`:**
            * Holt einen Lese-Lock auf `self.sys_info_manager`.
            * Ruft `manager.refresh_memory()` auf.
            * Liest `total_memory`, `used_memory`, `available_memory`, `total_swap`, `used_swap` von `manager`.
            * Erstellt und gibt ein `MemoryInfo` Struct zurück.
            * **Fehlerbehandlung:** `SystemMonitorError::LibraryError`.

        * **`get_network_usage(&self) -> Result<Vec<NetworkUsage>, SystemMonitorError>`:**
            * Holt einen Lese-Lock auf `self.sys_info_manager`.
            * Ruft `manager.refresh_networks()` auf.
            * Iteriert über `manager.networks()`:
                * Für jede Netzwerkschnittstelle: `interface_name`, `received()`, `transmitted()`.
                * Die Berechnung von Bytes pro Sekunde erfordert den Vergleich mit vorherigen Werten. **Entscheidung:** Für die erste Implementierung wird `sysinfo::NetworkData` verwendet, das `received` und `transmitted` Bytes liefert. Die "per_sec"-Berechnung muss aufruferseitig erfolgen oder intern im `SystemMonitorService` einen Zustand für die letzte Messung halten. **Korrektur:** Der `SystemMonitorService` sollte die Differenzberechnung intern durchführen, um die Rate zu liefern. Dies erfordert das Speichern der *letzten* `sysinfo::Networks` Instanz in `self.sys_info_manager` oder einer separaten `Arc<RwLock<HashMap<String, (u64, u64)>>>` für die letzten Bytes.
            * Erstellt und gibt eine `Vec<NetworkUsage>` zurück.
            * **Fehlerbehandlung:** `SystemMonitorError::LibraryError`.

        * **`get_disk_info(&self) -> Result<Vec<DiskInfo>, SystemMonitorError>`:**
            * Holt einen Lese-Lock auf `self.sys_info_manager`.
            * Ruft `manager.refresh_disks()` auf.
            * Iteriert über `manager.disks()`:
                * Extrahiert `name`, `mount_point`, `total_space`, `available_space`, `file_system`.
            * Erstellt und gibt eine `Vec<DiskInfo>` zurück.
            * **Fehlerbehandlung:** `SystemMonitorError::LibraryError`.

        * **`get_process_list(&self) -> Result<Vec<ProcessInfo>, SystemMonitorError>`:**
            * Holt einen Lese-Lock auf `self.sys_info_manager`.
            * Ruft `manager.refresh_processes()` auf.
            * Iteriert über `manager.processes()`:
                * Extrahiert `pid`, `name`, `cmd`, `cpu_usage`, `memory`, `status` (als String aus `ProcessStatus`), `user` (über `sysinfo::User` lookup).
            * Erstellt und gibt eine `Vec<ProcessInfo>` zurück.
            * **Fehlerbehandlung:** `SystemMonitorError::LibraryError`. Beachten Sie, dass der `sysinfo` Zugriff auf Prozesse manchmal Berechtigungen erfordert.

        * **`get_system_info(&self) -> Result<SystemInfo, SystemMonitorError>`:**
            * Holt einen Lese-Lock auf `self.sys_info_manager`.
            * Extrahiert `long_os_version` (oder `name` + `version`), `kernel_version`, `host_name`, `uptime`, `boot_time` (aus `System::boot_time`).
            * Erstellt und gibt ein `SystemInfo` Struct zurück.
            * **Fehlerbehandlung:** `SystemMonitorError::LibraryError`.

        * **`on_cpu_usage_updated(&self) -> impl Stream<Item = CpuUsage> + Send + Sync`:**
            * Gibt einen `tokio_stream::wrappers::UnboundedReceiverStream` über den Empfänger des `cpu_sender` zurück.
            * Die eigentliche Logik für die Aktualisierung und das Senden liegt in der `_spawn_cpu_monitor_task`.

        * **`on_memory_info_updated(&self) -> impl Stream<Item = MemoryInfo> + Send + Sync`:**
            * Gibt einen `tokio_stream::wrappers::UnboundedReceiverStream` über den Empfänger des `mem_sender` zurück.

        * **`on_network_usage_updated(&self) -> impl Stream<Item = Vec<NetworkUsage>> + Send + Sync`:**
            * Gibt einen `tokio_stream::wrappers::UnboundedReceiverStream` über den Empfänger des `net_sender` zurück.

        * **`on_disk_info_updated(&self) -> impl Stream<Item = Vec<DiskInfo>> + Send + Sync`:**
            * Gibt einen `tokio_stream::wrappers::UnboundedReceiverStream` über den Empfänger des `disk_sender` zurück.

    4.  **Private Hilfsmethoden für die Monitortasks (`_spawn_cpu_monitor_task`, etc.) implementieren:**
        * Diese Methoden sind `async fn` und werden von `initialize` als `tokio::spawn` aufgerufen.
        * Sie enthalten eine Schleife mit `tokio::time::interval`, rufen die entsprechenden `get_*` Methoden des `SystemMonitorService` auf (ggf. mit einem geklonten `Arc` des Dienstes), und senden die Ergebnisse über den `mpsc::Sender`.
        * Robuste Fehlerbehandlung innerhalb der Tasks, um zu verhindern, dass die Task bei einem Fehler abstürzt. Loggen der Fehler mit `tracing`.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/system_monitor/service.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::system_monitor::data_types::{CpuUsage, MemoryInfo, NetworkUsage, DiskInfo, ProcessInfo, SystemInfo}`
        * `crate::system_monitor::errors::SystemMonitorError`
        * `crate::system_monitor::service_iface::SystemMonitorService`
    * **Extern:** `async_trait::async_trait`, `tokio`, `tokio::sync::{mpsc, RwLock}`, `tokio::time::{interval, Duration}`, `futures::Stream`, `tokio_stream::wrappers::UnboundedReceiverStream`, `sysinfo`, `std::sync::Arc`, `tracing`, `chrono`.
* **Kommunikationsmuster:** Wird von UI-Komponenten (z.B. Systemüberwachungs-Widgets, Systemtray-Indikatoren) über `Arc` und `Stream` verwendet.
* **Erwartete Ergebnisse/Outputs:** Ein zuverlässiger und effizienter System-Monitor-Dienst, der genaue und aktuelle Systemmetriken bereitstellt, sowohl auf Abruf als auch über periodische Streams.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests (mit Mocks/Isolation):**
        * **Mocks:** Für `sysinfo::System`, um feste Daten zurückzugeben und die Berechnung der Auslastung zu testen.
        * Testen von `get_cpu_usage`, `get_memory_info`, `get_network_usage`, `get_disk_info`, `get_process_list`, `get_system_info` mit simulierten `sysinfo` Daten.
        * Testen der korrekten Konvertierung von `sysinfo` Typen in NovaDE-Datentypen.
        * Testen der Fehlerbehandlung (z.B. wenn `sysinfo` einen Fehler meldet).
        * Testen der **periodischen Aktualisierungen** und Streams:
            * Verwenden Sie `tokio::time::pause()` und `tokio::time::advance()` um die Zeit vorzuspulen und die Triggers der `interval` Tasks zu simulieren.
            * Senden Sie Daten über die Streams und verifizieren Sie, dass die korrekten Daten empfangen werden.
            * Stellen Sie sicher, dass die Streams funktionieren, auch wenn einzelne Aktualisierungsversuche fehlschlagen.
    * **Integration Tests:**
        * Führen Sie den Dienst mit dem echten `sysinfo` Backend aus.
        * Prüfen Sie, ob die zurückgegebenen Metriken plausibel sind (z.B. CPU-Auslastung ändert sich, Speicher ist nicht null).
        * Überwachen Sie die Streams für einige Sekunden und prüfen Sie die empfangenen Daten auf Konsistenz und Aktualität.
        * Besondere Aufmerksamkeit bei Tests auf unterschiedlichen Plattformen (Linux, macOS, Windows) falls relevant.


---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (69 von 100+) widmet sich der Initialisierung des `novade-domain/src/system_tray/mod.rs` Moduls. Dieses Modul wird die Funktionalität kapseln, die für die Interaktion mit dem System-Tray (auch bekannt als Statusbereich oder Benachrichtigungsbereich) erforderlich ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 69/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.26. `novade-domain/src/system_tray` Verzeichnis

Dieses Verzeichnis ist für die Verwaltung von System-Tray-Symbolen zuständig. System-Tray-Symbole sind kleine Icons im Statusbereich des Desktops, die typischerweise von Hintergrundanwendungen verwendet werden, um ihren Status anzuzeigen und Kontextmenüs bereitzustellen. Die Implementierung muss sowohl das ältere XEmbed-basierte System-Tray-Protokoll als auch das modernere StatusNotifierItem-Protokoll (basierend auf D-Bus) unterstützen, um maximale Kompatibilität mit bestehenden Anwendungen zu gewährleisten.

#### 3.26.1. `novade-domain/src/system_tray/mod.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/system_tray/mod.rs`
* **Verantwortlichkeit:** Definiert die öffentliche API des `system_tray`-Moduls der Domänenschicht. Es re-exportiert alle wichtigen Typen, Traits, Enums und Strukturen, die von der UI-Schicht (z.B. für das System-Tray-Panel im NovaDE-Desktop) oder anderen Diensten benötigt werden, um System-Tray-Symbole zu erkennen, zu rendern und mit ihnen zu interagieren.
* **Kern-Aufgaben (Tasks):**
    1.  **Public API Definition:** Re-exportiere die folgenden Komponenten, die die Schnittstelle dieses Moduls bilden:
        * `data_types` (alle relevanten Typen wie `SystemTrayItem`, `SystemTrayMenu`, `SystemTrayMenuItem`, `SystemTrayIcon`).
        * `errors` (das `SystemTrayError` Enum).
        * `service_iface` (den `SystemTrayService` Trait).
        * `service` (die konkrete `DefaultSystemTrayService` Implementierung).
    2.  **Modul-Strukturierung:** Stelle sicher, dass alle Re-Exporte korrekt sind und keine internen Implementierungsdetails unnötigerweise exponiert werden.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/system_tray/mod.rs`
* **Abhängigkeiten:**
    * **Intern:** `data_types`, `errors`, `service_iface`, `service` (innerhalb desselben `system_tray` Moduls).
    * **Extern:** Keine direkten, da nur Re-Exporte stattfinden.
* **Kommunikationsmuster:** Stellt die Hauptschnittstelle des `system_tray`-Moduls zur Verfügung. Es ist der primäre Punkt, über den das System-Tray-Panel im NovaDE-Desktop die verfügbaren Symbole und deren Interaktionsmöglichkeiten abruft.
* **Erwartete Ergebnisse/Outputs:** Eine klar definierte und leicht nutzbare öffentliche API für die Integration des System-Trays in den NovaDE-Desktop, die eine konsistente Interaktion über alle Schichten hinweg ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte sind. Die Tests erfolgen in den jeweiligen Submodulen.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (70 von 100+) widmet sich der Implementierung der grundlegenden Datentypen für das System-Tray-Modul in `novade-domain/src/system_tray/data_types.rs`. Diese Strukturen sind entscheidend, um die komplexen Informationen und Interaktionsmöglichkeiten von System-Tray-Elementen abzubilden.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 70/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.26.2. `novade-domain/src/system_tray/data_types.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/system_tray/data_types.rs`
* **Verantwortlichkeit:** Definiert die Datenstrukturen zur Repräsentation von System-Tray-Elementen, deren Icons, Tooltips und Kontextmenüs. Diese Typen dienen als Transportmittel für die vom `SystemTrayService` erfassten und bereitgestellten Daten, die dann von der UI-Schicht (z.B. dem System-Tray-Panel) gerendert und interaktiv gemacht werden. Es muss sowohl die Anforderungen des XEmbed-Protokolls (für ältere Anwendungen) als auch des StatusNotifierItem-Protokolls (für modernere Anwendungen) abdecken.
* **Kern-Aufgaben (Tasks):**

    1.  **`SystemTrayIcon` Enum definieren:**
        * Repräsentiert ein Icon für ein System-Tray-Element. Icons können auf verschiedene Weisen bereitgestellt werden.
        * **Varianten:**
            * `ThemeIcon { name: String, size: u32 }`: Ein Icon, das aus dem aktuellen Icon-Theme geladen werden soll (z.B. "firefox"). `size` gibt die bevorzugte Größe an.
            * `PathIcon { path: PathBuf }`: Ein Icon, das direkt über einen Dateipfad referenziert wird.
            * `ImageData { width: u32, height: u32, data: Vec<u8> }`: Roh-Bilddaten (z.B. PNG, RGBA). `data` enthält die Bytes des Bildes.
        * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.

    2.  **`SystemTrayMenuItem` Struct definieren:**
        * Repräsentiert einen einzelnen Eintrag in einem Kontextmenü eines System-Tray-Elements.
        * **Felder:**
            * `id: u32`: Eine eindeutige ID des Menüeintrags. Wird verwendet, um Klicks zu identifizieren.
            * `label: String`: Der sichtbare Text des Menüeintrags.
            * `icon: Option<SystemTrayIcon>`: Optionales Icon für den Menüeintrag.
            * `is_enabled: bool`: Gibt an, ob der Menüeintrag anklickbar ist.
            * `is_checked: bool`: Gibt an, ob der Menüeintrag markiert ist (z.B. bei Checkbox-Menüeinträgen).
            * `submenu: Option<SystemTrayMenu>`: Ein optionales Untermenü, falls dies ein hierarchischer Eintrag ist.
            * `item_type: SystemTrayMenuItemType`: Der Typ des Menüeintrags (normal, Trennlinie, Checkbox).
        * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.

    3.  **`SystemTrayMenuItemType` Enum definieren:**
        * Definiert den Typ eines Menüeintrags.
        * **Varianten:**
            * `Standard`: Ein normaler, anklickbarer Menüeintrag.
            * `Separator`: Eine Trennlinie.
            * `Checkbox`: Ein Menüeintrag mit einem Checkbox-Status.
        * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.

    4.  **`SystemTrayMenu` Struct definieren:**
        * Repräsentiert ein Kontextmenü, das aus einer Liste von `SystemTrayMenuItem` besteht.
        * **Felder:**
            * `items: Vec<SystemTrayMenuItem>`: Eine Liste der Menüeinträge.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.

    5.  **`SystemTrayItem` Struct definieren:**
        * Die Hauptstruktur, die ein vollständiges System-Tray-Element repräsentiert.
        * **Felder:**
            * `id: String`: Eine eindeutige ID für dieses Tray-Element (z.B. der D-Bus Service Name oder ein XID).
            * `icon: SystemTrayIcon`: Das primäre Icon des Tray-Elements.
            * `tooltip: String`: Der Text, der angezeigt wird, wenn der Mauszeiger über das Icon gehalten wird.
            * `status: SystemTrayItemStatus`: Der aktuelle Status des Tray-Elements (z.B. aktiv, passiv, beschäftigt).
            * `menu: Option<SystemTrayMenu>`: Das optionale Kontextmenü des Tray-Elements.
            * `has_attention: bool`: Gibt an, ob das Element Aufmerksamkeit erfordert (z.B. blinkendes Icon).
            * `category: String`: Die Kategorie des Elements (z.B. "Applications", "Hardware"). (Dies ist Teil des StatusNotifierItem-Protokolls).
            * `title: String`: Ein kurzer Titel des Elements. (Teil des StatusNotifierItem-Protokolls).
            * `window_id: Option<u32>`: Optional die XID des Fensters, wenn es sich um ein XEmbed-basiertes Tray-Element handelt.
        * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.

    6.  **`SystemTrayItemStatus` Enum definieren:**
        * Definiert den Status eines System-Tray-Elements.
        * **Varianten:**
            * `Active`: Das Element ist normal aktiv.
            * `Passive`: Das Element ist vorhanden, aber nicht aktiv (z.B. minimiert).
            * `NeedsAttention`: Das Element erfordert Benutzeraufmerksamkeit.
        * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/system_tray/data_types.rs`
* **Abhängigkeiten:**
    * **Extern:** `serde::{Serialize, Deserialize}`, `std::path::PathBuf`.
* **Kommunikationsmuster:**
    * Diese Strukturen werden vom `SystemTrayService` erstellt und als Events über Streams oder als direkte Rückgabewerte an die UI-Schicht übermittelt.
    * Die UI-Schicht empfängt diese Strukturen, um die System-Tray-Elemente zu rendern und deren Interaktionen zu handhaben.
* **Erwartete Ergebnisse/Outputs:** Klare, umfassende und flexible Datenmodelle zur Repräsentation aller relevanten Aspekte von System-Tray-Elementen, die sowohl XEmbed als auch StatusNotifierItem unterstützen.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der `Default` Implementierungen (wo anwendbar).
        * Testen der `Clone`, `Debug`, `PartialEq` Implementierungen für alle Strukturen und Enums.
        * Testen der korrekten Instanziierung jeder Variante von `SystemTrayIcon` und `SystemTrayMenuItemType`.
        * Testen der Serialisierung und Deserialisierung für alle Strukturen (z.B. zu/von JSON), um die Kompatibilität für zukünftige persistente Speicherung oder D-Bus-Übertragung zu gewährleisten.
        * Erstellen komplexer geschachtelter `SystemTrayMenu`-Strukturen und Testen ihrer Korrektheit.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (71 von 100+) widmet sich der Implementierung der Fehlerdefinitionen für das System-Tray-Modul in `novade-domain/src/system_tray/errors.rs`. Eine präzise Fehlerbehandlung ist entscheidend für die zuverlässige Interaktion mit System-Tray-Icons, die oft von Drittanbieteranwendungen bereitgestellt werden.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 71/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.26.3. `novade-domain/src/system_tray/errors.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/system_tray/errors.rs`
* **Verantwortlichkeit:** Definiert ein konsolidiertes Fehler-Enum (`SystemTrayError`) für alle Operationen, die innerhalb des `system_tray`-Moduls der Domänenschicht auftreten können. Dieses Enum kapselt spezifische Fehlerquellen wie Probleme bei der D-Bus-Kommunikation mit StatusNotifierItems, Fehler bei der XEmbed-Interaktion mit älteren Tray-Icons, oder ungültige Datenformate von Tray-Anwendungen. Die Nutzung von `thiserror` ist obligatorisch.
* **Kern-Aufgaben (Tasks):**
    1.  **`SystemTrayError` Enum definieren:**
        * Nutze `#[derive(thiserror::Error, Debug)]` für automatische Implementierung der `Error` und `Debug` Traits.
        * **Varianten:**
            * `DbusError(#[from] zbus::Error)`: Fehler, die bei der Interaktion mit D-Bus auftreten, insbesondere mit StatusNotifierItems.
                * `#[error("D-Bus error during system tray operation: {0}")]`
            * `XError(String)`: Fehler, die bei der Xlib/XCB-Interaktion mit XEmbed-basierten Tray-Icons auftreten. Dies würde die Konvertierung von spezifischen X-Fehlercodes oder Beschreibungen in einen verständlichen String umfassen.
                * `#[error("X11 error during system tray operation: {0}")]`
            * `ProtocolError { protocol: String, details: String }`: Ein allgemeiner Fehler, der auftritt, wenn eine Anwendung das Protokoll (XEmbed oder StatusNotifierItem) nicht korrekt implementiert oder ungültige Daten sendet.
                * `#[error("Protocol error in '{protocol}': {details}")]`
            * `ItemNotFound(String)`: Wenn ein angefordertes System-Tray-Element (z.B. nach seiner ID) nicht gefunden werden kann.
                * `#[error("System tray item with ID '{0}' not found.")]`
            * `InvalidData(String)`: Wenn die empfangenen Daten von einem Tray-Element nicht den erwarteten Formaten entsprechen (z.B. ungültige Bilddaten, Menüstruktur).
                * `#[error("Invalid data received from system tray item: {0}")]`
            * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler, z.B. beim Laden von Icons aus dem Dateisystem.
                * `#[error("I/O error during system tray operation: {0}")]`
            * `Other(String)`: Ein Catch-All für unvorhergesehene oder nicht spezifisch handhabbare Fehler.
                * `#[error("An unexpected system tray error occurred: {0}")]`
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/system_tray/errors.rs`
* **Abhängigkeiten:**
    * **Extern:** `thiserror::Error`, `zbus::Error`, `std::io::Error`.
* **Kommunikationsmuster:**
    * Wird als `E` (Fehler-Typ) in `Result<T, E>` Signaturen aller öffentlichen Funktionen und Methoden des `system_tray`-Moduls verwendet (z.B. `SystemTrayService`).
    * Sollte von `zbus::Error` und `std::io::Error` Fehlertypen erhalten und in die eigene Variante konvertieren (`#[from]`).
    * Wird von der UI-Schicht oder anderen Diensten empfangen und dort in ein übergeordnetes Fehler-Enum gekapselt oder direkt behandelt.
* **Erwartete Ergebnisse/Outputs:** Ein klar strukturiertes und wartbares Fehler-Enum, das alle denkbaren Fehlerzustände im System-Tray-Modul abdeckt und eine konsistente Fehlerbehandlung ermöglicht.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der Instanziierung jeder Fehlervariante mit aussagekräftigen Daten (z.B. D-Bus-Fehlermeldungen, Protokollnamen, Item-IDs).
        * Testen der `#[from]`-Konvertierungen von `zbus::Error` und `std::io::Error`.
        * Testen der `Display`-Implementierung (via `to_string()`) für jede Fehlervariante, um sicherzustellen, dass die Fehlermeldungen korrekt und informativ sind.
        * Testen der `source()`-Kette, um sicherzustellen, dass die Ursprungsfehler bei der Konvertierung beibehalten werden.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (72 von 100+) widmet sich der Implementierung des `novade-domain/src/system_tray/service_iface.rs` Moduls. Dieses Modul definiert den Vertrag für den Dienst, der für die Verwaltung und Interaktion mit System-Tray-Symbolen zuständig ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 72/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.26.4. `novade-domain/src/system_tray/service_iface.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/system_tray/service_iface.rs`
* **Verantwortlichkeit:** Definiert den `SystemTrayService` Trait. Dieser Trait ist die primäre Schnittstelle für das NovaDE-Panel oder andere UI-Komponenten, die System-Tray-Symbole erkennen, darstellen und mit ihnen interagieren müssen. Er abstrahiert die Komplexität der zugrunde liegenden Protokolle (XEmbed und StatusNotifierItem/D-Bus) und bietet eine einheitliche API für die Verwaltung von Tray-Elementen. Alle Methoden sind asynchron, da die Interaktion mit Tray-Anwendungen über D-Bus oder X-Protokoll asynchrone Operationen sind.
* **Kern-Aufgaben (Tasks):**
    1.  **`SystemTrayService` Trait definieren:**
        * Nutze `#[async_trait]` für alle Methoden.
        * Alle Methoden geben `Result<(), SystemTrayError>` oder `Result<T, SystemTrayError>` zurück, um eine konsistente Fehlerbehandlung zu gewährleisten.
        * **Methoden:**
            * `initialize(&self) -> Result<(), SystemTrayError>`:
                * Initialisiert den Dienst und startet die Listener für XEmbed- und StatusNotifierItem-Protokolle.
                * Sollte idempotent sein.
                * **Fehlerbehandlung:** `SystemTrayError::DbusError`, `SystemTrayError::XError`, `SystemTrayError::IoError`.
            * `get_all_items(&self) -> Result<Vec<SystemTrayItem>, SystemTrayError>`:
                * Gibt eine Liste aller aktuell registrierten System-Tray-Elemente zurück.
                * **Logik:** Sammelt Informationen von allen aktiven XEmbed- und StatusNotifierItem-Quellen.
                * **Fehlerbehandlung:** `SystemTrayError::DbusError`, `SystemTrayError::XError`, `SystemTrayError::InvalidData`.
            * `activate_item(&self, item_id: &str, x: i32, y: i32) -> Result<(), SystemTrayError>`:
                * Simuliert einen primären Klick auf ein System-Tray-Element. `x` und `y` sind die Koordinaten des Klicks im Tray-Bereich.
                * **Logik:** Basierend auf `item_id` wird entweder eine D-Bus-Methode (`Activate`) für StatusNotifierItems aufgerufen oder ein XEvent für XEmbed-Icons gesendet.
                * **Fehlerbehandlung:** `SystemTrayError::ItemNotFound`, `SystemTrayError::DbusError`, `SystemTrayError::XError`.
            * `show_item_context_menu(&self, item_id: &str, x: i32, y: i32) -> Result<(), SystemTrayError>`:
                * Fordert das Kontextmenü eines System-Tray-Elements an und zeigt es an den gegebenen Bildschirmkoordinaten an.
                * **Logik:** Für StatusNotifierItems wird eine D-Bus-Methode (`ContextMenu`) aufgerufen. Für XEmbed wird ein Rechtsklick-Event gesendet oder eine spezifische Eigenschaft abgefragt.
                * **Fehlerbehandlung:** `SystemTrayError::ItemNotFound`, `SystemTrayError::DbusError`, `SystemTrayError::XError`.
            * `item_menu_event(&self, item_id: &str, menu_item_id: u32) -> Result<(), SystemTrayError>`:
                * Informiert das System-Tray-Element, dass ein bestimmter Menüeintrag (identifiziert durch `menu_item_id`) im Kontextmenü des Elements angeklickt wurde.
                * **Logik:** Für StatusNotifierItems wird eine D-Bus-Methode (`MenuItemActivated`) aufgerufen. Für XEmbed sind die Interaktionen komplexer und müssen direkt an das X-Fenster des Tray-Elements gesendet werden.
                * **Fehlerbehandlung:** `SystemTrayError::ItemNotFound`, `SystemTrayError::DbusError`, `SystemTrayError::XError`.
            * `on_item_added(&self) -> impl Stream<Item = SystemTrayItem> + Send + Sync`:
                * Gibt einen asynchronen Stream zurück, der ein neues `SystemTrayItem` liefert, wenn ein neues Element registriert wird.
                * **Logik:** Intern werden D-Bus-Signale (`NewItem`) und X-Eigenschaftenänderungen (`_NET_SYSTEM_TRAY_OPCODE`) überwacht.
            * `on_item_removed(&self) -> impl Stream<Item = String> + Send + Sync`:
                * Gibt einen asynchronen Stream zurück, der die ID eines `SystemTrayItem` liefert, wenn ein Element entfernt wird.
                * **Logik:** Intern werden D-Bus-Signale (`ItemRemoved`) und X-Eigenschaftenänderungen überwacht.
            * `on_item_updated(&self) -> impl Stream<Item = SystemTrayItem> + Send + Sync`:
                * Gibt einen asynchronen Stream zurück, der ein aktualisiertes `SystemTrayItem` liefert, wenn sich dessen Status (Icon, Tooltip, Menü) ändert.
                * **Logik:** Intern werden D-Bus-Signale (`NewIcon`, `NewTitle`, `NewTooltip`, `NewMenu`) und X-Eigenschaftenänderungen überwacht.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/system_tray/service_iface.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::system_tray::data_types::{SystemTrayItem, SystemTrayMenu, SystemTrayIcon}`
        * `crate::system_tray::errors::SystemTrayError`
    * **Extern:** `async_trait::async_trait`, `futures::Stream`.
* **Kommunikationsmuster:**
    * Dieser Trait wird von konkreten Dienstimplementierungen (z.B. `DefaultSystemTrayService`) implementiert.
    * Die UI-Schicht (z.B. das NovaDE-Panel) wird diesen Trait nutzen, um System-Tray-Symbole zu erhalten, zu rendern und Benutzerinteraktionen an die richtigen Anwendungen weiterzuleiten.
* **Erwartete Ergebnisse/Outputs:** Eine robuste und umfassende Schnittstelle für die Integration von System-Tray-Funktionalität, die eine flexible Interaktion mit Anwendungen über beide gängigen Protokolle ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine direkten Tests für diesen Trait, da er nur eine Definition ist. Die Tests erfolgen für die konkreten Implementierungen (`DefaultSystemTrayService`).

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (73 von 100+) widmet sich der Implementierung des `novade-domain/src/system_tray/service.rs` Moduls. Dies ist die konkrete Implementierung des `SystemTrayService`-Traits und bildet die zentrale Komponente für die Verwaltung und Interaktion mit System-Tray-Symbolen in NovaDE.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 73/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.26.5. `novade-domain/src/system_tray/service.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/system_tray/service.rs`
* **Verantwortlichkeit:** Implementiert den `SystemTrayService`-Trait. Dieser Dienst ist verantwortlich für das Erkennen, Verwalten und die Interaktion mit System-Tray-Icons, die sowohl das ältere **XEmbed**-Protokoll als auch das modernere **StatusNotifierItem** (D-Bus-basiert) verwenden. Er fungiert als Broker zwischen den Tray-Anwendungen und der NovaDE-Shell, um Icons, Tooltips und Kontextmenüs bereitzustellen und Klickereignisse weiterzuleiten.
* **Kern-Aufgaben (Tasks):**

    1.  **`DefaultSystemTrayService` Struct definieren:**
        * **Felder:**
            * `dbus_connection: Arc<zbus::Connection>`: Geteilte Referenz zur System- oder Session-D-Bus-Verbindung. Für StatusNotifierItems wird normalerweise die Session-Bus-Verbindung verwendet.
            * `status_notifier_host_proxy: Arc<zbus::Proxy<'static>>`: Proxy für den `org.kde.StatusNotifierHost` D-Bus-Dienst. Dies ist die Komponente, die den StatusNotifierItems signalisiert, dass ein Host vorhanden ist.
            * `tray_items: Arc<RwLock<HashMap<String, SystemTrayItem>>>`: Ein Thread-sicherer Cache aller aktuell bekannten `SystemTrayItem`s, indiziert nach ihrer ID.
            * `item_added_sender: tokio::sync::mpsc::UnboundedSender<SystemTrayItem>`: Sender für den `on_item_added` Stream.
            * `item_removed_sender: tokio::sync::mpsc::UnboundedSender<String>`: Sender für den `on_item_removed` Stream.
            * `item_updated_sender: tokio::sync::mpsc::UnboundedSender<SystemTrayItem>`: Sender für den `on_item_updated` Stream.
            * `_item_added_receiver: tokio::sync::mpsc::UnboundedReceiver<SystemTrayItem>`: Interner Empfänger für `item_added_sender`.
            * `_item_removed_receiver: tokio::sync::mpsc::UnboundedReceiver<String>`: Interner Empfänger für `item_removed_sender`.
            * `_item_updated_receiver: tokio::sync::mpsc::UnboundedReceiver<SystemTrayItem>`: Interner Empfänger für `item_updated_sender`.
            * `x_connection: Arc<xcb::Connection>`: Geteilte Referenz zur XCB-Verbindung für XEmbed-Interaktion.
            * `x_tray_window_id: u32`: Die XID des NovaDE-eigenen System-Tray-Fensters für XEmbed.

    2.  **Konstruktor `new(dbus_connection: Arc<zbus::Connection>, x_connection: Arc<xcb::Connection>)` implementieren:**
        * Initialisiert alle `mpsc` Kanäle.
        * Initialisiert `tray_items` als leere `HashMap`.
        * Erstellt `status_notifier_host_proxy` für den **Session-D-Bus-Bus**, Interface `org.kde.StatusNotifierHost`, Objektpfad `/StatusNotifierHost`.
        * **XEmbed-Spezifisch:**
            * Erstellt ein unsichtbares Top-Level-Fenster für das System-Tray (`_NET_SYSTEM_TRAY_WINDOW_FOR_SCREEN`).
            * Setzt die Atom `_NET_SYSTEM_TRAY_ORIENTATION` auf `HORZ` oder `VERT`.
            * Setzt die Atom `_NET_SYSTEM_TRAY_VISUAL` auf eine geeignete Visual-ID.
            * Sendet das ClientMessage-Event `MANAGER_START` mit der Atom `_NET_SYSTEM_TRAY_S0` und der XID des Tray-Fensters. Dies signalisiert anderen Anwendungen, dass NovaDE ein System-Tray hostet.
            * Speichert die `x_tray_window_id`.
        * Gibt das `DefaultSystemTrayService` Struct zurück.

    3.  **Implementierung des `SystemTrayService`-Traits für `DefaultSystemTrayService`:**

        * **`initialize(&self) -> Result<(), SystemTrayError>`:**
            * Registriert diesen Host beim `StatusNotifierWatcher` über D-Bus (z.B. durch Aufruf der `RegisterStatusNotifierHost` Methode).
            * Startet eine Tokio-Task, die auf `PropertiesChanged` Signale von registrierten StatusNotifierItems lauscht (z.B. für `IconName`, `IconPixmap`, `ToolTip`, `Menu`). Bei Änderungen wird das `SystemTrayItem` aktualisiert und über `item_updated_sender` gesendet.
            * Startet eine Tokio-Task, die auf `NewItem` Signale vom `StatusNotifierWatcher` lauscht. Bei neuen Items werden diese hinzugefügt und über `item_added_sender` gesendet.
            * Startet eine Tokio-Task, die auf `ItemRemoved` Signale vom `StatusNotifierWatcher` lauscht. Bei entfernten Items werden diese aus dem Cache entfernt und über `item_removed_sender` gesendet.
            * Startet eine Tokio-Task, die auf XCB-Events für das `x_tray_window_id` lauscht. Dies beinhaltet `ClientMessage` (für neue XEmbed-Items), `PropertyNotify` (für Änderungen an Icons/Tooltips) und `ButtonPress` (für Klicks).
            * **Fehlerbehandlung:** Kapselt `zbus::Error` und `xcb::Error` in `SystemTrayError` Varianten.

        * **`get_all_items(&self) -> Result<Vec<SystemTrayItem>, SystemTrayError>`:**
            * Holt einen Lese-Lock auf `self.tray_items`.
            * Gibt alle im Cache befindlichen `SystemTrayItem`s zurück.
            * Sollte initial auch alle vorhandenen StatusNotifierItems abfragen (mittels `GetRegisteredItems` vom `StatusNotifierWatcher`) und XEmbed-Items, die sich bereits registriert haben.

        * **`activate_item(&self, item_id: &str, x: i32, y: i32) -> Result<(), SystemTrayError>`:**
            * Sucht das `SystemTrayItem` mit der `item_id` im `tray_items`-Cache.
            * **Logik (unterscheide nach Protokoll):**
                * **StatusNotifierItem:** Erstelle einen D-Bus-Proxy zum jeweiligen Item und rufe die Methode `Activate(x, y)` auf dem `org.kde.StatusNotifierItem` Interface auf.
                * **XEmbed:** Sende ein `ButtonPress` X-Event (Button 1, linke Maustaste) an das X-Fenster des Tray-Elements mit den gegebenen Koordinaten.
            * **Fehlerbehandlung:** `SystemTrayError::ItemNotFound`, `SystemTrayError::DbusError`, `SystemTrayError::XError`.

        * **`show_item_context_menu(&self, item_id: &str, x: i32, y: i32) -> Result<(), SystemTrayError>`:**
            * Sucht das `SystemTrayItem` mit der `item_id`.
            * **Logik (unterscheide nach Protokoll):**
                * **StatusNotifierItem:** Erstelle einen D-Bus-Proxy und rufe `ContextMenu(x, y)` auf. Der Dienst muss dann den Menüinhalt über das `Menu` Property des StatusNotifierItems abrufen.
                * **XEmbed:** Sende ein `ButtonPress` X-Event (Button 3, rechte Maustaste) an das X-Fenster des Tray-Elements. Das Menü muss dann von NovaDE auf Basis der Informationen des Tray-Elements (falls verfügbar) oder durch den XEmbed-Protokoll-Fluss aufgebaut werden.
            * **Fehlerbehandlung:** `SystemTrayError::ItemNotFound`, `SystemTrayError::DbusError`, `SystemTrayError::XError`.

        * **`item_menu_event(&self, item_id: &str, menu_item_id: u32) -> Result<(), SystemTrayError>`:**
            * Sucht das `SystemTrayItem` mit der `item_id`.
            * **Logik (unterscheide nach Protokoll):**
                * **StatusNotifierItem:** Erstelle einen D-Bus-Proxy und rufe `MenuItemActivated(menu_item_id)` auf.
                * **XEmbed:** Dies ist komplexer. XEmbed-Menüs werden oft als `_NET_SYSTEM_TRAY_OPCODE` mit spezifischen Werten gehandhabt, oder das Tray-Fenster selbst empfängt Events. Hier muss die interne Implementierung sorgfältig erfolgen, um den richtigen X-Event zu senden.
            * **Fehlerbehandlung:** `SystemTrayError::ItemNotFound`, `SystemTrayError::DbusError`, `SystemTrayError::XError`.

        * **`on_item_added(&self) -> impl Stream<Item = SystemTrayItem> + Send + Sync`:**
            * Gibt einen `tokio_stream::wrappers::UnboundedReceiverStream` über den Empfänger des `item_added_sender` zurück.

        * **`on_item_removed(&self) -> impl Stream<Item = String> + Send + Sync`:**
            * Gibt einen `tokio_stream::wrappers::UnboundedReceiverStream` über den Empfänger des `item_removed_sender` zurück.

        * **`on_item_updated(&self) -> impl Stream<Item = SystemTrayItem> + Send + Sync`:**
            * Gibt einen `tokio_stream::wrappers::UnboundedReceiverStream` über den Empfänger des `item_updated_sender` zurück.

    4.  **Private Hilfsmethoden implementieren:**
        * `_listen_for_status_notifier_items()`: Eine `async` Task, die D-Bus-Signale von `org.kde.StatusNotifierWatcher` und individuellen StatusNotifierItems abhört. Parst die empfangenen D-Bus-Daten in `SystemTrayItem` und sendet sie an die entsprechenden `mpsc::Sender`.
        * `_listen_for_xembed_items()`: Eine `async` Task, die XCB-Events für das System-Tray-Fenster abhört. Interpretieren von `ClientMessage` für neue Items, `PropertyNotify` für Icon/Tooltip-Änderungen und Button-Events. Wandelt XEmbed-spezifische Daten in `SystemTrayItem` um.
        * `_get_status_notifier_item_details(service_name: &str, object_path: &str) -> Result<SystemTrayItem, SystemTrayError>`: Hilfsfunktion zum Abrufen aller Details eines StatusNotifierItems über D-Bus-Properties.
        * `_get_xembed_item_details(window_id: u32) -> Result<SystemTrayItem, SystemTrayError>`: Hilfsfunktion zum Abrufen aller Details eines XEmbed-Items über Xlib-Properties.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/system_tray/service.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::system_tray::data_types::{SystemTrayItem, SystemTrayMenu, SystemTrayIcon, SystemTrayMenuItem}`
        * `crate::system_tray::errors::SystemTrayError`
        * `crate::system_tray::service_iface::SystemTrayService`
    * **Extern:** `async_trait::async_trait`, `tokio`, `tokio::sync::{mpsc, RwLock}`, `futures::Stream`, `tokio_stream::wrappers::UnboundedReceiverStream`, `zbus`, `xcb`, `std::sync::Arc`, `std::collections::HashMap`, `tracing`.
* **Kommunikationsmuster:** Interagiert direkt mit dem D-Bus-System und dem X-Server. Stellt die gesammelten und verarbeiteten Daten über die `SystemTrayService`-Trait-Methoden und asynchrone Streams der UI-Schicht zur Verfügung.
* **Erwartete Ergebnisse/Outputs:** Ein voll funktionsfähiger System-Tray-Dienst, der nahtlos mit XEmbed- und StatusNotifierItem-Anwendungen zusammenarbeitet, deren Icons, Tooltips und Kontextmenüs korrekt anzeigt und Benutzerinteraktionen weiterleitet.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests (mit Mocks/Isolation):**
        * **Mocking:** Mock `zbus::Connection` und `xcb::Connection` um simulierte D-Bus-Signale und X-Events zu senden und deren Verhalten zu kontrollieren.
        * Testen der `initialize` Methode, um sicherzustellen, dass Listener korrekt gestartet werden und die D-Bus-Registrierung erfolgt.
        * Testen der `get_all_items` Methode mit simulierten vorhandenen Items.
        * Testen von `activate_item`, `show_item_context_menu`, `item_menu_event` durch Simulation von D-Bus-Methodenaufrufen oder X-Events.
        * Testen der **Stream-Funktionalität**: Senden Sie simulierte `NewItem`, `ItemRemoved`, `PropertiesChanged` Signale/Events und verifizieren Sie, dass die korrekten Daten über die `on_item_added`, `on_item_removed`, `on_item_updated` Streams empfangen werden.
        * Testen der korrekten Umwandlung von D-Bus-Properties/X-Properties in `SystemTrayItem` Datenstrukturen.
    * **Integration Tests:**
        * Starten Sie den NovaDE-Dienst mit einem echten D-Bus-System und X-Server (oder einem simulierten X-Server wie Xvfb).
        * Starten Sie bekannte StatusNotifierItem-Anwendungen (z.B. `nm-applet`, `blueman-applet`) und XEmbed-Anwendungen (ältere Versionen von `VLC`, `Skype`).
        * Verifizieren Sie, dass die Tray-Icons erscheinen und korrekt dargestellt werden.
        * Simulieren Sie Mausklicks und Rechtsklicks auf die Icons und prüfen Sie, ob die entsprechenden Aktionen in den Anwendungen ausgelöst werden.
        * Überwachen Sie die Streams und stellen Sie sicher, dass Updates (z.B. Icon-Änderungen, Tooltip-Änderungen) korrekt übermittelt werden.


---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (74 von 100+) widmet sich der Initialisierung des `novade-domain/src/theme/mod.rs` Moduls. Dieses Modul wird die Funktionalität kapseln, die für die Verwaltung und Anwendung von Themes (visuellen Stilen) innerhalb der NovaDE-Desktop-Umgebung erforderlich ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 74/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.27. `novade-domain/src/theme` Verzeichnis

Dieses Verzeichnis ist für die Verwaltung und Anwendung von visuellen Themes im NovaDE-Desktop verantwortlich. Es stellt die nötigen Mechanismen bereit, um das Erscheinungsbild von UI-Komponenten (Farben, Schriftarten, Icons, Stile von Widgets) zu steuern und dynamisch zu wechseln. Ein robustes Theming-System ist entscheidend für eine personalisierbare und ästhetisch ansprechende Desktop-Umgebung. Es muss die XDG-Spezifikationen für Icon-Themes und GTK-Themes berücksichtigen, um eine breite Kompatibilität zu gewährleisten.

#### 3.27.1. `novade-domain/src/theme/mod.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/theme/mod.rs`
* **Verantwortlichkeit:** Definiert die öffentliche API des `theme`-Moduls der Domänenschicht. Es re-exportiert alle wichtigen Typen, Traits, Enums und Strukturen, die von der UI-Schicht (z.B. für Einstellungsdialoge, die Theme-Auswahl anbieten) oder anderen Diensten der Domänenschicht benötigt werden, um Themes zu verwalten und anzuwenden.
* **Kern-Aufgaben (Tasks):**
    1.  **Public API Definition:** Re-exportiere die folgenden Komponenten, die die Schnittstelle dieses Moduls bilden:
        * `data_types` (alle relevanten Typen wie `Theme`, `IconTheme`, `ColorPalette`, `FontSettings`, `WidgetStyle`).
        * `errors` (das `ThemeError` Enum).
        * `service_iface` (den `ThemeService` Trait).
        * `service` (die konkrete `DefaultThemeService` Implementierung).
    2.  **Modul-Strukturierung:** Stelle sicher, dass alle Re-Exporte korrekt sind und keine internen Implementierungsdetails unnötigerweise exponiert werden.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/theme/mod.rs`
* **Abhängigkeiten:**
    * **Intern:** `data_types`, `errors`, `service_iface`, `service` (innerhalb desselben `theme` Moduls).
    * **Extern:** Keine direkten, da nur Re-Exporte stattfinden.
* **Kommunikationsmuster:** Stellt die Hauptschnittstelle des `theme`-Moduls zur Verfügung. Es ist der primäre Punkt, über den die UI-Schicht und andere Dienste Theme-Informationen abrufen und Theme-Änderungen anstoßen.
* **Erwartete Ergebnisse/Outputs:** Eine klar definierte und leicht nutzbare öffentliche API für das Theming innerhalb der Domänenschicht, die konsistente Interaktionen über alle Schichten hinweg ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte sind. Die Tests erfolgen in den jeweiligen Submodulen.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (75 von 100+) widmet sich der Implementierung der grundlegenden Datentypen für das Theme-Modul in `novade-domain/src/theme/data_types.rs`. Diese Strukturen sind entscheidend, um die vielfältigen Aspekte eines visuellen Themes zu definieren und zu verwalten.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 75/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.27.2. `novade-domain/src/theme/data_types.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/theme/data_types.rs`
* **Verantwortlichkeit:** Definiert die **Datenstrukturen zur Repräsentation von Themes** im NovaDE-Desktop. Dies umfasst die Konfiguration von Farben, Schriftarten, Icon-Sets und allgemeinen Widget-Stilen. Diese Typen dienen als Transportmittel für die vom `ThemeService` verwalteten und bereitgestellten Daten, die dann von der UI-Schicht (z.B. dem Compositor, den Widgets) genutzt werden, um das Erscheinungsbild der Desktop-Umgebung dynamisch anzupassen.
* **Kern-Aufgaben (Tasks):**

    1.  **`Color` Struct definieren:**
        * Repräsentiert eine Farbe im RGBA-Format.
        * **Felder:**
            * `r: u8`: Rot-Komponente (0-255).
            * `g: u8`: Grün-Komponente (0-255).
            * `b: u8`: Blau-Komponente (0-255).
            * `a: u8`: Alpha-Komponente (Transparenz, 0-255).
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
        * Implementiere eine `new(r, g, b, a)`-Funktion und Helferfunktionen wie `from_hex(&str) -> Option<Color>`.

    2.  **`ColorPalette` Struct definieren:**
        * Definiert eine Reihe von Farbvariablen, die im gesamten Theme verwendet werden.
        * **Felder:**
            * `primary: Color`: Primärfarbe für UI-Elemente.
            * `secondary: Color`: Sekundärfarbe.
            * `background: Color`: Hintergrundfarbe von Flächen.
            * `surface: Color`: Farbe von Oberflächen (z.B. Karten, Fensterhintergründe).
            * `on_primary: Color`: Farbe für Text/Icons auf primären Elementen.
            * `on_secondary: Color`: Farbe für Text/Icons auf sekundären Elementen.
            * `on_background: Color`: Farbe für Text/Icons auf Hintergründen.
            * `on_surface: Color`: Farbe für Text/Icons auf Oberflächen.
            * `error: Color`: Farbe für Fehlermeldungen.
            * `on_error: Color`: Farbe für Text/Icons auf Fehlerelementen.
            * `success: Color`: Farbe für Erfolgsmeldungen.
            * `warning: Color`: Farbe für Warnmeldungen.
            * `text_primary: Color`: Haupt-Textfarbe.
            * `text_secondary: Color`: Sekundäre Textfarbe.
            * `border: Color`: Farbe für Ränder und Trennlinien.
            * `shadow: Color`: Farbe für Schatteneffekte.
            * `selection_background: Color`: Hintergrundfarbe für ausgewählte Elemente.
            * `selection_text: Color`: Textfarbe für ausgewählte Elemente.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion, die Standardfarben initialisiert.

    3.  **`FontSettings` Struct definieren:**
        * Definiert Schriftarteinstellungen.
        * **Felder:**
            * `font_family: String`: Der Name der Schriftfamilie (z.B. "Roboto", "Noto Sans").
            * `font_size: f32`: Standard-Schriftgröße in Pt oder Px.
            * `font_weight: u16`: Schriftstärke (z.B. 400 für Normal, 700 für Bold).
            * `line_height: f32`: Zeilenhöhe als Multiplikator der Schriftgröße.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion.

    4.  **`IconTheme` Struct definieren:**
        * Definiert die Einstellungen für Icon-Themes.
        * **Felder:**
            * `name: String`: Der Name des Icon-Themes (z.B. "Adwaita", "Papirus").
            * `fallback_themes: Vec<String>`: Eine Liste von Fallback-Icon-Themes, falls ein Icon im Haupt-Theme nicht gefunden wird.
            * `cursor_theme: String`: Name des Mauszeiger-Themes.
            * `cursor_size: u32`: Größe des Mauszeigers.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion.

    5.  **`WidgetStyle` Struct definieren:**
        * Definiert generische Stilattribute für UI-Widgets. Dies kann später durch spezifischere Widget-Typen erweitert werden.
        * **Felder:**
            * `border_radius: f32`: Standard-Randradius für runde Ecken.
            * `shadow_elevation: f32`: Schattenstärke.
            * `spacing: f32`: Standard-Abstand zwischen UI-Elementen.
            * `animation_duration_ms: u64`: Standard-Dauer für Animationen in Millisekunden.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion.

    6.  **`Theme` Struct definieren:**
        * Das Haupt-Struct, das ein vollständiges NovaDE-Theme repräsentiert.
        * **Felder:**
            * `id: String`: Eine eindeutige ID für das Theme (z.B. "nova-light", "nova-dark").
            * `name: String`: Der sichtbare Name des Themes (z.B. "Nova Light", "Nova Dark").
            * `description: String`: Eine kurze Beschreibung des Themes.
            * `version: String`: Versionsnummer des Themes.
            * `author: String`: Autor des Themes.
            * `colors: ColorPalette`: Die Farbpalette des Themes.
            * `fonts: FontSettings`: Die Schriftarteinstellungen.
            * `icons: IconTheme`: Die Icon-Theme-Einstellungen.
            * `widgets: WidgetStyle`: Allgemeine Widget-Stile.
            * `stylesheet_path: Option<PathBuf>`: Optionaler Pfad zu einer CSS- oder SCSS-Datei, die zusätzliche Stile definiert.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/theme/data_types.rs`
* **Abhängigkeiten:**
    * **Extern:** `serde::{Serialize, Deserialize}`, `std::path::PathBuf`.
* **Kommunikationsmuster:**
    * Diese Strukturen werden vom `ThemeService` erstellt, geladen und als aktuelles Theme an die UI-Schicht übermittelt.
    * Die UI-Schicht empfängt diese Strukturen, um ihre Rendering-Pipeline entsprechend anzupassen.
* **Erwartete Ergebnisse/Outputs:** Klare und konsistente Datenmodelle zur Repräsentation aller relevanten Aspekte eines visuellen Themes, die eine einfache Nutzung durch den NovaDE-Desktop ermöglichen.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der `Default` Implementierungen für alle Strukturen.
        * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` (für `Color`) Implementierungen.
        * Testen der `new()`-Funktionen, um sicherzustellen, dass alle Felder korrekt initialisiert werden.
        * Testen der `Color::from_hex` Funktion mit gültigen und ungültigen Hex-Strings.
        * Testen der Serialisierung und Deserialisierung (z.B. zu/von JSON) für jede Struktur, um die Korrektheit der Datenpersistenz zu gewährleisten.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (76 von 100+) widmet sich der Implementierung der Fehlerdefinitionen für das Theme-Modul in `novade-domain/src/theme/errors.rs`. Eine präzise Fehlerbehandlung ist entscheidend, um Probleme beim Laden, Parsen oder Anwenden von Themes zu identifizieren und zu kommunizieren.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 76/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.27.3. `novade-domain/src/theme/errors.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/theme/errors.rs`
* **Verantwortlichkeit:** Definiert ein konsolidiertes Fehler-Enum (`ThemeError`) für alle Operationen, die innerhalb des `theme`-Moduls der Domänenschicht auftreten können. Dieses Enum kapselt spezifische Fehlerquellen wie fehlende Theme-Dateien, ungültige Konfigurationsformate, Fehler beim Parsen von Farben oder Schriftarten, oder Probleme beim Laden von Icon-Ressourcen. Die Nutzung von `thiserror` ist obligatorisch.
* **Kern-Aufgaben (Tasks):**
    1.  **`ThemeError` Enum definieren:**
        * Nutze `#[derive(thiserror::Error, Debug)]` für automatische Implementierung der `Error` und `Debug` Traits.
        * **Varianten:**
            * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler, z.B. beim Lesen von Theme-Konfigurationsdateien oder Icon-Assets.
                * `#[error("I/O error during theme operation: {0}")]`
            * `ParseError { file: String, details: String }`: Fehler beim Parsen einer Theme-Konfigurationsdatei (z.B. TOML, JSON oder CSS). Enthält den Dateinamen und eine detaillierte Fehlermeldung.
                * `#[error("Failed to parse theme file '{file}': {details}")]`
            * `ThemeNotFound(String)`: Wenn ein angefordertes Theme nicht gefunden werden kann. Die `String` enthält den Namen oder die ID des fehlenden Themes.
                * `#[error("Theme '{0}' not found.")]`
            * `InvalidColorFormat(String)`: Wenn ein Farbwert in einem ungültigen Format vorliegt (z.B. ungültiger Hex-Code).
                * `#[error("Invalid color format: {0}")]`
            * `InvalidFontSettings(String)`: Wenn Schriftarteinstellungen ungültig sind (z.B. nicht existierende Schriftfamilie, ungültige Größe).
                * `#[error("Invalid font settings: {0}")]`
            * `SerializationError(#[from] serde_json::Error)`: Fehler, die während der Serialisierung oder Deserialisierung von Theme-Daten auftreten (z.B. wenn Themes in einer JSON-Datei gespeichert werden).
                * `#[error("Serialization/deserialization error for theme data: {0}")]`
            * `Other(String)`: Ein Catch-All für unvorhergesehene oder nicht spezifisch handhabbare Fehler.
                * `#[error("An unexpected theme error occurred: {0}")]`
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/theme/errors.rs`
* **Abhängigkeiten:**
    * **Extern:** `thiserror::Error`, `std::io::Error`, `serde_json::Error`.
* **Kommunikationsmuster:**
    * Wird als `E` (Fehler-Typ) in `Result<T, E>` Signaturen aller öffentlichen Funktionen und Methoden des `theme`-Moduls verwendet (z.B. `ThemeService`).
    * Sollte von `std::io::Error` und `serde_json::Error` Fehlertypen erhalten und in die eigene Variante konvertieren (`#[from]`).
    * Wird von der UI-Schicht oder anderen Diensten empfangen und dort in ein übergeordnetes Fehler-Enum gekapselt oder direkt behandelt.
* **Erwartete Ergebnisse/Outputs:** Ein klar strukturiertes und wartbares Fehler-Enum, das alle denkbaren Fehlerzustände im Theme-Modul abdeckt und eine konsistente Fehlerbehandlung ermöglicht.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der Instanziierung jeder Fehlervariante mit aussagekräftigen Daten (z.B. Dateipfade, Fehlermeldungen, ungültige Werte).
        * Testen der `#[from]`-Konvertierungen von `std::io::Error` und `serde_json::Error`.
        * Testen der `Display`-Implementierung (via `to_string()`) für jede Fehlervariante, um sicherzustellen, dass die Fehlermeldungen korrekt und informativ sind.
        * Testen der `source()`-Kette, um sicherzustellen, dass die Ursprungsfehler bei der Konvertierung beibehalten werden.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (77 von 100+) widmet sich der Implementierung des `novade-domain/src/theme/service_iface.rs` Moduls. Dieses Modul definiert den Vertrag für den Dienst, der für die Verwaltung und Anwendung von Themes zuständig ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 77/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.27.4. `novade-domain/src/theme/service_iface.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/theme/service_iface.rs`
* **Verantwortlichkeit:** Definiert den **`ThemeService` Trait**. Dieser Trait ist die primäre Schnittstelle für UI-Komponenten (z.B. der Compositor, Panels, Widgets) und Einstellungsanwendungen, die Informationen über verfügbare Themes abrufen, das aktuell angewendete Theme ändern oder auf Theme-Änderungen reagieren müssen. Er abstrahiert die Komplexität des Ladens, Parsens und der Verwaltung von Theme-Dateien und bietet eine einheitliche API. Alle Methoden sind asynchron, da das Laden und Anwenden von Themes I/O-Operationen und möglicherweise umfangreiche Parsvorgänge beinhalten kann.
* **Kern-Aufgaben (Tasks):**
    1.  **`ThemeService` Trait definieren:**
        * Nutze `#[async_trait]` für alle Methoden.
        * Alle Methoden geben `Result<(), ThemeError>` oder `Result<T, ThemeError>` zurück, um eine konsistente Fehlerbehandlung zu gewährleisten.
        * **Methoden:**
            * `initialize(&self) -> Result<(), ThemeError>`:
                * Initialisiert den Dienst, lädt die Liste der verfügbaren Themes und setzt das initial standardmäßig oder zuletzt gespeicherte Theme.
                * Sollte idempotent sein.
                * **Fehlerbehandlung:** `ThemeError::IoError`, `ThemeError::ParseError`, `ThemeError::ThemeNotFound`.
            * `get_available_themes(&self) -> Result<Vec<Theme>, ThemeError>`:
                * Gibt eine Liste aller auf dem System gefundenen und von NovaDE unterstützten Themes zurück.
                * **Logik:** Scannt vordefinierte Theme-Pfade (z.B. `~/.local/share/novade/themes/`, `/usr/share/novade/themes/`) nach Theme-Konfigurationsdateien (z.B. `theme.json` oder `theme.toml`). Parst die Metadaten jedes Themes.
                * **Fehlerbehandlung:** `ThemeError::IoError`, `ThemeError::ParseError`.
            * `get_current_theme(&self) -> Result<Theme, ThemeError>`:
                * Gibt das aktuell angewendete Theme zurück.
                * **Logik:** Ruft das intern gecachte oder persistierte aktuelle Theme ab.
                * **Fehlerbehandlung:** `ThemeError::ThemeNotFound` (falls kein Theme gesetzt ist, was nicht passieren sollte, wenn `initialize` erfolgreich war).
            * `apply_theme(&self, theme_id: &str) -> Result<(), ThemeError>`:
                * Wendet ein Theme mit der gegebenen ID an.
                * **Logik:** Lädt das Theme, speichert es als aktuelles Theme (persistent), und sendet ein Update-Signal an alle Abonnenten (`on_theme_changed`).
                * **Fehlerbehandlung:** `ThemeError::ThemeNotFound`, `ThemeError::IoError`, `ThemeError::ParseError`, `ThemeError::InvalidColorFormat`, `ThemeError::InvalidFontSettings`.
            * `on_theme_changed(&self) -> impl Stream<Item = Theme> + Send + Sync`:
                * Gibt einen asynchronen Stream zurück, der das neue `Theme`-Objekt liefert, wenn das aktuell angewendete Theme geändert wird.
                * **Logik:** Intern wird ein Broadcast-Channel oder ähnliches verwendet, um Theme-Änderungen an alle Listener zu publizieren.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/theme/service_iface.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::theme::data_types::Theme`
        * `crate::theme::errors::ThemeError`
    * **Extern:** `async_trait::async_trait`, `futures::Stream`.
* **Kommunikationsmuster:**
    * Dieser Trait wird von konkreten Dienstimplementierungen (z.B. `DefaultThemeService`) implementiert.
    * Die UI-Schicht (z.B. Einstellungsdialoge) nutzt diesen Trait, um verfügbare Themes anzuzeigen und die Auswahl des Benutzers zu persistieren.
    * Der Compositor und andere UI-Komponenten abonnieren den `on_theme_changed`-Stream, um ihre Darstellung dynamisch an das neue Theme anzupassen.
* **Erwartete Ergebnisse/Outputs:** Eine robuste und umfassende Schnittstelle für das Theming in NovaDE, die eine flexible Verwaltung und dynamische Anwendung visueller Stile ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine direkten Tests für diesen Trait, da er nur eine Definition ist. Die Tests erfolgen für die konkreten Implementierungen (`DefaultThemeService`).

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (78 von 100+) widmet sich der Implementierung des `novade-domain/src/theme/service.rs` Moduls. Dies ist die konkrete Implementierung des `ThemeService`-Traits und bildet die zentrale Komponente für das dynamische Theming der NovaDE-Desktop-Umgebung.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 78/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.27.5. `novade-domain/src/theme/service.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/theme/service.rs`
* **Verantwortlichkeit:** Implementiert den **`ThemeService`-Trait**. Dieser Dienst ist dafür zuständig, die verfügbaren Themes zu finden, sie zu laden und das aktuell ausgewählte Theme auf das System anzuwenden. Er verwaltet den Zustand des Themes und benachrichtigt abonnierte Komponenten über Änderungen. Er muss XDG-konforme Verzeichnisse für Themes scannen und die Theme-Konfigurationsdateien parsen können.
* **Kern-Aufgaben (Tasks):**

    1.  **`DefaultThemeService` Struct definieren:**
        * **Felder:**
            * `theme_directories: Vec<PathBuf>`: Eine Liste von Verzeichnispfaden, in denen nach Themes gesucht werden soll (z.B. `~/.local/share/novade/themes`, `/usr/share/novade/themes`).
            * `available_themes: Arc<RwLock<HashMap<String, Theme>>>`: Ein Thread-sicherer Cache aller gefundenen und geladenen Themes, indiziert nach ihrer ID.
            * `current_theme: Arc<RwLock<Option<Theme>>>`: Das aktuell angewendete Theme. `Option` für den Initialisierungszustand.
            * `theme_change_sender: tokio::sync::broadcast::Sender<Theme>`: Ein Broadcast-Sender, um Theme-Änderungen an mehrere Listener zu verteilen.
            * `_theme_change_receiver: tokio::sync::broadcast::Receiver<Theme>`: Ein interner Empfänger, um den Sender zu initialisieren.

    2.  **Konstruktor `new()` implementieren:**
        * Initialisiert `theme_directories` mit den XDG-konformen Basispfaden und NovaDE-spezifischen Pfaden.
        * Initialisiert `available_themes` und `current_theme` als leere/leere Strukturen.
        * Erstellt den `tokio::sync::broadcast::channel` für `theme_change_sender` und `_theme_change_receiver` (z.B. mit einer Kapazität von 1, da nur der letzte Wert relevant ist).
        * Gibt das `DefaultThemeService` Struct zurück.

    3.  **Implementierung des `SystemTrayService`-Traits für `DefaultThemeService`:**

        * **`initialize(&self) -> Result<(), ThemeError>`:**
            * Ruft intern `_load_available_themes()` auf, um `available_themes` zu füllen.
            * Ruft intern `_load_persisted_theme()` auf, um das zuletzt gespeicherte Theme zu laden.
            * Wenn kein persistentes Theme gefunden wird oder es ungültig ist, wählt NovaDE ein **Standard-Theme** (z.B. "nova-light"). Dieses muss immer vorhanden sein.
            * Loggt den Initialisierungserfolg oder -fehler.
            * **Fehlerbehandlung:** Alle Fehler von `_load_available_themes()` oder `_load_persisted_theme()` werden weitergegeben.

        * **`get_available_themes(&self) -> Result<Vec<Theme>, ThemeError>`:**
            * Holt einen Lese-Lock auf `self.available_themes`.
            * Gibt alle im Cache befindlichen `Theme`s als `Vec` zurück.
            * **Fehlerbehandlung:** Keine spezifischen Fehler, da der Cache direkt gelesen wird.

        * **`get_current_theme(&self) -> Result<Theme, ThemeError>`:**
            * Holt einen Lese-Lock auf `self.current_theme`.
            * Gibt das geklonte `Theme`-Objekt zurück, falls vorhanden.
            * **Fehlerbehandlung:** Wenn `current_theme` `None` ist (was nach erfolgreicher Initialisierung nicht passieren sollte), gib `ThemeError::ThemeNotFound("No theme currently set".to_string())` zurück.

        * **`apply_theme(&self, theme_id: &str) -> Result<(), ThemeError>`:**
            * Holt einen Lese-Lock auf `self.available_themes`.
            * Sucht das Theme mit der gegebenen `theme_id` im `available_themes`-Cache.
            * **Fehlerbehandlung:** Wenn nicht gefunden, gib `ThemeError::ThemeNotFound(theme_id.to_string())` zurück.
            * Holt einen Schreib-Lock auf `self.current_theme`.
            * Setzt das gefundene Theme als aktuelles Theme.
            * **Persistenz:** Speichert die `theme_id` des neuen Themes in den NovaDE-Einstellungen (über den `ConfigService`). Dies ist ein kritischer Schritt, um den Theme-Zustand zwischen Sitzungen zu erhalten.
            * Sendet das neue Theme über `self.theme_change_sender.send(new_theme.clone())`. Fehler beim Senden sollten geloggt, aber nicht als kritischer Fehler zurückgegeben werden, da es sich um eine Broadcast-Operation handelt.
            * **Fehlerbehandlung:** `ThemeError::IoError` oder `ThemeError::SerializationError` wenn das Speichern fehlschlägt.

        * **`on_theme_changed(&self) -> impl Stream<Item = Theme> + Send + Sync`:**
            * Erstellt einen neuen Empfänger vom `theme_change_sender.subscribe()`.
            * Gibt einen `tokio_stream::wrappers::BroadcastStream` über diesen Empfänger zurück.

    4.  **Private Hilfsmethoden implementieren:**
        * `_load_available_themes(&self) -> Result<(), ThemeError>`:
            * Iteriert über `self.theme_directories`.
            * In jedem Verzeichnis: Scannt nach Unterverzeichnissen, die als Themes gelten könnten (z.B. Verzeichnisse mit einer `theme.json` oder `theme.toml` Datei).
            * Parst die Konfigurationsdatei jedes Themes in ein `Theme`-Struct.
            * Fügt gültige Themes zu `self.available_themes` hinzu.
            * **Fehlerbehandlung:** Loggt Fehler beim Parsen einzelner Themes, ohne den gesamten Ladevorgang abzubrechen. Sammelt jedoch alle `ThemeError`s, die zurückgegeben werden könnten.
        * `_load_persisted_theme(&self) -> Result<(), ThemeError>`:
            * Verwendet den `ConfigService` (als Abhängigkeit oder über eine globale Instanz) um die zuletzt gespeicherte `theme_id` abzurufen.
            * Wenn eine `theme_id` gefunden wird, versucht sie, das entsprechende Theme aus `self.available_themes` zu laden und es als `self.current_theme` zu setzen.
            * Wenn kein persistentes Theme gefunden oder geladen werden kann, wählt es das vordefinierte **Standard-Theme** (z.B. "nova-light").
            * **Fehlerbehandlung:** `ThemeError::ConfigError` wenn der `ConfigService` fehlschlägt, `ThemeError::ThemeNotFound` wenn die persistierte ID nicht im Cache ist.
        * `_parse_theme_file(path: &Path) -> Result<Theme, ThemeError>`: Eine private Helferfunktion zum Lesen und Parsen einer einzelnen Theme-Konfigurationsdatei. Unterstützung für JSON und/oder TOML.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/theme/service.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::theme::data_types::{Theme, Color, ColorPalette, FontSettings, IconTheme, WidgetStyle}`
        * `crate::theme::errors::ThemeError`
        * `crate::theme::service_iface::ThemeService`
        * `crate::config::service_iface::ConfigService` (für Persistenz der Theme-Auswahl)
    * **Extern:** `async_trait::async_trait`, `tokio`, `tokio::sync::{RwLock, broadcast}`, `futures::Stream`, `tokio_stream::wrappers::BroadcastStream`, `std::sync::Arc`, `std::collections::HashMap`, `std::path::PathBuf`, `serde_json` (oder `toml` crate), `tracing`.
* **Kommunikationsmuster:** Wird von NovaDE-Anwendungen und UI-Komponenten über `Arc` und `Stream` verwendet. Der Dienst liest und schreibt auch über den `ConfigService` für die Persistenz.
* **Erwartete Ergebnisse/Outputs:** Ein zuverlässiger und effizienter Theme-Dienst, der das Laden, Anwenden und Benachrichtigen über Theme-Änderungen reibungslos ermöglicht, um ein dynamisches visuelles Erscheinungsbild des Desktops zu gewährleisten.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests (mit Mocks/Isolation):**
        * **Mocking:** Mocken Sie Dateisystemzugriffe (z.B. mit `tempfile` und simulierten Dateiinhalten) und den `ConfigService`.
        * Testen von `_load_available_themes()` mit verschiedenen Verzeichnisstrukturen und gültigen/ungültigen Theme-Dateien.
        * Testen von `_parse_theme_file()` mit korrekt formatierten und fehlerhaften Theme-Konfigurationen (JSON/TOML).
        * Testen von `initialize()`: Sicherstellen, dass Themes korrekt geladen werden und das Standard- oder persistente Theme angewendet wird.
        * Testen von `get_available_themes()` und `get_current_theme()` nach verschiedenen Zuständen.
        * Testen von `apply_theme()`:
            * Prüfen Sie, ob das `current_theme` korrekt aktualisiert wird.
            * Stellen Sie sicher, dass der `ConfigService` korrekt aufgerufen wird, um die Auswahl zu speichern.
            * Überprüfen Sie, dass das neue Theme über den `on_theme_changed` Stream gesendet wird.
        * Testen der Fehlerfälle, z.B. wenn ein angefordertes Theme in `apply_theme` nicht existiert.
        * Testen der Broadcast-Fähigkeit des `on_theme_changed`-Streams mit mehreren Abonnenten.
    * **Integration Tests:**
        * Führen Sie den Dienst in einer Testumgebung mit echten Dateisystempfaden aus.
        * Erstellen Sie temporäre Theme-Dateien und -Verzeichnisse, um den Ladevorgang von `_load_available_themes()` zu testen.
        * Simulieren Sie das Speichern und Laden von Theme-IDs über den `ConfigService` und prüfen Sie, ob der Dienst den Zustand korrekt beibehält.
        * Überwachen Sie den `on_theme_changed`-Stream, wenn `apply_theme` aufgerufen wird, und stellen Sie sicher, dass die korrekten Theme-Daten empfangen werden.


---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (79 von 100+) widmet sich der Initialisierung des `novade-domain/src/user_manager/mod.rs` Moduls. Dieses Modul wird die Funktionalität kapseln, die für die Verwaltung von Benutzerkonten und Sitzungen innerhalb der NovaDE-Desktop-Umgebung erforderlich ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 79/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.28. `novade-domain/src/user_manager` Verzeichnis

Dieses Verzeichnis ist für die **Verwaltung von Benutzern, Gruppen und Sitzungen** im NovaDE-Desktop verantwortlich. Es stellt die notwendigen Mechanismen bereit, um Benutzerinformationen abzurufen, Anmeldungen zu verwalten, Sitzungen zu starten/beenden und Benutzeraktionen wie Abmelden, Neustart oder Herunterfahren zu initiieren. Ein robuster Benutzer- und Sitzungsmanager ist entscheidend für eine sichere und funktionale Desktop-Umgebung, die den Zugriff auf Systemressourcen kontrolliert und Multi-User-Szenarien unterstützt. Die Implementierung muss sowohl mit traditionellen Unix-Systemen (PAM, systemd-logind) als auch potenziell mit Windows- oder macOS-Spezifika (falls NovaDE multi-plattformfähig sein soll) kompatibel sein.

#### 3.28.1. `novade-domain/src/user_manager/mod.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/user_manager/mod.rs`
* **Verantwortlichkeit:** Definiert die öffentliche API des `user_manager`-Moduls der Domänenschicht. Es re-exportiert alle wichtigen Typen, Traits, Enums und Strukturen, die von der UI-Schicht (z.B. für Login-Screens, Benutzerverwaltungs-Panels, Power-Menüs) oder anderen Diensten der Domänenschicht benötigt werden, um Benutzerdaten zu verwalten und Sitzungsaktionen durchzuführen.
* **Kern-Aufgaben (Tasks):**
    1.  **Public API Definition:** Re-exportiere die folgenden Komponenten, die die Schnittstelle dieses Moduls bilden:
        * `data_types` (alle relevanten Typen wie `User`, `Group`, `Session`, `LoginCredentials`, `UserAction`).
        * `errors` (das `UserManagerError` Enum).
        * `service_iface` (den `UserManagerService` Trait).
        * `service` (die konkrete `DefaultUserManagerService` Implementierung).
    2.  **Modul-Strukturierung:** Stelle sicher, dass alle Re-Exporte korrekt sind und keine internen Implementierungsdetails unnötigerweise exponiert werden.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/user_manager/mod.rs`
* **Abhängigkeiten:**
    * **Intern:** `data_types`, `errors`, `service_iface`, `service` (innerhalb desselben `user_manager` Moduls).
    * **Extern:** Keine direkten, da nur Re-Exporte stattfinden.
* **Kommunikationsmuster:** Stellt die Hauptschnittstelle des `user_manager`-Moduls zur Verfügung. Es ist der primäre Punkt, über den die UI-Schicht Benutzerinformationen abruft und Sitzungsaktionen initiiert.
* **Erwartete Ergebnisse/Outputs:** Eine klar definierte und leicht nutzbare öffentliche API für die Benutzer- und Sitzungsverwaltung innerhalb der Domänenschicht, die konsistente Interaktionen über alle Schichten hinweg ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte sind. Die Tests erfolgen in den jeweiligen Submodulen.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (80 von 100+) widmet sich der Implementierung der grundlegenden Datentypen für das Benutzer-Management-Modul in `novade-domain/src/user_manager/data_types.rs`. Diese Strukturen sind entscheidend, um die vielfältigen Informationen über Benutzer, Gruppen und Sitzungen innerhalb des NovaDE-Desktops abzubilden.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 80/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.28.2. `novade-domain/src/user_manager/data_types.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/user_manager/data_types.rs`
* **Verantwortlichkeit:** Definiert die **Datenstrukturen zur Repräsentation von Benutzern, Gruppen und Sitzungen** im NovaDE-Desktop. Diese Typen dienen als Transportmittel für die vom `UserManagerService` verwalteten und bereitgestellten Daten, die dann von der UI-Schicht (z.B. Login-Screen, Benutzerverwaltung, Power-Menü) genutzt werden, um Benutzerinformationen anzuzeigen und Interaktionen zu ermöglichen.
* **Kern-Aufgaben (Tasks):**

    1.  **`User` Struct definieren:**
        * Repräsentiert einen einzelnen Benutzer auf dem System.
        * **Felder:**
            * `id: u32`: Die eindeutige numerische Benutzer-ID (UID).
            * `username: String`: Der Benutzername (z.B. "novauser").
            * `real_name: String`: Der vollständige reale Name des Benutzers (z.B. "NovaDE Benutzer").
            * `home_dir: PathBuf`: Der Pfad zum Home-Verzeichnis des Benutzers.
            * `shell: String`: Der Pfad zur Standard-Shell des Benutzers (z.B. "/bin/bash").
            * `is_logged_in: bool`: Gibt an, ob der Benutzer derzeit angemeldet ist.
            * `avatar_path: Option<PathBuf>`: Optionaler Pfad zu einem Benutzer-Avatar-Bild.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion.

    2.  **`Group` Struct definieren:**
        * Repräsentiert eine Gruppe auf dem System.
        * **Felder:**
            * `id: u32`: Die eindeutige numerische Gruppen-ID (GID).
            * `name: String`: Der Name der Gruppe (z.B. "users", "sudo").
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion.

    3.  **`Session` Struct definieren:**
        * Repräsentiert eine aktive Benutzersitzung.
        * **Felder:**
            * `id: String`: Eine eindeutige ID der Sitzung (z.B. "c2", "x1").
            * `user_id: u32`: Die UID des Benutzers, dem die Sitzung gehört.
            * `session_type: String`: Der Typ der Sitzung (z.B. "x11", "wayland", "tty").
            * `login_time: chrono::DateTime<chrono::Utc>`: Der Zeitpunkt, zu dem die Sitzung begonnen hat.
            * `display_name: Option<String>`: Optionaler Name des Displays, falls zutreffend (z.B. ":0").
            * `is_active: bool`: Gibt an, ob die Sitzung die derzeit aktive (fokussierte) Sitzung ist.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion.

    4.  **`LoginCredentials` Struct definieren:**
        * Repräsentiert die Anmeldeinformationen eines Benutzers. **WICHTIG:** Passwörter sollten niemals unverschlüsselt gespeichert oder direkt in dieser Struktur verarbeitet werden. Dieses Struct dient primär dem Transport der vom Benutzer eingegebenen Anmeldedaten.
        * **Felder:**
            * `username: String`: Der Benutzername.
            * `password: String`: Das Passwort (sollte unmittelbar nach der Authentifizierung gelöscht/überschrieben werden).
        * Implementiere: `Debug`, `PartialEq`, `Default`. (Kein `Clone`, `Serialize`, `Deserialize` für Passwörter!).
        * Implementiere eine `new()`-Funktion.

    5.  **`UserAction` Enum definieren:**
        * Definiert mögliche Systemaktionen, die von Benutzern initiiert werden können (oder die mit Benutzerberechtigungen ausgeführt werden).
        * **Varianten:**
            * `Logout`: Der aktuelle Benutzer wird abgemeldet.
            * `Reboot`: Das System wird neu gestartet.
            * `Shutdown`: Das System wird heruntergefahren.
            * `Suspend`: Das System wird in den Standby-Modus versetzt.
            * `Hibernate`: Das System wird in den Ruhezustand versetzt.
            * `LockScreen`: Der Bildschirm wird gesperrt.
            * `SwitchUser(String)`: Benutzerwechsel zum angegebenen Benutzernamen.
        * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/user_manager/data_types.rs`
* **Abhängigkeiten:**
    * **Extern:** `serde::{Serialize, Deserialize}`, `std::path::PathBuf`, `chrono::{DateTime, Utc}`.
* **Kommunikationsmuster:**
    * Diese Strukturen werden vom `UserManagerService` erstellt und als Events über Streams oder als direkte Rückgabewerte an die UI-Schicht übermittelt.
    * Die UI-Schicht empfängt diese Strukturen, um Benutzer- und Sitzungsinformationen anzuzeigen.
    * `LoginCredentials` werden von der UI an den `UserManagerService` gesendet.
    * `UserAction` wird von der UI an den `UserManagerService` gesendet, um Systemaktionen auszulösen.
* **Erwartete Ergebnisse/Outputs:** Klare, umfassende und flexible Datenmodelle zur Repräsentation aller relevanten Aspekte von Benutzern, Gruppen und Sitzungen, die eine einfache Nutzung durch andere NovaDE-Komponenten ermöglichen.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der `Default` Implementierungen für alle Strukturen.
        * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` (für `User`, `Group`) Implementierungen.
        * Testen der `new()`-Funktionen, um sicherzustellen, dass alle Felder korrekt initialisiert werden.
        * Testen der Serialisierung und Deserialisierung (z.B. zu/von JSON) für alle Strukturen außer `LoginCredentials`, um die Korrektheit der Datenpersistenz oder D-Bus-Übertragung zu gewährleisten.
        * Stellen Sie sicher, dass `LoginCredentials` **nicht** `Serialize` oder `Deserialize` implementiert und dass `password` kein `Clone` ist.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (81 von 100+) widmet sich der Implementierung der Fehlerdefinitionen für das Benutzer-Management-Modul in `novade-domain/src/user_manager/errors.rs`. Eine präzise Fehlerbehandlung ist entscheidend für die Sicherheit und Zuverlässigkeit bei der Authentifizierung und Sitzungsverwaltung.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 81/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.28.3. `novade-domain/src/user_manager/errors.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/user_manager/errors.rs`
* **Verantwortlichkeit:** Definiert ein konsolidiertes Fehler-Enum (`UserManagerError`) für alle Operationen, die innerhalb des `user_manager`-Moduls der Domänenschicht auftreten können. Dieses Enum kapselt spezifische Fehlerquellen wie Authentifizierungsfehler, Probleme beim Abrufen von Benutzerinformationen aus dem System, Fehler bei der Interaktion mit systemd-logind oder PAM, oder Berechtigungsprobleme. Die Nutzung von **`thiserror`** ist obligatorisch.
* **Kern-Aufgaben (Tasks):**
    1.  **`UserManagerError` Enum definieren:**
        * Nutze `#[derive(thiserror::Error, Debug)]` für automatische Implementierung der `Error` und `Debug` Traits.
        * **Varianten:**
            * `AuthenticationFailed`: Wird zurückgegeben, wenn Benutzername oder Passwort falsch sind.
                * `#[error("Authentication failed: Invalid username or password.")]`
            * `UserNotFound(String)`: Wenn ein angeforderter Benutzer nicht auf dem System gefunden werden kann. Die `String` enthält den Benutzernamen.
                * `#[error("User '{0}' not found.")]`
            * `DbusError(#[from] zbus::Error)`: Fehler, die bei der Interaktion mit D-Bus auftreten, insbesondere mit `systemd-logind` oder anderen Systemdiensten.
                * `#[error("D-Bus error during user management operation: {0}")]`
            * `PamError(String)`: Fehler, die vom Pluggable Authentication Module (PAM) System zurückgegeben werden. Die `String` enthält die PAM-Fehlermeldung.
                * `#[error("PAM authentication error: {0}")]`
            * `PermissionDenied(String)`: Wenn NovaDE nicht die notwendigen Berechtigungen hat, um eine Benutzer- oder Sitzungsaktion auszuführen (z.B. Herunterfahren ohne Root-Rechte).
                * `#[error("Permission denied for user management operation: {0}")]`
            * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler, z.B. beim Lesen von Systemdateien wie `/etc/passwd`.
                * `#[error("I/O error during user management operation: {0}")]`
            * `SerializationError(#[from] serde_json::Error)`: Fehler, die während der Serialisierung oder Deserialisierung von Benutzerdaten (z.B. Sitzungsstatus) auftreten könnten, falls diese persistiert werden.
                * `#[error("Serialization/deserialization error for user data: {0}")]`
            * `UnsupportedFeature(String)`: Wenn eine angeforderte Benutzer-Management-Funktion auf der aktuellen Plattform oder Konfiguration nicht unterstützt wird.
                * `#[error("Unsupported user management feature: {0}")]`
            * `InvalidData(String)`: Wenn die vom System abgerufenen Benutzer- oder Sitzungsdaten in einem unerwarteten oder ungültigen Format vorliegen.
                * `#[error("Invalid user data received: {0}")]`
            * `Other(String)`: Ein Catch-All für unvorhergesehene oder nicht spezifisch handhabbare Fehler.
                * `#[error("An unexpected user management error occurred: {0}")]`
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/user_manager/errors.rs`
* **Abhängigkeiten:**
    * **Extern:** `thiserror::Error`, `zbus::Error`, `std::io::Error`, `serde_json::Error`.
* **Kommunikationsmuster:**
    * Wird als `E` (Fehler-Typ) in `Result<T, E>` Signaturen aller öffentlichen Funktionen und Methoden des `user_manager`-Moduls verwendet (z.B. `UserManagerService`).
    * Sollte von `zbus::Error`, `std::io::Error`, und `serde_json::Error` Fehlertypen erhalten und in die eigene Variante konvertieren (`#[from]`).
    * Wird von der UI-Schicht oder anderen Diensten empfangen und dort in ein übergeordnetes Fehler-Enum gekapselt oder direkt behandelt.
* **Erwartete Ergebnisse/Outputs:** Ein klar strukturiertes und wartbares Fehler-Enum, das alle denkbaren Fehlerzustände im Benutzer-Management-Modul abdeckt und eine konsistente Fehlerbehandlung ermöglicht.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der Instanziierung jeder Fehlervariante mit aussagekräftigen Daten (z.B. Benutzernamen, D-Bus-Fehlermeldungen, PAM-Fehlermeldungen).
        * Testen der `#[from]`-Konvertierungen von `zbus::Error`, `std::io::Error`, und `serde_json::Error`.
        * Testen der `Display`-Implementierung (via `to_string()`) für jede Fehlervariante, um sicherzustellen, dass die Fehlermeldungen korrekt und informativ sind.
        * Testen der `source()`-Kette, um sicherzustellen, dass die Ursprungsfehler bei der Konvertierung beibehalten werden.

---

Als 'NovaGem' setze ich den ultimativen Implementierungsplan für NovaDE fort. Dieser achte Teil (82 von 100+) widmet sich der Implementierung des `novade-domain/src/user_manager/service_iface.rs` Moduls. Dieses Modul definiert den Vertrag für den Dienst, der für die Verwaltung von Benutzerkonten und Sitzungen zuständig ist.

---

# Ultimativer Implementierungsplan für NovaDE (Teil 82/100+)

## 3. Detaillierte Implementierungsspezifikation: `novade-domain` Crate (Fortsetzung)

### 3.28.4. `novade-domain/src/user_manager/service_iface.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/user_manager/service_iface.rs`
* **Verantwortlichkeit:** Definiert den **`UserManagerService` Trait**. Dieser Trait ist die primäre Schnittstelle für Anmeldebildschirme, Benutzerverwaltungstools, Energieverwaltungsmenüs und andere NovaDE-Komponenten, die Benutzerinformationen abrufen, Anmeldungen verwalten, Sitzungen steuern oder Systemaktionen wie Abmelden, Neustart oder Herunterfahren initiieren müssen. Er abstrahiert die plattformspezifische Logik (z.B. PAM, systemd-logind, `/etc/passwd`-Parsing) und bietet eine einheitliche, asynchrone API.
* **Kern-Aufgaben (Tasks):**
    1.  **`UserManagerService` Trait definieren:**
        * Nutze `#[async_trait]` für alle Methoden.
        * Alle Methoden geben `Result<(), UserManagerError>` oder `Result<T, UserManagerError>` zurück, um eine konsistente Fehlerbehandlung zu gewährleisten.
        * **Methoden:**
            * `initialize(&self) -> Result<(), UserManagerError>`:
                * Initialisiert den Dienst und verbindet sich mit plattformspezifischen Backends (z.B. D-Bus für `systemd-logind`, PAM-Module).
                * Sollte idempotent sein.
                * **Fehlerbehandlung:** `UserManagerError::DbusError`, `UserManagerError::PamError`, `UserManagerError::IoError`.
            * `authenticate_user(&self, credentials: &LoginCredentials) -> Result<(), UserManagerError>`:
                * Versucht, einen Benutzer mit den bereitgestellten Anmeldeinformationen zu authentifizieren.
                * **Logik:** Nutzt PAM oder ein anderes Authentifizierungs-Backend.
                * **Fehlerbehandlung:** `UserManagerError::AuthenticationFailed`, `UserManagerError::UserNotFound`, `UserManagerError::PamError`, `UserManagerError::PermissionDenied`.
            * `get_current_user(&self) -> Result<User, UserManagerError>`:
                * Gibt die Informationen des aktuell angemeldeten Benutzers zurück.
                * **Logik:** Fragt die System-APIs oder `/etc/passwd` ab.
                * **Fehlerbehandlung:** `UserManagerError::UserNotFound`, `UserManagerError::IoError`, `UserManagerError::InvalidData`.
            * `get_all_users(&self) -> Result<Vec<User>, UserManagerError>`:
                * Gibt eine Liste aller Benutzerkonten auf dem System zurück.
                * **Logik:** Parsen von `/etc/passwd` und ggf. weitere Abfragen für zusätzliche Benutzerdetails.
                * **Fehlerbehandlung:** `UserManagerError::IoError`, `UserManagerError::InvalidData`.
            * `get_all_groups(&self) -> Result<Vec<Group>, UserManagerError>`:
                * Gibt eine Liste aller Gruppen auf dem System zurück.
                * **Logik:** Parsen von `/etc/group`.
                * **Fehlerbehandlung:** `UserManagerError::IoError`, `UserManagerError::InvalidData`.
            * `get_active_sessions(&self) -> Result<Vec<Session>, UserManagerError>`:
                * Gibt eine Liste aller aktiven Benutzersitzungen zurück.
                * **Logik:** Interagiert mit `systemd-logind` über D-Bus oder parst `utmp`/`wtmp` unter klassischen Unix-Systemen.
                * **Fehlerbehandlung:** `UserManagerError::DbusError`, `UserManagerError::IoError`, `UserManagerError::InvalidData`.
            * `perform_user_action(&self, action: UserAction) -> Result<(), UserManagerError>`:
                * Führt eine Systemaktion im Namen des Benutzers aus (z.B. Abmelden, Neustart, Herunterfahren, Sperren).
                * **Logik:** Interagiert mit `systemd-logind` (z.B. `PowerOff`, `Reboot`, `Suspend`, `Hibernate`, `TerminateUserUnit`) oder sendet entsprechende Signale/Befehle. Berechtigungsprüfung ist hier entscheidend.
                * **Fehlerbehandlung:** `UserManagerError::PermissionDenied`, `UserManagerError::DbusError`, `UserManagerError::UnsupportedFeature`, `UserManagerError::Other`.
            * `on_user_logged_in(&self) -> impl Stream<Item = User> + Send + Sync`:
                * Gibt einen asynchronen Stream zurück, der ein `User`-Objekt liefert, wenn sich ein Benutzer anmeldet.
                * **Logik:** Überwacht D-Bus-Signale von `systemd-logind` (`UserNew`) oder Änderungen an Systemdateien.
            * `on_user_logged_out(&self) -> impl Stream<Item = String> + Send + Sync`:
                * Gibt einen asynchronen Stream zurück, der den Benutzernamen des Benutzers liefert, wenn sich dieser abmeldet.
                * **Logik:** Überwacht D-Bus-Signale (`UserRemoved`) oder Systemereignisse.
            * `on_session_changed(&self) -> impl Stream<Item = Session> + Send + Sync`:
                * Gibt einen asynchronen Stream zurück, der ein `Session`-Objekt liefert, wenn sich der Status einer Sitzung ändert (z.B. aktiv/inaktiv).
                * **Logik:** Überwacht D-Bus-Signale (`SessionNew`, `SessionRemoved`, `SessionActiveChanged`).

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/user_manager/service_iface.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::user_manager::data_types::{User, Group, Session, LoginCredentials, UserAction}`
        * `crate::user_manager::errors::UserManagerError`
    * **Extern:** `async_trait::async_trait`, `futures::Stream`.
* **Kommunikationsmuster:**
    * Dieser Trait wird von konkreten Dienstimplementierungen (z.B. `DefaultUserManagerService`) implementiert.
    * Die UI-Schicht (z.B. Login-Manager, Power-Menü) wird diesen Trait nutzen, um Benutzerdaten zu erhalten und Systemaktionen zu initiieren.
* **Erwartete Ergebnisse/Outputs:** Eine robuste und umfassende Schnittstelle für die Benutzer- und Sitzungsverwaltung, die eine sichere und flexible Interaktion mit den Systemfunktionen ermöglicht.

---

User Manager Service

### `novade-domain/src/user_manager/service.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/user_manager/service.rs`
* **Verantwortlichkeit:** Implementiert den **`UserManagerService`-Trait**. Dieser Dienst ist zuständig für die Interaktion mit dem zugrunde liegenden System (Linux: PAM, `systemd-logind`; zukünftig: Windows, macOS), um Benutzer zu authentifizieren, Benutzer- und Gruppeninformationen abzurufen, Sitzungen zu verwalten und Systemaktionen (Abmelden, Neustart, Herunterfahren) auszuführen. Er kapselt plattformspezifische APIs und stellt eine einheitliche Schnittstelle bereit.
* **Kern-Aufgaben (Tasks):**

{{ ... }}
    1.  **`DefaultUserManagerService` Struct definieren:**
        * **Felder:**
            * `dbus_connection: Arc<zbus::Connection>`: Geteilte Referenz zur System-D-Bus-Verbindung, primär für `systemd-logind`-Interaktionen.
            * `logind_proxy: Arc<zbus::Proxy<'static>>`: Proxy für den `org.freedesktop.login1` D-Bus-Dienst (systemd-logind).
            * `users_cache: Arc<RwLock<HashMap<u32, User>>>`: Thread-sicherer Cache aller bekannten `User`s, indiziert nach UID.
            * `groups_cache: Arc<RwLock<HashMap<u32, Group>>>`: Thread-sicherer Cache aller bekannten `Group`s, indiziert nach GID.
            * `sessions_cache: Arc<RwLock<HashMap<String, Session>>>`: Thread-sicherer Cache aller aktiven `Session`s, indiziert nach Sitzungs-ID.
            * `user_login_sender: tokio::sync::broadcast::Sender<User>`: Sender für den `on_user_logged_in` Stream.
            * `user_logout_sender: tokio::sync::broadcast::Sender<String>`: Sender für den `on_user_logged_out` Stream.
            * `session_change_sender: tokio::sync::broadcast::Sender<Session>`: Sender für den `on_session_changed` Stream.
            * `_user_login_receiver: tokio::sync::broadcast::Receiver<User>`: Interner Empfänger für `user_login_sender`.
            * `_user_logout_receiver: tokio::sync::broadcast::Receiver<String>`: Interner Empfänger für `user_logout_sender`.
            * `_session_change_receiver: tokio::sync::broadcast::Receiver<Session>`: Interner Empfänger für `session_change_sender`.

    2.  **Konstruktor `new(dbus_connection: Arc<zbus::Connection>)` implementieren:**
        * Initialisiert alle `broadcast` Kanäle (z.B. mit einer Kapazität von 10).
        * Initialisiert alle Caches als leere Strukturen.
        * Erstellt `logind_proxy` für den **System-D-Bus-Bus**, Interface `org.freedesktop.login1.Manager`, Objektpfad `/org/freedesktop/login1`.
        * Gibt das `DefaultUserManagerService` Struct zurück.

    3.  **Implementierung des `UserManagerService`-Traits für `DefaultUserManagerService`:**

        * **`initialize(&self) -> Result<(), UserManagerError>`:**
            * Ruft intern `_load_initial_user_data()` und `_load_initial_group_data()` auf, um die Caches zu füllen.
            * Ruft intern `_load_initial_session_data()` auf, um den Sessions-Cache zu füllen.
            * Startet eine Tokio-Task, die auf D-Bus-Signale von `systemd-logind` lauscht (`UserNew`, `UserRemoved`, `SessionNew`, `SessionRemoved`, `SessionActiveChanged`, `PrepareForShutdown`, `PrepareForSleep`). Bei entsprechenden Signalen werden die Caches aktualisiert und Events über die jeweiligen `broadcast::Sender` versendet.
            * **Fehlerbehandlung:** Kapselt `zbus::Error` und `std::io::Error` in `UserManagerError` Varianten.

        * **`authenticate_user(&self, credentials: &LoginCredentials) -> Result<(), UserManagerError>`:**
            * **WICHTIG:** Implementierung der PAM-Authentifizierung.
            * PAM-Initialisierung: `pam::Pam::start("novade-login")` (oder einen anderen passenden Service-Namen).
            * Setzt Benutzernamen und Passwort.
            * Ruft `pam.authenticate()` auf.
            * Ruft `pam.acct_mgmt()` für zusätzliche Kontoüberprüfungen auf.
            * **Fehlerbehandlung:** Konvertiert PAM-Fehlercodes in `UserManagerError::PamError` oder `UserManagerError::AuthenticationFailed`. Gibt `UserManagerError::UserNotFound` zurück, wenn der Benutzer nicht existiert.

        * **`get_current_user(&self) -> Result<User, UserManagerError>`:**
            * Ermittelt die aktuelle UID (z.B. mit `nix::unistd::getuid().as_raw()`).
            * Holt einen Lese-Lock auf `self.users_cache`.
            * Sucht den Benutzer im Cache.
            * **Fehlerbehandlung:** Gibt `UserManagerError::UserNotFound` zurück, falls nicht gefunden.

        * **`get_all_users(&self) -> Result<Vec<User>, UserManagerError>`:**
            * Holt einen Lese-Lock auf `self.users_cache`.
            * Gibt alle im Cache befindlichen `User`s als `Vec` zurück.

        * **`get_all_groups(&self) -> Result<Vec<Group>, UserManagerError>`:**
            * Holt einen Lese-Lock auf `self.groups_cache`.
            * Gibt alle im Cache befindlichen `Group`s als `Vec` zurück.

        * **`get_active_sessions(&self) -> Result<Vec<Session>, UserManagerError>`:**
            * Holt einen Lese-Lock auf `self.sessions_cache`.
            * Gibt alle im Cache befindlichen `Session`s als `Vec` zurück.

        * **`perform_user_action(&self, action: UserAction) -> Result<(), UserManagerError>`:**
            * **Logik (unterscheide nach `UserAction`):**
                * `Logout`: Ruft `logind_proxy.call_terminate_user_unit()` auf. Benötigt UID des aktuellen Benutzers.
                * `Reboot`: Ruft `logind_proxy.call_reboot(false)` auf.
                * `Shutdown`: Ruft `logind_proxy.call_power_off(false)` auf.
                * `Suspend`: Ruft `logind_proxy.call_suspend(false)` auf.
                * `Hibernate`: Ruft `logind_proxy.call_hibernate(false)` auf.
                * `LockScreen`: Implementierung dieser Aktion muss in NovaDE spezifisch sein und kann z.B. einen Aufruf an den Compositor-Dienst erfordern. **Entscheidung:** Für den `UserManagerService` ist dies primär die Benachrichtigung an andere Komponenten. Eine direkte Sperrung wird vom Compositor-Service (oder einem separaten Lock-Screen-Dienst) durchgeführt. Hier sendet der `UserManagerService` ein Signal (z.B. über einen internen `mpsc::Sender`), das von einem anderen Dienst (z.B. `DesktopEnvironmentService`) abgehört wird.
                * `SwitchUser(username)`: Ruft `logind_proxy.call_activate_session_by_pid()` oder `call_activate_user()` auf, nachdem die UID des `username` ermittelt wurde.
            * **Berechtigungsprüfung:** `systemd-logind` handhabt viele Berechtigungsprüfungen, aber stellen Sie sicher, dass der Aufrufer (NovaDE-Dienst) die erforderlichen Rechte für D-Bus-Aufrufe hat (z.B. durch Polkit-Regeln).
            * **Fehlerbehandlung:** `UserManagerError::PermissionDenied`, `UserManagerError::DbusError`, `UserManagerError::UnsupportedFeature`.

        * **`on_user_logged_in(&self) -> impl Stream<Item = User> + Send + Sync`:**
            * Gibt einen `tokio_stream::wrappers::BroadcastStream` über den Empfänger des `user_login_sender` zurück.

        * **`on_user_logged_out(&self) -> impl Stream<Item = String> + Send + Sync`:**
            * Gibt einen `tokio_stream::wrappers::BroadcastStream` über den Empfänger des `user_logout_sender` zurück.

        * **`on_session_changed(&self) -> impl Stream<Item = Session> + Send + Sync`:**
            * Gibt einen `tokio_stream::wrappers::BroadcastStream` über den Empfänger des `session_change_sender` zurück.

    4.  **Private Hilfsmethoden implementieren:**
        * `_load_initial_user_data(&self) -> Result<(), UserManagerError>`:
            * Liest `/etc/passwd` und parst die Benutzerinformationen in `User`-Structs.
            * Füllt `self.users_cache`.
            * Verwendet ggf. die `users` crate oder `passwd-rs` für robustes Parsing.
        * `_load_initial_group_data(&self) -> Result<(), UserManagerError>`:
            * Liest `/etc/group` und parst die Gruppeninformationen in `Group`-Structs.
            * Füllt `self.groups_cache`.
            * Verwendet ggf. die `users` crate oder `group-rs` für robustes Parsing.
        * `_load_initial_session_data(&self) -> Result<(), UserManagerError>`:
            * Fragt `logind_proxy.call_list_sessions()` ab.
            * Iteriert über die zurückgegebenen Sitzungen, ruft Details für jede Sitzung ab (z.B. `GetSessionByPID`, `GetSession`), und parst sie in `Session`-Structs.
            * Füllt `self.sessions_cache`.
        * `_listen_for_logind_signals()`: Eine `async` Task, die auf D-Bus-Signale von `systemd-logind` lauscht und die `UserManagerService` Caches sowie die Sender aktualisiert.
        * `_convert_dbus_user_to_user(user_data: &zbus::fdo::Result<zbus::zvariant::OwnedValue>) -> Result<User, UserManagerError>`: Hilfsfunktion zum Parsen von D-Bus-Antworten in `User`-Structs.
        * `_convert_dbus_session_to_session(session_data: &zbus::fdo::Result<zbus::zvariant::OwnedValue>) -> Result<Session, UserManagerError>`: Hilfsfunktion zum Parsen von D-Bus-Antworten in `Session`-Structs.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/user_manager/service.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::user_manager::data_types::{User, Group, Session, LoginCredentials, UserAction}`
        * `crate::user_manager::errors::UserManagerError`
        * `crate::user_manager::service_iface::UserManagerService`
    * **Extern:** `async_trait::async_trait`, `tokio`, `tokio::sync::{RwLock, broadcast}`, `futures::Stream`, `tokio_stream::wrappers::BroadcastStream`, `zbus`, `std::sync::Arc`, `std::collections::HashMap`, `std::path::PathBuf`, `tracing`, `chrono`, `pam` (oder `libpam-sys` Wrapper), `users` crate (oder manuelle `/etc/passwd`, `/etc/group` Parsing), `nix` (für UID/GID Abfrage).
* **Kommunikationsmuster:** Interagiert direkt mit dem System-D-Bus (`systemd-logind`) und Dateisystem-APIs (`/etc/passwd`, `/etc/group`). Verwendet PAM für die Authentifizierung. Stellt die gesammelten und verarbeiteten Daten über die `UserManagerService`-Trait-Methoden und asynchrone Streams der UI-Schicht zur Verfügung.
* **Erwartete Ergebnisse/Outputs:** Ein voll funktionsfähiger Benutzer- und Sitzungsmanager, der eine sichere Authentifizierung, zuverlässige Systeminformationen und die Ausführung von kritischen Systemaktionen ermöglicht.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests (mit Mocks/Isolation):**
        * **Mocking:** Mocken Sie `zbus::Connection`, `pam` und Dateisystemzugriffe (`/etc/passwd`, `/etc/group`) mit simulierten Inhalten.
        * Testen von `_load_initial_user_data()` und `_load_initial_group_data()` mit verschiedenen gültigen und ungültigen Systemdateien.
        * Testen von `_load_initial_session_data()` mit simulierten `systemd-logind`-Antworten.
        * Testen von `initialize()`: Sicherstellen, dass die Listener gestartet werden und die Caches gefüllt werden.
        * Testen von `authenticate_user()` mit verschiedenen Anmeldeinformationen (korrekt, falsch, Benutzer nicht vorhanden) unter Verwendung des PAM-Mocks.
        * Testen von `get_current_user()`, `get_all_users()`, `get_all_groups()`, `get_active_sessions()` mit den Inhalten der Caches.
        * Testen von `perform_user_action()` durch Simulation von D-Bus-Aufrufen an `systemd-logind` (z.B. `call_power_off`). Prüfen Sie, ob die richtigen D-Bus-Methoden aufgerufen werden.
        * Testen der **Stream-Funktionalität**: Senden Sie simulierte D-Bus-Signale (`UserNew`, `SessionActiveChanged` etc.) und verifizieren Sie, dass die korrekten Daten über die `on_user_logged_in`, `on_user_logged_out`, `on_session_changed` Streams empfangen werden.
    * **Integration Tests:**
        * Führen Sie den Dienst in einer Testumgebung mit einem echten D-Bus-System und einem simulierten PAM-Backend (oder einem Test-PAM-Service) aus.
        * Versuchen Sie, sich mit Testbenutzern anzumelden und prüfen Sie das Ergebnis.
        * Testen Sie das Abrufen von Benutzer-, Gruppen- und Sitzungsinformationen auf einem realen System.
        * Testen Sie die Ausführung von `UserAction`s (Vorsicht: Dies kann das Testsystem herunterfahren/neu starten, daher in einer isolierten VM oder mit entsprechenden Vorkehrungen testen).
        * Überwachen Sie die Streams bei realen Anmelde-/Abmeldevorgängen oder Sitzungswechseln.


---

# Wallpaper Manager

### `novade-domain/src/wallpaper_manager/mod.rs`

Dieses Verzeichnis ist für die **Verwaltung und Anwendung von Desktophintergründen (Wallpapers)** im NovaDE-Desktop zuständig. Es stellt die notwendigen Mechanismen bereit, um verfügbare Wallpaper zu erkennen, sie zu laden, den aktuellen Hintergrund zu setzen und Änderungen des Hintergrunds an den Compositor zu kommunizieren. Ein robuster Wallpaper-Manager ist entscheidend für die visuelle Anpassbarkeit und die ästhetische Kohärenz der Desktop-Umgebung.

#### `novade-domain/src/wallpaper_manager/mod.rs`

{{ ... }}
* **Verantwortlichkeit:** Definiert die öffentliche API des `wallpaper_manager`-Moduls der Domänenschicht. Es re-exportiert alle wichtigen Typen, Traits, Enums und Strukturen, die von der UI-Schicht (z.B. für die Systemeinstellungen zur Wallpaper-Auswahl) oder anderen Diensten der Domänenschicht benötigt werden, um Hintergrundbilder zu verwalten und anzuwenden.
* **Kern-Aufgaben (Tasks):**
    1.  **Public API Definition:** Re-exportiere die folgenden Komponenten, die die Schnittstelle dieses Moduls bilden:
        * `data_types` (alle relevanten Typen wie `Wallpaper`, `WallpaperMode`).
        * `errors` (das `WallpaperManagerError` Enum).
        * `service_iface` (den `WallpaperManagerService` Trait).
        * `service` (die konkrete `DefaultWallpaperManagerService` Implementierung).
    2.  **Modul-Strukturierung:** Stelle sicher, dass alle Re-Exporte korrekt sind und keine internen Implementierungsdetails unnötigerweise exponiert werden.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/wallpaper_manager/mod.rs`
* **Abhängigkeiten:**
    * **Intern:** `data_types`, `errors`, `service_iface`, `service` (innerhalb desselben `wallpaper_manager` Moduls).
    * **Extern:** Keine direkten, da nur Re-Exporte stattfinden.
* **Kommunikationsmuster:** Stellt die Hauptschnittstelle des `wallpaper_manager`-Moduls zur Verfügung. Es ist der primäre Punkt, über den die UI-Schicht Wallpaper-Informationen abruft und Änderungen anstößt.
* **Erwartete Ergebnisse/Outputs:** Eine klar definierte und leicht nutzbare öffentliche API für die Wallpaper-Verwaltung innerhalb der Domänenschicht, die konsistente Interaktionen über alle Schichten hinweg ermöglicht.
* **Teststrategie (Modul-spezifisch):** Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte sind. Die Tests erfolgen in den jeweiligen Submodulen.

---

# Wallpaper Manager Data Types

## Wallpaper Manager Data Types

### `novade-domain/src/wallpaper_manager/data_types.rs`

* **Verzeichnis-/Modulname:** `novade-domain/src/wallpaper_manager/data_types.rs`
* **Verantwortlichkeit:** Definiert die **Datenstrukturen zur Repräsentation von Desktophintergründen und deren Anzeigemodi** im NovaDE-Desktop. Diese Typen dienen als Transportmittel für die vom `WallpaperManagerService` verwalteten und bereitgestellten Daten, die dann von der UI-Schicht (insbesondere dem Compositor oder Wallpaper-Renderer) genutzt werden, um das Hintergrundbild darzustellen.
* **Kern-Aufgaben (Tasks):**

    1.  **`WallpaperMode` Enum definieren:**
        * Definiert, wie ein Wallpaper auf den Bildschirm skaliert oder positioniert wird.
        * **Varianten:**
            * `Stretch`: Das Bild wird gestreckt, um den gesamten Bildschirm auszufüllen. Seitenverhältnis wird ignoriert.
            * `Fit`: Das Bild wird skaliert, sodass es vollständig auf den Bildschirm passt, wobei das Seitenverhältnis beibehalten wird. Leerräume werden mit der Hintergrundfarbe gefüllt.
            * `Fill`: Das Bild wird skaliert, sodass es den gesamten Bildschirm ausfüllt, wobei das Seitenverhältnis beibehalten wird. Teile des Bildes können abgeschnitten werden.
            * `Center`: Das Bild wird in der Mitte des Bildschirms platziert, ohne Skalierung. Leerräume werden mit der Hintergrundfarbe gefüllt.
            * `Tile`: Das Bild wird wiederholt (gekachelt), um den gesamten Bildschirm auszufüllen.
            * `Zoom`: Das Bild wird so skaliert, dass es die gesamte Breite oder Höhe ausfüllt, je nachdem, welcher Wert größer ist, und das Seitenverhältnis beibehält. Ähnlich wie `Fill`, aber spezifischer in der Namensgebung.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.

    2.  **`Wallpaper` Struct definieren:**
        * Repräsentiert ein einzelnes Hintergrundbild.
        * **Felder:**
            * `id: String`: Eine eindeutige ID für das Wallpaper (z.B. ein Hash des Pfades oder ein UUID).
            * `name: String`: Ein benutzerfreundlicher Name für das Wallpaper.
            * `path: PathBuf`: Der Dateipfad zum Wallpaper-Bild.
            * `thumbnail_path: Option<PathBuf>`: Optionaler Pfad zu einer generierten Miniaturansicht des Wallpapers.
            * `source: Option<String>`: Optionale Angabe der Quelle des Wallpapers (z.B. "NovaDE Standard", "Unsplash").
            * `dimensions: Option<(u32, u32)>`: Optionale Breite und Höhe des Bildes in Pixeln.
            * `aspect_ratio: Option<f32>`: Optionales Seitenverhältnis des Bildes.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion.

    3.  **`WallpaperSettings` Struct definieren:**
        * Repräsentiert die aktuellen Einstellungen für den Desktophintergrund.
        * **Felder:**
            * `current_wallpaper_id: Option<String>`: Die ID des aktuell ausgewählten Wallpapers. `None`, wenn eine einfarbige Farbe verwendet wird.
            * `wallpaper_mode: WallpaperMode`: Der Anzeigemodus des Wallpapers.
            * `background_color: crate::theme::data_types::Color`: Die Hintergrundfarbe, die verwendet wird, wenn das Wallpaper nicht den gesamten Bildschirm ausfüllt (`Fit`, `Center`) oder wenn kein Wallpaper ausgewählt ist.
            * `monitor_id: Option<String>`: Optional die ID des Monitors, für den diese Einstellungen gelten (für Multi-Monitor-Setups). Wenn `None`, gelten die Einstellungen global.
        * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion.

* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/wallpaper_manager/data_types.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::theme::data_types::Color` (für `background_color`).
    * **Extern:** `serde::{Serialize, Deserialize}`, `std::path::PathBuf`.
* **Kommunikationsmuster:**
    * Diese Strukturen werden vom `WallpaperManagerService` erstellt, geladen und als aktueller Zustand an die UI-Schicht übermittelt.
    * Die UI-Schicht empfängt diese Strukturen, um das Hintergrundbild und dessen Darstellung zu konfigurieren.
* **Erwartete Ergebnisse/Outputs:** Klare und konsistente Datenmodelle zur Repräsentation aller relevanten Aspekte von Desktophintergründen und deren Anzeigemodi, die eine einfache Nutzung durch den NovaDE-Desktop ermöglichen.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der `Default` Implementierungen für alle Strukturen.
        * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` (für `WallpaperMode`, `Wallpaper`) Implementierungen.
        * Testen der `new()`-Funktionen, um sicherzustellen, dass alle Felder korrekt initialisiert werden.
        * Testen der Serialisierung und Deserialisierung (z.B. zu/von JSON) für jede Struktur, um die Korrektheit der Datenpersistenz zu gewährleisten.
        * Testen spezifischer `WallpaperMode`-Varianten und deren Eigenschaften.

---

## Ultimativer Implementierungsplan für NovaDE (Fortsetzung)

### 2.2. Domänenschicht (`novade-domain`) - Fortsetzung

#### 2.2.9. `novade-domain/src/notifications`

  * **Verantwortlichkeit:** Dieses Modul verwaltet Benachrichtigungsregeln, ermöglicht die Verarbeitung eingehender Benachrichtigungen und wendet definierte Regeln an. Es ist die zentrale Logikschicht für die flexible und anpassbare Behandlung von Benachrichtigungen.

  * **Kern-Aufgaben (Tasks):**

    1.  **Strukturen und Enums (`data_types.rs`):**

          * Definiere die Enum `ConditionValue` zur Abbildung verschiedener Werttypen, die in Bedingungen verwendet werden können (String, Integer, Boolean, Timestamp, Enum).
          * Definiere die Enum `Operator` (Equals, NotEquals, GreaterThan, LessThan, Contains, StartsWith, EndsWith, RegexMatches, SettingIsTrue, SettingIsFalse).
          * Definiere die Enum `Field` zur Identifizierung der Felder einer Benachrichtigung, auf die Regeln angewendet werden können (AppId, Summary, Body, Urgency, Category, Timeout, Icon, DesktopEntry, Hint).
          * Definiere die Struktur `SimpleRuleCondition` mit `field: Field`, `operator: Operator`, `value: ConditionValue`.
          * Definiere die Enum `RuleCondition` zur Abbildung komplexer Bedingungen (Simple, AllOf, AnyOf, Not). Die Varianten `AllOf` und `AnyOf` sollen Vektoren von `RuleCondition` enthalten, um geschachtelte Bedingungen zu ermöglichen.
          * Definiere die Enum `RuleAction` (ChangeUrgency, ChangeTimeout, Suppress, PlaySound, ExecuteCommand, ShowOnScreen, LogNotification, StopProcessingFurtherRules). `ExecuteCommand` soll einen String für den Befehl und optional einen Vektor von Strings für Argumente enthalten. `PlaySound` soll einen String für den Sound-Pfad enthalten. `ShowOnScreen` soll ein optionales `Duration` für die Anzeigedauer enthalten.
          * Definiere die Struktur `NotificationRule` mit `id: Uuid`, `name: String`, `enabled: bool`, `priority: u32`, `condition: RuleCondition`, `actions: Vec<RuleAction>`. `id` sollte ein `Uuid` sein.
          * Definiere die Struktur `NotificationRuleSet` mit `rules: Vec<NotificationRule>`.
          * Implementiere für alle oben genannten Strukturen und Enums die Traits `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` (wo sinnvoll), `Serialize`, `Deserialize` und `Default` (wo sinnvoll).

    2.  **Fehlerbehandlung (`errors.rs`):**

          * Definiere die Enum `NotificationRulesError` mittels `thiserror` mit Varianten für:
              * `PersistenceError(#[from] ConfigError)`: Fehler beim Laden/Speichern von Regeln.
              * `InvalidRuleDefinition(String)`: Eine Regeldefinition ist syntaktisch oder logisch ungültig.
              * `RuleProcessingError(String)`: Ein Fehler während der Regelausführung (z.B. Befehlsausführung fehlgeschlagen).
              * `NotificationDataError(String)`: Fehler bei der Verarbeitung der Benachrichtigungsdaten.
              * `Other(#[from] anyhow::Error)`: Für allgemeine Fehler, die von abhängigen Bibliotheken kommen.
          * Implementiere `From<NotificationRulesError>` für `DomainError`.

    3.  **Persistenz-Schnittstelle (`persistence_iface.rs`):**

          * Definiere den `NotificationRulesProvider` Trait:
              * `async fn load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`: Lädt die gesamten Regelsätze.
              * `async fn save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`: Speichert die gesamten Regelsätze.
              * `async fn watch_for_changes(&self) -> Result<tokio::sync::broadcast::Receiver<()>, NotificationRulesError>`: Ermöglicht das Abonnieren von Änderungen der zugrunde liegenden Regeldatei.

    4.  **Dateisystem-Persistenz (`persistence.rs`):**

          * Implementiere die Struktur `FilesystemNotificationRulesProvider` für den `NotificationRulesProvider` Trait.
          * Verwende `novade-core::config::ConfigServiceAsync` (oder dessen synchrones Gegenstück, je nach API-Design) für die tatsächliche Dateisystem-Interaktion.
          * Der Konstruktor soll den Pfad zur Regeldatei (`notifications.json`) erhalten.
          * Implementiere die Methoden `load_rules` und `save_rules` zum Serialisieren/Deserialisieren des `NotificationRuleSet` als JSON-Datei.
          * Implementiere `watch_for_changes` mittels `notify` oder `tokio::fs::File::metadata` in einem Schleifentask, um Änderungen der Datei zu erkennen und Events zu senden. Nutze einen `tokio::sync::broadcast::Sender`.

    5.  **Regel-Engine (`engine.rs`):**

          * Definiere die Enum `RuleProcessingResult` (Processed, Suppressed, Modified).
          * Definiere den Trait `NotificationRulesEngine`:
              * `async fn process_notification(&self, notification: &mut IncomingNotification) -> Result<RuleProcessingResult, NotificationRulesError>`: Verarbeitet eine eingehende Benachrichtigung. Die `IncomingNotification` sollte ein veränderbares Struct sein, da Aktionen die Benachrichtigung modifizieren können.
              * `async fn reload_rules(&self) -> Result<(), NotificationRulesError>`: Lädt die Regeln neu.
              * `async fn get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`: Gibt die aktuell geladenen Regeln zurück.
              * `async fn update_rules(&self, rules: NotificationRuleSet) -> Result<(), NotificationRulesError>`: Aktualisiert die Regeln und speichert sie.
          * Implementiere die Struktur `DefaultNotificationRulesEngine` für den `NotificationRulesEngine` Trait.
          * Der Konstruktor nimmt einen `Arc<dyn NotificationRulesProvider + Send + Sync>` und einen `Arc<dyn GlobalSettingsService + Send + Sync>` entgegen.
          * Verwende ein `tokio::sync::RwLock<NotificationRuleSet>` um die Regeln intern zu speichern und Lese-/Schreibzugriffe zu synchronisieren.
          * **`reload_rules()`:**
              * Greife über den `NotificationRulesProvider` auf die Regeln zu.
              * Aktualisiere den internen `RwLock`.
              * Logge erfolgreiches Laden oder Fehler.
          * **`process_notification(&mut notification)`:**
              * Iteriere über die geladenen Regeln in der Reihenfolge ihrer `priority` (höhere Priorität zuerst).
              * Für jede Regel:
                  * Evaluieren die `condition` rekursiv:
                      * `SimpleRuleCondition`: Vergleiche das `field` der `notification` mit dem `value` basierend auf dem `operator`. Berücksichtige Typkonvertierungen und Fehlerbehandlung (z.B. Regex-Fehler, falscher Typ für Vergleich). Nutze die `GlobalSettingsService` für `SettingIsTrue/SettingIsFalse` Bedingungen.
                      * `AllOf`: Alle Unterbedingungen müssen `true` sein.
                      * `AnyOf`: Mindestens eine Unterbedingung muss `true` sein.
                      * `Not`: Die Negation der Unterbedingung.
                  * Wenn die Bedingung der Regel erfüllt ist:
                      * Wende alle `actions` der Regel auf die `notification` an.
                      * `ChangeUrgency`, `ChangeTimeout`: Modifiziere die entsprechenden Felder in `notification`.
                      * `Suppress`: Setze ein internes Flag in der `notification` oder gebe ein spezielles `RuleProcessingResult::Suppressed` zurück.
                      * `PlaySound`: Sende ein Event an den Audio-Service oder rufe direkt eine Funktion zum Abspielen auf (ggf. über eine Systemschicht-Schnittstelle).
                      * `ExecuteCommand`: Starte einen externen Prozess. Achte auf Sicherheit (keine Shell-Injektion\!). Starte als Nicht-Root-Benutzer.
                      * `ShowOnScreen`: Sende ein Event an die UI-Schicht, um die Benachrichtigung anzuzeigen.
                      * `LogNotification`: Logge die Benachrichtigung in einem spezifischen Format.
                      * `StopProcessingFurtherRules`: Beende die Regelverarbeitung und gebe das aktuelle `RuleProcessingResult` zurück.
              * Gebe das finale `RuleProcessingResult` zurück (Standard: `Processed` wenn nicht unterdrückt oder modifiziert).
          * **`get_rules()`:**
              * Lese die Regeln aus dem `RwLock` und klone sie.
          * **`update_rules(rules)`:**
              * Schreibe die neuen Regeln in das `RwLock`.
              * Speichere die neuen Regeln über den `NotificationRulesProvider`.
              * Sende ein `reload` Event an alle Listener, die an der `watch_for_changes` Schnittstelle des Providers lauschen.

    6.  **Modul-API (`mod.rs`):**

          * Re-exportiere alle wichtigen Strukturen, Traits und Service-Implementierungen: `data_types`, `errors`, `persistence_iface`, `engine`, `DefaultNotificationRulesEngine`, `FilesystemNotificationRulesProvider`.

  * **Spezifische Artefakte/Dateien:**

      * `novade-domain/src/notifications/data_types.rs`
      * `novade-domain/src/notifications/errors.rs`
      * `novade-domain/src/notifications/persistence_iface.rs`
      * `novade-domain/src/notifications/persistence.rs`
      * `novade-domain/src/notifications/engine.rs`
      * `novade-domain/src/notifications/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-core::config::{ConfigError, ConfigServiceAsync}`, `novade-domain::errors::DomainError`, `novade-domain::settings_service::GlobalSettingsService`, `novade-domain::notification_service::IncomingNotification`, `novade-domain::window_policy_service::data_types::Duration`.
      * **Extern:** `serde::{Serialize, Deserialize}`, `thiserror`, `uuid`, `tokio::sync::{RwLock, broadcast}`, `regex` (für `RegexMatches`), `chrono` (für Timestamps in Conditions), `std::process::Command` (für `ExecuteCommand`), `tracing`.

  * **Kommunikationsmuster:**

      * `DefaultNotificationRulesEngine` empfängt `IncomingNotification` aus der `NotificationService`.
      * Sendet Events oder ruft Funktionen in der Systemschicht auf (z.B. Audio-Service, Process-Execution Service) für Aktionen wie `PlaySound`, `ExecuteCommand`.
      * Informiert die UI-Schicht indirekt über die `NotificationService` über geänderte oder unterdrückte Benachrichtigungen.
      * Kommuniziert mit `ConfigServiceAsync` für Persistenz.
      * Abonniert Änderungen der Regeldatei über `FilesystemNotificationRulesProvider`.

  * **Erwartete Ergebnisse/Outputs:**

      * Ein robustes System zur Definition und Anwendung von Benachrichtigungsregeln.
      * Automatisierte Anpassung, Unterdrückung oder Ausführung von Aktionen basierend auf Benachrichtigungsinhalten.
      * Persistente Speicherung und Laden von Benachrichtigungsregeln.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * **`data_types.rs`:** Testen der `Default`, `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize` Implementierungen für alle Strukturen und Enums. Insbesondere für `RuleCondition` und `RuleAction` komplexe verschachtelte Fälle testen.
          * **`errors.rs`:** Testen der Fehlererzeugung, Fehlermeldungen und `From`-Implementierungen.
          * **`persistence_iface.rs`:** Mocking-Tests für den Trait (nicht die Implementierung).
          * **`persistence.rs`:**
              * Testen des Speicherns und Ladens von `NotificationRuleSet` in/aus einer temporären Datei.
              * Testen der Fehlerbehandlung bei fehlenden Dateien, ungültigem JSON, Schreib-/Lesefehlern.
              * Testen des `watch_for_changes` Mechanismus mit Dateisystem-Ereignissen oder simulierten Änderungen.
          * **`engine.rs`:**
              * Mocken von `NotificationRulesProvider` und `GlobalSettingsService`.
              * Testen der `reload_rules` Funktion (erfolgreich, fehlerhaft).
              * Umfassende Tests für `process_notification`:
                  * Alle `Operator`-Typen mit verschiedenen `ConditionValue`-Typen testen (String, Integer, Boolean, Timestamp, Enums).
                  * Komplexe `RuleCondition` (nested `AllOf`, `AnyOf`, `Not`) mit verschiedenen Szenarien.
                  * Alle `RuleAction`-Typen testen: `ChangeUrgency`, `ChangeTimeout`, `Suppress`, `PlaySound` (simulierte Aufrufe), `ExecuteCommand` (simulierte Ausführung), `ShowOnScreen` (simulierte Events), `LogNotification`, `StopProcessingFurtherRules`.
                  * Testen der Regelpriorisierung.
                  * Testen von Edge Cases: leere Regeln, Regeln ohne Aktionen, Aktionen ohne Bedingungen.
                  * Testen der Interaktion mit `GlobalSettingsService` für `SettingIsTrue/SettingIsFalse`.
              * Testen von `get_rules` und `update_rules`.
      * **Integration Tests:**
          * Integrationsszenarien, die das Zusammenspiel von `NotificationRulesEngine` mit `NotificationRulesProvider` und dem `GlobalSettingsService` (ggf. mit echten oder gemockten Implementierungen) überprüfen.

  * **Geschätzter Aufwand:** 8-12 Tage

#### 2.2.10. `novade-domain/src/power_management`

  * **Verantwortlichkeit:** Dieses Modul verwaltet die domänenspezifische Logik für Energieeinstellungen, Schlafmodi und damit verbundene Richtlinien, basierend auf globalen Einstellungen und Systemereignissen.

  * **Kern-Aufgaben (Tasks):**

    1.  **Strukturen und Enums (`data_types.rs`):**

          * Definiere die Enum `PowerState` (On, Suspend, Hibernate, Shutdown).
          * Definiere die Enum `BatteryStatus` (Charging, Discharging, Full, Unknown).
          * Definiere die Struktur `BatteryInfo` mit `percentage: f32`, `time_to_empty: Option<std::time::Duration>`, `time_to_full: Option<std::time::Duration>`, `status: BatteryStatus`.
          * Definiere die Enum `LidState` (Open, Closed).
          * Definiere die Enum `PowerPolicyAction` (Suspend, Hibernate, Shutdown, DoNothing).
          * Definiere die Struktur `PowerPolicy` mit `on_lid_close_action: PowerPolicyAction`, `on_critical_battery_action: PowerPolicyAction`, `display_sleep_timeout_seconds: u64`, `system_sleep_timeout_seconds: u64`.
          * Implementiere für alle Strukturen und Enums die Traits `Clone`, `Debug`, `PartialEq`, `Eq`, `Serialize`, `Deserialize`, `Default` (wo sinnvoll).

    2.  **Fehlerbehandlung (`errors.rs`):**

          * Definiere die Enum `PowerManagementError` mittels `thiserror` mit Varianten für:
              * `PolicyError(String)`: Fehler bei der Anwendung oder Auswertung von Power-Policies.
              * `SystemInteractionError(String)`: Fehler bei der Interaktion mit der Systemschicht für Power-Operationen (z.B. suspend fehlgeschlagen).
              * `InvalidConfiguration(String)`: Konfigurationsfehler in den Power-Einstellungen.
              * `Other(#[from] anyhow::Error)`: Für allgemeine Fehler.
          * Implementiere `From<PowerManagementError>` für `DomainError`.

    3.  **Dienst-Schnittstelle (`power_service_iface.rs`):**

          * Definiere den Trait `PowerManagementServiceAsync`:
              * `async fn get_current_battery_info(&self) -> Result<BatteryInfo, PowerManagementError>`: Ruft aktuelle Batterieinformationen ab.
              * `async fn get_lid_state(&self) -> Result<LidState, PowerManagementError>`: Ruft den Zustand des Laptop-Deckels ab.
              * `async fn request_power_state_change(&self, state: PowerState) -> Result<(), PowerManagementError>`: Fordert eine Änderung des System-Power-Zustands an (z.B. suspend, hibernate, shutdown).
              * `async fn apply_power_policies(&self) -> Result<(), PowerManagementError>`: Wendet die aktuellen Power-Policies an.
              * `fn subscribe_to_battery_changes(&self) -> tokio::sync::broadcast::Receiver<BatteryInfo>`: Liefert einen Receiver für Batterie-Zustandsänderungen.
              * `fn subscribe_to_lid_state_changes(&self) -> tokio::sync::broadcast::Receiver<LidState>`: Liefert einen Receiver für Deckel-Zustandsänderungen.

    4.  **Implementierung des Power Management Service (`service.rs`):**

          * Implementiere die Struktur `DefaultPowerManagementService` für den `PowerManagementServiceAsync` Trait.
          * Der Konstruktor nimmt einen `Arc<dyn GlobalSettingsService + Send + Sync>` und eine Schnittstelle zur Systemschicht für tatsächliche Power-Operationen (`Arc<dyn SystemPowerControl + Send + Sync>`) entgegen. Letztere muss im Systemschicht-Plan definiert werden.
          * Verwende `tokio::sync::broadcast::Sender` für Batterie- und Deckel-Zustandsänderungen.
          * **`get_current_battery_info()`:** Ruft Informationen über die Systemschicht ab.
          * **`get_lid_state()`:** Ruft Informationen über die Systemschicht ab.
          * **`request_power_state_change(state)`:** Delegiert den Aufruf an die Systemschicht (`SystemPowerControl`).
          * **`apply_power_policies()`:**
              * Lade die `PowerPolicy` aus `GlobalSettingsService`.
              * Überprüfe den `LidState` und `BatteryInfo`.
              * Wenn `LidState::Closed` und `on_lid_close_action` gesetzt ist, führe die entsprechende Aktion (`request_power_state_change`) aus.
              * Wenn `BatteryInfo::status` kritisch ist und `on_critical_battery_action` gesetzt ist, führe die entsprechende Aktion aus.
              * Logge Aktionen und Fehler.
          * **Hintergrund-Task für Monitoring:**
              * Starte einen `tokio::spawn` Task im Konstruktor, der periodisch (`poll_interval` aus Einstellungen) den Batterie- und Deckel-Zustand über die Systemschicht abfragt.
              * Bei Änderungen des Zustands oder kritischen Werten:
                  * Sende `BatteryInfo` oder `LidState` Events über die entsprechenden `broadcast::Sender`.
                  * Rufe `apply_power_policies()` auf, um sofort auf Änderungen zu reagieren.
              * Implementiere Logik für Display- und System-Sleep-Timeouts. Dies erfordert, dass die Systemschicht eine Möglichkeit bietet, Inaktivität zu erkennen und DPMS-Zustände zu steuern. Die Domänenschicht würde die Schwellenwerte aus den Einstellungen lesen und über den `SystemPowerControl`-Trait (`set_display_dpms_timeout`, `set_system_sleep_timeout`) der Systemschicht mitteilen. Der `SystemPowerControl` muss dann die tatsächliche Überwachung durchführen.

    5.  **Modul-API (`mod.rs`):**

          * Re-exportiere alle wichtigen Strukturen, Traits und Service-Implementierungen: `data_types`, `errors`, `power_service_iface`, `service`, `DefaultPowerManagementService`.

  * **Spezifische Artefakte/Dateien:**

      * `novade-domain/src/power_management/data_types.rs`
      * `novade-domain/src/power_management/errors.rs`
      * `novade-domain/src/power_management/power_service_iface.rs`
      * `novade-domain/src/power_management/service.rs`
      * `novade-domain/src/power_management/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-domain::errors::DomainError`, `novade-domain::settings_service::GlobalSettingsService`, `novade-system::power_management::SystemPowerControl` (dieser Trait wird in der Systemschicht definiert).
      * **Extern:** `serde::{Serialize, Deserialize}`, `thiserror`, `tokio::sync::broadcast`, `std::time::Duration`, `tracing`.

  * **Kommunikationsmuster:**

      * `DefaultPowerManagementService` ruft `GlobalSettingsService` ab, um Power-Policies zu erhalten.
      * `DefaultPowerManagementService` ruft Methoden auf dem `SystemPowerControl` Trait auf, um den Zustand des Systems abzufragen oder zu ändern.
      * Sendet `BatteryInfo` und `LidState` Events über `tokio::sync::broadcast` an die UI-Schicht oder andere Domänen-Services.

  * **Erwartete Ergebnisse/Outputs:**

      * Eine zentrale Logik für die Energieverwaltung, die auf Benutzer-Einstellungen und Systemereignisse reagiert.
      * Automatische Ausführung von Power-Aktionen (Suspend, Hibernate, Shutdown) basierend auf Regeln.
      * Bereitstellung aktueller Batterie- und Deckelzustandsinformationen für die UI.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * **`data_types.rs`:** Testen der `Default`, `Clone`, `Debug`, `PartialEq`, `Eq`, `Serialize`, `Deserialize` Implementierungen.
          * **`errors.rs`:** Testen der Fehlererzeugung und `From`-Implementierungen.
          * **`power_service_iface.rs`:** Mocking-Tests für den Trait.
          * **`service.rs`:**
              * Mocken von `GlobalSettingsService` und `SystemPowerControl`.
              * Testen von `get_current_battery_info` und `get_lid_state` (Delegation und Fehlerbehandlung).
              * Testen von `request_power_state_change` (Delegation und Fehlerbehandlung).
              * Umfassende Tests für `apply_power_policies`:
                  * Testen verschiedener `PowerPolicyAction` bei `LidState::Closed`.
                  * Testen verschiedener `PowerPolicyAction` bei kritischem Batteriestand.
                  * Testen des "DoNothing"-Falls.
                  * Sicherstellen, dass Policies nicht angewendet werden, wenn sie deaktiviert sind oder Bedingungen nicht erfüllt sind.
              * Testen des Hintergrund-Tasks für `subscribe_to_battery_changes` und `subscribe_to_lid_state_changes`, indem simulierte Systemevents empfangen und die korrekte Event-Weiterleitung überprüft wird.
              * Testen der Timeout-Logik für Display- und System-Sleep.
      * **Integration Tests:**
          * Szenarien, die das Zusammenspiel mit einer simulierten oder echten (lokalen) `SystemPowerControl`-Implementierung überprüfen.

  * **Geschätzter Aufwand:** 7-10 Tage

#### 2.2.11. `novade-domain/src/theme`

  * **Verantwortlichkeit:** Dieses Modul verwaltet die domänenspezifische Logik für das Theming der Desktop-Umgebung, einschließlich Farbpaletten, Schriftarten und Icon-Themen. Es bietet eine Schnittstelle für die UI, um Theme-Informationen abzurufen.

  * **Kern-Aufgaben (Tasks):**

    1.  **Strukturen und Enums (`data_types.rs`):**

          * Definiere die Struktur `Color` mit `r: u8`, `g: u8`, `b: u8`, `a: u8` (RGBA).
          * Definiere die Enum `ColorPaletteType` (Light, Dark, Custom).
          * Definiere die Struktur `ColorPalette` mit `type: ColorPaletteType`, `primary: Color`, `secondary: Color`, `accent: Color`, `background: Color`, `foreground: Color`.
          * Definiere die Enum `FontWeight` (Thin, ExtraLight, Light, Regular, Medium, SemiBold, Bold, ExtraBold, Black).
          * Definiere die Enum `FontStyle` (Normal, Italic, Oblique).
          * Definiere die Struktur `FontConfig` mit `family: String`, `size_pt: f32`, `weight: FontWeight`, `style: FontStyle`.
          * Definiere die Struktur `IconThemeConfig` mit `name: String`, `fallback_themes: Vec<String>`.
          * Definiere die Struktur `ThemeSettings` mit `color_palette: ColorPalette`, `font_config: FontConfig`, `icon_theme: IconThemeConfig`, `global_scale_factor: f32`.
          * Implementiere für alle Strukturen und Enums die Traits `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` (wo sinnvoll), `Serialize`, `Deserialize`, `Default` (wo sinnvoll). Implementiere für `Color` eine `to_rgba_string()` Methode.

    2.  **Fehlerbehandlung (`errors.rs`):**

          * Definiere die Enum `ThemeError` mittels `thiserror` mit Varianten für:
              * `InvalidThemeConfiguration(String)`: Konfigurationsfehler im Thema.
              * `ThemeNotFound(String)`: Ein angefordertes Thema oder eine Ressource wurde nicht gefunden.
              * `ColorParseError(String)`: Fehler beim Parsen von Farbwerten.
              * `Other(#[from] anyhow::Error)`: Für allgemeine Fehler.
          * Implementiere `From<ThemeError>` für `DomainError`.

    3.  **Dienst-Schnittstelle (`theme_service_iface.rs`):**

          * Definiere den Trait `ThemeServiceAsync`:
              * `async fn get_current_theme_settings(&self) -> Result<ThemeSettings, ThemeError>`: Ruft die aktuell aktiven Theme-Einstellungen ab.
              * `async fn set_theme_settings(&self, settings: ThemeSettings) -> Result<(), ThemeError>`: Speichert neue Theme-Einstellungen.
              * `fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeSettings>`: Liefert einen Receiver für Theme-Änderungen.

    4.  **Implementierung des Theme Service (`service.rs`):**

          * Implementiere die Struktur `DefaultThemeService` für den `ThemeServiceAsync` Trait.
          * Der Konstruktor nimmt einen `Arc<dyn GlobalSettingsService + Send + Sync>` entgegen.
          * Verwende einen `tokio::sync::broadcast::Sender<ThemeSettings>` für Theme-Änderungen.
          * **`get_current_theme_settings()`:**
              * Lade die `ThemeSettings` aus dem `GlobalSettingsService`.
              * Wende Standardwerte an, falls bestimmte Einstellungen fehlen.
              * Gib die `ThemeSettings` zurück.
          * **`set_theme_settings(settings)`:**
              * Speichere die `settings` über den `GlobalSettingsService`.
              * Sende die aktualisierten `settings` über den `broadcast::Sender`.
              * Logge erfolgreiches Speichern oder Fehler.
          * **Hintergrund-Task für Änderungen:**
              * Der `DefaultThemeService` sollte den `GlobalSettingsService` auf Änderungen an den Theme-Einstellungen abonnieren. Wenn der `GlobalSettingsService` eine Änderung meldet, soll der `ThemeService` die neuen Einstellungen laden und über seinen eigenen `broadcast::Sender` verteilen.

    5.  **Modul-API (`mod.rs`):**

          * Re-exportiere alle wichtigen Strukturen, Traits und Service-Implementierungen: `data_types`, `errors`, `theme_service_iface`, `service`, `DefaultThemeService`.

  * **Spezifische Artefekte/Dateien:**

      * `novade-domain/src/theme/data_types.rs`
      * `novade-domain/src/theme/errors.rs`
      * `novade-domain/src/theme/theme_service_iface.rs`
      * `novade-domain/src/theme/service.rs`
      * `novade-domain/src/theme/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-domain::errors::DomainError`, `novade-domain::settings_service::GlobalSettingsService`.
      * **Extern:** `serde::{Serialize, Deserialize}`, `thiserror`, `tokio::sync::broadcast`, `tracing`.

  * **Kommunikationsmuster:**

      * `DefaultThemeService` interagiert mit `GlobalSettingsService` für Theme-Einstellungen.
      * Sendet `ThemeSettings` Events über `tokio::sync::broadcast` an die UI-Schicht, damit diese sich anpassen kann.

  * **Erwartete Ergebnisse/Outputs:**

      * Eine konsistente Quelle für Theme-Informationen (Farben, Schriftarten, Icons).
      * Die Möglichkeit, Theme-Einstellungen persistent zu speichern und zu laden.
      * Reaktive Updates der UI bei Theme-Änderungen.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * **`data_types.rs`:** Testen der `Default`, `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize` Implementierungen. Insbesondere `Color::to_rgba_string()` testen.
          * **`errors.rs`:** Testen der Fehlererzeugung und `From`-Implementierungen.
          * **`theme_service_iface.rs`:** Mocking-Tests für den Trait.
          * **`service.rs`:**
              * Mocken von `GlobalSettingsService`.
              * Testen von `get_current_theme_settings` (Standardwerte, geladene Werte).
              * Testen von `set_theme_settings` (Speichern und Event-Versand).
              * Testen, dass der `subscribe_to_theme_changes` Receiver korrekt Events empfängt, wenn die Einstellungen im `GlobalSettingsService` geändert werden (simuliertes Ereignis vom `GlobalSettingsService`).
      * **Integration Tests:**
          * Szenarien, die das Zusammenspiel mit einer simulierten oder echten (lokalen) `GlobalSettingsService`-Implementierung überprüfen.

  * **Geschätzter Aufwand:** 5-7 Tage

#### 2.2.12. `novade-domain/src/wallpaper_manager`

  * **Verantwortlichkeit:** Dieses Modul verwaltet die domänenspezifische Logik für die Desktophintergründe, einschließlich der Auswahl, Konfiguration und Anwendung von Hintergrundbildern und Diashows.

  * **Kern-Aufgaben (Tasks):**

    1.  **Strukturen und Enums (`data_types.rs`):**

          * Definiere die Enum `WallpaperMode` (Center, Stretch, Zoom, Tile, Fit, Fill).
          * Definiere die Struktur `WallpaperSource` (FilePath(PathBuf), Color(Color), Slideshow(Vec\<PathBuf\>, std::time::Duration)). `Color` sollte die bereits definierte `novade-core::types::Color` oder `novade-domain::theme::data_types::Color` nutzen.
          * Definiere die Struktur `Wallpaper` mit `source: WallpaperSource`, `mode: WallpaperMode`, `background_color: Color`. Die `background_color` wird verwendet, wenn das Bild nicht den gesamten Bildschirm ausfüllt.
          * Implementiere für alle Strukturen und Enums die Traits `Clone`, `Debug`, `PartialEq`, `Eq`, `Serialize`, `Deserialize`, `Default` (wo sinnvoll). Implementiere `new()`-Funktionen für die komplexeren Strukturen.

    2.  **Fehlerbehandlung (`errors.rs`):**

          * Definiere die Enum `WallpaperManagerError` mittels `thiserror` mit Varianten für:
              * `InvalidWallpaperSource(String)`: Die Wallpaper-Quelle ist ungültig (z.B. Datei nicht gefunden, ungültiges Format).
              * `WallpaperProcessingError(String)`: Fehler beim Laden oder Skalieren von Bildern.
              * `SlideshowError(String)`: Fehler bei der Verwaltung der Diashow.
              * `PersistenceError(#[from] ConfigError)`: Fehler beim Speichern/Laden der Wallpaper-Einstellungen.
              * `Other(#[from] anyhow::Error)`: Für allgemeine Fehler.
          * Implementiere `From<WallpaperManagerError>` für `DomainError`.

    3.  **Dienst-Schnittstelle (`wallpaper_service_iface.rs`):**

          * Definiere den Trait `WallpaperServiceAsync`:
              * `async fn get_current_wallpaper(&self) -> Result<Wallpaper, WallpaperManagerError>`: Ruft die aktuell aktiven Wallpaper-Einstellungen ab.
              * `async fn set_wallpaper(&self, wallpaper: Wallpaper) -> Result<(), WallpaperManagerError>`: Setzt die Wallpaper-Einstellungen.
              * `fn subscribe_to_wallpaper_changes(&self) -> tokio::sync::broadcast::Receiver<Wallpaper>`: Liefert einen Receiver für Wallpaper-Änderungen.
              * `async fn next_slideshow_image(&self) -> Result<(), WallpaperManagerError>`: Schaltet zum nächsten Bild in einer Diashow.
              * `async fn previous_slideshow_image(&self) -> Result<(), WallpaperManagerError>`: Schaltet zum vorherigen Bild in einer Diashow.
              * `async fn refresh_wallpaper(&self) -> Result<(), WallpaperManagerError>`: Erzwingt ein Neuladen und Neuanwenden des aktuellen Wallpapers.

    4.  **Implementierung des Wallpaper Manager Service (`service.rs`):**

          * Implementiere die Struktur `DefaultWallpaperService` für den `WallpaperServiceAsync` Trait.
          * Der Konstruktor nimmt einen `Arc<dyn GlobalSettingsService + Send + Sync>` und optional eine Schnittstelle zur Systemschicht für Bildverarbeitung (`Arc<dyn SystemImageProcessor + Send + Sync>`) entgegen, falls Bildverarbeitung nicht in der Domäne stattfindet.
          * Verwende ein `tokio::sync::RwLock<Wallpaper>` für den aktuellen Wallpaper-Zustand.
          * Verwende einen `tokio::sync::broadcast::Sender<Wallpaper>` für Wallpaper-Änderungen.
          * Verwalte einen internen Zähler/Index für Diashows.
          * **`get_current_wallpaper()`:**
              * Lade die `Wallpaper` aus dem `GlobalSettingsService`.
              * Gib die `Wallpaper` zurück.
          * **`set_wallpaper(wallpaper)`:**
              * Validiere die `wallpaper` (z.B. Pfade existieren für `FilePath`, `Slideshow`).
              * Speichere die `wallpaper` über den `GlobalSettingsService`.
              * Aktualisiere den internen `RwLock`.
              * Sende die aktualisierte `wallpaper` über den `broadcast::Sender`.
              * Starte oder stoppe den Diashow-Timer basierend auf `wallpaper.source`.
              * Logge erfolgreiches Setzen oder Fehler.
          * **`next_slideshow_image()` / `previous_slideshow_image()`:**
              * Wenn die aktuelle Quelle `Slideshow` ist, aktualisiere den internen Index.
              * Aktualisiere den internen `RwLock` mit dem neuen Bildpfad.
              * Sende das aktualisierte `Wallpaper` über den `broadcast::Sender`.
              * Starte den Timer für das nächste Bild neu.
          * **`refresh_wallpaper()`:**
              * Lade den aktuellen Wallpaper-Zustand neu vom `GlobalSettingsService`.
              * Sende den geladenen Zustand über den `broadcast::Sender`.
          * **Hintergrund-Task für Diashow:**
              * Starte einen `tokio::spawn` Task, wenn eine Diashow aktiv ist.
              * Der Task sollte periodisch (basierend auf `std::time::Duration` in `Slideshow`) `next_slideshow_image()` aufrufen.
              * Der Task muss beendet werden, wenn der Wallpaper-Typ wechselt oder der Service herunterfährt.
          * **Hintergrund-Task für Änderungen:**
              * Der `DefaultWallpaperService` sollte den `GlobalSettingsService` auf Änderungen an den Wallpaper-Einstellungen abonnieren. Wenn der `GlobalSettingsService` eine Änderung meldet, soll der `WallpaperService` die neuen Einstellungen laden und über seinen eigenen `broadcast::Sender` verteilen.

    5.  **Modul-API (`mod.rs`):**

          * Re-exportiere alle wichtigen Strukturen, Traits und Service-Implementierungen: `data_types`, `errors`, `wallpaper_service_iface`, `service`, `DefaultWallpaperService`.

  * **Spezifische Artefakte/Dateien:**

      * `novade-domain/src/wallpaper_manager/data_types.rs`
      * `novade-domain/src/wallpaper_manager/errors.rs`
      * `novade-domain/src/wallpaper_manager/wallpaper_service_iface.rs`
      * `novade-domain/src/wallpaper_manager/service.rs`
      * `novade-domain/src/wallpaper_manager/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-core::config::ConfigError`, `novade-domain::errors::DomainError`, `novade-domain::settings_service::GlobalSettingsService`, `novade-domain::theme::data_types::Color` (für `Wallpaper::background_color`).
      * **Extern:** `serde::{Serialize, Deserialize}`, `thiserror`, `tokio::sync::{RwLock, broadcast}`, `std::path::PathBuf`, `std::time::Duration`, `tracing`. (Optional: `image` crate oder ähnliches für rudimentäre Bildprüfung, falls keine Systemschicht-Schnittstelle vorhanden ist).

  * **Kommunikationsmuster:**

      * `DefaultWallpaperService` interagiert mit `GlobalSettingsService` für Wallpaper-Einstellungen.
      * Sendet `Wallpaper` Events über `tokio::sync::broadcast` an die UI-Schicht, damit diese den Hintergrund aktualisieren kann.
      * Diashow-Management löst interne `set_wallpaper` und `refresh_wallpaper` Aufrufe aus, die wiederum Events senden.

  * **Erwartete Ergebnisse/Outputs:**

      * Eine zentrale Logik für die Verwaltung von Desktophintergründen.
      * Unterstützung für Einzelbilder, Farb-Hintergründe und Diashows.
      * Reaktive Updates der UI bei Wallpaper-Änderungen.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * **`data_types.rs`:** Testen der `Default`, `Clone`, `Debug`, `PartialEq`, `Eq`, `Serialize`, `Deserialize` Implementierungen. Testen der `new()`-Funktionen.
          * **`errors.rs`:** Testen der Fehlererzeugung und `From`-Implementierungen.
          * **`wallpaper_service_iface.rs`:** Mocking-Tests für den Trait.
          * **`service.rs`:**
              * Mocken von `GlobalSettingsService`.
              * Testen von `get_current_wallpaper` (Standardwerte, geladene Werte).
              * Testen von `set_wallpaper`:
                  * Erfolgreiches Setzen für `FilePath`, `Color`, `Slideshow`.
                  * Fehlerbehandlung bei ungültigen Pfaden oder Formaten (simuliert).
                  * Sicherstellen, dass Events gesendet werden.
                  * Diashow-Timer-Start/Stop Logik testen.
              * Testen von `next_slideshow_image` und `previous_slideshow_image` für `Slideshow`-Typen (Index-Rollover, Events).
              * Testen von `refresh_wallpaper`.
              * Testen des Diashow-Hintergrund-Tasks (simulieren von Zeitablauf).
      * **Integration Tests:**
          * Szenarien, die das Zusammenspiel mit einer simulierten oder echten (lokalen) `GlobalSettingsService`-Implementierung überprüfen.

  * **Geschätzter Aufwand:** 6-9 Tage

#### 2.2.13. `novade-domain/src/window_policy`

  * **Verantwortlichkeit:** Dieses Modul definiert die domänenspezifischen Richtlinien und Regeln für das Fenstermanagement, einschließlich Tiling, Fensterzustände, Fokusverhalten und Workspace-Zuordnung. Es ist die zentrale Entscheidungsinstanz für den `Compositor` der Systemschicht.

  * **Kern-Aufgaben (Tasks):**

    1.  **Strukturen und Enums (`data_types.rs`):**

          * Definiere die Enum `WindowType` (Normal, Dialog, Menu, Toolbar, Utility, Desktop, Dock, Notification, Splash, Unknown).
          * Definiere die Enum `WindowState` (Normal, Maximized, Minimized, Fullscreen, TiledLeft, TiledRight, TiledTop, TiledBottom).
          * Definiere die Enum `FocusMethod` (ClickToFocus, SloppyFocus, MouseFollowsFocus).
          * Definiere die Enum `TilingLayout` (Floating, Fullscreen, LeftStack, RightStack, Grid, Column).
          * Definiere die Struktur `Workspace` mit `id: Uuid`, `name: String`, `is_active: bool`.
          * Definiere die Struktur `WindowIdentifier` mit `app_id: String`, `title: String`, `pid: Option<u32>`.
          * Definiere die Struktur `WindowPolicyConfig` mit `focus_method: FocusMethod`, `default_tiling_layout: TilingLayout`, `workspaces_count: u32`, `auto_tile_new_windows: bool`.
          * Definiere die Struktur `WindowAttributes` (intern vom Compositor verwendet, aber vom Policy Service beeinflusst):
              * `id: WindowIdentifier`
              * `current_geometry: novade_core::types::geometry::Rectangle<i32>`
              * `min_size: Option<novade_core::types::geometry::Size<u32>>`
              * `max_size: Option<novade_core::types::geometry::Size<u32>>`
              * `is_mapped: bool`
              * `is_decorated: bool`
              * `is_resizable: bool`
              * `window_type: WindowType`
              * `current_state: WindowState`
              * `assigned_workspace_id: Uuid`
              * `is_urgent: bool`
              * `is_xwayland: bool`
              * `is_foreign_toplevel: bool` (für XDG Desktop Portals)
              * `is_always_on_top: bool`
          * Implementiere für alle Strukturen und Enums die Traits `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` (wo sinnvoll), `Serialize`, `Deserialize`, `Default` (wo sinnvoll).

    2.  **Fehlerbehandlung (`errors.rs`):**

          * Definiere die Enum `WindowPolicyError` mittels `thiserror` mit Varianten für:
              * `InvalidPolicy(String)`: Eine Richtlinie ist ungültig oder in sich widersprüchlich.
              * `WindowNotFoundError(WindowIdentifier)`: Das angegebene Fenster wurde nicht gefunden.
              * `WorkspaceNotFoundError(Uuid)`: Der angegebene Arbeitsbereich wurde nicht gefunden.
              * `PolicyApplicationError(String)`: Fehler beim Anwenden einer Richtlinie.
              * `Other(#[from] anyhow::Error)`: Für allgemeine Fehler.
          * Implementiere `From<WindowPolicyError>` für `DomainError`.

    3.  **Dienst-Schnittstelle (`window_policy_service_iface.rs`):**

          * Definiere den Trait `WindowPolicyServiceAsync`:
              * `async fn get_current_policy_config(&self) -> Result<WindowPolicyConfig, WindowPolicyError>`: Ruft die aktuellen Konfigurationsrichtlinien ab.
              * `async fn set_policy_config(&self, config: WindowPolicyConfig) -> Result<(), WindowPolicyError>`: Setzt neue Konfigurationsrichtlinien.
              * `fn subscribe_to_policy_changes(&self) -> tokio::sync::broadcast::Receiver<WindowPolicyConfig>`: Liefert einen Receiver für Änderungen der Konfigurationsrichtlinien.
              * `async fn get_workspaces(&self) -> Result<Vec<Workspace>, WindowPolicyError>`: Ruft alle definierten Arbeitsbereiche ab.
              * `async fn get_active_workspace(&self) -> Result<Workspace, WindowPolicyError>`: Ruft den aktiven Arbeitsbereich ab.
              * `async fn activate_workspace(&self, workspace_id: Uuid) -> Result<(), WindowPolicyError>`: Aktiviert einen Arbeitsbereich.
              * `async fn create_workspace(&self, name: String) -> Result<Workspace, WindowPolicyError>`: Erstellt einen neuen Arbeitsbereich.
              * `async fn remove_workspace(&self, workspace_id: Uuid) -> Result<(), WindowPolicyError>`: Entfernt einen Arbeitsbereich (wenn leer).
              * `async fn move_window_to_workspace(&self, window_id: WindowIdentifier, workspace_id: Uuid) -> Result<(), WindowPolicyError>`: Verschiebt ein Fenster in einen anderen Arbeitsbereich.
              * `async fn set_window_state(&self, window_id: WindowIdentifier, state: WindowState) -> Result<(), WindowPolicyError>`: Setzt den Zustand eines Fensters (Maximiert, Gekachelt etc.).
              * `async fn request_window_focus(&self, window_id: WindowIdentifier) -> Result<(), WindowPolicyError>`: Fordert den Fokus für ein Fenster an.
              * `async fn get_windows_on_workspace(&self, workspace_id: Uuid) -> Result<Vec<WindowIdentifier>, WindowPolicyError>`: Liefert eine Liste der Fenster auf einem Arbeitsbereich.
              * `fn subscribe_to_workspace_changes(&self) -> tokio::sync::broadcast::Receiver<Vec<Workspace>>`: Liefert einen Receiver für Arbeitsbereichsänderungen (hinzugefügt/entfernt/aktiv).
              * `fn subscribe_to_active_window_changes(&self) -> tokio::sync::broadcast::Receiver<Option<WindowIdentifier>>`: Liefert einen Receiver für Änderungen des aktiven Fensters.
              * `fn subscribe_to_window_state_changes(&self) -> tokio::sync::broadcast::Receiver<(WindowIdentifier, WindowState)>`: Liefert einen Receiver für Änderungen des Fensterzustands.
              * `async fn handle_new_window(&self, window_id: WindowIdentifier, initial_attributes: WindowAttributes) -> Result<WindowAttributes, WindowPolicyError>`: Handhabt ein neu erzeugtes Fenster und gibt die vom Policy-Service modifizierten Attribute zurück (z.B. initialer Workspace, Tiling-Zustand).

    4.  **Implementierung des Window Policy Service (`service.rs`):**

          * Implementiere die Struktur `DefaultWindowPolicyService` für den `WindowPolicyServiceAsync` Trait.
          * Der Konstruktor nimmt einen `Arc<dyn GlobalSettingsService + Send + Sync>` entgegen.
          * Verwende `tokio::sync::RwLock<Vec<Workspace>>` für die Liste der Workspaces.
          * Verwende `tokio::sync::RwLock<HashMap<WindowIdentifier, WindowAttributes>>` für den internen Fensterzustand. Dies ist die **zentrale Datenstruktur**, die vom Compositor aktualisiert und vom Policy Service manipuliert wird.
          * Verwende `tokio::sync::broadcast::Sender` für Workspace- und Fenster-Events.
          * **`get_current_policy_config()` / `set_policy_config()`:** Delegieren an `GlobalSettingsService` und senden `policy_changes` Events.
          * **Workspace-Management (`get_workspaces`, `get_active_workspace`, `activate_workspace`, `create_workspace`, `remove_workspace`):**
              * Verwalte die `Vec<Workspace>` im `RwLock`.
              * Bei `activate_workspace`: Setze `is_active` für alten und neuen Workspace, sende `workspace_changes` Event.
              * Bei `create_workspace`: Erzeuge neue `Uuid`, füge hinzu, sende Event.
              * Bei `remove_workspace`: Nur wenn leer, entferne, sende Event.
              * Sicherstellen, dass es immer mindestens einen Workspace gibt.
              * Workspaces sollten persistent gespeichert und geladen werden (z.B. über `GlobalSettingsService`).
          * **Fenster-Management (`set_window_state`, `request_window_focus`, `move_window_to_workspace`, `get_windows_on_workspace`):**
              * Diese Methoden manipulieren den internen `HashMap<WindowIdentifier, WindowAttributes>`.
              * Wenn `set_window_state` aufgerufen wird, sende `window_state_changes` Event.
              * Wenn `request_window_focus` aufgerufen wird, sende `active_window_changes` Event.
              * `move_window_to_workspace`: Ändere `assigned_workspace_id`, sende Event.
              * Bei Tiling-States (`TiledLeft`, `TiledRight`): Der Policy Service muss die Geometrie basierend auf dem aktiven Layout *vorschlagen*. Die tatsächliche Anwendung erfolgt im Compositor.
          * **`handle_new_window(window_id, initial_attributes)`:**
              * Füge das neue Fenster der internen `HashMap` hinzu.
              * Wende `auto_tile_new_windows` an, wenn aktiviert. Dies bedeutet, dass die `initial_attributes.current_state` auf den `default_tiling_layout` gesetzt wird und eine vorgeschlagene Geometrie berechnet wird.
              * Weise dem Fenster den aktiven Workspace zu.
              * Gib die modifizierten `WindowAttributes` zurück.
              * Sende `window_state_changes` (falls initialer Zustand geändert) und `windows_on_workspace_changes` Events.
          * **Hintergrund-Task für Änderungen:**
              * Der `DefaultWindowPolicyService` sollte den `GlobalSettingsService` auf Änderungen an den Fenster- und Workspace-Einstellungen abonnieren. Wenn der `GlobalSettingsService` eine Änderung meldet, soll der `WindowPolicyService` die neuen Einstellungen laden und über seine eigenen `broadcast::Sender` verteilen.
              * Die `subscribe_to_active_window_changes`, `subscribe_to_workspace_changes` und `subscribe_to_window_state_changes` Receiver sollten ihre Daten aus den internen `RwLock`s beziehen.

    5.  **Modul-API (`mod.rs`):**

          * Re-exportiere alle wichtigen Strukturen, Traits und Service-Implementierungen: `data_types`, `errors`, `window_policy_service_iface`, `service`, `DefaultWindowPolicyService`.

  * **Spezifische Artefakte/Dateien:**

      * `novade-domain/src/window_policy/data_types.rs`
      * `novade-domain/src/window_policy/errors.rs`
      * `novade-domain/src/window_policy/window_policy_service_iface.rs`
      * `novade-domain/src/window_policy/service.rs`
      * `novade-domain/src/window_policy/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-core::types::geometry::{Rectangle, Size}`, `novade-domain::errors::DomainError`, `novade-domain::settings_service::GlobalSettingsService`.
      * **Extern:** `serde::{Serialize, Deserialize}`, `thiserror`, `uuid`, `tokio::sync::{RwLock, broadcast}`, `std::collections::HashMap`, `tracing`.

  * **Kommunikationsmuster:**

      * `DefaultWindowPolicyService` interagiert mit `GlobalSettingsService` für Richtlinienkonfiguration.
      * Die Systemschicht (insbesondere der `Compositor`) ruft `handle_new_window` auf, um ein neues Fenster zu registrieren und die initialen Richtlinien zu erhalten.
      * Die Systemschicht ruft `set_window_state`, `request_window_focus`, `move_window_to_workspace` auf, um Aktionen des Benutzers zu verarbeiten oder den Zustand des Fensters zu aktualisieren.
      * Die Systemschicht abonniert `policy_changes`, `workspace_changes`, `active_window_changes`, `window_state_changes` um ihre Rendering- und Interaktionslogik anzupassen.
      * Die UI-Schicht abonniert `workspace_changes`, `active_window_changes`, `window_state_changes` für ihre Visualisierung (z.B. Taskleiste, Workspace-Switcher).

  * **Erwartete Ergebnisse/Outputs:**

      * Eine zentrale, konsistente Quelle für Fenster- und Workspace-Richtlinien.
      * Automatisches Anwenden von initialen Fensterattributen.
      * Ereignisse, die es dem Compositor und der UI ermöglichen, auf Änderungen des Fenster- und Workspace-Zustands zu reagieren.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * **`data_types.rs`:** Testen der `Default`, `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize` Implementierungen.
          * **`errors.rs`:** Testen der Fehlererzeugung und `From`-Implementierungen.
          * **`window_policy_service_iface.rs`:** Mocking-Tests für den Trait.
          * **`service.rs`:**
              * Mocken von `GlobalSettingsService`.
              * Testen von `get_current_policy_config` und `set_policy_config`.
              * Testen aller Workspace-Management-Funktionen (`get_workspaces`, `create_workspace`, `activate_workspace`, `remove_workspace`) inklusive Edge Cases (z.B. Versuch, den letzten Workspace zu entfernen, ungültige IDs). Sicherstellen, dass Events gesendet werden.
              * Testen von `handle_new_window`:
                  * Korrekte Zuweisung zum aktiven Workspace.
                  * Anwendung von `auto_tile_new_windows` und Berechnung der initialen Geometrie (wenn aktiviert).
                  * Sicherstellen, dass `WindowAttributes` korrekt zurückgegeben und Events gesendet werden.
              * Testen von `set_window_state`, `request_window_focus`, `move_window_to_workspace`, `get_windows_on_workspace` (Änderung des internen Zustands und Event-Versand).
              * Testen der verschiedenen `subscribe_to_..._changes` Receiver.
      * **Integration Tests:**
          * Szenarien, die das Zusammenspiel mit einer simulierten `GlobalSettingsService`-Implementierung und simulierten Fenster-Ereignissen überprüfen.

  * **Geschätzter Aufwand:** 10-15 Tage

#### 2.2.14. `novade-domain/src/system_monitor`

  * **Verantwortlichkeit:** Dieses Modul aggregiert und verarbeitet Systemleistungsdaten (CPU, RAM, Netzwerk, Speicher) und stellt diese in einer domänenspezifischen Form bereit. Es definiert Schwellenwerte und generiert ggf. Warnungen.

  * **Kern-Aufgaben (Tasks):**

    1.  **Strukturen und Enums (`data_types.rs`):**

          * Definiere die Struktur `CpuInfo` mit `usage_percentage: f32`, `frequency_ghz: f32`, `temperature_celsius: Option<f32>`.
          * Definiere die Struktur `MemoryInfo` mit `total_bytes: u64`, `used_bytes: u64`, `available_bytes: u64`, `swap_total_bytes: u64`, `swap_used_bytes: u64`.
          * Definiere die Struktur `NetworkInterfaceInfo` mit `name: String`, `ip_address: Option<String>`, `mac_address: Option<String>`, `is_up: bool`, `bytes_sent: u64`, `bytes_received: u64`.
          * Definiere die Struktur `DiskInfo` mit `name: String`, `total_bytes: u64`, `used_bytes: u64`, `available_bytes: u64`, `mount_point: String`.
          * Definiere die Struktur `SystemHealthStatus` mit `cpu: CpuInfo`, `memory: MemoryInfo`, `network_interfaces: Vec<NetworkInterfaceInfo>`, `disks: Vec<DiskInfo>`.
          * Definiere die Struktur `ThresholdConfig` mit `cpu_usage_warning_percent: f32`, `memory_usage_warning_percent: f32`, `disk_usage_warning_percent: f32`.
          * Implementiere für alle Strukturen und Enums die Traits `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`, `Default` (wo sinnvoll).

    2.  **Fehlerbehandlung (`errors.rs`):**

          * Definiere die Enum `SystemMonitorError` mittels `thiserror` mit Varianten für:
              * `DataAcquisitionError(String)`: Fehler beim Abrufen von Systemdaten (z.B. von der Systemschicht).
              * `InvalidThreshold(String)`: Ungültige Schwellenwertkonfiguration.
              * `Other(#[from] anyhow::Error)`: Für allgemeine Fehler.
          * Implementiere `From<SystemMonitorError>` für `DomainError`.

    3.  **Dienst-Schnittstelle (`system_monitor_service_iface.rs`):**

          * Definiere den Trait `SystemMonitorServiceAsync`:
              * `async fn get_current_system_health(&self) -> Result<SystemHealthStatus, SystemMonitorError>`: Ruft den aktuellen Systemzustand ab.
              * `async fn get_threshold_config(&self) -> Result<ThresholdConfig, SystemMonitorError>`: Ruft die aktuellen Schwellenwerte ab.
              * `async fn set_threshold_config(&self, config: ThresholdConfig) -> Result<(), SystemMonitorError>`: Setzt neue Schwellenwerte.
              * `fn subscribe_to_health_updates(&self) -> tokio::sync::broadcast::Receiver<SystemHealthStatus>`: Liefert einen Receiver für regelmäßige Systemstatus-Updates.
              * `fn subscribe_to_threshold_alerts(&self) -> tokio::sync::broadcast::Receiver<String>`: Liefert einen Receiver für Warnungen bei Überschreitung von Schwellenwerten.

    4.  **Implementierung des System Monitor Service (`service.rs`):**

          * Implementiere die Struktur `DefaultSystemMonitorService` für den `SystemMonitorServiceAsync` Trait.
          * Der Konstruktor nimmt einen `Arc<dyn GlobalSettingsService + Send + Sync>` und eine Schnittstelle zur Systemschicht für die Rohdaten-Akquisition (`Arc<dyn SystemMetricsProvider + Send + Sync>`) entgegen. Letztere muss im Systemschicht-Plan definiert werden.
          * Verwende einen `tokio::sync::broadcast::Sender<SystemHealthStatus>` für Status-Updates und einen `tokio::sync::broadcast::Sender<String>` für Warnungen.
          * **`get_current_system_health()`:** Delegiert an `SystemMetricsProvider`.
          * **`get_threshold_config()` / `set_threshold_config()`:** Delegieren an `GlobalSettingsService`.
          * **Hintergrund-Task für Monitoring:**
              * Starte einen `tokio::spawn` Task im Konstruktor.
              * Dieser Task fragt periodisch (Intervall aus `GlobalSettingsService`) den `SystemMetricsProvider` nach aktuellen Metriken ab.
              * Bei jeder Aktualisierung:
                  * Erstelle ein `SystemHealthStatus` Objekt.
                  * Sende es über den `health_updates` `broadcast::Sender`.
                  * Vergleiche die Metriken mit den geladenen `ThresholdConfig` Werten.
                  * Wenn ein Schwellenwert überschritten wird, generiere eine Warnmeldung (String) und sende sie über den `threshold_alerts` `broadcast::Sender`. Beispiel: "CPU usage critical: 95%\!".
              * Implementiere Fehlerbehandlung für den Fall, dass der `SystemMetricsProvider` Fehler zurückgibt.

    5.  **Modul-API (`mod.rs`):**

          * Re-exportiere alle wichtigen Strukturen, Traits und Service-Implementierungen: `data_types`, `errors`, `system_monitor_service_iface`, `service`, `DefaultSystemMonitorService`.

  * **Spezifische Artefakte/Dateien:**

      * `novade-domain/src/system_monitor/data_types.rs`
      * `novade-domain/src/system_monitor/errors.rs`
      * `novade-domain/src/system_monitor/system_monitor_service_iface.rs`
      * `novade-domain/src/system_monitor/service.rs`
      * `novade-domain/src/system_monitor/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-domain::errors::DomainError`, `novade-domain::settings_service::GlobalSettingsService`, `novade-system::metrics::SystemMetricsProvider` (dieser Trait wird in der Systemschicht definiert).
      * **Extern:** `serde::{Serialize, Deserialize}`, `thiserror`, `tokio::sync::broadcast`, `tracing`, `std::time::Duration`.

  * **Kommunikationsmuster:**

      * `DefaultSystemMonitorService` interagiert mit `GlobalSettingsService` für Schwellenwerte.
      * `DefaultSystemMonitorService` delegiert die Rohdaten-Akquisition an `SystemMetricsProvider` in der Systemschicht.
      * Sendet `SystemHealthStatus` und `String` (Warnungen) Events über `tokio::sync::broadcast` an die UI-Schicht oder andere Domänen-Services.

  * **Erwartete Ergebnisse/Outputs:**

      * Regelmäßige und konsistente Bereitstellung von Systemleistungsdaten.
      * Erkennung und Benachrichtigung bei Überschreitung kritischer Schwellenwerte.
      * Konfigurierbare Überwachungsintervalle und Schwellenwerte.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * **`data_types.rs`:** Testen der `Default`, `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize` Implementierungen.
          * **`errors.rs`:** Testen der Fehlererzeugung und `From`-Implementierungen.
          * **`system_monitor_service_iface.rs`:** Mocking-Tests für den Trait.
          * **`service.rs`:**
              * Mocken von `GlobalSettingsService` und `SystemMetricsProvider`.
              * Testen von `get_current_system_health` (Delegation und Fehlerbehandlung).
              * Testen von `get_threshold_config` und `set_threshold_config`.
              * Testen des Hintergrund-Tasks:
                  * Simulieren von Metriken vom `SystemMetricsProvider` und Überprüfung, dass `health_updates` korrekt gesendet werden.
                  * Simulieren von Metriken, die Schwellenwerte überschreiten, und Überprüfung, dass `threshold_alerts` korrekt gesendet werden (korrekte Warnmeldung).
                  * Testen, dass die Polling-Rate durch die Einstellungen beeinflusst wird.
      * **Integration Tests:**
          * Szenarien, die das Zusammenspiel mit einer simulierten `SystemMetricsProvider`-Implementierung überprüfen.

  * **Geschätzter Aufwand:** 6-8 Tage

#### 2.2.15. `novade-domain/src/mod.rs` (Domänenschicht Crate Root)

  * **Verantwortlichkeit:** Definiert die öffentliche API der gesamten `novade-domain` Crate. Exportiert alle relevanten Module und Strukturen, um sie für höhere Schichten (`novade-system`, `novade-ui`) zugänglich zu machen.

  * **Kern-Aufgaben (Tasks):**

    1.  **Modul-Deklarationen:** Deklariere alle Untermodule (`config`, `desktop_entries`, `errors`, `global_settings`, `notification_service`, `notifications`, `power_management`, `search`, `secret_service`, `shell_integration`, `system_monitor`, `theme`, `wallpaper_manager`, `window_policy`).
    2.  **Re-Exports:** Exportiere alle öffentlichen Traits, Services, Enums und Structs aus den Untermodulen, die für die Interaktion mit der Domänenschicht von außen notwendig sind.
          * Beispiele: `GlobalSettingsService`, `DefaultGlobalSettingsService`, `DomainError`, `ConfigServiceAsync`, `WallpaperServiceAsync`, `ThemeServiceAsync`, `WindowPolicyServiceAsync`, `NotificationServiceAsync`, `NotificationRulesEngine`, `SystemMonitorServiceAsync`, `DesktopEntryServiceAsync`, `SecretServiceAsync`, `ShellIntegrationServiceAsync`, `PowerManagementServiceAsync`, `SearchServiceAsync`.
          * Auch wichtige `data_types` wie `WindowAttributes`, `Wallpaper`, `ThemeSettings`, `SystemHealthStatus`, `IncomingNotification`, `NotificationRuleSet`, `DesktopEntry`, `Secret`, `ShellCommand`, `PowerPolicy` etc.

  * **Spezifische Artefakte/Dateien:**

      * `novade-domain/src/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** Alle Untermodule der `novade-domain` Crate.

  * **Kommunikationsmuster:** Ermöglicht den Import von Domänen-Services und Datenstrukturen durch andere Crates.

  * **Erwartete Ergebnisse/Outputs:** Eine sauber definierte und einfach zu nutzende öffentliche API für die `novade-domain` Crate.

  * **Teststrategie (Modul-spezifisch):**

      * **Compile-time Tests:** Sicherstellen, dass alle re-exportierten Pfade korrekt sind und keine Zirkelabhängigkeiten entstehen.
      * **Integration Tests:** Die Integrationstests auf höherer Ebene werden implizit testen, ob die Exports korrekt funktionieren.

  * **Geschätzter Aufwand:** 1 Tag

### 2.3. Systemschicht (`novade-system`)

#### 2.3.1. `novade-system/src/lib.rs` (Systemschicht Crate Root)

  * **Verantwortlichkeit:** Initialisiert die Systemschicht und koordiniert die Lebenszyklen ihrer Kernkomponenten. Definiert die grundlegende Struktur der Crate und aggregiert die System-Services.

  * **Kern-Aufgaben (Tasks):**

    1.  **Modul-Deklarationen:** Deklariere alle Untermodule der Systemschicht (`compositor`, `input`, `dbus_interfaces`, `audio_management`, `mcp_client`, `window_mechanics`, `power_management`, `metrics`, `portals`, `startup`, `events`, `error`, `desktop_state`).
    2.  **`SystemServices` Struktur:**
          * Definiere eine `SystemServices` Struktur, die `Arc<Mutex<DesktopState>>` (oder `RwLock` für bessere Nebenläufigkeit) und `Arc`s zu allen wichtigen System-Services (`CompositorService`, `InputService`, `DbusClientService`, etc.) enthält.
          * Diese Struktur dient als zentraler Zugriffspunkt für die Domänen- und UI-Schicht auf die Systemfunktionalitäten.
    3.  **`init()` Funktion:**
          * Erstelle eine asynchrone `init()` Funktion, die:
              * Die `DesktopState` Struktur initialisiert. Diese Struktur wird den aktuellen Zustand des Desktops halten (Fenster, Workspaces, Eingabegeräte, etc.) und ist essenziell für den Compositor.
              * Alle System-Services (`compositor`, `input`, `dbus_interfaces`, etc.) instanziiert. Die Services erhalten dabei die notwendigen Abhängigkeiten (z.B. `DesktopState`, Referenzen zu Domänen-Services).
              * Optionale Hintergrund-Tasks für Services startet (z.B. D-Bus Listener, Compositor-Loop).
              * Die initialisierte `SystemServices` Struktur zurückgibt.
              * Fehlerbehandlung für Initialisierungsfehler.
    4.  **`run()` Funktion:**
          * Eine `run()` Funktion, die die Haupt-Event-Loop des Compositors startet (Smithay). Dies wird typischerweise eine `async fn` sein, die nicht zurückkehrt, bis der Compositor beendet wird.

  * **Spezifische Artefakte/Dateien:**

      * `novade-system/src/lib.rs`

  * **Abhängigkeiten:**

      * **Intern:** Alle `novade-system` Untermodule.
      * **Extern:** `tokio`, `tracing`, `anyhow`, `parking_lot::{Mutex, RwLock}` (oder `std::sync`), `smithay` (für die Compositor-Initialisierung), `novade-core::error::CoreError`, `novade-domain::*` (für die Integration der Domänen-Services).

  * **Kommunikationsmuster:**

      * `lib.rs` ist der Orchestrator für die Systemschicht.
      * Stellt `SystemServices` für Domänen- und UI-Schicht bereit.
      * Die `init()` Funktion injiziert Domänen-Service-Schnittstellen in die System-Services.

  * **Erwartete Ergebnisse/Outputs:**

      * Eine vollständig initialisierte und lauffähige Systemschicht.
      * Ein zentrales Objekt (`SystemServices`), das den Zugriff auf die Kernfunktionalitäten der Systemschicht ermöglicht.

  * **Teststrategie (Modul-spezifisch):**

      * **Integration Tests:**
          * Testen der `init()` Funktion: Sicherstellen, dass alle Services korrekt initialisiert werden und die Abhängigkeiten richtig verdrahtet sind.
          * Simulieren eines System-Starts und -Herunterfahrens, um die Lebenszyklen zu überprüfen.
          * Überprüfen, ob keine Deadlocks oder Race Conditions während der Initialisierung auftreten.

  * **Geschätzter Aufwand:** 3-5 Tage

#### 2.3.2. `novade-system/src/error.rs`

  * **Verantwortlichkeit:** Definiert die spezifischen Fehlertypen für die Systemschicht, die für interne Operationen und die Kommunikation mit der Domänen- und UI-Schicht verwendet werden.

  * **Kern-Aufgaben (Tasks):**

    1.  **`SystemError` Enum:**
          * Definiere die Enum `SystemError` mittels `thiserror` mit Varianten für:
              * `CompositorError(String)`: Fehler im Wayland-Compositor (z.B. Renderer-Initialisierung, Protokollfehler).
              * `InputError(String)`: Fehler bei der Eingabeverarbeitung (z.B. libinput-Fehler, xkbcommon-Fehler).
              * `DbusError(#[from] zbus::Error)`: Fehler bei der D-Bus-Kommunikation.
              * `AudioError(String)`: Fehler im Audio-Management (PipeWire).
              * `McpClientError(String)`: Fehler in der MCP-Client-Kommunikation.
              * `WindowMechanicsError(String)`: Fehler bei der technischen Fensterverwaltung.
              * `PowerManagementError(String)`: Fehler bei der System-Power-Verwaltung.
              * `MetricsError(String)`: Fehler beim Abrufen von Systemmetriken.
              * `PortalError(String)`: Fehler bei der Interaktion mit XDG Desktop Portals.
              * `StartupError(String)`: Fehler während des Systemstarts.
              * `IOError(#[from] std::io::Error)`: Allgemeine I/O-Fehler.
              * `ConfigError(#[from] novade_core::config::ConfigError)`: Fehler bei der Konfigurationsverwaltung (intern).
              * `Other(#[from] anyhow::Error)`: Für alle anderen unvorhergesehenen Fehler.
    2.  **`From` Implementierungen:** Implementiere `From<SystemError>` für `novade_core::error::CoreError` und `novade_domain::errors::DomainError`, um eine reibungslose Fehlerpropagation zu ermöglichen.

  * **Spezifische Artefakte/Dateien:**

      * `novade-system/src/error.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-core::error::CoreError`, `novade_domain::errors::DomainError`.
      * **Extern:** `thiserror`, `zbus`.

  * **Kommunikationsmuster:**

      * Fehler werden intern in der Systemschicht mit diesem Enum behandelt und an höhere Schichten weitergegeben.

  * **Erwartete Ergebnisse/Outputs:**

      * Eine zentralisierte und konsistente Fehlerbehandlung für die gesamte Systemschicht.
      * Klare Abgrenzung von Fehlertypen.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * Testen der Fehlererzeugung für jede Variante.
          * Testen der `From`-Implementierungen für `zbus::Error` und `std::io::Error`.
          * Testen der Konvertierung zu `CoreError` und `DomainError`.
          * Überprüfen der Fehlermeldungen und Fehlerketten (`source()`).

  * **Geschätzter Aufwand:** 2 Tage

#### 2.3.3. `novade-system/src/events.rs`

  * **Verantwortlichkeit:** Definiert und verwaltet systemweite Ereignisse, die von verschiedenen Systemkomponenten ausgelöst und von anderen Komponenten (Domäne, UI) abonniert werden können.

  * **Kern-Aufgaben (Tasks):**

    1.  **`SystemEvent` Enum:**
          * Definiere eine zentrale Enum `SystemEvent` mit Varianten für alle wichtigen Systemereignisse:
              * `WindowCreated(novade_domain::window_policy::data_types::WindowIdentifier, novade_core::types::geometry::Rectangle<i32>)`
              * `WindowDestroyed(novade_domain::window_policy::data_types::WindowIdentifier)`
              * `WindowMoved(novade_domain::window_policy::data_types::WindowIdentifier, novade_core::types::geometry::Rectangle<i32>)`
              * `WindowResized(novade_domain::window_policy::data_types::WindowIdentifier, novade_core::types::geometry::Rectangle<i32>)`
              * `WindowMinimized(novade_domain::window_policy::data_types::WindowIdentifier)`
              * `WindowMaximized(novade_domain::window_policy::data_types::WindowIdentifier)`
              * `WindowFullscreened(novade_domain::window_policy::data_types::WindowIdentifier)`
              * `WindowActivated(novade_domain::window_policy::data_types::WindowIdentifier)`
              * `ActiveSeatChanged(String)`
              * `InputDeviceAdded(String, novade_core::types::input::InputDeviceType)`
              * `InputDeviceRemoved(String)`
              * `KeyboardLayoutChanged(String)`
              * `PowerStateRequested(novade_domain::power_management::data_types::PowerState)`
              * `BatteryInfoUpdated(novade_domain::power_management::data_types::BatteryInfo)`
              * `LidStateUpdated(novade_domain::power_management::data_types::LidState)`
              * `AudioVolumeChanged(f32)`
              * `AudioMuteToggled(bool)`
              * `MicrophoneVolumeChanged(f32)`
              * `MicrophoneMuteToggled(bool)`
              * `NotificationDisplayed(String)` (für externe Benachrichtigungen, die NovaDE verarbeitet)
              * `PortalRequest(novade_system::portals::PortalRequest)` (generische Anfragen an Portale)
              * `DesktopStateUpdated` (generischer Hinweis auf eine Änderung im `DesktopState`)
              * `CompositorReady`
              * `CompositorStopped`
          * Implementiere `Clone`, `Debug` und `PartialEq` für `SystemEvent`.
    2.  **`SystemEventSender` und `SystemEventReceiver`:**
          * Definiere Typ-Aliase für `tokio::sync::broadcast::Sender<SystemEvent>` und `tokio::sync::broadcast::Receiver<SystemEvent>`.
    3.  **`EventBus` Struktur:**
          * Definiere eine `EventBus` Struktur, die einen `tokio::sync::broadcast::Sender<SystemEvent>` hält.
          * Implementiere eine `new()` Funktion, die den Sender initialisiert.
          * Implementiere eine `publish(event: SystemEvent)` Methode, die ein Ereignis sendet.
          * Implementiere eine `subscribe(&self) -> SystemEventReceiver` Methode, die einen neuen Receiver zurückgibt.

  * **Spezifische Artefakte/Dateien:**

      * `novade-system/src/events.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-domain::window_policy::data_types`, `novade_domain::power_management::data_types`, `novade_core::types::geometry`, `novade_core::types::input`, `novade_system::portals::PortalRequest`.
      * **Extern:** `tokio::sync::broadcast`.

  * **Kommunikationsmuster:**

      * Zentrale Event-Drehscheibe für die Systemschicht.
      * Komponenten der Systemschicht publizieren relevante `SystemEvent`s.
      * Domänen- und UI-Schicht abonnieren diese Events, um auf Systemzustandsänderungen zu reagieren.

  * **Erwartete Ergebnisse/Outputs:**

      * Ein robuster, asynchroner Event-Bus für systemweite Kommunikation.
      * Stark typisierte Ereignisse, die eine klare Schnittstelle bieten.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * Testen der `publish` und `subscribe` Mechanismen: Sicherstellen, dass publizierte Events von allen abonnierenden Receivern empfangen werden.
          * Testen der Event-Typen und ihrer Datenstrukturen.
          * Testen von Szenarien mit mehreren Sendern und Receivern.
          * Testen des Verhaltens bei Überlauf des Kanals (falls Buffer begrenzt ist).

  * **Geschätzter Aufwand:** 2 Tage

#### 2.3.4. `novade-system/src/desktop_state.rs`

  * **Verantwortlichkeit:** Verwaltet den gesamten zentralen Zustand des Desktops aus Sicht der Systemschicht, einschließlich Compositor-spezifischer Daten, Input-Geräte, aktueller Fenstereigenschaften und Workspace-Zustände. Dieser Zustand ist `Arc<RwLock<DesktopState>>`-geschützt und wird von allen Systemkomponenten verwendet, die direkten Zugriff auf den globalen Zustand benötigen.

  * **Kern-Aufgaben (Tasks):**

    1.  **`DesktopState` Struktur:**

          * Definiere die Struktur `DesktopState` mit folgenden Feldern:
              * `display_handle: smithay::reexports::wayland_server::DisplayHandle`: Der Wayland-Display-Handle.
              * `compositor_state: smithay::wayland::compositor::CompositorState`: Smithay-Compositor-State.
              * `shell_state: smithay::wayland::shell::xdg::XdgShellState`: Smithay XDG-Shell-State.
              * `seat_state: smithay::input::SeatState`: Smithay Seat-State (für Eingabegeräte).
              * `shm_state: smithay::wayland::shm::ShmState`: Smithay SHM-State (für Shared Memory Buffer).
              * `output_manager_state: smithay::wayland::output::OutputManagerState`: Smithay Output-Manager-State.
              * `dmabuf_state: smithay::wayland::dmabuf::DmabufState`: Smithay DMABuf-State.
              * `xdg_decoration_state: smithay::wayland::shell::xdg::XdgDecorationState`: Smithay XDG-Decoration-State.
              * `layer_shell_state: smithay::wayland::shell::wlr_layer_shell::WlrLayerShellState`: Smithay Layer-Shell-State.
              * `pointer_grab_state: smithay::input::pointer::PointerGrabState`: Smithay Pointer-Grab-State.
              * `keyboard_grab_state: smithay::input::keyboard::KeyboardGrabState`: Smithay Keyboard-Grab-State.
              * `touch_grab_state: smithay::input::touch::TouchGrabState`: Smithay Touch-Grab-State.
              * `window_map: HashMap<smithay::utils::Serial, novade_domain::window_policy::data_types::WindowAttributes>`: Eine HashMap, die Smithay-Serials zu den domänenspezifischen `WindowAttributes` abbildet.
              * `active_seat: smithay::input::Seat`: Der aktuell aktive Seat.
              * `keyboard: Option<smithay::input::keyboard::KeyboardHandle>`: Handle zum Keyboard-Zustand.
              * `pointer: Option<smithay::input::pointer::PointerHandle>`: Handle zum Pointer-Zustand.
              * `primary_xdg_output: smithay::reexports::wayland_server::protocol::wl_output::WlOutput`: Der primäre Output für neue Fenster.
              * `current_workspaces: Arc<RwLock<Vec<novade_domain::window_policy::data_types::Workspace>>>`: Referenz zu den Workspaces aus der Domänen-Schicht, um Konsistenz zu gewährleisten.
              * `active_workspace_id: Uuid`: Die ID des aktuell aktiven Workspaces.
              * `dom_window_policy_service: Arc<dyn novade_domain::window_policy::WindowPolicyServiceAsync + Send + Sync>`: Schnittstelle zum Domänen-Fensterpolitikdienst.
              * `dom_global_settings_service: Arc<dyn novade_domain::settings_service::GlobalSettingsService + Send + Sync>`: Schnittstelle zum Domänen-GlobalSettingsService.
              * `event_bus: Arc<novade_system::events::EventBus>`: Referenz zum systemweiten Event-Bus.
              * `renderer: Option<smithay::backend::renderer::gles2::Gles2Renderer>`: Der OpenGL ES 2 Renderer von Smithay.
              * `backend_data: Option<smithay::backend::egl::EGLBackend>`: Backend-spezifische Daten (z.B. EGL-Kontext).
              * `current_output: smithay::output::Output`: Die aktuelle Ausgabe.
              * `allocator: smithay::wayland::shm::Allocator<smithay::backend::allocator::BufferAllocator>`: Buffer Allocator.
              * `primary_gpu_device: Option<GpuDevice>`: Das primäre GPU-Gerät, falls relevant für Backend-Initialisierung.
              * `primary_output_info: Option<OutputInfo>`: Informationen über den primären Monitor.
              * `input_handler_handle: smithay::input::pointer::CursorImageStatusWrapper`: Handle für die Mauszeiger-Darstellung.
              * `seat_name: String`: Name des Seats (z.B. "seat0").
              * `current_scale: i32`: Aktueller Skalierungsfaktor.
              * `cursor_location: novade_core::types::geometry::Point<f64>`: Aktuelle Position des Mauszeigers.
              * `dnd_state: smithay::wayland::data_device::DnDState`: Drag-and-Drop Zustand.
              * `primary_selection_state: smithay::wayland::primary_selection::PrimarySelectionState`: Primäre Auswahl (X11).
              * `data_device_state: smithay::wayland::data_device::DataDeviceState`: Data Device Zustand.
              * `output_map: HashMap<smithay::output::Output, novade_core::types::geometry::Rectangle<i32>>`: Map der Outputs zu ihren Positionen/Geometrien.
              * `logger: tracing::Logger`: Logger-Instanz für den Desktop-State.
              * `loop_handle: tokio::runtime::Handle`: Tokio Runtime Handle.
              * `keyboard_manager: novade_system::input::keyboard::KeyboardManager`: Instanz des Keyboard Managers.
              * `pointer_manager: novade_system::input::pointer::PointerManager`: Instanz des Pointer Managers.
              * `touch_manager: novade_system::input::touch::TouchManager`: Instanz des Touch Managers.
              * `power_management_control: Arc<dyn PowerManagementControl + Send + Sync>`: Trait zur Steuerung der System-Power-Events.
              * `system_metrics_provider: Arc<dyn SystemMetricsProvider + Send + Sync>`: Trait zum Abfragen von System-Metriken.

    2.  **`new()` Funktion:**

          * Implementiere eine `new()`-Funktion, die `DesktopState` mit den notwendigen Initialisierungsparametern (z.B. `DisplayHandle`, `Logger`, `Arc<dyn WindowPolicyServiceAsync>`, `Arc<dyn GlobalSettingsService>`) erzeugt.
          * Initialisiere alle Smithay-States.

    3.  **Hilfsfunktionen:**

          * `fn map_window(&mut self, surface: &smithay::wayland::shell::xdg::XdgSurface, attributes: novade_domain::window_policy::data_types::WindowAttributes)`: Fügt ein neues Fenster zur `window_map` hinzu.
          * `fn unmap_window(&mut self, surface: &smithay::wayland::shell::xdg::XdgSurface)`: Entfernt ein Fenster aus der `window_map`.
          * `fn window_by_surface_id(&self, surface_id: smithay::utils::Serial) -> Option<&novade_domain::window_policy::data_types::WindowAttributes>`: Sucht ein Fenster nach seiner Serial ID.
          * `fn window_by_surface_id_mut(&mut self, surface_id: smithay::utils::Serial) -> Option<&mut novade_domain::window_policy::data_types::WindowAttributes>`: Sucht ein Fenster nach seiner Serial ID (mutierbar).
          * `fn update_window_attributes(&mut self, window_id: novade_domain::window_policy::data_types::WindowIdentifier, attributes: novade_domain::window_policy::data_types::WindowAttributes)`: Aktualisiert die Attribute eines Fensters.
          * `fn get_window_at(&self, point: novade_core::types::geometry::Point<f64>) -> Option<(novade_domain::window_policy::data_types::WindowIdentifier, novade_core::types::geometry::Rectangle<i32>)>`: Gibt das Fenster an einer bestimmten Koordinate zurück.
          * `fn activate_window(&mut self, window_id: novade_domain::window_policy::data_types::WindowIdentifier)`: Setzt das angegebene Fenster auf aktiv.
          * `fn set_active_workspace(&mut self, workspace_id: Uuid)`: Setzt den aktiven Workspace.
          * `fn get_active_workspace_geometry(&self) -> novade_core::types::geometry::Rectangle<i32>`: Gibt die Geometrie des aktiven Workspaces (Bildschirmbereich) zurück.
          * `fn get_all_outputs(&self) -> Vec<smithay::output::Output>`: Gibt eine Liste aller Outputs zurück.
          * Implementiere die Traits `PowerManagementControl` und `SystemMetricsProvider` für `DesktopState` (oder eine Hilfsstruktur), die die tatsächliche Systeminteraktion delegieren (an D-Bus-Clients, `libinput`-Backends etc.).

  * **Spezifische Artefakte/Dateien:**

      * `novade-system/src/desktop_state.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-core::types::geometry`, `novade_core::types::input`, `novade_domain::window_policy::data_types`, `novade_domain::power_management::data_types`, `novade_system::events::EventBus`, `novade_system::input::keyboard::KeyboardManager`, `novade_system::input::pointer::PointerManager`, `novade_system::input::touch::TouchManager`, `novade_system::power_management::PowerManagementControl`, `novade_system::metrics::SystemMetricsProvider`.
      * **Extern:** `smithay`, `tokio::sync::RwLock`, `parking_lot::Mutex`, `std::collections::HashMap`, `uuid`, `tracing`.

  * **Kommunikationsmuster:**

      * `DesktopState` wird als `Arc<RwLock<DesktopState>>` an alle System-Services übergeben, die mit dem Desktop-Zustand interagieren müssen (Compositor, Input, Window Mechanics).
      * Die Domänenschicht (`WindowPolicyService`, `PowerManagementService`, `SystemMonitorService`) erhält Zugriff auf die `DesktopState` über die `SystemServices` Struktur und kann bestimmte Aspekte des Zustands über die definierten Schnittstellen (`PowerManagementControl`, `SystemMetricsProvider`) manipulieren oder abfragen.
      * Änderungen am `DesktopState` sollen ggf. `SystemEvent`s über den `event_bus` publizieren.

  * **Erwartete Ergebnisse/Outputs:**

      * Eine zentrale, thread-sichere Repräsentation des aktuellen Desktop-Zustands.
      * Einheitlicher Zugriffspunkt für alle Systemkomponenten auf den Desktop-Zustand.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * Testen der `new()` Funktion für die korrekte Initialisierung aller Smithay-States.
          * Testen der Hilfsfunktionen (`map_window`, `unmap_window`, `window_by_surface_id`, `update_window_attributes`, `get_window_at`, `activate_window`, `set_active_workspace`, `get_active_workspace_geometry`).
          * Testen der korrekten Nutzung des `RwLock` für Lese- und Schreibzugriffe.
          * Sicherstellen, dass `DesktopState` die Schnittstellen `PowerManagementControl` und `SystemMetricsProvider` korrekt implementiert oder delegiert.

  * **Geschätzter Aufwand:** 7-10 Tage (inklusive Einarbeitung Smithay States)

#### 2.3.5. `novade-system/src/compositor`

  * **Verantwortlichkeit:** Dies ist das Herzstück der Systemschicht. Es implementiert den Wayland-Compositor unter Verwendung von Smithay, verwaltet Fenster (XDG-Shell, Layer-Shell), führt das Rendering durch und steuert den Fenster-Lebenszyklus.

  * **Kern-Aufgaben (Tasks):**

    1.  **`core.rs` (Compositor Core Logic):**

          * **`CompositorService` Struktur:**
              * Definiere die Struktur `CompositorService` mit einer `Arc<RwLock<DesktopState>>` Referenz.
              * Zusätzliche Felder für Compositor-spezifische Handles (z.B. `EventBusSender`, `OutputManager`).
          * **`new()` Funktion:**
              * Der Konstruktor nimmt `Arc<RwLock<DesktopState>>`, `Arc<novade_system::events::EventBus>`, und `tokio::runtime::Handle` entgegen.
              * Initialisiert den `smithay::backend::renderer::gles2::Gles2Renderer` (falls noch nicht im `DesktopState` geschehen).
              * Registriert Smithay-Event-Handler für XDG-Shell, Layer-Shell, Output, Data Device, etc.
              * Registriert den Wayland-Listener (`WlCompositor`, `WlShm`, `XdgWmBase`, etc.) und fügt sie zum `display_handle` hinzu.
              * Setzt den Renderer im `DesktopState`.
          * **`run_compositor_loop()` Funktion:**
              * Eine `async fn` die den Haupt-Compositor-Loop ausführt.
              * Nutzt `smithay::backend::x11::X11Backend` oder `smithay::backend::drm::DrmBackend` für die Backend-Integration, abhängig von der Initialisierung.
              * Verarbeitet `smithay::backend::session::Session` Events.
              * Führt das Rendering der Szene durch (mithilfe des `Gles2Renderer`).
              * Ruft `smithay::output::Output::render()` auf.
              * Handhabt die Frame-Callbacks.
              * Implementiert das Event-Looping und die Dispatching-Logik für Wayland-Clients.
              * Achtung: Der Compositor-Loop muss im Kontext der Tokio-Runtime ausgeführt werden, aber Smithay selbst kann eigene Event-Loops haben, die in Tokio-Tasks integriert werden müssen.
              * Ruft den `dom_window_policy_service.handle_new_window()` auf, wenn ein neues XDG-Shell-Fenster erstellt wird, um die initialen Attribute vom Domänen-Service zu erhalten.
              * Publiziert `SystemEvent::WindowCreated`, `WindowDestroyed`, `WindowMoved`, `WindowResized`, `WindowMaximized`, `WindowFullscreened`, `WindowMinimized`, `WindowActivated` etc. an den `EventBus`.

    2.  **`xdg_shell.rs` (XDG-Shell Protokoll Handler):**

          * Implementiere den `XdgShellHandler` Trait für die `DesktopState` (oder eine Wrapper-Struktur, die Zugriff auf `DesktopState` hat).
          * Handle `configure` Events: Fenstern neue Größen vorschlagen.
          * Handle `ack_configure` Events: Bestätigung der Clients verarbeiten.
          * Handle `new_toplevel` Events: Neue Top-Level-Fenster registrieren.
          * Handle `new_popup` Events: Popups verwalten.
          * Interagiere mit `DesktopState` um die `WindowAttributes` zu aktualisieren.
          * Sende `SystemEvent::WindowCreated` oder `SystemEvent::WindowDestroyed` wenn Fenster gemappt/unmapped werden.

    3.  **`layer_shell.rs` (WLR-Layer-Shell Protokoll Handler):**

          * Implementiere den `WlrLayerShellHandler` Trait für die `DesktopState`.
          * Handle `new_layer_surface` Events: Neue Layer-Shell-Fenster registrieren (Panels, Docks, Desktops).
          * Verwalte die Positionierung und Größe von Layer-Shell-Fenstern basierend auf den `LayerSurface` Konfigurationen.
          * Implementiere die `WlrLayerShell` Protokoll-Spezifikation.
          * Sende `SystemEvent::WindowCreated` für Layer-Shell-Fenster.

    4.  **`output.rs` (Output Management):**

          * Implementiere den `OutputHandler` Trait für die `DesktopState`.
          * Handle `output_created` Events: Neue Monitore erkennen und registrieren.
          * Handle `output_destroyed` Events: Entfernte Monitore verarbeiten.
          * Setze `Output` Eigenschaften (Modus, Skalierung) basierend auf `GlobalSettingsService`.
          * Füge `WlOutput` Globals zum Display hinzu.
          * Aktualisiere die `output_map` im `DesktopState`.

    5.  **`seat.rs` (Seat Management):**

          * Implementiere den `SeatHandler` Trait für die `DesktopState`.
          * Handle `new_seat` Events: Neue Seats erstellen.
          * Verwalte Eingabegeräte für den Seat (`add_keyboard`, `add_pointer`, `add_touch`).
          * Publiziere `SystemEvent::ActiveSeatChanged` wenn der aktive Seat wechselt.

    6.  **`backend.rs` (Backend-Integration):**

          * Dieses Modul kapselt die Initialisierung des Smithay-Backends (DRM, X11, Wayland nested).
          * Funktion `init_backend()`:
              * Wählt das passende Backend basierend auf Umgebungsvariablen oder Konfiguration.
              * Initialisiert das `smithay::backend::egl::EGLBackend`.
              * Initialisiert den `smithay::backend::renderer::gles2::Gles2Renderer`.
              * Gibt das Backend und den Renderer zurück, um sie im `DesktopState` zu speichern.
              * Die Initialisierung des `Gles2Renderer` sollte im `DesktopState::new()` oder einer übergeordneten Initialisierungsfunktion erfolgen, um den Lebenszyklus des Renderers zu kontrollieren.

    7.  **`render.rs` (Rendering Logic):**

          * Bietet Helferfunktionen zum Rendern der Szene:
              * `render_surface_tree(renderer, surface_tree, ...)`: Rekursive Rendering-Funktion für die Fenster-Hierarchie.
              * `render_output(output, renderer, desktop_state)`: Rendert einen einzelnen Output.
              * Berücksichtigt die verschiedenen `WallpaperMode`s aus der Domänenschicht.
              * Kümmert sich um die Transformationen (Skalierung, Positionierung).

    8.  **`xwayland.rs` (XWayland Integration):**

          * Implementiert die `XWaylandHandler` Trait für `DesktopState`.
          * Handle `new_xwayland_surface` Events.
          * Verwalte die XWayland-Oberflächen und deren Interaktion mit dem Compositor.
          * Kümmert sich um die XWM-Konfiguration.

    9.  **`data_device.rs` (Data Device & DnD):**

          * Implementiert den `DataDeviceHandler` Trait für `DesktopState`.
          * Handle Drag-and-Drop (`DnD`) und Clipboard-Operationen.
          * Interagiert mit `smithay::wayland::data_device`.

    10. **`mod.rs`:**

          * Re-exportiere alle relevanten Module und Strukturen.

  * **Spezifische Artefakte/Dateien:**

      * `novade-system/src/compositor/core.rs`
      * `novade-system/src/compositor/xdg_shell.rs`
      * `novade-system/src/compositor/layer_shell.rs`
      * `novade-system/src/compositor/output.rs`
      * `novade-system/src/compositor/seat.rs`
      * `novade-system/src/compositor/backend.rs`
      * `novade-system/src/compositor/render.rs`
      * `novade-system/src/compositor/xwayland.rs`
      * `novade-system/src/compositor/data_device.rs`
      * `novade-system/src/compositor/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-system::error::SystemError`, `novade-system::events::EventBus`, `novade-system::desktop_state::DesktopState`, `novade-domain::window_policy::data_types`, `novade_domain::window_policy::WindowPolicyServiceAsync`, `novade_domain::settings_service::GlobalSettingsService`.
      * **Extern:** `smithay`, `tokio`, `tracing`, `wayland-server`, `wayland-protocols`, `image` (für Wallpaper-Rendering).

  * **Kommunikationsmuster:**

      * Hält `Arc<RwLock<DesktopState>>` um den globalen Zustand zu lesen und zu aktualisieren.
      * Publiziert `SystemEvent`s an den `EventBus` bei Fenster- und Output-Änderungen.
      * Ruft Methoden auf `WindowPolicyServiceAsync` auf, um domänenspezifische Entscheidungen zu Fenster-Attributen zu erhalten.
      * Ruft `SystemImageProcessor` in der Systemschicht für Bildverarbeitung auf (falls ausgelagert).

  * **Erwartete Ergebnisse/Outputs:**

      * Ein voll funktionsfähiger Wayland-Compositor, der Fenster darstellt und verwaltet.
      * Implementierung der XDG-Shell und Layer-Shell Protokolle.
      * Reaktives Rendering basierend auf Fenster- und Output-Änderungen.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * Testen der Smithay-Handler-Implementierungen (z.B. XDG-Shell `new_toplevel` muss `DesktopState` aktualisieren).
          * Testen der Rendering-Funktionen mit simulierten Szenen.
          * Testen der `handle_new_window` Interaktion mit dem Domänen-Service.
          * Testen des Event-Bus-Verhaltens bei Fenster-Ereignissen.
      * **Integration Tests (Schwierig, erfordert Test-Harness):**
          * Starten eines Compositors in einer virtuellen Umgebung (z.B. `libxwayland` oder `Xwayland` für Tests).
          * Starten von Wayland-Clients und Überprüfen des Fensterverhaltens (Erstellung, Verschieben, Größe ändern, minimieren/maximieren).
          * Screenshot-Vergleiche, um Rendering-Korrektheit zu überprüfen.
          * Testen der Layer-Shell-Integration (Panel-Anzeige).

  * **Geschätzter Aufwand:** 30-40 Tage (Dies ist das aufwendigste Modul)

#### 2.3.6. `novade-system/src/input`

  * **Verantwortlichkeit:** Verwaltet die gesamte Eingabeverarbeitung, einschließlich Tastatur, Maus, Touch und Gesten. Integriert `libinput` und `xkbcommon` für robuste Eingabe.

  * **Kern-Aufgaben (Tasks):**

    1.  **`input_service_iface.rs`:**

          * Definiere den Trait `InputServiceAsync`:
              * `async fn get_connected_devices(&self) -> Result<Vec<(String, novade_core::types::input::InputDeviceType)>, SystemError>`: Liefert eine Liste aller verbundenen Eingabegeräte.
              * `async fn set_keyboard_layout(&self, layout: String) -> Result<(), SystemError>`: Setzt das Tastaturlayout.
              * `async fn get_current_keyboard_layout(&self) -> Result<String, SystemError>`: Ruft das aktuelle Tastaturlayout ab.
              * `async fn set_pointer_acceleration(&self, factor: f64) -> Result<(), SystemError>`: Setzt die Zeigerbeschleunigung.
              * `async fn set_tap_to_click(&self, enabled: bool) -> Result<(), SystemError>`: Aktiviert/Deaktiviert Tap-to-Click.
              * `fn subscribe_to_device_changes(&self) -> tokio::sync::broadcast::Receiver<(String, novade_core::types::input::InputDeviceType)>`: Liefert einen Receiver für Gerät-Hinzufügungs/-Entfernungs-Events.
              * `fn subscribe_to_keyboard_events(&self) -> tokio::sync::broadcast::Receiver<novade_core::types::input::KeyboardEvent>`: Liefert einen Receiver für Tastaturereignisse.
              * `fn subscribe_to_pointer_events(&self) -> tokio::sync::broadcast::Receiver<novade_core::types::input::PointerEvent>`: Liefert einen Receiver für Zeigerereignisse.
              * `fn subscribe_to_touch_events(&self) -> tokio::sync::broadcast::Receiver<novade_core::types::input::TouchEvent>`: Liefert einen Receiver für Touch-Ereignisse.
              * `fn subscribe_to_gesture_events(&self) -> tokio::sync::broadcast::Receiver<novade_core::types::input::GestureEvent>`: Liefert einen Receiver für Gesten-Ereignisse.

    2.  **`service.rs` (Input Service Implementation):**

          * Implementiere die Struktur `DefaultInputService` für den `InputServiceAsync` Trait.
          * Der Konstruktor nimmt `Arc<RwLock<DesktopState>>`, `Arc<novade_system::events::EventBus>`, und `Arc<dyn novade_domain::settings_service::GlobalSettingsService + Send + Sync>` entgegen.
          * Verwalte interne `tokio::sync::broadcast::Sender` für die verschiedenen Event-Typen.
          * Nutzt `DesktopState::seat_state` und `DesktopState::keyboard`, `DesktopState::pointer`, `DesktopState::touch` Handles.
          * **`InputService` Haupt-Loop:**
              * Starte einen `tokio::spawn` Task, der `libinput` Ereignisse asynchron liest.
              * Verwendet `libinput` zum Enumerieren und Öffnen von Eingabegeräten.
              * Verarbeitet `libinput` Events: `DeviceAdded`, `DeviceRemoved`, `KeyboardEvent`, `PointerEvent`, `TouchEvent`, `GestureEvent`.
              * Übersetzt `libinput` Events in die domänenspezifischen `novade_core::types::input` Events.
              * Publiziert die übersetzten Events über die entsprechenden `broadcast::Sender` und an den `SystemEventBus`.
              * Interagiert mit `xkbcommon` für Tastaturzustand und Layout.
              * Bei `DeviceAdded` / `DeviceRemoved` Ereignissen, publiziere `SystemEvent::InputDeviceAdded` / `InputDeviceRemoved`.

    3.  **`keyboard.rs` (Keyboard Management):**

          * Definiere `KeyboardManager` Struktur.
          * Verwaltet den `xkbcommon::xkb::Context` und `xkbcommon::xkb::Keymap`.
          * Implementiere Funktionen zum Setzen und Abfragen des Tastaturlayouts.
          * Verarbeitet rohe Tastatur-Events von `libinput` und konvertiert sie in `novade_core::types::input::KeyboardEvent` (mit Modifikatoren, Keycode, Symbol).
          * Aktualisiert den `DesktopState::keyboard` Handle.
          * Kann auch Tastenkombinationen für globale Hotkeys verwalten (dies könnte auch ein separater Domänen-Service sein, der KeyboardEvents abonniert).
          * Publiziere `SystemEvent::KeyboardLayoutChanged`.

    4.  **`pointer.rs` (Pointer Management):**

          * Definiere `PointerManager` Struktur.
          * Verarbeitet rohe Zeiger-Events von `libinput` und konvertiert sie in `novade_core::types::input::PointerEvent` (Bewegung, Button-Klicks, Scrollen).
          * Kümmert sich um Zeigerbeschleunigung und Empfindlichkeit.
          * Aktualisiert den `DesktopState::pointer` Handle und `DesktopState::cursor_location`.
          * Interagiert mit `DesktopState::input_handler_handle` für die Cursor-Darstellung.

    5.  **`touch.rs` (Touch Management):**

          * Definiere `TouchManager` Struktur.
          * Verarbeitet rohe Touch-Events von `libinput` und konvertiert sie in `novade_core::types::input::TouchEvent` (Touch down, up, move, cancel).
          * Verfolgt die einzelnen Touchpunkte.

    6.  **`gestures.rs` (Gesture Recognition):**

          * Definiere `GestureManager` Struktur.
          * Verarbeitet eine Sequenz von Touch- oder Pointer-Events, um Gesten zu erkennen (z.B. Pinch-to-zoom, Multi-finger swipe, rotate).
          * Publiziert `novade_core::types::input::GestureEvent`.
          * Dies kann anspruchsvoll sein und könnte in einer späteren Phase detaillierter werden. Beginne mit einfachen Gesten wie 2-Finger-Scrollen.

    7.  **`mod.rs`:**

          * Re-exportiere alle relevanten Module und Strukturen.

  * **Spezifische Artefakte/Dateien:**

      * `novade-system/src/input/input_service_iface.rs`
      * `novade-system/src/input/service.rs`
      * `novade-system/src/input/keyboard.rs`
      * `novade-system/src/input/pointer.rs`
      * `novade-system/src/input/touch.rs`
      * `novade-system/src/input/gestures.rs`
      * `novade-system/src/input/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-system::error::SystemError`, `novade-system::events::EventBus`, `novade_system::desktop_state::DesktopState`, `novade-core::types::input`, `novade_domain::settings_service::GlobalSettingsService`.
      * **Extern:** `libinput`, `xkbcommon`, `tokio`, `tracing`.

  * **Kommunikationsmuster:**

      * Der `DefaultInputService` startet einen dedizierten Thread/Task für `libinput` Polling.
      * Publiziert `SystemEvent`s für Gerät-Änderungen und spezifische Eingabe-Events für die Domänen- und UI-Schicht.
      * Liest Eingabe-Einstellungen aus `GlobalSettingsService`.
      * Manipuliert `DesktopState` für Mauszeiger-Position und Tastatur-Zustand.

  * **Erwartete Ergebnisse/Outputs:**

      * Eine robuste und reaktionsschnelle Eingabeverarbeitung für alle Gerätetypen.
      * Korrekte Konvertierung von rohen Eingabeereignissen in abstraktere, domänenfreundliche Events.
      * Unterstützung für Tastaturlayouts, Mausbeschleunigung und grundlegende Gesten.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * Mocken von `libinput` Events und Testen der korrekten Umwandlung in `novade_core::types::input` Events.
          * Testen der Tastaturlayout-Funktionalität mit `xkbcommon` Mocking.
          * Testen der Zeigerbeschleunigung und Tap-to-Click Logik.
          * Testen des Event-Bus-Verhaltens bei Eingabe-Ereignissen.
      * **Integration Tests (Schwierig, erfordert Test-Harness):**
          * Einsatz von Tools zur Simulation von Eingabegeräten (z.B. `uinput` oder `evdev` Simulation).
          * Automatisierte Tests, die Tastendrücke, Mausbewegungen und Touch-Eingaben simulieren und überprüfen, ob die System Events korrekt generiert werden und der Compositor angemessen reagiert.

  * **Geschätzter Aufwand:** 12-18 Tage

#### 2.3.7. `novade-system/src/dbus_interfaces`

  * **Verantwortlichkeit:** Implementiert D-Bus-Clients für die Kommunikation mit externen Systemdiensten (NetworkManager, UPower, logind, Secret Service, PolicyKit) und stellt D-Bus-Server für NovaDE-spezifische Dienste (z.B. `org.freedesktop.Notifications`) bereit.

  * **Kern-Aufgaben (Tasks):**

    1.  **`dbus_client_iface.rs`:**

          * Definiere den Trait `DbusClientServiceAsync`:
              * `async fn get_network_status(&self) -> Result<novade_domain::network::NetworkStatus, SystemError>`: Status des Netzwerks.
              * `async fn connect_to_wifi(&self, ssid: String, password: Option<String>) -> Result<(), SystemError>`: Verbindet sich mit WLAN.
              * `async fn get_power_info(&self) -> Result<novade_domain::power_management::data_types::BatteryInfo, SystemError>`: Informationen zur Batterie.
              * `async fn suspend(&self) -> Result<(), SystemError>`: System suspendieren.
              * `async fn shutdown(&self) -> Result<(), SystemError>`: System herunterfahren.
              * `async fn authenticate_with_policykit(&self, action_id: String) -> Result<(), SystemError>`: Authentifiziert eine Aktion mit PolicyKit.
              * `async fn get_secret(&self, collection: String, key: String) -> Result<String, SystemError>`: Ruft ein Geheimnis ab.
              * `async fn store_secret(&self, collection: String, key: String, secret: String) -> Result<(), SystemError>`: Speichert ein Geheimnis.
              * `fn subscribe_to_network_changes(&self) -> tokio::sync::broadcast::Receiver<novade_domain::network::NetworkStatus>`: Netzwerk-Änderungen.
              * `fn subscribe_to_power_changes(&self) -> tokio::sync::broadcast::Receiver<novade_domain::power_management::data_types::BatteryInfo>`: Power-Änderungen.
              * `fn subscribe_to_notification_requests(&self) -> tokio::sync::broadcast::Receiver<novade_domain::notification_service::IncomingNotification>`: Eingehende externe Benachrichtigungen.

    2.  **`service.rs` (DbusClientService Implementation):**

          * Implementiere die Struktur `DefaultDbusClientService` für den `DbusClientServiceAsync` Trait.
          * Der Konstruktor nimmt `Arc<novade_system::events::EventBus>` entgegen.
          * Verwende `zbus::Connection::session()` oder `zbus::Connection::system()` für die D-Bus-Verbindungen.
          * Verwalte interne `zbus::Proxy` Instanzen für die verschiedenen D-Bus-Dienste.
          * Verwalte `tokio::sync::broadcast::Sender` für die Events.
          * **Implementierung der Client-Methoden:**
              * `get_network_status()`, `connect_to_wifi()`: Interagiere mit `NetworkManager` D-Bus-API.
              * `get_power_info()`, `suspend()`, `shutdown()`: Interagiere mit `UPower` und `logind` D-Bus-APIs.
              * `authenticate_with_policykit()`: Interagiere mit `PolicyKit` D-Bus-API.
              * `get_secret()`, `store_secret()`: Interagiere mit `Freedesktop Secret Service` D-Bus-API.
          * **Hintergrund-Tasks für Signal-Monitoring:**
              * Starte separate `tokio::spawn` Tasks, um D-Bus-Signale von `NetworkManager`, `UPower`, `logind` zu abonnieren.
              * Bei Empfang eines Signals, übersetze es in das entsprechende domänenspezifische Event und publiziere es über den `broadcast::Sender` und den `SystemEventBus`.

    3.  **`notifications_server.rs` (Freedesktop Notifications Server):**

          * Implementiere den `org.freedesktop.Notifications` D-Bus-Server unter Verwendung von `zbus`.
          * Implementiere die D-Bus-Methoden: `GetCapabilities`, `GetServerInformation`, `Notify`, `CloseNotification`.
          * Der `Notify` Call sollte die eingehende Benachrichtigung in eine `novade_domain::notification_service::IncomingNotification` Struktur konvertieren.
          * Diese konvertierte Benachrichtigung sollte an einen `tokio::sync::broadcast::Sender` gesendet werden, der von der Domänenschicht (`NotificationService`) abonniert wird.
          * Die `run_notifications_server()` Funktion sollte einen `Arc<dyn novade_domain::notification_service::NotificationServiceAsync + Send + Sync>` oder einen `tokio::sync::broadcast::Sender<novade_domain::notification_service::IncomingNotification>` erhalten, um die Benachrichtigungen an die Domänenschicht weiterzuleiten.
          * Fehlerbehandlung für D-Bus-Kommunikation und ungültige Benachrichtigungen.

    4.  **`mod.rs`:**

          * Re-exportiere alle relevanten Module und Strukturen.

  * **Spezifische Artefakte/Dateien:**

      * `novade-system/src/dbus_interfaces/dbus_client_iface.rs`
      * `novade-system/src/dbus_interfaces/service.rs`
      * `novade-system/src/dbus_interfaces/notifications_server.rs`
      * `novade-system/src/dbus_interfaces/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-system::error::SystemError`, `novade-system::events::EventBus`, `novade_domain::network::NetworkStatus`, `novade_domain::power_management::data_types::{BatteryInfo, PowerState}`, `novade_domain::notification_service::IncomingNotification`, `novade_domain::notification_service::NotificationServiceAsync`.
      * **Extern:** `zbus`, `tokio`, `tracing`, `async-trait`.

  * **Kommunikationsmuster:**

      * `DefaultDbusClientService` agiert als Bridge zwischen Domänen-Services und externen D-Bus-Diensten.
      * `notifications_server` empfängt D-Bus-Nachrichten von externen Apps und leitet sie an den Domänen-`NotificationService` weiter.
      * Publiziert D-Bus-Signals als `SystemEvent`s an den `EventBus`.

  * **Erwartete Ergebnisse/Outputs:**

      * Nahtlose Integration mit wichtigen Systemdiensten über D-Bus.
      * Fähigkeit, Systemzustände abzufragen und Aktionen auszulösen.
      * Empfang und Weiterleitung von Freedesktop-Benachrichtigungen.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * Mocken von `zbus` (falls möglich) oder Verwendung von `zbus` Test-Utilities, um die D-Bus-Client-Interaktionen zu testen.
          * Testen der Datenkonvertierung von D-Bus-Antworten in domänenspezifische Strukturen.
          * Testen der `notifications_server` Implementierung: Senden simulierter `Notify` Nachrichten und Überprüfen, ob die `IncomingNotification` korrekt an die Domänenschicht weitergeleitet wird.
          * Testen der Fehlerbehandlung bei D-Bus-Fehlern.
      * **Integration Tests:**
          * Starten eines echten (oder Mock-)D-Bus-Daemons und der relevanten Systemdienste (NetworkManager, UPower etc.).
          * Starten des `DefaultDbusClientService` und Überprüfen der Funktionalität (z.B. `get_network_status`).
          * Starten eines externen Benachrichtigungs-Client (z.B. `notify-send`) und Überprüfen, ob NovaDE die Benachrichtigung empfängt und verarbeitet.

  * **Geschätzter Aufwand:** 15-20 Tage

#### 2.3.8. `novade-system/src/audio_management`

  * **Verantwortlichkeit:** Stellt eine Schnittstelle zum PipeWire-Audiosystem bereit, um die Lautstärke zu steuern, Audio-Streams zu verwalten und Hardware-Informationen abzurufen.

  * **Kern-Aufgaben (Tasks):**

    1.  **`audio_service_iface.rs`:**

          * Definiere den Trait `AudioServiceAsync`:
              * `async fn get_master_volume(&self) -> Result<f32, SystemError>`: Ruft die globale Hauptlautstärke ab (0.0-1.0).
              * `async fn set_master_volume(&self, volume: f32) -> Result<(), SystemError>`: Setzt die globale Hauptlautstärke.
              * `async fn toggle_master_mute(&self) -> Result<(), SystemError>`: Schaltet die Hauptlautstärke stumm/aktiv.
              * `async fn get_microphone_volume(&self) -> Result<f32, SystemError>`: Ruft die Mikrofonlautstärke ab.
              * `async fn set_microphone_volume(&self, volume: f32) -> Result<(), SystemError>`: Setzt die Mikrofonlautstärke.
              * `async fn toggle_microphone_mute(&self) -> Result<(), SystemError>`: Schaltet das Mikrofon stumm/aktiv.
              * `async fn play_sound(&self, sound_path: PathBuf) -> Result<(), SystemError>`: Spielt eine Sounddatei ab.
              * `fn subscribe_to_master_volume_changes(&self) -> tokio::sync::broadcast::Receiver<f32>`: Änderungen der Hauptlautstärke.
              * `fn subscribe_to_master_mute_changes(&self) -> tokio::sync::broadcast::Receiver<bool>`: Änderungen des Haupt-Mute-Status.
              * `fn subscribe_to_microphone_volume_changes(&self) -> tokio::sync::broadcast::Receiver<f32>`: Änderungen der Mikrofonlautstärke.
              * `fn subscribe_to_microphone_mute_changes(&self) -> tokio::sync::broadcast::Receiver<bool>`: Änderungen des Mikrofon-Mute-Status.

    2.  **`service.rs` (Audio Service Implementation):**

          * Implementiere die Struktur `DefaultAudioService` für den `AudioServiceAsync` Trait.
          * Der Konstruktor nimmt `Arc<novade_system::events::EventBus>` entgegen.
          * Verwendet `pipewire-rs` Bindings für die Interaktion mit PipeWire.
          * Initialisiere eine `pipewire_rs::core::Core` Instanz.
          * Verwalte interne `tokio::sync::broadcast::Sender` für die verschiedenen Event-Typen.
          * **Implementierung der Methoden:**
              * `get_master_volume()`, `set_master_volume()`, `toggle_master_mute()`: Interagiere mit dem Standard-Sink (Ausgabegerät) über die PipeWire API.
              * `get_microphone_volume()`, `set_microphone_volume()`, `toggle_microphone_mute()`: Interagiere mit dem Standard-Source (Eingabegerät) über die PipeWire API.
              * `play_sound()`: Erstelle einen kurzlebigen PipeWire-Client, der die Sounddatei in einen Buffer lädt und abspielt.
          * **Hintergrund-Task für PipeWire-Events:**
              * Starte einen `tokio::spawn` Task, der die PipeWire-Events überwacht (Lautstärkeänderungen, Mute-Status, Geräte-Änderungen).
              * Bei relevanten Events, übersetze sie und publiziere sie über die `broadcast::Sender` und den `SystemEventBus` (`SystemEvent::AudioVolumeChanged`, `AudioMuteToggled`, etc.).

    3.  **`mod.rs`:**

          * Re-exportiere alle relevanten Module und Strukturen.

  * **Spezifische Artefakte/Dateien:**

      * `novade-system/src/audio_management/audio_service_iface.rs`
      * `novade-system/src/audio_management/service.rs`
      * `novade-system/src/audio_management/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-system::error::SystemError`, `novade-system::events::EventBus`.
      * **Extern:** `pipewire-rs`, `tokio`, `tracing`, `async-trait`, `std::path::PathBuf`.

  * **Kommunikationsmuster:**

      * Stellt eine Abstraktion für die Audio-Interaktion bereit.
      * Domänen-Services (z.B. `NotificationRulesEngine` für `PlaySound` Aktion) und UI-Komponenten rufen die Methoden dieses Services auf.
      * Publiziert Audio-relevante `SystemEvent`s an den `EventBus`.

  * **Erwartete Ergebnisse/Outputs:**

      * Robuste Steuerung des Audio-Systems über PipeWire.
      * Möglichkeit, System-Sounds abzuspielen.
      * Reaktive Updates auf Lautstärke- und Mute-Änderungen.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * Mocken von `pipewire-rs` APIs, um die Methoden (`get_master_volume`, `set_master_volume` etc.) zu testen.
          * Testen der Fehlerbehandlung bei PipeWire-API-Fehlern.
          * Testen des Event-Bus-Verhaltens bei Audio-Events.
          * Testen der `play_sound` Logik (simulierte erfolgreiche Wiedergabe und Fehler).
      * **Integration Tests:**
          * Starten eines echten PipeWire-Daemons (oder eines Test-Daemons).
          * Starten des `DefaultAudioService` und Überprüfen der Funktionalität (z.B. Lautstärke über CLI ändern und im Service abfragen).
          * Abspielen einer Sounddatei und Überprüfen, ob sie hörbar ist.

  * **Geschätzter Aufwand:** 8-12 Tage

#### 2.3.9. `novade-system/src/mcp_client`

  * **Verantwortlichkeit:** Implementiert den Client für das Model Context Protocol (MCP), um sichere und authentifizierte Kommunikation mit KI-Modellen für kontextbezogene Funktionen zu ermöglichen.

  * **Kern-Aufgaben (Tasks):**

    1.  **`mcp_client_iface.rs`:**

          * Definiere den Trait `McpClientServiceAsync`:
              * `async fn query_model(&self, context: String, query: String) -> Result<String, SystemError>`: Sendet eine Abfrage an das KI-Modell und erhält eine Antwort.
              * `async fn update_context(&self, context_id: String, new_data: String) -> Result<(), SystemError>`: Aktualisiert Kontextdaten für ein Modell.
              * `async fn invalidate_context(&self, context_id: String) -> Result<(), SystemError>`: Invalidiert einen Kontext.
              * `async fn is_model_available(&self, model_id: String) -> Result<bool, SystemError>`: Prüft die Verfügbarkeit eines spezifischen KI-Modells.

    2.  **`service.rs` (MCP Client Service Implementation):**

          * Implementiere die Struktur `DefaultMcpClientService` für den `McpClientServiceAsync` Trait.
          * Der Konstruktor nimmt `Arc<novade_system::events::EventBus>` und `Arc<dyn novade_domain::secret_service::SecretServiceAsync + Send + Sync>` (für API-Keys/Tokens) entgegen.
          * Verwendet eine (hypothetische) `mcp_client_rs` Bibliothek oder implementiert das Protokoll direkt über HTTP/HTTPS oder eine andere Transportmethode.
          * **Implementierung der Methoden:**
              * `query_model()`: Sendet eine Anfrage an den MCP-Server. Beinhaltet Authentifizierungslogik (z.B. API-Key aus Secret Service).
              * `update_context()`, `invalidate_context()`: Sendet entsprechende Kontext-Updates an den MCP-Server.
              * `is_model_available()`: Fragt den MCP-Server nach der Modellverfügbarkeit ab.
          * Implementiere Fehlerbehandlung für Netzwerkfehler, Authentifizierungsfehler und Protokollfehler.

    3.  **`mod.rs`:**

          * Re-exportiere alle relevanten Module und Strukturen.

  * **Spezifische Artefakte/Dateien:**

      * `novade-system/src/mcp_client/mcp_client_iface.rs`
      * `novade-system/src/mcp_client/service.rs`
      * `novade-system/src/mcp_client/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-system::error::SystemError`, `novade-system::events::EventBus`, `novade_domain::secret_service::SecretServiceAsync`.
      * **Extern:** `tokio`, `tracing`, `reqwest` (für HTTP-Kommunikation), `serde_json` (für JSON-Payloads), `async-trait`. (Annahme: keine dedizierte `mcp_client_rs` Crate, daher HTTP-basierte Implementierung).

  * **Kommunikationsmuster:**

      * Domänen-Services (z.B. SearchService für "intelligente Vorschläge") rufen die Methoden dieses Services auf.
      * Holt sich Tokens/Geheimnisse vom `SecretServiceAsync`.

  * **Erwartete Ergebnisse/Outputs:**

      * Sichere und zuverlässige Kommunikation mit externen KI-Modellen.
      * Bereitstellung von kontextbezogenen Informationen für die KI.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * Mocken der HTTP-Anfragen oder der `mcp_client_rs` API.
          * Testen der `query_model`, `update_context`, `invalidate_context`, `is_model_available` Methoden mit verschiedenen Szenarien (erfolgreich, Fehler, Authentifizierungsfehler).
          * Testen der Fehlerbehandlung und der Fehlerkonvertierung.
      * **Integration Tests:**
          * Starten eines Mock-MCP-Servers (oder eines echten, wenn verfügbar).
          * Starten des `DefaultMcpClientService` und Überprüfen der End-to-End-Kommunikation.

  * **Geschätzter Aufwand:** 10-15 Tage

#### 2.3.10. `novade-system/src/window_mechanics`

  * **Verantwortlichkeit:** Dies ist die technische Schnittstelle zum Wayland-Compositor, die die vom Domänen-`WindowPolicyService` definierten Fenster-Richtlinien umsetzt (Positionierung, Tiling, Fokus, Animationen).

  * **Kern-Aufgaben (Tasks):**

    1.  **`window_mechanics_iface.rs`:**

          * Definiere den Trait `WindowMechanicsServiceAsync`:
              * `async fn apply_window_state(&self, window_id: novade_domain::window_policy::data_types::WindowIdentifier, state: novade_domain::window_policy::data_types::WindowState, requested_geometry: Option<novade_core::types::geometry::Rectangle<i32>>) -> Result<(), SystemError>`: Wendet einen Fensterzustand an (Maximieren, Tilen, Fullscreen, etc.) und setzt optional eine Geometrie.
              * `async fn focus_window(&self, window_id: novade_domain::window_policy::data_types::WindowIdentifier) -> Result<(), SystemError>`: Setzt den Fokus auf ein Fenster.
              * `async fn move_window(&self, window_id: novade_domain::window_policy::data_types::WindowIdentifier, x: i32, y: i32) -> Result<(), SystemError>`: Bewegt ein Fenster zu neuen Koordinaten.
              * `async fn resize_window(&self, window_id: novade_domain::window_policy::data_types::WindowIdentifier, width: u32, height: u32) -> Result<(), SystemError>`: Ändert die Größe eines Fensters.
              * `async fn close_window(&self, window_id: novade_domain::window_policy::data_types::WindowIdentifier) -> Result<(), SystemError>`: Schließt ein Fenster.
              * `async fn set_window_opacity(&self, window_id: novade_domain::window_policy::data_types::WindowIdentifier, opacity: f32) -> Result<(), SystemError>`: Setzt die Opazität eines Fensters.
              * `async fn bring_window_to_front(&self, window_id: novade_domain::window_policy::data_types::WindowIdentifier) -> Result<(), SystemError>`: Bringt ein Fenster in den Vordergrund (Stacking Order).
              * `async fn send_window_to_back(&self, window_id: novade_domain::window_policy::data_types::WindowIdentifier) -> Result<(), SystemError>`: Sendet ein Fenster in den Hintergrund.
              * `async fn get_window_geometry(&self, window_id: novade_domain::window_policy::data_types::WindowIdentifier) -> Result<novade_core::types::geometry::Rectangle<i32>, SystemError>`: Ruft die aktuelle Geometrie eines Fensters ab.

    2.  **`service.rs` (Window Mechanics Service Implementation):**

          * Implementiere die Struktur `DefaultWindowMechanicsService` für den `WindowMechanicsServiceAsync` Trait.
          * Der Konstruktor nimmt `Arc<RwLock<DesktopState>>`, `Arc<novade_system::events::EventBus>`, und `Arc<dyn novade_domain::window_policy::WindowPolicyServiceAsync + Send + Sync>` entgegen.
          * **Internes Fenster-Mapping:** Das Service benötigt eine Möglichkeit, von `novade_domain::window_policy::data_types::WindowIdentifier` auf die Smithay-internen `smithay::wayland::shell::xdg::XdgSurface` oder `smithay::output::Output` Objekte zu mappen. Dies geschieht durch Abfragen des `DesktopState::window_map`.
          * **Implementierung der Methoden:**
              * Alle Methoden interagieren direkt mit den Smithay-APIs über den `DesktopState` (`compositor_state`, `shell_state`, `seat_state`, etc.).
              * **`apply_window_state()`:**
                  * Für `Maximized`, `Fullscreen`, `Minimized`: Sende die entsprechenden XDG-Shell `configure` Events an den Client mit dem `State::Maximized`, `State::Fullscreen`, `State::Tiled` Flag. Smithay kümmert sich um die Protokoll-Details.
                  * Für Tiling-States (`TiledLeft`, `TiledRight` etc.): Der `WindowPolicyService` liefert die *Zielgeometrie*. Diese Geometrie wird dann an den Client über `XdgSurface::send_configure` gesendet. Der Compositor im `desktop_state` muss die tatsächliche Geometrie des Fensters aktualisieren, sobald der Client die Konfiguration bestätigt.
                  * Für `Normal`: Entferne alle Flags und setze optionale `requested_geometry`.
                  * Aktualisiere den `DesktopState::window_map` mit dem neuen Zustand.
                  * Publiziere `SystemEvent::WindowMaximized`, `WindowFullscreened`, etc. an den `EventBus`.
              * **`focus_window()`:** Setzt den Fokus auf das entsprechende `XdgSurface` über `smithay::input::Seat::set_keyboard_focus`.
              * **`move_window()` / `resize_window()`:** Sendet `XdgSurface::send_configure` mit der neuen Geometrie.
              * **`close_window()`:** Sendet `XdgSurface::send_close()` an den Client.
              * **`set_window_opacity()`:** Benötigt ggf. einen Custom Wayland-Protokoll-Extension oder eine Compositor-interne Implementierung (z.B. durch spezifische GL-Shader, nicht direkt in Smithay). Das ist ein komplexeres Feature, das optional als "Advanced Feature" betrachtet werden kann.
              * **`bring_window_to_front()` / `send_window_to_back()`:** Manipuliert die Z-Ordnung der Fenster im Compositor. Das kann durch Ändern der Reihenfolge in einer internen Fensterliste im `DesktopState` geschehen, die vom Renderer verwendet wird.
              * `get_window_geometry()`: Liest aus `DesktopState::window_map`.
          * Fehlerbehandlung für nicht gefundene Fenster oder ungültige Operationen.

    3.  **`mod.rs`:**

          * Re-exportiere alle relevanten Module und Strukturen.

  * **Spezifische Artefakte/Dateien:**

      * `novade-system/src/window_mechanics/window_mechanics_iface.rs`
      * `novade-system/src/window_mechanics/service.rs`
      * `novade-system/src/window_mechanics/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-system::error::SystemError`, `novade-system::events::EventBus`, `novade-system::desktop_state::DesktopState`, `novade-domain::window_policy::data_types`, `novade_domain::window_policy::WindowPolicyServiceAsync`, `novade_core::types::geometry`.
      * **Extern:** `smithay`, `tokio`, `tracing`, `async-trait`.

  * **Kommunikationsmuster:**

      * Der `DefaultWindowMechanicsService` ist die primäre Schnittstelle für den `WindowPolicyService` (Domänenschicht) und die UI-Schicht, um Fenster zu manipulieren.
      * Liest/Schreibt in den `DesktopState` (durch `RwLock`).
      * Publiziert `SystemEvent`s, wenn Fensterzustände geändert werden (auch wenn von Domänenschicht initiiert, meldet die Systemschicht die technische Durchführung).

  * **Erwartete Ergebnisse/Outputs:**

      * Eine funktionale Schnittstelle zur Steuerung der Fenstereigenschaften im Compositor.
      * Technische Umsetzung der Domänen-Fensterrichtlinien.
      * Reaktive Änderungen der Fensterdarstellung.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * Mocken von `DesktopState` und `smithay` APIs.
          * Testen, ob `apply_window_state` die korrekten `configure` Events an simulierte Clients sendet und den `DesktopState` aktualisiert.
          * Testen der `focus_window`, `move_window`, `resize_window`, `close_window` Methoden.
          * Testen der Fehlerbehandlung (Fenster nicht gefunden, ungültige Parameter).
          * Testen der Event-Bus-Veröffentlichung.
      * **Integration Tests:**
          * Zusammen mit dem `compositor` Modul. Starten eines Test-Compositors und von Client-Anwendungen.
          * Automatisierte Tests, die den `WindowMechanicsService` nutzen, um Fenster zu maximieren, zu verschieben, zu tilen und zu schließen. Überprüfen, ob die Clients korrekt reagieren und der Compositor die Fenster korrekt darstellt.

  * **Geschätzter Aufwand:** 10-15 Tage

#### 2.3.11. `novade-system/src/power_management`

  * **Verantwortlichkeit:** Stellt eine technische Schnittstelle zur Steuerung der System-Power-Zustände (Suspend, Hibernate, Shutdown) und zur Abfrage von Batterie- und Lid-Zuständen bereit. Implementiert den `PowerManagementControl` Trait für `DesktopState`.

  * **Kern-Aufgaben (Tasks):**

    1.  **`power_control_iface.rs`:**

          * Definiere den Trait `PowerManagementControl`:
              * `async fn get_current_battery_info(&self) -> Result<novade_domain::power_management::data_types::BatteryInfo, SystemError>`: Ruft aktuelle Batterieinformationen ab.
              * `async fn get_lid_state(&self) -> Result<novade_domain::power_management::data_types::LidState, SystemError>`: Ruft den Zustand des Laptop-Deckels ab.
              * `async fn request_system_power_state_change(&self, state: novade_domain::power_management::data_types::PowerState) -> Result<(), SystemError>`: Fordert eine Änderung des System-Power-Zustands an.
              * `async fn set_display_dpms_timeout(&self, timeout_seconds: u64) -> Result<(), SystemError>`: Setzt das DPMS-Timeout für das Display.
              * `async fn set_system_sleep_timeout(&self, timeout_seconds: u64) -> Result<(), SystemError>`: Setzt das System-Sleep-Timeout.

    2.  **`service.rs` (Power Management Service Implementation):**

          * Implementiere die Struktur `DefaultSystemPowerManagementService` für den `PowerManagementControl` Trait. (Dies könnte auch direkt von `DesktopState` implementiert werden, aber eine separate Service-Struktur ist modularer).
          * Der Konstruktor nimmt `Arc<novade_system::events::EventBus>` und `Arc<dyn novade_system::dbus_interfaces::DbusClientServiceAsync + Send + Sync>` entgegen (für logind/UPower).
          * **Implementierung der Methoden:**
              * `get_current_battery_info()`: Ruft Daten über den `DbusClientServiceAsync` (UPower) ab.
              * `get_lid_state()`: Ruft Daten über den `DbusClientServiceAsync` (logind) ab.
              * `request_system_power_state_change(state)`: Ruft entsprechende Methoden auf dem `DbusClientServiceAsync` auf (logind für suspend/shutdown).
              * `set_display_dpms_timeout()`: Interagiert mit dem Compositor (`DesktopState::output_manager_state` oder spezifische Smithay API), um das DPMS-Timeout zu setzen.
              * `set_system_sleep_timeout()`: Interagiert mit `logind` über den `DbusClientServiceAsync`.
          * Publiziert `SystemEvent::BatteryInfoUpdated`, `SystemEvent::LidStateUpdated`, `SystemEvent::PowerStateRequested`.

    3.  **`mod.rs`:**

          * Re-exportiere alle relevanten Module und Strukturen.

  * **Spezifische Artefakte/Dateien:**

      * `novade-system/src/power_management/power_control_iface.rs`
      * `novade-system/src/power_management/service.rs`
      * `novade-system/src/power_management/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-system::error::SystemError`, `novade-system::events::EventBus`, `novade-system::dbus_interfaces::DbusClientServiceAsync`, `novade-domain::power_management::data_types`.
      * **Extern:** `tokio`, `tracing`, `async-trait`.

  * **Kommunikationsmuster:**

      * Dieser Service wird vom Domänen-`PowerManagementService` verwendet.
      * Delegiert die eigentlichen Systemaufrufe an den `DbusClientServiceAsync`.
      * Publiziert Power-Events an den `EventBus`.

  * **Erwartete Ergebnisse/Outputs:**

      * Eine einheitliche API zur Steuerung und Abfrage von System-Power-Zuständen.
      * Abstraktion von der zugrunde liegenden D-Bus-Kommunikation.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * Mocken von `DbusClientServiceAsync` und `DesktopState` (für DPMS).
          * Testen aller Methoden (`get_current_battery_info`, `request_system_power_state_change`, etc.) auf korrekte Delegation und Fehlerbehandlung.
          * Testen der Event-Veröffentlichung.
      * **Integration Tests:**
          * Zusammen mit dem `dbus_interfaces` Modul. Simulieren von D-Bus-Antworten von UPower/logind und Überprüfen der korrekten Weitergabe an den `DefaultSystemPowerManagementService`.

  * **Geschätzter Aufwand:** 5-7 Tage

#### 2.3.12. `novade-system/src/metrics`

  * **Verantwortlichkeit:** Sammelt und stellt technische Systemmetriken (CPU, RAM, Netzwerk, Speicher) aus der Systemperspektive bereit. Implementiert den `SystemMetricsProvider` Trait für `DesktopState`.

  * **Kern-Aufgaben (Tasks):**

    1.  **`metrics_provider_iface.rs`:**

          * Definiere den Trait `SystemMetricsProvider`:
              * `async fn get_cpu_info(&self) -> Result<novade_domain::system_monitor::data_types::CpuInfo, SystemError>`: Ruft CPU-Informationen ab.
              * `async fn get_memory_info(&self) -> Result<novade_domain::system_monitor::data_types::MemoryInfo, SystemError>`: Ruft Speicherinformationen ab.
              * `async fn get_network_interfaces_info(&self) -> Result<Vec<novade_domain::system_monitor::data_types::NetworkInterfaceInfo>, SystemError>`: Ruft Netzwerkschnittstellen-Informationen ab.
              * `async fn get_disk_info(&self) -> Result<Vec<novade_domain::system_monitor::data_types::DiskInfo>, SystemError>`: Ruft Festplatteninformationen ab.

    2.  **`service.rs` (Metrics Provider Implementation):**

          * Implementiere die Struktur `DefaultSystemMetricsProvider` für den `SystemMetricsProvider` Trait. (Auch dies könnte direkt von `DesktopState` implementiert werden).
          * Der Konstruktor nimmt `Arc<novade_system::events::EventBus>` entgegen.
          * Verwendet geeignete Rust-Bibliotheken für Systemmetriken (`sysinfo`, `psutil`, `procfs` auf Linux) oder delegiert an D-Bus-Clients.
          * **Implementierung der Methoden:**
              * `get_cpu_info()`: Nutzt `sysinfo` oder ähnliches, um CPU-Auslastung, Frequenz und Temperatur zu erfassen.
              * `get_memory_info()`: Nutzt `sysinfo` oder ähnliches, um RAM- und Swap-Nutzung zu erfassen.
              * `get_network_interfaces_info()`: Nutzt `sysinfo` oder `netdev` oder delegiert an `DbusClientServiceAsync` (NetworkManager).
              * `get_disk_info()`: Nutzt `sysinfo` oder ähnliches, um Festplattennutzung und Mountpoints zu erfassen.
          * Implementiere Fehlerbehandlung für den Fall, dass Metriken nicht abgerufen werden können.
          * Publiziert keine eigenen Events, da die Domänenschicht (`SystemMonitorService`) diese Daten periodisch abfragt und aggregiert.

    3.  **`mod.rs`:**

          * Re-exportiere alle relevanten Module und Strukturen.

  * **Spezifische Artefakte/Dateien:**

      * `novade-system/src/metrics/metrics_provider_iface.rs`
      * `novade-system/src/metrics/service.rs`
      * `novade-system/src/metrics/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-system::error::SystemError`, `novade-domain::system_monitor::data_types`.
      * **Extern:** `tokio`, `tracing`, `sysinfo` (oder ähnliche), `async-trait`.

  * **Kommunikationsmuster:**

      * Dieser Service wird vom Domänen-`SystemMonitorService` verwendet.
      * Stellt Rohmetriken bereit.

  * **Erwartete Ergebnisse/Outputs:**

      * Eine einheitliche API zum Abrufen von Systemleistungsdaten.
      * Abstraktion von der plattformspezifischen Metrik-Erfassung.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * Mocken der System-APIs (z.B. `sysinfo` oder `procfs`), um die Methoden (`get_cpu_info`, `get_memory_info` etc.) zu testen.
          * Testen der Datenkonvertierung in die domänenspezifischen Strukturen.
          * Testen der Fehlerbehandlung.
      * **Integration Tests:**
          * Starten des `DefaultSystemMetricsProvider` und Überprüfen der plausiblen Ausgabe (z.B. CPU-Auslastung \> 0, Speicher \> 0).

  * **Geschätzter Aufwand:** 5-8 Tage

#### 2.3.13. `novade-system/src/portals`

  * **Verantwortlichkeit:** Integriert XDG Desktop Portals, um NovaDE-Anwendungen sicheren Zugriff auf Host-System-Funktionen zu ermöglichen, die sonst sandboxed wären (z.B. Dateiauswahl, Screenshots).

  * **Kern-Aufgaben (Tasks):**

    1.  **`data_types.rs`:**

          * Definiere die Enum `PortalRequest` (FileChooser, Screenshot, Print, OpenURI, etc.). Jede Variante sollte die notwendigen Parameter enthalten (z.B. für FileChooser: `title: String`, `multiple: bool`, `filters: Vec<String>`).
          * Definiere die Enum `PortalResponse` (Success(PathBuf), Error(String), Cancelled). Für FileChooser: `Vec<PathBuf>`. Für Screenshot: `PathBuf`.
          * Implementiere `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize` für die Typen.

    2.  **`portal_service_iface.rs`:**

          * Definiere den Trait `PortalServiceAsync`:
              * `async fn handle_portal_request(&self, request: PortalRequest) -> Result<PortalResponse, SystemError>`: Sendet eine Portal-Anfrage und wartet auf eine Antwort.

    3.  **`service.rs` (Portal Service Implementation):**

          * Implementiere die Struktur `DefaultPortalService` für den `PortalServiceAsync` Trait.
          * Der Konstruktor nimmt `Arc<novade_system::events::EventBus>` entgegen.
          * Verwendet `ashpd` (Rust-Bindings für XDG Desktop Portals).
          * **Implementierung der Methoden:**
              * `handle_portal_request(request)`:
                  * Mappt die `PortalRequest` auf die entsprechende `ashpd` Methode (z.B. `ashpd::flatpak::FileChooser::open_file`).
                  * Sendet die Anfrage an den Portal-Daemon (über D-Bus).
                  * Wartet auf die Antwort und konvertiert sie in `PortalResponse`.
                  * Behandelt Fehler (z.B. Timeout, Portal nicht verfügbar, Benutzer abbricht).
                  * Für Screenshots könnte dies die Interaktion mit `DesktopState` beinhalten, um den aktuellen Output zu rendern und als Bild zu speichern, bevor es über das Portal angeboten wird.
          * Implementiere Fehlerbehandlung für Portal-spezifische Fehler.

    4.  **`mod.rs`:**

          * Re-exportiere alle relevanten Module und Strukturen.

  * **Spezifische Artefakte/Dateien:**

      * `novade-system/src/portals/data_types.rs`
      * `novade-system/src/portals/portal_service_iface.rs`
      * `novade-system/src/portals/service.rs`
      * `novade-system/src/portals/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-system::error::SystemError`, `novade-system::events::EventBus`, `novade_core::types::geometry`.
      * **Extern:** `tokio`, `tracing`, `ashpd`, `async-trait`, `std::path::PathBuf`.

  * **Kommunikationsmuster:**

      * Domänen-Services (z.B. `WallpaperManager` für Bildauswahl) und UI-Komponenten rufen die Methoden dieses Services auf.
      * Interagiert mit dem System über D-Bus und den XDG Desktop Portal Daemon.

  * **Erwartete Ergebnisse/Outputs:**

      * Sicherer und standardisierter Zugriff auf sandboxed Systemfunktionen.
      * Einfache Abstraktion der XDG Desktop Portal API.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * Mocken von `ashpd` APIs (D-Bus-Kommunikation) um die `handle_portal_request` Methode zu testen.
          * Testen der Konvertierung von `PortalRequest` zu `ashpd` Typen und von `ashpd` Antworten zu `PortalResponse`.
          * Testen der Fehlerbehandlung (Portal nicht verfügbar, Benutzer bricht ab).
      * **Integration Tests:**
          * Starten eines `xdg-desktop-portal` Daemons und eines Flatpak-Runners (falls relevant).
          * Starten des `DefaultPortalService` und Auslösen von Anfragen (z.B. Datei-Auswahldialog) und Überprüfen der Interaktion.

  * **Geschätzter Aufwand:** 8-12 Tage

#### 2.3.14. `novade-system/src/startup`

  * **Verantwortlichkeit:** Verwaltet den Start und das Herunterfahren der NovaDE-Umgebung, einschließlich der Initialisierung von `systemd` User-Sessions und dem Start von Autostart-Anwendungen.

  * **Kern-Aufgaben (Tasks):**

    1.  **`startup_service_iface.rs`:**

          * Definiere den Trait `StartupServiceAsync`:
              * `async fn start_user_session(&self) -> Result<(), SystemError>`: Initialisiert die `systemd` User Session.
              * `async fn launch_autostart_applications(&self) -> Result<(), SystemError>`: Startet Anwendungen, die für den Autostart konfiguriert sind (via XDG Autostart Specification).
              * `async fn prepare_shutdown(&self) -> Result<(), SystemError>`: Führt Shutdown-Vorbereitungen aus (Speichern des Zustands, Beenden von Diensten).
              * `async fn request_system_shutdown(&self) -> Result<(), SystemError>`: Fordert den System-Shutdown an (delegiert an Power Management).

    2.  **`service.rs` (Startup Service Implementation):**

          * Implementiere die Struktur `DefaultStartupService` für den `StartupServiceAsync` Trait.
          * Der Konstruktor nimmt `Arc<novade_system::events::EventBus>`, `Arc<dyn novade_system::dbus_interfaces::DbusClientServiceAsync + Send + Sync>` (für logind/systemd), und `Arc<dyn novade_domain::desktop_entries::DesktopEntryServiceAsync + Send + Sync>` entgegen.
          * **Implementierung der Methoden:**
              * `start_user_session()`: Interagiert mit `systemd-logind` über D-Bus (`DbusClientServiceAsync`) oder `systemd` Libraries, um die User Session zu aktivieren.
              * `launch_autostart_applications()`:
                  * Nutzt `DesktopEntryServiceAsync` um alle `.desktop`-Dateien zu finden, die den `Autostart` Desktop Entry Key auf `true` gesetzt haben.
                  * Filtert nach `OnlyShowIn=NovaDE` oder `NotShowIn=GNOME;KDE;` etc.
                  * Startet die entsprechenden Anwendungen als separate Prozesse (via `std::process::Command`), idealerweise mit `spawn_async`.
                  * Behandelt Fehler beim Starten von Anwendungen.
              * `prepare_shutdown()`:
                  * Sichert kritischen Zustand (z.B. über `GlobalSettingsService` der Domänenschicht).
                  * Signalisiert anderen Services das Herunterfahren (z.B. über den `EventBus`).
                  * Schließt offene Ressourcen.
              * `request_system_shutdown()`: Delegiert an `PowerManagementControl` in der Systemschicht.

    3.  **`mod.rs`:**

          * Re-exportiere alle relevanten Module und Strukturen.

  * **Spezifische Artefekte/Dateien:**

      * `novade-system/src/startup/startup_service_iface.rs`
      * `novade-system/src/startup/service.rs`
      * `novade-system/src/startup/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** `novade-system::error::SystemError`, `novade-system::events::EventBus`, `novade-system::dbus_interfaces::DbusClientServiceAsync`, `novade-system::power_management::PowerManagementControl`, `novade_domain::desktop_entries::DesktopEntryServiceAsync`.
      * **Extern:** `tokio`, `tracing`, `async-trait`, `std::process::Command`, `xdg` crate (für XDG Base Directory Spec, falls nicht von `DesktopEntryService` gekapselt).

  * **Kommunikationsmuster:**

      * Dieser Service wird vom Haupt-Anwendungseinstiegspunkt von NovaDE aufgerufen.
      * Nutzt D-Bus-Clients für Systemdienste.
      * Nutzt den `DesktopEntryService` der Domäne.
      * Publiziert Startup/Shutdown `SystemEvent`s.

  * **Erwartete Ergebnisse/Outputs:**

      * Ein ordnungsgemäßer Start und ein kontrolliertes Herunterfahren der Desktop-Umgebung.
      * Korrekter Start von Autostart-Anwendungen.

  * **Teststrategie (Modul-spezifisch):**

      * **Unit Tests:**
          * Mocken von `DbusClientServiceAsync`, `DesktopEntryServiceAsync`, `PowerManagementControl`.
          * Testen von `start_user_session` und `request_system_shutdown` auf korrekte Delegation.
          * Testen von `launch_autostart_applications`: Simulieren von `DesktopEntry`s und Überprüfen, ob die korrekten Befehle ausgeführt werden.
          * Testen der `prepare_shutdown` Logik.
          * Testen der Fehlerbehandlung.
      * **Integration Tests:**
          * Einrichten einer Minimalumgebung mit `systemd-logind` und Test-Desktop-Entries.
          * Starten des `DefaultStartupService` und Überprüfen des Starts und Herunterfahrens.

  * **Geschätzter Aufwand:** 7-10 Tage

#### 2.3.15. `novade-system/src/mod.rs` (Systemschicht Crate Root)

  * **Verantwortlichkeit:** Definiert die öffentliche API der gesamten `novade-system` Crate. Exportiert alle relevanten Module und Strukturen, um sie für höhere Schichten (`novade-ui`) zugänglich zu machen und die System-Services zu initialisieren.

  * **Kern-Aufgaben (Tasks):**

    1.  **Modul-Deklarationen:** Deklariere alle Untermodule (`compositor`, `input`, `dbus_interfaces`, `audio_management`, `mcp_client`, `window_mechanics`, `power_management`, `metrics`, `portals`, `startup`, `events`, `error`, `desktop_state`).
    2.  **Re-Exports:** Exportiere alle öffentlichen Traits, Services, Enums und Structs aus den Untermodulen, die für die Interaktion mit der Systemschicht von außen notwendig sind.
          * Beispiele: `SystemError`, `SystemEvent`, `EventBus`, `DesktopState`, `CompositorService`, `InputServiceAsync`, `DbusClientServiceAsync`, `AudioServiceAsync`, `McpClientServiceAsync`, `WindowMechanicsServiceAsync`, `PowerManagementControl`, `SystemMetricsProvider`, `PortalServiceAsync`, `StartupServiceAsync`.
          * Auch wichtige `data_types` wie `WindowAttributes` (aus `domain::window_policy`), `BatteryInfo` (aus `domain::power_management`), `NetworkStatus` (aus `domain::network`), `PortalRequest`, `PortalResponse` etc.
    3.  **`init_system_services()` Funktion:**
          * Diese Funktion sollte die `SystemServices` Struktur initialisieren und zurückgeben.
          * Sie ist der zentrale Einstiegspunkt, um die gesamte Systemschicht aufzubauen.
          * Sie sollte die notwendigen `Arc`s zu den Domänen-Services (`WindowPolicyServiceAsync`, `GlobalSettingsService`, `NotificationServiceAsync`, `SecretServiceAsync`, `DesktopEntryServiceAsync`, `PowerManagementServiceAsync`, `SearchServiceAsync`, `SystemMonitorServiceAsync`) als Parameter erhalten, da diese von vielen System-Services benötigt werden.

  * **Spezifische Artefakte/Dateien:**

      * `novade-system/src/mod.rs`

  * **Abhängigkeiten:**

      * **Intern:** Alle Untermodule der `novade-system` Crate. `novade-core::error::CoreError`, `novade-domain::*` (für alle benötigten Traits und Datentypen).

  * **Kommunikationsmuster:** Ermöglicht den Import von System-Services und Datenstrukturen durch die `novade-ui` Crate und die Hauptanwendung.

  * **Erwartete Ergebnisse/Outputs:** Eine sauber definierte und einfach zu nutzende öffentliche API für die `novade-system` Crate.

  * **Teststrategie (Modul-spezifisch):**

      * **Compile-time Tests:** Sicherstellen, dass alle re-exportierten Pfade korrekt sind und keine Zirkelabhängigkeiten entstehen.
      * **Integration Tests:** Die Integrationstests auf höherer Ebene werden implizit testen, ob die Exports und die `init_system_services` Funktion korrekt funktionieren.

  * **Geschätzter Aufwand:** 2 Tage

-----

**Priorisierung für die Implementierung der Domänenschicht (Fortsetzung):**

1.  `novade-domain/src/theme` (geringe Abhängigkeiten, essentiell für UI-Start)
2.  `novade-domain/src/wallpaper_manager` (geringe Abhängigkeiten, essentiell für UI-Start)
3.  `novade-domain/src/notifications` (kann unabhängig von anderen Modulen implementiert werden, ggf. Mocking für Audio/Process Execution)
4.  `novade-domain/src/window_policy` (Abhängigkeit von `novade-core::types::geometry`, wird vom Compositor der Systemschicht benötigt)
5.  `novade-domain/src/system_monitor` (geringe Abhängigkeiten, benötigt `SystemMetricsProvider` aus Systemschicht)
6.  `novade-domain/src/power_management` (geringe Abhängigkeiten, benötigt `SystemPowerControl` aus Systemschicht)
7.  `novade-domain/src/mod.rs` (nachdem alle Submodule definiert sind)

**Priorisierung für die Implementierung der Systemschicht:**

1.  `novade-system/src/error.rs` (Fundament für Fehlerbehandlung, keine weiteren Abhängigkeiten)
2.  `novade-system/src/events.rs` (Fundament für Event-Kommunikation, keine weiteren Abhängigkeiten)
3.  `novade-system/src/dbus_interfaces` (Clients können gemockt werden, Notifications Server kann unabhängig entwickelt werden)
4.  `novade-system/src/metrics` (Metriken-Provider, wird von `SystemMonitorService` (Domäne) benötigt)
5.  `novade-system/src/power_management` (Power-Steuerung, wird von `PowerManagementService` (Domäne) benötigt)
6.  `novade-system/src/desktop_state.rs` (Zentraler Zustand, benötigt alle Sub-States von Smithay und Referenzen zu Domänen-Services; **hohe Komplexität**)
7.  `novade-system/src/compositor` (Herzstück des Systems, viele Abhängigkeiten zu Smithay-States und `DesktopState`)
8.  `novade-system/src/input` (Direkte Interaktion mit `DesktopState` und `libinput`)
9.  `novade-system/src/window_mechanics` (Interagiert direkt mit `DesktopState` und `Compositor`)
10. `novade-system/src/portals` (Benötigt D-Bus, kann aber mit Mock-Services entwickelt werden)
11. `novade-system/src/mcp_client` (Geringe Abhängigkeiten, kann unabhängig von anderen System-Modulen implementiert werden, sofern Secret Service da ist)
12. `novade-system/src/audio_management` (Geringe Abhängigkeiten, kann unabhängig entwickelt werden)
13. `novade-system/src/startup` (Koordiniert andere System-Services)
14. `novade-system/src/lib.rs` (Orchestriert alles, sollte zuletzt entwickelt werden, wenn Submodule stabil sind)
15. `novade-system/src/mod.rs` (nachdem alle Submodule definiert sind)
## Detaillierter Implementierungsplan für NovaDE (Fortsetzung)

### Domänenschicht (`novade-domain`)

#### `novade-domain/src/wallpaper_manager/service.rs`

* **Verantwortlichkeit:** Implementiert die Geschäftslogik für die Verwaltung von Desktophintergründen. Dazu gehören das Laden, Speichern, Anwenden und Validieren von Hintergrundbildeinstellungen sowie die Benachrichtigung anderer Komponenten über Änderungen.
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `WallpaperManagerService` definieren:**
        * Struktur mit Feldern für den Zugriff auf `WallpaperProvider` (für Persistenz), `GlobalSettingsService` (für globale Einstellungen wie Dunkelmodus, die die Tapetenwahl beeinflussen könnten) und `DesktopState` (für den aktuellen Desktop-Zustand, der das angewendete Hintergrundbild reflektiert) definieren.
        * Nutze `Arc<dyn WallpaperProvider>` für den Provider und `Arc<RwLock<DesktopState>>` für den Desktop-Zustand.
        * Verwende `tokio::sync::broadcast::Sender<WallpaperEvent>` für Event-Benachrichtigungen.
    2.  **Konstruktor `new()` implementieren:**
        * Initialisiert den `WallpaperManagerService` mit den erforderlichen Abhängigkeiten.
        * Lade beim Start das zuletzt gespeicherte Hintergrundbild oder setze den Standardwert.
    3.  **Methode `set_wallpaper(wallpaper_path: PathBuf, mode: WallpaperMode)` implementieren:**
        * Setzt das angegebene Hintergrundbild mit dem gewünschten Modus.
        * Validiert den `wallpaper_path` (Existenz, Lesbarkeit).
        * Aktualisiert den internen Zustand des `WallpaperManagerService`.
        * Persistiert die neuen Einstellungen über den `WallpaperProvider`.
        * Sendet ein `WallpaperEvent::WallpaperChanged` über den `broadcast::Sender`.
        * Aktualisiert den `DesktopState` mit dem neuen Hintergrundbild und Modus.
    4.  **Methode `get_current_wallpaper() -> Option<Wallpaper>` implementieren:**
        * Gibt das aktuell konfigurierte Hintergrundbild zurück.
    5.  **Methode `set_wallpaper_mode(mode: WallpaperMode)` implementieren:**
        * Ändert nur den Anzeigemodus des aktuell gesetzten Hintergrundbildes.
        * Aktualisiert den internen Zustand und persistiert die Änderung.
        * Sendet ein `WallpaperEvent::WallpaperModeChanged`.
        * Aktualisiert den `DesktopState`.
    6.  **Methode `handle_theme_change(theme_event: ThemeEvent)` implementieren:**
        * Reagiert auf Änderungen des globalen Themas (z.B. Dunkelmodus-Umschaltung).
        * Passt ggf. das Hintergrundbild an, wenn themenabhängige Hintergrundbilder konfiguriert sind.
        * Aktualisiert den internen Zustand, persistiert und sendet Events.
    7.  **Fehlerbehandlung:** Alle Methoden sollten `Result<T, WallpaperManagerError>` zurückgeben. Fehler wie `FileNotFound`, `PermissionDenied`, `PersistenceError`, `InvalidImageFormat` sollten spezifisch behandelt und gemeldet werden.
    8.  **Asynchronität:** Verwende `async/await` für I/O-Operationen wie das Laden/Speichern von Hintergrundbildeinstellungen.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/wallpaper_manager/service.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::wallpaper_manager::data_types::{Wallpaper, WallpaperMode, WallpaperEvent}`
        * `crate::wallpaper_manager::persistence_iface::WallpaperProvider`
        * `crate::global_settings::service::GlobalSettingsService`
        * `crate::desktop_state::DesktopState`
        * `crate::error::DomainError` (für `WallpaperManagerError`)
        * `crate::theme::data_types::ThemeEvent`
    * **Extern:** `tokio::sync::broadcast`, `std::path::PathBuf`, `std::sync::{Arc, RwLock}`, `tracing` für Logging.
* **Kommunikationsmuster:**
    * Empfängt `ThemeEvent` von `GlobalSettingsService`.
    * Kommuniziert mit `WallpaperProvider` für Persistenz.
    * Aktualisiert `DesktopState`.
    * Sendet `WallpaperEvent` an UI-Schicht (z.B. Panel, Settings UI).
    * Die UI-Schicht ruft Methoden wie `set_wallpaper`, `get_current_wallpaper` auf.
* **Erwartete Ergebnisse/Outputs:** Ein voll funktionsfähiger Dienst zur Verwaltung von Desktophintergründen, der in der Lage ist, Hintergründe zu setzen, zu speichern, zu laden und über Änderungen zu informieren.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen von `set_wallpaper` mit gültigen und ungültigen Pfaden.
        * Testen der Persistenz (Mocks für `WallpaperProvider`).
        * Testen der Event-Aussendung (Mocks für `broadcast::Sender`).
        * Testen der `DesktopState`-Aktualisierung.
        * Testen von `get_current_wallpaper` nach Änderungen.
        * Testen von `set_wallpaper_mode`.
        * Testen der `handle_theme_change` Logik.
        * Testen der Fehlerfälle, z.B. wenn `WallpaperProvider` einen Fehler meldet.
    * **Integration Tests:**
        * Testen des Zusammenspiels mit einem konkreten `FilesystemWallpaperProvider`.

* **Geschätzter Aufwand:** Mittel

#### `novade-domain/src/wallpaper_manager/mod.rs`

* **Verantwortlichkeit:** Definiert die öffentliche Schnittstelle des `wallpaper_manager`-Moduls.
* **Kern-Aufgaben (Tasks):**
    1.  **Re-Exports:** Exportiert die wichtigsten Typen (`Wallpaper`, `WallpaperMode`, `WallpaperEvent`, `WallpaperManagerService`, `WallpaperProvider`, `WallpaperManagerError`) aus den Untermodulen.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/wallpaper_manager/mod.rs`
* **Abhängigkeiten:** Keine direkten, re-exportiert aus `data_types.rs`, `persistence_iface.rs`, `service.rs`, `error.rs`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Eine saubere, einheitliche API für das `wallpaper_manager`-Modul.
* **Teststrategie (Modul-spezifisch):** Verifizierung der Re-Exports (minimal).
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/notification_rules/error.rs`

* **Verantwortlichkeit:** Definiert spezifische Fehlertypen für das `notification_rules`-Modul.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `NotificationRulesError` definieren:**
        * Verwende `thiserror::Error` und `#[derive(Debug)]`.
        * Definiere Varianten für typische Fehler:
            * `PersistenceError(#[from] io::Error)`: Fehler beim Laden/Speichern von Regeln.
            * `SerializationError(#[from] serde_json::Error)`: Fehler beim Serialisieren/Deserialisieren.
            * `RuleNotFound`: Eine angeforderte Regel wurde nicht gefunden.
            * `InvalidRuleDefinition(String)`: Eine Regeldefinition ist syntaktisch oder logisch ungültig.
            * `ServiceError(String)`: Allgemeiner Fehler innerhalb des Services.
            * `GlobalSettingsError(#[from] GlobalSettingsError)`: Fehler vom GlobalSettingsService.
            * `DesktopStateError(#[from] DesktopStateError)`: Fehler vom DesktopState.
        * Implementiere `std::error::Error` Trait (durch `thiserror`).
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification_rules/error.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::error::DomainError`, `crate::global_settings::error::GlobalSettingsError`, `crate::desktop_state::error::DesktopStateError`.
    * **Extern:** `thiserror`, `std::io`, `serde_json`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Klar definierte, nachvollziehbare Fehlertypen für die Benachrichtigungsregeln.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der Fehlerkonstruktion.
        * Testen der `From`-Implementierungen für die Fehlerkonvertierung.
        * Testen der Fehlermeldungen.
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/notification_rules/data_types.rs`

* **Verantwortlichkeit:** Definiert die Datenstrukturen für Benachrichtigungsregeln, Bedingungen und Aktionen.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `ConditionValue` definieren:** Repräsentiert den Wert, gegen den eine Bedingung geprüft wird (z.B. String, Zahl, Bool).
        * `#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]`
        * Varianten: `String(String)`, `Int(i64)`, `Bool(bool)`.
    2.  **Enum `Operator` definieren:** Logische Operatoren für Bedingungen.
        * `#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]`
        * Varianten: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `GreaterThan`, `LessThan`, `IsPresent`, `IsAbsent`, `SettingIsTrue`, `SettingIsFalse`.
    3.  **Enum `Field` definieren:** Felder einer Benachrichtigung, auf die Regeln angewendet werden.
        * `#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]`
        * Varianten: `AppName`, `Summary`, `Body`, `Category`, `Urgency`, `ExpireTimeout`, `Hint(String)` (für benutzerdefinierte Hints).
    4.  **Struktur `SimpleRuleCondition` definieren:** Eine einzelne Bedingung.
        * `#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]`
        * Felder: `field: Field`, `operator: Operator`, `value: Option<ConditionValue>`. (`value` ist `Option` für Operatoren wie `IsPresent`).
    5.  **Enum `RuleCondition` definieren:** Repräsentiert eine komplexe Bedingung (Einzelregel, UND, ODER).
        * `#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]`
        * Varianten:
            * `Simple(SimpleRuleCondition)`
            * `And(Vec<RuleCondition>)`
            * `Or(Vec<RuleCondition>)`
            * `Not(Box<RuleCondition>)`
    6.  **Enum `RuleAction` definieren:** Aktionen, die bei einer passenden Regel ausgeführt werden.
        * `#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]`
        * Varianten:
            * `Suppress`: Unterdrückt die Benachrichtigung.
            * `PlaySound(PathBuf)`: Spielt einen Sound ab.
            * `SetUrgency(Urgency)`: Setzt die Dringlichkeit (z.B. von `Urgency` aus `novade-core::notification_types`).
            * `SetExpireTimeout(i32)`: Setzt das Ablauf-Timeout.
            * `ShowOnWorkspace(WorkspaceId)`: Zeigt auf bestimmtem Workspace an.
            * `DoNotShow`: Zeigt nicht an, aber unterdrückt nicht (z.B. für reine Logging-Regeln).
            * `ExecuteCommand(String)`: Führt einen externen Befehl aus.
    7.  **Struktur `NotificationRule` definieren:** Eine einzelne Benachrichtigungsregel.
        * `#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]`
        * Felder: `id: Uuid`, `name: String`, `enabled: bool`, `priority: i32`, `condition: RuleCondition`, `actions: Vec<RuleAction>`, `stop_processing_further_rules: bool`.
    8.  **Struktur `NotificationRuleSet` definieren:** Eine Sammlung von Benachrichtigungsregeln.
        * `#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]`
        * Felder: `rules: Vec<NotificationRule>`.
        * `Default`-Implementierung (leeres Regel-Set).
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification_rules/data_types.rs`
* **Abhängigkeiten:**
    * **Intern:** `novade-core::notification_types::Urgency`, `novade-core::desktop_state::data_types::WorkspaceId`.
    * **Extern:** `serde::{Serialize, Deserialize}`, `uuid::Uuid`, `std::path::PathBuf`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Stabile und vollständige Datenmodelle für Benachrichtigungsregeln.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der `Default`, `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` Implementierungen.
        * Testen der Serialisierung und Deserialisierung für alle Strukturen und Enums.
        * Testen der Konstruktion komplexer `RuleCondition` (And, Or, Not).
* **Geschätzter Aufwand:** Mittel

#### `novade-domain/src/notification_rules/persistence_iface.rs`

* **Verantwortlichkeit:** Definiert das Trait für die Persistenz von Benachrichtigungsregeln, um die Speicherung und das Laden zu abstrahieren.
* **Kern-Aufgaben (Tasks):**
    1.  **Trait `NotificationRulesProvider` definieren:**
        * Asynchrones Trait.
        * Methode `load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`: Lädt ein `NotificationRuleSet`.
        * Methode `save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`: Speichert ein `NotificationRuleSet`.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification_rules/persistence_iface.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::notification_rules::data_types::NotificationRuleSet`, `crate::notification_rules::error::NotificationRulesError`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Ein klares Interface für die Persistenzschicht der Benachrichtigungsregeln.
* **Teststrategie (Modul-spezifisch):** Keine Tests direkt für das Trait, sondern für Implementierungen des Traits.
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/notification_rules/persistence.rs`

* **Verantwortlichkeit:** Implementiert den `NotificationRulesProvider`-Trait für das Dateisystem.
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `FilesystemNotificationRulesProvider` definieren:**
        * Feld `config_service: Arc<ConfigServiceAsync>`: Zum Ermitteln von Konfigurationspfaden.
        * Feld `file_path: PathBuf`: Der konkrete Pfad zur Regeldatei (z.B. `~/.config/novade/notification_rules.json`).
    2.  **Konstruktor `new(config_service: Arc<ConfigServiceAsync>) -> Self` implementieren:**
        * Ermittelt den Standardpfad für die Regeldatei über `config_service`.
    3.  **Implementierung von `NotificationRulesProvider` für `FilesystemNotificationRulesProvider`:**
        * **`load_rules()`:**
            * Lese die Datei vom `file_path`.
            * Deserealisiere den Inhalt von JSON in `NotificationRuleSet`.
            * Behandle `io::Error::NotFound` als leeres `NotificationRuleSet`, andere `io::Error` oder `serde_json::Error` als `NotificationRulesError::PersistenceError` bzw. `::SerializationError`.
        * **`save_rules()`:**
            * Serialisiere `NotificationRuleSet` in JSON.
            * Schreibe den Inhalt atomar in die Datei am `file_path`. (Temporäre Datei schreiben, dann umbenennen, um Datenverlust bei Absturz zu vermeiden).
            * Behandle `io::Error` und `serde_json::Error`.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification_rules/persistence.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::config::service::ConfigServiceAsync`
        * `crate::notification_rules::data_types::NotificationRuleSet`
        * `crate::notification_rules::error::NotificationRulesError`
        * `crate::notification_rules::persistence_iface::NotificationRulesProvider`
    * **Extern:** `tokio::fs`, `serde_json`, `std::path::PathBuf`, `std::sync::Arc`, `tracing`.
* **Kommunikationsmuster:** Greift auf `ConfigServiceAsync` zu.
* **Erwartete Ergebnisse/Outputs:** Eine robuste Implementierung für das Laden und Speichern von Benachrichtigungsregeln.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Mocking von `ConfigServiceAsync` für Dateipfade.
        * Testen von `load_rules` mit existierender, leerer, ungültiger und nicht existierender Datei.
        * Testen von `save_rules` und anschließendes `load_rules` zur Verifikation der Persistenz.
        * Testen von Fehlern beim Lesen/Schreiben (z.B. Berechtigungsfehler).
        * Verifizierung der atomaren Speicherung (optional, aber hilfreich).
* **Geschätzter Aufwand:** Mittel

#### `novade-domain/src/notification_rules/engine.rs`

* **Verantwortlichkeit:** Implementiert die Logik zur Auswertung von Benachrichtigungsregeln und zur Anwendung von Aktionen auf eingehende Benachrichtigungen.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `RuleProcessingResult` definieren:**
        * `#[derive(Debug, Clone, PartialEq)]`
        * Varianten: `Processed`, `Suppressed`, `Modified(Notification)`.
        * Repräsentiert das Ergebnis der Regelverarbeitung.
    2.  **Trait `NotificationRulesEngine` definieren:**
        * Asynchrones Trait.
        * Methode `reload_rules(&self) -> Result<(), NotificationRulesError>`: Lädt Regeln neu.
        * Methode `process_notification(&self, notification: &mut Notification) -> Result<RuleProcessingResult, NotificationRulesError>`: Wendet Regeln auf eine Benachrichtigung an.
        * Methode `get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`: Gibt die aktuellen Regeln zurück.
        * Methode `update_rules(&self, rules: NotificationRuleSet) -> Result<(), NotificationRulesError>`: Aktualisiert die Regeln und persistiert sie.
        * Methode `add_rule(&self, rule: NotificationRule) -> Result<(), NotificationRulesError>`: Fügt eine einzelne Regel hinzu und persistiert.
        * Methode `remove_rule(&self, rule_id: Uuid) -> Result<(), NotificationRulesError>`: Entfernt eine Regel und persistiert.
    3.  **Struktur `DefaultNotificationRulesEngine` definieren:**
        * Felder:
            * `rules: Arc<RwLock<NotificationRuleSet>>`: Aktueller Satz von Regeln.
            * `provider: Arc<dyn NotificationRulesProvider>`: Für Persistenz.
            * `global_settings: Arc<GlobalSettingsService>`: Für `SettingIsTrue`/`SettingIsFalse`-Operatoren.
            * `desktop_state: Arc<RwLock<DesktopState>>`: Für `ShowOnWorkspace`-Aktion (Zugriff auf Workspace-Zustand).
    4.  **Konstruktor `new()` implementieren:** Initialisiert die Engine mit Provider und Services. Lädt initial Regeln.
    5.  **Implementierung von `NotificationRulesEngine` für `DefaultNotificationRulesEngine`:**
        * **`reload_rules()`:** Ruft `provider.load_rules()` auf und aktualisiert `self.rules`.
        * **`process_notification(notification: &mut Notification)`:**
            * Iteriere über `self.rules.read()` und sortiere nach Priorität (höhere Priorität zuerst).
            * Für jede `enabled` Regel:
                * Evaluiere `rule.condition` rekursiv:
                    * `SimpleRuleCondition`-Auswertung:
                        * Holen des entsprechenden Feldes aus der `notification`.
                        * Vergleich des Feldwerts mit `condition.value` unter Verwendung von `condition.operator`.
                        * Spezielle Logik für `IsPresent`, `IsAbsent`, `SettingIsTrue`, `SettingIsFalse` (interagiere mit `global_settings`).
                    * `And`, `Or`, `Not` rekursiv auswerten.
                * Wenn die Bedingung `true` ist:
                    * Wende `rule.actions` auf die `notification` an.
                    * Spezifische Logik für jede `RuleAction`:
                        * `Suppress`: Setze ein internes Flag für die Rückgabe von `RuleProcessingResult::Suppressed`.
                        * `PlaySound`: Asynchrone Ausführung des Sounds (nicht blockierend).
                        * `SetUrgency`, `SetExpireTimeout`, `ShowOnWorkspace`: Direkte Modifikation der `notification` Struktur.
                        * `ExecuteCommand`: Ausführung eines externen Prozesses (nicht blockierend).
                    * Wenn `rule.stop_processing_further_rules` gesetzt ist, beende die Verarbeitung.
            * Gebe `RuleProcessingResult` basierend auf den angewendeten Aktionen zurück (z.B. `Suppressed` oder `Modified`).
        * **`get_rules()`:** Gibt `self.rules.read().clone()` zurück.
        * **`update_rules(rules)`:** Setzt `self.rules` und ruft `provider.save_rules()` auf.
        * **`add_rule(rule)`:** Fügt Regel zu `self.rules` hinzu, sortiert, speichert. Prüfe auf `Uuid`-Kollisionen.
        * **`remove_rule(rule_id)`:** Entfernt Regel aus `self.rules`, speichert.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification_rules/engine.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::notification_rules::data_types::{NotificationRule, NotificationRuleSet, RuleCondition, RuleAction, Field, Operator, ConditionValue}`
        * `crate::notification_rules::error::NotificationRulesError`
        * `crate::notification_rules::persistence_iface::NotificationRulesProvider`
        * `crate::global_settings::service::GlobalSettingsService`
        * `crate::desktop_state::DesktopState`
        * `novade-core::notification_types::Notification`
        * `novade-core::desktop_state::data_types::WorkspaceId`
    * **Extern:** `tokio`, `std::sync::{Arc, RwLock}`, `tracing`, `uuid::Uuid`, `std::process::Command` (für `ExecuteCommand`).
* **Kommunikationsmuster:**
    * Interagiert mit `NotificationRulesProvider` für Persistenz.
    * Greift auf `GlobalSettingsService` für Einstellungen zu.
    * Greift auf `DesktopState` für Workspace-Informationen zu.
* **Erwartete Ergebnisse/Outputs:** Ein leistungsfähiges Regelsystem zur Filterung und Modifikation von Benachrichtigungen.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * **Bedingungsauswertung:**
            * Testen aller `Operator`-Typen (`Equals`, `Contains`, `StartsWith`, `EndsWith`, `GreaterThan`, `LessThan`, `IsPresent`, `IsAbsent`, `SettingIsTrue`, `SettingIsFalse`) mit verschiedenen `Field`-Typen und `ConditionValue`.
            * Testen komplexer `RuleCondition` (`And`, `Or`, `Not`) mit verschachtelten Bedingungen.
            * Testen von Edge-Cases für Bedingungen (leere Strings, Nullen, ungültige Werte).
            * Mocking von `GlobalSettingsService` und `DesktopState` für `SettingIsTrue`/`ShowOnWorkspace` Tests.
        * **Aktionsanwendung:**
            * Testen jeder `RuleAction` und deren Auswirkungen auf die `Notification`-Struktur.
            * Testen von `Suppress` und `DoNotShow`.
            * Testen von `PlaySound` und `ExecuteCommand` (Mocking/Spying auf Systemaufrufe).
        * **Regel-Engine-Logik:**
            * Testen der Priorisierung von Regeln.
            * Testen von `stop_processing_further_rules`.
            * Testen von `add_rule`, `remove_rule`, `update_rules`, `get_rules`.
            * Testen von `reload_rules` nach externen Änderungen (Mocks für `NotificationRulesProvider`).
            * Testen des Verhaltens, wenn keine Regeln definiert sind.
    * **Integration Tests:**
        * Testen des Zusammenspiels mit einem realen `FilesystemNotificationRulesProvider`.
* **Geschätzter Aufwand:** Hoch

#### `novade-domain/src/notification_rules/mod.rs`

* **Verantwortlichkeit:** Definiert die öffentliche Schnittstelle des `notification_rules`-Moduls.
* **Kern-Aufgaben (Tasks):**
    1.  **Re-Exports:** Exportiert die wichtigsten Typen (`ConditionValue`, `Operator`, `Field`, `SimpleRuleCondition`, `RuleCondition`, `RuleAction`, `NotificationRule`, `NotificationRuleSet`, `NotificationRulesError`, `NotificationRulesProvider`, `FilesystemNotificationRulesProvider`, `RuleProcessingResult`, `NotificationRulesEngine`, `DefaultNotificationRulesEngine`) aus den Untermodulen.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification_rules/mod.rs`
* **Abhängigkeiten:** Keine direkten, re-exportiert aus `data_types.rs`, `persistence_iface.rs`, `persistence.rs`, `engine.rs`, `error.rs`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Eine saubere, einheitliche API für das `notification_rules`-Modul.
* **Teststrategie (Modul-spezifisch):** Verifizierung der Re-Exports (minimal).
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/power_management/error.rs`

* **Verantwortlichkeit:** Definiert spezifische Fehlertypen für das `power_management`-Modul.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `PowerManagementError` definieren:**
        * Verwende `thiserror::Error` und `#[derive(Debug)]`.
        * Definiere Varianten für typische Fehler:
            * `LogindError(String)`: Fehler bei der Kommunikation mit `logind`.
            * `UPowerError(String)`: Fehler bei der Kommunikation mit `UPower`.
            * `PermissionDenied`: Fehlende Berechtigungen für eine Aktion.
            * `InvalidAction(String)`: Eine angeforderte Aktion ist ungültig (z.B. suspendieren, wenn nicht unterstützt).
            * `InternalError(String)`: Ein allgemeiner interner Fehler.
            * `SettingsServiceError(#[from] GlobalSettingsError)`: Fehler vom GlobalSettingsService.
            * `DesktopStateError(#[from] DesktopStateError)`: Fehler vom DesktopState.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/power_management/error.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::error::DomainError`, `crate::global_settings::error::GlobalSettingsError`, `crate::desktop_state::error::DesktopStateError`.
    * **Extern:** `thiserror`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Klar definierte Fehlertypen für das Power Management.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der Fehlerkonstruktion und `From`-Implementierungen.
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/power_management/data_types.rs`

* **Verantwortlichkeit:** Definiert die Datenstrukturen für den Zustand des Power Managements und zugehörige Ereignisse.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `PowerAction` definieren:** Mögliche Aktionen für das Power Management.
        * `#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]`
        * Varianten: `Suspend`, `Hibernate`, `Shutdown`, `Reboot`, `LockScreen`.
    2.  **Struktur `BatteryState` definieren:** Aktueller Batteriestatus.
        * `#[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]`
        * Felder: `percentage: f64`, `is_charging: bool`, `time_to_empty_s: Option<i64>`, `time_to_full_s: Option<i64>`.
    3.  **Enum `DisplayPowerState` definieren:** Zustand des Displays.
        * `#[derive(Debug, Clone, PartialEq, Eq, Default, Serialize, Deserialize)]`
        * Varianten: `On`, `Off`, `Dimmed`.
    4.  **Enum `PowerManagementEvent` definieren:** Ereignisse, die vom Power Manager ausgesendet werden.
        * `#[derive(Debug, Clone, PartialEq)]`
        * Varianten:
            * `BatteryStateChanged(BatteryState)`
            * `DisplayPowerStateChanged(DisplayPowerState)`
            * `SystemWillSuspend`
            * `SystemResumed`
            * `LidClosed`
            * `LidOpened`
            * `LowBatteryWarning(f64)`
            * `CriticalBatteryWarning(f64)`
            * `PowerSourceChanged` (AC/Battery)
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/power_management/data_types.rs`
* **Abhängigkeiten:**
    * **Extern:** `serde::{Serialize, Deserialize}`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Gut definierte Datenmodelle für Power Management.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:** Testen der `Default`, `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` (wo zutreffend) und Serialisierung/Deserialisierung.
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/power_management/control_iface.rs`

* **Verantwortlichkeit:** Definiert Traits für die Steuerung von Power-Management-Funktionen. Dies ermöglicht eine Abstraktion der darunterliegenden System-Implementierung.
* **Kern-Aufgaben (Tasks):**
    1.  **Trait `SystemPowerControl` definieren:**
        * Asynchrones Trait.
        * Methode `suspend(&self) -> Result<(), PowerManagementError>`.
        * Methode `hibernate(&self) -> Result<(), PowerManagementError>`.
        * Methode `shutdown(&self) -> Result<(), PowerManagementError>`.
        * Methode `reboot(&self) -> Result<(), PowerManagementError>`.
        * Methode `can_suspend(&self) -> bool`.
        * Methode `can_hibernate(&self) -> bool`.
        * Methode `can_shutdown(&self) -> bool`.
        * Methode `can_reboot(&self) -> bool`.
    2.  **Trait `DisplayPowerControl` definieren:**
        * Asynchrones Trait.
        * Methode `set_dpms_state(&self, state: DisplayPowerState) -> Result<(), PowerManagementError>`.
        * Methode `get_dpms_state(&self) -> Result<DisplayPowerState, PowerManagementError>`.
    3.  **Trait `PowerStateProvider` definieren:**
        * Asynchrones Trait.
        * Methode `get_battery_state(&self) -> Result<BatteryState, PowerManagementError>`.
        * Methode `is_on_ac_power(&self) -> Result<bool, PowerManagementError>`.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/power_management/control_iface.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::power_management::error::PowerManagementError`, `crate::power_management::data_types::{BatteryState, DisplayPowerState}`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Klare Abstraktionen für die Interaktion mit dem Power-Management auf Systemebene.
* **Teststrategie (Modul-spezifisch):** Keine Tests direkt für Traits.
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/power_management/service.rs`

* **Verantwortlichkeit:** Implementiert die Geschäftslogik für das Power Management. Dazu gehören das Überwachen des Batteriestatus, das Reagieren auf Lid-Events, das Steuern des Display-Zustands und das Ausführen von System-Power-Aktionen basierend auf Konfiguration und Systemereignissen.
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `PowerManagementService` definieren:**
        * Felder:
            * `settings_service: Arc<GlobalSettingsService>`: Für Schwellenwerte, automatische Suspend-Einstellungen.
            * `logind_client: Arc<dyn SystemPowerControl>`: Implementierung der System-Power-Aktionen.
            * `upower_client: Arc<dyn PowerStateProvider>`: Implementierung des Batteriestatus-Providers.
            * `display_power_control: Arc<dyn DisplayPowerControl>`: Steuerung des Display-DPMS-Zustands.
            * `desktop_state: Arc<RwLock<DesktopState>>`: Für den aktuellen Desktop-Zustand (z.B. ob der Bildschirm gesperrt ist).
            * `event_sender: tokio::sync::broadcast::Sender<PowerManagementEvent>`: Für Benachrichtigungen über Power-Events.
            * `internal_state: Arc<RwLock<InternalPowerState>>` (private Struktur für internen Zustand: `current_battery_state`, `current_display_power_state`, `is_lid_closed`).
    2.  **Konstruktor `new()` implementieren:** Initialisiert den Service mit allen Abhängigkeiten.
    3.  **Methode `run_event_loop()` implementieren:**
        * Asynchrone Endlosschleife, die periodisch (z.B. alle 10-30 Sekunden) den Batteriestatus über `upower_client` abfragt.
        * Überwacht Events von `logind` und `UPower` (diese kommen aus der Systemschicht, z.B. über D-Bus).
        * Verarbeitet `LidClosed`/`LidOpened`-Ereignisse und passt Display-Zustand oder Suspend-Verhalten an basierend auf `settings_service` und `desktop_state`.
        * Prüft auf niedrigen/kritischen Batteriestatus und sendet entsprechende `PowerManagementEvent::LowBatteryWarning`/`CriticalBatteryWarning`.
        * Passt den DPMS-Zustand des Displays an basierend auf `settings_service` (Inaktivitäts-Timeout).
        * Sendet alle relevanten `PowerManagementEvent` über `event_sender`.
        * Aktualisiert `desktop_state` mit relevanten Power-Informationen.
    4.  **Methoden `suspend()`, `hibernate()`, `shutdown()`, `reboot()`, `lock_screen()` implementieren:**
        * Rufen die entsprechenden Methoden auf `logind_client` auf.
        * `lock_screen()` würde den `DesktopState` aktualisieren und ein `DesktopEvent::LockScreenRequested` senden (was dann vom Compositor oder der UI gehandhabt wird).
        * Fehler von den Clients in `PowerManagementError` umwandeln.
    5.  **Methode `get_current_battery_state() -> Result<BatteryState, PowerManagementError>` implementieren:** Ruft `upower_client.get_battery_state()` auf.
    6.  **Methode `set_display_power_state(state: DisplayPowerState) -> Result<(), PowerManagementError>` implementieren:** Ruft `display_power_control.set_dpms_state()` auf.
    7.  **Fehlerbehandlung:** Alle Methoden sollten `Result<T, PowerManagementError>` zurückgeben.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/power_management/service.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::power_management::data_types::{BatteryState, DisplayPowerState, PowerAction, PowerManagementEvent}`
        * `crate::power_management::error::PowerManagementError`
        * `crate::power_management::control_iface::{SystemPowerControl, DisplayPowerControl, PowerStateProvider}`
        * `crate::global_settings::service::GlobalSettingsService`
        * `crate::desktop_state::DesktopState`
    * **Extern:** `tokio`, `std::sync::{Arc, RwLock}`, `tokio::sync::broadcast`, `tracing`, `std::time::Duration`.
* **Kommunikationsmuster:**
    * Empfängt Events von `logind_client` und `upower_client` (Systemschicht).
    * Interagiert mit `settings_service` für Konfiguration.
    * Aktualisiert `desktop_state`.
    * Sendet `PowerManagementEvent` an UI-Schicht (z.B. Panel, Settings UI).
    * Die UI-Schicht ruft Aktionen wie `suspend()` auf.
* **Erwartete Ergebnisse/Outputs:** Ein robuster Power Management Dienst, der Systemzustände überwacht und Aktionen ausführen kann.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Mocking aller externen Abhängigkeiten (`SystemPowerControl`, `DisplayPowerControl`, `PowerStateProvider`, `GlobalSettingsService`, `DesktopState`).
        * Testen der `run_event_loop` Logik: periodisches Abfragen, Event-Aussendung bei Schwellenwerten, Reaktion auf Lid-Events.
        * Testen der `suspend`, `hibernate` etc. Methoden: Sicherstellen, dass die richtigen Methoden auf den Mocks aufgerufen werden und Fehler korrekt propagiert werden.
        * Testen des Verhaltens bei verschiedenen Konfigurationen (aus `settings_service`).
        * Testen der Aktualisierung des `desktop_state`.
    * **Integration Tests:**
        * Testen des Zusammenspiels mit echten (aber simulierbaren) `logind` und `UPower` D-Bus-Implementierungen (wenn vorhanden, sonst End-to-End Tests auf Compositor-Ebene).
* **Geschätzter Aufwand:** Hoch

#### `novade-domain/src/power_management/mod.rs`

* **Verantwortlichkeit:** Definiert die öffentliche Schnittstelle des `power_management`-Moduls.
* **Kern-Aufgaben (Tasks):**
    1.  **Re-Exports:** Exportiert die wichtigsten Typen (`PowerAction`, `BatteryState`, `DisplayPowerState`, `PowerManagementEvent`, `PowerManagementError`, `SystemPowerControl`, `DisplayPowerControl`, `PowerStateProvider`, `PowerManagementService`) aus den Untermodulen.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/power_management/mod.rs`
* **Abhängigkeiten:** Keine direkten, re-exportiert aus `data_types.rs`, `error.rs`, `control_iface.rs`, `service.rs`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Eine saubere, einheitliche API für das `power_management`-Modul.
* **Teststrategie (Modul-spezifisch):** Verifizierung der Re-Exports (minimal).
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/screenshot/error.rs`

* **Verantwortlichkeit:** Definiert spezifische Fehlertypen für das `screenshot`-Modul.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `ScreenshotError` definieren:**
        * Verwende `thiserror::Error` und `#[derive(Debug)]`.
        * Definiere Varianten für typische Fehler:
            * `PortalError(String)`: Fehler bei der Kommunikation mit dem Freedesktop Screenshot Portal.
            * `IoError(#[from] io::Error)`: Fehler bei Dateisystemoperationen.
            * `InvalidFormat(String)`: Ungültiges Bildformat.
            * `ClipboardError(String)`: Fehler beim Kopieren in die Zwischenablage.
            * `NoScreenshotData`: Es wurden keine Screenshot-Daten empfangen.
            * `ServiceUnavailable`: Das Screenshot-Portal ist nicht verfügbar.
            * `Other(String)`: Ein allgemeiner, nicht kategorisierter Fehler.
* **Spezifische Artefekte/Dateien:**
    * `novade-domain/src/screenshot/error.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::error::DomainError`.
    * **Extern:** `thiserror`, `std::io`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Klar definierte, nachvollziehbare Fehlertypen für Screenshots.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:** Testen der Fehlerkonstruktion und `From`-Implementierungen.
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/screenshot/data_types.rs`

* **Verantwortlichkeit:** Definiert Datenstrukturen für Screenshot-Optionen und -Ergebnisse.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `ScreenshotType` definieren:** Art des Screenshots.
        * `#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]`
        * Varianten: `FullDesktop`, `ActiveWindow`, `Region`.
    2.  **Enum `ScreenshotFormat` definieren:** Speicherformat des Screenshots.
        * `#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]`
        * Varianten: `Png`, `Jpeg`.
    3.  **Struktur `ScreenshotOptions` definieren:** Konfiguration für die Aufnahme eines Screenshots.
        * `#[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]`
        * Felder:
            * `screenshot_type: ScreenshotType`
            * `save_to_file: bool`
            * `copy_to_clipboard: bool`
            * `file_format: ScreenshotFormat`
            * `output_dir: Option<PathBuf>` (wenn `save_to_file` true ist)
    4.  **Struktur `ScreenshotResult` definieren:** Ergebnis eines Screenshot-Vorgangs.
        * `#[derive(Debug, Clone, PartialEq)]`
        * Felder:
            * `file_path: Option<PathBuf>` (wenn in Datei gespeichert)
            * `image_data: Option<Vec<u8>>` (rohe Bilddaten, wenn nicht in Datei gespeichert, oder für Zwischenablage)
            * `mime_type: Option<String>` (MIME-Typ der Bilddaten)
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/screenshot/data_types.rs`
* **Abhängigkeiten:**
    * **Extern:** `serde::{Serialize, Deserialize}`, `std::path::PathBuf`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Klare und konsistente Datenmodelle für Screenshots.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:** Testen der `Default`, `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` (wo zutreffend) und Serialisierung/Deserialisierung.
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/screenshot/service.rs`

* **Verantwortlichkeit:** Implementiert die Geschäftslogik für die Aufnahme und Verarbeitung von Screenshots, primär durch Interaktion mit dem XDG-Desktop-Portal.
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `ScreenshotService` definieren:**
        * Feld `portal_client: Arc<dyn ScreenshotPortalClient>`: Abstraktion für die Kommunikation mit dem XDG-Screenshot-Portal.
        * Feld `event_sender: tokio::sync::broadcast::Sender<ScreenshotEvent>`: Für Benachrichtigungen.
        * Feld `config_service: Arc<ConfigServiceAsync>`: Für Standard-Speicherpfade.
    2.  **Konstruktor `new()` implementieren:** Initialisiert den Service.
    3.  **Methode `take_screenshot(options: ScreenshotOptions) -> Result<ScreenshotResult, ScreenshotError>` implementieren:**
        * Ruft die entsprechende Methode auf `portal_client` basierend auf `options.screenshot_type` auf.
        * Wenn `ScreenshotType::Region`, öffne einen temporären Selector (dies wird vom Portal oder vom Compositor über das Portal bereitgestellt).
        * Empfängt die Bilddaten vom Portal.
        * Wenn `options.save_to_file` ist:
            * Konstruiere einen Dateipfad (nutze `output_dir` oder Standardpfad aus `config_service`).
            * Speichere die Bilddaten im spezifizierten `file_format`.
            * Behandle `io::Error`.
        * Wenn `options.copy_to_clipboard` ist:
            * Kopiere die Bilddaten (ggf. als Base64-String oder direkten Bilddaten-MIME-Typ) in die Zwischenablage (über eine Abstraktion in der Systemschicht).
            * Behandle `ClipboardError`.
        * Erstellt und gibt `ScreenshotResult` zurück.
        * Sendet `ScreenshotEvent::ScreenshotTaken(ScreenshotResult)` über `event_sender`.
    4.  **Methode `can_take_screenshot() -> bool` implementieren:** Prüft, ob das Portal verfügbar ist (über `portal_client`).
    5.  **Fehlerbehandlung:** Alle Methoden geben `Result<T, ScreenshotError>` zurück.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/screenshot/service.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::screenshot::data_types::{ScreenshotOptions, ScreenshotType, ScreenshotFormat, ScreenshotResult}`
        * `crate::screenshot::error::ScreenshotError`
        * `crate::screenshot::portal_iface::ScreenshotPortalClient`
        * `crate::config::service::ConfigServiceAsync`
    * **Extern:** `tokio`, `std::sync::Arc`, `tokio::sync::broadcast`, `tracing`. Image-Bearbeitungsbibliothek (z.B. `image` crate) für Formatkonvertierung/Speicherung. Eine `clipboard` Abstraktion (Systemschicht).
* **Kommunikationsmuster:**
    * Interagiert mit `ScreenshotPortalClient` (Systemschicht).
    * Interagiert mit `ConfigServiceAsync` für Dateipfade.
    * Sendet `ScreenshotEvent` an UI-Schicht (z.B. für Benachrichtigungen).
* **Erwartete Ergebnisse/Outputs:** Ein Dienst, der Screenshots aufnehmen und speichern/kopieren kann.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Mocking von `ScreenshotPortalClient`, `ConfigServiceAsync` und der `Clipboard` Abstraktion.
        * Testen von `take_screenshot` für alle `ScreenshotType` und `ScreenshotFormat`.
        * Testen der Dateispeicherung (mit Mock-Dateisystem).
        * Testen des Kopierens in die Zwischenablage.
        * Testen der Event-Aussendung.
        * Testen von Fehlerfällen vom Portal, I/O-Fehlern, etc.
* **Geschätzter Aufwand:** Mittel

#### `novade-domain/src/screenshot/portal_iface.rs`

* **Verantwortlichkeit:** Definiert das Trait für die Interaktion mit dem Freedesktop Screenshot Portal, um die Abhängigkeit von der konkreten Implementierung (z.B. D-Bus) zu abstrahieren.
* **Kern-Aufgaben (Tasks):**
    1.  **Trait `ScreenshotPortalClient` definieren:**
        * Asynchrones Trait.
        * Methode `take_full_desktop_screenshot(&self, options: &ScreenshotOptions) -> Result<Vec<u8>, ScreenshotError>`: Nimmt Desktop-Screenshot auf.
        * Methode `take_active_window_screenshot(&self, options: &ScreenshotOptions) -> Result<Vec<u8>, ScreenshotError>`: Nimmt aktives Fenster auf.
        * Methode `take_region_screenshot(&self, options: &ScreenshotOptions) -> Result<Vec<u8>, ScreenshotError>`: Nimmt Region auf.
        * Methode `is_available(&self) -> bool`: Prüft Verfügbarkeit des Portals.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/screenshot/portal_iface.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::screenshot::error::ScreenshotError`, `crate::screenshot::data_types::ScreenshotOptions`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Eine klare Abstraktion für den Zugriff auf das Screenshot-Portal.
* **Teststrategie (Modul-spezifisch):** Keine Tests direkt für Traits.
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/screenshot/mod.rs`

* **Verantwortlichkeit:** Definiert die öffentliche Schnittstelle des `screenshot`-Moduls.
* **Kern-Aufgaben (Tasks):**
    1.  **Re-Exports:** Exportiert die wichtigsten Typen (`ScreenshotType`, `ScreenshotFormat`, `ScreenshotOptions`, `ScreenshotResult`, `ScreenshotError`, `ScreenshotPortalClient`, `ScreenshotService`) aus den Untermodulen.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/screenshot/mod.rs`
* **Abhängigkeiten:** Keine direkten, re-exportiert aus `data_types.rs`, `error.rs`, `portal_iface.rs`, `service.rs`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Eine saubere, einheitliche API für das `screenshot`-Modul.
* **Teststrategie (Modul-spezifisch):** Verifizierung der Re-Exports (minimal).
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/clipboard/error.rs`

* **Verantwortlichkeit:** Definiert spezifische Fehlertypen für das `clipboard`-Modul.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `ClipboardError` definieren:**
        * Verwende `thiserror::Error` und `#[derive(Debug)]`.
        * Definiere Varianten für typische Fehler:
            * `SystemError(String)`: Ein Fehler auf Systemebene (z.B. Wayland, X11).
            * `InvalidFormat(String)`: Daten konnten nicht in gewünschtem Format gelesen/geschrieben werden.
            * `NotSupported`: Die angeforderte Operation wird nicht unterstützt.
            * `IoError(#[from] io::Error)`: Allgemeine I/O-Fehler.
            * `Other(String)`: Ein allgemeiner Fehler.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/clipboard/error.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::error::DomainError`.
    * **Extern:** `thiserror`, `std::io`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Klar definierte, nachvollziehbare Fehlertypen für die Zwischenablage.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:** Testen der Fehlerkonstruktion und `From`-Implementierungen.
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/clipboard/data_types.rs`

* **Verantwortlichkeit:** Definiert Datenstrukturen für Zwischenablage-Inhalte und zugehörige Ereignisse.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `ClipboardContentType` definieren:** Typen von Inhalten in der Zwischenablage.
        * `#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]`
        * Varianten: `Text`, `Image`, `File`, `Other(String)` (für benutzerdefinierte MIME-Typen).
    2.  **Struktur `ClipboardContent` definieren:** Inhalt der Zwischenablage.
        * `#[derive(Debug, Clone, PartialEq)]`
        * Felder: `content_type: ClipboardContentType`, `data: Vec<u8>`.
    3.  **Enum `ClipboardEvent` definieren:** Ereignisse bezüglich der Zwischenablage.
        * `#[derive(Debug, Clone, PartialEq)]`
        * Varianten: `ContentChanged(ClipboardContent)`, `Cleared`.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/clipboard/data_types.rs`
* **Abhängigkeiten:**
    * **Extern:** `serde::{Serialize, Deserialize}`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Gut definierte Datenmodelle für Zwischenablage-Interaktionen.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:** Testen der `Default` (wo zutreffend), `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` (wo zutreffend) und Serialisierung/Deserialisierung.
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/clipboard/service.rs`

* **Verantwortlichkeit:** Implementiert die Geschäftslogik für die Zwischenablage, abstrahiert die Interaktion mit dem System.
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `ClipboardService` definieren:**
        * Feld `system_clipboard: Arc<dyn SystemClipboardBackend>`: Abstraktion zur System-Zwischenablage.
        * Feld `event_sender: tokio::sync::broadcast::Sender<ClipboardEvent>`: Für Benachrichtigungen.
    2.  **Konstruktor `new()` implementieren:** Initialisiert den Service.
    3.  **Methode `set_clipboard_content(content: ClipboardContent) -> Result<(), ClipboardError>` implementieren:**
        * Setzt den Inhalt der Zwischenablage über `system_clipboard`.
        * Sendet `ClipboardEvent::ContentChanged` über `event_sender`.
    4.  **Methode `get_clipboard_content(preferred_type: Option<ClipboardContentType>) -> Result<Option<ClipboardContent>, ClipboardError>` implementieren:**
        * Holt den Inhalt der Zwischenablage über `system_clipboard`.
        * Versucht, das bevorzugte Format zu erhalten, ansonsten ein verfügbares Format.
    5.  **Methode `clear_clipboard() -> Result<(), ClipboardError>` implementieren:**
        * Löscht den Inhalt der Zwischenablage über `system_clipboard`.
        * Sendet `ClipboardEvent::Cleared` über `event_sender`.
    6.  **Asynchrone Event-Verarbeitung:** Der Service muss in der Lage sein, auf `ContentChanged` Events vom `SystemClipboardBackend` zu reagieren und diese als `ClipboardEvent::ContentChanged` weiterzuleiten (Dies erfordert typischerweise einen `run` oder `spawn_event_listener` Methode).
    7.  **Fehlerbehandlung:** Alle Methoden geben `Result<T, ClipboardError>` zurück.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/clipboard/service.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::clipboard::data_types::{ClipboardContent, ClipboardContentType, ClipboardEvent}`
        * `crate::clipboard::error::ClipboardError`
        * `crate::clipboard::backend_iface::SystemClipboardBackend`
    * **Extern:** `tokio`, `std::sync::Arc`, `tokio::sync::broadcast`, `tracing`.
* **Kommunikationsmuster:**
    * Interagiert mit `SystemClipboardBackend` (Systemschicht).
    * Sendet `ClipboardEvent` an UI-Schicht (z.B. für History, Paste-Menüs).
    * Empfängt Events von `SystemClipboardBackend`.
* **Erwartete Ergebnisse/Outputs:** Ein robuster Zwischenablage-Dienst.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Mocking von `SystemClipboardBackend`.
        * Testen von `set_clipboard_content`, `get_clipboard_content`, `clear_clipboard`.
        * Testen der Event-Aussendung.
        * Testen der Event-Weiterleitung von `SystemClipboardBackend`.
        * Testen von Fehlerfällen vom Backend.
* **Geschätzter Aufwand:** Mittel

#### `novade-domain/src/clipboard/backend_iface.rs`

* **Verantwortlichkeit:** Definiert das Trait für die Interaktion mit der tatsächlichen System-Zwischenablage (z.B. Wayland `wl_data_device_manager`).
* **Kern-Aufgaben (Tasks):**
    1.  **Trait `SystemClipboardBackend` definieren:**
        * Asynchrones Trait.
        * Methode `set_primary_clipboard_content(&self, content: &ClipboardContent) -> Result<(), ClipboardError>`.
        * Methode `get_primary_clipboard_content(&self, preferred_type: Option<ClipboardContentType>) -> Result<Option<ClipboardContent>, ClipboardError>`.
        * Methode `set_selection_clipboard_content(&self, content: &ClipboardContent) -> Result<(), ClipboardError>` (für X11-ähnliche primäre Auswahl).
        * Methode `get_selection_clipboard_content(&self, preferred_type: Option<ClipboardContentType>) -> Result<Option<ClipboardContent>, ClipboardError>`.
        * Methode `get_clipboard_event_receiver(&self) -> tokio::sync::broadcast::Receiver<ClipboardEvent>`: Für Events von Änderungen durch andere Anwendungen.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/clipboard/backend_iface.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::clipboard::error::ClipboardError`, `crate::clipboard::data_types::{ClipboardContent, ClipboardContentType, ClipboardEvent}`.
    * **Extern:** `tokio::sync::broadcast`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Eine klare Abstraktion für den Zugriff auf die System-Zwischenablage.
* **Teststrategie (Modul-spezifisch):** Keine Tests direkt für Traits.
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/clipboard/mod.rs`

* **Verantwortlichkeit:** Definiert die öffentliche Schnittstelle des `clipboard`-Moduls.
* **Kern-Aufgaben (Tasks):**
    1.  **Re-Exports:** Exportiert die wichtigsten Typen (`ClipboardContentType`, `ClipboardContent`, `ClipboardEvent`, `ClipboardError`, `SystemClipboardBackend`, `ClipboardService`) aus den Untermodulen.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/clipboard/mod.rs`
* **Abhängigkeiten:** Keine direkten, re-exportiert aus `data_types.rs`, `error.rs`, `backend_iface.rs`, `service.rs`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Eine saubere, einheitliche API für das `clipboard`-Modul.
* **Teststrategie (Modul-spezifisch):** Verifizierung der Re-Exports (minimal).
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/application_launcher/error.rs`

* **Verantwortlichkeit:** Definiert spezifische Fehlertypen für das `application_launcher`-Modul.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `ApplicationLauncherError` definieren:**
        * Verwende `thiserror::Error` und `#[derive(Debug)]`.
        * Definiere Varianten für typische Fehler:
            * `IoError(#[from] io::Error)`: Fehler beim Lesen von `.desktop`-Dateien.
            * `ParseError(String)`: Fehler beim Parsen von `.desktop`-Dateien.
            * `ApplicationNotFound(String)`: Die angeforderte Anwendung wurde nicht gefunden.
            * `ExecutionError(String)`: Fehler beim Starten der Anwendung.
            * `InvalidDesktopEntry(String)`: Ungültiger oder unvollständiger Desktop Entry.
            * `DBusError(String)`: Fehler bei D-Bus-Kommunikation (z.B. beim Starten von Anwendungen über D-Bus).
            * `Other(String)`: Ein allgemeiner Fehler.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/application_launcher/error.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::error::DomainError`.
    * **Extern:** `thiserror`, `std::io`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Klar definierte, nachvollziehbare Fehlertypen für den Anwendungsstarter.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:** Testen der Fehlerkonstruktion und `From`-Implementierungen.
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/application_launcher/data_types.rs`

* **Verantwortlichkeit:** Definiert die Datenstrukturen für Anwendungsdefinitionen und zugehörige Ereignisse.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `ApplicationType` definieren:** Typ der Anwendung (GUI, Terminal, Web).
        * `#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]`
        * Varianten: `Graphical`, `Terminal`, `WebBrowser`, `Utility`, `Development`, `Other`.
    2.  **Struktur `DesktopEntry` definieren:** Repräsentiert eine Anwendung basierend auf einer `.desktop`-Datei.
        * `#[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]`
        * Felder:
            * `id: String` (z.B. `firefox.desktop`)
            * `name: String`
            * `generic_name: Option<String>`
            * `comment: Option<String>`
            * `icon_name: Option<String>` (Name des Icons, nicht der Pfad)
            * `exec: String` (Befehl zum Ausführen)
            * `path: Option<PathBuf>` (Arbeitsverzeichnis)
            * `terminal: bool`
            * `no_display: bool`
            * `hidden: bool`
            * `categories: Vec<String>`
            * `keywords: Vec<String>`
            * `mime_types: Vec<String>`
            * `startup_notify: bool`
            * `application_type: ApplicationType`
            * `dbus_startup_id: Option<String>` (Für D-Bus-basierte Starts)
            * `file_path: PathBuf` (Pfad zur .desktop-Datei)
            * `is_favorite: bool` (Nicht aus .desktop, sondern internem Zustand)
            * `last_launched: Option<DateTime<Utc>>` (Nicht aus .desktop, sondern internem Zustand)
    3.  **Enum `ApplicationEvent` definieren:** Ereignisse vom Application Launcher.
        * `#[derive(Debug, Clone, PartialEq)]`
        * Varianten: `ApplicationsUpdated`, `ApplicationLaunched(String)`.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/application_launcher/data_types.rs`
* **Abhängigkeiten:**
    * **Intern:** Keine.
    * **Extern:** `serde::{Serialize, Deserialize}`, `std::path::PathBuf`, `chrono::{DateTime, Utc}`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Gut definierte Datenmodelle für Anwendungen.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:** Testen der `Default` (wo zutreffend), `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` (wo zutreffend) und Serialisierung/Deserialisierung.
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/application_launcher/desktop_entry_parser.rs`

* **Verantwortlichkeit:** Implementiert die Logik zum Parsen von `.desktop`-Dateien gemäß dem Freedesktop Desktop Entry Specification.
* **Kern-Aufgaben (Tasks):**
    1.  **Funktion `parse_desktop_file(path: &Path) -> Result<DesktopEntry, ApplicationLauncherError>` implementieren:**
        * Lese den Inhalt der `.desktop`-Datei.
        * Nutze eine geeignete Parsing-Bibliothek (z.B. `ini` oder manuelles Parsen).
        * Extrahiere die relevanten Felder (`Name`, `GenericName`, `Comment`, `Icon`, `Exec`, `Path`, `Terminal`, `NoDisplay`, `Hidden`, `Categories`, `Keywords`, `MimeType`, `StartupNotify`, `Type`, `DBusActivatable`).
        * Wende Standardwerte an, wo nicht vorhanden.
        * Überprüfe auf kritische fehlende Felder (`Name`, `Exec`).
        * Konvertiere `Type` zu `ApplicationType`.
        * Fülle die `DesktopEntry`-Struktur.
        * Behandle Parsing-Fehler und I/O-Fehler als `ApplicationLauncherError`.
    2.  **Hilfsfunktionen:**
        * `parse_list_value(value: &str) -> Vec<String>`: Für kommagetrennte Listen.
        * `parse_bool_value(value: &str) -> bool`: Robuster Bool-Parser.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/application_launcher/desktop_entry_parser.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::application_launcher::data_types::{DesktopEntry, ApplicationType}`
    * `crate::application_launcher::error::ApplicationLauncherError`
    * **Extern:** `std::fs`, `std::path::Path`, `ini` crate (empfohlen).
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Korrekt geparste `DesktopEntry`-Objekte.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen mit gültigen `.desktop`-Dateien (verschiedene Varianten, mit/ohne optionale Felder).
        * Testen mit ungültigen/fehlerhaften `.desktop`-Dateien (fehlende Pflichtfelder, falsche Syntax, falsche Typen).
        * Testen von Edge-Cases (leere Dateien, große Dateien).
        * Testen der `parse_list_value` und `parse_bool_value` Hilfsfunktionen.
* **Geschätzter Aufwand:** Mittel

#### `novade-domain/src/application_launcher/favorites_persistence.rs`

* **Verantwortlichkeit:** Behandelt die Persistenz der Favoriten-Liste und der Startzeiten von Anwendungen.
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `FavoritesPersistence` definieren:**
        * Feld `config_service: Arc<ConfigServiceAsync>`: Zum Ermitteln von Konfigurationspfaden.
        * Feld `file_path: PathBuf`: Pfad zur Favoriten-/Startzeit-Datei.
    2.  **Struktur `PersistedAppData` definieren:** Interne Struktur für die zu persistierenden Daten.
        * `#[derive(Serialize, Deserialize)]`
        * Felder: `favorites: Vec<String>` (Liste der DesktopEntry-IDs), `last_launched: HashMap<String, DateTime<Utc>>` (Mapping von DesktopEntry-ID zu letztem Startzeitpunkt).
    3.  **Konstruktor `new(config_service: Arc<ConfigServiceAsync>) -> Self` implementieren:** Ermittelt den Dateipfad.
    4.  **Methode `load_data() -> Result<PersistedAppData, ApplicationLauncherError>` implementieren:**
        * Liest die JSON-Datei.
        * Deserealisiert den Inhalt.
        * Behandelt `io::Error::NotFound` als leere `PersistedAppData`.
    5.  **Methode `save_data(data: &PersistedAppData) -> Result<(), ApplicationLauncherError>` implementieren:**
        * Serialisiert die Daten in JSON.
        * Schreibt sie atomar in die Datei.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/application_launcher/favorites_persistence.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::config::service::ConfigServiceAsync`, `crate::application_launcher::error::ApplicationLauncherError`.
    * **Extern:** `tokio::fs`, `serde_json`, `std::path::PathBuf`, `std::sync::Arc`, `chrono::{DateTime, Utc}`, `std::collections::HashMap`.
* **Kommunikationsmuster:** Greift auf `ConfigServiceAsync` zu.
* **Erwartete Ergebnisse/Outputs:** Robuste Persistenz für Anwendungsfavoriten und Startzeiten.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Mocking von `ConfigServiceAsync`.
        * Testen von `load_data` mit existierender, leerer, ungültiger und nicht existierender Datei.
        * Testen von `save_data` und anschließendem `load_data`.
        * Testen von Fehlerfällen (Berechtigungen etc.).
* **Geschätzter Aufwand:** Mittel

#### `novade-domain/src/application_launcher/service.rs`

* **Verantwortlichkeit:** Implementiert die Geschäftslogik für den Anwendungsstarter: Indizieren von `.desktop`-Dateien, Starten von Anwendungen, Verwalten von Favoriten und Startzeiten.
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `ApplicationLauncherService` definieren:**
        * Felder:
            * `applications: Arc<RwLock<Vec<DesktopEntry>>>`: Cache der aktuell erkannten Anwendungen.
            * `favorites_persistence: Arc<FavoritesPersistence>`: Für Favoriten und Startzeiten.
            * `config_service: Arc<ConfigServiceAsync>`: Für XDG-Basispfade.
            * `system_launcher: Arc<dyn SystemApplicationLauncherBackend>`: Abstraktion für den eigentlichen Startbefehl.
            * `event_sender: tokio::sync::broadcast::Sender<ApplicationEvent>`: Für Benachrichtigungen.
    2.  **Konstruktor `new()` implementieren:** Initialisiert den Service und lädt initial Anwendungen und Persistenzdaten.
    3.  **Methode `initialize()` implementieren (asynchron):**
        * Durchsucht XDG-Standardpfade (`XDG_DATA_DIRS`) nach `.desktop`-Dateien.
        * Nutzt `desktop_entry_parser` zum Parsen jeder gefundenen Datei.
        * Läd Favoriten und Startzeiten über `favorites_persistence`.
        * Aktualisiert `applications` und `DesktopEntry::is_favorite`, `DesktopEntry::last_launched`.
        * Setzt `applications` im `RwLock`.
        * Sendet `ApplicationEvent::ApplicationsUpdated`.
    4.  **Methode `get_all_applications() -> Vec<DesktopEntry>` implementieren:** Gibt alle erkannten Anwendungen zurück (sortiert nach `last_launched` oder Alphabet).
    5.  **Methode `get_favorite_applications() -> Vec<DesktopEntry>` implementieren:** Gibt nur Favoriten zurück.
    6.  **Methode `add_to_favorites(app_id: &str) -> Result<(), ApplicationLauncherError>` implementieren:**
        * Findet die Anwendung nach ID.
        * Fügt sie zur Favoritenliste hinzu.
        * Speichert über `favorites_persistence`.
        * Aktualisiert `applications` und sendet `ApplicationsUpdated`.
    7.  **Methode `remove_from_favorites(app_id: &str) -> Result<(), ApplicationLauncherError>` implementieren:**
        * Entfernt Anwendung aus Favoriten.
        * Speichert, aktualisiert, sendet Event.
    8.  **Methode `launch_application(app_id: &str, args: &[String]) -> Result<(), ApplicationLauncherError>` implementieren:**
        * Findet die `DesktopEntry` nach `app_id`.
        * Ruft `system_launcher.launch()` auf.
        * Aktualisiert `last_launched` für die Anwendung und speichert über `favorites_persistence`.
        * Sendet `ApplicationEvent::ApplicationLaunched`.
    9.  **Fehlerbehandlung:** Alle Methoden geben `Result<T, ApplicationLauncherError>` zurück.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/application_launcher/service.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::application_launcher::data_types::{DesktopEntry, ApplicationEvent}`
        * `crate::application_launcher::error::ApplicationLauncherError`
        * `crate::application_launcher::desktop_entry_parser`
        * `crate::application_launcher::favorites_persistence::FavoritesPersistence`
        * `crate::application_launcher::backend_iface::SystemApplicationLauncherBackend`
        * `crate::config::service::ConfigServiceAsync`
    * **Extern:** `tokio`, `std::sync::{Arc, RwLock}`, `tokio::sync::broadcast`, `tracing`, `chrono::{DateTime, Utc}`.
* **Kommunikationsmuster:**
    * Interagiert mit `FavoritesPersistence` für Persistenz.
    * Interagiert mit `ConfigServiceAsync` für XDG-Pfade.
    * Interagiert mit `SystemApplicationLauncherBackend` (Systemschicht) für den Startbefehl.
    * Sendet `ApplicationEvent` an UI-Schicht (z.B. App-Launcher, Dock).
* **Erwartete Ergebnisse/Outputs:** Ein robuster Anwendungsstarter, der Anwendungen finden, verwalten und starten kann.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Mocking aller Abhängigkeiten (`FavoritesPersistence`, `ConfigServiceAsync`, `SystemApplicationLauncherBackend`).
        * Testen von `initialize` mit Mock-Dateisystem, das `.desktop`-Dateien enthält.
        * Testen von `get_all_applications` und `get_favorite_applications` nach Änderungen.
        * Testen von `add_to_favorites` und `remove_from_favorites`.
        * Testen von `launch_application` (Sicherstellen, dass `system_launcher.launch` aufgerufen wird).
        * Testen der Event-Aussendung.
        * Testen von Fehlerfällen (App nicht gefunden, Startfehler).
* **Geschätzter Aufwand:** Hoch

#### `novade-domain/src/application_launcher/backend_iface.rs`

* **Verantwortlichkeit:** Definiert das Trait für die Interaktion mit dem System, um Anwendungen zu starten.
* **Kern-Aufgaben (Tasks):**
    1.  **Trait `SystemApplicationLauncherBackend` definieren:**
        * Asynchrones Trait.
        * Methode `launch(&self, exec_command: &str, path: Option<&Path>, startup_notify: bool, dbus_startup_id: Option<&str>) -> Result<(), ApplicationLauncherError>`: Startet eine Anwendung.
        * Methode `get_icon_path(&self, icon_name: &str, size: u32) -> Result<PathBuf, ApplicationLauncherError>`: Sucht den Pfad zu einem Icon (XDG Icon Theme Specification).
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/application_launcher/backend_iface.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::application_launcher::error::ApplicationLauncherError`.
    * **Extern:** `std::path::Path`, `std::path::PathBuf`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Eine klare Abstraktion für das Starten von Anwendungen.
* **Teststrategie (Modul-spezifisch):** Keine Tests direkt für Traits.
* **Geschätzter Aufwand:** Gering

#### `novade-domain/src/application_launcher/mod.rs`

* **Verantwortlichkeit:** Definiert die öffentliche Schnittstelle des `application_launcher`-Moduls.
* **Kern-Aufgaben (Tasks):**
    1.  **Re-Exports:** Exportiert die wichtigsten Typen (`ApplicationType`, `DesktopEntry`, `ApplicationEvent`, `ApplicationLauncherError`, `ApplicationLauncherService`, `SystemApplicationLauncherBackend`) aus den Untermodulen.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/application_launcher/mod.rs`
* **Abhängigkeiten:** Keine direkten, re-exportiert aus `data_types.rs`, `error.rs`, `desktop_entry_parser.rs`, `favorites_persistence.rs`, `service.rs`, `backend_iface.rs`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Eine saubere, einheitliche API für das `application_launcher`-Modul.
* **Teststrategie (Modul-spezifisch):** Verifizierung der Re-Exports (minimal).
* **Geschätzter Aufwand:** Gering

### Systemschicht (`novade-system`)

Die Systemschicht (`novade-system`) ist verantwortlich für die Interaktion mit dem Betriebssystem, der Hardware und externen Diensten. Sie setzt die Richtlinien der Domänenschicht technisch um und stellt die Basis für die UI-Schicht dar.

#### `novade-system/src/lib.rs`

* **Verantwortlichkeit:** Das Root-Modul der `novade-system`-Crate. Enthält die Hauptinitialisierungslogik und re-exportiert öffentliche Schnittstellen der Submodule.
* **Kern-Aufgaben (Tasks):**
    1.  **Modul-Deklarationen:** Deklariert alle Submodule der Systemschicht (`compositor`, `input`, `dbus_interfaces`, `audio_management`, `mcp_client`, `window_mechanics`, `power_management`, `screenshot`, `clipboard`, `application_launcher`, `startup_manager`, `xdg_portal_interfaces`).
    2.  **Fehler-Aliase:** Importiert `DomainError` und definiert `SystemError` als Top-Level-Fehlertyp.
    3.  **`SystemServices` Struktur definieren:** Eine Struktur, die alle initialisierten Services der Systemschicht als `Arc` oder `Arc<RwLock<T>>` enthält. Diese Struktur wird dem Hauptanwendungslauf übergeben.
        * Felder: `compositor_handle: Arc<CompositorService>`, `input_manager: Arc<InputManagerService>`, `dbus_manager: Arc<DBusManagerService>`, `audio_manager: Arc<AudioManagerService>`, `mcp_client: Arc<MCPClient>`, `power_manager: Arc<PowerManagementSystemBackend>`, `screenshot_portal_client: Arc<ScreenshotPortalBackend>`, `clipboard_backend: Arc<ClipboardSystemBackend>`, `app_launcher_backend: Arc<ApplicationLauncherSystemBackend>`, `startup_manager: Arc<StartupManagerService>`.
    4.  **Funktion `initialize_system_services()` implementieren:**
        * Asynchrone Funktion, die die Kern-Abhängigkeiten entgegennimmt (z.B. `Arc<RwLock<DesktopState>>`, `Arc<DomainServices>`).
        * Initialisiert alle System-Services in der korrekten Reihenfolge, löst Abhängigkeiten auf und registriert Listener für Events, wo nötig.
        * Gibt `SystemServices` zurück.
        * **Initialisierungs-Reihenfolge (Wichtig!):**
            1.  `compositor`: Benötigt `DesktopState`.
            2.  `input`: Benötigt `compositor` für Seat-Management, `DesktopState`.
            3.  `dbus_interfaces`: Benötigt `DomainServices` (für Notifications Server), `compositor` (für Screen-Lock).
            4.  `audio_management`: Benötigt `DomainServices` (AudioService).
            5.  `mcp_client`: Benötigt `DomainServices` (ModelContextService).
            6.  `power_management_backend`: Implementiert `SystemPowerControl`, `DisplayPowerControl`, `PowerStateProvider` Traits für Domain.
            7.  `screenshot_portal_backend`: Implementiert `ScreenshotPortalClient` Trait für Domain.
            8.  `clipboard_backend`: Implementiert `SystemClipboardBackend` Trait für Domain.
            9.  `application_launcher_backend`: Implementiert `SystemApplicationLauncherBackend` Trait für Domain.
            10. `startup_manager`: Verwaltet XDG Autostart.
            11. `xdg_portal_interfaces`: Implementiert die Server-Seite der XDG-Portals für NovaDE.
        * Jeder Service wird als `Arc` oder `Arc<RwLock<T>>` initialisiert.
        * Mögliche Fehler bei der Initialisierung werden als `SystemError` propagiert.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/lib.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `novade-core::error::CoreError`
        * `novade-domain::error::DomainError`
        * `novade-domain::desktop_state::DesktopState`
        * Alle Submodules der `novade-system`-Crate.
    * **Extern:** `thiserror` (für `SystemError`), `std::sync::Arc`, `tokio`.
* **Kommunikationsmuster:** Die Initialisierungsfunktion orchestriert die Abhängigkeiten zwischen den System-Services.
* **Erwartete Ergebnisse/Outputs:** Ein vollständig initialisiertes `SystemServices`-Objekt, das alle System-Komponenten bereitstellt.
* **Teststrategie (Modul-spezifisch):**
    * **Integration Tests:** Testen der `initialize_system_services` Funktion, um sicherzustellen, dass alle Services korrekt initialisiert werden und ihre Abhängigkeiten richtig verdrahtet sind. Mocking von externen Systeminteraktionen, wo dies möglich ist.
* **Geschätzter Aufwand:** Hoch

#### `novade-system/src/error.rs`

* **Verantwortlichkeit:** Definiert den Top-Level-Fehlertyp für die Systemschicht und bietet Konvertierungen von spezifischen System-Fehlern.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `SystemError` definieren:**
        * Verwende `thiserror::Error` und `#[derive(Debug)]`.
        * Definiere allgemeine Varianten:
            * `InitializationError(String)`: Fehler bei der System-Initialisierung.
            * `DBusError(#[from] zbus::Error)`: Allgemeine D-Bus-Fehler.
            * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler.
            * `CompositorError(#[from] crate::compositor::error::CompositorError)`: Fehler vom Compositor.
            * `InputError(#[from] crate::input::error::InputError)`: Fehler von der Eingabeverarbeitung.
            * `PowerManagementError(#[from] crate::power_management::error::PowerManagementError)`: Fehler vom Power Management.
            * `ScreenshotError(#[from] crate::screenshot::error::ScreenshotError)`: Fehler vom Screenshot-Portal.
            * `ClipboardError(#[from] crate::clipboard::error::ClipboardError)`: Fehler von der Zwischenablage.
            * `ApplicationLauncherError(#[from] crate::application_launcher::error::ApplicationLauncherError)`: Fehler vom Anwendungsstarter.
            * `XdgPortalError(#[from] crate::xdg_portal_interfaces::error::XdgPortalError)`: Fehler von den XDG-Portals.
            * `AudioError(#[from] crate::audio_management::error::AudioError)`: Fehler vom Audio Management.
            * `McpClientError(#[from] crate::mcp_client::error::McpClientError)`: Fehler vom MCP Client.
            * `InternalError(String)`: Ein allgemeiner interner Fehler, der spezifischer sein sollte.
        * Implementiere `std::error::Error` Trait (durch `thiserror`).
        * Implementiere `From` für `novade-core::error::CoreError` und `novade-domain::error::DomainError`, um eine nahtlose Fehler-Aggregation zu ermöglichen.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/error.rs`
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error::CoreError`, `novade-domain::error::DomainError`, alle Submodule der Systemschicht für ihre spezifischen Fehler.
    * **Extern:** `thiserror`, `std::io`, `zbus`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Eine konsistente und umfassende Fehlerbehandlung für die gesamte Systemschicht.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der Fehlerkonstruktion und `From`-Implementierungen für alle Submodule und externe Bibliotheken.
        * Testen der Fehlermeldungen und der Quellketten (`source()`).
* **Geschätzter Aufwand:** Gering

#### `novade-system/src/compositor`

* **Verantwortlichkeit:** Kernmodul des Smithay-basierten Wayland-Compositors. Verwaltet den Fenster-Lebenszyklus, implementiert Wayland-Protokolle (XDG-Shell, Layer-Shell), abstrahiert den Renderer und integriert XWayland.
* **Struktur-Baum:**
    * `src/compositor/mod.rs`
    * `src/compositor/error.rs`
    * `src/compositor/data_types.rs`
    * `src/compositor/state.rs`
    * `src/compositor/backend.rs`
    * `src/compositor/rendering.rs`
    * `src/compositor/xdg_shell.rs`
    * `src/compositor/layer_shell.rs`
    * `src/compositor/output_manager.rs`
    * `src/compositor/xwayland.rs`
    * `src/compositor/cursor.rs`
    * `src/compositor/input_handler.rs`
    * `src/compositor/seat.rs`
    * `src/compositor/window_management_iface.rs`
    * `src/compositor/screenshot_iface.rs`

##### `novade-system/src/compositor/error.rs`

* **Verantwortlichkeit:** Definiert spezifische Fehlertypen für den Compositor.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `CompositorError` definieren:**
        * Verwende `thiserror::Error` und `#[derive(Debug)]`.
        * Definiere Varianten für:
            * `BackendError(String)`: Fehler vom Rendering-Backend (DRM, Winit).
            * `ProtocolError(String)`: Fehler bei Wayland-Protokoll-Implementierung.
            * `OutputError(String)`: Fehler bei der Output-Verwaltung.
            * `RenderingError(String)`: Fehler beim Rendern.
            * `XWaylandError(String)`: Fehler bei der XWayland-Integration.
            * `InputError(String)`: Fehler bei der Compositor-seitigen Eingabeverarbeitung.
            * `StateError(String)`: Inkonsistenzen im Compositor-Zustand.
            * `WindowManagementError(String)`: Fehler bei der Fensterverwaltung.
            * `InitializationError(String)`: Fehler während der Compositor-Initialisierung.
            * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler.
            * `Other(String)`: Ein allgemeiner, nicht kategorisierter Fehler.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/compositor/error.rs`
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error::CoreError` (für `From`-Implementierung, falls benötigt).
    * **Extern:** `thiserror`, `std::io`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Klare, nachvollziehbare Fehlertypen für den Compositor.
* **Teststrategie (Modul-spezifisch):** Unit Tests für Fehlerkonstruktion und `From`-Implementierungen.
* **Geschätzter Aufwand:** Gering

##### `novade-system/src/compositor/data_types.rs`

* **Verantwortlichkeit:** Definiert allgemeine Datentypen, die innerhalb des Compositors verwendet werden und zwischen Compositor-Modulen ausgetauscht werden.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `SurfaceType` definieren:** Typen von Wayland-Oberflächen.
        * `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]`
        * Varianten: `XdgShell`, `LayerShell`, `XWayland`.
    2.  **Struktur `WindowHandle` definieren:** Eindeutiger Identifikator für ein Compositor-Fenster.
        * `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]`
        * Felder: `id: Uuid`.
    3.  **Struktur `CompositorEvent` definieren:** Ereignisse, die vom Compositor ausgesendet werden.
        * `#[derive(Debug, Clone, PartialEq)]`
        * Varianten:
            * `WindowCreated(WindowHandle, SurfaceType)`
            * `WindowDestroyed(WindowHandle)`
            * `WindowMoved(WindowHandle, Point<i32>)`
            * `WindowResized(WindowHandle, Size<i32>)`
            * `WindowFocused(Option<WindowHandle>)`
            * `OutputAdded(OutputHandle)`
            * `OutputRemoved(OutputHandle)`
            * `PointerMotion(Point<f64>)`
            * `KeyboardInput(KeyboardKeyState)` (Aus `novade-core::input_types`)
            * `ScreenLocked`
            * `ScreenUnlocked`
            * `NewXdgShellSurface(WindowHandle)`
            * `NewLayerShellSurface(WindowHandle)`
            * `XWaylandSurfaceMapped(WindowHandle)`
            * `XWaylandSurfaceUnmapped(WindowHandle)`
    4.  **Enum `WindowRole` definieren:** Rolle eines Fensters (normal, Pop-up, Dialog, Menü etc.).
        * `#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]`
        * Varianten: `Toplevel`, `Popup`, `Transient`, `Menu`, `Tooltip`, `Notification`, `SplashScreen`.
    5.  **Enum `WindowLayer` definieren:** Layer einer Layer-Shell-Oberfläche.
        * `#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]`
        * Varianten: `Background`, `Bottom`, `Top`, `Overlay`.
    6.  **Struktur `CompositorView` definieren:** DTO für die Darstellung eines Compositor-Fensters (für UI-Layer).
        * `#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]`
        * Felder: `handle: WindowHandle`, `title: String`, `app_id: String`, `geometry: Rectangle<i32>`, `is_focused: bool`, `surface_type: SurfaceType`, `role: WindowRole`, `layer: Option<WindowLayer>` (für Layer-Shell), `current_workspace_id: WorkspaceId`.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/compositor/data_types.rs`
* **Abhängigkeiten:**
    * **Intern:** `novade-core::types::geometry::{Point, Size, Rectangle}`, `novade-core::input_types::KeyboardKeyState`, `novade-core::desktop_state::data_types::WorkspaceId`.
    * **Extern:** `uuid::Uuid`, `serde::{Serialize, Deserialize}`, `smithay::wayland::output::OutputHandle`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Ein konsistenter Satz von Typen für die interne und externe Kommunikation des Compositors.
* **Teststrategie (Modul-spezifisch):** Unit Tests für `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` (wo zutreffend) und Serialisierung/Deserialisierung.
* **Geschätzter Aufwand:** Mittel

##### `novade-system/src/compositor/state.rs`

* **Verantwortlichkeit:** Definiert den zentralen Zustand des Compositors und implementiert die `smithay::reexports::calloop::LoopData` und `smithay::wayland::compositor::State` (für Smithay).
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `CompositorState` definieren:**
        * Felder:
            * `display: Display<CompositorState>`: Der Wayland-Display-Server.
            * `space: Space<ManagedSurface>`: Die Haupt-Wayland-Space zur Verwaltung von Oberflächen.
            * `outputs: OutputsHandler`: Verwaltet die Outputs (Monitore).
            * `seat: Seat<CompositorState>`: Der Eingabe-Seat.
            * `xdg_shell_state: XdgShellState`: Smithay XDG-Shell State.
            * `layer_shell_state: LayerShellState`: Smithay Layer-Shell State.
            * `output_manager_global: smithay::wayland::output::OutputManagerGlobal`: Für Wayland Output Management.
            * `cursor_manager: CursorManager`: Verwaltet den Compositor-Cursor.
            * `xwayland: Option<XWayland<CompositorState>>`: XWayland-Integration.
            * `desktop_state: Arc<RwLock<DesktopState>>`: Zugriff auf den Domänen-Desktop-Zustand.
            * `domain_services: Arc<DomainServices>`: Zugriff auf Domänen-Services.
            * `event_sender: tokio::sync::broadcast::Sender<CompositorEvent>`: Für Compositor-Events.
            * `config_service: Arc<ConfigServiceAsync>`: Für Konfiguration.
            * `start_time: std::time::Instant`: Startzeit des Compositors.
            * `popups: smithay::utils::SerialMap<smithay::wayland::shell::xdg::Popup>`: Für XDG Popups.
            * `dnd_manager: smithay::wayland::data_device::DataDeviceManagerState`: Drag-and-Drop Management.
            * `primary_selection_manager: smithay::wayland::primary_selection::PrimarySelectionManagerState`: Primär-Auswahl.
            * `compositor_window_map: Arc<RwLock<HashMap<WindowHandle, SurfaceMapEntry>>>`: Mapping von `WindowHandle` auf `smithay::desktop::Window`/`smithay::desktop::LayerSurface`.
            * `next_window_id: AtomicUsize`: Für eindeutige `WindowHandle` IDs.
            * `is_screen_locked: Arc<AtomicBool>`: Zustand der Bildschirmsperre.
            * `gl_renderer: GlRenderer`: GPU Renderer.
            * `drm_backend: Option<DrmBackend>`: DRM-Backend (oder `WinitBackend`).
            * `current_frame_callback: Option<smithay::backend::SwapBuffersCallback>`: Für Rendering-Timing.
    2.  **Implementierung von `smithay::wayland::compositor::State` für `CompositorState`:**
        * Definiert `Backend` und `SurfaceUserData` assoziierte Typen.
        * Implementiert `client_disconnected()`, `map_surface()`, `unmap_surface()`, `new_client()` etc.
    3.  **Hilfsfunktionen:**
        * `window_from_surface_id(id: WindowHandle) -> Option<ManagedSurface>`
        * `set_focused_window(handle: Option<WindowHandle>)`
        * `lock_screen()` und `unlock_screen()`: Aktualisiert `is_screen_locked` und sendet Events.
        * `get_window_geometry(handle: WindowHandle) -> Option<Rectangle<i32>>`
        * `window_at(pos: Point<f64>) -> Option<(WindowHandle, Point<i32>)>`
        * `window_for_surface(surface: &smithay::wayland::compositor::Surface) -> Option<WindowHandle>`
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/compositor/state.rs`
* **Abhängigkeiten:**
    * **Intern:**
        * `crate::compositor::data_types::{CompositorEvent, WindowHandle, SurfaceType, WindowLayer, WindowRole}`
        * `crate::compositor::error::CompositorError`
        * `crate::compositor::rendering::GlRenderer`
        * `crate::compositor::output_manager::OutputsHandler`
        * `crate::compositor::cursor::CursorManager`
        * `novade-domain::desktop_state::DesktopState`
        * `novade-domain::main_loop::DomainServices`
        * `novade-domain::config::service::ConfigServiceAsync`
        * `novade-core::types::geometry::{Point, Size, Rectangle}`
    * **Extern:** `smithay::{reexports::{wayland_server, calloop}, wayland::{compositor, shell::{xdg, wlr_layer}}`, `smithay::desktop::{Space, Window as ManagedSurface}`, `smithay::input::{Seat, PointerHandle, KeyboardHandle}`, `smithay::backend::renderer::gles2`, `smithay::backend::drm`, `smithay::backend::winit`, `tracing`, `std::sync::{Arc, RwLock, AtomicBool, atomic::AtomicUsize}`, `std::collections::HashMap`, `uuid::Uuid`.
* **Kommunikationsmuster:**
    * Interner Zustand für Smithay-Callbacks.
    * Aktualisiert `DesktopState`.
    * Sendet `CompositorEvent`.
* **Erwartete Ergebnisse/Outputs:** Ein zentraler, konsistenter und performanter Compositor-Zustand.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Testen der Hilfsfunktionen (`window_from_surface_id`, `window_at`, `window_for_surface`).
        * Testen der Zustandsänderungen (`set_focused_window`, `lock_screen`).
        * Mocking von Smithay-Komponenten zur Isolierung der Zustandslogik.
* **Geschätzter Aufwand:** Hoch

##### `novade-system/src/compositor/backend.rs`

* **Verantwortlichkeit:** Abstrahiert das Hardware-Backend für den Compositor (DRM oder Winit für Entwicklung). Initialisiert den `smithay::backend`.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `BackendType` definieren:** `DRM`, `Winit`.
    2.  **Struktur `CompositorBackend` definieren:**
        * Felder: `event_loop: EventLoop<CompositorState>`, `backend: smithay::backend::drm::DrmBackend` (oder `WinitBackend`).
    3.  **Funktion `init_backend(state: CompositorState) -> Result<CompositorBackend, CompositorError>` implementieren:**
        * Wählt das Backend basierend auf Konfiguration/Umgebungsvariablen.
        * Initialisiert das `smithay::backend::drm::DrmBackend` (für produktive Nutzung) oder `smithay::backend::winit::WinitBackend` (für Entwicklung/Debugging).
        * Erstellt und initialisiert den `calloop::EventLoop`.
        * Registriert Smithay `backend` Events (z.B. `Frame`, `Input`, `DeviceAdded/Removed`) im `event_loop`.
        * Übergibt `CompositorState` an den `event_loop`.
    4.  **Asynchrone `run()` Methode für `CompositorBackend` implementieren:** Startet den `event_loop` und wartet auf Events.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/compositor/backend.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::compositor::state::CompositorState`, `crate::compositor::error::CompositorError`.
    * **Extern:** `smithay::backend::{drm, winit}`, `smithay::reexports::calloop`, `tracing`.
* **Kommunikationsmuster:** Kommuniziert mit dem `CompositorState` über den `calloop::EventLoop`.
* **Erwartete Ergebnisse/Outputs:** Ein initialisiertes Compositor-Backend, das Events an den Compositor-Zustand weiterleitet.
* **Teststrategie (Modul-spezifisch):**
    * **Integration Tests:** Starten des Backends und Überprüfung, ob grundlegende Events verarbeitet werden (z.B. durch Mock-Events).
* **Geschätzter Aufwand:** Hoch (DRM-spezifische Konfiguration kann komplex sein)

##### `novade-system/src/compositor/rendering.rs`

* **Verantwortlichkeit:** Handhabt das Rendering der Oberflächen auf den Outputs unter Verwendung von `smithay::backend::renderer::gles2`.
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `GlRenderer` definieren:** Wrapper um `smithay::backend::renderer::gles2::Gles2Renderer`.
    2.  **Funktion `init_renderer() -> Result<GlRenderer, CompositorError>` implementieren:**
        * Initialisiert den `Gles2Renderer`.
        * Benötigt einen GL-Kontext, der vom Backend bereitgestellt wird.
    3.  **Methode `render_output(&mut self, output: &Output, compositor_state: &mut CompositorState, elapsed_time: Duration) -> Result<(), CompositorError>` implementieren:**
        * Ruft `smithay::desktop::Space::render_output()` auf.
        * Behandelt die Buffer-Swaps (`output.swap_buffers()`).
        * Verwendet `smithay::backend::renderer::gles2::Gles2RenderBuffer` und `smithay::backend::allocator::dmabuf::Dmabuf`.
        * Handhabt die Ausgabe-Transformationen (Rotation, Skalierung).
        * Zeichnet den Hintergrund (z.B. aus `wallpaper_manager` oder Standardfarbe).
        * Zeichnet Fenster (XDG-Shell, XWayland).
        * Zeichnet Layer-Shell-Oberflächen (Panels, Docks).
        * Zeichnet den Cursor.
        * Zeichnet Popups.
    4.  **Shader-Verwaltung:** Lade und kompiliere grundlegende Shader (z.B. für Texturen, Farb-Füllungen).
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/compositor/rendering.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::compositor::state::CompositorState`, `crate::compositor::error::CompositorError`, `novade-core::types::geometry`.
    * **Extern:** `smithay::backend::renderer::gles2`, `smithay::desktop::{Space, Window, LayerSurface}`, `smithay::wayland::output::Output`, `smithay::backend::allocator::dmabuf`, `std::time::Duration`, `tracing`.
* **Kommunikationsmuster:** Greift auf `CompositorState` zu, um zu rendern.
* **Erwartete Ergebnisse/Outputs:** Reibungsloses und performantes Rendering der Desktop-Oberfläche.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:** Testen von Shader-Kompilierung (mit Mock-GL-Kontext).
    * **Integration Tests:** Visuelle Tests auf einem virtuellen Display-Server, um die Rendering-Korrektheit zu überprüfen.
* **Geschätzter Aufwand:** Hoch

##### `novade-system/src/compositor/xdg_shell.rs`

* **Verantwortlichkeit:** Implementiert die `xdg_shell`-Protokoll-Handler für Smithay.
* **Kern-Aufgaben (Tasks):**
    1.  **Implementierung von `smithay::wayland::shell::xdg::XdgShellHandler` für `CompositorState`:**
        * **`xdg_shell_state(&mut self) -> &mut XdgShellState`:** Liefert den Zustand.
        * **`new_toplevel(&mut self, surface: XdgToplevelSurface)`:**
            * Erstellt ein neues `Window` in der `Space`.
            * Weist eine `WindowHandle` zu.
            * Sendet `CompositorEvent::NewXdgShellSurface`.
            * Setzt die initiale Position und Größe.
            * Setzt den Fokus auf das neue Fenster.
        * **`new_popup(&mut self, surface: XdgPopupSurface)`:**
            * Verwaltet Popups, registriert sie in `compositor_state.popups`.
        * **`move_request(&mut self, surface: XdgToplevelSurface, serial: Serial)`:**
            * Setzt `compositor_state.current_move_window` und `compositor_state.input_manager.start_grab_move()`.
        * **`resize_request(&mut self, surface: XdgToplevelSurface, serial: Serial, edges: ResizeEdge)`:**
            * Setzt `compositor_state.current_resize_window` und `compositor_state.input_manager.start_grab_resize()`.
        * **`maximize_request(&mut self, surface: XdgToplevelSurface)`:**
            * Maximiert das Fenster, aktualisiert die `DesktopState` und sendet Event.
        * **`fullscreen_request(&mut self, surface: XdgToplevelSurface, output: Option<Output>)`:**
            * Setzt das Fenster auf Vollbild auf dem angegebenen Output.
        * **`unmaximize_request(&mut self, surface: XdgToplevelSurface)`:**
            * Stellt die ursprüngliche Größe wieder her.
        * **`unset_fullscreen_request(&mut self, surface: XdgToplevelSurface)`:**
            * Beendet den Vollbildmodus.
        * **`set_parent(&mut self, surface: XdgToplevelSurface, parent: Option<XdgToplevelSurface>)`:**
            * Verwaltet Eltern-Kind-Beziehungen (z.B. für Dialoge).
        * **`with_surface_tree_upiter_from_xdg_toplevel_surface(...)` und `xdg_toplevel_surface_destroyed(...)`:** Standard-Implementierungen von Smithay-Traits.
    2.  **Hilfsfunktionen:** Für die Interaktion mit dem `DesktopState` und `window_management_iface`.
* **Spezifische Artefekte/Dateien:**
    * `novade-system/src/compositor/xdg_shell.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::compositor::state::CompositorState`, `crate::compositor::data_types::{CompositorEvent, WindowHandle, SurfaceType, WindowRole}`, `crate::compositor::window_management_iface::WindowManagementService`.
    * **Extern:** `smithay::wayland::shell::xdg::{XdgShellState, XdgToplevelSurface, XdgPopupSurface, ToplevelSurface, PopupSurface, XdgShellHandler, ResizeEdge}`, `smithay::desktop::{Window, Space}`, `smithay::reexports::wayland_server::protocol::wl_surface::WlSurface`, `smithay::reexports::wayland_server::Serial`, `smithay::wayland::output::Output`, `tracing`.
* **Kommunikationsmuster:**
    * Empfängt Events von `xdg_shell` Clients.
    * Modifiziert `CompositorState`.
    * Sendet `CompositorEvent`.
    * Interagiert mit `WindowManagementService` (Domäne, über `desktop_state`).
* **Erwartete Ergebnisse/Outputs:** Korrekte Handhabung von XDG-Shell-Fenstern und deren Zuständen.
* **Teststrategie (Modul-spezifisch):**
    * **Integration Tests:** End-to-End Tests mit echten Wayland-Clients, die XDG-Shell verwenden.
    * **Unit Tests:** Mocking von `CompositorState` und `XdgShellSurface` zur Überprüfung der Callback-Logik.
* **Geschätzter Aufwand:** Mittel

##### `novade-system/src/compositor/layer_shell.rs`

* **Verantwortlichkeit:** Implementiert die `wlr_layer_shell`-Protokoll-Handler für Smithay. Dies ist für Panels, Docks, Desktops etc.
* **Kern-Aufgaben (Tasks):**
    1.  **Implementierung von `smithay::wayland::shell::wlr_layer::WlrLayerShellHandler` für `CompositorState`:**
        * **`layer_shell_state(&mut self) -> &mut LayerShellState`:** Liefert den Zustand.
        * **`new_layer_surface(&mut self, surface: LayerSurface, output: Option<Output>, layer: Layer, namespace: String)`:**
            * Erstellt eine neue `LayerSurface` in der `Space`.
            * Weist eine `WindowHandle` zu.
            * Sendet `CompositorEvent::NewLayerShellSurface`.
            * Setzt die initiale Position und Größe basierend auf `layer` und `output` (Randbedingungen: Anchors).
            * Automatische Platzierung (z.B. Panel oben).
        * **`layer_surface_destroyed(&mut self, surface: LayerSurface)`:**
            * Entfernt die Oberfläche aus der `Space`.
            * Sendet `CompositorEvent::WindowDestroyed`.
        * **`keyboard_interactivity(&self, surface: LayerSurface) -> Option<KeyboardInteractivity>`:** Definiert Tastaturinteraktivität.
        * **`with_surface_tree_upiter_from_wlr_layer_surface(...)`:** Standard-Implementierung.
    2.  **Hilfsfunktionen:** Für die korrekte Platzierung von Layer-Shell-Oberflächen.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/compositor/layer_shell.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::compositor::state::CompositorState`, `crate::compositor::data_types::{CompositorEvent, WindowHandle, SurfaceType, WindowLayer}`.
    * **Extern:** `smithay::wayland::shell::wlr_layer::{LayerShellState, LayerSurface, WlrLayerShellHandler, Layer, KeyboardInteractivity}`, `smithay::desktop::Space`, `smithay::reexports::wayland_server::protocol::wl_surface::WlSurface`, `smithay::wayland::output::Output`, `tracing`.
* **Kommunikationsmuster:**
    * Empfängt Events von `wlr_layer_shell` Clients.
    * Modifiziert `CompositorState`.
    * Sendet `CompositorEvent`.
* **Erwartete Ergebnisse/Outputs:** Korrekte Handhabung von Layer-Shell-Oberflächen (Panels, Docks, etc.).
* **Teststrategie (Modul-spezifisch):**
    * **Integration Tests:** End-to-End Tests mit Wayland-Clients, die Layer-Shell verwenden.
    * **Unit Tests:** Mocking von `CompositorState` und `LayerSurface` zur Überprüfung der Platzierungs- und Zerstörungslogik.
* **Geschätzter Aufwand:** Mittel

##### `novade-system/src/compositor/output_manager.rs`

* **Verantwortlichkeit:** Verwaltet die Outputs (Monitore) des Compositors, einschließlich Hotplugging, Modi und Skalierung.
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `OutputsHandler` definieren:**
        * Feld `outputs: Vec<smithay::wayland::output::Output>`: Liste der Outputs.
        * Feld `output_manager_global: smithay::wayland::output::OutputManagerGlobal`: Wayland Global für Output Management.
    2.  **Konstruktor `new()` implementieren:** Initialisiert mit `OutputManagerGlobal`.
    3.  **Methoden `add_output(output: Output) -> Result<(), CompositorError>` implementieren:**
        * Fügt einen neuen Output hinzu.
        * Konfiguriert den Output mit einem Standardmodus (Auflösung, Refresh-Rate).
        * Sendet `CompositorEvent::OutputAdded`.
        * Fügt den Output zur `smithay::desktop::Space` hinzu (durch `CompositorState`).
    4.  **Methoden `remove_output(output: &Output) -> Result<(), CompositorError>` implementieren:**
        * Entfernt einen Output.
        * Sendet `CompositorEvent::OutputRemoved`.
        * Entfernt den Output aus der `Space`.
    5.  **Methode `set_output_mode(output: &Output, mode: smithay::backend::output::Mode) -> Result<(), CompositorError>` implementieren:** Ändert den Anzeigemodus.
    6.  **Methode `set_output_scale(output: &Output, scale: i32) -> Result<(), CompositorError>` implementieren:** Setzt die Skalierung.
    7.  **Methode `output_from_handle(handle: OutputHandle) -> Option<&Output>` implementieren:** Hilfsfunktion.
    8.  **Implementierung von `smithay::wayland::output::OutputManagementHandler` für `CompositorState`:** (Callback für Output Management Protokoll)
        * `new_output()`: Handhabt neue Outputs (z.B. vom DRM-Backend).
        * `output_removed()`: Handhabt entfernte Outputs.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/compositor/output_manager.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::compositor::state::CompositorState`, `crate::compositor::error::CompositorError`, `crate::compositor::data_types::CompositorEvent`.
    * **Extern:** `smithay::wayland::output::{Output, OutputHandle, OutputManagerGlobal, OutputManagementHandler}`, `smithay::backend::output::Mode`, `smithay::desktop::Space`, `tracing`.
* **Kommunikationsmuster:**
    * Empfängt Events von `smithay::backend` über neue/entfernte Outputs.
    * Modifiziert `CompositorState.space`.
    * Sendet `CompositorEvent`.
* **Erwartete Ergebnisse/Outputs:** Robuste Verwaltung von Monitoren mit Hotplugging-Unterstützung.
* **Teststrategie (Modul-spezifisch):**
    * **Integration Tests:** Simulation von Monitor-Hotplugging und Überprüfung der Compositor-Reaktion.
    * **Unit Tests:** Mocking von `Output` und `CompositorState` zur Testung von `add_output`, `remove_output`, `set_output_mode`, `set_output_scale`.
* **Geschätzter Aufwand:** Mittel

##### `novade-system/src/compositor/xwayland.rs`

* **Verantwortlichkeit:** Integriert XWayland, um X11-Anwendungen auf dem Wayland-Compositor auszuführen.
* **Kern-Aufgaben (Tasks):**
    1.  **Funktion `init_xwayland(display: &Display<CompositorState>, compositor_state: &CompositorState) -> Result<XWayland<CompositorState>, CompositorError>` implementieren:**
        * Initialisiert die `smithay::xwayland::XWayland` Instanz.
        * Registriert die XWayland-Hooks/Listeners.
        * Startet den XWayland-Server.
    2.  **Implementierung von `smithay::xwayland::XWaylandHandler` für `CompositorState`:**
        * **`xwayland_state(&mut self) -> &mut XWayland<Self>`:** Liefert den Zustand.
        * **`new_xwm_surface(&mut self, surface: XwmSurface)`:**
            * Erstellt ein `smithay::desktop::Window` aus der XwmSurface.
            * Weist eine `WindowHandle` zu.
            * Sendet `CompositorEvent::XWaylandSurfaceMapped`.
            * Fügt die Oberfläche zur `Space` hinzu.
            * Setzt die initiale Position und Größe.
            * Setzt den Fokus auf das neue Fenster.
        * **`xwm_surface_destroyed(&mut self, surface: XwmSurface)`:**
            * Entfernt die Oberfläche aus der `Space`.
            * Sendet `CompositorEvent::XWaylandSurfaceUnmapped`.
        * **`xwm_surface_configure(&mut self, surface: XwmSurface, configure: XwmSurfaceConfigure)`:**
            * Handhabt Größen- und Positionsänderungsanfragen von X11-Clients.
        * **`xwm_surface_move_request(...)`, `xwm_surface_resize_request(...)`, `xwm_surface_maximize_request(...)`, `xwm_surface_fullscreen_request(...)`:** Leitet diese Anfragen an die Compositor-eigene Fensterverwaltung weiter.
    3.  **Behandlung von XDG-Shell-Fenstern als XWayland-Oberflächen:** Da XWayland Top-Level-Fenster als XDG-Toplevel-Fenster emuliert, muss die Logik in `xdg_shell.rs` dies berücksichtigen (oder umgekehrt, die XWayland-Oberflächen in die `Space` einfügen, aber mit einem `SurfaceType::XWayland` Marker).
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/compositor/xwayland.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::compositor::state::CompositorState`, `crate::compositor::error::CompositorError`, `crate::compositor::data_types::{CompositorEvent, WindowHandle, SurfaceType}`.
    * **Extern:** `smithay::xwayland::{XWayland, XWaylandHandler, XwmSurface, XwmSurfaceConfigure}`, `smithay::reexports::wayland_server::Display`, `smithay::desktop::Space`, `tracing`.
* **Kommunikationsmuster:**
    * Empfängt Events von XWayland-Clients.
    * Modifiziert `CompositorState.space`.
    * Sendet `CompositorEvent`.
* **Erwartete Ergebnisse/Outputs:** Nahtlose Ausführung von X11-Anwendungen auf dem Wayland-Desktop.
* **Teststrategie (Modul-spezifisch):**
    * **Integration Tests:** Starten von X11-Anwendungen und Überprüfung ihrer Funktionalität und Darstellung.
    * **Unit Tests:** Mocking von XwmSurface und CompositorState zur Überprüfung der Callback-Logik.
* **Geschätzter Aufwand:** Hoch (Komplexität der XWayland-Integration)

##### `novade-system/src/compositor/cursor.rs`

* **Verantwortlichkeit:** Verwaltet die Darstellung des Compositor-Cursors und dessen Zustand (z.B. Größe ändern, verschieben).
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `CursorManager` definieren:**
        * Felder: `cursor_image_manager: smithay::wayland::compositor::CursorImageManager`, `current_cursor_shape: smithay::utils::xcursor::XCursorTheme` (für XCursor-Themen), `cursor_surface: Option<smithay::wayland::compositor::Surface>` (optional für benutzerdefinierte Cursor-Oberflächen).
    2.  **Konstruktor `new()` implementieren:** Initialisiert `CursorImageManager` und lädt ein Standard-XCursor-Thema.
    3.  **Methode `update_cursor_position(&mut self, pos: Point<f64>)` implementieren:**
        * Aktualisiert die Position des Cursors in der `CompositorState.seat.pointer`.
        * Sendet `CompositorEvent::PointerMotion`.
    4.  **Methode `set_cursor_shape(&mut self, shape: &str)` implementieren:**
        * Setzt die Form des Cursors (z.B. "default", "pointer", "text", "grab", "resize").
        * Läd die entsprechende Cursor-Grafik aus dem XCursor-Thema.
    5.  **Methode `set_custom_cursor_surface(&mut self, surface: smithay::wayland::compositor::Surface, hotspot: Point<i32>)` implementieren:**
        * Erlaubt Anwendungen, einen eigenen Cursor zu setzen.
    6.  **`draw_cursor(renderer: &mut GlRenderer, output: &Output, compositor_state: &CompositorState)` Funktion:**
        * Rendert den Cursor auf dem Output. Integriert sich in `rendering.rs`.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/compositor/cursor.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::compositor::state::CompositorState`, `crate::compositor::data_types::CompositorEvent`, `crate::compositor::rendering::GlRenderer`, `novade-core::types::geometry::Point`.
    * **Extern:** `smithay::wayland::compositor::CursorImageManager`, `smithay::utils::xcursor`, `smithay::wayland::output::Output`, `tracing`.
* **Kommunikationsmuster:** Modifiziert den Zustand des Pointers im `CompositorState.seat`.
* **Erwartete Ergebnisse/Outputs:** Korrekte und reaktionsschnelle Cursor-Darstellung.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:** Testen von `set_cursor_shape`, `update_cursor_position`.
    * **Integration Tests:** Visuelle Überprüfung des Cursors bei verschiedenen Zuständen (Hover, Resize).
* **Geschätzter Aufwand:** Gering

##### `novade-system/src/compositor/input_handler.rs`

* **Verantwortlichkeit:** Verarbeitet Eingabe-Events (Tastatur, Maus, Touch) von Smithay und leitet sie an die entsprechende Logik weiter (Fokus, Bewegung, Größe ändern).
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `InputHandler` definieren:**
        * Felder: `seat_handle: smithay::input::SeatHandle<CompositorState>`, `pointer_grab_manager: PointerGrabManager`, `keyboard_grab_manager: KeyboardGrabManager`.
    2.  **Konstruktor `new()` implementieren:** Initialisiert den Handler.
    3.  **Methode `on_pointer_move(&mut self, event: &MotionEvent, compositor_state: &mut CompositorState)` implementieren:**
        * Aktualisiert die Pointer-Position in `CompositorState.seat`.
        * Führt Hit-Testing durch, um das fokussierte Fenster oder Layer zu bestimmen.
        * Setzt den Cursor-Shape basierend auf dem Kontext (Fensterränder für Resize).
        * Wenn ein Grab aktiv ist (Move/Resize), aktualisiert es die Fensterposition/Größe.
        * Sendet `CompositorEvent::PointerMotion`.
    4.  **Methode `on_pointer_button(&mut self, event: &ButtonEvent, compositor_state: &mut CompositorState)` implementieren:**
        * Leitet Button-Events an das fokussierte Fenster weiter.
        * Behandelt Klicks auf Fenster-Header für Drag & Drop.
        * Behandelt Klicks auf Fensterränder für Resize.
        * Implementiert `start_grab_move()` und `start_grab_resize()` für Fensteraktionen.
    5.  **Methode `on_keyboard_key(&mut self, event: &KeyEvent, compositor_state: &mut CompositorState)` implementieren:**
        * Verarbeitet Tastatur-Events.
        * Leitet an das fokussierte Fenster weiter.
        * Behandelt globale Tastenkombinationen (z.B. Super+Tab für Workspace-Switcher, Super+Space für Command Palette, Alt+F4 für Fenster schließen).
        * Generiert `CompositorEvent::KeyboardInput`.
    6.  **Methoden `start_grab_move(handle: WindowHandle)`, `start_grab_resize(handle: WindowHandle, edges: ResizeEdge)` implementieren:**
        * Speichert den Startzustand für die Grab-Operation.
    7.  **`PointerGrabManager` und `KeyboardGrabManager` (interne Hilfsstrukturen):**
        * Verwalten den aktuellen Pointer/Keyboard Grab (Fenster-Bewegung, Größenänderung, globale Tastenkombinationen).
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/compositor/input_handler.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::compositor::state::CompositorState`, `crate::compositor::error::CompositorError`, `crate::compositor::data_types::{CompositorEvent, WindowHandle}`, `novade-core::input_types::{KeyEvent, KeyboardKeyState, PointerEvent, MotionEvent, ButtonEvent}`.
    * **Extern:** `smithay::input::{SeatHandle, PointerHandle, KeyboardHandle, GrabStartInfo, GrabStatus}`, `smithay::desktop::{Space, Window}`, `smithay::wayland::shell::xdg::ResizeEdge`, `tracing`.
* **Kommunikationsmuster:**
    * Empfängt Roh-Input-Events von `smithay::backend::winit` oder `libinput` (über `novade-system::input`).
    * Modifiziert `CompositorState` (Fensterposition, Fokus).
    * Sendet `CompositorEvent`.
    * Interagiert mit `DesktopState` (für Workspace-Wechsel, Fokusänderungen).
* **Erwartete Ergebnisse/Outputs:** Reibungslose und präzise Benutzerinteraktion mit dem Compositor.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:** Mocking von `CompositorState` und Smithay-Eingabestrukturen, um das Verhalten bei verschiedenen Events (Mausbewegung, Klicks, Tastenanschläge) zu testen.
    * **Integration Tests:** Simulation von Benutzerinteraktionen und Überprüfung der Compositor-Reaktion.
* **Geschätzter Aufwand:** Hoch

##### `novade-system/src/compositor/seat.rs`

* **Verantwortlichkeit:** Verwaltet den Wayland-Seat und dessen Ressourcen (Tastatur, Pointer, Touch).
* **Kern-Aufgaben (Tasks):**
    1.  **Funktion `init_seat(display: &Display<CompositorState>, name: &str) -> Seat<CompositorState>` implementieren:**
        * Erstellt einen neuen `smithay::input::Seat`.
        * Registriert den Seat als Wayland Global.
        * Fügt die Pointer- und Keyboard-Capabilities hinzu.
    2.  **Implementierung von `smithay::input::SeatHandler` für `CompositorState`:**
        * `seat_state(&mut self) -> &mut SeatState`: Liefert den Zustand.
        * `new_capability(&mut self, seat: &Seat, capability: Capability)`: Handhabt das Hinzufügen von Capabilities (Pointer, Keyboard, Touch).
        * `remove_capability(&mut self, seat: &Seat, capability: Capability)`: Handhabt das Entfernen von Capabilities.
        * `focus_changed(...)`: Standard-Implementierung.
        * `start_drag(...)`: Standard-Implementierung.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/compositor/seat.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::compositor::state::CompositorState`.
    * **Extern:** `smithay::input::{Seat, SeatState, SeatHandler, Capability}`, `smithay::reexports::wayland_server::Display`, `tracing`.
* **Kommunikationsmuster:** Wayland-Protokoll-Kommunikation für den Seat.
* **Erwartete Ergebnisse/Outputs:** Ein voll funktionsfähiger Wayland-Seat für die Eingabeverwaltung.
* **Teststrategie (Modul-spezifisch):**
    * **Integration Tests:** Interaktion mit Wayland-Clients, die den Seat nutzen.
* **Geschätzter Aufwand:** Gering

##### `novade-system/src/compositor/window_management_iface.rs`

* **Verantwortlichkeit:** Definiert das Trait für die Interaktion des Compositors mit der Domänenschicht bezüglich der Fensterverwaltung.
* **Kern-Aufgaben (Tasks):**
    1.  **Trait `CompositorWindowManagement` definieren:**
        * Asynchrones Trait.
        * Methode `request_window_move(handle: WindowHandle, new_position: Point<i32>) -> Result<(), CompositorError>`.
        * Methode `request_window_resize(handle: WindowHandle, new_size: Size<i32>) -> Result<(), CompositorError>`.
        * Methode `request_window_focus(handle: WindowHandle) -> Result<(), CompositorError>`.
        * Methode `request_window_close(handle: WindowHandle) -> Result<(), CompositorError>`.
        * Methode `request_window_minimize(handle: WindowHandle) -> Result<(), CompositorError>`.
        * Methode `request_window_maximize(handle: WindowHandle) -> Result<(), CompositorError>`.
        * Methode `request_window_fullscreen(handle: WindowHandle, output_handle: OutputHandle) -> Result<(), CompositorError>`.
        * Methode `get_compositor_views() -> Vec<CompositorView>` (für UI).
        * Methode `move_window_to_workspace(handle: WindowHandle, workspace_id: WorkspaceId) -> Result<(), CompositorError>`.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/compositor/window_management_iface.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::compositor::data_types::{WindowHandle, CompositorView}`, `crate::compositor::error::CompositorError`, `novade-core::types::geometry::{Point, Size}`, `novade-core::desktop_state::data_types::WorkspaceId`.
    * **Extern:** `smithay::wayland::output::OutputHandle`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Eine klare Schnittstelle für die Fensterverwaltung.
* **Teststrategie (Modul-spezifisch):** Keine Tests direkt für Traits.
* **Geschätzter Aufwand:** Gering

##### `novade-system/src/compositor/screenshot_iface.rs`

* **Verantwortlichkeit:** Definiert das Trait für die Interaktion des Compositors mit dem Screenshot-Dienst der Domänenschicht.
* **Kern-Aufgaben (Tasks):**
    1.  **Trait `CompositorScreenshotProvider` definieren:**
        * Asynchrones Trait.
        * Methode `take_compositor_full_screenshot() -> Result<Vec<u8>, CompositorError>`: Nimmt Screenshot des gesamten Desktops.
        * Methode `take_compositor_window_screenshot(handle: WindowHandle) -> Result<Vec<u8>, CompositorError>`: Nimmt Screenshot eines bestimmten Fensters.
        * Methode `take_compositor_region_screenshot(region: Rectangle<i32>) -> Result<Vec<u8>, CompositorError>`: Nimmt Screenshot eines bestimmten Bereichs.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/compositor/screenshot_iface.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::compositor::error::CompositorError`, `crate::compositor::data_types::WindowHandle`, `novade-core::types::geometry::Rectangle`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Eine klare Schnittstelle für Screenshot-Aufnahmen direkt vom Compositor.
* **Teststrategie (Modul-spezifisch):** Keine Tests direkt für Traits.
* **Geschätzter Aufwand:** Gering

##### `novade-system/src/compositor/mod.rs`

* **Verantwortlichkeit:** Definiert die öffentliche Schnittstelle des `compositor`-Moduls.
* **Kern-Aufgaben (Tasks):**
    1.  **Re-Exports:** Exportiert die wichtigsten Typen und Funktionen (`CompositorError`, `CompositorEvent`, `WindowHandle`, `SurfaceType`, `WindowLayer`, `WindowRole`, `CompositorView`, `CompositorState`, `CompositorBackend`, `GlRenderer`, `OutputsHandler`, `CursorManager`, `InputHandler`, `CompositorWindowManagement`, `CompositorScreenshotProvider`, `initialize_compositor`).
    2.  **Funktion `initialize_compositor(domain_services: Arc<DomainServices>, desktop_state: Arc<RwLock<DesktopState>>, config_service: Arc<ConfigServiceAsync>, event_sender: tokio::sync::broadcast::Sender<CompositorEvent>) -> Result<CompositorBackend, CompositorError>` implementieren:**
        * Die Hauptinitialisierungsfunktion für den Compositor.
        * Erstellt `CompositorState`.
        * Initialisiert `smithay::reexports::wayland_server::Display`.
        * Initialisiert `XdgShellState`, `LayerShellState`.
        * Initialisiert `OutputsHandler`, `CursorManager`.
        * Initialisiert `Seat` und fügt Capabilities hinzu.
        * Initialisiert `XWayland` (optional).
        * Initialisiert das `CompositorBackend` (DRM oder Winit).
        * Registriert alle Wayland Globals (`xdg_shell`, `wlr_layer_shell`, `wl_compositor`, `wl_shm`, `wl_data_device_manager`, `wl_subcompositor`, `zwlr_screencopy_v1`, `zxdg_decoration_v1`, `zxdg_output_manager_v1`, `zwp_primary_selection_device_manager_v1`).
        * Verbindet die Event-Loop des Backends mit der Compositor-Logik.
        * Gibt das `CompositorBackend` zurück, das dann `run()` aufgerufen werden kann.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/compositor/mod.rs`
* **Abhängigkeiten:**
    * **Intern:** Alle Untermodule des `compositor`.
    * `novade-domain::desktop_state::DesktopState`
    * `novade-domain::main_loop::DomainServices`
    * `novade-domain::config::service::ConfigServiceAsync`
    * **Extern:** `smithay`, `tokio::sync::broadcast`, `std::sync::{Arc, RwLock}`, `tracing`.
* **Kommunikationsmuster:** Bietet die Haupt-API für die Initialisierung des Compositors.
* **Erwartete Ergebnisse/Outputs:** Ein vollständig initialisierter und betriebsbereiter Wayland-Compositor.
* **Teststrategie (Modul-spezifisch):**
    * **Integration Tests:** End-to-End Tests, die den Compositor starten und grundlegende Interaktionen simulieren (Fenster öffnen, verschieben, schließen).
* **Geschätzter Aufwand:** Sehr hoch (das ist der Kern des DE)

#### `novade-system/src/input`

* **Verantwortlichkeit:** `libinput`-basierte Eingabeverarbeitung; Seat-Management, `xkbcommon`-Integration, Event-Übersetzung für Tastatur, Zeiger, Touch, Gesten.
* **Struktur-Baum:**
    * `src/input/mod.rs`
    * `src/input/error.rs`
    * `src/input/data_types.rs`
    * `src/input/libinput_handler.rs`
    * `src/input/keyboard.rs`
    * `src/input/pointer.rs`
    * `src/input/gestures.rs`
    * `src/input/service.rs`

##### `novade-system/src/input/error.rs`

* **Verantwortlichkeit:** Definiert spezifische Fehlertypen für das Eingabe-Modul.
* **Kern-Aufgaben (Tasks):**
    1.  **Enum `InputError` definieren:**
        * Verwende `thiserror::Error` und `#[derive(Debug)]`.
        * Varianten:
            * `LibinputError(String)`: Fehler von `libinput`.
            * `XkbcommonError(String)`: Fehler von `xkbcommon`.
            * `DeviceNotFound(String)`: Eingabegerät nicht gefunden.
            * `EventProcessingError(String)`: Fehler bei der Event-Verarbeitung.
            * `InitializationError(String)`: Fehler während der Initialisierung.
            * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler.
            * `Other(String)`: Allgemeiner Fehler.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/input/error.rs`
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error::CoreError`.
    * **Extern:** `thiserror`, `std::io`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Klar definierte Fehlertypen für Eingabe.
* **Teststrategie (Modul-spezifisch):** Unit Tests für Fehlerkonstruktion.
* **Geschätzter Aufwand:** Gering

##### `novade-system/src/input/data_types.rs`

* **Verantwortlichkeit:** Definiert Datentypen für Eingabe-Events und Geräte.
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `InputDevice` definieren:** Repräsentiert ein Eingabegerät.
        * `#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]`
        * Felder: `id: String`, `name: String`, `kind: InputDeviceKind`.
    2.  **Enum `InputDeviceKind` definieren:** Typ des Eingabegeräts.
        * `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]`
        * Varianten: `Keyboard`, `Pointer`, `Touch`, `Tablet`, `Gesture`, `Other`.
    3.  **Enum `InputEvent` definieren:** Allgemeine Input-Events, die von diesem Modul gesendet werden.
        * `#[derive(Debug, Clone, PartialEq)]`
        * Varianten:
            * `DeviceAdded(InputDevice)`
            * `DeviceRemoved(InputDevice)`
            * `Keyboard(KeyEvent)` (Aus `novade-core::input_types`)
            * `Pointer(PointerEvent)` (Aus `novade-core::input_types`)
            * `Touch(TouchEvent)` (Aus `novade-core::input_types`)
            * `Gesture(GestureEvent)` (Aus `novade-core::input_types`)
            * `Tablet(TabletEvent)` (Aus `novade-core::input_types`)
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/input/data_types.rs`
* **Abhängigkeiten:**
    * **Intern:** `novade-core::input_types`.
    * **Extern:** `serde::{Serialize, Deserialize}`.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Gut definierte Eingabe-Datentypen.
* **Teststrategie (Modul-spezifisch):** Unit Tests für `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` (wo zutreffend) und Serialisierung/Deserialisierung.
* **Geschätzter Aufwand:** Gering

##### `novade-system/src/input/libinput_handler.rs`

* **Verantwortlichkeit:** Schnittstelle zu `libinput` und grundlegende Event-Verarbeitung.
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `LibinputHandler` definieren:**
        * Felder: `libinput_context: libinput::Context`, `input_event_sender: tokio::sync::broadcast::Sender<InputEvent>`.
    2.  **Konstruktor `new(display_handle: &DisplayHandle) -> Result<Self, InputError>` implementieren:**
        * Initialisiert `libinput::Context` (mit `udev` Backend).
        * Registriert für `udev` Events, um Hotplugging zu erkennen.
    3.  **Asynchrone `run_event_loop()` Methode implementieren:**
        * Endlosschleife, die `libinput_context.dispatch()` aufruft.
        * Für jedes empfangene `libinput::Event`:
            * Identifiziere den Event-Typ (DeviceAdded, DeviceRemoved, Keyboard, Pointer, Touch, Gesture).
            * Konvertiere `libinput::Event` in `novade-core::input_types` und `InputEvent`.
            * Sende das konvertierte `InputEvent` über `input_event_sender`.
            * Behandle `DeviceAdded`/`DeviceRemoved`: Erstelle `InputDevice` und sende entsprechende `InputEvent`.
            * `libinput_context.suspend()` und `resume()` bei System-Suspend/Resume Events (über D-Bus).
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/input/libinput_handler.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::input::data_types::{InputEvent, InputDevice, InputDeviceKind}`, `crate::input::error::InputError`, `novade-core::input_types`.
    * **Extern:** `libinput`, `tokio::sync::broadcast`, `tracing`, `wayland_server::DisplayHandle` (für `libinput::Context::udev_context`).
* **Kommunikationsmuster:** Sendet `InputEvent` an `InputManagerService`.
* **Erwartete Ergebnisse/Outputs:** Eine robuste Schnittstelle zu `libinput`, die Events verarbeitet.
* **Teststrategie (Modul-spezifisch):**
    * **Integration Tests:** Mit einem simulierten `libinput` Backend oder auf einem Testsystem, um Event-Fluss zu prüfen.
* **Geschätzter Aufwand:** Mittel

##### `novade-system/src/input/keyboard.rs`

* **Verantwortlichkeit:** Verarbeitet Tastatur-Events, integriert `xkbcommon` für Tastenbelegung und State-Management.
* **Kern-Aufgaben (Tasks):
    1.  **Struktur `KeyboardHandler` definieren:**
        * Felder: `xkb_state: xkbcommon::xkb::State`, `xkb_context: xkbcommon::xkb::Context`, `keyboard_config: GlobalKeyboardConfig` (aus `GlobalSettingsService`).
        * `keyboard_handle: smithay::input::keyboard::KeyboardHandle<CompositorState>`: Für Wayland-Key-Events.
    2.  **Konstruktor `new() -> Result<Self, InputError>` implementieren:**
        * Initialisiert `xkbcommon::xkb::Context`.
        * Läd die Standard-Keymap basierend auf `keyboard_config`.
        * Erstellt `xkbcommon::xkb::State`.
    3.  **Methode `process_key_event(&mut self, event: &KeyEvent, compositor_state: &mut CompositorState)` implementieren:**
        * Aktualisiert `xkb_state` mit dem `event.raw_code` und `event.key_state`.
        * Ermittelt den generierten Keycode und die Modifikatoren.
        * Leitet das Key-Event an `compositor_state.seat.keyboard` weiter, um es an den fokussierten Client zu senden.
        * Behandelt `dead_keys`.
        * Behandelt globale Tastenkombinationen (siehe `compositor::input_handler`).
    4.  **Methode `set_keymap(layout: &str, variant: Option<&str>, options: Option<&str>) -> Result<(), InputError>` implementieren:**
        * Ändert die aktuelle XKB-Keymap.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/input/keyboard.rs`
* **Abhängigkeiten:**
    * **Intern:** `crate::input::error::InputError`, `novade-core::input_types::KeyEvent`, `crate::compositor::state::CompositorState`, `novade-domain::global_settings::data_types::GlobalKeyboardConfig`.
    * **Extern:** `xkbcommon::xkb`, `smithay::input::keyboard`, `tracing`.
* **Kommunikationsmuster:** Empfängt `KeyEvent` von `LibinputHandler`. Leitet an `CompositorState` weiter.
* **Erwartete Ergebnisse/Outputs:** Korrekte Verarbeitung von Tastatur-Eingaben.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:** Testen von `process_key_event` mit verschiedenen Key-Codes und Modifikatoren. Testen von `set_keymap`.
* **Geschätzter Aufwand:** Mittel

##### `novade-system/src/input/pointer.rs`

* **Verantwortlichkeit:** Verarbeitet Pointer-Events (Maus, Touchpad), einschließlich Bewegung, Button-Klicks und Scrollen.
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `PointerHandler` definieren:**
        * Feld `pointer_handle: smithay::input::pointer::PointerHandle<CompositorState>`.
    2.  **Konstruktor `new() -> Self` implementieren.**
    3.  **Methode `process_pointer_event(&mut self, event: &PointerEvent, compositor_state: &mut CompositorState)` implementieren:**
        * Behandelt `MotionEvent`: Ruft `compositor_state.input_handler.on_pointer_move()` auf.
        * Behandelt `ButtonEvent`: Ruft `compositor_state.input_handler.on_pointer_button()` auf.
        * Behandelt `ScrollEvent`: Leitet Scroll-Events an das fokussierte Fenster weiter.
        * Sendet die Events an `compositor_state.seat.pointer`.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/input/pointer.rs`
* **Abhängigkeiten:**
    * **Intern:** `novade-core::input_types::{PointerEvent, MotionEvent, ButtonEvent, ScrollEvent}`, `crate::compositor::state::CompositorState`.
    * **Extern:** `smithay::input::pointer`, `tracing`.
* **Kommunikationsmuster:** Empfängt `PointerEvent` von `LibinputHandler`. Leitet an `CompositorState` weiter.
* **Erwartete Ergebnisse/Outputs:** Korrekte Verarbeitung von Pointer-Eingaben.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:** Testen von `process_pointer_event` mit verschiedenen Events.
* **Geschätzter Aufwand:** Gering

##### `novade-system/src/input/gestures.rs`

* **Verantwortlichkeit:** Verarbeitet Multitouch-Gesten-Events (z.B. Pinch, Swipe) und übersetzt sie in Desktop-Aktionen (z.B. Workspace-Wechsel, Zoom).
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `GestureHandler` definieren:**
        * Feld `desktop_state: Arc<RwLock<DesktopState>>`: Für Workspace-Wechsel.
        * Feld `compositor_window_management: Arc<dyn CompositorWindowManagement>`: Für Fensteraktionen.
    2.  **Konstruktor `new() -> Self` implementieren.**
    3.  **Methode `process_gesture_event(&mut self, event: &GestureEvent)` implementieren:**
        * Behandelt `PinchEvent`: Übersetzt in Zoom-Geste oder Skalierung.
        * Behandelt `SwipeEvent`: Übersetzt in Workspace-Wechsel (3-Finger Swipe) oder Fenster-Aktionen.
        * Behandelt `TapEvent`: Übersetzt in Klick.
        * Nutzt `desktop_state` und `compositor_window_management` zur Ausführung der Aktionen.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/input/gestures.rs`
* **Abhängigkeiten:**
    * **Intern:** `novade-core::input_types::GestureEvent`, `novade-domain::desktop_state::DesktopState`, `crate::compositor::window_management_iface::CompositorWindowManagement`.
    * **Extern:** `tracing`, `std::sync::{Arc, RwLock}`.
* **Kommunikationsmuster:** Empfängt `GestureEvent` von `LibinputHandler`. Interagiert mit `DesktopState` und `CompositorWindowManagement`.
* **Erwartete Ergebnisse/Outputs:** Intuitive Gestensteuerung des Desktops.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:** Mocking von `DesktopState` und `CompositorWindowManagement` zur Simulation von Gesten und Überprüfung der ausgelösten Aktionen.
* **Geschätzter Aufwand:** Mittel

##### `novade-system/src/input/service.rs`

* **Verantwortlichkeit:** Der zentrale Service für die Eingabeverwaltung. Initialisiert `libinput_handler`, `keyboard_handler`, `pointer_handler`, `gesture_handler` und leitet Events weiter.
* **Kern-Aufgaben (Tasks):**
    1.  **Struktur `InputManagerService` definieren:**
        * Felder:
            * `libinput_handler: LibinputHandler`
            * `keyboard_handler: KeyboardHandler`
            * `pointer_handler: PointerHandler`
            * `gesture_handler: GestureHandler`
            * `compositor_state: Arc<RwLock<CompositorState>>`
            * `input_event_sender: tokio::sync::broadcast::Sender<InputEvent>` (wird von `libinput_handler` verwendet und hier nur zur Weiterleitung an Dritte bereitgestellt).
    2.  **Konstruktor `new(compositor_state: Arc<RwLock<CompositorState>>, desktop_state: Arc<RwLock<DesktopState>>, config_service: Arc<ConfigServiceAsync>, display_handle: DisplayHandle) -> Result<Self, InputError>` implementieren:**
        * Initialisiert alle Handler.
        * Gibt den `InputManagerService` zurück.
    3.  **Asynchrone `run_event_loop()` Methode implementieren:**
        * Spawnt einen `tokio::task` für `libinput_handler.run_event_loop()`.
        * Erstellt einen `tokio::sync::broadcast::Receiver` für `libinput_handler.input_event_sender`.
        * Endlosschleife, die Events von `libinput_handler` empfängt.
        * Leitet jedes empfangene `InputEvent` an den entsprechenden Handler weiter (`keyboard_handler.process_key_event`, `pointer_handler.process_pointer_event`, `gesture_handler.process_gesture_event`).
        * Übergibt `compositor_state` als mutable Referenz an die Handler.
    4.  **Methoden zur Steuerung der Input-Einstellungen implementieren:** (z.B. `set_keyboard_layout`, `set_pointer_acceleration`). Diese rufen Methoden auf den jeweiligen Handlern auf und aktualisieren ggf. `GlobalSettingsService`.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/input/service.rs`
* **Abhängigkeiten:**
    * **Intern:** Alle anderen Module in `novade-system::input`, `crate::compositor::state::CompositorState`, `novade-domain::desktop_state::DesktopState`, `novade-domain::config::service::ConfigServiceAsync`.
    * **Extern:** `tokio`, `std::sync::{Arc, RwLock}`, `tokio::sync::broadcast`, `tracing`, `wayland_server::DisplayHandle`.
* **Kommunikationsmuster:**
    * Empfängt Roh-Events von `LibinputHandler`.
    * Sendet verarbeitete Events an `CompositorState`.
    * Bietet eine API für die Domänenschicht, um Eingabe-Einstellungen zu ändern.
* **Erwartete Ergebnisse/Outputs:** Ein zentraler Dienst für die umfassende Eingabeverwaltung.
* **Teststrategie (Modul-spezifisch):**
    * **Integration Tests:** End-to-End Tests mit echten oder simulierten Eingabegeräten, um den gesamten Event-Fluss zu überprüfen.
    * **Unit Tests:** Mocking von `LibinputHandler` und anderen Handlern, um die Event-Weiterleitung und die Konfigurationsänderungen zu testen.
* **Geschätzter Aufwand:** Hoch

##### `novade-system/src/input/mod.rs`

* **Verantwortlichkeit:** Definiert die öffentliche Schnittstelle des `input`-Moduls.
* **Kern-Aufgaben (Tasks):**
    1.  **Re-Exports:** Exportiert die wichtigsten Typen und Funktionen (`InputError`, `InputEvent`, `InputDevice`, `InputDeviceKind`, `InputManagerService`, `libinput_handler`, `keyboard`, `pointer`, `gestures`).
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/input/mod.rs`
* **Abhängigkeiten:** Keine direkten, re-exportiert aus den Untermodulen.
* **Kommunikationsmuster:** Keine.
* **Erwartete Ergebnisse/Outputs:** Eine saubere, einheitliche API für das `input`-Modul.
* **Teststrategie (Modul-spezifisch):** Verifizierung der Re-Exports (minimal).
* **Geschätzter Aufwand:** Gering
## 2. Detaillierte Implementierungspläne für NovaDE

### 2.1. Domänenschicht (`novade-domain`) Fortsetzung

#### `novade-domain/src/power_management`

* **Verzeichnis-/Modulname:** `novade-domain/src/power_management`
* **Verantwortlichkeit:** Dieses Modul ist für die Definition und Verarbeitung der Domänenlogik rund um das Energiemanagement des Systems verantwortlich. Es legt fest, wie NovaDE auf Energiesparereignisse reagiert und wie die Energieeinstellungen konfiguriert werden können.
* **Kern-Aufgaben (Tasks):**

    1.  **Definition der Datenstrukturen (`data_types.rs`):**
        * Definiere die Enum `PowerMode` mit Varianten wie `Performance`, `Balanced`, `PowerSaving`.
        * Definiere die Enum `SleepMode` mit Varianten wie `Suspend`, `Hibernate`, `HybridSleep`.
        * Definiere die Struktur `PowerSettings` mit Feldern wie `active_power_mode: PowerMode`, `idle_timeout_seconds: u32`, `lid_close_action: Option<SleepMode>`, `critical_battery_action: Option<SleepMode>`.
        * Implementiere für alle Strukturen und Enums `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
        * Implementiere eine `new()`-Funktion für `PowerSettings` mit Standardwerten.
    2.  **Definition der Fehler (`errors.rs`):**
        * Definiere das Enum `PowerManagementError` mit Varianten für typische Fehler im Energiemanagement (z.B. `SettingReadError`, `SettingWriteError`, `InvalidPowerMode`, `SystemCommandError`).
        * Implementiere `thiserror::Error`, `Debug` und `Display`.
        * Implementiere `From` für relevante Fehler aus `novade-core::error::CoreError` oder `novade-core::config::ConfigError`.
    3.  **Definition der Service-Schnittstelle (`service_iface.rs`):**
        * Definiere das asynchrone Trait `PowerManagementService` mit folgenden Methoden:
            * `get_current_power_mode() -> Result<PowerMode, PowerManagementError>`: Ruft den aktuell eingestellten Energiemodus ab.
            * `set_power_mode(&self, mode: PowerMode) -> Result<(), PowerManagementError>`: Setzt den Energiemodus und wendet die entsprechenden Systemrichtlinien an.
            * `get_power_settings() -> Result<PowerSettings, PowerManagementError>`: Ruft alle konfigurierten Energieeinstellungen ab.
            * `update_power_settings(&self, settings: PowerSettings) -> Result<(), PowerManagementError>`: Aktualisiert die Energieeinstellungen und persistiert sie.
            * `handle_lid_closed_event(&self) -> Result<(), PowerManagementError>`: Behandelt das Ereignis "Laptop-Deckel geschlossen" gemäß den Einstellungen.
            * `handle_battery_critical_event(&self) -> Result<(), PowerManagementError>`: Behandelt das Ereignis "Batterie kritisch" gemäß den Einstellungen.
            * `register_power_event_listener(&self) -> broadcast::Receiver<PowerEvent>`: Stellt einen `broadcast::Receiver` für Energieereignisse bereit (z.B. `PowerModeChanged`, `BatteryStatusChanged`).
        * Definiere das Enum `PowerEvent` für die Ereignisse.
    4.  **Implementierung des Power-Management-Service (`service.rs`):**
        * Implementiere die Struktur `DefaultPowerManagementService`, die das Trait `PowerManagementService` implementiert.
        * Halte Referenzen oder `Arc`s zu `Arc<dyn GlobalSettingsServiceAsync>` und `Arc<dyn SystemPowerControl>` (für die Systemschicht-Interaktion).
        * Verwende einen `RwLock` oder `Mutex` für den internen Zustand der Energieeinstellungen.
        * Implementiere die Methoden des Traits. Die `set_power_mode` und `update_power_settings` Methoden müssen die Änderungen über `GlobalSettingsServiceAsync` persistieren und relevante Systembefehle über `SystemPowerControl` in der Systemschicht auslösen.
        * Implementiere einen `tokio::sync::broadcast::Sender<PowerEvent>` für die Ereignisverteilung.
        * Erstelle eine interne, asynchrone Schleife (`run` Methode), die auf Ereignisse von der Systemschicht (z.B. `logind` über `SystemPowerControl`) hört und diese in `PowerEvent`s umwandelt und sendet.
    5.  **Integration mit GlobalSettingsService:**
        * Sicherstellen, dass `PowerSettings` über den `GlobalSettingsService` geladen und gespeichert werden kann. Dies erfordert die Registrierung der `PowerSettings` als konfigurierbarer Typ im `GlobalSettingsService`.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/power_management/data_types.rs`
    * `novade-domain/src/power_management/errors.rs`
    * `novade-domain/src/power_management/service_iface.rs`
    * `novade-domain/src/power_management/service.rs`
    * `novade-domain/src/power_management/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`, `novade-core::config`, `crate::global_settings::service_iface::GlobalSettingsServiceAsync`, `novade-system::power_control::SystemPowerControl` (im `service.rs`).
    * **Extern:** `serde::{Serialize, Deserialize}`, `thiserror`, `tokio::sync::{broadcast, RwLock, Mutex}`, `async_trait`.
* **Kommunikationsmuster:**
    * Empfängt und persistiert Einstellungen über `GlobalSettingsServiceAsync`.
    * Löst Aktionen in der `SystemPowerControl` der Systemschicht aus.
    * Sendet `PowerEvent`s über `tokio::sync::broadcast` an interessierte Parteien (z.B. UI-Schicht, Systemschicht).
* **Erwartete Ergebnisse/Outputs:** Ein voll funktionsfähiges Modul zur Verwaltung von Energieeinstellungen und zur Reaktion auf Energieereignisse, das die Domänenlogik von der Systeminteraktion trennt.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Tests für `PowerMode`, `SleepMode`, `PowerSettings` (Konstruktion, `Default`, Serialisierung/Deserialisierung).
        * Tests für `PowerManagementError` (Erstellung, `Display`, `source` chaining).
        * Tests für `DefaultPowerManagementService` mit gemockten `GlobalSettingsServiceAsync` und `SystemPowerControl`, um das Laden/Speichern von Einstellungen und das Auslösen von Systemaktionen zu überprüfen.
        * Tests für das Senden und Empfangen von `PowerEvent`s über den `broadcast::Sender`/`Receiver`.
        * Tests für die Logik der `handle_lid_closed_event` und `handle_battery_critical_event` Methoden basierend auf `PowerSettings`.
* **Geschätzter Aufwand:** 3-4 Tage

#### `novade-domain/src/device_management`

* **Verzeichnis-/Modulname:** `novade-domain/src/device_management`
* **Verantwortlichkeit:** Dieses Modul ist für die Abstraktion und Verwaltung von Geräten aus der Domänenperspektive verantwortlich, insbesondere für Eingabegeräte und andere Peripherie. Es definiert Gerätezustände, typische Aktionen und die Domänenlogik für die Geräteverwaltung.
* **Kern-Aufgaben (Tasks):**

    1.  **Definition der Datenstrukturen (`data_types.rs`):**
        * Definiere die Enum `DeviceType` (z.B. `Keyboard`, `Mouse`, `Touchpad`, `Monitor`, `AudioDevice`, `Other`).
        * Definiere die Struktur `DeviceInfo` mit Feldern wie `id: String` (eindeutiger Gerätename/ID), `name: String`, `device_type: DeviceType`, `is_connected: bool`, `properties: HashMap<String, String>` (generische Eigenschaften).
        * Definiere die Struktur `KeyboardLayout` mit Feldern wie `layout: String`, `variant: Option<String>`.
        * Definiere die Struktur `KeyboardSettings` mit Feldern wie `layouts: Vec<KeyboardLayout>`, `repeat_rate: u32`, `delay: u32`.
        * Definiere die Struktur `PointerSettings` mit Feldern wie `acceleration_profile: PointerAccelerationProfile`, `sensitivity: f64`, `scroll_direction_natural: bool`.
        * Definiere die Enum `PointerAccelerationProfile` (z.B. `Flat`, `Adaptive`, `Default`).
        * Definiere die Struktur `DeviceSettings` (aggregiert `KeyboardSettings`, `PointerSettings` und ggf. andere gerätetyp-spezifische Einstellungen).
        * Implementiere für alle Strukturen und Enums `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
    2.  **Definition der Fehler (`errors.rs`):**
        * Definiere das Enum `DeviceManagementError` mit Varianten (z.B. `DeviceNotFound`, `SettingsError`, `OperationFailed`).
        * Implementiere `thiserror::Error`, `Debug` und `Display`.
        * Implementiere `From` für relevante Fehler aus `novade-core::error::CoreError` oder `novade-core::config::ConfigError`.
    3.  **Definition der Service-Schnittstelle (`service_iface.rs`):**
        * Definiere das asynchrone Trait `DeviceManagementService` mit folgenden Methoden:
            * `list_connected_devices() -> Result<Vec<DeviceInfo>, DeviceManagementError>`: Listet alle aktuell verbundenen Geräte auf.
            * `get_device_info(&self, device_id: &str) -> Result<DeviceInfo, DeviceManagementError>`: Ruft detaillierte Informationen zu einem spezifischen Gerät ab.
            * `get_device_settings(&self, device_id: &str) -> Result<DeviceSettings, DeviceManagementError>`: Ruft die Einstellungen für ein spezifisches Gerät ab.
            * `update_device_settings(&self, device_id: &str, settings: DeviceSettings) -> Result<(), DeviceManagementError>`: Aktualisiert die Einstellungen für ein spezifisches Gerät und persistiert diese.
            * `register_device_event_listener(&self) -> broadcast::Receiver<DeviceEvent>`: Stellt einen `broadcast::Receiver` für Geräteereignisse bereit (z.B. `DeviceConnected`, `DeviceDisconnected`, `DeviceSettingsChanged`).
        * Definiere das Enum `DeviceEvent` für die Ereignisse.
    4.  **Implementierung des Device-Management-Service (`service.rs`):**
        * Implementiere die Struktur `DefaultDeviceManagementService`, die das Trait `DeviceManagementService` implementiert.
        * Halte Referenzen oder `Arc`s zu `Arc<dyn GlobalSettingsServiceAsync>` und `Arc<dyn SystemInputService>` (für die Systemschicht-Interaktion).
        * Implementiere die Methoden des Traits. Die `update_device_settings` Methode muss die Änderungen über `GlobalSettingsServiceAsync` persistieren und die entsprechenden Systembefehle über `SystemInputService` (z.B. für Tastaturlayouts, Zeigerbeschleunigung) auslösen.
        * Implementiere einen `tokio::sync::broadcast::Sender<DeviceEvent>` für die Ereignisverteilung.
        * Erstelle eine interne, asynchrone Schleife (`run` Methode), die auf Ereignisse von der Systemschicht (`SystemInputService`) hört (z.B. `DeviceAdded`, `DeviceRemoved`) und diese in `DeviceEvent`s umwandelt und sendet.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/device_management/data_types.rs`
    * `novade-domain/src/device_management/errors.rs`
    * `novade-domain/src/device_management/service_iface.rs`
    * `novade-domain/src/device_management/service.rs`
    * `novade-domain/src/device_management/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`, `novade-core::config`, `crate::global_settings::service_iface::GlobalSettingsServiceAsync`, `novade-system::input::SystemInputService` (im `service.rs`).
    * **Extern:** `serde::{Serialize, Deserialize}`, `thiserror`, `tokio::sync::broadcast`, `async_trait`, `std::collections::HashMap`.
* **Kommunikationsmuster:**
    * Empfängt und persistiert gerätespezifische Einstellungen über `GlobalSettingsServiceAsync`.
    * Löst gerätespezifische Aktionen in der `SystemInputService` der Systemschicht aus.
    * Sendet `DeviceEvent`s über `tokio::sync::broadcast` an interessierte Parteien.
* **Erwartete Ergebnisse/Outputs:** Ein Modul, das eine domänenspezifische Abstraktion über Systemgeräte bietet und deren Einstellungen verwaltet.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Tests für alle `data_types` (Konstruktion, `Default`, Serialisierung/Deserialisierung).
        * Tests für `DeviceManagementError`.
        * Tests für `DefaultDeviceManagementService` mit gemockten Abhängigkeiten, um die korrekte Weiterleitung von Einstellungen an die Systemschicht und die Verarbeitung von Systemereignissen zu überprüfen.
        * Tests für die Ereignisverteilung.
* **Geschätzter Aufwand:** 3-4 Tage

#### `novade-domain/src/app_management`

* **Verzeichnis-/Modulname:** `novade-domain/src/app_management`
* **Verantwortlichkeit:** Dieses Modul ist für die Verwaltung von Anwendungen aus der Domänenperspektive verantwortlich, einschließlich des Startens, Beendens und der Abfrage von Anwendungsdetails. Es abstrahiert die technischen Details der Anwendungsausführung und bietet eine domänenspezifische Schnittstelle für die Interaktion mit Anwendungen.
* **Kern-Aufgaben (Tasks):**

    1.  **Definition der Datenstrukturen (`data_types.rs`):**
        * Definiere die Struktur `ApplicationInfo` mit Feldern wie `desktop_entry_id: String` (der `desktop_entry_id` aus den `.desktop`-Dateien, z.B. "firefox.desktop"), `name: String`, `icon_name: Option<String>`, `command: String`, `generic_name: Option<String>`, `categories: Vec<String>`, `is_terminal_app: bool`, `no_display: bool`.
        * Definiere die Struktur `RunningApplicationInfo` mit Feldern wie `app_id: String` (Application ID, z.B. XDG-Shell `app_id`), `pid: u32`, `title: Option<String>`, `wm_class: Option<String>`, `icon: Option<Vec<u8>>` (binäre icon Daten, geladen bei Bedarf), `desktop_entry_id: Option<String>`.
        * Implementiere für alle Strukturen und Enums `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
    2.  **Definition der Fehler (`errors.rs`):**
        * Definiere das Enum `AppManagementError` mit Varianten (z.B. `AppNotFound`, `LaunchFailed`, `TerminateFailed`, `InvalidDesktopEntry`).
        * Implementiere `thiserror::Error`, `Debug` und `Display`.
        * Implementiere `From` für relevante Fehler aus `novade-core::error::CoreError`.
    3.  **Definition der Service-Schnittstelle (`service_iface.rs`):**
        * Definiere das asynchrone Trait `AppManagementService` mit folgenden Methoden:
            * `list_installed_applications() -> Result<Vec<ApplicationInfo>, AppManagementError>`: Listet alle auf dem System installierten Anwendungen auf (basierend auf `.desktop`-Dateien).
            * `get_application_info(&self, desktop_entry_id: &str) -> Result<ApplicationInfo, AppManagementError>`: Ruft detaillierte Informationen zu einer spezifischen installierten Anwendung ab.
            * `launch_application(&self, desktop_entry_id: &str, args: &[String]) -> Result<(), AppManagementError>`: Startet eine Anwendung anhand ihrer `desktop_entry_id`.
            * `list_running_applications() -> Result<Vec<RunningApplicationInfo>, AppManagementError>`: Listet alle aktuell laufenden Anwendungen auf.
            * `terminate_application(&self, app_id: &str) -> Result<(), AppManagementError>`: Beendet eine laufende Anwendung.
            * `register_application_event_listener(&self) -> broadcast::Receiver<ApplicationEvent>`: Stellt einen `broadcast::Receiver` für Anwendungsereignisse bereit (z.B. `ApplicationLaunched`, `ApplicationTerminated`, `ApplicationTitleChanged`).
        * Definiere das Enum `ApplicationEvent` für die Ereignisse.
    4.  **Implementierung des App-Management-Service (`service.rs`):**
        * Implementiere die Struktur `DefaultAppManagementService`, die das Trait `AppManagementService` implementiert.
        * Halte Referenzen oder `Arc`s zu `Arc<dyn SystemApplicationLauncher>` (für das Starten von Anwendungen) und `Arc<dyn SystemWindowService>` (für Informationen über laufende Anwendungen und ihre `app_id`s, `wm_class` etc.) aus der Systemschicht.
        * Implementiere die Methoden des Traits. Die `list_installed_applications` und `get_application_info` Methoden müssen `DesktopEntry`s parsen (ggf. über eine Hilfs-Crate). `launch_application` muss `SystemApplicationLauncher::launch_application` aufrufen. `list_running_applications` und `terminate_application` müssen `SystemWindowService` und ggf. andere System-APIs nutzen (z.B. `ps` oder D-Bus).
        * Implementiere einen `tokio::sync::broadcast::Sender<ApplicationEvent>` für die Ereignisverteilung.
        * Erstelle eine interne, asynchrone Schleife (`run` Methode), die auf Ereignisse von der Systemschicht (`SystemWindowService` für Fenstererstellung/-zerstörung, `SystemApplicationLauncher` für Start-/Beendungsereignisse) hört und diese in `ApplicationEvent`s umwandelt und sendet. Dies kann auch ein Polling-Mechanismus sein, falls keine direkten Systemereignisse verfügbar sind.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/app_management/data_types.rs`
    * `novade-domain/src/app_management/errors.rs`
    * `novade-domain/src/app_management/service_iface.rs`
    * `novade-domain/src/app_management/service.rs`
    * `novade-domain/src/app_management/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`, `novade-system::application_launcher::SystemApplicationLauncher`, `novade-system::window_service::SystemWindowService`.
    * **Extern:** `serde::{Serialize, Deserialize}`, `thiserror`, `tokio::sync::broadcast`, `async_trait`, `std::collections::HashMap`, `xdg_desktop_entry` (oder ähnliche Crate für `.desktop` Parsing).
* **Kommunikationsmuster:**
    * Delegiert das Starten von Anwendungen an `SystemApplicationLauncher`.
    * Fragt Informationen über laufende Anwendungen bei `SystemWindowService` ab.
    * Sendet `ApplicationEvent`s über `tokio::sync::broadcast` an interessierte Parteien.
* **Erwartete Ergebnisse/Outputs:** Ein Modul, das eine domänenspezifische Sicht auf installierte und laufende Anwendungen bietet und deren Lebenszyklus auf Domänenebene verwaltet.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Tests für `ApplicationInfo`, `RunningApplicationInfo` (Konstruktion, Serialisierung/Deserialisierung).
        * Tests für `AppManagementError`.
        * Tests für `DefaultAppManagementService` mit gemockten `SystemApplicationLauncher` und `SystemWindowService`, um das korrekte Parsen von `.desktop`-Dateien (mittels Mock-Daten), das Auslösen von Startbefehlen und die Verarbeitung von Anwendungsereignissen zu überprüfen.
        * Tests für die Ereignisverteilung.
* **Geschätzter Aufwand:** 4-5 Tage

#### `novade-domain/src/network_management`

* **Verzeichnis-/Modulname:** `novade-domain/src/network_management`
* **Verantwortlichkeit:** Dieses Modul verwaltet die Domänenlogik für Netzwerkverbindungen. Es abstrahiert die Komplexität von Netzwerk-APIs und bietet eine einheitliche Schnittstelle zur Abfrage des Netzwerkstatus, zur Verbindung zu Netzwerken und zur Verwaltung von Netzwerkprofilen.
* **Kern-Aufgaben (Tasks):**

    1.  **Definition der Datenstrukturen (`data_types.rs`):**
        * Definiere die Enum `NetworkType` (z.B. `Ethernet`, `Wifi`, `Bluetooth`, `Mobile`, `VPN`, `Loopback`).
        * Definiere die Enum `ConnectionStatus` (z.B. `Disconnected`, `Connecting`, `Connected`, `LimitedConnectivity`, `CaptivePortal`, `Unavailable`).
        * Definiere die Struktur `NetworkDevice` mit Feldern wie `name: String`, `device_type: NetworkType`, `is_enabled: bool`, `mac_address: String`, `ip_addresses: Vec<String>`.
        * Definiere die Struktur `WifiNetwork` mit Feldern wie `ssid: String`, `bssid: String`, `signal_strength: u8`, `security: WifiSecurityType`, `is_hidden: bool`.
        * Definiere die Enum `WifiSecurityType` (z.B. `None`, `WPA2Personal`, `WPA2Enterprise`, `WPA3Personal`, `WPA3Enterprise`).
        * Definiere die Struktur `NetworkConnection` mit Feldern wie `id: String`, `name: String`, `network_type: NetworkType`, `status: ConnectionStatus`.
        * Implementiere für alle Strukturen und Enums `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
    2.  **Definition der Fehler (`errors.rs`):**
        * Definiere das Enum `NetworkManagementError` mit Varianten (z.B. `NotConnected`, `ConnectionFailed`, `InvalidCredentials`, `DeviceError`, `ServiceUnavailable`).
        * Implementiere `thiserror::Error`, `Debug` und `Display`.
        * Implementiere `From` für relevante Fehler aus `novade-core::error::CoreError`.
    3.  **Definition der Service-Schnittstelle (`service_iface.rs`):**
        * Definiere das asynchrone Trait `NetworkManagementService` mit folgenden Methoden:
            * `get_overall_connection_status() -> Result<ConnectionStatus, NetworkManagementError>`: Ruft den allgemeinen Verbindungsstatus ab.
            * `list_network_devices() -> Result<Vec<NetworkDevice>, NetworkManagementError>`: Listet alle Netzwerkgeräte auf.
            * `list_wifi_networks() -> Result<Vec<WifiNetwork>, NetworkManagementError>`: Listet verfügbare WLAN-Netzwerke auf.
            * `connect_to_wifi(&self, ssid: &str, password: Option<&str>) -> Result<(), NetworkManagementError>`: Verbindet sich mit einem WLAN-Netzwerk.
            * `disconnect_from_network(&self, connection_id: &str) -> Result<(), NetworkManagementError>`: Trennt die Verbindung zu einem Netzwerk.
            * `get_active_connections() -> Result<Vec<NetworkConnection>, NetworkManagementError>`: Listet alle aktiven Netzwerkverbindungen auf.
            * `register_network_event_listener(&self) -> broadcast::Receiver<NetworkEvent>`: Stellt einen `broadcast::Receiver` für Netzwerkereignisse bereit (z.B. `ConnectionStatusChanged`, `WifiScanCompleted`, `DeviceStatusChanged`).
        * Definiere das Enum `NetworkEvent` für die Ereignisse.
    4.  **Implementierung des Network-Management-Service (`service.rs`):**
        * Implementiere die Struktur `DefaultNetworkManagementService`, die das Trait `NetworkManagementService` implementiert.
        * Halte Referenzen oder `Arc`s zu `Arc<dyn SystemNetworkService>` (für die Systemschicht-Interaktion, z.B. mit NetworkManager).
        * Implementiere die Methoden des Traits. Die Implementierung delegiert die eigentliche Arbeit an `SystemNetworkService`.
        * Implementiere einen `tokio::sync::broadcast::Sender<NetworkEvent>` für die Ereignisverteilung.
        * Erstelle eine interne, asynchrone Schleife (`run` Methode), die auf Ereignisse von der Systemschicht (`SystemNetworkService`) hört und diese in `NetworkEvent`s umwandelt und sendet.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/network_management/data_types.rs`
    * `novade-domain/src/network_management/errors.rs`
    * `novade-domain/src/network_management/service_iface.rs`
    * `novade-domain/src/network_management/service.rs`
    * `novade-domain/src/network_management/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`, `novade-system::network::SystemNetworkService`.
    * **Extern:** `serde::{Serialize, Deserialize}`, `thiserror`, `tokio::sync::broadcast`, `async_trait`.
* **Kommunikationsmuster:**
    * Delegiert Netzwerkanfragen an `SystemNetworkService`.
    * Empfängt Netzwerkereignisse von `SystemNetworkService` und verteilt sie weiter.
* **Erwartete Ergebnisse/Outputs:** Ein Modul, das eine domänenspezifische Schnittstelle für die Netzwerkverwaltung bietet und die Interaktion mit dem darunterliegenden System-Netzwerkdienst abstrahiert.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Tests für alle `data_types`.
        * Tests für `NetworkManagementError`.
        * Tests für `DefaultNetworkManagementService` mit gemocktem `SystemNetworkService`, um die korrekte Delegation von Aufrufen und die Verarbeitung von Netzwerkereignissen zu überprüfen.
        * Tests für die Ereignisverteilung.
* **Geschätzter Aufwand:** 3-4 Tage

#### `novade-domain/src/display_management`

* **Verzeichnis-/Modulname:** `novade-domain/src/display_management`
* **Verantwortlichkeit:** Dieses Modul verwaltet die Domänenlogik für die Display-Konfiguration, einschließlich Auflösung, Skalierung, Orientierung und der Anordnung mehrerer Monitore.
* **Kern-Aufgaben (Tasks):**

    1.  **Definition der Datenstrukturen (`data_types.rs`):**
        * Definiere die Struktur `Resolution` mit Feldern `width: u32`, `height: u32`, `refresh_rate: u32`.
        * Definiere die Enum `DisplayOrientation` mit Varianten `Normal`, `Left`, `Right`, `Inverted`.
        * Definiere die Struktur `DisplayMode` mit Feldern `resolution: Resolution`, `scale: f64`, `orientation: DisplayOrientation`.
        * Definiere die Struktur `MonitorInfo` mit Feldern `id: String`, `name: String`, `description: String`, `is_primary: bool`, `current_mode: DisplayMode`, `available_modes: Vec<DisplayMode>`, `position: novade_core::types::geometry::Point<i32>`.
        * Implementiere für alle Strukturen und Enums `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
    2.  **Definition der Fehler (`errors.rs`):**
        * Definiere das Enum `DisplayManagementError` mit Varianten (z.B. `DisplayNotFound`, `InvalidMode`, `ApplyFailed`, `ServiceUnavailable`).
        * Implementiere `thiserror::Error`, `Debug` und `Display`.
        * Implementiere `From` für relevante Fehler aus `novade-core::error::CoreError`.
    3.  **Definition der Service-Schnittstelle (`service_iface.rs`):**
        * Definiere das asynchrone Trait `DisplayManagementService` mit folgenden Methoden:
            * `list_connected_monitors() -> Result<Vec<MonitorInfo>, DisplayManagementError>`: Listet alle angeschlossenen Monitore mit ihren aktuellen und verfügbaren Modi auf.
            * `get_monitor_info(&self, monitor_id: &str) -> Result<MonitorInfo, DisplayManagementError>`: Ruft detaillierte Informationen zu einem spezifischen Monitor ab.
            * `apply_display_config(&self, configs: Vec<MonitorConfig>) -> Result<(), DisplayManagementError>`: Wendet eine Liste von Monitorkonfigurationen an.
            * `register_display_event_listener(&self) -> broadcast::Receiver<DisplayEvent>`: Stellt einen `broadcast::Receiver` für Display-Ereignisse bereit (z.B. `MonitorConnected`, `MonitorDisconnected`, `DisplayConfigChanged`).
        * Definiere die Struktur `MonitorConfig` mit Feldern `monitor_id: String`, `mode: DisplayMode`, `primary: bool`, `position: novade_core::types::geometry::Point<i32>`.
        * Definiere das Enum `DisplayEvent` für die Ereignisse.
    4.  **Implementierung des Display-Management-Service (`service.rs`):**
        * Implementiere die Struktur `DefaultDisplayManagementService`, die das Trait `DisplayManagementService` implementiert.
        * Halte Referenzen oder `Arc`s zu `Arc<dyn SystemDisplayConfigurator>` (für die Systemschicht-Interaktion, z.B. mit dem Compositor).
        * Implementiere die Methoden des Traits. Die Implementierung delegiert die eigentliche Arbeit an `SystemDisplayConfigurator`.
        * Implementiere einen `tokio::sync::broadcast::Sender<DisplayEvent>` für die Ereignisverteilung.
        * Erstelle eine interne, asynchrone Schleife (`run` Methode), die auf Ereignisse von der Systemschicht (`SystemDisplayConfigurator`) hört und diese in `DisplayEvent`s umwandelt und sendet.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/display_management/data_types.rs`
    * `novade-domain/src/display_management/errors.rs`
    * `novade-domain/src/display_management/service_iface.rs`
    * `novade-domain/src/display_management/service.rs`
    * `novade-domain/src/display_management/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`, `novade-core::types::geometry`, `novade-system::display_configurator::SystemDisplayConfigurator`.
    * **Extern:** `serde::{Serialize, Deserialize}`, `thiserror`, `tokio::sync::broadcast`, `async_trait`.
* **Kommunikationsmuster:**
    * Delegiert Display-Konfigurationsanfragen an `SystemDisplayConfigurator`.
    * Empfängt Display-Ereignisse von `SystemDisplayConfigurator` und verteilt sie weiter.
* **Erwartete Ergebnisse/Outputs:** Ein Modul, das eine domänenspezifische Abstraktion und Verwaltung von Displays und deren Konfigurationen bietet.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Tests für alle `data_types`.
        * Tests für `DisplayManagementError`.
        * Tests für `DefaultDisplayManagementService` mit gemocktem `SystemDisplayConfigurator`, um die korrekte Delegation von Aufrufen und die Verarbeitung von Display-Ereignissen zu überprüfen.
        * Tests für die Ereignisverteilung.
* **Geschätzter Aufwand:** 3-4 Tage

#### `novade-domain/src/session_management`

* **Verzeichnis-/Modulname:** `novade-domain/src/session_management`
* **Verantwortlichkeit:** Dieses Modul ist für die Domänenlogik der Benutzersitzungsverwaltung zuständig, einschließlich Authentifizierung, Sperren des Bildschirms, Abmelden, Neustarten und Herunterfahren des Systems.
* **Kern-Aufgaben (Tasks):**

    1.  **Definition der Datenstrukturen (`data_types.rs`):**
        * Definiere die Enum `SessionState` (z.B. `Active`, `Locked`, `Inactive`, `Terminating`).
        * Definiere die Enum `UserAction` (z.B. `Logout`, `Reboot`, `Shutdown`, `LockScreen`).
        * Definiere die Struktur `UserInfo` mit Feldern `username: String`, `real_name: Option<String>`, `uid: u32`, `gid: u32`, `home_dir: PathBuf`, `session_id: String` (von logind).
        * Implementiere für alle Strukturen und Enums `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
    2.  **Definition der Fehler (`errors.rs`):**
        * Definiere das Enum `SessionManagementError` mit Varianten (z.B. `AuthenticationFailed`, `PermissionDenied`, `ActionFailed`, `ServiceUnavailable`).
        * Implementiere `thiserror::Error`, `Debug` und `Display`.
        * Implementiere `From` für relevante Fehler aus `novade-core::error::CoreError`, `novade-core::security::SecurityError`.
    3.  **Definition der Service-Schnittstelle (`service_iface.rs`):**
        * Definiere das asynchrone Trait `SessionManagementService` mit folgenden Methoden:
            * `get_current_user_info() -> Result<UserInfo, SessionManagementError>`: Ruft Informationen über den aktuellen Benutzer ab.
            * `get_session_state() -> Result<SessionState, SessionManagementError>`: Ruft den aktuellen Sitzungsstatus ab.
            * `lock_screen() -> Result<(), SessionManagementError>`: Sperrt den Bildschirm.
            * `unlock_screen(&self, password: &str) -> Result<(), SessionManagementError>`: Entsperrt den Bildschirm mit einem Passwort (ggf. durch `PolicyKit` oder PAM-Integration in der Systemschicht).
            * `initiate_user_action(&self, action: UserAction) -> Result<(), SessionManagementError>`: Leitet eine Benutzeraktion (Abmelden, Neustart, Herunterfahren) ein.
            * `register_session_event_listener(&self) -> broadcast::Receiver<SessionEvent>`: Stellt einen `broadcast::Receiver` für Sitzungsereignisse bereit (z.B. `SessionStateChanged`, `ScreenLocked`, `ScreenUnlocked`).
        * Definiere das Enum `SessionEvent` für die Ereignisse.
    4.  **Implementierung des Session-Management-Service (`service.rs`):**
        * Implementiere die Struktur `DefaultSessionManagementService`, die das Trait `SessionManagementService` implementiert.
        * Halte Referenzen oder `Arc`s zu `Arc<dyn SystemLogindClient>` und `Arc<dyn SystemSecretService>` (für die Systemschicht-Interaktion). `SystemSecretService` ist relevant, wenn Passwörter zum Entsperren des Bildschirms über eine gesicherte Schnittstelle verifiziert werden müssen.
        * Implementiere die Methoden des Traits. Die Implementierung delegiert die eigentliche Arbeit an `SystemLogindClient` und `SystemSecretService` für Authentifizierung.
        * Implementiere einen `tokio::sync::broadcast::Sender<SessionEvent>` für die Ereignisverteilung.
        * Erstelle eine interne, asynchrone Schleife (`run` Methode), die auf Ereignisse von der Systemschicht (`SystemLogindClient`) hört und diese in `SessionEvent`s umwandelt und sendet.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/session_management/data_types.rs`
    * `novade-domain/src/session_management/errors.rs`
    * `novade-domain/src/session_management/service_iface.rs`
    * `novade-domain/src/session_management/service.rs`
    * `novade-domain/src/session_management/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`, `novade-core::security`, `novade-system::logind::SystemLogindClient`, `novade-system::secret_service::SystemSecretService` (optional, falls Bildschirmsperre Authentifizierung benötigt).
    * **Extern:** `serde::{Serialize, Deserialize}`, `thiserror`, `tokio::sync::broadcast`, `async_trait`, `std::path::PathBuf`.
* **Kommunikationsmuster:**
    * Delegiert Sitzungs- und Systembefehle an `SystemLogindClient`.
    * Delegiert Authentifizierungsanfragen an `SystemSecretService`.
    * Empfängt Sitzungsereignisse von `SystemLogindClient` und verteilt sie weiter.
* **Erwartete Ergebnisse/Outputs:** Ein Modul, das eine domänenspezifische Schnittstelle für die Sitzungsverwaltung bietet und die Interaktion mit Systemdiensten abstrahiert.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Tests für alle `data_types`.
        * Tests für `SessionManagementError`.
        * Tests für `DefaultSessionManagementService` mit gemocktem `SystemLogindClient` und `SystemSecretService`, um die korrekte Delegation von Aufrufen und die Verarbeitung von Sitzungsereignissen zu überprüfen.
        * Tests für die Ereignisverteilung.
* **Geschätzter Aufwand:** 3-4 Tage

#### `novade-domain/src/notification_rules`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules`
* **Verantwortlichkeit:** Dieses Modul implementiert die Domänenlogik für die Verwaltung und Verarbeitung von Regeln für Benachrichtigungen. Es ermöglicht die Filterung, Modifikation und das Auslösen von Aktionen basierend auf eingehenden Benachrichtigungen.
* **Kern-Aufgaben (Tasks):**

    1.  **Definition der Datenstrukturen (`data_types.rs`):**
        * Definiere die Enums `Field`, `Operator`, `ConditionValueType`.
            * `Field`: `AppName`, `Summary`, `Body`, `Category`, `Urgency`, `ExpireTimeout`.
            * `Operator`: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `GreaterThan`, `LessThan`, `MatchesRegex`, `SettingIsTrue`.
            * `ConditionValueType`: `String(String)`, `Integer(i32)`, `Boolean(bool)`.
        * Definiere die Strukturen `SimpleRuleCondition`, `RuleCondition`, `RuleAction`, `NotificationRule`, `NotificationRuleSet`.
            * `SimpleRuleCondition`: `field: Field`, `operator: Operator`, `value: ConditionValueType`.
            * `RuleCondition`: `condition_type: ConditionType` (`Simple(SimpleRuleCondition)`, `And(Vec<RuleCondition>)`, `Or(Vec<RuleCondition>)`, `Not(Box<RuleCondition>)`). Ermöglicht komplexe, verschachtelte Bedingungen.
            * `RuleAction`: `action_type: ActionType` (`HideNotification`, `SetUrgency(Urgency)`, `PlaySound(String)`, `ExecuteCommand(String)`, `StopProcessingFurtherRules`, `ApplyTheme(String)`).
            * `NotificationRule`: `id: Uuid`, `name: String`, `enabled: bool`, `priority: u32`, `conditions: RuleCondition`, `actions: Vec<RuleAction>`.
            * `NotificationRuleSet`: `rules: Vec<NotificationRule>`. (Dieses Set ist die Persistenz-Einheit).
        * Implementiere für alle Strukturen und Enums `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`, `Eq`, `Hash` (wo sinnvoll, z.B. für Enums und `NotificationRule`).
    2.  **Definition der Fehler (`errors.rs`):**
        * Definiere das Enum `NotificationRulesError` mit Varianten (z.B. `RuleNotFound`, `InvalidCondition`, `InvalidAction`, `PersistenceError`, `RegexError`).
        * Implementiere `thiserror::Error`, `Debug` und `Display`.
        * Implementiere `From` für relevante Fehler aus `novade-core::error::CoreError`, `novade-core::config::ConfigError`.
    3.  **Definition der Persistenz-Schnittstelle (`persistence_iface.rs`):**
        * Definiere das asynchrone Trait `NotificationRulesProvider` mit Methoden:
            * `load_rules() -> Result<NotificationRuleSet, NotificationRulesError>`: Lädt die Regeln.
            * `save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`: Speichert die Regeln.
    4.  **Implementierung der Persistenz (`persistence.rs`):**
        * Implementiere die Struktur `FilesystemNotificationRulesProvider`, die `NotificationRulesProvider` implementiert.
        * Nutze `novade-core::config::ConfigServiceAsync` zum Lesen und Schreiben von Konfigurationsdateien (z.B. JSON oder YAML).
        * Pfad zur Datei: `~/.config/novade/notification_rules.json` (oder entsprechend XDG Base Directory).
    5.  **Definition der Engine-Schnittstelle (`engine_iface.rs`):**
        * Definiere das asynchrone Trait `NotificationRulesEngine` mit Methoden:
            * `reload_rules() -> Result<(), NotificationRulesError>`: Lädt die Regeln neu aus der Persistenz.
            * `process_notification(&self, notification: &mut IncomingNotification) -> Result<RuleProcessingResult, NotificationRulesError>`: Verarbeitet eine eingehende Benachrichtigung gegen die Regeln. `IncomingNotification` ist ein domänenspezifischer Typ, der die eingehende D-Bus-Benachrichtigung abbildet.
            * `get_rules() -> Result<NotificationRuleSet, NotificationRulesError>`: Gibt die aktuell geladenen Regeln zurück.
            * `update_rules(&self, rules: NotificationRuleSet) -> Result<(), NotificationRulesError>`: Aktualisiert die Regeln im Speicher und persistiert sie.
        * Definiere das Enum `RuleProcessingResult` (`Continue`, `Stop`).
    6.  **Implementierung der Regel-Engine (`engine.rs`):**
        * Implementiere die Struktur `DefaultNotificationRulesEngine`, die `NotificationRulesEngine` implementiert.
        * Halte eine Referenz (`Arc<dyn NotificationRulesProvider>`) zur Persistenzschicht und eine Referenz (`Arc<dyn GlobalSettingsServiceAsync>`) zur Abfrage von Einstellungen für `SettingIsTrue`.
        * Verwende einen `tokio::sync::RwLock<NotificationRuleSet>` für den internen Regel-Zustand, um konkurrierenden Zugriff zu steuern.
        * `reload_rules()`: Lädt Regeln über `NotificationRulesProvider` und aktualisiert den `RwLock`-Zustand. Sortiere die Regeln nach Priorität.
        * `process_notification()`:
            * Iteriere über die aktivierten Regeln, sortiert nach Priorität.
            * Für jede Regel: Bewerte die `conditions` rekursiv.
                * Implementiere die Logik für jeden `Field` und `Operator`. Bei `SettingIsTrue` Abfrage des `GlobalSettingsServiceAsync`.
                * Nutze die `regex` Crate für `MatchesRegex`.
            * Wenn Bedingungen erfüllt sind, wende die `actions` auf die `IncomingNotification` an (z.B. Modifizieren der `Urgency`, Setzen von `hide_notification` Flag, Ausführen von Shell-Befehlen über `tokio::process::Command` im Hintergrund, aber *nicht* blockierend!).
            * Wenn eine `StopProcessingFurtherRules`-Aktion ausgelöst wird, beende die Verarbeitung und gib `Stop` zurück.
            * Ansonsten gib `Continue` zurück.
        * `get_rules()` und `update_rules()`: Greifen auf den `RwLock`-Zustand zu und nutzen `NotificationRulesProvider` zum Speichern.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification_rules/data_types.rs`
    * `novade-domain/src/notification_rules/errors.rs`
    * `novade-domain/src/notification_rules/persistence_iface.rs`
    * `novade-domain/src/notification_rules/persistence.rs`
    * `novade-domain/src/notification_rules/engine_iface.rs`
    * `novade-domain/src/notification_rules/engine.rs`
    * `novade-domain/src/notification_rules/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`, `novade-core::config::ConfigServiceAsync`, `novade-domain::global_settings::service_iface::GlobalSettingsServiceAsync`, `novade-domain::notification_service::data_types::IncomingNotification` (für `process_notification`).
    * **Extern:** `serde::{Serialize, Deserialize}`, `thiserror`, `tokio::sync::RwLock`, `async_trait`, `uuid` (für `Uuid`), `regex` (für `MatchesRegex`).
* **Kommunikationsmuster:**
    * `DefaultNotificationRulesEngine` fragt Regeln von `NotificationRulesProvider` ab und persistiert sie dorthin.
    * `DefaultNotificationRulesEngine` fragt Einstellungen von `GlobalSettingsServiceAsync` ab.
    * `NotificationService` ruft `NotificationRulesEngine::process_notification` auf.
* **Erwartete Ergebnisse/Outputs:** Eine robuste Regel-Engine, die Benachrichtigungen basierend auf konfigurierbaren Kriterien filtern und modifizieren kann.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Tests für alle `data_types` (Konstruktion, `Default`, Serialisierung/Deserialisierung, `Eq`, `Hash`).
        * Tests für `NotificationRulesError`.
        * Tests für `FilesystemNotificationRulesProvider`: Laden und Speichern von Regeln, Fehlerbehandlung bei ungültigen Dateien (mit Mocking von `ConfigServiceAsync`).
        * Tests für `DefaultNotificationRulesEngine`:
            * Tests für die Bedingungsauswertung: alle `Field`s, alle `Operator`s, verschiedene `ConditionValueType`s.
            * Testen von `And`, `Or`, `Not` Kombinationen.
            * Testen von `SettingIsTrue` mit gemocktem `GlobalSettingsServiceAsync`.
            * Tests für die Aktionsanwendung: `HideNotification`, `SetUrgency`, `PlaySound`, `ExecuteCommand` (mit Mocking des Kommando-Ausführers), `StopProcessingFurtherRules`, `ApplyTheme`.
            * Testen der Regelpriorisierung.
            * Testen von `reload_rules`, `get_rules`, `update_rules`.
            * Edge-Cases: Leere Regeln, Regeln mit ungültigen Ausdrücken.
* **Geschätzter Aufwand:** 5-7 Tage (aufgrund der Komplexität der Regel-Engine)

#### `novade-domain/src/notification_service`

* **Verzeichnis-/Modulname:** `novade-domain/src/notification_service`
* **Verantwortlichkeit:** Dieses Modul ist für die zentrale Verwaltung von Desktop-Benachrichtigungen zuständig. Es empfängt Benachrichtigungen, verarbeitet sie über die Regel-Engine, verwaltet ihren Lebenszyklus und stellt eine Schnittstelle für die UI-Schicht zur Anzeige bereit.
* **Kern-Aufgaben (Tasks):**

    1.  **Definition der Datenstrukturen (`data_types.rs`):**
        * Definiere die Enum `Urgency` (z.B. `Low`, `Normal`, `Critical`).
        * Definiere die Struktur `NotificationAction` mit Feldern `key: String`, `label: String`.
        * Definiere die Struktur `IncomingNotification` mit Feldern:
            * `app_name: String`
            * `replaces_id: u32` (0 für neue, sonst ID der zu ersetzenden Benachrichtigung)
            * `app_icon: Option<String>` (Name oder Pfad)
            * `summary: String`
            * `body: Option<String>`
            * `actions: Vec<NotificationAction>`
            * `hints: HashMap<String, Value>` (für D-Bus Hints, `Value` aus `zbus::fdo::DBusValue`)
            * `expire_timeout_ms: i32` (-1 für Standard, 0 für niemals, sonst ms)
            * `category: Option<String>`
            * `urgency: Urgency`
            * `timestamp: DateTime<Utc>` (Zeitpunkt des Empfangs)
            * `source_dbus_id: u32` (interne D-Bus-ID der Benachrichtigung, falls vom System bereitgestellt)
            * `hidden_by_rule: bool` (internes Flag, gesetzt durch `notification_rules`)
            * `_internal_id: Uuid` (eindeutiger NovaDE-interne ID für die Benachrichtigung)
        * Definiere die Struktur `DisplayedNotification` (abgeleitet von `IncomingNotification`, ggf. mit zusätzlichen UI-relevanten Feldern wie `on_screen_position`).
        * Implementiere für alle Strukturen und Enums `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`, `Default`.
    2.  **Definition der Fehler (`errors.rs`):**
        * Definiere das Enum `NotificationServiceError` mit Varianten (z.B. `NotificationNotFound`, `ActionExecutionFailed`, `InvalidNotificationData`, `ServiceUnavailable`).
        * Implementiere `thiserror::Error`, `Debug` und `Display`.
        * Implementiere `From` für relevante Fehler aus `novade-core::error::CoreError`, `crate::notification_rules::errors::NotificationRulesError`.
    3.  **Definition der Service-Schnittstelle (`service_iface.rs`):**
        * Definiere das asynchrone Trait `NotificationService` mit folgenden Methoden:
            * `handle_incoming_notification(&self, notification: IncomingNotification) -> Result<Uuid, NotificationServiceError>`: Empfängt eine neue Benachrichtigung, verarbeitet sie über die Regel-Engine und fügt sie dem internen Speicher hinzu. Gibt die interne UUID zurück.
            * `get_all_active_notifications() -> Result<Vec<DisplayedNotification>, NotificationServiceError>`: Ruft alle aktuell aktiven (nicht versteckten, nicht abgelaufenen) Benachrichtigungen ab.
            * `get_notification_by_id(&self, id: Uuid) -> Result<DisplayedNotification, NotificationServiceError>`: Ruft eine spezifische Benachrichtigung ab.
            * `close_notification(&self, id: Uuid, reason: CloseReason) -> Result<(), NotificationServiceError>`: Schließt eine Benachrichtigung.
            * `invoke_notification_action(&self, id: Uuid, action_key: &str) -> Result<(), NotificationServiceError>`: Führt eine spezifische Aktion einer Benachrichtigung aus (z.B. Button-Klick).
            * `clear_all_notifications() -> Result<(), NotificationServiceError>`: Löscht alle aktiven Benachrichtigungen.
            * `register_notification_event_listener(&self) -> broadcast::Receiver<NotificationEvent>`: Stellt einen `broadcast::Receiver` für Benachrichtigungsereignisse bereit (z.B. `NotificationAdded`, `NotificationUpdated`, `NotificationClosed`, `NotificationActionInvoked`).
        * Definiere das Enum `CloseReason` (`Dismissed`, `Expired`, `ClosedByDaemon`, `UserRequest`).
        * Definiere das Enum `NotificationEvent` für die Ereignisse.
    4.  **Implementierung des Notification-Service (`service.rs`):**
        * Implementiere die Struktur `DefaultNotificationService`, die das Trait `NotificationService` implementiert.
        * Halte Referenzen oder `Arc`s zu `Arc<dyn NotificationRulesEngine>` und `Arc<dyn SystemNotificationClient>` (für die Interaktion mit dem D-Bus Notification Server in der Systemschicht, wenn NovaDE der Client ist, oder um Aktionen zurück an den ursprünglichen Sender zu senden).
        * Verwende einen `tokio::sync::RwLock<HashMap<Uuid, IncomingNotification>>` für den internen Speicher aktiver Benachrichtigungen.
        * Implementiere die Methoden des Traits:
            * `handle_incoming_notification`: Ruft `NotificationRulesEngine::process_notification` auf. Setzt `hidden_by_rule` basierend auf dem Ergebnis. Fügt die Benachrichtigung zum internen Speicher hinzu. Startet einen `tokio::time::sleep` Task für `expire_timeout_ms` (falls nicht 0 oder -1), der dann `close_notification` aufruft. Sendet `NotificationAdded` oder `NotificationUpdated` Event.
            * `close_notification`: Entfernt Benachrichtigung aus dem Speicher. Sendet `NotificationClosed` Event. Bei Benachrichtigungen mit `replaces_id`, muss `SystemNotificationClient::notification_closed` aufgerufen werden.
            * `invoke_notification_action`: Führt die Logik für die Aktion aus. Bei D-Bus-Aktionen muss `SystemNotificationClient::action_invoked` aufgerufen werden. Sendet `NotificationActionInvoked` Event.
            * Beachte, dass die D-Bus-Kommunikation für eingehende Benachrichtigungen (als Server) in der `Systemschicht` (`system::dbus_interfaces::notifications_server`) stattfindet, die dann `handle_incoming_notification` aufruft.
        * Implementiere einen `tokio::sync::broadcast::Sender<NotificationEvent>` für die Ereignisverteilung.
* **Spezifische Artefakte/Dateien:**
    * `novade-domain/src/notification_service/data_types.rs`
    * `novade-domain/src/notification_service/errors.rs`
    * `novade-domain/src/notification_service/service_iface.rs`
    * `novade-domain/src/notification_service/service.rs`
    * `novade-domain/src/notification_service/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`, `crate::notification_rules::engine_iface::NotificationRulesEngine`, `novade-system::dbus_interfaces::notifications_client::SystemNotificationClient` (für das Senden von `CloseNotification` und `ActionInvoked` zurück an den Absender).
    * **Extern:** `serde::{Serialize, Deserialize}`, `thiserror`, `tokio::sync::{broadcast, RwLock}`, `async_trait`, `uuid`, `chrono::{DateTime, Utc}`, `std::collections::HashMap`, `zbus::zvariant::Value` (oder `serde_json::Value` wenn zbus-Value in json gewandelt).
* **Kommunikationsmuster:**
    * Empfängt Benachrichtigungen von `SystemNotificationClient` (indirekt über `system::dbus_interfaces::notifications_server`).
    * Ruft `NotificationRulesEngine` zur Verarbeitung auf.
    * Sendet Ereignisse an UI-Schicht und andere interessierte Parteien.
    * Sendet Bestätigungen/Aktionen zurück an `SystemNotificationClient`.
* **Erwartete Ergebnisse/Outputs:** Eine zentrale Verwaltung für alle eingehenden Benachrichtigungen, die die Regeln anwendet und Benachrichtigungsereignisse bereitstellt.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Tests für alle `data_types`.
        * Tests für `NotificationServiceError`.
        * Tests für `DefaultNotificationService` mit gemockter `NotificationRulesEngine` und `SystemNotificationClient`.
        * Testen von `handle_incoming_notification` (mit/ohne Regeln, Ersetzen von Benachrichtigungen, Ablaufzeiten).
        * Testen von `close_notification` (verschiedene Gründe).
        * Testen von `invoke_notification_action` (Ausführen von Aktionen, Senden an `SystemNotificationClient`).
        * Testen der Ereignisverteilung für alle Event-Typen.
        * Testen der Korrektheit des internen Speichers (Hinzufügen, Entfernen, Aktualisieren).
* **Geschätzter Aufwand:** 4-6 Tage

### 2.2. Systemschicht (`novade-system`)

#### `novade-system/src/compositor`

* **Verzeichnis-/Modulname:** `novade-system/src/compositor`
* **Verantwortlichkeit:** Dieses Modul implementiert den Smithay-basierten Wayland-Compositor. Es ist für das Fenster-Lebenszyklusmanagement, die Implementierung relevanter Wayland-Protokolle (XDG-Shell, Layer-Shell, etc.), die Renderer-Abstraktion und XWayland-Unterstützung zuständig. Dies ist die *zentrale* Komponente der Systemschicht, die visuelle Ausgabe und grundlegende Interaktion ermöglicht.
* **Kern-Aufgaben (Tasks):**

    1.  **Struktur des Compositors (`core.rs`):**
        * Definiere die Hauptstruktur des Compositors (z.B. `NovaCompositor`), die den Smithay `Display` und `Backend` sowie alle relevanten Wayland-Clients und Handler kapselt.
        * Initialisiere Smithay `Display` und `Backend` (z.B. `winit` für Testzwecke, später `libdrm`).
        * Implementiere den Haupt-Event-Loop des Compositors.
        * Definiere und implementiere `CompositorState` (`UserData` für Smithay), die alle Smithay-bezogenen Zustände und die `DesktopState` der Domänenschicht enthält.
        * Erstelle die Methode `create_all_wayland_globals(&mut self, display_handle: &DisplayHandle)`: Initialisiert alle erforderlichen Wayland Globals (XDG-Shell, zwp_input_method_v2, zwp_text_input_v3, zwlr_layer_shell_v1, xdg-output, seat, etc.).
        * Implementiere die `run()`-Methode für den Compositor, die den Event-Loop startet und verwaltet.
    2.  **XDG-Shell Implementierung (`xdg_shell.rs`):**
        * Implementiere `xdg_shell::XdgShellHandler` Trait für `NovaCompositor`.
        * Implementiere die Handhabung von `xdg_shell::XdgShellSurface` Zustandsänderungen (Konfigurationen, Größenänderungen, Minimieren/Maximieren).
        * Definiere den Smithay `xdg_shell::XdgToplevelSurfaceData` für jeden XDG-Toplevel.
        * Definiere den Smithay `xdg_shell::XdgPopupSurfaceData` für XDG-Popups.
        * Implementiere die Rolle für `xdg_shell::xdg_toplevel::XdgToplevelSurfaceRole` und `xdg_shell::xdg_popup::XdgPopupSurfaceRole`.
    3.  **Layer-Shell Implementierung (`layer_shell.rs`):**
        * Implementiere `smithay::wayland::shell::wlr_layer::WlrLayerShellHandler` Trait für `NovaCompositor`.
        * Verwalte Layer-Shell-Oberflächen (Panels, Docks, Desktops) und deren Positionierung (`Anchor`).
        * Implementiere die Logik für `KeyboardInteractivity` und `Layer`.
        * Definiere den Smithay `wlr_layer::LayerSurfaceData` für jede Layer-Shell-Oberfläche.
    4.  **Seat Management (`seat.rs`):**
        * Implementiere `smithay::input::SeatHandler` Trait für `NovaCompositor`.
        * Verwalte Zeiger (`Pointer`), Tastatur (`Keyboard`) und Touch-Geräte.
        * Aktualisiere den Cursor-Icon-Zustand.
        * Sende Fokus-Ereignisse an Clients.
        * Behandle Tastenanschläge und Mausbewegungen (Weiterleitung an `input::handler`).
    5.  **Output Management (`output.rs`):**
        * Implementiere `smithay::wayland::output::OutputHandler` Trait für `NovaCompositor`.
        * Verwaltung von Monitoren/Outputs.
        * Erstelle `Output` Instanzen für jeden verbundenen Monitor (physisch oder virtuell).
        * Aktualisiere die `Output` Konfiguration (Auflösung, Skalierung, Position) basierend auf `DisplayManagementService` in der Domänenschicht.
        * Implementiere `xdg_output` Protokoll (falls verwendet).
    6.  **Renderer (`renderer.rs`):**
        * Implementiere `smithay::backend::renderer::Renderer` und `smithay::backend::renderer::ImportMem` für den gewählten Renderer (z.B. `glium` oder `nix-drm`).
        * Definiere die Zeichenlogik für Oberflächen (XDG-Shell, Layer-Shell, Cursors).
        * Implementiere `smithay::render_surface`.
    7.  **Backend Integration (`backend.rs`):**
        * Implementiere `smithay::backend::winit::WinitGraphicsBackend` oder `smithay::backend::drm::DrmBackend` (basierend auf der gewählten Rendering-Methode).
        * Behandle Backend-Ereignisse (Frame-Ready, Input, etc.).
        * Verknüpfung des Backends mit dem Compositor-Haupt-Loop.
    8.  **XWayland Support (`xwayland.rs`, optional aber empfohlen):**
        * Initialisiere `smithay::xwayland::XWayland` Instanz.
        * Implementiere `smithay::xwayland::XWaylandHandler` Trait für `NovaCompositor`.
        * Behandle XWayland-Clients und ihre Fenster.
        * Sicherstellen der Kompatibilität mit X-Anwendungen.
    9.  **Fehler (`errors.rs`):**
        * Definiere `CompositorError` Enum mit Varianten (z.B. `BackendError`, `ProtocolError`, `InitializationError`).
        * Implementiere `thiserror::Error`, `Debug`, `Display`.
        * Implementiere `From` für Smithay-Fehler.
    10. **Service-Schnittstelle (`service_iface.rs`):**
        * Definiere das Trait `SystemWindowService` und `SystemDisplayConfigurator` (siehe unten, in anderen Modulen spezifiziert) als Schnittstellen, die vom Compositor implementiert werden.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/compositor/core.rs` (Haupt-Compositor-Logik)
    * `novade-system/src/compositor/xdg_shell.rs`
    * `novade-system/src/compositor/layer_shell.rs`
    * `novade-system/src/compositor/seat.rs`
    * `novade-system/src/compositor/output.rs`
    * `novade-system/src/compositor/renderer.rs`
    * `novade-system/src/compositor/backend.rs`
    * `novade-system/src/compositor/xwayland.rs` (optional)
    * `novade-system/src/compositor/errors.rs`
    * `novade-system/src/compositor/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`, `novade-core::types::geometry`, `novade-domain::desktop_state::DesktopState` (für den Zugriff auf den globalen Zustand), `novade-domain::display_management::DisplayManagementService` (für Display-Konfiguration), `novade-domain::window_policy::WindowPolicyService` (für Fenster-Richtlinien).
    * **Extern:** `smithay` (alle relevanten Module), `wayland-server`, `wayland-protocols`, `xkbcommon`, `libinput`, `tokio`, `async-trait`, `thiserror`, `tracing`, `image` (für Cursor-Theming), `rustix` (für DrmBackend).
* **Kommunikationsmuster:**
    * Interagiert direkt mit `DesktopState` zum Abrufen und Aktualisieren von Zustandsinformationen.
    * Verwendet `WindowPolicyService` und `DisplayManagementService` für Domänenlogik-Entscheidungen.
    * Empfängt Roh-Eingabe-Events von `libinput` (im `input` Modul) und wandelt sie in Wayland-Events um.
    * Sendet Wayland-Events an Clients.
    * Stellt über interne Traits (`SystemWindowService`, `SystemDisplayConfigurator`) Schnittstellen für andere System- und Domänenmodule bereit.
* **Erwartete Ergebnisse/Outputs:** Ein voll funktionsfähiger Wayland-Compositor, der Fenster darstellt, Eingaben verarbeitet und die Kommunikation mit Wayland-Clients und XWayland-Clients ermöglicht.
* **Teststrategie (Modul-spezifisch):**
    * **Integration Tests (Compositor-Tests):**
        * Starten des Compositors mit einem Dummy-Backend (z.B. `winit` oder ein reiner Test-Backend).
        * Starten von Wayland-Clients (z.B. `weston-terminal`, `gtk-demo`) und Überprüfen des Fensterverhaltens (Größenänderung, Verschieben, Minimieren/Maximieren).
        * Testen von Layer-Shell-Clients (Panels, Docks) und deren korrekter Positionierung.
        * Testen der Eingabeverarbeitung (Tastatur-Events, Maus-Events, Touch-Events).
        * Testen der `xdg-output` Protokoll-Implementierung.
        * Wenn XWayland implementiert ist: Starten von X-Anwendungen und Überprüfen des Verhaltens.
    * **Unit Tests:** (Eher für Helfer-Funktionen oder kleine Logik-Einheiten innerhalb des Compositors).
* **Geschätzter Aufwand:** 20-30 Tage (Dies ist die komplexeste Komponente, da sie das Herzstück der grafischen Oberfläche bildet und viele Wayland-Protokolle implementieren muss.)

#### `novade-system/src/input`

* **Verzeichnis-/Modulname:** `novade-system/src/input`
* **Verantwortlichkeit:** Dieses Modul ist für die `libinput`-basierte Eingabeverarbeitung zuständig. Es verwaltet Eingabegeräte (Keyboards, Mäuse, Touchpads), integriert `xkbcommon` für Tastaturlayouts, verarbeitet rohe Eingabeereignisse und übersetzt sie in Wayland-konforme Events für den Compositor.
* **Kern-Aufgaben (Tasks):**

    1.  **Libinput Integration (`libinput_handler.rs`):**
        * Initialisiere `libinput::Libinput` Kontext und Event-Schleife.
        * Implementiere `libinput::LibinputInterface` Trait für die Handhabung von Dateideskriptoren (z.B. `open_restricted`, `close_restricted`). Dies erfordert ggf. `logind` Integration (über `SystemLogindClient` in `dbus_interfaces`).
        * Erstelle eine asynchrone Task, die kontinuierlich `libinput` Events liest und diese verarbeitet.
        * Sende rohe `libinput` Events an den Compositor's `seat` Handler.
    2.  **XKBCommon Integration (`xkb_handler.rs`):**
        * Initialisiere `xkbcommon::xkb::Context`.
        * Verwalte Tastatur-Zustände (`xkbcommon::xkb::State`) für jedes Tastaturgerät.
        * Behandle Keymap-Änderungen.
        * Übersetze rohe Tastatur-Events (`EvKey`) in Wayland-Keycodes und Symbole.
        * Implementiere die Logik für Tastatur-Layout-Wechsel basierend auf den `KeyboardSettings` aus der Domänenschicht.
    3.  **Geräteverwaltung (`device_manager.rs`):**
        * Erkenne und verwalte angeschlossene und getrennte Eingabegeräte.
        * Halte eine Liste der aktiven Eingabegeräte (`libinput::Device`).
        * Sende `DeviceEvent`s (Hinzugefügt/Entfernt) an den `DeviceManagementService` in der Domänenschicht.
        * Wende `DeviceSettings` (z.B. Pointer-Beschleunigung, Tastatur-Layouts) an, die vom `DeviceManagementService` empfangen werden.
    4.  **Fehler (`errors.rs`):**
        * Definiere `InputError` Enum mit Varianten (z.B. `LibinputError`, `XkbError`, `PermissionError`).
        * Implementiere `thiserror::Error`, `Debug`, `Display`.
    5.  **Service-Schnittstelle (`service_iface.rs`):**
        * Definiere das Trait `SystemInputService` mit Methoden:
            * `get_connected_input_devices() -> Result<Vec<DeviceInfo>, InputError>`: Listet Details zu den Eingabegeräten auf (für `DeviceManagementService`).
            * `apply_keyboard_settings(&self, device_id: &str, settings: KeyboardSettings) -> Result<(), InputError>`: Wendet Tastatur-Einstellungen an.
            * `apply_pointer_settings(&self, device_id: &str, settings: PointerSettings) -> Result<(), InputError>`: Wendet Zeiger-Einstellungen an.
            * `register_raw_input_event_listener(&self) -> broadcast::Receiver<RawInputEvent>`: Stellt einen Receiver für rohe Eingabeereignisse bereit (optional, für Debugging oder spezifische Anwendungsfälle).
        * Definiere `RawInputEvent` (Enum für Tastatur-, Maus-, Touch-Events mit Rohdaten).
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/input/libinput_handler.rs`
    * `novade-system/src/input/xkb_handler.rs`
    * `novade-system/src/input/device_manager.rs`
    * `novade-system/src/input/errors.rs`
    * `novade-system/src/input/service_iface.rs`
    * `novade-system/src/input/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`, `novade-domain::device_management::data_types` (für `DeviceInfo`, `KeyboardSettings`, `PointerSettings`, `DeviceEvent`), `novade-domain::device_management::service_iface::DeviceManagementService` (zum Senden von Events und Abrufen von Einstellungen), `novade-system::logind::SystemLogindClient` (für `open_restricted`).
    * **Extern:** `libinput`, `xkbcommon`, `tokio`, `async-trait`, `thiserror`, `tracing`, `tokio::sync::broadcast`.
* **Kommunikationsmuster:**
    * Sendet rohe Eingabe-Events an den Smithay `seat` Handler im `compositor` Modul.
    * Sendet gerätespezifische Events und Informationen an den `DeviceManagementService` in der Domänenschicht.
    * Empfängt Einstellungen (`KeyboardSettings`, `PointerSettings`) vom `DeviceManagementService` und wendet diese auf `libinput` an.
    * Verwendet `SystemLogindClient` um die notwendigen Berechtigungen für `libinput` zu erhalten.
* **Erwartete Ergebnisse/Outputs:** Eine robuste Eingabeverarbeitung, die `libinput` und `xkbcommon` integriert, gerätespezifische Einstellungen anwenden kann und Wayland-konforme Eingabeereignisse für den Compositor generiert.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Tests für `InputError`.
        * Mocken von `libinput` und `xkbcommon` um die Event-Übersetzung und die Anwendung von Einstellungen zu testen.
        * Testen der `DeviceManager` Logik für Hinzufügen/Entfernen von Geräten und das Senden von Events.
        * Testen der `SystemInputService` Implementierung mit gemockten Abhängigkeiten.
    * **Integration Tests:**
        * End-to-End-Tests mit dem Compositor, um sicherzustellen, dass Tastatur- und Maus-Events korrekt verarbeitet und an Wayland-Clients gesendet werden.
* **Geschätzter Aufwand:** 7-10 Tage

#### `novade-system/src/dbus_interfaces`

* **Verzeichnis-/Modulname:** `novade-system/src/dbus_interfaces`
* **Verantwortlichkeit:** Dieses Modul bietet `zbus`-basierte Clients für verschiedene Systemdienste (NetworkManager, UPower, logind, Secrets, PolicyKit) und implementiert einen D-Bus-Server für `org.freedesktop.Notifications`. Es ist die primäre Brücke zwischen der Domänenlogik und den systemweiten D-Bus-Diensten.
* **Kern-Aufgaben (Tasks):**

    1.  **D-Bus Client für NetworkManager (`network_manager.rs`):**
        * Definiere das Trait `SystemNetworkService` (bereits im `network_management` Modul der Domänenschicht referenziert).
        * Implementiere eine Struktur `ZbusNetworkManagerClient`, die `SystemNetworkService` implementiert.
        * Nutze `zbus` zum Verbinden mit dem `org.freedesktop.NetworkManager` D-Bus Service.
        * Implementiere Methoden für `list_network_devices`, `list_wifi_networks`, `connect_to_wifi`, `disconnect_from_network`, `get_active_connections`.
        * Implementiere Signal-Handling für NetworkManager-Events (z.B. `StateChanged`, `DeviceAdded`, `DeviceRemoved`, `PropertiesChanged`), die in `NetworkEvent`s (Domänen-Datenstruktur) umgewandelt und an `NetworkManagementService` weitergeleitet werden.
        * Behandle D-Bus-Fehler und konvertiere sie in `NetworkManagementError`.
    2.  **D-Bus Client für UPower (`upower_client.rs`):**
        * Definiere das Trait `SystemPowerInfoProvider` (neu zu definieren, kapselt UPower-Interaktion).
        * Implementiere `ZbusUPowerClient`, die `SystemPowerInfoProvider` implementiert.
        * Nutze `zbus` zum Verbinden mit dem `org.freedesktop.UPower` D-Bus Service.
        * Implementiere Methoden für:
            * `get_battery_status() -> Result<BatteryInfo, PowerManagementError>` (Definition von `BatteryInfo` hier).
            * `get_power_supply_info() -> Result<PowerSupplyInfo, PowerManagementError>`.
            * Signal-Handling für UPower-Events (`Changed`, `DeviceAdded`, `DeviceRemoved`), die an `PowerManagementService` gesendet werden.
    3.  **D-Bus Client für systemd-logind (`logind.rs`):**
        * Definiere das Trait `SystemLogindClient` (bereits in `power_management`, `session_management`, `input` referenziert).
        * Implementiere `ZbusLogindClient`, die `SystemLogindClient` implementiert.
        * Nutze `zbus` zum Verbinden mit dem `org.freedesktop.login1` D-Bus Service.
        * Implementiere Methoden für:
            * `suspend()`, `hibernate()`, `reboot()`, `power_off()`.
            * `lock_session()`, `unlock_session()`.
            * `get_session_info()`, `get_user_info()`.
            * `open_device()`, `close_device()` (für `libinput` Integration).
            * Signal-Handling für logind-Events (z.B. `PrepareForSleep`, `SessionNew`, `SessionRemoved`), die an `SessionManagementService` und `PowerManagementService` gesendet werden.
    4.  **D-Bus Client für Secret Service (`secret_service.rs`):**
        * Definiere das Trait `SystemSecretService` (bereits in `session_management` referenziert).
        * Implementiere `ZbusSecretServiceClient`, die `SystemSecretService` implementiert.
        * Nutze `zbus` zum Verbinden mit dem `org.freedesktop.Secret.Service` D-Bus Service.
        * Implementiere Methoden für:
            * `retrieve_secret(&self, collection_id: &str, item_id: &str) -> Result<Secret, SecurityError>` (Definition von `Secret` hier).
            * `store_secret(&self, collection_id: &str, item_id: &str, secret: &Secret) -> Result<(), SecurityError>`.
            * `delete_secret(&self, collection_id: &str, item_id: &str) -> Result<(), SecurityError>`.
            * Dies wird für die sichere Speicherung von z.B. WLAN-Passwörtern oder Benutzer-Passwörtern für die Bildschirmsperre verwendet.
    5.  **D-Bus Client für PolicyKit (`policykit.rs`):**
        * Definiere das Trait `SystemPolicyKitClient` (neu zu definieren, kapselt PolicyKit-Interaktion).
        * Implementiere `ZbusPolicyKitClient`, die `SystemPolicyKitClient` implementiert.
        * Nutze `zbus` zum Verbinden mit dem `org.freedesktop.PolicyKit1` D-Bus Service.
        * Implementiere Methoden für:
            * `check_authorization(&self, action_id: &str, details: HashMap<String, String>) -> Result<AuthorizationResult, SecurityError>`.
            * Dies wird verwendet, um administrative Aktionen (z.B. Herunterfahren, Neustart) zu autorisieren, falls die Domänenlogik dies erfordert.
    6.  **D-Bus Server für `org.freedesktop.Notifications` (`notifications_server.rs`):**
        * Implementiere den D-Bus Service `org.freedesktop.Notifications`.
        * Implementiere die Methoden `Notify`, `GetCapabilities`, `CloseNotification`, `GetServerInformation`.
        * Nutze `zbus` zur Erstellung des D-Bus Servers.
        * Die `Notify` Methode empfängt eingehende Benachrichtigungen und leitet sie als `IncomingNotification` an den `NotificationService` der Domänenschicht weiter.
        * Sende Signale `NotificationClosed` und `ActionInvoked` zurück an den ursprünglichen Sender der Benachrichtigung, wenn der `NotificationService` dies anfordert.
    7.  **Fehler (`errors.rs`):**
        * Definiere `DBusError` Enum mit Varianten (z.B. `ConnectionError`, `MethodCallError`, `ServiceNotFound`).
        * Implementiere `thiserror::Error`, `Debug`, `Display`.
        * Implementiere `From` für `zbus::Error`.
    8.  **D-Bus Helper Funktionen (`utils.rs`):**
        * Hilfsfunktionen für die Konvertierung zwischen D-Bus `zvariant::Value` und Rust-Typen.
        * Einrichtung der D-Bus-Verbindung und des Asynchronen Kontexts.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/dbus_interfaces/network_manager.rs`
    * `novade-system/src/dbus_interfaces/upower_client.rs`
    * `novade-system/src/dbus_interfaces/logind.rs`
    * `novade-system/src/dbus_interfaces/secret_service.rs`
    * `novade-system/src/dbus_interfaces/policykit.rs`
    * `novade-system/src/dbus_interfaces/notifications_server.rs`
    * `novade-system/src/dbus_interfaces/errors.rs`
    * `novade-system/src/dbus_interfaces/utils.rs`
    * `novade-system/src/dbus_interfaces/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`, `novade-core::security`, `novade-domain::network_management::errors`, `novade-domain::network_management::data_types` (`NetworkEvent`, `NetworkDevice`, `WifiNetwork`), `novade-domain::power_management::errors`, `novade-domain::session_management::errors`, `novade-domain::notification_service::data_types` (`IncomingNotification`), `novade-domain::notification_service::service_iface::NotificationService`.
    * **Extern:** `zbus` (sowohl für Clients als auch Server), `async-trait`, `thiserror`, `tokio`, `tracing`, `futures` (für Stream-Verarbeitung), `std::collections::HashMap`, `chrono` (für Zeitstempel).
* **Kommunikationsmuster:**
    * **Clients:** Führen D-Bus-Methodenaufrufe aus und empfangen D-Bus-Signale von Systemdiensten. Wandeln D-Bus-Daten in Domänen-spezifische Daten um und leiten diese an die entsprechenden Domänen-Services weiter (z.B. `NetworkManager` -> `NetworkManagementService`).
    * **Server:** Empfängt D-Bus-Methodenaufrufe von externen Anwendungen (z.B. `Notify`), wandelt sie in Domänen-spezifische Daten um und leitet sie an den `NotificationService` weiter. Sendet D-Bus-Signale an externe Anwendungen.
* **Erwartete Ergebnisse/Outputs:** Eine robuste Sammlung von D-Bus-Clients und ein D-Bus-Server, die die Brücke zwischen NovaDE und dem D-Bus-Systembus bilden und die erforderlichen Interaktionen mit Systemdiensten ermöglichen.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Tests für `DBusError`.
        * Mocken der `zbus` Bibliothek (oder Verwendung von `zbus::blocking::Connection` für einfache Tests) um die Methoden- und Signal-Handler der Clients und des Servers zu testen.
        * Testen der Datenkonvertierung zwischen D-Bus-Typen und NovaDE-Domänen-Typen.
        * Testen der Fehlerbehandlung und Weiterleitung von D-Bus-Fehlern.
    * **Integration Tests:**
        * Starten eines Test-D-Bus-Daemons und Verbinden der Clients/Server, um die tatsächliche D-Bus-Kommunikation zu testen.
        * Verwenden von `dbus-send` oder `busctl` von der Kommandozeile, um den `notifications_server` zu testen.
* **Geschätzter Aufwand:** 10-15 Tage (Umfasst viele D-Bus-APIs)

#### `novade-system/src/audio_management`

* **Verzeichnis-/Modulname:** `novade-system/src/audio_management`
* **Verantwortlichkeit:** Dieses Modul bietet eine `pipewire-rs`-basierte Integration mit PipeWire für das Audio-Management. Es ist zuständig für die Verwaltung von Audio-Geräten, Streams, die Lautstärkeregelung und Routing.
* **Kern-Aufgaben (Tasks):**

    1.  **PipeWire Initialisierung (`pipewire_context.rs`):**
        * Initialisiere den PipeWire-Kontext (`pipewire::Context`).
        * Implementiere den PipeWire Haupt-Event-Loop (entweder durch Integration in `tokio` oder einen separaten Thread).
        * Stelle sicher, dass der Kontext und der Event-Loop korrekt gestartet und heruntergefahren werden.
    2.  **Audio-Geräteverwaltung (`device_manager.rs`):**
        * Beobachte PipeWire-Nodes für Audio-Geräte (`AudioSink`, `AudioSource`).
        * Halte einen internen Zustand der verfügbaren Audio-Geräte (Input/Output).
        * Definiere die Struktur `AudioDeviceInfo` (z.B. `id: u32`, `name: String`, `description: String`, `is_default: bool`, `volume: f64`, `is_muted: bool`).
        * Sende `AudioDeviceEvent`s (Hinzugefügt/Entfernt/Geändert) an die Domänenschicht.
    3.  **Lautstärke- und Mute-Steuerung (`volume_control.rs`):**
        * Implementiere Funktionen zum Abfragen und Setzen der System-Hauptlautstärke und des Mute-Status.
        * Implementiere die Steuerung der Lautstärke und des Mute-Status für einzelne Audio-Ausgabe-Streams (`AudioSink`) und Eingabe-Streams (`AudioSource`).
        * Behandle Events, wenn die Lautstärke oder der Mute-Status durch andere Anwendungen geändert wird.
    4.  **Fehler (`errors.rs`):**
        * Definiere `AudioManagementError` Enum mit Varianten (z.B. `PipewireError`, `DeviceNotFound`, `InvalidVolume`).
        * Implementiere `thiserror::Error`, `Debug`, `Display`.
        * Implementiere `From` für `pipewire-rs` Fehler.
    5.  **Service-Schnittstelle (`service_iface.rs`):**
        * Definiere das Trait `SystemAudioService` mit Methoden:
            * `get_output_devices() -> Result<Vec<AudioDeviceInfo>, AudioManagementError>`: Listet alle verfügbaren Audio-Ausgabegeräte auf.
            * `get_input_devices() -> Result<Vec<AudioDeviceInfo>, AudioManagementError>`: Listet alle verfügbaren Audio-Eingabegeräte auf.
            * `set_output_volume(&self, device_id: u32, volume: f64) -> Result<(), AudioManagementError>`: Setzt die Lautstärke für ein Ausgabegerät.
            * `set_output_muted(&self, device_id: u32, muted: bool) -> Result<(), AudioManagementError>`: Setzt den Mute-Status für ein Ausgabegerät.
            * `set_default_output_device(&self, device_id: u32) -> Result<(), AudioManagementError>`: Setzt das Standard-Ausgabegerät.
            * `register_audio_event_listener(&self) -> broadcast::Receiver<AudioEvent>`: Stellt einen `broadcast::Receiver` für Audio-Ereignisse bereit (z.B. `VolumeChanged`, `MuteChanged`, `DeviceAdded`, `DeviceRemoved`, `DefaultDeviceChanged`).
        * Definiere das Enum `AudioEvent`.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/audio_management/pipewire_context.rs`
    * `novade-system/src/audio_management/device_manager.rs`
    * `novade-system/src/audio_management/volume_control.rs`
    * `novade-system/src/audio_management/errors.rs`
    * `novade-system/src/audio_management/service_iface.rs`
    * `novade-system/src/audio_management/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`.
    * **Extern:** `pipewire-rs`, `tokio`, `async-trait`, `thiserror`, `tracing`, `tokio::sync::broadcast`.
* **Kommunikationsmuster:**
    * Integriert direkt mit der PipeWire-API.
    * Sendet Audio-Ereignisse an die Domänenschicht (z.B. an ein `AudioManagementService` in der Domäne, das noch zu definieren wäre, oder direkt an interessierte UI-Komponenten).
* **Erwartete Ergebnisse/Outputs:** Eine funktionale Schnittstelle zur Steuerung und Überwachung des Audiosystems über PipeWire.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Tests für `AudioManagementError`.
        * Mocken von `pipewire-rs` APIs, um die Lautstärke- und Mute-Funktionen zu testen.
        * Testen der Event-Verteilung und der Datenkonvertierung.
    * **Integration Tests:**
        * Starten eines einfachen PipeWire-Test-Setups und Interaktion mit dem `SystemAudioService`, um die tatsächliche Funktionalität zu überprüfen.
        * Manuelle Tests mit Audio-Playern und Systemlautstärkereglern.
* **Geschätzter Aufwand:** 7-10 Tage

#### `novade-system/src/mcp_client`

* **Verzeichnis-/Modulname:** `novade-system/src/mcp_client`
* **Verantwortlichkeit:** Dieses Modul implementiert den Client für das Model Context Protocol (MCP), um eine sichere Kommunikation mit KI-Modellen zu ermöglichen. Es ist für die Handhabung der Authentifizierung, der Datenübertragung und der Protokoll-Spezifika zuständig.
* **Kern-Aufgaben (Tasks):**

    1.  **MCP Client Implementierung (`client.rs`):**
        * Definiere die Struktur `McpClient`.
        * Initialisiere die Verbindung zum MCP-Server (z.B. über eine TCP-Socket-Verbindung oder eine andere IPC-Methode).
        * Implementiere Authentifizierungsmechanismen (z.B. Token-basiert, TLS-Client-Zertifikate) unter Verwendung des `SystemSecretService` für Credentials.
        * Implementiere Methoden zum Senden von Anfragen und Empfangen von Antworten gemäß dem MCP-Protokoll.
        * Behandle Verbindungswiederherstellung und Fehler.
    2.  **Datenstrukturen für MCP (`data_types.rs`):**
        * Definiere die Datenstrukturen für MCP-Anfragen (`McpRequest`) und Antworten (`McpResponse`), einschließlich verschiedener Kontexttypen (z.B. `TextContext`, `ImageContext`, `SystemContext`) und Modell-Antworttypen.
        * Sicherstellen, dass diese Strukturen serialisierbar/deserialisierbar sind (z.B. mit `serde`).
    3.  **Fehler (`errors.rs`):**
        * Definiere `McpClientError` Enum mit Varianten (z.B. `ConnectionError`, `ProtocolError`, `AuthenticationError`, `RequestFailed`).
        * Implementiere `thiserror::Error`, `Debug`, `Display`.
    4.  **Service-Schnittstelle (`service_iface.rs`):**
        * Definiere das Trait `SystemMcpClient` mit Methoden:
            * `send_context_request(&self, request: McpRequest) -> Result<McpResponse, McpClientError>`: Sendet eine Kontextanfrage an das KI-Modell und wartet auf eine Antwort.
            * `register_model_event_listener(&self) -> broadcast::Receiver<ModelEvent>`: Stellt einen `broadcast::Receiver` für Modellereignisse bereit (z.B. `ModelStatusChanged`, `ContextProcessed`).
        * Definiere das Enum `ModelEvent`.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/mcp_client/client.rs`
    * `novade-system/src/mcp_client/data_types.rs`
    * `novade-system/src/mcp_client/errors.rs`
    * `novade-system/src/mcp_client/service_iface.rs`
    * `novade-system/src/mcp_client/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`, `novade-domain::ai_integration::data_types` (für `McpRequest`, `McpResponse` wenn diese in der Domänenschicht definiert sind), `novade-system::dbus_interfaces::secret_service::SystemSecretService` (für Authentifizierung).
    * **Extern:** `tokio` (für Netzwerk-I/O), `serde::{Serialize, Deserialize}`, `serde_json` (oder `rmp_serde` für MessagePack), `async-trait`, `thiserror`, `tracing`, `tokio::sync::broadcast`.
* **Kommunikationsmuster:**
    * Kommuniziert direkt mit dem externen MCP-Server.
    * Nutzt `SystemSecretService` zum Abrufen von Authentifizierungsdaten.
    * Stellt eine Schnittstelle für die Domänenschicht (`AIIntegrationService`) bereit.
* **Erwartete Ergebnisse/Outputs:** Eine funktionale Client-Implementierung für das Model Context Protocol, die eine sichere und effiziente Kommunikation mit externen KI-Modellen ermöglicht.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Tests für `McpClientError`.
        * Tests für die Serialisierung/Deserialisierung der `McpRequest` und `McpResponse` Datenstrukturen.
        * Mocken der Netzwerk-I/O und des `SystemSecretService` um die `McpClient` Methoden zu testen.
    * **Integration Tests:**
        * Starten eines Mock-MCP-Servers und Testen der End-to-End-Kommunikation mit dem `McpClient`.
* **Geschätzter Aufwand:** 5-7 Tage

#### `novade-system/src/window_mechanics`

* **Verzeichnis-/Modulname:** `novade-system/src/window_mechanics`
* **Verantwortlichkeit:** Dieses Modul ist für die technische Umsetzung der Fenster-Policies aus der Domänenschicht verantwortlich. Es interagiert direkt mit dem Compositor, um Fenster zu positionieren, zu kacheln, den Fokus zu verwalten und andere visuelle Manipulationen gemäß den Anweisungen der Domänenschicht auszuführen.
* **Kern-Aufgaben (Tasks):**

    1.  **Fensterzustandsmodellierung (`window_state.rs`):**
        * Definiere eine interne Darstellung eines Fensters (`WindowHandle`), die alle notwendigen Informationen enthält, um das Fenster im Compositor zu manipulieren (z.B. `smithay::wayland::shell::xdg::XdgToplevelSurface`).
        * Kapselt den Compositor-spezifischen Fenster-Kontext.
        * Synchronisiert den internen Zustand mit dem `DesktopState` der Domänenschicht.
    2.  **Fokus-Management (`focus.rs`):**
        * Implementiere Methoden zum Setzen des Fokus auf ein bestimmtes Fenster.
        * Behandle Fokus-Wechsel, wenn ein Fenster geschlossen wird oder ein neues Fenster erscheint.
        * Sende Fokus-Änderungsereignisse an die Domänenschicht (`WindowPolicyService`).
    3.  **Fenster-Positionierung und -Größe (`layout.rs`):**
        * Implementiere Funktionen zum Setzen der Position und Größe von Fenstern.
        * Implementiere Logik für Tiling-Operationen (z.B. Halbtiling, Vollbild), die Anweisungen vom `WindowPolicyService` erhält und diese an den Compositor weitergibt.
        * Behandle Fenster-Größenänderungsanfragen von Clients.
    4.  **Fenster-Aktionen (`actions.rs`):**
        * Implementiere Methoden zum Minimieren, Maximieren, Schließen, Verschieben und Größenändern von Fenstern.
        * Diese Methoden werden von `WindowPolicyService` (Domänenschicht) aufgerufen und führen die Aktionen im Compositor aus.
    5.  **Fehler (`errors.rs`):**
        * Definiere `WindowMechanicsError` Enum mit Varianten (z.B. `WindowNotFound`, `InvalidState`, `CompositorInteractionError`).
        * Implementiere `thiserror::Error`, `Debug`, `Display`.
    6.  **Service-Schnittstelle (`service_iface.rs`):**
        * Definiere das Trait `SystemWindowService` (bereits in `app_management`, `notification_service` referenziert) mit Methoden:
            * `list_all_windows() -> Result<Vec<WindowInfo>, WindowMechanicsError>`: Listet alle vom Compositor verwalteten Fenster auf (Definition von `WindowInfo` hier, sollte die `RunningApplicationInfo` aus Domäne erweitern).
            * `set_window_focus(&self, window_id: Uuid) -> Result<(), WindowMechanicsError>`: Setzt den Fokus auf ein Fenster.
            * `set_window_geometry(&self, window_id: Uuid, geometry: novade_core::types::geometry::Rectangle<i32>) -> Result<(), WindowMechanicsError>`: Setzt Position und Größe eines Fensters.
            * `minimize_window(&self, window_id: Uuid) -> Result<(), WindowMechanicsError>`: Minimiert ein Fenster.
            * `maximize_window(&self, window_id: Uuid) -> Result<(), WindowMechanicsError>`: Maximiert ein Fenster.
            * `close_window(&self, window_id: Uuid) -> Result<(), WindowMechanicsError>`: Schließt ein Fenster.
            * `register_window_event_listener(&self) -> broadcast::Receiver<WindowEvent>`: Stellt einen `broadcast::Receiver` für Fenster-Ereignisse bereit (z.B. `WindowCreated`, `WindowDestroyed`, `WindowFocused`, `WindowGeometryChanged`).
        * Definiere das Enum `WindowEvent`.
        * Definiere `WindowInfo` hier mit `id: Uuid`, `title: Option<String>`, `app_id: Option<String>`, `wm_class: Option<String>`, `geometry: novade_core::types::geometry::Rectangle<i32>`, `is_minimized: bool`, `is_maximized: bool`, `is_fullscreen: bool`, `is_focused: bool`.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/window_mechanics/window_state.rs`
    * `novade-system/src/window_mechanics/focus.rs`
    * `novade-system/src/window_mechanics/layout.rs`
    * `novade-system/src/window_mechanics/actions.rs`
    * `novade-system/src/window_mechanics/errors.rs`
    * `novade-system/src/window_mechanics/service_iface.rs`
    * `novade-system/src/window_mechanics/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`, `novade-core::types::geometry`, `novade-domain::desktop_state::DesktopState` (für den globalen Zustand), `novade-domain::window_policy::WindowPolicyService` (für Anweisungen), `novade-system::compositor::core::NovaCompositor` (direkte Interaktion mit Smithay-APIs).
    * **Extern:** `smithay` (spezifische Submodule für Wayland-Shells), `tokio`, `async-trait`, `thiserror`, `tracing`, `tokio::sync::broadcast`, `uuid`.
* **Kommunikationsmuster:**
    * Empfängt Anweisungen vom `WindowPolicyService` der Domänenschicht.
    * Interagiert *direkt* mit den Smithay-APIs im `compositor` Modul, um Fenster zu manipulieren.
    * Sendet Fenster-Ereignisse an den `WindowPolicyService` (Domänenschicht) und `AppManagementService` (Domänenschicht).
* **Erwartete Ergebnisse/Outputs:** Eine Schicht, die die technischen Details der Fensterverwaltung kapselt und die Implementierung von Domänen-Fenster-Policies ermöglicht.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Tests für `WindowMechanicsError`.
        * Tests für die `WindowInfo` Datenstruktur.
        * Mocken des Compositor-APIs und Testen der `SystemWindowService` Methoden (Setzen von Fokus, Größe, Minimieren etc.).
        * Testen der Event-Verteilung.
    * **Integration Tests:**
        * End-to-End-Tests mit dem Compositor, bei denen Fenster erstellt und manipuliert werden, um die korrekte Umsetzung der Befehle zu überprüfen.
* **Geschätzter Aufwand:** 7-10 Tage

#### `novade-system/src/application_launcher`

* **Verzeichnis-/Modulname:** `novade-system/src/application_launcher`
* **Verantwortlichkeit:** Dieses Modul ist für das technische Starten von Anwendungen zuständig, sowohl über `exec` (für Terminal-Anwendungen) als auch über `xdg-open` oder ähnliche Mechanismen für die Öffnung von Dateien mit der Standardanwendung.
* **Kern-Aufgaben (Tasks):**

    1.  **Anwendungsstarter (`launcher.rs`):**
        * Implementiere eine Funktion `launch_command(command: &str, args: &[String]) -> Result<u32, LaunchError>`: Führt einen Befehl aus, entweder direkt mit `tokio::process::Command` oder durch Forken und Exec.
        * Implementiere eine Funktion `open_uri(uri: &str) -> Result<(), LaunchError>`: Nutzt `xdg-open` oder eine ähnliche Methode, um eine URI zu öffnen.
        * Behandle die Umgebungsvariablen korrekt (z.B. `DISPLAY`, `WAYLAND_DISPLAY`, `XDG_CURRENT_DESKTOP`).
        * Sicherstellen, dass die gestarteten Prozesse vom Desktop unabhängig sind und nicht blockieren.
    2.  **Fehler (`errors.rs`):**
        * Definiere `LaunchError` Enum mit Varianten (z.B. `CommandNotFound`, `PermissionDenied`, `ProcessSpawnFailed`, `InvalidUri`).
        * Implementiere `thiserror::Error`, `Debug`, `Display`.
        * Implementiere `From` für `std::io::Error`.
    3.  **Service-Schnittstelle (`service_iface.rs`):**
        * Definiere das Trait `SystemApplicationLauncher` (bereits in `app_management` referenziert) mit Methoden:
            * `launch_application(&self, desktop_entry_id: &str, args: &[String]) -> Result<u32, LaunchError>`: Startet eine Anwendung basierend auf ihrer `desktop_entry_id`. Intern muss dies die `.desktop`-Datei parsen (oder die `ApplicationInfo` aus Domäne nutzen, die bereits geparst ist) und den `Exec` Befehl ausführen.
            * `open_file_with_default_app(&self, file_path: &Path) -> Result<(), LaunchError>`: Öffnet eine Datei mit der vom System bestimmten Standardanwendung.
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/application_launcher/launcher.rs`
    * `novade-system/src/application_launcher/errors.rs`
    * `novade-system/src/application_launcher/service_iface.rs`
    * `novade-system/src/application_launcher/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`.
    * **Extern:** `tokio::process::Command`, `async-trait`, `thiserror`, `tracing`, `std::path::Path`.
* **Kommunikationsmuster:**
    * Empfängt Startanweisungen vom `AppManagementService` der Domänenschicht.
    * Führt Systembefehle aus, um Anwendungen zu starten.
* **Erwartete Ergebnisse/Outputs:** Eine zuverlässige Methode zum Starten von Anwendungen und Öffnen von Dateien.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Tests für `LaunchError`.
        * Testen von `launch_command` mit Dummy-Befehlen und Argumenten.
        * Testen von `open_uri` mit Dummy-URIs.
        * Testen der Fehlerbehandlung (z.B. wenn der Befehl nicht gefunden wird).
        * Mocken des `.desktop`-Datei-Parsings, um `launch_application` zu testen.
* **Geschätzter Aufwand:** 2-3 Tage

#### `novade-system/src/display_configurator`

* **Verzeichnis-/Modulname:** `novade-system/src/display_configurator`
* **Verantwortlichkeit:** Dieses Modul ist für die technische Anwendung der Display-Konfigurationen im Compositor zuständig. Es übersetzt die domänenspezifischen `DisplayMode` und `MonitorConfig` in Smithay-spezifische API-Aufrufe.
* **Kern-Aufgaben (Tasks):**

    1.  **Display-Konfiguration (`configurator.rs`):**
        * Implementiere eine Struktur `CompositorDisplayConfigurator`, die das Trait `SystemDisplayConfigurator` (bereits in `display_management` referenziert) implementiert.
        * Diese Struktur muss eine `Arc<Mutex<NovaCompositorState>>` oder `Arc<RwLock<NovaCompositorState>>` Referenz auf den Compositor-Zustand halten (oder eine andere sichere Methode zur Interaktion mit dem Compositor).
        * Implementiere die Methode `apply_display_config(&self, configs: Vec<MonitorConfig>) -> Result<(), DisplayManagementError>`:
            * Iteriere über die `MonitorConfig`s.
            * Finde den entsprechenden Smithay `Output` im Compositor.
            * Setze den `mode` (Auflösung, Refreshrate), `scale`, `transform` (Orientierung) und `position` des `Output` unter Verwendung der Smithay `Output` APIs.
            * Setze den primären Output.
            * Gebe `DisplayEvent`s an die Domänenschicht weiter, wenn Änderungen erkannt werden.
    2.  **Fehler (`errors.rs`):**
        * Definiere `DisplayConfiguratorError` Enum mit Varianten (z.B. `OutputNotFound`, `InvalidMode`, `CompositorError`).
        * Implementiere `thiserror::Error`, `Debug`, `Display`.
        * Implementiere `From` für relevante Compositor-Fehler.
    3.  **Service-Schnittstelle (`service_iface.rs`):**
        * Definiere das Trait `SystemDisplayConfigurator` mit Methoden:
            * `list_connected_outputs() -> Result<Vec<MonitorInfo>, DisplayConfiguratorError>`: Ruft die aktuellen und verfügbaren Modi direkt vom Compositor ab.
            * `apply_display_config(&self, configs: Vec<MonitorConfig>) -> Result<(), DisplayConfiguratorError>`: Wendet die Konfigurationen an.
            * `register_output_event_listener(&self) -> broadcast::Receiver<OutputEvent>`: Stellt einen `broadcast::Receiver` für rohe Compositor-Output-Ereignisse bereit (z.B. `OutputAdded`, `OutputRemoved`, `OutputModeChanged`).
        * Definiere `OutputEvent` (direkte Übersetzung von Smithay `OutputEvent`).
* **Spezifische Artefakte/Dateien:**
    * `novade-system/src/display_configurator/configurator.rs`
    * `novade-system/src/display_configurator/errors.rs`
    * `novade-system/src/display_configurator/service_iface.rs`
    * `novade-system/src/display_configurator/mod.rs` (re-exportiert public API)
* **Abhängigkeiten:**
    * **Intern:** `novade-core::error`, `novade-core::types::geometry`, `novade-domain::display_management::data_types` (`MonitorInfo`, `MonitorConfig`, `DisplayMode`), `novade-system::compositor::core::NovaCompositor` (oder den Zustand, der die Smithay `Output`s enthält).
    * **Extern:** `smithay` (spezifische `output` Module), `tokio`, `async-trait`, `thiserror`, `tracing`, `tokio::sync::broadcast`.
* **Kommunikationsmuster:**
    * Empfängt Konfigurationsanweisungen vom `DisplayManagementService` der Domänenschicht.
    * Interagiert *direkt* mit den Smithay `Output` APIs im `compositor` Modul.
    * Sendet Roh-Output-Ereignisse vom Compositor an die Domänenschicht (`DisplayManagementService`).
* **Erwartete Ergebnisse/Outputs:** Eine Abstraktionsschicht, die die Smithay-spezifischen Details der Display-Konfiguration kapselt und eine Schnittstelle für die Domänenschicht bereitstellt.
* **Teststrategie (Modul-spezifisch):**
    * **Unit Tests:**
        * Tests für `DisplayConfiguratorError`.
        * Mocken des Smithay `Output` APIs und Testen der `apply_display_config` und `list_connected_outputs` Methoden.
        * Testen der Event-Verteilung.
* **Geschätzter Aufwand:** 3-4 Tage

### Priorisierung der Implementierung (Abhängigkeiten von unten nach oben, von Kern zu UI)

1.  **`novade-core` Crate:**
    * `novade-core/src/error`
    * `novade-core/src/types`
    * `novade-core/src/config`
    * `novade-core/src/logging`
    * `novade-core/src/security`
    * `novade-core/src/utils`

2.  **`novade-domain` Crate (nachdem `novade-core` fertig ist):**
    * `novade-domain/src/global_settings` (da viele andere Domänen-Module darauf aufbauen)
    * `novade-domain/src/desktop_state` (Kernzustand, der von vielen benötigt wird)
    * `novade-domain/src/theme`
    * `novade-domain/src/wallpaper_manager`
    * `novade-domain/src/power_management` (hängt von `global_settings` ab)
    * `novade-domain/src/device_management` (hängt von `global_settings` ab)
    * `novade-domain/src/app_management`
    * `novade-domain/src/network_management`
    * `novade-domain/src/display_management`
    * `novade-domain/src/session_management`
    * `novade-domain/src/notification_rules` (hängt von `global_settings` ab)
    * `novade-domain/src/notification_service` (hängt von `notification_rules`, `app_management` ab)
    * `novade-domain/src/window_policy` (hängt von `desktop_state`, `global_settings` ab)
    * `novade-domain/src/ai_integration`
    * `novade-domain/src/file_management` (ggf. späte Implementierung oder parallel)
    * `novade-domain/src/search` (ggf. späte Implementierung oder parallel)

3.  **`novade-system` Crate (nachdem `novade-core` und erste Teile von `novade-domain` (z.B. `desktop_state`, `window_policy`, `display_management`, `device_management`, `session_management`, `network_management`, `notification_service`, `app_management`, `ai_integration`) als Traits verfügbar sind):**
    * `novade-system/src/dbus_interfaces/logind` (da `libinput_handler` und `session_management` darauf angewiesen sind)
    * `novade-system/src/input` (hängt von `logind` und `device_management` ab, versorgt `compositor`)
    * `novade-system/src/compositor` (KERN-Komponente, hängt von `input`, `window_policy`, `display_management` ab)
    * `novade-system/src/window_mechanics` (arbeitet direkt mit `compositor` zusammen, hängt von `window_policy` ab)
    * `novade-system/src/display_configurator` (arbeitet direkt mit `compositor` zusammen, hängt von `display_management` ab)
    * `novade-system/src/application_launcher` (hängt von `app_management` ab)
    * `novade-system/src/dbus_interfaces` (alle Clients und Server, die `NetworkManager`, `UPower`, `SecretService`, `PolicyKit`, `Notifications` abbilden, können dann implementiert werden, da ihre Domänen-Counterparts vorhanden sind)
    * `novade-system/src/audio_management`
    * `novade-system/src/mcp_client` (hängt von `secret_service` ab)
    * `novade-system/src/portals` (kann nach `compositor` und `window_mechanics` implementiert werden)

4.  **`novade-ui` Crate (nachdem `novade-core`, `novade-domain` und `novade-system` als Traits verfügbar sind):**
    * Grundlegende UI-Komponenten, dann spezifische Widgets und Ansichten.

Diese Reihenfolge minimiert zirkuläre Abhängigkeiten und stellt sicher, dass tiefere, stabilere Schichten zuerst implementiert und getestet werden, bevor höhere Schichten, die darauf aufbauen, in Angriff genommen werden.
Der Implementierungsplan für NovaDE wird ab der Domänenschicht fortgesetzt, beginnend mit `novade-domain/src/wallpaper_manager/data_types.rs` und systematisch alle weiteren Module der Domänenschicht sowie anschließend die System- und UI-Schicht detailliert spezifiziert.

### `novade-domain/src/wallpaper_manager/service.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/wallpaper_manager/service.rs`
  * **Verantwortlichkeit:** Implementiert die Kernlogik des Wallpaper-Managements, einschließlich des Ladens, Speicherns und Anwendens von Hintergrundbildern. Verwaltet den aktuellen Zustand des Desktophintergrunds und benachrichtigt über Änderungen.
  * **Kern-Aufgaben (Tasks):**
    1.  **Struktur `WallpaperManagerService` definieren:**
          * Enthält den aktuellen `Wallpaper` Zustand (ggf. `Arc<RwLock<Wallpaper>>` für Thread-sicheren Zugriff).
          * Referenz auf den `ConfigServiceAsync` für die Persistenz (ggf. `Arc<dyn ConfigServiceAsync>`).
          * Referenz auf den `GlobalSettingsService` für die Berücksichtigung globaler Einstellungen.
          * Ein `tokio::sync::broadcast::Sender` für `WallpaperChangedEvent`.
          * Ein `tokio::sync::broadcast::Sender` für `WallpaperLoadErrorEvent`.
    2.  **Konstruktor `new()` implementieren:**
          * Initialisiert den Service mit den erforderlichen Abhängigkeiten.
          * Lädt beim Start das Standard- oder zuletzt verwendete Hintergrundbild.
    3.  **Methode `load_wallpaper(source: WallpaperSource) -> Result<(), WallpaperManagerError>` implementieren:**
          * Lädt ein Hintergrundbild basierend auf der `WallpaperSource`.
          * Unterstützt Dateipfade, URLs und ggf. spezifische interne IDs.
          * Validiert die Quelldatei/URL.
          * Wandelt das geladene Bild in ein internes Format (ggf. Pfad zum Bild, keine Bilddaten selbst hier).
          * Aktualisiert den internen `Wallpaper` Zustand.
          * Sendet ein `WallpaperChangedEvent`.
          * Behandelt `IO-Fehler`, `Parsen-Fehler`, `Netzwerk-Fehler` und sendet `WallpaperLoadErrorEvent` bei Misserfolg.
    4.  **Methode `set_wallpaper_mode(mode: WallpaperMode) -> Result<(), WallpaperManagerError>` implementieren:**
          * Setzt den Anzeigemodus des aktuellen Hintergrundbildes.
          * Aktualisiert den internen `Wallpaper` Zustand.
          * Sendet ein `WallpaperChangedEvent`.
    5.  **Methode `set_background_color(color: Color) -> Result<(), WallpaperManagerError>` implementieren:**
          * Setzt die Hintergrundfarbe, die ggf. bei bestimmten `WallpaperMode`s oder als Fallback genutzt wird.
          * Aktualisiert den internen `Wallpaper` Zustand.
          * Sendet ein `WallpaperChangedEvent`.
    6.  **Methode `get_current_wallpaper() -> Wallpaper` implementieren:**
          * Gibt den aktuellen `Wallpaper` Zustand zurück.
    7.  **Methode `subscribe_to_wallpaper_changes() -> broadcast::Receiver<WallpaperChangedEvent>` implementieren:**
          * Gibt einen `Receiver` für Änderungen am Hintergrundbildzustand zurück.
    8.  **Methode `subscribe_to_wallpaper_load_errors() -> broadcast::Receiver<WallpaperLoadErrorEvent>` implementieren:**
          * Gibt einen `Receiver` für Fehler beim Laden von Hintergrundbildern zurück.
    9.  **Persistenz-Logik (`save_current_wallpaper_state()`):**
          * Speichert den aktuellen `Wallpaper` Zustand über den `ConfigServiceAsync`.
          * Diese Methode sollte bei jeder Zustandsänderung (`load_wallpaper`, `set_wallpaper_mode`, `set_background_color`) intern aufgerufen werden.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/wallpaper_manager/service.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::wallpaper_manager::data_types::{Wallpaper, WallpaperSource, WallpaperMode, WallpaperChangedEvent, WallpaperLoadErrorEvent, WallpaperManagerError}`, `crate::config::service::{ConfigServiceAsync, ConfigServiceError}`, `crate::global_settings::service::GlobalSettingsService`, `crate::theme::data_types::Color`.
      * **Extern:** `tokio::sync::{RwLock, broadcast}`, `std::path::PathBuf`, `url::Url` (für `WallpaperSource::Url`), `async_trait::async_trait`, `Arc`.
  * **Kommunikationsmuster:**
      * `WallpaperManagerService` kommuniziert mit `ConfigServiceAsync` zum Speichern und Laden des Wallpaper-Zustands.
      * Kommuniziert mit `GlobalSettingsService`, um globale Einstellungen zu berücksichtigen (z.B. ob Hintergrundbilder überhaupt angezeigt werden sollen).
      * Sendet Events (`WallpaperChangedEvent`, `WallpaperLoadErrorEvent`) an Abonnenten (hauptsächlich die UI-Schicht) über `tokio::sync::broadcast`.
      * Empfängt Aufrufe von der UI-Schicht oder anderen Domänendiensten, um das Hintergrundbild zu ändern.
  * **Erwartete Ergebnisse/Outputs:** Ein voll funktionsfähiger Dienst zum Verwalten von Desktophintergründen, der Zustandsänderungen persistiert und Ereignisse an interessierte Parteien sendet.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Mocking von `ConfigServiceAsync` und `GlobalSettingsService` zur Isolation.
          * Testen des Konstruktors, um sicherzustellen, dass der initiale Zustand korrekt geladen wird.
          * Testen von `load_wallpaper` mit verschiedenen `WallpaperSource` Typen (gültig, ungültig, nicht existent).
          * Testen der Ereignisverteilung (`WallpaperChangedEvent`, `WallpaperLoadErrorEvent`).
          * Testen von `set_wallpaper_mode` und `set_background_color`.
          * Testen der Persistenzlogik nach Zustandsänderungen.
          * Testen der Fehlerbehandlung für alle möglichen Fehlerfälle (z.B. Dateizugriffsfehler, ungültige URL).
  * **Geschätzter Aufwand:** Mittel (ca. 3-4 Tage)

### `novade-domain/src/notification_rules/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/data_types.rs`
  * **Verantwortlichkeit:** Definiert die Datenstrukturen für das Regelwerk zur Benachrichtigungsverarbeitung, einschließlich Bedingungen, Aktionen und der Benachrichtigungsregeln selbst.
  * **Kern-Aufgaben (Tasks):**
    1.  **Enum `Field` definieren:**
          * Varianten: `AppName`, `Summary`, `Body`, `Category`, `Urgency`, `DesktopEntry`, `Hint`, `Source` (neu, z.B. `Dbus`, `Internal`).
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `Display` (für menschenlesbare Namen).
    2.  **Enum `Operator` definieren:**
          * Varianten: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `MatchesRegex`, `GreaterThan`, `LessThan`, `Is`, `IsNot`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Eq`, `Serialize`, `Deserialize`, `Display`.
    3.  **Enum `ConditionValue` definieren:**
          * Varianten: `String(String)`, `Integer(i64)`, `Boolean(bool)`, `List(Vec<String>)`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
          * Implementiere `From` Trait für `String`, `i64`, `bool`, `Vec<String>`.
    4.  **Struktur `SimpleRuleCondition` definieren:**
          * Felder: `field: Field`, `operator: Operator`, `value: ConditionValue`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    5.  **Enum `RuleCondition` definieren:**
          * Varianten: `Simple(SimpleRuleCondition)`, `And(Vec<RuleCondition>)`, `Or(Vec<RuleCondition>)`, `Not(Box<RuleCondition>)`, `SettingIsTrue(String)` (Name der globalen Einstellung, die wahr sein muss).
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
          * Der `SettingIsTrue` Condition-Typ ist neu und ermöglicht es, Regeln an den Zustand globaler Einstellungen zu koppeln (z.B. "Nicht stören" Modus).
    6.  **Enum `RuleAction` definieren:**
          * Varianten: `Block`, `Display`, `PlaySound(String)`, `ExecuteCommand(String, Vec<String>)`, `SetUrgency(Urgency)`, `RemoveHint(String)`, `ChangeCategory(String)`, `RunScript(String, Vec<String>)`, `StopProcessingFurtherRules`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
          * `StopProcessingFurtherRules` ist eine kritische Aktion, die das Beenden der Regelauswertung nach Anwenden dieser Regel anweist.
    7.  **Struktur `NotificationRule` definieren:**
          * Felder: `id: Uuid`, `name: String`, `enabled: bool`, `priority: i32` (höhere Zahl = höhere Priorität), `condition: RuleCondition`, `actions: Vec<RuleAction>`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
          * `Uuid` für eindeutige Identifikation, `priority` für die Reihenfolge der Anwendung.
    8.  **Struktur `NotificationRuleSet` definieren:**
          * Felder: `rules: Vec<NotificationRule>`.
          * Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/data_types.rs`
  * **Abhängigkeiten:**
      * **Intern:** Keine direkten internen Abhängigkeiten.
      * **Extern:** `serde::{Serialize, Deserialize}`, `uuid::Uuid`, `std::fmt::Display`.
  * **Kommunikationsmuster:**
      * Diese Datenstrukturen werden vom `NotificationRulesService` (oder `Engine`) verwendet, um Benachrichtigungen zu verarbeiten. Sie werden vom `ConfigServiceAsync` geladen und gespeichert.
  * **Erwartete Ergebnisse/Outputs:** Eine klare, erweiterbare und persistierbare Definition des Regelwerks zur Benachrichtigungsverarbeitung.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der `Default` Implementierungen.
          * Testen der `Clone`, `Debug`, `PartialEq` Implementierungen.
          * Testen der Serialisierung und Deserialisierung für alle Strukturen und Varianten, um die Korrektheit der Datenpersistenz zu gewährleisten.
          * Testen der `From` Trait Implementierungen für `ConditionValue`.
  * **Geschätzter Aufwand:** Mittel (ca. 2 Tage)

### `novade-domain/src/notification_rules/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/errors.rs`
  * **Verantwortlichkeit:** Definiert spezifische Fehlertypen für das Benachrichtigungsregelmodul, die von `thiserror` abgeleitet sind und eine klare Fehlerdiagnose ermöglichen.
  * **Kern-Aufgaben (Tasks):**
    1.  **Enum `NotificationRulesError` definieren:**
          * Leite von `thiserror::Error` ab.
          * Varianten:
              * `PersistenceError(#[from] ConfigServiceError)`: Fehler beim Laden oder Speichern der Regeln.
              * `InvalidRuleDefinition(String)`: Eine Regeldefinition ist syntaktisch oder semantisch ungültig.
              * `RuleProcessingError(String)`: Ein Fehler während der Ausführung einer Regel (z.B. Befehl nicht gefunden).
              * `GlobalSettingServiceError(String)`: Fehler beim Abrufen einer globalen Einstellung (für `SettingIsTrue` Condition).
              * `Other(String)`: Für allgemeine oder unerwartete Fehler.
          * Implementiere `#[error(...)]` für jede Variante mit aussagekräftigen Fehlermeldungen.
          * Sicherstellen der `Debug` Implementierung.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/errors.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::config::service::ConfigServiceError`.
      * **Extern:** `thiserror::Error`.
  * **Kommunikationsmuster:**
      * Fehler werden von den `NotificationRulesProvider` und `NotificationRulesEngine` Komponenten zurückgegeben.
  * **Erwartete Ergebnisse/Outputs:** Eine robuste und aussagekräftige Fehlerbehandlung für das Benachrichtigungsregelmodul.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Erstellung jeder Fehler-Variante.
          * Testen der `From` Implementierungen (z.B. von `ConfigServiceError`).
          * Testen der korrekten Formatierung der Fehlermeldungen.
  * **Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

### `novade-domain/src/notification_rules/persistence_iface.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/persistence_iface.rs`
  * **Verantwortlichkeit:** Definiert das `NotificationRulesProvider`-Trait, das die Schnittstelle für die Persistenz des Benachrichtigungsregelwerks darstellt. Dies ermöglicht eine flexible Implementierung der Speicherlogik.
  * **Kern-Aufgaben (Tasks):**
    1.  **Trait `NotificationRulesProvider` definieren:**
          * Mache es `async_trait::async_trait`.
          * Funktion `load_rules() -> Result<NotificationRuleSet, NotificationRulesError>`: Lädt das gesamte Regelset.
          * Funktion `save_rules(rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`: Speichert das gesamte Regelset.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/persistence_iface.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notification_rules::data_types::NotificationRuleSet`, `crate::notification_rules::errors::NotificationRulesError`.
      * **Extern:** `async_trait::async_trait`.
  * **Kommunikationsmuster:**
      * Wird von der `NotificationRulesEngine` oder dem `NotificationRulesService` genutzt, um Regeln zu persistieren oder zu laden.
  * **Erwartete Ergebnisse/Outputs:** Eine klare und entkoppelte Schnittstelle für die Persistenz des Regelwerks.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Keine direkten Tests für ein Trait, aber es muss sichergestellt werden, dass Implementierungen dieses Traits die vertraglichen Zusicherungen erfüllen.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

### `novade-domain/src/notification_rules/persistence.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/persistence.rs`
  * **Verantwortlichkeit:** Implementiert das `NotificationRulesProvider`-Trait unter Verwendung des `ConfigServiceAsync`, um Benachrichtigungsregeln im Dateisystem zu speichern und zu laden.
  * **Kern-Aufgaben (Tasks):**
    1.  **Struktur `FilesystemNotificationRulesProvider` definieren:**
          * Feld: `config_service: Arc<dyn ConfigServiceAsync>`.
          * Konstante für den Dateipfad (z.B. `NOTIFICATION_RULES_CONFIG_PATH = "notification_rules.json"`).
    2.  **Konstruktor `new(config_service: Arc<dyn ConfigServiceAsync>) -> Self` implementieren.**
    3.  **Implementiere `async_trait::async_trait` für `NotificationRulesProvider` für `FilesystemNotificationRulesProvider`:**
          * **`load_rules()`:**
              * Nutze `config_service.load_config()` mit dem definierten Pfad.
              * Deserealisiere die geladenen Daten in `NotificationRuleSet`.
              * Fehlerbehandlung: Konvertiere `ConfigServiceError` in `NotificationRulesError::PersistenceError`. Wenn die Datei nicht existiert, gib ein leeres `NotificationRuleSet` zurück.
          * **`save_rules(rules: &NotificationRuleSet)`:**
              * Serialisiere das `NotificationRuleSet` zu einem String (z.B. JSON).
              * Nutze `config_service.save_config()` mit dem definierten Pfad und den serialisierten Daten.
              * Fehlerbehandlung: Konvertiere `ConfigServiceError` in `NotificationRulesError::PersistenceError`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/persistence.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notification_rules::data_types::NotificationRuleSet`, `crate::notification_rules::errors::NotificationRulesError`, `crate::notification_rules::persistence_iface::NotificationRulesProvider`, `crate::config::service::{ConfigServiceAsync, ConfigServiceError}`.
      * **Extern:** `Arc`, `async_trait::async_trait`, `serde_json`.
  * **Kommunikationsmuster:**
      * Kommuniziert mit dem `ConfigServiceAsync` zur Dateisystem-Interaktion.
  * **Erwartete Ergebnisse/Outputs:** Eine konkrete Implementierung zur Persistenz von Benachrichtigungsregeln.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Mocking von `ConfigServiceAsync` zur Simulation von Lese- und Schreibvorgängen.
          * Testen von `load_rules` mit existierenden und nicht-existierenden Konfigurationsdateien.
          * Testen von `save_rules` und anschließendem `load_rules`, um die Korrektheit der Serialisierung/Deserialisierung sicherzustellen.
          * Testen der Fehlerbehandlung bei zugrunde liegenden `ConfigServiceError`s.
  * **Geschätzter Aufwand:** Gering (ca. 1 Tag)

### `novade-domain/src/notification_rules/engine.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/engine.rs`
  * **Verantwortlichkeit:** Implementiert die Kernlogik zur Verarbeitung eingehender Benachrichtigungen gegen ein definiertes Regelwerk. Beinhaltet die Bedingungs- und Aktionsauswertung.
  * **Kern-Aufgaben (Tasks):**
    1.  **Enum `RuleProcessingResult` definieren:**
          * Varianten: `Blocked`, `Displayed`, `Modified(ProcessedNotification)`, `NoMatch`.
          * `ProcessedNotification` ist eine Kopie oder modifizierte Version der ursprünglichen Benachrichtigung nach Regelanwendung.
          * Implementiere `Clone`, `Debug`, `PartialEq`.
    2.  **Trait `NotificationRulesEngine` definieren:**
          * Mache es `async_trait::async_trait`.
          * Funktion `reload_rules() -> Result<(), NotificationRulesError>`: Lädt die Regeln neu aus dem Provider.
          * Funktion `process_notification(notification: &IncomingNotification) -> Result<RuleProcessingResult, NotificationRulesError>`: Verarbeitet eine eingehende Benachrichtigung.
          * Funktion `get_rules() -> NotificationRuleSet`: Gibt das aktuelle Regelset zurück (zu Debug- und UI-Zwecken).
          * Funktion `update_rules(rules: NotificationRuleSet) -> Result<(), NotificationRulesError>`: Aktualisiert das Regelset und speichert es.
    3.  **Struktur `DefaultNotificationRulesEngine` definieren:**
          * Felder: `rules: Arc<RwLock<NotificationRuleSet>>`, `provider: Arc<dyn NotificationRulesProvider>`, `global_settings_service: Arc<dyn GlobalSettingsService>`.
    4.  **Konstruktor `new(provider: Arc<dyn NotificationRulesProvider>, global_settings_service: Arc<dyn GlobalSettingsService>) -> Self` implementieren.**
          * Initialisiert das `RwLock` mit einem leeren `NotificationRuleSet`.
    5.  **Implementiere `async_trait::async_trait` für `NotificationRulesEngine` für `DefaultNotificationRulesEngine`:**
          * **`reload_rules()`:**
              * Ruft `provider.load_rules()` auf.
              * Aktualisiert den internen `rules` Zustand im `RwLock`.
          * **`process_notification(notification: &IncomingNotification)`:**
              * Eine interne Kopie der `notification` für Modifikationen erstellen.
              * Regeln nach `priority` sortieren (höchste Priorität zuerst).
              * Iteriere über die Regeln:
                  * Für jede Regel, wenn `enabled` ist und die `condition` erfüllt ist:
                      * Führe die `actions` aus der Regel auf der `ProcessedNotification` aus.
                      * Wenn eine Aktion `StopProcessingFurtherRules` ist, beende die Verarbeitung und gib das Ergebnis zurück.
                  * Wenn die Regel nicht aktiviert ist oder die Bedingung nicht erfüllt ist, fahre mit der nächsten Regel fort.
              * **`evaluate_condition(condition: &RuleCondition, notification: &IncomingNotification, global_settings_service: &Arc<dyn GlobalSettingsService>) -> Result<bool, NotificationRulesError>` (interne Hilfsfunktion):**
                  * Rekursive Funktion zur Auswertung komplexer Bedingungen (`And`, `Or`, `Not`).
                  * Für `SimpleRuleCondition`: Extrahiere den Wert aus der `notification` basierend auf `Field`. Führe den Vergleich mit `Operator` und `ConditionValue` durch. Beachte Typkonvertierungen und Fehlerbehandlung (z.B. Regex-Fehler).
                  * Für `SettingIsTrue`: Rufe `global_settings_service.get_setting(setting_name)` auf und prüfe, ob der Wert `true` ist.
              * **`apply_action(action: &RuleAction, processed_notification: &mut ProcessedNotification) -> Result<Option<RuleProcessingResult>, NotificationRulesError>` (interne Hilfsfunktion):**
                  * Implementiere Logik für jede `RuleAction`:
                      * `Block`: Gibt `RuleProcessingResult::Blocked` zurück (Signal für Beenden).
                      * `Display`: Kann als Default-Aktion angesehen werden, wenn keine Block-Aktion greift.
                      * `PlaySound`: Löse ein System-Event oder rufe einen Dienst auf, um einen Sound abzuspielen.
                      * `ExecuteCommand`: Spawne einen externen Prozess. Fehler bei Ausführung protokollieren, aber nicht die gesamte Regelverarbeitung abbrechen.
                      * `SetUrgency`: Setze die Dringlichkeit der `processed_notification`.
                      * `RemoveHint`: Entferne einen spezifischen Hint von der `processed_notification`.
                      * `ChangeCategory`: Ändere die Kategorie der `processed_notification`.
                      * `RunScript`: Ähnlich wie `ExecuteCommand`, aber mit Fokus auf Skripte.
                      * `StopProcessingFurtherRules`: Gibt `Some(RuleProcessingResult::Modified(...))` zurück, um die Verarbeitung zu beenden.
                  * Die Funktion sollte `Ok(None)` zurückgeben, wenn die Aktion keine sofortige Beendigung erfordert.
              * Standardmäßig (wenn keine Regel zutrifft oder `StopProcessingFurtherRules` nicht verwendet wird): `RuleProcessingResult::Displayed` oder `RuleProcessingResult::Modified` (wenn Änderungen vorgenommen wurden).
          * **`get_rules()`:** Gibt eine geklonte Kopie des aktuellen Regelsets zurück.
          * **`update_rules(rules: NotificationRuleSet)`:**
              * Aktualisiert den internen `rules` Zustand im `RwLock`.
              * Ruft `provider.save_rules()` auf.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/engine.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notification_rules::data_types::{NotificationRule, RuleCondition, RuleAction, NotificationRuleSet, Field, Operator, ConditionValue}`, `crate::notification_rules::errors::NotificationRulesError`, `crate::notification_rules::persistence_iface::NotificationRulesProvider`, `crate::notification_service::data_types::IncomingNotification` (und `ProcessedNotification` die noch zu definieren sind), `crate::global_settings::service::GlobalSettingsService`.
      * **Extern:** `Arc`, `tokio::sync::RwLock`, `async_trait::async_trait`, `regex::Regex` (für `MatchesRegex`).
  * **Kommunikationsmuster:**
      * Kommuniziert mit `NotificationRulesProvider` für Lade- und Speicheroperationen.
      * Kommuniziert mit `GlobalSettingsService` zur Abfrage von globalen Einstellungen für `SettingIsTrue` Conditions.
      * Empfängt `IncomingNotification`s zur Verarbeitung und gibt `RuleProcessingResult` zurück.
  * **Erwartete Ergebnisse/Outputs:** Eine leistungsstarke Engine, die eingehende Benachrichtigungen intelligent nach konfigurierten Regeln filtert, modifiziert und steuert.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Mocking von `NotificationRulesProvider` und `GlobalSettingsService`.
          * Testen der `evaluate_condition` Funktion:
              * Alle `Operator`-Typen mit verschiedenen `Field`s und `ConditionValue`s.
              * Komplexe `And`, `Or`, `Not` Kombinationen.
              * `SettingIsTrue` (sowohl `true` als auch `false` von Mock-Service).
              * Fehlerfälle (z.B. ungültiger Regex in `MatchesRegex`).
          * Testen der `apply_action` Funktion:
              * Alle `RuleAction`-Typen und ihre Auswirkungen auf die `ProcessedNotification`.
              * Das Verhalten von `StopProcessingFurtherRules`.
              * Simulieren der Ausführung externer Befehle (ohne tatsächliche Ausführung).
          * Testen von `process_notification`:
              * Benachrichtigungen, die blockiert werden sollten.
              * Benachrichtigungen, die modifiziert werden sollten.
              * Benachrichtigungen, die unverändert durchgelassen werden.
              * Priorisierung von Regeln.
              * Edge Cases (z.B. leeres Regelset, keine passenden Regeln).
          * Testen von `reload_rules`, `get_rules`, `update_rules`.
  * **Geschätzter Aufwand:** Hoch (ca. 5-7 Tage)

### `novade-domain/src/notification_rules/mod.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_rules/mod.rs`
  * **Verantwortlichkeit:** Definiert die öffentliche API des `notification_rules`-Moduls, indem es ausgewählte Typen und Funktionen aus seinen Untermodulen re-exportiert.
  * **Kern-Aufgaben (Tasks):**
    1.  **Public API definieren:**
          * `pub mod data_types;`
          * `pub mod errors;`
          * `pub mod persistence_iface;`
          * `pub mod persistence;`
          * `pub mod engine;`
          * `pub use data_types::{Field, Operator, ConditionValue, SimpleRuleCondition, RuleCondition, RuleAction, NotificationRule, NotificationRuleSet};`
          * `pub use errors::NotificationRulesError;`
          * `pub use persistence_iface::NotificationRulesProvider;`
          * `pub use persistence::FilesystemNotificationRulesProvider;`
          * `pub use engine::{NotificationRulesEngine, DefaultNotificationRulesEngine, RuleProcessingResult};`
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_rules/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** Alle Untermodule des `notification_rules` Verzeichnisses.
      * **Extern:** Keine direkten, da nur Re-Exports.
  * **Kommunikationsmuster:**
      * Stellt die öffentlichen Schnittstellen für andere Domänen-Services (z.B. `NotificationService`) oder die Systemschicht bereit.
  * **Erwartete Ergebnisse/Outputs:** Ein klar definiertes, konsistentes und leicht zugängliches Interface für das Benachrichtigungsregelmodul.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Sicherstellen, dass alle erwarteten Typen und Funktionen korrekt re-exportiert werden und über den `mod.rs`-Pfad zugänglich sind.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

-----

**Fortsetzung Domänenschicht: Module 9 bis 14 (aus B1 Domänenschicht.md)**

Die folgenden Module erweitern die Domänenschicht um kritische Funktionalitäten wie den Benachrichtigungsdienst, die Verwaltung von Arbeitsbereichen, die Sitzungsverwaltung, die Verwaltung von Schnellzugriffen, das System-Tray und das Kontrollzentrum.

### `novade-domain/src/notification_service/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_service/data_types.rs`
  * **Verantwortlichkeit:** Definiert die Datenstrukturen für Benachrichtigungen, sowohl eingehende als auch verarbeitete, sowie zugehörige Events.
  * **Kern-Aufgaben (Tasks):**
    1.  **Enum `Urgency` definieren:**
          * Varianten: `Low`, `Normal`, `Critical`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `From<u8>`.
    2.  **Struktur `Hint` definieren:**
          * Felder: `key: String`, `value: serde_json::Value` (um flexible Daten zu speichern, z.B. Icons, Timeout).
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    3.  **Struktur `IncomingNotification` definieren:**
          * Felder: `app_name: String`, `replaces_id: u32`, `app_icon: String`, `summary: String`, `body: String`, `actions: Vec<(String, String)>` (key, label), `hints: Vec<Hint>`, `expire_timeout: i32` (in ms), `urgency: Urgency`, `desktop_entry: Option<String>`, `category: Option<String>`, `source: String` (z.B. "D-Bus", "Internal").
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
          * `replaces_id` für das Aktualisieren bestehender Benachrichtigungen.
          * `source` zur Nachverfolgung, woher die Benachrichtigung stammt.
    4.  **Struktur `ProcessedNotification` definieren:**
          * Dies ist die intern modifizierbare Version einer Benachrichtigung, nachdem sie die Regeln durchlaufen hat.
          * Felder: Ähnlich `IncomingNotification`, aber alle Felder können modifiziert werden (`pub` oder mit Setter-Methoden).
          * Implementiere: `Clone`, `Debug`, `PartialEq`.
          * Implementiere `From<IncomingNotification>` für einfache Konvertierung.
    5.  **Enum `NotificationEvent` definieren:**
          * Varianten: `New(ProcessedNotification)`, `Closed(u32, NotificationCloseReason)`, `ActionInvoked(u32, String)`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`.
    6.  **Enum `NotificationCloseReason` definieren:**
          * Varianten: `Expired`, `Dismissed`, `ClosedByApp`, `UserCommand`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    7.  **`NotificationDisplayType` (neu)**
          * Enum `NotificationDisplayType`: `Popup`, `Persistent` (im Benachrichtigungszentrum).
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`. Kann durch Regeln gesetzt werden.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_service/data_types.rs`
  * **Abhängigkeiten:**
      * **Intern:** Keine direkten internen Abhängigkeiten.
      * **Extern:** `serde::{Serialize, Deserialize}`, `serde_json::Value`.
  * **Kommunikationsmuster:**
      * Diese Datenstrukturen werden vom `NotificationService` intern verwendet und als Events verbreitet.
  * **Erwartete Ergebnisse/Outputs:** Robuste Datenmodelle für Benachrichtigungen und deren Lebenszyklus.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der `Clone`, `Debug`, `PartialEq` Implementierungen.
          * Testen der `From` Implementierung für `Urgency` und `ProcessedNotification`.
          * Testen der Serialisierung/Deserialisierung für alle Strukturen und Varianten.
  * **Geschätzter Aufwand:** Mittel (ca. 1.5 Tage)

### `novade-domain/src/notification_service/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_service/errors.rs`
  * **Verantwortlichkeit:** Definiert spezifische Fehlertypen für den Benachrichtigungsdienst.
  * **Kern-Aufgaben (Tasks):**
    1.  **Enum `NotificationServiceError` definieren:**
          * Leite von `thiserror::Error` ab.
          * Varianten:
              * `InvalidNotification(String)`: Eingehende Benachrichtigung ist ungültig.
              * `RuleEngineError(#[from] NotificationRulesError)`: Fehler von der Regel-Engine.
              * `NotificationNotFound(u32)`: Eine Benachrichtigung mit der gegebenen ID wurde nicht gefunden.
              * `ActionFailed(String)`: Eine angeforderte Aktion konnte nicht ausgeführt werden.
              * `InternalError(String)`: Für unvorhergesehene interne Fehler.
          * Implementiere `#[error(...)]` für jede Variante.
  * **Spezifische Artefekte/Dateien:**
      * `novade-domain/src/notification_service/errors.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notification_rules::errors::NotificationRulesError`.
      * **Extern:** `thiserror::Error`.
  * **Kommunikationsmuster:**
      * Fehler werden von den Methoden des `NotificationService` zurückgegeben.
  * **Erwartete Ergebnisse/Outputs:** Eine klare Fehlerbehandlung für den Benachrichtigungsdienst.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Erstellung und Formatierung jeder Fehlervariante.
          * Testen der `From` Implementierung von `NotificationRulesError`.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

### `novade-domain/src/notification_service/service.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_service/service.rs`
  * **Verantwortlichkeit:** Verwaltet den Lebenszyklus von Benachrichtigungen, wendet Benachrichtigungsregeln an und sendet Benachrichtigungsereignisse.
  * **Kern-Aufgaben (Tasks):**
    1.  **Struktur `NotificationService` definieren:**
          * Felder: `rules_engine: Arc<dyn NotificationRulesEngine>`, `notifications: Arc<RwLock<HashMap<u32, ProcessedNotification>>>` (aktive Benachrichtigungen).
          * `next_id: Arc<AtomicU32>` (für eindeutige Benachrichtigungs-IDs).
          * `event_sender: broadcast::Sender<NotificationEvent>`.
          * `global_settings_service: Arc<dyn GlobalSettingsService>`.
    2.  **Konstruktor `new(rules_engine: Arc<dyn NotificationRulesEngine>, global_settings_service: Arc<dyn GlobalSettingsService>) -> Self` implementieren.**
          * Initialisiert alle Felder.
    3.  **Methode `handle_incoming_notification(notification: IncomingNotification) -> Result<u32, NotificationServiceError>` implementieren:**
          * Inkrementiere `next_id` für neue Benachrichtigungen.
          * Wenn `replaces_id` gesetzt ist, finde und aktualisiere die vorhandene Benachrichtigung, sonst eine neue.
          * Rufe `rules_engine.process_notification()` auf, um die Regeln anzuwenden.
          * Basierend auf `RuleProcessingResult`:
              * `Blocked`: Sende `NotificationEvent::Closed(id, Blocked)`.
              * `Displayed` oder `Modified`: Speichere/aktualisiere die `ProcessedNotification`. Sende `NotificationEvent::New` oder aktualisiere ein bestehendes.
              * Starte einen Timer für `expire_timeout` (wenn \> 0) und sende bei Ablauf `NotificationEvent::Closed(id, Expired)`.
          * Rückgabe der zugewiesenen/verwendeten ID.
    4.  **Methode `close_notification(id: u32, reason: NotificationCloseReason) -> Result<(), NotificationServiceError>` implementieren:**
          * Entferne die Benachrichtigung aus der `notifications` HashMap.
          * Sende `NotificationEvent::Closed(id, reason)`.
    5.  **Methode `invoke_action(id: u32, action_key: String) -> Result<(), NotificationServiceError>` implementieren:**
          * Finde die Benachrichtigung nach ID.
          * Validiere, ob die Aktion existiert.
          * Sende `NotificationEvent::ActionInvoked(id, action_key)`.
          * (Optional) Führe hier direkt die Aktion aus oder überlasse dies dem System Layer, je nach Granularität. Idealerweise verbleibt die Aktion als Event im Domänenbereich.
    6.  **Methode `get_notification(id: u32) -> Option<ProcessedNotification>` implementieren.**
    7.  **Methode `get_all_notifications() -> Vec<ProcessedNotification>` implementieren.**
    8.  **Methode `subscribe_to_events() -> broadcast::Receiver<NotificationEvent>` implementieren.**
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_service/service.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::notification_service::data_types::{Urgency, IncomingNotification, ProcessedNotification, NotificationEvent, NotificationCloseReason}`, `crate::notification_service::errors::NotificationServiceError`, `crate::notification_rules::engine::{NotificationRulesEngine, RuleProcessingResult}`, `crate::global_settings::service::GlobalSettingsService`.
      * **Extern:** `tokio::sync::{RwLock, broadcast}`, `std::collections::HashMap`, `std::sync::Arc`, `std::sync::atomic::{AtomicU32, Ordering}`.
  * **Kommunikationsmuster:**
      * Nutzt `NotificationRulesEngine` zur Regelverarbeitung.
      * Nutzt `GlobalSettingsService` zur Abfrage von globalen Einstellungen.
      * Sendet `NotificationEvent`s an die UI-Schicht oder andere interessierte Domänen-Services.
  * **Erwartete Ergebnisse/Outputs:** Ein zentraler Dienst zur Verwaltung und Steuerung von Benachrichtigungen.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Mocking von `NotificationRulesEngine` und `GlobalSettingsService`.
          * Testen der `handle_incoming_notification` für neue Benachrichtigungen, Updates, Blockierungen und Modifikationen.
          * Testen des Timings für `expire_timeout`.
          * Testen von `close_notification` mit verschiedenen Gründen.
          * Testen von `invoke_action` und die entsprechende Event-Generierung.
          * Testen der Event-Verteilung und des Abonnierens.
  * **Geschätzter Aufwand:** Hoch (ca. 4-6 Tage)

### `novade-domain/src/notification_service/mod.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/notification_service/mod.rs`
  * **Verantwortlichkeit:** Definiert die öffentliche API des `notification_service`-Moduls.
  * **Kern-Aufgaben (Tasks):**
    1.  **Public API definieren:**
          * `pub mod data_types;`
          * `pub mod errors;`
          * `pub mod service;`
          * `pub use data_types::{Urgency, Hint, IncomingNotification, ProcessedNotification, NotificationEvent, NotificationCloseReason, NotificationDisplayType};`
          * `pub use errors::NotificationServiceError;`
          * `pub use service::NotificationService;`
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/notification_service/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** Alle Untermodule des `notification_service` Verzeichnisses.
      * **Extern:** Keine direkten.
  * **Kommunikationsmuster:**
      * Stellt die öffentlichen Schnittstellen bereit.
  * **Erwartete Ergebnisse/Outputs:** Ein klar definiertes, konsistentes und leicht zugängliches Interface für den Benachrichtigungsdienst.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Sicherstellen, dass alle erwarteten Typen und Funktionen korrekt re-exportiert werden.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

### `novade-domain/src/workspace_manager/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/workspace_manager/data_types.rs`
  * **Verantwortlichkeit:** Definiert die Datenstrukturen für Workspaces, Fenster und deren Zustände im Kontext der Domänenlogik.
  * **Kern-Aufgaben (Tasks):**
    1.  **Struktur `WindowIdentifier` definieren:**
          * Felder: `id: Uuid`, `app_id: Option<String>` (aus D-Bus oder XDG Desktop Entry), `pid: Option<u32>`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
    2.  **Enum `WindowRole` definieren:**
          * Varianten: `Normal`, `Dialog`, `Utility`, `PopupMenu`, `Tooltip`, `Notification`, `Splashscreen`, `Dock`, `Desktop`, `Toolbar`, `Menu`, `DropdownMenu`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
    3.  **Enum `WindowState` definieren:**
          * Varianten: `Minimized`, `Maximized`, `Fullscreen`, `Tiled(TilingDirection)`, `Floating`, `Hidden`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    4.  **Enum `TilingDirection` definieren (neu):**
          * Varianten: `Left`, `Right`, `Top`, `Bottom`, `TopLeft`, `TopRight`, `BottomLeft`, `BottomRight`, `Full`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    5.  **Struktur `WindowInfo` definieren:**
          * Felder: `identifier: WindowIdentifier`, `title: String`, `class: String` (WM\_CLASS), `role: WindowRole`, `state: WindowState`, `geometry: Rect` (aus `novade-core::types::geometry`), `min_size: Option<Size>`, `max_size: Option<Size>`, `resizable: bool`, `active: bool`, `workspace_id: Uuid`, `visible_on_all_workspaces: bool`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    6.  **Struktur `Workspace` definieren:**
          * Felder: `id: Uuid`, `name: String`, `index: u32`, `windows: Vec<WindowIdentifier>`, `is_active: bool`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    7.  **Enum `WorkspaceEvent` definieren:**
          * Varianten: `Created(Workspace)`, `Removed(Uuid)`, `Activated(Uuid)`, `NameChanged(Uuid, String)`, `WindowAdded(Uuid, WindowIdentifier)`, `WindowRemoved(Uuid, WindowIdentifier)`, `WindowMoved(WindowIdentifier, Uuid, Uuid)` (Window, OldWsId, NewWsId).
          * Implementiere: `Clone`, `Debug`, `PartialEq`.
    8.  **Enum `WindowLifecycleEvent` definieren:**
          * Varianten: `New(WindowInfo)`, `Destroyed(WindowIdentifier)`, `Activated(WindowIdentifier)`, `Deactivated(WindowIdentifier)`, `Moved(WindowIdentifier, Point)`, `Resized(WindowIdentifier, Size)`, `StateChanged(WindowIdentifier, WindowState)`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/workspace_manager/data_types.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade-core::types::geometry::{Rect, Size, Point}`.
      * **Extern:** `uuid::Uuid`, `serde::{Serialize, Deserialize}`.
  * **Kommunikationsmuster:**
      * Diese Datenstrukturen werden vom `WorkspaceManagerService` und `WindowPolicyService` intern verwendet und als Events verbreitet.
  * **Erwartete Ergebnisse/Outputs:** Robuste Datenmodelle für die Verwaltung von Workspaces und Fenstern.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` Implementierungen.
          * Testen der Serialisierung/Deserialisierung für alle Strukturen und Varianten.
  * **Geschätzter Aufwand:** Mittel (ca. 2 Tage)

### `novade-domain/src/workspace_manager/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/workspace_manager/errors.rs`
  * **Verantwortlichkeit:** Definiert spezifische Fehlertypen für den Workspace-Manager.
  * **Kern-Aufgaben (Tasks):**
    1.  **Enum `WorkspaceManagerError` definieren:**
          * Leite von `thiserror::Error` ab.
          * Varianten:
              * `WorkspaceNotFound(Uuid)`: Workspace mit gegebener ID nicht gefunden.
              * `WindowNotFound(WindowIdentifier)`: Fenster mit gegebener ID nicht gefunden.
              * `InvalidWorkspaceOperation(String)`: Eine angeforderte Workspace-Operation ist ungültig (z.B. Entfernen des letzten Workspaces).
              * `PersistenceError(#[from] ConfigServiceError)`: Fehler beim Laden/Speichern von Workspace-Konfigurationen.
              * `InternalError(String)`: Für unvorhergesehene interne Fehler.
          * Implementiere `#[error(...)]` für jede Variante.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/workspace_manager/errors.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::config::service::ConfigServiceError`, `crate::workspace_manager::data_types::WindowIdentifier`.
      * **Extern:** `thiserror::Error`, `uuid::Uuid`.
  * **Kommunikationsmuster:**
      * Fehler werden von den Methoden des `WorkspaceManagerService` zurückgegeben.
  * **Erwartete Ergebnisse/Outputs:** Eine klare Fehlerbehandlung für den Workspace-Manager.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Erstellung und Formatierung jeder Fehlervariante.
          * Testen der `From` Implementierung von `ConfigServiceError`.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

### `novade-domain/src/workspace_manager/service.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/workspace_manager/service.rs`
  * **Verantwortlichkeit:** Verwaltet Workspaces, die Zuweisung von Fenstern zu Workspaces und den aktiven Workspace. Stellt den aktuellen Zustand und Events bereit.
  * **Kern-Aufgaben (Tasks):**
    1.  **Struktur `WorkspaceManagerService` definieren:**
          * Felder: `workspaces: Arc<RwLock<Vec<Workspace>>>`, `active_workspace_id: Arc<RwLock<Uuid>>`.
          * `config_service: Arc<dyn ConfigServiceAsync>`.
          * `workspace_event_sender: broadcast::Sender<WorkspaceEvent>`.
          * `window_lifecycle_event_sender: broadcast::Sender<WindowLifecycleEvent>`.
          * `global_settings_service: Arc<dyn GlobalSettingsService>`.
    2.  **Konstruktor `new(config_service: Arc<dyn ConfigServiceAsync>, global_settings_service: Arc<dyn GlobalSettingsService>) -> Result<Self, WorkspaceManagerError>` implementieren.**
          * Lädt Workspaces aus der Konfiguration oder erstellt einen Standard-Workspace.
          * Setzt den aktiven Workspace.
    3.  **Methode `create_workspace(name: String) -> Result<Workspace, WorkspaceManagerError>` implementieren:**
          * Erstellt einen neuen Workspace mit einer eindeutigen ID und Namen.
          * Fügt ihn zur Liste hinzu und sendet `WorkspaceEvent::Created`.
          * Speichert den aktualisierten Zustand.
    4.  **Methode `remove_workspace(id: Uuid) -> Result<(), WorkspaceManagerError>` implementieren:**
          * Entfernt einen Workspace. Stelle sicher, dass nicht der letzte Workspace entfernt wird.
          * Verschiebe alle Fenster des entfernten Workspaces auf einen anderen Workspace (z.B. den nächsten verfügbaren).
          * Sendet `WorkspaceEvent::Removed` und `WindowMoved` Events.
          * Speichert den aktualisierten Zustand.
    5.  **Methode `activate_workspace(id: Uuid) -> Result<(), WorkspaceManagerError>` implementieren:**
          * Setzt den gegebenen Workspace als aktiv.
          * Sendet `WorkspaceEvent::Activated`.
          * Speichert den aktualisierten Zustand.
    6.  **Methode `rename_workspace(id: Uuid, new_name: String) -> Result<(), WorkspaceManagerError>` implementieren:**
          * Ändert den Namen eines Workspaces.
          * Sendet `WorkspaceEvent::NameChanged`.
          * Speichert den aktualisierten Zustand.
    7.  **Methode `move_window_to_workspace(window_id: WindowIdentifier, target_workspace_id: Uuid) -> Result<(), WorkspaceManagerError>` implementieren:**
          * Verschiebt ein Fenster von seinem aktuellen Workspace zu einem anderen.
          * Aktualisiert die interne Fenster- und Workspace-Struktur.
          * Sendet `WorkspaceEvent::WindowMoved`.
          * Speichert den aktualisierten Zustand.
    8.  **Methode `add_window(window_info: WindowInfo, workspace_id: Uuid) -> Result<(), WorkspaceManagerError>` implementieren:**
          * Fügt ein Fenster einem bestimmten Workspace hinzu.
          * Sendet `WorkspaceEvent::WindowAdded` und `WindowLifecycleEvent::New`.
          * Speichert den aktualisierten Zustand.
    9.  **Methode `remove_window(window_id: WindowIdentifier) -> Result<(), WorkspaceManagerError>` implementieren:**
          * Entfernt ein Fenster aus seinem Workspace.
          * Sendet `WorkspaceEvent::WindowRemoved` und `WindowLifecycleEvent::Destroyed`.
          * Speichert den aktualisierten Zustand.
    10. **Methode `update_window_info(window_info: WindowInfo) -> Result<(), WorkspaceManagerError>` implementieren:**
          * Aktualisiert die Metadaten eines Fensters (z.B. Größe, Position, Titel, Zustand).
          * Sendet entsprechende `WindowLifecycleEvent`s (`Moved`, `Resized`, `StateChanged`, `Activated`, `Deactivated`).
          * Speichert den aktualisierten Zustand.
    11. **Methode `get_active_workspace() -> Workspace` implementieren.**
    12. **Methode `get_workspace_by_id(id: Uuid) -> Option<Workspace>` implementieren.**
    13. **Methode `get_all_workspaces() -> Vec<Workspace>` implementieren.**
    14. **Methode `get_windows_on_workspace(id: Uuid) -> Vec<WindowInfo>` implementieren.**
    15. **Methode `get_window_info(id: WindowIdentifier) -> Option<WindowInfo>` implementieren.**
    16. **Methoden `subscribe_to_workspace_events() -> broadcast::Receiver<WorkspaceEvent>` und `subscribe_to_window_lifecycle_events() -> broadcast::Receiver<WindowLifecycleEvent>` implementieren.**
    17. **Persistenz-Logik:** Regelmäßiges Speichern der Workspace- und Fenster-Zustände über `config_service`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/workspace_manager/service.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::workspace_manager::data_types::{Workspace, WindowInfo, WindowIdentifier, WorkspaceEvent, WindowLifecycleEvent}`, `crate::workspace_manager::errors::WorkspaceManagerError`, `crate::config::service::{ConfigServiceAsync, ConfigServiceError}`, `crate::global_settings::service::GlobalSettingsService`.
      * **Extern:** `tokio::sync::{RwLock, broadcast}`, `std::collections::HashMap`, `std::sync::Arc`, `uuid::Uuid`.
  * **Kommunikationsmuster:**
      * Kommuniziert mit `ConfigServiceAsync` zur Persistenz.
      * Nutzt `GlobalSettingsService` zur Abfrage von globalen Einstellungen (z.B. Anzahl der Standard-Workspaces).
      * Sendet Events (`WorkspaceEvent`, `WindowLifecycleEvent`) an die UI-Schicht und `WindowPolicyService`.
      * Empfängt Aufrufe von der UI-Schicht oder dem `WindowPolicyService`.
  * **Erwartete Ergebnisse/Outputs:** Ein robuster Dienst zur Verwaltung von Workspaces und Fenstern.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Mocking von `ConfigServiceAsync` und `GlobalSettingsService`.
          * Testen der Erstellung, Entfernung, Aktivierung und Umbenennung von Workspaces.
          * Testen des Hinzufügens, Entfernens und Verschiebens von Fenstern zwischen Workspaces.
          * Testen der `update_window_info` und der Generierung spezifischer Events.
          * Testen der Event-Verteilung und des Abonnierens.
          * Testen von Edge Cases (z.B. Entfernen des letzten Workspaces, Verschieben eines nicht existierenden Fensters).
  * **Geschätzter Aufwand:** Hoch (ca. 6-8 Tage)

### `novade-domain/src/workspace_manager/mod.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/workspace_manager/mod.rs`
  * **Verantwortlichkeit:** Definiert die öffentliche API des `workspace_manager`-Moduls.
  * **Kern-Aufgaben (Tasks):**
    1.  **Public API definieren:**
          * `pub mod data_types;`
          * `pub mod errors;`
          * `pub mod service;`
          * `pub use data_types::{WindowIdentifier, WindowRole, WindowState, TilingDirection, WindowInfo, Workspace, WorkspaceEvent, WindowLifecycleEvent};`
          * `pub use errors::WorkspaceManagerError;`
          * `pub use service::WorkspaceManagerService;`
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/workspace_manager/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** Alle Untermodule des `workspace_manager` Verzeichnisses.
      * **Extern:** Keine direkten.
  * **Kommunikationsmuster:**
      * Stellt die öffentlichen Schnittstellen bereit.
  * **Erwartete Ergebnisse/Outputs:** Ein klar definiertes, konsistentes und leicht zugängliches Interface für den Workspace-Manager.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Sicherstellen, dass alle erwarteten Typen und Funktionen korrekt re-exportiert werden.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

### `novade-domain/src/session_manager/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/session_manager/data_types.rs`
  * **Verantwortlichkeit:** Definiert Datenstrukturen für die Sitzungsverwaltung, einschließlich Sitzungszustand, Benutzerinformationen und Sitzungsereignisse.
  * **Kern-Aufgaben (Tasks):**
    1.  **Enum `SessionState` definieren:**
          * Varianten: `Active`, `Locked`, `Suspended`, `Idle`, `Terminating`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Eq`, `Serialize`, `Deserialize`.
    2.  **Struktur `UserInfo` definieren:**
          * Felder: `username: String`, `real_name: String`, `uid: u32`, `gid: u32`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    3.  **Struktur `SessionInfo` definieren:**
          * Felder: `session_id: String`, `state: SessionState`, `user: UserInfo`, `display_server: String` (z.B. "Wayland"), `tty: Option<String>`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    4.  **Enum `SessionEvent` definieren:**
          * Varianten: `StateChanged(SessionInfo)`, `UserChanged(UserInfo)`, `SessionEnded(String)`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/session_manager/data_types.rs`
  * **Abhängigkeiten:**
      * **Intern:** Keine direkten.
      * **Extern:** `serde::{Serialize, Deserialize}`.
  * **Kommunikationsmuster:**
      * Wird vom `SessionManagerService` verwendet und verbreitet.
  * **Erwartete Ergebnisse/Outputs:** Robuste Datenmodelle für die Sitzungsverwaltung.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der `Clone`, `Debug`, `PartialEq`, `Eq` Implementierungen.
          * Testen der Serialisierung/Deserialisierung für alle Strukturen und Varianten.
  * **Geschätzter Aufwand:** Gering (ca. 1 Tag)

### `novade-domain/src/session_manager/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/session_manager/errors.rs`
  * **Verantwortlichkeit:** Definiert spezifische Fehlertypen für den Sitzungsmanager.
  * **Kern-Aufgaben (Tasks):**
    1.  **Enum `SessionManagerError` definieren:**
          * Leite von `thiserror::Error` ab.
          * Varianten:
              * `PolicyKitError(String)`: Fehler bei PolicyKit-Interaktion (z.B. Berechtigungsfehler).
              * `LogindError(String)`: Fehler bei `logind`-Interaktion.
              * `InvalidOperation(String)`: Eine angeforderte Sitzungsoperation ist nicht erlaubt.
              * `UserNotFound(String)`: Benutzerinformationen konnten nicht abgerufen werden.
              * `InternalError(String)`: Für unvorhergesehene interne Fehler.
          * Implementiere `#[error(...)]` für jede Variante.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/session_manager/errors.rs`
  * **Abhängigkeiten:**
      * **Intern:** Keine direkten.
      * **Extern:** `thiserror::Error`.
  * **Kommunikationsmuster:**
      * Fehler werden von den Methoden des `SessionManagerService` zurückgegeben.
  * **Erwartete Ergebnisse/Outputs:** Eine klare Fehlerbehandlung für den Sitzungsmanager.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Erstellung und Formatierung jeder Fehlervariante.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

### `novade-domain/src/session_manager/service.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/session_manager/service.rs`
  * **Verantwortlichkeit:** Verwaltet den Zustand der Benutzersitzung (Sperren, Abmelden, Herunterfahren) und stellt Benutzerinformationen bereit.
  * **Kern-Aufgaben (Tasks):**
    1.  **Struktur `SessionManagerService` definieren:**
          * Felder: `current_session: Arc<RwLock<SessionInfo>>`.
          * `event_sender: broadcast::Sender<SessionEvent>`.
          * `logind_client: Arc<dyn LogindClientAsync>` (Schnittstelle zum Systemschicht `logind`).
          * `policy_kit_client: Arc<dyn PolicyKitClientAsync>` (Schnittstelle zum Systemschicht `PolicyKit`).
    2.  **Konstruktor `new(logind_client: Arc<dyn LogindClientAsync>, policy_kit_client: Arc<dyn PolicyKitClientAsync>) -> Result<Self, SessionManagerError>` implementieren.**
          * Initialisiert die `SessionInfo` durch Abfrage des `logind_client`.
          * Spawn einen Task, der kontinuierlich den Sitzungszustand über `logind_client` überwacht und `SessionEvent::StateChanged` sendet.
    3.  **Methode `lock_session() -> Result<(), SessionManagerError>` implementieren:**
          * Nutze `policy_kit_client` für Berechtigungsprüfung.
          * Rufe `logind_client.lock_session()` auf.
          * Aktualisiere den `SessionState` und sende `SessionEvent::StateChanged`.
    4.  **Methode `unlock_session() -> Result<(), SessionManagerError>` implementieren:**
          * Nutze `policy_kit_client` für Berechtigungsprüfung.
          * Rufe `logind_client.unlock_session()` auf.
          * Aktualisiere den `SessionState` und sende `SessionEvent::StateChanged`.
    5.  **Methode `terminate_session() -> Result<(), SessionManagerError>` implementieren:**
          * Nutze `policy_kit_client` für Berechtigungsprüfung.
          * Rufe `logind_client.terminate_session()` auf.
          * Aktualisiere den `SessionState` und sende `SessionEvent::SessionEnded`.
    6.  **Methode `reboot_system() -> Result<(), SessionManagerError>` implementieren:**
          * Nutze `policy_kit_client` für Berechtigungsprüfung.
          * Rufe `logind_client.reboot()` auf.
    7.  **Methode `shutdown_system() -> Result<(), SessionManagerError>` implementieren:**
          * Nutze `policy_kit_client` für Berechtigungsprüfung.
          * Rufe `logind_client.power_off()` auf.
    8.  **Methode `suspend_system() -> Result<(), SessionManagerError>` implementieren:**
          * Nutze `policy_kit_client` für Berechtigungsprüfung.
          * Rufe `logind_client.suspend()` auf.
    9.  **Methode `hibernate_system() -> Result<(), SessionManagerError>` implementieren:**
          * Nutze `policy_kit_client` für Berechtigungsprüfung.
          * Rufe `logind_client.hibernate()` auf.
    10. **Methode `get_current_session_info() -> SessionInfo` implementieren.**
    11. **Methode `get_current_user_info() -> UserInfo` implementieren.**
    12. **Methode `subscribe_to_events() -> broadcast::Receiver<SessionEvent>` implementieren.**
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/session_manager/service.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::session_manager::data_types::{SessionInfo, UserInfo, SessionState, SessionEvent}`, `crate::session_manager::errors::SessionManagerError`, `crate::system::dbus_interfaces::logind::LogindClientAsync` (Trait), `crate::system::dbus_interfaces::policykit::PolicyKitClientAsync` (Trait).
      * **Extern:** `tokio::sync::{RwLock, broadcast}`, `std::sync::Arc`.
  * **Kommunikationsmuster:**
      * Kommuniziert mit dem `logind_client` und `policy_kit_client` in der Systemschicht über D-Bus.
      * Sendet `SessionEvent`s an die UI-Schicht.
  * **Erwartete Ergebnisse/Outputs:** Ein zentraler Dienst zur Verwaltung des Sitzungszustands und zur Durchführung privilegierter Operationen (via PolicyKit).
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Mocking von `LogindClientAsync` und `PolicyKitClientAsync`.
          * Testen der Zustandsänderungen und Event-Generierung für alle Operationen (Sperren, Herunterfahren etc.).
          * Testen der Berechtigungsprüfung über den PolicyKit-Mock.
          * Testen der initialen Abfrage der Session-Info.
          * Testen der periodischen Überwachung des Sitzungszustands.
  * **Geschätzter Aufwand:** Hoch (ca. 4-6 Tage)

### `novade-domain/src/session_manager/mod.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/session_manager/mod.rs`
  * **Verantwortlichkeit:** Definiert die öffentliche API des `session_manager`-Moduls.
  * **Kern-Aufgaben (Tasks):**
    1.  **Public API definieren:**
          * `pub mod data_types;`
          * `pub mod errors;`
          * `pub mod service;`
          * `pub use data_types::{SessionState, UserInfo, SessionInfo, SessionEvent};`
          * `pub use errors::SessionManagerError;`
          * `pub use service::SessionManagerService;`
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/session_manager/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** Alle Untermodule des `session_manager` Verzeichnisses.
      * **Extern:** Keine direkten.
  * **Kommunikationsmuster:**
      * Stellt die öffentlichen Schnittstellen bereit.
  * **Erwartete Ergebnisse/Outputs:** Ein klar definiertes, konsistentes und leicht zugängliches Interface für den Sitzungsmanager.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Sicherstellen, dass alle erwarteten Typen und Funktionen korrekt re-exportiert werden.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

### `novade-domain/src/quick_access/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/quick_access/data_types.rs`
  * **Verantwortlichkeit:** Definiert die Datenstrukturen für Schnellzugriffe, z.B. Favoriten, Verknüpfungen, zuletzt verwendete Anwendungen.
  * **Kern-Aufgaben (Tasks):**
    1.  **Enum `QuickAccessItemType` definieren:**
          * Varianten: `Application`, `File`, `Directory`, `Url`, `Command`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
    2.  **Struktur `QuickAccessItem` definieren:**
          * Felder: `id: Uuid`, `item_type: QuickAccessItemType`, `name: String`, `icon: Option<String>` (Icon-Name oder Pfad), `target: String` (z.B. `.desktop` Pfad, Dateipfad, URL, Befehl), `last_accessed: Option<u64>` (Timestamp).
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    3.  **Enum `QuickAccessCollectionType` definieren (neu):**
          * Varianten: `Favorites`, `Recent`, `Custom(String)`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
    4.  **Struktur `QuickAccessCollection` definieren:**
          * Felder: `collection_type: QuickAccessCollectionType`, `items: Vec<QuickAccessItem>`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    5.  **Enum `QuickAccessEvent` definieren:**
          * Varianten: `ItemAdded(QuickAccessCollectionType, QuickAccessItem)`, `ItemRemoved(QuickAccessCollectionType, Uuid)`, `ItemUpdated(QuickAccessCollectionType, QuickAccessItem)`, `CollectionUpdated(QuickAccessCollectionType, QuickAccessCollection)`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/quick_access/data_types.rs`
  * **Abhängigkeiten:**
      * **Intern:** Keine direkten.
      * **Extern:** `uuid::Uuid`, `serde::{Serialize, Deserialize}`.
  * **Kommunikationsmuster:**
      * Wird vom `QuickAccessService` verwendet und verbreitet.
  * **Erwartete Ergebnisse/Outputs:** Robuste Datenmodelle für Schnellzugriffe.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` Implementierungen.
          * Testen der Serialisierung/Deserialisierung für alle Strukturen und Varianten.
  * **Geschätzter Aufwand:** Mittel (ca. 1.5 Tage)

### `novade-domain/src/quick_access/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/quick_access/errors.rs`
  * **Verantwortlichkeit:** Definiert spezifische Fehlertypen für den Schnellzugriffsdienst.
  * **Kern-Aufgaben (Tasks):**
    1.  **Enum `QuickAccessError` definieren:**
          * Leite von `thiserror::Error` ab.
          * Varianten:
              * `ItemNotFound(Uuid)`: Schnellzugriffselement nicht gefunden.
              * `CollectionNotFound(QuickAccessCollectionType)`: Schnellzugriffssammlung nicht gefunden.
              * `PersistenceError(#[from] ConfigServiceError)`: Fehler beim Laden/Speichern.
              * `ExecutionError(String)`: Fehler beim Ausführen eines Schnellzugriffs.
              * `InvalidItemData(String)`: Daten des Schnellzugriffselements sind ungültig.
              * `InternalError(String)`: Für unvorhergesehene interne Fehler.
          * Implementiere `#[error(...)]` für jede Variante.
  * **Spezifische Artefekte/Dateien:**
      * `novade-domain/src/quick_access/errors.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::config::service::ConfigServiceError`, `crate::quick_access::data_types::{Uuid, QuickAccessCollectionType}`.
      * **Extern:** `thiserror::Error`.
  * **Kommunikationsmuster:**
      * Fehler werden von den Methoden des `QuickAccessService` zurückgegeben.
  * **Erwartete Ergebnisse/Outputs:** Eine klare Fehlerbehandlung für den Schnellzugriffsdienst.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Erstellung und Formatierung jeder Fehlervariante.
          * Testen der `From` Implementierung von `ConfigServiceError`.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

### `novade-domain/src/quick_access/service.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/quick_access/service.rs`
  * **Verantwortlichkeit:** Verwaltet verschiedene Sammlungen von Schnellzugriffselementen (z.B. Favoriten, zuletzt verwendet) und ermöglicht deren Verwaltung und Ausführung.
  * **Kern-Aufgaben (Tasks):**
    1.  **Struktur `QuickAccessService` definieren:**
          * Felder: `collections: Arc<RwLock<HashMap<QuickAccessCollectionType, QuickAccessCollection>>>`.
          * `config_service: Arc<dyn ConfigServiceAsync>`.
          * `event_sender: broadcast::Sender<QuickAccessEvent>`.
          * `desktop_entry_manager: Arc<dyn DesktopEntryManagerAsync>` (Schnittstelle zum Systemschicht `DesktopEntryManager`).
          * `freedesktop_recent_manager: Arc<dyn FreedesktopRecentManagerAsync>` (Schnittstelle zum Systemschicht `FreedesktopRecentManager`).
    2.  **Konstruktor `new(config_service: Arc<dyn ConfigServiceAsync>, desktop_entry_manager: Arc<dyn DesktopEntryManagerAsync>, freedesktop_recent_manager: Arc<dyn FreedesktopRecentManagerAsync>) -> Result<Self, QuickAccessError>` implementieren.**
          * Lädt Sammlungen aus der Konfiguration.
          * Synchronisiert die "Recent" Sammlung mit dem `freedesktop_recent_manager`.
    3.  **Methode `add_item(collection_type: QuickAccessCollectionType, item: QuickAccessItem) -> Result<(), QuickAccessError>` implementieren:**
          * Fügt ein Element zu einer Sammlung hinzu.
          * Sende `QuickAccessEvent::ItemAdded`.
          * Speichert den aktualisierten Zustand.
    4.  **Methode `remove_item(collection_type: QuickAccessCollectionType, item_id: Uuid) -> Result<(), QuickAccessError>` implementieren:**
          * Entfernt ein Element aus einer Sammlung.
          * Sende `QuickAccessEvent::ItemRemoved`.
          * Speichert den aktualisierten Zustand.
    5.  **Methode `update_item(collection_type: QuickAccessCollectionType, updated_item: QuickAccessItem) -> Result<(), QuickAccessError>` implementieren:**
          * Aktualisiert ein bestehendes Element in einer Sammlung.
          * Sende `QuickAccessEvent::ItemUpdated`.
          * Speichert den aktualisierten Zustand.
    6.  **Methode `get_collection(collection_type: QuickAccessCollectionType) -> Option<QuickAccessCollection>` implementieren.**
    7.  **Methode `get_item(collection_type: QuickAccessCollectionType, item_id: Uuid) -> Option<QuickAccessItem>` implementieren.**
    8.  **Methode `execute_item(item_id: Uuid) -> Result<(), QuickAccessError>` implementieren:**
          * Findet das Element und führt die entsprechende Aktion aus:
              * `Application`: Starte über `desktop_entry_manager.launch_desktop_entry()`.
              * `File`/`Directory`: Öffne mit Standardanwendung (könnte über `xdg-open` oder D-Bus Portals laufen, delegieren an Systemschicht).
              * `Url`: Öffne im Browser (delegieren an Systemschicht).
              * `Command`: Führe Befehl aus (delegieren an Systemschicht).
          * Aktualisiere `last_accessed` und sende `ItemUpdated`.
    9.  **Methode `subscribe_to_events() -> broadcast::Receiver<QuickAccessEvent>` implementieren.**
    10. **Hintergrund-Task zur Synchronisierung mit `freedesktop_recent_manager` implementieren:**
          * Periodisches Abrufen der neuesten Elemente und Aktualisieren der `Recent` Sammlung.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/quick_access/service.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::quick_access::data_types::{QuickAccessItem, QuickAccessItemType, QuickAccessCollection, QuickAccessCollectionType, QuickAccessEvent}`, `crate::quick_access::errors::QuickAccessError`, `crate::config::service::{ConfigServiceAsync, ConfigServiceError}`, `crate::system::desktop_entry_manager::DesktopEntryManagerAsync`, `crate::system::freedesktop_recent_manager::FreedesktopRecentManagerAsync`.
      * **Extern:** `tokio::sync::{RwLock, broadcast}`, `std::collections::HashMap`, `std::sync::Arc`, `uuid::Uuid`.
  * **Kommunikationsmuster:**
      * Kommuniziert mit `ConfigServiceAsync` zur Persistenz.
      * Kommuniziert mit Systemschicht-Diensten (`DesktopEntryManagerAsync`, `FreedesktopRecentManagerAsync`) für die Ausführung von Anwendungen und Dateizugriffen.
      * Sendet `QuickAccessEvent`s an die UI-Schicht.
  * **Erwartete Ergebnisse/Outputs:** Ein flexibler Dienst zur Verwaltung von Schnellzugriffen, der die Integration mit globalen Standards für "zuletzt verwendete" Elemente bietet.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Mocking von `ConfigServiceAsync`, `DesktopEntryManagerAsync`, `FreedesktopRecentManagerAsync`.
          * Testen des Hinzufügens, Entfernens und Aktualisierens von Elementen in verschiedenen Sammlungen.
          * Testen der `execute_item` für verschiedene `QuickAccessItemType`s.
          * Testen der Synchronisierung mit dem `freedesktop_recent_manager`.
          * Testen der Event-Verteilung.
  * **Geschätzter Aufwand:** Hoch (ca. 5-7 Tage)

### `novade-domain/src/quick_access/mod.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/quick_access/mod.rs`
  * **Verantwortlichkeit:** Definiert die öffentliche API des `quick_access`-Moduls.
  * **Kern-Aufgaben (Tasks):**
    1.  **Public API definieren:**
          * `pub mod data_types;`
          * `pub mod errors;`
          * `pub mod service;`
          * `pub use data_types::{QuickAccessItemType, QuickAccessItem, QuickAccessCollectionType, QuickAccessCollection, QuickAccessEvent};`
          * `pub use errors::QuickAccessError;`
          * `pub use service::QuickAccessService;`
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/quick_access/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** Alle Untermodule des `quick_access` Verzeichnisses.
      * **Extern:** Keine direkten.
  * **Kommunikationsmuster:**
      * Stellt die öffentlichen Schnittstellen bereit.
  * **Erwartete Ergebnisse/Outputs:** Ein klar definiertes, konsistentes und leicht zugängliches Interface für den Schnellzugriffsdienst.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Sicherstellen, dass alle erwarteten Typen und Funktionen korrekt re-exportiert werden.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

### `novade-domain/src/system_tray/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/system_tray/data_types.rs`
  * **Verantwortlichkeit:** Definiert die Datenstrukturen für System-Tray-Symbole und zugehörige Ereignisse.
  * **Kern-Aufgaben (Tasks):**
    1.  **Struktur `SystemTrayIcon` definieren:**
          * Felder: `id: String` (D-Bus Service Name oder einzigartige ID), `tooltip: Option<String>`, `icon_name: Option<String>`, `icon_pixmap: Option<Vec<u8>>` (rohe Bilddaten für non-standard Icons), `menu_data: Option<String>` (für D-BusMenu-JSON).
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    2.  **Enum `SystemTrayEvent` definieren:**
          * Varianten: `IconAdded(SystemTrayIcon)`, `IconRemoved(String)`, `IconUpdated(SystemTrayIcon)`, `IconActivated(String, Point)` (ID, Mauskoordinaten), `MenuRequested(String, Point)` (ID, Mauskoordinaten), `Scroll(String, i32)` (ID, Delta).
          * Implementiere: `Clone`, `Debug`, `PartialEq`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/system_tray/data_types.rs`
  * **Abhängigkeiten:**
      * **Intern:** `novade-core::types::geometry::Point`.
      * **Extern:** `serde::{Serialize, Deserialize}`.
  * **Kommunikationsmuster:**
      * Wird vom `SystemTrayService` verwendet und verbreitet.
  * **Erwartete Ergebnisse/Outputs:** Robuste Datenmodelle für System-Tray-Symbole.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der `Clone`, `Debug`, `PartialEq` Implementierungen.
          * Testen der Serialisierung/Deserialisierung für alle Strukturen und Varianten.
  * **Geschätzter Aufwand:** Gering (ca. 1 Tag)

### `novade-domain/src/system_tray/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/system_tray/errors.rs`
  * **Verantwortlichkeit:** Definiert spezifische Fehlertypen für den System-Tray-Dienst.
  * **Kern-Aufgaben (Tasks):**
    1.  **Enum `SystemTrayError` definieren:**
          * Leite von `thiserror::Error` ab.
          * Varianten:
              * `IconNotFound(String)`: Symbol mit gegebener ID nicht gefunden.
              * `DbusError(String)`: Fehler bei D-Bus-Interaktion (z.B. Service nicht verfügbar).
              * `InvalidIconData(String)`: Icon-Daten sind ungültig.
              * `InternalError(String)`: Für unvorhergesehene interne Fehler.
          * Implementiere `#[error(...)]` für jede Variante.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/system_tray/errors.rs`
  * **Abhängigkeiten:**
      * **Intern:** Keine direkten.
      * **Extern:** `thiserror::Error`.
  * **Kommunikationsmuster:**
      * Fehler werden von den Methoden des `SystemTrayService` zurückgegeben.
  * **Erwartete Ergebnisse/Outputs:** Eine klare Fehlerbehandlung für den System-Tray-Dienst.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Erstellung und Formatierung jeder Fehlervariante.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

### `novade-domain/src/system_tray/service.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/system_tray/service.rs`
  * **Verantwortlichkeit:** Verwaltet die Anzeige und Interaktion mit System-Tray-Symbolen (StatusNotifierItem-Spezifikation).
  * **Kern-Aufgaben (Tasks):**
    1.  **Struktur `SystemTrayService` definieren:**
          * Felder: `icons: Arc<RwLock<HashMap<String, SystemTrayIcon>>>`.
          * `event_sender: broadcast::Sender<SystemTrayEvent>`.
          * `status_notifier_host: Arc<dyn StatusNotifierHostAsync>` (Schnittstelle zum Systemschicht `StatusNotifierHost`).
    2.  **Konstruktor `new(status_notifier_host: Arc<dyn StatusNotifierHostAsync>) -> Result<Self, SystemTrayError>` implementieren.**
          * Spawn einen Task, der auf `StatusNotifierHost` Events lauscht (z.B. neue Icons, Icon-Updates, Aktivierungen).
          * Verarbeitet diese Events und aktualisiert den internen `icons` Zustand.
          * Sendet `SystemTrayEvent`s entsprechend.
    3.  **Methode `get_all_icons() -> Vec<SystemTrayIcon>` implementieren.**
    4.  **Methode `get_icon(id: &str) -> Option<SystemTrayIcon>` implementieren.**
    5.  **Methode `activate_icon(id: String, x: i32, y: i32) -> Result<(), SystemTrayError>` implementieren:**
          * Rufe `status_notifier_host.activate_status_notifier_item(id, x, y)` auf.
          * Sende `SystemTrayEvent::IconActivated`.
    6.  **Methode `request_menu(id: String, x: i32, y: i32) -> Result<(), SystemTrayError>` implementieren:**
          * Rufe `status_notifier_host.context_menu_status_notifier_item(id, x, y)` auf.
          * Sende `SystemTrayEvent::MenuRequested`.
    7.  **Methode `scroll_icon(id: String, delta: i32, orientation: i32) -> Result<(), SystemTrayError>` implementieren:**
          * Rufe `status_notifier_host.scroll_status_notifier_item(id, delta, orientation)` auf.
          * Sende `SystemTrayEvent::Scroll`.
    8.  **Methode `subscribe_to_events() -> broadcast::Receiver<SystemTrayEvent>` implementieren.**
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/system_tray/service.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::system_tray::data_types::{SystemTrayIcon, SystemTrayEvent}`, `crate::system_tray::errors::SystemTrayError`, `crate::system::dbus_interfaces::status_notifier::StatusNotifierHostAsync` (Trait).
      * **Extern:** `tokio::sync::{RwLock, broadcast}`, `std::collections::HashMap`, `std::sync::Arc`, `futures::StreamExt`.
  * **Kommunikationsmuster:**
      * Interagiert mit der Systemschicht (`StatusNotifierHostAsync`) über D-Bus, um System-Tray-Symbole zu erkennen und zu manipulieren.
      * Sendet `SystemTrayEvent`s an die UI-Schicht.
  * **Erwartete Ergebnisse/Outputs:** Ein Dienst, der die Anzeige und Interaktion mit System-Tray-Symbolen ermöglicht.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Mocking von `StatusNotifierHostAsync`.
          * Testen der Reaktion auf `StatusNotifierHost` Events (Hinzufügen, Entfernen, Aktualisieren von Icons).
          * Testen der Methoden `activate_icon`, `request_menu`, `scroll_icon` und deren korrekte Weiterleitung an den Mock.
          * Testen der Event-Verteilung.
  * **Geschätzter Aufwand:** Mittel (ca. 3-4 Tage)

### `novade-domain/src/system_tray/mod.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/system_tray/mod.rs`
  * **Verantwortlichkeit:** Definiert die öffentliche API des `system_tray`-Moduls.
  * **Kern-Aufgaben (Tasks):**
    1.  **Public API definieren:**
          * `pub mod data_types;`
          * `pub mod errors;`
          * `pub mod service;`
          * `pub use data_types::{SystemTrayIcon, SystemTrayEvent};`
          * `pub use errors::SystemTrayError;`
          * `pub use service::SystemTrayService;`
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/system_tray/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** Alle Untermodule des `system_tray` Verzeichnisses.
      * **Extern:** Keine direkten.
  * **Kommunikationsmuster:**
      * Stellt die öffentlichen Schnittstellen bereit.
  * **Erwartete Ergebnisse/Outputs:** Ein klar definiertes, konsistentes und leicht zugängliches Interface für den System-Tray-Dienst.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Sicherstellen, dass alle erwarteten Typen und Funktionen korrekt re-exportiert werden.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

### `novade-domain/src/control_center/data_types.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/control_center/data_types.rs`
  * **Verantwortlichkeit:** Definiert Datenstrukturen für das Control Center, d.h. Kategorien, Einstellungen und Aktionen, die dort angezeigt werden können.
  * **Kern-Aufgaben (Tasks):**
    1.  **Enum `ControlItemType` definieren:**
          * Varianten: `Toggle`, `Slider`, `ComboBox`, `Button`, `TextEntry`, `Information`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
    2.  **Struktur `ControlItem` definieren:**
          * Felder: `id: String`, `item_type: ControlItemType`, `label: String`, `icon: Option<String>`, `description: Option<String>`.
          * `value: serde_json::Value` (für den aktuellen Wert, z.B. `bool` für Toggle, `f64` für Slider, `String` für ComboBox-Auswahl).
          * `min_value: Option<f64>`, `max_value: Option<f64>`, `step_size: Option<f64>` (für Slider).
          * `options: Option<Vec<String>>` (für ComboBox).
          * `action_id: Option<String>` (für Buttons, die eine spezifische Aktion auslösen).
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    3.  **Struktur `ControlCategory` definieren:**
          * Felder: `id: String`, `name: String`, `icon: Option<String>`, `items: Vec<ControlItem>`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    4.  **Enum `ControlCenterEvent` definieren:**
          * Varianten: `ItemUpdated(String, ControlItem)` (CategoryId, Item), `CategoryUpdated(ControlCategory)`, `ActionRequested(String, String)` (CategoryId, ItemId).
          * Implementiere: `Clone`, `Debug`, `PartialEq`.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/control_center/data_types.rs`
  * **Abhängigkeiten:**
      * **Intern:** Keine direkten.
      * **Extern:** `serde::{Serialize, Deserialize}`, `serde_json::Value`.
  * **Kommunikationsmuster:**
      * Wird vom `ControlCenterService` verwendet und verbreitet.
  * **Erwartete Ergebnisse/Outputs:** Robuste Datenmodelle für die Darstellung und Interaktion im Control Center.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` Implementierungen.
          * Testen der Serialisierung/Deserialisierung für alle Strukturen und Varianten.
  * **Geschätzter Aufwand:** Mittel (ca. 1.5 Tage)

### `novade-domain/src/control_center/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/control_center/errors.rs`
  * **Verantwortlichkeit:** Definiert spezifische Fehlertypen für den Control Center Dienst.
  * **Kern-Aufgaben (Tasks):**
    1.  **Enum `ControlCenterError` definieren:**
          * Leite von `thiserror::Error` ab.
          * Varianten:
              * `CategoryNotFound(String)`: Kategorie nicht gefunden.
              * `ItemNotFound(String, String)`: Element nicht gefunden (Category, ItemId).
              * `InvalidValueType(String)`: Werttyp stimmt nicht mit `ControlItemType` überein.
              * `ActionNotSupported(String)`: Angeforderte Aktion für Element nicht unterstützt.
              * `PersistenceError(#[from] ConfigServiceError)`: Fehler beim Laden/Speichern von Einstellungen.
              * `InternalError(String)`: Für unvorhergesehene interne Fehler.
          * Implementiere `#[error(...)]` für jede Variante.
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/control_center/errors.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::config::service::ConfigServiceError`.
      * **Extern:** `thiserror::Error`.
  * **Kommunikationsmuster:**
      * Fehler werden von den Methoden des `ControlCenterService` zurückgegeben.
  * **Erwartete Ergebnisse/Outputs:** Eine klare Fehlerbehandlung für den Control Center Dienst.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Erstellung und Formatierung jeder Fehlervariante.
          * Testen der `From` Implementierung von `ConfigServiceError`.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

### `novade-domain/src/control_center/service.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/control_center/service.rs`
  * **Verantwortlichkeit:** Bietet eine API zum Abfragen und Modifizieren von System- und Anwendungs-Einstellungen, die im Control Center angezeigt werden. Aggregiert Einstellungen von verschiedenen Domänen-Services.
  * **Kern-Aufgaben (Tasks):**
    1.  **Struktur `ControlCenterService` definieren:**
          * Felder: `categories: Arc<RwLock<HashMap<String, ControlCategory>>>`.
          * `event_sender: broadcast::Sender<ControlCenterEvent>`.
          * `global_settings_service: Arc<dyn GlobalSettingsService>`.
          * `power_management_service: Arc<dyn PowerManagementServiceAsync>` (für Energieeinstellungen).
          * `audio_management_service: Arc<dyn AudioManagementServiceAsync>` (für Lautstärke etc.).
          * `network_management_service: Arc<dyn NetworkManagementServiceAsync>` (für Netzwerkeinstellungen).
          * `theme_service: Arc<dyn ThemeServiceAsync>` (für Theme-Einstellungen).
          * *(Weitere Services für spezifische Kategorien, z.B. Displays, Input, Benachrichtigungen)*.
    2.  **Konstruktor `new(...) -> Result<Self, ControlCenterError>` implementieren.**
          * Registriert die relevanten Einstellungspfade und Service-APIs.
          * Initialisiert die Kategorien und Control Items basierend auf den verlinkten Services.
          * Startet Listener-Tasks für Änderungen in den verknüpften Services (`GlobalSettingsService`, `PowerManagementService`, etc.) und sendet `ControlCenterEvent::ItemUpdated` oder `CategoryUpdated`.
    3.  **Methode `get_all_categories() -> Vec<ControlCategory>` implementieren.**
    4.  **Methode `get_category(id: &str) -> Option<ControlCategory>` implementieren.**
    5.  **Methode `get_item(category_id: &str, item_id: &str) -> Option<ControlItem>` implementieren.**
    6.  **Methode `update_item_value(category_id: String, item_id: String, new_value: serde_json::Value) -> Result<(), ControlCenterError>` implementieren:**
          * Validiere den `new_value` Typ gegen den `ControlItemType`.
          * Delegiert die Aktualisierung an den zuständigen Domänen-Service (z.B. `global_settings_service.set_setting(...)`, `power_management_service.set_dpms_state(...)`).
          * Bei Erfolg: Aktualisiere den internen Zustand und sende `ControlCenterEvent::ItemUpdated`.
    7.  **Methode `invoke_action(category_id: String, item_id: String) -> Result<(), ControlCenterError>` implementieren:**
          * Delegiert die Aktion an den zuständigen Domänen-Service (z.B. `session_manager_service.reboot_system()`).
          * Sende `ControlCenterEvent::ActionRequested`.
    8.  **Methode `subscribe_to_events() -> broadcast::Receiver<ControlCenterEvent>` implementieren.**
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/control_center/service.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::control_center::data_types::{ControlItem, ControlCategory, ControlItemType, ControlCenterEvent}`, `crate::control_center::errors::ControlCenterError`, `crate::global_settings::service::GlobalSettingsService`, `crate::power_management::service::PowerManagementServiceAsync`, `crate::audio_management::service::AudioManagementServiceAsync`, `crate::network_management::service::NetworkManagementServiceAsync`, `crate::theme::service::ThemeServiceAsync`.
      * **Extern:** `tokio::sync::{RwLock, broadcast}`, `std::collections::HashMap`, `std::sync::Arc`, `serde_json::Value`.
  * **Kommunikationsmuster:**
      * Aggregiert Daten von zahlreichen anderen Domänen-Services.
      * Delegiert Wertaktualisierungen und Aktionen an die zuständigen Domänen-Services.
      * Sendet `ControlCenterEvent`s an die UI-Schicht.
  * **Erwartete Ergebnisse/Outputs:** Ein umfassender Dienst zur Aggregation und Steuerung systemweiter Einstellungen über eine einheitliche Schnittstelle.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Mocking aller abhängigen Domänen-Services.
          * Testen der initialen Aggregation von Einstellungen.
          * Testen von `update_item_value` für verschiedene Typen (Toggle, Slider etc.) und die Weiterleitung an die Mocks.
          * Testen von `invoke_action` und die Weiterleitung an die Mocks.
          * Testen der Reaktion auf Events von abhängigen Services und der Generierung von `ControlCenterEvent`s.
  * **Geschätzter Aufwand:** Hoch (ca. 6-8 Tage)

### `novade-domain/src/control_center/mod.rs`

  * **Verzeichnis-/Modulname:** `novade-domain/src/control_center/mod.rs`
  * **Verantwortlichkeit:** Definiert die öffentliche API des `control_center`-Moduls.
  * **Kern-Aufgaben (Tasks):**
    1.  **Public API definieren:**
          * `pub mod data_types;`
          * `pub mod errors;`
          * `pub mod service;`
          * `pub use data_types::{ControlItemType, ControlItem, ControlCategory, ControlCenterEvent};`
          * `pub use errors::ControlCenterError;`
          * `pub use service::ControlCenterService;`
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/control_center/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** Alle Untermodule des `control_center` Verzeichnisses.
      * **Extern:** Keine direkten.
  * **Kommunikationsmuster:**
      * Stellt die öffentlichen Schnittstellen bereit.
  * **Erwartete Ergebnisse/Outputs:** Ein klar definiertes, konsistentes und leicht zugängliches Interface für den Control Center Dienst.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Sicherstellen, dass alle erwarteten Typen und Funktionen korrekt re-exportiert werden.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

### `novade-domain/src/mod.rs` (Domänenschicht-Root)

  * **Verzeichnis-/Modulname:** `novade-domain/src/mod.rs`
  * **Verantwortlichkeit:** Aggregiert alle Sub-Module der Domänenschicht und definiert die oberste öffentliche Schnittstelle der `novade-domain` Crate.
  * **Kern-Aufgaben (Tasks):**
    1.  **Public API definieren:**
          * `pub mod config;`
          * `pub mod global_settings;`
          * `pub mod keyboard_layout;`
          * `pub mod file_manager;`
          * `pub mod theme;`
          * `pub mod wallpaper_manager;`
          * `pub mod notification_rules;`
          * `pub mod notification_service;`
          * `pub mod workspace_manager;`
          * `pub mod session_manager;`
          * `pub mod quick_access;`
          * `pub mod system_tray;`
          * `pub mod control_center;`
          * `pub mod application_launcher;` (noch zu spezifizieren)
          * `pub mod power_management;` (noch zu spezifizieren)
          * `pub mod audio_management;` (noch zu spezifizieren)
          * `pub mod network_management;` (noch zu spezifizieren)
          * `pub mod search;` (noch zu spezifizieren)
          * `pub mod plugin_manager;` (noch zu spezifizieren)
          * `pub mod device_manager;` (noch zu spezifizieren)
          * `pub mod user_feedback;` (noch zu spezifizieren)
          * `pub mod window_policy;` (noch zu spezifizieren)
          * `pub mod data_models;` (ggf. zentrale Datentypen, falls nicht schon in Submodulen)
          * `pub mod error;` (ggf. Domänen-spezifische Wrapper-Fehler, falls nicht schon im Core)
          * Re-exportiere wichtige Services und Event-Enums auf oberster Ebene für einfachen Zugriff, z.B.:
              * `pub use config::service::{ConfigService, ConfigServiceAsync};`
              * `pub use global_settings::service::{GlobalSettingsService, GlobalSettingsEvent};`
              * `pub use theme::service::ThemeService;`
              * `pub use wallpaper_manager::service::WallpaperManagerService;`
              * `pub use notification_service::service::NotificationService;`
              * `pub use workspace_manager::service::WorkspaceManagerService;`
              * `pub use session_manager::service::SessionManagerService;`
              * `pub use quick_access::service::QuickAccessService;`
              * `pub use system_tray::service::SystemTrayService;`
              * `pub use control_center::service::ControlCenterService;`
  * **Spezifische Artefakte/Dateien:**
      * `novade-domain/src/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** Alle Sub-Module der `novade-domain` Crate.
      * **Extern:** Keine direkten, da nur Re-Exports.
  * **Kommunikationsmuster:**
      * Stellt die konsolidierte API der Domänenschicht für die System- und UI-Schicht bereit.
  * **Erwartete Ergebnisse/Outputs:** Eine kohärente und gut organisierte öffentliche Schnittstelle für die gesamte Domänenschicht.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Überprüfung, dass alle beabsichtigten Module und Typen korrekt über den `mod.rs`-Pfad importiert werden können.
  * **Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

-----

**Priorisierung der Implementierung (Domänenschicht):**

Die Implementierung der Domänenschicht sollte in folgender Reihenfolge erfolgen, um Abhängigkeiten von unten nach oben zu berücksichtigen:

1.  **`novade-domain/src/config`**: (Bereits spezifiziert und müsste zuerst implementiert werden, da viele andere Module davon abhängen).
2.  **`novade-domain/src/global_settings`**: (Bereits spezifiziert).
3.  **`novade-domain/src/keyboard_layout`**: (Bereits spezifiziert).
4.  **`novade-domain/src/file_manager`**: (Bereits spezifiziert).
5.  **`novade-domain/src/theme`**: (Bereits spezifiziert).
6.  **`novade-domain/src/wallpaper_manager`**: (Gerade spezifiziert).
7.  **`novade-domain/src/notification_rules`**: (Gerade spezifiziert, da `notification_service` davon abhängt).
8.  **`novade-domain/src/notification_service`**: (Gerade spezifiziert, hängt von `notification_rules` ab).
9.  **`novade-domain/src/workspace_manager`**: (Gerade spezifiziert, hängt von `config` ab).
10. **`novade-domain/src/session_manager`**: (Gerade spezifiziert, hängt von Systemschicht `logind` und `policykit` Traits ab, die aber in der Domänenschicht als Traits definiert werden).
11. **`novade-domain/src/quick_access`**: (Gerade spezifiziert, hängt von `config` und Systemschicht `desktop_entry_manager`, `freedesktop_recent_manager` Traits ab).
12. **`novade-domain/src/system_tray`**: (Gerade spezifiziert, hängt von Systemschicht `status_notifier` Traits ab).
13. **`novade-domain/src/control_center`**: (Gerade spezifiziert, hängt von vielen anderen Domänen-Services ab).

Die noch zu spezifizierenden Module der Domänenschicht (Anwendungsluncher, Power Management, Audio Management, Netzwerk Management, Search, Plugin Manager, Device Manager, User Feedback, Window Policy) würden sich dann in den Abhängigkeitsbaum einreihen.

-----

**Übergang zur Systemschicht**

Die Spezifikation der Domänenschicht ist weit fortgeschritten. Nun wird die Systemschicht detailliert dekomponiert, wobei die Module `system::compositor` und `system::input` die Grundlage bilden, wie in "C1 System Implementierungsplan.md" beschrieben. Die `novade-system` Crate wird als nächstes in Angriff genommen.

## `novade-system`

### 1.1. Verzeichnisstruktur (`novade-system`)

```
novade-system/
├── src/
│   ├── lib.rs
│   ├── compositor/
│   │   ├── mod.rs
│   │   ├── core.rs
│   │   ├── output_management.rs
│   │   ├── xdg_shell.rs
│   │   ├── layer_shell.rs
│   │   ├── seat.rs
│   │   ├── renderer.rs
│   │   ├── cursor.rs
│   │   └── xwayland.rs
│   ├── input/
│   │   ├── mod.rs
│   │   ├── handler.rs
│   │   ├── libinput_backend.rs
│   │   ├── keyboard_layout.rs
│   │   └── gestures.rs
│   ├── dbus_interfaces/
│   │   ├── mod.rs
│   │   ├── logind.rs
│   │   ├── policykit.rs
│   │   ├── network_manager.rs
│   │   ├── upower.rs
│   │   ├── secrets.rs
│   │   ├── notifications_server.rs
│   │   ├── status_notifier.rs
│   │   └── freedesktop_recent_manager.rs
│   ├── audio_management/
│   │   ├── mod.rs
│   │   └── pipewire_backend.rs
│   ├── mcp_client/
│   │   ├── mod.rs
│   │   └── client.rs
│   ├── window_mechanics/
│   │   ├── mod.rs
│   │   ├── positioner.rs
│   │   ├── tiler.rs
│   │   └── z_order.rs
│   ├── power_management/
│   │   ├── mod.rs
│   │   └── dpms_control.rs
│   ├── device_manager/
│   │   ├── mod.rs
│   │   └── udev_monitor.rs
│   ├── portals/
│   │   ├── mod.rs
│   │   ├── file_chooser.rs
│   │   ├── screenshot.rs
│   │   └── wallpaper.rs
│   ├── application_launcher/
│   │   ├── mod.rs
│   │   └── desktop_entry_manager.rs
│   ├── errors.rs
│   └── types.rs
```

### `novade-system/src/lib.rs`

  * **Verzeichnis-/Modulname:** `novade-system/src/lib.rs`
  * **Verantwortlichkeit:** Das Root-Modul der `novade-system` Crate. Definiert die grundlegende Struktur und re-exportiert die öffentlichen Schnittstellen der Systemschicht-Module. Enthält die `SystemServices` Struktur für die Initialisierung.
  * **Kern-Aufgaben (Tasks):**
    1.  **Modul-Deklarationen:**
          * `pub mod compositor;`
          * `pub mod input;`
          * `pub mod dbus_interfaces;`
          * `pub mod audio_management;`
          * `pub mod mcp_client;`
          * `pub mod window_mechanics;`
          * `pub mod power_management;`
          * `pub mod device_manager;`
          * `pub mod portals;`
          * `pub mod application_launcher;`
          * `pub mod errors;`
          * `pub mod types;`
    2.  **Re-Exports:** Wichtige Typen und Service-Traits aus den Untermodulen re-exportieren, um den Zugriff zu vereinfachen.
          * `pub use errors::SystemError;`
          * `pub use types::*;` (allgemeine System-Typen)
          * `pub use compositor::service::{CompositorService, CompositorEvent};` (wenn Service-Pattern im Compositor angewendet wird)
          * `pub use input::InputService;`
          * `pub use dbus_interfaces::logind::LogindClientAsync;`
          * `pub use dbus_interfaces::policykit::PolicyKitClientAsync;`
          * `pub use dbus_interfaces::status_notifier::StatusNotifierHostAsync;`
          * `pub use application_launcher::desktop_entry_manager::DesktopEntryManagerAsync;`
          * `pub use dbus_interfaces::freedesktop_recent_manager::FreedesktopRecentManagerAsync;`
          * `pub use audio_management::service::AudioManagementServiceAsync;`
          * `pub use power_management::service::PowerManagementServiceAsync;`
          * (und weitere, sobald spezifiziert)
    3.  **Struktur `SystemServices` definieren:**
          * Eine zentrale Struktur, die Instanzen aller wichtigen System-Services enthält.
          * Felder: `compositor_service: Arc<CompositorService>`, `input_service: Arc<InputService>`, `logind_client: Arc<dyn LogindClientAsync>`, etc.
    4.  **Funktion `initialize_system_services(...) -> Result<SystemServices, SystemError>` implementieren:**
          * Diese asynchrone Funktion ist der zentrale Einstiegspunkt, um alle System-Services zu initialisieren.
          * Sie nimmt Abhängigkeiten von der Domänenschicht entgegen (z.B. `Arc<GlobalSettingsService>`, `Arc<WindowPolicyService>`).
          * Instanziiert alle System-Services in der korrekten Reihenfolge, löst D-Bus-Verbindungen auf und registriert Handler.
          * Startet die Haupt-Loops der Dienste (z.B. Compositor-Loop, Input-Handler-Loop) in Tokio-Tasks.
          * Gibt die `SystemServices`-Struktur zurück.
  * **Spezifische Artefakte/Dateien:**
      * `novade-system/src/lib.rs`
  * **Abhängigkeiten:**
      * **Intern:** Alle Untermodule der `novade-system` Crate.
      * **Extern:** `Arc`, `tokio`, `futures`, `zbus`, `smithay`, `libinput` etc.
  * **Kommunikationsmuster:**
      * Exportiert die API für die `novade-ui` Crate und ggf. andere externe Komponenten.
      * Initialisiert alle internen Komponenten der Systemschicht.
  * **Erwartete Ergebnisse/Outputs:** Eine vollständig initialisierte und lauffähige Systemschicht, bereit für die Interaktion mit der UI-Schicht.
  * **Teststrategie (Modul-spezifisch):**
      * **Integration Tests:**
          * Testen der `initialize_system_services` Funktion, um sicherzustellen, dass alle Dienste korrekt initialisiert werden und keine Fehler auftreten.
          * End-to-End-Tests, die die Interaktion zwischen verschiedenen System-Services simulieren.
  * **Geschätzter Aufwand:** Mittel (ca. 2-3 Tage, hauptsächlich Koordination und Orchestrierung)

### `novade-system/src/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-system/src/errors.rs`
  * **Verantwortlichkeit:** Definiert allgemeine Fehlertypen für die Systemschicht, die von `thiserror` abgeleitet sind und spezifische Fehler aus Submodulen aggregieren.
  * **Kern-Aufgaben (Tasks):**
    1.  **Enum `SystemError` definieren:**
          * Leite von `thiserror::Error` ab.
          * Varianten:
              * `CompositorError(#[from] crate::compositor::errors::CompositorError)`: Fehler vom Compositor.
              * `InputError(#[from] crate::input::errors::InputError)`: Fehler von der Eingabeverarbeitung.
              * `DbusError(#[from] zbus::Error)`: Allgemeine D-Bus-Fehler.
              * `DbusInterfaceError(String)`: Spezifische Fehler von D-Bus-Schnittstellen (z.B. `logind`).
              * `WaylandProtocolsError(String)`: Fehler bei Wayland-Protokoll-Implementierung.
              * `IOError(#[from] std::io::Error)`: Standard I/O Fehler.
              * `InitError(String)`: Fehler während der Initialisierung eines System-Dienstes.
              * `DominoError(#[from] crate::domino_interfaces::DominoError)`: Fehler von MCP-Kommunikation.
              * `PolicyError(String)`: Fehler bei der Anwendung von Domänen-Policies.
              * `UnhandledEvent(String)`: Ein unerwartetes oder unbehandeltes Ereignis.
              * `InternalError(String)`: Für unvorhergesehene interne Fehler.
          * Implementiere `#[error(...)]` für jede Variante.
  * **Spezifische Artefakte/Dateien:**
      * `novade-system/src/errors.rs`
  * **Abhängigkeiten:**
      * **Intern:** Abhängigkeiten zu allen spezifischen Fehlertypen der Submodule (z.B. `compositor::errors::CompositorError`).
      * **Extern:** `thiserror::Error`, `zbus::Error`, `std::io::Error`.
  * **Kommunikationsmuster:**
      * Diese Fehler werden von den System-Services an die aufrufende Schicht (`lib.rs` oder `novade-ui`) zurückgegeben.
  * **Erwartete Ergebnisse/Outputs:** Eine konsistente und zentralisierte Fehlerbehandlung für die gesamte Systemschicht.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Erstellung jeder Fehler-Variante.
          * Testen der `From` Implementierungen von den Submodul-Fehlern.
          * Testen der korrekten Formatierung der Fehlermeldungen.
  * **Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

### `novade-system/src/types.rs`

  * **Verzeichnis-/Modulname:** `novade-system/src/types.rs`
  * **Verantwortlichkeit:** Definiert grundlegende, systemweite Datentypen, die nicht spezifisch für ein Submodul sind, aber in mehreren verwendet werden.
  * **Kern-Aufgaben (Tasks):**
    1.  **Struktur `DesktopState` definieren:** (zentraler Zustand des Desktops, der von Compositor, Input etc. verwendet wird)
          * Felder:
              * `outputs: HashMap<WlOutput, Output>` (Smithay-Outputs)
              * `windows: HashMap<WlSurface, WindowSurface>` (Smithay-Fenster-Oberflächen)
              * `seats: Vec<Seat>` (Smithay-Seats, Eingabegeräte)
              * `input_state: InputState` (aus `input::handler`)
              * `cursor_state: CursorState` (aus `compositor::cursor`)
              * `active_window: Option<WindowIdentifier>` (aus `novade-domain::workspace_manager::data_types`)
              * `active_workspace_id: Option<Uuid>` (aus `novade-domain::workspace_manager::data_types`)
              * `renderer: Option<SmithayRenderer>` (Platzhalter für den tatsächlichen Smithay-Renderer)
              * `display_handle: smithay::wayland::DisplayHandle`
              * `event_loop_handle: smithay::wayland::EventLoopHandle`
              * `last_render_time: Instant`
              * `start_time: Instant`
              * `current_frame_time: Instant`
              * `pending_render_timer: Option<smithay::utils::signaling::SignalSender<()>>`
              * *(Weitere Felder nach Bedarf, z.B. für Global Settings, Compositor State, etc.)*
          * Implementiere: `Default`, `Debug`.
          * Stelle sicher, dass die Struktur `Send` und `Sync` ist (mit `Arc<Mutex>` oder `Arc<RwLock>` für Felder, die dies benötigen).
    2.  **Struktur `WindowSurface` definieren:**
          * Felder: `wl_surface: WlSurface`, `role: WindowRole`, `state: WindowState`, `geometry: Rect`, `last_active_time: Instant`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`.
    3.  **Enum `RenderEvent` definieren:**
          * Varianten: `RequestRepaint(OutputId)`.
          * Implementiere: `Clone`, `Debug`, `PartialEq`.
    4.  **`OutputId` (aus Smithay) re-exportieren.**
    5.  **`Instant` (aus `std::time`) re-exportieren.**
  * **Spezifische Artefakte/Dateien:**
      * `novade-system/src/types.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::input::handler::InputState`, `crate::compositor::cursor::CursorState`.
      * **Extern:** `smithay::wayland::{DisplayHandle, EventLoopHandle, WlOutput, WlSurface}`, `smithay::utils::signaling::SignalSender`, `smithay::output::Output`, `std::collections::HashMap`, `std::time::Instant`, `Arc`, `Mutex`, `RwLock` (für interne Nutzung), `novade-core::types::geometry::{Rect, Size, Point}`, `novade-domain::workspace_manager::data_types::{WindowIdentifier, WindowRole, WindowState}`.
  * **Kommunikationsmuster:**
      * Diese Typen dienen als zentrale Datenmodelle und Zustandshalter für verschiedene System-Komponenten.
  * **Erwartete Ergebnisse/Outputs:** Eine gemeinsame und kohärente Definition von Systemzuständen und grundlegenden Datenstrukturen.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der `Default`, `Clone`, `Debug`, `PartialEq` Implementierungen.
  * **Geschätzter Aufwand:** Mittel (ca. 1.5 Tage)

### `novade-system/src/compositor/mod.rs`

  * **Verzeichnis-/Modulname:** `novade-system/src/compositor/mod.rs`
  * **Verantwortlichkeit:** Definiert die öffentliche API des `compositor`-Moduls.
  * **Kern-Aufgaben (Tasks):**
    1.  **Modul-Deklarationen:**
          * `pub mod core;`
          * `pub mod output_management;`
          * `pub mod xdg_shell;`
          * `pub mod layer_shell;`
          * `pub mod seat;`
          * `pub mod renderer;`
          * `pub mod cursor;`
          * `pub mod xwayland;`
          * `pub mod errors;`
          * `pub mod service;` (wenn ein Service-Pattern verwendet wird)
    2.  **Re-Exports:**
          * `pub use core::{CompositorState, create_all_wayland_globals, run_compositor_event_loop};`
          * `pub use errors::CompositorError;`
          * `pub use service::{CompositorService, CompositorEvent};` (wenn Service-Pattern)
          * `pub use output_management::OutputConfiguration;`
          * *(Weitere Re-Exports, die über die Modulgrenze hinaus sichtbar sein sollen)*
  * **Spezifische Artefakte/Dateien:**
      * `novade-system/src/compositor/mod.rs`
  * **Abhängigkeiten:**
      * **Intern:** Alle Untermodule des `compositor` Verzeichnisses.
      * **Extern:** Keine direkten, da nur Re-Exports.
  * **Kommunikationsmuster:**
      * Stellt die öffentlichen Schnittstellen für den Compositor bereit, die von `novade-system/src/lib.rs` genutzt werden.
  * **Erwartete Ergebnisse/Outputs:** Ein klar definierter Zugangspunkt zur Compositor-Funktionalität.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Sicherstellen, dass alle erwarteten Typen und Funktionen korrekt re-exportiert werden.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

### `novade-system/src/compositor/errors.rs`

  * **Verzeichnis-/Modulname:** `novade-system/src/compositor/errors.rs`
  * **Verantwortlichkeit:** Definiert spezifische Fehlertypen für den Compositor.
  * **Kern-Aufgaben (Tasks):**
    1.  **Enum `CompositorError` definieren:**
          * Leite von `thiserror::Error` ab.
          * Varianten:
              * `WaylandInitError(#[from] smithay::backend::session::Error)`: Fehler bei der Initialisierung des Wayland-Backends.
              * `GraphicsError(String)`: Fehler im Grafik-Backend (z.B. OpenGL, Vulkan).
              * `OutputNotFound(String)`: Ein angefragter Monitor-Output wurde nicht gefunden.
              * `SurfaceNotFound`: Eine Wayland-Oberfläche wurde nicht gefunden.
              * `ProtocolError(String)`: Fehler bei der Implementierung eines Wayland-Protokolls.
              * `XWaylandError(String)`: Fehler bei der XWayland-Integration.
              * `InternalError(String)`: Für unvorhergesehene interne Fehler.
          * Implementiere `#[error(...)]` für jede Variante.
  * **Spezifische Artefakte/Dateien:**
      * `novade-system/src/compositor/errors.rs`
  * **Abhängigkeiten:**
      * **Intern:** Keine direkten.
      * **Extern:** `thiserror::Error`, `smithay::backend::session::Error`.
  * **Kommunikationsmuster:**
      * Fehler werden von den Compositor-Komponenten zurückgegeben.
  * **Erwartete Ergebnisse/Outputs:** Eine klare Fehlerbehandlung für den Compositor.
  * **Teststrategie (Modul-spezifisch):**
      * **Unit Tests:**
          * Testen der Erstellung und Formatierung jeder Fehlervariante.
          * Testen der `From` Implementierung von `smithay::backend::session::Error`.
  * **Geschätzter Aufwand:** Gering (ca. 0.25 Tage)

### `novade-system/src/compositor/core.rs`

  * **Verzeichnis-/Modulname:** `novade-system/src/compositor/core.rs`
  * **Verantwortlichkeit:** Enthält die Hauptschleife des Compositors, verwaltet den globalen `DesktopState` und integriert alle Smithay-Komponenten.
  * **Kern-Aufgaben (Tasks):**
    1.  **Struktur `CompositorState` definieren:**
          * Dies ist der zentrale Zustand des Compositors, der Smithay-spezifische Elemente enthält und von `novade-system::types::DesktopState` referenziert oder umschlossen wird.
          * Felder:
              * `display_handle: smithay::wayland::DisplayHandle`
              * `event_loop_handle: smithay::wayland::EventLoopHandle`
              * `space: smithay::desktop::Space` (für die Verwaltung von Oberflächen auf Outputs)
              * `render_timer: smithay::utils::signaling::SignalSender<()>` (für die Steuerung des Renderings)
              * `allocator: smithay::backend::allocator::dmabuf::DmabufAllocator` (für Buffer-Management)
              * `dnd_manager: smithay::wayland::data_device::DataDeviceManager`
              * `keyboard_manager: smithay::wayland::keyboard_shortcuts_inhibit::KeyboardShortcutsInhibitManager`
              * `layer_shell_state: smithay::wayland::shell::wlr_layer_shell::WlrLayerShell`
              * `xdg_shell_state: smithay::wayland::shell::xdg::XdgShell`
              * `output_manager: smithay::output::OutputManager`
              * `primary_seat: smithay::input::Seat<DesktopState>`
              * `seat_state: smithay::input::SeatState<DesktopState>`
              * `xdg_decoration_manager: smithay::wayland::shell::xdg::decoration::XdgDecorationManager`
              * `xdg_output_manager: smithay::wayland::output::xdg::XdgOutputManager`
              * `shm_state: smithay::wayland::shm::ShmState`
              * `drm_node: Option<PathBuf>` (für DRM-Backend)
              * `backend_data: smithay::backend::winit::WinitEventLoopData` oder `smithay::backend::drm::DrmEventLoopData` (abhängig vom Backend)
              * `window_policy_service: Arc<dyn WindowPolicyServiceAsync>` (Domänen-Dienst für Fenster-Policies)
              * `workspace_manager_service: Arc<dyn WorkspaceManagerService>` (Domänen-Dienst für Workspace-Management)
              * `global_settings_service: Arc<dyn GlobalSettingsService>` (Domänen-Dienst für globale Einstellungen)
          * Implementiere: `Default` (wenn sinnvoll, sonst über `new`).
          * `DesktopState` sollte eine `Arc<Mutex<CompositorState>>` oder `Arc<RwLock<CompositorState>>` beinhalten oder `CompositorState` selbst ein Wrapper um `DesktopState` sein.
    2.  **Funktion `create_all_wayland_globals(display_handle: &DisplayHandle, state: &mut DesktopState) -> Result<(), CompositorError>` implementieren:**
          * Initialisiert alle Smithay Wayland-Globals (e.g. `ShmState`, `XdgShell`, `LayerShell`, `SeatState`, `OutputManager`, `DataDeviceManager`, `KeyboardShortcutsInhibitManager`, `XdgDecorationManager`, `XdgOutputManager`).
          * Verbindet diese mit den entsprechenden Handlern im `CompositorState` und `DesktopState`.
    3.  **Funktion `run_compositor_event_loop(display_handle: DisplayHandle, event_loop: EventLoop<CompositorState>) -> Result<(), CompositorError>` implementieren:**
          * Dies ist die Haupt-Event-Schleife, die auf Smithay-Events, Backend-Events und interne Render-Anfragen reagiert.
          * Beinhaltet den `event_loop.run()` Aufruf oder eine `async` Schleife, die Smithay-Events verarbeitet.
          * Regelt das Rendering:
              * Wenn ein `RequestRepaint` Event empfangen wird oder ein Timeout abläuft, triggere einen Render-Durchlauf.
              * Nutze `renderer` Modul zum Zeichnen.
              * Plane den nächsten Frame.
          * Verarbeitet `smithay::backend::session::SessionEvent` und `smithay::backend::drm::DrmEvent` oder `smithay::backend::winit::WinitEvent`.
    4.  **Funktion `send_frame_callbacks(surface: &WlSurface, time: Duration)` (intern):**
          * Iteriert über alle `FrameCallback`s einer Oberfläche und sendet diese.
    5.  **Hilfsfunktionen für die Statusverwaltung:**
          * `focused_client_surface(seat: &Seat) -> Option<WlSurface>`
          * `window_at(pos: Point, state: &DesktopState) -> Option<(WindowSurface, Point)>`
          * `surface_under_cursor(state: &DesktopState) -> Option<(WlSurface, Point)>`
  * **Spezifische Artefakte/Dateien:**
      * `novade-system/src/compositor/core.rs`
  * **Abhängigkeiten:**
      * **Intern:** `crate::compositor::errors::CompositorError`, `crate::compositor::renderer`, `crate::compositor::output_management`, `crate::compositor::xdg_shell`, `crate::compositor::layer_shell`, `crate::compositor::seat`, `crate::compositor::cursor`, `crate::compositor::xwayland`, `crate::system::types::{DesktopState, WindowSurface}`, `novade-domain::window_policy::service::WindowPolicyServiceAsync`, `novade-domain::workspace_manager::service::WorkspaceManagerService`, `novade-domain::global_settings::service::GlobalSettingsService`.
      * **Extern:** `smithay::wayland::{DisplayHandle, EventLoopHandle, WlSurface, WlOutput}`, `smithay::desktop::{Space, Window}`, `smithay::input::Seat`, `smithay::backend::allocator::dmabuf::DmabufAllocator`, `smithay::wayland::data_device::DataDeviceManager`, `smithay::wayland::keyboard_shortcuts_inhibit::KeyboardShortcutsInhibitManager`, `smithay::wayland::shell::wlr_layer_shell::WlrLayerShell`, `smithay::wayland::shell::xdg::{XdgShell, decoration::XdgDecorationManager}`, `smithay::output::OutputManager`, `smithay::input::SeatState`, `smithay::wayland::output::xdg::XdgOutputManager`, `smithay::wayland::shm::ShmState`, `smithay::backend::winit::WinitEventLoopData`, `smithay::backend::drm::DrmEventLoopData`, `smithay::utils::signaling::SignalSender`, `smithay::utils::signaling::Signals`, `Arc`, `Mutex`, `RwLock`, `std::path::PathBuf`, `std::time::{Duration, Instant}`, `futures::executor::block_on`.
  * **Kommunikationsmuster:**
      * Interagiert stark mit Smithay-APIs.
      * Nutzt `WindowPolicyService`, `WorkspaceManagerService` und `GlobalSettingsService` aus der Domänenschicht, um Wayland-Oberflächen in den Desktop-Kontext zu integrieren und deren Verhalten zu steuern.
      * Sendet Render-Anfragen an das `renderer`-Modul.
      * Empfängt Events von Backend-Treibern (Winit, DRM).
  * **Erwartete Ergebnisse/Outputs:** Das Herzstück des Compositors, das die Wayland-Kommunikation, das Rendering und die Zustandsverwaltung orchestriert.
  * **Teststrategie (Modul-spezifisch):**
      * **Integration Tests (auf Compositor-Ebene):**
          * Tests, die einen Wayland-Client starten und dessen Fensterlebenszyklus simulieren (Erstellung, Größenänderung, Fokus, Schließen).
          * Testen der Interaktion zwischen Compositor und Domänen-Services (z.B. Fenster auf anderen Workspace verschieben).
          * Snapshot-Tests des Render-Outputs (wenn möglich).
      * **Unit Tests:**
          * Testen der Hilfsfunktionen wie `window_at`.
  * **Geschätzter Aufwand:** Sehr Hoch (ca. 10-15 Tage)
Die Arbeit wird ab `novade-domain/src/power_management` fortgesetzt, um eine lückenlose Spezifikation zu gewährleisten.

### **novade-domain/src/power\_management**

**Verantwortlichkeit:**
Dieses Modul ist für die Domänenlogik des Energiemanagements zuständig. Es definiert den Zustand, die Richtlinien und Aktionen, die NovaDE in Bezug auf Energieoptionen (Bildschirmabschaltung, Ruhezustand, Herunterfahren) ausführen kann. Es abstrahiert die technischen Details der Systemschicht, um eine saubere Trennung der Verantwortlichkeiten zu gewährleisten.

**Kern-Aufgaben (Tasks):**

1.  **Definition von Datenstrukturen und Enums:**

      * Definiere die `PowerState` Enum mit Varianten wie `Active`, `ScreenOff`, `Suspended`, `Hibernated`, `ShuttingDown`, `Rebooting`.
      * Definiere die `DisplayPowerManagementMode` Enum mit Varianten wie `On`, `Off`, `Dim`.
      * Definiere eine `ScreenLockPolicy` Enum (z.B. `NoLock`, `LockOnSuspend`, `LockAfterTimeout`).
      * Definiere eine `PowerAction` Enum mit Varianten wie `Suspend`, `Hibernate`, `Shutdown`, `Reboot`, `SetDisplayMode(DisplayPowerManagementMode)`.
      * Definiere die `PowerSettings` Struktur, die Konfigurationsoptionen für das Energiemanagement enthält, z.B. Timeout für Bildschirmabschaltung, Verhalten bei Deckel-Schließung, globale Energie-Profil-Einstellung. Implementiere: `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
      * Definiere `PowerManagementError` Enum, das Fehler im Energiemanagement kapselt (z.B. `PolicyConflict`, `InvalidPowerState`, `PermissionDenied`, `SystemError`).

2.  **`PowerManagementService` Trait:**

      * Definiere den `PowerManagementService` Trait, der die Schnittstelle für die Domänenlogik des Energiemanagements darstellt.
      * Methoden:
          * `fn get_current_power_state(&self) -> Result<PowerState, PowerManagementError>`: Ruft den aktuellen Energiestatus ab.
          * `async fn request_power_action(&self, action: PowerAction) -> Result<(), PowerManagementError>`: Fordert eine Energieaktion an. Prüft Domänenrichtlinien vor der Weitergabe an die Systemschicht.
          * `async fn apply_display_power_policy(&self, mode: DisplayPowerManagementMode) -> Result<(), PowerManagementError>`: Wendet eine Bildschirm-Energieverwaltungspolitik an.
          * `fn get_power_settings(&self) -> Result<PowerSettings, PowerManagementError>`: Ruft die aktuellen Energieeinstellungen ab.
          * `async fn update_power_settings(&self, settings: PowerSettings) -> Result<(), PowerManagementError>`: Aktualisiert die Energieeinstellungen.
          * `fn subscribe_to_power_state_changes(&self) -> broadcast::Receiver<PowerState>`: Ermöglicht das Abonnieren von Änderungen des Energiestatus.

3.  **Implementierung `DefaultPowerManagementService`:**

      * Implementiere `DefaultPowerManagementService` basierend auf dem `PowerManagementService` Trait.
      * Verwalte den internen Zustand des Energiemanagements.
      * Interagiere mit `GlobalSettingsService` (für `PowerSettings`) und `SystemPowerService` (für tatsächliche Aktionen).
      * Implementiere die Logik zur Anwendung von Richtlinien (z.B. Blockieren von Aktionen basierend auf Einstellungen oder Benutzerberechtigungen).
      * Nutze `RwLock` oder `Mutex` für den internen Zustand, falls nötig.
      * Verwende `tokio::sync::broadcast::Sender` und `Receiver` für Statusänderungen.

**Spezifische Artefakte/Dateien:**

  * `novade-domain/src/power_management/mod.rs`
  * `novade-domain/src/power_management/data_types.rs`
  * `novade-domain/src/power_management/errors.rs`
  * `novade-domain/src/power_management/service.rs` (enthält Trait und Implementierung)

**Abhängigkeiten:**

  * **Intern:**
      * `crate::global_settings::GlobalSettingsService` (für `PowerSettings`).
      * `novade-system::power_management::SystemPowerService` (für die Interaktion mit dem System).
      * `novade-core::error::CoreError` (für Basisfehlerkonvertierung).
      * `novade-core::config::ConfigServiceAsync` (potenziell für persistente Speicherung der Einstellungen, falls `GlobalSettingsService` dies nicht direkt übernimmt).
  * **Extern:**
      * `serde::{Serialize, Deserialize}`
      * `thiserror::Error` (für `PowerManagementError`)
      * `tokio::sync::broadcast`
      * `tokio::task`
      * `parking_lot::{RwLock, Mutex}` (optional, je nach Zustandskonsistenzmodell)
      * `async_trait` (für async Traits)

**Kommunikationsmuster:**

  * **Von UI-Schicht:** Ruft Methoden auf `PowerManagementService` auf (z.B. `request_power_action`, `update_power_settings`).
  * **An UI-Schicht:** Sendet `PowerState` Änderungen über `broadcast::Sender`.
  * **An Systemschicht:** Ruft Methoden auf `SystemPowerService` auf, um die tatsächlichen Energieaktionen auszuführen.
  * **Von GlobalSettingsService:** Empfängt Änderungen an Energieeinstellungen.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Energiemanagement-Dienst, der es NovaDE ermöglicht, den Energiestatus zu überwachen, Energieeinstellungen zu verwalten und Energieaktionen (Suspend, Shutdown, etc.) unter Berücksichtigung von Domänenrichtlinien sicher auszuführen.

**Teststrategie (Modul-spezifisch):**

  * **Unit Tests:**
      * Testen der `PowerState` und `DisplayPowerManagementMode` Enums.
      * Testen der Serialisierung/Deserialisierung von `PowerSettings`.
      * Testen der `request_power_action` Methode mit verschiedenen `PowerAction`s, einschließlich Szenarien, in denen Aktionen aufgrund von Richtlinien blockiert werden sollten.
      * Mocken von `GlobalSettingsService` und `SystemPowerService` um die Logik des `DefaultPowerManagementService` isoliert zu testen.
      * Testen der `subscribe_to_power_state_changes` Funktionalität, um sicherzustellen, dass Statusänderungen korrekt propagiert werden.
      * Testen der Fehlerbehandlung für jede Methode.

**Geschätzter Aufwand:** Mittel (ca. 3-4 Tage)

-----

### **novade-domain/src/desktop\_environment\_management**

**Verantwortlichkeit:**
Dieses Modul ist für die Verwaltung des allgemeinen Zustands und der Lifecycle-Ereignisse der NovaDE-Desktop-Umgebung verantwortlich. Es koordiniert den Start und Stopp anderer Domänendienste und orchestriert globale Desktop-Zustandsübergänge.

**Kern-Aufgaben (Tasks):**

1.  **Definition von Datenstrukturen und Enums:**

      * Definiere die `DesktopState` Enum mit Varianten wie `Initializing`, `Running`, `Suspending`, `ShuttingDown`, `Error`.
      * Definiere `DesktopEvent` Enum (z.B. `DesktopStarted`, `DesktopStopped`, `SuspendRequested`, `ResumeRequested`, `ShutdownRequested`, `RebootRequested`).
      * Definiere `DesktopEnvironmentError` Enum, das Fehler in der Desktop-Verwaltung kapselt (z.B. `InitializationFailed`, `ServiceStartError`, `ShutdownError`).

2.  **`DesktopEnvironmentService` Trait:**

      * Definiere den `DesktopEnvironmentService` Trait.
      * Methoden:
          * `async fn initialize(&self) -> Result<(), DesktopEnvironmentError>`: Initialisiert alle erforderlichen Domänen- und Systemdienste.
          * `async fn start(&self) -> Result<(), DesktopEnvironmentError>`: Startet die Desktop-Umgebung und alle zugehörigen Services.
          * `async fn shutdown(&self) -> Result<(), DesktopEnvironmentError>`: Leitet das Herunterfahren der Desktop-Umgebung ein.
          * `async fn suspend(&self) -> Result<(), DesktopEnvironmentError>`: Leitet den Ruhezustand ein.
          * `async fn resume(&self) -> Result<(), DesktopEnvironmentError>`: Setzt den Betrieb nach dem Ruhezustand fort.
          * `fn get_current_state(&self) -> Result<DesktopState, DesktopEnvironmentError>`: Ruft den aktuellen globalen Desktop-Zustand ab.
          * `fn subscribe_to_desktop_events(&self) -> broadcast::Receiver<DesktopEvent>`: Ermöglicht das Abonnieren globaler Desktop-Ereignisse.

3.  **Implementierung `DefaultDesktopEnvironmentService`:**

      * Implementiere `DefaultDesktopEnvironmentService` basierend auf dem `DesktopEnvironmentService` Trait.
      * Hält Referenzen (z.B. `Arc<dyn ServiceTrait>`) zu allen anderen Domänen- und kritischen Systemdiensten (z.B. `ConfigService`, `GlobalSettingsService`, `WallpaperManagerService`, `ThemeService`, `NotificationService`, `PowerManagementService`, `SystemCompositorService`).
      * Die `initialize` Methode ist verantwortlich für die korrekte Initialisierung dieser abhängigen Dienste in der richtigen Reihenfolge, das Laden initialer Konfigurationen und das Abonnieren relevanter Events.
      * Die `start` Methode startet die Event-Loops oder Listener der Dienste.
      * Die `shutdown`, `suspend`, `resume` Methoden orchestrieren die jeweiligen Aktionen über die abhängigen Dienste (z.B. Speichern des Zustands, Beenden von Prozessen, Anfordern von Systemaktionen über `PowerManagementService`).
      * Verwaltet den `DesktopState` intern und sendet `DesktopEvent`s über `broadcast::Sender` bei Zustandsänderungen.

**Spezifische Artefakte/Dateien:**

  * `novade-domain/src/desktop_environment_management/mod.rs`
  * `novade-domain/src/desktop_environment_management/data_types.rs`
  * `novade-domain/src/desktop_environment_management/errors.rs`
  * `novade-domain/src/desktop_environment_management/service.rs`

**Abhängigkeiten:**

  * **Intern:**
      * Alle anderen Domänen-Services (`ConfigServiceAsync`, `GlobalSettingsService`, `WallpaperManagerService`, `ThemeService`, `NotificationService`, `PowerManagementService`, `WindowPolicyService`, `InputPolicyService`, `ApplicationManagementService`).
      * Kritische System-Services, die direkt von der Domänenschicht initiiert oder gesteuert werden (`novade-system::compositor::SystemCompositorService`, `novade-system::power_management::SystemPowerService`).
      * `novade-core::error::CoreError`.
  * **Extern:**
      * `tokio` (für `async/await` und Task-Spawning).
      * `tokio::sync::broadcast`.
      * `async_trait`.
      * `parking_lot::{RwLock, Mutex}` (für internen Status).
      * `thiserror::Error`.

**Kommunikationsmuster:**

  * **An UI-Schicht:** Sendet `DesktopEvent`s (z.B. `DesktopStarted`, `ShutdownRequested`) über `broadcast::Sender`.
  * **An/Von anderen Domänen-Services:** Direkte Methodenaufrufe für Initialisierung, Start, Stopp, Suspend, Resume.
  * **An Systemschicht:** Indirekte Kommunikation über die entsprechenden Domänen-Services, die wiederum die Systemschicht aufrufen (z.B. `PowerManagementService` ruft `SystemPowerService` auf).

**Erwartete Ergebnisse/Outputs:**
Ein zentraler Dienst, der den Lebenszyklus der gesamten NovaDE-Umgebung koordiniert und steuert, die korrekte Initialisierung und Beendigung aller Komponenten gewährleistet und globale Desktop-Zustandsänderungen bekannt gibt.

**Teststrategie (Modul-spezifisch):**

  * **Unit Tests:**
      * Testen der `DesktopState` und `DesktopEvent` Enums.
      * Mocken aller abhängigen Domänen- und System-Services, um den `initialize`, `start`, `shutdown`, `suspend`, `resume` Methoden zu testen.
      * Verifizieren, dass Services in der korrekten Reihenfolge initialisiert/beendet werden.
      * Testen, dass die `DesktopEvent`s korrekt bei Zustandsübergängen gesendet werden.
      * Testen der Fehlerbehandlung bei Service-Initialisierungs- oder Startfehlern.
      * Sicherstellen, dass der interne `DesktopState` korrekt aktualisiert wird.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage)

-----

### **novade-domain/src/input\_policy**

**Verantwortlichkeit:**
Dieses Modul definiert die Domänenlogik und Richtlinien für die Verarbeitung von Benutzereingaben. Es abstrahiert die rohen Eingabedaten von der Systemschicht und wendet Regeln an, um Aktionen wie Tastatur-Shortcuts, Gesten oder Maus-Interaktionen in konkrete Desktop-Operationen zu übersetzen.

**Kern-Aufgaben (Tasks):**

1.  **Definition von Datenstrukturen und Enums:**

      * Definiere `InputEvent` Enum (z.B. `KeyboardEvent { key_code: u32, state: KeyState, modifiers: Modifiers }`, `PointerEvent { x: f64, y: f64, button: Option<MouseButton>, state: ButtonState }`, `TouchEvent { id: u32, x: f64, y: f64, state: TouchState }`, `GestureEvent { kind: GestureKind, data: GestureData }`).
      * Definiere `KeyState` (Pressed/Released), `ButtonState` (Pressed/Released), `TouchState` (Down/Motion/Up/Cancel), `Modifiers` Bitmaske.
      * Definiere `Shortcut` Struktur: Kombination aus `Modifier`n und `KeyCode` oder Maus-Button. Implementiere `PartialEq`, `Eq`, `Hash`, `Clone`, `Debug`, `Serialize`, `Deserialize`.
      * Definiere `InputPolicyAction` Enum (z.B. `SpawnApplication(String)`, `SwitchWorkspace(u32)`, `ToggleOverview`, `ExecuteCommand(String)`, `AdjustVolume(i32)`).
      * Definiere `InputPolicy` Struktur: Eine Zuordnung von `Shortcut` zu `InputPolicyAction`. Implementiere `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
      * Definiere `InputPolicySet` Struktur: Eine Sammlung von `InputPolicy`s.
      * Definiere `InputPolicyError` Enum.

2.  **`InputPolicyService` Trait:**

      * Definiere den `InputPolicyService` Trait.
      * Methoden:
          * `async fn process_input_event(&self, event: InputEvent) -> Result<(), InputPolicyError>`: Verarbeitet ein eingehendes Eingabeereignis von der Systemschicht.
          * `fn register_shortcut(&self, shortcut: Shortcut, action: InputPolicyAction) -> Result<(), InputPolicyError>`: Registriert einen neuen Shortcut.
          * `fn unregister_shortcut(&self, shortcut: Shortcut) -> Result<(), InputPolicyError>`: Entfernt einen Shortcut.
          * `fn get_active_policies(&self) -> Result<InputPolicySet, InputPolicyError>`: Ruft die aktuell aktiven Eingaberichtlinien ab.
          * `async fn update_policies(&self, policies: InputPolicySet) -> Result<(), InputPolicyError>`: Aktualisiert die Menge der aktiven Eingaberichtlinien (z.B. aus Konfiguration).
          * `fn subscribe_to_actions(&self) -> broadcast::Receiver<InputPolicyAction>`: Ermöglicht das Abonnieren von Aktionen, die durch Eingaben ausgelöst wurden.

3.  **Implementierung `DefaultInputPolicyService`:**

      * Implementiere `DefaultInputPolicyService` basierend auf dem `InputPolicyService` Trait.
      * Hält eine interne Map (`HashMap<Shortcut, InputPolicyAction>`) der registrierten Shortcuts.
      * Die `process_input_event` Methode:
          * Empfängt `InputEvent` von der Systemschicht (direkt oder über einen Channel).
          * Evaluiert den Event gegen die registrierten `Shortcut`s.
          * Führt die entsprechende `InputPolicyAction` aus oder sendet sie über `broadcast::Sender`.
          * Behandelt Reihenfolge und Prioritäten von Shortcuts (z.B. längste Übereinstimmung zuerst).
          * Integrationspunkt mit `GlobalSettingsService` für persistente Shortcut-Konfiguration.
          * Ruft andere Domänen-Services auf, um Aktionen auszuführen (z.B. `ApplicationManagementService` für `SpawnApplication`, `WorkspaceService` für `SwitchWorkspace`).
      * Nutzt `RwLock` für die interne `HashMap`.

**Spezifische Artefakte/Dateien:**

  * `novade-domain/src/input_policy/mod.rs`
  * `novade-domain/src/input_policy/data_types.rs`
  * `novade-domain/src/input_policy/errors.rs`
  * `novade-domain/src/input_policy/service.rs`

**Abhängigkeiten:**

  * **Intern:**
      * `crate::global_settings::GlobalSettingsService` (für Shortcut-Konfiguration).
      * `crate::application_management::ApplicationManagementService` (für `SpawnApplication`).
      * `crate::workspace::WorkspaceService` (für `SwitchWorkspace`, `ToggleOverview`).
      * `crate::power_management::PowerManagementService` (für Systemaktionen wie Lautstärke).
      * `novade-core::error::CoreError`.
  * **Extern:**
      * `tokio::sync::broadcast`.
      * `parking_lot::RwLock`.
      * `std::collections::HashMap`.
      * `serde::{Serialize, Deserialize}`.
      * `thiserror::Error`.
      * `async_trait`.

**Kommunikationsmuster:**

  * **Von Systemschicht:** Empfängt rohe Eingabeereignisse (z.B. von `novade-system::input::InputService`).
  * **An UI-Schicht:** Sendet `InputPolicyAction`s (z.B. für visuelles Feedback oder zur Ausführung von UI-spezifischen Aktionen).
  * **An andere Domänen-Services:** Ruft Methoden auf den entsprechenden Services auf, um die durch Shortcuts ausgelösten Aktionen durchzuführen.

**Erwartete Ergebnisse/Outputs:**
Ein zentraler Dienst zur Verarbeitung von Benutzereingaben, der rohe Systemereignisse in bedeutungsvolle Desktop-Aktionen übersetzt, basierend auf konfigurierbaren Richtlinien und Shortcuts.

**Teststrategie (Modul-spezifisch):**

  * **Unit Tests:**
      * Testen der `InputEvent` und `InputPolicyAction` Enums.
      * Testen der `Shortcut` Hash-Implementierung und Gleichheit.
      * Testen der `register_shortcut` und `unregister_shortcut` Funktionalität.
      * Mocken von abhängigen Services.
      * Testen der `process_input_event` Methode mit verschiedenen `InputEvent`s und `Shortcut`-Konfigurationen.
      * Verifizieren, dass korrekte `InputPolicyAction`s gesendet oder andere Services aufgerufen werden.
      * Testen von Edge-Cases wie überlappende Shortcuts oder ungültige Eingaben.
      * Testen der Abonnements von Aktionen.

**Geschätzter Aufwand:** Mittel bis Hoch (ca. 4-6 Tage)

-----

### **novade-domain/src/application\_management**

**Verantwortlichkeit:**
Dieses Modul verwaltet Informationen über installierte Anwendungen, deren Start und Beendigung und stellt eine Abstraktion für die Interaktion mit dem Anwendungs-Ökosystem des Systems bereit. Es dient als zentrale Stelle für die Suche, den Start und die Verwaltung von Anwendungszuständen.

**Kern-Aufgaben (Tasks):**

1.  **Definition von Datenstrukturen und Enums:**

      * Definiere `ApplicationInfo` Struktur: Enthält Metadaten einer Anwendung (z.B. `id: String`, `name: String`, `exec_path: PathBuf`, `icon_path: Option<PathBuf>`, `categories: Vec<String>`, `is_hidden: bool`, `desktop_file_path: PathBuf`). Implementiere `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`, `Hash`, `Eq`.
      * Definiere `ApplicationLaunchContext` Struktur: Kontext für den Start einer Anwendung (z.B. `arguments: Vec<String>`, `working_directory: Option<PathBuf>`, `display_id: Option<String>`).
      * Definiere `ApplicationState` Enum: `Running`, `Stopped`, `Crashed`.
      * Definiere `ApplicationManagementError` Enum (z.B. `ApplicationNotFound`, `LaunchFailed`, `PermissionDenied`, `InvalidDesktopFile`).

2.  **`ApplicationManagementService` Trait:**

      * Definiere den `ApplicationManagementService` Trait.
      * Methoden:
          * `async fn discover_applications(&self) -> Result<(), ApplicationManagementError>`: Scannt das System nach installierten Anwendungen (z.B. `.desktop`-Dateien im XDG-Standard). Aktualisiert den internen Katalog.
          * `fn get_all_applications(&self) -> Result<Vec<ApplicationInfo>, ApplicationManagementError>`: Gibt eine Liste aller entdeckten Anwendungen zurück.
          * `fn get_application_by_id(&self, id: &str) -> Result<ApplicationInfo, ApplicationManagementError>`: Ruft `ApplicationInfo` für eine bestimmte ID ab.
          * `async fn launch_application(&self, app_id: &str, context: ApplicationLaunchContext) -> Result<(), ApplicationManagementError>`: Startet eine Anwendung.
          * `async fn terminate_application(&self, app_id: &str) -> Result<(), ApplicationManagementError>`: Beendet eine laufende Anwendung (signalbasiert).
          * `fn subscribe_to_application_state_changes(&self) -> broadcast::Receiver<(String, ApplicationState)>`: Ermöglicht das Abonnieren von Änderungen des Anwendungszustands.
          * `fn subscribe_to_application_discovery_events(&self) -> broadcast::Receiver<ApplicationInfo>`: Ermöglicht das Abonnieren von neuen oder aktualisierten Anwendungen.

3.  **Implementierung `DefaultApplicationManagementService`:**

      * Implementiere `DefaultApplicationManagementService` basierend auf dem `ApplicationManagementService` Trait.
      * Hält einen internen Katalog (`HashMap<String, ApplicationInfo>`) der Anwendungen.
      * Verwendet `novade-system::application_launcher::SystemApplicationLauncher` für den tatsächlichen Start und die Beendigung von Prozessen.
      * Implementiert die Logik zum Parsen von `.desktop`-Dateien gemäß XDG Desktop Entry Specification.
      * Muss periodisch oder bei Dateisystem-Änderungen `discover_applications` aufrufen (oder einen Watcher nutzen).
      * Sendet `ApplicationState` und `ApplicationInfo` über `broadcast::Sender`.

**Spezifische Artefakte/Dateien:**

  * `novade-domain/src/application_management/mod.rs`
  * `novade-domain/src/application_management/data_types.rs`
  * `novade-domain/src/application_management/errors.rs`
  * `novade-domain/src/application_management/service.rs`
  * `novade-domain/src/application_management/desktop_file_parser.rs` (Helfermodul für `.desktop`-Dateien)

**Abhängigkeiten:**

  * **Intern:**
      * `novade-system::application_launcher::SystemApplicationLauncher`.
      * `novade-core::error::CoreError`.
      * `novade-core::paths::XdgPathsService` (für XDG-konforme Verzeichnisse).
  * **Extern:**
      * `tokio::sync::broadcast`.
      * `parking_lot::RwLock`.
      * `std::collections::HashMap`.
      * `serde::{Serialize, Deserialize}`.
      * `thiserror::Error`.
      * `async_trait`.
      * `walkdir` (für `discover_applications`).
      * `ini` oder ähnliche Crates zum Parsen von `.desktop`-Dateien.

**Kommunikationsmuster:**

  * **Von UI-Schicht:** Ruft `get_all_applications`, `launch_application` etc. auf. Abonniert Statusänderungen.
  * **An UI-Schicht:** Sendet `ApplicationInfo` bei Entdeckung und `(app_id, ApplicationState)` bei Zustandsänderungen.
  * **An Systemschicht:** Ruft Methoden auf `SystemApplicationLauncher` auf.

**Erwartete Ergebnisse/Outputs:**
Ein Dienst, der eine umfassende und aktuelle Liste installierter Anwendungen bereitstellt, deren Metadaten verwaltet und den Start und die Überwachung von Anwendungsprozessen ermöglicht.

**Teststrategie (Modul-spezifisch):**

  * **Unit Tests:**
      * Testen der `ApplicationInfo` und `ApplicationLaunchContext` Strukturen.
      * Testen des `.desktop`-Datei-Parsers mit gültigen und ungültigen Dateien (Mock-Dateien im Test).
      * Testen von `discover_applications` (Mocken des Dateisystems oder Nutzung von temp-Dirs).
      * Testen von `get_all_applications` und `get_application_by_id`.
      * Mocken von `SystemApplicationLauncher`, um `launch_application` und `terminate_application` zu testen, ohne echte Prozesse zu starten.
      * Verifizieren, dass `ApplicationState` Änderungen korrekt propagiert werden.
      * Testen der Fehlerbehandlung für alle Methoden.

**Geschätzter Aufwand:** Hoch (ca. 6-8 Tage)

-----

### **novade-domain/src/mod.rs**

**Verantwortlichkeit:**
Dieses `mod.rs` dient als öffentlicher Eintrittspunkt für die `novade-domain` Crate. Es exportiert die wesentlichen Module und Dienste der Domänenschicht, um sie für höhere Schichten (insbesondere die UI-Schicht und die Systemschicht, wenn Domänen-Dienste als Callback-Handler agieren) zugänglich zu machen. Es definiert auch eine übergeordnete `DomainServices` Struktur, die alle implementierten Domänen-Dienste bündelt.

**Kern-Aufgaben (Tasks):**

1.  **Re-Export von Modulen:**

      * Exportiere alle öffentlichen Module der Domänenschicht, z.B. `config`, `global_settings`, `theme`, `wallpaper_manager`, `notification`, `window_policy`, `workspace`, `power_management`, `input_policy`, `application_management`.
      * Stelle sicher, dass die öffentlichen Traits und wichtigen Datenstrukturen aus diesen Modulen re-exportiert werden, um eine einfache Nutzung zu ermöglichen.

2.  **Definition `DomainServices` Struktur:**

      * Definiere eine `DomainServices` Struktur, die `Arc<dyn ServiceTrait>`-Handles zu allen zentralen Domänen-Services enthält.
      * Diese Struktur sollte die primäre Möglichkeit sein, wie andere Schichten (z.B. die `novade-system` Init-Logik oder die `novade-ui` Main-Loop) auf die Domänen-Dienste zugreifen.
      * Implementiere eine `new()`-Methode für `DomainServices`, die alle Domänen-Services instanziiert und deren Abhängigkeiten korrekt injiziert. Dies ist ein kritischer Initialisierungspunkt.
      * Stelle sicher, dass alle Services die notwendigen gemeinsamen Ressourcen (z.B. `ConfigService`, `GlobalSettingsService`) erhalten.

**Spezifische Artefakte/Dateien:**

  * `novade-domain/src/mod.rs` (Hauptdatei)
  * `novade-domain/src/domain_services.rs` (Optionale separate Datei für `DomainServices` Struktur, falls `mod.rs` zu groß wird)

**Abhängigkeiten:**

  * **Intern:** Alle anderen Module innerhalb von `novade-domain`.
  * **Extern:** `std::sync::Arc` (für Service-Handles).

**Kommunikationsmuster:**

  * `mod.rs` ist der Aggregator; es leitet keine eigene Kommunikation ein, sondern stellt die Schnittstellen bereit.
  * Die `DomainServices` Struktur wird in der `main.rs` oder der `novade-system` Initialisierungslogik instanziiert und an die entsprechenden Komponenten (z.B. UI-Hauptfenster, System-Compositor) übergeben.

**Erwartete Ergebnisse/Outputs:**
Ein sauber definierter und aggregierter öffentlicher API-Eintrittspunkt für die gesamte Domänenschicht, der die Instanziierung und den Zugriff auf alle Domänen-Services vereinfacht.

**Teststrategie (Modul-spezifisch):**

  * **Unit Tests:**
      * Testen, dass alle erwarteten Module und Typen re-exportiert werden.
      * Testen der `DomainServices::new()`-Methode, um sicherzustellen, dass alle Services korrekt instanziiert und ihre Abhängigkeiten richtig injiziert werden (Mocken der unterliegenden Services, falls nötig).
      * Verifizieren, dass keine zirkulären Abhängigkeiten zwischen den Services bei der Instanziierung entstehen.

**Geschätzter Aufwand:** Gering (ca. 0.5-1 Tag)

-----

### **Zusammenfassung Domänenschicht**

Die Domänenschicht ist nun vollständig dekomponiert und spezifiziert. Sie bildet das Herzstück der NovaDE-Logik, unabhängig von Systemdetails und UI-Implementierungen. Die einzelnen Module sind wie folgt organisiert und aufeinander abgestimmt:

  * **`novade-domain/src/config`**: Basis für alle persistenten Konfigurationen.
  * **`novade-domain/src/global_settings`**: Aggregiert alle systemweiten Einstellungen.
  * **`novade-domain/src/theme`**: Verwaltet das Erscheinungsbild, Farben und Token.
  * **`novade-domain/src/wallpaper_manager`**: Steuert Hintergrundbilder und deren Anzeige.
  * **`novade-domain/src/notification`**: Verwaltet und verarbeitet Systembenachrichtigungen.
  * **`novade-domain/src/window_policy`**: Definiert Fensterverhalten und -interaktionen.
  * **`novade-domain/src/workspace`**: Verwaltet virtuelle Desktops und deren Zustände.
  * **`novade-domain/src/power_management`**: Steuert Energiemanagement-Optionen.
  * **`novade-domain/src/input_policy`**: Übersetzt rohe Eingaben in Desktop-Aktionen.
  * **`novade-domain/src/application_management`**: Verwaltet installierte Anwendungen.
  * **`novade-domain/src/desktop_environment_management`**: Orchestriert den Lebenszyklus des gesamten Desktops.
  * **`novade-domain/src/mod.rs`**: Öffentliche API und Service-Aggregation.

Diese Struktur gewährleistet eine hohe Kohäsion innerhalb der Module und eine lose Kopplung zwischen ihnen, was die Wartbarkeit und Erweiterbarkeit von NovaDE signifikant verbessert. Die nächste Phase wird die detaillierte Spezifikation der Systemschicht umfassen, die die Domänenrichtlinien technisch umsetzt und mit dem Betriebssystem interagiert.

-----

## **III. Systemschicht (`novade-system`)**

**Übersicht:**
Die Systemschicht ist für die Interaktion mit dem Betriebssystem, der Hardware und externen Systemdiensten zuständig. Sie implementiert die Policies und Anfragen der Domänenschicht, ohne selbst Geschäftslogik zu enthalten. Dies ist die Schicht, die Wayland-Compositor, Eingabeverarbeitung, D-Bus-Kommunikation und andere systemspezifische APIs kapselt.

### 1\. Verzeichnisstruktur (Systemschicht)

```
novade-system/
├── src/
│   ├── mod.rs
│   ├── compositor/
│   │   ├── mod.rs
│   │   ├── core.rs
│   │   ├── handlers.rs
│   │   ├── data_types.rs
│   │   ├── errors.rs
│   │   ├── xdg_shell.rs
│   │   ├── layer_shell.rs
│   │   ├── output_management.rs
│   │   └── dma_buf.rs
│   ├── input/
│   │   ├── mod.rs
│   │   ├── service.rs
│   │   ├── data_types.rs
│   │   ├── errors.rs
│   │   ├── libinput_handler.rs
│   │   └── xkb_handler.rs
│   ├── dbus_interfaces/
│   │   ├── mod.rs
│   │   ├── notifications_server.rs
│   │   ├── system_clients.rs
│   │   ├── data_types.rs
│   │   └── errors.rs
│   ├── audio_management/
│   │   ├── mod.rs
│   │   ├── service.rs
│   │   ├── data_types.rs
│   │   └── errors.rs
│   ├── mcp_client/
│   │   ├── mod.rs
│   │   ├── client.rs
│   │   ├── data_types.rs
│   │   └── errors.rs
│   ├── window_mechanics/
│   │   ├── mod.rs
│   │   ├── service.rs
│   │   ├── data_types.rs
│   │   └── errors.rs
│   ├── power_management/
│   │   ├── mod.rs
│   │   ├── service.rs
│   │   ├── data_types.rs
│   │   └── errors.rs
│   ├── application_launcher/
│   │   ├── mod.rs
│   │   ├── service.rs
│   │   ├── data_types.rs
│   │   └── errors.rs
│   └── portals/
│       ├── mod.rs
│       ├── service.rs
│       ├── data_types.rs
│       └── errors.rs
└── Cargo.toml
```

### **novade-system/src/compositor**

**Verantwortlichkeit:**
Das `compositor`-Modul ist das Herzstück der visuellen Darstellung und des Wayland-Protokollhandlings. Es ist für die Verwaltung von Fenstern, Ausgängen, die Renderer-Abstraktion und die Implementierung der Wayland-Protokolle (XDG-Shell, Layer-Shell) verantwortlich. Es nutzt das Smithay Toolkit als Grundlage.

**Kern-Aufgaben (Tasks):**

1.  **Einrichtung des Smithay Compositor Frameworks:**

      * Initialisiere das Smithay `Display` und `EventLoop`.
      * Konfiguriere das Backend (z.B. `libseat` für DRM/KMS oder `winit` für Debugging/X11).
      * Erstelle die notwendigen `Global`s für Wayland-Protokolle.

2.  **`SystemCompositorService` Trait:**

      * Definiere den `SystemCompositorService` Trait.
      * Methoden:
          * `async fn run(&self) -> Result<(), CompositorError>`: Startet die Compositor-Event-Loop.
          * `fn create_output(&self, name: String, resolution: Size<i32, Logical>) -> Result<(), CompositorError>`: Erstellt einen virtuellen/physischen Output.
          * `fn destroy_output(&self, name: &str) -> Result<(), CompositorError>`: Zerstört einen Output.
          * `fn activate_output(&self, name: &str) -> Result<(), CompositorError>`: Aktiviert einen Output.
          * `fn move_surface(&self, surface_id: SurfaceId, x: i32, y: i32) -> Result<(), CompositorError>`: Verschiebt eine Oberfläche.
          * `fn resize_surface(&self, surface_id: SurfaceId, width: i32, height: i32) -> Result<(), CompositorError>`: Skaliert eine Oberfläche.
          * `fn bring_surface_to_front(&self, surface_id: SurfaceId) -> Result<(), CompositorError>`: Bringt eine Oberfläche in den Vordergrund.
          * `fn hide_surface(&self, surface_id: SurfaceId) -> Result<(), CompositorError>`: Verbirgt eine Oberfläche.
          * `fn show_surface(&self, surface_id: SurfaceId) -> Result<(), CompositorError>`: Zeigt eine Oberfläche an.
          * `fn set_input_focus(&self, surface_id: Option<SurfaceId>) -> Result<(), CompositorError>`: Setzt den Eingabefokus.
          * `fn send_keyboard_input(&self, surface_id: SurfaceId, key: KeyCode, state: KeyState) -> Result<(), CompositorError>`: Sendet synthetische Tastatureingaben.
          * `fn send_pointer_input(&self, surface_id: SurfaceId, x: f64, y: f64, button: Option<MouseButton>, state: ButtonState) -> Result<(), CompositorError>`: Sendet synthetische Zeigereingaben.
          * `fn send_touch_input(&self, surface_id: SurfaceId, id: i32, x: f64, y: f64, state: TouchState) -> Result<(), CompositorError>`: Sendet synthetische Toucheingaben.
          * `fn subscribe_to_surface_events(&self) -> broadcast::Receiver<CompositorSurfaceEvent>`: Ermöglicht das Abonnieren von Oberflächen-bezogenen Events.
          * `fn subscribe_to_output_events(&self) -> broadcast::Receiver<CompositorOutputEvent>`: Ermöglicht das Abonnieren von Output-bezogenen Events.

3.  **Implementierung `DefaultSystemCompositorService`:**

      * Implementiere `DefaultSystemCompositorService` basierend auf dem `SystemCompositorService` Trait.
      * Hält den Smithay `State` (das zentrale State-Objekt für den Compositor).
      * Nutzt `RwLock` oder `Mutex` für den Zugriff auf den Compositor-Zustand, da es von verschiedenen Threads oder Async-Tasks aus zugänglich sein muss.
      * Verantwortlich für das Rendern der Szenen (Verwendung des internen Renderer-Moduls oder direkte Nutzung von Smithay-Rendering).
      * Interagiert mit `novade-domain::window_policy::WindowPolicyService` und `novade-domain::workspace::WorkspaceService` um Fenster- und Workspace-Zustände widerzuspiegeln.
      * Sendet Events wie `CompositorSurfaceEvent::NewSurface` oder `CompositorOutputEvent::OutputAdded` über `broadcast::Sender`.

**Spezifische Artefakte/Dateien:**

  * `novade-system/src/compositor/mod.rs`
  * `novade-system/src/compositor/core.rs` (Initialisierung des Compositors, Haupt-Event-Loop, State-Management)
  * `novade-system/src/compositor/handlers.rs` (Smithay Handler-Implementierungen für Events wie `NewToplevelSurface`, `NewLayerSurface`, `InputEvent`)
  * `novade-system/src/compositor/data_types.rs` (Compositor-spezifische Datenstrukturen wie `SurfaceId`, `CompositorSurfaceEvent`, `CompositorOutputEvent`)
  * `novade-system/src/compositor/errors.rs` (`CompositorError` Enum)
  * `novade-system/src/compositor/xdg_shell.rs` (XDG-Shell spezifische Logik und Handler)
  * `novade-system/src/compositor/layer_shell.rs` (Layer-Shell spezifische Logik und Handler)
  * `novade-system/src/compositor/output_management.rs` (Verwaltung von Bildschirmausgängen, DRM/KMS-Integration)
  * `novade-system/src/compositor/dma_buf.rs` (DMA-BUF Handling für Zero-Copy Rendering, falls relevant)

**Abhängigkeiten:**

  * **Intern:**
      * `novade-core::error::CoreError`.
      * `novade-core::types::geometry::{Size, Logical}`.
      * `novade-domain::window_policy::WindowPolicyService` (für window management policies).
      * `novade-domain::workspace::WorkspaceService` (für workspace management).
      * `novade-domain::input_policy::InputPolicyService` (für Forwarding von rohen Input Events).
  * **Extern:**
      * `smithay` (Hauptabhängigkeit: `smithay`, `smithay-client-toolkit`).
      * `wayland-server`, `wayland-protocols`.
      * `tracing` (für Logging).
      * `tokio` (für `async/await` und Task-Spawning, insbesondere für die Event-Loop).
      * `tokio::sync::broadcast`.
      * `parking_lot::{RwLock, Mutex}`.
      * `thiserror::Error`.
      * `async_trait`.
      * `libseat` (für DRM/KMS Backend-Integration).
      * `winit` (optional, für Debugging/X11 Backend).
      * `drm` / `gbm` (für DRM/KMS und Buffer-Management).
      * `egl` / `opengl_es` (für Rendering).
      * `vulkano` (optional, falls Vulkan Renderer implementiert wird).

**Kommunikationsmuster:**

  * **Von Domänenschicht:** Erhält Anweisungen für Fenster-Operationen (`move_surface`, `resize_surface`, `set_input_focus`) und Output-Management.
  * **An Domänenschicht (`WindowPolicyService`, `WorkspaceService`):** Sendet Events über Oberflächen-Lebenszyklus, Größenänderungen, Fokusänderungen, Output-Statusänderungen.
  * **An Domänenschicht (`InputPolicyService`):** Leitet rohe Eingabeereignisse (`KeyboardEvent`, `PointerEvent`) weiter.
  * **Direkt an Wayland-Clients:** Sendet Protokoll-Nachrichten und Events.

**Erwartete Ergebnisse/Outputs:**
Ein voll funktionsfähiger Wayland-Compositor, der grundlegende Fensterverwaltung, Output-Handling und die Implementierung der benötigten Wayland-Protokolle bereitstellt. Er sollte in der Lage sein, Wayland-Clients zu hosten und ihre Ausgaben auf den Bildschirmen darzustellen.

**Teststrategie (Modul-spezifisch):**

  * **Integration Tests (Compositor-spezifisch):**
      * Nutzen von Smithay's Test-Utilities oder `wayland-client` um einen Test-Client zu starten und zu interagieren.
      * Testen des Fenster-Lebenszyklus: Client startet, Fenster erstellt, maximiert, minimiert, geschlossen.
      * Testen der Eingabeverarbeitung: Tastendrücke, Mausbewegungen, Klicks, Toucheingaben.
      * Testen von Output-Management: Hinzufügen/Entfernen virtueller Outputs, Auflösungsänderungen.
      * Testen der XDG-Shell und Layer-Shell Protokoll-Implementierungen.
      * Testen der Fokusverwaltung.
      * Überprüfen, dass die richtigen Events an die Domänenschicht gesendet werden.
  * **Unit Tests:**
      * Testen der `data_types` Enums und Strukturen.
      * Testen der `errors.rs` Definitionen.
      * Testen von Helferfunktionen (z.B. für Geometrieberechnungen im Rendering).

**Geschätzter Aufwand:** Sehr Hoch (ca. 10-15 Tage, da dies ein Kernstück ist und Smithay-Einarbeitung erfordert)

-----

### **novade-system/src/compositor/core.rs**

**Verantwortlichkeit:**
Dieses Modul enthält die Hauptlogik für die Initialisierung des Smithay Compositors, die Verwaltung des zentralen Smithay `State` und die Ausführung der Haupt-Event-Loop. Es ist der primäre Startpunkt für den Compositor.

**Kern-Aufgaben (Tasks):**

1.  **Struktur `NovaCompositorState`:**

      * Definiere `NovaCompositorState`, die den gesamten Zustand des Compositors kapselt und den `smithay::MainState` Trait implementiert.
      * Enthält Felder für:
          * `display_handle: wayland_server::DisplayHandle`
          * `event_loop: smithay::wayland::EventLoop<Self>`
          * `backend_data: BackendData` (ein Enum für `WinitData` oder `DrmData`)
          * `space: smithay::desktop::Space` (Verwaltung von Oberflächen in 2D-Räumen)
          * `output_manager: smithay::output::OutputManager`
          * `seat: smithay::input::Seat`
          * `primary_gpu: Option<DeviceFd>` (für DRM/KMS)
          * `renderer: smithay::backend::renderer::Renderer` (oder eine Abstraktion davon)
          * `allocator: smithay::backend::allocator::Allocator` (oder eine Abstraktion davon)
          * `shell_globals: smithay::wayland::shell::ShellGlobals` (XDG, Layer Shell, etc.)
          * `domain_services: Arc<DomainServices>` (Referenzen zu den Domänen-Services, die der Compositor benötigt, z.B. `WindowPolicyService`, `InputPolicyService`, `WorkspaceService`).
          * `event_senders: CompositorEventSenders` (struct mit `broadcast::Sender` für interne Compositor-Events an `DefaultSystemCompositorService`).
          * `xdg_shell_state: smithay::xdg::XdgShellState`
          * `layer_shell_state: smithay::wayland::shell::wlr_layer_shell::WlrLayerShellState`
          * `input_handler_state: InputHandlerState` (für die Integration mit `novade-system::input`)
          * ... und weitere States für andere Protokolle/Komponenten.
      * Implementiere die Smithay-relevanten Traits wie `wayland_server::Dispatch` für alle relevanten Protokolle.

2.  **Funktion `start_compositor_loop`:**

      * `pub async fn start_compositor_loop(domain_services: Arc<DomainServices>) -> Result<(), CompositorError>`
      * Initialisiert das `DisplayHandle`.
      * Wählt das passende Backend (DRM/KMS oder Winit).
      * Initialisiert `NovaCompositorState` mit allen notwendigen Komponenten.
      * Erstellt und bindet alle Wayland Globals (XDG-Shell, Layer-Shell, Input, Output, Shm, Data Device, etc.).
      * Spawnt `tokio` Tasks für die Event-Loop des Backends und für die Wayland-Event-Loop (`display_handle.run_forever_async()`).
      * Startet die Compositor-Rendering-Loop.

3.  **Rendering-Loop:**

      * Eine asynchrone Schleife, die für jeden Output das Rendern der aktuellen Szene triggert.
      * Verwendet `smithay::backend::renderer::Renderer` um die im `Space` verwalteten Oberflächen zu zeichnen.
      * Behandelt `Damage` Regionen für effizientes Redrawing.
      * Übergibt den gerenderten Frame an das Backend (z.B. KMS oder Winit).

**Spezifische Artefakte/Dateien:**

  * `novade-system/src/compositor/core.rs`

**Abhängigkeiten:**

  * **Intern:**
      * `crate::compositor::data_types::{CompositorEventSenders, CompositorSurfaceEvent, CompositorOutputEvent}`
      * `crate::compositor::errors::CompositorError`
      * `crate::compositor::handlers::{InputHandlerState, XdgShellHandler, LayerShellHandler, ...}` (für die tatsächlichen Callback-Logik)
      * `crate::compositor::output_management`
      * `novade-domain::domain_services::DomainServices` (für den Zugriff auf Domänen-Services)
  * **Extern:**
      * `smithay::{self, backend::{renderer::Renderer, allocater::Allocator}, input::Seat, desktop::Space, output::OutputManager, wayland::{shell::ShellGlobals, xdg::XdgShellState, wlr_layer_shell::WlrLayerShellState}}`
      * `wayland-server::{DisplayHandle, Global, Dispatch}`
      * `tokio::{self, task, sync::broadcast}`
      * `parking_lot::{RwLock, Mutex}`
      * `tracing`
      * `libseat` (für DRM/KMS Backend)
      * `winit` (für Winit Backend)
      * `drm` (für DRM/KMS)
      * `gbm` (für DRM/KMS)
      * `egl` / `opengl_es`

**Kommunikationsmuster:**

  * **Intern:** Interagiert direkt mit anderen Modulen innerhalb von `novade-system::compositor` (z.B. `handlers`, `output_management`) durch Methodenaufrufe oder den gemeinsamen `NovaCompositorState`.
  * **An Domänenschicht:** Leitet transformierte Wayland-Events an die Domänenschicht weiter (z.B. neue Fenster an `WindowPolicyService`, Input-Events an `InputPolicyService`).
  * **An Wayland-Clients:** Kommuniziert über die `DisplayHandle` und Smithay-Protokoll-Implementierungen.

**Erwartete Ergebnisse/Outputs:**
Ein initialisierter und laufender Wayland-Compositor, der als Backend für die NovaDE-Umgebung dient, in der Lage ist, Wayland-Clients zu hosten und grafische Ausgaben zu verwalten.

**Teststrategie (Modul-spezifisch):**

  * **Integration Tests:**
      * Starten des Compositors mit einem Mock-Backend (Winit ist dafür gut geeignet).
      * Verbinden eines `wayland-client` Testprogramms.
      * Überprüfen, ob die Globals korrekt beworben werden.
      * Testen der grundlegenden `DisplayHandle` Interaktionen.
      * Verifizieren der korrekten Initialisierung des `NovaCompositorState`.
      * Sicherstellen, dass die Rendering-Loop startet und keine Fehler wirft.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage)

-----

### **novade-system/src/compositor/handlers.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert die verschiedenen Smithay-Handler-Traits für Wayland-Protokolle und Backend-Events. Es enthält die Callback-Logik, die von Smithay aufgerufen wird, wenn relevante Ereignisse eintreten (z.B. ein neuer XDG-Toplevel, ein Eingabeereignis vom Backend).

**Kern-Aufgaben (Tasks):**

1.  **Implementierung des `smithay::MainState` Trait für `NovaCompositorState`:**

      * Diese Implementierung ist der zentrale Punkt für viele Smithay-Callbacks.
      * Handhabt generische Smithay-Events.

2.  **Implementierung von `wayland_server::Dispatch` für alle Wayland-Protokolle:**

      * Für `wl_shm`, `wl_seat`, `wl_output`, `wl_data_device_manager`, `xdg_shell`, `wlr_layer_shell`, `wlr_screencopy_v1` (falls implementiert) etc.
      * Jede `dispatch` Funktion delegiert die Logik an spezifische Handler-Funktionen oder an die `NovaCompositorState`.

3.  **Spezifische Protokoll-Handler:**

      * **XDG-Shell Handler:**
          * `xdg_shell::handle_new_toplevel(surface: smithay::desktop::ToplevelSurface, state: &mut NovaCompositorState)`: Wird aufgerufen, wenn ein neuer XDG-Toplevel-Client verbunden wird. Initialisiert `WindowPolicyService` und `WorkspaceService` mit den Surface-Informationen.
          * `xdg_shell::handle_new_popup(...)`: Behandelt Popups.
          * Callback für `configure`, `ack_configure` für XDG-Shell Oberflächen.
          * Callback für `commit` von XDG-Shell Oberflächen (für Buffer-Updates).
      * **Layer-Shell Handler:**
          * `layer_shell::handle_new_layer_surface(surface: smithay::desktop::LayerSurface, state: &mut NovaCompositorState)`: Wird aufgerufen, wenn ein neuer Layer-Shell-Client verbunden wird.
          * Callback für `configure`, `ack_configure` für Layer-Shell Oberflächen.
          * Callback für `commit` von Layer-Shell Oberflächen.
      * **Input Handler:**
          * `input::handle_keyboard_key(event: KeyEvent, state: &mut NovaCompositorState)`: Leitet Tastaturereignisse an `InputPolicyService` weiter.
          * `input::handle_pointer_motion(event: PointerMotionEvent, state: &mut NovaCompositorState)`: Leitet Mausbewegungen an `InputPolicyService` weiter.
          * `input::handle_pointer_button(event: PointerButtonEvent, state: &mut NovaCompositorState)`: Leitet Maus-Klicks an `InputPolicyService` weiter.
          * `input::handle_touch_event(...)`: Leitet Toucheingaben an `InputPolicyService` weiter.
          * Verwaltet den Fokus für den `Seat`.
      * **Backend Handler:**
          * Callbacks für `BackendEvent` (z.B. `NewOutput`, `Input`).
          * `backend_handler::handle_new_output(output: Output, state: &mut NovaCompositorState)`: Registriert neue Bildschirmausgaben beim `OutputManager` und sendet Event an Domänenschicht.
          * `backend_handler::handle_input_event(...)`: Verarbeitet Backend-Input-Events und leitet sie an den `InputPolicyService` weiter.

4.  **Struktur `InputHandlerState`:**

      * Verwaltet den Input-Zustand des Compositors, z.B. aktive Tasten, Zeigerposition.
      * Integrieren von `xkbcommon` für Tastatur-Layouts und Tasten-Mapping.

**Spezifische Artefakte/Dateien:**

  * `novade-system/src/compositor/handlers.rs`

**Abhängigkeiten:**

  * **Intern:**
      * `crate::compositor::core::NovaCompositorState`
      * `crate::compositor::data_types::{CompositorSurfaceEvent, CompositorOutputEvent}`
      * `crate::compositor::xdg_shell`
      * `crate::compositor::layer_shell`
      * `novade-domain::window_policy::WindowPolicyService`
      * `novade-domain::workspace::WorkspaceService`
      * `novade-domain::input_policy::InputPolicyService`
  * **Extern:**
      * `smithay::{self, xdg, wayland::{shell::wlr_layer_shell, seat::SeatHandler}, backend::input::{KeyboardKeyEvent, PointerMotionEvent, PointerButtonEvent}}`
      * `wayland-server::{DisplayHandle, Dispatch}`
      * `xkbcommon::xkb`
      * `tracing`

**Kommunikationsmuster:**

  * **Vom Smithay Event-Loop:** Empfängt Callbacks für Wayland-Protokollereignisse und Backend-Events.
  * **An `NovaCompositorState`:** Modifiziert den Zustand des Compositors basierend auf Ereignissen.
  * **An Domänenschicht:** Ruft Methoden auf `WindowPolicyService`, `WorkspaceService` und `InputPolicyService` auf, um domänenspezifische Logik auszulösen.

**Erwartete Ergebnisse/Outputs:**
Eine Sammlung von robusten Event-Handlern, die die Interaktionen von Wayland-Clients und Backend-Geräten korrekt verarbeiten und die notwendigen Informationen an die Domänenschicht weiterleiten oder interne Compositor-Zustandsänderungen vornehmen.

**Teststrategie (Modul-spezifisch):**

  * **Unit Tests:**
      * Testen der spezifischen Handler-Funktionen isoliert, indem `NovaCompositorState` gemockt oder ein `FakeCompositorState` verwendet wird.
      * Simulieren von `xdg_shell` und `layer_shell` Ereignissen und überprüfen der Reaktionen.
      * Simulieren von Eingabeereignissen (Tastatur, Maus, Touch) und überprüfen, ob sie korrekt an den `InputPolicyService` weitergeleitet werden.
      * Testen der `xkbcommon` Integration für Tastatur-Events.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, aufgrund der Komplexität der Protokoll-Handler und des Input-Managements)

-----

### **novade-system/src/compositor/data\_types.rs**

**Verantwortlichkeit:**
Dieses Modul definiert die spezifischen Datenstrukturen und Enums, die innerhalb des `compositor`-Moduls verwendet werden, um den Zustand, Ereignisse und IDs zu repräsentieren. Es stellt eine gemeinsame Grundlage für die Kommunikation und den Datenfluss innerhalb des Compositors und zu anderen Schichten dar.

**Kern-Aufgaben (Tasks):**

1.  **`SurfaceId` Struktur:**

      * Definiere eine eindeutige ID für jede Oberfläche (z.B. `uuid::Uuid` oder ein Wrapper um `smithay::wayland::surface::Surface`).
      * Implementiere `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Copy` (falls passend), `Serialize`, `Deserialize`.

2.  **`CompositorSurfaceEvent` Enum:**

      * Varianten:
          * `NewToplevelSurface { id: SurfaceId, client_pid: u32, app_id: Option<String> }`
          * `ToplevelSurfaceDestroyed { id: SurfaceId }`
          * `ToplevelSurfaceResized { id: SurfaceId, new_size: Size<i32, Logical> }`
          * `ToplevelSurfaceMoved { id: SurfaceId, new_position: Point<i32, Logical> }`
          * `ToplevelSurfaceFocusChanged { id: SurfaceId, focused: bool }`
          * `NewLayerSurface { id: SurfaceId, namespace: String, layer: Layer }` (von `wlr_layer_shell`)
          * `LayerSurfaceDestroyed { id: SurfaceId }`
          * `SurfaceCommit { id: SurfaceId }` (signalisiert, dass ein Buffer einer Oberfläche aktualisiert wurde)
          * `SurfaceMap { id: SurfaceId }` (Oberfläche wird zum ersten Mal sichtbar)
          * `SurfaceUnmap { id: SurfaceId }` (Oberfläche wird unsichtbar)
          * ... weitere Events nach Bedarf.
      * Implementiere `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.

3.  **`CompositorOutputEvent` Enum:**

      * Varianten:
          * `OutputAdded { name: String, resolution: Size<i32, Logical>, transform: Transform }`
          * `OutputRemoved { name: String }`
          * `OutputMoved { name: String, new_position: Point<i32, Logical> }`
          * `OutputResized { name: String, new_resolution: Size<i32, Logical> }`
          * ... weitere Events nach Bedarf.
      * Implementiere `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.

4.  **`CompositorEventSenders` Struktur:**

      * Eine Sammlung von `tokio::sync::broadcast::Sender`s für die verschiedenen Compositor-Events, die an höhere Schichten oder andere Dienste gesendet werden.
      * `surface_events: broadcast::Sender<CompositorSurfaceEvent>`
      * `output_events: broadcast::Sender<CompositorOutputEvent>`
      * `new()`-Funktion zum Initialisieren.

5.  **`BackendData` Enum:**

      * Definiert, welches Smithay-Backend verwendet wird.
      * `WinitData { ... }` (für `winit` Backend)
      * `DrmData { ... }` (für `drm` Backend)

**Spezifische Artefakte/Dateien:**

  * `novade-system/src/compositor/data_types.rs`

**Abhängigkeiten:**

  * **Intern:**
      * `novade-core::types::geometry::{Size, Point, Logical}`
      * `novade-core::types::input::{Keycode, KeyState, MouseButton, ButtonState, TouchState, Modifiers}`
      * `novade-core::types::theme::Layer` (falls `Layer` direkt hier verwendet wird)
  * **Extern:**
      * `smithay::{desktop::{ToplevelSurface, LayerSurface}, wayland::output::Transform}`
      * `tokio::sync::broadcast`
      * `uuid::Uuid`
      * `serde::{Serialize, Deserialize}`
      * `std::hash::Hash`

**Kommunikationsmuster:**

  * Wird von `core.rs` und `handlers.rs` verwendet, um Ereignisse zu definieren und zu senden.
  * Wird von der Domänenschicht (`WindowPolicyService`, `WorkspaceService`) verwendet, um Ereignisse zu empfangen und zu interpretieren.

**Erwartete Ergebnisse/Outputs:**
Ein klar definiertes Set von Datenstrukturen, das die Kommunikation und den Zustand des Compositors präzise abbildet und eine Typ-sichere Interaktion mit anderen Modulen und Schichten ermöglicht.

**Teststrategie (Modul-spezifisch):**

  * **Unit Tests:**
      * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize` Implementierungen für alle Strukturen und Enums.
      * Verifizieren der korrekten Initialisierung von `CompositorEventSenders`.
      * Testen der `SurfaceId` Generierung (falls `uuid::Uuid` verwendet wird, ist dies meist implizit korrekt).

**Geschätzter Aufwand:** Gering (ca. 1-2 Tage)

-----

### **novade-system/src/compositor/errors.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Fehler (`CompositorError`) die innerhalb des `compositor`-Moduls auftreten können. Dies gewährleistet eine konsistente und detaillierte Fehlerbehandlung innerhalb der Systemschicht und ermöglicht eine präzise Fehlerweiterleitung an höhere Schichten.

**Kern-Aufgaben (Tasks):**

1.  **`CompositorError` Enum Definition:**
      * Verwende `thiserror` für die Fehlerdefinition.
      * Varianten:
          * `BackendInitializationFailed(#[source] Box<dyn std::error::Error + Send + Sync>)`: Fehler beim Initialisieren des Smithay-Backends (DRM/KMS, Winit).
          * `WaylandServerError(#[source] wayland_server::DisplayError)`: Fehler im Wayland-Server.
          * `SurfaceNotFound(SurfaceId)`: Oberfläche mit gegebener ID nicht gefunden.
          * `OutputNotFound(String)`: Output mit gegebenem Namen nicht gefunden.
          * `InvalidSurfaceState(String)`: Oberfläche ist in einem ungültigen Zustand für die Operation.
          * `ProtocolError(String)`: Generischer Protokollfehler (z.B. XDG-Shell Konfigurationsfehler).
          * `InputError(#[source] InputError)`: Fehler aus dem Input-Modul.
          * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler.
          * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
      * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

  * `novade-system/src/compositor/errors.rs`

**Abhängigkeiten:**

  * **Intern:**
      * `crate::compositor::data_types::SurfaceId`
      * `crate::input::errors::InputError` (falls direkt referenziert)
      * `novade-core::error::CoreError` (für Konvertierung von `CompositorError` in `CoreError` auf höherer Ebene).
  * **Extern:**
      * `thiserror::Error`
      * `wayland_server::DisplayError`
      * `std::io::Error`

**Kommunikationsmuster:**

  * Wird von allen Funktionen innerhalb des `compositor`-Moduls als `Result` Fehler zurückgegeben.
  * Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im Compositor-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

  * **Unit Tests:**
      * Testen der Erstellung und Konvertierung von `CompositorError` Varianten.
      * Verifizieren der korrekten Fehlermeldungen.
      * Testen der `source()`-Kette für geschachtelte Fehler.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

-----

### **novade-system/src/compositor/xdg\_shell.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert die spezifische Logik für das Wayland XDG-Shell Protokoll. Es verarbeitet Anfragen von XDG-Shell-Clients (Desktop-Anwendungen) und sendet entsprechende Antworten, um deren Fensterlebenszyklus zu steuern.

**Kern-Aufgaben (Tasks):**

1.  **Implementierung `smithay::xdg::XdgShellHandler` für `NovaCompositorState`:**

      * `xdg_shell_state(&mut self) -> &mut smithay::xdg::XdgShellState`: Getter für den XDG-Shell-Zustand.
      * `new_xdg_toplevel(&mut self, surface: smithay::xdg::ToplevelSurface)`:
          * Wird aufgerufen, wenn ein neuer XDG-Toplevel-Client eine Oberfläche erstellt.
          * Erzeugt eine `SurfaceId` für die neue Oberfläche.
          * Sendet `CompositorSurfaceEvent::NewToplevelSurface` an die Domänenschicht (`WindowPolicyService`).
          * Fügt die Oberfläche dem `smithay::desktop::Space` hinzu.
          * Registriert die Oberfläche für `commit` Events.
      * `new_xdg_popup(&mut self, surface: smithay::xdg::PopupSurface)`:
          * Verarbeitet neue XDG-Popups.
          * Fügt sie dem `Space` hinzu und registriert sie für `commit` Events.
      * `xdg_toplevel_destroyed(&mut self, surface_id: SurfaceId)`:
          * Wird aufgerufen, wenn ein XDG-Toplevel zerstört wird.
          * Entfernt die Oberfläche aus dem `Space`.
          * Sendet `CompositorSurfaceEvent::ToplevelSurfaceDestroyed`.
      * `xdg_popup_destroyed(...)`:
          * Entfernt das Popup aus dem `Space`.

2.  **Implementierung `smithay::desktop::WindowHandler` für `NovaCompositorState` (für XDG-Toplevels):**

      * `committed(&mut self, surface_id: SurfaceId, current_state: &smithay::wayland::surface::SurfaceData)`:
          * Wird aufgerufen, wenn ein Client Änderungen an seiner Oberfläche committed.
          * Überprüft auf Größenänderungen (`configure`).
          * Aktualisiert die Oberfläche im `Space`.
          * Sendet `CompositorSurfaceEvent::SurfaceCommit`.
          * Triggert ggf. ein Redraw für die betroffene Region.

3.  **Hilfsfunktionen:**

      * Funktionen zum Senden von `configure` Events an XDG-Toplevels (z.B. bei Größenänderungen oder Maximierung).
      * Funktionen zum Setzen von Toplevel-Zuständen (z.B. `maximized`, `fullscreen`).

**Spezifische Artefakte/Dateien:**

  * `novade-system/src/compositor/xdg_shell.rs`

**Abhängigkeiten:**

  * **Intern:**
      * `crate::compositor::core::NovaCompositorState`
      * `crate::compositor::data_types::{SurfaceId, CompositorSurfaceEvent}`
      * `crate::compositor::errors::CompositorError`
      * `novade-domain::window_policy::WindowPolicyService`
      * `novade-domain::workspace::WorkspaceService`
  * **Extern:**
      * `smithay::{xdg::{self, ToplevelSurface, PopupSurface}, desktop::{Space, WindowHandler}}`
      * `wayland-server::Dispatch`
      * `tracing`

**Kommunikationsmuster:**

  * **Vom Smithay Event-Loop:** Empfängt XDG-Shell spezifische Callbacks.
  * **An `NovaCompositorState`:** Modifiziert den Zustand des Compositors (z.B. Hinzufügen/Entfernen von Oberflächen).
  * **An Domänenschicht:** Sendet `CompositorSurfaceEvent`s an den `WindowPolicyService` und `WorkspaceService`.
  * **An Wayland-Clients:** Sendet `xdg_toplevel.configure` Events.

**Erwartete Ergebnisse/Outputs:**
Eine vollständige Implementierung des XDG-Shell Protokolls, die es Desktop-Anwendungen ermöglicht, ihre Fenster über NovaDE zu verwalten.

**Teststrategie (Modul-spezifisch):**

  * **Integration Tests:**
      * Starten eines Test-Clients, der XDG-Shell-Fenster erstellt.
      * Testen von Fensterschritten: Erstellung, Größenänderung (Client-seitig und Compositor-seitig), Maximierung, Minimierung, Schließung.
      * Verifizieren, dass die korrekten `CompositorSurfaceEvent`s gesendet werden.
      * Testen der Fokus-Übergabe.
      * Testen von Popups.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage)

-----

### **novade-system/src/compositor/layer\_shell.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert die spezifische Logik für das Wayland `wlr_layer_shell_v1` Protokoll. Es verarbeitet Anfragen von Layer-Shell-Clients (Panels, Docks, Desktophintergründe, Popups) und sendet entsprechende Antworten, um deren Positionierung und Verhalten zu steuern.

**Kern-Aufgaben (Tasks):**

1.  **Implementierung `smithay::wayland::shell::wlr_layer_shell::WlrLayerShellHandler` für `NovaCompositorState`:**

      * `layer_shell_state(&mut self) -> &mut smithay::wayland::shell::wlr_layer_shell::WlrLayerShellState`: Getter für den Layer-Shell-Zustand.
      * `new_layer_surface(&mut self, surface: smithay::desktop::LayerSurface)`:
          * Wird aufgerufen, wenn ein neuer Layer-Shell-Client eine Oberfläche erstellt.
          * Erzeugt eine `SurfaceId` für die neue Oberfläche.
          * Sendet `CompositorSurfaceEvent::NewLayerSurface` an die Domänenschicht (für Metadaten).
          * Fügt die Oberfläche dem `smithay::desktop::Space` hinzu, ggf. unter Berücksichtigung des `Layer`-Typs (Background, Bottom, Top, Overlay).
          * Registriert die Oberfläche für `commit` Events.
      * `layer_surface_destroyed(&mut self, surface_id: SurfaceId)`:
          * Wird aufgerufen, wenn eine Layer-Surface zerstört wird.
          * Entfernt die Oberfläche aus dem `Space`.
          * Sendet `CompositorSurfaceEvent::LayerSurfaceDestroyed`.

2.  **Implementierung `smithay::desktop::WindowHandler` für `NovaCompositorState` (für Layer-Surfaces):**

      * `committed(&mut self, surface_id: SurfaceId, current_state: &smithay::wayland::surface::SurfaceData)`:
          * Wird aufgerufen, wenn ein Client Änderungen an seiner Layer-Surface committed.
          * Überprüft auf Größenänderungen (`configure`) und Anchor-Updates.
          * Aktualisiert die Positionierung der Oberfläche im `Space` basierend auf `LayerShell` Spezifikationen (Anker, Margins).
          * Triggert ggf. ein Redraw für die betroffene Region.

3.  **Hilfsfunktionen:**

      * Funktionen zur Berechnung der korrekten Position und Größe von Layer-Shell-Oberflächen basierend auf Ankern und Margins, unter Berücksichtigung des Work-Areas und anderer Layer.
      * Funktionen zum Senden von `configure` Events an Layer-Surfaces.

**Spezifische Artefakte/Dateien:**

  * `novade-system/src/compositor/layer_shell.rs`

**Abhängigkeiten:**

  * **Intern:**
      * `crate::compositor::core::NovaCompositorState`
      * `crate::compositor::data_types::{SurfaceId, CompositorSurfaceEvent}`
      * `crate::compositor::errors::CompositorError`
      * `novade-core::types::theme::Layer` (Direkte Nutzung der Domänen `Layer` Enum).
  * **Extern:**
      * `smithay::{wayland::shell::wlr_layer_shell::{self, WlrLayerShellState, LayerSurface}, desktop::{Space, WindowHandler}}`
      * `wayland-server::Dispatch`
      * `tracing`

**Kommunikationsmuster:**

  * **Vom Smithay Event-Loop:** Empfängt Layer-Shell spezifische Callbacks.
  * **An `NovaCompositorState`:** Modifiziert den Zustand des Compositors (z.B. Hinzufügen/Entfernen von Oberflächen, Anpassen der Anordnung).
  * **An Domänenschicht:** Sendet `CompositorSurfaceEvent`s (z.B. `NewLayerSurface`).
  * **An Wayland-Clients:** Sendet `zwlr_layer_surface_v1.configure` Events.

**Erwartete Ergebnisse/Outputs:**
Eine vollständige Implementierung des `wlr_layer_shell_v1` Protokolls, die es UI-Komponenten wie Panels, Docks und Desktophintergründen ermöglicht, sich korrekt zu positionieren und mit dem Compositor zu interagieren.

**Teststrategie (Modul-spezifisch):**

  * **Integration Tests:**
      * Starten eines Test-Clients, der Layer-Shell-Oberflächen mit verschiedenen Ankern und Margins erstellt.
      * Testen der Positionierung: Oberflächen am oberen, unteren, linken, rechten Rand; vollflächige Hintergründe.
      * Testen von Größenänderungen und Neupositionierung.
      * Verifizieren, dass die korrekten `CompositorSurfaceEvent`s gesendet werden.
      * Testen der Überlappung und Z-Ordnung von Layern.

**Geschätzter Aufwand:** Mittel (ca. 4-6 Tage)

-----

### **novade-system/src/compositor/output\_management.rs**

**Verantwortlichkeit:**
Dieses Modul ist für die Verwaltung der Bildschirmausgänge (Monitore) des Systems zuständig. Es erkennt neue Outputs, verwaltet deren Konfiguration (Auflösung, Position, Skalierung) und interagiert mit dem zugrundeliegenden Grafik-Backend (DRM/KMS oder Winit) zur Anzeige.

**Kern-Aufgaben (Tasks):**

1.  **Implementierung des `smithay::output::OutputHandler` Trait für `NovaCompositorState`:**

      * `output_state(&mut self) -> &mut smithay::output::OutputManager`: Getter für den Output-Manager.
      * `new_output(&mut self, output: smithay::output::Output)`:
          * Wird aufgerufen, wenn ein neuer Output vom Backend erkannt wird.
          * Registriert den Output beim Smithay `OutputManager`.
          * Sendet `CompositorOutputEvent::OutputAdded` an die Domänenschicht.
          * Initialisiert den Output mit Standard-Modus und Position.
          * Erstellt einen `OutputGlobal` für den Wayland-Client.
      * `output_mode_updated(&mut self, output: smithay::output::Output)`:
          * Wird aufgerufen, wenn der Anzeigemodus eines Outputs geändert wird.
          * Aktualisiert die Output-Konfiguration.
          * Sendet `CompositorOutputEvent::OutputResized` oder ähnliches.
      * `output_removed(&mut self, output: smithay::output::Output)`:
          * Wird aufgerufen, wenn ein Output entfernt wird.
          * Entfernt den Output vom `OutputManager`.
          * Sendet `CompositorOutputEvent::OutputRemoved`.

2.  **Funktionen für Output-Konfiguration:**

      * `fn configure_output(state: &mut NovaCompositorState, output_name: &str, new_mode: smithay::output::Mode, position: Point<i32, Logical>) -> Result<(), CompositorError>`: Setzt Auflösung und Position eines Outputs.
      * `fn find_output_by_name(state: &NovaCompositorState, name: &str) -> Option<&smithay::output::Output>`: Hilfsfunktion zum Suchen von Outputs.

3.  **Integration mit Smithay `OutputManager` und `Global`s:**

      * Sicherstellen, dass `OutputGlobal`s korrekt für Wayland-Clients beworben werden.
      * Verwaltung von Work-Areas für jeden Output.

**Spezifische Artefakte/Dateien:**

  * `novade-system/src/compositor/output_management.rs`

**Abhängigkeiten:**

  * **Intern:**
      * `crate::compositor::core::NovaCompositorState`
      * `crate::compositor::data_types::CompositorOutputEvent`
      * `crate::compositor::errors::CompositorError`
      * `novade-core::types::geometry::{Size, Point, Logical}`
  * **Extern:**
      * `smithay::{output::{self, Output, OutputManager}, backend::output::Mode}`
      * `wayland-server::Dispatch`
      * `tracing`

**Kommunikationsmuster:**

  * **Vom Smithay Backend:** Empfängt Events über neue/entfernte/geänderte Outputs.
  * **An `NovaCompositorState`:** Aktualisiert den Zustand der Outputs.
  * **An Domänenschicht:** Sendet `CompositorOutputEvent`s an den `WorkspaceService` oder `GlobalSettingsService` (falls dieser für Output-Konfiguration zuständig ist).
  * **An Wayland-Clients:** Informiert Clients über Output-Änderungen über das Wayland `wl_output` Protokoll.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Dienst zur Verwaltung von Bildschirmausgängen, der dynamisch auf Hardwareänderungen reagiert und die Konfiguration der Ausgänge über eine API ermöglicht.

**Teststrategie (Modul-spezifisch):**

  * **Integration Tests:**
      * Simulieren des Hinzufügens/Entfernens von virtuellen Outputs (mit Winit-Backend möglich).
      * Testen von Auflösungs- und Positionsänderungen.
      * Verifizieren, dass die korrekten `CompositorOutputEvent`s an die Domänenschicht gesendet werden.
      * Überprüfen, ob Wayland-Clients die Output-Änderungen korrekt empfangen.

**Geschätzter Aufwand:** Mittel (ca. 3-5 Tage)

-----

### **novade-system/src/compositor/dma\_buf.rs**

**Verantwortlichkeit:**
Dieses Modul ist für die Handhabung von `dmabuf`-basierten Puffern verantwortlich. `dmabuf` ermöglicht Zero-Copy-Import und -Export von Grafikpuffern zwischen verschiedenen Prozessen (z.B. Wayland-Client und Compositor, oder Compositor und Renderer), was die Performance erheblich steigert.

**Kern-Aufgaben (Tasks):**

1.  **Implementierung des `smithay::wayland::dmabuf::DmabufHandler` Trait für `NovaCompositorState`:**

      * `dmabuf_state(&mut self) -> &mut smithay::wayland::dmabuf::DmabufState`: Getter für den Dmabuf-Zustand.
      * `device_fd(&self) -> Option<std::fs::File>`: Stellt das DRM-Gerät für den Im- und Export von `dmabuf`s bereit.
      * `format_map(&self) -> &dmabuf::FormatList`: Gibt eine Liste der unterstützten `dmabuf`-Formate zurück.
      * `dmabuf_imported(&mut self, dmabuf: smithay::wayland::dmabuf::Dmabuf)`:
          * Wird aufgerufen, wenn ein Client einen `dmabuf` importiert.
          * Importiert den `dmabuf` in den Renderer (z.B. über `gbm_bo_import`).
          * Registriert den Buffer beim Compositor.
          * Übergibt den Buffer zur weiteren Verwendung an den Renderer oder die Oberfläche.

2.  **Konfiguration der `dmabuf` Unterstützung:**

      * Stellen Sie sicher, dass der Smithay `DmabufState` korrekt initialisiert ist und die unterstützten Formate beworben werden.
      * Integration mit dem verwendeten DRM-Backend und dem Renderer (`gbm`, `egl`).

**Spezifische Artefekte/Dateien:**

  * `novade-system/src/compositor/dma_buf.rs`

**Abhängigkeiten:**

  * **Intern:**
      * `crate::compositor::core::NovaCompositorState`
      * `crate::compositor::errors::CompositorError`
  * **Extern:**
      * `smithay::wayland::dmabuf::{self, Dmabuf, DmabufHandler, DmabufState}`
      * `wayland-server::Dispatch`
      * `drm` (für DRM-Gerät)
      * `gbm` (für Buffer-Import)
      * `tracing`

**Kommunikationsmuster:**

  * **Vom Smithay Event-Loop:** Empfängt `dmabuf` spezifische Callbacks.
  * **An `NovaCompositorState`:** Speichert den `DmabufState`.
  * **An Renderer:** Übergibt den importierten `dmabuf` an den Grafik-Renderer zur Darstellung.

**Erwartete Ergebnisse/Outputs:**
Eine funktionierende `dmabuf`-Integration, die eine effiziente und performante Pufferübergabe zwischen Wayland-Clients und dem Compositor ermöglicht, was zu geringerer CPU-Auslastung und höherer Framerate führt.

**Teststrategie (Modul-spezifisch):**

  * **Integration Tests:**
      * Starten eines Test-Clients, der `dmabuf`-Puffer verwendet.
      * Verifizieren, dass die `dmabuf`s korrekt importiert und gerendert werden.
      * Testen der Pufferlebensdauer und Freigabe.
      * Überprüfen der Performance-Vorteile (optional, durch Benchmarks).

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da DRM-spezifische Kenntnisse und Setup erforderlich sind)

-----
### **novade-system/src/input**

**Verantwortlichkeit:**
Das `input`-Modul ist für die rohe Erfassung und Verarbeitung von Benutzereingaben zuständig, die von verschiedenen Systemquellen (z.B. Tastatur, Maus, Touchpad) stammen. Es abstrahiert die gerätespezifischen Details und stellt normalisierte Eingabeereignisse bereit. Es integriert `libinput` und `xkbcommon` für robuste Eingabeverarbeitung.

**Kern-Aufgaben (Tasks):**

1.  **Einrichtung des `libinput` Backends:**
    * Initialisiere `libinput::Context`.
    * Konfiguriere das `libinput` Backend (z.B. `udev` für physische Geräte).
    * Setze den `libinput` Seat.

2.  **`InputService` Trait:**
    * Definiere den `InputService` Trait.
    * Methoden:
        * `async fn run(&self) -> Result<(), InputError>`: Startet die Eingabe-Event-Loop.
        * `fn get_active_devices(&self) -> Result<Vec<InputDeviceInfo>, InputError>`: Ruft Informationen über aktive Eingabegeräte ab.
        * `async fn set_keyboard_layout(&self, layout: &str, variant: Option<&str>) -> Result<(), InputError>`: Setzt das Tastaturlayout (`xkbcommon`).
        * `fn subscribe_to_input_events(&self) -> broadcast::Receiver<InputEvent>`: Ermöglicht das Abonnieren von verarbeiteten Eingabeereignissen.

3.  **Implementierung `DefaultInputService`:**
    * Implementiere `DefaultInputService` basierend auf dem `InputService` Trait.
    * Hält den `libinput::Context` und den `xkbcommon::Context`.
    * Eine dedizierte `tokio::task` liest Events von `libinput` und verarbeitet diese.
    * Die Verarbeitung beinhaltet:
        * **Tastatur:** Übersetzen von Scancodes in Keysyms unter Berücksichtigung des aktuellen `xkbcommon` Layouts und Modifiers.
        * **Zeiger:** Normalisierung von Maus- und Touchpad-Bewegungen.
        * **Touch:** Verfolgung von Multi-Touch-Eingaben.
        * **Gesten:** Erkennung grundlegender Gesten (z.B. Pinch, Swipe).
    * Sendet normalisierte `InputEvent`s über `broadcast::Sender` an die Domänenschicht (`InputPolicyService`).
    * Verwaltet den Zustand der Eingabegeräte.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/mod.rs`
* `novade-system/src/input/service.rs` (enthält Trait und Implementierung)
* `novade-system/src/input/data_types.rs` (Input-spezifische Datenstrukturen wie `InputDeviceInfo`)
* `novade-system/src/input/errors.rs` (`InputError` Enum)
* `novade-system/src/input/libinput_handler.rs` (spezifische Callbacks und Event-Verarbeitung für `libinput`)
* `novade-system/src/input/xkb_handler.rs` (Verwaltung des `xkbcommon` Zustands und Tastatur-Mapping)

**Abhängigkeiten:**

* **Intern:**
    * `novade-core::error::CoreError`.
    * `novade-core::types::input::{InputEvent, KeyState, ButtonState, TouchState, Modifiers, KeyCode, MouseButton}` (für die an die Domäne gesendeten Events).
    * `novade-core::types::geometry::{Point, Logical}`.
* **Extern:**
    * `libinput::{self, Context, Event, EventKind, Device, KeyState, EventTrait, DeviceTrait, KeyboardEvent, PointerEvent, TouchEvent, GestureEvent}` (für Low-Level-Eingabe).
    * `xkbcommon::xkb::{self, Context, Keymap, State}` (für Tastatur-Layouts).
    * `tokio::{self, task, sync::broadcast}`.
    * `thiserror::Error`.
    * `async_trait`.
    * `tracing`.
    * `udev` (für `libinput` Backend).

**Kommunikationsmuster:**

* **An Domänenschicht (`InputPolicyService`):** Sendet verarbeitete `InputEvent`s (Tastatur, Zeiger, Touch, Gesten).
* **Vom System/Kernel:** Empfängt rohe Eingabeereignisse über `libinput`.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Eingabeverwaltungsdienst, der plattformunabhängig rohe Eingaben verarbeitet und normalisierte, für die Domänenschicht verständliche Events bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `InputDeviceInfo` und `InputEvent` Enums.
    * Mocken von `libinput` und `xkbcommon` zur Simulation von Eingabeereignissen.
    * Testen der Übersetzung von Scancodes in Keysyms.
    * Testen der Modifier-Verwaltung.
    * Testen der `set_keyboard_layout` Funktionalität.
    * Verifizieren, dass die `InputEvent`s korrekt über den `broadcast::Sender` gesendet werden.
* **Integration Tests:**
    * Starten des Compositors und des `InputService`.
    * Durchführung realer Tastatur- und Mauseingaben (manuell oder über Automatisierungstools).
    * Überprüfen, ob die Ereignisse korrekt in der Domänenschicht ankommen.

**Geschätzter Aufwand:** Hoch (ca. 6-9 Tage, da `libinput` und `xkbcommon` Integration komplex sein kann)

---

### **novade-system/src/input/service.rs**

**Verantwortlichkeit:**
Dieses Modul enthält die Implementierung des `InputService` Traits, der die Hauptlogik für die Initialisierung, die Event-Loop und die Verwaltung des `libinput`- und `xkbcommon`-Kontexts für die Eingabeverarbeitung bereitstellt.

**Kern-Aufgaben (Tasks):**

1.  **Struktur `DefaultInputService`:**
    * Felder:
        * `libinput_context: Mutex<libinput::Context>`
        * `xkb_context: Arc<xkbcommon::xkb::Context>`
        * `event_sender: broadcast::Sender<InputEvent>`
        * `current_keyboard_state: Mutex<xkbcommon::xkb::State>`
        * `current_keyboard_keymap: Mutex<xkbcommon::xkb::Keymap>`
        * `active_devices: RwLock<HashMap<DeviceId, InputDeviceInfo>>`
        * `seat_name: String` (z.B. "seat0")

2.  **`DefaultInputService::new()` Funktion:**
    * Initialisiert `libinput::Context` mit dem `udev` Backend.
    * Initialisiert `xkbcommon::xkb::Context`.
    * Erstellt den `broadcast::Sender` für `InputEvent`s.
    * Initialisiert `current_keyboard_state` und `current_keyboard_keymap` mit einem Standard-Layout.
    * Ruft `libinput::udev_assign_seat("seat0")` auf.
    * Scannt initial nach bestehenden Geräten und füllt `active_devices`.
    * Gibt `Arc<DefaultInputService>` zurück.

3.  **`InputService` Trait Implementierung für `DefaultInputService`:**
    * `async fn run(&self) -> Result<(), InputError>`:
        * Startet eine `tokio::task` für die `libinput` Event-Loop.
        * Innerhalb der Loop:
            * Liest Events von `libinput_context.dispatch()`.
            * Iteriert über die Events:
                * Ruft `libinput_handler::process_event` für jedes `libinput::Event` auf.
                * Die Handler-Funktionen nutzen `current_keyboard_state`, `current_keyboard_keymap` und `active_devices`.
                * Die Handler-Funktionen senden normalisierte `InputEvent`s über `event_sender`.
    * `fn get_active_devices(&self) -> Result<Vec<InputDeviceInfo>, InputError>`:
        * Gibt eine Kopie der `active_devices` HashMap-Werte zurück.
    * `async fn set_keyboard_layout(&self, layout: &str, variant: Option<&str>) -> Result<(), InputError>`:
        * Erstellt eine neue `xkbcommon::xkb::Keymap` basierend auf dem `layout` und `variant`.
        * Aktualisiert `current_keyboard_keymap` und `current_keyboard_state`.
        * Sendet möglicherweise ein Event, dass das Layout geändert wurde.
    * `fn subscribe_to_input_events(&self) -> broadcast::Receiver<InputEvent>`:
        * Gibt einen neuen `broadcast::Receiver` zurück.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/service.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input::data_types::{InputDeviceInfo}`
    * `crate::input::errors::InputError`
    * `crate::input::libinput_handler`
    * `crate::input::xkb_handler`
    * `novade-core::types::input::InputEvent`
* **Extern:**
    * `libinput`
    * `xkbcommon::xkb`
    * `tokio::{self, task, sync::broadcast}`
    * `parking_lot::{Mutex, RwLock}`
    * `std::collections::HashMap`
    * `async_trait`
    * `tracing`

**Kommunikationsmuster:**

* **Intern:** Delegiert die Detailverarbeitung der `libinput`-Events an `libinput_handler` und `xkb_handler`.
* **An Domänenschicht:** Sendet normalisierte `InputEvent`s.

**Erwartete Ergebnisse/Outputs:**
Eine laufende `libinput`-gesteuerte Eingabeverarbeitung, die Eingabeereignisse zuverlässig erkennt, normalisiert und an die Domänenschicht weiterleitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken von `libinput::Context` und `xkbcommon::xkb::Context` um die Event-Verarbeitungsschleife zu testen.
    * Testen der `set_keyboard_layout` Methode, um sicherzustellen, dass die `xkbcommon` Zustände korrekt aktualisiert werden.
    * Testen der Gerät-Erkennung und -Verwaltung in `active_devices`.
    * Verifizieren, dass `InputEvent`s mit korrekten Daten gesendet werden.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage)

---

### **novade-system/src/input/data_types.rs**

**Verantwortlichkeit:**
Dieses Modul definiert die spezifischen Datenstrukturen und Enums, die innerhalb des `input`-Moduls verwendet werden, um Informationen über Eingabegeräte und deren Fähigkeiten zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`InputDeviceInfo` Struktur:**
    * Definiere `InputDeviceInfo` zur Kapselung von Geräteinformationen.
    * Felder:
        * `id: String` (Eindeutiger Geräte-Identifier, z.B. `/dev/input/eventX` oder `libinput` internal ID).
        * `name: String` (Gerätename, z.B. "AT Translated Set 2 keyboard").
        * `device_type: InputDeviceType` (Enum, z.B. `Keyboard`, `Pointer`, `Touch`, `Tablet`, `Gesture`).
        * `capabilities: Vec<InputDeviceCapability>` (Enum, z.B. `Keyboard`, `PointerMotion`, `PointerButton`, `TouchMulti`, `ScrollVertical`).
        * `is_active: bool` (Gerät ist derzeit aktiv und liefert Events).
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.

2.  **`InputDeviceType` Enum:**
    * Varianten: `Keyboard`, `Pointer`, `Touch`, `Tablet`, `Gesture`, `Other`.
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.

3.  **`InputDeviceCapability` Enum:**
    * Varianten: `Keyboard`, `PointerMotion`, `PointerButton`, `TouchSingle`, `TouchMulti`, `ScrollVertical`, `ScrollHorizontal`, `GestureSwipe`, `GesturePinch`.
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/data_types.rs`

**Abhängigkeiten:**

* **Intern:** Keine direkten Abhängigkeiten von anderen NovaDE-Modulen.
* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::hash::Hash`

**Kommunikationsmuster:**

* Wird von `service.rs` erstellt und verwaltet.
* Wird von der Domänenschicht (`InputPolicyService`) abgefragt, um Informationen über angeschlossene Eingabegeräte zu erhalten.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und konsistente Datenmodelle zur Repräsentation von Eingabegeräten und deren Fähigkeiten, die eine einfache Nutzung in der gesamten Anwendung ermöglichen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize` Implementierungen für alle Strukturen und Enums.
    * Testen der Erstellung von `InputDeviceInfo` mit verschiedenen `InputDeviceType`s und `InputDeviceCapability`s.

**Geschätzter Aufwand:** Gering (ca. 0.5-1 Tag)

---

### **novade-system/src/input/errors.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Fehler (`InputError`), die innerhalb des `input`-Moduls auftreten können. Dies gewährleistet eine konsistente und detaillierte Fehlerbehandlung und ermöglicht eine präzise Fehlerweiterleitung an höhere Schichten.

**Kern-Aufgaben (Tasks):**

1.  **`InputError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `LibinputContextError(String)`: Fehler beim Initialisieren oder Interagieren mit dem `libinput` Kontext.
        * `XkbCommonError(String)`: Fehler bei der `xkbcommon` Initialisierung oder Tasten-Mapping.
        * `DeviceNotFound(String)`: Gerät mit gegebener ID/Name nicht gefunden.
        * `InvalidKeyboardLayout(String)`: Ungültiges Tastaturlayout angegeben.
        * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/errors.rs`

**Abhängigkeiten:**

* **Intern:** Keine direkten Abhängigkeiten.
* **Extern:**
    * `thiserror::Error`
    * `std::io::Error`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `input`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im Input-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `InputError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---

### **novade-system/src/input/libinput_handler.rs**

**Verantwortlichkeit:**
Dieses Modul enthält die spezifische Logik für die Verarbeitung der von `libinput` erzeugten rohen Events. Es übersetzt diese Low-Level-Events in die normalisierten `InputEvent`s von NovaDE.

**Kern-Aufgaben (Tasks):**

1.  **Funktion `process_event`:**
    * `pub fn process_event(event: libinput::Event, input_service: &DefaultInputService) -> Result<(), InputError>`
    * Nimmt ein `libinput::Event` entgegen.
    * Nutzt ein `match` Statement für `event.event_type()`:
        * **`EventKind::DeviceAdded` / `EventKind::DeviceRemoved`:**
            * Aktualisiert die `active_devices` in `DefaultInputService`.
            * Sendet ein (optionales) internes Event über Geräteänderungen.
        * **`EventKind::Keyboard*`:**
            * Parsen von `libinput::KeyboardEvent`.
            * Aktualisiert den `xkbcommon::xkb::State` in `DefaultInputService` (`current_keyboard_state`).
            * Konvertiert `libinput::KeyState` zu `novade_core::types::input::KeyState`.
            * Ruft `xkb_handler::map_keycode_to_keysym` auf, um den `KeyCode` zu erhalten.
            * Erstellt ein `novade_core::types::input::InputEvent::KeyboardEvent`.
            * Sendet das Event über `input_service.event_sender`.
        * **`EventKind::PointerMotion*`:**
            * Parsen von `libinput::PointerMotionEvent`.
            * Erstellt ein `novade_core::types::input::InputEvent::PointerEvent` mit `PointerMotion` State.
            * Sendet das Event.
        * **`EventKind::PointerButton*`:**
            * Parsen von `libinput::PointerButtonEvent`.
            * Erstellt ein `novade_core::types::input::InputEvent::PointerEvent` mit `PointerButton` State.
            * Sendet das Event.
        * **`EventKind::PointerScroll*`:**
            * Parsen von `libinput::PointerScrollEvent`.
            * Erstellt ein `novade_core::types::input::InputEvent::PointerEvent` mit `PointerScroll` State.
            * Sendet das Event.
        * **`EventKind::Touch*`:**
            * Parsen von `libinput::TouchEvent` (Down, Motion, Up, Cancel).
            * Erstellt ein `novade_core::types::input::InputEvent::TouchEvent`.
            * Sendet das Event.
        * **`EventKind::Gesture*`:**
            * Parsen von `libinput::GestureEvent` (Pinch, Swipe).
            * Erstellt ein `novade_core::types::input::InputEvent::GestureEvent`.
            * Sendet das Event.
    * Behandelt alle anderen `EventKind`s (z.B. Tablet, Switch) oder ignoriert sie vorerst.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/libinput_handler.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input::service::DefaultInputService` (als Referenz, um auf Zustand und Sender zuzugreifen).
    * `crate::input::errors::InputError`
    * `crate::input::xkb_handler`
    * `novade-core::types::input::{InputEvent, KeyState, ButtonState, TouchState, Modifiers, KeyCode, MouseButton}`
    * `novade-core::types::geometry::{Point, Logical}`
* **Extern:**
    * `libinput::{Event, EventKind, DeviceTrait, KeyboardEventTrait, PointerEventTrait, TouchEventTrait, GestureEventTrait}`
    * `tracing`

**Kommunikationsmuster:**

* **Vom `DefaultInputService::run()` Loop:** Empfängt `libinput::Event`s.
* **An `DefaultInputService` (Zustand):** Greift auf `current_keyboard_state`, `current_keyboard_keymap` und `active_devices` zu (über `Mutex` oder `RwLock`).
* **An `DefaultInputService` (Event-Sender):** Sendet verarbeitete `InputEvent`s an den `broadcast::Sender`.

**Erwartete Ergebnisse/Outputs:**
Eine effiziente und korrekte Übersetzung von Low-Level `libinput`-Events in High-Level `InputEvent`s, die für die Domänenschicht nutzbar sind.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Erstellen von Mock `libinput::Event`s für verschiedene Typen (Tastatur, Maus, Touch, Geste).
    * Mocken von `DefaultInputService` (insbesondere `current_keyboard_state`, `current_keyboard_keymap`, `active_devices` und `event_sender`).
    * Testen, ob `process_event` die korrekten `InputEvent`s erzeugt und über den `event_sender` sendet.
    * Testen der `xkbcommon` Integration für Tastatur-Events.
    * Testen der Modifier-Verarbeitung.
    * Testen von Edge-Cases wie unbekannten Event-Typen.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage)

---

### **novade-system/src/input/xkb_handler.rs**

**Verantwortlichkeit:**
Dieses Modul ist für die Integration mit `xkbcommon` zuständig, um Tastatur-Layouts zu verwalten, Tastendrücke in symbolische Keysyms zu übersetzen und den Zustand der Modifier (Shift, Ctrl, Alt etc.) zu verfolgen.

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des `xkbcommon` Kontexts:**
    * `pub fn new_xkb_context() -> Result<xkbcommon::xkb::Context, InputError>`: Erstellt einen neuen `xkbcommon::xkb::Context`.

2.  **Erstellung der Tastatur-Keymap:**
    * `pub fn create_keymap(context: &xkbcommon::xkb::Context, layout: &str, variant: Option<&str>) -> Result<xkbcommon::xkb::Keymap, InputError>`:
        * Erstellt eine neue `xkbcommon::xkb::Keymap` basierend auf dem angegebenen Layout und Variant.
        * Verwendet die `xkbcommon::xkb::Keymap::new_from_names` Funktion.
        * Fügt Fallback-Logik hinzu, falls ein Layout nicht gefunden wird.

3.  **Verwaltung des Tastatur-Zustands:**
    * `pub fn create_keyboard_state(keymap: &xkbcommon::xkb::Keymap) -> xkbcommon::xkb::State`: Erstellt einen neuen `xkbcommon::xkb::State` aus einer `Keymap`.

4.  **Tasten-Mapping und Modifier-Verwaltung:**
    * `pub fn map_keycode_to_keysym(state: &mut xkbcommon::xkb::State, keycode: u32, key_state: KeyState) -> KeyCode`:
        * Nimmt einen rohen `keycode` (von `libinput`) und den `KeyState` (Pressed/Released).
        * Aktualisiert den `xkbcommon::xkb::State` mit dem `keycode` und `key_state` (wichtig für Modifier-Erkennung).
        * Verwendet `state.key_get_sym()` oder `state.key_get_utf8()` um den symbolischen `KeyCode` zu erhalten.
        * Gibt den `KeyCode` aus `novade_core::types::input` zurück.
    * `pub fn get_modifiers(state: &xkbcommon::xkb::State) -> Modifiers`:
        * Gibt die aktuellen `Modifiers` (Shift, Ctrl, Alt, Super) basierend auf dem `xkbcommon::xkb::State` zurück.
        * Konvertiert `xkbcommon::xkb::State::mods_state()` in die `novade_core::types::input::Modifiers` Bitmaske.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/xkb_handler.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input::errors::InputError`
    * `novade-core::types::input::{KeyCode, KeyState, Modifiers}`
* **Extern:**
    * `xkbcommon::xkb::{self, Context, Keymap, State, Keysym, KeyState, ModState}`
    * `tracing`

**Kommunikationsmuster:**

* Wird von `libinput_handler.rs` aufgerufen, um Tastatur-Events zu verarbeiten.
* Ruft `xkbcommon` APIs auf.

**Erwartete Ergebnisse/Outputs:**
Eine korrekte und effiziente Umwandlung von rohen Tastatur-Scancodes in logische Keysyms und die zuverlässige Erkennung von Modifier-Zuständen, was für die korrekte Eingabeverarbeitung essentiell ist.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen von `new_xkb_context`.
    * Testen von `create_keymap` mit verschiedenen gültigen und ungültigen Layouts/Variants.
    * Testen von `create_keyboard_state`.
    * Testen von `map_keycode_to_keysym` mit verschiedenen Tastencodes und Zuständen (z.B. A gedrückt, Shift+A gedrückt, Ctrl+C gedrückt).
    * Testen von `get_modifiers` um sicherzustellen, dass die korrekten Modifier-Flags gesetzt werden.
    * Simulieren von Tasten-Sequenzen, um die Zustandsübergänge zu testen.

**Geschätzter Aufwand:** Mittel (ca. 3-4 Tage)

---
### **novade-system/src/compositor**

**Verantwortlichkeit:**
Das `compositor`-Modul ist das Herzstück des NovaDE-Grafiksystems. Es basiert auf dem `smithay`-Toolkit und ist für die Verwaltung des Wayland-Displays, die Fensterverwaltung, die Protokollimplementierungen (XDG-Shell, Layer-Shell), das Rendering und die Integration mit XWayland verantwortlich. Es agiert als zentraler Punkt für die Darstellung und Interaktion mit grafischen Oberflächen.

**Kern-Aufgaben (Tasks):**

1.  **Wayland Compositor Initialisierung:**
    * Initialisierung des `smithay::wayland::Display` und `smithay::wayland::compositor::CompositorState`.
    * Einrichtung des `smithay::backend::renderer::Renderer`.
    * Erstellung des `smithay::backend::allocator::Allocator`.

2.  **Protokoll-Management:**
    * Implementierung und Management der `xdg_shell` und `wlr_layer_shell` Protokolle.
    * Handling von Client-Verbindungen und Protokoll-Requests.
    * Verwaltung der Fenster-Lebenszyklen (Erstellung, Zerstörung, Resize, Min/Max).

3.  **Rendering-Pipeline:**
    * Integration mit dem `smithay` Renderer (z.B. `wgpu` oder `egl`).
    * Management von Scenen und Oberflächen.
    * Durchführung des Renderns von Clients und Overlay-Elementen.

4.  **Cursor-Management:**
    * Verwaltung des systemweiten Cursors (Cursor-Theming, Hotspots).
    * Setzen des Cursor-Bildes für Clients.

5.  **Subsurface- und Buffer-Management:**
    * Handling von `wl_subsurface` für komplexe Oberflächenstrukturen.
    * Management der `wl_buffer`s für das Rendern.

6.  **XWayland Integration:**
    * Initialisierung und Management des XWayland Desktops.
    * Übersetzung von X11-Events in Wayland-Events und umgekehrt.
    * Handling von X11-Fenstern im Wayland Compositor.

7.  **Output-Management:**
    * Erkennung und Konfiguration von Displays (Outputs).
    * Verwaltung von Multi-Monitor-Setups.
    * Skalierung und Transformation von Outputs.

8.  **Event-Handling:**
    * Empfangen von Events vom `libinput` System und Weiterleitung an `smithay` für Client-Fokus und Eingabe-Weiterleitung.
    * Handling von `Frame` Events für das Compositor-Rendering.

9.  **Zustandsverwaltung:**
    * Verwaltung des `DesktopState` (oder ähnlichem globalen Zustand), der den Zustand aller Fenster, Oberflächen und Outputs hält.
    * Sicherstellung der Thread-Sicherheit für den globalen Zustand.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/mod.rs`
* `novade-system/src/compositor/state.rs` (Hauptstruktur für den Compositor-Zustand, hält Smithay-States)
* `novade-system/src/compositor/backend.rs` (Definition und Initialisierung des `smithay` Backends und Renderers)
* `novade-system/src/compositor/xdg_shell.rs` (XDG-Shell Protokoll Implementierung und Logik)
* `novade-system/src/compositor/layer_shell.rs` (Layer-Shell Protokoll Implementierung und Logik)
* `novade-system/src/compositor/xwayland.rs` (XWayland Initialisierung und Event-Handling)
* `novade-system/src/compositor/outputs.rs` (Output-Management und Modus-Einstellung)
* `novade-system/src/compositor/renderer.rs` (Renderer-spezifische Helferfunktionen)
* `novade-system/src/compositor/events.rs` (Definiert interne Compositor-Events)
* `novade-system/src/compositor/error.rs` (`CompositorError` Enum)

**Abhängigkeiten:**

* **Intern:**
    * `novade-core::error::CoreError`
    * `novade-core::types::geometry::{Size, Point, Logical, Physical}`
    * `novade-core::types::window::{WindowId, WindowState, WindowType, WindowConfig}` (wenn vom Domänen-Fenster-Management verwendet)
    * `novade-system::input::service::InputService` (für Input-Event-Integration)
    * `novade-domain::desktop_state::DesktopState` (für den globalen Zustand)
* **Extern:**
    * `smithay::{self, backend, wayland, utils, reexports}`
        * `smithay::backend::{renderer, allocator, winit, egl, gles, drm, Backend, SwapBuffersError, SwapBuffersFrame, Frame}`
        * `smithay::wayland::{compositor, data_device, shm, xdg_shell, layer_shell, primary_selection}`
        * `smithay::utils::{Point, Size, Rectangle, Scale, Transform, Logical, Physical, Ratio}`
        * `smithay::reexports::{calloop, wayland_server, wayland_protocols, xkbcommon, drm_rs, libdrm}`
    * `tokio::{self, task, sync::broadcast}`
    * `tracing`
    * `thiserror::Error`
    * `async_trait`
    * `parking_lot::{Mutex, RwLock}`
    * `std::collections::HashMap`
    * `x11rb_protocol` (für XWayland)
    * `x11rb::connection::Connection` (für XWayland)

**Kommunikationsmuster:**

* **Von Domänenschicht (`WindowPolicyService`, `DesktopState`):** Empfängt Anweisungen für Fensteraktionen (Minimieren, Maximieren, Verschieben, Fokus setzen) und Statusabfragen.
* **An Domänenschicht (`DesktopState`):** Benachrichtigt über Zustandsänderungen der Fenster (z.B. Fenster geschlossen, Fokus geändert).
* **Vom `input` Modul:** Empfängt normalisierte `InputEvent`s zur Weiterleitung an die Wayland-Clients.
* **An Wayland Clients:** Sendet Events (Frame, Configure, Input) über Wayland-Protokolle.
* **An den Kernel/Grafiktreiber:** Interagiert über `smithay::backend` für Rendering und Display-Modi.

**Erwartete Ergebnisse/Outputs:**
Ein voll funktionsfähiger Wayland Compositor, der grafische Ausgaben rendert, Fenstermanagement durchführt und Benutzereingaben an die Clients weiterleitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Initialisierung von `smithay` Komponenten.
    * Mocken von Wayland-Clients zur Simulation von Protokoll-Interaktionen (z.B. `xdg_shell` Handshakes).
    * Testen der Fenster-Zustandsverwaltung in `CompositorState`.
    * Testen der Umrechnungen zwischen logischen und physikalischen Koordinaten.
    * Überprüfung der korrekten Fehlerbehandlung.
* **Integration Tests:**
    * Starten eines Test-Compositors mit einem `winit` Backend.
    * Starten von Test-Clients (z.B. `wayland-client-rs` Beispiele, oder einfache GTK/Qt-Anwendungen).
    * Überprüfen der Fenster-Rendering, Größenänderung, Verschiebung, Fokus-Änderung.
    * Testen der Input-Weiterleitung an die Clients.
    * Testen der XWayland-Integration mit X11-Clients.
    * Visuelle Überprüfung der Ausgabe.

**Geschätzter Aufwand:** Sehr hoch (ca. 10-15 Tage, da `smithay` Integration und Protokoll-Implementierung komplex ist)

---

### **novade-system/src/compositor/state.rs**

**Verantwortlichkeit:**
Dieses Modul definiert die zentrale `CompositorState`-Struktur, die den gesamten Zustand des Wayland-Compositors kapselt und verwaltet. Es ist der Dreh- und Angelpunkt für alle `smithay`-relevanten Zustände und die Interaktion mit dem `smithay` Dispatch-System.

**Kern-Aufgaben (Tasks):**

1.  **Struktur `CompositorState`:**
    * Felder:
        * `compositor_state: Mutex<smithay::wayland::compositor::CompositorState>`
        * `shm_state: Mutex<smithay::wayland::shm::ShmState>`
        * `xdg_shell_state: Mutex<smithay::wayland::xdg_shell::XdgShellState>`
        * `layer_shell_state: Mutex<smithay::wayland::layer_shell::LayerShellState>`
        * `data_device_state: Mutex<smithay::wayland::data_device::DataDeviceState>`
        * `primary_selection_state: Mutex<smithay::wayland::primary_selection::PrimarySelectionState>`
        * `xdg_activation_state: Mutex<smithay::wayland::xdg_activation::XdgActivationState>` (optional, aber empfohlen für `xdg-activation-v1`)
        * `seat_state: Mutex<smithay::wayland::seat::SeatState>`
        * `pointer_handle: Mutex<smithay::wayland::seat::PointerHandle<Self>>`
        * `keyboard_handle: Mutex<smithay::wayland::seat::KeyboardHandle<Self>>`
        * `touch_handle: Mutex<smithay::wayland::seat::TouchHandle<Self>>`
        * `outputs: RwLock<HashMap<OutputId, smithay::wayland::output::Output>>`
        * `window_map: RwLock<HashMap<WindowId, Arc<Mutex<XdgToplevelSurface>>>>` (oder eine andere Abstraktion für `xdg_shell` und `xwayland` Fenster)
        * `layer_map: RwLock<HashMap<LayerId, Arc<Mutex<LayerSurface>>>>`
        * `desktop_state: Arc<DesktopState>` (Referenz auf den Domänen-Desktop-Zustand)
        * `display_handle: smithay::wayland::DisplayHandle`
        * `loop_handle: calloop::LoopHandle<'static, Self>`
        * `render_scheduler: smithay::backend::renderer::scheduler::Scheduler`
        * `renderer: Mutex<Option<Box<dyn smithay::backend::renderer::Renderer<Error = anyhow::Error>>>>` (Renderer-Instanz, optional)
        * `allocator: Mutex<Option<Box<dyn smithay::backend::allocator::Allocator<Error = anyhow::Error>>>>` (Allocator-Instanz, optional)
        * `xwayland_state: Mutex<Option<XWaylandState>>` (wenn XWayland aktiviert)

2.  **`CompositorState::new()` Funktion:**
    * Initialisiert alle `smithay`-States.
    * Erstellt `smithay::wayland::DisplayHandle`.
    * Erstellt `smithay::wayland::seat::Seat` und dessen Handles.
    * Initialisiert die `output` HashMap.
    * Erstellt und speichert eine Referenz auf `DesktopState`.
    * Initialisiert den `render_scheduler`.
    * Gibt die `CompositorState`-Instanz zurück.

3.  **Implementierung `smithay::wayland::compositor::State` Trait:**
    * Implementiert die erforderlichen Methoden für `smithay` Dispatching.
    * `compositor_state()`: Gibt `compositor_state` zurück.
    * `shm_state()`: Gibt `shm_state` zurück.
    * `xdg_shell_state()`: Gibt `xdg_shell_state` zurück.
    * `layer_shell_state()`: Gibt `layer_shell_state` zurück.
    * `data_device_state()`: Gibt `data_device_state` zurück.
    * `primary_selection_state()`: Gibt `primary_selection_state` zurück.
    * `xdg_activation_state()`: Gibt `xdg_activation_state` zurück.
    * `seat_state()`: Gibt `seat_state` zurück.

4.  **Helper-Methoden:**
    * `add_output(...)`: Fügt einen neuen Output hinzu.
    * `get_active_surface_for_point(...)`: Findet die oberste Oberfläche an einem Punkt (für Pointer-Events).
    * `set_focused_surface(...)`: Setzt den Fokus auf eine Oberfläche.
    * `set_cursor_image(...)`: Setzt das Cursor-Bild.
    * `send_input_event_to_focused_client(...)`: Leitet ein Eingabeereignis an den aktuell fokussierten Client weiter.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/state.rs`

**Abhängigkeiten:**

* **Intern:**
    * `novade-domain::desktop_state::DesktopState`
    * `novade-core::types::input::{InputEvent}`
    * `novade-core::types::window::{WindowId}`
    * `crate::compositor::xwayland::XWaylandState`
    * `crate::compositor::xdg_shell::{XdgToplevelSurface, WindowId as XdgWindowId}`
    * `crate::compositor::layer_shell::{LayerSurface, LayerId}`
    * `crate::compositor::outputs::{OutputId}`
* **Extern:**
    * `smithay::{wayland, backend, utils, reexports::{calloop}}`
    * `parking_lot::{Mutex, RwLock}`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `tracing`

**Kommunikationsmuster:**

* **Intern (`compositor` Modul):** Alle anderen Sub-Module innerhalb von `compositor` greifen auf die `CompositorState` zu, um den Zustand abzufragen oder zu aktualisieren.
* **An `smithay`:** Implementiert die `smithay::wayland::compositor::State` Trait, um als Dispatch-Target zu fungieren.
* **An `DesktopState`:** Informiert `DesktopState` über Änderungen des Fenstermanagements (z.B. Fenster hinzugefügt/entfernt, Fokus geändert).

**Erwartete Ergebnisse/Outputs:**
Eine zentrale, konsistente und thread-sichere State-Management-Struktur für den Wayland-Compositor, die alle notwendigen `smithay`-Komponenten und Anwendungszustände kapselt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion und der korrekten Initialisierung aller Felder.
    * Testen der Implementierung des `smithay::wayland::compositor::State` Trait.
    * Testen der Helper-Methoden wie `add_output`, `set_focused_surface`, `get_active_surface_for_point`.
    * Sicherstellen der Thread-Sicherheit bei der Verwendung von `Mutex` und `RwLock`.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage)

---

### **novade-system/src/compositor/backend.rs**

**Verantwortlichkeit:**
Dieses Modul abstrahiert und initialisiert das konkrete `smithay` Backend, das für die Interaktion mit der Hardware und dem Anzeigesystem zuständig ist. Es wählt je nach Umgebung das passende Backend (z.B. `winit` für Entwicklung, `drm` für direkte Hardware-Interaktion, `egl` für GL-Rendering) und konfiguriert es.

**Kern-Aufgaben (Tasks):**

1.  **Backend-Initialisierung `initialize_backend`:**
    * `pub async fn initialize_backend(compositor_state: Arc<CompositorState>) -> Result<impl Backend, CompositorError>`
    * Identifiziert die Laufzeitumgebung:
        * **`Winit` Backend (für Entwicklung/Tests):**
            * Initialisiert `smithay::backend::winit::WinitEventLoop`.
            * Erstellt `smithay::backend::winit::WinitGraphicsBackend` und den zugehörigen Renderer (z.B. `GlesRenderer` mit EGL).
            * Konfiguriert den `winit` Fenster und den Event-Loop.
            * Fügt den `winit` Output zum `CompositorState` hinzu.
        * **`DRM` Backend (für produktive Systeme):**
            * Initialisiert `smithay::backend::drm::DrmDevice` für den DRM-Gerätepfad (z.B. `/dev/dri/card0`).
            * Scannt für DRM-Connectors und CRTCs.
            * Wählt den primären Connector und CRTC.
            * Initialisiert einen Renderer (z.B. `GlesRenderer` mit EGL oder `WgpuRenderer`).
            * Fügt den DRM-Output zum `CompositorState` hinzu.
            * Implementiert Error-Handling für DRM-spezifische Probleme (z.B. keine GPU gefunden, keine geeigneten Modi).

2.  **Renderer-Initialisierung `initialize_renderer`:**
    * `pub fn initialize_renderer<B: Backend>(backend: &B) -> Result<Box<dyn smithay::backend::renderer::Renderer<Error = anyhow::Error>>, CompositorError>`
    * Konfiguriert und initialisiert den eigentlichen Grafik-Renderer.
    * Optionen: `GlesRenderer` (via `EGL`), `WgpuRenderer` (wenn `wgpu` Feature aktiviert).
    * Stellt sicher, dass der Renderer zum gewählten Backend passt.
    * Gibt einen `Box<dyn Renderer>` zurück.

3.  **Event-Loop-Integration:**
    * `pub fn run_event_loop<B: Backend + 'static>(event_loop: B::EventLoop, compositor_state: Arc<CompositorState>) -> Result<(), CompositorError>`
    * Startet den Haupt-Event-Loop des Backends.
    * Verarbeitet `backend::BackendEvent`s:
        * `Frame`: Auslösen des Renderns.
        * `Input`: Weiterleitung an `CompositorState` zur Verarbeitung.
        * `DeviceAdded`/`DeviceRemoved`: Aktualisierung der `InputService` und `CompositorState`.
        * `OutputAdded`/`OutputRemoved`: Aktualisierung der `CompositorState`.
        * `CloseRequested`: Beenden des Compositors.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/backend.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::state::CompositorState`
    * `crate::compositor::error::CompositorError`
    * `crate::compositor::outputs`
    * `novade-system::input::service::InputService` (wenn `InputService` aus dem Backend Events empfängt)
* **Extern:**
    * `smithay::backend::{self, winit, drm, renderer, allocator, egl, gles}`
        * `smithay::backend::Backend`
        * `smithay::backend::renderer::{Renderer, Frame}`
        * `smithay::reexports::{calloop}`
    * `tokio`
    * `tracing`
    * `anyhow` (für generische Renderer-Fehler)
    * `std::sync::Arc`
    * `parking_lot::Mutex`

**Kommunikationsmuster:**

* **Initialisiert und hält den `CompositorState`.**
* **Interagiert direkt mit `smithay::backend` um Events zu empfangen und zu rendern.**
* **Sendet Rendering-Anforderungen an den Renderer.**

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes `smithay` Backend, das bereit ist, Compositor-Events zu verarbeiten und grafische Ausgaben zu rendern. Der Compositor ist in der Lage, sich an verschiedene Hardware-Umgebungen anzupassen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `initialize_backend` Funktion mit Mock-Umgebungen (z.B. simulierte `DRM` Geräte oder `winit` Fenster).
    * Testen der `initialize_renderer` Funktion, um sicherzustellen, dass der korrekte Renderer initialisiert wird.
    * Mocken des `smithay::backend::EventLoop` um die Event-Verarbeitung zu simulieren.
* **Integration Tests:**
    * Starten des Compositors mit dem `winit` Backend und visueller Überprüfung.
    * Falls möglich, Integrationstests mit einem emulierten `DRM` Backend.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da die Komplexität der Backend-Initialisierung und Fehlerbehandlung, insbesondere bei DRM, hoch ist)

---

### **novade-system/src/compositor/xdg_shell.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert die `xdg_shell` Wayland-Protokoll-Spezifikation und ist für die Verwaltung von Top-Level-Fenstern (typische Desktop-Anwendungen) zuständig. Es behandelt deren Lebenszyklen, Zustandsänderungen (Maximieren, Minimieren, Vollbild), Größenanpassungen und Fokusmanagement.

**Kern-Aufgaben (Tasks):**

1.  **`XdgToplevelSurface` Struktur:**
    * Definiere eine Struktur, die eine `xdg_shell::ToplevelSurface` und deren zugehörigen Client-Status kapselt.
    * Felder:
        * `toplevel_surface: xdg_shell::ToplevelSurface`
        * `window_id: WindowId` (interne NovaDE WindowId)
        * `current_geometry: Mutex<Rectangle<i32, Logical>>` (aktuelle Position und Größe)
        * `pending_state: Mutex<Option<xdg_shell::ToplevelSurfaceConfigure>>` (Konfigurationen, die noch vom Client bestätigt werden müssen)
        * `is_mapped: AtomicBool` (ob die Oberfläche gemappt ist)
        * `is_active: AtomicBool` (ob die Oberfläche den Fokus hat)
        * `client_id: ClientId` (Eindeutige ID des Wayland-Clients)
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`.

2.  **`xdg_shell::XdgShellHandler` Trait Implementierung für `CompositorState`:**
    * `xdg_shell_state(&self) -> &XdgShellState`: Zugriff auf den `xdg_shell` Zustand.
    * `new_toplevel(&mut self, surface: xdg_shell::ToplevelSurface)`:
        * Erstellt eine neue `XdgToplevelSurface` Instanz.
        * Fügt sie zur `window_map` in `CompositorState` hinzu.
        * Informiert `DesktopState` über das neue Fenster.
    * `new_popup(&mut self, surface: xdg_shell::PopupSurface)`:
        * Implementiert Logik für Popups (z.B. Menüs, Tooltips).
        * Behandelt Fokus und Positionierung relativ zum Parent.
    * `xdg_shell_activated(&mut self, surface: &xdg_shell::ToplevelSurface, serial: u32)`:
        * Setzt den Fokus auf die angegebene Oberfläche.
        * Aktualisiert den `is_active` Status.
        * Informiert `DesktopState` über den Fokuswechsel.
    * `xdg_shell_configure(&mut self, surface: &xdg_shell::ToplevelSurface, configure: xdg_shell::ToplevelSurfaceConfigure, serial: u32)`:
        * Sendet Konfigurations-Events an den Client (Größe, Zustand).
        * Speichert die Konfiguration in `pending_state`.
    * `xdg_shell_ack_configure(&mut self, surface: &xdg_shell::ToplevelSurface, serial: u32)`:
        * Bestätigt eine ausstehende Konfiguration vom Client.
        * Aktualisiert die `current_geometry`.

3.  **`xdg_shell::XdgSurfaceHandler` Trait Implementierung für `CompositorState`:**
    * `map(&mut self, surface: &xdg_shell::XdgSurface)`:
        * Wird aufgerufen, wenn ein Client seine Oberfläche mappt (sichtbar macht).
        * Setzt `is_mapped` auf `true`.
        * Ordnet dem Fenster eine Position zu und gibt es für das Rendering frei.
    * `unmap(&mut self, surface: &xdg_shell::XdgSurface)`:
        * Wird aufgerufen, wenn ein Client seine Oberfläche unmappt (unsichtbar macht).
        * Setzt `is_mapped` auf `false`.
        * Entfernt das Fenster vom Compositor-Rendering.
    * `destroy(&mut self, surface: &xdg_shell::XdgSurface)`:
        * Wird aufgerufen, wenn ein Client seine Oberfläche zerstört.
        * Entfernt die `XdgToplevelSurface` aus der `window_map`.
        * Informiert `DesktopState` über das Schließen des Fensters.
    * `commit(&mut self, surface: &xdg_shell::XdgSurface)`:
        * Wird aufgerufen, wenn ein Client Änderungen an seiner Oberfläche committet.
        * Veranlasst ein erneutes Rendering der Oberfläche.
        * Verarbeitet Buffer-Updates und Subsurfaces.

4.  **Helper-Funktionen:**
    * `send_configure_to_client(...)`: Sendet eine `xdg_shell::ToplevelSurfaceConfigure` an den Client.
    * `get_toplevel_surface_from_surface_data(...)`: Helferfunktion, um `XdgToplevelSurface` aus `smithay` Surface Data zu extrahieren.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/xdg_shell.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::state::CompositorState`
    * `crate::compositor::error::CompositorError`
    * `novade-core::types::window::WindowId`
    * `novade-core::types::geometry::{Rectangle, Logical}`
    * `novade-domain::desktop_state::DesktopState`
* **Extern:**
    * `smithay::wayland::xdg_shell::{self, XdgShellState, ToplevelSurface, PopupSurface, XdgSurface, ToplevelSurfaceConfigure}`
    * `smithay::wayland::compositor::SurfaceData`
    * `smithay::utils::Rectangle`
    * `parking_lot::Mutex`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `std::sync::atomic::{AtomicBool, Ordering}`
    * `tracing`

**Kommunikationsmuster:**

* **Von `smithay` Event-Loop:** Empfängt `xdg_shell` spezifische Events (z.B. `new_toplevel`, `commit`).
* **An `CompositorState`:** Ruft Methoden auf `CompositorState` auf, um den globalen Compositor-Zustand zu aktualisieren.
* **An Wayland Clients:** Sendet `configure` Events und andere Protokoll-Nachrichten.
* **An `DesktopState`:** Informiert `DesktopState` über Änderungen im Fensterzustand (Erstellung, Zerstörung, Fokus, Größenänderung).

**Erwartete Ergebnisse/Outputs:**
Eine vollständige und korrekte Implementierung des `xdg_shell` Protokolls, die es Wayland-Anwendungen ermöglicht, ihre Top-Level-Fenster zu verwalten und mit dem Compositor zu interagieren.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken von `xdg_shell::ToplevelSurface` und `CompositorState` um die `XdgShellHandler` Methoden zu testen.
    * Testen der `new_toplevel`, `map`, `unmap`, `destroy` Logik.
    * Verifizieren der korrekten Zustandsänderungen in `XdgToplevelSurface` und `CompositorState`.
    * Testen der `configure` und `ack_configure` Mechanismen, um sicherzustellen, dass Clients korrekte Konfigurationen erhalten und bestätigen.
* **Integration Tests:**
    * Starten des Compositors mit einem `winit` Backend.
    * Starten von `xdg_shell`-kompatiblen Wayland-Clients (z.B. `alacritty`, `gnome-calculator`).
    * Manuelles oder automatisiertes Testen von Fensteraktionen (Größe ändern, verschieben, minimieren, maximieren, schließen) und Beobachten des Verhaltens.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage)

---

### **novade-system/src/compositor/layer_shell.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert die `wlr_layer_shell` Wayland-Protokoll-Spezifikation. Es ist zuständig für die Verwaltung von "Layer-Shell"-Oberflächen, die spezielle Desktop-Elemente wie Panels, Docks, Desktophintergründe und Lock-Screens darstellen. Diese Oberflächen werden in bestimmten "Layern" (z.B. Background, Bottom, Top, Overlay) platziert und haben fixe Positionen und Größen.

**Kern-Aufgaben (Tasks):**

1.  **`LayerSurface` Struktur:**
    * Definiere eine Struktur, die eine `wlr_layer_shell::LayerSurface` und deren zugehörigen Client-Status kapselt.
    * Felder:
        * `layer_surface: wlr_layer_shell::LayerSurface`
        * `layer_id: LayerId` (eindeutige ID für diese Layer-Oberfläche)
        * `current_geometry: Mutex<Rectangle<i32, Logical>>` (aktuelle Position und Größe)
        * `current_layer: Mutex<wlr_layer_shell::Layer>` (aktuelle Layer-Zuweisung: Background, Bottom, Top, Overlay)
        * `is_mapped: AtomicBool` (ob die Oberfläche gemappt ist)
        * `client_id: ClientId` (Eindeutige ID des Wayland-Clients)
        * `namespace: String` (der von der Client-Anwendung definierte Namespace, z.B. "nova-panel")
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`.

2.  **`wlr_layer_shell::WlrLayerShellHandler` Trait Implementierung für `CompositorState`:**
    * `layer_shell_state(&self) -> &LayerShellState`: Zugriff auf den `wlr_layer_shell` Zustand.
    * `new_layer_surface(&mut self, surface: wlr_layer_shell::LayerSurface)`:
        * Erstellt eine neue `LayerSurface` Instanz.
        * Fügt sie zur `layer_map` in `CompositorState` hinzu.
        * Informiert `DesktopState` über die neue Layer-Oberfläche.
        * Initialisiert die Positionierung und Größe basierend auf den `layer_surface` Angaben (anchors, exclusive zone).
    * `layer_shell_configure(&mut self, surface: &wlr_layer_shell::LayerSurface, configure: wlr_layer_shell::LayerSurfaceConfigure, serial: u32)`:
        * Sendet Konfigurations-Events an den Client (Größe, Position, serial).
        * Clients müssen diese Konfigurationen bestätigen.
    * `layer_shell_ack_configure(&mut self, surface: &wlr_layer_shell::LayerSurface, serial: u32)`:
        * Bestätigt eine ausstehende Konfiguration vom Client.
        * Aktualisiert die `current_geometry`.

3.  **`wlr_layer_shell::LayerSurfaceHandler` Trait Implementierung für `CompositorState`:**
    * `map(&mut self, surface: &wlr_layer_shell::LayerSurface)`:
        * Wird aufgerufen, wenn ein Client seine Layer-Oberfläche mappt.
        * Setzt `is_mapped` auf `true`.
        * Berechnet die finale Position und Größe basierend auf Ankerpunkten und exklusiven Zonen.
        * Gibt die Oberfläche für das Rendering frei.
    * `unmap(&mut self, surface: &wlr_layer_shell::LayerSurface)`:
        * Wird aufgerufen, wenn ein Client seine Oberfläche unmappt.
        * Setzt `is_mapped` auf `false`.
        * Entfernt die Oberfläche vom Compositor-Rendering.
    * `destroy(&mut self, surface: &wlr_layer_shell::LayerSurface)`:
        * Wird aufgerufen, wenn ein Client seine Oberfläche zerstört.
        * Entfernt die `LayerSurface` aus der `layer_map`.
        * Informiert `DesktopState` über das Entfernen der Layer-Oberfläche.
    * `commit(&mut self, surface: &wlr_layer_shell::LayerSurface)`:
        * Wird aufgerufen, wenn ein Client Änderungen an seiner Oberfläche committet.
        * Veranlasst ein erneutes Rendering der Oberfläche.
        * Verarbeitet Buffer-Updates und Subsurfaces.
        * Überprüft, ob sich die `layer` oder `anchors` geändert haben und passt die Positionierung ggf. an.

4.  **Helper-Funktionen:**
    * `arrange_layers_on_output(...)`: Funktion zur Anordnung aller Layer-Oberflächen auf einem bestimmten Output, unter Berücksichtigung von Ankern und exklusiven Zonen.
    * `calculate_exclusive_zone(...)`: Berechnet die exklusive Zone, die von Panels belegt wird, um Platz für `xdg_shell` Fenster zu schaffen.
    * `send_configure_to_client(...)`: Sendet eine `wlr_layer_shell::LayerSurfaceConfigure` an den Client.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/layer_shell.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::state::CompositorState`
    * `crate::compositor::error::CompositorError`
    * `crate::compositor::outputs::{OutputId}`
    * `novade-core::types::geometry::{Rectangle, Logical, Size, Point}`
    * `novade-domain::desktop_state::DesktopState`
* **Extern:**
    * `smithay::wayland::wlr_layer_shell::{self, LayerShellState, LayerSurface, Layer, Anchor, KeyboardInteractivity, LayerSurfaceConfigure}`
    * `smithay::wayland::compositor::SurfaceData`
    * `smithay::utils::Rectangle`
    * `parking_lot::Mutex`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `std::sync::atomic::{AtomicBool, Ordering}`
    * `tracing`

**Kommunikationsmuster:**

* **Von `smithay` Event-Loop:** Empfängt `wlr_layer_shell` spezifische Events (z.B. `new_layer_surface`, `commit`).
* **An `CompositorState`:** Ruft Methoden auf `CompositorState` auf, um den globalen Compositor-Zustand zu aktualisieren.
* **An Wayland Clients:** Sendet `configure` Events und andere Protokoll-Nachrichten.
* **An `DesktopState`:** Informiert `DesktopState` über Änderungen in Layer-Oberflächen (Erstellung, Zerstörung, Positionierung).

**Erwartete Ergebnisse/Outputs:**
Eine vollständige und korrekte Implementierung des `wlr_layer_shell` Protokolls, die es Clients ermöglicht, Panels, Docks, Hintergründe etc. korrekt anzuzeigen und mit dem Compositor zu interagieren.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken von `wlr_layer_shell::LayerSurface` und `CompositorState` um die `WlrLayerShellHandler` Methoden zu testen.
    * Testen der `new_layer_surface`, `map`, `unmap`, `destroy` Logik.
    * Verifizieren der korrekten Zustandsänderungen in `LayerSurface` und `CompositorState`.
    * Testen der Positionierungslogik basierend auf `anchors` und `exclusive_zone` Berechnungen.
    * Testen von `layer_shell_configure` und `layer_shell_ack_configure`.
* **Integration Tests:**
    * Starten des Compositors mit einem `winit` Backend.
    * Starten von `wlr_layer_shell`-kompatiblen Clients (z.B. `waybar`, oder ein NovaDE-Panel-Client).
    * Manuelles oder automatisiertes Testen der korrekten Platzierung, Größenanpassung und Interaktion von Layer-Oberflächen.
    * Überprüfen der Interaktion mit `xdg_shell` Fenstern (z.B. ob Fenster die exklusive Zone von Panels respektieren).

**Geschätzter Aufwand:** Hoch (ca. 6-9 Tage)
### **novade-system/src/compositor/xwayland.rs**

**Verantwortlichkeit:**
Dieses Modul integriert den XWayland-Server in den NovaDE Compositor, um die Kompatibilität mit traditionellen X11-Anwendungen zu gewährleisten. Es verwaltet die Lebenszyklen von X11-Fenstern, übersetzt X11-Protokolle in Wayland-Äquivalente und umgekehrt, und behandelt Eingaben und Rendering für X11-Clients.

**Kern-Aufgaben (Tasks):**

1.  **`XWaylandState` Struktur:**
    * Definiere eine Struktur zur Kapselung des XWayland-Zustands.
    * Felder:
        * `xwm: Arc<Mutex<smithay::xwayland::X11Wm<CompositorState>>>` (Der X11 Window Manager von `smithay`).
        * `display_name: String` (Display-Name für XWayland, z.B. `:1`).
        * `connection: Arc<x11rb::rust_connection::RustConnection>` (X11rb Verbindung zum XWayland Server).
        * `screen_idx: usize` (Index des Screens, den XWayland verwendet).
        * `wm_fd: RawFd` (File-Descriptor für den XWayland WM).
        * `resource_manager: XWaylandResourceManager` (interner Manager für XWayland-Ressourcen wie Atome, Properties).

2.  **Initialisierung `init_xwayland`:**
    * `pub async fn init_xwayland(compositor_state: Arc<CompositorState>) -> Result<XWaylandState, CompositorError>`:
        * Initialisiert `smithay::xwayland::X11Wm`.
        * Startet den XWayland-Server.
        * Erstellt eine X11rb-Verbindung zum XWayland-Server.
        * Registriert X11-Events, die NovaDE abfangen soll (z.B. `MapRequest`, `ConfigureRequest`, `ClientMessage`).
        * Fügt den XWayland `loop_handle` zum `calloop::EventLoop` hinzu.
        * Gibt `XWaylandState` zurück.

3.  **`X11WmHandler` Trait Implementierung für `CompositorState`:**
    * `xwm_state(&self) -> &X11Wm`: Gibt die `X11Wm` Instanz zurück.
    * `new_x11_surface(&mut self, surface: smithay::xwayland::X11Surface)`:
        * Wird aufgerufen, wenn ein neuer X11-Client eine Oberfläche erstellt.
        * Erstellt eine interne Repräsentation für das X11-Fenster (ähnlich `XdgToplevelSurface`).
        * Fügt es zur `window_map` in `CompositorState` hinzu.
        * Informiert `DesktopState` über das neue X11-Fenster.
    * `x11_surface_map_request(&mut self, surface: &smithay::xwayland::X11Surface)`:
        * Wird aufgerufen, wenn ein X11-Client das Fenster mappen möchte.
        * Bestimmt die Initialposition und Größe des Fensters.
        * Erlaubt das Mapping des Fensters.
        * Setzt das Fenster als gemappt.
    * `x11_surface_unmap_request(&mut self, surface: &smithay::xwayland::X11Surface)`:
        * Wird aufgerufen, wenn ein X11-Client das Fenster unmappen möchte.
        * Setzt das Fenster als ungemappt.
    * `x11_surface_configure_request(&mut self, surface: &smithay::xwayland::X11Surface, configure: smithay::xwayland::X11SurfaceConfigure)`:
        * Behandelt Größen- und Positionsanfragen von X11-Clients.
        * Wendet die Konfiguration auf das Fenster an.
        * Sendet `ConfigureNotify` Event zurück an den Client.
    * `x11_surface_set_active(&mut self, surface: &smithay::xwayland::X11Surface)`:
        * Setzt den Fokus auf das X11-Fenster.
        * Informiert `DesktopState` über den Fokuswechsel.
    * `x11_surface_set_geometry(&mut self, surface: &smithay::xwayland::X11Surface, new_geometry: Rectangle<i32, Logical>)`:
        * Aktualisiert die Geometrie des X11-Fensters.
    * `x11_surface_closed(&mut self, surface: &smithay::xwayland::X11Surface)`:
        * Wird aufgerufen, wenn ein X11-Fenster geschlossen wird.
        * Entfernt das Fenster aus der `window_map`.
        * Informiert `DesktopState` über das Schließen.
    * `x11_surface_restacked(&mut self, surface: &smithay::xwayland::X11Surface)`:
        * Behandelt Z-Order-Änderungen.
        * Aktualisiert die Fenster-Z-Order im Compositor-Zustand.

4.  **Helper-Funktionen und `XWaylandResourceManager`:**
    * Funktionen zum Abrufen von X11-Atomen (z.B. `_NET_WM_STATE`, `_NET_WM_WINDOW_TYPE`).
    * Funktionen zum Setzen von X11-Fenstereigenschaften.
    * Übersetzungsfunktionen zwischen X11-Keysyms und Wayland KeyCodes.

**Spezifische ArteFakte/Dateien:**

* `novade-system/src/compositor/xwayland.rs`
* `novade-system/src/compositor/xwayland/data_types.rs` (für X11-Fensterrepräsentation)
* `novade-system/src/compositor/xwayland/resource_manager.rs` (für X11-Atome und Properties)

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::state::CompositorState`
    * `crate::compositor::error::CompositorError`
    * `novade-core::types::window::WindowId`
    * `novade-core::types::geometry::{Rectangle, Logical}`
    * `novade-domain::desktop_state::DesktopState`
* **Extern:**
    * `smithay::xwayland::{self, X11Wm, X11Surface, X11WmHandler, X11SurfaceConfigure}`
    * `smithay::reexports::{calloop, x11rb}`
    * `x11rb::{rust_connection::RustConnection, connection::Connection, protocol::xproto, cursor}`
    * `tokio`
    * `parking_lot::Mutex`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `std::os::unix::io::RawFd`
    * `tracing`

**Kommunikationsmuster:**

* **Von `smithay::xwayland`:** Empfängt X11-spezifische Events und Anfragen.
* **An `CompositorState`:** Aktualisiert den globalen Compositor-Zustand (Fenster hinzufügen/entfernen, Fokus).
* **An X11-Clients:** Sendet X11-Events (z.B. `ConfigureNotify`) und antwortet auf Anfragen.
* **An `DesktopState`:** Informiert über X11-Fensteraktionen (Erstellung, Zerstörung, Fokus).

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger XWayland-Server, der nahtlos in den NovaDE Compositor integriert ist, sodass X11-Anwendungen korrekt gerendert und bedient werden können.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken von `X11Wm` und `CompositorState` um die `X11WmHandler` Methoden zu testen.
    * Testen der Lebenszyklen von X11-Fenstern (Erstellung, Mapping, Unmapping, Zerstörung).
    * Verifizieren der korrekten Geometrie- und Zustandsänderungen.
    * Testen der Atom- und Property-Verwaltung in `XWaylandResourceManager`.
* **Integration Tests:**
    * Starten des Compositors mit XWayland aktiviert.
    * Starten verschiedener X11-Clients (z.B. `xterm`, `xeyes`, `xfce4-panel`).
    * Manuelles oder automatisiertes Testen von Fensteraktionen (Größe ändern, verschieben, minimieren, maximieren, schließen) und Beobachten des Verhaltens.
    * Überprüfen der Eingabe-Weiterleitung an X11-Clients.
    * Visuelle Überprüfung der Darstellung.

**Geschätzter Aufwand:** Sehr hoch (ca. 8-12 Tage, XWayland ist komplex und erfordert detaillierte Protokoll-Implementierung)

---

### **novade-system/src/compositor/outputs.rs**

**Verantwortlichkeit:**
Dieses Modul verwaltet die Anzeigemonitore (Outputs) des Systems. Es ist zuständig für deren Erkennung, Konfiguration (Auflösung, Bildwiederholrate, Skalierung), Positionierung in einem Multi-Monitor-Setup und das Senden von `wl_output` Events an Wayland-Clients.

**Kern-Aufgaben (Tasks):**

1.  **`OutputId` Typalias:**
    * Definiere `pub type OutputId = String;` oder `pub type OutputId = Uuid;` für eine eindeutige Identifikation eines Outputs.

2.  **`OutputManager` Struktur:**
    * (Optional, kann auch direkt in `CompositorState` verwaltet werden, aber eine separate Struktur für die Logik ist sauberer).
    * Felder:
        * `outputs: Mutex<HashMap<OutputId, smithay::wayland::output::Output>>`
        * `display_handle: smithay::wayland::DisplayHandle`
        * `loop_handle: calloop::LoopHandle<'static, CompositorState>` (für Event-Scheduling).

3.  **`OutputManager::new()` Funktion:**
    * Erstellt eine neue `OutputManager` Instanz.

4.  **`add_output` Funktion:**
    * `pub fn add_output(compositor_state: &mut CompositorState, backend_output: &impl smithay::backend::renderer::Output, config: OutputConfiguration) -> Result<(), CompositorError>`
    * Erstellt einen neuen `smithay::wayland::output::Output`.
    * Fügt ihn zur `outputs` HashMap in `CompositorState` hinzu.
    * Setzt den Modus (Auflösung, Bildwiederholrate) und die Skalierung für den Output.
    * Registriert den Output als Wayland Global.
    * Sendet initiale `Output` Events an Wayland-Clients.
    * Informiert `DesktopState` über den neuen Output.

5.  **`remove_output` Funktion:**
    * `pub fn remove_output(compositor_state: &mut CompositorState, output_id: &OutputId) -> Result<(), CompositorError>`
    * Entfernt den Output aus der `outputs` HashMap.
    * Zerstört das Wayland Global für diesen Output.
    * Informiert `DesktopState` über das Entfernen.

6.  **`set_output_mode` Funktion:**
    * `pub fn set_output_mode(compositor_state: &mut CompositorState, output_id: &OutputId, mode: OutputMode) -> Result<(), CompositorError>`
    * Aktualisiert den Modus (Auflösung, Refresh Rate) eines Outputs.
    * Sendet `mode` und `done` Events an die Clients.
    * Aktualisiert die Output-Konfiguration im `smithay` Backend.

7.  **`set_output_scale` Funktion:**
    * `pub fn set_output_scale(compositor_state: &mut CompositorState, output_id: &OutputId, scale: f64) -> Result<(), CompositorError>`
    * Aktualisiert die Skalierung eines Outputs.
    * Sendet `scale` und `done` Events an die Clients.

8.  **`set_output_position` Funktion:**
    * `pub fn set_output_position(compositor_state: &mut CompositorState, output_id: &OutputId, position: Point<i32, Logical>) -> Result<(), CompositorError>`
    * Aktualisiert die Position eines Outputs in einem Multi-Monitor-Setup.
    * Sendet `position` und `done` Events an die Clients.

9.  **`OutputConfiguration` Struktur:**
    * Eine Struktur zur Beschreibung der gewünschten Output-Konfiguration.
    * Felder: `mode: OutputMode`, `scale: f64`, `position: Point<i32, Logical>`.

10. **`OutputMode` Struktur:**
    * Kapselt Auflösung und Refresh Rate.
    * Felder: `size: Size<i32, Physical>`, `refresh_rate_mhz: i33`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/outputs.rs`
* `novade-system/src/compositor/outputs/data_types.rs` (für `OutputConfiguration`, `OutputMode`)

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::state::CompositorState`
    * `crate::compositor::error::CompositorError`
    * `novade-core::types::geometry::{Size, Point, Logical, Physical}`
    * `novade-domain::desktop_state::DesktopState`
* **Extern:**
    * `smithay::wayland::output::{self, Output}`
    * `smithay::backend::renderer::{Output as BackendOutput}`
    * `smithay::utils::{Size, Point, Logical, Physical}`
    * `smithay::reexports::calloop`
    * `parking_lot::Mutex`
    * `std::collections::HashMap`
    * `uuid::Uuid` (wenn `OutputId` als UUID verwendet wird)
    * `tracing`

**Kommunikationsmuster:**

* **An `CompositorState`:** Fügt Outputs hinzu/entfernt sie, aktualisiert deren Zustand.
* **An `smithay::wayland::output`:** Nutzt `smithay` APIs zur Verwaltung von Wayland Outputs.
* **An Wayland Clients:** Sendet Output-spezifische Events.
* **An `DesktopState`:** Informiert über Änderungen in der Output-Konfiguration (hinzugefügt, entfernt, geändert).

**Erwartete Ergebnisse/Outputs:**
Ein robuster Output-Manager, der die angeschlossenen Displays korrekt erkennt, konfiguriert und deren Zustand an Wayland-Clients kommuniziert, um eine reibungslose Multi-Monitor-Nutzung zu gewährleisten.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken von `CompositorState` und `smithay::wayland::output::Output`.
    * Testen der `add_output`, `remove_output`, `set_output_mode`, `set_output_scale`, `set_output_position` Funktionen.
    * Verifizieren, dass die korrekten Parameter an die `smithay::wayland::output::Output` Methoden übergeben werden.
    * Testen der Aktualisierung der `outputs` HashMap.
* **Integration Tests:**
    * Starten des Compositors mit einem `winit` Backend, das mehrere virtuelle Outputs simulieren kann.
    * Oder mit einem `drm` Backend mit mehreren angeschlossenen Monitoren.
    * Konfiguration der Outputs (Auflösung, Position, Skalierung) über ein Test-Tool oder manuell.
    * Überprüfen, ob Wayland-Clients die korrekte Output-Konfiguration erhalten und ihr Verhalten entsprechend anpassen.
    * Visuelle Überprüfung der Multi-Monitor-Anordnung.

**Geschätzter Aufwand:** Mittel (ca. 4-6 Tage)

---

### **novade-system/src/compositor/renderer.rs**

**Verantwortlichkeit:**
Dieses Modul enthält Helferfunktionen und Logik für das Rendering der Compositor-Szene unter Verwendung des `smithay` Renderers. Es kümmert sich um das Durchlaufen der Oberflächenhierarchie, das Zeichnen von Fenstern und Overlays und die Optimierung des Renderings.

**Kern-Aufgaben (Tasks):**

1.  **Funktion `render_scene`:**
    * `pub fn render_scene<R>(renderer: &mut R, outputs: &HashMap<OutputId, smithay::wayland::output::Output>, window_map: &HashMap<WindowId, Arc<Mutex<XdgToplevelSurface>>>, layer_map: &HashMap<LayerId, Arc<Mutex<LayerSurface>>>, active_output_id: &OutputId) -> Result<(), CompositorError>`
    * Nimmt den `smithay` Renderer, die Output-Map, Fenster- und Layer-Maps entgegen.
    * Iteriert über jeden Output:
        * Startet einen Rendering-Frame für den Output (`renderer.render(...)`).
        * **Hintergrund:** Zeichnet den Desktop-Hintergrund (Farbe oder Bild, von `WallpaperManagerService`).
        * **Layer "Background":** Rendert alle `wlr_layer_shell` Oberflächen im `Background` Layer.
        * **Layer "Bottom":** Rendert alle `wlr_layer_shell` Oberflächen im `Bottom` Layer.
        * **XDG Toplevel Fenster:** Rendert alle `xdg_shell` und XWayland Fenster.
            * Berücksichtigt die Z-Ordnung (Fokus-Reihenfolge).
            * Wendet Transformationen und Skalierung an.
            * Rendert optional Fenster-Dekorationen (Client-Side oder Server-Side).
        * **Layer "Top":** Rendert alle `wlr_layer_shell` Oberflächen im `Top` Layer.
        * **Cursor:** Rendert den Hardware- oder Software-Cursor.
        * **Layer "Overlay":** Rendert alle `wlr_layer_shell` Oberflächen im `Overlay` Layer (z.B. Lockscreen).
        * **Debug-Overlays:** Optionales Rendern von Debug-Informationen (FPS, Leistungsindikatoren).
        * Beendet den Frame (`renderer.finish()`).

2.  **Funktion `render_surface`:**
    * `pub fn render_surface<R>(renderer: &mut R, surface: &smithay::wayland::compositor::Surface, scale: f64, location: Point<i32, Physical>) -> Result<(), CompositorError>`
    * Eine Helper-Funktion zum rekursiven Rendern einer einzelnen Wayland-Oberfläche und ihrer Subsurfaces.
    * Nutzt `smithay::backend::renderer::Renderer::render_texture` oder ähnliches.
    * Beachtet die `buffer` und `damage_regions` für effizientes Rendering.

3.  **Cursor-Rendering:**
    * `pub fn render_cursor<R>(renderer: &mut R, cursor_image: &smithay::backend::renderer::Texture, hotspot: Point<i32, Physical>, output_location: Point<i32, Physical>) -> Result<(), CompositorError>`: Rendert den Maus-Cursor.

4.  **Damage Tracking:**
    * Integriert `smithay::utils::damage::DamageTracker` oder ähnliche Mechanismen, um nur die veränderten Regionen des Bildschirms neu zu rendern.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/renderer.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::state::CompositorState`
    * `crate::compositor::error::CompositorError`
    * `crate::compositor::xdg_shell::XdgToplevelSurface`
    * `crate::compositor::layer_shell::LayerSurface`
    * `crate::compositor::outputs::OutputId`
    * `novade-core::types::geometry::{Rectangle, Point, Logical, Physical}`
    * `novade-domain::wallpaper_manager::WallpaperManagerService` (indirekt über `DesktopState` oder direkten Service-Aufruf für Hintergrundbild)
* **Extern:**
    * `smithay::backend::renderer::{Renderer, Texture, Frame}`
    * `smithay::wayland::output::Output`
    * `smithay::wayland::compositor::{Surface, SurfaceData}`
    * `smithay::utils::{Rectangle, Point, Logical, Physical, Scale}`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `parking_lot::Mutex`
    * `tracing`

**Kommunikationsmuster:**

* **Vom `backend` Modul:** Wird von der Haupt-Event-Loop des Compositors (z.B. im `WinitGraphicsBackend` oder `DrmDevice`) aufgerufen, wenn ein `Frame` Event empfangen wird.
* **An `smithay` Renderer:** Nutzt die Methoden des `smithay::backend::renderer::Renderer` Traits für die eigentliche Zeichenoperation.
* **An `CompositorState`:** Liest den aktuellen Zustand der Fenster, Layer und Outputs.

**Erwartete Ergebnisse/Outputs:**
Ein effizientes Rendering der gesamten Desktop-Oberfläche, das alle Fenster, Panels, den Hintergrund und den Cursor korrekt darstellt und Optimierungen wie Damage Tracking nutzt, um die GPU-Auslastung zu minimieren.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken des `smithay` Renderers, der `CompositorState` und der Oberflächen (XdgToplevelSurface, LayerSurface).
    * Testen, ob `render_scene` die Oberflächen in der korrekten Reihenfolge und auf dem richtigen Output rendert.
    * Testen der `render_surface` Funktion, um sicherzustellen, dass Subsurfaces rekursiv gerendert werden.
    * Verifizieren, dass Damage Regions korrekt berücksichtigt werden (obwohl der Renderer selbst dies verwaltet, kann man testen, ob die Anweisungen korrekt übergeben werden).
* **Integration Tests:**
    * Starten des Compositors mit Test-Clients (XDG-Shell und Layer-Shell).
    * Visuelle Überprüfung des Renderings: Fenster-Stapelung, Transparenz, Cursor, Hintergrundbild.
    * Performance-Messungen, um die Effizienz des Renderings zu bewerten.

**Geschätzter Aufwand:** Hoch (ca. 6-8 Tage, Rendering-Logik und Optimierung sind anspruchsvoll)

---

### **novade-system/src/compositor/events.rs**

**Verantwortlichkeit:**
Dieses Modul definiert interne Compositor-spezifische Ereignisse, die verwendet werden, um Änderungen im Compositor-Zustand zwischen verschiedenen Teilen des `compositor`-Moduls oder an die Domänenschicht zu kommunizieren.

**Kern-Aufgaben (Tasks):**

1.  **`CompositorEvent` Enum Definition:**
    * Definiere ein Enum `CompositorEvent` zur Kapselung aller relevanten Compositor-Ereignisse.
    * Varianten:
        * `SurfaceMapped { window_id: WindowId, client_id: ClientId }`: Eine Oberfläche wurde gemappt (sichtbar).
        * `SurfaceUnmapped { window_id: WindowId, client_id: ClientId }`: Eine Oberfläche wurde ungemappt (unsichtbar).
        * `SurfaceDestroyed { window_id: WindowId, client_id: ClientId }`: Eine Oberfläche wurde zerstört.
        * `SurfaceActivated { window_id: WindowId, client_id: ClientId }`: Eine Oberfläche hat den Fokus erhalten.
        * `SurfaceDeactivated { window_id: WindowId, client_id: ClientId }`: Eine Oberfläche hat den Fokus verloren.
        * `SurfaceResized { window_id: WindowId, client_id: ClientId, new_geometry: Rectangle<i32, Logical> }`: Eine Oberfläche wurde in der Größe geändert.
        * `OutputAdded { output_id: OutputId, current_mode: OutputMode }`: Ein neuer Monitor wurde erkannt.
        * `OutputRemoved { output_id: OutputId }`: Ein Monitor wurde entfernt.
        * `OutputConfigured { output_id: OutputId, new_config: OutputConfiguration }`: Ein Monitor wurde konfiguriert (Auflösung, Skalierung, Position).
        * `XWaylandStarted`: XWayland wurde erfolgreich gestartet.
        * `XWaylandStopped`: XWayland wurde beendet.
        * `FrameRendered { output_id: OutputId, duration_ms: u64 }`: Ein Rendering-Frame wurde abgeschlossen (für Performance-Monitoring).
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Eq`, `Serialize`, `Deserialize`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/events.rs`

**Abhängigkeiten:**

* **Intern:**
    * `novade-core::types::window::WindowId`
    * `novade-core::types::geometry::{Rectangle, Logical}`
    * `crate::compositor::outputs::{OutputId, OutputMode, OutputConfiguration}`
    * (Optional: `novade-core::types::ClienttId` falls definiert.)
* **Extern:**
    * `serde::{Serialize, Deserialize}`

**Kommunikationsmuster:**

* **Intern (`compositor` module):** Die verschiedenen Sub-Module (z.B. `xdg_shell`, `layer_shell`, `outputs`, `xwayland`) senden diese Events an den zentralen `CompositorState` oder direkt an einen `broadcast::Sender`.
* **An Domänenschicht (`DesktopState`):** Der `DesktopState` der Domänenschicht abonniert einen `broadcast::Receiver<CompositorEvent>` um über relevante UI-Zustandsänderungen informiert zu werden (z.B. Fenster-Lebenszyklen, Output-Konfiguration).

**Erwartete Ergebnisse/Outputs:**
Ein klar definiertes Set von Ereignissen, das die Kommunikation innerhalb des Compositor-Moduls und zwischen Compositor und Domänenschicht standardisiert und entkoppelt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Serialize`, `Deserialize` Implementierungen für alle Event-Varianten.
    * Verifizieren, dass Events mit den korrekten Daten erstellt werden können.

**Geschätzter Aufwand:** Gering (ca. 0.5-1 Tag)

---

### **novade-system/src/compositor/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`CompositorError`) für das `compositor`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung innerhalb des Compositors sicher und ermöglicht eine präzise Fehlerweiterleitung.

**Kern-Aufgaben (Tasks):**

1.  **`CompositorError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `InitializationError(String)`: Fehler bei der Initialisierung des Compositors oder seiner Backends (z.B. `smithay` Context, Renderer, Allocator).
        * `BackendError(#[from] smithay::backend::SwapBuffersError)`: Fehler beim Swappen von Buffern (Rendering-Fehler).
        * `DrmError(#[from] smithay::reexports::drm_rs::Error)`: DRM-spezifische Fehler.
        * `EglError(String)`: Fehler bei der EGL-Initialisierung oder Nutzung.
        * `X11rbError(#[from] x11rb::rust_connection::ConnectionError)`: Fehler in der X11rb-Verbindung (für XWayland).
        * `XWaylandError(String)`: Allgemeine XWayland-spezifische Fehler.
        * `OutputConfigurationError(String)`: Fehler bei der Konfiguration eines Monitors.
        * `SurfaceNotFoundError(String)`: Eine angeforderte Oberfläche wurde nicht gefunden.
        * `ProtocolError(String)`: Allgemeine Wayland-Protokollfehler.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/error.rs`

**Abhängigkeiten:**

* **Intern:** Keine direkten Abhängigkeiten.
* **Extern:**
    * `thiserror::Error`
    * `smithay::backend::SwapBuffersError`
    * `smithay::reexports::drm_rs::Error`
    * `x11rb::rust_connection::ConnectionError`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `compositor`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im Compositor-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `CompositorError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---
### **novade-system/src/input**

**Verantwortlichkeit:**
Das `input`-Modul ist für die gesamte Eingabeverarbeitung in NovaDE zuständig. Es integriert `libinput` zur Erkennung und Verarbeitung von Eingabegeräten (Tastatur, Maus, Touchpad, Touchscreen) und `xkbcommon` für die Tastaturbelegung. Es normalisiert rohe Eingabeereignisse und leitet sie an den Compositor und die Domänenschicht weiter.

**Kern-Aufgaben (Tasks):**

1.  **`InputService` Initialisierung:**
    * Initialisierung des `libinput` Contexts.
    * Initialisierung von `xkbcommon` Context und Keymap.
    * Spawnen eines asynchronen Tasks, der den `libinput` Event-Loop überwacht.

2.  **Geräte-Management:**
    * Erkennung von neuen und entfernten Eingabegeräten.
    * Konfiguration von Geräte-spezifischen Einstellungen (z.B. Mausbeschleunigung, Touchpad-Gesten).
    * Zuordnung von Geräten zu Seats (derzeit ein `default` Seat).

3.  **Event-Verarbeitung:**
    * Empfang roher Events von `libinput` (Tastendrücke, Mausbewegungen, Scrollen, Touch-Events, Gesten).
    * Übersetzung von Tastatur-Events unter Verwendung von `xkbcommon` (Keycodes zu Unicode, Modifikatoren).
    * Normalisierung aller Events in eine interne `InputEvent`-Struktur.

4.  **Event-Weiterleitung:**
    * Broadcasting von `InputEvent`s an alle interessierten Parteien (Compositor für Client-Weiterleitung, Domänenschicht für globale Shortcuts/Gesten).
    * Bereitstellung von `InputEvent` `tokio::sync::broadcast::Receiver`s.

5.  **Seat-Management:**
    * Implementierung von `smithay::input::SeatState`.
    * Verwaltung von Pointer-, Keyboard- und Touch-Handles.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/mod.rs`
* `novade-system/src/input/service.rs` (Implementierung von `InputService`)
* `novade-system/src/input/handler.rs` (Logik zur Verarbeitung einzelner `libinput` Events)
* `novade-system/src/input/events.rs` (Definition des `InputEvent` Enums)
* `novade-system/src/input/keyboard.rs` (Tastatur-spezifische Logik, `xkbcommon` Integration)
* `novade-system/src/input/pointer.rs` (Maus/Touchpad-Pointer-Logik)
* `novade-system/src/input/touch.rs` (Touchscreen-Logik)
* `novade-system/src/input/gestures.rs` (Gesten-Erkennung und -Verarbeitung)
* `novade-system/src/input/error.rs` (`InputError` Enum)

**Abhängigkeiten:**

* **Intern:**
    * `novade-core::error::CoreError`
    * `novade-core::types::input::{InputEvent, KeyState, ButtonState, ScrollDelta, TouchPhase}` (vom `core` Modul)
    * `novade-core::types::geometry::{Point, Logical, Physical}`
    * `novade-domain::global_shortcuts::service::GlobalShortcutService` (für globale Shortcuts)
* **Extern:**
    * `libinput::{Libinput, Event, EventTrait, Device, DeviceTrait, EventKind, EventKeyboard, EventPointer, EventTouch, EventGesture}`
    * `xkbcommon::{xkb::*}`
    * `smithay::input::{Seat, SeatState, PointerHandle, KeyboardHandle, TouchHandle}`
    * `tokio::{self, task, sync::broadcast}`
    * `tracing`
    * `thiserror::Error`
    * `async_trait`
    * `parking_lot::Mutex`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* **An `CompositorState`:** Leitet normalisierte `InputEvent`s über Callbacks oder direkte Methodenaufrufe zur Weiterleitung an die Wayland-Clients weiter.
* **An `GlobalShortcutService` (Domänenschicht):** Sendet Tastatur- und Gesten-Events zur Auswertung globaler Shortcuts.
* **An `InputService` (innerhalb `input` Modul):** Ereignisse werden von `handler.rs` an die Haupt `InputService` Instanz gesendet.
* **An andere System-Services:** Bei Bedarf könnten andere System-Services (z.B. `power_management` für Sleep-Gesten) Input-Events abonnieren.
* **Verwendet `tokio::sync::broadcast` für Event-Verteilung.**

**Erwartete Ergebnisse/Outputs:**
Eine zuverlässige und konfigurierbare Eingabeverarbeitung, die alle Benutzereingaben korrekt erkennt, normalisiert und an die entsprechenden Konsumenten im System weiterleitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken von `libinput` und `xkbcommon` Contexts.
    * Testen der Event-Übersetzung von `libinput` Events in `InputEvent`s (z.B. Keycodes zu `InputEvent::Keyboard`).
    * Testen der `xkbcommon` Integration (Modifikatoren, Tastaturbelegungen).
    * Testen der Geräte-Konfiguration und des Gerätemanagements.
    * Überprüfung der korrekten Event-Weiterleitung über den `broadcast` Channel.
* **Integration Tests:**
    * Starten des `InputService` mit einem realen `libinput` Context (wenn möglich, oder über uinput).
    * Simulieren von Benutzereingaben (Tastatur, Maus, Touchpad).
    * Überprüfen, ob die Events korrekt im `CompositorState` und `GlobalShortcutService` ankommen und verarbeitet werden.
    * Testen der Gesten-Erkennung.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, aufgrund der Komplexität von `libinput` und `xkbcommon` sowie der Notwendigkeit, alle Event-Typen zu behandeln und zu normalisieren.)

---

### **novade-system/src/input/service.rs**

**Verantwortlichkeit:**
Implementiert die `InputService`-Struktur, die den Haupt-Einstiegspunkt für die Eingabeverarbeitung darstellt. Sie ist für die Initialisierung des `libinput`-Contexts, den Start des Event-Loops und die Bereitstellung von Methoden zur Steuerung der Eingabegeräte verantwortlich.

**Kern-Aufgaben (Tasks):**

1.  **`InputService` Struktur:**
    * Felder:
        * `libinput_context: Mutex<Libinput>`
        * `seat: Mutex<smithay::input::Seat>`
        * `keyboard_state: Mutex<KeyboardState>` (interner Zustand für Tastatur, z.B. gedrückte Tasten, Modifikatoren)
        * `pointer_state: Mutex<PointerState>` (interner Zustand für Pointer)
        * `touch_state: Mutex<TouchState>` (interner Zustand für Touch)
        * `event_tx: broadcast::Sender<InputEvent>` (Sender für Input Events)
        * `compositor_state: Arc<CompositorState>` (Referenz auf den Compositor-Zustand für direkte Weiterleitung an Clients)
        * `global_shortcut_service: Arc<GlobalShortcutService>` (Referenz auf den GlobalShortcutService der Domäne)
        * `loop_handle: calloop::LoopHandle<'static, CompositorState>` (für den `calloop`-Event-Loop)

2.  **`InputService::new()` Funktion:**
    * `pub fn new(compositor_state: Arc<CompositorState>, global_shortcut_service: Arc<GlobalShortcutService>, loop_handle: calloop::LoopHandle<'static, CompositorState>) -> Result<Arc<Self>, InputError>`
    * Initialisiert `libinput::Libinput` mit einem `udev` Backend (für echte Hardware) oder einem `dummy` Backend (für Tests).
    * Initialisiert `smithay::input::Seat` und dessen Handles (Pointer, Keyboard, Touch).
    * Erstellt den `tokio::sync::broadcast` Channel für `InputEvent`s.
    * Fügt den `libinput` File Descriptor zum `calloop::EventLoop` hinzu, um asynchron Events zu empfangen.
    * Spawnt einen Tokio-Task, der den `libinput` Event-Loop pollert und Events verarbeitet.

3.  **`run_event_loop_task()` Funktion:**
    * Eine private `async` Funktion, die in einem separaten Tokio-Task läuft.
    * Wartet auf Events vom `libinput` File Descriptor.
    * Bei jedem Event:
        * Ruft `libinput_context.dispatch()` auf.
        * Iteriert über die dispatched Events.
        * Für jedes Event, ruft eine entsprechende Handler-Funktion auf (z.B. `handle_keyboard_event`, `handle_pointer_event` aus `handler.rs`).
        * Sendet normalisierte `InputEvent`s über `event_tx`.
        * Leitet spezifische Events direkt an `compositor_state.seat` weiter (z.B. Pointer-Bewegung, Tastendrücke an den Wayland-Client).
        * Leitet relevante Events an `global_shortcut_service` weiter.

4.  **`get_event_receiver()` Funktion:**
    * `pub fn get_event_receiver(&self) -> broadcast::Receiver<InputEvent>`
    * Bietet eine Möglichkeit für andere Komponenten, `InputEvent`s zu abonnieren.

5.  **Geräte-Management-Methoden (Beispiele):**
    * `configure_device_settings(device_id: String, settings: InputDeviceSettings)`: Wendet Einstellungen auf ein Gerät an.
    * `list_devices() -> Vec<InputDeviceInfo>`: Gibt eine Liste der erkannten Geräte zurück.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/service.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input::error::InputError`
    * `crate::input::events::InputEvent`
    * `crate::input::handler::{handle_keyboard_event, handle_pointer_event, handle_touch_event, handle_device_event}`
    * `crate::input::keyboard::{KeyboardState}`
    * `crate::input::pointer::{PointerState}`
    * `crate::input::touch::{TouchState}`
    * `crate::compositor::state::CompositorState`
    * `novade-domain::global_shortcuts::service::GlobalShortcutService`
* **Extern:**
    * `libinput::{Libinput, Event, EventTrait, DeviceTrait, EventKind, EventKeyboard, EventPointer, EventTouch, EventGesture, EventDevice}`
    * `smithay::input::{Seat, SeatState, PointerHandle, KeyboardHandle, TouchHandle}`
    * `smithay::reexports::{calloop}`
    * `tokio::{self, task, sync::broadcast}`
    * `tracing`
    * `parking_lot::Mutex`
    * `std::sync::Arc`
    * `async_trait`
    * `std::os::unix::io::AsRawFd`

**Kommunikationsmuster:**

* **Von `libinput`:** Empfängt rohe Eingabeereignisse.
* **An `CompositorState`:** Informiert den Compositor über Eingabeereignisse zur Weiterleitung an fokussierte Wayland-Clients.
* **An `GlobalShortcutService`:** Leitet Tastatur- und Gesten-Events zur Verarbeitung globaler Shortcuts weiter.
* **An andere NovaDE Komponenten:** Broadcastet `InputEvent`s über den `event_tx` Channel.

**Erwartete Ergebnisse/Outputs:**
Ein asynchroner Dienst, der Eingabegeräte verwaltet, Events von `libinput` empfängt und diese in normalisierter Form an andere Systemkomponenten verteilt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken des `libinput` Contexts und simulieren von `libinput` Events.
    * Testen der `new()`-Funktion und der korrekten Initialisierung aller Komponenten.
    * Testen des Event-Dispatching-Mechanismus in `run_event_loop_task()` mit Mock-Handlern.
    * Verifizieren, dass Events korrekt über den `broadcast` Channel gesendet werden.
* **Integration Tests:**
    * Starten des `InputService` und des `CompositorState` (mit `winit` Backend).
    * Starten eines Test-Wayland-Clients.
    * Simulation von Maus- und Tastatureingaben (ggf. über `uinput`).
    * Überprüfung, ob der Client die Eingaben korrekt empfängt.
    * Testen von globalen Shortcuts.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage)

---

### **novade-system/src/input/handler.rs**

**Verantwortlichkeit:**
Dieses Modul enthält die Logik zur Verarbeitung und Normalisierung spezifischer `libinput` Event-Typen. Es transformiert die rohen `libinput`-Events in die generischeren `InputEvent`s von `novade-core::types::input` und leitet sie an die `InputService` zur weiteren Verteilung.

**Kern-Aufgaben (Tasks):**

1.  **`handle_event(event: libinput::Event, input_service: &Arc<InputService>)` Funktion:**
    * Der zentrale Einstiegspunkt, der verschiedene `libinput::Event` Typen matcht.
    * Ruft die spezifischen Handler-Funktionen basierend auf dem `EventKind` auf.

2.  **`handle_device_event(event: libinput::EventDevice, input_service: &Arc<InputService>)`:**
    * Wird aufgerufen bei `libinput::EventKind::DeviceAdded` oder `DeviceRemoved`.
    * Aktualisiert die Liste der bekannten Geräte in `InputService` (oder `CompositorState`).
    * Optional: Wendet Standardkonfigurationen auf neue Geräte an.
    * Sendet `InputEvent::DeviceAdded` oder `InputEvent::DeviceRemoved`.

3.  **`handle_keyboard_event(event: libinput::EventKeyboard, input_service: &Arc<InputService>)`:**
    * Verarbeitet Tastatur-Events (`EventKind::Key`).
    * Nutzt `xkbcommon` um Keycodes in Symbole und Unicode zu übersetzen.
    * Aktualisiert den `keyboard_state` in `InputService` (gedrückte Tasten, Modifikatoren).
    * Erstellt `InputEvent::Keyboard` und sendet es.
    * Ruft `compositor_state.seat.keyboard_notify()` auf, um den Event an den Wayland-Client zu senden.
    * Leitet an `global_shortcut_service` weiter.

4.  **`handle_pointer_event(event: libinput::EventPointer, input_service: &Arc<InputService>)`:**
    * Verarbeitet Pointer-Events (`EventKind::Motion`, `Button`, `Scroll`).
    * Berechnet relative und absolute Mauspositionen.
    * Aktualisiert den `pointer_state`.
    * Erstellt `InputEvent::PointerMove`, `InputEvent::PointerButton`, `InputEvent::PointerScroll`.
    * Sendet die Events.
    * Ruft `compositor_state.seat.pointer_notify_motion()`, `pointer_notify_button()`, `pointer_notify_axis()` auf.

5.  **`handle_touch_event(event: libinput::EventTouch, input_service: &Arc<InputService>)`:**
    * Verarbeitet Touch-Events (`EventKind::TouchDown`, `TouchUp`, `TouchMotion`, `TouchCancel`).
    * Verwaltet Touch-Punkte.
    * Aktualisiert den `touch_state`.
    * Erstellt `InputEvent::Touch` Events.
    * Sendet die Events.
    * Ruft `compositor_state.seat.touch_notify_*()` auf.

6.  **`handle_gesture_event(event: libinput::EventGesture, input_service: &Arc<InputService>)`:**
    * Verarbeitet Gesten-Events (`EventKind::GestureSwipeBegin`, `GestureSwipeUpdate`, etc.).
    * Erstellt `InputEvent::Gesture` Events.
    * Sendet die Events.
    * Leitet an `global_shortcut_service` weiter.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/handler.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input::service::InputService`
    * `crate::input::keyboard::{KeyboardState}`
    * `crate::input::pointer::{PointerState}`
    * `crate::input::touch::{TouchState}`
    * `novade-core::types::input::{InputEvent, KeyState, ButtonState, ScrollDelta, TouchPhase}`
    * `novade-core::types::geometry::{Point, Logical, Physical}`
* **Extern:**
    * `libinput::{Event, EventTrait, DeviceTrait, EventKind, EventKeyboard, EventPointer, EventTouch, EventGesture, EventDevice}`
    * `smithay::input::Seat`
    * `std::sync::Arc`
    * `tracing`
    * `xkbcommon::xkb::*`

**Kommunikationsmuster:**

* **Von `InputService`:** Wird von der Haupt-Event-Loop der `InputService` aufgerufen.
* **An `InputService`:** Greift auf den internen Zustand (`keyboard_state`, `pointer_state`, `touch_state`) der `InputService` zu und sendet über den `event_tx` Kanal.
* **An `CompositorState` (`seat`):** Direkte Weiterleitung von Wayland-relevanten Eingabeereignissen über `smithay::input::Seat` Methoden.
* **An `GlobalShortcutService`:** Direkte Weiterleitung von Events zur Shortcut-Auswertung.

**Erwartete Ergebnisse/Outputs:**
Eine zuverlässige Verarbeitung von rohen `libinput`-Events in normalisierte, konsumierbare `InputEvent`s, die an die richtigen Komponenten weitergeleitet werden.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken von `libinput` Events und des `InputService` (`Arc<InputService>`).
    * Testen jeder `handle_*_event` Funktion isoliert.
    * Verifizieren, dass die korrekten `InputEvent`s erzeugt und gesendet werden.
    * Überprüfen, dass `smithay::input::Seat` Methoden mit den richtigen Parametern aufgerufen werden.
    * Testen der `xkbcommon` Integration für Tastatur-Events (z.B. verschiedene Tastaturbelegungen, Modifikator-Kombinationen).
    * Testen der Pointer-Bewegungs- und Scroll-Berechnungen.
    * Testen der Touch-Punkt-Verwaltung.
* **Integration Tests:**
    * Siehe `InputService` Integrationstests.

**Geschätzter Aufwand:** Hoch (ca. 6-9 Tage, da viele Event-Typen und deren Subtilitäten behandelt werden müssen)

---

### **novade-system/src/input/events.rs**

**Verantwortlichkeit:**
Dieses Modul definiert die kanonische `InputEvent` Enumeration, die alle normalisierten Benutzereingabeereignisse innerhalb von NovaDE darstellt. Es dient als zentrale Abstraktion für Eingabeereignisse, unabhängig von der zugrunde liegenden Hardware oder dem Protokoll (`libinput`, `xkbcommon`).

**Kern-Aufgaben (Tasks):**

1.  **`InputEvent` Enum Definition:**
    * `pub enum InputEvent`:
        * `Keyboard { key: Key, state: KeyState, mods: ModifiersState, serial: u32 }`: Tastaturereignis.
            * `Key` (enum): Repräsentiert die gedrückte Taste (z.B. `Key::A`, `Key::Enter`, `Key::F1`).
            * `KeyState` (enum): `Pressed` oder `Released`.
            * `ModifiersState`: Aktuelle Modifikatoren (Shift, Ctrl, Alt, Super).
        * `PointerMove { device_id: String, location: Point<f64, Logical>, delta: Point<f64, Logical>, serial: u32 }`: Maus-/Touchpad-Bewegung.
        * `PointerButton { device_id: String, button: Button, state: ButtonState, location: Point<f64, Logical>, serial: u32 }`: Maus-/Touchpad-Tastendruck.
            * `Button` (enum): Maus-Button (Left, Right, Middle, Extra1, Extra2).
            * `ButtonState` (enum): `Pressed` oder `Released`.
        * `PointerScroll { device_id: String, delta: ScrollDelta, serial: u32 }`: Maus-/Touchpad-Scrollen.
            * `ScrollDelta` (struct): Enthält `dx` und `dy` für horizontale/vertikale Bewegung.
        * `Touch { device_id: String, slot: i32, location: Point<f64, Logical>, phase: TouchPhase, serial: u32 }`: Touchscreen-Event.
            * `TouchPhase` (enum): `Down`, `Up`, `Motion`, `Frame`, `Cancel`.
        * `GestureSwipeBegin { device_id: String, fingers: i32, location: Point<f64, Logical>, serial: u32 }`: Gesten-Swipe-Beginn.
        * `GestureSwipeUpdate { device_id: String, fingers: i32, location: Point<f64, Logical>, delta: Point<f64, Logical>, serial: u32 }`: Gesten-Swipe-Update.
        * `GestureSwipeEnd { device_id: String, fingers: i32, serial: u32 }`: Gesten-Swipe-Ende.
        * `GesturePinchBegin { device_id: String, fingers: i32, location: Point<f64, Logical>, serial: u32 }`: Gesten-Pinch-Beginn.
        * `GesturePinchUpdate { device_id: String, fingers: i32, location: Point<f64, Logical>, scale: f64, rotation: f64, serial: u32 }`: Gesten-Pinch-Update.
        * `GesturePinchEnd { device_id: String, fingers: i32, serial: u32 }`: Gesten-Pinch-Ende.
        * `DeviceAdded { device_id: String, name: String, kind: InputDeviceKind }`: Neues Gerät angeschlossen.
        * `DeviceRemoved { device_id: String }`: Gerät entfernt.
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize` für `InputEvent` und alle enthaltenen Typen (`Key`, `KeyState`, `Button`, `ButtonState`, `ScrollDelta`, `TouchPhase`, `ModifiersState`, `InputDeviceKind`).
    * Implementiere `Default` für `ModifiersState`.

2.  **`Key` Enum Definition:**
    * Umfasst alle relevanten Tasten (Buchstaben, Zahlen, Funktionstasten, Sondertasten wie Enter, Space, Ctrl, Shift, Alt, Super etc.).
    * Kann aus `xkbcommon::xkb::Key` konvertiert werden.

3.  **`ModifiersState` Struktur:**
    * Kapselt den Zustand der Modifikator-Tasten (Shift, Ctrl, Alt, Super, CapsLock, NumLock).
    * `pub struct ModifiersState { shift: bool, ctrl: bool, alt: bool, logo: bool, caps_lock: bool, num_lock: bool }`
    * Helper-Methoden wie `is_shift()`, `is_ctrl()`, `is_alt()`, `is_logo()`.

4.  **`InputDeviceKind` Enum:**
    * `pub enum InputDeviceKind { Keyboard, Pointer, Touchscreen, Touchpad, TabletTool, GestureSource, Other }`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/events.rs`

**Abhängigkeiten:**

* **Intern:**
    * `novade-core::types::geometry::{Point, Logical}`
* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `bitflags::bitflags` (optional für `ModifiersState` für effizientere Bitmasken)
    * `xkbcommon::xkb::Keysym` (für interne Konvertierung zu `Key` Enum)
    * `xkbcommon::xkb::State` (für Extraktion von Modifikatoren)

**Kommunikationsmuster:**

* Wird von `input::handler` erzeugt und von `input::service` gebroadcastet.
* Wird von `compositor` und `novade-domain::global_shortcuts` konsumiert.
* `novade-ui` Komponenten können diese Events ebenfalls abonnieren, um UI-Elemente basierend auf Eingaben zu aktualisieren (z.B. Tastatur-Layout-Anzeige).

**Erwartete Ergebnisse/Outputs:**
Eine umfassende und einheitliche Darstellung aller Benutzereingabeereignisse, die die Weiterverarbeitung in verschiedenen NovaDE-Komponenten vereinfacht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize` Implementierungen für alle Event-Varianten und deren enthaltenen Typen.
    * Testen der Konvertierung von `xkbcommon::xkb::Keysym` zu `Key`.
    * Testen der `ModifiersState` Logik (z.B. `is_shift()`).
    * Verifizieren, dass alle Event-Varianten mit korrekten Daten erstellt werden können.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---

### **novade-system/src/input/keyboard.rs**

**Verantwortlichkeit:**
Verwaltet den Zustand der Tastatur, einschließlich gedrückter Tasten und des Zustands der Modifikatoren. Es stellt Funktionen zur Verfügung, um Tastaturereignisse zu verarbeiten und den `xkbcommon`-Tastaturzustand zu aktualisieren.

**Kern-Aufgaben (Tasks):**

1.  **`KeyboardState` Struktur:**
    * Felder:
        * `xkb_context: xkbcommon::xkb::Context`
        * `xkb_keymap: xkbcommon::xkb::Keymap`
        * `xkb_state: xkbcommon::xkb::State` (derzeitiger Tastaturzustand mit Modifikatoren)
        * `pressed_keys: HashSet<u32>` (eine Menge der aktuell gedrückten `libinput` Keycodes)
        * `serial_generator: smithay::utils::Serial` (für Wayland-Serial-Nummern)
    * Implementiere `Default` oder eine `new()`-Funktion für die Initialisierung.

2.  **`KeyboardState::new()` Funktion:**
    * `pub fn new() -> Result<Self, InputError>`:
        * Initialisiert `xkbcommon::xkb::Context`.
        * Lädt die Standard-Keymap (z.B. "evdev+aliases(qwerty)" oder basierend auf Systemkonfiguration).
        * Erstellt `xkbcommon::xkb::State` aus der Keymap.
        * Initialisiert `pressed_keys` und `serial_generator`.

3.  **`update_keyboard_state(event: &libinput::EventKeyboard, xkb_state: &mut xkbcommon::xkb::State, pressed_keys: &mut HashSet<u32>)` Funktion:**
    * Verarbeitet ein `libinput::EventKeyboard`.
    * Aktualisiert den `xkb_state` mit dem neuen Keycode und Zustand (gedrückt/losgelassen).
    * Fügt den Keycode zu `pressed_keys` hinzu oder entfernt ihn.

4.  **`get_key_from_keycode(keycode: u32, xkb_state: &xkbcommon::xkb::State) -> Option<Key>` Funktion:**
    * Konvertiert einen `libinput` Keycode in unser internes `InputEvent::Key` Enum.
    * Nutzt `xkb_state.key_get_sym()` für die primäre Keysym.

5.  **`get_modifiers_state(xkb_state: &xkbcommon::xkb::State) -> ModifiersState` Funktion:**
    * Extrahiert den aktuellen Zustand der Modifikatoren (Shift, Ctrl, Alt, Super, CapsLock, NumLock) aus dem `xkb_state`.

6.  **`is_key_pressed(keycode: u32, pressed_keys: &HashSet<u32>) -> bool` Funktion:**
    * Prüft, ob ein bestimmter Keycode aktuell gedrückt ist.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/keyboard.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input::error::InputError`
    * `novade-core::types::input::{Key, KeyState, ModifiersState}`
* **Extern:**
    * `libinput::EventKeyboard`
    * `xkbcommon::{xkb::*}`
    * `smithay::utils::Serial`
    * `std::collections::HashSet`
    * `tracing`

**Kommunikationsmuster:**

* Wird von `input::handler` verwendet, um Tastaturereignisse zu verarbeiten und den Tastaturzustand zu aktualisieren.
* Stellt die benötigten Daten für die Erstellung von `InputEvent::Keyboard` bereit.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Modul zur Verwaltung des Tastaturzustands und zur korrekten Übersetzung von Tastaturereignissen, einschließlich Unterstützung für Tastaturbelegungen und Modifikatoren.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion und der korrekten Initialisierung von `xkbcommon` Komponenten.
    * Testen von `update_keyboard_state` mit simulierten Key-Press/Release-Events, um die `pressed_keys` und `xkb_state` Aktualisierungen zu verifizieren.
    * Testen der `get_key_from_keycode` Funktion für verschiedene Keycodes und Tastaturbelegungen.
    * Testen von `get_modifiers_state` für verschiedene Modifikator-Kombinationen.
    * Testen von `is_key_pressed`.

**Geschätzter Aufwand:** Mittel (ca. 3-4 Tage)

---
### **novade-system/src/input/pointer.rs**

**Verantwortlichkeit:**
Verwaltet den Zustand des Pointers (Maus, Touchpad). Es ist verantwortlich für die Verfolgung der Cursorposition, die Handhabung von Tasten- und Scroll-Events und die Aktualisierung des Pointer-Zustands, um ihn an Wayland-Clients zu übermitteln.

**Kern-Aufgaben (Tasks):**

1.  **`PointerState` Struktur:**
    * Felder:
        * `current_location: Point<f64, Logical>` (aktuelle logische Cursorposition relativ zum Compositor).
        * `active_button: Option<Button>` (aktuell gedrückte Maustaste, falls vorhanden).
        * `serial_generator: smithay::utils::Serial` (für Wayland-Serial-Nummern).
    * Implementiere `Default` oder eine `new()`-Funktion für die Initialisierung.

2.  **`PointerState::new()` Funktion:**
    * `pub fn new() -> Self`: Initialisiert `current_location` auf (0.0, 0.0), `active_button` auf `None`, und `serial_generator`.

3.  **`update_pointer_move(event: &libinput::EventPointerMotion, pointer_state: &mut PointerState)` Funktion:**
    * Verarbeitet ein `libinput::EventPointerMotion`.
    * Aktualisiert `pointer_state.current_location` basierend auf der Delta-Bewegung.
    * Berücksichtigt Output-Grenzen und Multi-Monitor-Setups (ggf. über `compositor_state` oder `desktop_state`).

4.  **`update_pointer_button(event: &libinput::EventPointerButton, pointer_state: &mut PointerState)` Funktion:**
    * Verarbeitet ein `libinput::EventPointerButton`.
    * Aktualisiert `pointer_state.active_button` basierend auf dem Button-Zustand (gedrückt/losgelassen).
    * Konvertiert `libinput` Button Code zu `InputEvent::Button`.

5.  **`update_pointer_scroll(event: &libinput::EventPointerScroll, pointer_state: &mut PointerState)` Funktion:**
    * Verarbeitet ein `libinput::EventPointerScroll`.
    * Extrahiert `dx` und `dy` für `InputEvent::ScrollDelta`.
    * Berücksichtigt Scroll-Achsen und Richtung.

6.  **`get_current_location(&self) -> Point<f64, Logical>` Funktion:**
    * Gibt die aktuelle logische Cursorposition zurück.

7.  **`get_active_button(&self) -> Option<Button>` Funktion:**
    * Gibt die aktuell gedrückte Maustaste zurück.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/pointer.rs`

**Abhängigkeiten:**

* **Intern:**
    * `novade-core::types::geometry::{Point, Logical}`
    * `novade-core::types::input::{Button, ButtonState, ScrollDelta}`
* **Extern:**
    * `libinput::{EventPointerMotion, EventPointerButton, EventPointerScroll}`
    * `smithay::utils::Serial`
    * `tracing`

**Kommunikationsmuster:**

* Wird von `input::handler` verwendet, um Pointer-Ereignisse zu verarbeiten und den Pointer-Zustand zu aktualisieren.
* Stellt die benötigten Daten für die Erstellung von `InputEvent::PointerMove`, `InputEvent::PointerButton` und `InputEvent::PointerScroll` bereit.

**Erwartete Ergebnisse/Outputs:**
Ein Modul, das die Maus- und Touchpad-Eingaben präzise verarbeitet, die Cursorposition verwaltet und die Maustasten- und Scroll-Events für die Weiterverarbeitung normalisiert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion.
    * Testen von `update_pointer_move` mit verschiedenen Delta-Werten, um die Positionsaktualisierung zu verifizieren.
    * Testen von `update_pointer_button` für verschiedene Button-Typen und Zustandswechsel (Pressed/Released).
    * Testen von `update_pointer_scroll` für horizontale und vertikale Scroll-Ereignisse.
    * Testen der Getter-Methoden (`get_current_location`, `get_active_button`).

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---

### **novade-system/src/input/touch.rs**

**Verantwortlichkeit:**
Verwaltet den Zustand von Touch-Eingaben von Touchscreens und Touchpads. Es verfolgt einzelne Touch-Punkte (`slots`), deren Positionen und Phasen (Down, Up, Motion) und bereitet diese Informationen für die Weiterleitung an Wayland-Clients vor.

**Kern-Aufgaben (Tasks):**

1.  **`TouchState` Struktur:**
    * Felder:
        * `active_touches: HashMap<i32, Point<f64, Logical>>` (Map von Touch-Slot-ID zu logischer Position).
        * `serial_generator: smithay::utils::Serial` (für Wayland-Serial-Nummern).
    * Implementiere `Default` oder eine `new()`-Funktion für die Initialisierung.

2.  **`TouchState::new()` Funktion:**
    * `pub fn new() -> Self`: Initialisiert `active_touches` als leere HashMap und `serial_generator`.

3.  **`update_touch_down(event: &libinput::EventTouchDown, touch_state: &mut TouchState)` Funktion:**
    * Verarbeitet ein `libinput::EventTouchDown`.
    * Fügt den neuen Touch-Punkt mit seiner Slot-ID und Position zu `active_touches` hinzu.

4.  **`update_touch_up(event: &libinput::EventTouchUp, touch_state: &mut TouchState)` Funktion:**
    * Verarbeitet ein `libinput::EventTouchUp`.
    * Entfernt den Touch-Punkt mit der entsprechenden Slot-ID aus `active_touches`.

5.  **`update_touch_motion(event: &libinput::EventTouchMotion, touch_state: &mut TouchState)` Funktion:**
    * Verarbeitet ein `libinput::EventTouchMotion`.
    * Aktualisiert die Position des Touch-Punkts in `active_touches` für die gegebene Slot-ID.

6.  **`update_touch_cancel(event: &libinput::EventTouchCancel, touch_state: &mut TouchState)` Funktion:**
    * Verarbeitet ein `libinput::EventTouchCancel`.
    * Löscht alle aktiven Touch-Punkte in `active_touches` (oder spezifische, falls der Event eine Slot-ID enthält).

7.  **`get_active_touches(&self) -> &HashMap<i32, Point<f64, Logical>>` Funktion:**
    * Gibt eine Referenz auf die Map der aktiven Touch-Punkte zurück.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/touch.rs`

**Abhängigkeiten:**

* **Intern:**
    * `novade-core::types::geometry::{Point, Logical}`
* **Extern:**
    * `libinput::{EventTouchDown, EventTouchUp, EventTouchMotion, EventTouchCancel}`
    * `smithay::utils::Serial`
    * `std::collections::HashMap`
    * `tracing`

**Kommunikationsmuster:**

* Wird von `input::handler` verwendet, um Touch-Ereignisse zu verarbeiten und den Touch-Zustand zu aktualisieren.
* Stellt die benötigten Daten für die Erstellung von `InputEvent::Touch` bereit.

**Erwartete Ergebnisse/Outputs:**
Ein Modul, das eine präzise Verfolgung mehrerer Touch-Punkte ermöglicht und die notwendigen Zustandsinformationen für die Weiterleitung an Wayland-Clients liefert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion.
    * Testen von `update_touch_down` zum Hinzufügen neuer Touch-Punkte.
    * Testen von `update_touch_up` zum Entfernen von Touch-Punkten.
    * Testen von `update_touch_motion` zur Aktualisierung von Touch-Punkt-Positionen.
    * Testen von `update_touch_cancel` zum Löschen von Touch-Punkten.
    * Testen von `get_active_touches`.
    * Szenarien mit mehreren simultanen Touch-Punkten testen.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---

### **novade-system/src/input/gestures.rs**

**Verantwortlichkeit:**
Dieses Modul ist für die Erkennung und Verarbeitung von Multi-Touch-Gesten (z.B. Swipes, Pinches) zuständig. Es übersetzt rohe `libinput` Gesten-Events in höherwertige `InputEvent::Gesture` Events und leitet diese an den `GlobalShortcutService` oder andere Komponenten zur Ausführung von Aktionen weiter.

**Kern-Aufgaben (Tasks):**

1.  **`GestureState` Struktur:**
    * (Optional, falls komplexe Gesten-Zustandsmaschinen erforderlich sind. Für einfache Weiterleitung eventuell nicht nötig.)
    * Felder: Zustand der aktuellen Geste (z.B. `is_swiping: bool`, `initial_swipe_location: Point<f64, Logical>`, `current_fingers: i32`).

2.  **`handle_gesture_begin(event: &libinput::EventGesture, input_service: &Arc<InputService>)` Funktion:**
    * Verarbeitet `libinput::EventGestureSwipeBegin` oder `EventGesturePinchBegin`.
    * Erstellt das entsprechende `InputEvent::GestureSwipeBegin` oder `InputEvent::GesturePinchBegin`.
    * Sendet das Event über den `event_tx` Channel von `InputService`.
    * Leitet an `global_shortcut_service` weiter.

3.  **`handle_gesture_update(event: &libinput::EventGesture, input_service: &Arc<InputService>)` Funktion:**
    * Verarbeitet `libinput::EventGestureSwipeUpdate` oder `EventGesturePinchUpdate`.
    * Berechnet Delta-Werte für Bewegung, Skalierung und Rotation.
    * Erstellt das entsprechende `InputEvent::GestureSwipeUpdate` oder `InputEvent::GesturePinchUpdate`.
    * Sendet das Event über den `event_tx` Channel.
    * Leitet an `global_shortcut_service` weiter.

4.  **`handle_gesture_end(event: &libinput::EventGesture, input_service: &Arc<InputService>)` Funktion:**
    * Verarbeitet `libinput::EventGestureSwipeEnd` oder `EventGesturePinchEnd`.
    * Erstellt das entsprechende `InputEvent::GestureSwipeEnd` oder `InputEvent::GesturePinchEnd`.
    * Sendet das Event über den `event_tx` Channel.
    * Leitet an `global_shortcut_service` weiter.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/gestures.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input::service::InputService`
    * `novade-core::types::input::{InputEvent}` (insbesondere Gesture-Varianten)
    * `novade-core::types::geometry::{Point, Logical}`
* **Extern:**
    * `libinput::{EventGesture, EventGestureSwipeBegin, EventGestureSwipeUpdate, EventGestureSwipeEnd, EventGesturePinchBegin, EventGesturePinchUpdate, EventGesturePinchEnd}`
    * `std::sync::Arc`
    * `tracing`

**Kommunikationsmuster:**

* Wird von `input::handler` aufgerufen, wenn ein `libinput` Gesten-Event empfangen wird.
* Sendet normalisierte `InputEvent::Gesture` Events an den `InputService` Broadcast-Channel.
* Leitet spezifische Events direkt an den `GlobalShortcutService` weiter, falls eine sofortige Reaktion erforderlich ist.

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiges Gesten-Modul, das Multi-Touch-Gesten zuverlässig erkennt und deren Parameter (Anzahl Finger, Bewegung, Skalierung, Rotation) korrekt an die Konsumenten weiterleitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken von `libinput` Gesten-Events.
    * Testen der `handle_gesture_begin`, `handle_gesture_update`, `handle_gesture_end` Funktionen.
    * Verifizieren, dass die korrekten `InputEvent::Gesture` Varianten mit den richtigen Parametern erzeugt und über den `broadcast` Channel gesendet werden.
    * Testen der Delta-Berechnungen für Swipe und Pinch.
* **Integration Tests:**
    * Starten des Compositors mit Gesten-fähiger Hardware (Touchpad, Touchscreen).
    * Ausführen verschiedener Gesten (z.B. 3-Finger-Swipe, 2-Finger-Pinch).
    * Überprüfen, ob `GlobalShortcutService` die Gesten korrekt empfängt und entsprechende Aktionen auslöst (z.B. Workspace-Wechsel, Zoom).

**Geschätzter Aufwand:** Mittel (ca. 3-4 Tage)

---

### **novade-system/src/input/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`InputError`) für das `input`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung innerhalb des Eingabesystems sicher und ermöglicht eine präzise Fehlerweiterleitung.

**Kern-Aufgaben (Tasks):**

1.  **`InputError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `LibinputInitializationError(String)`: Fehler bei der Initialisierung von `libinput` (z.B. fehlende Berechtigungen, udev-Fehler).
        * `XkbcommonError(String)`: Fehler bei der Initialisierung oder Nutzung von `xkbcommon` (z.B. fehlende Keymaps).
        * `DeviceNotFound(String)`: Ein angefordertes Eingabegerät wurde nicht gefunden.
        * `ConfigurationError(String)`: Fehler beim Anwenden von Geräteeinstellungen.
        * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/error.rs`

**Abhängigkeiten:**

* **Intern:** Keine direkten Abhängigkeiten.
* **Extern:**
    * `thiserror::Error`
    * `std::io::Error`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `input`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im `input`-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `InputError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---

### **novade-system/src/dbus_interfaces**

**Verantwortlichkeit:**
Das `dbus_interfaces`-Modul ist die Brücke zwischen NovaDE und dem D-Bus-System. Es implementiert sowohl D-Bus-Clients, um mit externen Systemdiensten (z.B. NetworkManager, UPower, logind) zu kommunizieren, als auch D-Bus-Server für NovaDE-spezifische Dienste (z.B. Notifications, Configuration API).

**Kern-Aufgaben (Tasks):**

1.  **D-Bus Bus Connection:**
    * Etablieren einer D-Bus-Verbindung zum System- und Session-Bus.
    * Wiederverbindungslogik bei Verbindungsabbruch.

2.  **Client-Implementierungen:**
    * Für jeden benötigten Systemdienst:
        * Definition der D-Bus-Schnittstelle (Interface, Methoden, Signale, Properties) mit `zbus_macros::DBus` oder manueller Implementierung.
        * Implementierung des `zbus::Proxy` Clients.
        * Methoden zur Interaktion mit dem Dienst (z.B. `NetworkManager::enable_networking()`, `UPower::get_battery_info()`, `logind::inhibit_sleep()`).
        * Signal-Handler für asynchrone Benachrichtigungen vom Dienst (z.B. `NetworkManager::PropertiesChanged`, `UPower::DeviceAdded`).

3.  **Server-Implementierungen:**
    * Für jeden von NovaDE bereitgestellten D-Bus-Dienst:
        * Definition der D-Bus-Schnittstelle (Interface, Methoden, Signale, Properties).
        * Implementierung der `zbus::fdo::ObjectServer` oder `zbus::Object` für die Geschäftslogik der Schnittstelle.
        * Veröffentlichung des Objekts auf dem D-Bus.
        * Signal-Emission, um Clients über Änderungen zu informieren.

4.  **Fehlerbehandlung und Logging:**
    * Robuste Fehlerbehandlung für D-Bus-Interaktionen.
    * Detailliertes Logging aller D-Bus-Kommunikation für Debugging-Zwecke.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/mod.rs`
* `novade-system/src/dbus_interfaces/service.rs` (Haupt-D-Bus-Service-Manager)
* `novade-system/src/dbus_interfaces/error.rs` (`DBusError` Enum)
* `novade-system/src/dbus_interfaces/network_manager.rs` (Client für NetworkManager)
* `novade-system/src/dbus_interfaces/upower.rs` (Client für UPower)
* `novade-system/src/dbus_interfaces/logind.rs` (Client für logind)
* `novade-system/src/dbus_interfaces/secret_service.rs` (Client für Secret Service API)
* `novade-system/src/dbus_interfaces/policykit.rs` (Client für PolicyKit)
* `novade-system/src/dbus_interfaces/notifications_server.rs` (Server für `org.freedesktop.Notifications`)
* `novade-system/src/dbus_interfaces/settings_server.rs` (Optional: Server für Domänen-Einstellungen, falls D-Bus-Zugriff benötigt)

**Abhängigkeiten:**

* **Intern:**
    * `novade-core::error::CoreError`
    * `novade-core::types::network::{NetworkConfig, ConnectionState}` (Beispiel)
    * `novade-core::types::power::{BatteryInfo, PowerState}` (Beispiel)
    * `novade-core::types::notification::{Notification}` (für Notification Server)
    * `novade-domain::global_settings::service::GlobalSettingsService` (falls `settings_server`)
    * `novade-domain::notification_service::service::NotificationService` (für Notification Server)
* **Extern:**
    * `zbus::{self, Connection, Interface, SignalContext, fdo, blocking}`
    * `zbus_macros::{self, dbus_interface, dbus_proxy}`
    * `tokio`
    * `async_trait`
    * `futures::StreamExt`
    * `tracing`
    * `thiserror::Error`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* **Client-Seite:**
    * Ruft D-Bus-Methoden auf externen Diensten auf.
    * Abonnieren von D-Bus-Signalen von externen Diensten.
    * Ergebnisse und Signale werden in internen NovaDE-Events normalisiert und an die Domänenschicht weitergeleitet (z.B. über `tokio::sync::broadcast`).
* **Server-Seite:**
    * Empfängt D-Bus-Methodenaufrufe von externen Clients.
    * Interagiert mit der Domänenschicht (z.B. `NotificationService` für `org.freedesktop.Notifications`).
    * Sendet D-Bus-Signale an abonnierende Clients.
* **Zwischen SystemServices:** Die `dbus_interfaces::Service` wird von der `SystemServices` Initialisierung instanziiert und die Proxys (Clients) und ObjectServer (Server) dort registriert.

**Erwartete Ergebnisse/Outputs:**
Eine stabile und vollständige Integration mit dem System-D-Bus, die NovaDE den Zugriff auf kritische Systemfunktionen ermöglicht und es erlaubt, selbst D-Bus-Dienste für andere Anwendungen bereitzustellen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken von D-Bus-Verbindungen (`zbus::blocking::Connection::new_session_for_test()` kann nützlich sein).
    * Testen der Proxy-Methodenaufrufe und der Argument-Serialisierung.
    * Testen der Signal-Deserialisierung und der Callback-Verarbeitung.
    * Testen der Fehlerbehandlung für D-Bus-Fehler.
    * Für Server: Testen der Object-Implementierungen und der Signal-Emission.
* **Integration Tests:**
    * Starten eines realen `zbus::Connection` (Session oder System Bus).
    * Interaktion mit echten Systemdiensten (NetworkManager, UPower) und Verifizierung der Antworten.
    * Für den Notification Server: Starten eines externen D-Bus-Clients (z.B. `notify-send`) und Überprüfung, ob NovaDE die Benachrichtigungen empfängt und verarbeitet.

**Geschätzter Aufwand:** Hoch (ca. 10-15 Tage, da viele D-Bus-Schnittstellen implementiert werden müssen und D-Bus-Interaktionen komplex sein können)

---
### **novade-system/src/dbus_interfaces/service.rs**

**Verantwortlichkeit:**
Dieses Modul ist der zentrale Manager für alle D-Bus-Interaktionen in NovaDE. Es initialisiert und verwaltet die D-Bus-Verbindungen (System- und Session-Bus), registriert NovaDE-eigene D-Bus-Objekte und deren Schnittstellen und erstellt Proxys für die Kommunikation mit externen D-Bus-Diensten.

**Kern-Aufgaben (Tasks):**

1.  **`DBusService` Struktur:**
    * Felder:
        * `system_bus_conn: Arc<zbus::Connection>` (Verbindung zum System-Bus).
        * `session_bus_conn: Arc<zbus::Connection>` (Verbindung zum Session-Bus, falls benötigt).
        * `notification_object_server: Mutex<zbus::ObjectServer>` (Server für `org.freedesktop.Notifications`).
        * `network_manager_proxy: Arc<network_manager::NetworkManagerProxy>` (Proxy für NetworkManager).
        * `upower_proxy: Arc<upower::UPowerProxy>` (Proxy für UPower).
        * `logind_proxy: Arc<logind::LogindProxy>` (Proxy für logind).
        * `secret_service_proxy: Arc<secret_service::SecretServiceProxy>` (Proxy für Secret Service).
        * `policykit_proxy: Arc<policykit::PolicyKitProxy>` (Proxy für PolicyKit).
        * `notification_service: Arc<NotificationService>` (Referenz auf den Notification Service der Domäne).

2.  **`DBusService::new()` Funktion:**
    * `pub async fn new(notification_service: Arc<NotificationService>) -> Result<Arc<Self>, DBusError>`
    * Stellt asynchron eine Verbindung zum System-Bus her (`zbus::Connection::system().await`).
    * Stellt optional eine Verbindung zum Session-Bus her (`zbus::Connection::session().await`).
    * **Initialisierung von D-Bus Clients (Proxys):**
        * Erstellt `NetworkManagerProxy::new_from_connection(&system_bus_conn).await?`.
        * Erstellt `UPowerProxy::new_from_connection(&system_bus_conn).await?`.
        * Erstellt `LogindProxy::new_from_connection(&system_bus_conn).await?`.
        * Erstellt `SecretServiceProxy::new_from_connection(&session_bus_conn).await?`.
        * Erstellt `PolicyKitProxy::new_from_connection(&system_bus_conn).await?`.
    * **Initialisierung des D-Bus Server:**
        * Erstellt einen `zbus::ObjectServer::new_with_data()`.
        * Fügt die `NotificationsServer` Implementierung hinzu (`object_server.at(&"/org/freedesktop/Notifications".try_into()?, notifications_server_impl).await?`).
        * Requestet den Well-Known Name `org.freedesktop.Notifications` (`connection.request_name("org.freedesktop.Notifications").await?`).
    * Gibt die `DBusService` Instanz in einem `Arc` zurück.

3.  **`run_object_server()` Funktion:**
    * `pub async fn run_object_server(service: Arc<DBusService>) -> Result<(), DBusError>`
    * Startet den `object_server` in einem separaten Tokio-Task, um eingehende D-Bus-Anfragen für die NovaDE-eigenen Dienste zu bearbeiten.
    * Wartet auf Events vom `object_server`.

4.  **`get_network_manager_proxy(&self) -> Arc<network_manager::NetworkManagerProxy>` etc.:**
    * Getter-Methoden für alle Proxys, um sie anderen Services zur Verfügung zu stellen.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/service.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DBusError`
    * `crate::dbus_interfaces::network_manager::NetworkManagerProxy`
    * `crate::dbus_interfaces::upower::UPowerProxy`
    * `crate::dbus_interfaces::logind::LogindProxy`
    * `crate::dbus_interfaces::secret_service::SecretServiceProxy`
    * `crate::dbus_interfaces::policykit::PolicyKitProxy`
    * `crate::dbus_interfaces::notifications_server::NotificationsServer` (die Implementierung des D-Bus-Objekts).
    * `novade-domain::notification_service::service::NotificationService`
* **Extern:**
    * `zbus::{self, Connection, ObjectServer, fdo}`
    * `tokio`
    * `std::sync::Arc`
    * `parking_lot::Mutex`
    * `tracing`
    * `async_trait`

**Kommunikationsmuster:**

* **Von `SystemServices`:** Wird bei der Initialisierung der Systemschicht aufgerufen.
* **An `zbus`:** Nutzt die `zbus` API für alle D-Bus-Operationen.
* **An interne Domänen-Services:** Verweist auf den `NotificationService` für den Notification Server.
* **An externe D-Bus-Dienste:** Die erstellten Proxys kommunizieren direkt mit den jeweiligen Systemdiensten.

**Erwartete Ergebnisse/Outputs:**
Ein vollständig initialisierter und laufender D-Bus-Manager, der sowohl als Client für externe Dienste agiert als auch NovaDE-eigene D-Bus-Dienste bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken der `zbus::Connection` und der Proxys/ObjectServer.
    * Testen der `new()`-Funktion für die korrekte Initialisierung und Registrierung.
    * Verifizieren, dass die `request_name` Aufrufe korrekt erfolgen.
    * Testen der `run_object_server` Funktion, um sicherzustellen, dass der Server korrekt gestartet wird.
* **Integration Tests:**
    * Starten des `DBusService` mit echten D-Bus-Verbindungen (Session und/oder System Bus).
    * Testen der Interaktion mit realen Systemdiensten (z.B. `nmcli` Befehle, `upower` Abfragen, `loginctl` Befehle) und Überprüfung, ob der Proxy die Antworten korrekt empfängt.
    * Testen des Notification Servers durch Senden von Test-Benachrichtigungen über `notify-send` und Überprüfung, ob diese vom `NotificationService` empfangen werden.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da die Initialisierung vieler Komponenten und das Management von Lebenszyklen komplex sind)

---

### **novade-system/src/dbus_interfaces/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`DBusError`) für das `dbus_interfaces`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung für D-Bus-Interaktionen sicher und ermöglicht eine präzise Fehlerweiterleitung.

**Kern-Aufgaben (Tasks):**

1.  **`DBusError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `ConnectionError(#[from] zbus::Error)`: Fehler bei der D-Bus-Verbindung oder allgemeinen D-Bus-Operationen.
        * `ProxyCreationError(String)`: Fehler beim Erstellen eines D-Bus-Proxys.
        * `MethodCallError(String)`: Fehler beim Aufrufen einer D-Bus-Methode.
        * `NameRequestError(String)`: Fehler beim Anfordern eines D-Bus-Namens.
        * `InterfaceImplementationError(String)`: Fehler in der Implementierung einer D-Bus-Schnittstelle.
        * `InvalidArgument(String)`: Ungültiges Argument an eine D-Bus-Methode übergeben.
        * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/error.rs`

**Abhängigkeiten:**

* **Intern:** Keine direkten Abhängigkeiten.
* **Extern:**
    * `thiserror::Error`
    * `zbus::Error`
    * `std::io::Error`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `dbus_interfaces`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im `dbus_interfaces`-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `DBusError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---

### **novade-system/src/dbus_interfaces/network_manager.rs**

**Verantwortlichkeit:**
Implementiert den D-Bus-Client für den NetworkManager-Dienst (`org.freedesktop.NetworkManager`). Dieses Modul ermöglicht es NovaDE, Netzwerkverbindungen zu verwalten, den Netzwerkstatus abzufragen und auf Änderungen im Netzwerk zuzugreifen.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkManagerProxy` Struktur (via `zbus_macros::dbus_proxy`):**
    * Definiere die D-Bus-Schnittstelle für `org.freedesktop.NetworkManager`.
    * Methoden (Beispiele):
        * `state() -> zbus::Result<u32>`: Gibt den globalen Netzwerkstatus zurück.
        * `get_devices() -> zbus::Result<Vec<zbus::zvariant::ObjectPath<'static>>>`: Listet alle Netzwerkgeräte auf.
        * `activate_connection(connection: &ObjectPath, device: &ObjectPath, specific_object: &ObjectPath) -> zbus::Result<ObjectPath<'static>>`: Aktiviert eine Netzwerkverbindung.
        * `deactivate_connection(active_connection: &ObjectPath) -> zbus::Result<()>`: Deaktiviert eine Netzwerkverbindung.
        * `sleep(value: bool) -> zbus::Result<()>`: Versetzt den NetworkManager in den Schlafmodus.
    * Properties (Beispiele):
        * `State`: `READONLY` `u32` (globaler Netzwerkstatus).
        * `Connectivity`: `READONLY` `u32` (Konnektivitätsstatus).
    * Signals (Beispiele):
        * `StateChanged(u32)`: Emittiert, wenn sich der globale Status ändert.
        * `PropertiesChanged(HashMap<String, zbus::zvariant::OwnedValue>)`: Generisches Signal für Property-Änderungen.

2.  **`NetworkManagerProxy::new_from_connection()` Funktion:**
    * Initialisiert den Proxy für den NetworkManager.

3.  **Wrapper-Funktionen für D-Bus-Aufrufe:**
    * Bieten höherwertige APIs, die die `zbus` spezifischen Typen kapseln und NovaDE-interne Typen (`novade-core::types::network::*`) verwenden.
    * `pub async fn get_network_state(&self) -> Result<NetworkConnectionState, DBusError>`: Ruft den State ab und konvertiert ihn.
    * `pub async fn list_network_devices(&self) -> Result<Vec<NetworkDeviceInfo>, DBusError>`: Listet Geräte auf.
    * `pub async fn connect_to_wifi(ssid: &str, password: &str) -> Result<(), DBusError>`: Beispiel für eine komplexere Operation.

4.  **Signal-Verarbeitung:**
    * Implementiert Methoden, um die `StateChanged` und `PropertiesChanged` Signale des NetworkManager zu abonnieren.
    * Konvertiert die D-Bus-Signal-Payloads in interne `NetworkEvent`s (z.B. `NetworkEvent::StateChanged`).
    * Sendet diese Events an einen `tokio::sync::broadcast::Sender` im `DBusService` oder direkt an den `NetworkService` der Domänenschicht.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/network_manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DBusError`
    * `novade-core::types::network::{NetworkConnectionState, NetworkDeviceInfo, NetworkEvent}`
* **Extern:**
    * `zbus::{self, Connection, Proxy, zvariant::ObjectPath, zvariant::OwnedValue}`
    * `zbus_macros::dbus_proxy`
    * `tokio`
    * `futures::StreamExt`
    * `std::collections::HashMap`
    * `tracing`
    * `async_trait`

**Kommunikationsmuster:**

* **An NetworkManager D-Bus-Dienst:** Sendet Methodenaufrufe und empfängt Antworten und Signale.
* **An Domänenschicht (`NetworkService`):** Sendet `NetworkEvent`s über einen Broadcast-Channel, um den Netzwerkzustand zu melden.
* **An `DBusService`:** Der Proxy wird in `DBusService` instanziiert und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein voll funktionsfähiger NetworkManager-D-Bus-Client, der es NovaDE ermöglicht, den Netzwerkstatus zu überwachen und grundlegende Netzwerkoperationen durchzuführen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken der `zbus::Connection` und des `NetworkManagerProxy`.
    * Testen der Wrapper-Funktionen, um zu verifizieren, dass die D-Bus-Methoden mit den korrekten Argumenten aufgerufen und die Ergebnisse korrekt konvertiert werden.
    * Simulieren von D-Bus-Signalen und Testen, ob die Signal-Handler die internen `NetworkEvent`s korrekt erzeugen und senden.
* **Integration Tests:**
    * Starten des NovaDE-Compositors mit aktivem NetworkManager-Dienst.
    * Verwenden von `nmcli` oder `NetworkManager` APIs, um den Netzwerkstatus zu ändern (z.B. WLAN ein/aus, Verbindung herstellen/trennen).
    * Überprüfen, ob NovaDE über die empfangenen `NetworkEvent`s korrekt auf diese Änderungen reagiert.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da NetworkManager eine komplexe Schnittstelle hat)

---

### **novade-system/src/dbus_interfaces/upower.rs**

**Verantwortlichkeit:**
Implementiert den D-Bus-Client für den UPower-Dienst (`org.freedesktop.UPower`). Dieses Modul ermöglicht es NovaDE, Informationen über Batteriestatus, angeschlossene Stromquellen und den allgemeinen Energieverbrauch des Systems abzurufen und auf Änderungen zu reagieren.

**Kern-Aufgaben (Tasks):**

1.  **`UPowerProxy` Struktur (via `zbus_macros::dbus_proxy`):**
    * Definiere die D-Bus-Schnittstelle für `org.freedesktop.UPower`.
    * Methoden (Beispiele):
        * `enumerate_devices() -> zbus::Result<Vec<zbus::zvariant::ObjectPath<'static>>>`: Listet alle Power-Geräte auf.
        * `get_display_brightness() -> zbus::Result<f64>`: (Optional, falls UPower dies direkt bietet, sonst via `backlight`).
    * Properties (Beispiele):
        * `DaemonVersion`: `READONLY` `String`.
        * `IsSuppressingPowersave`: `READONLY` `bool`.
    * Signals (Beispiele):
        * `DeviceAdded(ObjectPath)`: Emittiert, wenn ein neues Gerät hinzugefügt wird.
        * `DeviceRemoved(ObjectPath)`: Emittiert, wenn ein Gerät entfernt wird.

2.  **`UPowerDeviceProxy` Struktur (via `zbus_macros::dbus_proxy`):**
    * Definiere die D-Bus-Schnittstelle für einzelne UPower-Geräte (`org.freedesktop.UPower.Device`).
    * Methoden (Beispiele):
        * Keine spezifischen Methoden auf dem Device-Objekt, meist Properties.
    * Properties (Beispiele):
        * `PowerSupply`: `READONLY` `bool`.
        * `State`: `READONLY` `u32` (Lade-/Entladezustand).
        * `IsCharging`: `READONLY` `bool`.
        * `Energy`: `READONLY` `f64` (aktuelle Energie in Wh).
        * `EnergyFull`: `READONLY` `f64` (maximale Energie in Wh).
        * `TimeToEmpty`: `READONLY` `i64` (Restlaufzeit in Sekunden).
        * `Type`: `READONLY` `u32` (Typ des Geräts: Battery, AC, UPS etc.).
    * Signals (Beispiele):
        * `PropertiesChanged(HashMap<String, zbus::zvariant::OwnedValue>)`: Generisches Signal für Property-Änderungen des Geräts.

3.  **Wrapper-Funktionen für D-Bus-Aufrufe:**
    * Bieten höherwertige APIs, die `zbus` spezifische Typen kapseln und NovaDE-interne Typen (`novade-core::types::power::*`) verwenden.
    * `pub async fn get_all_power_devices(&self) -> Result<Vec<BatteryInfo>, DBusError>`: Listet alle Power-Geräte und deren Status auf.
    * `pub async fn get_battery_info(device_path: &ObjectPath) -> Result<BatteryInfo, DBusError>`: Ruft Details zu einem spezifischen Gerät ab.

4.  **Signal-Verarbeitung:**
    * Implementiert Methoden, um die `DeviceAdded` und `DeviceRemoved` Signale von `UPowerProxy` zu abonnieren.
    * Implementiert Signal-Handler für `PropertiesChanged` Signale auf einzelnen `UPowerDeviceProxy` Instanzen.
    * Konvertiert die D-Bus-Signal-Payloads in interne `PowerEvent`s (z.B. `PowerEvent::BatteryStatusChanged`, `PowerEvent::DeviceAdded`).
    * Sendet diese Events an einen `tokio::sync::broadcast::Sender` im `DBusService` oder direkt an den `PowerManagementService` der Domänenschicht.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/upower.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DBusError`
    * `novade-core::types::power::{BatteryInfo, PowerState, PowerEventType, PowerEvent}`
* **Extern:**
    * `zbus::{self, Connection, Proxy, zvariant::ObjectPath, zvariant::OwnedValue}`
    * `zbus_macros::dbus_proxy`
    * `tokio`
    * `futures::StreamExt`
    * `std::collections::HashMap`
    * `tracing`
    * `async_trait`

**Kommunikationsmuster:**

* **An UPower D-Bus-Dienst:** Sendet Methodenaufrufe und empfängt Antworten und Signale.
* **An Domänenschicht (`PowerManagementService`):** Sendet `PowerEvent`s über einen Broadcast-Channel, um den Energiestatus zu melden.
* **An `DBusService`:** Die Proxys werden in `DBusService` instanziiert und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein voll funktionsfähiger UPower-D-Bus-Client, der es NovaDE ermöglicht, den Energie- und Batteriestatus präzise zu überwachen und auf kritische Änderungen zu reagieren.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken der `zbus::Connection` und der UPower/UPowerDevice Proxys.
    * Testen der Wrapper-Funktionen, um zu verifizieren, dass die D-Bus-Methoden mit den korrekten Argumenten aufgerufen und die Ergebnisse korrekt konvertiert werden.
    * Simulieren von D-Bus-Signalen (`DeviceAdded`, `DeviceRemoved`, `PropertiesChanged`) und Testen, ob die Signal-Handler die internen `PowerEvent`s korrekt erzeugen und senden.
* **Integration Tests:**
    * Starten des NovaDE-Compositors mit aktivem UPower-Dienst.
    * Simulation von Batterie-Events (z.B. Stromkabel ziehen/stecken, Batteriestand ändern, mit `upower` CLI-Tools oder Hardware-Manipulation).
    * Überprüfen, ob NovaDE über die empfangenen `PowerEvent`s korrekt auf diese Änderungen reagiert und die UI entsprechend aktualisiert.

**Geschätzter Aufwand:** Mittel (ca. 3-5 Tage)

---
### **novade-system/src/dbus_interfaces/logind.rs**

**Verantwortlichkeit:**
Implementiert den D-Bus-Client für den `logind`-Dienst (`org.freedesktop.login1`). Dieses Modul ermöglicht es NovaDE, mit `systemd-logind` zu interagieren, um Sitzungen zu verwalten, den Ruhezustand zu inhibieren (verhindern) und den Systemstatus (Shutdown, Reboot) zu steuern.

**Kern-Aufgaben (Tasks):**

1.  **`LogindProxy` Struktur (via `zbus_macros::dbus_proxy`):**
    * Definiere die D-Bus-Schnittstelle für `org.freedesktop.login1`.
    * Methods (Beispiele):
        * `list_sessions() -> zbus::Result<Vec<(String, u32, String, String, String, String, u32, u32)>>`: Listet alle aktiven Sitzungen auf.
        * `get_session(session_id: &str) -> zbus::Result<zbus::zvariant::ObjectPath<'static>>`: Holt den ObjectPath für eine Sitzung.
        * `inhibit(what: &str, who: &str, mode: &str, hint: &str) -> zbus::Result<zbus::zvariant::OwnedFd>`: Fordert eine Sperre gegen den Ruhezustand an. `what` kann "shutdown", "sleep", "idle", "handle-power-key" sein.
        * `power_off(interactive: bool) -> zbus::Result<()>`: Fährt das System herunter.
        * `reboot(interactive: bool) -> zbus::Result<()>`: Startet das System neu.
        * `suspend(interactive: bool) -> zbus::Result<()>`: Versetzt das System in den Schlafmodus.
        * `hibernate(interactive: bool) -> zbus::Result<()>`: Versetzt das System in den Ruhezustand.
        * `get_session_by_pid(pid: u32) -> zbus::Result<zbus::zvariant::ObjectPath<'static>>`: Holt die Sitzung für einen bestimmten PID.
    * Properties (Beispiele):
        * `NAutoVTs`: `READONLY` `u32`.
        * `IdleHint`: `READONLY` `bool`.
    * Signals (Beispiele):
        * `PrepareForShutdown(bool)`: Emittiert, bevor das System heruntergefahren wird.
        * `PrepareForSleep(bool)`: Emittiert, bevor das System in den Schlafmodus geht.
        * `SessionNew(String, ObjectPath)`: Eine neue Sitzung wurde erstellt.
        * `SessionRemoved(String, ObjectPath)`: Eine Sitzung wurde beendet.

2.  **`LogindSessionProxy` Struktur (via `zbus_macros::dbus_proxy`):**
    * Definiere die D-Bus-Schnittstelle für einzelne `logind`-Sitzungen (`org.freedesktop.login1.Session`).
    * Properties (Beispiele):
        * `Id`: `READONLY` `String`.
        * `User`: `READONLY` `u32`.
        * `Name`: `READONLY` `String`.
        * `Seat`: `READONLY` `String`.
        * `Active`: `READONLY` `bool`.
        * `Type`: `READONLY` `String` (z.B. "wayland").
        * `VTNr`: `READONLY` `u32`.
    * Signals (Beispiele):
        * `PropertiesChanged(HashMap<String, zbus::zvariant::OwnedValue>)`: Generisches Signal für Property-Änderungen der Sitzung.

3.  **Wrapper-Funktionen für D-Bus-Aufrufe:**
    * Bieten höherwertige APIs, die `zbus` spezifische Typen kapseln und NovaDE-interne Typen (`novade-core::types::system_status::*`) verwenden.
    * `pub async fn request_sleep_inhibit(&self, reason: &str) -> Result<zbus::zvariant::OwnedFd, DBusError>`: Fordert eine Schlaf-Inhibitions-Sperre an.
    * `pub async fn shutdown_system(&self) -> Result<(), DBusError>`: Ruft das System-Shutdown auf.
    * `pub async fn get_current_session_info(&self) -> Result<SessionInfo, DBusError>`: Holt Informationen über die aktuelle Sitzung.

4.  **Signal-Verarbeitung:**
    * Implementiert Methoden, um die `PrepareForSleep`, `PrepareForShutdown`, `SessionNew`, `SessionRemoved` Signale von `LogindProxy` zu abonnieren.
    * Konvertiert die D-Bus-Signal-Payloads in interne `SystemEvent`s (z.B. `SystemEvent::PrepareForSleep`).
    * Sendet diese Events an einen `tokio::sync::broadcast::Sender` im `DBusService` oder direkt an den `PowerManagementService` und `SessionManagerService` der Domänenschicht.
    * Wichtig: Der `OwnedFd` von `inhibit` muss korrekt verwaltet werden, um die Sperre aufrechtzuerhalten. Er sollte in einem Struct gespeichert und beim Beenden der Sperre geschlossen werden.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/logind.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DBusError`
    * `novade-core::types::system_status::{SessionInfo, SystemEvent}` (Beispiel)
* **Extern:**
    * `zbus::{self, Connection, Proxy, zvariant::ObjectPath, zvariant::OwnedValue, zvariant::OwnedFd}`
    * `zbus_macros::dbus_proxy`
    * `tokio`
    * `futures::StreamExt`
    * `std::collections::HashMap`
    * `tracing`
    * `async_trait`

**Kommunikationsmuster:**

* **An `logind` D-Bus-Dienst:** Sendet Methodenaufrufe und empfängt Antworten und Signale.
* **An Domänenschicht (`PowerManagementService`, `SessionManagerService`):** Sendet `SystemEvent`s über einen Broadcast-Channel, um den Systemstatus zu melden und Aktionen auszulösen.
* **An `DBusService`:** Der Proxy wird in `DBusService` instanziiert und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein voll funktionsfähiger `logind`-D-Bus-Client, der es NovaDE ermöglicht, Sitzungen zu verwalten, den Ruhezustand zu beeinflussen und Systemaktionen wie Herunterfahren oder Neustart auszulösen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken der `zbus::Connection` und der `LogindProxy`/`LogindSessionProxy`.
    * Testen der Wrapper-Funktionen, um zu verifizieren, dass D-Bus-Methoden korrekt aufgerufen und Ergebnisse konvertiert werden.
    * Simulieren von D-Bus-Signalen (`PrepareForSleep`, `PrepareForShutdown`) und Testen, ob die Signal-Handler die internen `SystemEvent`s korrekt erzeugen und senden.
    * Testen der Handhabung des `OwnedFd` für Inhibitions-Sperren (Open/Close).
* **Integration Tests:**
    * Starten des NovaDE-Compositors.
    * Manuelles Auslösen von `systemctl suspend`/`reboot`/`poweroff` oder Nutzung von `loginctl`.
    * Überprüfen, ob NovaDE die `PrepareForSleep`/`PrepareForShutdown` Events korrekt empfängt und darauf reagiert.
    * Testen der Inhibitions-Sperren: Fordern Sie eine Sperre an und versuchen Sie, das System in den Schlaf zu versetzen; NovaDE sollte den Schlaf verhindern können.

**Geschätzter Aufwand:** Mittel (ca. 3-5 Tage, da Inhibition komplex sein kann)

---

### **novade-system/src/dbus_interfaces/secret_service.rs**

**Verantwortlichkeit:**
Implementiert den D-Bus-Client für die FreeDesktop Secret Service API (`org.freedesktop.secrets`). Dieses Modul ermöglicht es NovaDE, Passwörter, API-Schlüssel und andere sensible Daten sicher und verschlüsselt zu speichern und abzurufen.

**Kern-Aufgaben (Tasks):**

1.  **`SecretServiceProxy` Struktur (via `zbus_macros::dbus_proxy`):**
    * Definiere die D-Bus-Schnittstelle für `org.freedesktop.secrets`.
    * Path: `/org/freedesktop/secrets`
    * Interface: `org.freedesktop.Secret.Service`
    * Methods (Beispiele):
        * `open_session(algorithm: &str, input: &[u8]) -> zbus::Result<(zbus::zvariant::OwnedValue, zbus::zvariant::ObjectPath<'static>)>`: Öffnet eine verschlüsselte Session.
        * `create_collection(properties: HashMap<String, zbus::zvariant::OwnedValue>, alias: &str) -> zbus::Result<(zbus::zvariant::ObjectPath<'static>, zbus::zvariant::ObjectPath<'static>)>`: Erstellt eine neue Sammlung.
        * `search_items(attributes: HashMap<String, String>) -> zbus::Result<(Vec<zbus::zvariant::ObjectPath<'static>>, Vec<zbus::zvariant::ObjectPath<'static>>)>`: Sucht nach Items basierend auf Attributen.
        * `unlock(objects: &[ObjectPath<'static>]) -> zbus::Result<(Vec<ObjectPath<'static>>, ObjectPath<'static>)>`: Entsperrt Sammlungen/Items.
        * `lock(objects: &[ObjectPath<'static>]) -> zbus::Result<(Vec<ObjectPath<'static>>, ObjectPath<'static>)>`: Sperrt Sammlungen/Items.
        * `delete_collection(collection: &ObjectPath) -> zbus::Result<ObjectPath<'static>>`: Löscht eine Sammlung.
        * `get_secrets(items: &[ObjectPath<'static>], session: &ObjectPath) -> zbus::Result<HashMap<ObjectPath<'static>, SecretStruct>>`: Ruft Geheimnisse für mehrere Items ab.
    * Properties (Beispiele):
        * `Collections`: `READONLY` `Vec<ObjectPath<'static>>`.
        * `Sessions`: `READONLY` `Vec<ObjectPath<'static>>`.

2.  **`SecretCollectionProxy` Struktur (via `zbus_macros::dbus_proxy`):**
    * Definiere die D-Bus-Schnittstelle für `org.freedesktop.Secret.Collection`.
    * Properties (Beispiele):
        * `Label`: `READWRITE` `String`.
        * `Locked`: `READONLY` `bool`.
        * `Created`: `READONLY` `u64`.
        * `Modified`: `READONLY` `u64`.
    * Methods:
        * `create_item(properties: HashMap<String, zbus::zvariant::OwnedValue>, secret: SecretStruct, replace: bool) -> zbus::Result<ObjectPath<'static>>`: Fügt ein Geheimnis hinzu.
        * `delete() -> zbus::Result<ObjectPath<'static>>`: Löscht die Sammlung.
        * `search_items(attributes: HashMap<String, String>) -> zbus::Result<Vec<ObjectPath<'static>>>`: Sucht nach Items in dieser Sammlung.

3.  **`SecretItemProxy` Struktur (via `zbus_macros::dbus_proxy`):**
    * Definiere die D-Bus-Schnittstelle für `org.freedesktop.Secret.Item`.
    * Properties (Beispiele):
        * `Locked`: `READONLY` `bool`.
        * `Attributes`: `READWRITE` `HashMap<String, String>`.
        * `Secret`: `READONLY` `SecretStruct`.
    * Methods:
        * `get_secret(session: &ObjectPath) -> zbus::Result<SecretStruct>`: Ruft das Geheimnis ab.
        * `set_secret(secret: SecretStruct) -> zbus::Result<()>`: Setzt das Geheimnis.
        * `delete() -> zbus::Result<ObjectPath<'static>>`: Löscht das Item.

4.  **`SecretStruct` Definition:**
    * `pub struct SecretStruct<'a> { pub session: zbus::zvariant::ObjectPath<'a>, pub parameters: Vec<u8>, pub value: Vec<u8>, pub content_type: String }`
    * Repräsentiert ein Geheimnis, wie es über D-Bus gesendet wird.

5.  **Wrapper-Funktionen und Management-Logik:**
    * Bietet höherwertige APIs für den `SecretService` der Domänenschicht.
    * `pub async fn store_secret(&self, label: &str, attributes: HashMap<String, String>, secret_data: &[u8]) -> Result<(), DBusError>`: Speichert ein Geheimnis.
    * `pub async fn retrieve_secret(&self, attributes: HashMap<String, String>) -> Result<Option<Vec<u8>>, DBusError>`: Ruft ein Geheimnis ab.
    * `pub async fn delete_secret(&self, attributes: HashMap<String, String>) -> Result<(), DBusError>`: Löscht ein Geheimnis.
    * **Session Management:** Automatische Öffnung und Schließung von Sessions (oft "plain" Session, sonst Verschlüsselung via Diffie-Hellman). Das Management von Sessions ist kritisch für die korrekte Nutzung des Secret Service.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/secret_service.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DBusError`
    * `novade-core::types::secret::{SecretAttributes, SecretData}` (Beispiel)
* **Extern:**
    * `zbus::{self, Connection, Proxy, zvariant::{ObjectPath, OwnedValue}, zbus_macros::dbus_proxy}`
    * `tokio`
    * `std::collections::HashMap`
    * `tracing`
    * `async_trait`

**Kommunikationsmuster:**

* **An `Secret Service` D-Bus-Dienst:** Sendet Methodenaufrufe und empfängt Antworten.
* **Von Domänenschicht (`SecretService`):** Wird von der Domänenschicht verwendet, um sichere Daten zu speichern und abzurufen.
* **An `DBusService`:** Der Proxy wird in `DBusService` instanziiert und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein robuster D-Bus-Client für den Secret Service, der NovaDE ermöglicht, sensible Daten sicher und standardkonform zu verwalten.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken der `zbus::Connection` und der verschiedenen Secret Service Proxys.
    * Testen der Wrapper-Funktionen für Speichern, Abrufen und Löschen von Geheimnissen.
    * Simulieren von D-Bus-Antworten (z.B. erfolgreiche/fehlgeschlagene Operationen, fehlende Geheimnisse).
    * Testen der Session-Management-Logik (Öffnen/Schließen von Sessions, Fehlerbehandlung).
* **Integration Tests:**
    * Starten des NovaDE-Compositors.
    * Installieren und Starten eines Secret Service Daemons (z.B. `gnome-keyring-daemon` oder `kwallet`).
    * Speichern und Abrufen von Test-Geheimnissen über NovaDE und Verifikation, dass diese im Secret Service Daemon korrekt persistiert werden.
    * Testen von Sperr-/Entsperr-Szenarien, ggf. mit Benutzerinteraktion (Passworteingabe).

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage, da das Secret Service API komplex ist und Session Management sowie mögliche Benutzerinteraktionen für Entsperrung berücksichtigt werden müssen)

---

### **novade-system/src/dbus_interfaces/policykit.rs**

**Verantwortlichkeit:**
Implementiert den D-Bus-Client für PolicyKit (`org.freedesktop.PolicyKit1`). Dieses Modul ermöglicht es NovaDE, Berechtigungen für privilegierte Aktionen zu überprüfen und gegebenenfalls eine Authentifizierung vom Benutzer anzufordern.

**Kern-Aufgaben (Tasks):**

1.  **`AuthorityProxy` Struktur (via `zbus_macros::dbus_proxy`):**
    * Definiere die D-Bus-Schnittstelle für `org.freedesktop.PolicyKit1.Authority`.
    * Path: `/org/freedesktop/PolicyKit1/Authority`
    * Interface: `org.freedesktop.PolicyKit1.Authority`
    * Methods (Beispiele):
        * `check_authorization(subject: &zbus::zvariant::ObjectPath, action_id: &str, details: &HashMap<String, String>, flags: u32, cancellable: &zbus::zvariant::ObjectPath) -> zbus::Result<(u32, String)>`: Prüft, ob ein Benutzer für eine Aktion autorisiert ist. Flags: `Implicit` (1), `AllowUserInteraction` (2).
        * `authenticate_with_authentication_agent(action_id: &str, cookie: &str, identity: &zbus::zvariant::ObjectPath) -> zbus::Result<(bool)>`: Fordert eine Authentifizierung über einen Authentifizierungsagenten an.
        * `register_authentication_agent(identity: &zbus::zvariant::ObjectPath, locale: &str, object_path: &zbus::zvariant::ObjectPath) -> zbus::Result<()>`: Registriert einen Authentifizierungsagenten.
        * `unregister_authentication_agent(object_path: &zbus::zvariant::ObjectPath) -> zbus::Result<()>`: Deregistriert einen Authentifizierungsagenten.

2.  **`Subject` Helper-Typ (intern):**
    * Repräsentiert das Subjekt, für das eine Autorisierung geprüft wird (z.B. `unix-process` mit PID, `unix-session` mit Session-ID). PolicyKit erwartet `ObjectPath`s für Subjekte, die einem bestimmten Format folgen (z.B. `/org/freedesktop/PolicyKit1/Subject/1234`).
    * Helper-Funktion `current_process_subject() -> ObjectPath<'static>` oder `current_session_subject() -> ObjectPath<'static>`.

3.  **`AuthenticationAgent` (optional, aber empfohlen für NovaDE):**
    * NovaDE sollte einen eigenen PolicyKit-Authentifizierungsagenten implementieren, um Passworteingaben in der NovaDE-UI zu ermöglichen, anstatt auf externe Agenten angewiesen zu sein.
    * Dies wäre eine D-Bus-Server-Seite, die die `org.freedesktop.PolicyKit1.AuthenticationAgent` Schnittstelle implementiert.
    * Das `DBusService` müsste dieses Objekt auf dem Session-Bus registrieren.

4.  **Wrapper-Funktionen für D-Bus-Aufrufe:**
    * Bietet höherwertige APIs für die `PolicyService` der Domänenschicht.
    * `pub async fn check_permission(&self, action_id: &str, allow_user_interaction: bool, reason: &str) -> Result<PermissionResult, DBusError>`:
        * Ruft `check_authorization` auf.
        * Wenn `result.is_granted` `false` ist und `allow_user_interaction` `true`, dann wird der Authentifizierungsagent gestartet/genutzt.
        * Konvertiert das Ergebnis in ein internes `PermissionResult` Enum (`Granted`, `Denied`, `AuthenticationRequired`).
        * `PermissionResult` Enum mit Status und ggf. einem `AuthCookie` oder `IdentityPath`.
    * `pub async fn authenticate(&self, action_id: &str, cookie: &str, identity: &zbus::zvariant::ObjectPath) -> Result<(), DBusError>`: Führt die eigentliche Authentifizierung durch.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/policykit.rs`
* `novade-system/src/dbus_interfaces/policykit_agent.rs` (falls NovaDE einen eigenen Agenten implementiert)

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DBusError`
    * `novade-core::types::security::{PermissionResult}` (Beispiel)
* **Extern:**
    * `zbus::{self, Connection, Proxy, zvariant::ObjectPath, zvariant::OwnedValue}`
    * `zbus_macros::dbus_proxy`
    * `tokio`
    * `std::collections::HashMap`
    * `tracing`
    * `async_trait`
    * `libc` (für PID, wenn `unix-process` Subjekt verwendet wird)

**Kommunikationsmuster:**

* **An PolicyKit D-Bus-Dienst:** Sendet Methodenaufrufe und empfängt Antworten.
* **An Domänenschicht (`PolicyService`):** Wird von der Domänenschicht verwendet, um Berechtigungen zu prüfen und Authentifizierung anzufordern.
* **Von PolicyKit D-Bus-Dienst an NovaDE Agent (falls implementiert):** PolicyKit ruft Methoden auf dem NovaDE Authentication Agent auf, um Authentifizierungsaufforderungen anzuzeigen.
* **An `DBusService`:** Der Proxy wird in `DBusService` instanziiert und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger PolicyKit-D-Bus-Client, der es NovaDE ermöglicht, administrative Aktionen sicher durchzuführen und bei Bedarf eine Authentifizierung des Benutzers über eine integrierte oder externe Schnittstelle anzufordern.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken der `zbus::Connection` und des `AuthorityProxy`.
    * Testen der `check_permission` Funktion mit verschiedenen `action_id`s und `flags` (z.B. mit/ohne `AllowUserInteraction`).
    * Simulieren von D-Bus-Antworten für `check_authorization` (Granted, Denied, AuthRequired).
    * Wenn ein Agent implementiert wird: Testen der `AuthenticationAgent` Implementierung.
* **Integration Tests:**
    * Starten des NovaDE-Compositors.
    * Definieren einer PolicyKit-Regel, die für eine Test-Aktion eine Authentifizierung erfordert (z.B. mittels einer `.pkla` Datei).
    * Versuchen, diese Test-Aktion über NovaDE auszulösen.
    * Überprüfen, ob NovaDE die Authentifizierungsaufforderung korrekt anzeigt (wenn ein Agent implementiert) oder PolicyKit den Dialog öffnet und die Aktion nach erfolgreicher Authentifizierung ausgeführt wird.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, besonders wenn ein eigener Authentifizierungsagent implementiert wird)

---
### **novade-system/src/dbus_interfaces/notifications_server.rs**

**Verantwortlichkeit:**
Implementiert den D-Bus-Server für den FreeDesktop Notifications Service (`org.freedesktop.Notifications`). Dieses Modul ermöglicht es anderen Anwendungen, Benachrichtigungen an NovaDE zu senden, die dann von der Domänenschicht (`NotificationService`) verarbeitet und von der UI-Schicht angezeigt werden.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationsServer` Struktur:**
    * Felder:
        * `notification_service: Arc<NotificationService>`: Referenz auf den Service der Domänenschicht, der die Benachrichtigungslogik enthält.
    * Implementiere `new()`-Funktion.

2.  **Implementierung des `org.freedesktop.Notifications` D-Bus-Interfaces (via `zbus_macros::dbus_interface`):**
    * Pfad: `/org/freedesktop/Notifications`
    * Interface: `org.freedesktop.Notifications`
    * **Methoden:**
        * `get_capabilities() -> zbus::fdo::Result<Vec<String>>`:
            * Returns the capabilities of the notification server (e.g., "body", "actions", "persistence"). NovaDE sollte mindestens `body`, `actions`, `persistence`, `body-markup`, `private-notifications` unterstützen.
        * `notify(app_name: String, replaces_id: u32, app_icon: String, summary: String, body: String, actions: Vec<String>, hints: HashMap<String, zbus::zvariant::OwnedValue>, expire_timeout: i32) -> zbus::fdo::Result<u32>`:
            * Diese Methode ist der Haupt-Eingangspunkt für neue Benachrichtigungen.
            * `app_name`: Name der Anwendung, die die Benachrichtigung sendet.
            * `replaces_id`: ID einer zu ersetzenden Benachrichtigung (0, wenn neu).
            * `app_icon`: URI des Anwendungs-Icons.
            * `summary`: Kurze Überschrift der Benachrichtigung.
            * `body`: Detaillierter Text der Benachrichtigung.
            * `actions`: Liste von Action-IDs und Labels (`"action_key\0Action Label\0action_key2\0Action Label 2"`).
            * `hints`: Zusätzliche Hinweise (z.B. "category", "urgency", "desktop-entry", "image-data").
            * `expire_timeout`: Zeit in ms, nach der die Benachrichtigung ablaufen soll (-1 für Standard).
            * **Intern:** Konvertiert die D-Bus-Parameter in eine interne `Notification` Struktur (`novade-core::types::notification::Notification`).
            * Ruft eine Methode auf `notification_service` auf, um die Benachrichtigung zu verarbeiten (z.B. `notification_service.show_notification(notification)`).
            * Gibt eine neue Benachrichtigungs-ID zurück (generiert vom `NotificationService`).
        * `close_notification(id: u32) -> zbus::fdo::Result<()>`:
            * Fordert das Schließen einer Benachrichtigung an.
            * Ruft eine Methode auf `notification_service` auf (z.B. `notification_service.close_notification(id)`).
        * `get_server_information() -> zbus::fdo::Result<(String, String, String, String)>`:
            * Returns `(name, vendor, version, spec_version)`. Z.B. `("NovaDE Notifications", "NovaDE", "0.1.0", "1.2")`.
    * **Signale:**
        * `NotificationClosed(u32, u32)`:
            * Emittiert, wenn eine Benachrichtigung geschlossen wird (ID, Grund: `Expired=1`, `Dismissed=2`, `ClosedByCall=3`, `Undef=4`).
        * `ActionInvoked(u32, String)`:
            * Emittiert, wenn eine Aktion auf einer Benachrichtigung ausgeführt wird (ID, Action-Key).

3.  **Implementierung von `NotificationsServer::new()`:**
    * `pub fn new(notification_service: Arc<NotificationService>) -> Self`: Erstellt eine neue Instanz.

4.  **Signal-Emission:**
    * Die Signale `NotificationClosed` und `ActionInvoked` müssen vom `NotificationsServer` emittiert werden, wenn die Domänenschicht (`NotificationService`) entsprechende Ereignisse signalisiert. Dies erfordert, dass `NotificationService` einen Callback oder einen Channel zur Verfügung stellt, über den der `NotificationsServer` informiert werden kann.
    * Eventuell speichert `NotificationsServer` eine `zbus::SignalContext` Referenz, um Signale senden zu können.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/notifications_server.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DBusError`
    * `novade-core::types::notification::{Notification, NotificationAction, NotificationUrgency, NotificationCategory}`
    * `novade-domain::notification_service::service::NotificationService`
* **Extern:**
    * `zbus::{self, fdo, zvariant::OwnedValue, zbus_macros::dbus_interface, SignalContext}`
    * `tokio`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `tracing`
    * `async_trait`

**Kommunikationsmuster:**

* **Von externen D-Bus-Clients:** Empfängt Methodenaufrufe für Benachrichtigungen (z.B. `notify-send`).
* **An Domänenschicht (`NotificationService`):** Delegiert die Verarbeitung der Benachrichtigungen an den `NotificationService`.
* **Von Domänenschicht (`NotificationService`):** Empfängt Rückmeldungen (z.B. Benachrichtigung geschlossen, Aktion ausgeführt) und emittiert entsprechende D-Bus-Signale an externe Clients.
* **An `DBusService`:** Der `NotificationsServer` wird in `DBusService` instanziiert und auf dem D-Bus registriert.

**Erwartete Ergebnisse/Outputs:**
Ein voll funktionsfähiger FreeDesktop Notifications Server, der es anderen Anwendungen ermöglicht, Benachrichtigungen an NovaDE zu senden, und der die Spezifikation `org.freedesktop.Notifications` vollständig implementiert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken des `NotificationService`.
    * Testen der `get_capabilities` und `get_server_information` Methoden.
    * Testen der `notify` Methode: Verifizieren, dass die Argumente korrekt in eine `Notification` Struktur konvertiert und an den `NotificationService` weitergeleitet werden.
    * Testen der `close_notification` Methode.
    * Testen der Signal-Emission, indem der `NotificationService` Mock entsprechende "closed" oder "action invoked" Ereignisse auslöst.
* **Integration Tests:**
    * Starten des NovaDE-Compositors mit dem `NotificationsServer`.
    * Verwenden eines externen D-Bus-Clients (z.B. `notify-send`) zum Senden verschiedener Benachrichtigungen (einfach, mit Aktionen, mit Ersetzungs-ID, mit Hints).
    * Überprüfen, ob NovaDE die Benachrichtigungen korrekt anzeigt und verarbeitet.
    * Testen des Schließens von Benachrichtigungen über `notify-send --close <ID>` und Überprüfen, ob NovaDE die Benachrichtigung entfernt.
    * Testen der Interaktion mit Aktionen: Wenn eine Aktion in der NovaDE-UI geklickt wird, muss das `ActionInvoked` Signal korrekt an den `notify-send` Client zurückgesendet werden.

**Geschätzter Aufwand:** Mittel (ca. 3-5 Tage, da die Spezifikation detailliert ist und Callback-Mechanismen für Signale implementiert werden müssen)

---

### **novade-system/src/audio_management**

**Verantwortlichkeit:**
Dieses Modul ist für die Interaktion mit dem Audio-System (PipeWire) zuständig. Es ermöglicht NovaDE, die Lautstärke zu steuern, Audiogeräte zu erkennen, Audio-Streams zu verwalten (z.B. Stummschalten, Verschieben zwischen Ausgängen) und auf Audio-Ereignisse zu reagieren.

**Kern-Aufgaben (Tasks):**

1.  **`AudioService` Struktur:**
    * Felder:
        * `pipewire_client: Arc<pipewire::main_loop::MainLoop>` (Der PipeWire MainLoop).
        * `core: Arc<pipewire::core::Core>` (Die PipeWire Core-Verbindung).
        * `node_listener: Arc<pipewire::node::NodeListener>` (Listener für Node-Events).
        * `current_volume: RwLock<f64>` (Aktuelle globale Lautstärke, 0.0-1.0).
        * `is_muted: RwLock<bool>` (Globaler Stummschaltungsstatus).
        * `output_devices: RwLock<HashMap<u32, AudioDeviceInfo>>` (Map von Node-ID zu Audio-Geräteinformationen).
        * `active_output_device: RwLock<Option<u32>>` (ID des aktuell aktiven Ausgabegeräts).
        * `sender: Sender<AudioEvent>` (Broadcast-Sender für Audio-Events an die Domänenschicht).
        * `receiver: Receiver<AudioEvent>` (Broadcast-Receiver-Template).

2.  **`AudioService::new()` Funktion:**
    * `pub async fn new() -> Result<Arc<Self>, AudioError>`
    * Initialisiert die PipeWire-Bibliothek (`pipewire::init()`).
    * Erstellt einen PipeWire `MainLoop` und `Core`.
    * Verbindet mit dem PipeWire Daemon.
    * **Node-Listener einrichten:** Registriert einen Listener für PipeWire-Nodes, um Änderungen an Audiogeräten und Streams zu erkennen.
        * Callback für `node_added`: Fügt neue Audio-Geräte (`AudioDeviceInfo`) zu `output_devices` hinzu.
        * Callback für `node_removed`: Entfernt Geräte aus `output_devices`.
        * Callback für `node_changed`: Aktualisiert den Status existierender Geräte (z.B. Lautstärkeänderungen auf dem Node).
    * Initialisiert `current_volume`, `is_muted`, `output_devices`, `active_output_device` basierend auf dem initialen PipeWire-Zustand.
    * Erstellt `tokio::sync::broadcast::channel` für `AudioEvent`s.

3.  **`AudioService::run_event_loop()` Funktion:**
    * `pub async fn run_event_loop(service: Arc<AudioService>) -> Result<(), AudioError>`
    * Startet den PipeWire `MainLoop` in einem separaten Tokio-Task, um PipeWire-Events asynchron zu verarbeiten.
    * Dies sollte sicherstellen, dass PipeWire-Callbacks im richtigen Kontext ausgeführt werden.

4.  **Steuerungs-Methoden:**
    * `pub async fn set_volume(&self, volume: f64) -> Result<(), AudioError>`:
        * Setzt die globale Lautstärke.
        * Iteriert über relevante Sink-Nodes (Ausgabegeräte) und setzt deren Lautstärke.
        * Sendet `AudioEvent::VolumeChanged`.
    * `pub async fn set_muted(&self, muted: bool) -> Result<(), AudioError>`:
        * Setzt den globalen Stummschaltungsstatus.
        * Setzt den Mute-Status für alle relevanten Sink-Nodes.
        * Sendet `AudioEvent::MutedChanged`.
    * `pub async fn get_current_volume(&self) -> f64`: Gibt die aktuelle Lautstärke zurück.
    * `pub async fn is_muted(&self) -> bool`: Gibt den Mute-Status zurück.
    * `pub async fn get_output_devices(&self) -> HashMap<u32, AudioDeviceInfo>`: Gibt eine Liste der verfügbaren Ausgabegeräte zurück.
    * `pub async fn set_active_output_device(&self, device_id: u32) -> Result<(), AudioError>`:
        * Ändert das aktive Ausgabegerät (Verschiebt z.B. alle relevanten Streams).
        * Sendet `AudioEvent::ActiveOutputDeviceChanged`.

5.  **Helper-Funktionen für PipeWire-Interaktion:**
    * Funktionen zum Filtern von Nodes nach Typ (Sink, Source, Stream).
    * Funktionen zum Abrufen von Node-Properties (z.B. Lautstärke, Mute, Name).
    * Funktionen zum Setzen von Node-Parametern.

6.  **`AudioEvent` Enum (`novade-core::types::audio::AudioEvent`):**
    * `VolumeChanged(f64)`
    * `MutedChanged(bool)`
    * `ActiveOutputDeviceChanged(u32)`
    * `DeviceAdded(AudioDeviceInfo)`
    * `DeviceRemoved(u32)`
    * `StreamAdded(AudioStreamInfo)`
    * `StreamRemoved(u32)`

7.  **`AudioDeviceInfo` und `AudioStreamInfo` Strukturen:**
    * Definieren die Daten für Audiogeräte und Streams (Name, ID, Typ, Zustand, etc.).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_management/mod.rs`
* `novade-system/src/audio_management/service.rs`
* `novade-system/src/audio_management/error.rs` (`AudioError` Enum)
* `novade-system/src/audio_management/data_types.rs` (falls komplexere PW-spezifische D-Typen benötigt werden)

**Abhängigkeiten:**

* **Intern:**
    * `crate::audio_management::error::AudioError`
    * `novade-core::types::audio::{AudioEvent, AudioDeviceInfo, AudioStreamInfo}`
* **Extern:**
    * `pipewire::{self, prelude::*, main_loop, core, node}`
    * `tokio`
    * `std::sync::Arc`
    * `parking_lot::RwLock`
    * `std::collections::HashMap`
    * `tokio::sync::broadcast::{channel, Sender, Receiver}`
    * `tracing`
    * `async_trait`

**Kommunikationsmuster:**

* **An PipeWire Daemon:** Über `pipewire-rs` API.
* **Von PipeWire Daemon:** Empfängt Events über den `MainLoop` und Listener.
* **An Domänenschicht (`AudioManagementService`):** Sendet `AudioEvent`s über einen Broadcast-Channel.
* **An `SystemServices`:** Wird bei der Initialisierung der Systemschicht aufgerufen und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein stabiles und umfassendes Audio-Management-System, das NovaDE die volle Kontrolle über die Audio-Wiedergabe ermöglicht und Echtzeit-Updates über den Audio-Systemstatus bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken des `pipewire-rs` Clients, um simulierte PipeWire-Events zu erzeugen.
    * Testen der `set_volume` und `set_muted` Funktionen: Verifizieren, dass die korrekten Befehle an die gemockte PipeWire-Schnittstelle gesendet und die internen Zustände aktualisiert werden.
    * Testen der Event-Weiterleitung: Sicherstellen, dass `AudioEvent`s korrekt generiert und über den Broadcast-Channel gesendet werden, wenn sich der simulierte PipeWire-Zustand ändert.
    * Testen der Geräte- und Stream-Erkennung (Add/Remove/Change).
* **Integration Tests:**
    * Starten des NovaDE-Compositors mit aktivem PipeWire-Daemon.
    * Verwendung von `pactl` (oder `pw-cli`) zum Ändern der Lautstärke, Stummschalten, Hinzufügen/Entfernen von Audiogeräten.
    * Überprüfen, ob NovaDE auf diese Änderungen reagiert und die UI entsprechend aktualisiert.
    * Testen der Steuerung von NovaDE (z.B. über ein UI-Widget): Verifizieren, dass die Lautstärkeänderungen im PipeWire-System reflektiert werden.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da PipeWire API komplex ist und asynchrone Event-Verarbeitung erfordert)

---

### **novade-system/src/audio_management/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`AudioError`) für das `audio_management`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung für Audio-Interaktionen sicher und ermöglicht eine präzise Fehlerweiterleitung.

**Kern-Aufgaben (Tasks):**

1.  **`AudioError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `PipewireInitializationError(String)`: Fehler bei der Initialisierung von PipeWire.
        * `PipewireConnectionError(String)`: Fehler beim Verbindungsaufbau zum PipeWire Daemon.
        * `NodeNotFoundError(u32)`: Ein spezifischer Audio-Node (Gerät/Stream) wurde nicht gefunden.
        * `InvalidVolume(f64)`: Ungültiger Lautstärkewert (z.B. außerhalb des Bereichs 0.0-1.0).
        * `OperationFailed(String)`: Eine PipeWire-Operation ist fehlgeschlagen.
        * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_management/error.rs`

**Abhängigkeiten:**

* **Intern:** Keine direkten Abhängigkeiten.
* **Extern:**
    * `thiserror::Error`
    * `std::io::Error`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `audio_management`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im `audio_management`-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `AudioError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---
### **novade-system/src/power_management**

**Verantwortlichkeit:**
Dieses Modul ist für die systemweite Energieverwaltung zuständig. Es interagiert mit `systemd-logind` und D-Bus, um Schlaf- und Herunterfahrungsaktionen zu initiieren, Inhibit-Sperren zu verwalten (um den Ruhezustand zu verhindern) und auf Änderungen des Systemstromzustands zu reagieren. Es stellt eine API für die Domänenschicht bereit, um den Energieverbrauch zu steuern und zu überwachen.

**Kern-Aufgaben (Tasks):**

1.  **`PowerManagementService` Struktur:**
    * Felder:
        * `logind_proxy: Arc<dbus_interfaces::logind::LogindProxy>` (D-Bus Proxy für `logind`).
        * `upower_proxy: Arc<dbus_interfaces::upower::UPowerProxy>` (D-Bus Proxy für UPower).
        * `settings_service: Arc<GlobalSettingsService>` (Referenz auf den Global Settings Service der Domäne, um Energie-Einstellungen zu lesen).
        * `inhibitors: RwLock<Vec<InhibitorHandle>>` (Liste der aktiven Inhibitor-Handles, um den Ruhezustand zu verhindern).
        * `sender: Sender<PowerEvent>` (Broadcast-Sender für `PowerEvent`s an die Domänenschicht).
        * `receiver: Receiver<PowerEvent>` (Broadcast-Receiver-Template).
        * `dpms_control: Arc<dyn DPMSControl>` (Trait-Objekt zur Steuerung des DPMS-Zustands, z.B. Bildschirm ausschalten).

2.  **`InhibitorHandle` Struktur:**
    * Beinhaltet den `zbus::zvariant::OwnedFd` des `logind` Inhibitor-Fds und Metadaten (Grund, Typ der Sperre).
    * Implementiert `Drop`, um den File Descriptor beim Verlassen des Scopes automatisch zu schließen und die Inhibitions-Sperre freizugeben.

3.  **`DPMSControl` Trait:**
    * `pub trait DPMSControl: Send + Sync`:
        * `fn set_dpms_state(&self, state: DPMSState) -> Result<(), PowerError>`: Steuert den DPMS-Zustand des Bildschirms (`On`, `Off`, `Suspend`, `Standby`). Die Implementierung kann durch den Compositor (Smithay) oder direkte DRM/KMS-Interaktion erfolgen.
    * Eine konkrete Implementierung dieses Traits muss im Compositor bereitgestellt werden, z.B. durch den `DesktopState` oder einen spezifischen Display-Manager.

4.  **`PowerManagementService::new()` Funktion:**
    * `pub async fn new(logind_proxy: Arc<logind::LogindProxy>, upower_proxy: Arc<upower::UPowerProxy>, settings_service: Arc<GlobalSettingsService>, dpms_control: Arc<dyn DPMSControl>) -> Result<Arc<Self>, PowerError>`
    * Initialisiert die Felder.
    * Erstellt `tokio::sync::broadcast::channel` für `PowerEvent`s.
    * Abonnieren relevanter D-Bus-Signale von `logind` (`PrepareForSleep`, `PrepareForShutdown`) und UPower (`DeviceAdded`, `DeviceRemoved`, `PropertiesChanged` von Geräten).
    * Startet einen Task, der diese Signale überwacht und `PowerEvent`s über den Sender verschickt.

5.  **`PowerManagementService::run_event_loop()` Funktion:**
    * `pub async fn run_event_loop(service: Arc<PowerManagementService>) -> Result<(), PowerError>`
    * Die main loop, die auf Power-Events reagiert (vom UPower-Proxy und Logind-Proxy) und intern oder an die Domänenschicht weiterleitet.
    * Implementiert die Logik für automatisches Sperren/Schlafen basierend auf Inaktivität (benötigt Input-Events vom `InputService`).

6.  **Steuerungs-Methoden:**
    * `pub async fn shutdown(&self, interactive: bool) -> Result<(), PowerError>`: Fährt das System über `logind` herunter.
    * `pub async fn reboot(&self, interactive: bool) -> Result<(), PowerError>`: Startet das System über `logind` neu.
    * `pub async fn suspend(&self, interactive: bool) -> Result<(), PowerError>`: Versetzt das System über `logind` in den Schlafmodus.
    * `pub async fn hibernate(&self, interactive: bool) -> Result<(), PowerError>`: Versetzt das System über `logind` in den Ruhezustand.
    * `pub async fn request_inhibit(&self, what: InhibitWhat, who: String, reason: String, mode: InhibitMode) -> Result<InhibitorHandle, PowerError>`:
        * Fordert eine Inhibitions-Sperre von `logind` an.
        * Erstellt und verwaltet ein `InhibitorHandle`.
    * `pub async fn release_inhibit(&self, handle: InhibitorHandle) -> Result<(), PowerError>`: Gibt eine Inhibitions-Sperre explizit frei.
    * `pub async fn get_battery_info(&self) -> Result<Vec<BatteryInfo>, PowerError>`: Ruft aktuelle Batterieinformationen über den `upower_proxy` ab.
    * `pub async fn set_display_state(&self, state: DisplayState) -> Result<(), PowerError>`: Steuert den Anzeigestatus (ein/aus/schlafend) über `dpms_control`.

7.  **Automatische Power-Management-Logik:**
    * Regelmäßige Überprüfung der System-Inaktivität (erfordert den `InputService` zu abonnieren oder einen Mechanismus, um die letzte Aktivität zu erhalten).
    * Basierend auf `GlobalSettingsService` (Idle-Timeout, Auto-Suspend-Einstellungen):
        * Automatische Display-Abschaltung.
        * Automatische Suspendierung.
    * Reagiert auf `PrepareForSleep` und `PrepareForShutdown` Signale von `logind` zur Vorbereitung des Systems.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management/mod.rs`
* `novade-system/src/power_management/service.rs`
* `novade-system/src/power_management/error.rs` (`PowerError` Enum)
* `novade-system/src/power_management/dpms_control.rs` (Trait und eine Beispiel-Implementierung, die an `DesktopState` deligiert)

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::logind::LogindProxy`
    * `crate::dbus_interfaces::upower::UPowerProxy`
    * `crate::power_management::error::PowerError`
    * `novade-core::types::power::{PowerEvent, BatteryInfo, DisplayState, DPMSState, InhibitWhat, InhibitMode}`
    * `novade-core::types::system_status::{SystemEvent}`
    * `novade-domain::global_settings::service::GlobalSettingsService`
* **Extern:**
    * `tokio`
    * `std::sync::Arc`
    * `parking_lot::RwLock`
    * `tokio::sync::broadcast::{channel, Sender, Receiver}`
    * `tracing`
    * `async_trait`
    * `zbus::zvariant::OwnedFd`

**Kommunikationsmuster:**

* **An `logind` und UPower D-Bus-Dienste:** Über die jeweiligen Proxys.
* **Von `logind` und UPower D-Bus-Dienste:** Empfängt Signale über die Proxys.
* **An Domänenschicht (`PowerManagementService`):** Sendet `PowerEvent`s über einen Broadcast-Channel.
* **Von Domänenschicht (z.B. `DesktopManagerService`):** Empfängt Aufrufe für Systemaktionen (Shutdown, Suspend) oder zur Anforderung von Inhibitor-Sperren.
* **An `SystemServices`:** Wird bei der Initialisierung der Systemschicht aufgerufen und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und reaktionsfähiges Energieverwaltungssystem, das NovaDE die Kontrolle über den Systemstromzustand, die Batteriestatusüberwachung und die präzise Verwaltung von Inhibit-Sperren ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken des `LogindProxy`, `UPowerProxy` und `GlobalSettingsService`.
    * Testen der `shutdown`, `reboot`, `suspend`, `hibernate` Methoden, um zu verifizieren, dass die korrekten `logind` Aufrufe erfolgen.
    * Testen der `request_inhibit` und `release_inhibit` Methoden, einschließlich der korrekten Verwaltung des `OwnedFd`s.
    * Testen der `InhibitorHandle::drop` Implementierung.
    * Simulieren von `logind` und UPower Signalen und Verifizieren, dass die `PowerEvent`s korrekt gesendet werden.
    * Testen der `set_display_state` Funktion und der Interaktion mit dem `DPMSControl` Trait.
* **Integration Tests:**
    * Starten des NovaDE-Compositors.
    * Manuelles Auslösen von `systemctl suspend`/`reboot`/`poweroff` oder Nutzung von `loginctl` und Überprüfen, ob NovaDE korrekt darauf reagiert.
    * Testen der Inhibitions-Sperren: Eine Anwendung oder NovaDE selbst fordert eine Sperre an, dann wird versucht, das System in den Schlaf zu versetzen. NovaDE sollte den Schlaf verhindern.
    * Testen der automatischen Power-Management-Logik (z.B. Idle-Timeout für Display-Abschaltung).
    * Simulieren von Batterieänderungen und Überprüfen, ob die UI korrekt aktualisiert wird.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da die Integration mit `logind`, UPower und die Inhibit-Logik komplex sind)

---

### **novade-system/src/power_management/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`PowerError`) für das `power_management`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung für Energieverwaltungs-Interaktionen sicher und ermöglicht eine präzise Fehlerweiterleitung.

**Kern-Aufgaben (Tasks):**

1.  **`PowerError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `LogindError(#[from] crate::dbus_interfaces::error::DBusError)`: Fehler vom `logind` D-Bus-Proxy.
        * `UPowerError(#[from] crate::dbus_interfaces::error::DBusError)`: Fehler vom UPower D-Bus-Proxy.
        * `InvalidStateTransition(String)`: Eine angeforderte Zustandsänderung ist im aktuellen Systemzustand nicht gültig.
        * `InhibitFailed(String)`: Eine Anforderung für eine Inhibitions-Sperre ist fehlgeschlagen.
        * `ReleaseInhibitFailed(String)`: Das Freigeben einer Inhibitions-Sperre ist fehlgeschlagen.
        * `DPMSControlError(String)`: Fehler bei der Steuerung des DPMS-Zustands.
        * `ConfigurationError(String)`: Fehler beim Lesen von Energie-Einstellungen.
        * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management/error.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DBusError`
* **Extern:**
    * `thiserror::Error`
    * `std::io::Error`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `power_management`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im `power_management`-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `PowerError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler (insbesondere für `DBusError` Konvertierungen).

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---

### **novade-system/src/mcp_client**

**Verantwortlichkeit:**
Dieses Modul implementiert den Client für das Model Context Protocol (MCP), ein von NovaDE entwickeltes Protokoll für die sichere und performante Kommunikation mit externen KI-Modellen und Agenten. Es ist verantwortlich für die Etablierung von Verbindungen, die Serialisierung/Deserialisierung von Nachrichten und die Handhabung des Kommunikations-Lebenszyklus.

**Kern-Aufgaben (Tasks):**

1.  **`MCPClient` Struktur:**
    * Felder:
        * `connection: tokio::net::TcpStream` (oder `tokio_vsock::VsockStream` für VSOCK).
        * `read_buffer: Vec<u8>` (Puffer für eingehende Daten).
        * `write_buffer: Vec<u8>` (Puffer für ausgehende Daten).
        * `message_codec: Arc<Mutex<mcp_codec::MCPCodec>>` (Codec für MCP-Nachrichten, ggf. mit Verschlüsselung).
        * `response_tx: Sender<MCPResponse>` (Broadcast-Sender für Antworten vom Modell).
        * `response_rx: Receiver<MCPResponse>` (Broadcast-Receiver-Template).
        * `request_id_counter: AtomicU64` (Zähler für eindeutige Request-IDs).

2.  **`mcp_codec` Modul/Crate:**
    * Muss separat definiert werden, oder zumindest die `MCPCodec` Logik hier implementiert werden.
    * **Verantwortlichkeit:** Serialisierung und Deserialisierung von MCP-Nachrichten, Header-Parsing, Payload-Verschlüsselung/-Entschlüsselung (falls im MCP vorgesehen).
    * Methoden: `encode(message: MCPMessage) -> Result<Vec<u8>, MCPError>`, `decode(buffer: &[u8]) -> Result<Option<MCPMessage>, MCPError>`.

3.  **`MCPClient::new()` Funktion:**
    * `pub async fn new(address: String, encryption_key: Option<Vec<u8>>) -> Result<Arc<Self>, MCPError>`
    * Stellt eine TCP- oder VSOCK-Verbindung zur angegebenen Adresse her.
    * Initialisiert den `MCPCodec` (ggf. mit Verschlüsselung).
    * Erstellt `tokio::sync::broadcast::channel` für `MCPResponse`s.

4.  **`MCPClient::send_request()` Funktion:**
    * `pub async fn send_request(&self, request: MCPRequest) -> Result<MCPResponse, MCPError>`
    * Generiert eine neue `request_id`.
    * Serialisiert den `MCPRequest` über den `MCPCodec`.
    * Sendet die serialisierten Daten über die Netzwerkverbindung.
    * Wartet auf eine Antwort mit der entsprechenden `request_id` (via `response_rx` Filterung) oder einen Timeout.

5.  **`MCPClient::receive_loop()` Funktion:**
    * `pub async fn receive_loop(client: Arc<MCPClient>) -> Result<(), MCPError>`
    * Eine Endlos-Schleife, die Daten von der Netzwerkverbindung liest.
    * Nutzt den `MCPCodec`, um vollständige Nachrichten aus dem Puffer zu dekodieren.
    * Bei jeder dekodierten `MCPMessage`:
        * Unterscheidet zwischen `MCPResponse` und `MCPEvent`.
        * Wenn `MCPResponse`: Sendet an den `response_tx` Broadcast-Channel.
        * Wenn `MCPEvent`: Sendet an einen separaten `event_tx` Broadcast-Channel (oder den Haupt-Client-Sender für Events).

6.  **`MCPRequest`, `MCPResponse`, `MCPEvent`, `MCPMessage` Enums/Strukturen:**
    * Diese sollten in `novade-core::types::mcp` definiert werden.
    * `MCPMessage`: Ein Enum, das `Request`, `Response`, `Event` kapselt.
    * `MCPRequest`: Enthält `request_id`, `command` (Enum für Befehle wie `GetContext`, `ExecuteAction`, `QueryData`), `payload`.
    * `MCPResponse`: Enthält `request_id`, `status` (Success/Error), `payload`.
    * `MCPEvent`: Enthält `event_type`, `payload`.

7.  **Reconnect-Logik und Fehlerbehandlung:**
    * Implementierung einer robusten Wiederverbindungslogik bei Verbindungsabbruch.
    * Fehlerbehandlung für Netzwerkfehler, Serialisierungsfehler und Protokollverletzungen.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/mcp_client/mod.rs`
* `novade-system/src/mcp_client/client.rs`
* `novade-system/src/mcp_client/codec.rs` (oder separate `novade-mcp-codec` crate)
* `novade-system/src/mcp_client/error.rs` (`MCPError` Enum)

**Abhängigkeiten:**

* **Intern:**
    * `crate::mcp_client::error::MCPError`
    * `novade-core::types::mcp::{MCPRequest, MCPResponse, MCPEvent, MCPMessage}`
* **Extern:**
    * `tokio::{self, net::{TcpStream, ToSocketAddrs}, sync::broadcast::{channel, Sender, Receiver}}`
    * `tokio_vsock` (falls VSOCK-Unterstützung implementiert wird)
    * `futures::StreamExt`
    * `std::sync::Arc`
    * `parking_lot::Mutex`
    * `std::sync::atomic::{AtomicU64, Ordering}`
    * `bytes::{BytesMut, Buf}` (für effizientes Puffer-Management)
    * `tracing`
    * `serde::{Serialize, Deserialize}` (für Payload-Serialisierung)

**Kommunikationsmuster:**

* **An externe KI-Modelle/Agenten:** Über TCP/VSOCK-Verbindung, sendet MCP-Nachrichten.
* **Von externen KI-Modellen/Agenten:** Empfängt MCP-Nachrichten und leitet `MCPResponse`s an den Anfragenden und `MCPEvent`s an alle Listener in der Domänenschicht weiter.
* **Von Domänenschicht (`AIIntegrationService`):** Empfängt `MCPRequest`s zur Verarbeitung.
* **An Domänenschicht (`AIIntegrationService`):** Sendet `MCPResponse`s und `MCPEvent`s.
* **An `SystemServices`:** Wird bei der Initialisierung der Systemschicht aufgerufen und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein robuster und sicherer Client für das Model Context Protocol, der eine zuverlässige Kommunikation zwischen NovaDE und externen KI-Modellen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken von `tokio::net::TcpStream` oder Erstellen von In-Memory-Pipes zur Simulation der Netzwerkverbindung.
    * Testen der `MCPCodec` für korrekte Serialisierung/Deserialisierung von Nachrichten, einschließlich Header-Parsing und Payload-Verarbeitung.
    * Testen der `send_request` Methode: Verifizieren, dass Requests korrekt gesendet und Antworten korrekt empfangen/gematcht werden.
    * Testen der `receive_loop`: Sicherstellen, dass Nachrichten aus dem Puffer korrekt extrahiert und als `MCPResponse` oder `MCPEvent` weitergeleitet werden.
    * Testen der Fehlerfälle: Verbindungsabbruch, ungültige Nachrichten, Timeouts.
* **Integration Tests:**
    * Starten eines Mock-MCP-Servers, der Test-Nachrichten sendet und empfängt.
    * Starten des `MCPClient` und Senden von Test-Requests.
    * Überprüfen, ob die Antworten korrekt empfangen werden.
    * Simulieren von Fehlern auf dem Server und Überprüfen der Fehlerbehandlung im Client.

**Geschätzter Aufwand:** Sehr hoch (ca. 10-15 Tage, da das MCP-Protokoll selbst komplex ist, Verschlüsselung, Konnektivität und asynchrone Verarbeitung integriert werden müssen)

---

### **novade-system/src/mcp_client/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`MCPError`) für das `mcp_client`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung für MCP-Interaktionen sicher und ermöglicht eine präzise Fehlerweiterleitung.

**Kern-Aufgaben (Tasks):**

1.  **`MCPError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `ConnectionError(#[from] std::io::Error)`: Fehler beim Aufbau oder der Wartung der Netzwerkverbindung.
        * `SerializationError(#[from] serde_json::Error)`: Fehler beim Serialisieren/Deserialisieren von Nachrichten-Payloads.
        * `CodecError(String)`: Fehler im MCP-Codec (z.B. ungültiger Header, Checksummenfehler).
        * `Timeout`: Eine Antwort auf eine Anfrage wurde nicht innerhalb der erwarteten Zeit empfangen.
        * `ProtocolError(String)`: Eine Verletzung des MCP-Protokolls (z.B. unerwartete Nachrichtentypen).
        * `ResponseError(String)`: Das KI-Modell hat einen Fehler zurückgegeben.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/mcp_client/error.rs`

**Abhängigkeiten:**

* **Intern:** Keine direkten Abhängigkeiten.
* **Extern:**
    * `thiserror::Error`
    * `std::io::Error`
    * `serde_json::Error`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `mcp_client`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im `mcp_client`-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `MCPError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler (insbesondere für `io::Error` und `serde_json::Error`).

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---
### **novade-system/src/input_management**

**Verantwortlichkeit:**
Dieses Modul ist die zentrale Schnittstelle für die Verarbeitung von Benutzereingaben. Es nutzt `libinput` zur Erkennung und Interpretation von Eingabegeräten (Tastatur, Maus, Touchpad, Touchscreen, Grafiktablett) und deren Ereignissen. Es übersetzt rohe Eingabeereignisse in hochrangige, semantisch bedeutsame `InputEvent`s, die an die Domänenschicht weitergeleitet werden, und verwaltet die Eingabegeräte.

**Kern-Aufgaben (Tasks):**

1.  **`InputService` Struktur:**
    * Felder:
        * `libinput_context: libinput::Libinput` (Der `libinput`-Kontext für die Geräterkennung und Event-Verarbeitung).
        * `keyboard_state: RwLock<HashMap<DeviceId, KeyboardState>>` (Aktueller Tastaturzustand pro Gerät, z.B. gedrückte Tasten, Modifikatoren).
        * `pointer_state: RwLock<HashMap<DeviceId, PointerState>>` (Aktueller Zeigerzustand pro Gerät, z.B. Mausposition, Tasten).
        * `seat_manager: Arc<SeatManagerService>` (Referenz auf den `SeatManagerService` der Domänenschicht zur Zuweisung von Eingaben zu Seats).
        * `sender: Sender<InputEvent>` (Broadcast-Sender für `InputEvent`s an die Domänenschicht).
        * `receiver: Receiver<InputEvent>` (Broadcast-Receiver-Template).
        * `xkb_context: xkbcommon::xkb::Context` (xkbcommon Kontext für Tastaturlayouts).

2.  **`InputService::new()` Funktion:**
    * `pub async fn new(seat_manager: Arc<SeatManagerService>) -> Result<Arc<Self>, InputError>`
    * Initialisiert einen neuen `libinput` Kontext (`libinput::Libinput::new_with_udev()`).
    * Setzt den `libinput` Logger.
    * Initialisiert den `xkbcommon::xkb::Context`.
    * Erstellt `tokio::sync::broadcast::channel` für `InputEvent`s.
    * Führt ein initiales `libinput::Libinput::dispatch()` aus, um vorhandene Geräte zu erkennen.

3.  **`InputService::run_event_loop()` Funktion:**
    * `pub async fn run_event_loop(service: Arc<InputService>) -> Result<(), InputError>`
    * Eine Endlos-Schleife, die `libinput` Events dispatchen und verarbeiten soll.
    * `libinput_context.dispatch().await?` (oder `tokio::task::spawn_blocking` für blocking `dispatch` falls `libinput` keine async Schnittstelle hat).
    * Iteriert über die empfangenen `libinput::Event`s:
        * Unterscheidet zwischen `DeviceAdded`, `DeviceRemoved` und verschiedenen Eingabeereignissen (Keyboard, Pointer, Touch, Tablet, Gesture).
        * Für `DeviceAdded`/`DeviceRemoved`: Aktualisiert die internen `keyboard_state`/`pointer_state` Maps und sendet `InputEvent::DeviceAdded`/`DeviceRemoved`.
        * Für Keyboard-Events:
            * Verarbeitet `libinput::event::keyboard::KeyboardEvent` (Taste gedrückt/losgelassen).
            * Nutzt `xkb_context` und `keyboard_state` zur Interpretation von Keycodes in Symbole und Modifikatoren.
            * Sendet `InputEvent::KeyboardInput` (mit `KeyEvent` aus `novade-core::types::input`).
            * Aktualisiert den `keyboard_state`.
        * Für Pointer-Events:
            * Verarbeitet `libinput::event::pointer::PointerEvent` (Bewegung, Button, Scroll).
            * Sendet `InputEvent::PointerMotion`, `InputEvent::PointerButton`, `InputEvent::PointerScroll`.
            * Aktualisiert den `pointer_state`.
        * Für Touch/Tablet/Gesture Events: Ähnliche Verarbeitung und Senden entsprechender `InputEvent`s.
        * **Wichtig:** Events können zu Composite-Events kombiniert werden (z.B. Strg+C). Dies muss von der Domänenschicht oder einem spezialisierten Submodul behandelt werden, aber der `InputService` sollte atomare `InputEvent`s liefern.

4.  **Helper-Strukturen:**
    * `KeyboardState`: Enthält `xkbcommon::xkb::State`, gedrückte Keycodes, Modifikatoren-Maske.
    * `PointerState`: Enthält aktuelle Cursor-Position, gedrückte Buttons.
    * `DeviceId`: Typ alias für `libinput::Device` ID oder ähnliches.

5.  **Geräteverwaltung:**
    * `pub async fn get_connected_devices(&self) -> HashMap<DeviceId, DeviceInfo>`: Liefert eine Liste der verbundenen Eingabegeräte.
    * `pub async fn enable_device(&self, device_id: DeviceId) -> Result<(), InputError>`: Aktiviert ein Gerät.
    * `pub async fn disable_device(&self, device_id: DeviceId) -> Result<(), InputError>`: Deaktiviert ein Gerät.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_management/mod.rs`
* `novade-system/src/input_management/service.rs`
* `novade-system/src/input_management/error.rs` (`InputError` Enum)
* `novade-system/src/input_management/device_state.rs` (für `KeyboardState`, `PointerState` etc.)

**Abhängigkeiten:**

* **Intern:**
    * `crate::input_management::error::InputError`
    * `novade-core::types::input::{InputEvent, KeyEvent, PointerEvent, TouchEvent, GestureEvent, DeviceInfo}`
    * `novade-core::types::geometry::{Point, Size}` (für Positionsdaten)
    * `novade-domain::seat_manager::service::SeatManagerService` (für Zuweisung zu Seats und ggf. Event-Filterung).
* **Extern:**
    * `libinput::{self, prelude::*, event, ffi}`
    * `xkbcommon::xkb::{self, Context, State}`
    * `tokio`
    * `std::sync::Arc`
    * `parking_lot::RwLock`
    * `std::collections::HashMap`
    * `tokio::sync::broadcast::{channel, Sender, Receiver}`
    * `tracing`
    * `async_trait`
    * `nix::libc` (für fd management mit `libinput`)

**Kommunikationsmuster:**

* **An `libinput`:** Über die `libinput-rs` API.
* **Von `libinput`:** Empfängt rohe Eingabeereignisse.
* **An Domänenschicht (`InputProcessingService` oder `SeatManagerService`):** Sendet hochrangige `InputEvent`s über einen Broadcast-Channel.
* **An `SystemServices`:** Wird bei der Initialisierung der Systemschicht aufgerufen und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschnelles und präzises Eingabeverwaltungssystem, das alle relevanten Benutzereingaben erkennt, interpretiert und der Domänenschicht zur weiteren Verarbeitung zur Verfügung stellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken des `libinput` Kontexts, um simulierte `libinput::Event`s einzuspeisen.
    * Testen der Event-Verarbeitung für Tastaturereignisse: Verifizieren, dass Keycodes korrekt in Symbole und Modifikatoren übersetzt werden und `InputEvent::KeyboardInput` korrekt gesendet wird.
    * Testen der Pointer-Event-Verarbeitung (Bewegung, Klicks, Scrollen).
    * Testen der `DeviceAdded`/`DeviceRemoved` Ereignisse.
    * Testen der Aktualisierung des internen `keyboard_state` und `pointer_state`.
    * Mocken des `xkbcommon` Kontexts, falls nötig, um bestimmte Tastaturlayout-Szenarien zu testen.
* **Integration Tests:**
    * Starten des NovaDE-Compositors.
    * Interagieren mit verschiedenen physischen Eingabegeräten (Tastatur, Maus, Touchpad).
    * Überprüfen, ob NovaDE die Eingaben korrekt erkennt und die UI darauf reagiert (z.B. Cursor-Bewegung, Texteingabe, Fenster-Fokus).
    * Testen des Hot-Plugging von Geräten.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da `libinput`-Integration, `xkbcommon` und komplexes Event-Processing erforderlich sind)

---

### **novade-system/src/input_management/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`InputError`) für das `input_management`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung für Eingabe-Interaktionen sicher und ermöglicht eine präzise Fehlerweiterleitung.

**Kern-Aufgaben (Tasks):**

1.  **`InputError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `LibinputContextError(String)`: Fehler beim Erstellen oder Initialisieren des `libinput` Kontexts.
        * `LibinputDispatchError(String)`: Fehler beim Dispatching von `libinput` Events.
        * `XkbCommonError(String)`: Fehler im `xkbcommon` Kontext oder bei der Tastaturlayout-Verarbeitung.
        * `DeviceNotFound(String)`: Ein angefordertes Eingabegerät wurde nicht gefunden.
        * `DeviceOperationFailed(String)`: Eine Operation auf einem Eingabegerät (z.B. Aktivieren/Deaktivieren) ist fehlgeschlagen.
        * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_management/error.rs`

**Abhängigkeiten:**

* **Intern:** Keine direkten Abhängigkeiten.
* **Extern:**
    * `thiserror::Error`
    * `std::io::Error`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `input_management`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im `input_management`-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `InputError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---
### **novade-system/src/keyboard_layout**

**Verantwortlichkeit:**
Dieses Modul ist für die Verwaltung und Anwendung von Tastaturlayouts zuständig. Es interagiert mit `xkbcommon` um Tastaturzuordnungen zu laden, zu wechseln und den Zustand der Tastatur zu interpretieren (z.B. Modifikatoren, Compose-Sequenzen). Es stellt eine API für den `InputService` bereit und kann von der Domänenschicht (`GlobalSettingsService`) zur Konfiguration genutzt werden.

**Kern-Aufgaben (Tasks):**

1.  **`KeyboardLayoutService` Struktur:**
    * Felder:
        * `xkb_context: RwLock<xkbcommon::xkb::Context>` (Der globale `xkbcommon`-Kontext).
        * `current_layout: RwLock<KeyboardLayoutConfig>` (Aktuell geladenes Layout und seine Varianten).
        * `keymap_cache: RwLock<HashMap<KeyboardLayoutConfig, xkbcommon::xkb::Keymap>>` (Cache für geladene Keymaps).

2.  **`KeyboardLayoutService::new()` Funktion:**
    * `pub fn new() -> Result<Arc<Self>, KeyboardLayoutError>`
    * Initialisiert einen neuen `xkbcommon::xkb::Context`.
    * Lädt ein Standard-Tastaturlayout (z.B. "us") als initiales `current_layout`.
    * Initialisiert den `keymap_cache`.

3.  **`KeyboardLayoutService::set_layout()` Funktion:**
    * `pub async fn set_layout(&self, config: KeyboardLayoutConfig) -> Result<(), KeyboardLayoutError>`
    * Akzeptiert eine `KeyboardLayoutConfig` (definiert in `novade-core::types::input`).
    * Überprüft, ob die Keymap bereits im `keymap_cache` ist.
    * Wenn nicht, erstellt eine neue `xkbcommon::xkb::Keymap` aus dem `xkb_context` basierend auf der `config`.
    * Speichert die neue Keymap im Cache.
    * Aktualisiert `current_layout`.
    * **Wichtig:** Emittiert ein internes Event oder informiert den `InputService` über die Layout-Änderung, damit dieser seine `xkbcommon::xkb::State` für alle Keyboards neu initialisiert.

4.  **`KeyboardLayoutService::get_current_layout()` Funktion:**
    * `pub fn get_current_layout(&self) -> KeyboardLayoutConfig`
    * Gibt die aktuell geladene Tastaturlayout-Konfiguration zurück.

5.  **`KeyboardLayoutService::get_keymap_for_config()` Funktion:**
    * `pub fn get_keymap_for_config(&self, config: &KeyboardLayoutConfig) -> Result<xkbcommon::xkb::Keymap, KeyboardLayoutError>`
    * Interne Helper-Funktion, die eine Keymap aus dem Cache zurückgibt oder neu generiert.
    * Wird vom `InputService` verwendet, wenn eine neue Tastatur verbunden wird oder das Layout gewechselt wird.

6.  **`KeyboardLayoutService::get_available_layouts()` Funktion (Optional, aber nützlich für UI):**
    * `pub async fn get_available_layouts() -> Result<Vec<String>, KeyboardLayoutError>`
    * Scannt das System nach verfügbaren `xkb` Layouts und Varianten (kann eine externe Helper-Bibliothek oder direkten `xkbcommon` API-Aufruf erfordern).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/keyboard_layout/mod.rs`
* `novade-system/src/keyboard_layout/service.rs`
* `novade-system/src/keyboard_layout/error.rs` (`KeyboardLayoutError` Enum)

**Abhängigkeiten:**

* **Intern:**
    * `crate::keyboard_layout::error::KeyboardLayoutError`
    * `novade-core::types::input::{KeyboardLayoutConfig}`
* **Extern:**
    * `xkbcommon::xkb::{self, Context, Keymap, State}`
    * `std::sync::Arc`
    * `parking_lot::RwLock`
    * `std::collections::HashMap`
    * `tracing`
    * `async_trait`

**Kommunikationsmuster:**

* **An `xkbcommon` Bibliothek:** Direkte Interaktion zur Erstellung und Verwaltung von Keymaps und Kontexten.
* **Von Domänenschicht (`GlobalSettingsService`):** Empfängt Anforderungen zum Ändern des Tastaturlayouts.
* **An `InputService`:** Informiert den `InputService` über Layout-Änderungen und stellt `xkbcommon::xkb::Keymap` Objekte bereit, die der `InputService` zur Erstellung seiner `xkbcommon::xkb::State` Objekte pro Tastatur verwendet.
* **An `SystemServices`:** Wird bei der Initialisierung der Systemschicht aufgerufen und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Dienst zur Verwaltung von Tastaturlayouts, der es NovaDE ermöglicht, Tastaturbelegungen dynamisch zu ändern und die korrekte Interpretation von Tastatureingaben sicherzustellen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken des `xkbcommon` Kontexts oder verwenden eines temporären Verzeichnisses mit minimalen xkb-Dateien für Tests.
    * Testen der `set_layout` Funktion: Verifizieren, dass das Layout korrekt gesetzt, im Cache gespeichert und das `current_layout` aktualisiert wird.
    * Testen der `get_current_layout` Funktion.
    * Testen des Cache-Verhaltens (z.B. wird eine Keymap nicht neu geladen, wenn sie bereits im Cache ist).
    * Testen der Fehlerfälle, z.B. wenn ein ungültiges Layout angefordert wird.
* **Integration Tests:**
    * Starten des NovaDE-Compositors.
    * Ändern des Tastaturlayouts über die NovaDE-UI (die den `GlobalSettingsService` aufruft).
    * Überprüfen, ob die Tastatureingaben nun dem neuen Layout entsprechen.
    * Testen des Wechsels zwischen verschiedenen Layouts.

**Geschätzter Aufwand:** Mittel (ca. 3-5 Tage, da `xkbcommon`-Integration etwas Einarbeitung erfordert)

---

### **novade-system/src/keyboard_layout/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`KeyboardLayoutError`) für das `keyboard_layout`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung für Tastaturlayout-Interaktionen sicher und ermöglicht eine präzise Fehlerweiterleitung.

**Kern-Aufgaben (Tasks):**

1.  **`KeyboardLayoutError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `XkbCommonError(String)`: Ein Fehler, der direkt von der `xkbcommon`-Bibliothek stammt.
        * `InvalidLayout(String)`: Das angeforderte Tastaturlayout oder die Variante ist ungültig oder nicht verfügbar.
        * `KeymapCreationError(String)`: Fehler beim Erstellen einer Keymap aus dem `xkbcommon` Kontext.
        * `ContextInitializationError(String)`: Fehler bei der Initialisierung des `xkbcommon` Kontexts.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/keyboard_layout/error.rs`

**Abhängigkeiten:**

* **Intern:** Keine direkten Abhängigkeiten.
* **Extern:**
    * `thiserror::Error`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `keyboard_layout`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im `keyboard_layout`-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `KeyboardLayoutError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---

### **novade-system/src/portals**

**Verantwortlichkeit:**
Dieses Modul dient als Brücke zu den XDG Desktop Portals. Es ermöglicht NovaDE und Anwendungen, sicher und standardisiert auf verschiedene Systemfunktionen zuzugreifen, die sonst erhöhte Privilegien oder eine direkte Interaktion mit dem Desktop-Environment erfordern würden (z.B. Dateiauswahl, Screenshots, Drucken). Es abstrahiert die zugrunde liegende D-Bus-Kommunikation mit den Portal-Implementierungen (z.B. `xdg-desktop-portal-gtk`, `xdg-desktop-portal-gnome`).

**Kern-Aufgaben (Tasks):**

1.  **`PortalService` Struktur:**
    * Felder:
        * `connection: zbus::Connection` (Die D-Bus-Verbindung zum System- oder Session-Bus, auf dem die Portale laufen).
        * `file_chooser_proxy: Arc<FileChooserProxy>` (D-Bus Proxy für `org.freedesktop.portal.FileChooser`).
        * `screenshot_proxy: Arc<ScreenshotProxy>` (D-Bus Proxy für `org.freedesktop.portal.Screenshot`).
        * `open_uri_proxy: Arc<OpenURIProxy>` (D-Bus Proxy für `org.freedesktop.portal.OpenURI`).
        * `documents_proxy: Arc<DocumentsProxy>` (D-Bus Proxy für `org.freedesktop.portal.Documents`).
        * *Weitere Proxys bei Bedarf (Print, Background, RemoteDesktop etc.).*

2.  **D-Bus Proxy Definitionen (via `zbus_macros::dbus_proxy`):**
    * Für jedes benötigte Portal wird ein eigener D-Bus Proxy definiert. Diese Proxys müssen die spezifischen Methoden und Signale der jeweiligen `org.freedesktop.portal.*` Schnittstelle widerspiegeln.
    * Beispiel `FileChooserProxy`:
        * Interface: `org.freedesktop.portal.FileChooser`
        * Method: `OpenFile(parent_window: String, title: String, options: HashMap<String, zbus::zvariant::OwnedValue>) -> zbus::Result<zbus::zvariant::ObjectPath<'static>>`
        * Method: `SaveFile(parent_window: String, title: String, options: HashMap<String, zbus::zvariant::OwnedValue>) -> zbus::Result<zbus::zvariant::ObjectPath<'static>>`
        * Method: `OpenDirectory(...)`
    * Beispiel `ScreenshotProxy`:
        * Interface: `org.freedesktop.portal.Screenshot`
        * Method: `Screenshot(parent_window: String, options: HashMap<String, zbus::zvariant::OwnedValue>) -> zbus::Result<zbus::zvariant::ObjectPath<'static>>`

3.  **`PortalService::new()` Funktion:**
    * `pub async fn new() -> Result<Arc<Self>, PortalError>`
    * Stellt eine D-Bus-Verbindung her (typischerweise Session-Bus).
    * Initialisiert alle benötigten Portal-Proxys.

4.  **Wrapper-Funktionen für Portal-Interaktionen:**
    * `pub async fn open_file_dialog(&self, title: &str, start_location: Option<PathBuf>, filters: Vec<FileChooserFilter>) -> Result<Option<PathBuf>, PortalError>`:
        * Kapselt den `FileChooserProxy::OpenFile` Aufruf.
        * Verarbeitet die Optionen (z.B. `multiple`, `modal`, `directory`).
        * Wartet auf das `Response` Signal vom `Request` Objekt-Pfad (der vom Portal zurückgegeben wird) und parst das Ergebnis.
    * `pub async fn take_screenshot(&self, interactive: bool, area: Option<Rectangle>) -> Result<Option<PathBuf>, PortalError>`:
        * Kapselt den `ScreenshotProxy::Screenshot` Aufruf.
        * Verarbeitet Optionen (z.B. `interactive`, `area`).
        * Wartet auf das `Response` Signal und parst das Ergebnis.
    * `pub async fn open_uri(&self, uri: &str) -> Result<(), PortalError>`:
        * Kapselt den `OpenURIProxy::OpenURI` Aufruf.

5.  **`FileChooserFilter` und andere Helper-Typen:**
    * Definieren interne Typen, die die Interaktion mit den Portalen vereinfachen und die `HashMap`s für die D-Bus-Optionen abstrahieren.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/portals/mod.rs`
* `novade-system/src/portals/service.rs`
* `novade-system/src/portals/error.rs` (`PortalError` Enum)
* `novade-system/src/portals/file_chooser.rs` (Für FileChooserProxy und zugehörige Helper-Typen)
* `novade-system/src/portals/screenshot.rs` (Für ScreenshotProxy)
* `novade-system/src/portals/open_uri.rs` (Für OpenURIProxy)
* *Weitere Dateien für andere Portale, falls benötigt.*

**Abhängigkeiten:**

* **Intern:**
    * `crate::portals::error::PortalError`
    * `novade-core::types::geometry::Rectangle`
    * `novade-core::types::file_system::FileChooserFilter` (Beispiel, ggf. in `novade-core::types` definieren)
* **Extern:**
    * `zbus::{self, Connection, Proxy, zvariant::{ObjectPath, OwnedValue}}`
    * `zbus_macros::dbus_proxy`
    * `tokio`
    * `std::sync::Arc`
    * `std::collections::HashMap`
    * `std::path::PathBuf`
    * `tracing`
    * `async_trait`
    * `url::Url` (für URI-Verarbeitung)

**Kommunikationsmuster:**

* **An `xdg-desktop-portal` D-Bus-Dienst:** Sendet Methodenaufrufe und empfängt Antworten und Signale.
* **Von Domänenschicht (z.B. `FileManagerService`, `ScreenshotService`):** Empfängt Anfragen zur Durchführung von Portal-Aktionen.
* **An `SystemServices`:** Wird bei der Initialisierung der Systemschicht aufgerufen und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und benutzerfreundliches Schnittstellen-Modul zu den XDG Desktop Portals, das NovaDE und Anwendungen die sichere und standardisierte Interaktion mit Kernsystemfunktionen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken der `zbus::Connection` und der Portal-Proxys.
    * Testen der Wrapper-Funktionen: Verifizieren, dass die Argumente korrekt in die D-Bus-Optionen umgewandelt und die Proxy-Methoden korrekt aufgerufen werden.
    * Simulieren von D-Bus-Antworten vom Portal (z.B. erfolgreiche Dateiauswahl, abgebrochener Screenshot) und Verifizieren der korrekten Ergebnis-Konvertierung.
    * Testen der Fehlerfälle (z.B. Portal nicht gefunden, Aufruf fehlgeschlagen).
* **Integration Tests:**
    * Starten des NovaDE-Compositors mit einem laufenden `xdg-desktop-portal` Daemon (z.B. `xdg-desktop-portal-gtk`).
    * Auslösen von Portal-Aktionen über die NovaDE-UI oder Test-Anwendungen (z.B. Dateiauswahldialog öffnen, Screenshot erstellen).
    * Überprüfen, ob die Portal-Dialoge korrekt erscheinen und die Ergebnisse korrekt an NovaDE zurückgegeben werden.

**Geschätzter Aufwand:** Hoch (ca. 5-8 Tage, da viele verschiedene Portal-Schnittstellen integriert werden müssen und die asynchrone Signal-Verarbeitung für Ergebnisse notwendig ist)

---

### **novade-system/src/portals/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`PortalError`) für das `portals`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung für XDG Desktop Portal-Interaktionen sicher und ermöglicht eine präzise Fehlerweiterleitung.

**Kern-Aufgaben (Tasks):**

1.  **`PortalError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `DBusError(#[from] crate::dbus_interfaces::error::DBusError)`: Fehler, die von der zugrunde liegenden D-Bus-Kommunikation stammen (z.B. Portal-Service nicht gefunden).
        * `InvalidResponse(String)`: Die Antwort vom Portal konnte nicht korrekt geparst werden.
        * `OperationCancelled`: Der Benutzer hat die Portal-Operation abgebrochen.
        * `PortalNotFound(String)`: Der angeforderte Portal-Dienst ist auf dem System nicht verfügbar.
        * `InvalidArguments(String)`: Ungültige Argumente wurden an eine Portal-Methode übergeben.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/portals/error.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DBusError`
* **Extern:**
    * `thiserror::Error`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `portals`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im `portals`-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `PortalError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler (insbesondere für `DBusError` Konvertierungen).

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---
### **novade-system/src/dbus_interfaces/secrets_service.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert einen Client für den FreeDesktop Secret Service (`org.freedesktop.Secret`). Es ermöglicht NovaDE, Passwörter und andere sensible Daten sicher zu speichern und abzurufen, typischerweise über ein Benutzer-Login-Passwort, das den Keyring entschlüsselt. Dies ist entscheidend für Anwendungen, die Anmeldeinformationen persistieren müssen (z.B. E-Mail-Clients, Cloud-Speicher-Clients).

**Kern-Aufgaben (Tasks):**

1.  **`SecretService` Struktur:**
    * Felder:
        * `connection: zbus::Connection` (Die D-Bus-Verbindung zum Session-Bus).
        * `service_proxy: Arc<ServiceProxy>` (D-Bus Proxy für das Haupt-Service-Interface `org.freedesktop.Secret.Service`).
        * `collection_cache: RwLock<HashMap<String, ObjectPath<'static>>>` (Cache für bekannte Sammlungen und deren Pfade).

2.  **D-Bus Proxy Definitionen (via `zbus_macros::dbus_proxy`):**
    * `ServiceProxy`: Interface `org.freedesktop.Secret.Service`
        * Methoden: `OpenSession`, `CreateCollection`, `SearchCollections`, `GetSecrets`, `Unlock`, `Lock`, `Prompt`, `Terminate`.
        * Signale: `CollectionCreated`, `CollectionDeleted`, `CollectionChanged`.
    * `CollectionProxy`: Interface `org.freedesktop.Secret.Collection`
        * Methoden: `Delete`, `SearchItems`, `CreateItem`, `Lock`, `Unlock`.
        * Signale: `ItemCreated`, `ItemDeleted`, `ItemChanged`.
    * `ItemProxy`: Interface `org.freedesktop.Secret.Item`
        * Methoden: `Delete`, `GetSecret`, `SetSecret`, `GetAttributes`, `SetAttributes`.
        * Signale: `PropertiesChanged`.
    * `SessionProxy`: Interface `org.freedesktop.Secret.Session`
        * Methoden: `Close`.

3.  **`SecretService::new()` Funktion:**
    * `pub async fn new() -> Result<Arc<Self>, SecretsServiceError>`
    * Stellt eine D-Bus-Verbindung zum Session-Bus her.
    * Erstellt den `ServiceProxy`.
    * `open_session()` mit dem Secret Service (typischerweise eine `plain` oder `dh-ietf1024` Session).
    * Initialisiert den `collection_cache` durch Abfragen vorhandener Sammlungen.
    * Startet einen Task, der auf `CollectionCreated`/`Deleted`/`Changed` Signale lauscht und den Cache aktualisiert.

4.  **Verwaltung von Sammlungen:**
    * `pub async fn create_collection(&self, label: &str, properties: Option<HashMap<String, OwnedValue>>) -> Result<CollectionInfo, SecretsServiceError>`: Erstellt eine neue Sammlung.
    * `pub async fn get_collection_by_alias(&self, alias: &str) -> Result<Option<CollectionInfo>, SecretsServiceError>`: Ruft eine Sammlung anhand ihres Alias ab (z.B. "default").
    * `pub async fn delete_collection(&self, collection_id: &ObjectPath) -> Result<(), SecretsServiceError>`: Löscht eine Sammlung.
    * `pub async fn unlock_collection(&self, collection_id: &ObjectPath) -> Result<(), SecretsServiceError>`: Entsperrt eine Sammlung (kann eine D-Bus-Prompt-Interaktion auslösen).
    * `pub async fn lock_collection(&self, collection_id: &ObjectPath) -> Result<(), SecretsServiceError>`: Sperrt eine Sammlung.

5.  **Verwaltung von Items (Geheimnissen):**
    * `pub async fn create_secret(&self, collection_id: &ObjectPath, label: &str, attributes: HashMap<String, String>, secret: &SecretStruct) -> Result<ItemInfo, SecretsServiceError>`: Speichert ein neues Geheimnis.
    * `pub async fn get_secret(&self, item_id: &ObjectPath) -> Result<SecretStruct, SecretsServiceError>`: Ruft ein Geheimnis ab.
    * `pub async fn set_secret(&self, item_id: &ObjectPath, secret: &SecretStruct) -> Result<(), SecretsServiceError>`: Aktualisiert ein Geheimnis.
    * `pub async fn delete_secret(&self, item_id: &ObjectPath) -> Result<(), SecretsServiceError>`: Löscht ein Geheimnis.
    * `pub async fn search_secrets(&self, attributes: HashMap<String, String>) -> Result<Vec<ItemInfo>, SecretsServiceError>`: Sucht nach Geheimnissen basierend auf Attributen.

6.  **`SecretStruct` Definition (`novade-core::types::secrets::SecretStruct`):**
    * Felder: `service: String`, `username: String`, `password: Vec<u8>`.
    * Dieses sollte die eigentlichen Geheimnisdaten enthalten, die sicher übertragen werden.

7.  **`CollectionInfo` und `ItemInfo` Strukturen:**
    * Abstrahieren die `ObjectPath`s und Attribute/Eigenschaften von Sammlungen und Items.

8.  **Prompt-Handling:**
    * Die Secret Service API kann Prompts auslösen (z.B. für ein Master-Passwort). Der `SecretService` muss in der Lage sein, diese Prompts zu empfangen und an eine UI-Komponente (z.B. den `PromptService` in der Domänenschicht) weiterzuleiten, um eine Benutzerinteraktion zu ermöglichen. Dies erfordert die Implementierung des `org.freedesktop.Secret.Prompt` Interfaces.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/secrets_service.rs`
* `novade-system/src/dbus_interfaces/secrets_service/mod.rs` (für Proxy-Definitionen)
* `novade-system/src/dbus_interfaces/secrets_service/error.rs` (`SecretsServiceError` Enum)

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DBusError`
    * `crate::dbus_interfaces::secrets_service::error::SecretsServiceError`
    * `novade-core::types::secrets::{SecretStruct}`
* **Extern:**
    * `zbus::{self, Connection, Proxy, zvariant::{ObjectPath, OwnedValue}}`
    * `zbus_macros::dbus_proxy`
    * `tokio`
    * `std::sync::Arc`
    * `parking_lot::RwLock`
    * `std::collections::HashMap`
    * `tracing`
    * `async_trait`
    * `base64` (für die Serialisierung von Geheimnissen, falls im Protokoll so vorgesehen)

**Kommunikationsmuster:**

* **An `org.freedesktop.Secret` D-Bus-Dienst:** Sendet Methodenaufrufe und empfängt Antworten und Signale.
* **Von Domänenschicht (`SecretManagementService`):** Empfängt Anfragen zum Speichern, Abrufen, Suchen und Löschen von Geheimnissen.
* **An Domänenschicht (`PromptService`):** Delegiert D-Bus-Prompts zur Benutzerinteraktion.
* **An `SystemServices`:** Wird bei der Initialisierung der Systemschicht aufgerufen und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein robuster und sicherer Client für den FreeDesktop Secret Service, der NovaDE ermöglicht, sensible Daten sicher zu speichern und abzurufen und gleichzeitig eine ordnungsgemäße Handhabung von Benutzer-Prompts gewährleistet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken der `zbus::Connection` und der Secret Service Proxys.
    * Simulieren von Secret Service Antworten für alle Operationen (Erstellen, Abrufen, Löschen, Suchen von Geheimnissen und Sammlungen).
    * Testen der Ent-/Verschlüsselung von Geheimnissen und Attributen, falls der Codec innerhalb dieses Moduls liegt.
    * Testen der Prompt-Handling-Logik (Simulation eines Prompts und Verifikation der Weiterleitung).
* **Integration Tests:**
    * Starten des NovaDE-Compositors mit einem laufenden Secret Service (z.B. `gnome-keyring-daemon` oder `kwalletd`).
    * Verwenden einer Testanwendung, die Geheimnisse speichert/abruft, oder direkter Aufruf der NovaDE-API.
    * Überprüfen, ob Geheimnisse korrekt gespeichert und abgerufen werden.
    * Testen der Sperr-/Entsperrfunktionen für Sammlungen, die eine Benutzerinteraktion erfordern.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da die Secret Service API komplex ist und sichere Prompt-Handhabung erfordert)

---

### **novade-system/src/dbus_interfaces/secrets_service/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`SecretsServiceError`) für das `secrets_service`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung für Secret Service-Interaktionen sicher und ermöglicht eine präzise Fehlerweiterleitung.

**Kern-Aufgaben (Tasks):**

1.  **`SecretsServiceError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `DBusError(#[from] crate::dbus_interfaces::error::DBusError)`: Fehler, die von der zugrunde liegenden D-Bus-Kommunikation stammen.
        * `ServiceNotAvailable`: Der FreeDesktop Secret Service ist auf dem System nicht verfügbar.
        * `CollectionNotFound(String)`: Die angeforderte Sammlung wurde nicht gefunden.
        * `ItemNotFound(String)`: Das angeforderte Geheimnis (Item) wurde nicht gefunden.
        * `AuthenticationFailed`: Die Authentifizierung zum Entsperren einer Sammlung ist fehlgeschlagen (z.B. falsches Passwort).
        * `PromptCancelled`: Der Benutzer hat einen angeforderten Prompt abgebrochen.
        * `InvalidData(String)`: Die empfangenen oder zu sendenden Geheimnisdaten sind ungültig.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/secrets_service/error.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DBusError`
* **Extern:**
    * `thiserror::Error`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `secrets_service`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im `secrets_service`-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `SecretsServiceError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler (insbesondere für `DBusError` Konvertierungen).

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---

### **novade-system/src/dbus_interfaces/policykit_agent.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert einen PolicyKit-Authentifizierungs-Agenten. PolicyKit (oder `polkit`) wird verwendet, um nicht-privilegierten Programmen die Berechtigung zur Ausführung privilegierter Aktionen zu erteilen. NovaDE, als Desktop-Umgebung, muss in der Lage sein, solche Berechtigungsanfragen vom System zu empfangen, dem Benutzer einen Authentifizierungsdialog anzuzeigen und die Antwort des Benutzers an PolicyKit zurückzusenden.

**Kern-Aufgaben (Tasks):**

1.  **`PolicyKitAgent` Struktur:**
    * Felder:
        * `connection: zbus::Connection` (Die D-Bus-Verbindung zum System-Bus).
        * `agent_id: String` (Eine eindeutige ID für diesen Agenten).
        * `prompt_service: Arc<PromptService>` (Referenz auf den PromptService der Domänenschicht, um GUI-Prompts anzuzeigen).
        * `pending_authentications: RwLock<HashMap<ObjectPath<'static>, tokio::sync::oneshot::Sender<bool>>>` (Speichert die Sender für ausstehende Authentifizierungsanfragen).

2.  **Implementierung des `org.freedesktop.PolicyKit1.AuthenticationAgent` D-Bus-Interfaces (via `zbus_macros::dbus_interface`):**
    * Pfad: Dynamisch (von PolicyKit zugewiesen).
    * Interface: `org.freedesktop.PolicyKit1.AuthenticationAgent`
    * **Methoden:**
        * `BeginAuthentication(action_id: String, message: String, icon_name: String, details: HashMap<String, String>, cookie: String, identities: Vec<ObjectPath<'static>>, window_id: String) -> zbus::fdo::Result<()>`:
            * Diese Methode wird von PolicyKit aufgerufen, wenn eine Authentifizierung für eine Aktion erforderlich ist.
            * `action_id`: Die PolicyKit-Aktion, die autorisiert werden soll (z.B. "org.freedesktop.systemd1.manage-units").
            * `message`: Die vom PolicyKit-Daemon generierte Nachricht an den Benutzer.
            * `icon_name`: Symbol für den Dialog.
            * `details`: Zusätzliche Details zur Aktion.
            * `cookie`: Ein zufälliger String, der an `Result()` zurückgegeben werden muss.
            * `identities`: Liste der Prinzipal-Objektpfade, die authentifiziert werden müssen (z.B. `unix-user` für den aktuellen Benutzer).
            * `window_id`: ID des Fensters, das die Authentifizierung angefordert hat (optional, für Parent-Hinweise).
            * **Intern:**
                * Erstellt eine `PromptRequest` (definiert in `novade-core::types::prompt`) mit den Details der Authentifizierungsanfrage.
                * Sendet diese `PromptRequest` an den `prompt_service` und erwartet eine Antwort (ob der Benutzer authentifiziert hat oder nicht).
                * Speichert einen `oneshot::Sender<bool>` in `pending_authentications` gemappt auf die `ObjectPath` der Authentifizierungsanfrage.
        * `CancelAuthentication(action_id: String, cookie: String) -> zbus::fdo::Result<()>`:
            * Wird aufgerufen, wenn eine Authentifizierungsanfrage abgebrochen wird.
            * Beendet die entsprechende ausstehende Prompt-Interaktion und löscht den `oneshot::Sender`.

    * **Signale:**
        * `Result(action_id: String, cookie: String, authenticated: bool)`:
            * Dieses Signal muss vom Agenten an PolicyKit gesendet werden, nachdem der Benutzer authentifiziert wurde oder die Authentifizierung fehlschlug/abgebrochen wurde.
            * `authenticated: bool`: `true` wenn erfolgreich, `false` sonst.

3.  **`PolicyKitAgent::new()` Funktion:**
    * `pub async fn new(prompt_service: Arc<PromptService>) -> Result<Arc<Self>, PolicyKitError>`
    * Stellt eine D-Bus-Verbindung zum System-Bus her.
    * Initialisiert `prompt_service` und `pending_authentications`.
    * Generiert eine eindeutige `agent_id`.
    * **Registriert den Agenten bei PolicyKit:**
        * Ruft `org.freedesktop.PolicyKit1.Authority.RegisterAuthenticationAgent(agent_id, capabilities)` auf. Capabilities können `temp-session` oder `system` sein.
        * Das `object_path` des registrierten Agenten wird zurückgegeben.

4.  **`PolicyKitAgent::unregister()` Funktion:**
    * `pub async fn unregister(&self) -> Result<(), PolicyKitError>`
    * Ruft `org.freedesktop.PolicyKit1.Authority.UnregisterAuthenticationAgent(agent_id)` auf.

5.  **Rücksendung des Authentifizierungsergebnisses:**
    * Wenn der `PromptService` eine Antwort auf eine `PromptRequest` für eine PolicyKit-Authentifizierung liefert:
        * Der `PolicyKitAgent` muss den entsprechenden `oneshot::Sender<bool>` finden und die Antwort senden.
        * Anschließend muss das `Result` Signal an PolicyKit emittiert werden.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/policykit_agent.rs`
* `novade-system/src/dbus_interfaces/policykit_agent/mod.rs` (für Proxy-Definitionen)
* `novade-system/src/dbus_interfaces/policykit_agent/error.rs` (`PolicyKitError` Enum)

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DBusError`
    * `crate::dbus_interfaces::policykit_agent::error::PolicyKitError`
    * `novade-core::types::prompt::{PromptRequest, PromptResponse, PromptKind}` (Diese sollten in `novade-core::types` definiert werden).
    * `novade-domain::prompt_service::service::PromptService`
* **Extern:**
    * `zbus::{self, Connection, Proxy, zvariant::{ObjectPath, OwnedValue}}`
    * `zbus_macros::dbus_interface`
    * `tokio`
    * `std::sync::Arc`
    * `parking_lot::RwLock`
    * `std::collections::HashMap`
    * `tokio::sync::oneshot`
    * `tracing`
    * `async_trait`
    * `uuid` (für `agent_id`)

**Kommunikationsmuster:**

* **An `org.freedesktop.PolicyKit1.Authority` D-Bus-Dienst:** Registriert und Deregistriert den Agenten.
* **Von `org.freedesktop.PolicyKit1.Authority` D-Bus-Dienst:** Empfängt `BeginAuthentication` und `CancelAuthentication` Methodenaufrufe.
* **An `org.freedesktop.PolicyKit1.AuthenticationAgent` (self):** Emittiert das `Result` Signal zurück an PolicyKit.
* **An Domänenschicht (`PromptService`):** Delegiert die Aufgabe, einen GUI-Prompt für die Authentifizierung anzuzeigen.
* **Von Domänenschicht (`PromptService`):** Empfängt die Benutzerantwort auf den Prompt.
* **An `SystemServices`:** Wird bei der Initialisierung der Systemschicht aufgerufen und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein voll funktionsfähiger PolicyKit Authentifizierungs-Agent, der es NovaDE ermöglicht, privilegierte Aktionen im Namen des Benutzers sicher und über eine grafische Oberfläche zu autorisieren.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken der `zbus::Connection` und des `PromptService`.
    * Simulieren von `BeginAuthentication` Aufrufen von PolicyKit.
    * Verifizieren, dass der `PromptService` korrekt aufgerufen wird.
    * Testen der `Result` Signal-Emission basierend auf der Antwort des gemockten `PromptService`.
    * Testen der `CancelAuthentication` Methode und der korrekten Aufräumlogik.
    * Testen der Registrierungs- und Deregistrierungsmechanismen.
* **Integration Tests:**
    * Starten des NovaDE-Compositors mit einem laufenden `polkitd` Daemon.
    * Verwenden einer Testanwendung, die eine privilegierte PolicyKit-Aktion ausführt (z.B. `pkexec systemctl restart foo.service`).
    * Überprüfen, ob der NovaDE-Authentifizierungsdialog erscheint.
    * Eingabe des Passworts (oder Abbrechen) und Verifizieren, ob die Aktion korrekt autorisiert/abgelehnt wird und der Dialog verschwindet.

**Geschätzter Aufwand:** Hoch (ca. 5-8 Tage, da D-Bus-Proxy/Interface-Implementierung, Signal-Handling, OneShot-Kanäle und UI-Prompt-Integration erforderlich sind)

---

### **novade-system/src/dbus_interfaces/policykit_agent/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`PolicyKitError`) für das `policykit_agent`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung für PolicyKit-Agenten-Interaktionen sicher und ermöglicht eine präzise Fehlerweiterleitung.

**Kern-Aufgaben (Tasks):**

1.  **`PolicyKitError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `DBusError(#[from] crate::dbus_interfaces::error::DBusError)`: Fehler, die von der zugrunde liegenden D-Bus-Kommunikation stammen (z.B. `polkitd` nicht erreichbar).
        * `RegistrationFailed(String)`: Der Authentifizierungs-Agent konnte sich nicht bei PolicyKit registrieren.
        * `UnregistrationFailed(String)`: Das Deregistrieren des Agenten ist fehlgeschlagen.
        * `PromptServiceError(String)`: Ein Fehler ist beim Aufrufen des `PromptService` der Domänenschicht aufgetreten.
        * `AuthenticationCancelled`: Die Authentifizierung wurde vom Benutzer oder PolicyKit abgebrochen.
        * `InvalidArguments(String)`: PolicyKit hat ungültige Argumente an den Agenten gesendet.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/policykit_agent/error.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DBusError`
* **Extern:**
    * `thiserror::Error`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `policykit_agent`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im `policykit_agent`-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `PolicyKitError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler (insbesondere für `DBusError` Konvertierungen).

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)
### **novade-system/src/notification_server**

**Verantwortlichkeit:**
Dieses Modul implementiert einen D-Bus-Server für das FreeDesktop Notifications Specification (`org.freedesktop.Notifications`). NovaDE agiert hier als Benachrichtigungsdienst, der Benachrichtigungsanfragen von Anwendungen entgegennimmt, diese gemäß der konfigurierten Benachrichtigungsregeln der Domänenschicht verarbeitet und dann an die UI-Schicht zur Anzeige weiterleitet.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationServer` Struktur:**
    * Felder:
        * `connection: zbus::Connection` (Die D-Bus-Verbindung, auf der der Server läuft, typischerweise Session-Bus).
        * `notification_engine: Arc<DefaultNotificationRulesEngine>` (Referenz auf die Benachrichtigungsregeln der Domänenschicht).
        * `notification_tx: Sender<Notification>` (Broadcast-Sender für verarbeitete `Notification`s an die UI-Schicht).
        * `notification_rx: Receiver<Notification>` (Broadcast-Receiver-Template).
        * `notification_id_counter: AtomicU32` (Zähler für eindeutige Benachrichtigungs-IDs).
        * `active_notifications: RwLock<HashMap<u32, Notification>>` (Cache für aktive Benachrichtigungen, um z.B. `CloseNotification` zu verarbeiten).

2.  **Implementierung des `org.freedesktop.Notifications` D-Bus-Interfaces (via `zbus_macros::dbus_interface`):**
    * Pfad: `/org/freedesktop/Notifications`
    * Interface: `org.freedesktop.Notifications`
    * **Methoden:**
        * `GetCapabilities() -> zbus::fdo::Result<Vec<String>>`:
            * Gibt die unterstützten Fähigkeiten des Servers zurück (z.B. "body", "actions", "persistence", "icons").
        * `Notify(app_name: String, replaces_id: u32, app_icon: String, summary: String, body: String, actions: Vec<String>, hints: HashMap<String, zbus::zvariant::OwnedValue>, expire_timeout: i32) -> zbus::fdo::Result<u32>`:
            * Die Hauptmethode zum Senden einer Benachrichtigung.
            * `app_name`, `summary`, `body`, `app_icon`: Standard-Felder der Benachrichtigung.
            * `replaces_id`: Eine ID, die ersetzt werden soll (für Updates einer bestehenden Benachrichtigung).
            * `actions`: Liste von Aktions-IDs.
            * `hints`: Zusätzliche Meta-Informationen.
            * `expire_timeout`: Timeout in Millisekunden (-1 für Standard).
            * **Intern:**
                * Erstellt eine `Notification` Struktur (`novade-core::types::notification::Notification`) aus den D-Bus-Argumenten, ggf. mit einer neuen `notification_id` oder der `replaces_id`.
                * Übergibt die `Notification` an die `notification_engine` der Domänenschicht zur Regelverarbeitung.
                * Basierend auf dem Ergebnis der `notification_engine` (z.B. `RuleProcessingResult::Display`, `RuleProcessingResult::Suppress`, `RuleProcessingResult::Modify`):
                    * Wenn `Display` oder `Modify`: Speichert die (modifizierte) Benachrichtigung in `active_notifications`.
                    * Sendet die Benachrichtigung über `notification_tx` an die UI-Schicht zur Anzeige.
                    * Gibt die `notification_id` an den Aufrufer zurück.
        * `CloseNotification(id: u32) -> zbus::fdo::Result<()>`:
            * Eine Anwendung fordert das Schließen einer Benachrichtigung an.
            * **Intern:**
                * Entfernt die Benachrichtigung aus `active_notifications`.
                * Sendet ein `NotificationEvent::Closed` (mit der ID) an die UI-Schicht, um die Anzeige zu beenden.
        * `GetServerInformation() -> zbus::fdo::Result<(String, String, String, String)>`:
            * Gibt Informationen über den Benachrichtigungsdienst zurück (Name, Vendor, Version, Spec Version).

    * **Signale:**
        * `NotificationClosed(id: u32, reason: u32)`:
            * Wird gesendet, wenn eine Benachrichtigung geschlossen wird (vom Benutzer, Timeout, Anwendung).
            * `reason`: 1 (expired), 2 (dismissed by user), 3 (closed by app), 4 (undefined).
        * `ActionInvoked(id: u32, action_key: String)`:
            * Wird gesendet, wenn der Benutzer eine Aktion innerhalb einer Benachrichtigung anklickt.

3.  **`NotificationServer::run_server()` Funktion:**
    * `pub async fn run_server(engine: Arc<DefaultNotificationRulesEngine>, notification_tx: Sender<Notification>) -> Result<(), NotificationServerError>`
    * Stellt eine D-Bus-Verbindung her (Session-Bus).
    * Fordert den Well-Known Name `org.freedesktop.Notifications` an.
    * Registriert das implementierte D-Bus-Interface.
    * Startet die D-Bus-Event-Schleife, um eingehende Anfragen zu verarbeiten.

4.  **Verwaltung von Benutzer-Interaktionen (von UI):**
    * Das Modul muss auch in der Lage sein, Aktionen von der UI zu empfangen (z.B. Benutzer klickt auf eine Benachrichtigung oder eine Aktion in der Benachrichtigung).
    * `pub async fn handle_user_action(&self, id: u32, action_key: Option<String>) -> Result<(), NotificationServerError>`:
        * Intern aufgerufen, wenn die UI eine Benutzerinteraktion meldet.
        * Wenn `action_key` vorhanden: Emittiert das `ActionInvoked` Signal.
        * Wenn `action_key` `None` (Benachrichtigung geschlossen): Emittiert das `NotificationClosed` Signal mit dem entsprechenden `reason`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_server/mod.rs`
* `novade-system/src/notification_server/server.rs`
* `novade-system/src/notification_server/error.rs` (`NotificationServerError` Enum)

**Abhängigkeiten:**

* **Intern:**
    * `crate::notification_server::error::NotificationServerError`
    * `novade-core::types::notification::{Notification, NotificationEvent}`
    * `novade-domain::notification_rules::engine::DefaultNotificationRulesEngine`
    * `novade-domain::notification_rules::engine::RuleProcessingResult`
* **Extern:**
    * `zbus::{self, Connection, Interface, InterfaceRef, fdo}`
    * `zbus_macros::dbus_interface`
    * `tokio`
    * `std::sync::Arc`
    * `parking_lot::RwLock`
    * `std::collections::HashMap`
    * `tokio::sync::broadcast::{channel, Sender, Receiver}`
    * `std::sync::atomic::{AtomicU32, Ordering}`
    * `tracing`

**Kommunikationsmuster:**

* **Von externen Anwendungen:** Empfängt D-Bus-Methodenaufrufe (`Notify`, `CloseNotification` etc.) über das `org.freedesktop.Notifications` Interface.
* **An externe Anwendungen:** Sendet D-Bus-Signale (`NotificationClosed`, `ActionInvoked`).
* **An Domänenschicht (`DefaultNotificationRulesEngine`):** Leitet `Notification`s zur Regelverarbeitung weiter.
* **Von Domänenschicht (`DefaultNotificationRulesEngine`):** Empfängt `RuleProcessingResult`.
* **An UI-Schicht (`NotificationDisplayService`):** Sendet `Notification`s und `NotificationEvent::Closed` über einen Broadcast-Channel zur Anzeige.
* **Von UI-Schicht (`NotificationDisplayService`):** Empfängt Informationen über Benutzer-Interaktionen (Klick auf Benachrichtigung, Aktion).
* **An `SystemServices`:** Wird bei der Initialisierung der Systemschicht aufgerufen und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein vollständig konformer FreeDesktop Notifications Server, der Benachrichtigungen von Anwendungen entgegennimmt, durch NovaDE-Regeln filtert und die verbleibenden Benachrichtigungen zur Anzeige an die UI-Schicht weiterleitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken des `DefaultNotificationRulesEngine` und des `notification_tx` Senders.
    * Testen der `Notify` Methode:
        * Verifizieren, dass eine `Notification` korrekt aus den D-Bus-Argumenten erstellt wird.
        * Sicherstellen, dass die `notification_engine` korrekt aufgerufen wird.
        * Testen der verschiedenen `RuleProcessingResult`s (Display, Suppress, Modify) und deren Auswirkungen auf den `notification_tx` und die `active_notifications` Map.
        * Verifizieren der Rückgabe der korrekten `notification_id`.
    * Testen der `CloseNotification` Methode: Verifizieren, dass die Benachrichtigung aus `active_notifications` entfernt und ein `NotificationEvent::Closed` gesendet wird.
    * Testen der `GetCapabilities` und `GetServerInformation` Methoden.
    * Testen des `NotificationClosed` und `ActionInvoked` Signals unter verschiedenen Bedingungen.
* **Integration Tests:**
    * Starten des NovaDE-Compositors und des `NotificationServer`.
    * Verwenden einer Testanwendung (z.B. `notify-send` Utility oder eine kleine GTK-App), um Benachrichtigungen zu senden.
    * Überprüfen, ob die Benachrichtigungen in der NovaDE-UI erscheinen (oder unterdrückt werden, wenn Regeln dies vorschreiben).
    * Interagieren mit den Benachrichtigungen in der UI (Schließen, Klick auf Aktion) und Überprüfen, ob die entsprechenden D-Bus-Signale von NovaDE an die sendende Anwendung gesendet werden.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da D-Bus-Server-Implementierung, Signal-Handling, Integration mit `NotificationRulesEngine` und UI-Feedback komplex sind)

---

### **novade-system/src/notification_server/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`NotificationServerError`) für das `notification_server`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung für Benachrichtigungs-Server-Interaktionen sicher und ermöglicht eine präzise Fehlerweiterleitung.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationServerError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `DBusError(#[from] zbus::Error)`: Fehler, die von der zugrunde liegenden D-Bus-Kommunikation stammen (z.B. Name bereits beansprucht).
        * `EngineError(#[from] novade_domain::notification_rules::error::NotificationRulesError)`: Fehler bei der Verarbeitung von Benachrichtigungsregeln.
        * `InvalidArguments(String)`: Ungültige Argumente wurden in einer `Notify` Methode erhalten.
        * `NotificationNotFound(u32)`: Eine angeforderte Benachrichtigung (z.B. zum Schließen) wurde nicht gefunden.
        * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_server/error.rs`

**Abhängigkeiten:**

* **Intern:**
    * `novade_domain::notification_rules::error::NotificationRulesError`
* **Extern:**
    * `thiserror::Error`
    * `zbus::Error`
    * `std::io::Error`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `notification_server`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im `notification_server`-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `NotificationServerError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler (insbesondere für `zbus::Error` und `NotificationRulesError` Konvertierungen).

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---

### **novade-system/src/dbus_interfaces/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle D-Bus Client- und Server-Implementierungen innerhalb der Systemschicht. Es stellt eine klare und organisierte API für die `SystemServices` zur Verfügung, um alle D-Bus-bezogenen Funktionalitäten zu initialisieren und zu verwalten.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod logind;`
    * `pub mod upower;`
    * `pub mod network_manager;`
    * `pub mod secrets_service;`
    * `pub mod policykit_agent;`
    * `pub mod notification_server;`
    * `pub mod error;` (für das allgemeine `DBusError`)

2.  **Re-Exporte (`pub use`):**
    * Re-exportiert die Haupt-Services/Proxys und Fehler-Typen aus den Untermodulen, um den Zugriff zu vereinfachen.
    * Beispiel:
        * `pub use logind::{LogindProxy, LogindError};`
        * `pub use upower::{UPowerProxy, UPowerError};`
        * `pub use network_manager::{NetworkManagerProxy, NetworkManagerError, DeviceType, ConnectivityState, NetworkState};`
        * `pub use secrets_service::{SecretService, SecretsServiceError};`
        * `pub use policykit_agent::{PolicyKitAgent, PolicyKitError};`
        * `pub use notification_server::{NotificationServer, NotificationServerError};`
        * `pub use error::DBusError;`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/mod.rs`

**Abhängigkeiten:**

* **Intern:** Abhängig von allen Submodulen innerhalb von `novade-system::dbus_interfaces`.
* **Extern:** Keine direkten externen Abhängigkeiten, nur die, die von den re-exportierten Modulen verwendet werden.

**Kommunikationsmuster:**

* Wird von `novade-system::SystemServices` genutzt, um alle D-Bus-bezogenen Dienste zu initialisieren und zu referenzieren.

**Erwartete Ergebnisse/Outputs:**
Ein gut strukturierter und leicht zugänglicher Einstiegspunkt für alle D-Bus-bezogenen Funktionalitäten der NovaDE-Systemschicht.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte enthält.** Die Funktionalität wird in den einzelnen Submodulen getestet.

**Geschätzter Aufwand:** Gering (ca. 0.2 Tage)

---

### **novade-system/src/dbus_interfaces/error.rs**

**Verantwortlichkeit:**
Definiert ein allgemeines D-Bus-Fehler-Enum (`DBusError`) für alle D-Bus-Client- und Server-Implementierungen in der Systemschicht. Dies stellt eine konsistente Fehlerbehandlung für D-Bus-Operationen über verschiedene Dienste hinweg sicher und ermöglicht eine gemeinsame Fehlerkonvertierung in höhere Schichten.

**Kern-Aufgaben (Tasks):**

1.  **`DBusError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `ZbusError(#[from] zbus::Error)`: Ein Fehler, der direkt von der `zbus`-Bibliothek stammt (z.B. Verbindungsfehler, Methodenaufruf-Fehler).
        * `SignalMonitoringError(String)`: Fehler beim Monitoring von D-Bus-Signalen.
        * `InvalidData(String)`: Empfangene D-Bus-Daten konnten nicht korrekt deserialisiert oder interpretiert werden.
        * `ServiceUnavailable(String)`: Der Ziel-D-Bus-Dienst ist nicht verfügbar.
        * `MethodCallFailed(String)`: Ein D-Bus-Methodenaufruf ist auf der Gegenseite fehlgeschlagen.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/error.rs`

**Abhängigkeiten:**

* **Intern:** Keine direkten Abhängigkeiten.
* **Extern:**
    * `thiserror::Error`
    * `zbus::Error`

**Kommunikationsmuster:**

* Wird von allen D-Bus Client- und Server-Modulen innerhalb von `novade-system::dbus_interfaces` verwendet, um spezifische D-Bus-Fehler zu kapseln und zu standardisieren.
* Wird von den spezifischen Fehler-Enums dieser Module in ihre eigene Fehlerhierarchie eingebettet (z.B. `LogindError(DBusError)`).

**Erwartete Ergebnisse/Outputs:**
Ein zentrales und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung für D-Bus-Interaktionen in der Systemschicht standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `DBusError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler (insbesondere für `zbus::Error` Konvertierungen).

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---
### **novade-system/src/power_management**

**Verantwortlichkeit:**
Dieses Modul ist für die Steuerung und Überwachung des Energiemanagements des Systems zuständig. Es interagiert mit `logind` (über das `dbus_interfaces::logind` Modul) für Systemzustandsänderungen (Suspend, Hibernate, Shutdown, Reboot) und mit `upower` (über `dbus_interfaces::upower`) zur Überwachung des Batteriestatus und der Energiequellen. Es setzt die Richtlinien des `PowerPolicyService` aus der Domänenschicht um.

**Kern-Aufgaben (Tasks):**

1.  **`PowerManagementService` Struktur:**
    * Felder:
        * `logind_client: Arc<LogindProxy>` (D-Bus Proxy zum `logind` Service).
        * `upower_client: Arc<UPowerProxy>` (D-Bus Proxy zum `upower` Service).
        * `power_policy_service: Arc<PowerPolicyService>` (Referenz auf den PowerPolicyService der Domänenschicht).
        * `desktop_state_control: Arc<dyn PowerManagementControl>` (Trait-Objekt zur direkten DPMS-Kontrolle des Compositors, z.B. Bildschirm ausschalten).
        * `battery_status_tx: Sender<BatteryStatus>` (Broadcast-Sender für `BatteryStatus` Updates an die Domänenschicht und UI).
        * `battery_status_rx: Receiver<BatteryStatus>` (Broadcast-Receiver-Template).
        * `current_battery_status: RwLock<BatteryStatus>` (Aktueller Batteriestatus).

2.  **`PowerManagementService::new()` Funktion:**
    * `pub async fn new(logind_client: Arc<LogindProxy>, upower_client: Arc<UPowerProxy>, power_policy_service: Arc<PowerPolicyService>, desktop_state_control: Arc<dyn PowerManagementControl>) -> Result<Arc<Self>, PowerManagementError>`
    * Initialisiert die Clients und Services.
    * Fordert den initialen Batteriestatus von `upower` an und setzt `current_battery_status`.
    * Startet einen Task, der auf `upower` Signale (`DeviceAdded`, `DeviceRemoved`, `Changed`) lauscht und den Batteriestatus aktualisiert und über `battery_status_tx` sendet.
    * Startet einen Task, der auf `logind` Signale (`PrepareForSleep`, `PrepareForShutdown`) lauscht und die entsprechenden Aktionen einleitet.

3.  **`PowerManagementService::run_policy_loop()` Funktion:**
    * `pub async fn run_policy_loop(service: Arc<PowerManagementService>) -> Result<(), PowerManagementError>`
    * Eine Endlos-Schleife, die periodisch (oder auf `battery_status_tx` Events) den `PowerPolicyService` konsultiert.
    * Bei Änderungen im Batteriestatus oder im Netzteilanschluss:
        * Ruft `power_policy_service.evaluate_power_policy(current_battery_status)` auf.
        * Basierend auf dem Ergebnis (`PowerAction` Enum aus der Domänenschicht):
            * Führt die entsprechende Aktion aus:
                * `PowerAction::Nothing`: Keine Aktion.
                * `PowerAction::Suspend`: Ruft `logind_client.suspend()` auf.
                * `PowerAction::Hibernate`: Ruft `logind_client.hibernate()` auf.
                * `PowerAction::Shutdown`: Ruft `logind_client.poweroff()` auf.
                * `PowerAction::Reboot`: Ruft `logind_client.reboot()` auf.
                * `PowerAction::LockScreen`: Sendet ein Event an den `ScreenLockerService` der Domänenschicht.
                * `PowerAction::SetDPMS(bool)`: Ruft `desktop_state_control.set_dpms_active(bool)` auf, um den Bildschirm an-/auszuschalten.

4.  **`PowerManagementService::request_system_action()` Funktion:**
    * `pub async fn request_system_action(&self, action: SystemPowerAction) -> Result<(), PowerManagementError>`
    * `SystemPowerAction`: Enum mit `Shutdown`, `Reboot`, `Suspend`, `Hibernate`.
    * Ermöglicht der Domänenschicht oder UI, direkte Systemaktionen anzufordern (z.B. über ein Power-Menü).
    * Ruft die entsprechenden `logind_client`-Methoden auf.

5.  **`PowerManagementControl` Trait:**
    * Definiert in `novade-system/src/power_management/interface.rs`.
    * `pub trait PowerManagementControl: Send + Sync { async fn set_dpms_active(&self, active: bool) -> Result<(), PowerManagementError>; }`
    * Wird vom `CompositorState` der `novade-system::compositor` Crate implementiert, um DPMS zu steuern.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management/mod.rs`
* `novade-system/src/power_management/service.rs`
* `novade-system/src/power_management/error.rs` (`PowerManagementError` Enum)
* `novade-system/src/power_management/interface.rs` (`PowerManagementControl` Trait)

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_management::error::PowerManagementError`
    * `crate::power_management::interface::PowerManagementControl`
    * `crate::dbus_interfaces::logind::{LogindProxy, LogindError}`
    * `crate::dbus_interfaces::upower::{UPowerProxy, UPowerError}`
    * `novade-core::types::power::{BatteryStatus, SystemPowerAction}`
    * `novade-domain::power_policy::service::{PowerPolicyService, PowerAction}`
    * `novade-domain::screen_locker::service::ScreenLockerService` (für `LockScreen` Aktion)
* **Extern:**
    * `tokio`
    * `std::sync::Arc`
    * `parking_lot::RwLock`
    * `tokio::sync::broadcast::{channel, Sender, Receiver}`
    * `tracing`
    * `async_trait`

**Kommunikationsmuster:**

* **An `logind` und `upower` (D-Bus):** Sendet Methodenaufrufe und lauscht auf Signale.
* **An Domänenschicht (`PowerPolicyService`):** Fragt nach Energiemanagement-Richtlinien.
* **An Domänenschicht (`ScreenLockerService`):** Sendet Lock-Screen-Anfragen.
* **An Compositor (`PowerManagementControl` Trait):** Steuert DPMS (Display Power Management Signaling).
* **An Domänenschicht/UI:** Broadcastet `BatteryStatus` Updates.
* **Von Domänenschicht/UI:** Empfängt direkte Anfragen für Systemaktionen (`request_system_action`).
* **An `SystemServices`:** Wird bei der Initialisierung der Systemschicht aufgerufen und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein umfassender und reaktionsschneller Dienst für das Energiemanagement, der die Systemenergieeffizienz optimiert, Batteriestatus überwacht und korrekte Systemzustandsübergänge (Suspend, Shutdown etc.) gemäß den Domänen-Richtlinien und Benutzeranfragen durchführt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken des `LogindProxy`, `UPowerProxy`, `PowerPolicyService` und `PowerManagementControl`.
    * Testen der `new()`-Funktion: Verifizieren, dass Clients korrekt initialisiert und der initiale Batteriestatus abgefragt wird.
    * Testen der Signal-Verarbeitung von `upower`: Simulieren von `Changed` Signalen und überprüfen, ob `battery_status_tx` korrekt sendet.
    * Testen der `run_policy_loop`: Simulieren verschiedener `BatteryStatus` und `PowerPolicyService` Antworten und verifizieren, dass die korrekten `logind_client`-Methoden oder `desktop_state_control`-Methoden aufgerufen werden.
    * Testen der `request_system_action` Methode für alle `SystemPowerAction` Varianten.
    * Testen der Fehlerbehandlung für D-Bus-Fehler und Policy-Service-Fehler.
* **Integration Tests:**
    * Starten des NovaDE-Compositors.
    * Simulieren von Batteriezustandsänderungen (z.B. über `upower` CLI-Tools oder udev-Regeln).
    * Überprüfen, ob NovaDE die entsprechenden Power-Aktionen ausführt (Bildschirm ausschalten, Suspend, etc.).
    * Testen des Power-Menüs in der UI und Verifizieren, ob die Systemaktionen korrekt ausgeführt werden.

**Geschätzter Aufwand:** Hoch (ca. 6-9 Tage, da D-Bus-Integration, asynchrone Signalverarbeitung, Policy-Interaktion und DPMS-Steuerung komplex sind)

---

### **novade-system/src/power_management/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`PowerManagementError`) für das `power_management`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung für Energiemanagement-Interaktionen sicher und ermöglicht eine präzise Fehlerweiterleitung.

**Kern-Aufgaben (Tasks):**

1.  **`PowerManagementError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `LogindError(#[from] crate::dbus_interfaces::logind::LogindError)`: Fehler vom `logind` D-Bus-Dienst.
        * `UPowerError(#[from] crate::dbus_interfaces::upower::UPowerError)`: Fehler vom `upower` D-Bus-Dienst.
        * `PolicyError(#[from] novade_domain::power_policy::error::PowerPolicyError)`: Fehler bei der Auswertung von Energie-Richtlinien.
        * `ScreenLockerError(String)`: Fehler beim Anfordern einer Bildschirmsperre.
        * `DPMSControlError(String)`: Fehler bei der direkten DPMS-Kontrolle (Bildschirm an/aus).
        * `InvalidState(String)`: Das Energiemanagement-Modul befindet sich in einem unerwarteten Zustand.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management/error.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::logind::LogindError`
    * `crate::dbus_interfaces::upower::UPowerError`
    * `novade_domain::power_policy::error::PowerPolicyError`
* **Extern:**
    * `thiserror::Error`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `power_management`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im `power_management`-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `PowerManagementError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---

### **novade-system/src/power_management/interface.rs**

**Verantwortlichkeit:**
Definiert das `PowerManagementControl`-Trait, das eine Schnittstelle für die Steuerung von Display Power Management Signaling (DPMS) bereitstellt. Dies ist entscheidend, um den Bildschirm basierend auf Energie-Richtlinien oder Benutzeraktionen ein- und auszuschalten.

**Kern-Aufgaben (Tasks):**

1.  **`PowerManagementControl` Trait Definition:**
    * `pub trait PowerManagementControl: Send + Sync {`
    * `async fn set_dpms_active(&self, active: bool) -> Result<(), PowerManagementError>;`
    * `}`
    * `active: bool` - `true` um DPMS zu aktivieren (Bildschirm an), `false` um es zu deaktivieren (Bildschirm aus).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management/interface.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_management::error::PowerManagementError`
* **Extern:**
    * `async_trait` (für `async fn` in Traits)

**Kommunikationsmuster:**

* Implementiert vom `CompositorState` der `novade-system::compositor` Crate.
* Wird vom `PowerManagementService` aufgerufen, um den Bildschirm direkt zu steuern.

**Erwartete Ergebnisse/Outputs:**
Eine klare und konsistente Schnittstelle zur Steuerung des Display-Zustands, die eine Entkopplung zwischen dem Energiemanagement-Dienst und der Compositor-Implementierung ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Implementierungen dieses Traits in den konkreten Klassen (z.B. Mock-Implementierungen für den `CompositorState`).
    * Verifizieren, dass die `set_dpms_active` Methode korrekt aufgerufen wird und die erwarteten Ergebnisse liefert.

**Geschätzter Aufwand:** Gering (ca. 0.2 Tage)

---

### **novade-system/src/system_services.rs**

**Verantwortlichkeit:**
Dieses Modul ist der zentrale Orchestrator für die Initialisierung, Verwaltung und Bereitstellung aller Kerndienste der Systemschicht von NovaDE. Es stellt sicher, dass alle Systemkomponenten korrekt miteinander verdrahtet sind und die erforderlichen Abhängigkeiten erfüllt werden. Es kapselt die Komplexität der Systemdienst-Initialisierung und bietet eine einzige Schnittstelle für die Domänenschicht.

**Kern-Aufgaben (Tasks):**

1.  **`SystemServices` Struktur:**
    * Felder:
        * `compositor_state: Arc<CompositorState>` (Der Zustand des Wayland-Compositors).
        * `input_service: Arc<InputService>`
        * `keyboard_layout_service: Arc<KeyboardLayoutService>`
        * `audio_management_service: Arc<AudioManagementService>`
        * `power_management_service: Arc<PowerManagementService>`
        * `portal_service: Arc<PortalService>`
        * `network_manager_proxy: Arc<NetworkManagerProxy>` (Direkte Referenz, da oft von UI/Settings benötigt)
        * `secret_service: Arc<SecretService>`
        * `policykit_agent: Arc<PolicyKitAgent>`
        * `notification_server: Arc<NotificationServer>`
        * `mcp_client: Arc<MCPClient>` (Client für Model Context Protocol)
        * `display_handle: smithay::reexports::wayland_server::DisplayHandle` (Wayland Display Handle).
        * `event_channel_tx: Sender<CoreEvent>` (Optional: Ein globaler Event-Bus für System-Events).

2.  **`SystemServices::new()` Funktion:**
    * `pub async fn new(domain_services: Arc<DomainServices>, event_channel_tx: Sender<CoreEvent>) -> Result<Arc<Self>, SystemServiceError>`
    * Dies ist die Hauptinitialisierungsfunktion der Systemschicht.
    * Schritte in der Initialisierungsreihenfolge (die Abhängigkeiten beachten):
        * **1. Compositor & Display Handle:**
            * Initialisiere `smithay::reexports::wayland_server::Display`.
            * Erstelle `CompositorState::new()` mit den nötigen Callbacks und Event-Handlern, die mit der Domänenschicht interagieren (z.B. für Fenster-Lebenszyklus, Fokusänderungen).
            * Die `CompositorState` sollte in der Lage sein, die `PowerManagementControl`-Implementierung für den `PowerManagementService` zu liefern.
        * **2. Keyboard Layout Service:**
            * `keyboard_layout_service = KeyboardLayoutService::new()?`
        * **3. Audio Management Service:**
            * `audio_management_service = AudioManagementService::new(domain_services.audio_policy_service.clone())?`
        * **4. Input Service:**
            * `input_service = InputService::new(domain_services.seat_manager_service.clone())?`
            * Startet den `run_event_loop` Task für den `input_service`.
        * **5. D-Bus Interfaces (Clients & Server):**
            * `logind_proxy = LogindProxy::new().await?`
            * `upower_proxy = UPowerProxy::new().await?`
            * `network_manager_proxy = NetworkManagerProxy::new().await?`
            * `portal_service = PortalService::new().await?`
            * `secret_service = SecretService::new().await?`
            * `policykit_agent = PolicyKitAgent::new(domain_services.prompt_service.clone()).await?`
            * `notification_server = NotificationServer::new(domain_services.notification_rules_engine.clone(), ui_notification_tx).await?` (Hinweis: `ui_notification_tx` muss von der UI-Schicht bereitgestellt werden, oder `SystemServices` muss einen eigenen Channel bereitstellen und die UI abonniert diesen).
        * **6. Power Management Service:**
            * `power_management_service = PowerManagementService::new(logind_proxy.clone(), upower_proxy.clone(), domain_services.power_policy_service.clone(), compositor_state.clone() as Arc<dyn PowerManagementControl>)?`
            * Startet den `run_policy_loop` Task.
        * **7. Window Mechanics Service:**
            * `window_mechanics_service = WindowMechanicsService::new(compositor_state.clone(), domain_services.window_policy_service.clone())?`
            * Startet den Event-Processing-Task für `window_mechanics_service`.
        * **8. MCP Client:**
            * `mcp_client = MCPClient::new(domain_services.mcp_policy_service.clone(), domain_services.secret_management_service.clone())?`
        * **9. Starten aller Wayland Globals:**
            * `compositor::core::create_all_wayland_globals(&display_handle, compositor_state.clone())`
        * **10. Rückgabe von `SystemServices` Instanz.**

3.  **`SystemServices::run()` Funktion (optional, für den Haupt-Event-Loop):**
    * `pub async fn run(&self) -> Result<(), SystemServiceError>`
    * Startet den Wayland-Display-Loop (`display_handle.run_event_loop()`).
    * Blockiert und hält den Compositor am Laufen.
    * Kann auch zusätzliche Hintergrundtasks spawnen, die nicht direkt an einen Service gebunden sind, aber für die Lebensdauer des Systems kritisch sind.

4.  **`SystemServiceError` Enum:**
    * Definiert in `novade-system/src/system_services/error.rs`.
    * Kapselt alle Fehler, die während der Initialisierung oder des Betriebs der Systemdienste auftreten können.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/system_services.rs`
* `novade-system/src/system_services/error.rs` (`SystemServiceError` Enum)

**Abhängigkeiten:**

* **Intern (alle Module innerhalb `novade-system`):**
    * `crate::compositor::CompositorState`
    * `crate::input_management::{InputService, InputError}`
    * `crate::keyboard_layout::{KeyboardLayoutService, KeyboardLayoutError}`
    * `crate::audio_management::{AudioManagementService, AudioManagementError}`
    * `crate::power_management::{PowerManagementService, PowerManagementError, PowerManagementControl}`
    * `crate::portals::{PortalService, PortalError}`
    * `crate::dbus_interfaces::logind::{LogindProxy, LogindError}`
    * `crate::dbus_interfaces::upower::{UPowerProxy, UPowerError}`
    * `crate::dbus_interfaces::network_manager::{NetworkManagerProxy, NetworkManagerError}`
    * `crate::dbus_interfaces::secrets_service::{SecretService, SecretsServiceError}`
    * `crate::dbus_interfaces::policykit_agent::{PolicyKitAgent, PolicyKitError}`
    * `crate::dbus_interfaces::notification_server::{NotificationServer, NotificationServerError}`
    * `crate::mcp_client::{MCPClient, MCPClientError}`
    * `crate::window_mechanics::{WindowMechanicsService, WindowMechanicsError}`
* **Extern:**
    * `novade-core::types::core::CoreEvent`
    * `novade-domain::DomainServices` (und alle darin enthaltenen Services)
    * `smithay::reexports::wayland_server::DisplayHandle`
    * `tokio`
    * `std::sync::Arc`
    * `tokio::sync::broadcast::{channel, Sender}`
    * `tracing`

**Kommunikationsmuster:**

* **Von `main` (oder einem höherliegenden Bootstrapper):** Ruft `SystemServices::new()` auf, um die Systemschicht zu initialisieren.
* **An Domänenschicht (`DomainServices`):** Empfängt Referenzen auf Domänendienste für Callbacks und Policy-Abfragen.
* **An UI-Schicht:** Sendet Events über Broadcast-Channels (z.B. `NotificationServer` an `NotificationDisplayService`).
* **Intern:** Jeder Dienst ruft Methoden auf den Services auf, von denen er abhängt.

**Erwartete Ergebnisse/Outputs:**
Eine vollständig initialisierte und lauffähige Systemschicht, die alle Interaktionen mit dem Betriebssystem, der Hardware und externen Diensten übernimmt und die Domänenschicht und UI mit den notwendigen Informationen und Funktionen versorgt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Schwierig direkt auf `SystemServices::new()` anzuwenden, da es viele echte Abhängigkeiten hat. Man könnte alle Services mocken und die korrekte Verdrahtung überprüfen.
    * Testen der `SystemServiceError` Konvertierungen.
* **Integration Tests:**
    * **Crucial:** Dies ist der Hauptpunkt für Integrationstests der gesamten Systemschicht.
    * Starten der `SystemServices` in einer isolierten Umgebung (z.B. `xvfb` oder `rootless` `wayland-server`).
    * Überprüfen, ob alle D-Bus-Dienste erreichbar sind und die Proxys funktionieren.
    * Simmulieren von Input-Ereignissen und überprüfen, ob der Compositor korrekt reagiert.
    * Simulieren von Power-Ereignissen und überprüfen, ob die entsprechenden Aktionen getriggert werden.
    * Testen der End-to-End-Flüsse, z.B. Benachrichtigung senden -> wird angezeigt -> Aktion wird verarbeitet.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage für die Orchestrierung und Fehlerbehandlung, da die Initialisierungsreihenfolge und das Fehlerhandling komplex sind)

---

### **novade-system/src/system_services/error.rs**

**Verantwortlichkeit:**
Definiert das globale Fehler-Enum (`SystemServiceError`) für die gesamte `novade-system` Crate. Dieses Enum kapselt alle möglichen Fehler, die von den verschiedenen Modulen der Systemschicht während ihrer Initialisierung oder ihres Betriebs zurückgegeben werden können, und bietet eine konsistente Fehlerhierarchie für höhere Schichten.

**Kern-Aufgaben (Tasks):**

1.  **`SystemServiceError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten (mit `#[from]` für automatische Konvertierung):
        * `CompositorError(#[from] crate::compositor::error::CompositorError)`
        * `InputError(#[from] crate::input_management::error::InputError)`
        * `KeyboardLayoutError(#[from] crate::keyboard_layout::error::KeyboardLayoutError)`
        * `AudioManagementError(#[from] crate::audio_management::error::AudioManagementError)`
        * `PowerManagementError(#[from] crate::power_management::error::PowerManagementError)`
        * `PortalError(#[from] crate::portals::error::PortalError)`
        * `LogindError(#[from] crate::dbus_interfaces::logind::LogindError)`
        * `UPowerError(#[from] crate::dbus_interfaces::upower::UPowerError)`
        * `NetworkManagerError(#[from] crate::dbus_interfaces::network_manager::NetworkManagerError)`
        * `SecretsServiceError(#[from] crate::dbus_interfaces::secrets_service::SecretsServiceError)`
        * `PolicyKitError(#[from] crate::dbus_interfaces::policykit_agent::PolicyKitError)`
        * `NotificationServerError(#[from] crate::dbus_interfaces::notification_server::NotificationServerError)`
        * `MCPClientError(#[from] crate::mcp_client::error::MCPClientError)`
        * `WindowMechanicsError(#[from] crate::window_mechanics::error::WindowMechanicsError)`
        * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler, z.B. bei Dateizugriff.
        * `InitializationError(String)`: Ein allgemeiner Fehler während der Initialisierung, der nicht spezifischer zugeordnet werden kann.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/system_services/error.rs`

**Abhängigkeiten:**

* **Intern:** Abhängig von allen spezifischen Fehler-Enums der anderen Module in `novade-system`.
* **Extern:**
    * `thiserror::Error`
    * `std::io::Error`

**Kommunikationsmuster:**

* Wird als Rückgabetyp (`Result<(), SystemServiceError>`) von `SystemServices::new()` und `SystemServices::run()` verwendet.
* Wird von den spezifischen Fehler-Enums der Submodule durch die `#[from]`-Attribute automatisch konvertiert, wenn sie in `SystemServices` propagiert werden.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und umfassendes Fehler-Enum, das die Fehlerbehandlung auf der Systemschichtebene standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `SystemServiceError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette, um sicherzustellen, dass die ursprüngliche Fehlerursache erhalten bleibt.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---
### **novade-system/src/mcp_client**

**Verantwortlichkeit:**
Dieses Modul implementiert einen Client für das Model Context Protocol (MCP). MCP ist ein spezifisches Protokoll, das für die sichere und effiziente Kommunikation mit KI-Modellen innerhalb der NovaDE-Umgebung entwickelt wurde. Der MCP-Client ist verantwortlich für die Anbindung an den MCP-Daemon (oder -Service), das Senden von Anfragen an registrierte KI-Modelle und das Empfangen von Antworten, wobei Aspekte wie Authentifizierung, Autorisierung und Datensicherheit (z.B. über den Secret Service) berücksichtigt werden. Er dient als Brücke zwischen der Domänenschicht, die KI-Funktionalität anfordert, und den eigentlichen KI-Modellen.

**Kern-Aufgaben (Tasks):**

1.  **`MCPClient` Struktur:**
    * Felder:
        * `connection: zbus::Connection` (D-Bus-Verbindung zum System- oder Session-Bus, je nachdem wo der MCP-Daemon läuft).
        * `mcp_proxy: Arc<MCPProxy>` (D-Bus Proxy für das `org.novade.MCP` Haupt-Interface).
        * `mcp_policy_service: Arc<MCPPolicyService>` (Referenz auf den `MCPPolicyService` der Domänenschicht zur Policy-Auswertung).
        * `secret_management_service: Arc<SecretManagementService>` (Referenz auf den `SecretManagementService` zur sicheren Handhabung von API-Schlüsseln oder Tokens).
        * `model_cache: RwLock<HashMap<String, ModelInfo>>` (Cache für Informationen über registrierte KI-Modelle).

2.  **D-Bus Proxy Definition (`zbus_macros::dbus_proxy`):**
    * `MCPProxy`: Interface `org.novade.MCP.Manager` (oder ähnlich, je nach finaler MCP-Spezifikation).
        * Methoden: `RegisterModel`, `UnregisterModel`, `ListModels`, `InvokeModel`.
        * Signale: `ModelRegistered`, `ModelUnregistered`, `ModelAvailabilityChanged`.

3.  **`MCPClient::new()` Funktion:**
    * `pub async fn new(mcp_policy_service: Arc<MCPPolicyService>, secret_management_service: Arc<SecretManagementService>) -> Result<Arc<Self>, MCPClientError>`
    * Stellt eine D-Bus-Verbindung her (System- oder Session-Bus).
    * Erstellt den `MCPProxy`.
    * Fragt den initialen Status der registrierten Modelle ab und füllt den `model_cache`.
    * Startet einen Task, der auf `ModelRegistered`, `ModelUnregistered` und `ModelAvailabilityChanged` Signale lauscht und den `model_cache` aktualisiert.

4.  **Modell-Interaktion:**
    * `pub async fn invoke_model(&self, model_id: &str, request: ModelRequest) -> Result<ModelResponse, MCPClientError>`:
        * `model_id`: Eindeutiger Bezeichner des aufzurufenden KI-Modells.
        * `request`: Die Datenstruktur, die die Anfrage an das KI-Modell kapselt (z.B. Text für Generierung, Bild für Analyse).
        * **Intern:**
            * Prüft über `mcp_policy_service` die Berechtigung für den Aufruf (`CheckModelAccess`).
            * Holt ggf. erforderliche Authentifizierungs-Tokens/API-Schlüssel über den `secret_management_service`.
            * Serialisiert `request` in ein geeignetes Format (z.B. JSON, protobuf) für den D-Bus-Transport.
            * Ruft die `InvokeModel` D-Bus-Methode auf dem `MCPProxy` auf.
            * Deserialisiert die empfangene Antwort in `ModelResponse`.
            * Verarbeitet potenzielle Fehler oder spezielle Statuscodes vom Modell/Daemon.
    * `pub async fn list_available_models(&self) -> Result<Vec<ModelInfo>, MCPClientError>`:
        * Ruft `ListModels` auf dem `MCPProxy` auf und gibt die Informationen über verfügbare Modelle zurück.

5.  **Datenstrukturen für MCP (`novade-core::types::mcp`):**
    * `ModelInfo`: Enthält Metadaten zu einem KI-Modell (ID, Name, Beschreibung, unterstützte Features, Kostenmodell, etc.).
    * `ModelRequest`: Struktur für Anfragen an KI-Modelle (generisch genug, um verschiedene KI-Aufgaben zu kapseln).
    * `ModelResponse`: Struktur für Antworten von KI-Modellen.
    * Implementiere `serde::{Serialize, Deserialize}` für diese Strukturen, da sie über D-Bus ausgetauscht werden müssen.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/mcp_client/mod.rs`
* `novade-system/src/mcp_client/client.rs`
* `novade-system/src/mcp_client/error.rs` (`MCPClientError` Enum)

**Abhängigkeiten:**

* **Intern:**
    * `crate::mcp_client::error::MCPClientError`
    * `novade-core::types::mcp::{ModelInfo, ModelRequest, ModelResponse}`
    * `novade-domain::mcp_policy::service::{MCPPolicyService, MCPPolicyError}`
    * `novade-domain::secret_management::service::SecretManagementService`
    * `crate::dbus_interfaces::error::DBusError`
* **Extern:**
    * `zbus::{self, Connection, Proxy, zvariant::{ObjectPath, OwnedValue}}`
    * `zbus_macros::dbus_proxy`
    * `tokio`
    * `std::sync::Arc`
    * `parking_lot::RwLock`
    * `std::collections::HashMap`
    * `serde::{Serialize, Deserialize}`
    * `serde_json` (für die Serialisierung/Deserialisierung von `ModelRequest`/`ModelResponse`)
    * `tracing`
    * `async_trait`

**Kommunikationsmuster:**

* **An MCP-Daemon (D-Bus):** Sendet Methodenaufrufe (`InvokeModel`, `ListModels`) und lauscht auf Signale (`ModelRegistered`).
* **An Domänenschicht (`MCPPolicyService`):** Fragt nach Policies für den Zugriff auf Modelle.
* **An Domänenschicht (`SecretManagementService`):** Fordert API-Schlüssel oder Tokens an.
* **Von Domänenschicht (`AIIntegrationService` oder ähnliches):** Empfängt Anfragen zum Aufruf von KI-Modellen.
* **An `SystemServices`:** Wird bei der Initialisierung der Systemschicht aufgerufen und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Client für das Model Context Protocol, der NovaDE ermöglicht, sicher und effizient mit lokalen oder entfernten KI-Modellen zu interagieren, unter Berücksichtigung von Zugriffsrichtlinien und der sicheren Handhabung von Anmeldeinformationen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken des `zbus::Connection`, `MCPProxy`, `MCPPolicyService` und `SecretManagementService`.
    * Testen der `new()`-Funktion: Verifizieren der Initialisierung und des Caching von Model-Informationen.
    * Testen der `invoke_model` Methode:
        * Simulieren erfolgreicher Aufrufe und Überprüfen der Deserialisierung.
        * Simulieren von Policy-Ablehnungen und Verifizieren der korrekten Fehler.
        * Simulieren fehlender/fehlerhafter Geheimnisse und Verifizieren der Fehler.
        * Simulieren verschiedener D-Bus-Fehler und Modell-spezifischer Fehler.
    * Testen der `list_available_models` Methode.
    * Testen der Signalverarbeitung für Modell-Registrierung/Deregistrierung/Verfügbarkeit.
* **Integration Tests:**
    * Starten des NovaDE-Compositors mit einem laufenden MCP-Daemon (ggf. einem Mock-Daemon für Tests).
    * Testen von End-to-End-Szenarien, bei denen die Domänenschicht eine KI-Anfrage über den `MCPClient` initiiert und die Antwort verarbeitet.
    * Verifizieren der korrekten Authentifizierung und Autorisierung mit dem MCP-Daemon.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da MCP-Protokoll-Implementierung, D-Bus-Interaktion, Policy-Integration und Secret-Handling komplex sind)

---

### **novade-system/src/mcp_client/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`MCPClientError`) für das `mcp_client`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung für MCP-Client-Interaktionen sicher und ermöglicht eine präzise Fehlerweiterleitung.

**Kern-Aufgaben (Tasks):**

1.  **`MCPClientError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `DBusError(#[from] crate::dbus_interfaces::error::DBusError)`: Fehler, die von der zugrunde liegenden D-Bus-Kommunikation stammen.
        * `PolicyError(#[from] novade_domain::mcp_policy::error::MCPPolicyError)`: Fehler bei der Auswertung von MCP-Zugriffsrichtlinien.
        * `SecretManagementError(String)`: Fehler beim Abrufen von Geheimnissen vom `SecretManagementService`.
        * `ModelNotFound(String)`: Das angeforderte KI-Modell wurde nicht gefunden oder ist nicht verfügbar.
        * `ModelInvocationFailed(String)`: Der Aufruf des KI-Modells ist fehlgeschlagen (Fehler vom Modell/Daemon).
        * `SerializationError(#[from] serde_json::Error)`: Fehler beim Serialisieren/Deserialisieren von Model-Anfragen/Antworten.
        * `InvalidData(String)`: Empfangene Daten sind ungültig oder konnten nicht interpretiert werden.
        * `AuthenticationRequired`: Das Modell benötigt eine Authentifizierung, die nicht bereitgestellt werden konnte.
        * `UnauthorizedAccess`: Der Zugriff auf das Modell wurde durch die PolicyKit/MCP-Policy abgelehnt.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/mcp_client/error.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DBusError`
    * `novade_domain::mcp_policy::error::MCPPolicyError`
* **Extern:**
    * `thiserror::Error`
    * `serde_json::Error`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `mcp_client`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im `mcp_client`-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `MCPClientError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---

### **novade-system/src/window_mechanics**

**Verantwortlichkeit:**
Dieses Modul ist für die technische Umsetzung der Fenster-Policies verantwortlich, die von der Domänenschicht (`WindowPolicyService`) definiert werden. Es interagiert direkt mit dem Compositor (`CompositorState`), um Fenster zu positionieren, zu verändern, Tiling-Layouts anzuwenden und den Fokus zu verwalten. Es übersetzt die abstrakten Policy-Anweisungen in konkrete Compositor-Operationen.

**Kern-Aufgaben (Tasks):**

1.  **`WindowMechanicsService` Struktur:**
    * Felder:
        * `compositor_state: Arc<CompositorState>` (Referenz auf den Wayland-Compositor-Zustand).
        * `window_policy_service: Arc<WindowPolicyService>` (Referenz auf den Policy-Dienst der Domänenschicht).
        * `window_event_rx: Receiver<WindowEventType>` (Broadcast-Receiver für Fenster-Events vom `CompositorState`).
        * `layout_engine: Box<dyn TilingLayout>` (Dynamisch wählbare Tiling-Layout-Engine).

2.  **`WindowMechanicsService::new()` Funktion:**
    * `pub fn new(compositor_state: Arc<CompositorState>, window_policy_service: Arc<WindowPolicyService>) -> Result<Arc<Self>, WindowMechanicsError>`
    * Initialisiert den Service, holt den Receiver für Fenster-Events vom `CompositorState`.
    * Wählt eine Standard `TilingLayout` Engine (z.B. eine einfache Stack-Layout-Implementierung).

3.  **`WindowMechanicsService::run_event_loop()` Funktion:**
    * `pub async fn run_event_loop(self: Arc<Self>) -> Result<(), WindowMechanicsError>`
    * Eine Endlos-Schleife, die auf `WindowEventType`s vom `compositor_state` lauscht.
    * **Behandlung von `WindowEventType`s:**
        * `WindowEventType::NewWindow(surface_id)`:
            * Informiert `window_policy_service.on_new_window(surface_id)`.
            * Fordert eine initiale Position/Größe/Tiling-Anweisung vom `window_policy_service` an.
            * Wendet diese Anweisung auf das Fenster im `compositor_state` an (`compositor_state.map_window(...)`, `compositor_state.set_window_geometry(...)`).
            * Fügt das Fenster zum `layout_engine` hinzu und triggert einen Re-Layout.
        * `WindowEventType::WindowClosed(surface_id)`:
            * Informiert `window_policy_service.on_window_closed(surface_id)`.
            * Entfernt das Fenster aus dem `layout_engine` und triggert einen Re-Layout.
        * `WindowEventType::WindowMoved(surface_id, new_position)`:
            * Informiert `window_policy_service.on_window_moved(surface_id, new_position)`.
            * Falls das Fenster im Tiling-Modus ist, muss es ggf. aus dem Tiling-Modus entfernt werden.
        * `WindowEventType::WindowResized(surface_id, new_geometry)`:
            * Informiert `window_policy_service.on_window_resized(surface_id, new_geometry)`.
            * Falls das Fenster im Tiling-Modus ist, muss es ggf. aus dem Tiling-Modus entfernt werden.
        * `WindowEventType::FocusChanged(surface_id)`:
            * Informiert `window_policy_service.on_focus_changed(surface_id)`.
            * Setzt den Fokus im `compositor_state` (`compositor_state.set_focused_window(surface_id)`).
        * `WindowEventType::Minimize(surface_id)`:
            * Informiert `window_policy_service.on_window_minimize(surface_id)`.
            * Wendet den Minimierungszustand im `compositor_state` an.
        * `WindowEventType::Maximize(surface_id)`:
            * Informiert `window_policy_service.on_window_maximize(surface_id)`.
            * Wendet den Maximierungszustand im `compositor_state` an.
        * `WindowEventType::Fullscreen(surface_id)`:
            * Informiert `window_policy_service.on_window_fullscreen(surface_id)`.
            * Wendet den Vollbildzustand im `compositor_state` an.
        * `WindowEventType::RequestMove(surface_id)` / `RequestResize(surface_id)`:
            * Leitet interaktive Moves/Resizes über den `compositor_state` ein.

4.  **`WindowMechanicsService::set_tiling_layout()` Funktion:**
    * `pub fn set_tiling_layout(&self, layout: Box<dyn TilingLayout>) -> Result<(), WindowMechanicsError>`
    * Ermöglicht das Ändern der aktiven Tiling-Engine.
    * Triggert einen Re-Layout aller Fenster mit der neuen Engine.

5.  **`TilingLayout` Trait:**
    * Definiert in `novade-system/src/window_mechanics/tiling.rs`.
    * `pub trait TilingLayout: Send + Sync {`
    * `fn add_window(&mut self, window_id: WindowId, workspace_id: WorkspaceId);`
    * `fn remove_window(&mut self, window_id: WindowId);`
    * `fn rearrange_windows(&self, workspace_id: WorkspaceId, output_geometry: Rectangle) -> HashMap<WindowId, Rectangle>;`
    * `fn get_name(&self) -> &'static str;`
    * `}`
    * `WindowId` und `WorkspaceId` sollten aus `novade-core::types::window` kommen.

6.  **Beispiel-Implementierungen von `TilingLayout` (in `novade-system/src/window_mechanics/tiling`):**
    * `StackLayout`: Einfacher Stapel von Fenstern.
    * `ColumnsLayout`: Teilt den Bildschirm in Spalten.
    * `FibonacciLayout`: Fibonacci-spiralförmiges Layout.
    * `MonocleLayout`: Nur ein Fenster maximiert sichtbar, andere gestapelt.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_mechanics/mod.rs`
* `novade-system/src/window_mechanics/service.rs`
* `novade-system/src/window_mechanics/error.rs` (`WindowMechanicsError` Enum)
* `novade-system/src/window_mechanics/tiling.rs` (Trait und Beispiel-Layouts)

**Abhängigkeiten:**

* **Intern:**
    * `crate::window_mechanics::error::WindowMechanicsError`
    * `crate::window_mechanics::tiling::TilingLayout`
    * `crate::compositor::{CompositorState, WindowEventType, CompositorError}`
    * `novade-core::types::window::{WindowId, WorkspaceId, WindowState, WindowGeometry}`
    * `novade-core::types::geometry::Rectangle`
    * `novade-domain::window_policy::service::{WindowPolicyService, WindowPolicyError, WindowPolicyResult}`
* **Extern:**
    * `tokio`
    * `std::sync::Arc`
    * `tokio::sync::broadcast::Receiver`
    * `std::collections::HashMap`
    * `tracing`
    * `async_trait`

**Kommunikationsmuster:**

* **Von Compositor (`CompositorState`):** Empfängt `WindowEventType`s über einen Broadcast-Channel.
* **An Compositor (`CompositorState`):** Ruft Methoden auf, um Fenstergeometrie, Zustand und Fokus zu ändern.
* **An Domänenschicht (`WindowPolicyService`):** Informiert über Fenster-Events und fragt nach Policy-Entscheidungen.
* **Von Domänenschicht (`WindowPolicyService`):** Empfängt Policy-Entscheidungen (`WindowPolicyResult`).
* **An `SystemServices`:** Wird bei der Initialisierung der Systemschicht aufgerufen und verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller und erweiterbarer Dienst für die Fensterverwaltung, der die Fenster-Policies der Domänenschicht technisch umsetzt, verschiedene Tiling-Layouts unterstützt und eine nahtlose Benutzererfahrung bei der Interaktion mit Fenstern bietet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken des `CompositorState` und des `WindowPolicyService`.
    * Testen der `run_event_loop` für jeden `WindowEventType`:
        * Verifizieren, dass der `WindowPolicyService` korrekt informiert und konsultiert wird.
        * Sicherstellen, dass die korrekten `compositor_state`-Methoden mit den richtigen Argumenten aufgerufen werden (z.B. `set_window_geometry` nach einer Layout-Anwendung).
        * Testen der Integration mit `TilingLayout` (Add/Remove/Rearrange).
    * Testen verschiedener `TilingLayout`-Implementierungen isoliert: Überprüfen, ob sie korrekte Geometrien für eine gegebene Fensterliste und Output-Größe berechnen.
    * Testen der `set_tiling_layout` Funktion und des Re-Layout-Verhaltens.
* **Integration Tests:**
    * Starten des NovaDE-Compositors.
    * Öffnen, Schließen, Verschieben, Größenändern und Minimieren/Maximieren von Testfenstern.
    * Überprüfen, ob die Fenster die erwarteten Positionen und Größen einnehmen, insbesondere bei Anwendung verschiedener Tiling-Layouts.
    * Testen der Fokus-Änderungen.
    * Interaktion mit der UI-Schicht zur Änderung des Tiling-Layouts und Überprüfung des Verhaltens.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da komplexe Zustandsverwaltung, Event-Verarbeitung, Policy-Interaktion und Tiling-Logik erforderlich sind)

---

### **novade-system/src/window_mechanics/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`WindowMechanicsError`) für das `window_mechanics`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung für Fenster-Mechanik-Interaktionen sicher und ermöglicht eine präzise Fehlerweiterleitung.

**Kern-Aufgaben (Tasks):**

1.  **`WindowMechanicsError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten:
        * `CompositorError(#[from] crate::compositor::error::CompositorError)`: Fehler vom zugrunde liegenden Compositor.
        * `PolicyError(#[from] novade_domain::window_policy::error::WindowPolicyError)`: Fehler bei der Auswertung von Fenster-Richtlinien.
        * `WindowNotFound(WindowId)`: Ein angefordertes Fenster wurde nicht gefunden.
        * `LayoutError(String)`: Ein Fehler in der Tiling-Layout-Engine.
        * `ChannelError(String)`: Fehler beim Empfangen von Events vom Compositor-Channel.
        * `InvalidState(String)`: Das Modul befindet sich in einem unerwarteten Zustand.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_mechanics/error.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::error::CompositorError`
    * `novade_domain::window_policy::error::WindowPolicyError`
    * `novade-core::types::window::WindowId`
* **Extern:**
    * `thiserror::Error`

**Kommunikationsmuster:**

* Wird von allen Funktionen innerhalb des `window_mechanics`-Moduls als `Result` Fehler zurückgegeben.
* Wird von der `novade-system::SystemServices` Initialisierung abgefangen und möglicherweise in `CoreError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung im `window_mechanics`-Modul standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `WindowMechanicsError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---

### **novade-system/src/window_mechanics/tiling.rs**

**Verantwortlichkeit:**
Dieses Modul definiert das `TilingLayout`-Trait und implementiert verschiedene konkrete Tiling-Layout-Algorithmen. Es ist ein zentraler Bestandteil der Fensterverwaltung, der die automatische Anordnung von Fenstern auf einem Arbeitsbereich ermöglicht, basierend auf den vom Benutzer gewählten Layout-Strategien.

**Kern-Aufgaben (Tasks):**

1.  **`TilingLayout` Trait Definition:**
    * `pub trait TilingLayout: Send + Sync {`
    * `fn add_window(&mut self, window_id: WindowId, workspace_id: WorkspaceId);`
        * Fügt ein Fenster zum Layout hinzu. Layouts müssen intern verfolgen, welche Fenster sie verwalten.
    * `fn remove_window(&mut self, window_id: WindowId);`
        * Entfernt ein Fenster aus dem Layout.
    * `fn rearrange_windows(&self, workspace_id: WorkspaceId, output_geometry: Rectangle) -> HashMap<WindowId, Rectangle>;`
        * Die Kernfunktion: Berechnet für alle Fenster im angegebenen `workspace_id` neue Geometrien (`Rectangle`) basierend auf dem `output_geometry` und dem Layout-Algorithmus.
    * `fn get_name(&self) -> &'static str;`
        * Liefert einen menschenlesbaren Namen des Layouts.
    * `}`

2.  **Implementierung des `StackLayout`:**
    * Struktur: `StackLayout { windows: Vec<WindowId> }` (Liste der Fenster in Reihenfolge).
    * `add_window`: Fügt Fenster einfach am Ende der Liste hinzu.
    * `remove_window`: Entfernt Fenster aus der Liste.
    * `rearrange_windows`: Alle Fenster werden übereinander gestapelt, vielleicht mit einem kleinen Offset, oder nur das oberste Fenster ist sichtbar.
    * `get_name`: "Stack"

3.  **Implementierung des `ColumnsLayout`:**
    * Struktur: `ColumnsLayout { master_window: Option<WindowId>, stack_windows: Vec<WindowId>, master_ratio: f64 }`
    * `add_window`: Fügt Fenster hinzu, erster Fenster wird Master, andere Stack.
    * `remove_window`: Entfernt Fenster, passt Master/Stack an.
    * `rearrange_windows`:
        * Teilt `output_geometry` in zwei Bereiche: Master-Bereich (links) und Stack-Bereich (rechts).
        * Master-Fenster nimmt den Master-Bereich ein.
        * Stack-Fenster teilen den Stack-Bereich vertikal oder horizontal auf.
    * `get_name`: "Columns"

4.  **Implementierung des `MonocleLayout`:**
    * Struktur: `MonocleLayout { windows: Vec<WindowId>, current_index: usize }`
    * `add_window`: Fügt Fenster hinzu.
    * `remove_window`: Entfernt Fenster, passt `current_index` an.
    * `rearrange_windows`: Nur das Fenster bei `current_index` nimmt die gesamte `output_geometry` ein. Andere Fenster sind "unsichtbar" (aber gemappt).
    * Zusätzliche Methoden (nicht Teil des Trait, aber für die Steuerung): `next_window()`, `prev_window()`.
    * `get_name`: "Monocle"

5.  **Fehlerbehandlung:** Layout-Algorithmen sollten robuste Logik enthalten, um Division by Zero oder ungültige Geometrien zu vermeiden. Fehler sollten als `WindowMechanicsError::LayoutError` zurückgegeben werden.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_mechanics/tiling.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::window_mechanics::error::WindowMechanicsError`
    * `novade-core::types::window::{WindowId, WorkspaceId}`
    * `novade-core::types::geometry::Rectangle`
* **Extern:**
    * `std::collections::HashMap`
    * `std::sync::Arc` (wenn Layouts Shared State halten)

**Kommunikationsmuster:**

* Wird vom `WindowMechanicsService` verwendet, um Geometrien für Fenster zu berechnen.
* Hat keine direkten externen Kommunikationen; rein logische Komponente.

**Erwartete Ergebnisse/Outputs:**
Ein Satz von robusten und effizienten Tiling-Layout-Implementierungen, die vom `WindowMechanicsService` zur dynamischen Anordnung von Fenstern genutzt werden können.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests für jedes Layout:**
    * Testen von `add_window` und `remove_window`: Verifizieren, dass die interne Fensterliste korrekt verwaltet wird.
    * Testen von `rearrange_windows` mit verschiedenen Anzahlen von Fenstern (0, 1, viele) und unterschiedlichen `output_geometry` Größen.
    * Verifizieren, dass die zurückgegebenen `Rectangle`s korrekt sind (Position, Größe).
    * Testen von Edge Cases (z.B. Fenster auf einem sehr kleinen Output, leere Fensterliste).
    * Sicherstellen, dass die Fenster nicht überlappen, wenn es das Layout vorschreibt.
    * Für `ColumnsLayout`, testen der `master_ratio` und seiner Auswirkungen.

**Geschätzter Aufwand:** Mittel (ca. 4-6 Tage pro Layout, abhängig von der Komplexität)
### **novade-ui/src/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Haupt-Einstiegspunkt und Re-Export für die gesamte `novade-ui` Crate. Es definiert die öffentliche API der UI-Schicht und organisiert alle Submodule, die die verschiedenen UI-Komponenten und Services implementieren.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod application;` (Das Haupt-GTK-Anwendungsobjekt und der Lebenszyklus)
    * `pub mod components;` (Sammelpunkt für alle wiederverwendbaren UI-Widgets und Komponenten)
    * `pub mod windows;` (Definitionen für Hauptfenster, Dialoge und Overlay-Fenster)
    * `pub mod services;` (UI-spezifische Services, die mit der Domänen- und Systemschicht kommunizieren)
    * `pub mod theming;` (Theming-Engine und CSS-Provider)
    * `pub mod settings_ui;` (UI für die Einstellungen)
    * `pub mod notifications_ui;` (UI für die Benachrichtigungsanzeige)
    * `pub mod wallpaper_ui;` (UI für die Hintergrundbildverwaltung)
    * `pub mod menu_bar;` (Implementierung der globalen Menüleiste, falls benötigt)
    * `pub mod overlays;` (Z.B. für die kontextuelle Befehlspalette, OSDs)
    * `pub mod error;` (Fehler-Enum für die UI-Schicht)

2.  **Re-Exporte (`pub use`):**
    * Re-exportiert die wichtigsten Strukturen und Funktionen, die von der `main`-Funktion oder anderen NovaDE-Komponenten benötigt werden.
    * Beispiel:
        * `pub use application::NovaApplication;`
        * `pub use error::UiError;`
        * `pub use services::{UiServices, UiServicesError};` (wenn `UiServices` als übergeordneter Orchestrator existiert)

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/mod.rs`
* `novade-ui/src/lib.rs` (könnte auch `mod.rs` sein, je nach Konvention)

**Abhängigkeiten:**

* **Intern:** Abhängig von allen Submodulen innerhalb von `novade-ui`.
* **Extern:** Keine direkten externen Abhängigkeiten in `mod.rs` selbst, nur die, die von den re-exportierten Modulen verwendet werden.

**Kommunikationsmuster:**

* Der `mod.rs` fungiert als API-Gateway für die gesamte UI-Schicht.
* Die `main`-Funktion (`novade-desktop/src/main.rs`) importiert und initialisiert die `NovaApplication` von hier.

**Erwartete Ergebnisse/Outputs:**
Ein klar definierter und organisierter Einstiegspunkt für die `novade-ui` Crate, der die modulare Struktur der Benutzeroberfläche widerspiegelt und eine einfache Integration in das NovaDE-Gesamtsystem ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte enthält.** Die Funktionalität wird in den einzelnen Submodulen getestet.

**Geschätzter Aufwand:** Gering (ca. 0.2 Tage)

---

### **novade-ui/src/error.rs**

**Verantwortlichkeit:**
Definiert das globale Fehler-Enum (`UiError`) für die gesamte `novade-ui` Crate. Dieses Enum kapselt alle möglichen Fehler, die von den verschiedenen UI-Komponenten oder Services während ihrer Initialisierung, ihres Betriebs oder der Interaktion mit unteren Schichten zurückgegeben werden können. Es bietet eine konsistente Fehlerhierarchie für die übergeordnete Anwendungslogik.

**Kern-Aufgaben (Tasks):**

1.  **`UiError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten (mit `#[from]` für automatische Konvertierung):
        * `GtkError(String)`: Allgemeine GTK-bezogene Fehler (z.B. Widget-Initialisierung, Template-Laden).
        * `GlibError(#[from] glib::Error)`: Fehler, die direkt von `glib` stammen.
        * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler (z.B. beim Laden von Assets).
        * `DomainError(#[from] novade_domain::DomainError)`: Fehler von der Domänenschicht.
        * `SystemServiceError(#[from] novade_system::SystemServiceError)`: Fehler von der Systemschicht.
        * `ConfigurationError(#[from] novade_core::config::ConfigError)`: Fehler beim Laden/Speichern von Konfigurationen.
        * `ResourceLoadingError(String)`: Fehler beim Laden von UI-Ressourcen (z.B. `blueprint` XML, CSS).
        * `InvalidState(String)`: Das UI-Modul oder Widget befindet sich in einem unerwarteten Zustand.
        * `ChannelError(String)`: Fehler bei der Kommunikation über Tokio-Channels (z.B. Empfänger geschlossen).
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler, die nicht spezifischer zugeordnet werden können.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/error.rs`

**Abhängigkeiten:**

* **Intern:**
    * `novade-domain::DomainError`
    * `novade-system::SystemServiceError`
    * `novade-core::config::ConfigError`
* **Extern:**
    * `thiserror::Error`
    * `glib::Error`
    * `std::io::Error`

**Kommunikationsmuster:**

* Wird als Rückgabetyp (`Result<(), UiError>`) von vielen Funktionen und Methoden innerhalb der `novade-ui` Crate verwendet.
* Empfängt Fehler von den tieferen Schichten (`DomainError`, `SystemServiceError`) und konvertiert sie in `UiError`, um eine einheitliche Fehlerbehandlung auf UI-Ebene zu ermöglichen.
* Fehler werden bis zur `NovaApplication` oder einer zentralen Fehlerbehandlungsroutine in der UI propagiert, wo sie dem Benutzer präsentiert werden können.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und umfassendes Fehler-Enum, das die Fehlerbehandlung auf der UI-Schichtebene standardisiert und eine klare Diagnose von Problemen ermöglicht, um sie dem Endbenutzer zu melden.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `UiError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette, um sicherzustellen, dass die ursprüngliche Fehlerursache erhalten bleibt.
    * Simulieren von Konvertierungen von `DomainError` und `SystemServiceError`.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---

### **novade-ui/src/application.rs**

**Verantwortlichkeit:**
Dieses Modul definiert die Haupt-GTK-Anwendung (`NovaApplication`) für NovaDE. Es ist der zentrale Einstiegspunkt, der den GTK-Anwendungslebenszyklus verwaltet, die UI-Schicht initialisiert, die Verbindung zu den Domänen- und Systemschichten herstellt und grundlegende Anwendungsaktionen (z.B. Quit) handhabt.

**Kern-Aufgaben (Tasks):**

1.  **`NovaApplication` Struktur:**
    * Ist eine Wrapper-Struktur um `gtk::Application`.
    * Felder:
        * `gtk_app: gtk::Application` (Die eigentliche GTK-Anwendung).
        * `domain_services: Arc<DomainServices>` (Referenz auf die Domänenschicht-Services).
        * `system_services: Arc<SystemServices>` (Referenz auf die Systemschicht-Services).
        * `ui_services: Arc<UiServices>` (Referenz auf die UI-spezifischen Services).
        * `main_window: Option<gtk::ApplicationWindow>` (Die Hauptanwendungsfenster-Instanz).
        * `event_tx: Sender<CoreEvent>` (Optional: Ein globaler Event-Sender für UI-Events, die an untere Schichten gesendet werden).
        * `settings_window: Option<gtk::Window>` (Referenz zum Einstellungsfenster).

2.  **`NovaApplication::new()` Funktion:**
    * `pub async fn new(domain_services: Arc<DomainServices>, system_services: Arc<SystemServices>, event_tx: Sender<CoreEvent>) -> Result<Arc<Self>, UiError>`
    * Erstellt eine neue `gtk::Application` Instanz (`application_id` z.B. "org.novade.Desktop").
    * Initialisiert `UiServices` und übergibt die Referenzen zu `domain_services` und `system_services`.
    * Verbindet das `activate` Signal der `gtk_app`:
        * Dies ist der Haupt-Callback, wenn die Anwendung gestartet wird.
        * Ruft `self.on_activate()` auf.
    * Verbindet das `startup` Signal der `gtk_app`:
        * Hier können einmalige Initialisierungen vor `activate` stattfinden.
    * Verbindet das `shutdown` Signal der `gtk_app`:
        * Für Aufräumarbeiten beim Beenden der Anwendung.
    * Verbindet das `open` Signal, um Datei-Öffnungsanfragen zu handhaben.
    * Verbindet das `handle_local_options` Signal für Kommandozeilenargumente.
    * Gibt `Arc<Self>` zurück.

3.  **`NovaApplication::on_activate()` Methode:**
    * `fn on_activate(self: Arc<Self>)`
    * Wird aufgerufen, wenn die Anwendung aktiviert wird (z.B. beim Start oder wenn sie in den Vordergrund gebracht wird).
    * Wenn `main_window` noch nicht existiert:
        * Erstellt das Hauptfenster (`novade-ui::windows::main_window::MainWindow`).
        * Setzt das Hauptfenster auf der `gtk_app`.
        * Zeigt das Hauptfenster an (`main_window.present()`).
        * Startet alle UI-spezifischen Services (`ui_services.start_all_listeners()`).
    * Wenn `main_window` bereits existiert, bringt es das Fenster in den Vordergrund (`main_window.present()`).

4.  **`NovaApplication::run()` Funktion:**
    * `pub fn run(&self) -> glib::ExitCode`
    * Startet die GTK-Anwendungsschleife (`self.gtk_app.run()`).
    * Diese Funktion blockiert, bis die Anwendung beendet wird.

5.  **`NovaApplication::open_settings_window()` Methode:**
    * `pub fn open_settings_window(self: Arc<Self>) -> Result<(), UiError>`
    * Erstellt ein neues Einstellungsfenster (`novade-ui::settings_ui::SettingsWindow`) oder bringt ein bestehendes in den Vordergrund.
    * Setzt das Einstellungsfenster auf der `gtk_app`.
    * Speichert die Referenz im `settings_window`-Feld.

6.  **`NovaApplication::quit()` Methode:**
    * `pub fn quit(&self)`
    * Ruft `self.gtk_app.quit()` auf, um die Anwendung sauber zu beenden.

7.  **`NovaApplication::show_error_dialog()` Methode:**
    * `pub fn show_error_dialog(&self, error: &UiError, title: &str)`
    * Zeigt einen benutzerfreundlichen Fehlerdialog an (z.B. `gtk::AlertDialog`).
    * Extrahiert die Fehlermeldung aus dem `UiError` und präsentiert sie dem Benutzer.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/application.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::error::UiError`
    * `crate::services::{UiServices, UiServicesError}`
    * `crate::windows::main_window::MainWindow`
    * `crate::settings_ui::SettingsWindow`
    * `novade-core::types::core::CoreEvent`
    * `novade-domain::DomainServices`
    * `novade-system::SystemServices`
* **Extern:**
    * `gtk::{self, Application, ApplicationWindow, Window, gio}`
    * `glib::{self, ExitCode, MainContext}`
    * `tokio::sync::broadcast::Sender`
    * `std::sync::Arc`
    * `tracing`

**Kommunikationsmuster:**

* **Verwaltet den GTK-Anwendungslebenszyklus.**
* **Initialisiert und hält Referenzen zu `DomainServices`, `SystemServices`, `UiServices`.**
* **Interagiert mit `main_window` und `settings_window` (Erstellung, Anzeige, Fokus).**
* **Sendet Events (optional) an untere Schichten über `event_tx`.**
* **Empfängt Events von GTK-Signalen.**

**Erwartete Ergebnisse/Outputs:**
Eine funktionsfähige GTK-Anwendung, die den gesamten NovaDE-Desktop hostet, die verschiedenen Schichten miteinander verbindet und grundlegende Anwendungsmanagement-Aufgaben übernimmt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (schwierig ohne echten GTK-Kontext):**
    * Mocken von `DomainServices`, `SystemServices`, `UiServices`.
    * Testen der `new()`-Funktion: Verifizieren, dass alle Felder korrekt initialisiert und Signale verbunden werden.
    * Testen der `on_activate()`-Logik: Prüfen, ob das Hauptfenster erstellt/präsentiert wird und `UiServices` gestartet werden.
    * Testen der `quit()`-Methode.
    * Testen der `show_error_dialog()`-Logik (wenn der Dialog als GTK-Widget mockbar ist).
* **Integration Tests (mit `gtk-test` oder `xvfb`):**
    * Starten der `NovaApplication`.
    * Verifizieren, dass das Hauptfenster korrekt angezeigt wird.
    * Simulieren von Benutzeraktionen (z.B. Schließen des Fensters, Öffnen des Einstellungsfensters) und Prüfen des Verhaltens.
    * Sicherstellen, dass die Anwendung sauber beendet wird.
    * Testen der Anzeige von Fehlerdialogen bei Fehlern von unteren Schichten.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage, da es die Integration mehrerer Schichten und den GTK-Anwendungslebenszyklus umfasst)

---

### **novade-ui/src/ui_services.rs**

**Verantwortlichkeit:**
Dieses Modul ist der zentrale Orchestrator für die Initialisierung, Verwaltung und Bereitstellung aller UI-spezifischen Dienste und Komponenten innerhalb der `novade-ui` Crate. Es stellt sicher, dass alle UI-Teile korrekt miteinander verdrahtet sind und die erforderlichen Abhängigkeiten zu den Domänen- und Systemschichten erfüllt werden. Es agiert als Mittelsmann, der Events von den unteren Schichten abonniert und an die relevanten UI-Komponenten weiterleitet.

**Kern-Aufgaben (Tasks):**

1.  **`UiServices` Struktur:**
    * Felder:
        * `domain_services: Arc<DomainServices>` (Referenz auf die Domänenschicht-Services).
        * `system_services: Arc<SystemServices>` (Referenz auf die Systemschicht-Services).
        * `notification_display_service: Arc<NotificationDisplayService>` (Dienst zur Anzeige von Benachrichtigungen).
        * `settings_manager_ui: Arc<SettingsManagerUI>` (Dienst für die Verwaltung der Einstellungs-UI).
        * `wallpaper_controller_ui: Arc<WallpaperControllerUI>` (Dienst für die Verwaltung des Hintergrundbildes).
        * `panel_controller: Arc<PanelController>` (Dienst für das Haupt-Panel).
        * `desktop_switcher_controller: Arc<DesktopSwitcherController>` (Dienst für den Workspace-Switcher).
        * `command_palette_controller: Arc<CommandPaletteController>` (Dienst für die kontextuelle Befehlspalette).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>` (Liste von JoinHandles für Hintergrund-Tasks, die Events von unteren Schichten abhören).

2.  **`UiServices::new()` Funktion:**
    * `pub fn new(domain_services: Arc<DomainServices>, system_services: Arc<SystemServices>) -> Result<Arc<Self>, UiServicesError>`
    * Initialisiert die einzelnen UI-Sub-Services.
    * Beispiel-Initialisierungen:
        * `notification_display_service = NotificationDisplayService::new(domain_services.notification_rules_engine.clone(), system_services.notification_server.clone())?`
        * `settings_manager_ui = SettingsManagerUI::new(domain_services.settings_service.clone())?`
        * `wallpaper_controller_ui = WallpaperControllerUI::new(domain_services.wallpaper_manager_service.clone())?`
        * `panel_controller = PanelController::new(domain_services.app_launcher_service.clone(), system_services.network_manager_proxy.clone(), system_services.audio_management_service.clone(), system_services.power_management_service.clone())?`
        * `desktop_switcher_controller = DesktopSwitcherController::new(domain_services.workspace_manager_service.clone())?`
        * `command_palette_controller = CommandPaletteController::new(domain_services.command_palette_service.clone())?`
    * **Wichtig:** Zu diesem Zeitpunkt werden die Services nur *erstellt*, die Event-Listener werden erst später gestartet.

3.  **`UiServices::start_all_listeners()` Methode:**
    * `pub fn start_all_listeners(self: Arc<Self>)`
    * Spawnt asynchrone Tasks (`tokio::spawn`) für jeden UI-Service, der auf Events von der Domänen- oder Systemschicht lauschen muss.
    * Beispiel:
        * `let notif_service = self.notification_display_service.clone();`
        * `let mut notif_rx = self.system_services.notification_server.get_notification_receiver();`
        * `self.listeners.push(tokio::spawn(async move { notif_service.run_event_listener(notif_rx).await }));`
        * Ähnlich für `settings_manager_ui` (lauscht auf `SettingsChanged` von `SettingsService`), `wallpaper_controller_ui` (lauscht auf `WallpaperChanged` von `WallpaperManagerService`) etc.
    * Diese Tasks sollten in `glib::MainContext::spawn_local` gespawnt werden, wenn sie GTK-Widgets manipulieren, um Threading-Probleme zu vermeiden. Wenn sie nur Daten verarbeiten und dann auf den GTK-Thread dispatchen, können sie `tokio::spawn` verwenden.

4.  **`UiServices::shutdown_all_listeners()` Methode:**
    * `pub async fn shutdown_all_listeners(&mut self)`
    * Geht über die `listeners`-Liste und bricht alle laufenden Tasks ab.
    * Wartet auf deren Beendigung (`join_all`).

5.  **`UiServices` Bereitstellung von Gettern:**
    * Methoden, um Referenzen zu den einzelnen UI-Sub-Services zu erhalten, z.B. `pub fn get_notification_display_service(&self) -> Arc<NotificationDisplayService>`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/ui_services.rs`
* `novade-ui/src/ui_services/error.rs` (`UiServicesError` Enum)

**Abhängigkeiten:**

* **Intern:**
    * `crate::error::UiError`
    * `crate::ui_services::error::UiServicesError`
    * `crate::notifications_ui::service::{NotificationDisplayService, NotificationDisplayError}`
    * `crate::settings_ui::service::{SettingsManagerUI, SettingsUiError}`
    * `crate::wallpaper_ui::service::{WallpaperControllerUI, WallpaperUiError}`
    * `crate::components::panel::PanelController` (oder ähnlich)
    * `crate::components::desktop_switcher::DesktopSwitcherController`
    * `crate::overlays::command_palette::CommandPaletteController`
    * `novade-domain::DomainServices` (und alle darin enthaltenen Services)
    * `novade-system::SystemServices` (und alle darin enthaltenen Services)
* **Extern:**
    * `tokio`
    * `tokio::task::JoinHandle`
    * `std::sync::Arc`
    * `futures::future::join_all`
    * `glib::MainContext` (für GTK-Thread-Spawning)
    * `tracing`

**Kommunikationsmuster:**

* **Initialisiert alle UI-Sub-Services und injiziert deren Abhängigkeiten.**
* **Abonniert Events von `DomainServices` und `SystemServices` und leitet sie an die jeweiligen UI-Sub-Services weiter.**
* **Stellt Getter für die einzelnen UI-Sub-Services bereit, damit andere UI-Komponenten (z.B. Fenster, Widgets) mit ihnen interagieren können.**
* **Wird von `NovaApplication` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein zentraler Dienst, der die Verwaltung der gesamten UI-Logik und ihrer Interaktionen mit den unteren Schichten koordiniert, eine modulare und erweiterbare UI-Architektur ermöglicht und eine effiziente Event-Verarbeitung gewährleistet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken von `DomainServices`, `SystemServices` und allen UI-Sub-Services.
    * Testen der `new()`-Funktion: Verifizieren, dass alle Sub-Services korrekt initialisiert und die richtigen Abhängigkeiten injiziert werden.
    * Testen der `start_all_listeners()`: Verifizieren, dass die korrekten Listener-Tasks gespawnt werden und die richtigen Event-Receiver abonniert werden.
    * Testen der `shutdown_all_listeners()`: Verifizieren, dass alle Tasks abgebrochen und gejoint werden.
    * Testen der Getter-Methoden.
* **Integration Tests (mit `gtk-test` oder `xvfb`):**
    * Starten der gesamten NovaDE-Anwendung.
    * Simulieren von Events auf der Domänen- oder Systemschicht (z.B. neue Benachrichtigung, Einstellungsänderung, Batteriestatusänderung).
    * Verifizieren, dass die entsprechenden UI-Komponenten korrekt auf diese Events reagieren und ihre Darstellung aktualisieren.
    * Überprüfen, ob die Interaktionen der UI mit den unteren Schichten korrekt funktionieren (z.B. Speichern von Einstellungen, Klick auf Benachrichtigungsaktion).

**Geschätzter Aufwand:** Hoch (ca. 6-8 Tage, da es sich um eine komplexe Orchestrierung von Diensten und asynchroner Event-Verarbeitung handelt)

---

### **novade-ui/src/ui_services/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`UiServicesError`) für das `ui_services`-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung für die Initialisierung und Orchestrierung der UI-spezifischen Dienste sicher.

**Kern-Aufgaben (Tasks):**

1.  **`UiServicesError` Enum Definition:**
    * Verwende `thiserror` für die Fehlerdefinition.
    * Varianten (mit `#[from]` für automatische Konvertierung):
        * `NotificationDisplayError(#[from] crate::notifications_ui::service::NotificationDisplayError)`: Fehler vom Benachrichtigungsanzeige-Dienst.
        * `SettingsUiError(#[from] crate::settings_ui::service::SettingsUiError)`: Fehler vom Einstellungs-UI-Manager.
        * `WallpaperUiError(#[from] crate::wallpaper_ui::service::WallpaperUiError)`: Fehler vom Hintergrundbild-Controller.
        * `PanelControllerError(String)`: Fehler vom Panel-Controller.
        * `DesktopSwitcherError(String)`: Fehler vom Desktop-Switcher-Controller.
        * `CommandPaletteError(String)`: Fehler vom Command-Palette-Controller.
        * `DomainError(#[from] novade_domain::DomainError)`: Fehler von der Domänenschicht, die an dieser Stelle auftreten.
        * `SystemServiceError(#[from] novade_system::SystemServiceError)`: Fehler von der Systemschicht, die an dieser Stelle auftreten.
        * `ListenerSpawnError(String)`: Fehler beim Spawnen eines Event-Listener-Tasks.
        * `Other(String)`: Für unvorhergesehene oder allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/ui_services/error.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::notifications_ui::service::NotificationDisplayError`
    * `crate::settings_ui::service::SettingsUiError`
    * `crate::wallpaper_ui::service::WallpaperUiError`
    * `novade_domain::DomainError`
    * `novade_system::SystemServiceError`
* **Extern:**
    * `thiserror::Error`

**Kommunikationsmuster:**

* Wird von Funktionen innerhalb des `ui_services`-Moduls als `Result` Fehler zurückgegeben.
* Kapselt Fehler der initialisierten UI-Sub-Services.
* Wird an die `NovaApplication` propagiert und dort in `UiError` konvertiert.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Fehler-Enum, das die Fehlerbehandlung bei der Initialisierung der UI-Dienste standardisiert und eine klare Diagnose von Problemen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `UiServicesError` Varianten.
    * Verifizieren der korrekten Fehlermeldungen.
    * Testen der `source()`-Kette für geschachtelte Fehler.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---
### **novade-ui/src/windows/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Hauptfenster, Dialoge und Overlay-Fenster der NovaDE-Benutzeroberfläche. Es strukturiert die verschiedenen Fenstertypen und macht sie für die `NovaApplication` und andere UI-Services zugänglich.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**

      * `pub mod main_window;` (Das Haupt-Desktop-Fenster)
      * `pub mod settings_window;` (Das Fenster für die Systemeinstellungen)
      * `pub mod about_dialog;` (Ein "Über"-Dialog für die Anwendung)
      * `pub mod file_chooser_dialog;` (Ein Wrapper für den XDG Portal File Chooser)
      * `pub mod message_dialog;` (Generischer Dialog für Meldungen und Warnungen)
      * `pub mod prompt_dialog;` (Generischer Dialog für Benutzereingaben/Bestätigungen)

2.  **Re-Exporte (`pub use`):**

      * Re-exportiert die wichtigsten Fenster-Strukturen für den Zugriff von `NovaApplication` und anderen UI-Komponenten.
      * Beispiel:
          * `pub use main_window::MainWindow;`
          * `pub use settings_window::SettingsWindow;`
          * `pub use about_dialog::AboutDialog;`

**Spezifische Artefakte/Dateien:**

  * `novade-ui/src/windows/mod.rs`

**Abhängigkeiten:**

  * **Intern:** Abhängig von allen Submodulen innerhalb von `novade-ui/src/windows`.
  * **Extern:** Keine direkten externen Abhängigkeiten in `mod.rs` selbst.

**Kommunikationsmuster:**

  * Wird von der `NovaApplication` verwendet, um Haupt- und Einstellungsfenster zu erstellen und zu verwalten.
  * Wird von anderen UI-Komponenten verwendet, um spezifische Dialoge zu öffnen.

**Erwartete Ergebnisse/Outputs:**
Eine klare und organisierte Struktur für alle Fenster der UI, die eine einfache Auffindbarkeit und Instanziierung ermöglicht.

**Teststrategie (Modul-spezifisch):**

  * **Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte enthält.** Die Funktionalität wird in den einzelnen Submodulen getestet.

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

-----

### **novade-ui/src/windows/main\_window.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert das Hauptanwendungsfenster von NovaDE, das den Desktop-Hintergrund, das Panel, den Workspace-Switcher und andere Haupt-UI-Elemente beherbergt. Es ist der primäre visuelle Container für die Desktop-Umgebung.

**Kern-Aufgaben (Tasks):**

1.  **`MainWindow` Struktur:**

      * Ist ein Wrapper-Struktur um `gtk::ApplicationWindow`.
      * Felder:
          * `window: gtk::ApplicationWindow` (Die eigentliche GTK-Fensterinstanz).
          * `wallpaper_area: gtk::Picture` (Widget zur Anzeige des Hintergrundbildes).
          * `panel: crate::components::panel::Panel` (Instanz des Panel-Widgets).
          * `desktop_switcher: crate::components::desktop_switcher::DesktopSwitcher` (Instanz des Workspace-Switchers).
          * `notification_display_area: crate::notifications_ui::widgets::NotificationOverlay` (Widget zur Anzeige von Benachrichtigungen).
          * `command_palette_overlay: crate::overlays::command_palette::CommandPaletteOverlay` (Das Overlay für die Befehlspalette).
          * `ui_services: Arc<UiServices>` (Referenz auf die UI-spezifischen Services zur Interaktion).

2.  **`MainWindow::new()` Funktion:**

      * `pub fn new(application: &gtk::Application, ui_services: Arc<UiServices>) -> Result<Arc<Self>, UiError>`
      * Lädt die UI-Definition aus einer `.ui` (Blueprint)-Datei (z.B. `main_window.ui`).
      * Initialisiert die `gtk::ApplicationWindow`.
      * Holt Referenzen auf die Kind-Widgets aus dem UI-Template (z.B. `wallpaper_area`, `panel_container`).
      * Instanziiert `Panel`, `DesktopSwitcher`, `NotificationOverlay`, `CommandPaletteOverlay` und fügt sie den entsprechenden Containern im Fenster hinzu.
      * Setzt die Referenz zu `ui_services`.
      * Verbindet GTK-Signale:
          * `close_request`: Für sauberes Beenden der Anwendung.
          * `key_press_event`: Für globale Tastenkombinationen (z.B. Super+Space für Befehlspalette).
      * `set_default_size` und `set_title`.

3.  **`MainWindow::init_wallpaper_listener()` Methode:**

      * `fn init_wallpaper_listener(self: Arc<Self>)`
      * Abonniert den `wallpaper_changed_rx` Receiver vom `WallpaperControllerUI` (über `ui_services`).
      * Spawnt einen `glib::MainContext::spawn_local` Task.
      * Bei Empfang eines `WallpaperChanged` Events:
          * Aktualisiert das `wallpaper_area` (`gtk::Picture`) mit dem neuen Bild.
          * Setzt die Hintergrundfarbe, falls kein Bild vorhanden oder der Modus es erfordert.
          * Verarbeitet verschiedene `WallpaperMode`s (Stretch, Center, Zoom, Fit, Tiled).

4.  **`MainWindow::handle_key_press()` Methode:**

      * `fn handle_key_press(self: Arc<Self>, event: &gdk::EventKey) -> glib::Propagation`
      * Verarbeitet globale Tastendrücke.
      * Wenn `Super + Space` erkannt wird:
          * Ruft `command_palette_overlay.toggle_visibility()` auf.
      * Wenn andere relevante globale Shortcuts erkannt werden:
          * Leitet sie an `ui_services.command_processor_service` weiter (falls vorhanden) oder direkt an Domänen-Services.
      * Rückgabe von `glib::Propagation::Stop` bei verarbeiteten Events.

5.  **`MainWindow::present()` Methode:**

      * `pub fn present(&self)`
      * Ruft `self.window.present()` auf, um das Fenster anzuzeigen und in den Vordergrund zu bringen.

**Spezifische Artefakte/Dateien:**

  * `novade-ui/src/windows/main_window.rs`
  * `novade-ui/resources/ui/main_window.ui` (Blueprint XML für das GTK-Layout)

**Abhängigkeiten:**

  * **Intern:**
      * `crate::error::UiError`
      * `crate::ui_services::UiServices`
      * `crate::components::panel::Panel`
      * `crate::components::desktop_switcher::DesktopSwitcher`
      * `crate::notifications_ui::widgets::NotificationOverlay`
      * `crate::overlays::command_palette::CommandPaletteOverlay`
      * `novade-core::types::wallpaper::WallpaperChanged`
  * **Extern:**
      * `gtk::{self, Application, ApplicationWindow, Picture, gdk, glib}`
      * `std::sync::Arc`
      * `glib::MainContext::spawn_local`
      * `tracing`
      * `tokio::sync::broadcast::Receiver`

**Kommunikationsmuster:**

  * **Wird von `NovaApplication` instanziiert und verwaltet.**
  * **Abonniert Events von `WallpaperControllerUI` zur Aktualisierung des Hintergrundbildes.**
  * **Delegiert Ereignisse (Tastenkombinationen) an andere UI-Komponenten oder Services.**
  * **Ist der Haupt-Container für viele andere UI-Widgets.**

**Erwartete Ergebnisse/Outputs:**
Das Hauptfenster der Desktop-Umgebung, das den Desktop-Hintergrund anzeigt und alle primären UI-Komponenten hostet, reaktionsschnell auf Systemereignisse und Benutzereingaben reagiert.

**Teststrategie (Modul-spezifisch):**

  * **Unit Tests (mit Mocking):**
      * Mocken von `gtk::ApplicationWindow` und Kind-Widgets.
      * Mocken von `UiServices` und seinen Sub-Services.
      * Testen der `new()`-Funktion: Überprüfen, ob das UI-Template geladen und Widgets korrekt instanziiert werden.
      * Testen der `init_wallpaper_listener()`: Simulieren von `WallpaperChanged` Events und Verifizieren, dass die `wallpaper_area` korrekt aktualisiert wird (Mock `gtk::Picture`).
      * Testen von `handle_key_press()`: Simulieren von Tastendrücken (z.B. Super+Space) und Verifizieren, dass die korrekten Methoden auf `command_palette_overlay` aufgerufen werden.
  * **Integration Tests (mit `gtk-test` oder `xvfb`):**
      * Starten der gesamten NovaDE-Anwendung.
      * Visuelle Inspektion des Hauptfensters: Panel, Desktop-Switcher, Hintergrundbild.
      * Ändern des Hintergrundbildes über die Einstellungen und Verifizieren, dass es im Hauptfenster aktualisiert wird.
      * Drücken von globalen Tastenkombinationen und Überprüfen der Funktionalität (z.B. Öffnen/Schließen der Befehlspalette).

**Geschätzter Aufwand:** Mittel (ca. 4-6 Tage, da UI-Layout, Widget-Integration und Event-Listener-Handling)

-----

### **novade-ui/src/windows/settings\_window.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert das Einstellungsfenster von NovaDE. Es bietet eine grafische Oberfläche, um alle konfigurierbaren Optionen der Desktop-Umgebung zu verwalten, die von der Domänenschicht (`SettingsService`) bereitgestellt werden.

**Kern-Aufgaben (Tasks):**

1.  **`SettingsWindow` Struktur:**

      * Ist ein Wrapper-Struktur um `gtk::ApplicationWindow` oder `gtk::Window`.
      * Felder:
          * `window: gtk::ApplicationWindow` (Die eigentliche GTK-Fensterinstanz).
          * `settings_stack: gtk::Stack` (Der Haupt-Container für die verschiedenen Einstellungsseiten).
          * `sidebar_nav: gtk::ListBox` (Die Navigationsleiste mit den Kategorien).
          * `ui_services: Arc<UiServices>` (Referenz auf die UI-spezifischen Services).
          * `settings_service: Arc<SettingsService>` (Referenz auf den SettingsService der Domänenschicht).

2.  **`SettingsWindow::new()` Funktion:**

      * `pub fn new(application: &gtk::Application, ui_services: Arc<UiServices>) -> Result<Arc<Self>, UiError>`
      * Lädt die UI-Definition aus einer `.ui` (Blueprint)-Datei (z.B. `settings_window.ui`).
      * Initialisiert die `gtk::ApplicationWindow`.
      * Holt Referenzen auf `settings_stack` und `sidebar_nav`.
      * Setzt die Referenzen zu `ui_services` und `settings_service`.
      * **Dynamisches Laden von Einstellungsseiten:**
          * Registriert jede Einstellungsseite als separates Widget im `settings_stack`.
          * Jede Seite (z.B. `AppearanceSettingsPage`, `NetworkSettingsPage`, `PowerSettingsPage`) ist ein separates GTK-Widget (z.B. `gtk::Box` oder `gtk::Grid`) und implementiert ein `SettingsPage` Trait (siehe unten).
          * Fügt für jede Seite einen Eintrag zur `sidebar_nav` hinzu.
          * Verbindet das `row_activated` Signal der `sidebar_nav` mit der `settings_stack.set_visible_child_name()` Methode.
      * Verbindet das `close_request` Signal.
      * `set_default_size` und `set_title`.

3.  **`SettingsPage` Trait (Definiert in `novade-ui/src/settings_ui/interface.rs`):**

      * `pub trait SettingsPage: IsA<gtk::Widget> + 'static + Send + Sync {`
      * `fn new(settings_service: Arc<SettingsService>, ui_services: Arc<UiServices>) -> Self;`
      * `fn get_name(&self) -> &'static str;` (Z.B. "Appearance", "Network")
      * `fn get_icon_name(&self) -> &'static str;` (Z.B. "preferences-desktop-appearance")
      * `}`
      * Jede konkrete Einstellungsseite (z.B. `AppearanceSettingsPage`) implementiert dieses Trait.

4.  **Beispiel für Einstellungsseiten-Module:**

      * `novade-ui/src/settings_ui/pages/appearance.rs` (`AppearanceSettingsPage`): Verwaltet Theme, Akzentfarben, Icon-Theme, Font-Einstellungen. Interagiert mit `settings_service` zum Laden/Speichern und `ThemingService` zum Anwenden.
      * `novade-ui/src/settings_ui/pages/network.rs` (`NetworkSettingsPage`): Zeigt Netzwerkschnittstellen an, ermöglicht WLAN-Verbindungen. Interagiert mit `system_services.network_manager_proxy`.
      * `novade-ui/src/settings_ui/pages/power.rs` (`PowerSettingsPage`): Verwaltet Power-Management-Richtlinien. Interagiert mit `domain_services.power_policy_service`.
      * `novade-ui/src/settings_ui/pages/keyboard.rs` (`KeyboardSettingsPage`): Tastatur-Layouts, Wiederholrate. Interagiert mit `system_services.keyboard_layout_service`.

5.  **Interaktion mit `SettingsService`:**

      * Jede Einstellungsseite muss Änderungen in ihren Widgets (z.B. `gtk::Switch`, `gtk::Entry`) mit dem `settings_service` synchronisieren.
      * Beim Laden der Seite: Liest aktuelle Werte vom `settings_service`.
      * Bei Änderungen an UI-Widgets: Ruft entsprechende `settings_service.set_setting(...)` Methoden auf.
      * Kann auch `settings_service.subscribe_to_setting_changes(...)` abonnieren, um auf externe Änderungen zu reagieren (z.B. über D-Bus).

**Spezifische Artefakte/Dateien:**

  * `novade-ui/src/windows/settings_window.rs`
  * `novade-ui/resources/ui/settings_window.ui`
  * `novade-ui/src/settings_ui/interface.rs` (`SettingsPage` Trait)
  * `novade-ui/src/settings_ui/pages/mod.rs`
  * `novade-ui/src/settings_ui/pages/appearance.rs`
  * `novade-ui/src/settings_ui/pages/network.rs`
  * `novade-ui/src/settings_ui/pages/power.rs`
  * `novade-ui/src/settings_ui/pages/keyboard.rs`
  * `novade-ui/src/settings_ui/error.rs` (`SettingsUiError` Enum)
  * `novade-ui/src/settings_ui/service.rs` (`SettingsManagerUI` Orchestrator)

**Abhängigkeiten:**

  * **Intern:**
      * `crate::error::UiError`
      * `crate::ui_services::UiServices`
      * `crate::settings_ui::interface::SettingsPage`
      * `crate::settings_ui::error::SettingsUiError`
      * `novade-domain::settings::service::SettingsService`
      * `novade-domain::wallpaper_manager::service::WallpaperManagerService` (für Appearance)
      * `novade-domain::power_policy::service::PowerPolicyService` (für Power)
      * `novade-system::dbus_interfaces::network_manager::NetworkManagerProxy` (für Network)
      * `novade-system::keyboard_layout::KeyboardLayoutService` (für Keyboard)
  * **Extern:**
      * `gtk::{self, Application, ApplicationWindow, Window, Stack, ListBox, gio, glib}`
      * `std::sync::Arc`
      * `tracing`

**Kommunikationsmuster:**

  * **Wird von `NovaApplication` instanziiert und verwaltet.**
  * **Interagiert direkt mit `SettingsService` der Domänenschicht zum Lesen und Schreiben von Einstellungen.**
  * **Interagiert mit anderen Domänen- und System-Services über `UiServices` zur Anzeige und Manipulation von systembezogenen Einstellungen.**
  * **Jede Einstellungsseite ist ein unabhängiges GTK-Widget, das seine Daten vom `SettingsService` holt und an diesen zurückschreibt.**

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und benutzerfreundliches Einstellungsfenster, das eine intuitive Verwaltung aller NovaDE-Konfigurationsoptionen ermöglicht und die Änderungen persistent speichert.

**Teststrategie (Modul-spezifisch):**

  * **Unit Tests (mit Mocking):**
      * Mocken von `gtk::ApplicationWindow`, `gtk::Stack`, `gtk::ListBox` und allen `SettingsPage` Implementierungen.
      * Mocken von `UiServices` und `SettingsService`.
      * Testen der `new()`-Funktion: Verifizieren, dass das UI-Template geladen, Seiten korrekt hinzugefügt und Navigation verbunden wird.
      * Testen der `SettingsPage` Trait-Implementierungen für jede Seite:
          * Testen der Initialisierung (`new`) und ob sie korrekte Namen/Icons zurückgeben.
          * Testen, dass Widgets die Werte korrekt vom gemockten `SettingsService` lesen.
          * Testen, dass Änderungen an Widgets die korrekten `settings_service.set_setting()` Aufrufe triggern.
  * **Integration Tests (mit `gtk-test` oder `xvfb`):**
      * Starten der gesamten NovaDE-Anwendung und Öffnen des Einstellungsfensters.
      * Navigation zwischen den Seiten und Verifizieren, dass die korrekten Inhalte angezeigt werden.
      * Ändern von Einstellungen in der UI und Überprüfen, ob die Änderungen persistent gespeichert werden (manuelles Prüfen der Konfigurationsdateien oder über API).
      * Starten der Anwendung neu und Verifizieren, dass die gespeicherten Einstellungen geladen werden.
      * Testen der Funktionalität jeder einzelnen Einstellungsseite.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da viele verschiedene Einstellungsseiten, komplexe UI-Synchronisierung und Interaktion mit mehreren Services)

-----

### **novade-ui/src/windows/about\_dialog.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert einen Standard "Über"-Dialog für die NovaDE-Anwendung. Es zeigt grundlegende Informationen über die Software an, wie Version, Lizenz, Autoren und Links zu Webseiten.

**Kern-Aufgaben (Tasks):**

1.  **`AboutDialog` Funktion/Struktur:**
      * `pub fn show_about_dialog(parent: &impl IsA<gtk::Window>)` oder `pub struct AboutDialog { ... }`
      * Verwende `gtk::AboutDialog`.
      * Setzt folgende Eigenschaften:
          * `program_name`: "NovaDE"
          * `version`: Lese die Version aus `Cargo.toml` (`env!("CARGO_PKG_VERSION")`) oder von einem `build_info` Modul.
          * `comments`: Eine kurze Beschreibung von NovaDE.
          * `copyright`: "Copyright © 2024-2025 NovaDE Developers"
          * `license_type`: `gtk::License::MitX11` (oder die tatsächliche Lizenz).
          * `website`: "[https://novade.org](https://www.google.com/search?q=https://novade.org)" (Platzhalter)
          * `website_label`: "NovaDE Website"
          * `authors`: Liste der Hauptautoren.
          * `artists`: Liste der Künstler/Designer.
          * `logo_icon_name`: "novade-logo" (oder Pfad zu einem Icon).
          * `modal`: `true`
          * `transient_for`: Der übergeordnete Fenster.
      * Verbindet das `close_request` Signal, um den Dialog zu schließen.
      * Zeigt den Dialog an (`dialog.present()`).

**Spezifische Artefakte/Dateien:**

  * `novade-ui/src/windows/about_dialog.rs`

**Abhängigkeiten:**

  * **Extern:**
      * `gtk::{self, AboutDialog, Window, IsA}`
      * `glib`

**Kommunikationsmuster:**

  * Wird von der `NovaApplication` oder anderen UI-Komponenten aufgerufen, um den Dialog anzuzeigen.
  * Keine komplexen internen Abhängigkeiten oder Event-Verarbeitung.

**Erwartete Ergebnisse/Outputs:**
Ein standardisierter und informativer "Über"-Dialog, der die notwendigen Informationen über die NovaDE-Anwendung präsentiert.

**Teststrategie (Modul-spezifisch):**

  * **Unit Tests (mit Mocking):**
      * Mocken von `gtk::AboutDialog`.
      * Testen, dass alle Eigenschaften korrekt gesetzt werden.
  * **Integration Tests (mit `gtk-test` oder `xvfb`):**
      * Starten der Anwendung und Aufrufen des "Über"-Dialogs über ein Menü oder Shortcut.
      * Visuelle Inspektion, dass der Dialog korrekt angezeigt wird und die Informationen stimmen.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

-----
### **novade-ui/src/windows/file_chooser_dialog.rs**

**Verantwortlichkeit:**
Dieses Modul bietet eine Abstraktion für den plattformunabhängigen Dateiauswahldialog unter Verwendung der XDG Desktop Portals. Es gewährleistet, dass NovaDE den nativen Dateimanager des Benutzers für Dateiauswahloperationen nutzt, was die Konsistenz der Benutzererfahrung verbessert und Sicherheitsvorteile bietet.

**Kern-Aufgaben (Tasks):**

1.  **`FileChooserDialog` Struktur (optional, kann auch als freie Funktion implementiert werden):**
    * Wenn als Struktur: `struct FileChooserDialog;`
    * Hat keine eigenen Felder, da es eine Wrapper-Funktion für das Portal ist.

2.  **`FileChooserOptions` Struktur:**
    * `pub struct FileChooserOptions {`
    * `pub title: Option<String>,`
    * `pub modal: bool,`
    * `pub accept_label: Option<String>,`
    * `pub multiple: bool,`
    * `pub directories: bool,`
    * `pub save_as: bool,` (Für Speichern-Dialog)
    * `pub current_folder: Option<PathBuf>,`
    * `pub current_file: Option<PathBuf>,` (Für Speichern-Dialog mit vorgeschlagenem Dateinamen)
    * `pub filters: Vec<FileFilter>,`
    * `}`
    * `FileFilter` (interne Struktur): `pub struct FileFilter { pub name: String, pub patterns: Vec<String> }`

3.  **`open_file_dialog()` Funktion:**
    * `pub async fn open_file_dialog(parent: &impl IsA<gtk::Window>, options: FileChooserOptions) -> Result<Vec<PathBuf>, UiError>`
    * Ruft die D-Bus-Methode für `org.freedesktop.portal.FileChooser` auf (`OpenFile` oder `SaveFile` je nach `options.save_as`).
    * Verwendet `zbus` und `PortalProxy` (von `novade-system::dbus_interfaces::xdg_portal`).
    * Konvertiert `FileChooserOptions` in die vom Portal erwarteten D-Bus-Argumente.
    * Wartet auf die Antwort vom Portal.
    * Parsen der Portal-Antwort (`Vec<String>` URLs) in `Vec<PathBuf>`.
    * Fehlerbehandlung für Portal-Fehler (`UiError::PortalError`).

4.  **`save_file_dialog()` Funktion:**
    * `pub async fn save_file_dialog(parent: &impl IsA<gtk::Window>, options: FileChooserOptions) -> Result<Option<PathBuf>, UiError>`
    * Setzt `options.save_as = true`.
    * Ruft die D-Bus-Methode `SaveFile` des `FileChooser` Portals auf.
    * Wie `open_file_dialog`, aber erwartet nur einen einzelnen Pfad.

5.  **`select_folder_dialog()` Funktion:**
    * `pub async fn select_folder_dialog(parent: &impl IsA<gtk::Window>, options: FileChooserOptions) -> Result<Vec<PathBuf>, UiError>`
    * Setzt `options.directories = true`.
    * Ruft die D-Bus-Methode `OpenFile` des `FileChooser` Portals auf, aber mit der Option für Verzeichnisse.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/windows/file_chooser_dialog.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::error::UiError`
    * `novade-system::dbus_interfaces::xdg_portal::FileChooserPortal` (und zugehörige Proxies)
* **Extern:**
    * `gtk::{self, Window, IsA}`
    * `zbus`
    * `std::path::PathBuf`
    * `url::Url`
    * `tracing`

**Kommunikationsmuster:**

* Wird von der UI-Schicht aufgerufen, wenn eine Datei- oder Verzeichnisinteraktion erforderlich ist.
* Kommuniziert direkt mit der Systemschicht, die den D-Bus-Aufruf zum XDG Portal sendet.
* Asynchrone Operationen aufgrund der D-Bus-Kommunikation.

**Erwartete Ergebnisse/Outputs:**
Funktionale Dateiauswahldialoge, die die nativen Portal-Implementierungen des Systems nutzen und eine sichere und konsistente Benutzererfahrung bieten.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `FileChooserPortal` D-Bus-Proxys.
    * Testen, dass die `options` korrekt in D-Bus-Argumente umgewandelt werden.
    * Testen des Parsens der Portal-Antwort in `PathBuf`.
    * Simulieren von Erfolgsfällen (einzelne/mehrere Dateien, Ordner).
    * Simulieren von Abbruchfällen (Benutzer bricht Dialog ab).
    * Simulieren von Portal-Fehlern und Verifizieren der korrekten Fehlerbehandlung.
* **Integration Tests (auf einem System mit XDG Portals):**
    * Starten der Anwendung und Aufrufen des Dateiauswahldialogs.
    * Manuelle Auswahl von Dateien/Ordnern und Verifizieren, dass die korrekten Pfade zurückgegeben werden.
    * Testen des Speichern-Dialogs: Eingabe eines Dateinamens und Speichern an einem Ort.
    * Testen von Filtern.

**Geschätzter Aufwand:** Mittel (ca. 3-4 Tage, da D-Bus-Interaktion und Portal-Spezifikation)

---

### **novade-ui/src/windows/message_dialog.rs**

**Verantwortlichkeit:**
Dieses Modul bietet eine einfache API zum Anzeigen generischer Informations-, Warn- oder Fehlerdialoge für den Benutzer. Es kapselt die Komplexität der GTK-Dialogerstellung und stellt eine konsistente Darstellung von Nachrichten sicher.

**Kern-Aufgaben (Tasks):**

1.  **`MessageType` Enum:**
    * `pub enum MessageType { Info, Warning, Error, Question }`

2.  **`show_message_dialog()` Funktion:**
    * `pub fn show_message_dialog(parent: Option<&impl IsA<gtk::Window>>, message_type: MessageType, title: &str, text: &str)`
    * Erstellt eine `gtk::AlertDialog` Instanz.
    * Setzt `message_type` auf Basis des Enums (z.B. `gtk::MessageType::Info`).
    * Setzt `heading` auf den `title`.
    * Setzt `body` auf den `text`.
    * Ruft `dialog.show()` auf, um den Dialog anzuzeigen.
    * Setzt `modal` auf `true`.
    * Setzt `transient_for` auf das `parent` Fenster, falls vorhanden.

3.  **`show_error_dialog()` Funktion (Wrapper):**
    * `pub fn show_error_dialog(parent: Option<&impl IsA<gtk::Window>>, title: &str, error_text: &str)`
    * Interner Aufruf von `show_message_dialog` mit `MessageType::Error`.

4.  **`show_info_dialog()` Funktion (Wrapper):**
    * `pub fn show_info_dialog(parent: Option<&impl IsA<gtk::Window>>, title: &str, info_text: &str)`
    * Interner Aufruf von `show_message_dialog` mit `MessageType::Info`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/windows/message_dialog.rs`

**Abhängigkeiten:**

* **Extern:**
    * `gtk::{self, AlertDialog, Window, IsA, glib}`

**Kommunikationsmuster:**

* Wird von der gesamten UI-Schicht (und potenziell von `NovaApplication` für globale Fehler) aufgerufen, um Meldungen anzuzeigen.
* Blockiert die aufrufende UI nicht, da `AlertDialog` asynchron ist.

**Erwartete Ergebnisse/Outputs:**
Einfache, aber konsistente Dialoge zur Anzeige von Meldungen an den Benutzer, ohne dass jeder Aufrufer die GTK-spezifischen Details kennen muss.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `gtk::AlertDialog`.
    * Testen, dass bei verschiedenen `MessageType`s die korrekten `gtk::MessageType`s und Texte gesetzt werden.
    * Testen, dass `parent` und `modal` korrekt angewendet werden.
* **Integration Tests (mit `gtk-test` oder `xvfb`):**
    * Starten der Anwendung.
    * Auslösen von Events, die einen Dialog anzeigen sollten (z.B. ein fehlerhafter Speichervorgang).
    * Visuelle Inspektion, dass der Dialog korrekt erscheint, den richtigen Text hat und sich schließen lässt.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---

### **novade-ui/src/windows/prompt_dialog.rs**

**Verantwortlichkeit:**
Dieses Modul bietet eine generische Möglichkeit, vom Benutzer eine einfache Bestätigung (Ja/Nein, OK/Abbrechen) oder eine Texteingabe anzufordern. Es kapselt die Logik für interaktive Dialoge.

**Kern-Aufgaben (Tasks):**

1.  **`PromptType` Enum:**
    * `pub enum PromptType { Confirmation, TextInput }`

2.  **`show_confirmation_dialog()` Funktion:**
    * `pub async fn show_confirmation_dialog(parent: Option<&impl IsA<gtk::Window>>, title: &str, text: &str, ok_label: &str, cancel_label: &str) -> Result<bool, UiError>`
    * Erstellt eine `gtk::AlertDialog` Instanz mit `gtk::MessageType::Question`.
    * Setzt `heading`, `body`.
    * Fügt zwei Buttons hinzu: einen für `ok_label` und einen für `cancel_label`.
    * Wartet auf die Benutzereingabe (`dialog.choose()`).
    * Gibt `true` für "OK" (oder ähnliche Bestätigung) und `false` für "Abbrechen" zurück.

3.  **`show_text_input_dialog()` Funktion:**
    * `pub async fn show_text_input_dialog(parent: Option<&impl IsA<gtk::Window>>, title: &str, prompt: &str, initial_value: Option<&str>, ok_label: &str, cancel_label: &str) -> Result<Option<String>, UiError>`
    * Erstellt eine `gtk::AlertDialog` Instanz (oder `gtk::Dialog` mit benutzerdefiniertem Inhalt).
    * Fügt ein `gtk::Entry` Widget in den Dialogbereich ein.
    * Setzt den `prompt` Text.
    * Setzt `initial_value` für das `gtk::Entry`.
    * Fügt "OK" und "Abbrechen" Buttons hinzu.
    * Wartet auf die Benutzereingabe.
    * Gibt `Some(String)` mit dem eingegebenen Text oder `None` zurück, wenn der Benutzer abbricht.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/windows/prompt_dialog.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::error::UiError`
* **Extern:**
    * `gtk::{self, AlertDialog, Dialog, Entry, Label, Window, IsA, glib}`

**Kommunikationsmuster:**

* Wird von UI-Komponenten aufgerufen, die eine Benutzereingabe oder Bestätigung benötigen (z.B. "Möchten Sie wirklich löschen?", "Geben Sie Ihren Namen ein").
* Blockiert die aufrufende UI-Logik asynchron, bis der Dialog geschlossen wird.

**Erwartete Ergebnisse/Outputs:**
Funktionale Dialoge zur Interaktion mit dem Benutzer, die es ermöglichen, Bestätigungen einzuholen oder Texteingaben zu erfassen, mit einer konsistenten UI/UX.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `gtk::AlertDialog` oder `gtk::Dialog`.
    * Testen, dass die Dialoge mit den korrekten Texten und Buttons initialisiert werden.
    * Simulieren von Button-Klicks und Verifizieren, dass die korrekten Ergebnisse zurückgegeben werden (z.B. `true` für OK, `None` für Abbrechen).
    * Für Texteingabe: Simulieren der Texteingabe in das `gtk::Entry` und Verifizieren des zurückgegebenen Wertes.
* **Integration Tests (mit `gtk-test` oder `xvfb`):**
    * Starten der Anwendung.
    * Auslösen von Aktionen, die einen Prompt-Dialog anzeigen (z.B. Löschbestätigung).
    * Manuelle Interaktion mit dem Dialog und Verifizieren, dass das Ergebnis in der Anwendung korrekt verarbeitet wird.

**Geschätzter Aufwand:** Gering (ca. 1-2 Tage)

---
### **novade-ui/src/components/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle wiederverwendbaren UI-Widgets und Komponenten, die in der NovaDE-Desktop-Umgebung verwendet werden. Es fördert die Wiederverwendbarkeit und eine konsistente UI/UX.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod panel;` (Das Haupt-Panel am oberen/unteren Bildschirmrand)
    * `pub mod desktop_switcher;` (Widget zum Wechseln der Workspaces)
    * `pub mod app_launcher;` (Widget für den Anwendungsstarter/Menü)
    * `pub mod notification_indicator;` (Kleines Panel-Widget für Benachrichtigungszähler)
    * `pub mod battery_indicator;` (Panel-Widget für den Batteriestatus)
    * `pub mod network_indicator;` (Panel-Widget für den Netzwerkstatus)
    * `pub mod volume_indicator;` (Panel-Widget für die Lautstärkeregelung)
    * `pub mod clock_widget;` (Panel-Widget für Uhrzeit und Datum)
    * `pub mod search_bar;` (Generische Suchleiste)
    * `pub mod toggle_switch;` (Angepasster GTK-Switch)
    * `pub mod color_picker;` (Widget zur Farbauswahl)
    * `pub mod icon_viewer;` (Widget zur Anzeige von Icons)
    * `pub mod window_list_taskbar;` (Widget zur Anzeige offener Fenster auf dem Panel)
    * `pub mod system_tray;` (Implementierung für System Tray Icons / StatusNotifier)
    * `pub mod control_center_indicator;` (Indikator zum Öffnen des Control Centers)

2.  **Re-Exporte (`pub use`):**
    * Re-exportiert die wichtigsten Komponenten-Strukturen für den Zugriff von `MainWindow` und anderen UI-Modulen.
    * Beispiel:
        * `pub use panel::Panel;`
        * `pub use desktop_switcher::DesktopSwitcher;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/mod.rs`

**Abhängigkeiten:**

* **Intern:** Abhängig von allen Submodulen innerhalb von `novade-ui/src/components`.
* **Extern:** Keine direkten externen Abhängigkeiten in `mod.rs` selbst.

**Kommunikationsmuster:**

* Wird von `MainWindow` und anderen Fenstern verwendet, um die UI aus einzelnen Komponenten zusammenzusetzen.

**Erwartete Ergebnisse/Outputs:**
Ein gut organisierter Satz von wiederverwendbaren UI-Komponenten, die die modulare Entwicklung der NovaDE-Benutzeroberfläche unterstützen.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich, da es nur Re-Exporte enthält.** Die Funktionalität wird in den einzelnen Submodulen getestet.

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/panel/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die das Haupt-Panel von NovaDE bilden. Es organisiert die verschiedenen Panel-Widgets und deren Controller.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod panel_widget;` (Die Haupt-GTK-Box, die das Panel darstellt)
    * `pub mod controller;` (Der Controller, der die Logik für das Panel und seine Widgets verwaltet)
    * `pub mod error;` (Fehler-Enum für das Panel-Modul)

2.  **Re-Exporte (`pub use`):**
    * Re-exportiert die Haupt-`Panel` Struktur und den `PanelController`.
    * Beispiel:
        * `pub use panel_widget::Panel;`
        * `pub use controller::PanelController;`
        * `pub use error::PanelError;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/panel/mod.rs`

**Abhängigkeiten:**

* **Intern:** Abhängig von allen Submodulen innerhalb von `novade-ui/src/components/panel`.
* **Extern:** Keine direkten externen Abhängigkeiten in `mod.rs` selbst.

**Kommunikationsmuster:**

* Wird von `MainWindow` verwendet, um das Panel zu instanziieren.
* `UiServices` initialisiert den `PanelController`.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für das Panel, die seine Implementierung und Integration erleichtert.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/panel/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`PanelError`) für das Panel-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung für die Panel-Komponenten sicher.

**Kern-Aufgaben (Tasks):**

1.  **`PanelError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `CommunicationError(String)`: Fehler bei der Kanal-Kommunikation.
        * `DomainServiceError(#[from] novade_domain::DomainError)`: Fehler von der Domänenschicht.
        * `SystemServiceError(#[from] novade_system::SystemServiceError)`: Fehler von der Systemschicht.
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/panel/error.rs`

**Abhängigkeiten:**

* **Intern:**
    * `novade-domain::DomainError`
    * `novade_system::SystemServiceError`
* **Extern:**
    * `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `panel`-Moduls zurückgegeben.
* Wird an `UiServicesError` propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für das Panel, das eine präzise Fehlerdiagnose ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `PanelError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/panel/panel_widget.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert das Haupt-GTK-Widget für das NovaDE-Panel. Es ist ein `gtk::Box` (oder `gtk::CenterBox`), das die verschiedenen Panel-Widgets (Uhr, System-Tray, etc.) horizontal anordnet. Es ist primär ein Layout-Container und delegiert die Logik an den `PanelController`.

**Kern-Aufgaben (Tasks):**

1.  **`Panel` Struktur:**
    * Ist ein Wrapper-Struktur um `gtk::Widget` (oder `gtk::Box`).
    * Felder:
        * `container: gtk::Box` (Das Haupt-GTK-Box-Widget).
        * `left_box: gtk::Box`, `center_box: gtk::Box`, `right_box: gtk::Box` (Für flexible Anordnung).
        * `app_launcher: crate::components::app_launcher::AppLauncherButton` (Linker Bereich).
        * `window_list: crate::components::window_list_taskbar::WindowListTaskbar` (Zentraler Bereich).
        * `clock_widget: crate::components::clock_widget::ClockWidget` (Rechter Bereich).
        * `notification_indicator: crate::components::notification_indicator::NotificationIndicator` (Rechter Bereich).
        * `battery_indicator: crate::components::battery_indicator::BatteryIndicator` (Rechter Bereich).
        * `network_indicator: crate::components::network_indicator::NetworkIndicator` (Rechter Bereich).
        * `volume_indicator: crate::components::volume_indicator::VolumeIndicator` (Rechter Bereich).
        * `system_tray: crate::components::system_tray::SystemTray` (Rechter Bereich).
        * `control_center_indicator: crate::components::control_center_indicator::ControlCenterIndicator` (Rechter Bereich).

2.  **`Panel::new()` Funktion:**
    * `pub fn new(ui_services: Arc<UiServices>) -> Result<Self, PanelError>`
    * Lädt die UI-Definition aus einer `.ui` (Blueprint)-Datei (z.B. `panel.ui`).
    * Initialisiert die `gtk::Box`.
    * Holt Referenzen auf die Container-Boxen (`left_box`, `center_box`, `right_box`).
    * Instanziiert die einzelnen Panel-Widgets (z.B. `AppLauncherButton::new()`, `ClockWidget::new()`) und fügt sie den entsprechenden Boxen hinzu.
    * Übergibt die `ui_services` (oder spezifische Sub-Services) an die Panel-Widgets, damit diese mit der Domänen- und Systemschicht interagieren können.
    * Setzt CSS-Klassen für Theming (z.B. "nova-panel").

3.  **`Panel::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`
    * Gibt eine Referenz auf das Haupt-GTK-Widget (`self.container`) zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/panel/panel_widget.rs`
* `novade-ui/resources/ui/panel.ui` (Blueprint XML für das Panel-Layout)

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::panel::error::PanelError`
    * `crate::components::app_launcher::AppLauncherButton`
    * `crate::components::window_list_taskbar::WindowListTaskbar`
    * `crate::components::clock_widget::ClockWidget`
    * `crate::components::notification_indicator::NotificationIndicator`
    * `crate::components::battery_indicator::BatteryIndicator`
    * `crate::components::network_indicator::NetworkIndicator`
    * `crate::components::volume_indicator::VolumeIndicator`
    * `crate::components::system_tray::SystemTray`
    * `crate::components::control_center_indicator::ControlCenterIndicator`
    * `crate::ui_services::UiServices`
* **Extern:**
    * `gtk::{self, prelude::*, Box, CenterBox, Widget, glib}`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Wird von `MainWindow` instanziiert und im Hauptfenster platziert.
* Hält Referenzen zu seinen Kind-Widgets.
* Seine Kind-Widgets interagieren mit den `UiServices` oder direkt mit Domänen-/System-Services.

**Erwartete Ergebnisse/Outputs:**
Ein voll funktionsfähiges, visuell ansprechendes Panel, das alle erforderlichen Indikatoren und Startpunkte für Anwendungen und Systemfunktionen enthält.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `gtk::Box` und Kind-Widgets.
    * Mocken von `UiServices`.
    * Testen der `new()`-Funktion: Verifizieren, dass das UI-Template geladen, alle erwarteten Kind-Widgets instanziiert und korrekt in den Boxen platziert werden.
    * Testen der `get_widget()`-Methode.
* **Integration Tests (mit `gtk-test` oder `xvfb`):**
    * Starten der gesamten NovaDE-Anwendung.
    * Visuelle Inspektion des Panels: Sind alle Widgets sichtbar und korrekt positioniert?
    * Überprüfen, ob die Widgets auf ihre Daten reagieren (z.B. Uhrzeit, Batteriestatus).

**Geschätzter Aufwand:** Mittel (ca. 3-5 Tage, da viele Sub-Widgets integriert werden müssen)

---

### **novade-ui/src/components/panel/controller.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert den `PanelController`, der die logische Steuerung und Koordination des NovaDE-Panels und seiner integrierten Widgets übernimmt. Er abonniert Events von den Domänen- und Systemschichten und aktualisiert die Panel-Widgets entsprechend.

**Kern-Aufgaben (Tasks):**

1.  **`PanelController` Struktur:**
    * Felder:
        * `app_launcher_service: Arc<AppLauncherService>`
        * `network_manager_proxy: Arc<NetworkManagerProxy>`
        * `audio_management_service: Arc<AudioManagementService>`
        * `power_management_service: Arc<PowerManagementService>`
        * `notification_rules_engine: Arc<NotificationRulesEngine>`
        * `panel_widget: Arc<Panel>` (Referenz auf das GTK-Widget selbst)
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>` (Für Event-Listener).

2.  **`PanelController::new()` Funktion:**
    * `pub fn new(app_launcher_service: Arc<AppLauncherService>, network_manager_proxy: Arc<NetworkManagerProxy>, audio_management_service: Arc<AudioManagementService>, power_management_service: Arc<PowerManagementService>, notification_rules_engine: Arc<NotificationRulesEngine>) -> Result<Arc<Self>, PanelError>`
    * Speichert die Referenzen zu den Domänen- und System-Services.
    * Erstellt eine Instanz des `Panel` GTK-Widgets und speichert sie als `panel_widget`.
    * **Wichtig:** Initialisiert hier noch keine Event-Listener. Dies geschieht in `start_listeners()`.

3.  **`PanelController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt asynchrone Tasks (`glib::MainContext::spawn_local`) für jeden Event-Listener, der die Panel-Widgets aktualisiert.
    * **Beispiele für Listener-Tasks:**
        * **Netzwerkstatus:**
            * `let network_indicator = self.panel_widget.network_indicator.clone();`
            * `let mut network_rx = self.network_manager_proxy.subscribe_to_network_status_changes();`
            * `self.listeners.push(glib::MainContext::spawn_local(async move { ... update network_indicator ... }));`
        * **Batteriestatus:**
            * `let battery_indicator = self.panel_widget.battery_indicator.clone();`
            * `let mut battery_rx = self.power_management_service.subscribe_to_power_status_changes();`
            * `self.listeners.push(glib::MainContext::spawn_local(async move { ... update battery_indicator ... }));`
        * **Audio-Lautstärke:**
            * `let volume_indicator = self.panel_widget.volume_indicator.clone();`
            * `let mut volume_rx = self.audio_management_service.subscribe_to_volume_changes();`
            * `self.listeners.push(glib::MainContext::spawn_local(async move { ... update volume_indicator ... }));`
        * **Benachrichtigungszähler:**
            * `let notification_indicator = self.panel_widget.notification_indicator.clone();`
            * `let mut notification_rx = self.notification_rules_engine.subscribe_to_unread_count_changes();` (oder ähnlich)
            * `self.listeners.push(glib::MainContext::spawn_local(async move { ... update notification_indicator ... }));`
        * **Fensterliste (WindowListTaskbar):**
            * `let window_list_taskbar = self.panel_widget.window_list.clone();`
            * `let mut window_manager_rx = self.app_launcher_service.get_window_manager_event_receiver();` (simuliert)
            * `self.listeners.push(glib::MainContext::spawn_local(async move { ... update window_list_taskbar ... }));`
        * **Uhrzeit:** Der `ClockWidget` kann seine eigene `glib::timeout_add_seconds_local` Schleife haben oder hier vom Controller mit einem Tick-Event versorgt werden, wenn eine zentrale Uhrzeitverwaltung gewünscht ist.

4.  **`PanelController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

5.  **`PanelController::get_panel_widget()` Methode:**
    * `pub fn get_panel_widget(&self) -> Arc<Panel>`
    * Gibt die Referenz auf das Panel-Widget zurück, um es in `MainWindow` zu platzieren.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/panel/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::panel::panel_widget::Panel`
    * `crate::components::panel::error::PanelError`
    * `novade-domain::app_launcher::service::AppLauncherService`
    * `novade_domain::notification_rules::engine::NotificationRulesEngine`
    * `novade_system::dbus_interfaces::network_manager::NetworkManagerProxy`
    * `novade_system::audio_management::service::AudioManagementService`
    * `novade_system::power_management::service::PowerManagementService`
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`

**Kommunikationsmuster:**

* **Initialisiert und verwaltet das `Panel` GTK-Widget.**
* **Abonniert Events von den entsprechenden Domänen- und System-Services.**
* **Aktualisiert die Zustände der einzelnen Panel-Widgets auf Basis empfangener Events.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein dynamisches Panel, dessen Inhalte sich in Echtzeit an Änderungen im System und der Domäne anpassen, wie Netzwerkstatus, Batteriestatus, Benachrichtigungszähler usw.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken aller abhängigen Domänen- und System-Services, um `tokio::sync::broadcast::Sender` zu kontrollieren.
    * Mocken des `Panel` Widgets, um die Aufrufe an seine Kind-Widgets zu verifizieren.
    * Testen der `new()`-Funktion: Verifizieren, dass Services und Panel-Widget korrekt gespeichert werden.
    * Testen der `start_listeners()`: Verifizieren, dass die korrekten Tasks gespawnt werden und die richtigen Event-Receiver abonniert werden. Simulieren von Event-Sendungen und prüfen, ob die Mock-Methoden der Panel-Widgets aufgerufen werden.
    * Testen der `shutdown_listeners()`: Verifizieren, dass Tasks abgebrochen werden.
* **Integration Tests (mit `gtk-test` oder `xvfb`):**
    * Starten der gesamten NovaDE-Anwendung.
    * Simulieren von Systemereignissen (z.B. Netzwerk trennen, Batteriestand ändern) über D-Bus-Mocks oder System-Spies.
    * Visuelle Inspektion, ob die Panel-Indikatoren korrekt aktualisiert werden.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage, da komplexe Event-Verarbeitung, Spawning von Tasks und Interaktion mit vielen Sub-Widgets)

---
### **novade-ui/src/components/desktop_switcher/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die den Workspace-Switcher von NovaDE bilden. Es organisiert das Haupt-Widget und seinen Controller.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod desktop_switcher_widget;` (Das Haupt-GTK-Widget für den Workspace-Switcher)
    * `pub mod controller;` (Der Controller, der die Logik für den Workspace-Switcher verwaltet)
    * `pub mod error;` (Fehler-Enum für das Desktop-Switcher-Modul)

2.  **Re-Exporte (`pub use`):**
    * Re-exportiert die Haupt-`DesktopSwitcher` Struktur und den `DesktopSwitcherController`.
    * Beispiel:
        * `pub use desktop_switcher_widget::DesktopSwitcher;`
        * `pub use controller::DesktopSwitcherController;`
        * `pub use error::DesktopSwitcherError;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/desktop_switcher/mod.rs`

**Abhängigkeiten:**

* **Intern:** Abhängig von allen Submodulen innerhalb von `novade-ui/src/components/desktop_switcher`.
* **Extern:** Keine direkten externen Abhängigkeiten in `mod.rs` selbst.

**Kommunikationsmuster:**

* Wird von `MainWindow` verwendet, um den Workspace-Switcher zu instanziieren.
* `UiServices` initialisiert den `DesktopSwitcherController`.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für den Workspace-Switcher, die seine Implementierung und Integration erleichtert.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/desktop_switcher/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`DesktopSwitcherError`) für das Desktop-Switcher-Modul. Dies stellt eine konsistente und detaillierte Fehlerbehandlung sicher.

**Kern-Aufgaben (Tasks):**

1.  **`DesktopSwitcherError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `CommunicationError(String)`: Fehler bei der Kanal-Kommunikation.
        * `DomainServiceError(#[from] novade_domain::DomainError)`: Fehler von der Domänenschicht.
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/desktop_switcher/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_domain::DomainError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `desktop_switcher`-Moduls zurückgegeben.
* Wird an `UiServicesError` propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für den Workspace-Switcher, das eine präzise Fehlerdiagnose ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `DesktopSwitcherError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/desktop_switcher/desktop_switcher_widget.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert das Haupt-GTK-Widget für den Workspace-Switcher von NovaDE. Es visualisiert die vorhandenen Workspaces und den aktuell aktiven Workspace und ermöglicht die Navigation zwischen ihnen.

**Kern-Aufgaben (Tasks):**

1.  **`DesktopSwitcher` Struktur:**
    * Ist ein Wrapper-Struktur um `gtk::Widget` (z.B. `gtk::Box` oder `gtk::StackSwitcher`).
    * Felder:
        * `container: gtk::Box` (Der Haupt-Container).
        * `workspace_buttons: Vec<gtk::Button>` (Liste der Buttons für jeden Workspace).
        * `active_workspace_idx: Rc<Cell<usize>>` (Interner Zustand des aktiven Workspace-Index).
        * `workspace_manager_service: Arc<WorkspaceManagerService>` (Referenz zum Domänen-Service).

2.  **`DesktopSwitcher::new()` Funktion:**
    * `pub fn new(workspace_manager_service: Arc<WorkspaceManagerService>) -> Result<Self, DesktopSwitcherError>`
    * Initialisiert die `gtk::Box` und speichert die `workspace_manager_service` Referenz.
    * Lädt die aktuelle Anzahl der Workspaces vom `workspace_manager_service`.
    * Erstellt für jeden Workspace einen `gtk::Button` (mit Label oder Icon).
    * Fügt die Buttons dem `container` hinzu.
    * Verbindet das `clicked` Signal jedes Buttons:
        * Bei Klick: Ruft `workspace_manager_service.switch_to_workspace(index)` auf.
    * Initialisiert den visuellen Zustand (z.B. Highlight des aktiven Workspaces).
    * Setzt CSS-Klassen für Theming (z.B. "nova-desktop-switcher").

3.  **`DesktopSwitcher::update_workspace_display()` Methode:**
    * `fn update_workspace_display(&self, active_index: usize)`
    * Aktualisiert die visuelle Darstellung der Workspace-Buttons.
    * Entfernt das "active" CSS-Klasse vom vorherigen aktiven Button.
    * Fügt die "active" CSS-Klasse zum neuen aktiven Button hinzu.
    * Aktualisiert `active_workspace_idx`.

4.  **`DesktopSwitcher::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`
    * Gibt eine Referenz auf das Haupt-GTK-Widget (`self.container`) zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/desktop_switcher/desktop_switcher_widget.rs`
* `novade-ui/resources/ui/desktop_switcher.ui` (optional, für komplexere Layouts)

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::desktop_switcher::error::DesktopSwitcherError`
    * `novade_domain::workspace_manager::service::WorkspaceManagerService`
* **Extern:**
    * `gtk::{self, prelude::*, Box, Button, glib}`
    * `std::sync::Arc`
    * `std::rc::Rc`
    * `std::cell::Cell`

**Kommunikationsmuster:**

* **Wird von `MainWindow` instanziiert.**
* **Fordert Informationen vom `WorkspaceManagerService` an.**
* **Sendet Befehle (`switch_to_workspace`) an den `WorkspaceManagerService` bei Benutzerinteraktion.**
* **Wird vom `DesktopSwitcherController` aktualisiert, wenn sich der aktive Workspace ändert.**

**Erwartete Ergebnisse/Outputs:**
Ein interaktives Widget, das die Workspaces visualisiert und die Navigation zwischen ihnen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `WorkspaceManagerService` (um `get_all_workspaces` und `switch_to_workspace` zu verifizieren).
    * Mocken von GTK-Widgets.
    * Testen der `new()`-Funktion: Überprüfen der Button-Erstellung und Signal-Verbindung.
    * Testen der `update_workspace_display()`: Verifizieren, dass CSS-Klassen korrekt gesetzt/entfernt werden.
    * Simulieren von Button-Klicks und prüfen, ob die korrekten Aufrufe an den gemockten Service erfolgen.
* **Integration Tests (mit `gtk-test` oder `xvfb`):**
    * Starten der NovaDE-Anwendung.
    * Visuelle Inspektion des Workspace-Switchers.
    * Klicken auf Workspace-Buttons und Verifizieren, dass der aktive Workspace visuell wechselt und die Fenster entsprechend neu angeordnet werden (end-to-end Test mit dem Compositor).

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---

### **novade-ui/src/components/desktop_switcher/controller.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert den `DesktopSwitcherController`, der die logische Steuerung für das `DesktopSwitcher` Widget übernimmt. Er abonniert Events vom `WorkspaceManagerService` der Domänenschicht, um Änderungen am aktiven Workspace oder an der Liste der Workspaces zu erkennen und das UI-Widget entsprechend zu aktualisieren.

**Kern-Aufgaben (Tasks):**

1.  **`DesktopSwitcherController` Struktur:**
    * Felder:
        * `workspace_manager_service: Arc<WorkspaceManagerService>`
        * `desktop_switcher_widget: Arc<DesktopSwitcher>` (Referenz auf das GTK-Widget selbst).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>` (Für Event-Listener).

2.  **`DesktopSwitcherController::new()` Funktion:**
    * `pub fn new(workspace_manager_service: Arc<WorkspaceManagerService>) -> Result<Arc<Self>, DesktopSwitcherError>`
    * Speichert die Referenz zum `workspace_manager_service`.
    * Erstellt eine Instanz des `DesktopSwitcher` GTK-Widgets und speichert sie als `desktop_switcher_widget`.
    * **Wichtig:** Initialisiert hier noch keine Event-Listener. Dies geschieht in `start_listeners()`.

3.  **`DesktopSwitcherController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt asynchrone Tasks (`glib::MainContext::spawn_local`) für jeden Event-Listener.
    * **Beispiele für Listener-Tasks:**
        * **Aktiver Workspace geändert:**
            * `let desktop_switcher = self.desktop_switcher_widget.clone();`
            * `let mut active_workspace_rx = self.workspace_manager_service.subscribe_to_active_workspace_changes();`
            * `self.listeners.push(glib::MainContext::spawn_local(async move {`
            * `while let Ok(new_active_index) = active_workspace_rx.recv().await {`
            * `desktop_switcher.update_workspace_display(new_active_index);`
            * `}`
            * `Ok(())`
            * `}));`
        * **Workspaces hinzugefügt/entfernt:**
            * `let desktop_switcher = self.desktop_switcher_widget.clone();`
            * `let mut workspace_list_rx = self.workspace_manager_service.subscribe_to_workspace_list_changes();`
            * `self.listeners.push(glib::MainContext::spawn_local(async move {`
            * `while let Ok(new_workspace_list) = workspace_list_rx.recv().await {`
            * `// Logik zum Neuerstellen/Aktualisieren der Buttons im desktop_switcher_widget`
            * `desktop_switcher.rebuild_workspace_buttons(new_workspace_list);`
            * `}`
            * `Ok(())`
            * `}));`

4.  **`DesktopSwitcherController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

5.  **`DesktopSwitcherController::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> Arc<DesktopSwitcher>`
    * Gibt die Referenz auf das `DesktopSwitcher` Widget zurück, um es in `MainWindow` zu platzieren.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/desktop_switcher/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::desktop_switcher::desktop_switcher_widget::DesktopSwitcher`
    * `crate::components::desktop_switcher::error::DesktopSwitcherError`
    * `novade_domain::workspace_manager::service::WorkspaceManagerService`
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`

**Kommunikationsmuster:**

* **Initialisiert und verwaltet das `DesktopSwitcher` GTK-Widget.**
* **Abonniert Events vom `WorkspaceManagerService` der Domänenschicht.**
* **Aktualisiert den Zustand des `DesktopSwitcher` Widgets auf Basis empfangener Events.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein dynamischer Workspace-Switcher, der den aktuellen Workspace korrekt anzeigt und auf Änderungen in der Workspace-Liste reagiert, sowie eine reaktionsschnelle Navigation ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `WorkspaceManagerService` (um `subscribe_to_active_workspace_changes` und `subscribe_to_workspace_list_changes` zu kontrollieren).
    * Mocken des `DesktopSwitcher` Widgets (um `update_workspace_display` und `rebuild_workspace_buttons` zu verifizieren).
    * Testen der `new()`-Funktion: Verifizieren, dass Services und Widget korrekt gespeichert werden.
    * Testen der `start_listeners()`: Verifizieren, dass die korrekten Tasks gespawnt werden. Simulieren von Event-Sendungen und prüfen, ob die Mock-Methoden des Widgets aufgerufen werden.
    * Testen der `shutdown_listeners()`: Verifizieren, dass Tasks abgebrochen werden.
* **Integration Tests (mit `gtk-test` oder `xvfb`):**
    * Starten der NovaDE-Anwendung.
    * Programmgesteuertes Wechseln des Workspaces über den `WorkspaceManagerService`.
    * Visuelle Inspektion, ob der Workspace-Switcher im UI korrekt den aktiven Workspace markiert.
    * Programmgesteuertes Hinzufügen/Entfernen von Workspaces und Verifizieren, dass der Switcher die Änderungen widerspiegelt.

**Geschätzter Aufwand:** Mittel (ca. 3-4 Tage)

---

### **novade-ui/src/components/app_launcher/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die den Anwendungsstarter von NovaDE bilden (z.B. ein Startmenü-Button oder ein App-Grid).

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod app_launcher_button;` (Der Button, der das App-Menü/Grid öffnet)
    * `pub mod app_launcher_menu;` (Das eigentliche Menü/Grid mit Anwendungen)
    * `pub mod controller;` (Der Controller, der die Logik für den App-Launcher verwaltet)
    * `pub mod error;` (Fehler-Enum für das App-Launcher-Modul)
    * `pub mod search_bar;` (Eine integrierte Suchleiste für Apps, falls im Menü vorhanden)
    * `pub mod app_icon;` (Ein wiederverwendbares Widget zur Anzeige von App-Icons)

2.  **Re-Exporte (`pub use`):**
    * Re-exportiert die Hauptstrukturen.
    * Beispiel:
        * `pub use app_launcher_button::AppLauncherButton;`
        * `pub use app_launcher_menu::AppLauncherMenu;`
        * `pub use controller::AppLauncherController;`
        * `pub use error::AppLauncherError;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/app_launcher/mod.rs`

**Abhängigkeiten:**

* **Intern:** Abhängig von allen Submodulen innerhalb von `novade-ui/src/components/app_launcher`.
* **Extern:** Keine direkten externen Abhängigkeiten in `mod.rs` selbst.

**Kommunikationsmuster:**

* Wird von `Panel` verwendet, um den App-Launcher-Button zu instanziieren.
* `UiServices` initialisiert den `AppLauncherController`.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für den Anwendungsstarter.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/app_launcher/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`AppLauncherError`) für das App-Launcher-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`AppLauncherError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `DomainServiceError(#[from] novade_domain::DomainError)`: Fehler von der Domänenschicht.
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/app_launcher/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_domain::DomainError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `app_launcher`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für den App-Launcher.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `AppLauncherError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/app_launcher/app_launcher_button.rs**

**Verantwortlichkeit:**
Implementiert den Panel-Button, der das Anwendungsstarter-Menü oder -Grid öffnet.

**Kern-Aufgaben (Tasks):**

1.  **`AppLauncherButton` Struktur:**
    * Ist ein Wrapper um `gtk::Button`.
    * Felder:
        * `button: gtk::Button`
        * `app_launcher_menu: Option<AppLauncherMenu>` (Die Menü-/Grid-Instanz).

2.  **`AppLauncherButton::new()` Funktion:**
    * `pub fn new(app_launcher_menu: AppLauncherMenu) -> Result<Self, AppLauncherError>`
    * Erstellt einen `gtk::Button` (mit einem Icon, z.B. "start-here" oder NovaDE-Logo).
    * Speichert die `app_launcher_menu` Instanz.
    * Verbindet das `clicked` Signal des Buttons:
        * Bei Klick: `app_launcher_menu.popup_at_widget(&self.button, gtk::Gravity::NorthWest, Some(&self.button));` oder `app_launcher_menu.toggle_visibility();`
    * Setzt CSS-Klasse "nova-app-launcher-button".

3.  **`AppLauncherButton::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/app_launcher/app_launcher_button.rs`
* `novade-ui/resources/ui/app_launcher_button.ui` (optional)

**Abhängigkeiten:**

* **Intern:** `crate::components::app_launcher::app_launcher_menu::AppLauncherMenu`, `crate::components::app_launcher::error::AppLauncherError`
* **Extern:** `gtk::{self, Button, glib, IsA, Widget, prelude::*}`

**Kommunikationsmuster:**

* Wird von `Panel` instanziiert.
* Sendet `clicked` Event an den `AppLauncherMenu` zum Öffnen/Schließen.

**Erwartete Ergebnisse/Outputs:**
Ein funktionaler Button im Panel, der das Anwendungsmenü öffnet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken von `AppLauncherMenu` (um `popup_at_widget` aufzurufen).
    * Testen der Button-Initialisierung und der Signal-Verbindung.
    * Simulieren eines Klicks und Überprüfen des `popup`-Aufrufs.
* **Integration Tests:**
    * Starten der NovaDE.
    * Klicken auf den Button im Panel und Verifizieren, dass das Menü/Grid erscheint.

**Geschätzter Aufwand:** Gering (ca. 1 Tag)

---

### **novade-ui/src/components/app_launcher/app_launcher_menu.rs**

**Verantwortlichkeit:**
Implementiert das eigentliche Anwendungsmenü oder -grid, das alle installierten Anwendungen anzeigt, kategorisiert und eine Suchfunktion bietet.

**Kern-Aufgaben (Tasks):**

1.  **`AppLauncherMenu` Struktur:**
    * Ist ein Wrapper um `gtk::Popover` oder `gtk::Window` (für Vollbild-App-Grid).
    * Felder:
        * `popover_or_window: gtk::Widget` (Abhängig vom Design: Popover für Menü, Window für Grid).
        * `search_bar: crate::components::search_bar::SearchBar` (Integrierte Suchleiste).
        * `app_flow_box: gtk::FlowBox` (Für ein App-Grid) oder `app_list_box: gtk::ListBox` (Für eine kategorisierte Liste).
        * `app_launcher_controller: Arc<AppLauncherController>`
        * `active_search_results: Rc<RefCell<Vec<ApplicationInfo>>>` (Aktuell angezeigte Suchergebnisse).

2.  **`AppLauncherMenu::new()` Funktion:**
    * `pub fn new(controller: Arc<AppLauncherController>) -> Result<Self, AppLauncherError>`
    * Lädt die UI-Definition (`app_launcher_menu.ui`).
    * Initialisiert `search_bar`.
    * Initialisiert `app_flow_box` oder `app_list_box`.
    * Speichert `app_launcher_controller`.
    * Initialisiert die vollständige Liste der Anwendungen vom `controller` (`controller.get_all_applications()`).
    * Fügt die Anwendungen als `AppIcon` Widgets zur `app_flow_box`/`app_list_box` hinzu.
    * **Verbindet Signale:**
        * `search_bar.connect_search_text_changed(...)`: Bei Eingabe in die Suchleiste: filtert die `app_flow_box`.
        * `AppIcon.connect_clicked(...)`: Bei Klick auf ein App-Icon: ruft `controller.launch_application(app_id)` auf und schließt das Menü.
        * `popover_or_window.connect_hide()`: Wenn das Menü geschlossen wird: Suchleiste leeren, Fokus zurücksetzen.
    * Setzt CSS-Klassen.

3.  **`AppLauncherMenu::populate_applications()` Methode:**
    * `fn populate_applications(&self, applications: &[ApplicationInfo])`
    * Leert den aktuellen Inhalt der `app_flow_box` oder `app_list_box`.
    * Erstellt für jede `ApplicationInfo` ein `AppIcon` Widget und fügt es hinzu.

4.  **`AppLauncherMenu::filter_applications()` Methode:**
    * `fn filter_applications(&self, search_text: &str)`
    * Ruft `controller.search_applications(search_text)` auf.
    * Aktualisiert `app_flow_box` mit den Ergebnissen.

5.  **`AppLauncherMenu::popup_at_widget()` Methode:**
    * `pub fn popup_at_widget(&self, widget: &impl IsA<gtk::Widget>, gravity: gtk::Gravity, rect: Option<&gdk::Rectangle>)`
    * Zeigt den Popover/das Fenster an einer bestimmten Position relativ zu einem Widget an.

6.  **`AppLauncherMenu::toggle_visibility()` Methode:**
    * `pub fn toggle_visibility(&self)`
    * Wechselt den Sichtbarkeitsstatus des Menüs.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/app_launcher/app_launcher_menu.rs`
* `novade-ui/resources/ui/app_launcher_menu.ui`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::app_launcher::controller::AppLauncherController`
    * `crate::components::app_launcher::error::AppLauncherError`
    * `crate::components::app_launcher::search_bar::SearchBar`
    * `crate::components::app_launcher::app_icon::AppIcon`
    * `novade_domain::app_launcher::data_types::ApplicationInfo`
* **Extern:**
    * `gtk::{self, prelude::*, Popover, Window, FlowBox, ListBox, glib, gdk, IsA}`
    * `std::sync::Arc`
    * `std::rc::Rc`
    * `std::cell::RefCell`

**Kommunikationsmuster:**

* Wird von `AppLauncherButton` zum Öffnen aufgerufen.
* Ruft `AppLauncherController` zum Abrufen und Starten von Anwendungen auf.
* Kann Events vom `AppLauncherController` abonnieren, wenn sich die Liste der installierten Anwendungen ändert (optional).

**Erwartete Ergebnisse/Outputs:**
Ein interaktives und durchsuchbares Anwendungsmenü oder -grid, das alle installierten Anwendungen anzeigt und das Starten von Anwendungen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken von `AppLauncherController` (für `get_all_applications`, `search_applications`, `launch_application`).
    * Mocken von `SearchBar` und `AppIcon`.
    * Testen der `new()`-Funktion: Initialisierung, Populating von Anwendungen, Signal-Verbindungen.
    * Testen von `filter_applications()`: Simulieren von Sucheingaben und Verifizieren, dass die `app_flow_box` korrekt aktualisiert wird.
    * Simulieren von Klicks auf `AppIcon` und Verifizieren des `launch_application`-Aufrufs.
* **Integration Tests:**
    * Starten der NovaDE.
    * Öffnen des App-Launchers.
    * Eingabe in die Suchleiste und Verifizieren der Filterung.
    * Starten einer Anwendung über das Menü.
    * Deinstallieren/Installieren einer Anwendung (simuliert) und Verifizieren, dass das Menü aktualisiert wird.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da Suchfunktion, dynamisches Laden von Anwendungen und GTK-Layout)

---

### **novade-ui/src/components/app_launcher/controller.rs**

**Verantwortlichkeit:**
Implementiert den `AppLauncherController`, der die logische Steuerung für den Anwendungsstarter übernimmt. Er interagiert mit dem `AppLauncherService` der Domänenschicht, um die Liste der Anwendungen zu verwalten und Anwendungen zu starten.

**Kern-Aufgaben (Tasks):**

1.  **`AppLauncherController` Struktur:**
    * Felder:
        * `app_launcher_service: Arc<AppLauncherService>`
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>` (Optional, für dynamische App-Listen-Updates).

2.  **`AppLauncherController::new()` Funktion:**
    * `pub fn new(app_launcher_service: Arc<AppLauncherService>) -> Result<Arc<Self>, AppLauncherError>`
    * Speichert die Referenz zum `app_launcher_service`.

3.  **`AppLauncherController::get_all_applications()` Methode:**
    * `pub async fn get_all_applications(&self) -> Result<Vec<ApplicationInfo>, AppLauncherError>`
    * Ruft `self.app_launcher_service.get_all_applications().await` auf.
    * Gibt die Liste der `ApplicationInfo` zurück.

4.  **`AppLauncherController::search_applications()` Methode:**
    * `pub async fn search_applications(&self, query: &str) -> Result<Vec<ApplicationInfo>, AppLauncherError>`
    * Ruft `self.app_launcher_service.search_applications(query).await` auf.
    * Gibt die gefilterte Liste zurück.

5.  **`AppLauncherController::launch_application()` Methode:**
    * `pub async fn launch_application(&self, app_id: &str) -> Result<(), AppLauncherError>`
    * Ruft `self.app_launcher_service.launch_application(app_id).await` auf.

6.  **`AppLauncherController::start_listeners()` Methode (Optional):**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt einen Listener für `ApplicationListChanged` Events vom `AppLauncherService`.
    * Bei Empfang: Aktualisiert die `AppLauncherMenu` (muss über `glib::MainContext::spawn_local` in den GTK-Thread dispatcht werden).

7.  **`AppLauncherController::shutdown_listeners()` Methode (Optional):**
    * `pub async fn shutdown_listeners(&mut self)`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/app_launcher/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::app_launcher::error::AppLauncherError`
    * `novade_domain::app_launcher::service::AppLauncherService`
    * `novade_domain::app_launcher::data_types::ApplicationInfo`
* **Extern:**
    * `tokio`
    * `std::sync::Arc`
    * `tracing`

**Kommunikationsmuster:**

* **Fasst die Interaktionen des App-Launchers mit der Domänenschicht zusammen.**
* **Wird von `AppLauncherMenu` aufgerufen.**
* **Wird von `UiServices` initialisiert.**

**Erwartete Ergebnisse/Outputs:**
Eine reaktionsschnelle und effiziente Verwaltung der Anwendungsstarter-Logik.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `AppLauncherService`.
    * Testen der `new()`-Funktion.
    * Testen von `get_all_applications()`, `search_applications()`, `launch_application()`: Verifizieren, dass die korrekten Methoden auf dem gemockten Service aufgerufen werden und die Ergebnisse korrekt weitergeleitet werden.
    * Testen der Listener-Logik (wenn implementiert): Simulieren von `ApplicationListChanged` und prüfen, ob die UI-Update-Callbacks getriggert werden.
* **Integration Tests:**
    * Starten der NovaDE.
    * Starten des App-Launchers.
    * Testen des Starts einer realen Anwendung über den App-Launcher.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---

### **novade-ui/src/components/app_launcher/search_bar.rs**

**Verantwortlichkeit:**
Implementiert eine generische Suchleiste (`gtk::Entry`) mit zusätzlichen Features wie Such-Icon und Clear-Button, speziell für die Verwendung im App-Launcher oder der Befehlspalette.

**Kern-Aufgaben (Tasks):**

1.  **`SearchBar` Struktur:**
    * Ist ein Wrapper um `gtk::Entry`.
    * Felder:
        * `entry: gtk::Entry`
        * `search_icon: gtk::Image` (Im linken Bereich des Entry).
        * `clear_button: gtk::Button` (Im rechten Bereich des Entry, erscheint bei Eingabe).

2.  **`SearchBar::new()` Funktion:**
    * `pub fn new() -> Self`
    * Erstellt ein `gtk::Entry`.
    * Setzt ein Such-Icon (`gtk::Entry::set_icon_from_icon_name(gtk::EntryIconPosition::Primary, ...)`).
    * Erstellt einen Clear-Button mit einem "clear" Icon.
    * Verbindet das `changed` Signal des `entry`:
        * Zeigt den Clear-Button an/aus, basierend auf dem Textinhalt.
        * Emittiert ein eigenes `search_text_changed` Signal (siehe unten).
    * Verbindet das `clicked` Signal des `clear_button`:
        * Löscht den Text im `entry`.
        * Versteckt den Clear-Button.
    * Setzt Placeholder-Text (z.B. "Suche Anwendungen...").
    * Setzt CSS-Klasse "nova-search-bar".

3.  **`SearchBar::connect_search_text_changed()` Methode:**
    * `pub fn connect_search_text_changed<F: Fn(&Self, String) + 'static>(&self, f: F)`
    * Eine Wrapper-Methode, um das `changed` Signal des internen `gtk::Entry` zu abonnieren, aber mit der Möglichkeit, den Text direkt zu erhalten.

4.  **`SearchBar::get_text()` Methode:**
    * `pub fn get_text(&self) -> String`
    * Gibt den aktuellen Text des `entry` zurück.

5.  **`SearchBar::set_text()` Methode:**
    * `pub fn set_text(&self, text: &str)`
    * Setzt den Text des `entry`.

6.  **`SearchBar::grab_focus()` Methode:**
    * `pub fn grab_focus(&self)`
    * Setzt den Tastaturfokus auf die Suchleiste.

7.  **`SearchBar::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/app_launcher/search_bar.rs`

**Abhängigkeiten:**

* **Extern:** `gtk::{self, prelude::*, Entry, Button, Image, glib, Widget}`

**Kommunikationsmuster:**

* Wird von `AppLauncherMenu` und `CommandPaletteOverlay` verwendet.
* Emittiert ein Signal (`search_text_changed`) bei Textänderung.

**Erwartete Ergebnisse/Outputs:**
Eine funktionsfähige und benutzerfreundliche Suchleiste.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Initialisierung: Sind Icon und Button vorhanden, Placeholder-Text gesetzt?
    * Testen der `changed`-Logik: Eingabe von Text -> Clear-Button erscheint, Text löschen -> Clear-Button verschwindet.
    * Testen des Clear-Buttons: Klick löscht Text.
    * Testen von `get_text()` und `set_text()`.
    * Simulieren von Textänderungen und prüfen, ob `search_text_changed` korrekt ausgelöst wird.
* **Integration Tests:**
    * Starten der NovaDE.
    * Öffnen eines UI-Elements mit der Suchleiste (z.B. App-Launcher).
    * Texteingabe, Clear-Button klicken, Fokus setzen und visuell prüfen.

**Geschätzter Aufwand:** Gering (ca. 1-2 Tage)

---

### **novade-ui/src/components/app_launcher/app_icon.rs**

**Verantwortlichkeit:**
Implementiert ein wiederverwendbares GTK-Widget zur Darstellung einer einzelnen Anwendung als Icon mit Textbeschriftung.

**Kern-Aufgaben (Tasks):**

1.  **`AppIcon` Struktur:**
    * Ist ein Wrapper um `gtk::Button` oder `gtk::Box` mit `gtk::EventControllerClick`.
    * Felder:
        * `container: gtk::Box` (Oder `gtk::Button`).
        * `icon: gtk::Image`
        * `label: gtk::Label`
        * `app_id: String` (Die Freedesktop.org Desktop Entry ID der Anwendung).

2.  **`AppIcon::new()` Funktion:**
    * `pub fn new(app_info: &ApplicationInfo) -> Self`
    * Erstellt eine `gtk::Box` (`container`).
    * Erstellt ein `gtk::Image` aus `app_info.icon`. Verwende `gdk_pixbuf::Pixbuf` oder `gio::Icon` und `gtk::Picture`.
    * Erstellt ein `gtk::Label` aus `app_info.name`.
    * Fügt `icon` und `label` zum `container` hinzu (vertikal oder horizontal, je nach Layout).
    * Speichert `app_info.id` in `app_id`.
    * Setzt CSS-Klasse "nova-app-icon".
    * **Wichtig:** Fügt `gtk::EventControllerClick` zum `container` hinzu und verbindet das `pressed` Signal, um einen `clicked` Event zu emittieren (siehe unten).

3.  **`AppIcon::connect_clicked()` Methode:**
    * `pub fn connect_clicked<F: Fn(&Self, String) + 'static>(&self, f: F)`
    * Gibt die `app_id` an den Callback weiter, wenn das Icon geklickt wird.

4.  **`AppIcon::get_app_id()` Methode:**
    * `pub fn get_app_id(&self) -> &str`

5.  **`AppIcon::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/app_launcher/app_icon.rs`

**Abhängigkeiten:**

* **Intern:** `novade_domain::app_launcher::data_types::ApplicationInfo`
* **Extern:** `gtk::{self, prelude::*, Box, Button, Image, Label, EventControllerClick, glib, Widget}`

**Kommunikationsmuster:**

* Wird von `AppLauncherMenu` dynamisch erstellt.
* Emittiert ein `clicked` Signal mit seiner `app_id` bei Klick.

**Erwartete Ergebnisse/Outputs:**
Ein optisch ansprechendes und klickbares Widget für die Darstellung einzelner Anwendungen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion: Prüfen, ob Icon und Label korrekt aus `ApplicationInfo` erstellt werden.
    * Simulieren eines Klicks und Verifizieren, dass `connect_clicked` den korrekten `app_id` Wert sendet.
* **Integration Tests:**
    * Anzeigen einer Liste von `AppIcon`s in einem UI-Kontext.
    * Visuelle Inspektion der Icons und Labels.
    * Klicken auf die Icons und Verifizieren, dass die zugehörige Anwendung startet.

**Geschätzter Aufwand:** Gering (ca. 1-2 Tage)

---
### **novade-ui/src/components/notification_indicator/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die den Benachrichtigungsindikator im Panel bilden.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod notification_indicator_widget;` (Das Panel-Widget)
    * `pub mod controller;` (Der Controller, der die Logik verwaltet)
    * `pub mod error;` (Fehler-Enum für das Modul)

2.  **Re-Exporte (`pub use`):**
    * `pub use notification_indicator_widget::NotificationIndicator;`
    * `pub use controller::NotificationIndicatorController;`
    * `pub use error::NotificationIndicatorError;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/notification_indicator/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* Wird von `Panel` verwendet.
* `UiServices` initialisiert den Controller.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für den Benachrichtigungsindikator.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/notification_indicator/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`NotificationIndicatorError`) für das Benachrichtigungsindikator-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationIndicatorError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `DomainServiceError(#[from] novade_domain::DomainError)`: Fehler von der Domänenschicht.
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/notification_indicator/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_domain::DomainError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `notification_indicator`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für den Benachrichtigungsindikator.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `NotificationIndicatorError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/notification_indicator/notification_indicator_widget.rs**

**Verantwortlichkeit:**
Implementiert das GTK-Widget für den Benachrichtigungsindikator, das die Anzahl ungelesener Benachrichtigungen anzeigt und bei Klick das Benachrichtigungs-Panel öffnet.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationIndicator` Struktur:**
    * Ist ein Wrapper um `gtk::Button` oder `gtk::Box`.
    * Felder:
        * `container: gtk::Box` (oder `gtk::Button`).
        * `icon: gtk::Image` (Z.B. eine Glocke).
        * `badge_label: gtk::Label` (Anzeige der Anzahl ungelesener Benachrichtigungen).
        * `popover: Option<gtk::Popover>` (Das Popover für das Benachrichtigungs-Panel).

2.  **`NotificationIndicator::new()` Funktion:**
    * `pub fn new() -> Result<Self, NotificationIndicatorError>`
    * Erstellt die `gtk::Box` oder `gtk::Button`.
    * Initialisiert `icon` und `badge_label`.
    * Ordnet sie im `container` an.
    * Initialisiert ein leeres `popover` Feld (dieses wird vom Controller bei Bedarf befüllt).
    * Verbindet das `clicked` Signal des `container` (oder `Button`):
        * Ruft eine Callback-Funktion auf, die vom Controller gesetzt wird, um das Benachrichtigungs-Panel zu öffnen.
    * Setzt CSS-Klassen "nova-notification-indicator".

3.  **`NotificationIndicator::update_unread_count()` Methode:**
    * `pub fn update_unread_count(&self, count: u32)`
    * Aktualisiert den Text des `badge_label` mit der neuen Anzahl.
    * Versteckt/zeigt das `badge_label`, wenn der Zähler 0 ist.
    * Fügt/entfernt eine CSS-Klasse (z.B. "has-unread-notifications") für visuelles Feedback.

4.  **`NotificationIndicator::set_popover()` Methode:**
    * `pub fn set_popover(&mut self, popover: gtk::Popover)`
    * Setzt das `popover` Feld.

5.  **`NotificationIndicator::show_popover_at_widget()` Methode:**
    * `pub fn show_popover_at_widget(&self, widget: &impl IsA<gtk::Widget>)`
    * Zeigt das Popover am Indikator an.

6.  **`NotificationIndicator::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/notification_indicator/notification_indicator_widget.rs`
* `novade-ui/resources/ui/notification_indicator.ui` (optional)

**Abhängigkeiten:**

* **Intern:** `crate::components::notification_indicator::error::NotificationIndicatorError`
* **Extern:** `gtk::{self, prelude::*, Box, Button, Image, Label, Popover, glib, IsA, Widget}`

**Kommunikationsmuster:**

* Wird von `Panel` instanziiert.
* Wird vom `NotificationIndicatorController` aktualisiert.
* Emittiert Klick-Events, die vom `NotificationIndicatorController` verarbeitet werden.

**Erwartete Ergebnisse/Outputs:**
Ein funktionaler Benachrichtigungsindikator im Panel, der die Anzahl ungelesener Benachrichtigungen anzeigt und das Benachrichtigungs-Panel öffnet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion: Initialisierung der Widgets, CSS-Klassen.
    * Testen von `update_unread_count()`: Korrekte Anzeige des Zählers, Sichtbarkeit des Labels, CSS-Klassen bei 0/ungelesen.
    * Testen von `set_popover()` und `show_popover_at_widget()`.
    * Simulieren eines Klicks und Verifizieren, dass der entsprechende Callback ausgelöst wird.
* **Integration Tests:**
    * Starten der NovaDE.
    * Senden von Test-Benachrichtigungen über D-Bus und Verifizieren, dass der Zähler im Panel aktualisiert wird.
    * Klicken auf den Indikator und Überprüfen, ob das Benachrichtigungs-Panel erscheint.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---

### **novade-ui/src/components/notification_indicator/controller.rs**

**Verantwortlichkeit:**
Implementiert den `NotificationIndicatorController`, der die logische Steuerung für den Benachrichtigungsindikator übernimmt. Er abonniert Events vom `NotificationRulesEngine` der Domänenschicht, um Änderungen an der Anzahl ungelesener Benachrichtigungen zu erkennen. Außerdem steuert er die Anzeige des Benachrichtigungs-Panels.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationIndicatorController` Struktur:**
    * Felder:
        * `notification_rules_engine: Arc<NotificationRulesEngine>`
        * `notification_indicator_widget: Arc<NotificationIndicator>` (Referenz auf das GTK-Widget selbst).
        * `notification_panel_popover: Arc<NotificationPanelPopover>` (Das Popover, das die Benachrichtigungen anzeigt).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>`.

2.  **`NotificationIndicatorController::new()` Funktion:**
    * `pub fn new(notification_rules_engine: Arc<NotificationRulesEngine>) -> Result<Arc<Self>, NotificationIndicatorError>`
    * Speichert die Referenz zum `notification_rules_engine`.
    * Erstellt eine Instanz des `NotificationIndicator` GTK-Widgets.
    * Erstellt eine Instanz des `NotificationPanelPopover` (siehe `novade-ui/src/windows/notification_panel`).
    * Verbindet das Klick-Signal des `notification_indicator_widget`:
        * Bei Klick: `self.notification_panel_popover.show_popover_at_widget(&self.notification_indicator_widget.get_widget());`
    * Speichert die Instanzen.

3.  **`NotificationIndicatorController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt einen asynchronen Task (`glib::MainContext::spawn_local`) für den Event-Listener.
    * **Listener-Task für ungelesene Benachrichtigungen:**
        * `let indicator = self.notification_indicator_widget.clone();`
        * `let mut unread_count_rx = self.notification_rules_engine.subscribe_to_unread_count_changes();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `while let Ok(count) = unread_count_rx.recv().await {`
        * `indicator.update_unread_count(count);`
        * `}`
        * `Ok(())`
        * `}));`

4.  **`NotificationIndicatorController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

5.  **`NotificationIndicatorController::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> Arc<NotificationIndicator>`
    * Gibt die Referenz auf das `NotificationIndicator` Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/notification_indicator/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::notification_indicator::notification_indicator_widget::NotificationIndicator`
    * `crate::components::notification_indicator::error::NotificationIndicatorError`
    * `crate::windows::notification_panel::NotificationPanelPopover`
    * `novade_domain::notification_rules::engine::NotificationRulesEngine`
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`

**Kommunikationsmuster:**

* **Initialisiert und verwaltet das `NotificationIndicator` GTK-Widget und das `NotificationPanelPopover`.**
* **Abonniert Events vom `NotificationRulesEngine`.**
* **Aktualisiert den Zustand des `NotificationIndicator` Widgets auf Basis empfangener Events.**
* **Öffnet das `NotificationPanelPopover` bei Klick auf den Indikator.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller Controller, der den Benachrichtigungsindikator aktuell hält und die korrekte Anzeige des Benachrichtigungs-Panels steuert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NotificationRulesEngine` (um `subscribe_to_unread_count_changes` zu kontrollieren).
    * Mocken von `NotificationIndicator` und `NotificationPanelPopover`.
    * Testen der `new()`-Funktion: Verifizieren, dass Services, Indicator und Popover korrekt gespeichert und Signale verbunden werden.
    * Testen der `start_listeners()`: Simulieren von `unread_count_changes` Events und prüfen, ob `update_unread_count` des Indicators aufgerufen wird.
    * Testen des Klick-Handlings: Simulieren eines Klicks auf den Indicator und prüfen, ob `show_popover_at_widget` des Popovers aufgerufen wird.
* **Integration Tests:**
    * Starten der NovaDE.
    * Senden von Test-Benachrichtigungen (direkt oder über einen D-Bus-Client).
    * Visuelle Inspektion, ob der Zähler aktualisiert wird und ob das Benachrichtigungs-Panel bei Klick korrekt erscheint.

**Geschätzter Aufwand:** Mittel (ca. 3-4 Tage)

---
### **novade-ui/src/components/battery_indicator/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die den Batteriestatus-Indikator im Panel bilden.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod battery_indicator_widget;` (Das Panel-Widget)
    * `pub mod controller;` (Der Controller, der die Logik verwaltet)
    * `pub mod error;` (Fehler-Enum für das Modul)

2.  **Re-Exporte (`pub use`):**
    * `pub use battery_indicator_widget::BatteryIndicator;`
    * `pub use controller::BatteryIndicatorController;`
    * `pub use error::BatteryIndicatorError;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/battery_indicator/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* Wird von `Panel` verwendet.
* `UiServices` initialisiert den Controller.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für den Batteriestatus-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/battery_indicator/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`BatteryIndicatorError`) für das Batteriestatus-Indikator-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`BatteryIndicatorError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `SystemServiceError(#[from] novade_system::SystemServiceError)`: Fehler von der Systemschicht.
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/battery_indicator/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_system::SystemServiceError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `battery_indicator`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für den Batteriestatus-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `BatteryIndicatorError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/battery_indicator/battery_indicator_widget.rs**

**Verantwortlichkeit:**
Implementiert das GTK-Widget für den Batteriestatus-Indikator, der den Ladezustand, den Ladestatus (Laden/Entladen) und Warnungen bei niedrigem Akkustand anzeigt.

**Kern-Aufgaben (Tasks):**

1.  **`BatteryIndicator` Struktur:**
    * Ist ein Wrapper um `gtk::Box` (oder `gtk::Button`).
    * Felder:
        * `container: gtk::Box`
        * `icon: gtk::Image` (Batterie-Icon, z.B. `battery-full-symbolic`, `battery-charging-symbolic`, `battery-empty-symbolic`).
        * `percentage_label: gtk::Label` (Anzeige des Prozentsatzes).
        * `time_remaining_label: gtk::Label` (Optional: Geschätzte Restlaufzeit).

2.  **`BatteryIndicator::new()` Funktion:**
    * `pub fn new() -> Result<Self, BatteryIndicatorError>`
    * Erstellt die `gtk::Box` und die Kind-Widgets (`icon`, `percentage_label`, `time_remaining_label`).
    * Ordnet sie im `container` an.
    * Setzt CSS-Klassen "nova-battery-indicator".
    * Initialisiert den Status als unbekannt/Standard (z.B. ein Fragezeichen-Icon).

3.  **`BatteryIndicator::update_status()` Methode:**
    * `pub fn update_status(&self, status: &BatteryStatus)`
    * Empfängt ein `BatteryStatus` Objekt von der Systemschicht.
    * Aktualisiert das `percentage_label` mit `status.percentage`.
    * Wählt das korrekte `icon` basierend auf `status.charging` und `status.percentage` (z.B. `battery-charging-symbolic` wenn ladend, `battery-full-symbolic` wenn 100%, `battery-low-symbolic` unter 20% etc.).
    * Aktualisiert `time_remaining_label` basierend auf `status.time_to_empty` oder `status.time_to_full`.
    * Fügt/entfernt CSS-Klassen für Warnungen (z.B. "battery-low", "battery-critical").

4.  **`BatteryIndicator::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/battery_indicator/battery_indicator_widget.rs`
* `novade-ui/resources/ui/battery_indicator.ui` (optional)

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::battery_indicator::error::BatteryIndicatorError`
    * `novade_system::power_management::data_types::BatteryStatus` (und zugehörige Enums)
* **Extern:** `gtk::{self, prelude::*, Box, Image, Label, glib, Widget}`

**Kommunikationsmuster:**

* Wird von `Panel` instanziiert.
* Wird vom `BatteryIndicatorController` aktualisiert.

**Erwartete Ergebnisse/Outputs:**
Ein funktionaler Batteriestatus-Indikator im Panel, der jederzeit den aktuellen Ladezustand und Status der Batterie anzeigt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion: Initialisierung der Widgets, CSS-Klassen.
    * Testen von `update_status()` mit verschiedenen `BatteryStatus` Werten:
        * Verschiedene Prozentsätze (0, 10, 50, 90, 100).
        * Ladend/Entladend.
        * Verschiedene geschätzte Zeiten.
        * Verifizieren der korrekten Icon-Auswahl und CSS-Klassen.
* **Integration Tests:**
    * Starten der NovaDE.
    * Simulieren von Batteriestatusänderungen (über D-Bus-Mocks des UPower-Dienstes oder direkte Injektion in den `PowerManagementService`).
    * Visuelle Inspektion, ob Icon, Prozentsatz und Status korrekt im Panel aktualisiert werden.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---

### **novade-ui/src/components/battery_indicator/controller.rs**

**Verantwortlichkeit:**
Implementiert den `BatteryIndicatorController`, der die logische Steuerung für den Batteriestatus-Indikator übernimmt. Er abonniert Events vom `PowerManagementService` der Systemschicht, um Änderungen am Batteriestatus zu erkennen und das UI-Widget entsprechend zu aktualisieren.

**Kern-Aufgaben (Tasks):**

1.  **`BatteryIndicatorController` Struktur:**
    * Felder:
        * `power_management_service: Arc<PowerManagementService>`
        * `battery_indicator_widget: Arc<BatteryIndicator>` (Referenz auf das GTK-Widget selbst).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>`.

2.  **`BatteryIndicatorController::new()` Funktion:**
    * `pub fn new(power_management_service: Arc<PowerManagementService>) -> Result<Arc<Self>, BatteryIndicatorError>`
    * Speichert die Referenz zum `power_management_service`.
    * Erstellt eine Instanz des `BatteryIndicator` GTK-Widgets.
    * Speichert die Instanzen.

3.  **`BatteryIndicatorController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt einen asynchronen Task (`glib::MainContext::spawn_local`) für den Event-Listener.
    * **Listener-Task für Batteriestatus-Änderungen:**
        * `let indicator = self.battery_indicator_widget.clone();`
        * `let mut battery_status_rx = self.power_management_service.subscribe_to_power_status_changes();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `while let Ok(status) = battery_status_rx.recv().await {`
        * `indicator.update_status(&status);`
        * `}`
        * `Ok(())`
        * `}));`
    * **Initialer Status-Update:** Ruft einmalig `power_management_service.get_battery_status()` auf und aktualisiert den Indikator, um den Zustand direkt nach dem Start anzuzeigen.

4.  **`BatteryIndicatorController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

5.  **`BatteryIndicatorController::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> Arc<BatteryIndicator>`
    * Gibt die Referenz auf das `BatteryIndicator` Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/battery_indicator/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::battery_indicator::battery_indicator_widget::BatteryIndicator`
    * `crate::components::battery_indicator::error::BatteryIndicatorError`
    * `novade_system::power_management::service::PowerManagementService`
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`

**Kommunikationsmuster:**

* **Initialisiert und verwaltet das `BatteryIndicator` GTK-Widget.**
* **Abonniert Events vom `PowerManagementService` der Systemschicht.**
* **Aktualisiert den Zustand des `BatteryIndicator` Widgets auf Basis empfangener Events.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller Controller, der den Batteriestatus-Indikator aktuell hält.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `PowerManagementService` (um `subscribe_to_power_status_changes` und `get_battery_status` zu kontrollieren).
    * Mocken des `BatteryIndicator` Widgets (um `update_status` zu verifizieren).
    * Testen der `new()`-Funktion: Verifizieren, dass Services und Indicator korrekt gespeichert werden.
    * Testen der `start_listeners()`: Simulieren von `power_status_changes` Events und prüfen, ob `update_status` des Indicators aufgerufen wird.
    * Testen des initialen Status-Updates nach `start_listeners`.
* **Integration Tests:**
    * Starten der NovaDE.
    * Simulieren von Batteriestatusänderungen (z.B. durch UPower-D-Bus-Mocks oder Skripte).
    * Visuelle Inspektion, ob der Indikator im Panel korrekt aktualisiert wird.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---
### **novade-ui/src/components/network_indicator/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die den Netzwerkstatus-Indikator im Panel bilden.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod network_indicator_widget;` (Das Panel-Widget)
    * `pub mod controller;` (Der Controller, der die Logik verwaltet)
    * `pub mod error;` (Fehler-Enum für das Modul)
    * `pub mod network_details_popover;` (Das Popover für detaillierte Netzwerk-Informationen und Einstellungen)

2.  **Re-Exporte (`pub use`):**
    * `pub use network_indicator_widget::NetworkIndicator;`
    * `pub use controller::NetworkIndicatorController;`
    * `pub use error::NetworkIndicatorError;`
    * `pub use network_details_popover::NetworkDetailsPopover;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* Wird von `Panel` verwendet.
* `UiServices` initialisiert den Controller.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für den Netzwerkstatus-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/network_indicator/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`NetworkIndicatorError`) für das Netzwerkstatus-Indikator-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkIndicatorError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `SystemServiceError(#[from] novade_system::SystemServiceError)`: Fehler von der Systemschicht (z.B. von NetworkManager D-Bus).
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_system::SystemServiceError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `network_indicator`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für den Netzwerkstatus-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `NetworkIndicatorError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/network_indicator/network_indicator_widget.rs**

**Verantwortlichkeit:**
Implementiert das GTK-Widget für den Netzwerkstatus-Indikator, der den allgemeinen Netzwerkstatus (verbunden, getrennt, WLAN, Ethernet) anzeigt.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkIndicator` Struktur:**
    * Ist ein Wrapper um `gtk::Button` oder `gtk::Box`.
    * Felder:
        * `container: gtk::Box` (oder `gtk::Button`).
        * `icon: gtk::Image` (Netzwerk-Icon, z.B. `network-wireless-signal-good-symbolic`, `network-wired-symbolic`, `network-offline-symbolic`).
        * `status_label: gtk::Label` (Optional: Kurztext-Status wie "WLAN: NovaNet" oder "Offline").

2.  **`NetworkIndicator::new()` Funktion:**
    * `pub fn new() -> Result<Self, NetworkIndicatorError>`
    * Erstellt die `gtk::Box` und die Kind-Widgets (`icon`, `status_label`).
    * Ordnet sie im `container` an.
    * Setzt CSS-Klassen "nova-network-indicator".
    * Initialisiert den Status als unbekannt/Standard (z.B. ein Fragezeichen-Icon).

3.  **`NetworkIndicator::update_status()` Methode:**
    * `pub fn update_status(&self, status: &NetworkStatus)`
    * Empfängt ein `NetworkStatus` Objekt von der Systemschicht.
    * Wählt das korrekte `icon` basierend auf `status.state` und `status.connection_type` (z.B. `network-wireless-signal-good-symbolic` für verbundenes WLAN, `network-wired-symbolic` für verbundenes Ethernet, `network-offline-symbolic` für offline).
    * Aktualisiert `status_label` (wenn verwendet) mit einer kurzen Statusbeschreibung (z.B. "WLAN: NovaNet", "Ethernet verbunden", "Offline").
    * Fügt/entfernt CSS-Klassen basierend auf dem Status (z.B. "network-offline", "network-connected-wifi").

4.  **`NetworkIndicator::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/network_indicator_widget.rs`
* `novade-ui/resources/ui/network_indicator.ui` (optional)

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::network_indicator::error::NetworkIndicatorError`
    * `novade_system::dbus_interfaces::network_manager::data_types::NetworkStatus` (und zugehörige Enums)
* **Extern:** `gtk::{self, prelude::*, Box, Button, Image, Label, glib, Widget}`

**Kommunikationsmuster:**

* Wird von `Panel` instanziiert.
* Wird vom `NetworkIndicatorController` aktualisiert.
* Emittiert Klick-Events, die vom `NetworkIndicatorController` verarbeitet werden, um das Detail-Popover zu öffnen.

**Erwartete Ergebnisse/Outputs:**
Ein funktionaler Netzwerkstatus-Indikator im Panel, der den aktuellen Status der Netzwerkverbindung anzeigt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion: Initialisierung der Widgets, CSS-Klassen.
    * Testen von `update_status()` mit verschiedenen `NetworkStatus` Werten:
        * Verbunden (WLAN, Ethernet), getrennt, verbindend, Fehler.
        * Verifizieren der korrekten Icon-Auswahl, Label-Text und CSS-Klassen.
* **Integration Tests:**
    * Starten der NovaDE.
    * Simulieren von Netzwerkstatusänderungen (z.B. über D-Bus-Mocks des NetworkManager-Dienstes oder direkte Injektion in den `NetworkManagerProxy`).
    * Visuelle Inspektion, ob Icon und Text im Panel korrekt aktualisiert werden.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---

### **novade-ui/src/components/network_indicator/controller.rs**

**Verantwortlichkeit:**
Implementiert den `NetworkIndicatorController`, der die logische Steuerung für den Netzwerkstatus-Indikator übernimmt. Er abonniert Events vom `NetworkManagerProxy` der Systemschicht, um Änderungen am Netzwerkstatus zu erkennen und das UI-Widget entsprechend zu aktualisieren. Er steuert auch die Anzeige des detaillierten Netzwerk-Popovers.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkIndicatorController` Struktur:**
    * Felder:
        * `network_manager_proxy: Arc<NetworkManagerProxy>`
        * `network_indicator_widget: Arc<NetworkIndicator>` (Referenz auf das GTK-Widget selbst).
        * `network_details_popover: Arc<NetworkDetailsPopover>` (Das Popover mit Details/Einstellungen).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>`.

2.  **`NetworkIndicatorController::new()` Funktion:**
    * `pub fn new(network_manager_proxy: Arc<NetworkManagerProxy>) -> Result<Arc<Self>, NetworkIndicatorError>`
    * Speichert die Referenz zum `network_manager_proxy`.
    * Erstellt eine Instanz des `NetworkIndicator` GTK-Widgets.
    * Erstellt eine Instanz des `NetworkDetailsPopover`.
    * Verbindet das Klick-Signal des `network_indicator_widget`:
        * Bei Klick: `self.network_details_popover.show_popover_at_widget(&self.network_indicator_widget.get_widget());`
    * Speichert die Instanzen.

3.  **`NetworkIndicatorController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt einen asynchronen Task (`glib::MainContext::spawn_local`) für den Event-Listener.
    * **Listener-Task für Netzwerkstatus-Änderungen:**
        * `let indicator = self.network_indicator_widget.clone();`
        * `let popover = self.network_details_popover.clone();`
        * `let mut network_status_rx = self.network_manager_proxy.subscribe_to_network_status_changes();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `while let Ok(status) = network_status_rx.recv().await {`
        * `indicator.update_status(&status);`
        * `popover.update_status(&status);` (Aktualisiert das Popover, auch wenn es nicht sichtbar ist)
        * `}`
        * `Ok(())`
        * `}));`
    * **Initialer Status-Update:** Ruft einmalig `network_manager_proxy.get_current_network_status()` auf und aktualisiert sowohl den Indikator als auch das Popover.

4.  **`NetworkIndicatorController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

5.  **`NetworkIndicatorController::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> Arc<NetworkIndicator>`
    * Gibt die Referenz auf das `NetworkIndicator` Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::network_indicator::network_indicator_widget::NetworkIndicator`
    * `crate::components::network_indicator::network_details_popover::NetworkDetailsPopover`
    * `crate::components::network_indicator::error::NetworkIndicatorError`
    * `novade_system::dbus_interfaces::network_manager::NetworkManagerProxy`
    * `novade_system::dbus_interfaces::network_manager::data_types::NetworkStatus`
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`

**Kommunikationsmuster:**

* **Initialisiert und verwaltet das `NetworkIndicator` GTK-Widget und das `NetworkDetailsPopover`.**
* **Abonniert Events vom `NetworkManagerProxy` der Systemschicht.**
* **Aktualisiert den Zustand beider UI-Komponenten auf Basis empfangener Events.**
* **Öffnet das `NetworkDetailsPopover` bei Klick auf den Indikator.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller Controller, der den Netzwerkstatus-Indikator und das Detail-Popover aktuell hält.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NetworkManagerProxy` (um `subscribe_to_network_status_changes` und `get_current_network_status` zu kontrollieren).
    * Mocken des `NetworkIndicator` Widgets und des `NetworkDetailsPopover` (um `update_status` und `show_popover_at_widget` zu verifizieren).
    * Testen der `new()`-Funktion: Verifizieren, dass Proxies, Indicator und Popover korrekt gespeichert und Signale verbunden werden.
    * Testen der `start_listeners()`: Simulieren von `network_status_changes` Events und prüfen, ob `update_status` beider UI-Komponenten aufgerufen wird.
    * Testen des Klick-Handlings: Simulieren eines Klicks auf den Indicator und prüfen, ob `show_popover_at_widget` des Popovers aufgerufen wird.
* **Integration Tests:**
    * Starten der NovaDE.
    * Simulieren von Netzwerkstatusänderungen (z.B. WLAN verbinden/trennen) über `nmcli` oder D-Bus-Mocks.
    * Visuelle Inspektion, ob der Indikator im Panel korrekt aktualisiert wird und ob das Detail-Popover bei Klick korrekt erscheint und die richtigen Informationen anzeigt.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da Interaktion mit D-Bus, Popover-Logik und verschiedene Netzwerktypen)

---

### **novade-ui/src/components/network_indicator/network_details_popover.rs**

**Verantwortlichkeit:**
Implementiert das `gtk::Popover` oder `gtk::Window` (für ein Mini-Control-Center-Panel), das detaillierte Netzwerk-Informationen anzeigt und grundlegende Netzwerk-Einstellungen (z.B. WLAN-Scan, Verbinden/Trennen) ermöglicht.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkDetailsPopover` Struktur:**
    * Ist ein Wrapper um `gtk::Popover` oder `gtk::Window`.
    * Felder:
        * `container: gtk::Widget` (Das Popover/Window).
        * `current_status_label: gtk::Label` (Zeigt aktuellen Verbindungsstatus an, z.B. "Verbunden mit NovaNet").
        * `ip_address_label: gtk::Label` (Zeigt die IP-Adresse an).
        * `wifi_list_box: gtk::ListBox` (Liste der verfügbaren WLAN-Netzwerke).
        * `ethernet_status_label: gtk::Label` (Status für Ethernet).
        * `toggle_wifi_button: gtk::ToggleButton` (WLAN ein/aus).
        * `toggle_ethernet_button: gtk::ToggleButton` (Ethernet ein/aus).
        * `network_manager_proxy: Arc<NetworkManagerProxy>` (Direkte Referenz zur Interaktion).

2.  **`NetworkDetailsPopover::new()` Funktion:**
    * `pub fn new(network_manager_proxy: Arc<NetworkManagerProxy>) -> Result<Self, NetworkIndicatorError>`
    * Lädt die UI-Definition (`network_details_popover.ui`).
    * Initialisiert die Widgets und speichert die `network_manager_proxy` Referenz.
    * Setzt Initialzustände für Toggle-Buttons basierend auf `network_manager_proxy.get_current_network_status()`.
    * Verbindet das `toggled` Signal von `toggle_wifi_button`:
        * Bei `true`: Ruft `network_manager_proxy.enable_wifi(true)` auf.
        * Bei `false`: Ruft `network_manager_proxy.enable_wifi(false)` auf.
    * Verbindet `toggled` Signal von `toggle_ethernet_button` (ähnlich).
    * Verbindet das `row-activated` Signal der `wifi_list_box`:
        * Bei Auswahl eines WLANs: Ruft `network_manager_proxy.connect_to_wifi(ssid, password)` auf (ggf. Passwort-Dialog vorher anzeigen).
    * Setzt CSS-Klassen "nova-network-details-popover".

3.  **`NetworkDetailsPopover::update_status()` Methode:**
    * `pub fn update_status(&self, status: &NetworkStatus)`
    * Aktualisiert `current_status_label`, `ip_address_label`, `ethernet_status_label`.
    * Aktualisiert den Zustand der Toggle-Buttons (`toggle_wifi_button`, `toggle_ethernet_button`) basierend auf `status.state` und `status.connection_type`.

4.  **`NetworkDetailsPopover::update_wifi_list()` Methode:**
    * `pub async fn update_wifi_list(&self, wifi_networks: Vec<WifiNetwork>)`
    * Leert die `wifi_list_box`.
    * Fügt für jedes `WifiNetwork` aus der Liste einen `gtk::ListBoxRow` mit Label (SSID) und ggf. Signalstärke-Icon hinzu.

5.  **`NetworkDetailsPopover::show_popover_at_widget()` Methode:**
    * `pub fn show_popover_at_widget(&self, widget: &impl IsA<gtk::Widget>)`
    * Zeigt das Popover an.

6.  **`NetworkDetailsPopover::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/network_details_popover.rs`
* `novade-ui/resources/ui/network_details_popover.ui`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::network_indicator::error::NetworkIndicatorError`
    * `novade_system::dbus_interfaces::network_manager::NetworkManagerProxy`
    * `novade_system::dbus_interfaces::network_manager::data_types::{NetworkStatus, WifiNetwork}`
* **Extern:**
    * `gtk::{self, prelude::*, Popover, Window, Label, ListBox, ListBoxRow, ToggleButton, glib, IsA, Widget}`
    * `std::sync::Arc`
    * `tokio` (für async-Aufrufe an `NetworkManagerProxy`)

**Kommunikationsmuster:**

* Wird vom `NetworkIndicatorController` erstellt und angezeigt.
* Interagiert direkt mit dem `NetworkManagerProxy` der Systemschicht, um Netzwerkaktionen auszuführen (WLAN ein/aus, verbinden).
* Wird vom `NetworkIndicatorController` aktualisiert, wenn sich der Netzwerkstatus ändert.

**Erwartete Ergebnisse/Outputs:**
Ein interaktives Popover, das detaillierte Netzwerk-Informationen anzeigt und grundlegende Netzwerk-Einstellungen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NetworkManagerProxy`.
    * Testen der `new()`-Funktion: Initialisierung der Widgets, Signal-Verbindungen.
    * Testen von `update_status()` mit verschiedenen `NetworkStatus` Werten.
    * Testen von `update_wifi_list()`: Verifizieren, dass die Liste korrekt gefüllt wird.
    * Simulieren von Toggle-Button-Klicks und ListBox-Row-Aktivierung und Prüfen, ob die korrekten Aufrufe an den gemockten `NetworkManagerProxy` erfolgen.
* **Integration Tests:**
    * Starten der NovaDE.
    * Öffnen des Popovers.
    * Visuelle Inspektion der angezeigten Informationen.
    * Testen des WLAN-Scans, Verbinden/Trennen von Netzwerken und Verifizieren, dass die Aktionen korrekt ausgeführt werden und der Indikator sowie das Popover aktualisiert werden.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage, da komplexe UI für WLAN-Liste, Passwort-Handling und Interaktion mit NetworkManager)

---
### **novade-ui/src/components/volume_indicator/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die den Lautstärke-Indikator im Panel bilden.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod volume_indicator_widget;` (Das Panel-Widget)
    * `pub mod controller;` (Der Controller, der die Logik verwaltet)
    * `pub mod error;` (Fehler-Enum für das Modul)
    * `pub mod volume_details_popover;` (Das Popover für detaillierte Lautstärke-Einstellungen und Audio-Geräteauswahl)

2.  **Re-Exporte (`pub use`):**
    * `pub use volume_indicator_widget::VolumeIndicator;`
    * `pub use controller::VolumeIndicatorController;`
    * `pub use error::VolumeIndicatorError;`
    * `pub use volume_details_popover::VolumeDetailsPopover;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/volume_indicator/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* Wird von `Panel` verwendet.
* `UiServices` initialisiert den Controller.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für den Lautstärke-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/volume_indicator/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`VolumeIndicatorError`) für das Lautstärke-Indikator-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`VolumeIndicatorError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `SystemServiceError(#[from] novade_system::SystemServiceError)`: Fehler von der Systemschicht (z.B. von PipeWire).
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/volume_indicator/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_system::SystemServiceError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `volume_indicator`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für den Lautstärke-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `VolumeIndicatorError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/volume_indicator/volume_indicator_widget.rs**

**Verantwortlichkeit:**
Implementiert das GTK-Widget für den Lautstärke-Indikator, der den aktuellen Lautstärkepegel anzeigt und den Mute-Status visualisiert.

**Kern-Aufgaben (Tasks):**

1.  **`VolumeIndicator` Struktur:**
    * Ist ein Wrapper um `gtk::Button` oder `gtk::Box`.
    * Felder:
        * `container: gtk::Box` (oder `gtk::Button`).
        * `icon: gtk::Image` (Lautstärke-Icon, z.B. `audio-volume-high-symbolic`, `audio-volume-muted-symbolic`).
        * `percentage_label: gtk::Label` (Optional: Anzeige des Prozentsatzes).

2.  **`VolumeIndicator::new()` Funktion:**
    * `pub fn new() -> Result<Self, VolumeIndicatorError>`
    * Erstellt die `gtk::Box` und die Kind-Widgets (`icon`, `percentage_label`).
    * Ordnet sie im `container` an.
    * Setzt CSS-Klassen "nova-volume-indicator".
    * Initialisiert den Status als unbekannt/Standard (z.B. ein mittleres Lautstärke-Icon).

3.  **`VolumeIndicator::update_status()` Methode:**
    * `pub fn update_status(&self, status: &AudioStatus)`
    * Empfängt ein `AudioStatus` Objekt von der Systemschicht.
    * Wählt das korrekte `icon` basierend auf `status.muted` und `status.volume_percentage` (z.B. `audio-volume-muted-symbolic` wenn gemutet, `audio-volume-high-symbolic` für hohe Lautstärke, `audio-volume-low-symbolic` für niedrige Lautstärke).
    * Aktualisiert `percentage_label` mit `status.volume_percentage`.
    * Fügt/entfernt CSS-Klassen basierend auf dem Status (z.B. "volume-muted", "volume-high").

4.  **`VolumeIndicator::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/volume_indicator/volume_indicator_widget.rs`
* `novade-ui/resources/ui/volume_indicator.ui` (optional)

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::volume_indicator::error::VolumeIndicatorError`
    * `novade_system::audio_management::data_types::AudioStatus`
* **Extern:** `gtk::{self, prelude::*, Box, Button, Image, Label, glib, Widget}`

**Kommunikationsmuster:**

* Wird von `Panel` instanziiert.
* Wird vom `VolumeIndicatorController` aktualisiert.
* Emittiert Klick-Events, die vom `VolumeIndicatorController` verarbeitet werden, um das Detail-Popover zu öffnen.

**Erwartete Ergebnisse/Outputs:**
Ein funktionaler Lautstärke-Indikator im Panel, der den aktuellen Audiostatus anzeigt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion: Initialisierung der Widgets, CSS-Klassen.
    * Testen von `update_status()` mit verschiedenen `AudioStatus` Werten:
        * Verschiedene Lautstärken (0, 10, 50, 100).
        * Gemutet/Nicht gemutet.
        * Verifizieren der korrekten Icon-Auswahl, Label-Text und CSS-Klassen.
* **Integration Tests:**
    * Starten der NovaDE.
    * Ändern der Systemlautstärke (z.B. über Tastenkürzel oder `pactl`/`wpctl`).
    * Visuelle Inspektion, ob Icon und Text im Panel korrekt aktualisiert werden.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---

### **novade-ui/src/components/volume_indicator/controller.rs**

**Verantwortlichkeit:**
Implementiert den `VolumeIndicatorController`, der die logische Steuerung für den Lautstärke-Indikator übernimmt. Er abonniert Events vom `AudioManagementService` der Systemschicht, um Änderungen am Audiostatus zu erkennen und das UI-Widget entsprechend zu aktualisieren. Er steuert auch die Anzeige des detaillierten Lautstärke-Popovers.

**Kern-Aufgaben (Tasks):**

1.  **`VolumeIndicatorController` Struktur:**
    * Felder:
        * `audio_management_service: Arc<AudioManagementService>`
        * `volume_indicator_widget: Arc<VolumeIndicator>` (Referenz auf das GTK-Widget selbst).
        * `volume_details_popover: Arc<VolumeDetailsPopover>` (Das Popover mit Details/Einstellungen).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>`.

2.  **`VolumeIndicatorController::new()` Funktion:**
    * `pub fn new(audio_management_service: Arc<AudioManagementService>) -> Result<Arc<Self>, VolumeIndicatorError>`
    * Speichert die Referenz zum `audio_management_service`.
    * Erstellt eine Instanz des `VolumeIndicator` GTK-Widgets.
    * Erstellt eine Instanz des `VolumeDetailsPopover`.
    * Verbindet das Klick-Signal des `volume_indicator_widget`:
        * Bei Klick: `self.volume_details_popover.show_popover_at_widget(&self.volume_indicator_widget.get_widget());`
    * Speichert die Instanzen.

3.  **`VolumeIndicatorController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt einen asynchronen Task (`glib::MainContext::spawn_local`) für den Event-Listener.
    * **Listener-Task für Audiostatus-Änderungen:**
        * `let indicator = self.volume_indicator_widget.clone();`
        * `let popover = self.volume_details_popover.clone();`
        * `let mut audio_status_rx = self.audio_management_service.subscribe_to_audio_status_changes();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `while let Ok(status) = audio_status_rx.recv().await {`
        * `indicator.update_status(&status);`
        * `popover.update_status(&status);` (Aktualisiert das Popover, auch wenn es nicht sichtbar ist)
        * `}`
        * `Ok(())`
        * `}));`
    * **Initialer Status-Update:** Ruft einmalig `audio_management_service.get_current_audio_status()` auf und aktualisiert sowohl den Indikator als auch das Popover.

4.  **`VolumeIndicatorController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

5.  **`VolumeIndicatorController::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> Arc<VolumeIndicator>`
    * Gibt die Referenz auf das `VolumeIndicator` Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/volume_indicator/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::volume_indicator::volume_indicator_widget::VolumeIndicator`
    * `crate::components::volume_indicator::volume_details_popover::VolumeDetailsPopover`
    * `crate::components::volume_indicator::error::VolumeIndicatorError`
    * `novade_system::audio_management::service::AudioManagementService`
    * `novade_system::audio_management::data_types::AudioStatus`
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`

**Kommunikationsmuster:**

* **Initialisiert und verwaltet das `VolumeIndicator` GTK-Widget und das `VolumeDetailsPopover`.**
* **Abonniert Events vom `AudioManagementService` der Systemschicht.**
* **Aktualisiert den Zustand beider UI-Komponenten auf Basis empfangener Events.**
* **Öffnet das `VolumeDetailsPopover` bei Klick auf den Indikator.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller Controller, der den Lautstärke-Indikator und das Detail-Popover aktuell hält.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `AudioManagementService` (um `subscribe_to_audio_status_changes` und `get_current_audio_status` zu kontrollieren).
    * Mocken des `VolumeIndicator` Widgets und des `VolumeDetailsPopover` (um `update_status` und `show_popover_at_widget` zu verifizieren).
    * Testen der `new()`-Funktion: Verifizieren, dass Services, Indicator und Popover korrekt gespeichert und Signale verbunden werden.
    * Testen der `start_listeners()`: Simulieren von `audio_status_changes` Events und prüfen, ob `update_status` beider UI-Komponenten aufgerufen wird.
    * Testen des Klick-Handlings: Simulieren eines Klicks auf den Indicator und prüfen, ob `show_popover_at_widget` des Popovers aufgerufen wird.
* **Integration Tests:**
    * Starten der NovaDE.
    * Ändern der Systemlautstärke (z.B. über Tastenkürzel oder `pactl`/`wpctl`).
    * Visuelle Inspektion, ob der Indikator im Panel korrekt aktualisiert wird und ob das Detail-Popover bei Klick korrekt erscheint und die richtigen Informationen anzeigt.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da komplexe Interaktion mit PipeWire, Popover-Logik und verschiedene Audio-Geräte)

---

### **novade-ui/src/components/volume_indicator/volume_details_popover.rs**

**Verantwortlichkeit:**
Implementiert das `gtk::Popover` oder `gtk::Window`, das detaillierte Lautstärke-Einstellungen, Mute-Funktion und Auswahl von Audio-Ausgabegeräten ermöglicht.

**Kern-Aufgaben (Tasks):**

1.  **`VolumeDetailsPopover` Struktur:**
    * Ist ein Wrapper um `gtk::Popover` oder `gtk::Window`.
    * Felder:
        * `container: gtk::Widget` (Das Popover/Window).
        * `volume_slider: gtk::Scale` (Lautstärkeregler).
        * `mute_button: gtk::ToggleButton` (Mute-Schalter).
        * `output_device_combo: gtk::ComboBoxText` (Auswahl des Audio-Ausgabegeräts).
        * `input_device_combo: gtk::ComboBoxText` (Optional: Auswahl des Audio-Eingabegeräts).
        * `audio_management_service: Arc<AudioManagementService>` (Direkte Referenz zur Interaktion).

2.  **`VolumeDetailsPopover::new()` Funktion:**
    * `pub fn new(audio_management_service: Arc<AudioManagementService>) -> Result<Self, VolumeIndicatorError>`
    * Lädt die UI-Definition (`volume_details_popover.ui`).
    * Initialisiert die Widgets und speichert die `audio_management_service` Referenz.
    * Setzt Initialzustände für Slider und Mute-Button basierend auf `audio_management_service.get_current_audio_status()`.
    * Befüllt `output_device_combo` und `input_device_combo` mit verfügbaren Geräten von `audio_management_service.get_audio_devices()`.
    * **Verbindet Signale:**
        * `volume_slider.connect_value_changed()`: Bei Slider-Änderung: `audio_management_service.set_volume(new_value)`.
        * `mute_button.connect_toggled()`: Bei Toggle: `audio_management_service.set_mute(is_muted)`.
        * `output_device_combo.connect_changed()`: Bei Auswahl eines Geräts: `audio_management_service.set_default_output_device(device_id)`.
        * `input_device_combo.connect_changed()` (optional): Bei Auswahl: `audio_management_service.set_default_input_device(device_id)`.
    * Setzt CSS-Klassen "nova-volume-details-popover".

3.  **`VolumeDetailsPopover::update_status()` Methode:**
    * `pub fn update_status(&self, status: &AudioStatus)`
    * Aktualisiert den Wert des `volume_slider` mit `status.volume_percentage`.
    * Aktualisiert den Zustand des `mute_button` mit `status.muted`.
    * **Wichtig:** Setzt den `output_device_combo` auf das `status.active_output_device_id`.
    * Aktualisiert ggf. `input_device_combo`.

4.  **`VolumeDetailsPopover::update_audio_devices()` Methode:**
    * `pub async fn update_audio_devices(&self, devices: Vec<AudioDevice>)`
    * Leert beide ComboBoxen.
    * Fügt alle `AudioDevice`s hinzu und wählt das aktive Gerät aus.

5.  **`VolumeDetailsPopover::show_popover_at_widget()` Methode:**
    * `pub fn show_popover_at_widget(&self, widget: &impl IsA<gtk::Widget>)`
    * Zeigt das Popover an.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/volume_indicator/volume_details_popover.rs`
* `novade-ui/resources/ui/volume_details_popover.ui`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::volume_indicator::error::VolumeIndicatorError`
    * `novade_system::audio_management::service::AudioManagementService`
    * `novade_system::audio_management::data_types::{AudioStatus, AudioDevice}`
* **Extern:**
    * `gtk::{self, prelude::*, Popover, Window, Scale, ToggleButton, ComboBoxText, glib, IsA, Widget}`
    * `std::sync::Arc`
    * `tokio` (für async-Aufrufe an `AudioManagementService`)

**Kommunikationsmuster:**

* Wird vom `VolumeIndicatorController` erstellt und angezeigt.
* Interagiert direkt mit dem `AudioManagementService` der Systemschicht, um Audioaktionen auszuführen (Lautstärke ändern, muten, Gerät wählen).
* Wird vom `VolumeIndicatorController` aktualisiert, wenn sich der Audiostatus oder die Liste der Geräte ändert.

**Erwartete Ergebnisse/Outputs:**
Ein interaktives Popover, das detaillierte Audiosteuerung ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `AudioManagementService`.
    * Testen der `new()`-Funktion: Initialisierung der Widgets, Signal-Verbindungen.
    * Testen von `update_status()` mit verschiedenen `AudioStatus` Werten.
    * Testen von `update_audio_devices()`: Verifizieren, dass die ComboBoxen korrekt gefüllt werden.
    * Simulieren von Slider-Änderungen, Button-Klicks und ComboBox-Auswahlen und Prüfen, ob die korrekten Aufrufe an den gemockten `AudioManagementService` erfolgen.
* **Integration Tests:**
    * Starten der NovaDE.
    * Öffnen des Popovers.
    * Visuelle Inspektion der angezeigten Informationen und Geräte.
    * Testen der Lautstärke-Änderung, Mute-Funktion und des Gerätewechsels und Verifizieren, dass die Aktionen korrekt ausgeführt werden und der Indikator sowie das Popover aktualisiert werden.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage, da komplexe UI für Geräteauswahl, Lautstärkeregelung und Interaktion mit PipeWire)

---
### **novade-ui/src/components/datetime_indicator/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die den Datums- und Uhrzeit-Indikator im Panel bilden.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod datetime_indicator_widget;` (Das Panel-Widget)
    * `pub mod controller;` (Der Controller, der die Logik verwaltet)
    * `pub mod error;` (Fehler-Enum für das Modul)
    * `pub mod calendar_popover;` (Das Popover für Kalender und eventuell Zeitzoneneinstellungen)

2.  **Re-Exporte (`pub use`):**
    * `pub use datetime_indicator_widget::DateTimeIndicator;`
    * `pub use controller::DateTimeIndicatorController;`
    * `pub use error::DateTimeIndicatorError;`
    * `pub use calendar_popover::CalendarPopover;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/datetime_indicator/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* Wird von `Panel` verwendet.
* `UiServices` initialisiert den Controller.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für den Datums- und Uhrzeit-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/datetime_indicator/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`DateTimeIndicatorError`) für das Datums- und Uhrzeit-Indikator-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`DateTimeIndicatorError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `DomainServiceError(#[from] novade_domain::DomainError)`: Fehler von der Domänenschicht (z.B. Zeitzonen-Konfiguration).
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/datetime_indicator/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_domain::DomainError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `datetime_indicator`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für den Datums- und Uhrzeit-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `DateTimeIndicatorError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/datetime_indicator/datetime_indicator_widget.rs**

**Verantwortlichkeit:**
Implementiert das GTK-Widget für den Datums- und Uhrzeit-Indikator, der die aktuelle Uhrzeit und das Datum im Panel anzeigt.

**Kern-Aufgaben (Tasks):**

1.  **`DateTimeIndicator` Struktur:**
    * Ist ein Wrapper um `gtk::Button` oder `gtk::Box`.
    * Felder:
        * `container: gtk::Box` (oder `gtk::Button`).
        * `time_label: gtk::Label` (Anzeige der Uhrzeit).
        * `date_label: gtk::Label` (Anzeige des Datums, optional versteckt).

2.  **`DateTimeIndicator::new()` Funktion:**
    * `pub fn new() -> Result<Self, DateTimeIndicatorError>`
    * Erstellt die `gtk::Box` und die Kind-Widgets (`time_label`, `date_label`).
    * Ordnet sie im `container` an.
    * Setzt CSS-Klassen "nova-datetime-indicator".
    * Verbindet das `clicked` Signal des `container` (oder `Button`), um das Kalender-Popover zu öffnen.

3.  **`DateTimeIndicator::update_datetime()` Methode:**
    * `pub fn update_datetime(&self, datetime: &DateTime<Local>)`
    * Empfängt ein `DateTime<Local>` Objekt von `chrono`.
    * Formatiert die Uhrzeit (z.B. "HH:MM") und aktualisiert `time_label`.
    * Formatiert das Datum (z.B. "Tag, DD. Monat") und aktualisiert `date_label`.
    * Berücksichtigt die Konfiguration des Datums- und Uhrzeitformats aus den `GlobalSettingsService`.

4.  **`DateTimeIndicator::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/datetime_indicator/datetime_indicator_widget.rs`
* `novade-ui/resources/ui/datetime_indicator.ui` (optional)

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::datetime_indicator::error::DateTimeIndicatorError`
* **Extern:**
    * `gtk::{self, prelude::*, Box, Button, Label, glib, Widget}`
    * `chrono::{Local, DateTime, Timelike}`
    * `std::sync::Arc` (für den Zugriff auf `GlobalSettingsService` über den Controller)

**Kommunikationsmuster:**

* Wird von `Panel` instanziiert.
* Wird vom `DateTimeIndicatorController` aktualisiert.
* Emittiert Klick-Events, die vom `DateTimeIndicatorController` verarbeitet werden, um das Kalender-Popover zu öffnen.

**Erwartete Ergebnisse/Outputs:**
Ein funktionaler Datums- und Uhrzeit-Indikator im Panel, der die aktuelle Zeit und das Datum anzeigt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion: Initialisierung der Widgets, CSS-Klassen.
    * Testen von `update_datetime()` mit verschiedenen `DateTime<Local>` Werten:
        * Verschiedene Zeiten und Daten.
        * Überprüfen der korrekten Formatierung im `time_label` und `date_label`.
        * Testen der Uhrzeit- und Datumsformat-Konfiguration.
* **Integration Tests:**
    * Starten der NovaDE.
    * Ändern der Systemzeit oder des Datums (z.B. über `timedatectl`).
    * Visuelle Inspektion, ob die Anzeige im Panel korrekt aktualisiert wird.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---

### **novade-ui/src/components/datetime_indicator/controller.rs**

**Verantwortlichkeit:**
Implementiert den `DateTimeIndicatorController`, der die logische Steuerung für den Datums- und Uhrzeit-Indikator übernimmt. Er aktualisiert das UI-Widget periodisch und steuert die Anzeige des Kalender-Popovers.

**Kern-Aufgaben (Tasks):**

1.  **`DateTimeIndicatorController` Struktur:**
    * Felder:
        * `datetime_indicator_widget: Arc<DateTimeIndicator>` (Referenz auf das GTK-Widget selbst).
        * `calendar_popover: Arc<CalendarPopover>` (Das Popover für Kalender).
        * `global_settings_service: Arc<GlobalSettingsService>` (Zugriff auf Zeit-/Datumsformat-Einstellungen).
        * `update_interval_handle: Option<glib::SourceId>` (Handle für den periodischen Update-Timer).

2.  **`DateTimeIndicatorController::new()` Funktion:**
    * `pub fn new(global_settings_service: Arc<GlobalSettingsService>) -> Result<Arc<Self>, DateTimeIndicatorError>`
    * Speichert die Referenz zum `global_settings_service`.
    * Erstellt eine Instanz des `DateTimeIndicator` GTK-Widgets.
    * Erstellt eine Instanz des `CalendarPopover`.
    * Verbindet das Klick-Signal des `datetime_indicator_widget`:
        * Bei Klick: `self.calendar_popover.show_popover_at_widget(&self.datetime_indicator_widget.get_widget());`
    * Speichert die Instanzen.

3.  **`DateTimeIndicatorController::start_periodic_update()` Methode:**
    * `pub fn start_periodic_update(self: Arc<Self>)`
    * Setzt einen `glib::timeout_add_seconds_local` (oder `glib::timeout_add_local`) Timer, der jede Sekunde oder Minute (abhängig von gewünschter Granularität und Performance) eine Callback-Funktion aufruft.
    * **Callback-Funktion:**
        * Holt die aktuelle lokale Zeit (`chrono::Local::now()`).
        * Ruft `self.datetime_indicator_widget.update_datetime()` auf.
        * `glib::Continue(true)` zurückgeben, um den Timer fortzusetzen.
    * Speichert den `glib::SourceId` im `update_interval_handle`.

4.  **`DateTimeIndicatorController::stop_periodic_update()` Methode:**
    * `pub fn stop_periodic_update(&mut self)`
    * Wenn `update_interval_handle` vorhanden ist, entfernt den Timer mit `glib::SourceId::remove()`.
    * Setzt `update_interval_handle` auf `None`.

5.  **`DateTimeIndicatorController::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> Arc<DateTimeIndicator>`
    * Gibt die Referenz auf das `DateTimeIndicator` Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/datetime_indicator/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::datetime_indicator::datetime_indicator_widget::DateTimeIndicator`
    * `crate::components::datetime_indicator::calendar_popover::CalendarPopover`
    * `crate::components::datetime_indicator::error::DateTimeIndicatorError`
    * `novade_domain::settings::service::GlobalSettingsService`
* **Extern:**
    * `tokio::task::JoinHandle` (indirekt, falls Settings-Änderungen gelauscht werden)
    * `std::sync::Arc`
    * `glib::{self, MainContext, SourceId, Continue}`
    * `chrono::{Local, DateTime}`
    * `tracing`

**Kommunikationsmuster:**

* **Initialisiert und verwaltet das `DateTimeIndicator` GTK-Widget und das `CalendarPopover`.**
* **Aktualisiert den Zustand beider UI-Komponenten periodisch und bei Settings-Änderungen.**
* **Öffnet das `CalendarPopover` bei Klick auf den Indikator.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller Controller, der den Datums- und Uhrzeit-Indikator aktuell hält und das Kalender-Popover steuert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `DateTimeIndicator` und `CalendarPopover` (um `update_datetime` und `show_popover_at_widget` zu verifizieren).
    * Mocken von `GlobalSettingsService` (um Zeit-/Datumsformat-Einstellungen zu kontrollieren).
    * Testen der `new()`-Funktion: Verifizieren, dass Services, Indicator und Popover korrekt gespeichert und Signale verbunden werden.
    * Testen von `start_periodic_update()` und `stop_periodic_update()`: Prüfen, ob der Timer korrekt gestartet und gestoppt wird (dies kann schwierig sein, da `glib::timeout_add_local` direkt mit dem MainContext interagiert; ggf. nur manuelle Tests oder spezifische `glib` Test-Helfer).
    * Testen des Klick-Handlings: Simulieren eines Klicks auf den Indicator und prüfen, ob `show_popover_at_widget` des Popovers aufgerufen wird.
* **Integration Tests:**
    * Starten der NovaDE.
    * Visuelle Inspektion, ob die Uhrzeit korrekt läuft.
    * Klicken auf den Indikator und Verifizieren, ob das Kalender-Popover korrekt erscheint.
    * Ändern der Zeitzone oder des Datumsformats in den NovaDE-Einstellungen und Prüfen, ob die Anzeige im Panel und Popover aktualisiert wird.

**Geschätzter Aufwand:** Mittel (ca. 3-4 Tage)

---

### **novade-ui/src/components/datetime_indicator/calendar_popover.rs**

**Verantwortlichkeit:**
Implementiert das `gtk::Popover`, das einen Kalender zur Anzeige des aktuellen Monats und zur Navigation durch Monate/Jahre bietet. Optional können auch Events aus einem Kalenderdienst angezeigt und Zeitzonen ausgewählt werden.

**Kern-Aufgaben (Tasks):**

1.  **`CalendarPopover` Struktur:**
    * Ist ein Wrapper um `gtk::Popover`.
    * Felder:
        * `container: gtk::Popover`.
        * `calendar: gtk::Calendar` (Das GTK-Kalender-Widget).
        * `timezone_combo: Option<gtk::ComboBoxText>` (Optional: für Zeitzonenauswahl).
        * `event_list_box: Option<gtk::ListBox>` (Optional: für die Anzeige von Kalenderereignissen).
        * `global_settings_service: Arc<GlobalSettingsService>` (für Zeitzonen und eventuell Kalenderintegration).

2.  **`CalendarPopover::new()` Funktion:**
    * `pub fn new(global_settings_service: Arc<GlobalSettingsService>) -> Result<Self, DateTimeIndicatorError>`
    * Lädt die UI-Definition (`calendar_popover.ui`).
    * Initialisiert das `gtk::Calendar` Widget.
    * **Optional:**
        * Initialisiert `timezone_combo` und befüllt es mit den System-Zeitzonen (ggf. über eine Systemschicht-API). Setzt die aktuelle Zeitzone als ausgewählt. Verbindet das `changed` Signal zur Aktualisierung über `global_settings_service`.
        * Initialisiert `event_list_box`.
    * Setzt CSS-Klassen "nova-calendar-popover".
    * Verbindet das `day-selected` Signal des `gtk::Calendar`:
        * Holt das ausgewählte Datum.
        * Wenn `event_list_box` vorhanden, aktualisiert es die Events für diesen Tag (ggf. über einen Domänen-Service).

3.  **`CalendarPopover::update_datetime()` Methode:**
    * `pub fn update_datetime(&self, datetime: &DateTime<Local>)`
    * Setzt das `gtk::Calendar` auf das aktuelle Datum (falls es nicht bereits das ausgewählte Datum ist).
    * Aktualisiert die Anzeige der Zeitzone, falls vorhanden.

4.  **`CalendarPopover::update_events()` Methode (optional):**
    * `pub fn update_events(&self, date: &Date<Local>, events: Vec<CalendarEvent>)`
    * Leert die `event_list_box`.
    * Fügt für jedes `CalendarEvent` (welches eine einfache Struktur mit Titel, Startzeit etc. sein könnte) einen `gtk::ListBoxRow` hinzu.

5.  **`CalendarPopover::show_popover_at_widget()` Methode:**
    * `pub fn show_popover_at_widget(&self, widget: &impl IsA<gtk::Widget>)`
    * Zeigt das Popover an.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/datetime_indicator/calendar_popover.rs`
* `novade-ui/resources/ui/calendar_popover.ui`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::datetime_indicator::error::DateTimeIndicatorError`
    * `novade_domain::settings::service::GlobalSettingsService`
    * Ggf. `novade_domain::calendar_service::CalendarService` (falls Event-Anzeige implementiert).
    * Ggf. `novade_system::time_management::TimeManagementService` (für Zeitzonenliste).
* **Extern:**
    * `gtk::{self, prelude::*, Popover, Calendar, ComboBoxText, ListBox, ListBoxRow, glib, IsA, Widget}`
    * `chrono::{Local, DateTime, Date}`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Wird vom `DateTimeIndicatorController` erstellt und angezeigt.
* Interagiert mit `GlobalSettingsService` für Zeitzonen-Änderungen.
* Interagiert ggf. mit einem `CalendarService` (Domänenschicht) für Event-Abfragen.
* Wird vom `DateTimeIndicatorController` aktualisiert.

**Erwartete Ergebnisse/Outputs:**
Ein interaktives Popover, das einen Kalender und optionale Funktionen für Zeitzonen und Events bietet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `GlobalSettingsService` und `CalendarService`.
    * Testen der `new()`-Funktion: Initialisierung der Widgets, Signal-Verbindungen.
    * Testen von `update_datetime()`: Korrekte Kalenderanzeige.
    * Testen von `update_events()`: Korrektes Befüllen der Event-Liste.
    * Simulieren von Kalender-Day-Selected und ComboBox-Changed und Prüfen, ob die korrekten Aufrufe an die gemockten Services erfolgen.
* **Integration Tests:**
    * Starten der NovaDE.
    * Öffnen des Popovers.
    * Visuelle Inspektion des Kalenders und der korrekten Monatsnavigation.
    * Falls implementiert: Testen der Zeitzonen-Auswahl und Event-Anzeige.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, abhängig von den optionalen Features wie Zeitzonen- und Event-Integration)

---
### **novade-ui/src/components/workspaces_indicator/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die den Workspace-Indikator im Panel bilden.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod workspaces_indicator_widget;` (Das Panel-Widget, das die Workspace-Nummern anzeigt)
    * `pub mod controller;` (Der Controller, der die Logik verwaltet)
    * `pub mod error;` (Fehler-Enum für das Modul)

2.  **Re-Exporte (`pub use`):**
    * `pub use workspaces_indicator_widget::WorkspacesIndicator;`
    * `pub use controller::WorkspacesIndicatorController;`
    * `pub use error::WorkspacesIndicatorError;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/workspaces_indicator/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* Wird von `Panel` verwendet.
* `UiServices` initialisiert den Controller.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für den Workspace-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/workspaces_indicator/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`WorkspacesIndicatorError`) für das Workspace-Indikator-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`WorkspacesIndicatorError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `DomainServiceError(#[from] novade_domain::DomainError)`: Fehler von der Domänenschicht (z.B. von `WorkspaceManagementService`).
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/workspaces_indicator/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_domain::DomainError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `workspaces_indicator`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für den Workspace-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `WorkspacesIndicatorError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/workspaces_indicator/workspaces_indicator_widget.rs**

**Verantwortlichkeit:**
Implementiert das GTK-Widget für den Workspace-Indikator, der eine visuelle Darstellung der verfügbaren Workspaces und des aktuell aktiven Workspaces im Panel anzeigt.

**Kern-Aufgaben (Tasks):**

1.  **`WorkspacesIndicator` Struktur:**
    * Ist ein Wrapper um `gtk::Box` oder `gtk::StackSwitcher`.
    * Felder:
        * `container: gtk::Box` (HBox oder VBox für die Workspace-Buttons).
        * `workspace_buttons: Vec<gtk::Button>` (Liste von Buttons, einer pro Workspace).
        * `active_workspace_id: u32` (ID des aktuell aktiven Workspaces).
        * `show_empty_workspaces: bool` (Konfigurationseinstellung aus `GlobalSettingsService`).
        * `show_workspace_names: bool` (Konfigurationseinstellung).

2.  **`WorkspacesIndicator::new()` Funktion:**
    * `pub fn new() -> Result<Self, WorkspacesIndicatorError>`
    * Erstellt die `gtk::Box`.
    * Setzt CSS-Klassen "nova-workspaces-indicator".
    * Initialisiert leere `workspace_buttons` und `active_workspace_id`.
    * Bereitet das Container-Layout vor.

3.  **`WorkspacesIndicator::update_workspaces()` Methode:**
    * `pub fn update_workspaces(&self, workspaces: Vec<WorkspaceInfo>, active_workspace_id: u32)`
    * Empfängt eine Liste von `WorkspaceInfo` Objekten (von `WorkspaceManagementService`) und die ID des aktiven Workspaces.
    * Löscht alle vorhandenen Buttons im `container`.
    * Iteriert über `workspaces`:
        * Erstellt für jeden `WorkspaceInfo` einen `gtk::Button`.
        * Setzt den Button-Text (Workspace-Nummer oder Name, abhängig von `show_workspace_names`).
        * Fügt CSS-Klassen hinzu (z.B. "workspace-button", "active-workspace-button" wenn aktiv).
        * Verbindet das `clicked` Signal des Buttons:
            * Ruft eine Callback-Funktion auf, die vom Controller gesetzt wird, um zum entsprechenden Workspace zu wechseln.
        * Fügt den Button zum `container` hinzu.
    * Aktualisiert `active_workspace_id`.
    * Stellt sicher, dass die `show_empty_workspaces` und `show_workspace_names` Einstellungen berücksichtigt werden, um die Anzeige anzupassen (z.B. leere Workspaces nicht anzeigen, wenn so konfiguriert).

4.  **`WorkspacesIndicator::set_switch_workspace_callback()` Methode:**
    * `pub fn set_switch_workspace_callback<F>(&self, callback: F)`
    * `where F: Fn(u32) + 'static`
    * Speichert den Callback, der aufgerufen wird, wenn ein Workspace-Button geklickt wird.

5.  **`WorkspacesIndicator::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/workspaces_indicator/workspaces_indicator_widget.rs`
* `novade-ui/resources/ui/workspaces_indicator.ui` (optional)

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::workspaces_indicator::error::WorkspacesIndicatorError`
    * `novade_domain::workspace_management::data_types::WorkspaceInfo`
* **Extern:** `gtk::{self, prelude::*, Box, Button, glib, Widget}`

**Kommunikationsmuster:**

* Wird von `Panel` instanziiert.
* Wird vom `WorkspacesIndicatorController` aktualisiert.
* Emittiert Klick-Events, die vom `WorkspacesIndicatorController` verarbeitet werden.

**Erwartete Ergebnisse/Outputs:**
Ein funktionaler Workspace-Indikator im Panel, der Workspaces anzeigt und das Umschalten ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion: Initialisierung der Widgets, CSS-Klassen.
    * Testen von `update_workspaces()` mit verschiedenen Listen von `WorkspaceInfo`:
        * Leere Liste, eine Handvoll Workspaces, viele Workspaces.
        * Aktiver Workspace in verschiedenen Positionen.
        * Testen der korrekten Erstellung und Anordnung der Buttons.
        * Verifizieren der korrekten CSS-Klassen für aktive/inaktive Workspaces.
        * Testen der `show_empty_workspaces` und `show_workspace_names` Logik.
    * Simulieren eines Klicks auf einen Workspace-Button und Verifizieren, dass der entsprechende Callback mit der korrekten Workspace-ID ausgelöst wird.
* **Integration Tests:**
    * Starten der NovaDE.
    * Hinzufügen/Entfernen von Workspaces (z.B. über Tastenkürzel oder API).
    * Wechseln zwischen Workspaces.
    * Visuelle Inspektion, ob die Anzeige im Panel korrekt aktualisiert wird (Anzahl der Buttons, aktiver Button).

**Geschätzter Aufwand:** Mittel (ca. 3-4 Tage)

---

### **novade-ui/src/components/workspaces_indicator/controller.rs**

**Verantwortlichkeit:**
Implementiert den `WorkspacesIndicatorController`, der die logische Steuerung für den Workspace-Indikator übernimmt. Er abonniert Events vom `WorkspaceManagementService` der Domänenschicht, um Änderungen an Workspaces zu erkennen und das UI-Widget entsprechend zu aktualisieren. Er initiiert auch das Umschalten von Workspaces.

**Kern-Aufgaben (Tasks):**

1.  **`WorkspacesIndicatorController` Struktur:**
    * Felder:
        * `workspace_management_service: Arc<WorkspaceManagementService>`
        * `global_settings_service: Arc<GlobalSettingsService>` (für Konfigurationen wie `show_empty_workspaces`, `show_workspace_names`).
        * `workspaces_indicator_widget: Arc<WorkspacesIndicator>` (Referenz auf das GTK-Widget selbst).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>`.

2.  **`WorkspacesIndicatorController::new()` Funktion:**
    * `pub fn new(workspace_management_service: Arc<WorkspaceManagementService>, global_settings_service: Arc<GlobalSettingsService>) -> Result<Arc<Self>, WorkspacesIndicatorError>`
    * Speichert die Referenzen zu den Services.
    * Erstellt eine Instanz des `WorkspacesIndicator` GTK-Widgets.
    * **Setzt den Callback für den Workspace-Wechsel:**
        * `let service_clone = workspace_management_service.clone();`
        * `widget.set_switch_workspace_callback(move |id| {`
        * `glib::spawn_future_local(async move {`
        * `if let Err(e) = service_clone.switch_to_workspace(id).await {`
        * `// Log error`
        * `tracing::error!("Failed to switch workspace: {:?}", e);`
        * `}`
        * `});`
        * `});`
    * Speichert die Instanzen.

3.  **`WorkspacesIndicatorController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt asynchrone Tasks (`glib::MainContext::spawn_local`) für die Event-Listener.
    * **Listener-Task für Workspace-Änderungen:**
        * `let indicator = self.workspaces_indicator_widget.clone();`
        * `let settings_service = self.global_settings_service.clone();`
        * `let mut workspace_changes_rx = self.workspace_management_service.subscribe_to_workspace_changes();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `while let Ok((workspaces, active_id)) = workspace_changes_rx.recv().await {`
        * `// Hier die Konfigurationen vom settings_service holen`
        * `let show_empty = settings_service.get_setting::<bool>("desktop.workspaces.show_empty").unwrap_or(false);` // Beispiel
        * `let show_names = settings_service.get_setting::<bool>("desktop.workspaces.show_names").unwrap_or(false);` // Beispiel
        * `indicator.update_workspaces(workspaces, active_id, show_empty, show_names);` // Übergabe der Settings an Widget
        * `}`
        * `Ok(())`
        * `}));`
    * **Initialer Status-Update:** Ruft einmalig `workspace_management_service.get_all_workspaces()` und `workspace_management_service.get_active_workspace_id()` auf, um den Indikator initial zu befüllen.

4.  **`WorkspacesIndicatorController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

5.  **`WorkspacesIndicatorController::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> Arc<WorkspacesIndicator>`
    * Gibt die Referenz auf das `WorkspacesIndicator` Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/workspaces_indicator/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::workspaces_indicator::workspaces_indicator_widget::WorkspacesIndicator`
    * `crate::components::workspaces_indicator::error::WorkspacesIndicatorError`
    * `novade_domain::workspace_management::service::WorkspaceManagementService`
    * `novade_domain::settings::service::GlobalSettingsService`
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`

**Kommunikationsmuster:**

* **Initialisiert und verwaltet das `WorkspacesIndicator` GTK-Widget.**
* **Abonniert Events vom `WorkspaceManagementService` der Domänenschicht für Workspace-Änderungen.**
* **Aktualisiert den Zustand des `WorkspacesIndicator` Widgets auf Basis empfangener Events.**
* **Ruft Methoden auf `WorkspaceManagementService` auf, um Workspaces zu wechseln.**
* **Liest Konfigurationen von `GlobalSettingsService`.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller Controller, der den Workspace-Indikator aktuell hält und Benutzerinteraktionen für den Workspace-Wechsel an die Domänenschicht weiterleitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `WorkspaceManagementService` (um `subscribe_to_workspace_changes`, `get_all_workspaces`, `get_active_workspace_id`, `switch_to_workspace` zu kontrollieren).
    * Mocken von `GlobalSettingsService`.
    * Mocken des `WorkspacesIndicator` Widgets (um `update_workspaces` und `set_switch_workspace_callback` zu verifizieren).
    * Testen der `new()`-Funktion: Verifizieren, dass Services und Indicator korrekt gespeichert und der Callback gesetzt wird.
    * Testen der `start_listeners()`: Simulieren von `workspace_changes` Events und prüfen, ob `update_workspaces` des Indicators aufgerufen wird.
    * Testen des `switch_workspace_callback`: Simulieren eines Aufrufs des Callbacks und prüfen, ob `switch_to_workspace` des Service aufgerufen wird.
* **Integration Tests:**
    * Starten der NovaDE.
    * Erstellen/Löschen/Wechseln von Workspaces über Tastenkürzel oder einen Test-Client.
    * Visuelle Inspektion, ob der Indikator im Panel korrekt aktualisiert wird und ob der Workspace-Wechsel über den Indikator funktioniert.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da Interaktion mit dynamischen Workspace-Listen und Konfigurationen)

---
### **novade-ui/src/components/power_indicator/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die den Energie-Indikator im Panel bilden.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod power_indicator_widget;` (Das Panel-Widget)
    * `pub mod controller;` (Der Controller, der die Logik verwaltet)
    * `pub mod error;` (Fehler-Enum für das Modul)
    * `pub mod power_details_popover;` (Das Popover für detaillierte Energie-Informationen und -Einstellungen)

2.  **Re-Exporte (`pub use`):**
    * `pub use power_indicator_widget::PowerIndicator;`
    * `pub use controller::PowerIndicatorController;`
    * `pub use error::PowerIndicatorError;`
    * `pub use power_details_popover::PowerDetailsPopover;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/power_indicator/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* Wird von `Panel` verwendet.
* `UiServices` initialisiert den Controller.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für den Energie-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/power_indicator/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`PowerIndicatorError`) für das Energie-Indikator-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`PowerIndicatorError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `SystemServiceError(#[from] novade_system::SystemServiceError)`: Fehler von der Systemschicht (z.B. von UPower oder logind D-Bus).
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/power_indicator/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_system::SystemServiceError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `power_indicator`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für den Energie-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `PowerIndicatorError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/power_indicator/power_indicator_widget.rs**

**Verantwortlichkeit:**
Implementiert das GTK-Widget für den Energie-Indikator, der den Batteriestatus, Ladezustand und Restlaufzeit (falls zutreffend) anzeigt.

**Kern-Aufgaben (Tasks):**

1.  **`PowerIndicator` Struktur:**
    * Ist ein Wrapper um `gtk::Button` oder `gtk::Box`.
    * Felder:
        * `container: gtk::Box` (oder `gtk::Button`).
        * `icon: gtk::Image` (Batterie-Icon, z.B. `battery-full-symbolic`, `battery-charging-symbolic`).
        * `percentage_label: gtk::Label` (Anzeige des Prozentsatzes).
        * `time_label: gtk::Label` (Optional: Restlaufzeit oder Ladezeit).

2.  **`PowerIndicator::new()` Funktion:**
    * `pub fn new() -> Result<Self, PowerIndicatorError>`
    * Erstellt die `gtk::Box` und die Kind-Widgets (`icon`, `percentage_label`, `time_label`).
    * Ordnet sie im `container` an.
    * Setzt CSS-Klassen "nova-power-indicator".
    * Initialisiert den Status als unbekannt/Standard (z.B. ein leeres Batterie-Icon).

3.  **`PowerIndicator::update_status()` Methode:**
    * `pub fn update_status(&self, status: &BatteryStatus)`
    * Empfängt ein `BatteryStatus` Objekt von der Systemschicht.
    * Wählt das korrekte `icon` basierend auf `status.charging_state`, `status.percentage` und `status.is_present` (z.B. `battery-full-symbolic` wenn geladen, `battery-charging-symbolic` wenn lädt, `battery-low-symbolic` für niedrigen Akkustand, `battery-missing-symbolic` wenn keine Batterie).
    * Aktualisiert `percentage_label` mit `status.percentage`.
    * Aktualisiert `time_label` mit `status.time_to_empty` oder `status.time_to_full` (formatiert in Stunden und Minuten).
    * Fügt/entfernt CSS-Klassen basierend auf dem Status (z.B. "battery-critical", "battery-charging").

4.  **`PowerIndicator::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/power_indicator/power_indicator_widget.rs`
* `novade-ui/resources/ui/power_indicator.ui` (optional)

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::power_indicator::error::PowerIndicatorError`
    * `novade_system::power_management::data_types::BatteryStatus`
* **Extern:** `gtk::{self, prelude::*, Box, Button, Image, Label, glib, Widget}`

**Kommunikationsmuster:**

* Wird von `Panel` instanziiert.
* Wird vom `PowerIndicatorController` aktualisiert.
* Emittiert Klick-Events, die vom `PowerIndicatorController` verarbeitet werden, um das Detail-Popover zu öffnen.

**Erwartete Ergebnisse/Outputs:**
Ein funktionaler Energie-Indikator im Panel, der den aktuellen Batteriestatus anzeigt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion: Initialisierung der Widgets, CSS-Klassen.
    * Testen von `update_status()` mit verschiedenen `BatteryStatus` Werten:
        * Verschiedene Ladestände (0, 10, 50, 90, 100).
        * Ladezustände (Laden, Entladen, Voll, Unbekannt).
        * Restlaufzeiten.
        * Verifizieren der korrekten Icon-Auswahl, Label-Text und CSS-Klassen.
* **Integration Tests:**
    * Starten der NovaDE.
    * Simulieren von Batteriezustandsänderungen (z.B. AC ein/aus, Batterie entleeren/laden).
    * Visuelle Inspektion, ob Icon, Prozentsatz und Zeit im Panel korrekt aktualisiert werden.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---

### **novade-ui/src/components/power_indicator/controller.rs**

**Verantwortlichkeit:**
Implementiert den `PowerIndicatorController`, der die logische Steuerung für den Energie-Indikator übernimmt. Er abonniert Events vom `PowerManagementService` der Systemschicht, um Änderungen am Batteriestatus zu erkennen und das UI-Widget entsprechend zu aktualisieren. Er steuert auch die Anzeige des detaillierten Energie-Popovers.

**Kern-Aufgaben (Tasks):**

1.  **`PowerIndicatorController` Struktur:**
    * Felder:
        * `power_management_service: Arc<PowerManagementService>`
        * `power_indicator_widget: Arc<PowerIndicator>` (Referenz auf das GTK-Widget selbst).
        * `power_details_popover: Arc<PowerDetailsPopover>` (Das Popover mit Details/Einstellungen).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>`.

2.  **`PowerIndicatorController::new()` Funktion:**
    * `pub fn new(power_management_service: Arc<PowerManagementService>) -> Result<Arc<Self>, PowerIndicatorError>`
    * Speichert die Referenz zum `power_management_service`.
    * Erstellt eine Instanz des `PowerIndicator` GTK-Widgets.
    * Erstellt eine Instanz des `PowerDetailsPopover`.
    * Verbindet das Klick-Signal des `power_indicator_widget`:
        * Bei Klick: `self.power_details_popover.show_popover_at_widget(&self.power_indicator_widget.get_widget());`
    * Speichert die Instanzen.

3.  **`PowerIndicatorController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt einen asynchronen Task (`glib::MainContext::spawn_local`) für den Event-Listener.
    * **Listener-Task für Batteriestatus-Änderungen:**
        * `let indicator = self.power_indicator_widget.clone();`
        * `let popover = self.power_details_popover.clone();`
        * `let mut battery_status_rx = self.power_management_service.subscribe_to_battery_status_changes();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `while let Ok(status) = battery_status_rx.recv().await {`
        * `indicator.update_status(&status);`
        * `popover.update_status(&status);` (Aktualisiert das Popover, auch wenn es nicht sichtbar ist)
        * `}`
        * `Ok(())`
        * `}));`
    * **Initialer Status-Update:** Ruft einmalig `power_management_service.get_current_battery_status()` auf und aktualisiert sowohl den Indikator als auch das Popover.

4.  **`PowerIndicatorController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

5.  **`PowerIndicatorController::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> Arc<PowerIndicator>`
    * Gibt die Referenz auf das `PowerIndicator` Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/power_indicator/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::power_indicator::power_indicator_widget::PowerIndicator`
    * `crate::components::power_indicator::power_details_popover::PowerDetailsPopover`
    * `crate::components::power_indicator::error::PowerIndicatorError`
    * `novade_system::power_management::service::PowerManagementService`
    * `novade_system::power_management::data_types::BatteryStatus`
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`

**Kommunikationsmuster:**

* **Initialisiert und verwaltet das `PowerIndicator` GTK-Widget und das `PowerDetailsPopover`.**
* **Abonniert Events vom `PowerManagementService` der Systemschicht.**
* **Aktualisiert den Zustand beider UI-Komponenten auf Basis empfangener Events.**
* **Öffnet das `PowerDetailsPopover` bei Klick auf den Indikator.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller Controller, der den Energie-Indikator und das Detail-Popover aktuell hält.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `PowerManagementService` (um `subscribe_to_battery_status_changes` und `get_current_battery_status` zu kontrollieren).
    * Mocken des `PowerIndicator` Widgets und des `PowerDetailsPopover` (um `update_status` und `show_popover_at_widget` zu verifizieren).
    * Testen der `new()`-Funktion: Verifizieren, dass Services, Indicator und Popover korrekt gespeichert und Signale verbunden werden.
    * Testen der `start_listeners()`: Simulieren von `battery_status_changes` Events und prüfen, ob `update_status` beider UI-Komponenten aufgerufen wird.
    * Testen des Klick-Handlings: Simulieren eines Klicks auf den Indicator und prüfen, ob `show_popover_at_widget` des Popovers aufgerufen wird.
* **Integration Tests:**
    * Starten der NovaDE.
    * Simulieren von Batteriezustandsänderungen (z.B. AC ein/aus, Batterie entleeren/laden).
    * Visuelle Inspektion, ob der Indikator im Panel korrekt aktualisiert wird und ob das Detail-Popover bei Klick korrekt erscheint und die richtigen Informationen anzeigt.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da Interaktion mit UPower D-Bus und Popover-Logik)

---

### **novade-ui/src/components/power_indicator/power_details_popover.rs**

**Verantwortlichkeit:**
Implementiert das `gtk::Popover` oder `gtk::Window`, das detaillierte Batterie-Informationen, Energiesparmodi und Optionen zum Herunterfahren/Neustarten/Sperren anzeigt.

**Kern-Aufgaben (Tasks):**

1.  **`PowerDetailsPopover` Struktur:**
    * Ist ein Wrapper um `gtk::Popover` oder `gtk::Window`.
    * Felder:
        * `container: gtk::Widget` (Das Popover/Window).
        * `battery_info_label: gtk::Label` (Zeigt detaillierte Infos: Zustand, Kapazität, Spannung).
        * `power_mode_combo: gtk::ComboBoxText` (Auswahl des Energiesparmodus: Performance, Balanced, Power Saver).
        * `shutdown_button: gtk::Button`.
        * `restart_button: gtk::Button`.
        * `suspend_button: gtk::Button`.
        * `lock_button: gtk::Button`.
        * `power_management_service: Arc<PowerManagementService>` (Direkte Referenz zur Interaktion).
        * `session_management_service: Arc<SessionManagementService>` (Für Sperren, Herunterfahren, Neustarten).

2.  **`PowerDetailsPopover::new()` Funktion:**
    * `pub fn new(power_management_service: Arc<PowerManagementService>, session_management_service: Arc<SessionManagementService>) -> Result<Self, PowerIndicatorError>`
    * Lädt die UI-Definition (`power_details_popover.ui`).
    * Initialisiert die Widgets und speichert die Service-Referenzen.
    * Befüllt `power_mode_combo` mit den unterstützten Energiesparmodi. Setzt den aktuellen Modus als ausgewählt.
    * **Verbindet Signale:**
        * `power_mode_combo.connect_changed()`: Bei Auswahl eines Modus: `power_management_service.set_power_mode(selected_mode)`.
        * `shutdown_button.connect_clicked()`: Ruft `session_management_service.shutdown()` auf (ggf. mit Bestätigungsdialog).
        * `restart_button.connect_clicked()`: Ruft `session_management_service.reboot()` auf (ggf. mit Bestätigungsdialog).
        * `suspend_button.connect_clicked()`: Ruft `session_management_service.suspend()` auf.
        * `lock_button.connect_clicked()`: Ruft `session_management_service.lock_screen()` auf.
    * Setzt CSS-Klassen "nova-power-details-popover".

3.  **`PowerDetailsPopover::update_status()` Methode:**
    * `pub fn update_status(&self, status: &BatteryStatus)`
    * Aktualisiert `battery_info_label` mit detaillierten Informationen (z.B. "Zustand: Laden, Restkapazität: 85%, Spannung: 12.3V").
    * Aktualisiert die Auswahl in `power_mode_combo` basierend auf `status.current_power_mode`.

4.  **`PowerDetailsPopover::show_popover_at_widget()` Methode:**
    * `pub fn show_popover_at_widget(&self, widget: &impl IsA<gtk::Widget>)`
    * Zeigt das Popover an.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/power_indicator/power_details_popover.rs`
* `novade-ui/resources/ui/power_details_popover.ui`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::power_indicator::error::PowerIndicatorError`
    * `novade_system::power_management::service::PowerManagementService`
    * `novade_system::power_management::data_types::BatteryStatus`
    * `novade_system::session_management::service::SessionManagementService` (für Shutdown/Restart/Suspend/Lock)
    * `novade_system::session_management::data_types::PowerAction` (für die Aktionen)
* **Extern:**
    * `gtk::{self, prelude::*, Popover, Window, Label, ComboBoxText, Button, glib, IsA, Widget}`
    * `std::sync::Arc`
    * `tokio` (für async-Aufrufe an Services)

**Kommunikationsmuster:**

* Wird vom `PowerIndicatorController` erstellt und angezeigt.
* Interagiert direkt mit dem `PowerManagementService` der Systemschicht, um Energiesparmodi zu setzen.
* Interagiert direkt mit dem `SessionManagementService` der Systemschicht, um Systemaktionen (Shutdown, Reboot, Suspend, Lock) auszuführen.
* Wird vom `PowerIndicatorController` aktualisiert, wenn sich der Batteriestatus ändert.

**Erwartete Ergebnisse/Outputs:**
Ein interaktives Popover, das detaillierte Energieverwaltung und Systemsteuerungsoptionen bietet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `PowerManagementService` und `SessionManagementService`.
    * Testen der `new()`-Funktion: Initialisierung der Widgets, Signal-Verbindungen.
    * Testen von `update_status()` mit verschiedenen `BatteryStatus` Werten.
    * Simulieren von ComboBox-Änderungen und Button-Klicks und Prüfen, ob die korrekten Aufrufe an die gemockten Services erfolgen.
* **Integration Tests:**
    * Starten der NovaDE.
    * Öffnen des Popovers.
    * Visuelle Inspektion der angezeigten Batterie-Informationen.
    * Testen der Auswahl von Energiesparmodi (wenn implementiert).
    * **Vorsicht bei Shutdown/Restart/Suspend/Lock-Tests:** Diese sollten in einer isolierten Testumgebung durchgeführt oder gemockt werden, um den Entwicklungsrechner nicht zu beeinträchtigen. Unit-Tests mit Mocking sind hier bevorzugt.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage, da komplexe UI für Einstellungen und kritische Systemaktionen)

---
### **novade-ui/src/components/network_indicator/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die den Netzwerk-Indikator im Panel bilden.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod network_indicator_widget;` (Das Panel-Widget)
    * `pub mod controller;` (Der Controller, der die Logik verwaltet)
    * `pub mod error;` (Fehler-Enum für das Modul)
    * `pub mod network_details_popover;` (Das Popover für detaillierte Netzwerk-Informationen und -Einstellungen)

2.  **Re-Exporte (`pub use`):**
    * `pub use network_indicator_widget::NetworkIndicator;`
    * `pub use controller::NetworkIndicatorController;`
    * `pub use error::NetworkIndicatorError;`
    * `pub use network_details_popover::NetworkDetailsPopover;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* Wird von `Panel` verwendet.
* `UiServices` initialisiert den Controller.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für den Netzwerk-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/network_indicator/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`NetworkIndicatorError`) für das Netzwerk-Indikator-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkIndicatorError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `SystemServiceError(#[from] novade_system::SystemServiceError)`: Fehler von der Systemschicht (z.B. von NetworkManager D-Bus).
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_system::SystemServiceError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `network_indicator`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für den Netzwerk-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `NetworkIndicatorError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/network_indicator/network_indicator_widget.rs**

**Verantwortlichkeit:**
Implementiert das GTK-Widget für den Netzwerk-Indikator, der den aktuellen Verbindungsstatus (WLAN, Ethernet, kein Netzwerk) anzeigt.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkIndicator` Struktur:**
    * Ist ein Wrapper um `gtk::Button` oder `gtk::Box`.
    * Felder:
        * `container: gtk::Box` (oder `gtk::Button`).
        * `icon: gtk::Image` (Netzwerk-Icon, z.B. `network-wireless-signal-good-symbolic`, `network-wired-symbolic`, `network-disconnected-symbolic`).
        * `network_name_label: gtk::Label` (Optional: Name des verbundenen Netzwerks, z.B. SSID für WLAN).

2.  **`NetworkIndicator::new()` Funktion:**
    * `pub fn new() -> Result<Self, NetworkIndicatorError>`
    * Erstellt die `gtk::Box` und die Kind-Widgets (`icon`, `network_name_label`).
    * Ordnet sie im `container` an.
    * Setzt CSS-Klassen "nova-network-indicator".
    * Initialisiert den Status als unbekannt/Standard (z.B. ein disconnected Icon).

3.  **`NetworkIndicator::update_status()` Methode:**
    * `pub fn update_status(&self, status: &NetworkStatus)`
    * Empfängt ein `NetworkStatus` Objekt von der Systemschicht.
    * Wählt das korrekte `icon` basierend auf `status.connection_type`, `status.strength` (für WLAN) und `status.is_connected` (z.B. `network-wireless-signal-good-symbolic` wenn verbunden und starkes Signal, `network-wired-symbolic` für Ethernet, `network-disconnected-symbolic` wenn nicht verbunden).
    * Aktualisiert `network_name_label` mit `status.network_name`.
    * Fügt/entfernt CSS-Klassen basierend auf dem Status (z.B. "network-connected", "network-disconnected", "network-wireless", "network-wired").

4.  **`NetworkIndicator::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/network_indicator_widget.rs`
* `novade-ui/resources/ui/network_indicator.ui` (optional)

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::network_indicator::error::NetworkIndicatorError`
    * `novade_system::network_management::data_types::NetworkStatus`
* **Extern:** `gtk::{self, prelude::*, Box, Button, Image, Label, glib, Widget}`

**Kommunikationsmuster:**

* Wird von `Panel` instanziiert.
* Wird vom `NetworkIndicatorController` aktualisiert.
* Emittiert Klick-Events, die vom `NetworkIndicatorController` verarbeitet werden, um das Detail-Popover zu öffnen.

**Erwartete Ergebnisse/Outputs:**
Ein funktionaler Netzwerk-Indikator im Panel, der den aktuellen Netzwerkstatus anzeigt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion: Initialisierung der Widgets, CSS-Klassen.
    * Testen von `update_status()` mit verschiedenen `NetworkStatus` Werten:
        * Verschiedene Verbindungstypen (WLAN, Ethernet, Mobile).
        * Verschiedene Signalstärken (für WLAN).
        * Verbunden/Nicht verbunden.
        * Verifizieren der korrekten Icon-Auswahl, Label-Text und CSS-Klassen.
* **Integration Tests:**
    * Starten der NovaDE.
    * Ändern des Netzwerkstatus (z.B. WLAN ein/aus, Kabel ein/aus).
    * Visuelle Inspektion, ob Icon und Text im Panel korrekt aktualisiert werden.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---

### **novade-ui/src/components/network_indicator/controller.rs**

**Verantwortlichkeit:**
Implementiert den `NetworkIndicatorController`, der die logische Steuerung für den Netzwerk-Indikator übernimmt. Er abonniert Events vom `NetworkManagementService` der Systemschicht, um Änderungen am Netzwerkstatus zu erkennen und das UI-Widget entsprechend zu aktualisieren. Er steuert auch die Anzeige des detaillierten Netzwerk-Popovers.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkIndicatorController` Struktur:**
    * Felder:
        * `network_management_service: Arc<NetworkManagementService>`
        * `network_indicator_widget: Arc<NetworkIndicator>` (Referenz auf das GTK-Widget selbst).
        * `network_details_popover: Arc<NetworkDetailsPopover>` (Das Popover mit Details/Einstellungen).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>`.

2.  **`NetworkIndicatorController::new()` Funktion:**
    * `pub fn new(network_management_service: Arc<NetworkManagementService>) -> Result<Arc<Self>, NetworkIndicatorError>`
    * Speichert die Referenz zum `network_management_service`.
    * Erstellt eine Instanz des `NetworkIndicator` GTK-Widgets.
    * Erstellt eine Instanz des `NetworkDetailsPopover`.
    * Verbindet das Klick-Signal des `network_indicator_widget`:
        * Bei Klick: `self.network_details_popover.show_popover_at_widget(&self.network_indicator_widget.get_widget());`
    * Speichert die Instanzen.

3.  **`NetworkIndicatorController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt einen asynchronen Task (`glib::MainContext::spawn_local`) für den Event-Listener.
    * **Listener-Task für Netzwerkstatus-Änderungen:**
        * `let indicator = self.network_indicator_widget.clone();`
        * `let popover = self.network_details_popover.clone();`
        * `let mut network_status_rx = self.network_management_service.subscribe_to_network_status_changes();`
        * `let mut available_networks_rx = self.network_management_service.subscribe_to_available_networks_changes();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `loop {`
        * `tokio::select! {`
        * `Ok(status) = network_status_rx.recv() => {`
        * `indicator.update_status(&status);`
        * `popover.update_status(&status);`
        * `},`
        * `Ok(networks) = available_networks_rx.recv() => {`
        * `popover.update_available_networks(&networks);`
        * `},`
        * `_ = futures::future::pending() => break, // Keep the task alive`
        * `}`
        * `}`
        * `Ok(())`
        * `}));`
    * **Initialer Status-Update:** Ruft einmalig `network_management_service.get_current_network_status()` und `network_management_service.get_available_networks()` auf und aktualisiert sowohl den Indikator als auch das Popover.

4.  **`NetworkIndicatorController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

5.  **`NetworkIndicatorController::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> Arc<NetworkIndicator>`
    * Gibt die Referenz auf das `NetworkIndicator` Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::network_indicator::network_indicator_widget::NetworkIndicator`
    * `crate::components::network_indicator::network_details_popover::NetworkDetailsPopover`
    * `crate::components::network_indicator::error::NetworkIndicatorError`
    * `novade_system::network_management::service::NetworkManagementService`
    * `novade_system::network_management::data_types::{NetworkStatus, NetworkInfo}`
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`

**Kommunikationsmuster:**

* **Initialisiert und verwaltet das `NetworkIndicator` GTK-Widget und das `NetworkDetailsPopover`.**
* **Abonniert Events vom `NetworkManagementService` der Systemschicht (Statusänderungen, verfügbare Netzwerke).**
* **Aktualisiert den Zustand beider UI-Komponenten auf Basis empfangener Events.**
* **Öffnet das `NetworkDetailsPopover` bei Klick auf den Indikator.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller Controller, der den Netzwerk-Indikator und das Detail-Popover aktuell hält.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NetworkManagementService` (um `subscribe_to_network_status_changes`, `subscribe_to_available_networks_changes`, `get_current_network_status`, `get_available_networks` zu kontrollieren).
    * Mocken des `NetworkIndicator` Widgets und des `NetworkDetailsPopover` (um `update_status`, `update_available_networks`, `show_popover_at_widget` zu verifizieren).
    * Testen der `new()`-Funktion: Verifizieren, dass Services, Indicator und Popover korrekt gespeichert und Signale verbunden werden.
    * Testen der `start_listeners()`: Simulieren von `network_status_changes` und `available_networks_changes` Events und prüfen, ob `update_status` / `update_available_networks` beider UI-Komponenten aufgerufen wird.
    * Testen des Klick-Handlings: Simulieren eines Klicks auf den Indicator und prüfen, ob `show_popover_at_widget` des Popovers aufgerufen wird.
* **Integration Tests:**
    * Starten der NovaDE.
    * Ändern des Netzwerkstatus (z.B. WLAN aus-/einschalten, mit verschiedenen Netzwerken verbinden).
    * Visuelle Inspektion, ob der Indikator im Panel korrekt aktualisiert wird und ob das Detail-Popover bei Klick korrekt erscheint und die richtigen Informationen anzeigt (verfügbare Netzwerke, Verbindungsinformationen).

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da Interaktion mit NetworkManager D-Bus und komplexe Popover-Logik)

---

### **novade-ui/src/components/network_indicator/network_details_popover.rs**

**Verantwortlichkeit:**
Implementiert das `gtk::Popover` oder `gtk::Window`, das detaillierte Netzwerk-Informationen, verfügbare WLAN-Netzwerke, Verbindungs-/Trennoptionen und möglicherweise eine Schnittstelle zu den Netzwerkeinstellungen des Systems anzeigt.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkDetailsPopover` Struktur:**
    * Ist ein Wrapper um `gtk::Popover` oder `gtk::Window`.
    * Felder:
        * `container: gtk::Widget` (Das Popover/Window).
        * `current_connection_label: gtk::Label` (Zeigt aktuellen Verbindungsnamen und Status).
        * `connection_toggle_button: gtk::Switch` (Ein/Aus-Schalter für WLAN/Mobilfunk).
        * `wifi_list_box: gtk::ListBox` (Liste der verfügbaren WLAN-Netzwerke).
        * `ethernet_status_label: gtk::Label` (Status für Ethernet).
        * `open_settings_button: gtk::Button` (Button zum Öffnen der vollständigen Netzwerkeinstellungen).
        * `network_management_service: Arc<NetworkManagementService>` (Direkte Referenz zur Interaktion).

2.  **`NetworkDetailsPopover::new()` Funktion:**
    * `pub fn new(network_management_service: Arc<NetworkManagementService>) -> Result<Self, NetworkIndicatorError>`
    * Lädt die UI-Definition (`network_details_popover.ui`).
    * Initialisiert die Widgets und speichert die `network_management_service` Referenz.
    * Setzt Initialzustände für Labels und Toggle-Button basierend auf `network_management_service.get_current_network_status()`.
    * **Verbindet Signale:**
        * `connection_toggle_button.connect_state_set()`: Bei Toggle: `network_management_service.set_radio_enabled(is_enabled, NetworkType::Wifi)` oder `NetworkType::Mobile`.
        * Für jeden `gtk::ListBoxRow` in `wifi_list_box` (wenn ein WLAN-Netzwerk ausgewählt wird): `network_management_service.connect_to_network(network_id)`.
        * `open_settings_button.connect_clicked()`: Öffnet die System-Netzwerkeinstellungen über XDG Desktop Portal oder direkten D-Bus-Aufruf (z.B. an Gnome Control Center oder KDE System Settings).
    * Setzt CSS-Klassen "nova-network-details-popover".

3.  **`NetworkDetailsPopover::update_status()` Methode:**
    * `pub fn update_status(&self, status: &NetworkStatus)`
    * Aktualisiert `current_connection_label` (z.B. "Verbunden mit 'MeinWLAN' (80%)" oder "Ethernet verbunden").
    * Aktualisiert den Zustand von `connection_toggle_button` (ein/aus basierend auf globalem WLAN/Mobilfunk-Status).
    * Aktualisiert `ethernet_status_label` entsprechend.
    * Hebt das aktuell verbundene WLAN-Netzwerk in `wifi_list_box` hervor.

4.  **`NetworkDetailsPopover::update_available_networks()` Methode:**
    * `pub async fn update_available_networks(&self, networks: Vec<NetworkInfo>)`
    * Leert die `wifi_list_box`.
    * Fügt für jedes `NetworkInfo` (insbesondere WLAN-Netzwerke) einen `gtk::ListBoxRow` hinzu.
        * Jeder Row sollte den Namen (SSID) und ein Signalstärke-Icon enthalten.
        * Handhabt sichtbare/versteckte Netzwerke.
        * Markiert den aktuell verbundenen Netzwerk-Eintrag.
        * Setzt das `row-activated` Signal für jede Reihe, um eine Verbindung herzustellen.

5.  **`NetworkDetailsPopover::show_popover_at_widget()` Methode:**
    * `pub fn show_popover_at_widget(&self, widget: &impl IsA<gtk::Widget>)`
    * Zeigt das Popover an.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/network_details_popover.rs`
* `novade-ui/resources/ui/network_details_popover.ui`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::network_indicator::error::NetworkIndicatorError`
    * `novade_system::network_management::service::NetworkManagementService`
    * `novade_system::network_management::data_types::{NetworkStatus, NetworkInfo, NetworkType}`
* **Extern:**
    * `gtk::{self, prelude::*, Popover, Window, Label, Switch, ListBox, ListBoxRow, Button, Image, glib, IsA, Widget}`
    * `std::sync::Arc`
    * `tokio` (für async-Aufrufe an `NetworkManagementService`)
    * `zbus` (für D-Bus-Aufrufe an XDG Desktop Portal für Einstellungen)

**Kommunikationsmuster:**

* Wird vom `NetworkIndicatorController` erstellt und angezeigt.
* Interagiert direkt mit dem `NetworkManagementService` der Systemschicht, um Netzwerkaktionen auszuführen (WLAN ein/aus, Verbindung herstellen/trennen).
* Kann über XDG Desktop Portals mit dem System interagieren, um die vollständigen Netzwerkeinstellungen zu öffnen.
* Wird vom `NetworkIndicatorController` aktualisiert, wenn sich der Netzwerkstatus oder die Liste der verfügbaren Netzwerke ändert.

**Erwartete Ergebnisse/Outputs:**
Ein interaktives Popover, das detaillierte Netzwerkverwaltung ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NetworkManagementService`.
    * Testen der `new()`-Funktion: Initialisierung der Widgets, Signal-Verbindungen.
    * Testen von `update_status()` mit verschiedenen `NetworkStatus` Werten.
    * Testen von `update_available_networks()`: Korrektes Befüllen der WLAN-Liste mit SSID und Signalstärke, Hervorhebung des verbundenen Netzwerks.
    * Simulieren von Toggle-Änderungen, Button-Klicks und ListBox-Auswahlen und Prüfen, ob die korrekten Aufrufe an den gemockten `NetworkManagementService` erfolgen.
* **Integration Tests:**
    * Starten der NovaDE.
    * Öffnen des Popovers.
    * Visuelle Inspektion der angezeigten Informationen und verfügbaren Netzwerke.
    * Testen des WLAN-Ein-/Ausschaltens.
    * Testen des Verbindungsaufbaus zu einem WLAN-Netzwerk (wenn Test-SSID verfügbar).
    * Testen des Klicks auf den "Einstellungen öffnen"-Button und Verifizieren, dass die Systemeinstellungen geöffnet werden.

**Geschätzter Aufwand:** Hoch (ca. 6-8 Tage, da komplexe UI für WLAN-Listen, Passworteingabe (falls in Popover integriert) und Interaktion mit NetworkManager D-Bus)

---
### **novade-ui/src/components/media_player_indicator/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die den Medienplayer-Indikator im Panel bilden.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod media_player_indicator_widget;` (Das Panel-Widget)
    * `pub mod controller;` (Der Controller, der die Logik verwaltet)
    * `pub mod error;` (Fehler-Enum für das Modul)
    * `pub mod media_controls_popover;` (Das Popover für Mediensteuerungen und Song-Informationen)

2.  **Re-Exporte (`pub use`):**
    * `pub use media_player_indicator_widget::MediaPlayerIndicator;`
    * `pub use controller::MediaPlayerIndicatorController;`
    * `pub use error::MediaPlayerIndicatorError;`
    * `pub use media_controls_popover::MediaControlsPopover;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/media_player_indicator/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* Wird von `Panel` verwendet.
* `UiServices` initialisiert den Controller.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für den Medienplayer-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/media_player_indicator/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`MediaPlayerIndicatorError`) für das Medienplayer-Indikator-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`MediaPlayerIndicatorError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `SystemServiceError(#[from] novade_system::SystemServiceError)`: Fehler von der Systemschicht (z.B. MPRIS D-Bus).
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/media_player_indicator/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_system::SystemServiceError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `media_player_indicator`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für den Medienplayer-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `MediaPlayerIndicatorError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/media_player_indicator/media_player_indicator_widget.rs**

**Verantwortlichkeit:**
Implementiert das GTK-Widget für den Medienplayer-Indikator, der das Abspiel-Icon und optional den aktuell spielenden Titel oder Künstler im Panel anzeigt.

**Kern-Aufgaben (Tasks):**

1.  **`MediaPlayerIndicator` Struktur:**
    * Ist ein Wrapper um `gtk::Button` oder `gtk::Box`.
    * Felder:
        * `container: gtk::Box` (oder `gtk::Button`).
        * `icon: gtk::Image` (Play/Pause/Stop-Icon, oder spezifisches Player-Icon).
        * `title_label: gtk::Label` (Optional: Titel des aktuellen Tracks).
        * `artist_label: gtk::Label` (Optional: Künstler des aktuellen Tracks).

2.  **`MediaPlayerIndicator::new()` Funktion:**
    * `pub fn new() -> Result<Self, MediaPlayerIndicatorError>`
    * Erstellt die `gtk::Box` und die Kind-Widgets (`icon`, `title_label`, `artist_label`).
    * Ordnet sie im `container` an.
    * Setzt CSS-Klassen "nova-media-player-indicator".
    * Initialisiert den Status als nicht spielend (z.B. ein leeres Play-Icon).

3.  **`MediaPlayerIndicator::update_status()` Methode:**
    * `pub fn update_status(&self, status: &MediaPlayerStatus)`
    * Empfängt ein `MediaPlayerStatus` Objekt von der Systemschicht.
    * Wählt das korrekte `icon` basierend auf `status.playback_status` (z.B. `media-playback-start-symbolic` für Play, `media-playback-pause-symbolic` für Pause, `media-playback-stop-symbolic` für Stop).
    * Aktualisiert `title_label` mit `status.title` und `artist_label` mit `status.artist`. Zeigt diese Labels nur an, wenn ein Track aktiv ist.
    * Fügt/entfernt CSS-Klassen basierend auf dem Status (z.B. "media-playing", "media-paused").
    * Setzt die Sichtbarkeit des gesamten Widgets, wenn kein Medienplayer aktiv ist oder keine Medien spielen.

4.  **`MediaPlayerIndicator::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/media_player_indicator/media_player_indicator_widget.rs`
* `novade-ui/resources/ui/media_player_indicator.ui` (optional)

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::media_player_indicator::error::MediaPlayerIndicatorError`
    * `novade_system::media_player_management::data_types::MediaPlayerStatus`
* **Extern:** `gtk::{self, prelude::*, Box, Button, Image, Label, glib, Widget}`

**Kommunikationsmuster:**

* Wird von `Panel` instanziiert.
* Wird vom `MediaPlayerIndicatorController` aktualisiert.
* Emittiert Klick-Events, die vom `MediaPlayerIndicatorController` verarbeitet werden, um das Steuerungs-Popover zu öffnen.

**Erwartete Ergebnisse/Outputs:**
Ein funktionaler Medienplayer-Indikator im Panel, der den aktuellen Abspielstatus anzeigt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion: Initialisierung der Widgets, CSS-Klassen.
    * Testen von `update_status()` mit verschiedenen `MediaPlayerStatus` Werten:
        * Spielt, pausiert, gestoppt.
        * Verschiedene Titel/Künstler.
        * Keine Medien aktiv.
        * Verifizieren der korrekten Icon-Auswahl, Label-Text und Sichtbarkeit.
* **Integration Tests:**
    * Starten der NovaDE.
    * Starten eines MPRIS-kompatiblen Medienplayers (z.B. Spotify, VLC, Rhythmbox).
    * Abspielen/Pausieren/Stoppen von Medien.
    * Visuelle Inspektion, ob Icon, Titel und Künstler im Panel korrekt aktualisiert werden.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---

### **novade-ui/src/components/media_player_indicator/controller.rs**

**Verantwortlichkeit:**
Implementiert den `MediaPlayerIndicatorController`, der die logische Steuerung für den Medienplayer-Indikator übernimmt. Er abonniert Events vom `MediaPlayerManagementService` der Systemschicht, um Änderungen am Medienplayer-Status zu erkennen und das UI-Widget sowie das Steuerungs-Popover entsprechend zu aktualisieren. Er leitet auch Steuerungsbefehle an die Systemschicht weiter.

**Kern-Aufgaben (Tasks):**

1.  **`MediaPlayerIndicatorController` Struktur:**
    * Felder:
        * `media_player_management_service: Arc<MediaPlayerManagementService>`
        * `media_player_indicator_widget: Arc<MediaPlayerIndicator>` (Referenz auf das GTK-Widget selbst).
        * `media_controls_popover: Arc<MediaControlsPopover>` (Das Popover mit Steuerungen).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>`.

2.  **`MediaPlayerIndicatorController::new()` Funktion:**
    * `pub fn new(media_player_management_service: Arc<MediaPlayerManagementService>) -> Result<Arc<Self>, MediaPlayerIndicatorError>`
    * Speichert die Referenz zum `media_player_management_service`.
    * Erstellt eine Instanz des `MediaPlayerIndicator` GTK-Widgets.
    * Erstellt eine Instanz des `MediaControlsPopover`.
    * Verbindet das Klick-Signal des `media_player_indicator_widget`:
        * Bei Klick: `self.media_controls_popover.show_popover_at_widget(&self.media_player_indicator_widget.get_widget());`
    * Speichert die Instanzen.

3.  **`MediaPlayerIndicatorController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt einen asynchronen Task (`glib::MainContext::spawn_local`) für den Event-Listener.
    * **Listener-Task für Medienplayer-Status-Änderungen:**
        * `let indicator = self.media_player_indicator_widget.clone();`
        * `let popover = self.media_controls_popover.clone();`
        * `let service_clone = self.media_player_management_service.clone();`
        * `let mut media_status_rx = service_clone.subscribe_to_media_player_status_changes();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `while let Ok(status) = media_status_rx.recv().await {`
        * `indicator.update_status(&status);`
        * `popover.update_status(&status);` (Aktualisiert das Popover, auch wenn es nicht sichtbar ist)
        * `}`
        * `Ok(())`
        * `}));`
    * **Initialer Status-Update:** Ruft einmalig `media_player_management_service.get_current_media_player_status()` auf und aktualisiert sowohl den Indikator als auch das Popover.

4.  **`MediaPlayerIndicatorController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

5.  **`MediaPlayerIndicatorController::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> Arc<MediaPlayerIndicator>`
    * Gibt die Referenz auf das `MediaPlayerIndicator` Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/media_player_indicator/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::media_player_indicator::media_player_indicator_widget::MediaPlayerIndicator`
    * `crate::components::media_player_indicator::media_controls_popover::MediaControlsPopover`
    * `crate::components::media_player_indicator::error::MediaPlayerIndicatorError`
    * `novade_system::media_player_management::service::MediaPlayerManagementService`
    * `novade_system::media_player_management::data_types::MediaPlayerStatus`
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`

**Kommunikationsmuster:**

* **Initialisiert und verwaltet das `MediaPlayerIndicator` GTK-Widget und das `MediaControlsPopover`.**
* **Abonniert Events vom `MediaPlayerManagementService` der Systemschicht.**
* **Aktualisiert den Zustand beider UI-Komponenten auf Basis empfangener Events.**
* **Öffnet das `MediaControlsPopover` bei Klick auf den Indikator.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller Controller, der den Medienplayer-Indikator und das Detail-Popover aktuell hält.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `MediaPlayerManagementService` (um `subscribe_to_media_player_status_changes` und `get_current_media_player_status` zu kontrollieren).
    * Mocken des `MediaPlayerIndicator` Widgets und des `MediaControlsPopover` (um `update_status` und `show_popover_at_widget` zu verifizieren).
    * Testen der `new()`-Funktion: Verifizieren, dass Services, Indicator und Popover korrekt gespeichert und Signale verbunden werden.
    * Testen der `start_listeners()`: Simulieren von `media_player_status_changes` Events und prüfen, ob `update_status` beider UI-Komponenten aufgerufen wird.
    * Testen des Klick-Handlings: Simulieren eines Klicks auf den Indicator und prüfen, ob `show_popover_at_widget` des Popovers aufgerufen wird.
* **Integration Tests:**
    * Starten der NovaDE.
    * Starten eines MPRIS-kompatiblen Medienplayers.
    * Abspielen/Pausieren/Stoppen von Medien, Wechseln von Tracks.
    * Visuelle Inspektion, ob der Indikator im Panel korrekt aktualisiert wird und ob das Steuerungs-Popover bei Klick korrekt erscheint und die richtigen Informationen anzeigt und Steuerungsbefehle übermittelt.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da Interaktion mit MPRIS D-Bus und Popover-Logik)

---

### **novade-ui/src/components/media_player_indicator/media_controls_popover.rs**

**Verantwortlichkeit:**
Implementiert das `gtk::Popover` oder `gtk::Window`, das detaillierte Medieninformationen (Album-Cover, Titel, Künstler, Player-Name) und Steuerungsbuttons (Play/Pause, Nächstes, Vorheriges) anzeigt.

**Kern-Aufgaben (Tasks):**

1.  **`MediaControlsPopover` Struktur:**
    * Ist ein Wrapper um `gtk::Popover` oder `gtk::Window`.
    * Felder:
        * `container: gtk::Widget` (Das Popover/Window).
        * `album_art_image: gtk::Image` (Optional: Für Album-Cover).
        * `title_label: gtk::Label`.
        * `artist_album_label: gtk::Label` (Künstler und Album).
        * `player_name_label: gtk::Label` (Name des Medienplayers, z.B. "Spotify").
        * `seek_slider: Option<gtk::Scale>` (Optional: Abspielposition-Slider).
        * `previous_button: gtk::Button`.
        * `play_pause_button: gtk::Button`.
        * `next_button: gtk::Button`.
        * `media_player_management_service: Arc<MediaPlayerManagementService>` (Direkte Referenz zur Interaktion).

2.  **`MediaControlsPopover::new()` Funktion:**
    * `pub fn new(media_player_management_service: Arc<MediaPlayerManagementService>) -> Result<Self, MediaPlayerIndicatorError>`
    * Lädt die UI-Definition (`media_controls_popover.ui`).
    * Initialisiert die Widgets und speichert die `media_player_management_service` Referenz.
    * Setzt Initialzustände für Labels und Buttons.
    * **Verbindet Signale:**
        * `previous_button.connect_clicked()`: Ruft `media_player_management_service.previous_track()` auf.
        * `play_pause_button.connect_clicked()`: Ruft `media_player_management_service.toggle_play_pause()` auf.
        * `next_button.connect_clicked()`: Ruft `media_player_management_service.next_track()` auf.
        * `seek_slider.connect_change_value()`: Ruft `media_player_management_service.set_position(new_position)` auf.
    * Setzt CSS-Klassen "nova-media-controls-popover".

3.  **`MediaControlsPopover::update_status()` Methode:**
    * `pub fn update_status(&self, status: &MediaPlayerStatus)`
    * Aktualisiert `title_label`, `artist_album_label`, `player_name_label`.
    * Aktualisiert das Icon und die Beschriftung von `play_pause_button` basierend auf `status.playback_status`.
    * Wenn `status.album_art_url` vorhanden, lädt und zeigt das Album-Cover in `album_art_image` an (ggf. asynchron).
    * Aktualisiert den Wert von `seek_slider` und dessen Bereich (`status.length_in_ms`, `status.position_in_ms`). Macht den Slider sensitiv/insensitiv basierend auf `status.can_seek`.
    * Zeigt/versteckt das Popover, wenn kein Medienplayer aktiv ist oder keine Medien spielen.

4.  **`MediaControlsPopover::show_popover_at_widget()` Methode:**
    * `pub fn show_popover_at_widget(&self, widget: &impl IsA<gtk::Widget>)`
    * Zeigt das Popover an.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/media_player_indicator/media_controls_popover.rs`
* `novade-ui/resources/ui/media_controls_popover.ui`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::media_player_indicator::error::MediaPlayerIndicatorError`
    * `novade_system::media_player_management::service::MediaPlayerManagementService`
    * `novade_system::media_player_management::data_types::MediaPlayerStatus`
* **Extern:**
    * `gtk::{self, prelude::*, Popover, Window, Label, Image, Button, Scale, glib, IsA, Widget}`
    * `std::sync::Arc`
    * `tokio` (für async-Aufrufe an `MediaPlayerManagementService` und Bildladen)
    * `gdk_pixbuf` (für Bildladen von URLs)

**Kommunikationsmuster:**

* Wird vom `MediaPlayerIndicatorController` erstellt und angezeigt.
* Interagiert direkt mit dem `MediaPlayerManagementService` der Systemschicht, um Mediensteuerungsbefehle zu senden (Play/Pause, Nächstes, Vorheriges, Seek).
* Wird vom `MediaPlayerIndicatorController` aktualisiert, wenn sich der Medienplayer-Status ändert.

**Erwartete Ergebnisse/Outputs:**
Ein interaktives Popover, das detaillierte Medieninformationen und Steuerungen bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `MediaPlayerManagementService`.
    * Testen der `new()`-Funktion: Initialisierung der Widgets, Signal-Verbindungen.
    * Testen von `update_status()` mit verschiedenen `MediaPlayerStatus` Werten:
        * Verschiedene Spielzustände, Titel, Künstler.
        * Mit und ohne Album-Cover URL.
        * Mit und ohne Suchfunktionalität (`can_seek`).
        * Verifizieren der korrekten Label-Texte, Button-Icons und Slider-Zustände.
    * Simulieren von Button-Klicks und Slider-Bewegungen und Prüfen, ob die korrekten Aufrufe an den gemockten `MediaPlayerManagementService` erfolgen.
* **Integration Tests:**
    * Starten der NovaDE.
    * Starten eines MPRIS-kompatiblen Medienplayers.
    * Öffnen des Popovers.
    * Visuelle Inspektion der angezeigten Medieninformationen und Steuerungen.
    * Testen aller Steuerungsbuttons (Play/Pause, Nächstes, Vorheriges) und des Sliders (wenn implementiert).
    * Testen mit verschiedenen Playern, die unterschiedliche MPRIS-Fähigkeiten unterstützen.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage, da Album-Cover-Laden, Slider-Interaktion und Interaktion mit MPRIS D-Bus)

---
### **novade-ui/src/components/notifications/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die das Benachrichtigungssystem im Panel und auf dem Desktop bilden.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod notification_widget;` (Ein einzelnes GTK-Widget zur Anzeige einer Benachrichtigung)
    * `pub mod notification_center;` (Das Popover/Side-Panel, das alle Benachrichtigungen listet)
    * `pub mod controller;` (Der Controller, der die Logik verwaltet und mit dem `NotificationService` interagiert)
    * `pub mod error;` (Fehler-Enum für das Modul)
    * `pub mod notification_toast;` (Temporäre, kurzlebige Benachrichtigungs-Popups am Bildschirmrand)

2.  **Re-Exporte (`pub use`):**
    * `pub use notification_widget::NotificationWidget;`
    * `pub use notification_center::NotificationCenter;`
    * `pub use controller::NotificationController;`
    * `pub use error::NotificationUiError;`
    * `pub use notification_toast::NotificationToast;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/notifications/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* `NotificationController` wird von `UiServices` initialisiert.
* `NotificationCenter` und `NotificationToast` werden vom Controller verwaltet.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für das Benachrichtigungssystem.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/notifications/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`NotificationUiError`) für das Benachrichtigungs-UI-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationUiError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `DomainServiceError(#[from] novade_domain::notification_management::error::NotificationError)`: Fehler von der Domänenschicht (`NotificationService`).
        * `SystemError(String)`: Allgemeine Fehler bei Systeminteraktionen.
        * `InvalidIconPath(String)`: Fehler beim Laden eines Icons.
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/notifications/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_domain::notification_management::error::NotificationError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `notifications`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für das Benachrichtigungs-UI.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `NotificationUiError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/notifications/notification_widget.rs**

**Verantwortlichkeit:**
Implementiert ein einzelnes GTK-Widget zur Darstellung einer einzelnen Benachrichtigung (für Toasts und das Notification Center).

**Kern-Aufgaben (Tasks):**

1.  **`NotificationWidget` Struktur:**
    * Ist ein Wrapper um `gtk::Box` oder `gtk::Grid`.
    * Felder:
        * `container: gtk::Box`.
        * `app_icon: gtk::Image` (Anwendungssymbol).
        * `app_name_label: gtk::Label` (Name der sendenden Anwendung).
        * `summary_label: gtk::Label` (Kurze Überschrift der Benachrichtigung).
        * `body_label: gtk::Label` (Detaillierter Nachrichtentext).
        * `timestamp_label: gtk::Label` (Zeitstempel der Benachrichtigung).
        * `actions_box: gtk::Box` (Container für Aktionsbuttons).
        * `close_button: gtk::Button` (Schaltfläche zum Schließen der Benachrichtigung).
        * `notification_id: u32` (ID der Benachrichtigung).
        * `action_callback: RefCell<Option<Box<dyn Fn(u32, String)>>>` (Callback für Aktions-Klicks).
        * `close_callback: RefCell<Option<Box<dyn Fn(u32)>>>` (Callback für Schließen).

2.  **`NotificationWidget::new()` Funktion:**
    * `pub fn new() -> Result<Self, NotificationUiError>`
    * Lädt die UI-Definition (z.B. aus `notification_widget.ui`).
    * Initialisiert die Widgets.
    * Setzt CSS-Klassen "nova-notification-widget".
    * Fügt einen Close-Button hinzu und verbindet sein `clicked` Signal.

3.  **`NotificationWidget::update_notification()` Methode:**
    * `pub fn update_notification(&self, notification: &Notification)`
    * Empfängt ein `Notification` Objekt von der Domänenschicht.
    * Setzt `notification_id`.
    * Aktualisiert `app_icon` (lädt Icon basierend auf `notification.app_icon`).
    * Aktualisiert `app_name_label` mit `notification.app_name`.
    * Aktualisiert `summary_label` mit `notification.summary`.
    * Aktualisiert `body_label` mit `notification.body`.
    * Formatiert und aktualisiert `timestamp_label` mit `notification.timestamp`.
    * Löscht alte Aktionsbuttons und fügt neue hinzu basierend auf `notification.actions`:
        * Für jede Aktion einen `gtk::Button` erstellen.
        * Button-Text setzen.
        * `clicked` Signal verbinden, um `action_callback` mit der `notification_id` und `action_key` aufzurufen.

4.  **`NotificationWidget::set_action_callback()` Methode:**
    * `pub fn set_action_callback<F>(&self, callback: F)`
    * `where F: Fn(u32, String) + 'static`
    * Speichert den Callback, der aufgerufen wird, wenn ein Aktionsbutton geklickt wird.

5.  **`NotificationWidget::set_close_callback()` Methode:**
    * `pub fn set_close_callback<F>(&self, callback: F)`
    * `where F: Fn(u32) + 'static`
    * Speichert den Callback, der aufgerufen wird, wenn der Schließen-Button oder das Widget selbst geschlossen wird.

6.  **`NotificationWidget::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/notifications/notification_widget.rs`
* `novade-ui/resources/ui/notification_widget.ui`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::notifications::error::NotificationUiError`
    * `novade_domain::notification_management::data_types::Notification`
* **Extern:**
    * `gtk::{self, prelude::*, Box, Button, Image, Label, glib, Widget}`
    * `gdk_pixbuf` (für Icon-Laden)
    * `std::cell::RefCell`

**Kommunikationsmuster:**

* Wird von `NotificationToast` und `NotificationCenter` instanziiert.
* Empfängt `Notification` Daten und rendert sie.
* Emittiert Klick-Events für Aktionen und Schließen.

**Erwartete Ergebnisse/Outputs:**
Ein visuell ansprechendes und funktionales Widget zur Anzeige einzelner Benachrichtigungen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion: Initialisierung der Widgets, CSS-Klassen.
    * Testen von `update_notification()` mit verschiedenen `Notification` Daten:
        * Benachrichtigungen ohne Aktionen, mit einer Aktion, mit mehreren Aktionen.
        * Lange/kurze Texte, verschiedene Icon-Pfade.
        * Verifizieren der korrekten Label-Texte, Icon-Anzeige und Button-Generierung.
    * Simulieren von Klicks auf Aktionsbuttons und den Schließen-Button und Verifizieren, dass die Callbacks mit den korrekten IDs/Schlüsseln aufgerufen werden.
* **Integration Tests:**
    * Visualisierung des Widgets in einer Testumgebung mit verschiedenen Benachrichtigungsdaten.

**Geschätzter Aufwand:** Mittel (ca. 3-4 Tage, da Icon-Laden und dynamische Button-Erstellung)

---

### **novade-ui/src/components/notifications/notification_toast.rs**

**Verantwortlichkeit:**
Implementiert die temporären, nicht-intrusiven Pop-up-Benachrichtigungen (Toasts), die am Bildschirmrand erscheinen und nach einer kurzen Zeit automatisch verschwinden oder manuell geschlossen werden können.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationToast` Struktur:**
    * Ist ein Wrapper um `gtk::Window` (mit `GtkWindowType::Popup`).
    * Felder:
        * `window: gtk::Window`.
        * `notification_widget: NotificationWidget` (Eine Instanz des `NotificationWidget`).
        * `timeout_id: RefCell<Option<glib::SourceId>>` (Für das automatische Verschwinden).
        * `notification_id: u32` (ID der angezeigten Benachrichtigung).
        * `on_dismiss_callback: RefCell<Option<Box<dyn Fn(u32)>>>` (Callback, wenn Toast verschwindet).

2.  **`NotificationToast::new()` Funktion:**
    * `pub fn new() -> Result<Self, NotificationUiError>`
    * Erstellt ein `gtk::Window` vom Typ `GtkWindowType::Popup`.
    * Setzt `window.set_decorated(false)`, `window.set_resizable(false)`, `window.set_keep_above(true)`.
    * Setzt CSS-Klassen "nova-notification-toast".
    * Erstellt eine Instanz von `NotificationWidget`.
    * Fügt `notification_widget` zum `window` hinzu.
    * Verbindet das `close_request` Signal des `window` und das `close_callback` des `notification_widget` mit einer internen Methode, die den Toast schließt.
    * Verbindet das `action_callback` des `notification_widget` mit einer Methode, die Aktionen weiterleitet und den Toast schließt.

3.  **`NotificationToast::show_notification()` Methode:**
    * `pub fn show_notification(&self, notification: Notification, display_duration_ms: u32)`
    * Ruft `notification_widget.update_notification(notification)` auf.
    * Setzt `notification_id`.
    * Positioniert das `window` am Bildschirmrand (z.B. unten rechts), basierend auf `GdkDisplay` und `GdkMonitor`. Muss Kollisionen mit anderen Toasts vermeiden (Implementierung hierfür im `NotificationController`).
    * Zeigt das `window` an (`window.show()`).
    * Startet einen `glib::timeout_add_local` Timer, der nach `display_duration_ms` das `window` schließt und `on_dismiss_callback` aufruft. Speichert die `SourceId` in `timeout_id`.

4.  **`NotificationToast::hide_and_dismiss()` Methode:**
    * `pub fn hide_and_dismiss(&self)`
    * Versteckt das `window` (`window.hide()`).
    * Falls ein Timer aktiv ist, diesen abbrechen (`glib::SourceId::remove`).
    * Ruft `on_dismiss_callback` mit der `notification_id` auf, falls gesetzt.

5.  **`NotificationToast::set_dismiss_callback()` Methode:**
    * `pub fn set_dismiss_callback<F>(&self, callback: F)`
    * `where F: Fn(u32) + 'static`
    * Speichert den Callback, der aufgerufen wird, wenn der Toast vom Benutzer geschlossen wird oder der Timer abläuft.

6.  **`NotificationToast::get_id()` Methode:**
    * `pub fn get_id(&self) -> u32`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/notifications/notification_toast.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::notifications::notification_widget::NotificationWidget`
    * `crate::components::notifications::error::NotificationUiError`
    * `novade_domain::notification_management::data_types::Notification`
* **Extern:**
    * `gtk::{self, prelude::*, Window, glib, gdk}`
    * `std::cell::RefCell`

**Kommunikationsmuster:**

* Wird vom `NotificationController` instanziiert, angezeigt und verwaltet.
* Teilt dem `NotificationController` über Callbacks mit, wenn der Toast geschlossen oder eine Aktion ausgeführt wurde.

**Erwartete Ergebnisse/Outputs:**
Temporäre, anpassbare Benachrichtigungs-Popups am Bildschirmrand.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Testen der `new()`-Funktion: Korrekte Window-Erstellung und Eigenschaften (Popup, not decorated, keep above).
    * Testen von `show_notification()`: Verifizieren, dass `update_notification` des inneren Widgets aufgerufen wird und ein Timer gestartet wird.
    * Testen von `hide_and_dismiss()`: Verifizieren, dass der Timer gestoppt und der Callback aufgerufen wird.
    * Simulieren von Timer-Ablauf und manuellem Schließen und Prüfen, ob der `on_dismiss_callback` korrekt aufgerufen wird.
* **Integration Tests:**
    * Starten der NovaDE und Senden von Benachrichtigungen.
    * Visuelle Inspektion der Toast-Positionierung, Anzeige und des automatischen Verschwindens.
    * Testen der Interaktion (Klick auf Aktion, Schließen des Toasts).

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da Window-Management, Timer-Logik und Kollisionsvermeidung für mehrere Toasts im Controller)

---

### **novade-ui/src/components/notifications/notification_center.rs**

**Verantwortlichkeit:**
Implementiert das Benachrichtigungs-Center (oft ein Popover oder Side-Panel), das eine Liste aller aktiven und/oder archivierten Benachrichtigungen anzeigt.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationCenter` Struktur:**
    * Ist ein Wrapper um `gtk::Popover` oder `gtk::Box` (wenn als Side-Panel).
    * Felder:
        * `container: gtk::Widget` (Das Popover/Side-Panel).
        * `header_label: gtk::Label` (Z.B. "Benachrichtigungen").
        * `clear_all_button: gtk::Button` (Button zum Löschen aller Benachrichtigungen).
        * `notification_list_box: gtk::ListBox` (Liste der `NotificationWidget` Instanzen).
        * `empty_state_label: gtk::Label` (Anzeige, wenn keine Benachrichtigungen vorhanden sind).
        * `clear_all_callback: RefCell<Option<Box<dyn Fn()>>>` (Callback für "Alle löschen").
        * `action_callback: RefCell<Option<Box<dyn Fn(u32, String)>>>` (Callback für Benachrichtigungsaktionen).
        * `close_notification_callback: RefCell<Option<Box<dyn Fn(u32)>>>` (Callback zum Schließen einer einzelnen Benachrichtigung).

2.  **`NotificationCenter::new()` Funktion:**
    * `pub fn new() -> Result<Self, NotificationUiError>`
    * Lädt die UI-Definition (`notification_center.ui`).
    * Initialisiert die Widgets.
    * Setzt CSS-Klassen "nova-notification-center".
    * Verbindet das `clicked` Signal des `clear_all_button` mit einem internen Handler, der `clear_all_callback` aufruft.

3.  **`NotificationCenter::update_notifications()` Methode:**
    * `pub fn update_notifications(&self, notifications: Vec<Notification>)`
    * Löscht alle vorhandenen `ListBoxRow`s aus `notification_list_box`.
    * Wenn `notifications` leer ist: `empty_state_label.set_visible(true)`, `clear_all_button.set_sensitive(false)`.
    * Andernfalls: `empty_state_label.set_visible(false)`, `clear_all_button.set_sensitive(true)`.
    * Iteriert über die `notifications`:
        * Erstellt für jede `Notification` eine neue `NotificationWidget` Instanz.
        * Ruft `notification_widget.update_notification(notification)` auf.
        * Setzt den `action_callback` und `close_callback` für jedes `NotificationWidget`, um diese an die eigenen Callbacks weiterzuleiten (z.B. `self.action_callback.borrow().as_ref().map(|f| f(id, key))`).
        * Fügt das `NotificationWidget` einer `gtk::ListBoxRow` hinzu und diese zur `notification_list_box`.

4.  **`NotificationCenter::set_clear_all_callback()` Methode:**
    * `pub fn set_clear_all_callback<F>(&self, callback: F)`
    * `where F: Fn() + 'static`
    * Speichert den Callback für den "Alle löschen"-Button.

5.  **`NotificationCenter::set_action_callback()` Methode:**
    * `pub fn set_action_callback<F>(&self, callback: F)`
    * `where F: Fn(u32, String) + 'static`
    * Speichert den Callback für Aktionsklicks innerhalb der einzelnen Benachrichtigungen.

6.  **`NotificationCenter::set_close_notification_callback()` Methode:**
    * `pub fn set_close_notification_callback<F>(&self, callback: F)`
    * `where F: Fn(u32) + 'static`
    * Speichert den Callback für das Schließen einzelner Benachrichtigungen aus dem Center.

7.  **`NotificationCenter::show_popover_at_widget()` Methode:**
    * `pub fn show_popover_at_widget(&self, widget: &impl IsA<gtk::Widget>)`
    * Zeigt das Popover an.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/notifications/notification_center.rs`
* `novade-ui/resources/ui/notification_center.ui`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::notifications::notification_widget::NotificationWidget`
    * `crate::components::notifications::error::NotificationUiError`
    * `novade_domain::notification_management::data_types::Notification`
* **Extern:**
    * `gtk::{self, prelude::*, Popover, Box, Button, Label, ListBox, ListBoxRow, glib, IsA, Widget}`
    * `std::cell::RefCell`

**Kommunikationsmuster:**

* Wird vom `NotificationController` erstellt und angezeigt.
* Empfängt eine Liste von `Notification` Objekten und rendert sie.
* Emittiert Callbacks für "Alle löschen", einzelne Benachrichtigungsaktionen und das Schließen einzelner Benachrichtigungen.

**Erwartete Ergebnisse/Outputs:**
Ein interaktives Benachrichtigungs-Center, das alle aktiven Benachrichtigungen übersichtlich darstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Testen der `new()`-Funktion: Korrekte Widget-Initialisierung.
    * Testen von `update_notifications()` mit verschiedenen Listen:
        * Leere Liste (empty state sichtbar, Clear All Button inaktiv).
        * Liste mit einer Benachrichtigung.
        * Liste mit mehreren Benachrichtigungen.
        * Verifizieren der korrekten Erstellung und Reihenfolge der `NotificationWidget` Instanzen.
    * Simulieren von Klicks auf "Alle löschen" und einzelne Benachrichtigungsaktionen/Schließen und Prüfen, ob die Callbacks korrekt ausgelöst werden.
* **Integration Tests:**
    * Starten der NovaDE.
    * Senden von mehreren Benachrichtigungen.
    * Öffnen des Notification Centers über ein Panel-Icon.
    * Visuelle Inspektion der Benachrichtigungen im Center.
    * Testen der "Alle löschen"-Funktion.
    * Testen des Schließens einzelner Benachrichtigungen.
    * Testen von Aktionsbuttons innerhalb des Centers.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da dynamische Widget-Erstellung und komplexes Event-Routing)

---

### **novade-ui/src/components/notifications/controller.rs**

**Verantwortlichkeit:**
Implementiert den `NotificationController`, der die logische Steuerung für das gesamte Benachrichtigungssystem (Toasts und Notification Center) übernimmt. Er abonniert Events vom `NotificationService` der Domänenschicht, um neue Benachrichtigungen zu erhalten, verwaltet die Lebenszyklen der Toasts und aktualisiert das Notification Center. Er leitet auch Benutzerinteraktionen (Aktionen, Schließen) an die Domänenschicht weiter.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationController` Struktur:**
    * Felder:
        * `notification_service: Arc<NotificationService>`
        * `notification_center: Arc<NotificationCenter>` (Das zentrale Benachrichtigungs-Panel).
        * `active_toasts: RefCell<HashMap<u32, Arc<NotificationToast>>>` (HashMap von `notification_id` zu `NotificationToast` Instanzen für aktive Toasts).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>`.
        * `max_toasts_displayed: usize` (Konfiguration, wie viele Toasts gleichzeitig sichtbar sein dürfen).
        * `toast_display_duration_ms: u32` (Konfiguration, wie lange ein Toast sichtbar ist).

2.  **`NotificationController::new()` Funktion:**
    * `pub fn new(notification_service: Arc<NotificationService>) -> Result<Arc<Self>, NotificationUiError>`
    * Speichert die Referenz zum `notification_service`.
    * Erstellt eine Instanz des `NotificationCenter`.
    * **Setzt Callbacks für `NotificationCenter`:**
        * `notification_center.set_clear_all_callback(move || {`
        * `glib::spawn_future_local(async move {`
        * `if let Err(e) = service_clone.clear_all_notifications().await {`
        * `tracing::error!("Failed to clear all notifications: {:?}", e);`
        * `}`
        * `});`
        * `});`
        * `notification_center.set_action_callback(move |id, key| {`
        * `glib::spawn_future_local(async move {`
        * `if let Err(e) = service_clone.execute_notification_action(id, &key).await {`
        * `tracing::error!("Failed to execute notification action: {:?}", e);`
        * `}`
        * `});`
        * `});`
        * `notification_center.set_close_notification_callback(move |id| {`
        * `glib::spawn_future_local(async move {`
        * `if let Err(e) = service_clone.dismiss_notification(id).await {`
        * `tracing::error!("Failed to dismiss notification: {:?}", e);`
        * `}`
        * `});`
        * `});`
    * Initialisiert `active_toasts` als leere HashMap.
    * Liest `max_toasts_displayed` und `toast_display_duration_ms` aus `GlobalSettingsService` (optional, falls diese Einstellungen existieren).
    * Speichert die Instanzen.

3.  **`NotificationController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt asynchrone Tasks (`glib::MainContext::spawn_local`) für die Event-Listener.
    * **Listener-Task für neue Benachrichtigungen (`new_notification_rx`):**
        * `let controller_clone = self.clone();`
        * `let mut new_notification_rx = self.notification_service.subscribe_to_new_notifications();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `while let Ok(notification) = new_notification_rx.recv().await {`
        * `controller_clone.handle_new_notification(notification).await;`
        * `}`
        * `Ok(())`
        * `}));`
    * **Listener-Task für entfernte Benachrichtigungen (`dismissed_notification_rx`):**
        * `let controller_clone = self.clone();`
        * `let mut dismissed_notification_rx = self.notification_service.subscribe_to_dismissed_notifications();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `while let Ok(notification_id) = dismissed_notification_rx.recv().await {`
        * `controller_clone.handle_dismissed_notification(notification_id).await;`
        * `}`
        * `Ok(())`
        * `}));`
    * **Listener-Task für alle Benachrichtigungen aktualisieren (`all_notifications_rx`):**
        * `let center_clone = self.notification_center.clone();`
        * `let mut all_notifications_rx = self.notification_service.subscribe_to_all_notifications_updates();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `while let Ok(notifications) = all_notifications_rx.recv().await {`
        * `center_clone.update_notifications(notifications);`
        * `}`
        * `Ok(())`
        * `}));`
    * **Initialer Status-Update:** Ruft einmalig `notification_service.get_all_notifications()` auf, um das Center initial zu befüllen.

4.  **`NotificationController::handle_new_notification()` Methode:**
    * `async fn handle_new_notification(&self, notification: Notification)`
    * Ruft `notification_center.update_notifications(self.notification_service.get_all_notifications().await)` auf, um das Center zu aktualisieren.
    * **Toast-Logik:**
        * Prüft, ob ein Toast für diese Benachrichtigung angezeigt werden soll (z.B. basierend auf Regeln oder Einstellungen).
        * Wenn `active_toasts.len() >= max_toasts_displayed`, dann ältesten Toast entfernen (oder bestehenden aktualisieren, wenn `notification.replaces_id`).
        * Erstellt eine neue `NotificationToast` Instanz.
        * Setzt Callbacks für den Toast (Aktionen, Dismiss).
        * Ruft `toast.show_notification(notification, self.toast_display_duration_ms)` auf.
        * Fügt den neuen Toast zu `active_toasts` hinzu.

5.  **`NotificationController::handle_dismissed_notification()` Methode:**
    * `async fn handle_dismissed_notification(&self, notification_id: u32)`
    * Ruft `notification_center.update_notifications(self.notification_service.get_all_notifications().await)` auf, um das Center zu aktualisieren.
    * Wenn der Toast mit `notification_id` in `active_toasts` vorhanden ist, ruft `toast.hide_and_dismiss()` auf und entfernt ihn aus der HashMap.

6.  **`NotificationController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

7.  **`NotificationController::get_notification_center_widget()` Methode:**
    * `pub fn get_notification_center_widget(&self) -> Arc<NotificationCenter>`
    * Gibt die Referenz auf das `NotificationCenter` Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/notifications/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::notifications::notification_widget::NotificationWidget` (indirekt)
    * `crate::components::notifications::notification_toast::NotificationToast`
    * `crate::components::notifications::notification_center::NotificationCenter`
    * `crate::components::notifications::error::NotificationUiError`
    * `novade_domain::notification_management::service::NotificationService`
    * `novade_domain::notification_management::data_types::Notification`
    * `novade_domain::settings::service::GlobalSettingsService` (optional für Konfiguration)
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `std::cell::RefCell`
    * `std::collections::HashMap`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`

**Kommunikationsmuster:**

* **Verwaltet den gesamten Lebenszyklus von Benachrichtigungen in der UI.**
* **Abonniert alle relevanten Events vom `NotificationService` der Domänenschicht.**
* **Initialisiert, aktualisiert und verwaltet sowohl `NotificationToast` Instanzen als auch die `NotificationCenter` Instanz.**
* **Leitet Benutzerinteraktionen (Aktionen, Schließen, Alle löschen) an den `NotificationService` weiter.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein voll funktionsfähiges, reaktionsschnelles und konfigurierbares Benachrichtigungssystem, das Benachrichtigungen als Toasts anzeigt und in einem zentralen Bereich verwaltet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NotificationService` (für Events und Methodenaufrufe).
    * Mocken von `NotificationToast` und `NotificationCenter`.
    * Testen der `new()`-Funktion: Korrekte Initialisierung und Callback-Verbindungen.
    * Testen von `handle_new_notification()`:
        * Verifizieren, dass `NotificationToast::show_notification` aufgerufen wird (unter Berücksichtigung von `max_toasts_displayed`).
        * Verifizieren, dass `NotificationCenter::update_notifications` aufgerufen wird.
        * Testen von `replaces_id` Logik.
    * Testen von `handle_dismissed_notification()`: Verifizieren, dass `NotificationToast::hide_and_dismiss` aufgerufen und der Toast aus der HashMap entfernt wird.
    * Simulieren von Toast-Aktionen und Schließen-Events und Prüfen, ob die korrekten Aufrufe an den gemockten `NotificationService` erfolgen.
    * Testen der "Alle löschen"-Logik.
* **Integration Tests:**
    * Starten der NovaDE.
    * Senden von Benachrichtigungen von einer Testanwendung (z.B. über `notify-send`).
    * Verifizieren, dass Toasts korrekt erscheinen und verschwinden.
    * Verifizieren, dass das Notification Center den aktuellen Status korrekt widerspiegelt.
    * Testen aller Interaktionen: Schließen von Toasts, Aktionen in Toasts/Center, "Alle löschen".
    * Testen des Verhaltens bei vielen Benachrichtigungen (Toast-Limit).

**Geschätzter Aufwand:** Sehr hoch (ca. 8-12 Tage, da komplexes Lebenszyklusmanagement von UI-Widgets, Timer-Logik, Event-Verteilung und Interaktion mit zwei verschiedenen UI-Darstellungen)

---
### **novade-ui/src/components/quick_settings/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die das Schnellzugriffs-Einstellungs-Panel (Quick Settings) im Panel bilden. Es aggregiert Steuerelemente für Lautstärke, Helligkeit, WLAN, Bluetooth, Akku und weitere häufig genutzte Einstellungen.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod quick_settings_panel;` (Das Haupt-Popover/Side-Panel)
    * `pub mod controller;` (Der Controller, der die Logik verwaltet und mit Domänen-/System-Services interagiert)
    * `pub mod error;` (Fehler-Enum für das Modul)
    * `pub mod widgets;` (Enthält spezifische, wiederverwendbare Widgets für einzelne Einstellungen, z.B. `VolumeSliderWidget`, `BrightnessSliderWidget`, `ToggleButton`)

2.  **Re-Exporte (`pub use`):**
    * `pub use quick_settings_panel::QuickSettingsPanel;`
    * `pub use controller::QuickSettingsController;`
    * `pub use error::QuickSettingsError;`
    * `pub use widgets::{VolumeSliderWidget, BrightnessSliderWidget, BluetoothToggleButton, WifiToggleButton, PowerInfoWidget};` (und weitere je nach Bedarf)

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/quick_settings/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* `QuickSettingsController` wird von `UiServices` initialisiert.
* `QuickSettingsPanel` wird vom Controller verwaltet.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für das Quick Settings Panel.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/quick_settings/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`QuickSettingsError`) für das Quick Settings UI-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`QuickSettingsError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `SystemServiceError(#[from] novade_system::SystemServiceError)`: Fehler von der Systemschicht (z.B. Audio, Power, Network).
        * `DomainServiceError(#[from] novade_domain::DomainError)`: Allgemeine Fehler von der Domänenschicht.
        * `InvalidValue(String)`: Ein empfangener Wert ist außerhalb des erwarteten Bereichs.
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/quick_settings/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_system::SystemServiceError`, `novade_domain::DomainError` (Basis-Fehler)
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `quick_settings`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für das Quick Settings UI.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `QuickSettingsError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/quick_settings/widgets.rs**

**Verantwortlichkeit:**
Definiert spezifische, wiederverwendbare GTK-Widgets für einzelne Schnellzugriffs-Einstellungen (z.B. Lautstärkeregler, Helligkeitsregler, WLAN/Bluetooth-Toggle).

**Kern-Aufgaben (Tasks):**

1.  **`VolumeSliderWidget` Struktur:**
    * Wrapper um `gtk::Box` mit `gtk::Scale` und Icons.
    * Felder: `slider: gtk::Scale`, `icon: gtk::Image`, `mute_button: gtk::Button` (optional).
    * `new()`: Erstellt Widgets, setzt CSS-Klassen "nova-volume-slider". Verbindet `change-value` Signal des Sliders und `clicked` Signal des Mute-Buttons mit Callbacks.
    * `set_volume(volume: f64)`: Aktualisiert Slider-Wert und Icon (lautlos, leise, mittel, laut).
    * `set_muted(muted: bool)`: Aktualisiert Mute-Button-Icon.
    * `on_volume_changed(callback: F)`: Setzt Callback für Lautstärkeänderungen.
    * `on_mute_toggled(callback: F)`: Setzt Callback für Mute-Toggle.
    * `get_widget()`: Gibt das Haupt-Widget zurück.

2.  **`BrightnessSliderWidget` Struktur:**
    * Wrapper um `gtk::Box` mit `gtk::Scale` und Icons.
    * Felder: `slider: gtk::Scale`, `icon: gtk::Image`.
    * `new()`: Erstellt Widgets, setzt CSS-Klassen "nova-brightness-slider". Verbindet `change-value` Signal des Sliders mit Callback.
    * `set_brightness(brightness: f64)`: Aktualisiert Slider-Wert und Icon.
    * `on_brightness_changed(callback: F)`: Setzt Callback für Helligkeitsänderungen.
    * `get_widget()`: Gibt das Haupt-Widget zurück.

3.  **`WifiToggleButton` Struktur:**
    * Wrapper um `gtk::Box` mit `gtk::Switch` und Label/Icon.
    * Felder: `toggle: gtk::Switch`, `label: gtk::Label`, `icon: gtk::Image`.
    * `new()`: Erstellt Widgets, setzt CSS-Klassen "nova-wifi-toggle". Verbindet `state-set` Signal des Switch.
    * `set_active(active: bool)`: Aktualisiert Switch-Zustand und Label/Icon (Ein/Aus).
    * `on_toggled(callback: F)`: Setzt Callback.
    * `get_widget()`: Gibt das Haupt-Widget zurück.

4.  **`BluetoothToggleButton` Struktur:**
    * Ähnlich `WifiToggleButton`.
    * Felder: `toggle: gtk::Switch`, `label: gtk::Label`, `icon: gtk::Image`.
    * `new()`: Erstellt Widgets, setzt CSS-Klassen "nova-bluetooth-toggle". Verbindet `state-set` Signal des Switch.
    * `set_active(active: bool)`: Aktualisiert Switch-Zustand.
    * `on_toggled(callback: F)`: Setzt Callback.
    * `get_widget()`: Gibt das Haupt-Widget zurück.

5.  **`PowerInfoWidget` Struktur:**
    * Wrapper um `gtk::Box` zur Anzeige von Akku-Status und Ladezustand.
    * Felder: `icon: gtk::Image`, `percentage_label: gtk::Label`, `status_label: gtk::Label`.
    * `new()`: Erstellt Widgets, setzt CSS-Klassen "nova-power-info".
    * `update_power_status(status: &PowerStatus)`: Aktualisiert Icon (Akku-Level, Ladezustand), `percentage_label` und `status_label`.
    * `get_widget()`: Gibt das Haupt-Widget zurück.

6.  **`NotificationsToggleButton` Struktur:**
    * Wrapper um `gtk::Box` mit `gtk::Switch` und Label/Icon.
    * Felder: `toggle: gtk::Switch`, `label: gtk::Label`, `icon: gtk::Image`.
    * `new()`: Erstellt Widgets, setzt CSS-Klassen "nova-notifications-toggle". Verbindet `state-set` Signal des Switch.
    * `set_active(active: bool)`: Aktualisiert Switch-Zustand.
    * `on_toggled(callback: F)`: Setzt Callback.
    * `get_widget()`: Gibt das Haupt-Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/quick_settings/widgets.rs`
* `novade-ui/resources/ui/quick_settings_widgets.ui` (optional, für komplexere Widgets)

**Abhängigkeiten:**

* **Intern:** `crate::components::quick_settings::error::QuickSettingsError`
* **Extern:**
    * `gtk::{self, prelude::*, Box, Scale, Image, Button, Switch, Label, glib, Widget}`
    * `std::cell::RefCell`

**Kommunikationsmuster:**

* Diese Widgets werden von `QuickSettingsPanel` instanziiert.
* Sie exponieren Callbacks (`on_volume_changed`, `on_toggled` etc.), die vom `QuickSettingsController` verbunden werden, um Benutzerinteraktionen an die Domänen-/Systemschicht weiterzuleiten.
* Sie empfangen Updates von `QuickSettingsPanel` (welches wiederum vom Controller aktualisiert wird), um ihren Zustand zu ändern.

**Erwartete Ergebnisse/Outputs:**
Eine Sammlung von modularen, wiederverwendbaren UI-Widgets für schnelle Einstellungen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktionen: Korrekte Widget-Initialisierung, CSS-Klassen, Signal-Verbindungen.
    * Testen der `set_*()`-Methoden: Verifizieren, dass die GTK-Widgets ihren Zustand korrekt aktualisieren (z.B. Slider-Wert, Icon, Label-Text, Switch-Zustand).
    * Simulieren von Benutzerinteraktionen (Slider bewegen, Button klicken, Switch umschalten) und Prüfen, ob die registrierten Callbacks mit den korrekten Werten aufgerufen werden.

**Geschätzter Aufwand:** Mittel (ca. 5-7 Tage, da viele Einzelwidgets und deren Logik zu implementieren sind)

---

### **novade-ui/src/components/quick_settings/quick_settings_panel.rs**

**Verantwortlichkeit:**
Implementiert das Haupt-GTK-Popover oder Side-Panel für die Schnellzugriffs-Einstellungen. Es aggregiert die einzelnen Widgets aus `quick_settings/widgets.rs` und stellt die Gesamtstruktur und das Layout bereit.

**Kern-Aufgaben (Tasks):**

1.  **`QuickSettingsPanel` Struktur:**
    * Ist ein Wrapper um `gtk::Popover` oder `gtk::Box` (wenn als Side-Panel).
    * Felder:
        * `container: gtk::Widget` (Das Popover/Side-Panel).
        * `volume_widget: VolumeSliderWidget`.
        * `brightness_widget: BrightnessSliderWidget`.
        * `wifi_toggle_widget: WifiToggleButton`.
        * `bluetooth_toggle_widget: BluetoothToggleButton`.
        * `power_info_widget: PowerInfoWidget`.
        * `notifications_toggle_widget: NotificationsToggleButton`.
        * `open_settings_button: gtk::Button` (Button zum Öffnen der vollständigen Systemeinstellungen).
        * `open_control_center_button: gtk::Button` (Button zum Öffnen des Control Centers, falls dieses getrennt ist).
        * `open_settings_callback: RefCell<Option<Box<dyn Fn()>>>` (Callback für Einstellungen öffnen).
        * `open_control_center_callback: RefCell<Option<Box<dyn Fn()>>>` (Callback für Control Center öffnen).

2.  **`QuickSettingsPanel::new()` Funktion:**
    * `pub fn new() -> Result<Self, QuickSettingsError>`
    * Lädt die UI-Definition (`quick_settings_panel.ui`).
    * Initialisiert die einzelnen Widgets (z.B. `VolumeSliderWidget::new()`).
    * Fügt die Widgets dem `container` in einem strukturierten Layout (z.B. `gtk::Grid`, `gtk::Box`).
    * Setzt CSS-Klassen "nova-quick-settings-panel".
    * Verbindet `clicked` Signale von `open_settings_button` und `open_control_center_button` mit internen Handlern, die die entsprechenden Callbacks auslösen.

3.  **`QuickSettingsPanel::update_volume_status()` Methode:**
    * `pub fn update_volume_status(&self, volume: f64, muted: bool)`
    * Ruft `self.volume_widget.set_volume(volume)` und `self.volume_widget.set_muted(muted)` auf.

4.  **`QuickSettingsPanel::update_brightness_status()` Methode:**
    * `pub fn update_brightness_status(&self, brightness: f64)`
    * Ruft `self.brightness_widget.set_brightness(brightness)` auf.

5.  **`QuickSettingsPanel::update_wifi_status()` Methode:**
    * `pub fn update_wifi_status(&self, enabled: bool)`
    * Ruft `self.wifi_toggle_widget.set_active(enabled)` auf.

6.  **`QuickSettingsPanel::update_bluetooth_status()` Methode:**
    * `pub fn update_bluetooth_status(&self, enabled: bool)`
    * Ruft `self.bluetooth_toggle_widget.set_active(enabled)` auf.

7.  **`QuickSettingsPanel::update_power_status()` Methode:**
    * `pub fn update_power_status(&self, status: &PowerStatus)`
    * Ruft `self.power_info_widget.update_power_status(status)` auf.

8.  **`QuickSettingsPanel::update_notifications_status()` Methode:**
    * `pub fn update_notifications_status(&self, enabled: bool)`
    * Ruft `self.notifications_toggle_widget.set_active(enabled)` auf.

9.  **`QuickSettingsPanel::set_open_settings_callback()` / `set_open_control_center_callback()` Methoden:**
    * `pub fn set_open_settings_callback<F>(&self, callback: F)`
    * `pub fn set_open_control_center_callback<F>(&self, callback: F)`
    * Speichern die jeweiligen Callbacks.

10. **`QuickSettingsPanel::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

11. **Exponiert die Callbacks der Kind-Widgets:**
    * `pub fn on_volume_changed(&self, callback: F)` etc.
    * Leitet diese Anfragen an die internen Widgets weiter.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/quick_settings/quick_settings_panel.rs`
* `novade-ui/resources/ui/quick_settings_panel.ui`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::quick_settings::widgets::{VolumeSliderWidget, BrightnessSliderWidget, WifiToggleButton, BluetoothToggleButton, PowerInfoWidget, NotificationsToggleButton}`
    * `crate::components::quick_settings::error::QuickSettingsError`
    * `novade_system::power_management::data_types::PowerStatus`
* **Extern:**
    * `gtk::{self, prelude::*, Popover, Box, Grid, Button, Label, glib, IsA, Widget}`
    * `std::cell::RefCell`

**Kommunikationsmuster:**

* Wird vom `QuickSettingsController` instanziiert und angezeigt.
* Empfängt Status-Updates für alle enthaltenen Einstellungen vom `QuickSettingsController`.
* Leitet Benutzerinteraktionen von seinen Kind-Widgets (Slider-Änderungen, Toggles, Button-Klicks) über Callbacks an den `QuickSettingsController` weiter.

**Erwartete Ergebnisse/Outputs:**
Ein funktionales und ästhetisch ansprechendes Schnellzugriffs-Einstellungs-Panel.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken der `widgets` Komponenten (um nur die Panel-Logik zu testen).
    * Testen der `new()`-Funktion: Korrekte Initialisierung der Kind-Widgets und des Layouts.
    * Testen der `update_*_status()`-Methoden: Verifizieren, dass die Aufrufe an die gemockten Kind-Widgets korrekt weitergeleitet werden.
    * Simulieren von Klicks auf "Open Settings" und "Open Control Center" und Prüfen, ob die Callbacks ausgelöst werden.
* **Integration Tests:**
    * Starten der NovaDE und Öffnen des Quick Settings Panel.
    * Visuelle Inspektion der Widgets und des Layouts.
    * Testen der Interaktion mit den Sliders, Toggles und Buttons und Verifizieren, dass die UI reagiert und die Änderungen an die Systemschicht weitergeleitet werden.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da Layout, Integration der Kind-Widgets und Event-Delegation)

---

### **novade-ui/src/components/quick_settings/controller.rs**

**Verantwortlichkeit:**
Implementiert den `QuickSettingsController`, der die logische Steuerung für das Quick Settings Panel übernimmt. Er abonniert Events von verschiedenen Domänen- und System-Services (Audio, Power, Network, Global Settings) und aktualisiert das UI-Panel entsprechend. Er leitet auch Benutzerinteraktionen vom Panel an die entsprechenden Services weiter.

**Kern-Aufgaben (Tasks):**

1.  **`QuickSettingsController` Struktur:**
    * Felder:
        * `audio_management_service: Arc<AudioManagementService>`
        * `power_management_service: Arc<PowerManagementService>`
        * `network_management_service: Arc<NetworkManagementService>`
        * `display_management_service: Arc<DisplayManagementService>` (für Helligkeit)
        * `notification_service: Arc<NotificationService>` (für "Bitte nicht stören" Toggle)
        * `global_settings_service: Arc<GlobalSettingsService>` (für allgemeine Einstellungen, die von der UI geöffnet werden)
        * `quick_settings_panel: Arc<QuickSettingsPanel>` (Referenz auf das GTK-Panel selbst).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>`.

2.  **`QuickSettingsController::new()` Funktion:**
    * `pub fn new(...) -> Result<Arc<Self>, QuickSettingsError>` (Parameter sind die Service-Referenzen)
    * Speichert die Referenzen zu allen benötigten Services.
    * Erstellt eine Instanz des `QuickSettingsPanel`.
    * **Verbindet Callbacks vom `QuickSettingsPanel` an die Services:**
        * `panel.on_volume_changed(|vol| { glib::spawn_future_local(async move { service.set_volume(vol) }); });`
        * `panel.on_mute_toggled(|muted| { glib::spawn_future_local(async move { service.set_muted(muted) }); });`
        * `panel.on_brightness_changed(|bright| { glib::spawn_future_local(async move { service.set_brightness(bright) }); });`
        * `panel.on_wifi_toggled(|enabled| { glib::spawn_future_local(async move { service.set_radio_enabled(enabled, NetworkType::Wifi) }); });`
        * `panel.on_bluetooth_toggled(|enabled| { glib::spawn_future_local(async move { service.set_radio_enabled(enabled, NetworkType::Bluetooth) }); });`
        * `panel.on_notifications_toggled(|enabled| { glib::spawn_future_local(async move { service.set_do_not_disturb(!enabled) }); });`
        * `panel.set_open_settings_callback(move || { glib::spawn_future_local(async move { global_settings_service.open_settings_app(None) }); });` (Startet die zentrale Einstellungen-App)
        * `panel.set_open_control_center_callback(move || { /* Logik zum Öffnen des Control Centers */ });` (Falls Control Center separat ist)
    * Speichert die Instanzen.

3.  **`QuickSettingsController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt asynchrone Tasks (`glib::MainContext::spawn_local`) für alle Event-Listener.
    * **Listener-Tasks für alle Services:**
        * `audio_management_service.subscribe_to_volume_changes()` -> `panel.update_volume_status()`
        * `power_management_service.subscribe_to_power_status_changes()` -> `panel.update_power_status()`
        * `network_management_service.subscribe_to_network_status_changes()` -> `panel.update_wifi_status()` (für generellen WLAN-Status)
        * `network_management_service.subscribe_to_bluetooth_status_changes()` -> `panel.update_bluetooth_status()` (für generellen Bluetooth-Status)
        * `display_management_service.subscribe_to_brightness_changes()` -> `panel.update_brightness_status()`
        * `notification_service.subscribe_to_do_not_disturb_changes()` -> `panel.update_notifications_status()`
    * **Initialer Status-Update:** Ruft einmalig die `get_*_status()` Methoden aller Services auf und aktualisiert das Panel entsprechend.

4.  **`QuickSettingsController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

5.  **`QuickSettingsController::get_panel_widget()` Methode:**
    * `pub fn get_panel_widget(&self) -> Arc<QuickSettingsPanel>`
    * Gibt die Referenz auf das `QuickSettingsPanel` Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/quick_settings/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::quick_settings::quick_settings_panel::QuickSettingsPanel`
    * `crate::components::quick_settings::error::QuickSettingsError`
    * `novade_system::audio_management::service::AudioManagementService`
    * `novade_system::power_management::service::PowerManagementService`
    * `novade_system::network_management::service::NetworkManagementService`
    * `novade_system::display_management::service::DisplayManagementService`
    * `novade_domain::notification_management::service::NotificationService`
    * `novade_domain::settings::service::GlobalSettingsService`
    * `novade_system::network_management::data_types::NetworkType`
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`

**Kommunikationsmuster:**

* **Verwaltet den gesamten Quick Settings Panel.**
* **Abonniert Events von multiplen Domänen- und System-Services.**
* **Aktualisiert das `QuickSettingsPanel` auf Basis empfangener Events.**
* **Leitet Benutzerinteraktionen vom Panel an die entsprechenden Services weiter.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller und funktionaler Controller, der das Quick Settings Panel synchron hält und Benutzerinteraktionen verarbeitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken aller abhängigen Services (`AudioManagementService`, `PowerManagementService` etc.) und des `QuickSettingsPanel`.
    * Testen der `new()`-Funktion: Verifizieren, dass alle Service-Referenzen korrekt gespeichert und Callbacks an das Panel verbunden werden.
    * Testen von `start_listeners()`: Simulieren von Events von den gemockten Services und Prüfen, ob die entsprechenden `update_*_status()`-Methoden des gemockten `QuickSettingsPanel` aufgerufen werden.
    * Simulieren von Benutzerinteraktionen am gemockten Panel (z.B. `on_volume_changed` Callback auslösen) und Prüfen, ob die korrekten Methoden (z.B. `set_volume`) auf den gemockten Services aufgerufen werden.
* **Integration Tests:**
    * Starten der NovaDE.
    * Öffnen des Quick Settings Panel.
    * Manipulieren von System-Einstellungen (z.B. Lautstärke über `pactl`, Helligkeit über `xrandr`/`brightnessctl`, WLAN/Bluetooth über `nmcli`/`bluetoothctl`, DND über `notify-send`).
    * Visuelle Inspektion, ob das Panel korrekt aktualisiert wird.
    * Interagieren mit den Panel-Widgets (Slider, Toggles, Buttons) und Verifizieren, dass die System-Einstellungen korrekt geändert werden.

**Geschätzter Aufwand:** Sehr hoch (ca. 8-12 Tage, da viele Services integriert und Events/Interaktionen verwaltet werden müssen)

---
### **novade-ui/src/components/power_indicator/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die den Akku- und Energie-Indikator im Panel bilden.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod power_indicator_widget;` (Das Panel-Widget, das den Akku-Status anzeigt)
    * `pub mod controller;` (Der Controller, der die Logik verwaltet und mit dem `PowerManagementService` interagiert)
    * `pub mod error;` (Fehler-Enum für das Modul)
    * `pub mod power_details_popover;` (Das Popover mit detaillierten Akku-Informationen und Energieeinstellungen)

2.  **Re-Exporte (`pub use`):**
    * `pub use power_indicator_widget::PowerIndicator;`
    * `pub use controller::PowerIndicatorController;`
    * `pub use error::PowerIndicatorError;`
    * `pub use power_details_popover::PowerDetailsPopover;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/power_indicator/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* `PowerIndicatorController` wird von `UiServices` initialisiert.
* `PowerIndicator` und `PowerDetailsPopover` werden vom Controller verwaltet.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für den Akku- und Energie-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/power_indicator/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`PowerIndicatorError`) für das Akku- und Energie-Indikator-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`PowerIndicatorError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `SystemServiceError(#[from] novade_system::SystemServiceError)`: Fehler von der Systemschicht (z.B. UPower-Interaktion).
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/power_indicator/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_system::SystemServiceError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `power_indicator`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für den Akku- und Energie-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `PowerIndicatorError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/power_indicator/power_indicator_widget.rs**

**Verantwortlichkeit:**
Implementiert das GTK-Widget für den Akku- und Energie-Indikator im Panel, der den aktuellen Ladezustand und Status (z.B. Ladezustand, verbleibende Zeit) anzeigt.

**Kern-Aufgaben (Tasks):**

1.  **`PowerIndicator` Struktur:**
    * Ist ein Wrapper um `gtk::Button` oder `gtk::Box`.
    * Felder:
        * `container: gtk::Box` (oder `gtk::Button`).
        * `icon: gtk::Image` (Akku-Icon mit Füllstand).
        * `percentage_label: gtk::Label` (Akkuprozentsatz).
        * `time_label: gtk::Label` (Optional: Verbleibende Zeit oder Ladezeit).

2.  **`PowerIndicator::new()` Funktion:**
    * `pub fn new() -> Result<Self, PowerIndicatorError>`
    * Erstellt die `gtk::Box` und die Kind-Widgets (`icon`, `percentage_label`, `time_label`).
    * Ordnet sie im `container` an.
    * Setzt CSS-Klassen "nova-power-indicator".
    * Initialisiert mit einem Standard-Akku-Icon und leerem Label.

3.  **`PowerIndicator::update_status()` Methode:**
    * `pub fn update_status(&self, status: &PowerStatus)`
    * Empfängt ein `PowerStatus` Objekt von der Systemschicht.
    * Wählt das korrekte `icon` basierend auf `status.percentage`, `status.is_charging` und `status.state` (z.B. `battery-full-charging-symbolic`, `battery-70-symbolic`, `battery-low-symbolic`).
    * Aktualisiert `percentage_label` mit `status.percentage` gefolgt von "%".
    * Aktualisiert `time_label` mit `status.time_to_empty_or_full` formatiert als menschlich lesbare Zeit (z.B. "2h 30m remaining" oder "1h 15m until full"). Macht das Label unsichtbar, wenn keine relevante Zeitinformation verfügbar ist.
    * Fügt/entfernt CSS-Klassen basierend auf dem Status (z.B. "charging", "low-battery", "critical-battery").
    * Setzt die Sichtbarkeit des gesamten Widgets, wenn keine Akku-Informationen verfügbar sind (z.B. Desktop-PC ohne Akku).

4.  **`PowerIndicator::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/power_indicator/power_indicator_widget.rs`
* `novade-ui/resources/ui/power_indicator.ui` (optional)

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::power_indicator::error::PowerIndicatorError`
    * `novade_system::power_management::data_types::PowerStatus`
* **Extern:** `gtk::{self, prelude::*, Box, Button, Image, Label, glib, Widget}`

**Kommunikationsmuster:**

* Wird von `Panel` instanziiert.
* Wird vom `PowerIndicatorController` aktualisiert.
* Emittiert Klick-Events, die vom `PowerIndicatorController` verarbeitet werden, um das Detail-Popover zu öffnen.

**Erwartete Ergebnisse/Outputs:**
Ein funktionaler Akku- und Energie-Indikator im Panel, der den aktuellen Status anzeigt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion: Initialisierung der Widgets, CSS-Klassen.
    * Testen von `update_status()` mit verschiedenen `PowerStatus` Werten:
        * Verschiedene Ladezustände (0%, 20%, 50%, 100%).
        * Ladend und nicht ladend.
        * Verschiedene Ladezeiten/Restlaufzeiten.
        * Keine Akku-Informationen.
        * Verifizieren der korrekten Icon-Auswahl, Label-Texte und Sichtbarkeit.
* **Integration Tests:**
    * Starten der NovaDE.
    * Ändern des Akku-Status (z.B. Netzteil an/aus, Akku entladen/laden).
    * Visuelle Inspektion, ob Icon, Prozentsatz und Zeit im Panel korrekt aktualisiert werden.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---

### **novade-ui/src/components/power_indicator/power_details_popover.rs**

**Verantwortlichkeit:**
Implementiert das `gtk::Popover` oder `gtk::Window`, das detaillierte Akku-Informationen (Gesundheit, Kapazität, Entlade-/Laderate) und Energieeinstellungen (Energiesparmodus, Helligkeit, DPMS-Steuerung) anzeigt.

**Kern-Aufgaben (Tasks):**

1.  **`PowerDetailsPopover` Struktur:**
    * Ist ein Wrapper um `gtk::Popover` oder `gtk::Window`.
    * Felder:
        * `container: gtk::Widget` (Das Popover/Window).
        * `main_power_info_widget: PowerInfoWidget` (Wiederverwendetes Widget für Haupt-Akku-Info).
        * `health_label: gtk::Label` (Akku-Gesundheit in %).
        * `capacity_label: gtk::Label` (Designtest-Kapazität vs. volle Kapazität).
        * `rate_label: gtk::Label` (Entlade-/Laderate in Watt).
        * `energy_saver_toggle: gtk::Switch` (Energiesparmodus an/aus).
        * `brightness_slider: gtk::Scale` (Helligkeitsregler).
        * `screen_timeout_dropdown: gtk::DropDown` (Bildschirm-Timeout/DPMS-Einstellungen).
        * `shutdown_button: gtk::Button`.
        * `reboot_button: gtk::Button`.
        * `suspend_button: gtk::Button`.
        * `lock_button: gtk::Button`.
        * `power_management_service: Arc<PowerManagementService>` (Direkte Referenz zur Interaktion).
        * `display_management_service: Arc<DisplayManagementService>` (Direkte Referenz zur Interaktion).
        * `global_settings_service: Arc<GlobalSettingsService>` (Für Energiesparmodus Einstellungen).

2.  **`PowerDetailsPopover::new()` Funktion:**
    * `pub fn new(...) -> Result<Self, PowerIndicatorError>` (Parameter sind die Service-Referenzen)
    * Lädt die UI-Definition (`power_details_popover.ui`).
    * Initialisiert die Widgets und speichert die Service-Referenzen.
    * Setzt Initialzustände für Labels und Buttons.
    * **Verbindet Signale:**
        * `energy_saver_toggle.connect_state_set()`: Ruft `global_settings_service.set_energy_saver_mode()` auf.
        * `brightness_slider.connect_change_value()`: Ruft `display_management_service.set_brightness()` auf.
        * `screen_timeout_dropdown.connect_selected_item_notify()`: Ruft `display_management_service.set_dpms_timeout()` auf.
        * `shutdown_button.connect_clicked()`: Ruft `power_management_service.shutdown()` auf.
        * `reboot_button.connect_clicked()`: Ruft `power_management_service.reboot()` auf.
        * `suspend_button.connect_clicked()`: Ruft `power_management_service.suspend()` auf.
        * `lock_button.connect_clicked()`: Ruft `power_management_service.lock_screen()` auf.
    * Setzt CSS-Klassen "nova-power-details-popover".

3.  **`PowerDetailsPopover::update_status()` Methode:**
    * `pub fn update_status(&self, power_status: &PowerStatus, brightness: f64, energy_saver_enabled: bool, dpms_timeout: u32)`
    * Aktualisiert `main_power_info_widget` mit `power_status`.
    * Aktualisiert `health_label`, `capacity_label` und `rate_label` mit Details aus `power_status`.
    * Aktualisiert `energy_saver_toggle` basierend auf `energy_saver_enabled`.
    * Aktualisiert `brightness_slider` mit `brightness`.
    * Setzt das ausgewählte Item in `screen_timeout_dropdown` basierend auf `dpms_timeout`.
    * Aktiviert/Deaktiviert Buttons und Slider basierend auf Verfügbarkeit der Funktionen (z.B. `power_status.can_suspend`).

4.  **`PowerDetailsPopover::show_popover_at_widget()` Methode:**
    * `pub fn show_popover_at_widget(&self, widget: &impl IsA<gtk::Widget>)`
    * Zeigt das Popover an.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/power_indicator/power_details_popover.rs`
* `novade-ui/resources/ui/power_details_popover.ui`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::power_indicator::error::PowerIndicatorError`
    * `crate::components::quick_settings::widgets::PowerInfoWidget` (Wiederverwendung)
    * `novade_system::power_management::service::PowerManagementService`
    * `novade_system::power_management::data_types::PowerStatus`
    * `novade_system::display_management::service::DisplayManagementService`
    * `novade_domain::settings::service::GlobalSettingsService`
* **Extern:**
    * `gtk::{self, prelude::*, Popover, Window, Label, Switch, Scale, Button, DropDown, glib, IsA, Widget}`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Wird vom `PowerIndicatorController` erstellt und angezeigt.
* Empfängt Status-Updates für Akku, Helligkeit und Einstellungen vom `PowerIndicatorController`.
* Interagiert direkt mit `PowerManagementService`, `DisplayManagementService` und `GlobalSettingsService` um Benutzerbefehle auszuführen (Helligkeit ändern, Energiesparmodus, Herunterfahren etc.).

**Erwartete Ergebnisse/Outputs:**
Ein interaktives Popover, das detaillierte Energieinformationen und Steuerungen bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `PowerManagementService`, `DisplayManagementService`, `GlobalSettingsService`.
    * Testen der `new()`-Funktion: Initialisierung der Widgets, Signal-Verbindungen.
    * Testen von `update_status()` mit verschiedenen Status-Werten:
        * Verschiedene Akku-Zustände, Ladezustände, Helligkeitswerte, Energiesparmodi.
        * Verifizieren der korrekten Label-Texte, Slider-Werte und Toggle-Zustände.
    * Simulieren von Button-Klicks, Slider-Bewegungen und Dropdown-Auswahlen und Prüfen, ob die korrekten Aufrufe an die gemockten Services erfolgen.
* **Integration Tests:**
    * Starten der NovaDE.
    * Öffnen des Popovers.
    * Visuelle Inspektion der angezeigten Informationen und Steuerungen.
    * Testen aller Steuerungen (Helligkeit, Energiesparmodus, Timeout, Herunterfahren/Neustart/Sperren/Suspend).
    * Beobachten der Systemreaktion auf diese Befehle.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage, da viele verschiedene System-Interaktionen und UI-Elemente)

---

### **novade-ui/src/components/power_indicator/controller.rs**

**Verantwortlichkeit:**
Implementiert den `PowerIndicatorController`, der die logische Steuerung für den Akku- und Energie-Indikator übernimmt. Er abonniert Events vom `PowerManagementService` und `DisplayManagementService` der Systemschicht sowie dem `GlobalSettingsService` der Domänenschicht, um Änderungen am Akku-Status, der Helligkeit und dem Energiesparmodus zu erkennen und das UI-Widget sowie das Detail-Popover entsprechend zu aktualisieren. Er leitet auch Steuerungsbefehle an die System-/Domänenschicht weiter.

**Kern-Aufgaben (Tasks):**

1.  **`PowerIndicatorController` Struktur:**
    * Felder:
        * `power_management_service: Arc<PowerManagementService>`
        * `display_management_service: Arc<DisplayManagementService>`
        * `global_settings_service: Arc<GlobalSettingsService>`
        * `power_indicator_widget: Arc<PowerIndicator>` (Referenz auf das GTK-Widget selbst).
        * `power_details_popover: Arc<PowerDetailsPopover>` (Das Popover mit Details und Steuerungen).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>`.

2.  **`PowerIndicatorController::new()` Funktion:**
    * `pub fn new(power_service: Arc<PowerManagementService>, display_service: Arc<DisplayManagementService>, settings_service: Arc<GlobalSettingsService>) -> Result<Arc<Self>, PowerIndicatorError>`
    * Speichert die Referenzen zu den Services.
    * Erstellt eine Instanz des `PowerIndicator` GTK-Widgets.
    * Erstellt eine Instanz des `PowerDetailsPopover` (übergibt die relevanten Services an das Popover).
    * Verbindet das Klick-Signal des `power_indicator_widget`:
        * Bei Klick: `self.power_details_popover.show_popover_at_widget(&self.power_indicator_widget.get_widget());`
    * Speichert die Instanzen.

3.  **`PowerIndicatorController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt asynchrone Tasks (`glib::MainContext::spawn_local`) für die Event-Listener.
    * **Listener-Task für `PowerManagementService` Status-Änderungen:**
        * `let indicator_clone = self.power_indicator_widget.clone();`
        * `let popover_clone = self.power_details_popover.clone();`
        * `let display_service_clone = self.display_management_service.clone();`
        * `let settings_service_clone = self.global_settings_service.clone();`
        * `let mut power_status_rx = self.power_management_service.subscribe_to_power_status_changes();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `while let Ok(power_status) = power_status_rx.recv().await {`
        * `let brightness = display_service_clone.get_current_brightness().await.unwrap_or(0.0);`
        * `let energy_saver_enabled = settings_service_clone.get_energy_saver_mode().await.unwrap_or(false);`
        * `let dpms_timeout = display_service_clone.get_dpms_timeout().await.unwrap_or(0);`
        * `indicator_clone.update_status(&power_status);`
        * `popover_clone.update_status(&power_status, brightness, energy_saver_enabled, dpms_timeout);`
        * `}`
        * `Ok(())`
        * `}));`
    * **Listener-Task für `DisplayManagementService` Helligkeits-Änderungen:**
        * `let popover_clone = self.power_details_popover.clone();`
        * `let power_service_clone = self.power_management_service.clone();`
        * `let settings_service_clone = self.global_settings_service.clone();`
        * `let mut brightness_rx = self.display_management_service.subscribe_to_brightness_changes();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `while let Ok(brightness) = brightness_rx.recv().await {`
        * `let power_status = power_service_clone.get_current_power_status().await.unwrap_or_default();`
        * `let energy_saver_enabled = settings_service_clone.get_energy_saver_mode().await.unwrap_or(false);`
        * `let dpms_timeout = power_service_clone.get_dpms_timeout().await.unwrap_or(0);`
        * `popover_clone.update_status(&power_status, brightness, energy_saver_enabled, dpms_timeout);`
        * `}`
        * `Ok(())`
        * `}));`
    * **Listener-Task für `GlobalSettingsService` Energiesparmodus-Änderungen:**
        * `let popover_clone = self.power_details_popover.clone();`
        * `let power_service_clone = self.power_management_service.clone();`
        * `let display_service_clone = self.display_management_service.clone();`
        * `let mut energy_saver_rx = self.global_settings_service.subscribe_to_energy_saver_mode_changes();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `while let Ok(energy_saver_enabled) = energy_saver_rx.recv().await {`
        * `let power_status = power_service_clone.get_current_power_status().await.unwrap_or_default();`
        * `let brightness = display_service_clone.get_current_brightness().await.unwrap_or(0.0);`
        * `let dpms_timeout = power_service_clone.get_dpms_timeout().await.unwrap_or(0);`
        * `popover_clone.update_status(&power_status, brightness, energy_saver_enabled, dpms_timeout);`
        * `}`
        * `Ok(())`
        * `}));`
    * **Initialer Status-Update:** Ruft einmalig `get_current_power_status()`, `get_current_brightness()`, `get_energy_saver_mode()` und `get_dpms_timeout()` auf und aktualisiert sowohl den Indikator als auch das Popover.

4.  **`PowerIndicatorController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

5.  **`PowerIndicatorController::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> Arc<PowerIndicator>`
    * Gibt die Referenz auf das `PowerIndicator` Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/power_indicator/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::power_indicator::power_indicator_widget::PowerIndicator`
    * `crate::components::power_indicator::power_details_popover::PowerDetailsPopover`
    * `crate::components::power_indicator::error::PowerIndicatorError`
    * `novade_system::power_management::service::PowerManagementService`
    * `novade_system::power_management::data_types::PowerStatus`
    * `novade_system::display_management::service::DisplayManagementService`
    * `novade_domain::settings::service::GlobalSettingsService`
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`

**Kommunikationsmuster:**

* **Initialisiert und verwaltet das `PowerIndicator` GTK-Widget und das `PowerDetailsPopover`.**
* **Abonniert Events von `PowerManagementService`, `DisplayManagementService` (Systemschicht) und `GlobalSettingsService` (Domänenschicht).**
* **Aktualisiert den Zustand beider UI-Komponenten auf Basis empfangener Events.**
* **Öffnet das `PowerDetailsPopover` bei Klick auf den Indikator.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller Controller, der den Akku- und Energie-Indikator sowie das Detail-Popover aktuell hält und Benutzerinteraktionen verarbeitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `PowerManagementService`, `DisplayManagementService`, `GlobalSettingsService`.
    * Mocken des `PowerIndicator` Widgets und des `PowerDetailsPopover`.
    * Testen der `new()`-Funktion: Verifizieren, dass Services, Indicator und Popover korrekt gespeichert und Signale verbunden werden.
    * Testen der `start_listeners()`: Simulieren von Events von den gemockten Services und Prüfen, ob `update_status` beider UI-Komponenten aufgerufen wird.
    * Testen des Klick-Handlings: Simulieren eines Klicks auf den Indicator und prüfen, ob `show_popover_at_widget` des Popovers aufgerufen wird.
* **Integration Tests:**
    * Starten der NovaDE.
    * Manipulieren des Akku-Status, Helligkeit, Energiesparmodus (manuell oder über System-Tools).
    * Visuelle Inspektion, ob der Indikator im Panel und das Popover korrekt aktualisiert werden.
    * Testen der Steuerungen im Popover (Helligkeit, Energiesparmodus, Timeout, Herunterfahren/Neustart/Sperren/Suspend).

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da Integration von drei Services und Popover-Logik)

---
### **novade-ui/src/components/network_indicator/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die den Netzwerk-Indikator im Panel bilden. Es umfasst sowohl WLAN- als auch Bluetooth-Status und zugehörige Popover für Details und Einstellungen.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod network_indicator_widget;` (Das Panel-Widget, das den Netzwerkstatus anzeigt)
    * `pub mod controller;` (Der Controller, der die Logik verwaltet und mit dem `NetworkManagementService` interagiert)
    * `pub mod error;` (Fehler-Enum für das Modul)
    * `pub mod network_details_popover;` (Das Popover mit detaillierten Netzwerk-Informationen und Steuerungen für WLAN und Bluetooth)
    * `pub mod wifi_list_widget;` (Ein Widget zur Anzeige und Auswahl verfügbarer WLAN-Netzwerke)
    * `pub mod bluetooth_devices_widget;` (Ein Widget zur Anzeige und Verwaltung gekoppelter/verfügbarer Bluetooth-Geräte)

2.  **Re-Exporte (`pub use`):**
    * `pub use network_indicator_widget::NetworkIndicator;`
    * `pub use controller::NetworkIndicatorController;`
    * `pub use error::NetworkIndicatorError;`
    * `pub use network_details_popover::NetworkDetailsPopover;`
    * `pub use wifi_list_widget::WifiListWidget;`
    * `pub use bluetooth_devices_widget::BluetoothDevicesWidget;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* `NetworkIndicatorController` wird von `UiServices` initialisiert.
* `NetworkIndicator` und `NetworkDetailsPopover` werden vom Controller verwaltet.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für den Netzwerk-Indikator und seine Popover.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/network_indicator/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`NetworkIndicatorError`) für das Netzwerk-Indikator-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkIndicatorError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `SystemServiceError(#[from] novade_system::SystemServiceError)`: Fehler von der Systemschicht (z.B. NetworkManager/Bluetooth-Interaktion).
        * `ConnectionError(String)`: Fehler bei der Netzwerkverbindung.
        * `InvalidData(String)`: Ungültige Daten empfangen (z.B. von D-Bus).
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_system::SystemServiceError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `network_indicator`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für den Netzwerk-Indikator.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `NetworkIndicatorError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/network_indicator/network_indicator_widget.rs**

**Verantwortlichkeit:**
Implementiert das GTK-Widget für den Netzwerk-Indikator im Panel, das den aktuellen Konnektivitätsstatus (z.B. WLAN verbunden, kein Netzwerk) und Bluetooth-Status anzeigt.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkIndicator` Struktur:**
    * Ist ein Wrapper um `gtk::Button` oder `gtk::Box`.
    * Felder:
        * `container: gtk::Box` (oder `gtk::Button`).
        * `icon: gtk::Image` (Netzwerk-Icon, z.B. WLAN-Stärke, Ethernet, kein Netzwerk).
        * `status_label: gtk::Label` (Optional: Name des verbundenen Netzwerks oder "Verbunden/Nicht verbunden").
        * `bluetooth_icon: gtk::Image` (Optional: Bluetooth-Icon, wenn aktiv).

2.  **`NetworkIndicator::new()` Funktion:**
    * `pub fn new() -> Result<Self, NetworkIndicatorError>`
    * Erstellt die `gtk::Box` und die Kind-Widgets (`icon`, `status_label`, `bluetooth_icon`).
    * Ordnet sie im `container` an.
    * Setzt CSS-Klassen "nova-network-indicator".
    * Initialisiert mit einem Standard-Icon und leerem Label.

3.  **`NetworkIndicator::update_status()` Methode:**
    * `pub fn update_status(&self, network_status: &NetworkStatus, bluetooth_enabled: bool)`
    * Empfängt `NetworkStatus` und `bluetooth_enabled` von der Systemschicht.
    * **Netzwerk-Icon-Logik:**
        * Basierend auf `network_status.connectivity` und `network_status.active_connections`:
            * Wählt das korrekte `icon` (z.B. `network-wired-symbolic`, `network-wireless-signal-good-symbolic`, `network-wireless-no-route-symbolic`, `network-offline-symbolic`).
            * Wenn WLAN, Icon-Stärke basierend auf `network_status.signal_strength`.
    * **Status-Label-Logik:**
        * Aktualisiert `status_label` mit dem Namen der aktiven Verbindung oder "Verbunden"/"Nicht verbunden". Macht Label unsichtbar, wenn kein Text angezeigt werden soll.
    * **Bluetooth-Icon-Logik:**
        * Zeigt `bluetooth_icon` an/versteckt es basierend auf `bluetooth_enabled`.
        * Wählt `bluetooth-symbolic` Icon.
    * Fügt/entfernt CSS-Klassen basierend auf dem Status (z.B. "connected", "offline", "wifi", "bluetooth-active").

4.  **`NetworkIndicator::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/network_indicator_widget.rs`
* `novade-ui/resources/ui/network_indicator.ui` (optional)

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::network_indicator::error::NetworkIndicatorError`
    * `novade_system::network_management::data_types::{NetworkStatus, NetworkType}`
* **Extern:** `gtk::{self, prelude::*, Box, Button, Image, Label, glib, Widget}`

**Kommunikationsmuster:**

* Wird von `Panel` instanziiert.
* Wird vom `NetworkIndicatorController` aktualisiert.
* Emittiert Klick-Events, die vom `NetworkIndicatorController` verarbeitet werden, um das Detail-Popover zu öffnen.

**Erwartete Ergebnisse/Outputs:**
Ein funktionaler Netzwerk-Indikator im Panel, der den aktuellen Status anzeigt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion: Initialisierung der Widgets, CSS-Klassen.
    * Testen von `update_status()` mit verschiedenen `NetworkStatus` und `bluetooth_enabled` Werten:
        * WLAN verbunden (verschiedene Signalstärken), Ethernet verbunden, kein Netzwerk.
        * Bluetooth aktiv/inaktiv.
        * Kombinationen davon.
        * Verifizieren der korrekten Icon-Auswahl, Label-Texte und Sichtbarkeit.
* **Integration Tests:**
    * Starten der NovaDE.
    * Ändern des Netzwerk-Status (WLAN an/aus, Verbindung herstellen/trennen, Bluetooth an/aus).
    * Visuelle Inspektion, ob Icons und Labels im Panel korrekt aktualisiert werden.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage)

---

### **novade-ui/src/components/network_indicator/wifi_list_widget.rs**

**Verantwortlichkeit:**
Implementiert ein GTK-Widget zur Anzeige einer Liste verfügbarer WLAN-Netzwerke mit deren Signalstärke und Sicherheitsstatus. Ermöglicht die Auswahl und Verbindung zu einem Netzwerk.

**Kern-Aufgaben (Tasks):**

1.  **`WifiListWidget` Struktur:**
    * Ist ein Wrapper um `gtk::ListBox`.
    * Felder:
        * `list_box: gtk::ListBox`.
        * `connect_callback: RefCell<Option<Box<dyn Fn(String)>>>` (Callback für Netzwerkverbindung).
        * `active_connection_id: RefCell<Option<String>>` (SSID des aktuell verbundenen Netzwerks).

2.  **`WifiListWidget::new()` Funktion:**
    * `pub fn new() -> Result<Self, NetworkIndicatorError>`
    * Erstellt eine `gtk::ListBox`.
    * Setzt CSS-Klassen "nova-wifi-list".
    * `list_box.set_selection_mode(gtk::SelectionMode::None)`.

3.  **`WifiListWidget::update_networks()` Methode:**
    * `pub fn update_networks(&self, networks: Vec<WifiNetwork>, active_ssid: Option<String>)`
    * Löscht alle vorhandenen Zeilen aus `list_box`.
    * Speichert `active_ssid` in `active_connection_id`.
    * Für jedes `WifiNetwork` in `networks`:
        * Erstellt eine `gtk::ListBoxRow`.
        * Innerhalb der Row: `gtk::Box` mit `gtk::Image` (Signalstärke-Icon), `gtk::Label` (SSID), `gtk::Image` (Sicherheitsschloss-Icon, wenn gesichert).
        * Wenn `network.ssid == active_ssid`, fügt die CSS-Klasse "active-network" zur Row hinzu.
        * `row.set_activatable(true)`.
        * Verbindet `row.connect_activate()` mit einem Closure, das die SSID des Netzwerks an `connect_callback` weiterleitet.
        * Fügt die Row zur `list_box` hinzu.

4.  **`WifiListWidget::set_connect_callback()` Methode:**
    * `pub fn set_connect_callback<F>(&self, callback: F)`
    * `where F: Fn(String) + 'static`
    * Speichert den Callback, der aufgerufen wird, wenn der Benutzer ein Netzwerk auswählt.

5.  **`WifiListWidget::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/wifi_list_widget.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::network_indicator::error::NetworkIndicatorError`
    * `novade_system::network_management::data_types::WifiNetwork`
* **Extern:** `gtk::{self, prelude::*, Box, Image, Label, ListBox, ListBoxRow, glib, Widget}`
    * `std::cell::RefCell`

**Kommunikationsmuster:**

* Wird von `NetworkDetailsPopover` instanziiert.
* Empfängt eine Liste von `WifiNetwork` Objekten vom Controller und rendert sie.
* Emittiert eine `connect_callback` mit der SSID des ausgewählten Netzwerks, die vom Controller verarbeitet wird.

**Erwartete Ergebnisse/Outputs:**
Eine interaktive Liste verfügbarer WLAN-Netzwerke.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion: Korrekte Initialisierung der `ListBox`, CSS-Klassen.
    * Testen von `update_networks()` mit verschiedenen Szenarien:
        * Leere Liste.
        * Liste mit einem offenen Netzwerk, einem gesicherten Netzwerk.
        * Liste mit mehreren Netzwerken, davon eines aktiv.
        * Verifizieren der korrekten Anzahl von Rows, SSID-Labels, Icon-Auswahl und "active-network" CSS-Klasse.
    * Simulieren eines Klicks auf eine ListBoxRow und Prüfen, ob der `connect_callback` mit der korrekten SSID aufgerufen wird.
* **Integration Tests:**
    * Starten der NovaDE.
    * Verfügbare WLAN-Netzwerke in der Umgebung.
    * Öffnen des Popovers und visuelle Inspektion der WLAN-Liste.
    * Klicken auf ein Netzwerk und Verifizieren der Verbindungsversuch.

**Geschätzter Aufwand:** Mittel (ca. 3-4 Tage, da dynamische Listengenerierung und Icon-Logik)

---

### **novade-ui/src/components/network_indicator/bluetooth_devices_widget.rs**

**Verantwortlichkeit:**
Implementiert ein GTK-Widget zur Anzeige einer Liste erkannter und gekoppelter Bluetooth-Geräte. Ermöglicht das Koppeln, Entkoppeln und Verbinden/Trennen von Geräten.

**Kern-Aufgaben (Tasks):**

1.  **`BluetoothDevicesWidget` Struktur:**
    * Ist ein Wrapper um `gtk::ListBox`.
    * Felder:
        * `list_box: gtk::ListBox`.
        * `connect_disconnect_callback: RefCell<Option<Box<dyn Fn(String, bool)>>>` (Callback für Verbinden/Trennen, `device_address`, `connect`).
        * `pair_unpair_callback: RefCell<Option<Box<dyn Fn(String, bool)>>>` (Callback für Koppeln/Entkoppeln, `device_address`, `pair`).

2.  **`BluetoothDevicesWidget::new()` Funktion:**
    * `pub fn new() -> Result<Self, NetworkIndicatorError>`
    * Erstellt eine `gtk::ListBox`.
    * Setzt CSS-Klassen "nova-bluetooth-devices-list".
    * `list_box.set_selection_mode(gtk::SelectionMode::None)`.

3.  **`BluetoothDevicesWidget::update_devices()` Methode:**
    * `pub fn update_devices(&self, devices: Vec<BluetoothDevice>)`
    * Löscht alle vorhandenen Zeilen aus `list_box`.
    * Für jedes `BluetoothDevice` in `devices`:
        * Erstellt eine `gtk::ListBoxRow`.
        * Innerhalb der Row: `gtk::Box` mit `gtk::Image` (Gerätetyp-Icon), `gtk::Label` (Gerätename).
        * Fügt Aktionsbuttons hinzu (z.B. "Verbinden"/"Trennen", "Koppeln"/"Entkoppeln") basierend auf `device.is_connected` und `device.is_paired`.
        * Verbindet `clicked` Signale der Buttons mit Closures, die die Geräteadresse und den Aktionstyp an die entsprechenden Callbacks weiterleiten.
        * Fügt die Row zur `list_box` hinzu.

4.  **`BluetoothDevicesWidget::set_connect_disconnect_callback()` Methode:**
    * `pub fn set_connect_disconnect_callback<F>(&self, callback: F)`
    * `where F: Fn(String, bool) + 'static`
    * Speichert den Callback.

5.  **`BluetoothDevicesWidget::set_pair_unpair_callback()` Methode:**
    * `pub fn set_pair_unpair_callback<F>(&self, callback: F)`
    * `where F: Fn(String, bool) + 'static`
    * Speichert den Callback.

6.  **`BluetoothDevicesWidget::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/bluetooth_devices_widget.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::network_indicator::error::NetworkIndicatorError`
    * `novade_system::network_management::data_types::BluetoothDevice`
* **Extern:** `gtk::{self, prelude::*, Box, Image, Label, Button, ListBox, ListBoxRow, glib, Widget}`
    * `std::cell::RefCell`

**Kommunikationsmuster:**

* Wird von `NetworkDetailsPopover` instanziiert.
* Empfängt eine Liste von `BluetoothDevice` Objekten vom Controller und rendert sie.
* Emittiert Callbacks für Verbinden/Trennen und Koppeln/Entkoppeln von Geräten, die vom Controller verarbeitet werden.

**Erwartete Ergebnisse/Outputs:**
Eine interaktive Liste von Bluetooth-Geräten.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion: Korrekte Initialisierung der `ListBox`, CSS-Klassen.
    * Testen von `update_devices()` mit verschiedenen Szenarien:
        * Leere Liste.
        * Liste mit gekoppelten, verbundenen, nur erkannten Geräten.
        * Verifizieren der korrekten Anzeige von Gerätenamen, Icons und Verfügbarkeit der Aktionsbuttons.
    * Simulieren von Klicks auf Aktionsbuttons und Prüfen, ob die Callbacks mit den korrekten Geräteadressen und Aktionen aufgerufen werden.
* **Integration Tests:**
    * Starten der NovaDE.
    * Bluetooth-Geräte in der Nähe einschalten/koppeln.
    * Öffnen des Popovers und visuelle Inspektion der Bluetooth-Liste.
    * Testen von Koppeln, Verbinden und Trennen von Geräten über die UI.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da dynamische Listengenerierung, Aktionsbuttons und State-Management)

---

### **novade-ui/src/components/network_indicator/network_details_popover.rs**

**Verantwortlichkeit:**
Implementiert das `gtk::Popover` oder `gtk::Window`, das detaillierte Netzwerk- und Bluetooth-Informationen sowie Steuerungen anzeigt. Es integriert die `WifiListWidget` und `BluetoothDevicesWidget`.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkDetailsPopover` Struktur:**
    * Ist ein Wrapper um `gtk::Popover` oder `gtk::Window`.
    * Felder:
        * `container: gtk::Widget` (Das Popover/Window).
        * `wifi_toggle: gtk::Switch` (WLAN an/aus).
        * `bluetooth_toggle: gtk::Switch` (Bluetooth an/aus).
        * `main_connection_status_label: gtk::Label` (Zusammenfassender Status).
        * `wifi_list_widget: WifiListWidget`.
        * `bluetooth_devices_widget: BluetoothDevicesWidget`.
        * `open_network_settings_button: gtk::Button` (Button zum Öffnen der vollständigen Netzwerkeinstellungen).
        * `network_management_service: Arc<NetworkManagementService>` (Direkte Referenz zur Interaktion).
        * `global_settings_service: Arc<GlobalSettingsService>` (Für Einstellungen öffnen).

2.  **`NetworkDetailsPopover::new()` Funktion:**
    * `pub fn new(network_service: Arc<NetworkManagementService>, settings_service: Arc<GlobalSettingsService>) -> Result<Self, NetworkIndicatorError>`
    * Lädt die UI-Definition (`network_details_popover.ui`).
    * Initialisiert die Widgets und speichert die Service-Referenzen.
    * Setzt Initialzustände.
    * **Verbindet Signale:**
        * `wifi_toggle.connect_state_set()`: Ruft `network_management_service.set_radio_enabled(new_state, NetworkType::Wifi)` auf.
        * `bluetooth_toggle.connect_state_set()`: Ruft `network_management_service.set_radio_enabled(new_state, NetworkType::Bluetooth)` auf.
        * `open_network_settings_button.connect_clicked()`: Ruft `global_settings_service.open_settings_app(Some(SettingsCategory::Network))` auf.
        * **Verbindet Callbacks der Unter-Widgets:**
            * `wifi_list_widget.set_connect_callback()`: Leitet an `network_management_service.connect_to_wifi()` weiter.
            * `bluetooth_devices_widget.set_connect_disconnect_callback()`: Leitet an `network_management_service.connect_bluetooth_device()` / `disconnect_bluetooth_device()` weiter.
            * `bluetooth_devices_widget.set_pair_unpair_callback()`: Leitet an `network_management_service.pair_bluetooth_device()` / `unpair_bluetooth_device()` weiter.
    * Setzt CSS-Klassen "nova-network-details-popover".

3.  **`NetworkDetailsPopover::update_status()` Methode:**
    * `pub fn update_status(&self, network_status: &NetworkStatus, bluetooth_enabled: bool, wifi_networks: Vec<WifiNetwork>, bluetooth_devices: Vec<BluetoothDevice>)`
    * Aktualisiert `wifi_toggle` mit `network_status.wifi_enabled`.
    * Aktualisiert `bluetooth_toggle` mit `bluetooth_enabled`.
    * Aktualisiert `main_connection_status_label` (z.B. "Verbunden mit WLAN: MyHome", "Offline").
    * Ruft `wifi_list_widget.update_networks(wifi_networks, network_status.active_connections.first().map(|c| c.ssid.clone()))` auf (falls `active_connections` WLAN enthält).
    * Ruft `bluetooth_devices_widget.update_devices(bluetooth_devices)` auf.
    * Aktiviert/Deaktiviert WLAN/Bluetooth-Sektionen basierend auf dem Status (z.B. WLAN-Liste unsichtbar, wenn WLAN-Toggle aus ist).

4.  **`NetworkDetailsPopover::show_popover_at_widget()` Methode:**
    * `pub fn show_popover_at_widget(&self, widget: &impl IsA<gtk::Widget>)`
    * Zeigt das Popover an.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/network_details_popover.rs`
* `novade-ui/resources/ui/network_details_popover.ui`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::network_indicator::error::NetworkIndicatorError`
    * `crate::components::network_indicator::wifi_list_widget::WifiListWidget`
    * `crate::components::network_indicator::bluetooth_devices_widget::BluetoothDevicesWidget`
    * `novade_system::network_management::service::NetworkManagementService`
    * `novade_system::network_management::data_types::{NetworkStatus, WifiNetwork, BluetoothDevice, NetworkType}`
    * `novade_domain::settings::service::GlobalSettingsService`
    * `novade_domain::settings::data_types::SettingsCategory`
* **Extern:**
    * `gtk::{self, prelude::*, Popover, Window, Label, Switch, Button, glib, IsA, Widget}`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Wird vom `NetworkIndicatorController` erstellt und angezeigt.
* Empfängt Status-Updates für Netzwerk und Bluetooth vom `NetworkIndicatorController`.
* Interagiert direkt mit `NetworkManagementService` um Benutzerbefehle auszuführen (WLAN/Bluetooth ein/aus, verbinden, koppeln etc.).
* Interagiert mit `GlobalSettingsService` zum Öffnen der Einstellungen.

**Erwartete Ergebnisse/Outputs:**
Ein interaktives Popover, das detaillierte Netzwerk- und Bluetooth-Informationen und Steuerungen bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NetworkManagementService`, `GlobalSettingsService`.
    * Mocken von `WifiListWidget` und `BluetoothDevicesWidget`.
    * Testen der `new()`-Funktion: Korrekte Initialisierung der Widgets, Signal-Verbindungen und Callback-Weiterleitung.
    * Testen von `update_status()` mit verschiedenen Status-Werten:
        * WLAN an/aus, Bluetooth an/aus.
        * Verschiedene Netzwerkstatus-Details.
        * Verifizieren der korrekten Toggle-Zustände, Status-Label und Aufrufe an die gemockten Unter-Widgets.
    * Simulieren von Toggle-Aktionen und Button-Klicks und Prüfen, ob die korrekten Aufrufe an die gemockten Services erfolgen.
* **Integration Tests:**
    * Starten der NovaDE.
    * Öffnen des Popovers.
    * Visuelle Inspektion der angezeigten Informationen und Steuerungen.
    * Testen aller Steuerungen (WLAN/Bluetooth Toggles, Verbinden/Trennen von WLAN, Koppeln/Verbinden von Bluetooth-Geräten).
    * Beobachten der Systemreaktion auf diese Befehle.

**Geschätzter Aufwand:** Sehr hoch (ca. 6-9 Tage, da viele Sub-Widgets, Status-Updates und komplexe Interaktionen)

---

### **novade-ui/src/components/network_indicator/controller.rs**

**Verantwortlichkeit:**
Implementiert den `NetworkIndicatorController`, der die logische Steuerung für den Netzwerk-Indikator übernimmt. Er abonniert Events vom `NetworkManagementService` der Systemschicht und aktualisiert das UI-Widget sowie das Detail-Popover entsprechend. Er leitet auch Steuerungsbefehle an die Systemschicht weiter.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkIndicatorController` Struktur:**
    * Felder:
        * `network_management_service: Arc<NetworkManagementService>`
        * `global_settings_service: Arc<GlobalSettingsService>`
        * `network_indicator_widget: Arc<NetworkIndicator>` (Referenz auf das GTK-Widget selbst).
        * `network_details_popover: Arc<NetworkDetailsPopover>` (Das Popover mit Details und Steuerungen).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>`.

2.  **`NetworkIndicatorController::new()` Funktion:**
    * `pub fn new(network_service: Arc<NetworkManagementService>, settings_service: Arc<GlobalSettingsService>) -> Result<Arc<Self>, NetworkIndicatorError>`
    * Speichert die Referenzen zu den Services.
    * Erstellt eine Instanz des `NetworkIndicator` GTK-Widgets.
    * Erstellt eine Instanz des `NetworkDetailsPopover` (übergibt die relevanten Services an das Popover).
    * Verbindet das Klick-Signal des `network_indicator_widget`:
        * Bei Klick: `self.network_details_popover.show_popover_at_widget(&self.network_indicator_widget.get_widget());`
    * Speichert die Instanzen.

3.  **`NetworkIndicatorController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt asynchrone Tasks (`glib::MainContext::spawn_local`) für die Event-Listener.
    * **Listener-Task für `NetworkManagementService` Status-Änderungen:**
        * `let indicator_clone = self.network_indicator_widget.clone();`
        * `let popover_clone = self.network_details_popover.clone();`
        * `let network_service_clone = self.network_management_service.clone();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `let mut network_status_rx = network_service_clone.subscribe_to_network_status_changes();`
        * `let mut bluetooth_status_rx = network_service_clone.subscribe_to_bluetooth_status_changes();`
        * `// Initialer Status-Fetch für beide`
        * `let mut current_network_status = network_service_clone.get_current_network_status().await.unwrap_or_default();`
        * `let mut current_bluetooth_enabled = network_service_clone.get_bluetooth_enabled().await.unwrap_or(false);`
        * `indicator_clone.update_status(&current_network_status, current_bluetooth_enabled);`
        * `popover_clone.update_status(&current_network_status, current_bluetooth_enabled, network_service_clone.get_available_wifi_networks().await.unwrap_or_default(), network_service_clone.get_bluetooth_devices().await.unwrap_or_default());`
        * `loop {`
        * `tokio::select! {`
        * `Ok(status) = network_status_rx.recv() => {`
        * `current_network_status = status;`
        * `}`
        * `Ok(enabled) = bluetooth_status_rx.recv() => {`
        * `current_bluetooth_enabled = enabled;`
        * `}`
        * `}`
        * `indicator_clone.update_status(&current_network_status, current_bluetooth_enabled);`
        * `// Bei Netzwerk- oder Bluetooth-Änderungen das Popover aktualisieren`
        * `let wifi_networks = network_service_clone.get_available_wifi_networks().await.unwrap_or_default();`
        * `let bluetooth_devices = network_service_clone.get_bluetooth_devices().await.unwrap_or_default();`
        * `popover_clone.update_status(&current_network_status, current_bluetooth_enabled, wifi_networks, bluetooth_devices);`
        * `}`
        * `Ok(())`
        * `}));`

4.  **`NetworkIndicatorController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

5.  **`NetworkIndicatorController::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> Arc<NetworkIndicator>`
    * Gibt die Referenz auf das `NetworkIndicator` Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/network_indicator/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::network_indicator::network_indicator_widget::NetworkIndicator`
    * `crate::components::network_indicator::network_details_popover::NetworkDetailsPopover`
    * `crate::components::network_indicator::error::NetworkIndicatorError`
    * `novade_system::network_management::service::NetworkManagementService`
    * `novade_system::network_management::data_types::{NetworkStatus, WifiNetwork, BluetoothDevice}`
    * `novade_domain::settings::service::GlobalSettingsService`
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`
    * `tokio::select!`

**Kommunikationsmuster:**

* **Initialisiert und verwaltet das `NetworkIndicator` GTK-Widget und das `NetworkDetailsPopover`.**
* **Abonniert Events vom `NetworkManagementService` (Systemschicht).**
* **Aktualisiert den Zustand beider UI-Komponenten auf Basis empfangener Events.**
* **Öffnet das `NetworkDetailsPopover` bei Klick auf den Indikator.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller Controller, der den Netzwerk-Indikator sowie das Detail-Popover aktuell hält und Benutzerinteraktionen verarbeitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NetworkManagementService`, `GlobalSettingsService`.
    * Mocken des `NetworkIndicator` Widgets und des `NetworkDetailsPopover`.
    * Testen der `new()`-Funktion: Verifizieren, dass Services, Indicator und Popover korrekt gespeichert und Signale verbunden werden.
    * Testen der `start_listeners()`: Simulieren von Netzwerk- und Bluetooth-Events von den gemockten Services und Prüfen, ob `update_status` beider UI-Komponenten aufgerufen wird.
    * Testen des Klick-Handlings: Simulieren eines Klicks auf den Indicator und prüfen, ob `show_popover_at_widget` des Popovers aufgerufen wird.
* **Integration Tests:**
    * Starten der NovaDE.
    * Manipulieren des Netzwerk- und Bluetooth-Status (z.B. über `nmcli`, `bluetoothctl`, WLAN an/aus, Verbindungen herstellen).
    * Visuelle Inspektion, ob der Indikator im Panel und das Popover korrekt aktualisiert werden.
    * Testen der Steuerungen im Popover (WLAN/Bluetooth Toggles, WLAN-Verbindungen, Bluetooth-Geräteverwaltung).

**Geschätzter Aufwand:** Sehr hoch (ca. 8-12 Tage, da komplexe Zustandsverwaltung und Interaktion mit zwei separaten Listen/Gerätetypen im Popover)
### **novade-ui/src/components/notification_center/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die das Benachrichtigungszentrum und die individuellen Benachrichtigungs-Widgets bilden. Es ist verantwortlich für die Anzeige, Verwaltung und Interaktion mit System- und Anwendungsbenachrichtigungen.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod notification_center_panel;` (Das Haupt-Panel oder Popover des Benachrichtigungszentrums)
    * `pub mod notification_widget;` (Das Widget für eine einzelne Benachrichtigung)
    * `pub mod controller;` (Der Controller, der die Logik verwaltet und mit dem `NotificationService` interagiert)
    * `pub mod error;` (Fehler-Enum für das Modul)

2.  **Re-Exporte (`pub use`):**
    * `pub use notification_center_panel::NotificationCenterPanel;`
    * `pub use notification_widget::NotificationWidget;`
    * `pub use controller::NotificationCenterController;`
    * `pub use error::NotificationCenterError;`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/notification_center/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* `NotificationCenterController` wird von `UiServices` initialisiert.
* `NotificationCenterPanel` und `NotificationWidget` werden vom Controller verwaltet.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für das Benachrichtigungszentrum.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/notification_center/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`NotificationCenterError`) für das Benachrichtigungszentrum-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationCenterError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `NotificationServiceError(#[from] novade_domain::notification_management::error::NotificationError)`: Fehler von der Domänenschicht.
        * `InvalidData(String)`: Ungültige Daten empfangen (z.B. von einer Benachrichtigung).
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/notification_center/error.rs`

**Abhängigkeiten:**

* **Intern:** `novade_domain::notification_management::error::NotificationError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `notification_center`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für das Benachrichtigungszentrum.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `NotificationCenterError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/notification_center/notification_widget.rs**

**Verantwortlichkeit:**
Implementiert das GTK-Widget, das eine einzelne Benachrichtigung anzeigt. Dies umfasst Titel, Body, App-Icon, ggf. ein Bild, Fortschrittsbalken und Aktionen (Buttons).

**Kern-Aufgaben (Tasks):**

1.  **`NotificationWidget` Struktur:**
    * Ist ein Wrapper um `gtk::Box`.
    * Felder:
        * `container: gtk::Box`.
        * `app_icon: gtk::Image`.
        * `title_label: gtk::Label`.
        * `body_label: gtk::Label`.
        * `image_area: gtk::Image` (optional, für Inline-Bilder).
        * `progress_bar: gtk::ProgressBar` (optional, für Benachrichtigungen mit Fortschritt).
        * `actions_box: gtk::Box` (Container für Aktionsbuttons).
        * `close_button: gtk::Button` (Optional, zum Schließen der Benachrichtigung).
        * `notification_id: u32` (ID der Benachrichtigung).
        * `action_callback: RefCell<Option<Box<dyn Fn(u32, String)>>>` (Callback für Aktions-Buttons).
        * `close_callback: RefCell<Option<Box<dyn Fn(u32)>>>` (Callback für Schließen).

2.  **`NotificationWidget::new()` Funktion:**
    * `pub fn new(notification: &Notification) -> Result<Self, NotificationCenterError>`
    * Erstellt die `gtk::Box` und die statischen Kind-Widgets.
    * Setzt CSS-Klassen "nova-notification-widget".
    * Ruft `update_content()` auf, um die Benachrichtigungsdetails zu füllen.

3.  **`NotificationWidget::update_content()` Methode:**
    * `pub fn update_content(&self, notification: &Notification)`
    * Setzt `notification_id`.
    * Setzt `app_icon` basierend auf `notification.app_icon`. Verwendet `gdk_pixbuf::PixbufLoader` oder `gtk::IconTheme` für das Laden.
    * Setzt `title_label.set_text(&notification.summary)`.
    * Setzt `body_label.set_text(&notification.body)`.
    * Handhabt `notification.image_path`: Lädt Bild in `image_area`, macht sichtbar/unsichtbar.
    * Handhabt `notification.progress`: Setzt `progress_bar.set_fraction()`, macht sichtbar/unsichtbar.
    * **Aktions-Buttons generieren:**
        * Löscht alte Buttons aus `actions_box`.
        * Für jedes Action-Paar in `notification.actions`: Erstellt `gtk::Button` mit dem Label der Aktion.
        * Verbindet `clicked` Signal des Buttons mit einem Closure, das `action_callback` mit `notification_id` und der `action_key` aufruft.
        * Fügt Buttons zu `actions_box` hinzu.
    * Handhabt `close_button`: Macht sichtbar, verbindet `clicked` Signal mit `close_callback`.
    * Setzt die Sichtbarkeit des `progress_bar` und `image_area` basierend auf der Existenz der Daten.

4.  **`NotificationWidget::update_progress()` Methode:**
    * `pub fn update_progress(&self, progress: Option<f64>)`
    * Wenn `progress` Some ist, aktualisiert `progress_bar.set_fraction()`.
    * Wenn `progress` None, versteckt `progress_bar`.

5.  **`NotificationWidget::set_action_callback()` Methode:**
    * `pub fn set_action_callback<F>(&self, callback: F)`
    * `where F: Fn(u32, String) + 'static`
    * Speichert den Callback für Aktions-Buttons.

6.  **`NotificationWidget::set_close_callback()` Methode:**
    * `pub fn set_close_callback<F>(&self, callback: F)`
    * `where F: Fn(u32) + 'static`
    * Speichert den Callback für den Schließen-Button.

7.  **`NotificationWidget::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/notification_center/notification_widget.rs`
* `novade-ui/resources/ui/notification_widget.ui` (optional)

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::notification_center::error::NotificationCenterError`
    * `novade_domain::notification_management::data_types::Notification`
* **Extern:** `gtk::{self, prelude::*, Box, Image, Label, ProgressBar, Button, glib, Widget}`
    * `gdk_pixbuf::{PixbufLoader, Pixbuf}`
    * `std::cell::RefCell`

**Kommunikationsmuster:**

* Wird von `NotificationCenterPanel` instanziiert.
* Empfängt `Notification` Objekte zur Darstellung.
* Emittiert Callbacks für Aktions-Buttons und Schließen an den Controller.

**Erwartete Ergebnisse/Outputs:**
Ein visuell ansprechendes und interaktives Widget für einzelne Benachrichtigungen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion mit verschiedenen `Notification` Varianten (mit/ohne Bild, mit/ohne Fortschritt, mit/ohne Aktionen).
    * Testen von `update_content()`: Verifizieren der korrekten Anzeige von Titel, Body, Icon, Bild, Fortschritt und Buttons.
    * Testen von `update_progress()`: Verifizieren der korrekten Aktualisierung des Fortschrittsbalkens.
    * Simulieren von Klicks auf Aktions-Buttons und Schließen-Button und Prüfen, ob die Callbacks mit den korrekten IDs und Aktionen aufgerufen werden.
* **Integration Tests:**
    * Starten der NovaDE.
    * Senden von Test-Benachrichtigungen über `notify-send`.
    * Visuelle Inspektion der angezeigten Benachrichtigungen und deren Inhalte.
    * Interagieren mit Aktions-Buttons und Schließen-Buttons.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da dynamische UI-Elemente, Bild- und Fortschrittshandling)

---

### **novade-ui/src/components/notification_center/notification_center_panel.rs**

**Verantwortlichkeit:**
Implementiert das Haupt-GTK-Panel oder Popover für das Benachrichtigungszentrum. Es aggregiert `NotificationWidget` Instanzen, bietet Optionen zum Löschen aller Benachrichtigungen und zum Umschalten von "Bitte nicht stören".

**Kern-Aufgaben (Tasks):**

1.  **`NotificationCenterPanel` Struktur:**
    * Ist ein Wrapper um `gtk::Popover` oder `gtk::Box`.
    * Felder:
        * `container: gtk::Widget` (Das Popover/Panel).
        * `header_label: gtk::Label` ("Benachrichtigungen").
        * `do_not_disturb_toggle: gtk::Switch`.
        * `clear_all_button: gtk::Button`.
        * `notifications_list_box: gtk::ListBox` (Container für `NotificationWidget`s).
        * `no_notifications_label: gtk::Label` ("Keine Benachrichtigungen").
        * `do_not_disturb_callback: RefCell<Option<Box<dyn Fn(bool)>>>` (Callback für DND-Toggle).
        * `clear_all_callback: RefCell<Option<Box<dyn Fn()>>>` (Callback für "Alle Löschen").

2.  **`NotificationCenterPanel::new()` Funktion:**
    * `pub fn new() -> Result<Self, NotificationCenterError>`
    * Lädt die UI-Definition (`notification_center_panel.ui`).
    * Initialisiert die Widgets und speichert die Service-Referenzen.
    * Setzt Initialzustände.
    * Verbindet `clicked` Signale von `clear_all_button` und `state-set` Signal von `do_not_disturb_toggle` mit internen Handlern, die die Callbacks auslösen.
    * Setzt CSS-Klassen "nova-notification-center-panel".

3.  **`NotificationCenterPanel::update_notifications()` Methode:**
    * `pub fn update_notifications(&self, notifications: &[Notification])`
    * Löscht alle vorhandenen `NotificationWidget`s aus `notifications_list_box`.
    * Für jede `Notification` in `notifications`:
        * Erstellt eine `NotificationWidget::new()`.
        * Setzt deren `action_callback` und `close_callback` (die an die Controller-Methoden weitergeleitet werden).
        * Fügt das `NotificationWidget` zur `notifications_list_box` hinzu.
    * Zeigt `no_notifications_label` an/versteckt es basierend darauf, ob `notifications` leer ist.

4.  **`NotificationCenterPanel::update_do_not_disturb_status()` Methode:**
    * `pub fn update_do_not_disturb_status(&self, enabled: bool)`
    * Setzt `do_not_disturb_toggle.set_state(enabled)`.

5.  **`NotificationCenterPanel::set_do_not_disturb_callback()` Methode:**
    * `pub fn set_do_not_disturb_callback<F>(&self, callback: F)`
    * `where F: Fn(bool) + 'static`
    * Speichert den Callback für den DND-Toggle.

6.  **`NotificationCenterPanel::set_clear_all_callback()` Methode:**
    * `pub fn set_clear_all_callback<F>(&self, callback: F)`
    * `where F: Fn() + 'static`
    * Speichert den Callback für den "Alle Löschen"-Button.

7.  **`NotificationCenterPanel::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/notification_center/notification_center_panel.rs`
* `novade-ui/resources/ui/notification_center_panel.ui`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::notification_center::error::NotificationCenterError`
    * `crate::components::notification_center::notification_widget::NotificationWidget`
    * `novade_domain::notification_management::data_types::Notification`
* **Extern:** `gtk::{self, prelude::*, Popover, Box, Label, Switch, Button, ListBox, glib, IsA, Widget}`
    * `std::cell::RefCell`

**Kommunikationsmuster:**

* Wird vom `NotificationCenterController` instanziiert und angezeigt.
* Empfängt eine Liste von `Notification` Objekten vom Controller zur Darstellung.
* Leitet Benutzerinteraktionen (DND-Toggle, "Alle Löschen", Aktionen auf einzelnen Benachrichtigungen, Schließen einzelner Benachrichtigungen) über Callbacks an den Controller weiter.

**Erwartete Ergebnisse/Outputs:**
Ein funktionales und übersichtliches Benachrichtigungszentrum.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NotificationWidget` (um nur die Panel-Logik zu testen).
    * Testen der `new()`-Funktion: Korrekte Initialisierung der Kind-Widgets und des Layouts.
    * Testen von `update_notifications()`:
        * Mit leerer Liste (sollte "Keine Benachrichtigungen" anzeigen).
        * Mit Liste von Benachrichtigungen (sollte korrekte Anzahl von `NotificationWidget`s erstellen und deren Callbacks setzen).
        * Verifizieren, dass `NotificationWidget::new()` aufgerufen und die Widgets zur `ListBox` hinzugefügt werden.
    * Testen von `update_do_not_disturb_status()`.
    * Simulieren von Klicks auf "Alle Löschen" und DND-Toggle und Prüfen, ob die Callbacks ausgelöst werden.
* **Integration Tests:**
    * Starten der NovaDE.
    * Senden/Empfangen von Benachrichtigungen.
    * Öffnen des Benachrichtigungszentrums.
    * Visuelle Inspektion der Benachrichtigungen.
    * Testen von "Alle Löschen" und DND-Toggle.
    * Testen von Aktionen und Schließen auf einzelnen Benachrichtigungen.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage, da dynamische Listenverwaltung und Integration von Unter-Widgets)

---

### **novade-ui/src/components/notification_center/controller.rs**

**Verantwortlichkeit:**
Implementiert den `NotificationCenterController`, der die logische Steuerung für das Benachrichtigungszentrum übernimmt. Er abonniert Events vom `NotificationService` der Domänenschicht, um neue Benachrichtigungen zu empfangen, bestehende zu aktualisieren oder zu entfernen. Er leitet auch Benutzerinteraktionen vom Panel an den `NotificationService` weiter.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationCenterController` Struktur:**
    * Felder:
        * `notification_service: Arc<NotificationService>`
        * `notification_center_panel: Arc<NotificationCenterPanel>` (Referenz auf das GTK-Panel selbst).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>`.
        * `active_notifications: RefCell<Vec<Notification>>` (In-Memory-Cache der aktuellen Benachrichtigungen, sortiert).

2.  **`NotificationCenterController::new()` Funktion:**
    * `pub fn new(notification_service: Arc<NotificationService>) -> Result<Arc<Self>, NotificationCenterError>`
    * Speichert die Referenz zum `NotificationService`.
    * Erstellt eine Instanz des `NotificationCenterPanel`.
    * **Verbindet Callbacks vom `NotificationCenterPanel` an den Service:**
        * `panel.set_do_not_disturb_callback(|enabled| { glib::spawn_future_local(async move { service.set_do_not_disturb(enabled) }); });`
        * `panel.set_clear_all_callback(|_| { glib::spawn_future_local(async move { service.clear_all_notifications() }); });`
        * **Calllbacks für einzelne NotificationWidgets (werden in `update_notifications` vom Panel gesetzt):**
            * `notification_widget.set_action_callback(|id, action_key| { glib::spawn_future_local(async move { service.invoke_notification_action(id, action_key) }); });`
            * `notification_widget.set_close_callback(|id| { glib::spawn_future_local(async move { service.close_notification(id) }); });`
    * Speichert die Instanzen.

3.  **`NotificationCenterController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt asynchrone Tasks (`glib::MainContext::spawn_local`) für die Event-Listener.
    * **Listener-Task für `NotificationService` Events (`NotificationEvent` Enum):**
        * `let panel_clone = self.notification_center_panel.clone();`
        * `let active_notifications_clone = self.active_notifications.clone();`
        * `let service_clone = self.notification_service.clone();`
        * `let mut notification_rx = service_clone.subscribe_to_notification_events();`
        * `let mut dnd_rx = service_clone.subscribe_to_do_not_disturb_changes();`
        * `self.listeners.push(glib::MainContext::spawn_local(async move {`
        * `// Initialer Status-Fetch`
        * `let initial_notifications = service_clone.get_active_notifications().await.unwrap_or_default();`
        * `*active_notifications_clone.borrow_mut() = initial_notifications;`
        * `panel_clone.update_notifications(&active_notifications_clone.borrow());`
        * `panel_clone.update_do_not_disturb_status(service_clone.get_do_not_disturb().await.unwrap_or(false));`
        * `loop {`
        * `tokio::select! {`
        * `Ok(event) = notification_rx.recv() => {`
        * `match event {`
        * `NotificationEvent::New(notification) => {`
        * `active_notifications_clone.borrow_mut().push(notification);`
        * `// Sortieren nach Zeitstempel, neueste zuerst`
        * `active_notifications_clone.borrow_mut().sort_by(|a, b| b.timestamp.cmp(&a.timestamp));`
        * `}`
        * `NotificationEvent::Updated(notification) => {`
        * `// Finde und aktualisiere Benachrichtigung in active_notifications`
        * `if let Some(idx) = active_notifications_clone.borrow().iter().position(|n| n.id == notification.id) {`
        * `active_notifications_clone.borrow_mut()[idx] = notification;`
        * `}`
        * `}`
        * `NotificationEvent::Closed(id) => {`
        * `active_notifications_clone.borrow_mut().retain(|n| n.id != id);`
        * `}`
        * `NotificationEvent::Progress(id, progress) => {`
        * `// Benachrichtigung in active_notifications finden und progress aktualisieren`
        * `if let Some(n) = active_notifications_clone.borrow_mut().iter_mut().find(|n| n.id == id) {`
        * `n.progress = Some(progress);`
        * `}`
        * `}`
        * `}`
        * `panel_clone.update_notifications(&active_notifications_clone.borrow());`
        * `}`
        * `Ok(dnd_enabled) = dnd_rx.recv() => {`
        * `panel_clone.update_do_not_disturb_status(dnd_enabled);`
        * `}`
        * `}`
        * `}`
        * `Ok(())`
        * `}));`

4.  **`NotificationCenterController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

5.  **`NotificationCenterController::get_panel_widget()` Methode:**
    * `pub fn get_panel_widget(&self) -> Arc<NotificationCenterPanel>`
    * Gibt die Referenz auf das `NotificationCenterPanel` Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/notification_center/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::notification_center::notification_center_panel::NotificationCenterPanel`
    * `crate::components::notification_center::error::NotificationCenterError`
    * `novade_domain::notification_management::service::NotificationService`
    * `novade_domain::notification_management::data_types::{Notification, NotificationEvent}`
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `std::cell::RefCell`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`
    * `tokio::select!`

**Kommunikationsmuster:**

* **Initialisiert und verwaltet das `NotificationCenterPanel` GTK-Widget.**
* **Abonniert Events vom `NotificationService` (Domänenschicht) für alle Benachrichtigungsereignisse (neu, aktualisiert, geschlossen, Fortschritt) und DND-Status.**
* **Führt ein lokales Cache der aktiven Benachrichtigungen und aktualisiert das `NotificationCenterPanel` auf Basis empfangener Events.**
* **Leitet Benutzerinteraktionen vom Panel (DND-Toggle, "Alle Löschen", Aktionen auf Benachrichtigungen, Schließen einzelner Benachrichtigungen) an den `NotificationService` weiter.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller und funktionaler Controller, der das Benachrichtigungszentrum aktuell hält und Benutzerinteraktionen verarbeitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NotificationService`.
    * Mocken des `NotificationCenterPanel`.
    * Testen der `new()`-Funktion: Verifizieren, dass der Service und das Panel korrekt gespeichert und Callbacks verbunden werden.
    * Testen der `start_listeners()`:
        * Simulieren von `NotificationEvent::New`, `Updated`, `Closed`, `Progress` und `DoNotDisturb` Events von den gemockten Services.
        * Prüfen, ob der `active_notifications` Cache korrekt aktualisiert wird.
        * Prüfen, ob `panel.update_notifications()` und `panel.update_do_not_disturb_status()` mit den korrekten Daten aufgerufen werden.
    * Simulieren von Aktionen des Panels (DND-Toggle, "Alle Löschen", Aktionen an Widgets, Schließen) und Prüfen, ob die korrekten Aufrufe an den gemockten `NotificationService` erfolgen.
* **Integration Tests:**
    * Starten der NovaDE.
    * Senden von Test-Benachrichtigungen über `notify-send` (verschiedene Typen, mit/ohne Aktionen, mit Fortschritt, Updates, Löschen).
    * Visuelle Inspektion des Panels: Sind Benachrichtigungen korrekt hinzugefügt/aktualisiert/entfernt? Sind Fortschrittsbalken korrekt?
    * Testen von DND-Toggle, "Alle Löschen", sowie Aktions- und Schließen-Buttons auf Benachrichtigungen.
    * Verifizieren, dass die Benachrichtigungen im System korrekt verarbeitet werden (z.B. verschwinden, wenn geschlossen).

**Geschätzter Aufwand:** Sehr hoch (ca. 8-12 Tage, da komplexe Event-Verarbeitung, State-Management und UI-Updates)

---
### **novade-ui/src/components/quick_settings/mod.rs**

**Verantwortlichkeit:**
Dieses Modul dient als Sammelpunkt und Re-Export für alle Komponenten, die das Schnellzugriffs-Menü (Quick Settings) im Panel bilden. Dies umfasst Widgets für grundlegende Systemsteuerungen wie Audio, Helligkeit, Netzwerk, Bluetooth und die Integration von anderen Indikatoren.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod quick_settings_panel;` (Das Haupt-Panel oder Popover der Schnellzugriffe)
    * `pub mod controller;` (Der Controller, der die Logik verwaltet und mit diversen Services interagiert)
    * `pub mod error;` (Fehler-Enum für das Modul)
    * `pub mod widgets;` (Modul für kleinere, wiederverwendbare Widgets innerhalb der Schnellzugriffe, z.B. Toggle-Buttons mit Icon und Label, Slider)

2.  **Re-Exporte (`pub use`):**
    * `pub use quick_settings_panel::QuickSettingsPanel;`
    * `pub use controller::QuickSettingsController;`
    * `pub use error::QuickSettingsError;`
    * `pub use widgets::*;` (Re-Export aller öffentlichen Elemente aus `widgets`)

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/quick_settings/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* `QuickSettingsController` wird von `UiServices` initialisiert.
* `QuickSettingsPanel` und seine Sub-Widgets werden vom Controller verwaltet und aktualisiert.

**Erwartete Ergebnisse/Outputs:**
Eine strukturierte API für das Schnellzugriffs-Menü.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-ui/src/components/quick_settings/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`QuickSettingsError`) für das Schnellzugriffs-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`QuickSettingsError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `GtkInitializationError(String)`: Fehler beim Initialisieren von GTK-Widgets oder Laden von Blueprints.
        * `MissingWidget(String)`: Ein erwartetes Widget wurde nicht im Blueprint gefunden.
        * `SystemError(#[from] novade_system::SystemServiceError)`: Fehler von der Systemschicht (z.B. Audio, Display, Power, Network).
        * `DomainError(#[from] novade_domain::DomainError)`: Allgemeine Fehler von der Domänenschicht.
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/quick_settings/error.rs`

**Abhängigkeiten:**

* **Intern:**
    * `novade_system::SystemServiceError`
    * `novade_domain::DomainError`
* **Extern:** `thiserror::Error`

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `quick_settings`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für die Schnellzugriffe.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `QuickSettingsError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-ui/src/components/quick_settings/widgets.rs**

**Verantwortlichkeit:**
Definiert kleinere, wiederverwendbare GTK-Widgets, die innerhalb des Schnellzugriffs-Panels oder anderer UI-Komponenten verwendet werden können. Dies fördert die Konsistenz und Wiederverwendbarkeit.

**Kern-Aufgaben (Tasks):**

1.  **`PowerInfoWidget` Struktur und Implementierung:**
    * Zeigt den aktuellen Akku-Status (Icon, Prozentsatz, Zeit).
    * `pub struct PowerInfoWidget { container: gtk::Box, icon: gtk::Image, label: gtk::Label }`
    * `pub fn new() -> Self`: Erstellt das Widget.
    * `pub fn update(&self, status: &PowerStatus)`: Aktualisiert Icon und Label basierend auf `PowerStatus`.
    * `pub fn get_widget(&self) -> &gtk::Widget`
    * Wiederverwendbar in `power_indicator_widget` und `power_details_popover`.

2.  **`ToggleSettingWidget` Struktur und Implementierung:**
    * Ein generisches Widget für eine Einstellung, die ein-/ausgeschaltet werden kann (z.B. WLAN, Bluetooth, DND).
    * `pub struct ToggleSettingWidget { container: gtk::Box, icon: gtk::Image, label: gtk::Label, toggle: gtk::Switch }`
    * `pub fn new(icon_name: &str, label_text: &str) -> Self`: Erstellt das Widget.
    * `pub fn set_active(&self, active: bool)`: Setzt den Zustand des Toggles.
    * `pub fn connect_state_set<F>(&self, callback: F)`: Verbindet einen Callback mit dem Toggle-Switch.
    * `pub fn get_widget(&self) -> &gtk::Widget`

3.  **`SliderSettingWidget` Struktur und Implementierung:**
    * Ein generisches Widget für eine Einstellung, die einen Wert über einen Slider steuert (z.B. Helligkeit, Lautstärke).
    * `pub struct SliderSettingWidget { container: gtk::Box, icon: gtk::Image, label: gtk::Label, slider: gtk::Scale }`
    * `pub fn new(icon_name: &str, label_text: &str, min: f64, max: f64) -> Self`: Erstellt das Widget.
    * `pub fn set_value(&self, value: f64)`: Setzt den Wert des Sliders.
    * `pub fn connect_value_changed<F>(&self, callback: F)`: Verbindet einen Callback mit dem Slider.
    * `pub fn get_widget(&self) -> &gtk::Widget`

4.  **`QuickActionButton` Struktur und Implementierung:**
    * Ein einfacher Button mit Icon und optionalem Label für schnelle Aktionen (z.B. Screenshot, Sperren, Herunterfahren).
    * `pub struct QuickActionButton { button: gtk::Button, icon: gtk::Image, label: Option<gtk::Label> }`
    * `pub fn new(icon_name: &str, label_text: Option<&str>) -> Self`: Erstellt den Button.
    * `pub fn connect_clicked<F>(&self, callback: F)`: Verbindet einen Callback mit dem Button-Klick.
    * `pub fn get_widget(&self) -> &gtk::Widget`

5.  **`ConnectedNetworkInfoWidget` Struktur und Implementierung:**
    * Zeigt den Namen der aktuell verbundenen WLAN/Ethernet-Verbindung und das zugehörige Icon an.
    * `pub struct ConnectedNetworkInfoWidget { container: gtk::Box, icon: gtk::Image, label: gtk::Label }`
    * `pub fn new() -> Self`
    * `pub fn update(&self, connection_name: &str, connection_type: NetworkType)`: Aktualisiert Icon und Label.
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/quick_settings/widgets.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::quick_settings::error::QuickSettingsError`
    * `novade_system::power_management::data_types::PowerStatus`
    * `novade_system::network_management::data_types::NetworkType`
* **Extern:** `gtk::{self, prelude::*, Box, Image, Label, Switch, Scale, Button, glib, Widget}`

**Kommunikationsmuster:**

* Diese Widgets werden von `QuickSettingsPanel` und anderen Komponenten instanziiert.
* Sie empfangen Daten zur Aktualisierung ihres Zustands.
* Sie emittieren GTK-Signale, die von ihren Elternkomponenten (z.B. `QuickSettingsPanel`, `NetworkDetailsPopover`) verarbeitet werden.

**Erwartete Ergebnisse/Outputs:**
Ein Set von gut designten, wiederverwendbaren UI-Elementen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Für jedes Widget:
        * Testen der `new()`-Funktion: Überprüfen der korrekten Initialisierung und des Layouts.
        * Testen der `update()`/`set_active()`/`set_value()`-Methoden: Verifizieren, dass der Zustand der inneren GTK-Widgets korrekt gesetzt wird (z.B. Label-Text, Slider-Wert, Toggle-Zustand, Icon).
        * Simulieren von Benutzerinteraktionen (z.B. Klick auf Toggle, Wertänderung am Slider) und Prüfen, ob die registrierten Callbacks mit den korrekten Argumenten ausgelöst werden.

**Geschätzter Aufwand:** Mittel (ca. 4-6 Tage, je nach Komplexität und Anzahl der Widgets)

---

### **novade-ui/src/components/quick_settings/quick_settings_panel.rs**

**Verantwortlichkeit:**
Implementiert das Haupt-GTK-Popover für das Schnellzugriffs-Menü. Es aggregiert verschiedene Schnellzugriffs-Widgets und Steuerungen für globale Systemfunktionen.

**Kern-Aufgaben (Tasks):**

1.  **`QuickSettingsPanel` Struktur:**
    * Ist ein Wrapper um `gtk::Popover` oder `gtk::Box`.
    * Felder:
        * `container: gtk::Widget` (Das Popover/Panel).
        * `date_time_label: gtk::Label` (Anzeige von Datum und Uhrzeit).
        * `power_info_widget: PowerInfoWidget` (Wiederverwendetes Akku-Info-Widget).
        * `brightness_slider_widget: SliderSettingWidget`.
        * `volume_slider_widget: SliderSettingWidget`.
        * `network_toggle_widget: ToggleSettingWidget`.
        * `bluetooth_toggle_widget: ToggleSettingWidget`.
        * `do_not_disturb_toggle_widget: ToggleSettingWidget`.
        * `connected_network_info_widget: ConnectedNetworkInfoWidget`.
        * `open_settings_button: gtk::Button`.
        * `lock_button: QuickActionButton`.
        * `shutdown_button: QuickActionButton`.
        * `reboot_button: QuickActionButton`.
        * `suspend_button: QuickActionButton`.
        * `callbacks: RefCell<PanelCallbacks>` (Struktur, um alle Callbacks zu halten, die vom Controller gesetzt werden).

    * **`PanelCallbacks` Struktur:**
        * `brightness_changed: Option<Box<dyn Fn(f64)>>`
        * `volume_changed: Option<Box<dyn Fn(f64)>>`
        * `wifi_toggled: Option<Box<dyn Fn(bool)>>`
        * `bluetooth_toggled: Option<Box<dyn Fn(bool)>>`
        * `dnd_toggled: Option<Box<dyn Fn(bool)>>`
        * `open_settings_clicked: Option<Box<dyn Fn(Option<SettingsCategory>)>>`
        * `lock_clicked: Option<Box<dyn Fn()>>`
        * `shutdown_clicked: Option<Box<dyn Fn()>>`
        * `reboot_clicked: Option<Box<dyn Fn()>>`
        * `suspend_clicked: Option<Box<dyn Fn()>>`

2.  **`QuickSettingsPanel::new()` Funktion:**
    * `pub fn new() -> Result<Self, QuickSettingsError>`
    * Lädt die UI-Definition (`quick_settings_panel.ui`).
    * Initialisiert alle Sub-Widgets (`PowerInfoWidget`, `SliderSettingWidget`, etc.) und die Buttons.
    * Ordnet sie im `container` an.
    * Setzt Initialzustände für Labels, Slider etc.
    * **Verbindet lokale GTK-Signale der Sub-Widgets:**
        * Z.B. `brightness_slider_widget.connect_value_changed()` leitet an `self.callbacks.borrow().brightness_changed` weiter.
        * Analog für alle anderen Toggles, Slider und Buttons.
    * Setzt CSS-Klassen "nova-quick-settings-panel".

3.  **`QuickSettingsPanel::update_datetime()` Methode:**
    * `pub fn update_datetime(&self, datetime: &str)`
    * Aktualisiert `date_time_label`.

4.  **`QuickSettingsPanel::update_power_status()` Methode:**
    * `pub fn update_power_status(&self, status: &PowerStatus)`
    * Ruft `power_info_widget.update(status)` auf.

5.  **`QuickSettingsPanel::update_brightness()` Methode:**
    * `pub fn update_brightness(&self, brightness: f64)`
    * Ruft `brightness_slider_widget.set_value(brightness)` auf.

6.  **`QuickSettingsPanel::update_volume()` Methode:**
    * `pub fn update_volume(&self, volume: f64)`
    * Ruft `volume_slider_widget.set_value(volume)` auf.

7.  **`QuickSettingsPanel::update_wifi_toggle_status()` Methode:**
    * `pub fn update_wifi_toggle_status(&self, active: bool)`
    * Ruft `network_toggle_widget.set_active(active)` auf.

8.  **`QuickSettingsPanel::update_bluetooth_toggle_status()` Methode:**
    * `pub fn update_bluetooth_toggle_status(&self, active: bool)`
    * Ruft `bluetooth_toggle_widget.set_active(active)` auf.

9.  **`QuickSettingsPanel::update_do_not_disturb_toggle_status()` Methode:**
    * `pub fn update_do_not_disturb_toggle_status(&self, active: bool)`
    * Ruft `do_not_disturb_toggle_widget.set_active(active)` auf.

10. **`QuickSettingsPanel::update_connected_network_info()` Methode:**
    * `pub fn update_connected_network_info(&self, connection_name: &str, connection_type: NetworkType)`
    * Ruft `connected_network_info_widget.update(connection_name, connection_type)` auf.

11. **`QuickSettingsPanel::set_callbacks()` Methode:**
    * `pub fn set_callbacks(&self, callbacks: PanelCallbacks)`
    * Speichert die gesamte `PanelCallbacks` Struktur.

12. **`QuickSettingsPanel::show_popover_at_widget()` Methode:**
    * `pub fn show_popover_at_widget(&self, widget: &impl IsA<gtk::Widget>)`
    * Zeigt das Popover an.

13. **`QuickSettingsPanel::get_widget()` Methode:**
    * `pub fn get_widget(&self) -> &gtk::Widget`

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/quick_settings/quick_settings_panel.rs`
* `novade-ui/resources/ui/quick_settings_panel.ui`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::quick_settings::error::QuickSettingsError`
    * `crate::components::quick_settings::widgets::{PowerInfoWidget, ToggleSettingWidget, SliderSettingWidget, QuickActionButton, ConnectedNetworkInfoWidget}`
    * `novade_system::power_management::data_types::PowerStatus`
    * `novade_system::network_management::data_types::NetworkType`
    * `novade_domain::settings::data_types::SettingsCategory`
* **Extern:** `gtk::{self, prelude::*, Popover, Box, Label, Button, glib, IsA, Widget}`
    * `std::cell::RefCell`

**Kommunikationsmuster:**

* Wird vom `QuickSettingsController` instanziiert und angezeigt.
* Empfängt verschiedene Status-Updates (Datum/Zeit, Akku, Helligkeit, Lautstärke, Netzwerk/Bluetooth-Toggles, DND, verbundene Netzwerkinfo) vom Controller.
* Leitet alle Benutzerinteraktionen (Slider-Bewegungen, Toggle-Klicks, Button-Klicks) über die `PanelCallbacks` an den Controller weiter.

**Erwartete Ergebnisse/Outputs:**
Ein funktionales und übersichtliches Schnellzugriffs-Panel.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken aller Sub-Widgets (um nur die Panel-Layout- und Callback-Logik zu testen).
    * Testen der `new()`-Funktion: Korrekte Initialisierung und Layout aller Sub-Widgets und Buttons.
    * Testen aller `update_*()`-Methoden: Verifizieren, dass die korrekten `update()`/`set_active()`/`set_value()` Methoden auf den gemockten Sub-Widgets aufgerufen werden.
    * Simulieren von Interaktionen mit den gemockten Sub-Widgets (z.B. `brightness_slider_widget.emit_value_changed(0.5)`) und Prüfen, ob die korrekten Callbacks in `PanelCallbacks` ausgelöst werden.
* **Integration Tests:**
    * Starten der NovaDE.
    * Öffnen des Schnellzugriffs-Panels.
    * Visuelle Inspektion aller Elemente und ihrer Initialzustände.
    * Testen aller Toggles, Slider und Buttons und Beobachten der Systemreaktion (z.B. Lautstärkeänderung, Helligkeitsänderung, WLAN an/aus, Sperrbildschirm).

**Geschätzter Aufwand:** Sehr hoch (ca. 7-10 Tage, da viele verschiedene UI-Elemente, komplexe Callback-Struktur und Integration von Unter-Widgets)

---

### **novade-ui/src/components/quick_settings/controller.rs**

**Verantwortlichkeit:**
Implementiert den `QuickSettingsController`, der die logische Steuerung für das Schnellzugriffs-Menü übernimmt. Er abonniert Events von verschiedenen Services der System- und Domänenschicht, um den Zustand des Panels aktuell zu halten. Er leitet auch Steuerungsbefehle von der UI an die entsprechenden Services weiter.

**Kern-Aufgaben (Tasks):**

1.  **`QuickSettingsController` Struktur:**
    * Felder:
        * `audio_management_service: Arc<AudioManagementService>`
        * `display_management_service: Arc<DisplayManagementService>`
        * `power_management_service: Arc<PowerManagementService>`
        * `network_management_service: Arc<NetworkManagementService>`
        * `global_settings_service: Arc<GlobalSettingsService>`
        * `date_time_service: Arc<DateTimeService>` (Annahme: Ein neuer Service für Datum/Uhrzeit)
        * `quick_settings_panel: Arc<QuickSettingsPanel>` (Referenz auf das GTK-Panel selbst).
        * `listeners: Vec<JoinHandle<Result<(), Box<dyn std::error::Error + Send + Sync>>>>`.

2.  **`QuickSettingsController::new()` Funktion:**
    * `pub fn new(...) -> Result<Arc<Self>, QuickSettingsError>` (Parameter sind alle Service-Referenzen)
    * Speichert die Referenzen zu den Services.
    * Erstellt eine Instanz des `QuickSettingsPanel`.
    * **Setzt Callbacks auf dem `quick_settings_panel`:**
        * Erstellt eine `PanelCallbacks` Instanz.
        * Füllt die Callbacks mit Closures, die `glib::spawn_future_local` verwenden, um die entsprechenden Methoden der Services aufzurufen:
            * `brightness_changed`: Ruft `display_management_service.set_brightness()` auf.
            * `volume_changed`: Ruft `audio_management_service.set_volume()` auf.
            * `wifi_toggled`: Ruft `network_management_service.set_radio_enabled(val, NetworkType::Wifi)` auf.
            * `bluetooth_toggled`: Ruft `network_management_service.set_radio_enabled(val, NetworkType::Bluetooth)` auf.
            * `dnd_toggled`: Ruft `global_settings_service.set_do_not_disturb()` auf.
            * `open_settings_clicked`: Ruft `global_settings_service.open_settings_app()` auf.
            * `lock_clicked`: Ruft `power_management_service.lock_screen()` auf.
            * `shutdown_clicked`: Ruft `power_management_service.shutdown()` auf.
            * `reboot_clicked`: Ruft `power_management_service.reboot()` auf.
            * `suspend_clicked`: Ruft `power_management_service.suspend()` auf.
        * Ruft `panel.set_callbacks(callbacks)` auf.
    * Speichert die Instanzen.

3.  **`QuickSettingsController::start_listeners()` Methode:**
    * `pub fn start_listeners(self: Arc<Self>)`
    * Spawnt asynchrone Tasks (`glib::MainContext::spawn_local`) für die Event-Listener.
    * **Listener-Tasks für alle relevanten Service-Events:**
        * **Datum/Uhrzeit:** `date_time_service.subscribe_to_updates()` -> `panel.update_datetime()`.
        * **Akku-Status:** `power_management_service.subscribe_to_power_status_changes()` -> `panel.update_power_status()`.
        * **Helligkeit:** `display_management_service.subscribe_to_brightness_changes()` -> `panel.update_brightness()`.
        * **Lautstärke:** `audio_management_service.subscribe_to_volume_changes()` -> `panel.update_volume()`.
        * **Netzwerkstatus:** `network_management_service.subscribe_to_network_status_changes()` (für verbundene Netzwerkinfo und WLAN-Toggle Status) -> `panel.update_connected_network_info()` und `panel.update_wifi_toggle_status()`.
        * **Bluetoothstatus:** `network_management_service.subscribe_to_bluetooth_status_changes()` -> `panel.update_bluetooth_toggle_status()`.
        * **Bitte nicht stören:** `global_settings_service.subscribe_to_do_not_disturb_changes()` -> `panel.update_do_not_disturb_toggle_status()`.
    * **Initialer Status-Update:** Ruft einmalig `get_current_*()` für alle relevanten Status ab und aktualisiert das Panel.

4.  **`QuickSettingsController::shutdown_listeners()` Methode:**
    * `pub async fn shutdown_listeners(&mut self)`
    * Bricht alle `JoinHandle`s ab und wartet auf deren Beendigung.

5.  **`QuickSettingsController::get_panel_widget()` Methode:**
    * `pub fn get_panel_widget(&self) -> Arc<QuickSettingsPanel>`
    * Gibt die Referenz auf das `QuickSettingsPanel` Widget zurück.

**Spezifische Artefakte/Dateien:**

* `novade-ui/src/components/quick_settings/controller.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::components::quick_settings::quick_settings_panel::{QuickSettingsPanel, PanelCallbacks}`
    * `crate::components::quick_settings::error::QuickSettingsError`
    * `novade_system::audio_management::service::AudioManagementService`
    * `novade_system::display_management::service::DisplayManagementService`
    * `novade_system::power_management::service::PowerManagementService`
    * `novade_system::network_management::service::NetworkManagementService`
    * `novade_system::network_management::data_types::NetworkType`
    * `novade_domain::settings::service::GlobalSettingsService`
    * `novade_domain::settings::data_types::SettingsCategory`
    * `novade_domain::date_time::service::DateTimeService` (Muss noch definiert werden, aber logisch hier benötigt)
* **Extern:**
    * `tokio::task::JoinHandle`
    * `tokio::sync::broadcast::Receiver`
    * `std::sync::Arc`
    * `glib::MainContext::spawn_local`
    * `tracing`
    * `futures::future::join_all`

**Kommunikationsmuster:**

* **Initialisiert und verwaltet das `QuickSettingsPanel` GTK-Widget.**
* **Abonniert Events von `AudioManagementService`, `DisplayManagementService`, `PowerManagementService`, `NetworkManagementService` (Systemschicht), `GlobalSettingsService` und `DateTimeService` (Domänenschicht).**
* **Aktualisiert den Zustand des `QuickSettingsPanel` auf Basis empfangener Events.**
* **Leitet Benutzerinteraktionen vom Panel (Slider-Änderungen, Toggle-Klicks, Button-Klicks) an die entsprechenden Services weiter.**
* **Wird von `UiServices` initialisiert und verwaltet.**

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller und funktionaler Controller, der das Schnellzugriffs-Menü aktuell hält und Benutzerinteraktionen verarbeitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken aller abhängigen Services (`AudioManagementService`, etc.).
    * Mocken des `QuickSettingsPanel`.
    * Testen der `new()`-Funktion: Verifizieren, dass alle Services und das Panel korrekt gespeichert und alle Callbacks korrekt auf dem Panel gesetzt werden, sodass sie die gemockten Services aufrufen.
    * Testen der `start_listeners()`:
        * Simulieren von Events von den gemockten Services (z.B. `audio_service.emit_volume_change(0.7)`).
        * Prüfen, ob die korrekten `update_*()`-Methoden auf dem gemockten `QuickSettingsPanel` aufgerufen werden.
    * Simulieren von Interaktionen mit dem gemockten `QuickSettingsPanel` (z.B. `panel.emit_brightness_changed(0.5)`) und Prüfen, ob die korrekten Methoden auf den gemockten Services aufgerufen werden.
* **Integration Tests:**
    * Starten der NovaDE.
    * Öffnen des Schnellzugriffs-Panels (z.B. über Panel-Klick).
    * Manuelle Manipulationen am System (Lautstärke ändern, Helligkeit ändern, WLAN/Bluetooth umschalten, Energiesparmodus umschalten, Akku-Status ändern).
    * Visuelle Inspektion, ob das Panel korrekt und reaktionsschnell aktualisiert wird.
    * Interaktion mit allen Steuerelementen im Panel und Beobachten der Systemreaktion (z.B. Helligkeitsänderung, WLAN an/aus, Sperrbildschirm wird aktiv).

**Geschätzter Aufwand:** Extrem hoch (ca. 10-15 Tage, da Integration von vielen Services, umfangreiche Event-Verarbeitung, Status-Management und viele UI-Interaktionen)

---
### **novade-domain/src/date_time/mod.rs**

**Verantwortlichkeit:**
Dieses Modul ist für die Verwaltung und Bereitstellung von Datum- und Uhrzeitinformationen verantwortlich. Es bietet Schnittstellen, um die aktuelle Uhrzeit abzufragen und sich für Änderungen zu registrieren.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod data_types;` (Definition relevanter Datenstrukturen für Datum/Uhrzeit)
    * `pub mod service;` (Implementierung des `DateTimeService`)
    * `pub mod error;` (Fehler-Enum für das Modul)

2.  **Re-Exporte (`pub use`):**
    * `pub use data_types::*;`
    * `pub use service::DateTimeService;`
    * `pub use error::DateTimeError;`

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/date_time/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* `DateTimeService` wird von der `DomainServices` Initialisierungsroutine in `novade-domain/src/lib.rs` instanziiert.
* Andere Services (z.B. `novade-ui::components::quick_settings::controller`) können den `DateTimeService` abonnieren.

**Erwartete Ergebnisse/Outputs:**
Eine kohärente API zur Verwaltung und Abfrage von Datum- und Uhrzeitinformationen.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-domain/src/date_time/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`DateTimeError`) für das Datum/Uhrzeit-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`DateTimeError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `SystemTimeError(#[from] std::time::SystemTimeError)`: Fehler von `std::time::SystemTime`.
        * `FormatError(String)`: Fehler beim Formatieren oder Parsen von Datum/Uhrzeit-Strings.
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/date_time/error.rs`

**Abhängigkeiten:**

* **Intern:** Keine.
* **Extern:** `thiserror::Error`, `std::time::SystemTimeError`.

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `date_time`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für Datum/Uhrzeit-Operationen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `DateTimeError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.2 Tage)

---

### **novade-domain/src/date_time/data_types.rs**

**Verantwortlichkeit:**
Definiert die Datenstrukturen, die die Zeitinformationen im `date_time`-Modul repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`DateTimeInfo` Struktur:**
    * `pub struct DateTimeInfo { pub local_datetime: String, pub timestamp: u64, // Unix Timestamp }`
    * Implementiere `Clone`, `Debug`, `Default`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
    * Implementiere eine `new()`-Funktion:
        * `pub fn new(local_datetime: String, timestamp: u64) -> Self`
    * `Default` sollte sinnvolle initiale Werte liefern (z.B. leere Zeichenkette, 0 für Timestamp).

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/date_time/data_types.rs`

**Abhängigkeiten:**

* **Intern:** Keine.
* **Extern:** `serde::{Serialize, Deserialize}`, `std::string::String`.

**Kommunikationsmuster:**

* Diese Struktur wird vom `DateTimeService` erzeugt und über Events an Abonnenten gesendet.

**Erwartete Ergebnisse/Outputs:**
Klare und konsistente Datenmodelle zur Repräsentation von Datum- und Uhrzeitinformationen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `Default` Implementierung.
    * Testen der `new()`-Funktion.
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` Implementierungen.
    * Testen der Serialisierung und Deserialisierung (z.B. zu/von JSON).

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---

### **novade-domain/src/date_time/service.rs**

**Verantwortlichkeit:**
Implementiert den `DateTimeService`, der die aktuelle Datum- und Uhrzeitinformation bereitstellt und periodische Updates über einen Broadcast-Kanal sendet.

**Kern-Aufgaben (Tasks):**

1.  **`DateTimeService` Struktur:**
    * `pub struct DateTimeService { sender: broadcast::Sender<DateTimeInfo>, interval: Duration, }`
    * `interval`: Konfigurierbare Dauer für Updates (z.B. 1 Sekunde).

2.  **`DateTimeService::new()` Funktion:**
    * `pub fn new(interval: Duration) -> Arc<Self>`
    * Erstellt einen `broadcast::channel` mit geeigneter Kapazität (z.B. 1).
    * Initialisiert die Struktur.

3.  **`DateTimeService::run()` Methode:**
    * `pub async fn run(self: Arc<Self>) -> Result<(), DateTimeError>`
    * Startet einen asynchronen Schleife, die alle `self.interval` die aktuelle Uhrzeit abfragt und sendet.
    * Verwendet `tokio::time::interval_at` für präzise Intervalle.
    * Innerhalb der Schleife:
        * Holt die aktuelle Systemzeit: `SystemTime::now()`.
        * Konvertiert die Systemzeit in eine lokale, formatierte Zeichenkette (z.B. "HH:MM:SS DD.MM.YYYY"). Verwende `chrono` für robuste Datum/Uhrzeit-Operationen und Formatierung.
        * Erstellt ein `DateTimeInfo` Objekt.
        * Sendet das `DateTimeInfo` Objekt über `self.sender.send()`. Ignoriere `RecvError::Lagged` wenn keine Abonnenten vorhanden sind.
        * Füge robustes Fehlerhandling hinzu (z.B. `tracing::error!` bei Formatierungsfehlern).

4.  **`DateTimeService::get_current_datetime_info()` Methode:**
    * `pub async fn get_current_datetime_info(&self) -> Result<DateTimeInfo, DateTimeError>`
    * Ruft die aktuelle Systemzeit ab.
    * Formatiert sie in eine `DateTimeInfo` und gibt sie zurück.

5.  **`DateTimeService::subscribe_to_updates()` Methode:**
    * `pub fn subscribe_to_updates(&self) -> broadcast::Receiver<DateTimeInfo>`
    * Gibt einen neuen `broadcast::Receiver` für Updates zurück.

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/date_time/service.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::date_time::data_types::DateTimeInfo`
    * `crate::date_time::error::DateTimeError`
* **Extern:**
    * `tokio::sync::broadcast::{self, Sender, Receiver}`
    * `tokio::time::{self, Duration}`
    * `std::sync::Arc`
    * `std::time::SystemTime`
    * `chrono::{Local, DateTime, Datelike, Timelike}` (für Datum/Uhrzeit-Konvertierung und Formatierung)
    * `tracing`

**Kommunikationsmuster:**

* Sendet periodisch `DateTimeInfo` Events über einen `tokio::sync::broadcast` Kanal.
* Andere Komponenten können den Service abonnieren, um diese Events zu empfangen.

**Erwartete Ergebnisse/Outputs:**
Ein Hintergrunddienst, der genaue und aktuelle Datum- und Uhrzeitinformationen für die gesamte DE bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking für Zeit):**
    * Testen der `new()`-Funktion: Sicherstellen, dass der Sender korrekt initialisiert wird.
    * Testen von `get_current_datetime_info()`: Prüfen, ob die aktuelle Zeit korrekt geholt und formatiert wird.
    * Testen von `run()`:
        * Starten des Services in einer `tokio::test` Umgebung.
        * Abonnieren von Updates und Prüfen, ob `DateTimeInfo` Objekte mit dem erwarteten Intervall empfangen werden.
        * Verifizieren, dass die empfangenen `DateTimeInfo` Objekte korrekte und aktualisierte Zeitstempel und formatierte Zeichenketten enthalten.
        * Testen der Fehlerbehandlung, z.B. wenn die Systemzeitabfrage fehlschlägt.
* **Integration Tests:**
    * Starten der NovaDE.
    * Beobachten der Uhrzeit im Panel, um sicherzustellen, dass sie korrekt aktualisiert wird.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage, inklusive `chrono`-Integration und robustem `run` Loop)

---

### **novade-domain/src/task_management/mod.rs**

**Verantwortlichkeit:**
Dieses Modul ist für die Verwaltung von Hintergrundaufgaben und geplanten Aktionen verantwortlich. Es bietet einen zentralen Mechanismus zur Registrierung, Überwachung und Ausführung von zeitbasierten oder event-gesteuerten Aufgaben.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod data_types;` (Definition von Task-spezifischen Datenstrukturen)
    * `pub mod service;` (Implementierung des `TaskManagerService`)
    * `pub mod error;` (Fehler-Enum für das Modul)
    * `pub mod scheduler;` (Logik für die Zeitplanung von Aufgaben)

2.  **Re-Exporte (`pub use`):**
    * `pub use data_types::*;`
    * `pub use service::TaskManagerService;`
    * `pub use error::TaskManagerError;`
    * `pub use scheduler::*;`

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/task_management/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* `TaskManagerService` wird von der `DomainServices` Initialisierungsroutine in `novade-domain/src/lib.rs` instanziiert.
* Andere Services können Aufgaben beim `TaskManagerService` registrieren.

**Erwartete Ergebnisse/Outputs:**
Eine kohärente API zur Verwaltung und Ausführung von Hintergrundaufgaben.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-domain/src/task_management/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`TaskManagerError`) für das Aufgabenverwaltungsmodul.

**Kern-Aufgaben (Tasks):**

1.  **`TaskManagerError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `TaskNotFound(String)`: Eine Aufgabe mit der angegebenen ID wurde nicht gefunden.
        * `InvalidTaskDefinition(String)`: Ungültige oder unvollständige Aufgabendefinition.
        * `SchedulerError(String)`: Fehler, die vom internen Scheduler stammen (z.B. ungültiger Cron-Ausdruck).
        * `IoError(#[from] std::io::Error)`: Fehler beim Laden/Speichern von Aufgaben.
        * `SerializationError(#[from] serde_json::Error)`: Fehler bei der Serialisierung/Deserialisierung.
        * `ServiceError(String)`: Allgemeine Service-bezogene Fehler (z.B. Kommunikationsfehler mit der auszuführenden Aufgabe).
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/task_management/error.rs`

**Abhängigkeiten:**

* **Intern:** Keine.
* **Extern:** `thiserror::Error`, `std::io::Error`, `serde_json::Error`.

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `task_management`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für die Aufgabenverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `TaskManagerError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-domain/src/task_management/data_types.rs**

**Verantwortlichkeit:**
Definiert die Datenstrukturen, die zur Beschreibung und Verwaltung von Aufgaben im `task_management`-Modul verwendet werden.

**Kern-Aufgaben (Tasks):**

1.  **`TaskId` Typ-Alias:**
    * `pub type TaskId = Uuid;`

2.  **`TaskAction` Enum:**
    * Definiert die Art der Aktion, die eine Aufgabe ausführen soll.
    * `pub enum TaskAction {`
    * `ExecuteCommand { command: String, args: Vec<String> },` (Ausführen eines Shell-Befehls)
    * `EmitEvent { event_name: String, payload: serde_json::Value },` (Senden eines Domänen-Events)
    * `RunScript { script_path: PathBuf, args: Vec<String> },` (Ausführen eines Skripts)
    * `CustomAction(String, serde_json::Value),` (Erweiterbare, anwendungsspezifische Aktionen)
    * `}`
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.

3.  **`TaskTrigger` Enum:**
    * Definiert die Bedingungen, unter denen eine Aufgabe ausgelöst wird.
    * `pub enum TaskTrigger {`
    * `Manual,` (Manuelle Auslösung)
    * `AtTime(String),` (Einmalig zu einer bestimmten Zeit, z.B. "2025-12-31T23:59:59")
    * `CronSchedule(String),` (Regelmäßige Auslösung über Cron-Expression)
    * `OnEvent(String),` (Auslösung bei Empfang eines bestimmten Domänen-Events)
    * `Interval(Duration),` (Regelmäßige Auslösung nach einem Zeitintervall)
    * `}`
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
    * **Validierung:** Füge eine `validate()`-Methode hinzu, die die Gültigkeit der enthaltenen Strings (Zeitformat, Cron-Expression) prüft.

4.  **`TaskStatus` Enum:**
    * Repräsentiert den aktuellen Status einer Aufgabe.
    * `pub enum TaskStatus {`
    * `Pending,`
    * `Running,`
    * `Completed,`
    * `Failed,`
    * `Cancelled,`
    * `}`
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.

5.  **`Task` Struktur:**
    * `pub struct Task {`
    * `pub id: TaskId,`
    * `pub name: String,`
    * `pub description: Option<String>,`
    * `pub action: TaskAction,`
    * `pub trigger: TaskTrigger,`
    * `pub enabled: bool,`
    * `pub created_at: DateTime<Local>,`
    * `pub last_run_at: Option<DateTime<Local>>,`
    * `pub status: TaskStatus,`
    * `pub last_error: Option<String>,`
    * `}`
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    * **`new()`-Funktion:**
        * `pub fn new(name: String, action: TaskAction, trigger: TaskTrigger) -> Self`
        * Generiert eine neue `TaskId` (UUID).
        * Setzt `created_at` auf aktuelle Zeit.
        * Setzt Initialstatus auf `Pending`.

6.  **`TaskEvent` Enum:**
    * Events, die vom `TaskManagerService` gesendet werden, um über den Lebenszyklus von Aufgaben zu informieren.
    * `pub enum TaskEvent {`
    * `TaskAdded(Task),`
    * `TaskUpdated(Task),`
    * `TaskRemoved(TaskId),`
    * `TaskStarted(TaskId),`
    * `TaskCompleted(TaskId, Result<(), String>),` (Result enthält Fehlerstring bei Fehlschlag)
    * `}`
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/task_management/data_types.rs`

**Abhängigkeiten:**

* **Intern:** Keine.
* **Extern:**
    * `uuid::Uuid` (für `TaskId`)
    * `serde::{Serialize, Deserialize}`
    * `serde_json::Value` (für `TaskAction::EmitEvent` payload)
    * `std::path::PathBuf`
    * `std::time::Duration`
    * `chrono::{DateTime, Local}` (für Zeitstempel)
    * `cron::Schedule` (optional, für interne Validierung von Cron-Expressions in `TaskTrigger::CronSchedule::validate()`)

**Kommunikationsmuster:**

* Diese Strukturen werden intern im `TaskManagerService` verwendet und über `TaskEvent`s an Abonnenten gesendet.
* Sie werden auch für die Persistenz von Aufgaben verwendet.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut definiertes Datenmodell für die Aufgabenverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion für `Task`.
    * Testen der `validate()`-Methode für `TaskTrigger` (gültige/ungültige Cron-Strings, Zeitformate).
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` (wo zutreffend) Implementierungen.
    * Testen der Serialisierung und Deserialisierung für alle Strukturen/Enums.
    * Testen verschiedener `TaskAction` Varianten.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage, aufgrund der Komplexität der Enums und der Validierungslogik)

---

### **novade-domain/src/task_management/scheduler.rs**

**Verantwortlichkeit:**
Implementiert die Logik für die Zeitplanung von Aufgaben basierend auf verschiedenen `TaskTrigger`-Typen. Dies beinhaltet die Handhabung von Cron-Jobs, Intervallen und einmaligen Ausführungen.

**Kern-Aufgaben (Tasks):**

1.  **`Scheduler` Struktur:**
    * `pub struct Scheduler {`
    * `event_tx: broadcast::Sender<TaskEvent>,` (Sender, um Events an TaskManagerService zu senden)
    * `task_tx: mpsc::Sender<TaskId>,` (Sender, um auszuführende Task-IDs an TaskManagerService zu senden)
    * `active_schedules: Mutex<HashMap<TaskId, JoinHandle<()>>>,` (Map von TaskId zu den JoinHandles der laufenden Scheduler-Tasks)
    * `}`

2.  **`Scheduler::new()` Funktion:**
    * `pub fn new(event_tx: broadcast::Sender<TaskEvent>, task_tx: mpsc::Sender<TaskId>) -> Arc<Self>`
    * Initialisiert die Struktur.

3.  **`Scheduler::schedule_task()` Methode:**
    * `pub async fn schedule_task(self: Arc<Self>, task: Task) -> Result<(), TaskManagerError>`
    * Nimmt eine `Task` entgegen.
    * **Logik pro `TaskTrigger`:**
        * **`TaskTrigger::Manual`**: Keine automatische Planung, nur manuell ausführbar.
        * **`TaskTrigger::AtTime(time_str)`**:
            * Parsen der `time_str` mit `chrono` zu `DateTime<Local>`.
            * Berechnen der Dauer bis zu diesem Zeitpunkt.
            * Spawnt einen `tokio::task` mit `tokio::time::sleep()`. Nach dem Sleep wird die `task.id` an `task_tx` gesendet.
            * Entfernt den Handle aus `active_schedules` nach Ausführung.
        * **`TaskTrigger::CronSchedule(cron_expr)`**:
            * Parsen der `cron_expr` mit der `cron` Krate zu `Schedule`.
            * Spawnt einen `tokio::task`. In einer Schleife:
                * Berechnet die nächste Ausführungszeit mit `schedule.upcoming()`.
                * `tokio::time::sleep_until()` bis zur nächsten Zeit.
                * Sendet `task.id` an `task_tx`.
        * **`TaskTrigger::OnEvent(event_name)`**:
            * Abonnieren von Domänen-Events (Muss über `TaskManagerService` zu dessen `event_rx` geleitet werden, oder `Scheduler` erhält einen `event_rx` für *alle* Domänen-Events und filtert hier).
            * Spawnt einen `tokio::task` in einer Schleife, der auf den `event_name` wartet.
            * Bei Empfang des Events wird `task.id` an `task_tx` gesendet.
        * **`TaskTrigger::Interval(duration)`**:
            * Spawnt einen `tokio::task` mit `tokio::time::interval()`.
            * In einer Schleife: `interval.tick().await`, dann `task_tx.send(task.id)`.
    * Speichert das `JoinHandle` der gespawnten Task in `active_schedules`.

4.  **`Scheduler::cancel_task()` Methode:**
    * `pub async fn cancel_task(&self, task_id: &TaskId) -> Result<(), TaskManagerError>`
    * Sucht das `JoinHandle` für `task_id` in `active_schedules`.
    * Ruft `handle.abort()` auf.
    * Entfernt den Eintrag aus `active_schedules`.
    * Sendet `TaskEvent::TaskRemoved(task_id)` über `event_tx`.

5.  **`Scheduler::shutdown_all_tasks()` Methode:**
    * `pub async fn shutdown_all_tasks(&self)`
    * Iteriert über alle `JoinHandle`s in `active_schedules` und ruft `abort()` auf.
    * Wartet auf deren Beendigung.

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/task_management/scheduler.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::task_management::data_types::{Task, TaskId, TaskAction, TaskTrigger, TaskEvent}`
    * `crate::task_management::error::TaskManagerError`
* **Extern:**
    * `tokio::sync::{broadcast, mpsc}`
    * `tokio::time::{self, Duration}`
    * `tokio::task::JoinHandle`
    * `std::sync::{Arc, Mutex}`
    * `std::collections::HashMap`
    * `chrono::{DateTime, Local, Duration as ChronoDuration}`
    * `cron::Schedule`
    * `tracing`

**Kommunikationsmuster:**

* Empfängt `Task` Objekte vom `TaskManagerService` zur Planung.
* Sendet `TaskId`s an den `TaskManagerService` über einen `mpsc::Sender`, wenn eine Aufgabe ausgeführt werden soll.
* Sendet `TaskEvent`s über den `broadcast::Sender` (vom `TaskManagerService` bereitgestellt), z.B. wenn eine Aufgabe erfolgreich geplant/abgebrochen wurde.

**Erwartete Ergebnisse/Outputs:**
Eine robuste und flexible Zeitplanungs-Engine für verschiedene Arten von Aufgaben.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `event_tx` und `task_tx` Kanals, um gesendete Nachrichten zu verifizieren.
    * Testen von `schedule_task()` für jeden `TaskTrigger` Typ:
        * **`AtTime`**: Prüfen, ob die Task nach der korrekten Zeitverzögerung an `task_tx` gesendet wird.
        * **`CronSchedule`**: Prüfen, ob die Task wiederholt und korrekt nach dem Cron-Muster ausgelöst wird.
        * **`Interval`**: Prüfen, ob die Task im korrekten Intervall ausgelöst wird.
        * **`OnEvent`**: Simulieren eines Events und Prüfen, ob die Task danach ausgelöst wird.
    * Testen von `cancel_task()`: Sicherstellen, dass die laufende Task korrekt abgebrochen und der Eintrag aus `active_schedules` entfernt wird.
    * Testen von `shutdown_all_tasks()`: Sicherstellen, dass alle laufenden Tasks abgebrochen werden.
* **Integration Tests:**
    * Starten des `TaskManagerService` mit dem `Scheduler`.
    * Registrieren von verschiedenen Tasks (zeitbasiert, event-basiert).
    * Beobachten der Ausführung der Tasks (z.B. durch Logs oder die `TaskEvent`s).

**Geschätzter Aufwand:** Sehr hoch (ca. 8-12 Tage, aufgrund der Komplexität von Zeitplanung, Asynchronität und der verschiedenen Trigger-Typen)

---

### **novade-domain/src/task_management/service.rs**

**Verantwortlichkeit:**
Implementiert den `TaskManagerService`, den zentralen Service für die Verwaltung von Hintergrundaufgaben. Dieser Service ist die primäre Schnittstelle für andere Domänenkomponenten und die UI, um Aufgaben zu registrieren, zu starten, zu beenden und ihren Status zu überwachen. Er orchestriert die Persistenz, Zeitplanung und Ausführung von Aufgaben.

**Kern-Aufgaben (Tasks):**

1.  **`TaskManagerService` Struktur:**
    * `pub struct TaskManagerService {`
    * `scheduler: Arc<Scheduler>,`
    * `tasks: RwLock<HashMap<TaskId, Task>>,` (In-Memory-Cache aller bekannten Aufgaben)
    * `event_sender: broadcast::Sender<TaskEvent>,` (Für externe Abonnenten des Task-Lebenszyklus)
    * `task_execution_rx: mpsc::Receiver<TaskId>,` (Empfängt von Scheduler, welche Task ausgeführt werden soll)
    * `task_execution_tx: mpsc::Sender<TaskId>,` (Wird an Scheduler übergeben)
    * `config_service: Arc<ConfigServiceAsync>,` (Zum Laden/Speichern von Aufgaben)
    * `dbus_event_bus: Arc<DbusEventBus>,` (Zum Senden/Empfangen von `TaskAction::EmitEvent`/`TaskTrigger::OnEvent`)
    * `}`

2.  **`TaskManagerService::new()` Funktion:**
    * `pub fn new(config_service: Arc<ConfigServiceAsync>, dbus_event_bus: Arc<DbusEventBus>) -> Result<Arc<Self>, TaskManagerError>`
    * Erstellt einen `broadcast::channel` für `event_sender`.
    * Erstellt einen `mpsc::channel` für `task_execution_rx`/`task_execution_tx`.
    * Initialisiert den `Scheduler` mit dem `event_sender` und `task_execution_tx`.
    * Lädt initial alle gespeicherten Aufgaben über `config_service` und `load_tasks()`.
    * Für jede geladene, `enabled` Aufgabe, ruft `scheduler.schedule_task()` auf.

3.  **`TaskManagerService::run()` Methode:**
    * `pub async fn run(self: Arc<Self>) -> Result<(), TaskManagerError>`
    * Startet eine asynchrone Schleife, die auf `task_execution_rx` wartet.
    * Bei Empfang einer `TaskId`:
        * Holt die `Task` aus `self.tasks`.
        * Spawnt einen `tokio::task` zur Ausführung der `Task` (siehe `execute_task()` unten).
        * Aktualisiert den Task-Status auf `Running` und sendet `TaskEvent::TaskStarted`.
        * Aktualisiert `last_run_at`.

4.  **`TaskManagerService::execute_task()` (private Methode):**
    * `async fn execute_task(self: Arc<Self>, task_id: TaskId)`
    * Holt die Task.
    * Matcht `task.action`:
        * **`TaskAction::ExecuteCommand`**: Führt den Befehl über `tokio::process::Command` aus. Fängt Output, StdErr ab.
        * **`TaskAction::EmitEvent`**: Sendet das Event über `dbus_event_bus.emit_event()`.
        * **`TaskAction::RunScript`**: Führt das Skript aus (Shell oder direkt).
        * **`TaskAction::CustomAction`**: Ruft eine interne Logik für diese Aktion auf (ggf. über ein registriertes Trait).
    * Aktualisiert den Task-Status auf `Completed` oder `Failed` (mit Fehlermeldung).
    * Sendet `TaskEvent::TaskCompleted` (oder `TaskFailed`) über `event_sender`.
    * Speichert den aktualisierten Task-Status via `config_service`.

5.  **`TaskManagerService::add_task()` Methode:**
    * `pub async fn add_task(&self, task: Task) -> Result<(), TaskManagerError>`
    * Fügt die Task zu `self.tasks` hinzu.
    * Speichert die Task über `config_service`.
    * Wenn `task.enabled`, ruft `scheduler.schedule_task()` auf.
    * Sendet `TaskEvent::TaskAdded`.

6.  **`TaskManagerService::update_task()` Methode:**
    * `pub async fn update_task(&self, task: Task) -> Result<(), TaskManagerError>`
    * Aktualisiert die Task in `self.tasks`.
    * Ruft `scheduler.cancel_task()` für die alte Version auf.
    * Speichert die Task über `config_service`.
    * Wenn `task.enabled`, ruft `scheduler.schedule_task()` für die neue Version auf.
    * Sendet `TaskEvent::TaskUpdated`.

7.  **`TaskManagerService::remove_task()` Methode:**
    * `pub async fn remove_task(&self, task_id: &TaskId) -> Result<(), TaskManagerError>`
    * Entfernt die Task aus `self.tasks`.
    * Ruft `scheduler.cancel_task()` auf.
    * Löscht die Task über `config_service`.
    * Sendet `TaskEvent::TaskRemoved`.

8.  **`TaskManagerService::get_task()` Methode:**
    * `pub async fn get_task(&self, task_id: &TaskId) -> Option<Task>`

9.  **`TaskManagerService::get_all_tasks()` Methode:**
    * `pub async fn get_all_tasks(&self) -> Vec<Task>`

10. **`TaskManagerService::execute_manual_task()` Methode:**
    * `pub async fn execute_manual_task(&self, task_id: &TaskId) -> Result<(), TaskManagerError>`
    * Holt die Task.
    * Prüft, ob `task.trigger` `Manual` ist.
    * Ruft `execute_task()` auf.

11. **`TaskManagerService::subscribe_to_task_events()` Methode:**
    * `pub fn subscribe_to_task_events(&self) -> broadcast::Receiver<TaskEvent>`

12. **`TaskManagerService::load_tasks()` (private/helper):**
    * `async fn load_tasks(...) -> Result<Vec<Task>, TaskManagerError>`
    * Lädt Aufgaben aus der Konfiguration.

13. **`TaskManagerService::save_task()` (private/helper):**
    * `async fn save_task(...) -> Result<(), TaskManagerError>`
    * Speichert eine einzelne Aufgabe in der Konfiguration.

14. **`TaskManagerService::delete_task_config()` (private/helper):**
    * `async fn delete_task_config(...) -> Result<(), TaskManagerError>`
    * Löscht eine Aufgabe aus der Konfiguration.

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/task_management/service.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::task_management::data_types::{Task, TaskId, TaskAction, TaskTrigger, TaskStatus, TaskEvent}`
    * `crate::task_management::error::TaskManagerError`
    * `crate::task_management::scheduler::Scheduler`
    * `crate::config::service::ConfigServiceAsync`
    * `crate::event_bus::DbusEventBus` (muss in Domänenschicht neu definiert werden, oder D-Bus wird als Systemschicht-Abhängigkeit verstanden. Annahme: `DbusEventBus` für interne Domänen-Events, die über D-Bus gehen könnten, oder ein dedizierter Domänen-Event-Bus für `OnEvent` Trigger. Für den Scope dieser Spec ist ein Domänen-interner `DbusEventBus` anzunehmen, der als Schnittstelle zur Systemschicht fungiert.)
* **Extern:**
    * `tokio::sync::{broadcast, mpsc}`
    * `tokio::task::JoinHandle`
    * `tokio::process::Command`
    * `std::sync::Arc`
    * `tokio::sync::RwLock`
    * `std::collections::HashMap`
    * `tracing`

**Kommunikationsmuster:**

* Stellt eine CRUD-API für Aufgaben bereit.
* Integriert mit dem `Scheduler` für zeitliche Ausführung.
* Integriert mit `ConfigServiceAsync` für Persistenz.
* Integriert mit `DbusEventBus` für event-basierte Trigger und Aktionen.
* Sendet `TaskEvent`s über einen Broadcast-Kanal, um Änderungen im Task-Status mitzuteilen.
* Empfängt Ausführungsanfragen vom `Scheduler` über einen `mpsc` Kanal.

**Erwartete Ergebnisse/Outputs:**
Ein robuster und vollständiger Service für die Verwaltung und Ausführung von Hintergrundaufgaben.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `ConfigServiceAsync`, `DbusEventBus`, und `Scheduler`.
    * Testen von `add_task()`, `update_task()`, `remove_task()`:
        * Verifizieren, dass die Tasks korrekt im `HashMap` gespeichert/aktualisiert/gelöscht werden.
        * Prüfen, ob `config_service` korrekt zum Speichern/Löschen aufgerufen wird.
        * Prüfen, ob `scheduler.schedule_task()` / `cancel_task()` korrekt aufgerufen wird.
        * Prüfen, ob die korrekten `TaskEvent`s gesendet werden.
    * Testen von `execute_manual_task()`: Prüfen der Fehlerbehandlung für Nicht-manuelle Tasks.
    * Testen von `run()` (Simulieren von `TaskId`s, die auf `task_execution_rx` ankommen): Prüfen, ob `execute_task()` aufgerufen wird und der Task-Status korrekt aktualisiert wird.
    * Testen von `execute_task()` für verschiedene `TaskAction` Varianten:
        * Mocken von `tokio::process::Command` (z.B. mit `assert_cmd`).
        * Mocken von `dbus_event_bus.emit_event()`.
        * Verifizieren der Status-Updates und `TaskEvent`s.
* **Integration Tests:**
    * Starten des gesamten `task_management` Moduls mit echten `ConfigServiceAsync` und `DbusEventBus` (wenn Mocking zu komplex ist, könnte `DbusEventBus` in einem Test-Setup laufen).
    * Registrieren, Aktualisieren, Löschen von Tasks.
    * Beobachten der Ausführung von Tasks (z.B. indem die Tasks Log-Meldungen erzeugen oder Testdateien schreiben).
    * Prüfen, ob persistierte Tasks nach einem Neustart des Service korrekt geladen und geplant werden.

**Geschätzter Aufwand:** Extrem hoch (ca. 15-20 Tage, da komplexe Orchestrierung von Sub-Komponenten, Persistenz, asynchroner Ausführung und externer Interaktion)

---
### **novade-domain/src/screenshot/mod.rs**

**Verantwortlichkeit:**
Dieses Modul ist für die Aufnahme von Screenshots verantwortlich. Es definiert die notwendigen Datenstrukturen, den Service zur Steuerung der Screenshot-Funktionalität und die Fehlerbehandlung.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod data_types;` (Definition relevanter Datenstrukturen für Screenshots)
    * `pub mod service;` (Implementierung des `ScreenshotService`)
    * `pub mod error;` (Fehler-Enum für das Modul)

2.  **Re-Exporte (`pub use`):**
    * `pub use data_types::*;`
    * `pub use service::ScreenshotService;`
    * `pub use error::ScreenshotError;`

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/screenshot/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* `ScreenshotService` wird von der `DomainServices` Initialisierungsroutine in `novade-domain/src/lib.rs` instanziiert.
* Andere Services (z.B. `novade-ui::components::command_palette`) können den `ScreenshotService` aufrufen.

**Erwartete Ergebnisse/Outputs:**
Eine kohärente API zur Steuerung und Verwaltung von Screenshots.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-domain/src/screenshot/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`ScreenshotError`) für das Screenshot-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`ScreenshotError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `SystemError(String)`: Fehler von der Systemschicht (z.B. Compositor-Fehler beim Aufnehmen des Bildes).
        * `IoError(#[from] std::io::Error)`: Fehler beim Speichern der Screenshot-Datei.
        * `FormatError(String)`: Fehler beim Konvertieren des Bildformats.
        * `PermissionDenied(String)`: Fehlende Berechtigungen für das Speichern.
        * `NoScreenshotsTaken`: Es wurde kein Screenshot aufgenommen.
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/screenshot/error.rs`

**Abhängigkeiten:**

* **Intern:** Keine.
* **Extern:** `thiserror::Error`, `std::io::Error`.

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `screenshot`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für Screenshot-Operationen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `ScreenshotError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.2 Tage)

---

### **novade-domain/src/screenshot/data_types.rs**

**Verantwortlichkeit:**
Definiert die Datenstrukturen, die zur Beschreibung von Screenshots und ihren Parametern im `screenshot`-Modul verwendet werden.

**Kern-Aufgaben (Tasks):**

1.  **`ScreenshotRegion` Enum:**
    * Definiert den Bereich, der aufgenommen werden soll.
    * `pub enum ScreenshotRegion {`
    * `Fullscreen,`
    * `ActiveWindow,`
    * `Selection(Rectangle<i32>),` (Für benutzerdefinierte rechteckige Auswahl)
    * `}`
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.

2.  **`ScreenshotFormat` Enum:**
    * Definiert das Dateiformat für den Screenshot.
    * `pub enum ScreenshotFormat {`
    * `Png,`
    * `Jpeg,`
    * `WebP,`
    * `}`
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.
    * `impl Display for ScreenshotFormat`: Für menschenlesbare Namen.

3.  **`ScreenshotOptions` Struktur:**
    * Konfiguriert die Parameter für die Screenshot-Aufnahme.
    * `pub struct ScreenshotOptions {`
    * `pub region: ScreenshotRegion,`
    * `pub format: ScreenshotFormat,`
    * `pub destination_path: Option<PathBuf>,` (Optionaler Pfad zum Speichern. Wenn None, Standard-Screenshot-Verzeichnis verwenden)
    * `pub copy_to_clipboard: bool,`
    * `pub show_ui_confirmation: bool,`
    * `}`
    * Implementiere `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
    * `Default` sollte sinnvolle Standardwerte liefern (z.B. `Fullscreen`, `Png`, `None`, `true`, `true`).

4.  **`ScreenshotResult` Struktur:**
    * Das Ergebnis einer erfolgreichen Screenshot-Operation.
    * `pub struct ScreenshotResult {`
    * `pub path: PathBuf,` (Pfad zur gespeicherten Datei)
    * `pub timestamp: DateTime<Local>,` (Zeitpunkt der Aufnahme)
    * `}`
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    * `pub fn new(path: PathBuf, timestamp: DateTime<Local>) -> Self`

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/screenshot/data_types.rs`

**Abhängigkeiten:**

* **Intern:** `novade_core::types::geometry::Rectangle`.
* **Extern:** `serde::{Serialize, Deserialize}`, `std::path::PathBuf`, `chrono::{DateTime, Local}`, `std::fmt::Display`.

**Kommunikationsmuster:**

* Diese Strukturen werden von der UI an den `ScreenshotService` übergeben, um Screenshot-Operationen zu initiieren.
* Der `ScreenshotService` gibt `ScreenshotResult` als Ergebnis zurück.

**Erwartete Ergebnisse/Outputs:**
Klare und konsistente Datenmodelle zur Steuerung und Ergebnismeldung von Screenshot-Operationen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `Default` Implementierung für `ScreenshotOptions`.
    * Testen der `new()`-Funktion für `ScreenshotResult`.
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` (wo zutreffend) Implementierungen.
    * Testen der Serialisierung und Deserialisierung für alle Strukturen/Enums.
    * Testen der `Display` Implementierung für `ScreenshotFormat`.

**Geschätzter Aufwand:** Gering (ca. 1 Tag)

---

### **novade-domain/src/screenshot/service.rs**

**Verantwortlichkeit:**
Implementiert den `ScreenshotService`, der die Kernlogik für die Aufnahme von Screenshots kapselt. Dieser Service delegiert die eigentliche Bildaufnahme an die Systemschicht und kümmert sich um das Speichern der Dateien, die Verwaltung der Optionen und die Benachrichtigung der UI.

**Kern-Aufgaben (Tasks):**

1.  **`ScreenshotService` Struktur:**
    * `pub struct ScreenshotService {`
    * `screenshot_system_service: Arc<dyn ScreenshotSystemServiceTrait + Send + Sync>,` (Trait für die Systemschicht-Integration)
    * `config_service: Arc<ConfigServiceAsync>,`
    * `notification_service: Arc<NotificationService>,`
    * `}`

2.  **`ScreenshotService::new()` Funktion:**
    * `pub fn new(screenshot_system_service: Arc<dyn ScreenshotSystemServiceTrait + Send + Sync>, config_service: Arc<ConfigServiceAsync>, notification_service: Arc<NotificationService>) -> Arc<Self>`
    * Initialisiert den Service mit den Abhängigkeiten.

3.  **`ScreenshotService::take_screenshot()` Methode:**
    * `pub async fn take_screenshot(&self, options: ScreenshotOptions) -> Result<ScreenshotResult, ScreenshotError>`
    * **Logik:**
        * Ruft `screenshot_system_service.capture_screenshot(options.region)` auf, um die Rohbilddaten zu erhalten (oder einen temporären Pfad).
        * Wenn `options.destination_path` gesetzt ist, wird der angegebene Pfad verwendet.
        * Andernfalls wird ein Standardpfad im Benutzer-`Pictures`-Verzeichnis generiert (`XDG_PICTURES_DIR` oder Fallback). Dateiname sollte Timestamp-basiert sein (z.B. `Screenshot_YYYY-MM-DD_HH-MM-SS.png`).
        * Konvertiert das Bild in das `options.format` (Delegation an Systemschicht oder Helper-Funktion).
        * Speichert das Bild am Zielpfad.
        * Wenn `options.copy_to_clipboard` `true` ist, kopiert das Bild in die Zwischenablage (Delegation an Systemschicht).
        * Erstellt ein `ScreenshotResult` Objekt.
        * Wenn `options.show_ui_confirmation` `true` ist, sendet eine Benachrichtigung über `notification_service` (z.B. "Screenshot gespeichert unter: /path/to/screenshot.png" mit Option zum Öffnen des Ordners).
        * Gibt das `ScreenshotResult` zurück.
        * **Fehlerbehandlung:** Alle möglichen Fehler (Systemfehler, I/O, Format) müssen in `ScreenshotError` konvertiert und zurückgegeben werden.

4.  **`ScreenshotService::open_screenshots_folder()` Methode:**
    * `pub async fn open_screenshots_folder(&self) -> Result<(), ScreenshotError>`
    * Ermittelt das Standard-Screenshot-Verzeichnis.
    * Öffnet dieses Verzeichnis im Dateimanager (Delegation an Systemschicht über `ShellService` oder ähnliches).

5.  **`ScreenshotService::set_default_options()` Methode (Optional):**
    * `pub async fn set_default_options(&self, options: ScreenshotOptions) -> Result<(), ScreenshotError>`
    * Speichert die Standard-Screenshot-Optionen über `config_service`.

6.  **`ScreenshotService::get_default_options()` Methode (Optional):**
    * `pub async fn get_default_options(&self) -> Result<ScreenshotOptions, ScreenshotError>`
    * Lädt die Standard-Screenshot-Optionen über `config_service`. Wenn nicht vorhanden, gibt `ScreenshotOptions::default()` zurück.

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/screenshot/service.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::screenshot::data_types::{ScreenshotOptions, ScreenshotRegion, ScreenshotFormat, ScreenshotResult}`
    * `crate::screenshot::error::ScreenshotError`
    * `crate::config::service::ConfigServiceAsync`
    * `crate::notification::service::NotificationService`
    * `novade_core::types::geometry::Rectangle`
    * `novade_system::screenshot_capture::ScreenshotSystemServiceTrait` (Ein neu zu definierendes Trait in der Systemschicht).
    * `novade_system::shell_integration::ShellServiceTrait` (für das Öffnen von Ordnern, muss noch definiert werden).
* **Extern:**
    * `std::sync::Arc`
    * `chrono::{Local, DateTime, Datelike, Timelike, Utc}`
    * `std::path::PathBuf`
    * `tokio::fs`
    * `tracing`

**Kommunikationsmuster:**

* Empfängt Anfragen zur Screenshot-Aufnahme von der UI oder anderen Domänen-Services.
* Delegiert die eigentliche Bildaufnahme an die `ScreenshotSystemServiceTrait` (Systemschicht).
* Nutzt `ConfigServiceAsync` für die Persistenz von Standardoptionen.
* Nutzt `NotificationService` für Benutzerbenachrichtigungen.
* Nutzt `ShellServiceTrait` für das Öffnen von Ordnern.

**Erwartete Ergebnisse/Outputs:**
Ein Service, der eine vollständige und konfigurierbare Screenshot-Funktionalität bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `ScreenshotSystemServiceTrait`, `ConfigServiceAsync`, `NotificationService`, `ShellServiceTrait`.
    * Testen von `take_screenshot()`:
        * Verifizieren, dass `capture_screenshot` mit der korrekten Region aufgerufen wird.
        * Verifizieren der Pfadgenerierung und dass `tokio::fs::write` (oder Mock-Äquivalent) mit den korrekten Daten aufgerufen wird.
        * Prüfen, ob `copy_to_clipboard` richtig delegiert wird.
        * Prüfen, ob `notification_service.send_notification` korrekt aufgerufen wird.
        * Testen der Fehlerbehandlung für alle Fehlerquellen (Systemdienst, I/O, Format).
    * Testen von `open_screenshots_folder()`: Verifizieren, dass `shell_service.open_path` mit dem korrekten Pfad aufgerufen wird.
    * Testen von `set_default_options()` und `get_default_options()`: Sicherstellen, dass Optionen korrekt gespeichert und geladen werden.
* **Integration Tests:**
    * Starten der NovaDE mit dem `ScreenshotService` und echten System-Services (wo möglich).
    * Auslösen von Screenshot-Operationen über die UI (z.B. `Super+PrintScreen`).
    * Visuelle Überprüfung der Screenshots und ihrer Speicherung.
    * Testen der "In Zwischenablage kopieren"-Funktion.
    * Testen der Benachrichtigungen und des "Ordner öffnen"-Links.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage, da Integration mit mehreren Services und Dateisystem-Operationen)

---

### **novade-domain/src/clipboard/mod.rs**

**Verantwortlichkeit:**
Dieses Modul ist für die Verwaltung des System-Clipboards verantwortlich. Es bietet Schnittstellen zum Setzen und Abrufen von Clipboard-Inhalten für verschiedene Datentypen (Text, Bilder, Dateien).

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod data_types;` (Definition relevanter Datenstrukturen für Clipboard-Inhalte)
    * `pub mod service;` (Implementierung des `ClipboardService`)
    * `pub mod error;` (Fehler-Enum für das Modul)

2.  **Re-Exporte (`pub use`):**
    * `pub use data_types::*;`
    * `pub use service::ClipboardService;`
    * `pub use error::ClipboardError;`

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/clipboard/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* `ClipboardService` wird von der `DomainServices` Initialisierungsroutine in `novade-domain/src/lib.rs` instanziiert.
* Andere Services (z.B. `ScreenshotService`, `TextEditorService`) oder die UI können den `ClipboardService` aufrufen.

**Erwartete Ergebnisse/Outputs:**
Eine kohärente API zur Interaktion mit dem System-Clipboard.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-domain/src/clipboard/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`ClipboardError`) für das Clipboard-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`ClipboardError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `SystemError(String)`: Fehler von der Systemschicht (z.B. D-Bus-Kommunikation, Wayland-Protokollfehler).
        * `UnsupportedDataType(String)`: Der angeforderte Datentyp wird nicht unterstützt.
        * `EmptyClipboard`: Das Clipboard ist leer.
        * `ConversionError(String)`: Fehler bei der Datenkonvertierung.
        * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler (z.B. beim Lesen/Schreiben von Dateien für den Datentransfer).
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/clipboard/error.rs`

**Abhängigkeiten:**

* **Intern:** Keine.
* **Extern:** `thiserror::Error`, `std::io::Error`.

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `clipboard`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für Clipboard-Operationen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `ClipboardError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.2 Tage)

---

### **novade-domain/src/clipboard/data_types.rs**

**Verantwortlichkeit:**
Definiert die Datenstrukturen, die zur Beschreibung von Clipboard-Inhalten im `clipboard`-Modul verwendet werden.

**Kern-Aufgaben (Tasks):**

1.  **`ClipboardContentType` Enum:**
    * Definiert die Art des Inhalts im Clipboard.
    * `pub enum ClipboardContentType {`
    * `Text(String),`
    * `Image(Vec<u8>, String),` (Bilddaten als Bytes, gefolgt von MIME-Typ wie "image/png")
    * `Files(Vec<PathBuf>),` (Liste von Dateipfaden)
    * `Url(String),`
    * `Empty,`
    * `Unknown(String),` (Für nicht unterstützte oder unbekannte Typen, mit MIME-Typ)
    * `}`
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.

2.  **`ClipboardState` Struktur:**
    * Repräsentiert den aktuellen Zustand des Clipboards.
    * `pub struct ClipboardState {`
    * `pub content_type: ClipboardContentType,`
    * `pub last_updated: DateTime<Local>,`
    * `}`
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Serialize`, `Deserialize`.
    * `pub fn new(content_type: ClipboardContentType) -> Self`
    * `Default` für `ClipboardState` sollte `Empty` und aktuelle Zeit setzen.

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/clipboard/data_types.rs`

**Abhängigkeiten:**

* **Intern:** Keine.
* **Extern:** `serde::{Serialize, Deserialize}`, `std::path::PathBuf`, `chrono::{DateTime, Local}`, `std::vec::Vec`.

**Kommunikationsmuster:**

* Diese Strukturen werden vom `ClipboardService` intern verwendet und über Events an Abonnenten gesendet.
* Sie werden auch vom `ClipboardService` an die Systemschicht übergeben oder von dort empfangen.

**Erwartete Ergebnisse/Outputs:**
Klare und konsistente Datenmodelle zur Repräsentation des Clipboard-Inhalts.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktion für `ClipboardState`.
    * Testen der `Default` Implementierung für `ClipboardState`.
    * Testen der `Clone`, `Debug`, `PartialEq` Implementierungen.
    * Testen der Serialisierung und Deserialisierung für alle Strukturen/Enums.
    * Testen verschiedener `ClipboardContentType` Varianten.

**Geschätzter Aufwand:** Gering (ca. 1 Tag)

---

### **novade-domain/src/clipboard/service.rs**

**Verantwortlichkeit:**
Implementiert den `ClipboardService`, der die Interaktion mit dem System-Clipboard verwaltet. Dieser Service abstrahiert die spezifischen System-APIs für den Clipboard-Zugriff und stellt eine domänenspezifische Schnittstelle bereit.

**Kern-Aufgaben (Tasks):**

1.  **`ClipboardService` Struktur:**
    * `pub struct ClipboardService {`
    * `clipboard_system_service: Arc<dyn ClipboardSystemServiceTrait + Send + Sync>,` (Trait für die Systemschicht-Integration)
    * `state_sender: broadcast::Sender<ClipboardState>,` (Für externe Abonnenten des Clipboard-Zustands)
    * `current_state: RwLock<ClipboardState>,`
    * `}`

2.  **`ClipboardService::new()` Funktion:**
    * `pub fn new(clipboard_system_service: Arc<dyn ClipboardSystemServiceTrait + Send + Sync>) -> Arc<Self>`
    * Erstellt einen `broadcast::channel` für `state_sender`.
    * Initialisiert `current_state` mit `ClipboardState::default()`.
    * Initialisiert den Service mit der Abhängigkeit.
    * Startet einen Listener, der auf Änderungen des System-Clipboards hört (mittels `clipboard_system_service.subscribe_to_changes()`) und dann `update_clipboard_state()` aufruft.

3.  **`ClipboardService::set_text()` Methode:**
    * `pub async fn set_text(&self, text: &str) -> Result<(), ClipboardError>`
    * Ruft `clipboard_system_service.set_text(text)` auf.
    * Bei Erfolg aktualisiert `update_clipboard_state()` mit `ClipboardContentType::Text`.

4.  **`ClipboardService::get_text()` Methode:**
    * `pub async fn get_text(&self) -> Result<String, ClipboardError>`
    * Ruft `clipboard_system_service.get_text()` auf.
    * Gibt das Ergebnis zurück. Wenn der Typ nicht Text ist, Fehler `UnsupportedDataType` zurückgeben.

5.  **`ClipboardService::set_image()` Methode:**
    * `pub async fn set_image(&self, data: &[u8], mime_type: &str) -> Result<(), ClipboardError>`
    * Ruft `clipboard_system_service.set_image(data, mime_type)` auf.
    * Bei Erfolg aktualisiert `update_clipboard_state()` mit `ClipboardContentType::Image`.

6.  **`ClipboardService::get_image()` Methode:**
    * `pub async fn get_image(&self) -> Result<(Vec<u8>, String), ClipboardError>`
    * Ruft `clipboard_system_service.get_image()` auf.
    * Gibt das Ergebnis zurück. Wenn der Typ nicht Bild ist, Fehler `UnsupportedDataType` zurückgeben.

7.  **`ClipboardService::set_files()` Methode:**
    * `pub async fn set_files(&self, paths: &[PathBuf]) -> Result<(), ClipboardError>`
    * Ruft `clipboard_system_service.set_files(paths)` auf.
    * Bei Erfolg aktualisiert `update_clipboard_state()` mit `ClipboardContentType::Files`.

8.  **`ClipboardService::get_files()` Methode:**
    * `pub async fn get_files(&self) -> Result<Vec<PathBuf>, ClipboardError>`
    * Ruft `clipboard_system_service.get_files()` auf.
    * Gibt das Ergebnis zurück. Wenn der Typ nicht Dateien ist, Fehler `UnsupportedDataType` zurückgeben.

9.  **`ClipboardService::clear_clipboard()` Methode:**
    * `pub async fn clear_clipboard(&self) -> Result<(), ClipboardError>`
    * Ruft `clipboard_system_service.clear_clipboard()` auf.
    * Bei Erfolg aktualisiert `update_clipboard_state()` mit `ClipboardContentType::Empty`.

10. **`ClipboardService::get_current_state()` Methode:**
    * `pub async fn get_current_state(&self) -> ClipboardState`
    * Gibt den aktuellen internen `ClipboardState` zurück.

11. **`ClipboardService::subscribe_to_changes()` Methode:**
    * `pub fn subscribe_to_changes(&self) -> broadcast::Receiver<ClipboardState>`
    * Gibt einen neuen `broadcast::Receiver` für Clipboard-Zustandsänderungen zurück.

12. **`ClipboardService::update_clipboard_state()` (private Methode):**
    * `async fn update_clipboard_state(self: Arc<Self>) -> Result<(), ClipboardError>`
    * Holt den aktuellen Inhalt vom `clipboard_system_service` (fragt alle relevanten Formate ab).
    * Bestimmt den `ClipboardContentType`.
    * Aktualisiert `self.current_state`.
    * Sendet den neuen Zustand über `self.state_sender`.

**Spezifische Artefakte/Dateien:**

* `novade-domain/src/clipboard/service.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::clipboard::data_types::{ClipboardContentType, ClipboardState}`
    * `crate::clipboard::error::ClipboardError`
    * `novade_system::clipboard_integration::ClipboardSystemServiceTrait` (Ein neu zu definierendes Trait in der Systemschicht).
* **Extern:**
    * `std::sync::Arc`
    * `tokio::sync::broadcast::{self, Sender, Receiver}`
    * `tokio::sync::RwLock`
    * `tracing`
    * `chrono::Local`

**Kommunikationsmuster:**

* Stellt eine API zum Setzen und Abrufen von Clipboard-Inhalten bereit.
* Delegiert die tatsächliche Interaktion mit dem System-Clipboard an die `ClipboardSystemServiceTrait` (Systemschicht).
* Sendet `ClipboardState` Events über einen Broadcast-Kanal, um Änderungen im Clipboard mitzuteilen.
* Hört selbst auf System-Clipboard-Änderungen über das `ClipboardSystemServiceTrait`.

**Erwartete Ergebnisse/Outputs:**
Ein robuster und vollständiger Service für die Interaktion mit dem System-Clipboard, der verschiedene Datentypen unterstützt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `ClipboardSystemServiceTrait`.
    * Testen von `set_text()`, `get_text()`, `set_image()`, `get_image()`, `set_files()`, `get_files()`, `clear_clipboard()`:
        * Verifizieren, dass die korrekten Methoden auf dem gemockten `clipboard_system_service` aufgerufen werden.
        * Prüfen, ob `state_sender` korrekte `ClipboardState` Updates sendet.
        * Testen der Fehlerbehandlung für `UnsupportedDataType`, `EmptyClipboard` und `SystemError`.
    * Testen des initialen Zustands und der `subscribe_to_changes()` Methode.
    * Simulieren von System-Clipboard-Änderungen über den Mock und Prüfen, ob der `current_state` und die gesendeten Events korrekt sind.
* **Integration Tests:**
    * Starten der NovaDE mit dem `ClipboardService` und einem echten `ClipboardSystemService` (falls GTK-Clipboard oder Wayland-Clipboard direkt getestet werden kann).
    * Manuelles Kopieren/Einfügen von Text, Bildern, Dateien in und aus anderen Anwendungen.
    * Prüfen, ob der NovaDE-Clipboard-Service die Änderungen erkennt und die Inhalte korrekt verarbeiten kann.
    * Implementieren von einfachen UI-Elementen, die Clipboard-Operationen auslösen und deren Ergebnisse anzeigen.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da Umgang mit verschiedenen Datentypen und asynchronen System-Events)

---
**Übergang zur Systemschicht**

Nachdem die Domänenschicht mit allen wesentlichen Services (Konfiguration, Fehlerbehandlung, Logging, Ereignisbus, Benachrichtigungen, Einstellungen, Themen, Desktop-Zustand, Wallpaper-Manager, Datum/Uhrzeit, Aufgabenverwaltung, Screenshots, Clipboard) detailliert spezifiziert wurde, beginnt die Spezifikation der Systemschicht. Diese Schicht ist dafür verantwortlich, die abstrakten Anforderungen der Domänenschicht in konkrete Interaktionen mit dem Betriebssystem, der Hardware und externen Prozessen umzusetzen.

Die Systemschicht wird in mehrere logische Module unterteilt, die jeweils für spezifische Systeminteraktionen zuständig sind. Die Kommunikation mit der Domänenschicht erfolgt über klar definierte Traits und Service-Implementierungen, die die Entkopplung und Testbarkeit gewährleisten.

Beginn der Systemschicht-Spezifikation:

### **novade-system/src/mod.rs**

**Verantwortlichkeit:**
Dieses Modul ist der Einstiegspunkt für die gesamte `novade-system` Crate. Es definiert die öffentliche API der Systemschicht, indem es die wichtigsten Services und Traits re-exportiert. Es initialisiert die Systemschicht und bietet einen Container für alle System-Services.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod compositor;` (Wayland Compositor Implementierung)
    * `pub mod input;` (Eingabeverarbeitung)
    * `pub mod dbus_interfaces;` (D-Bus Clients und Server)
    * `pub mod audio_management;` (Audio-Steuerung via PipeWire)
    * `pub mod display_management;` (Bildschirm- und Helligkeitssteuerung)
    * `pub mod network_management;` (Netzwerk- und Bluetooth-Steuerung)
    * `pub mod power_management;` (Energieverwaltung)
    * `pub mod screenshot_capture;` (System-spezifische Screenshot-Aufnahme)
    * `pub mod clipboard_integration;` (System-spezifische Clipboard-Integration)
    * `pub mod shell_integration;` (Integration mit Shell-Funktionen wie Dateimanager öffnen)
    * `pub mod process_management;` (Prozess-Management, z.B. App-Start)
    * `pub mod xdg_portal_integration;` (XDG Desktop Portals Integration)
    * `pub mod config;` (Systemschicht-spezifische Konfiguration, die Systemdienste betreffen kann)
    * `pub mod error;` (Globale Fehler für die Systemschicht)

2.  **Re-Exporte (`pub use`):**
    * `pub use error::SystemServiceError;`
    * `pub use compositor::CompositorService;`
    * `pub use input::InputService;`
    * `pub use dbus_interfaces::{DbusClientService, DbusServerService};` (oder spezifische Clients/Server)
    * `pub use audio_management::AudioManagementService;`
    * `pub use display_management::DisplayManagementService;`
    * `pub use network_management::NetworkManagementService;`
    * `pub use power_management::PowerManagementService;`
    * `pub use screenshot_capture::ScreenshotSystemServiceTrait;` (Das Trait, nicht die Implementierung)
    * `pub use clipboard_integration::ClipboardSystemServiceTrait;`
    * `pub use shell_integration::ShellServiceTrait;`
    * `pub use process_management::ProcessManagerService;`
    * `pub use xdg_portal_integration::XdgPortalService;`

3.  **`SystemServices` Struktur:**
    * `pub struct SystemServices {`
    * `pub compositor_service: Arc<CompositorService>,`
    * `pub input_service: Arc<InputService>,`
    * `pub dbus_client_service: Arc<DbusClientService>,`
    * `pub audio_management_service: Arc<AudioManagementService>,`
    * `pub display_management_service: Arc<DisplayManagementService>,`
    * `pub network_management_service: Arc<NetworkManagementService>,`
    * `pub power_management_service: Arc<PowerManagementService>,`
    * `pub screenshot_system_service: Arc<dyn ScreenshotSystemServiceTrait + Send + Sync>,`
    * `pub clipboard_system_service: Arc<dyn ClipboardSystemServiceTrait + Send + Sync>,`
    * `pub shell_service: Arc<dyn ShellServiceTrait + Send + Sync>,`
    * `pub process_manager_service: Arc<ProcessManagerService>,`
    * `pub xdg_portal_service: Arc<XdgPortalService>,`
    * `// D-Bus server service might be spawned separately, not necessarily held here`
    * `}`

4.  **`init_system_services()` Funktion:**
    * `pub async fn init_system_services(domain_services: &DomainServices) -> Result<SystemServices, SystemServiceError>`
    * **Zweck:** Initialisiert alle System-Services und injiziert die notwendigen Abhängigkeiten von der Domänenschicht (z.B. `DesktopStateService`, `NotificationService`).
    * **Schritte:**
        * Initialisiere `CompositorService`.
        * Initialisiere `InputService`.
        * Initialisiere `DbusClientService` (für System-D-Bus-Interaktionen).
        * Initialisiere `AudioManagementService`.
        * Initialisiere `DisplayManagementService`.
        * Initialisiere `NetworkManagementService`.
        * Initialisiere `PowerManagementService`.
        * Initialisiere die konkreten Implementierungen für `ScreenshotSystemServiceTrait`, `ClipboardSystemServiceTrait`, `ShellServiceTrait` und `ProcessManagerService`.
        * Initialisiere `XdgPortalService`.
        * Spawnt alle Hintergrund-Tasks der Services (`.run()` Methoden).
        * Gibt die `SystemServices` Struktur zurück.
    * **Abhängigkeiten:** Hier müssen die Abhängigkeiten von der `DomainServices` Struktur (und somit `novade-domain`) eingefügt werden, die für die Systemschicht relevant sind.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/mod.rs`
* `novade-system/src/lib.rs` (enthält `init_system_services` oder ruft es von `mod.rs` auf)

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses, insbesondere die `service.rs` Dateien der einzelnen Module.
* **Extern:** `std::sync::Arc`, `novade_domain::DomainServices` (für die Initialisierung), `tokio` für das Spawnen von Tasks.

**Kommunikationsmuster:**

* Definiert die vertikale API der Systemschicht.
* Die `init_system_services` Funktion ist der zentrale Startpunkt für die Systemschicht, der von der `novade-desktop` Anwendung aufgerufen wird.

**Erwartete Ergebnisse/Outputs:**
Eine vollständig initialisierte und funktionierende Systemschicht, bereit zur Interaktion mit der Domänen- und UI-Schicht.

**Teststrategie (Modul-spezifisch):**

* **Integration Tests für `init_system_services()`:**
    * Starten der Funktion und Überprüfen, ob alle Services korrekt initialisiert und deren `run()`-Methoden (falls vorhanden) gestartet werden.
    * Tests, die sicherstellen, dass die Abhängigkeiten korrekt injiziert werden.
    * Überprüfen der Fehlerbehandlung während der Initialisierung.
* **Keine spezifischen Unit Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 1 Tag, hauptsächlich Orchestrierung)

---
### **novade-system/src/error.rs**

**Verantwortlichkeit:**
Definiert das globale Fehler-Enum (`SystemServiceError`) für die gesamte Systemschicht. Alle modulspezifischen Fehler der Systemschicht werden in dieses zentrale Enum konvertiert.

**Kern-Aufgaben (Tasks):**

1.  **`SystemServiceError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `CompositorError(#[from] crate::compositor::error::CompositorError)`: Fehler vom Compositor-Modul.
        * `InputError(#[from] crate::input::error::InputError)`: Fehler vom Eingabe-Modul.
        * `DbusError(#[from] crate::dbus_interfaces::error::DbusError)`: Fehler von D-Bus-Interaktionen.
        * `AudioManagementError(#[from] crate::audio_management::error::AudioManagementError)`: Fehler vom Audio-Management.
        * `DisplayManagementError(#[from] crate::display_management::error::DisplayManagementError)`: Fehler vom Display-Management.
        * `NetworkManagementError(#[from] crate::network_management::error::NetworkManagementError)`: Fehler vom Netzwerk-Management.
        * `PowerManagementError(#[from] crate::power_management::error::PowerManagementError)`: Fehler vom Energie-Management.
        * `ScreenshotCaptureError(#[from] crate::screenshot_capture::error::ScreenshotCaptureError)`: Fehler von der Screenshot-Aufnahme.
        * `ClipboardIntegrationError(#[from] crate::clipboard_integration::error::ClipboardIntegrationError)`: Fehler von der Clipboard-Integration.
        * `ShellIntegrationError(#[from] crate::shell_integration::error::ShellIntegrationError)`: Fehler von der Shell-Integration.
        * `ProcessManagementError(#[from] crate::process_management::error::ProcessManagementError)`: Fehler vom Prozess-Management.
        * `XdgPortalError(#[from] crate::xdg_portal_integration::error::XdgPortalError)`: Fehler von XDG Portals.
        * `ConfigError(#[from] crate::config::error::SystemConfigError)`: Fehler von der Systemschicht-Konfiguration.
        * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler.
        * `TaskSpawnError(String)`: Fehler beim Spawnen einer Tokio-Task.
        * `Other(String)`: Allgemeine, unspezifizierte Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/error.rs`

**Abhängigkeiten:**

* **Intern:** Alle spezifischen Fehler-Enums der Submodule (`crate::compositor::error::CompositorError`, etc.).
* **Extern:** `thiserror::Error`, `std::io::Error`.

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden in der gesamten `novade-system` Crate zurückgegeben.
* Dient als Aggregator für alle systemnahen Fehler.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und umfassendes Fehlerbehandlungssystem für die gesamte Systemschicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `SystemServiceError` Varianten aus den Quellfehlern der Submodule.
    * Sicherstellen, dass die `source()`-Kette korrekt funktioniert.
    * Testen der Formatierung der Fehlermeldungen.

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---

### **novade-system/src/config/mod.rs**

**Verantwortlichkeit:**
Dieses Modul verwaltet die Systemschicht-spezifische Konfiguration, die für die Operationen der Systemdienste relevant ist. Es kapselt die Datenstrukturen und die Schnittstelle zur Persistenz.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod data_types;` (Definition relevanter Konfigurationsstrukturen)
    * `pub mod error;` (Fehler-Enum für die Systemschicht-Konfiguration)

2.  **Re-Exporte (`pub use`):**
    * `pub use data_types::*;`
    * `pub use error::SystemConfigError;`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/config/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** Keine direkten externen Abhängigkeiten.

**Kommunikationsmuster:**

* Wird von System-Services genutzt, um ihre Konfiguration zu laden oder zu speichern, typischerweise über den `ConfigServiceAsync` aus der Domänenschicht.

**Erwartete Ergebnisse/Outputs:**
Eine klar definierte Schnittstelle für die Systemschicht-Konfiguration.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-system/src/config/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`SystemConfigError`) für die Systemschicht-Konfiguration.

**Kern-Aufgaben (Tasks):**

1.  **`SystemConfigError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `SerializationError(#[from] serde_json::Error)`: Fehler bei der Serialisierung/Deserialisierung.
        * `IoError(#[from] std::io::Error)`: Fehler beim Lesen/Schreiben von Konfigurationsdateien.
        * `InvalidConfig(String)`: Die geladene Konfiguration ist ungültig.
        * `Other(String)`: Allgemeine Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/config/error.rs`

**Abhängigkeiten:**

* **Intern:** Keine.
* **Extern:** `thiserror::Error`, `serde_json::Error`, `std::io::Error`.

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `system::config`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für die Systemschicht-Konfiguration.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `SystemConfigError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.2 Tage)

---

### **novade-system/src/config/data_types.rs**

**Verantwortlichkeit:**
Definiert die Datenstrukturen, die die Konfigurationseinstellungen für die Systemschicht-Komponenten repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`CompositorConfig` Struktur:**
    * `pub struct CompositorConfig {`
    * `pub enable_xwayland: bool,`
    * `pub max_clients: u32,`
    * `pub cursor_theme: String,`
    * `pub cursor_size: u32,`
    * `pub font_config: String,` (Optional, für Schriftarten-Rendering im Compositor)
    * `}`
    * Implementiere `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
    * `Default` sollte sinnvolle Basiswerte liefern.

2.  **`InputConfig` Struktur:**
    * `pub struct InputConfig {`
    * `pub enable_libinput: bool,`
    * `pub keyboard_layout: String,` (z.B. "de", "us")
    * `pub keyboard_variant: Option<String>,`
    * `pub keyboard_options: Option<String>,`
    * `pub touchpad_sensitivity: f64,`
    * `pub touchpad_natural_scroll: bool,`
    * `pub mouse_sensitivity: f64,`
    * `}`
    * Implementiere `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
    * `Default` sollte sinnvolle Basiswerte liefern.

3.  **`DisplayConfig` Struktur:**
    * `pub struct DisplayConfig {`
    * `pub default_brightness: f64,` (0.0 - 1.0)
    * `pub enable_dpms: bool,`
    * `}`
    * Implementiere `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
    * `Default` sollte sinnvolle Basiswerte liefern.

4.  **`NetworkConfig` Struktur:**
    * `pub struct NetworkConfig {`
    * `pub enable_wifi: bool,`
    * `pub enable_bluetooth: bool,`
    * `pub default_connection: Option<String>,`
    * `}`
    * Implementiere `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
    * `Default` sollte sinnvolle Basiswerte liefern.

5.  **`PowerConfig` Struktur:**
    * `pub struct PowerConfig {`
    * `pub suspend_on_lid_close: bool,`
    * `pub critical_battery_action: String,` (z.B. "shutdown", "hibernate")
    * `pub idle_timeout_seconds: u64,`
    * `}`
    * Implementiere `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
    * `Default` sollte sinnvolle Basiswerte liefern.

6.  **`ScreenshotConfig` Struktur:**
    * `pub struct ScreenshotConfig {`
    * `pub default_format: String,` (z.B. "png", "jpeg")
    * `pub default_save_directory: PathBuf,`
    * `pub copy_to_clipboard_by_default: bool,`
    * `}`
    * Implementiere `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
    * `Default` sollte sinnvolle Basiswerte liefern (z.B. `Png`, `XDG_PICTURES_DIR`).

7.  **`SystemSettings` Struktur (Aggregator):**
    * `pub struct SystemSettings {`
    * `pub compositor: CompositorConfig,`
    * `pub input: InputConfig,`
    * `pub display: DisplayConfig,`
    * `pub network: NetworkConfig,`
    * `pub power: PowerConfig,`
    * `pub screenshot: ScreenshotConfig,`
    * `}`
    * Implementiere `Clone`, `Debug`, `Default`, `PartialEq`, `Serialize`, `Deserialize`.
    * `Default` sollte die `Default`-Implementierungen der enthaltenen Strukturen nutzen.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/config/data_types.rs`

**Abhängigkeiten:**

* **Intern:** Keine.
* **Extern:** `serde::{Serialize, Deserialize}`, `std::path::PathBuf`.

**Kommunikationsmuster:**

* Diese Strukturen werden vom `ConfigServiceAsync` (Domänenschicht) geladen und gespeichert.
* System-Services lesen diese Konfiguration, um ihr Verhalten anzupassen.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut definiertes Datenmodell für die Konfiguration der Systemschicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `Default` Implementierungen für alle Strukturen.
    * Testen der `Clone`, `Debug`, `PartialEq` Implementierungen.
    * Testen der Serialisierung und Deserialisierung für alle Strukturen (z.B. zu/von JSON).

**Geschätzter Aufwand:** Mittel (ca. 1-2 Tage)

---

### **novade-system/src/compositor/mod.rs**

**Verantwortlichkeit:**
Dieses Modul enthält die Kernlogik für den Wayland-Compositor, basierend auf dem Smithay Toolkit. Es ist verantwortlich für die Fensterverwaltung, Protokollimplementierungen und das Rendering.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod error;` (Fehler-Enum für den Compositor)
    * `pub mod data_types;` (Compositor-spezifische Datenstrukturen, z.B. `Window`, `Surface`)
    * `pub mod backend;` (DRM/GL, X11, headless Backends)
    * `pub mod input_handler;` (Integration mit dem `input` Modul)
    * `pub mod xdg_shell;` (Implementierung des `xdg-shell` Protokolls)
    * `pub mod layer_shell;` (Implementierung des `wlr-layer-shell` Protokolls)
    * `pub mod seat;` (Smithay Seat Management)
    * `pub mod output;` (Smithay Output Management)
    * `pub mod cursor;` (Cursor-Verwaltung)
    * `pub mod focus;` (Fokus-Management)
    * `pub mod window_management;` (Allgemeine Fenster-Lifecycle-Verwaltung)
    * `pub mod renderer;` (Abstraktion über das Rendering)
    * `pub mod dnd;` (Drag-and-Drop Implementierung)
    * `pub mod clipboard_protocol;` (Wayland Clipboard Protokolle, nicht zu verwechseln mit `clipboard_integration`)
    * `pub mod screenshot_protocol;` (Wayland Screenshot Protokolle)
    * `pub mod xwayland;` (XWayland-Integration)
    * `pub mod service;` (Haupt-Compositor-Service)

2.  **Re-Exporte (`pub use`):**
    * `pub use error::CompositorError;`
    * `pub use data_types::*;`
    * `pub use service::CompositorService;`
    * `pub use backend::*;`
    * `pub use input_handler::*;`
    * `pub use xdg_shell::*;`
    * `pub use layer_shell::*;`
    * `pub use seat::*;`
    * `pub use output::*;`
    * `pub use cursor::*;`
    * `pub use focus::*;`
    * `pub use window_management::*;`
    * `pub use renderer::*;`
    * `pub use dnd::*;`
    * `pub use clipboard_protocol::*;`
    * `pub use screenshot_protocol::*;`
    * `pub use xwayland::*;`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** `smithay`.

**Kommunikationsmuster:**

* Der `CompositorService` ist der zentrale Punkt.
* Andere System-Services (z.B. `InputService`) interagieren mit dem Compositor.
* Die Domänenschicht (`DesktopStateService`, `WindowPolicyService`) kann Events vom Compositor empfangen oder Operationen auf ihm auslösen.

**Erwartete Ergebnisse/Outputs:**
Ein voll funktionsfähiger Wayland-Compositor, der als Basis für die NovaDE dient.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-system/src/compositor/error.rs**

**Verantwortlichkeit:**
Definiert das spezifische Fehler-Enum (`CompositorError`) für das Compositor-Modul.

**Kern-Aufgaben (Tasks):**

1.  **`CompositorError` Enum Definition:**
    * Verwende `thiserror`.
    * Varianten:
        * `BackendError(String)`: Fehler vom Smithay Backend (DRM, X11, etc.).
        * `ProtocolError(String)`: Fehler bei der Wayland-Protokollkommunikation (z.B. ungültige Client-Anfrage).
        * `InputHandlerError(#[from] crate::input::error::InputError)`: Fehler bei der Eingabeverarbeitung (wenn direkt vom Compositor ausgelöst).
        * `RenderError(String)`: Fehler beim Rendering.
        * `XWaylandError(String)`: Fehler bei der XWayland-Initialisierung oder -Kommunikation.
        * `IoError(#[from] std::io::Error)`: Allgemeine I/O-Fehler.
        * `WaylandSocketError(#[from] wayland_server::DisplayBuilderError)`: Fehler beim Erstellen des Wayland-Sockets.
        * `LogicError(String)`: Logische Fehler innerhalb des Compositors.
        * `Other(String)`: Allgemeine, unspezifizierte Fehler.
    * Implementiere `std::error::Error` und `Debug`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/error.rs`

**Abhängigkeiten:**

* **Intern:** `crate::input::error::InputError` (direkte Konvertierung).
* **Extern:** `thiserror::Error`, `std::io::Error`, `wayland_server::DisplayBuilderError`.

**Kommunikationsmuster:**

* Wird als `Result` Fehler von Funktionen und Methoden innerhalb des `compositor`-Moduls zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Fehler-Enum für Compositor-Operationen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung und Konvertierung von `CompositorError` Varianten.

**Geschätzter Aufwand:** Gering (ca. 0.3 Tage)

---

### **novade-system/src/compositor/data_types.rs**

**Verantwortlichkeit:**
Definiert die Kern-Datenstrukturen, die den Zustand und die Elemente des Wayland-Compositors repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`NovaCompositorState` Struktur:**
    * Die zentrale State-Struktur des Compositors, die an alle Smithay-Callbacks übergeben wird.
    * `pub struct NovaCompositorState {`
    * `pub display: Display<NovaCompositorState>,`
    * `pub event_loop: EventLoop<NovaCompositorState>,`
    * `pub backend: BackendState,` (Definiert im `backend` Modul)
    * `pub seat_state: SeatState<NovaCompositorState>,`
    * `pub xdg_shell_state: XdgShellState,`
    * `pub layer_shell_state: LayerShellState,`
    * `pub keyboard_handle: smithay::input::keyboard::KeyboardHandle<NovaCompositorState>,`
    * `pub pointer_handle: smithay::input::pointer::PointerHandle<NovaCompositorState>,`
    * `pub touch_handle: smithay::input::touch::TouchHandle<NovaCompositorState>,`
    * `pub primary_selection_state: PrimarySelectionState,`
    * `pub data_device_state: DataDeviceState,`
    * `pub dnd_state: DndState<NovaCompositorState>,`
    * `pub output_manager: OutputManager<NovaCompositorState>,`
    * `pub compositor_config: SystemSettings,` (Konfiguration vom `system::config` Modul)
    * `pub desktop_state_service: Arc<DesktopStateService>,` (Referenz zur Domänenschicht)
    * `pub window_policy_service: Arc<WindowPolicyService>,` (Referenz zur Domänenschicht)
    * `pub input_service: Arc<InputService>,` (Referenz zum InputService der Systemschicht)
    * `pub display_management_service: Arc<DisplayManagementService>,` (Referenz zum DisplayManagementService)
    * `pub focused_window: RwLock<Option<WindowId>>,` (ID des aktuell fokussierten Fensters)
    * `pub window_tree: RwLock<HashMap<WindowId, Window>>,` (Map von WindowId zu `Window` structs)
    * `pub grab_state: GrabState,` (Für Drag-and-Drop, Resize, Move)
    * `pub log_level: tracing::Level,`
    * `}`
    * Implementiere `Debug`.

2.  **`WindowId` Typ-Alias:**
    * `pub type WindowId = Uuid;`

3.  **`Window` Struktur:**
    * Repräsentiert ein Client-Fenster (xdg-shell oder layer-shell).
    * `pub struct Window {`
    * `pub id: WindowId,`
    * `pub surface: smithay::wayland::shell::xdg::xdg_shell::XdgToplevelSurface,` (oder `LayerSurface`)
    * `pub size: Size<i32, Logical>,`
    * `pub position: Point<i32, Logical>,`
    * `pub title: Option<String>,`
    * `pub app_id: Option<String>,`
    * `pub min_size: Size<i32, Logical>,`
    * `pub max_size: Size<i32, Logical>,`
    * `pub state: WindowState,` (Enum für minimiert, maximiert, etc.)
    * `pub is_maximized: bool,`
    * `pub is_minimized: bool,`
    * `pub is_fullscreen: bool,`
    * `pub is_tiled: bool,`
    * `pub resize_state: ResizeEdge,` (Optional, welche Kante gerade skaliert wird)
    * `pub current_workspace_id: WorkspaceId,` (ID des Workspaces, auf dem sich das Fenster befindet)
    * `}`
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`.
    * **Methoden:**
        * `pub fn new(...) -> Self`
        * `pub fn set_size(&mut self, size: Size<i32, Logical>)`
        * `pub fn set_position(&mut self, position: Point<i32, Logical>)`
        * `pub fn set_maximized(&mut self, maximized: bool)` (updated auch Wayland surface state)
        * `pub fn set_minimized(&mut self, minimized: bool)` (updated auch Wayland surface state)
        * `pub fn set_fullscreen(&mut self, fullscreen: bool)` (updated auch Wayland surface state)
        * `pub fn activate(&self, serial: Serial)` (sendet activate event an Client)
        * `pub fn send_close(&self)` (sendet close event an Client)
        * `pub fn underlying_surface(&self) -> &smithay::wayland::shell::xdg::xdg_shell::XdgToplevelSurface` (oder LayerSurface)

4.  **`WindowState` Enum:**
    * `pub enum WindowState {`
    * `Normal,`
    * `Maximized,`
    * `Minimized,`
    * `Fullscreen,`
    * `Tiled,`
    * `Resizing,`
    * `Moving,`
    * `}`
    * Implementiere `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash`.

5.  **`GrabState` Enum:**
    * Beschreibt den aktuellen Greif-Zustand (Bewegen, Skalieren, etc.).
    * `pub enum GrabState {`
    * `None,`
    * `Moving { start_loc: Point<f64, Physical> },`
    * `Resizing { start_loc: Point<f64, Physical>, edges: ResizeEdge, initial_window_rect: Rectangle<i32, Logical> },`
    * `}`
    * Implementiere `Clone`, `Debug`.

6.  **`BackendState` Struktur:**
    * Kapselt den Smithay Backend-Zustand (DRM, X11, headless).
    * `pub struct BackendState {`
    * `pub display_handle: smithay::reexports::calloop::LoopHandle<'static, NovaCompositorState>,`
    * `pub renderer: Box<dyn RenderSurface>,` (Trait für Rendering-Implementierungen)
    * `pub last_frame_rendered: Instant,`
    * `}`
    * Implementiere `Debug`.

7.  **`RenderSurface` Trait:**
    * `pub trait RenderSurface: Send + Sync + Debug {`
    * `fn render(&mut self, ...) -> Result<(), CompositorError>;`
    * `fn get_size(&self) -> Size<i32, Physical>;`
    * `// ... weitere Methoden für Buffer-Management, etc.`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/data_types.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::error::CompositorError`
    * `crate::config::data_types::SystemSettings`
    * `crate::input::service::InputService`
    * `crate::display_management::service::DisplayManagementService`
* **Extern:**
    * `smithay::wayland::shell::xdg::{XdgShellState, XdgToplevelSurface}`
    * `smithay::wayland::shell::wlr_layer_shell::LayerShellState`
    * `smithay::input::{SeatState, keyboard::KeyboardHandle, pointer::PointerHandle, touch::TouchHandle}`
    * `smithay::reexports::calloop::{EventLoop, LoopHandle}`
    * `smithay::output::OutputManager`
    * `smithay::backend::renderer::{Frame, Renderer, ImportDmaBuf, ImportMem, result::Result as RenderResult}` (für `RenderSurface` Implementierungen)
    * `smithay::wayland::primary_selection::PrimarySelectionState`
    * `smithay::wayland::data_device::{DataDeviceState, DndState}`
    * `smithay::utils::{Serial, Point, Size, Logical, Physical, Rectangle, Is ;s}`
    * `wayland_server::Display`
    * `uuid::Uuid` (für `WindowId`)
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `std::collections::HashMap`
    * `std::time::Instant`
    * `tracing`
    * `novade_core::types::geometry::{Rectangle, Point, Size}` (für die NovaDE-eigenen Geometrie-Typen)
    * `novade_domain::desktop_state::service::DesktopStateService`
    * `novade_domain::window_policy::service::WindowPolicyService`
    * `novade_domain::desktop_state::data_types::WorkspaceId`

**Kommunikationsmuster:**

* `NovaCompositorState` ist der zentrale Datencontainer, der von allen Smithay-Callbacks verwendet wird.
* Enthält Referenzen zu Services der Domänen- und Systemschicht, um deren Methoden aufzurufen und Events zu empfangen/senden.
* `Window` Objekte repräsentieren den Zustand einzelner Fenster.

**Erwartete Ergebnisse/Outputs:**
Ein klar definiertes und umfassendes Set von Datenstrukturen, das den Zustand und die Interaktionen des Wayland-Compositors modelliert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `new()`-Funktionen und Getter/Setter für `Window` und andere Strukturen.
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` Implementierungen.
    * Testen der Zustandstransitionen (z.B. `set_maximized`).
    * **Keine tiefgehenden Tests für `NovaCompositorState` selbst, da dies ein Aggregator ist.**

**Geschätzter Aufwand:** Hoch (ca. 3-5 Tage, aufgrund der Komplexität der Compositor-Datenstrukturen und ihrer Verknüpfungen)

---

### **novade-system/src/compositor/backend/mod.rs**

**Verantwortlichkeit:**
Dieses Modul abstrahiert die verschiedenen Smithay-Backends (DRM/KMS, X11, headless) und bietet eine einheitliche Schnittstelle für den Compositor-Core.

**Kern-Aufgaben (Tasks):**

1.  **Modul-Deklarationen:**
    * `pub mod drm;` (DRM/KMS Backend Implementierung)
    * `pub mod x11;` (X11 Backend Implementierung)
    * `pub mod headless;` (Headless Backend für Tests/virtuelle Umgebungen)
    * `pub mod traits;` (Definiert `BackendHandler` Trait)

2.  **Re-Exporte (`pub use`):**
    * `pub use traits::BackendHandler;`
    * `pub use drm::*;`
    * `pub use x11::*;`
    * `pub use headless::*;`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/backend/mod.rs`

**Abhängigkeiten:**

* **Intern:** Alle Submodule innerhalb des Verzeichnisses.
* **Extern:** `smithay::backend`.

**Kommunikationsmuster:**

* Der `CompositorService` wählt und initialisiert ein spezifisches Backend basierend auf der Umgebung oder Konfiguration.
* Das Backend interagiert über das `BackendHandler` Trait mit dem `NovaCompositorState`.

**Erwartete Ergebnisse/Outputs:**
Eine flexible Backend-Abstraktion, die verschiedene Grafik-Backends für den Compositor unterstützt.

**Teststrategie (Modul-spezifisch):**

* **Keine spezifischen Tests für `mod.rs` erforderlich.**

**Geschätzter Aufwand:** Gering (ca. 0.1 Tage)

---

### **novade-system/src/compositor/backend/traits.rs**

**Verantwortlichkeit:**
Definiert das `BackendHandler` Trait, das die Schnittstelle für alle Smithay-Backends bereitstellt, um Ereignisse an den `NovaCompositorState` zu übermitteln.

**Kern-Aufgaben (Tasks):**

1.  **`BackendHandler` Trait Definition:**
    * `pub trait BackendHandler {`
    * `fn on_new_active_input(&mut self, state: &mut NovaCompositorState) -> Result<(), CompositorError>;` (Wird aufgerufen, wenn ein neues Input-Gerät aktiv wird)
    * `fn on_new_output(&mut self, output: Output, state: &mut NovaCompositorState) -> Result<(), CompositorError>;` (Wird aufgerufen, wenn ein neuer Monitor erkannt wird)
    * `fn on_output_removed(&mut self, output: Output, state: &mut NovaCompositorState) -> Result<(), CompositorError>;`
    * `fn on_frame(&mut self, state: &mut NovaCompositorState, time: Instant) -> Result<(), CompositorError>;` (Wird für jeden Render-Frame aufgerufen)
    * `fn on_pointer_move(&mut self, state: &mut NovaCompositorState, event: &MotionEvent) -> Result<(), CompositorError>;`
    * `fn on_pointer_button(&mut self, state: &mut NovaCompositorState, event: &ButtonEvent) -> Result<(), CompositorError>;`
    * `fn on_keyboard_key(&mut self, state: &mut NovaCompositorState, event: &KeyEvent) -> Result<(), CompositorError>;`
    * `fn on_touch_event(&mut self, state: &mut NovaCompositorState, event: &TouchEvent) -> Result<(), CompositorError>;`
    * `// ... weitere Handler für Hotplug, DRM-Events, etc.`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/backend/traits.rs`

**Abhängigkeiten:**

* **Intern:** `crate::compositor::data_types::NovaCompositorState`, `crate::compositor::error::CompositorError`.
* **Extern:** `smithay::input::{pointer::{MotionEvent, ButtonEvent}, keyboard::KeyEvent, touch::TouchEvent}`, `smithay::output::Output`, `std::time::Instant`.

**Kommunikationsmuster:**

* Implementierungen dieses Traits (z.B. `DrmBackend`, `X11Backend`) rufen diese Methoden auf dem `NovaCompositorState` auf, wenn entsprechende Systemereignisse auftreten.

**Erwartete Ergebnisse/Outputs:**
Ein klares Trait, das die Interaktion zwischen den Smithay-Backends und dem Kern des Compositors definiert.

**Teststrategie (Modul-spezifisch):**

* **Keine direkten Tests für Traits erforderlich, Tests erfolgen in den Implementierungen.**

**Geschätzter Aufwand:** Gering (ca. 0.5 Tage)

---

### **novade-system/src/compositor/backend/drm.rs**

**Verantwortlichkeit:**
Implementiert das DRM/KMS-Backend für den Wayland-Compositor, das die direkte Interaktion mit der Grafikhardware ermöglicht.

**Kern-Aufgaben (Tasks):**

1.  **`DrmBackend` Struktur:**
    * `pub struct DrmBackend {`
    * `pub backend: smithay::backend::drm::DrmBackend,`
    * `pub renderer: Gles2Renderer,`
    * `pub input_backend: smithay::backend::libinput::LibinputInputBackend,` (Libinput-Integration für DRM)
    * `// ... weitere Felder für Output-Konfiguration, etc.`
    * `}`

2.  **`DrmBackend::new()` Funktion:**
    * `pub fn new(display: &mut Display<NovaCompositorState>, event_loop: &mut EventLoop<NovaCompositorState>, config: &CompositorConfig) -> Result<Self, CompositorError>`
    * Initialisiert `smithay::backend::drm::DrmBackend`.
    * Initialisiert `Gles2Renderer`.
    * Initialisiert `smithay::backend::libinput::LibinputInputBackend` und registriert es im Event-Loop.
    * Fügt alle erkannten Outputs zum Compositor hinzu.
    * **Fehlerbehandlung:** Fehler bei der DRM-Initialisierung oder Renderer-Erstellung.

3.  **Implementierung des `BackendHandler` Trait für `DrmBackend`:**
    * Implementiert alle Methoden des `BackendHandler` Trait.
    * **`on_new_active_input`**: Ruft `input_service.add_input_device()` der Domänenschicht auf.
    * **`on_new_output`**: Fügt den neuen `Output` zu `NovaCompositorState.output_manager` hinzu. Ruft `display_management_service.add_display()` auf.
    * **`on_output_removed`**: Entfernt den `Output`. Ruft `display_management_service.remove_display()` auf.
    * **`on_frame`**: Hier wird das Rendering auf den DRM-Output durchgeführt.
        * Ruft `renderer.render()` auf, um alle Client-Surfaces zu zeichnen.
        * Präsentiert den Frame an den DRM-Output.
        * Aktualisiert `last_frame_rendered`.
    * **`on_pointer_move` / `on_pointer_button` / `on_keyboard_key` / `on_touch_event`**: Übersetzt die Smithay-Events in domänenspezifische Events (z.B. über `input_service.process_input_event()`) oder direkt die Compositor-Logik (`seat_state`, `focus`).

4.  **`Gles2Renderer` Implementierung für `RenderSurface` Trait:**
    * `pub fn render(&mut self, state: &mut NovaCompositorState) -> Result<(), CompositorError>`
    * Die eigentliche Rendering-Logik mit OpenGL ES 2.0.
    * Iteriert über alle Outputs und deren Layer (Background, Bottom, Toplevels, Overlay).
    * Rendert jede Surface an ihrer Position.
    * Behandelt Cursor-Rendering.
    * Verwendet `smithay::backend::renderer::Frame` und `smithay::backend::renderer::Renderer`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/backend/drm.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::error::CompositorError`
    * `crate::compositor::data_types::NovaCompositorState`
    * `crate::compositor::backend::traits::BackendHandler`
    * `crate::compositor::renderer::RenderSurface`
    * `crate::config::data_types::CompositorConfig`
    * `crate::input::service::InputService`
    * `crate::display_management::service::DisplayManagementService`
* **Extern:**
    * `smithay::backend::drm::{DrmBackend, DrmEvent, DrmHandler, DrmError}`
    * `smithay::backend::renderer::gles2::Gles2Renderer`
    * `smithay::backend::libinput::{LibinputInputBackend, LibinputInputBackendConfig, LibinputEvent}`
    * `smithay::input::{SeatState, keyboard::KeyEvent, pointer::MotionEvent, pointer::ButtonEvent, touch::TouchEvent}`
    * `smithay::output::Output`
    * `smithay::reexports::calloop::EventLoop`
    * `wayland_server::Display`
    * `std::time::Instant`
    * `tracing`

**Kommunikationsmuster:**

* Interagiert direkt mit dem `NovaCompositorState` und delegiert Input-Events an den `InputService`.
* Ruft `display_management_service` für Monitor-Verwaltung auf.

**Erwartete Ergebnisse/Outputs:**
Ein stabiles und performantes DRM-basiertes Grafik-Backend für den Wayland-Compositor.

**Teststrategie (Modul-spezifisch):**

* **Integration Tests (auf echter Hardware oder in VMs mit DRM-Emulation):**
    * Starten des Compositors mit dem DRM-Backend.
    * Öffnen von Wayland-Clients und Überprüfen des Renderings.
    * Testen von Eingabegeräten (Tastatur, Maus, Touchpad).
    * Monitor-Hotplugging (wenn möglich).
    * Testen der Performance (FPS).
* **Unit Tests (für kleinere Helferfunktionen im DRM-Backend):**
    * Isolierte Tests für die Konfiguration des Renderers oder die Event-Filterung.

**Geschätzter Aufwand:** Extrem hoch (ca. 20-30 Tage, da komplexe Interaktion mit Hardware, GPU-Rendering und Smithay-Interna)

---

### **novade-system/src/compositor/backend/x11.rs**

**Verantwortlichkeit:**
Implementiert das X11-Backend für den Wayland-Compositor. Dies ist primär für Entwicklungs- und Testzwecke gedacht, da NovaDE ein Wayland-nativer Compositor ist.

**Kern-Aufgaben (Tasks):**

1.  **`X11Backend` Struktur:**
    * `pub struct X11Backend {`
    * `pub backend: smithay::backend::x11::X11Backend,`
    * `pub renderer: Gles2Renderer,`
    * `pub input_backend: smithay::backend::x11::X11InputBackend,` (X11-spezifische Eingabeverarbeitung)
    * `// ...`
    * `}`

2.  **`X11Backend::new()` Funktion:**
    * `pub fn new(display: &mut Display<NovaCompositorState>, event_loop: &mut EventLoop<NovaCompositorState>, config: &CompositorConfig) -> Result<Self, CompositorError>`
    * Initialisiert `smithay::backend::x11::X11Backend`.
    * Initialisiert `Gles2Renderer`.
    * Initialisiert `smithay::backend::x11::X11InputBackend` und registriert es im Event-Loop.
    * Fügt den X11-Output zum Compositor hinzu.
    * **Fehlerbehandlung:** Fehler bei der X11-Initialisierung.

3.  **Implementierung des `BackendHandler` Trait für `X11Backend`:**
    * Implementiert alle Methoden des `BackendHandler` Trait, analog zum `DrmBackend`.
    * **`on_frame`**: Rendering an den X11-Fenster-Puffer.
    * Event-Übersetzung von X11-Eingabeereignissen.

4.  **`Gles2Renderer` Implementierung für `RenderSurface` Trait:**
    * (Wird von Smithay bereitgestellt, keine spezielle Implementierung hier.)

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/backend/x11.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::error::CompositorError`
    * `crate::compositor::data_types::NovaCompositorState`
    * `crate::compositor::backend::traits::BackendHandler`
    * `crate::compositor::renderer::RenderSurface`
    * `crate::config::data_types::CompositorConfig`
    * `crate::input::service::InputService`
* **Extern:**
    * `smithay::backend::x11::{X11Backend, X11Event, X11InputBackend, X11Error}`
    * `smithay::backend::renderer::gles2::Gles2Renderer`
    * `smithay::input::{SeatState, keyboard::KeyEvent, pointer::MotionEvent, pointer::ButtonEvent}`
    * `smithay::output::Output`
    * `smithay::reexports::calloop::EventLoop`
    * `wayland_server::Display`
    * `std::time::Instant`
    * `tracing`

**Kommunikationsmuster:**

* Analog zu DRM, aber über X11-APIs.

**Erwartete Ergebnisse/Outputs:**
Ein funktionierendes X11-basiertes Backend für Entwicklungs- und Testzwecke.

**Teststrategie (Modul-spezifisch):**

* **Integration Tests:**
    * Starten des Compositors mit dem X11-Backend in einer X11-Session.
    * Öffnen von Wayland-Clients und Überprüfen des Renderings.
    * Testen von Eingabegeräten.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage, da X11-spezifische Handhabung von Events und Rendering)

---

### **novade-system/src/compositor/backend/headless.rs**

**Verantwortlichkeit:**
Implementiert ein "headless" Backend für den Wayland-Compositor. Dies ist ausschließlich für automatisierte Tests und Benchmarking gedacht, da es keine visuelle Ausgabe hat.

**Kern-Aufgaben (Tasks):**

1.  **`HeadlessBackend` Struktur:**
    * `pub struct HeadlessBackend {`
    * `pub backend: smithay::backend::headless::HeadlessBackend,`
    * `pub renderer: Gles2Renderer,` (Kann auch ein Mock-Renderer sein)
    * `// ...`
    * `}`

2.  **`HeadlessBackend::new()` Funktion:**
    * `pub fn new(display: &mut Display<NovaCompositorState>, event_loop: &mut EventLoop<NovaCompositorState>, config: &CompositorConfig) -> Result<Self, CompositorError>`
    * Initialisiert `smithay::backend::headless::HeadlessBackend`.
    * Initialisiert einen Renderer (z.B. `Gles2Renderer` oder einen Dummy-Renderer).
    * Fügt einen Headless-Output hinzu.

3.  **Implementierung des `BackendHandler` Trait für `HeadlessBackend`:**
    * Implementiert alle Methoden des `BackendHandler` Trait.
    * **`on_frame`**: Führt das Rendering durch, aber die Ergebnisse werden nicht an eine Anzeige geschickt. Kann zum Prüfen von Render-Operationen in Tests verwendet werden.
    * Eingabe-Events können simuliert werden.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/backend/headless.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::error::CompositorError`
    * `crate::compositor::data_types::NovaCompositorState`
    * `crate::compositor::backend::traits::BackendHandler`
    * `crate::compositor::renderer::RenderSurface`
    * `crate::config::data_types::CompositorConfig`
* **Extern:**
    * `smithay::backend::headless::{HeadlessBackend, HeadlessEvent, HeadlessError}`
    * `smithay::backend::renderer::gles2::Gles2Renderer`
    * `smithay::output::Output`
    * `smithay::reexports::calloop::EventLoop`
    * `wayland_server::Display`
    * `std::time::Instant`
    * `tracing`

**Kommunikationsmuster:**

* Dient als ein internes Test- und Entwicklungs-Backend.

**Erwartete Ergebnisse/Outputs:**
Ein stabiles und effizientes Headless-Backend für Testzwecke.

**Teststrategie (Modul-spezifisch):**

* **Unit/Integration Tests:**
    * Ideal für schnelle, isolierte Tests von Compositor-Logik, die keine tatsächliche Anzeige erfordert.
    * Simulieren von Client-Verbindungen, Surface-Updates und Rendering-Aufrufen, um die interne Logik zu überprüfen.

**Geschätzter Aufwand:** Gering (ca. 1-2 Tage)

---
### **novade-system/src/compositor/input_handler.rs**

**Verantwortlichkeit:**
Dieses Modul ist für die Verarbeitung und Weiterleitung von Eingabe-Ereignissen (Tastatur, Maus, Touch) innerhalb des Compositors zuständig. Es ist die Brücke zwischen den Smithay-Eingabe-Backends und dem `InputService` der Systemschicht sowie der direkten Compositor-Logik (Fokus, Grab-States).

**Kern-Aufgaben (Tasks):**

1.  **`InputHandler` Struktur:**
    * Dieses Modul enthält typischerweise keine eigene Struktur, da die Logik direkt in den Smithay-Callbacks (die in `NovaCompositorState` implementiert werden) oder als Helferfunktionen agiert.
    * Es kann jedoch eine Trait-Implementierung auf `NovaCompositorState` selbst oder freistehende Funktionen sein.

2.  **`handle_keyboard_key()` Funktion:**
    * `pub fn handle_keyboard_key(state: &mut NovaCompositorState, event: KeyEvent) -> Result<(), CompositorError>`
    * **Logik:**
        * Verarbeitet Tastaturereignisse (`KeyEvent`).
        * Nutzt `seat_state.keyboard_mut().input()`.
        * Prüft auf Tastenkombinationen für globale Shortcuts (z.B. `Super+Tab` für Workspace-Wechsel, `Super+Q` für Fenster schließen, `Super+Space` für Command Palette).
        * Wenn ein Shortcut erkannt wird:
            * Ruft die entsprechende Methode auf `DesktopStateService` (z.B. `switch_workspace()`) oder `WindowPolicyService` (z.B. `close_window()`) oder `InputService` (für globale Shortcuts) auf.
            * Sendet ggf. Events über den `event_bus` der Domänenschicht.
            * Setzt `event.prevent_default()` wenn der Shortcut verarbeitet wurde.
        * Leitet nicht verarbeitete Events an das aktuell fokussierte Client-Fenster weiter.
        * **Fehlerbehandlung:** Wenn ein Service-Aufruf fehlschlägt.

3.  **`handle_pointer_motion()` Funktion:**
    * `pub fn handle_pointer_motion(state: &mut NovaCompositorState, event: MotionEvent) -> Result<(), CompositorError>`
    * **Logik:**
        * Aktualisiert die Pointer-Position im `seat_state`.
        * Prüft, ob ein Fenster verschoben oder skaliert wird (prüft `state.grab_state`).
            * Wenn ja, aktualisiert die Position/Größe des Fensters entsprechend `event.delta_physical()`.
            * Ruft `window.set_size()` / `window.set_position()` auf.
            * Sendet die neuen Zustände an den Client.
        * Wenn nicht, findet das nächste Surface unter dem Cursor.
            * Wenn eine neue Surface gefunden wird, sendet `leave` an die alte und `enter` an die neue Surface.
            * Aktualisiert den Pointer-Fokus im `seat_state`.
        * Leitet die Bewegung an das fokussierte Surface weiter.

4.  **`handle_pointer_button()` Funktion:**
    * `pub fn handle_pointer_button(state: &mut NovaCompositorState, event: ButtonEvent) -> Result<(), CompositorError>`
    * **Logik:**
        * Aktualisiert den Button-Zustand im `seat_state`.
        * Prüft, ob es sich um einen Klick auf eine Fensteroberfläche handelt:
            * Wenn ja, aktiviert das Fenster (`window.activate()`) und setzt den Fokus.
            * Wenn die Taste gedrückt wird (Press):
                * Prüft auf Fenstertitelbar für Move-Grab.
                * Prüft auf Fenster-Ränder für Resize-Grab.
                * Setzt `state.grab_state` entsprechend.
            * Wenn die Taste losgelassen wird (Release):
                * Setzt `state.grab_state` auf `None`.
        * Leitet das Button-Event an das fokussierte Surface weiter.

5.  **`handle_touch_event()` Funktion:**
    * `pub fn handle_touch_event(state: &mut NovaCompositorState, event: TouchEvent) -> Result<(), CompositorError>`
    * **Logik:**
        * Verarbeitet Touch-Ereignisse (`TouchEvent`).
        * Aktualisiert den Touch-Zustand im `seat_state`.
        * Leitet die Ereignisse an die entsprechenden Surfaces oder an den `InputService` zur Gestenerkennung weiter.

6.  **`focus_window()` Funktion:**
    * `pub fn focus_window(state: &mut NovaCompositorState, window_id: WindowId, serial: Serial) -> Result<(), CompositorError>`
    * **Logik:**
        * Deaktiviert das aktuell fokussierte Fenster (wenn vorhanden).
        * Aktiviert das neue Fenster (`window.activate(serial)`).
        * Setzt den Tastaturfokus auf das neue Fenster im `seat_state`.
        * Aktualisiert `state.focused_window`.
        * Benachrichtigt `desktop_state_service` über den Fokuswechsel.

7.  **`process_input_event()` Funktion (Global Shortcuts):**
    * Diese Funktion könnte direkt vom `InputService` aufgerufen werden, um globale Tastenkombinationen zu verarbeiten, bevor sie an den Compositor weitergeleitet werden.
    * Oder, der Compositor verarbeitet kritische Compositor-Shortcuts selbst und delegiert andere an den InputService.
    * **Entscheidung:** Compositor verarbeitet Window-Management-Shortcuts (Close, Maximize, Minimize, Move, Resize), und InputService verarbeitet systemweite Shortcuts (Screenshot, Command Palette, Workspace-Wechsel). Der `InputService` kann dann dem Compositor signalisieren, dass ein Fensterwechsel oder ähnliches stattfinden soll.

**Spezifische Artefekte/Dateien:**

* `novade-system/src/compositor/input_handler.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::data_types::{NovaCompositorState, WindowId, Window, GrabState}`
    * `crate::compositor::error::CompositorError`
    * `crate::input::service::InputService`
    * `novade_domain::desktop_state::service::DesktopStateService`
    * `novade_domain::window_policy::service::WindowPolicyService`
    * `novade_core::types::geometry::{Point, Size, Rectangle}`
* **Extern:**
    * `smithay::input::{keyboard::KeyEvent, pointer::{MotionEvent, ButtonEvent}, touch::TouchEvent}`
    * `smithay::utils::Serial`
    * `tokio::sync::RwLock`
    * `tracing`
    * `winit::keyboard::KeyCode` (oder `xkbcommon::keysyms`) für Key-Mappings.

**Kommunikationsmuster:**

* Empfängt rohe Input-Events von den Smithay-Backends.
* Interagiert direkt mit dem `NovaCompositorState` zur Verwaltung von Fokus, Grab-States und Fensterpositionen.
* Ruft Methoden auf `DesktopStateService`, `WindowPolicyService`, `InputService` auf, um höhere Logik auszulösen.

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschnelles und präzises Eingabe-Verarbeitungssystem für den Wayland-Compositor.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NovaCompositorState` und den Services (`DesktopStateService`, `WindowPolicyService`, `InputService`).
    * Testen der `handle_keyboard_key()` für verschiedene Shortcuts und deren korrekte Ausführung/Weiterleitung.
    * Testen von `handle_pointer_motion()` für Fensterverschiebung und -skalierung.
    * Testen von `handle_pointer_button()` für Fokuswechsel und Grab-State-Initialisierung.
    * Testen von `focus_window()` für die korrekte Deaktivierung/Aktivierung und Fokus-Aktualisierung.
* **Integration Tests (mit Headless-Backend):**
    * Simulieren von Input-Events (z.B. Tastendrücke, Mausbewegungen) und Überprüfen des Zustands des Compositors (Fensterposition, Fokus).

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, komplexe Logik für Shortcuts, Fenster-Grabs und Fokusverwaltung)

---

### **novade-system/src/compositor/xdg_shell.rs**

**Verantwortlichkeit:**
Implementiert das `xdg-shell` Wayland-Protokoll, das für die Verwaltung von Desktop-Fenstern (Top-Level-Surfaces) zuständig ist. Dies beinhaltet das Erstellen, Zerstören, Maximieren, Minimieren und Verschieben von Anwendungsfenstern.

**Kern-Aufgaben (Tasks):**

1.  **`xdg_shell_state` Initialisierung:**
    * Im `CompositorService::new()` oder `NovaCompositorState::new()`:
        * `let (xdg_shell_state, _) = XdgShellState::new::<NovaCompositorState>(display_handle.clone());`
        * Registriere den XdgShell-Handler im `EventLoop`.

2.  **`XdgShellHandler` Trait Implementierung für `NovaCompositorState`:**
    * `impl XdgShellHandler for NovaCompositorState {`
    * **`xdg_shell_surface_created`:**
        * `fn xdg_shell_surface_created(&mut self, surface: XdgToplevelSurface) {`
        * Erstellt ein neues `Window`-Objekt (`Window::new(...)`).
        * Fügt das neue `Window` zu `state.window_tree` hinzu.
        * Wenn es das erste Fenster ist oder der Fokus explizit gesetzt werden soll, ruft `input_handler::focus_window()` auf.
        * Benachrichtigt `desktop_state_service` über das neue Fenster.
        * Setzt Listener für `commit` und `destroy` Events der Surface.
    * **`xdg_shell_surface_destroyed`:**
        * `fn xdg_shell_surface_destroyed(&mut self, surface: XdgToplevelSurface) {`
        * Entfernt das `Window` aus `state.window_tree`.
        * Benachrichtigt `desktop_state_service` über das geschlossene Fenster.
        * Überprüft, ob der Fokus neu gesetzt werden muss.
    * **`xdg_shell_surface_configure`:**
        * `fn xdg_shell_surface_configure(&mut self, surface: XdgToplevelSurface, config: XdgToplevelSurfaceConfigure) {`
        * Sendet die Konfiguration an den Client.
        * Setzt den Zustand des Fensters (maximiert, minimiert, etc.) entsprechend der Konfiguration.
        * Aktualisiert die Größe und Position des Fensters, wenn erforderlich.
    * **`xdg_shell_surface_map`:**
        * `fn xdg_shell_surface_map(&mut self, surface: XdgToplevelSurface) {`
        * Das Fenster wird sichtbar; Rendering kann beginnen.
        * Benachrichtigt `desktop_state_service` über das gemappte Fenster.
    * **`xdg_shell_surface_unmap`:**
        * `fn xdg_shell_surface_unmap(&mut self, surface: XdgToplevelSurface) {`
        * Das Fenster wird unsichtbar.
        * Benachrichtigt `desktop_state_service` über das ungemappte Fenster.
    * **`xdg_shell_surface_set_title` / `xdg_shell_surface_set_app_id`:**
        * Aktualisiert den Titel/App-ID im `Window`-Objekt.
        * Benachrichtigt `desktop_state_service` über die Änderung.
    * **`xdg_shell_surface_set_min_size` / `xdg_shell_surface_set_max_size`:**
        * Aktualisiert die Größenbeschränkungen im `Window`-Objekt.
    * **`xdg_shell_surface_move_request`:**
        * `fn xdg_shell_surface_move_request(&mut self, surface: XdgToplevelSurface, seat: smithay::input::Seat, serial: Serial) {`
        * Startet den "Move"-Vorgang für das Fenster.
        * Setzt `state.grab_state` auf `Moving`.
        * Benötigt ggf. Aufruf von `focus_window`.
    * **`xdg_shell_surface_resize_request`:**
        * `fn xdg_shell_surface_resize_request(&mut self, surface: XdgToplevelSurface, seat: smithay::input::Seat, serial: Serial, edges: smithay::utils::ResizeEdge) {`
        * Startet den "Resize"-Vorgang für das Fenster.
        * Setzt `state.grab_state` auf `Resizing`.
        * Benötigt ggf. Aufruf von `focus_window`.
    * **`xdg_shell_surface_maximize_request` / `xdg_shell_surface_unmaximize_request`:**
        * Ruft `window_policy_service.maximize_window()` / `unmaximize_window()` auf.
    * **`xdg_shell_surface_fullscreen_request` / `xdg_shell_surface_unfullscreen_request`:**
        * Ruft `window_policy_service.fullscreen_window()` / `unfullscreen_window()` auf.
    * **`xdg_shell_surface_minimize_request`:**
        * Ruft `window_policy_service.minimize_window()` auf.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/xdg_shell.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::data_types::{NovaCompositorState, Window, WindowId, GrabState}`
    * `crate::compositor::error::CompositorError`
    * `crate::compositor::input_handler` (für `focus_window`)
    * `novade_domain::desktop_state::service::DesktopStateService`
    * `novade_domain::window_policy::service::WindowPolicyService`
* **Extern:**
    * `smithay::wayland::shell::xdg::{XdgShellHandler, XdgToplevelSurface, XdgToplevelSurfaceConfigure, XdgShellState}`
    * `smithay::input::Seat`
    * `smithay::utils::{Serial, ResizeEdge}`
    * `wayland_server::{DisplayHandle, protocol::wl_surface::WlSurface}`
    * `tracing`
    * `std::collections::HashMap`

**Kommunikationsmuster:**

* Implementiert Wayland-Protokoll-Handler und reagiert auf Client-Anfragen.
* Verwaltet den Zustand der `Window`-Objekte in `NovaCompositorState`.
* Delegiert komplexe Fenster-Management-Logik an den `WindowPolicyService` der Domänenschicht.
* Informiert den `DesktopStateService` über Fenster-Lebenszyklusereignisse.

**Erwartete Ergebnisse/Outputs:**
Eine vollständige und konforme Implementierung des `xdg-shell` Protokolls, die es Anwendungen ermöglicht, ihre Fenster korrekt darzustellen und zu verwalten.

**Teststrategie (Modul-spezifisch):**

* **Integration Tests (mit einem Wayland-Client-Test-Toolkit):**
    * Starten des Compositors mit diesem Modul.
    * Starten eines Test-Clients, der `xdg-shell` verwendet.
    * Testen der Fenster-Erstellung, -Zerstörung, -Maximierung, -Minimierung, -Verschiebung, -Skalierung.
    * Überprüfen, ob der Compositor korrekt auf Client-Anfragen reagiert und die Fensterzustände richtig verwaltet.
    * Testen von Titeln und App-IDs.
    * Testen von Fokus-Wechseln und Aktivierung.
* **Unit Tests:**
    * Für Helferfunktionen, die Konfigurationen verarbeiten oder Fenster-IDs generieren.

**Geschätzter Aufwand:** Sehr hoch (ca. 10-15 Tage, da detaillierte Implementierung des Wayland-Protokolls und dessen Integration mit der NovaDE-Logik)

---
### **novade-system/src/compositor/layer_shell.rs**

**Verantwortlichkeit:**
Implementiert das `wlr-layer-shell` Wayland-Protokoll, das für die Verwaltung von speziellen Desktop-Elementen wie Panels, Desktophintergründen, Sperrbildschirmen und Popups zuständig ist. Diese "Layer-Surfaces" werden in spezifischen Schichten (Layer) gerendert.

**Kern-Aufgaben (Tasks):**

1.  **`layer_shell_state` Initialisierung:**
    * Im `CompositorService::new()` oder `NovaCompositorState::new()`:
        * `let (layer_shell_state, _) = LayerShellState::new::<NovaCompositorState>(display_handle.clone());`
        * Registriere den LayerShell-Handler im `EventLoop`.

2.  **`LayerShellHandler` Trait Implementierung für `NovaCompositorState`:**
    * `impl LayerShellHandler for NovaCompositorState {`
    * **`layer_surface_created`:**
        * `fn layer_surface_created(&mut self, surface: LayerSurface, ...) {`
        * Erstellt ein internes Repräsentations-Objekt für die Layer-Surface (ggf. analog zu `Window`).
        * Fügt die neue Layer-Surface zu einer internen Liste oder Map hinzu (z.B. `state.layer_surfaces: HashMap<WlSurface, LayerSurfaceData>`).
        * Setzt Listener für `commit` und `destroy` Events der Surface.
        * Benachrichtigt `desktop_state_service` über die neue Layer-Surface (z.B. für Panel-Erkennung).
    * **`layer_surface_destroyed`:**
        * `fn layer_surface_destroyed(&mut self, surface: LayerSurface) {`
        * Entfernt die Layer-Surface aus der internen Verwaltung.
        * Benachrichtigt `desktop_state_service` über das Entfernen.
    * **`layer_surface_map` / `layer_surface_unmap`:**
        * `fn layer_surface_map(&mut self, surface: LayerSurface) {`
        * Markiert die Surface als sichtbar/unsichtbar.
        * Aktualisiert den Render-Baum.
    * **`layer_surface_configure`:**
        * `fn layer_surface_configure(&mut self, surface: LayerSurface, config: LayerSurfaceConfigure, serial: Serial) {`
        * Sendet die Konfiguration an den Client.
        * Aktualisiert die Größe und Position der Layer-Surface basierend auf der Konfiguration (Größe, Anker, Margins).
        * Validiert die Anker-Konfiguration.
        * Informiert den Client über die neuen Konfigurationsparameter.
        * Akzeptiert die Konfiguration mit `surface.send_configure(config)`.

3.  **Rendering-Reihenfolge (`renderer` Integration):**
    * Das `renderer` Modul muss die `LayerSurface`s in der korrekten Z-Ordnung rendern:
        * `Background` -> `Bottom` -> `XdgToplevel` (normale Fenster) -> `Top` -> `Overlay` -> `OverlayPopups`.
    * Logik zur Sortierung und Positionierung der Layer-Surfaces basierend auf ihren `Layer`, `Anchor` und `Size` Properties.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/layer_shell.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::data_types::{NovaCompositorState}`
    * `crate::compositor::error::CompositorError`
    * `novade_domain::desktop_state::service::DesktopStateService`
    * `novade_core::types::geometry::{Point, Size, Rectangle}`
* **Extern:**
    * `smithay::wayland::shell::wlr_layer_shell::{LayerShellHandler, LayerSurface, LayerSurfaceConfigure, LayerShellState, Layer, Anchor}`
    * `smithay::utils::{Serial}`
    * `wayland_server::protocol::wl_surface::WlSurface`
    * `tracing`
    * `std::collections::HashMap`

**Kommunikationsmuster:**

* Implementiert Wayland-Protokoll-Handler und reagiert auf Client-Anfragen für Layer-Surfaces.
* Verwaltet den Zustand der Layer-Surfaces.
* Informiert den `DesktopStateService` über die Existenz und Eigenschaften von Layer-Surfaces (z.B. Panel-Größen für die Arbeitsbereichs-Geometrie).

**Erwartete Ergebnisse/Outputs:**
Eine vollständige und konforme Implementierung des `wlr-layer-shell` Protokolls, die die Darstellung von Desktop-Elementen in definierten Layern ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Integration Tests (mit einem Wayland-client, der `wlr-layer-shell` verwendet, z.B. `waybar` oder ein Test-Client):**
    * Starten des Compositors.
    * Starten eines Layer-Shell-Clients mit verschiedenen Layern (Background, Panel, Dock).
    * Überprüfen der korrekten Positionierung und Z-Ordnung.
    * Testen von Größenänderungen und Ankern (top, bottom, left, right, center).
    * Testen der Interaktion mit normalen XDG-Toplevel-Fenstern (z.B. ob ein Panel den verfügbaren Arbeitsbereich korrekt einschränkt).
* **Unit Tests:**
    * Für Funktionen, die Ankerberechnungen durchführen.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da komplexe Geometrieberechnungen und Interaktion mit dem Rendering-Pfad)

---

### **novade-system/src/compositor/seat.rs**

**Verantwortlichkeit:**
Verwaltet den Wayland "Seat", der alle Eingabegeräte (Tastatur, Pointer, Touch) für einen Benutzer abstrahiert. Dieses Modul ist die zentrale Anlaufstelle für Input-Ereignisse auf Wayland-Protokollebene.

**Kern-Aufgaben (Tasks):**

1.  **`SeatState` Initialisierung:**
    * Im `CompositorService::new()` oder `NovaCompositorState::new()`:
        * `let mut seat_state = SeatState::new(&mut state.display_handle, "seat0");`
        * Erstelle `KeyboardHandle`, `PointerHandle`, `TouchHandle`.
        * `seat_state.attach_keyboard(...)`, `seat_state.attach_pointer(...)`, `seat_state.attach_touch(...)`.
        * `state.keyboard_handle = keyboard_handle;`
        * `state.pointer_handle = pointer_handle;`
        * `state.touch_handle = touch_handle;`

2.  **`SeatHandler` Trait Implementierung für `NovaCompositorState`:**
    * `impl SeatHandler for NovaCompositorState {`
    * **`pointer_moved`:**
        * `fn pointer_moved(&mut self, seat: &smithay::input::Seat, event: &MotionEvent) {`
        * Leitet das Ereignis an `input_handler::handle_pointer_motion()` weiter.
    * **`pointer_button`:**
        * `fn pointer_button(&mut self, seat: &smithay::input::Seat, event: &ButtonEvent) {`
        * Leitet das Ereignis an `input_handler::handle_pointer_button()` weiter.
    * **`pointer_axis`:**
        * `fn pointer_axis(&mut self, seat: &smithay::input::Seat, event: &AxisEvent) {`
        * Verarbeitet Scroll-Ereignisse (Achsenbewegung).
        * Leitet an das fokussierte Surface weiter.
    * **`keyboard_key`:**
        * `fn keyboard_key(&mut self, seat: &smithay::input::Seat, event: &KeyEvent) {`
        * Leitet das Ereignis an `input_handler::handle_keyboard_key()` weiter.
    * **`touch_down` / `touch_up` / `touch_motion` / `touch_cancel`:**
        * `fn touch_down(&mut self, seat: &smithay::input::Seat, event: &TouchEvent) {`
        * Leitet das Ereignis an `input_handler::handle_touch_event()` weiter.
    * **`new_input`:**
        * `fn new_input(&mut self, _seat: &smithay::input::Seat, _device: &smithay::input::Device) {`
        * Informiert den `InputService` über ein neues Eingabegerät.
        * `self.input_service.add_input_device(...)`
    * **`seat_removed`:**
        * `fn seat_removed(&mut self, _seat: &smithay::input::Seat) {`
        * Informiert den `InputService` über das Entfernen eines Geräts.

3.  **Pointer-Fokus-Management:**
    * Funktionen zum Setzen und Zurücksetzen des Pointer-Fokus auf eine Surface.
    * Wird von `input_handler` verwendet.

4.  **Tastatur-Fokus-Management:**
    * Funktionen zum Setzen und Zurücksetzen des Tastatur-Fokus auf eine Surface.
    * Wird von `input_handler` und `xdg_shell` verwendet.
    * Berücksichtigt `xkbcommon` für Tastatur-Layouts und -Mapping.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/seat.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::data_types::{NovaCompositorState}`
    * `crate::compositor::error::CompositorError`
    * `crate::compositor::input_handler`
    * `crate::input::service::InputService`
* **Extern:**
    * `smithay::input::{SeatState, SeatHandler, Seat, Device, keyboard::{KeyboardHandle, KeyEvent}, pointer::{PointerHandle, MotionEvent, ButtonEvent, AxisEvent}, touch::{TouchHandle, TouchEvent}}`
    * `wayland_server::DisplayHandle`
    * `tracing`
    * `xkbcommon::xkb`

**Kommunikationsmuster:**

* Empfängt `Seat` und Input-Ereignisse von Smithay.
* Delegiert die eigentliche Event-Verarbeitung an das `input_handler` Modul.
* Verwaltet den globalen Tastatur- und Pointer-Fokus.

**Erwartete Ergebnisse/Outputs:**
Eine robuste Implementierung des Wayland "Seat"-Managements, die eine konsistente Eingabeverarbeitung über alle Gerätetypen hinweg gewährleistet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NovaCompositorState` und `InputService`.
    * Testen der korrekten Weiterleitung von Events an `input_handler`.
    * Testen des Fokus-Managements: Sicherstellen, dass der Fokus korrekt gesetzt und entfernt wird.
* **Integration Tests (mit Headless-Backend):**
    * Simulieren von Input-Ereignissen und Überprüfen des Verhaltens des Compositors in Bezug auf Fokus und Event-Verarbeitung.

**Geschätzter Aufwand:** Mittel (ca. 4-6 Tage, da grundlegende Komponente der Eingabeverarbeitung)

---

### **novade-system/src/compositor/output.rs**

**Verantwortlichkeit:**
Verwaltet die Ausgaben (Monitore) des Compositors. Dies beinhaltet das Hinzufügen/Entfernen von Monitoren, das Setzen ihrer Modi und das Management des globalen Ausgabezustands.

**Kern-Aufgaben (Tasks):**

1.  **`OutputManager` Initialisierung:**
    * Im `CompositorService::new()` oder `NovaCompositorState::new()`:
        * `let output_manager = OutputManager::new(display_handle.clone());`
        * `state.output_manager = output_manager;`

2.  **`OutputManagerHandler` Trait Implementierung für `NovaCompositorState`:**
    * `impl OutputManagerHandler for NovaCompositorState {`
    * **`new_output`:**
        * `fn new_output(&mut self, output: Output) {`
        * Fügt den neuen `Output` zur `OutputManager` hinzu.
        * `output.create_global(&mut self.display_handle);` (Erstellt das Wayland `wl_output` Global)
        * Benachrichtigt `display_management_service.add_display(output_id, output_info)` über den neuen Monitor.
        * Setzt einen Standard-Modus für den Output, wenn noch keiner konfiguriert ist.
    * **`output_removed`:**
        * `fn output_removed(&mut self, output: Output) {`
        * Entfernt den `Output` aus der `OutputManager`.
        * Benachrichtigt `display_management_service.remove_display(output_id)`.

3.  **`configure_output()` Funktion:**
    * `pub fn configure_output(state: &mut NovaCompositorState, output_id: OutputId, new_mode: Mode) -> Result<(), CompositorError>`
    * **Logik:**
        * Findet den `Output` anhand der `output_id`.
        * Sucht den `new_mode` in den verfügbaren Modi des Outputs.
        * Setzt den neuen Modus für den `Output` (`output.set_mode(new_mode)`).
        * Sendet die Konfiguration an alle Clients, die den `wl_output` global abonniert haben.
        * Benachrichtigt `display_management_service` über die Änderung.
        * Triggert einen Neu-Render-Zyklus.
    * **Fehlerbehandlung:** `OutputNotFound`, `ModeNotAvailable`.

4.  **`get_outputs()` Funktion:**
    * `pub fn get_outputs(state: &NovaCompositorState) -> Vec<OutputInfo>`
    * **Logik:**
        * Gibt eine Liste der aktuell verbundenen Outputs und deren grundlegende Informationen (ID, Name, aktuelle Mode, unterstützte Modi) zurück.
        * `OutputInfo` ist eine Domänen-Datentyp, der von `DisplayManagementService` verwendet wird.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/output.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::data_types::NovaCompositorState`
    * `crate::compositor::error::CompositorError`
    * `crate::display_management::service::DisplayManagementService`
    * `novade_domain::display_management::data_types::{OutputInfo, Mode, OutputId}`
* **Extern:**
    * `smithay::output::{OutputManager, OutputManagerHandler, Output, Mode, PhysicalProperties}`
    * `wayland_server::DisplayHandle`
    * `tracing`

**Kommunikationsmuster:**

* Implementiert Smithay `OutputManagerHandler`.
* Benachrichtigt den `DisplayManagementService` der Systemschicht über Änderungen der Monitor-Topologie.
* Empfängt Anfragen vom `DisplayManagementService` zur Konfiguration von Outputs.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Modul zur Verwaltung von physischen und virtuellen Monitoren innerhalb des Compositors.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NovaCompositorState` und `DisplayManagementService`.
    * Testen der `new_output` und `output_removed` Handler.
    * Testen von `configure_output` mit gültigen und ungültigen Modi.
    * Testen von `get_outputs`.
* **Integration Tests (mit Headless-Backend oder virtuellen DRM-Outputs):**
    * Simulieren des Hinzufügens/Entfernens von Outputs.
    * Testen des Setzens von Auflösungen und Bildwiederholraten.
    * Überprüfen, ob Clients über `wl_output` Änderungen informiert werden.

**Geschätzter Aufwand:** Mittel (ca. 3-5 Tage, da Interaktion mit Hardware/virtuellen Outputs und Protokoll-Messaging)

---

### **novade-system/src/compositor/cursor.rs**

**Verantwortlichkeit:**
Verwaltet die Anzeige und das Theming des Mauscursors innerhalb des Wayland-Compositors.

**Kern-Aufgaben (Tasks):**

1.  **Cursor-Management im `NovaCompositorState`:**
    * Füge Felder hinzu, um den Cursor-Status zu speichern:
        * `pub cursor_status: smithay::input::pointer::CursorImageStatus,`
        * `pub cursor_handle: smithay::cursor::CursorHandle,`
        * `pub cursor_theme_manager: Option<smithay::cursor::CursorThemeManager>,`
    * In `NovaCompositorState::new()`:
        * Initialisiere `cursor_handle`.
        * Initialisiere `cursor_theme_manager` basierend auf der `CompositorConfig` (Thema, Größe).
        * Lade die Cursor-Bilder in den Renderer.

2.  **`CursorImageStatusHandler` Trait Implementierung für `NovaCompositorState`:**
    * `impl CursorImageStatusHandler for NovaCompositorState {`
    * **`set_cursor_status`:**
        * `fn set_cursor_status(&mut self, seat: &smithay::input::Seat, status: CursorImageStatus) {`
        * Aktualisiert `state.cursor_status`.
        * Basierend auf `status` (z.B. `Hidden`, `Surface`, `Named`), aktualisiert den sichtbaren Cursor.
        * Wenn `Named`, lädt das entsprechende Cursor-Bild vom `cursor_theme_manager` und setzt es auf die `cursor_handle`.
        * Informiert den Renderer, dass der Cursor neu gezeichnet werden muss.
        * Wenn `Surface`, wird die Client-eigene Cursor-Surface verwendet.

3.  **Rendering des Cursors:**
    * Das `renderer` Modul muss den Cursor beim Rendern berücksichtigen.
    * Wenn `cursor_status` `Named` ist, wird das statische Cursor-Bild an der Pointer-Position gezeichnet.
    * Wenn `cursor_status` `Surface` ist, wird die Client-definierte Cursor-Surface an der Pointer-Position gezeichnet.
    * Der Cursor sollte immer die oberste Ebene des Renderings sein (Overlay).

4.  **`set_cursor_theme()` Funktion:**
    * `pub fn set_cursor_theme(state: &mut NovaCompositorState, theme_name: String, size: u32) -> Result<(), CompositorError>`
    * **Logik:**
        * Erstellt einen neuen `CursorThemeManager`.
        * Lädt die Cursor-Bilder neu.
        * Aktualisiert die Anzeige des Cursors.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/cursor.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::data_types::{NovaCompositorState}`
    * `crate::compositor::error::CompositorError`
    * `crate::config::data_types::CompositorConfig`
    * `crate::compositor::renderer::RenderSurface`
* **Extern:**
    * `smithay::input::pointer::{CursorImageStatus, CursorImageStatusHandler}`
    * `smithay::cursor::{CursorHandle, CursorThemeManager}`
    * `smithay::reexports::wayland_cursor::Cursor`
    * `smithay::utils::{Point, Physical}`
    * `tracing`

**Kommunikationsmuster:**

* Integriert sich direkt in den Rendering-Zyklus des Compositors.
* Reagiert auf Wayland-Protokoll-Anfragen zum Setzen von Cursor-Bildern durch Clients.
* Kann vom `SettingsService` (Domänenschicht) über den `CompositorService` (Systemschicht) aufgerufen werden, um das globale Cursor-Thema zu ändern.

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller und visuell anpassbarer Mauscursor im Wayland-Compositor.

**Teststrategie (Modul-spezifisch):**

* **Integration Tests (mit Headless-Backend oder X11-Backend):**
    * Starten des Compositors.
    * Starten eines Clients, der verschiedene Cursor-Bilder setzt.
    * Testen des Wechsels zwischen Client-definierten Cursors und vom Compositor bereitgestellten Themes.
    * Testen des Änderns des Cursor-Themas und der Größe zur Laufzeit.
* **Unit Tests:**
    * Für die Lade-Logik des Cursor-Themes.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage, da Interaktion mit dem Renderer und Smithay-Cursor-API)

---

### **novade-system/src/compositor/focus.rs**

**Verantwortlichkeit:**
Verwaltet den Fokuszustand von Fenstern und Surfaces innerhalb des Compositors. Dies ist entscheidend für die korrekte Weiterleitung von Eingabeereignissen an das richtige Client-Fenster und für visuelle Hervorhebungen.

**Kern-Aufgaben (Tasks):**

1.  **Fokus-Management im `NovaCompositorState`:**
    * `pub focused_window: RwLock<Option<WindowId>>,` (bereits in `data_types.rs`)

2.  **`set_focused_window()` Funktion:**
    * `pub fn set_focused_window(state: &mut NovaCompositorState, window_id: Option<WindowId>, serial: Serial) -> Result<(), CompositorError>`
    * **Logik:**
        * Holt das aktuell fokussierte Fenster (falls vorhanden) und sendet ein "deactivate"-Event an seinen Client.
        * Aktualisiert `state.focused_window`.
        * Wenn ein neues Fenster fokussiert werden soll (`Some(window_id)`):
            * Findet das `Window` in `state.window_tree`.
            * Sendet ein "activate"-Event an den Client des neuen Fensters (`window.activate(serial)`).
            * Setzt den Tastaturfokus des `seat_state` auf die Surface des neuen Fensters (`state.seat_state.keyboard_mut().set_focus(...)`).
            * Informiert den `DesktopStateService` über den Fokuswechsel (`desktop_state_service.on_window_focus_changed(old_id, new_id)`).
        * Wenn kein Fenster fokussiert werden soll (`None`):
            * Setzt den Tastaturfokus des `seat_state` auf `None`.
            * Benachrichtigt den `DesktopStateService`, dass der Fokus verloren gegangen ist.
    * **Fehlerbehandlung:** Wenn `window_id` nicht in `window_tree` gefunden wird.

3.  **`get_focused_window()` Funktion:**
    * `pub fn get_focused_window(state: &NovaCompositorState) -> Option<WindowId>`
    * Gibt die `WindowId` des aktuell fokussierten Fensters zurück.

4.  **Z-Ordnung und Fokus-Ring:**
    * Wenn ein Fenster fokussiert wird, sollte es an die Spitze der Z-Ordnung (d.h. über andere normale Fenster) gebracht werden. Dies wird im `window_management` Modul oder direkt im `renderer` Modul gehandhabt.
    * Das `DesktopStateService` könnte auch eine Rolle spielen, indem es eine Liste von Fenstern in Reihenfolge ihrer Fokus-Historie pflegt, um Alt+Tab-Wechsel zu ermöglichen.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/focus.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::data_types::{NovaCompositorState, WindowId, Window}`
    * `crate::compositor::error::CompositorError`
    * `novade_domain::desktop_state::service::DesktopStateService`
* **Extern:**
    * `smithay::utils::Serial`
    * `tokio::sync::RwLock`
    * `tracing`

**Kommunikationsmuster:**

* Wird vom `input_handler` aufgerufen, wenn ein Klick auf ein Fenster erfolgt oder ein globaler Shortcut den Fokus wechselt.
* Wird von `xdg_shell` und `layer_shell` aufgerufen, wenn neue Fenster erstellt werden und den initialen Fokus erhalten sollen.
* Informiert den `DesktopStateService` über Fokusänderungen.

**Erwartete Ergebnisse/Outputs:**
Ein zuverlässiges Fokus-Managementsystem, das die korrekte Zustellung von Eingabeereignissen und die visuelle Hervorhebung des aktiven Fensters sicherstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NovaCompositorState` und `DesktopStateService`.
    * Testen von `set_focused_window` für den Wechsel des Fokus von Fenster A zu B, von A zu None und von None zu A.
    * Testen, ob "activate" und "deactivate" Events korrekt gesendet werden.
    * Testen, ob der `DesktopStateService` über den Fokuswechsel benachrichtigt wird.
    * Testen von Edge-Cases (z.B. Versuch, ein nicht existierendes Fenster zu fokussieren).
* **Integration Tests (mit Headless-Backend):**
    * Starten des Compositors und von mehreren Test-Clients.
    * Simulieren von Klicks auf verschiedene Fenster und Überprüfen des Fokus-Zustands.
    * Simulieren von Tastenkombinationen, die den Fokus wechseln sollen.

**Geschätzter Aufwand:** Mittel (ca. 3-4 Tage, da kritische Komponente für Benutzerinteraktion und State-Management)

---

### **novade-system/src/compositor/window_management.rs**

**Verantwortlichkeit:**
Dieses Modul enthält die allgemeine Logik für das Fenster-Management, wie das Hinzufügen, Entfernen, Ordnen, Verschieben und Skalieren von Fenstern. Es ist die technische Umsetzung der Richtlinien, die vom `WindowPolicyService` der Domänenschicht vorgegeben werden.

**Kern-Aufgaben (Tasks):**

1.  **`add_window()` Funktion:**
    * `pub fn add_window(state: &mut NovaCompositorState, window: Window) -> Result<(), CompositorError>`
    * **Logik:**
        * Fügt das `Window`-Objekt zu `state.window_tree` hinzu.
        * Setzt den initialen Fokus, wenn dies das erste Fenster ist oder eine Regel es erfordert.
        * Benachrichtigt den `WindowPolicyService` und `DesktopStateService` über das neue Fenster.
        * Ordnet das Fenster in den Render-Baum ein (Z-Ordnung).

2.  **`remove_window()` Funktion:**
    * `pub fn remove_window(state: &mut NovaCompositorState, window_id: WindowId) -> Result<(), CompositorError>`
    * **Logik:**
        * Entfernt das `Window` aus `state.window_tree`.
        * Wenn das entfernte Fenster fokussiert war, wählt ein neues Fenster für den Fokus (z.B. das zuletzt fokussierte, oder das nächste im Z-Stack).
        * Benachrichtigt `WindowPolicyService` und `DesktopStateService`.
        * Entfernt das Fenster aus dem Render-Baum.

3.  **`set_window_geometry()` Funktion:**
    * `pub fn set_window_geometry(state: &mut NovaCompositorState, window_id: WindowId, new_rect: Rectangle<i32, Logical>) -> Result<(), CompositorError>`
    * **Logik:**
        * Aktualisiert die Größe und Position des Fensters im `Window`-Objekt.
        * Sendet die Konfiguration an den Client (`surface.send_configure(...)`).
        * **Anwendung von `window_policy_service` Regeln:** Bevor die neue Geometrie angewendet wird, könnte diese Funktion den `WindowPolicyService.apply_window_policy()` aufrufen, um sicherzustellen, dass die Geometrie den Regeln entspricht (z.B. Tiling-Regeln, minimale/maximale Größen).
        * Triggert einen Neu-Render-Zyklus.
    * **Fehlerbehandlung:** `WindowNotFound`.

4.  **`maximize_window()` / `unmaximize_window()` Funktion:**
    * `pub fn maximize_window(state: &mut NovaCompositorState, window_id: WindowId) -> Result<(), CompositorError>`
    * **Logik:**
        * Setzt den maximierten Zustand des Fensters.
        * Berechnet die neue Größe basierend auf dem verfügbaren Output-Bereich und Panel-Offsets.
        * Sendet die entsprechende Konfiguration an den Client.
        * Aktualisiert `window.is_maximized` und `window.state`.
        * Benachrichtigt den `WindowPolicyService`.

5.  **`minimize_window()` / `unminimize_window()` Funktion:**
    * `pub fn minimize_window(state: &mut NovaCompositorState, window_id: WindowId) -> Result<(), CompositorError>`
    * **Logik:**
        * Setzt den minimierten Zustand des Fensters.
        * Verbirgt die Surface des Fensters (unmap).
        * Benachrichtigt `WindowPolicyService` und `DesktopStateService`.

6.  **`fullscreen_window()` / `unfullscreen_window()` Funktion:**
    * `pub fn fullscreen_window(state: &mut NovaCompositorState, window_id: WindowId, output_id: Option<OutputId>) -> Result<(), CompositorError>`
    * **Logik:**
        * Setzt den Vollbildzustand des Fensters auf dem angegebenen oder aktuellen Output.
        * Berechnet die Größe auf die volle Output-Größe.
        * Sendet Konfiguration an den Client.
        * Aktualisiert `window.is_fullscreen` und `window.state`.
        * Benachrichtigt `WindowPolicyService`.

7.  **`move_window_by_delta()` Funktion (für Grab-State):**
    * `pub fn move_window_by_delta(state: &mut NovaCompositorState, window_id: WindowId, delta: Point<f64, Physical>) -> Result<(), CompositorError>`
    * **Logik:**
        * Aktualisiert die Position des Fensters basierend auf der Delta-Bewegung.
        * Wird während eines "Move"-Grab-Vorgangs vom `input_handler` aufgerufen.
        * Ruft `set_window_geometry` auf.

8.  **`resize_window_by_delta()` Funktion (für Grab-State):**
    * `pub fn resize_window_by_delta(state: &mut NovaCompositorState, window_id: WindowId, delta: Point<f64, Physical>, edges: ResizeEdge) -> Result<(), CompositorError>`
    * **Logik:**
        * Aktualisiert Größe und Position des Fensters basierend auf Delta und Kanten.
        * Wird während eines "Resize"-Grab-Vorgangs vom `input_handler` aufgerufen.
        * Berücksichtigt minimale/maximale Größen des Clients.
        * Ruft `set_window_geometry` auf.

9.  **Fenster-Sortierung (Z-Ordnung):**
    * Interne Helferfunktionen, um die Reihenfolge der Fenster für das Rendering zu pflegen.
    * Beachtet `LayerShell` Fenster (Panels, Backgrounds) und `XdgToplevel` Fenster.
    * Normalerweise nach Fokus und dann nach Erstellungszeit oder einer Policy sortiert.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/window_management.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::data_types::{NovaCompositorState, Window, WindowId}`
    * `crate::compositor::error::CompositorError`
    * `crate::compositor::focus`
    * `novade_domain::window_policy::service::WindowPolicyService`
    * `novade_domain::desktop_state::service::DesktopStateService`
    * `novade_domain::display_management::data_types::OutputId`
    * `novade_core::types::geometry::{Rectangle, Point, Logical, Physical}`
* **Extern:**
    * `smithay::wayland::shell::xdg::XdgToplevelSurface`
    * `smithay::utils::ResizeEdge`
    * `tracing`
    * `tokio::sync::RwLock`

**Kommunikationsmuster:**

* Nimmt Anweisungen vom `WindowPolicyService` entgegen, um Fenster-Operationen durchzuführen.
* Wird vom `input_handler` aufgerufen, um Fenster basierend auf Benutzerinteraktionen zu verschieben/skalieren.
* Interagiert direkt mit den `Window`-Objekten im `NovaCompositorState`.
* Benachrichtigt den `DesktopStateService` über wesentliche Fenster-Zustandsänderungen.

**Erwartete Ergebnisse/Outputs:**
Ein zentrales Modul für die technische Umsetzung der Fensterverwaltung, das die Einhaltung der Domänen-Policies sicherstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NovaCompositorState`, `WindowPolicyService` und `DesktopStateService`.
    * Testen von `add_window` und `remove_window`, einschließlich Fokus-Anpassung.
    * Testen von `set_window_geometry`, `maximize_window`, `minimize_window`, `fullscreen_window` mit verschiedenen Eingaben und Überprüfung der gesendeten Konfigurationen.
    * Testen von `move_window_by_delta` und `resize_window_by_delta` unter Berücksichtigung von Mindest-/Maximalgrößen.
    * Testen der Z-Ordnung Logik.
* **Integration Tests (mit Headless-Backend):**
    * Starten des Compositors mit mehreren Test-Clients.
    * Simulieren von Fenster-Operationen (maximieren, verschieben, etc.) und Überprüfen des visuellen Ergebnisses und der internen Zustandskonsistenz.

**Geschätzter Aufwand:** Sehr hoch (ca. 12-18 Tage, da komplexe Interaktion mit Wayland-Clients, Rendering und Domänen-Policies)

---
### **novade-system/src/compositor/shell_manager.rs**

**Verantwortlichkeit:**
Dieses Modul dient als übergeordnete Verwaltungsschicht für verschiedene Wayland-Shell-Protokolle (z.B. `xdg-shell`, `wlr-layer-shell`, `xdg-output`, `xdg-decoration`). Es orchestriert die Initialisierung und Interaktion dieser Protokolle und bietet eine vereinheitlichte Schnittstelle für den `CompositorService`.

**Kern-Aufgaben (Tasks):**

1.  **`ShellManager` Struktur:**
    * `pub struct ShellManager {`
        * `pub xdg_shell_state: XdgShellState,`
        * `pub layer_shell_state: LayerShellState,`
        * `pub xdg_output_manager: XdgOutputManager,`
        * `pub xdg_decoration_state: Option<XdgDecorationState>,` // Optional, wenn client-side decorations unterstützt werden
        * `// ... weitere Shell-States`
    * `}`

2.  **`ShellManager::new()` Funktion:**
    * `pub fn new(display_handle: &DisplayHandle) -> Self`
    * **Logik:**
        * Initialisiert alle benötigten Shell-States:
            * `XdgShellState::new::<NovaCompositorState>(display_handle.clone())`
            * `LayerShellState::new::<NovaCompositorState>(display_handle.clone())`
            * `XdgOutputManager::new::<NovaCompositorState>(display_handle.clone())`
            * `XdgDecorationState::new::<NovaCompositorState>(display_handle.clone())` (Optional, nur wenn aktiviert)
        * Fügt die entsprechenden Smithay-Event-Handler zum `EventLoop` hinzu (indirekt über `SmithayEventLoop`).
        * Gibt `ShellManager` zurück.

3.  **Registrierung von Shell-Clients im `EventLoop`:**
    * Die `ShellManager` oder der `CompositorService` stellt sicher, dass die Handler für `XdgShell`, `LayerShell`, etc. im `EventLoop` registriert werden. Dies geschieht durch die Implementierung der jeweiligen `Handler`-Traits für `NovaCompositorState`. Das `ShellManager` selbst verwaltet nur die `State`-Objekte.

4.  **Weiterleitung von Anfragen:**
    * Dieses Modul selbst führt selten Logik aus, sondern dient als Container und Delegator. Die eigentlichen Handler-Implementierungen für die Protokolle liegen in `NovaCompositorState` und rufen dann spezifische Funktionen in `xdg_shell.rs`, `layer_shell.rs` usw. auf.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/shell_manager.rs`
* **Hinweis:** Die eigentlichen Implementierungen der Handler-Traits (`XdgShellHandler`, `LayerShellHandler`, etc.) verbleiben in `novade-system/src/compositor/mod.rs` (bzw. der Datei, die `NovaCompositorState` enthält), aber die Logik der Funktionen wird in die spezialisierten Module (`xdg_shell.rs`, `layer_shell.rs` etc.) ausgelagert.

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::data_types::NovaCompositorState`
    * `crate::compositor::xdg_shell`
    * `crate::compositor::layer_shell`
    * `crate::compositor::xdg_output` (wird noch spezifiziert)
    * `crate::compositor::xdg_decoration` (wird noch spezifiziert)
* **Extern:**
    * `smithay::wayland::shell::xdg::XdgShellState`
    * `smithay::wayland::shell::wlr_layer_shell::LayerShellState`
    * `smithay::wayland::output::XdgOutputManager`
    * `smithay::wayland::shell::xdg_decoration::XdgDecorationState`
    * `wayland_server::DisplayHandle`

**Kommunikationsmuster:**

* Die `ShellManager` wird vom `CompositorService` instanziiert und hält die Zustände der verschiedenen Shell-Protokolle.
* Die `NovaCompositorState` implementiert die Handler-Traits für diese Protokolle, nutzt dabei die in `ShellManager` gehaltenen States und delegiert die konkrete Verarbeitung an die jeweiligen Submodule (z.B. `xdg_shell::handle_surface_created`).

**Erwartete Ergebnisse/Outputs:**
Ein zentrales Management für alle Wayland-Shell-Protokolle, das deren korrekte Initialisierung und Interaktion gewährleistet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Testen der `new()`-Funktion zur Sicherstellung, dass alle `State`-Objekte korrekt initialisiert werden.
    * Da dieses Modul hauptsächlich ein Aggregator ist, werden die tiefgehenden Tests in den einzelnen Shell-Modulen (`xdg_shell.rs`, `layer_shell.rs`) durchgeführt.
* **Integration Tests:**
    * Im Rahmen der Compositor-Integrationstests wird die korrekte Funktion der einzelnen Shell-Protokolle implizit getestet.

**Geschätzter Aufwand:** Niedrig (ca. 1-2 Tage, da hauptsächlich Aggregation und Initialisierung)

---

### **novade-system/src/compositor/xdg_output.rs**

**Verantwortlichkeit:**
Implementiert das `xdg-output` Wayland-Protokoll, das Clients detailliertere Informationen über die verfügbaren Bildschirmausgaben bereitstellt als das grundlegende `wl_output` Protokoll. Dies ist wichtig für Clients, die ihre Fenster in Bezug auf bestimmte Monitore positionieren oder sich an Multi-Monitor-Setups anpassen müssen.

**Kern-Aufgaben (Tasks):**

1.  **`xdg_output_manager` Initialisierung:**
    * Im `CompositorService::new()` oder `NovaCompositorState::new()`:
        * `let xdg_output_manager = XdgOutputManager::new::<NovaCompositorState>(display_handle.clone());`
        * Registriere den XdgOutput-Handler im `EventLoop`.

2.  **`XdgOutputHandler` Trait Implementierung für `NovaCompositorState`:**
    * `impl XdgOutputHandler for NovaCompositorState {`
    * **`output_created`:**
        * `fn output_created(&mut self, output: XdgOutput) {`
        * Diese Funktion wird aufgerufen, wenn ein neuer `wl_output` global erstellt wird (siehe `compositor/output.rs`).
        * Das `XdgOutput` Objekt wird dem `output_manager` hinzugefügt und seine Eigenschaften (Name, Beschreibung, physische Größe, Position) an den Client gesendet.
        * Das `display_management_service` könnte hier über die detaillierten XDG-Output-Informationen informiert werden.
    * **`output_destroyed`:**
        * `fn output_destroyed(&mut self, output: XdgOutput) {`
        * Entfernt die `XdgOutput` Instanz, wenn der `wl_output` global zerstört wird.
    * **`output_moved` / `output_mode_changed` / `output_description_changed`:**
        * `fn output_moved(&mut self, output: XdgOutput, old_position: Point<i32, Logical>) {`
        * Wird aufgerufen, wenn sich die Position oder der Modus eines Outputs ändert.
        * Sendet die aktualisierten Informationen an den Client.
        * Triggert einen Neu-Render-Zyklus und ggf. eine Neuanordnung der Fenster.
        * Informiert den `display_management_service`.

3.  **Integration mit `output.rs`:**
    * Wenn ein `Output` im `compositor/output.rs` Modul konfiguriert wird (Position, Modus), müssen diese Änderungen auch dem `XdgOutputManager` gemeldet werden, damit die `xdg-output` Events an die Clients gesendet werden.
    * `state.xdg_output_manager.output_updated(&output, None);`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/xdg_output.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::data_types::{NovaCompositorState}`
    * `crate::compositor::error::CompositorError`
    * `crate::display_management::service::DisplayManagementService`
    * `novade_core::types::geometry::{Point, Logical}`
* **Extern:**
    * `smithay::wayland::output::{XdgOutputManager, XdgOutput, XdgOutputHandler}`
    * `wayland_server::DisplayHandle`
    * `tracing`

**Kommunikationsmuster:**

* Implementiert Wayland-Protokoll-Handler für `xdg-output`.
* Wird von `output.rs` (indirekt über `NovaCompositorState`) über Änderungen an den primären `wl_output` Instanzen informiert, um die detaillierteren `xdg-output` Events zu generieren.
* Stellt Informationen für Clients bereit, die `xdg-output` abonniert haben.

**Erwartete Ergebnisse/Outputs:**
Eine konforme Implementierung des `xdg-output` Protokolls, die Clients präzise Informationen über Ausgaben bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Integration Tests (mit einem Wayland-Client, der `xdg-output` verwendet):**
    * Starten des Compositors mit mehreren virtuellen Ausgängen.
    * Starten eines Test-Clients, der `xdg-output` abonniert.
    * Ändern der Output-Konfiguration (Position, Modus) im Compositor und Überprüfen, ob der Client die korrekten `xdg-output` Events empfängt.
    * Hinzufügen/Entfernen von Ausgängen und Überprüfen der Client-Reaktion.
* **Unit Tests:**
    * Für die Initialisierung des Managers.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage, da Protokollimplementierung und Koordination mit `output.rs`)

---

### **novade-system/src/compositor/xdg_decoration.rs**

**Verantwortlichkeit:**
Implementiert das `zxdg-decoration-unstable-v1` Wayland-Protokoll. Dieses Protokoll ermöglicht es Clients, den Compositor um Server-Side Decorations (SSD) zu bitten (z.B. Titelleisten, Schatten, Schaltflächen zum Schließen/Maximieren/Minimieren), anstatt diese selbst zu zeichnen (Client-Side Decorations, CSD).

**Kern-Aufgaben (Tasks):**

1.  **`xdg_decoration_state` Initialisierung:**
    * Im `CompositorService::new()` oder `NovaCompositorState::new()`:
        * `let (xdg_decoration_state, _) = XdgDecorationState::new::<NovaCompositorState>(display_handle.clone());`
        * Registriere den XdgDecoration-Handler im `EventLoop`.
    * **Entscheidung:** Ob SSD verwendet werden sollen, hängt von der Konfiguration ab. NovaDE sollte primär CSD nutzen, aber eine Fallback-Option für SSD bereitstellen oder für Anwendungen, die dies explizit anfordern (z.B. GTK-Apps können CSD oder SSD wählen).

2.  **`XdgDecorationHandler` Trait Implementierung für `NovaCompositorState`:**
    * `impl XdgDecorationHandler for NovaCompositorState {`
    * **`new_toplevel_decoration`:**
        * `fn new_toplevel_decoration(&mut self, toplevel_decoration: ToplevelDecoration) {`
        * Wird aufgerufen, wenn ein Client eine `zxdg_toplevel_decoration` Ressource erstellt.
        * Die `toplevel_decoration` Instanz wird dem `Window`-Objekt (falls gefunden) zugeordnet.
        * `toplevel_decoration.send_mode(Mode::ServerSide);` oder `Mode::ClientSide` je nach NovaDE-Policy.
        * Aktualisiert den Dekorationszustand des Fensters (ob es SSD erwartet).
        * Registriert Listener für `destroy` Event.
    * **`request_mode`:**
        * `fn request_mode(&mut self, toplevel_decoration: ToplevelDecoration, mode: Mode) {`
        * Der Client bittet um einen bestimmten Dekorationsmodus (SSD oder CSD).
        * NovaDE entscheidet, ob es dem Wunsch des Clients nachkommt oder seine eigene Policy durchsetzt.
        * Wenn SSD genehmigt wird, muss der Compositor die Titelleiste etc. rendern und Eingaben dafür verarbeiten.

3.  **Rendering von Server-Side Decorations (optional):**
    * Wenn NovaDE SSD implementiert, muss das `renderer` Modul in der Lage sein, Titelleisten, Ränder und Schaltflächen für Fenster zu zeichnen, die SSD angefordert haben.
    * Das `input_handler` Modul muss Eingaben auf diesen SSD-Elementen (Klicks auf Schließen-Button, Ziehen an Titelleiste) verarbeiten.
    * Dies ist eine komplexe Erweiterung und sollte nur implementiert werden, wenn es eine explizite Anforderung gibt. Standardmäßig sollte NovaDE CSD bevorzugen.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/xdg_decoration.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::data_types::{NovaCompositorState, Window}`
    * `crate::compositor::error::CompositorError`
    * `crate::compositor::window_management` (für Größenanpassung/Verschiebung durch SSD)
    * `crate::compositor::input_handler` (für Eingabe-Verarbeitung auf SSD)
* **Extern:**
    * `smithay::wayland::shell::xdg_decoration::{XdgDecorationState, XdgDecorationHandler, ToplevelDecoration, Mode}`
    * `wayland_server::DisplayHandle`
    * `tracing`

**Kommunikationsmuster:**

* Implementiert Wayland-Protokoll-Handler für `zxdg-decoration`.
* Informiert die `Window`-Struktur über den gewünschten Dekorationsstil.
* Bei SSD-Implementierung interagiert es mit dem `renderer` und `input_handler`.

**Erwartete Ergebnisse/Outputs:**
Eine Implementierung des `xdg-decoration` Protokolls, die es dem Compositor ermöglicht, über den Dekorationsstil von Fenstern zu verhandeln.

**Teststrategie (Modul-spezifisch):**

* **Integration Tests (mit einem Wayland-Client, der `zxdg-decoration` anfordert):**
    * Starten des Compositors mit der gewünschten Dekorations-Policy (z.B. immer CSD, oder SSD erlauben).
    * Starten eines Test-Clients, der `zxdg-decoration` nutzt.
    * Überprüfen, ob der Client den erwarteten Dekorationsstil erhält (z.B. ob der Compositor SSD zeichnet oder der Client CSD zeichnet).
    * Testen der Interaktion mit SSD-Elementen (z.B. Schließen-Button, Größenänderung via Rand).
* **Unit Tests:**
    * Für die Initialisierung des States.

**Geschätzter Aufwand:** Niedrig-Mittel (ca. 2-5 Tage, je nachdem ob volle SSD-Rendering-Logik implementiert wird oder nur die Protokoll-Negotiation)

---

### **novade-system/src/compositor/xdg_foreign.rs**

**Verantwortlichkeit:**
Implementiert das `xdg-foreign-unstable-v1` Wayland-Protokoll. Dieses Protokoll ermöglicht es Clients, auf Surfaces zuzugreifen, die von anderen Clients oder dem Compositor selbst erstellt wurden. Dies ist nützlich für Anwendungsfälle wie Drag-and-Drop über Anwendungsfenster hinweg oder die Implementierung von "Global Hot Corners" oder "Taskbars", die Surfaces anderer Anwendungen manipulieren müssen.

**Kern-Aufgaben (Tasks):**

1.  **`xdg_foreign_state` Initialisierung:**
    * Im `CompositorService::new()` oder `NovaCompositorState::new()`:
        * `let (xdg_foreign_state, _) = XdgForeignState::new::<NovaCompositorState>(display_handle.clone());`
        * Registriere den XdgForeign-Handler im `EventLoop`.

2.  **`XdgForeignHandler` Trait Implementierung für `NovaCompositorState`:**
    * `impl XdgForeignHandler for NovaCompositorState {`
    * **`new_exported_surface`:**
        * `fn new_exported_surface(&mut self, exported: Exported) {`
        * Wird aufgerufen, wenn ein Client eine Surface zur Exportierung anbietet.
        * `exported.with_toplevel_surface(...)` um die zugehörige XDG-Toplevel-Surface zu erhalten.
        * Speichert die exportierte Surface intern ab, zusammen mit den Metadaten (z.B. Token).
        * Benachrichtigt den `DesktopStateService` oder `WindowManagerService` über die exportierte Surface, falls relevant für globale Features (z.B. für Taskleiste, die Thumbnails anzeigen soll).
    * **`new_imported_surface`:**
        * `fn new_imported_surface(&mut self, imported: Imported) {`
        * Wird aufgerufen, wenn ein Client eine Surface importieren möchte.
        * Validiert das bereitgestellte Token gegen die Liste der exportierten Surfaces.
        * `imported.send_surface(wl_surface)`: Sendet die `wl_surface` Ressource des exportierten Fensters an den importierenden Client.
    * **`exported_destroyed` / `imported_destroyed`:**
        * `fn exported_destroyed(&mut self, exported: Exported) {`
        * Bereinigt die internen Zustände, wenn eine exportierte/importierte Surface zerstört wird.

3.  **Token-Generierung und -Verwaltung:**
    * Der Compositor muss Mechanismen bereitstellen, um "Export Tokens" zu generieren, die Clients verwenden können, um Surfaces zu referenzieren.
    * Diese Tokens müssen sicher und eindeutig sein (z.B. UUIDs).
    * Speicherung dieser Tokens und der zugehörigen `WlSurface` im `NovaCompositorState`.

4.  **Integration mit UI-Komponenten (optional):**
    * NovaDE UI-Komponenten (z.B. Taskleiste, Übersichtsmodus) könnten dieses Protokoll nutzen, um Vorschaubilder von Fenstern zu erhalten oder Drag-and-Drop-Operationen zu unterstützen.
    * Dies erfordert, dass die UI-Komponenten selbst als Wayland-Clients agieren können, die `xdg-foreign` nutzen.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/xdg_foreign.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::data_types::{NovaCompositorState, Window}`
    * `crate::compositor::error::CompositorError`
    * `novade_domain::desktop_state::service::DesktopStateService` (zur Information über Fenster-Exporte)
* **Extern:**
    * `smithay::wayland::shell::xdg_foreign::{XdgForeignState, XdgForeignHandler, Exported, Imported}`
    * `wayland_server::{DisplayHandle, protocol::wl_surface::WlSurface}`
    * `tracing`
    * `uuid::Uuid` (für Token-Generierung)
    * `std::collections::HashMap`

**Kommunikationsmuster:**

* Implementiert Wayland-Protokoll-Handler für `xdg-foreign`.
* Verwaltet eine Liste von exportierten Surfaces und zugehörigen Tokens.
* Ermöglicht es Clients, Surfaces von anderen Clients zu importieren.

**Erwartete Ergebnisse/Outputs:**
Eine Implementierung des `xdg-foreign` Protokolls, das fortgeschrittene Interaktionen zwischen Clients und dem Compositor ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Integration Tests (mit zwei Wayland-Clients, die `xdg-foreign` verwenden):**
    * Starten des Compositors.
    * Client A exportiert eine seiner Surfaces.
    * Client B versucht, diese Surface mit dem korrekten Token zu importieren.
    * Überprüfen, ob Client B die Surface erfolgreich importieren kann.
    * Testen der Zerstörung exportierter/importierter Surfaces.
* **Unit Tests:**
    * Für Token-Generierung und -Validierung.

**Geschätzter Aufwand:** Mittel (ca. 4-6 Tage, da Protokollimplementierung und sichere Token-Verwaltung)

---

### **novade-system/src/compositor/data_device.rs**

**Verantwortlichkeit:**
Implementiert das `wl_data_device` Wayland-Protokoll, das für Drag-and-Drop-Operationen und das Zwischenablage-Management (Clipboard) zuständig ist.

**Kern-Aufgaben (Tasks):**

1.  **`DataDeviceState` Initialisierung:**
    * Im `CompositorService::new()` oder `NovaCompositorState::new()`:
        * `let (data_device_state, _) = DataDeviceState::new::<NovaCompositorState>(display_handle.clone());`
        * Registriere den DataDevice-Handler im `EventLoop`.

2.  **`DataDeviceHandler` Trait Implementierung für `NovaCompositorState`:**
    * `impl DataDeviceHandler for NovaCompositorState {`
    * **`data_device_manager_created`:**
        * Wird aufgerufen, wenn der `wl_data_device_manager` erstellt wird.
    * **`new_data_source`:**
        * `fn new_data_source(&mut self, source: DataSource) {`
        * Ein Client hat Daten zum Ziehen oder für die Zwischenablage angeboten.
        * Speichert die `DataSource` und deren Mimetypen (`source.current_mimetypes()`).
        * Setzt Listener für `finish` und `cancelled` Events.
    * **`data_source_destroyed`:**
        * `fn data_source_destroyed(&mut self, source: DataSource) {`
        * Entfernt die `DataSource` aus dem internen Zustand.
    * **`drop`:**
        * `fn drop(&mut self, seat: &smithay::input::Seat, source: Option<DataSource>) {`
        * Wird aufgerufen, wenn ein Drag-and-Drop-Vorgang beendet wird (Daten fallen gelassen werden).
        * Wenn `source` vorhanden, leitet es das Drop-Event an den aktuell fokussierten Client weiter, damit dieser die Daten empfangen kann.
        * Oder übergibt es an einen systemweiten Service (z.B. einen Dateimanager, der Drag-and-Drop vom Desktop empfangen kann).
    * **`selection_changed`:**
        * `fn selection_changed(&mut self, seat: &smithay::input::Seat, source: Option<DataSource>) {`
        * Wird aufgerufen, wenn sich der Inhalt der Zwischenablage ändert.
        * Wenn `source` vorhanden, ist es die neue Quelle für die Zwischenablage.
        * Aktualisiert den internen Zwischenablage-Zustand des Compositors.
        * Benachrichtigt den `ClipboardService` der Domänenschicht.
    * **`action_chosen`:**
        * `fn action_chosen(&mut self, seat: &smithay::input::Seat, action: smithay::utils::DndAction) {`
        * Der Client hat eine Drag-and-Drop-Aktion gewählt (z.B. Copy, Move, Ask). Compositor passt Verhalten an.
    * **`start_drag`:**
        * `fn start_drag(&mut self, seat: &smithay::input::Seat, source: Option<DataSource>, icon: Option<WlSurface>) {`
        * Ein Client hat einen Drag-Vorgang gestartet.
        * Setzt den internen `drag_status` auf `Dragging`.
        * Speichert das Drag-Icon (`icon`) zur Darstellung.
        * Der `renderer` muss dieses Icon an der Cursorposition rendern.

3.  **Zwischenablage-Management (`ClipboardService` Integration):**
    * Das `ClipboardService` (Domänenschicht) ist der primäre Endpunkt für Lese- und Schreibzugriffe auf die Zwischenablage.
    * Wenn `selection_changed` im Compositor aufgerufen wird, liest der Compositor die Daten von der neuen `DataSource` (asynchron) und übergibt sie an den `ClipboardService`.
    * Wenn der `ClipboardService` neue Daten in die Zwischenablage schreibt, erstellt er eine temporäre `DataSource` im Compositor und setzt diese als Auswahl.

4.  **Drag-and-Drop Visuelles Feedback:**
    * Der `renderer` muss das Drag-Icon, wenn vorhanden, an der Mausposition zeichnen.
    * Das `input_handler` Modul muss die Drag-Position verfolgen und `data_device_state.motion(...)` aufrufen, um das Ziel zu benachrichtigen.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/data_device.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::data_types::{NovaCompositorState}`
    * `crate::compositor::error::CompositorError`
    * `crate::compositor::renderer` (für Drag-Icon)
    * `novade_domain::clipboard::service::ClipboardService`
* **Extern:**
    * `smithay::wayland::data_device::{DataDeviceState, DataDeviceHandler, DataSource}`
    * `smithay::utils::DndAction`
    * `wayland_server::{DisplayHandle, protocol::wl_surface::WlSurface}`
    * `tracing`
    * `tokio::fs::File` (für Datei-Drag-and-Drop)
    * `bytes::Bytes`

**Kommunikationsmuster:**

* Implementiert Wayland-Protokoll-Handler für `wl_data_device`.
* Integriert sich mit `ClipboardService` für Zwischenablage-Operationen.
* Arbeitet eng mit `input_handler` und `renderer` für Drag-and-Drop-Feedback.

**Erwartete Ergebnisse/Outputs:**
Ein voll funktionsfähiges Drag-and-Drop-System und Zwischenablage-Management für Wayland-Clients.

**Teststrategie (Modul-spezifisch):**

* **Integration Tests (mit zwei Wayland-Clients, die D&D und Clipboard nutzen):**
    * Starten des Compositors.
    * Client A kopiert Text in die Zwischenablage, Client B liest ihn.
    * Client A startet einen Drag-Vorgang mit Text/Datei, Client B empfängt ihn.
    * Testen von D&D über verschiedene Fenster hinweg.
    * Testen von D&D mit verschiedenen Mimetypen.
* **Unit Tests:**
    * Für das Handling von `DataSource` und Mimetypen.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da komplexe Protokoll-Interaktionen und asynchrone Datenübertragung)

---

### **novade-system/src/compositor/socket.rs**

**Verantwortlichkeit:**
Verwaltet die Wayland-Socket-Erstellung und -Verbindung. Dies ist der Einstiegspunkt für Wayland-Clients, um mit dem Compositor zu kommunizieren.

**Kern-Aufgaben (Tasks):**

1.  **Wayland Socket Erstellung:**
    * `pub fn create_wayland_socket(display: &mut Display<NovaCompositorState>) -> Result<SocketName, CompositorError>`
    * **Logik:**
        * Verwendet `Display::add_socket_auto()` oder `Display::add_socket()` um einen Wayland-Socket zu erstellen.
        * Die Socket-Umgebungsvariable (`WAYLAND_DISPLAY`) wird entsprechend gesetzt.
        * Speichert den Socket-Namen (z.B. "wayland-1") und gibt ihn zurück.
    * **Fehlerbehandlung:** Wenn der Socket nicht erstellt werden kann (z.B. Berechtigungen, schon belegt).

2.  **Socket-Pfad-Verwaltung:**
    * Bestimmt den Speicherort für den Wayland-Socket (typischerweise in `/run/user/<UID>/`).
    * Stellt sicher, dass die Berechtigungen korrekt gesetzt sind.

3.  **Cleanup bei Compositor-Beendigung:**
    * Stellt sicher, dass der Wayland-Socket beim Herunterfahren des Compositors korrekt geschlossen und entfernt wird. Dies wird oft automatisch von Smithay und der `Display` Instanz gehandhabt, aber es ist wichtig, dies zu verifizieren.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/compositor/socket.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::compositor::data_types::NovaCompositorState`
    * `crate::compositor::error::CompositorError`
* **Extern:**
    * `smithay::wayland::socket::SocketName`
    * `wayland_server::Display`
    * `tracing`
    * `std::env` (für `WAYLAND_DISPLAY`)

**Kommunikationsmuster:**

* Wird vom `CompositorService` während der Initialisierung aufgerufen, um den Wayland-Socket zu starten.

**Erwartete Ergebnisse/Outputs:**
Ein funktionierender Wayland-Socket, über den Clients eine Verbindung zum Compositor herstellen können.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `create_wayland_socket()` Funktion mit Mocking der `Display` Instanz, um Erfolgs- und Fehlerfälle zu simulieren.
    * Überprüfen, ob die `WAYLAND_DISPLAY` Umgebungsvariable korrekt gesetzt wird.
* **Integration Tests:**
    * Starten des Compositors und Überprüfen, ob die Socket-Datei existiert und Clients eine Verbindung herstellen können.

**Geschätzter Aufwand:** Niedrig (ca. 1-2 Tage, da grundlegende, aber kritische Setup-Aufgabe)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Basierend auf den Abhängigkeiten und der Bedeutung für die Grundfunktionalität des Compositors schlage ich folgende weitere Reihenfolge für die Implementierung der verbleibenden `compositor`-Module vor:

1.  **`novade-system/src/compositor/socket.rs`**: Absolut kritisch, da es der erste Kontaktpunkt für Clients ist. Ohne Socket kann kein Client verbinden.
2.  **`novade-system/src/compositor/xdg_output.rs`**: Eng an `output.rs` gekoppelt und essenziell für Multi-Monitor-Setups für Clients.
3.  **`novade-system/src/compositor/xdg_foreign.rs`**: Ermöglicht erweiterte Interaktionen wie Drag-and-Drop über Fenster hinweg und ist für einige UI-Features nützlich.
4.  **`novade-system/src/compositor/data_device.rs`**: Wichtig für grundlegende Benutzerinteraktionen (Zwischenablage, Drag-and-Drop), aber nicht blocker für den Start.
5.  **`novade-system/src/compositor/xdg_decoration.rs`**: Abhängig von der Entscheidung über SSD vs. CSD; kann später implementiert werden, wenn CSD der Standard ist.
6.  **`novade-system/src/compositor/shell_manager.rs`**: Aggregator, sollte nach den einzelnen Shell-Modulen implementiert werden.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/compositor` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/input` Verzeichnisses.
### **novade-system/src/input/mod.rs**

**Verantwortlichkeit:**
Das `input` Modul in der Systemschicht ist der zentrale Aggregator und Koordinator für alle Eingabegeräte und deren Ereignisse. Es ist für die Initialisierung von `libinput`-Backends, die Integration von `xkbcommon` für Tastatur-Layouts und die Weiterleitung verarbeiteter Eingabeereignisse an die `InputService` der Domänenschicht sowie direkt an den Compositor verantwortlich.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/input/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `device_manager.rs` (Verwaltung von libinput-Geräten)
    * `keyboard.rs` (xkbcommon-Integration und Tastaturereignis-Verarbeitung)
    * `pointer.rs` (Maus- und Touchpad-Ereignis-Verarbeitung)
    * `touch.rs` (Touchscreen-Ereignis-Verarbeitung und Gesten-Erkennung)
    * `events.rs` (Definiert interne Eingabe-Event-Typen)
    * `error.rs` (Fehlerbehandlung für die Eingabeschicht)
    * `service.rs` (Implementierung des `InputService` Trait der Domänenschicht)
    * `data_types.rs` (Datentypen für Eingabegeräte und -zustände)

**Kern-Aufgaben (Tasks):**

1.  **`InputService` Trait Implementierung:**
    * Die Implementierung des `novade_domain::input::service::InputService` Trait wird hier im `service.rs` Modul erfolgen, aber `mod.rs` wird dies re-exportieren und initialisieren.

2.  **Initialisierung der Eingabegeräte:**
    * `pub async fn initialize_input(compositor_state_handle: Arc<RwLock<NovaCompositorState>>, event_bus: EventBus) -> Result<Arc<InputService>, InputError>`
    * **Logik:**
        * Erstellt eine `libinput` Kontext.
        * Erstellt und initialisiert `device_manager::DeviceManager`.
        * Initialisiert `keyboard::KeyboardManager` mit `xkbcommon` Kontext.
        * Initialisiert `pointer::PointerManager` und `touch::TouchManager`.
        * Startet den Event-Loop des `libinput`-Kontextes in einem separaten Tokio-Task, um blockierende Aufrufe zu vermeiden.
        * Dieser Task liest kontinuierlich `libinput` Events und leitet sie an die entsprechenden Handler in `device_manager`, `keyboard`, `pointer` und `touch` weiter.
        * Erstellt eine Instanz von `InputService` (aus `service.rs`) und gibt diese zurück.

3.  **Zentrale Event-Verteilung:**
    * Das `mod.rs` oder ein Submodul fungiert als Verteiler:
        * Empfängt rohe `libinput` Events.
        * Übersetzt sie in interne, hochrangigere Events (`input::events::InputEvent`).
        * Sendet diese Events:
            * An den `InputService` (für globale Shortcuts, Gesten, etc.).
            * An den `NovaCompositorState` (`compositor::input_handler`) für direkte Compositor-Aktionen (Fenster-Fokus, Grab-States, etc.).
        * Die Unterscheidung, ob ein Event an den Compositor oder den `InputService` geht, ist entscheidend. Compositor-kritische Events (wie Tastendrücke auf fokussiertem Fenster, Mausbewegungen für Drag/Resize) gehen direkt an den Compositor. Globale Gesten oder systemweite Shortcuts gehen an den `InputService`.

4.  **Sitzungsmanagement (Seat):**
    * Das `compositor::seat` Modul ist für die Wayland-Seite des Seats zuständig.
    * Das `input` Modul ist für die `libinput`-Seite zuständig, d.h. es fügt Geräte zum Seat hinzu und entfernt sie.
    * **Integration:** Wenn `new_input` oder `seat_removed` in `compositor::seat` aufgerufen werden, sollte der `InputService` informiert werden, um den internen Zustand zu aktualisieren.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/mod.rs`
* `novade-system/src/input/service.rs` (Implementierung des `InputService` Trait)

**Abhängigkeiten:**

* **Intern:**
    * `crate::input::device_manager`
    * `crate::input::keyboard`
    * `crate::input::pointer`
    * `crate::input::touch`
    * `crate::input::events::{InputEvent, KeyboardEvent, PointerEvent, TouchEvent}`
    * `crate::input::error::InputError`
    * `crate::input::data_types::{InputDevice, InputDeviceType, KeyboardConfig, PointerConfig}`
    * `crate::compositor::data_types::NovaCompositorState`
    * `novade_domain::input::service::InputService` (Trait)
    * `novade_domain::input::data_types::InputConfiguration`
    * `novade_core::event_bus::EventBus`
* **Extern:**
    * `libinput::{Libinput, Event, EventKind, Device as LibinputDevice}`
    * `tokio::sync::RwLock`
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `xkbcommon::xkb::Context`

**Kommunikationsmuster:**

* Empfängt Rohdaten von `libinput`.
* Delegiert die Verarbeitung an Submodule (`device_manager`, `keyboard`, `pointer`, `touch`).
* Sendet hochrangige Events an den `InputService` (Domänenschicht) für Policy-Entscheidungen und globale Aktionen.
* Sendet spezifische Compositor-Events an den `compositor::input_handler` für direkte Fenster-Manipulationen.
* Nutzung des `EventBus` für Broadcasts von `InputEvent` an abonnierende Domänen-Services.

**Erwartete Ergebnisse/Outputs:**
Ein voll funktionsfähiges Eingabesubsystem, das alle physischen Eingabegeräte erkennt, ihre Ereignisse verarbeitet, Tastaturlayouts korrekt handhabt und die verarbeiteten Events an die korrekten Ziele (Compositor oder Domänenservices) weiterleitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `libinput` (schwierig, ggf. `mock_input_backend` von Smithay nutzen).
    * Testen der Event-Weiterleitung an Submodule und Services.
    * Testen der Initialisierungslogik.
* **Integration Tests (mit `evdev` oder `udev` basierten `libinput` Simulationen):**
    * Starten des `input` Subsystems.
    * Simulieren von Tastendrücken, Mausbewegungen, Klicks etc.
    * Überprüfen, ob die richtigen Events an den `InputService` und den Compositor gesendet werden und ob die Fenster entsprechend reagieren.

**Geschätzter Aufwand:** Sehr hoch (ca. 10-15 Tage, da komplexe Interaktion mit `libinput`, `xkbcommon` und dem Compositor)

---

### **novade-system/src/input/device_manager.rs**

**Verantwortlichkeit:**
Verwaltet die Erkennung, Initialisierung und den Lebenszyklus von Eingabegeräten (`libinput` Devices). Es informiert den `InputService` und den Compositor über das Hinzufügen und Entfernen von Geräten.

**Kern-Aufgaben (Tasks):**

1.  **`DeviceManager` Struktur:**
    * `pub struct DeviceManager {`
        * `libinput_context: Libinput,`
        * `compositor_state_handle: Arc<RwLock<NovaCompositorState>>,`
        * `input_service: Arc<InputService>,`
        * `xkb_context: Arc<xkbcommon::xkb::Context>,`
        * `// ... weitere Handles zu Keyboard/Pointer/Touch-Managern`
    * `}`

2.  **`DeviceManager::new()` Funktion:**
    * `pub fn new(libinput_context: Libinput, compositor_state_handle: Arc<RwLock<NovaCompositorState>>, input_service: Arc<InputService>, xkb_context: Arc<xkbcommon::xkb::Context>) -> Self`
    * Initialisiert die Struktur.

3.  **`handle_device_event()` Funktion:**
    * `pub fn handle_device_event(&mut self, event: libinput::Event) -> Result<(), InputError>`
    * **Logik:**
        * Unterscheidet zwischen `DeviceAddedEvent` und `DeviceRemovedEvent`.
        * Bei `DeviceAddedEvent`:
            * Erstellt ein `InputDevice`-Objekt (`input::data_types::InputDevice`).
            * Informiert den `InputService` über das neue Gerät (`input_service.on_device_added(device_info)`).
            * Informiert den `compositor::seat` über das Hinzufügen des Geräts zum Wayland Seat (`compositor_state.lock().unwrap().seat_state.add_device(...)`).
            * Überprüft den Gerätetyp (`libinput::Device::device_type()`) und fügt es dem entsprechenden Sub-Manager hinzu (`keyboard::KeyboardManager`, `pointer::PointerManager`, `touch::TouchManager`).
        * Bei `DeviceRemovedEvent`:
            * Informiert den `InputService` über das Entfernen des Geräts (`input_service.on_device_removed(device_id)`).
            * Informiert den `compositor::seat` über das Entfernen (`compositor_state.lock().unwrap().seat_state.remove_device(...)`).
            * Entfernt das Gerät aus den Sub-Managern.
    * **Fehlerbehandlung:** Fehler bei der Geräteinitialisierung oder beim Zugriff auf die Services.

4.  **Iterativer Event-Loop (in `input::mod.rs`):**
    * Der `libinput` Event-Loop wird im `input::mod.rs` gestartet.
    * Jedes rohe `libinput::Event` wird dann an die `handle_device_event()` Funktion des `DeviceManager` gesendet, der es weiterleitet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/device_manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input::error::InputError`
    * `crate::input::data_types::{InputDevice, InputDeviceType}`
    * `crate::input::keyboard`
    * `crate::input::pointer`
    * `crate::input::touch`
    * `crate::compositor::data_types::NovaCompositorState`
    * `novade_domain::input::service::InputService` (Trait)
* **Extern:**
    * `libinput::{Libinput, Event, EventKind, Device as LibinputDevice, EventDevice}`
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `tracing`
    * `xkbcommon::xkb::Context`

**Kommunikationsmuster:**

* Empfängt `libinput::Event` für Geräte-Hinzufügen/Entfernen.
* Informiert den `InputService` der Domänenschicht über Änderungen der Geräteliste.
* Informiert den `compositor::seat` über Änderungen am Wayland Seat.
* Delegiert die detaillierte Event-Verarbeitung an die Submodule (`keyboard`, `pointer`, `touch`).

**Erwartete Ergebnisse/Outputs:**
Ein robustes System zur dynamischen Erkennung und Verwaltung von Eingabegeräten.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `Libinput`, `NovaCompositorState` und `InputService`.
    * Testen der `handle_device_event()` Funktion für `DeviceAddedEvent` und `DeviceRemovedEvent`.
    * Überprüfen, ob die korrekten Methoden auf gemockten Services aufgerufen werden.
* **Integration Tests (mit `libinput-debug-events` oder simulierten `evdev` Geräten):**
    * Starten des `DeviceManager` als Teil des Input-Subsystems.
    * Physisches Hinzufügen/Entfernen von Geräten (USB-Maus/-Tastatur) und Beobachten der Log-Ausgaben und des Systemzustands.

**Geschätzter Aufwand:** Mittel (ca. 3-4 Tage, da Verwaltung von externen Geräten und Integration mit Kern-Services)

---

### **novade-system/src/input/keyboard.rs**

**Verantwortlichkeit:**
Verarbeitet Tastaturereignisse, wendet `xkbcommon`-Layouts an, verwaltet den Tastaturzustand und leitet die verarbeiteten Ereignisse an den `input_handler` des Compositors und den `InputService` der Domänenschicht weiter.

**Kern-Aufgaben (Tasks):**

1.  **`KeyboardManager` Struktur:**
    * `pub struct KeyboardManager {`
        * `xkb_state: xkbcommon::xkb::State,`
        * `xkb_context: Arc<xkbcommon::xkb::Context>,`
        * `compositor_state_handle: Arc<RwLock<NovaCompositorState>>,`
        * `input_service: Arc<InputService>,`
        * `current_modifiers: ModifiersState,` // Aktueller Zustand der Modifier-Tasten
        * `active_layout: String,` // Name des aktiven Tastatur-Layouts
        * `// ... weitere Zustände für Wiederholraten, etc.`
    * `}`

2.  **`KeyboardManager::new()` Funktion:**
    * `pub fn new(xkb_context: Arc<xkbcommon::xkb::Context>, compositor_state_handle: Arc<RwLock<NovaCompositorState>>, input_service: Arc<InputService>, config: KeyboardConfig) -> Result<Self, InputError>`
    * **Logik:**
        * Erstellt eine `xkbcommon::xkb::Keymap` basierend auf der initialen `KeyboardConfig` (Layout, Variant, Options, Rules).
        * Erstellt eine `xkbcommon::xkb::State` aus der `Keymap`.
        * Initialisiert `current_modifiers`.
        * Setzt die initiale Layout-Variante.
    * **Fehlerbehandlung:** Wenn Keymap nicht geladen werden kann.

3.  **`handle_keyboard_event()` Funktion:**
    * `pub fn handle_keyboard_event(&mut self, event: libinput::EventKeyboard) -> Result<(), InputError>`
    * **Logik:**
        * Nutzt `xkb_state.update_key(...)` um den Tastaturzustand zu aktualisieren.
        * Aktualisiert `current_modifiers` basierend auf dem `xkb_state`.
        * Konvertiert den `libinput` Scancode in ein `Keysym` mit `xkb_state.key_get_syms(...)`.
        * Erstellt ein `KeyboardEvent` (`input::events::KeyboardEvent`).
        * **Priorisierung der Event-Verarbeitung:**
            * Zuerst: Globale Shortcuts (z.B. `Super+Space` für Command Palette)
                * Ruft `input_service.process_keyboard_event(event)` auf.
                * Wenn der `InputService` das Event konsumiert, wird es nicht weitergeleitet.
            * Zweitens: Compositor-spezifische Shortcuts (z.B. `Super+Q` für Fenster schließen)
                * Ruft `compositor::input_handler::handle_keyboard_key()` auf.
            * Drittens: Weiterleitung an das fokussierte Client-Fenster (via `compositor::seat::keyboard_mut().input()`).
        * Sendet `KeyEvent` an den Wayland `seat_state` des Compositors.
    * **Fehlerbehandlung:** Wenn `xkb_state` inkonsistent ist oder Weiterleitung fehlschlägt.

4.  **`set_keyboard_layout()` Funktion:**
    * `pub fn set_keyboard_layout(&mut self, layout_name: String) -> Result<(), InputError>`
    * **Logik:**
        * Erstellt eine neue `Keymap` mit dem gewünschten Layout.
        * Erstellt eine neue `xkb_state` aus der neuen `Keymap`.
        * Aktualisiert `active_layout`.
        * Benachrichtigt `input_service` und `desktop_state_service` über Layout-Änderung.

5.  **`get_keyboard_state()` Funktion:**
    * `pub fn get_keyboard_state(&self) -> KeyboardState`
    * Gibt den aktuellen Tastaturzustand (Layout, Modifier) zurück.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/keyboard.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input::error::InputError`
    * `crate::input::events::KeyboardEvent`
    * `crate::input::data_types::KeyboardConfig`
    * `crate::compositor::data_types::NovaCompositorState`
    * `crate::compositor::input_handler`
    * `novade_domain::input::service::InputService` (Trait)
    * `novade_domain::desktop_state::service::DesktopStateService`
    * `novade_core::types::input::{ModifiersState, KeyState}`
* **Extern:**
    * `libinput::EventKeyboard`
    * `xkbcommon::xkb::{Context, Keymap, State, Keysym, MOD_INDEX_SHIFT}`
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `tracing`

**Kommunikationsmuster:**

* Empfängt rohe Tastaturereignisse vom `DeviceManager`.
* Verarbeitet sie mit `xkbcommon`.
* Delegiert Events an `input_handler` (Compositor) und `InputService` (Domäne).
* Stellt Methoden zur Abfrage/Änderung des Tastatur-Layouts bereit, die vom `InputService` oder `SettingsService` aufgerufen werden können.

**Erwartete Ergebnisse/Outputs:**
Ein präzises und reaktionsschnelles Tastatur-Subsystem, das korrekt auf verschiedene Tastaturlayouts reagiert und sowohl globale als auch anwendungsspezifische Eingaben verarbeitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `xkbcommon::xkb::State`, `NovaCompositorState` und `InputService`.
    * Testen der `handle_keyboard_event()` für verschiedene Tastendrücke und Modifier-Kombinationen.
    * Überprüfen, ob die korrekten `KeyEvent` an den Compositor und `InputService` gesendet werden.
    * Testen von `set_keyboard_layout()` und `get_keyboard_state()`.
* **Integration Tests (mit `libinput-debug-events` oder simulierten Tastaturen):**
    * Starten des Compositors und des Keyboard-Managers.
    * Physisches Tippen und Überprüfen der Reaktion von Anwendungen und des Compositors.
    * Wechseln des Tastatur-Layouts zur Laufzeit und Verifizieren der Änderungen.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage, da komplexe xkbcommon-Integration und Event-Priorisierung)

---

### **novade-system/src/input/pointer.rs**

**Verantwortlichkeit:**
Verarbeitet Maus- und Touchpad-Ereignisse (Bewegung, Klicks, Scrollen), verwaltet den Pointer-Zustand und leitet die verarbeiteten Ereignisse an den `input_handler` des Compositors und den `InputService` der Domänenschicht weiter.

**Kern-Aufgaben (Tasks):**

1.  **`PointerManager` Struktur:**
    * `pub struct PointerManager {`
        * `compositor_state_handle: Arc<RwLock<NovaCompositorState>>,`
        * `input_service: Arc<InputService>,`
        * `cursor_position: Point<f64, Physical>,` // Aktuelle Cursorposition
        * `button_state: ButtonState,` // Aktueller Zustand der Maustasten
        * `// ... weitere Zustände für Empfindlichkeit, Beschleunigung, etc.`
    * `}`

2.  **`PointerManager::new()` Funktion:**
    * `pub fn new(compositor_state_handle: Arc<RwLock<NovaCompositorState>>, input_service: Arc<InputService>, config: PointerConfig) -> Self`
    * Initialisiert die Struktur und wendet initiale Konfiguration an (z.B. Empfindlichkeit).

3.  **`handle_pointer_event()` Funktion:**
    * `pub fn handle_pointer_event(&mut self, event: libinput::EventPointer) -> Result<(), InputError>`
    * **Logik:**
        * Unterscheidet nach `libinput` Event-Typen: `MotionEvent`, `ButtonEvent`, `AxisEvent`.
        * Bei `MotionEvent`:
            * Aktualisiert `cursor_position` basierend auf `event.delta()`.
            * Ruft `compositor::input_handler::handle_pointer_motion()` auf.
            * Ruft `input_service.process_pointer_event(event)` auf (für Gesten oder globale Trigger).
        * Bei `ButtonEvent`:
            * Aktualisiert `button_state`.
            * Ruft `compositor::input_handler::handle_pointer_button()` auf.
            * Ruft `input_service.process_pointer_event(event)` auf.
        * Bei `AxisEvent` (Scrollen):
            * Leitet an `compositor::seat::pointer_mut().axis()` weiter.
            * Ruft `input_service.process_pointer_event(event)` auf.
        * Sendet `MotionEvent`, `ButtonEvent`, `AxisEvent` an den Wayland `seat_state` des Compositors.
    * **Fehlerbehandlung:** Wenn Weiterleitung fehlschlägt.

4.  **`set_pointer_sensitivity()` Funktion:**
    * `pub fn set_pointer_sensitivity(&mut self, sensitivity: f64) -> Result<(), InputError>`
    * Wendet die Empfindlichkeit auf die zugrunde liegende `libinput` Konfiguration an.
    * Informiert den `InputService` über die Änderung.

5.  **`get_pointer_state()` Funktion:**
    * `pub fn get_pointer_state(&self) -> PointerState`
    * Gibt den aktuellen Pointer-Zustand (Position, Tasten) zurück.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/pointer.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input::error::InputError`
    * `crate::input::events::PointerEvent`
    * `crate::input::data_types::{PointerConfig, ButtonState, PointerState}`
    * `crate::compositor::data_types::NovaCompositorState`
    * `crate::compositor::input_handler`
    * `novade_domain::input::service::InputService` (Trait)
    * `novade_core::types::geometry::{Point, Physical}`
* **Extern:**
    * `libinput::{EventPointer, EventPointerMotion, EventPointerButton, EventPointerAxis}`
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `tracing`

**Kommunikationsmuster:**

* Empfängt rohe Pointer-Ereignisse vom `DeviceManager`.
* Delegiert Events an `input_handler` (Compositor) und `InputService` (Domäne).
* Stellt Methoden zur Abfrage/Änderung der Pointer-Konfiguration bereit.

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschnelles und konfigurierbares Maus- und Touchpad-Subsystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NovaCompositorState` und `InputService`.
    * Testen der `handle_pointer_event()` für Bewegung, Klicks und Scrollen.
    * Überprüfen, ob die korrekten Events an den Compositor und `InputService` gesendet werden.
    * Testen von `set_pointer_sensitivity()`.
* **Integration Tests (mit `libinput-debug-events` oder simulierten Mäusen/Touchpads):**
    * Starten des Compositors und des Pointer-Managers.
    * Physisches Bewegen der Maus/Touchpad, Klicks und Scrollen und Beobachten der Reaktion von Anwendungen und des Compositors.

**Geschätzter Aufwand:** Mittel (ca. 4-6 Tage, da Interaktion mit Compositor-Logik wie Grabs)

---

### **novade-system/src/input/touch.rs**

**Verantwortlichkeit:**
Verarbeitet Touchscreen-Ereignisse und ist für die Erkennung grundlegender Gesten (z.B. Pinch-to-Zoom, Swipe für Workspace-Wechsel) zuständig. Leitet diese Events an den `input_handler` des Compositors und den `InputService` der Domänenschicht weiter.

**Kern-Aufgaben (Tasks):**

1.  **`TouchManager` Struktur:**
    * `pub struct TouchManager {`
        * `compositor_state_handle: Arc<RwLock<NovaCompositorState>>,`
        * `input_service: Arc<InputService>,`
        * `active_touches: HashMap<i32, Point<f64, Physical>>,` // Touch-ID zu Position-Mapping
        * `gesture_recognizer: GestureRecognizer,` // Separate Struktur für Gesten-Logik
        * `// ... weitere Zustände für Touch-Kalibrierung, etc.`
    * `}`

2.  **`TouchManager::new()` Funktion:**
    * `pub fn new(compositor_state_handle: Arc<RwLock<NovaCompositorState>>, input_service: Arc<InputService>, config: TouchConfig) -> Self`
    * Initialisiert die Struktur und den `GestureRecognizer`.

3.  **`handle_touch_event()` Funktion:**
    * `pub fn handle_touch_event(&mut self, event: libinput::EventTouch) -> Result<(), InputError>`
    * **Logik:**
        * Unterscheidet nach `libinput` Event-Typen: `EventTouchDown`, `EventTouchUp`, `EventTouchMotion`, `EventTouchCancel`.
        * Bei `EventTouchDown`:
            * Speichert die Touch-ID und Position in `active_touches`.
            * Leitet Event an `compositor::input_handler::handle_touch_event()` weiter.
            * Führt `gesture_recognizer.on_touch_down()` aus.
        * Bei `EventTouchUp`:
            * Entfernt die Touch-ID aus `active_touches`.
            * Leitet Event an `compositor::input_handler::handle_touch_event()` weiter.
            * Führt `gesture_recognizer.on_touch_up()` aus.
        * Bei `EventTouchMotion`:
            * Aktualisiert die Position in `active_touches`.
            * Leitet Event an `compositor::input_handler::handle_touch_event()` weiter.
            * Führt `gesture_recognizer.on_touch_motion()` aus.
        * Bei `EventTouchCancel`:
            * Löscht `active_touches`.
            * Leitet Event an `compositor::input_handler::handle_touch_event()` weiter.
            * Führt `gesture_recognizer.on_touch_cancel()` aus.
        * Sendet Wayland `TouchEvent` an den `seat_state` des Compositors.
        * Prüft `gesture_recognizer` auf erkannte Gesten und sendet diese an `input_service.process_gesture_event()`.

4.  **`GestureRecognizer` Struktur/Trait:**
    * Eine interne Helferstruktur oder ein Trait, das die Logik für die Erkennung von Multi-Touch-Gesten kapselt (z.B. `libinput::Gesture`).
    * Implementiert Methoden wie `on_touch_down`, `on_touch_up`, `on_touch_motion`, die den Zustand der Gestenerkennung aktualisieren und bei Erfolg ein `GestureEvent` (z.B. `Pinch`, `Swipe`) erzeugen.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/touch.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input::error::InputError`
    * `crate::input::events::{TouchEvent, GestureEvent}`
    * `crate::input::data_types::TouchConfig`
    * `crate::compositor::data_types::NovaCompositorState`
    * `crate::compositor::input_handler`
    * `novade_domain::input::service::InputService` (Trait)
    * `novade_core::types::geometry::{Point, Physical}`
* **Extern:**
    * `libinput::{EventTouch, EventTouchDown, EventTouchUp, EventTouchMotion, EventTouchCancel}`
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `tracing`
    * `std::collections::HashMap`

**Kommunikationsmuster:**

* Empfängt rohe Touch-Ereignisse vom `DeviceManager`.
* Verarbeitet diese und erkennt Gesten.
* Delegiert rohe Touch-Events an `input_handler` (Compositor) und hochrangige `GestureEvent` an `InputService` (Domäne).

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschnelles Touchscreen-Subsystem, das sowohl direkte Touch-Eingaben als auch komplexe Multi-Touch-Gesten verarbeitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NovaCompositorState` und `InputService`.
    * Testen der `handle_touch_event()` für verschiedene Touch-Ereignisse (Down, Up, Motion, Cancel).
    * Testen der `GestureRecognizer` für verschiedene Gesten-Sequenzen (z.B. simulierte Pinch-Geste).
    * Überprüfen, ob die korrekten Events an den Compositor und `InputService` gesendet werden.
* **Integration Tests (mit Touchscreen-Hardware oder simulierten `evdev` Touch-Eingaben):**
    * Starten des Compositors und des Touch-Managers.
    * Physisches Berühren des Bildschirms mit einzelnen Fingern oder Multi-Touch-Gesten und Beobachten der Reaktion von Anwendungen und des Compositors (z.B. Workspace-Wechsel bei Swipe).

**Geschätzter Aufwand:** Hoch (ca. 6-9 Tage, da Gestenerkennung komplex sein kann)

---

### **novade-system/src/input/events.rs**

**Verantwortlichkeit:**
Definiert die hochrangigen, abstrakten Eingabeereignis-Typen, die innerhalb der `input` Systemschicht und zur Kommunikation mit der Domänenschicht verwendet werden. Dies entkoppelt die Domänenschicht von den `libinput`-spezifischen Details.

**Kern-Aufgaben (Tasks):**

1.  **`InputEvent` Enum:**
    * `pub enum InputEvent {`
        * `Keyboard(KeyboardEvent),`
        * `Pointer(PointerEvent),`
        * `Touch(TouchEvent),`
        * `Gesture(GestureEvent),`
        * `Device(DeviceEvent),`
    * `}`
    * Implementiere `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`.

2.  **`KeyboardEvent` Enum:**
    * `pub enum KeyboardEvent {`
        * `KeyPressed { key_code: u32, key_state: KeyState, sym: Keysym, modifiers: ModifiersState },`
        * `KeyReleased { key_code: u32, key_state: KeyState, sym: Keysym, modifiers: ModifiersState },`
        * `// ... weitere spezifische Tastaturereignisse (z.B. Repeat)`
    * `}`
    * Implementiere `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`.

3.  **`PointerEvent` Enum:**
    * `pub enum PointerEvent {`
        * `Motion { delta_x: f64, delta_y: f64, position: Point<f64, Physical> },`
        * `Button { button_code: u32, button_state: ButtonState, position: Point<f64, Physical> },`
        * `Axis { source: AxisSource, axis: Axis, delta: f64 },`
    * `}`
    * Implementiere `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`.

4.  **`TouchEvent` Enum:**
    * `pub enum TouchEvent {`
        * `Down { touch_id: i32, position: Point<f64, Physical> },`
        * `Up { touch_id: i32 },`
        * `Motion { touch_id: i32, position: Point<f64, Physical> },`
        * `Cancel,`
    * `}`
    * Implementiere `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`.

5.  **`GestureEvent` Enum:**
    * `pub enum GestureEvent {`
        * `PinchStart { fingers: i32, position: Point<f64, Physical> },`
        * `PinchUpdate { fingers: i32, delta_scale: f64, delta_angle: f64, delta_x: f64, delta_y: f64 },`
        * `PinchEnd { fingers: i32, cancelled: bool },`
        * `SwipeStart { fingers: i32, position: Point<f64, Physical> },`
        * `SwipeUpdate { fingers: i32, delta_x: f64, delta_y: f64 },`
        * `SwipeEnd { fingers: i32, cancelled: bool },`
        * `// ... weitere Gesten (z.B. hold, tap)`
    * `}`
    * Implementiere `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`.

6.  **`DeviceEvent` Enum:**
    * `pub enum DeviceEvent {`
        * `DeviceAdded { device_id: String, device_type: InputDeviceType, name: String },`
        * `DeviceRemoved { device_id: String },`
    * `}`
    * Implementiere `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/events.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input::data_types::{InputDeviceType, ButtonState}`
    * `novade_core::types::input::{ModifiersState, KeyState, AxisSource, Axis}`
    * `novade_core::types::geometry::{Point, Physical}`
* **Extern:**
    * `xkbcommon::xkb::Keysym`

**Kommunikationsmuster:**

* Diese Events werden vom `input::mod.rs` (und seinen Submodulen) erstellt und an den `InputService` (Domänenschicht) über den Event-Bus gesendet.
* Sie werden auch intern zwischen den `input` Submodulen verwendet.

**Erwartete Ergebnisse/Outputs:**
Ein klares und erweiterbares Set von Event-Definitionen, das die Schnittstelle zwischen der Eingabeverarbeitung auf Systemebene und der Domänenlogik bildet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Event-Variante mit verschiedenen Daten.
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` Implementierungen.
    * Sicherstellen, dass alle Felder korrekt abgebildet werden.

**Geschätzter Aufwand:** Niedrig (ca. 1-2 Tage, hauptsächlich Definitionen)

---

### **novade-system/src/input/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `input` Subsystem der Systemschicht. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation.

**Kern-Aufgaben (Tasks):**

1.  **`InputError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum InputError {`
        * `#[error("Failed to initialize libinput context: {0}")]`
        * `LibinputInitError(#[from] libinput::LibinputError),`
        * `#[error("Failed to create xkbcommon keymap: {0}")]`
        * `XkbcommonError(String),`
        * `#[error("Device not found: {0}")]`
        * `DeviceNotFound(String),`
        * `#[error("Invalid input configuration: {0}")]`
        * `InvalidConfiguration(String),`
        * `#[error("Failed to send event to compositor: {0}")]`
        * `CompositorEventSendError(String),` // Kann spezifischer gemacht werden, z.B. Tokio-Fehler
        * `#[error("Service communication error: {0}")]`
        * `ServiceCommunicationError(String),` // Z.B. wenn Arc::try_lock fehlschlägt
        * `#[error("Unknown input error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für häufige Fehlerquellen (`libinput::LibinputError`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `libinput::LibinputError`
    * `anyhow::Error` (für generische Fehler-Wrapper)

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `input` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an den aufrufenden `CompositorService` oder die Top-Level-Anwendung propagiert, um dort geloggt oder dem Benutzer angezeigt zu werden.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Eingabesubsystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/input/service.rs**

**Verantwortlichkeit:**
Implementiert den `InputService` Trait, der in `novade-domain::input::service::InputService` definiert ist. Diese Implementierung ist die Brücke zwischen den rohen und verarbeiteten Eingabeereignissen der Systemschicht und der Business-Logik der Domänenschicht.

**Kern-Aufgaben (Tasks):**

1.  **`InputServiceImpl` Struktur:**
    * `pub struct InputServiceImpl {`
        * `desktop_state_service: Arc<DesktopStateService>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `// ... weitere Abhängigkeiten zu Services der Domänenschicht, z.B. CommandPaletteService`
    * `}`
    * Diese Struktur ist die konkrete Implementierung des `InputService` Traits.

2.  **`InputServiceImpl::new()` Funktion:**
    * `pub fn new(desktop_state_service: Arc<DesktopStateService>, config_service: Arc<ConfigService>, event_bus: EventBus) -> Arc<Self>`
    * Konstruktor zur Initialisierung der Service-Abhängigkeiten.

3.  **`InputService` Trait Implementierung für `InputServiceImpl`:**
    * `impl InputService for InputServiceImpl {`
    * **`process_keyboard_event(&self, event: &KeyboardEvent) -> Result<EventProcessingResult, InputError>`:**
        * **Logik:**
            * Prüft, ob das Event eine globale Tastenkombination ist (z.B. `Super+Space` für Command Palette, `Super+Tab` für Workspace-Wechsel, `PrtSc` für Screenshot).
            * Greift auf den `config_service` zu, um konfigurierte Tastenkombinationen zu laden.
            * Bei Erkennung einer Tastenkombination:
                * Ruft die entsprechende Methode auf `desktop_state_service` (z.B. `switch_workspace()`) oder `command_palette_service` (z.B. `open_command_palette()`) auf.
                * Sendet ein Event über den `event_bus` (z.B. `SystemEvent::ScreenshotRequested`).
                * Gibt `EventProcessingResult::Consumed` zurück, wenn der Shortcut verarbeitet wurde.
            * Wenn es keine globale Tastenkombination ist, gibt `EventProcessingResult::Unconsumed` zurück.
        * **Fehlerbehandlung:** Wenn Service-Aufrufe fehlschlagen oder Konfiguration nicht geladen werden kann.
    * **`process_pointer_event(&self, event: &PointerEvent) -> Result<EventProcessingResult, InputError>`:**
        * **Logik:**
            * Prüft auf spezifische Mausgesten (z.B. Mittelklick für Paste) oder globale Klick-Trigger.
            * Gibt `EventProcessingResult::Consumed` oder `Unconsumed` zurück.
    * **`process_gesture_event(&self, event: &GestureEvent) -> Result<EventProcessingResult, InputError>`:**
        * **Logik:**
            * Prüft auf erkannte Gesten (z.B. 4-Finger-Swipe für Workspace-Wechsel, Pinch-to-Zoom für Desktop-Zoom).
            * Ruft die entsprechende Methode auf `desktop_state_service` auf.
            * Gibt `EventProcessingResult::Consumed` oder `Unconsumed` zurück.
    * **`on_device_added(&self, device: &InputDevice) -> Result<(), InputError>`:**
        * **Logik:**
            * Loggt das Hinzufügen des Geräts.
            * Informiert ggf. andere Domänen-Services oder die UI über das neue Gerät.
            * Sendet `SystemEvent::InputDeviceAdded` über den Event-Bus.
    * **`on_device_removed(&self, device_id: &str) -> Result<(), InputError>`:**
        * **Logik:**
            * Loggt das Entfernen des Geräts.
            * Informiert andere Services.
            * Sendet `SystemEvent::InputDeviceRemoved` über den Event-Bus.
    * **`get_connected_devices(&self) -> Result<Vec<InputDevice>, InputError>`:**
        * **Logik:**
            * Fragt den `DeviceManager` nach der aktuellen Liste der verbundenen Geräte ab.
    * **`get_keyboard_configuration(&self) -> Result<KeyboardConfig, InputError>`:**
        * **Logik:**
            * Fragt den `keyboard` Manager nach der aktuellen Konfiguration.
    * **`set_keyboard_configuration(&self, config: KeyboardConfig) -> Result<(), InputError>`:**
        * **Logik:**
            * Weist den `keyboard` Manager an, die Konfiguration zu ändern.
            * Aktualisiert die persistente Konfiguration über `ConfigService`.
    * **`get_pointer_configuration(&self) -> Result<PointerConfig, InputError>`:**
        * Fragt den `pointer` Manager ab.
    * **`set_pointer_configuration(&self, config: PointerConfig) -> Result<(), InputError>`:**
        * Weist den `pointer` Manager an, die Konfiguration zu ändern.
        * Aktualisiert die persistente Konfiguration.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/service.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input::error::InputError`
    * `crate::input::events::{KeyboardEvent, PointerEvent, GestureEvent, DeviceEvent}`
    * `crate::input::data_types::{InputDevice, KeyboardConfig, PointerConfig}`
    * `crate::input::keyboard` (direkte Methodenaufrufe)
    * `crate::input::pointer` (direkte Methodenaufrufe)
    * `crate::input::touch` (direkte Methodenaufrufe)
* **Extern:**
    * `novade_domain::input::service::{InputService, EventProcessingResult}` (Trait)
    * `novade_domain::desktop_state::service::DesktopStateService`
    * `novade_domain::config::service::ConfigService`
    * `novade_domain::command_palette::service::CommandPaletteService` (falls existiert)
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
    * `tokio::sync::broadcast::Sender` (für `EventBus`)
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Implementiert die Schnittstelle zur Domänenschicht.
* Empfängt verarbeitete Events von den `input` Submodulen.
* Sendet Aktionen an andere Domänen-Services (`DesktopStateService`, `CommandPaletteService`).
* Broadcastet `SystemEvent` über den Event-Bus an abonnierende Services (z.B. UI für Status-Updates).
* Ruft Methoden auf den konkreten `keyboard`, `pointer`, `touch` Managern auf, um Konfigurationen zu setzen.

**Erwartete Ergebnisse/Outputs:**
Eine zentrale Steuerung für alle Eingabe-bezogenen Domänen-Logik, die globale Shortcuts, Gesten und Gerätekonfigurationen handhabt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken aller abhängigen Services (`DesktopStateService`, `ConfigService`, `keyboard`, `pointer`, `touch` Manager).
    * Testen von `process_keyboard_event()` für verschiedene Shortcuts, Überprüfen, ob die korrekten Service-Methoden aufgerufen werden und das korrekte `EventProcessingResult` zurückgegeben wird.
    * Ähnliche Tests für `process_pointer_event()` und `process_gesture_event()`.
    * Testen von `on_device_added()` und `on_device_removed()`, Überprüfen der Event-Bus-Broadcasts.
    * Testen der Konfigurations-Methoden (`set_keyboard_configuration`, etc.).
* **Integration Tests:**
    * Im Rahmen des gesamten Input-Subsystems und der Compositor-Integration.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da komplexe Entscheidungslogik für Shortcuts und Gesten)

---

### **novade-system/src/input/data_types.rs**

**Verantwortlichkeit:**
Definiert Datentypen, die innerhalb des `input` Subsystems der Systemschicht verwendet werden, um Eingabegeräte und deren Konfiguration zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`InputDeviceType` Enum:**
    * `pub enum InputDeviceType {`
        * `Keyboard,`
        * `Pointer,`
        * `Touch,`
        * `Tablet,`
        * `Gesture,`
        * `Switch,`
        * `Unknown,`
    * `}`
    * Implementiere `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.

2.  **`InputDevice` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]`
    * `pub struct InputDevice {`
        * `pub id: String,` // Eindeutige ID des Geräts (z.B. syspath oder libinput.id)
        * `pub name: String,`
        * `pub device_type: InputDeviceType,`
        * `pub vendor_id: u32,`
        * `pub product_id: u32,`
        * `// ... weitere Metadaten (z.B. Bus, Physikalische Eigenschaften)`
    * `}`
    * Implementiere `new()`-Funktion.

3.  **`KeyboardConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]`
    * `pub struct KeyboardConfig {`
        * `pub layout: String,` // z.B. "de", "us"
        * `pub variant: Option<String>,` // z.B. "neo"
        * `pub options: Option<String>,` // z.B. "caps:swapescape"
        * `pub rules: Option<String>,` // z.B. "evdev"
        * `pub model: Option<String>,` // z.B. "pc105"
        * `pub repeat_rate: u32,` // in Hz
        * `pub repeat_delay: u32,` // in ms
    * `}`
    * Implementiere `Default`, `new()`-Funktion.

4.  **`PointerConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]`
    * `pub struct PointerConfig {`
        * `pub sensitivity: f64,` // Beschleunigung/Empfindlichkeit
        * `pub natural_scrolling: bool,`
        * `pub tap_to_click: bool,` // Nur für Touchpads
        * `pub scroll_method: ScrollMethod,` // Für Touchpads (z.B. "two-finger", "edge")
        * `// ... weitere Pointer-spezifische Einstellungen`
    * `}`
    * Implementiere `Default`, `new()`-Funktion.

5.  **`TouchConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]`
    * `pub struct TouchConfig {`
        * `pub enabled: bool,`
        * `pub calibration_matrix: Option<[f64; 6]>,`
        * `// ... weitere Touch-spezifische Einstellungen`
    * `}`
    * Implementiere `Default`, `new()`-Funktion.

6.  **`ScrollMethod` Enum (Helper for PointerConfig):**
    * `pub enum ScrollMethod {`
        * `None,`
        * `TwoFinger,`
        * `Edge,`
        * `OnButtonDown,`
    * `}`
    * Implementiere `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`.

7.  **`ButtonState` Enum (Helper for PointerEvent):**
    * `pub enum ButtonState {`
        * `Pressed,`
        * `Released,`
    * `}`
    * Implementiere `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`.

8.  **`PointerState` Struct (Helper for `get_pointer_state`):**
    * `pub struct PointerState {`
        * `pub position: Point<f64, Physical>,`
        * `pub button_state: ButtonState,`
    * `}`
    * Implementiere `Debug`, `Clone`, `PartialEq`, `Eq`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `novade_core::types::geometry::{Point, Physical}`

**Kommunikationsmuster:**

* Diese Strukturen werden von den `input` Submodulen verwendet, um Gerätedaten und Konfigurationen zu übergeben.
* Sie werden vom `InputService` verwendet, um Konfigurationen an die Domänenschicht zu kommunizieren und von dort zu empfangen.

**Erwartete Ergebnisse/Outputs:**
Ein klares und konsistentes Set von Datentypen, das die Struktur und Konfiguration von Eingabegeräten innerhalb von NovaDE repräsentiert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `Default` Implementierungen für alle Konfigurationsstrukturen.
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` Implementierungen für alle Typen.
    * Testen der Serialisierung und Deserialisierung (z.B. zu/von JSON) für alle Strukturen, um die Korrektheit der Datenpersistenz zu gewährleisten.

**Geschätzter Aufwand:** Niedrig (ca. 1-2 Tage, hauptsächlich Definitionen)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nachdem die `compositor`-Module abgeschlossen wurden, fokussieren wir uns auf `input`. Die Reihenfolge innerhalb von `input` sollte wie folgt sein:

1.  **`novade-system/src/input/data_types.rs`**: Definitionen sollten immer zuerst kommen, da sie von allen anderen Modulen abhängen.
2.  **`novade-system/src/input/error.rs`**: Fehlerdefinitionen sind grundlegend für die Fehlerbehandlung in allen anderen Modulen.
3.  **`novade-system/src/input/events.rs`**: Die Event-Definitionen sind die Kommunikationsbasis.
4.  **`novade-system/src/input/keyboard.rs`**: Tastatureingabe ist grundlegend und komplex aufgrund von `xkbcommon`.
5.  **`novade-system/src/input/pointer.rs`**: Maus/Touchpad-Eingabe, ebenfalls grundlegend.
6.  **`novade-system/src/input/touch.rs`**: Touch und Gestenerkennung, baut auf grundlegenden Input-Konzepten auf.
7.  **`novade-system/src/input/device_manager.rs`**: Orchestriert die Geräteerkennung und leitet an die spezifischen Manager weiter.
8.  **`novade-system/src/input/service.rs`**: Implementiert das Domänen-Service-Trait und ist der zentrale Punkt für die Geschäftslogik der Eingabe.
9.  **`novade-system/src/input/mod.rs`**: Der Modul-Root, der alles initialisiert und orchestriert, sollte zuletzt implementiert werden, da er von allen Submodulen abhängt.

Dies schließt die detaillierte Spezifikation des `novade-system/src/input` Verzeichnisses ab. Der nächste Schritt wäre die Dekomposition des `novade-system/src/dbus_interfaces` Verzeichnisses.
### **novade-system/src/dbus_interfaces/mod.rs**

**Verantwortlichkeit:**
Das `dbus_interfaces` Modul in der Systemschicht ist der zentrale Punkt für die Interaktion mit Systemdiensten über D-Bus. Es fasst die `zbus`-basierten Clients und Server für verschiedene Freedesktop- und Linux-spezifische D-Bus-APIs zusammen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/dbus_interfaces/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für D-Bus-Interaktionen)
    * `notifications_server.rs` (Implementiert den `org.freedesktop.Notifications` Server)
    * `logind_client.rs` (Client für `org.freedesktop.login1` Schnittstelle)
    * `network_manager_client.rs` (Client für `org.freedesktop.NetworkManager` Schnittstelle)
    * `upower_client.rs` (Client für `org.freedesktop.UPower` Schnittstelle)
    * `secrets_client.rs` (Client für `org.freedesktop.Secret.Service` Schnittstelle)
    * `policykit_client.rs` (Client für `org.freedesktop.PolicyKit1` Schnittstelle)
    * `portal_client.rs` (Client für ausgewählte `org.freedesktop.portal.*` Schnittstellen)
    * `data_types.rs` (Spezifische Datentypen für D-Bus-Objekte)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung aller D-Bus Clients und Server:**
    * `pub async fn initialize_dbus_services(event_bus: EventBus, domain_services: Arc<DomainServices>) -> Result<DbusServices, DbusError>`
    * **Logik:**
        * Stellt eine Verbindung zum System-Bus und Session-Bus her (`zbus::Connection::session().await?`, `zbus::Connection::system().await?`).
        * Initialisiert alle Clients:
            * `logind_client::LogindClient::new(system_bus_conn.clone(), event_bus.clone()).await?`
            * `network_manager_client::NetworkManagerClient::new(system_bus_conn.clone(), event_bus.clone()).await?`
            * `upower_client::UPowerClient::new(system_bus_conn.clone(), event_bus.clone()).await?`
            * `secrets_client::SecretsClient::new(session_bus_conn.clone()).await?`
            * `policykit_client::PolicyKitClient::new(system_bus_conn.clone()).await?`
            * `portal_client::PortalClient::new(session_bus_conn.clone()).await?`
        * Startet den Notifications Server:
            * `tokio::spawn(notifications_server::run_notifications_server(domain_services.notification_service.clone()));` (der Server läuft in einem separaten Task und braucht das `NotificationService` aus der Domänenschicht).
        * Gibt ein gebündeltes `DbusServices` Struct zurück, das Handles zu allen initialisierten D-Bus Clients enthält.
    * **Fehlerbehandlung:** Fehler bei der D-Bus-Verbindung oder Client-Initialisierung.

2.  **`DbusServices` Struktur:**
    * `pub struct DbusServices {`
        * `pub logind_client: Arc<LogindClient>,`
        * `pub network_manager_client: Arc<NetworkManagerClient>,`
        * `pub upower_client: Arc<UPowerClient>,`
        * `pub secrets_client: Arc<SecretsClient>,`
        * `pub policykit_client: Arc<PolicyKitClient>,`
        * `pub portal_client: Arc<PortalClient>,`
    * `}`
    * Dient als Container für alle D-Bus Clients, die von anderen System-Services oder dem Compositor benötigt werden.

3.  **Event-Weiterleitung:**
    * Viele D-Bus Clients (z.B. `logind`, `NetworkManager`, `UPower`) müssen asynchron auf Signale von den D-Bus-Services hören (z.B. `PrepareForSleep`, `StateChanged`).
    * Diese Signale werden in den jeweiligen Client-Modulen in `SystemEvent`s übersetzt und über den `EventBus` gesendet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/mod.rs`
* `novade-system/src/dbus_interfaces/notifications_server.rs` (als separates ausführbares Modul für `tokio::spawn`)

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
    * `crate::dbus_interfaces::notifications_server`
    * `crate::dbus_interfaces::logind_client`
    * `crate::dbus_interfaces::network_manager_client`
    * `crate::dbus_interfaces::upower_client`
    * `crate::dbus_interfaces::secrets_client`
    * `crate::dbus_interfaces::policykit_client`
    * `crate::dbus_interfaces::portal_client`
    * `novade_domain::services::DomainServices` (Wrapper für alle Domänen-Services, insbesondere `NotificationService`)
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus::{Connection, Result as ZbusResult, zbus::Error as ZbusError}`
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Initiiert D-Bus-Verbindungen.
* Instanziiert D-Bus Clients und Server.
* Clients rufen Methoden auf Remote D-Bus Services auf.
* Clients empfangen Signale von Remote D-Bus Services und wandeln sie in `SystemEvent`s um, die über den `EventBus` gesendet werden.
* Der `notifications_server` empfängt D-Bus-Methodenaufrufe von Clients und leitet sie an den `NotificationService` der Domänenschicht weiter.

**Erwartete Ergebnisse/Outputs:**
Ein vollständig initialisiertes D-Bus-Subsystem, das NovaDE die Kommunikation mit essentiellen Systemdiensten ermöglicht und den `org.freedesktop.Notifications` Server bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `zbus::Connection` und den D-Bus-Proxies, um die Initialisierung der Clients und das Senden/Empfangen von Testdaten zu simulieren.
    * Testen der Fehlerbehandlung bei Verbindungsfehlern.
* **Integration Tests (mit realen D-Bus-Services oder D-Bus-Testdoubles):**
    * Starten eines Test-Compositors mit den initialisierten D-Bus-Clients.
    * Simulieren von D-Bus-Signalen (z.B. `logind` schaltet in den Schlafmodus) und Überprüfen, ob die korrekten `SystemEvent`s im `EventBus` ankommen.
    * Senden von Test-Notifications an den `notifications_server` und Überprüfen, ob sie vom `NotificationService` verarbeitet werden.
    * Aufruf von D-Bus-Methoden auf den Clients (z.B. `NetworkManagerClient::get_active_connections()`) und Überprüfen der Rückgabewerte.

**Geschätzter Aufwand:** Hoch (ca. 10-14 Tage, da viele verschiedene D-Bus-Protokolle und asynchrone Signalverarbeitung)

---

### **novade-system/src/dbus_interfaces/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `dbus_interfaces` Subsystem der Systemschicht. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für D-Bus-bezogene Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`DbusError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum DbusError {`
        * `#[error("D-Bus connection error: {0}")]`
        * `ConnectionError(#[from] zbus::Error),`
        * `#[error("D-Bus method call failed: {0}")]`
        * `MethodCallError(String),` // Kann spezifischer sein, z.B. zbus::fdo::Error
        * `#[error("Failed to acquire D-Bus name: {0}")]`
        * `NameAcquisitionError(String),`
        * `#[error("Invalid D-Bus response: {0}")]`
        * `InvalidResponse(String),`
        * `#[error("Service communication error: {0}")]`
        * `ServiceCommunicationError(String),` // Wenn z.B. ein Lock auf einen Domänen-Service fehlschlägt
        * `#[error("Property access error: {0}")]`
        * `PropertyAccessError(String),`
        * `#[error("D-Bus protocol error: {0}")]`
        * `ProtocolError(String),`
        * `#[error("Unknown D-Bus error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `zbus::Error` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `zbus::Error`
    * `anyhow::Error`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `dbus_interfaces` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an den aufrufenden `CompositorService` oder die Top-Level-Anwendung propagiert, um dort geloggt oder dem Benutzer angezeigt zu werden.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das D-Bus-Subsystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/dbus_interfaces/notifications_server.rs**

**Verantwortlichkeit:**
Implementiert den `org.freedesktop.Notifications` D-Bus-Service. Dieser Service empfängt Benachrichtigungen von Anwendungen (z.B. E-Mail-Clients, Instant Messenger) und leitet sie an den `NotificationService` der Domänenschicht weiter.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationsServer` Struct:**
    * `#[derive(zbus::DBusServer)]`
    * `#[interface("org.freedesktop.Notifications")]`
    * `pub struct NotificationsServer {`
        * `notification_service: Arc<NotificationService>,` // Referenz zum Domänen-Service
        * `// ... ggf. ein Handle zum EventBus für Benachrichtigungs-Events`
    * `}`

2.  **`NotificationsServer::new()` Funktion:**
    * `pub fn new(notification_service: Arc<NotificationService>) -> Self`
    * Einfacher Konstruktor.

3.  **Implementierung der D-Bus-Methoden (als `zbus` Methoden):**
    * `pub async fn Notify(&self, app_name: String, replaces_id: u32, app_icon: String, summary: String, body: String, actions: Vec<String>, hints: HashMap<String, zbus::zvariant::Value>, expire_timeout: i32) -> zbus::fdo::Result<u32>`
        * **Logik:**
            * Konvertiert die D-Bus-Parameter in einen `novade_domain::notification::data_types::Notification`-Typ.
            * Ruft `self.notification_service.create_notification(notification_data).await` auf.
            * Gibt die generierte Benachrichtigungs-ID zurück.
            * **Fehlerbehandlung:** Konvertierungsfehler, Fehler vom `NotificationService`.
    * `pub async fn GetCapabilities(&self) -> zbus::fdo::Result<Vec<String>>`
        * **Logik:**
            * Gibt eine Liste der unterstützten Fähigkeiten zurück (z.B. "body", "actions", "persistence", "body-markup").
    * `pub async fn CloseNotification(&self, id: u32) -> zbus::fdo::Result<()>`
        * **Logik:**
            * Ruft `self.notification_service.close_notification(id).await` auf.
    * `pub async fn GetServerInformation(&self) -> zbus::fdo::Result<(String, String, String, String)>`
        * **Logik:**
            * Gibt Name, Vendor, Version und Spezifikationsversion zurück (z.B. "NovaDE Notification Server", "NovaDE Team", "0.1.0", "1.2").

4.  **Implementierung der D-Bus-Signale (als `zbus` Signale):**
    * `#[zbus::signal]`
    * `pub async fn NotificationClosed(&self, id: u32, reason: u32) -> zbus::Result<()>`
        * Wird vom `NotificationService` getriggert, wenn eine Benachrichtigung geschlossen wird (z.B. durch Benutzeraktion in der UI oder Ablauf der Zeit).
    * `#[zbus::signal]`
    * `pub async fn ActionInvoked(&self, id: u32, action_key: String) -> zbus::Result<()>`
        * Wird vom `NotificationService` getriggert, wenn eine Aktion einer Benachrichtigung vom Benutzer aufgerufen wird.

5.  **`run_notifications_server()` Funktion:**
    * `pub async fn run_notifications_server(notification_service: Arc<NotificationService>) -> Result<(), DbusError>`
    * **Logik:**
        * Stellt eine Verbindung zum Session-Bus her.
        * Erstellt eine Instanz von `NotificationsServer`.
        * Registriert den Server am D-Bus mit dem Namen `org.freedesktop.Notifications`.
        * Startet den D-Bus-Event-Loop für diesen Server.
        * **Event-Bus Subscription:** Der Server muss Events vom `NotificationService` der Domänenschicht abonnieren (z.B. `NotificationClosedEvent`, `NotificationActionInvokedEvent`), um die entsprechenden D-Bus-Signale senden zu können. Dies erfordert, dass der `NotificationService` über den `EventBus` solche Events broadcastet. Eine `tokio::spawn` Aufgabe innerhalb von `run_notifications_server` könnte diese Events abonnieren und die D-Bus-Signale senden.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/notifications_server.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
    * `novade_domain::notification::service::NotificationService`
    * `novade_domain::notification::data_types::Notification` (für Konvertierung)
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent` (wenn NotificationService Events darüber sendet)
* **Extern:**
    * `zbus::{Connection, Result as ZbusResult, zbus::Error as ZbusError, fdo::Result as FdoResult, zvariant::Value, DBusServer}`
    * `tokio::task`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `tracing`

**Kommunikationsmuster:**

* Empfängt D-Bus-Methodenaufrufe von externen Anwendungen.
* Ruft Methoden auf dem `NotificationService` der Domänenschicht auf.
* Sendet D-Bus-Signale an abonnierende Clients, wenn der `NotificationService` Änderungen (Schließen, Aktion) meldet.

**Erwartete Ergebnisse/Outputs:**
Ein voll funktionsfähiger D-Bus-Benachrichtigungsserver, der es Anwendungen ermöglicht, Benachrichtigungen an NovaDE zu senden, und NovaDE ermöglicht, auf Aktionen an Benachrichtigungen zu reagieren.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `NotificationService` und des D-Bus-Connections.
    * Testen der `Notify` Methode: Überprüfen, ob `create_notification` auf dem gemockten Service aufgerufen wird und die korrekte ID zurückgegeben wird.
    * Testen von `GetCapabilities`, `GetServerInformation`, `CloseNotification`.
    * Testen des Sendens von D-Bus-Signalen, wenn der gemockte `NotificationService` entsprechende Events auslöst.
* **Integration Tests (mit `notify-send` oder einem anderen D-Bus-Client):**
    * Starten des `notifications_server` im Compositor.
    * Verwenden von `notify-send` von der Kommandozeile, um eine Benachrichtigung zu senden und zu überprüfen, ob sie in NovaDE angezeigt wird.
    * Testen des Schließens einer Benachrichtigung und ob das `NotificationClosed` Signal gesendet wird.
    * Testen von Aktionen an Benachrichtigungen.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da komplexe D-Bus-Schnittstelle, Signal-Handling und Integration mit Domänen-Service)

---

### **novade-system/src/dbus_interfaces/logind_client.rs**

**Verantwortlichkeit:**
Stellt einen D-Bus-Client für die `org.freedesktop.login1` Schnittstelle von `systemd-logind` bereit. Ermöglicht die Abfrage des Sitzungsstatus, die Steuerung von Systemaktionen (Suspend, Hibernate, Reboot, Shutdown) und das Empfangen von Signalen über Sitzungsänderungen und Power-Management-Ereignisse.

**Kern-Aufgaben (Tasks):**

1.  **`LogindClient` Struct:**
    * `pub struct LogindClient {`
        * `proxy: zbus::Proxy<'static>,`
        * `event_bus: EventBus,`
        * `// ... Cache für den aktuellen Sitzungsstatus`
    * `}`

2.  **`LogindClient::new()` Funktion:**
    * `pub async fn new(connection: Connection, event_bus: EventBus) -> Result<Arc<Self>, DbusError>`
    * **Logik:**
        * Erstellt eine `zbus::Proxy` Instanz für den `org.freedesktop.login1` Service auf dem System-Bus.
        * Abonniert relevante D-Bus-Signale (z.B. `PrepareForShutdown`, `PrepareForSleep`, `SessionNew`, `SessionRemoved`).
        * Startet einen `tokio::spawn`-Task, der diese Signale überwacht und in `SystemEvent`s umwandelt (z.B. `SystemEvent::SystemPreparingForSleep`) und diese über den `event_bus` sendet.
        * Initialisiert den internen Status (z.B. `is_session_active`).
        * Gibt `Arc<Self>` zurück.

3.  **Implementierung der D-Bus-Methoden (als `zbus` Methoden):**
    * `pub async fn suspend(&self) -> Result<(), DbusError>`
        * Ruft `proxy.call_method("Suspend", &())` auf.
    * `pub async fn hibernate(&self) -> Result<(), DbusError>`
        * Ruft `proxy.call_method("Hibernate", &())` auf.
    * `pub async fn reboot(&self) -> Result<(), DbusError>`
        * Ruft `proxy.call_method("Reboot", &())` auf.
    * `pub async fn power_off(&self) -> Result<(), DbusError>`
        * Ruft `proxy.call_method("PowerOff", &())` auf.
    * `pub async fn get_session_id(&self) -> Result<String, DbusError>`
        * Ruft `proxy.call_method("GetSession", &("self", "true"))` auf.
    * `pub async fn get_user_data(&self, uid: u32) -> Result<UserData, DbusError>` (Helper-Struct `UserData`)
        * Ruft `proxy.call_method("GetUserData", &(uid))` auf.
    * `pub async fn inhibit(&self, what: &str, who: &str, mode: &str, hint: &str) -> Result<zbus::zvariant::OwnedFd, DbusError>`
        * Für Power-Management-Inhibition (z.B. bei Video-Wiedergabe).
    * `pub async fn get_current_session_uid(&self) -> Result<u32, DbusError>`
        * Ruft die entsprechende Methode ab.

4.  **Signal-Handling:**
    * **`PrepareForShutdown(bool)`:** Sendet `SystemEvent::SystemPreparingForShutdown(bool)`
    * **`PrepareForSleep(bool)`:** Sendet `SystemEvent::SystemPreparingForSleep(bool)`
    * **`SessionNew(String, String)`:** Sendet `SystemEvent::SessionNew(session_id, user_id)`
    * **`SessionRemoved(String, String)`:** Sendet `SystemEvent::SessionRemoved(session_id, user_id)`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/logind_client.rs`
* `novade-system/src/dbus_interfaces/data_types.rs` (für `UserData` oder andere Logind-spezifische Typen)

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
    * `crate::dbus_interfaces::data_types::{UserData}`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus::{Connection, Proxy, Result as ZbusResult, zvariant::OwnedFd}`
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Ruft D-Bus-Methoden auf dem `systemd-logind` Service auf, um Systemaktionen zu steuern.
* Empfängt D-Bus-Signale von `systemd-logind` und sendet entsprechende `SystemEvent`s an den `EventBus`.

**Erwartete Ergebnisse/Outputs:**
Ein stabiler Client für `systemd-logind`, der es NovaDE ermöglicht, den Systemstatus abzufragen und Power-Management-Operationen durchzuführen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `zbus::Connection` und `zbus::Proxy`.
    * Testen der Methoden `suspend`, `reboot`, `power_off`, `get_session_id`, `inhibit` und Überprüfen, ob die korrekten Proxy-Methoden aufgerufen werden.
    * Testen des Signal-Handlings: Simulieren des Empfangs von `PrepareForSleep` oder `SessionNew` Signalen und Überprüfen, ob die entsprechenden `SystemEvent`s über den gemockten `EventBus` gesendet werden.
* **Integration Tests (mit einem laufenden `systemd` und `logind`):**
    * Starten des Clients im Compositor.
    * Senden von Suspend/Reboot-Befehlen (Vorsicht: Systemzustand!) und Beobachten des Systemverhaltens.
    * Überprüfen der Session-ID und User-Data.
    * Testen der Inhibition: Starten eines Videos und Überprüfen, ob das System nicht in den Schlafmodus geht.

**Geschätzter Aufwand:** Mittel-Hoch (ca. 5-8 Tage, da kritische Systeminteraktionen und asynchrone Signalverarbeitung)

---

### **novade-system/src/dbus_interfaces/network_manager_client.rs**

**Verantwortlichkeit:**
Stellt einen D-Bus-Client für die `org.freedesktop.NetworkManager` Schnittstelle bereit. Ermöglicht die Abfrage des Netzwerkstatus, die Verwaltung von Verbindungen (WLAN, Ethernet) und das Empfangen von Signalen über Netzwerkänderungen.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkManagerClient` Struct:**
    * `pub struct NetworkManagerClient {`
        * `proxy: zbus::Proxy<'static>,`
        * `event_bus: EventBus,`
        * `// ... Cache für den aktuellen Netzwerkstatus, aktive Verbindungen`
    * `}`

2.  **`NetworkManagerClient::new()` Funktion:**
    * `pub async fn new(connection: Connection, event_bus: EventBus) -> Result<Arc<Self>, DbusError>`
    * **Logik:**
        * Erstellt eine `zbus::Proxy` Instanz für den `org.freedesktop.NetworkManager` Service auf dem System-Bus.
        * Abonniert relevante D-Bus-Signale (z.B. `StateChanged`, `DeviceAdded`, `DeviceRemoved`, `PropertiesChanged` für spezifische Geräte).
        * Startet einen `tokio::spawn`-Task, der diese Signale überwacht und in `SystemEvent`s umwandelt (z.B. `SystemEvent::NetworkStateChanged`, `SystemEvent::NetworkDeviceAdded`) und diese über den `event_bus` sendet.
        * Initialisiert den internen Netzwerkstatus.
        * Gibt `Arc<Self>` zurück.

3.  **Implementierung der D-Bus-Methoden und Properties:**
    * `pub async fn get_state(&self) -> Result<u32, DbusError>`
        * Ruft die Property `State` ab.
    * `pub async fn get_all_devices(&self) -> Result<Vec<zbus::zvariant::ObjectPath>, DbusError>`
        * Ruft die Property `AllDevices` ab.
    * `pub async fn get_device_info(&self, device_path: &ObjectPath) -> Result<NetworkDeviceInfo, DbusError>` (Helper-Struct `NetworkDeviceInfo`)
        * Erstellt einen Proxy für das Gerät (`org.freedesktop.NetworkManager.Device`).
        * Ruft relevante Properties ab (z.B. `Interface`, `DeviceType`, `State`, `Udi`).
    * `pub async fn get_active_connections(&self) -> Result<Vec<zbus::zvariant::ObjectPath>, DbusError>`
        * Ruft die Property `ActiveConnections` ab.
    * `pub async fn connect_to_wifi(&self, ssid: &str, password: &str) -> Result<(), DbusError>`
        * Dies erfordert Interaktion mit `NetworkManager.Settings` und `NetworkManager.Agent`. Ist komplex und erfordert ggf. eine separate Helper-Funktion oder ein Submodul.
        * Ruft `AddAndActivateConnection` auf der Settings-Schnittstelle auf.
        * **Hinweis:** Dies ist eine tiefgehende Implementierung, die möglicherweise über den ersten MVP hinausgeht und später hinzugefügt wird, wenn eine UI für Netzwerkeinstellungen benötigt wird. Der Client sollte jedoch die Grundlagen dafür bereitstellen.

4.  **Signal-Handling:**
    * **`StateChanged(u32)`:** Sendet `SystemEvent::NetworkStateChanged(NetworkState)`
    * **`DeviceAdded(ObjectPath)`:** Sendet `SystemEvent::NetworkDeviceAdded(device_path)`
    * **`DeviceRemoved(ObjectPath)`:** Sendet `SystemEvent::NetworkDeviceRemoved(device_path)`
    * **`PropertiesChanged` für spezifische Geräte:** Sendet `SystemEvent::NetworkDevicePropertiesChanged(device_path, changed_properties)`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/network_manager_client.rs`
* `novade-system/src/dbus_interfaces/data_types.rs` (für `NetworkDeviceInfo`, `NetworkState`, etc.)

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
    * `crate::dbus_interfaces::data_types::{NetworkDeviceInfo, NetworkState}`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus::{Connection, Proxy, zbus::zvariant::ObjectPath}`
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Ruft D-Bus-Methoden und Properties auf dem `NetworkManager` Service auf.
* Empfängt D-Bus-Signale von `NetworkManager` und sendet entsprechende `SystemEvent`s an den `EventBus`.

**Erwartete Ergebnisse/Outputs:**
Ein Client für NetworkManager, der es NovaDE ermöglicht, den Netzwerkstatus abzufragen und auf Änderungen zu reagieren. Die Verwaltung von Verbindungen kann schrittweise erweitert werden.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `zbus::Connection` und `zbus::Proxy`.
    * Testen der Methoden `get_state`, `get_all_devices`, `get_device_info` und Überprüfen, ob die korrekten Proxy-Methoden/Properties aufgerufen werden.
    * Testen des Signal-Handlings: Simulieren des Empfangs von `StateChanged` oder `DeviceAdded` Signalen und Überprüfen, ob die entsprechenden `SystemEvent`s über den gemockten `EventBus` gesendet werden.
* **Integration Tests (mit einem laufenden NetworkManager):**
    * Starten des Clients im Compositor.
    * Änderungen der Netzwerkverbindungen (WLAN an/aus, Kabel rein/raus) und Beobachten der generierten `SystemEvent`s.
    * Abfragen des Netzwerkstatus und der Geräteinformationen.

**Geschätzter Aufwand:** Hoch (ca. 6-9 Tage, da komplexer Service mit vielen Sub-Objekten und asynchronen Signalen)

---

### **novade-system/src/dbus_interfaces/upower_client.rs**

**Verantwortlichkeit:**
Stellt einen D-Bus-Client für die `org.freedesktop.UPower` Schnittstelle bereit. Ermöglicht die Abfrage des Batteriestatus und anderer Power-Management-Informationen sowie das Empfangen von Signalen über Änderungen des Power-Zustands.

**Kern-Aufgaben (Tasks):**

1.  **`UPowerClient` Struct:**
    * `pub struct UPowerClient {`
        * `proxy: zbus::Proxy<'static>,`
        * `event_bus: EventBus,`
        * `// ... Cache für den aktuellen Batteriestatus, Liste der Geräte`
    * `}`

2.  **`UPowerClient::new()` Funktion:**
    * `pub async fn new(connection: Connection, event_bus: EventBus) -> Result<Arc<Self>, DbusError>`
    * **Logik:**
        * Erstellt eine `zbus::Proxy` Instanz für den `org.freedesktop.UPower` Service auf dem System-Bus.
        * Abonniert relevante D-Bus-Signale (z.B. `DeviceAdded`, `DeviceRemoved`).
        * Startet einen `tokio::spawn`-Task, der diese Signale überwacht und in `SystemEvent`s umwandelt (z.B. `SystemEvent::PowerDeviceAdded`) und diese über den `event_bus` sendet.
        * Initialisiert den internen Power-Status (z.B. Akku-Prozentsatz, Ladezustand).
        * Gibt `Arc<Self>` zurück.

3.  **Implementierung der D-Bus-Methoden und Properties:**
    * `pub async fn get_daemon_version(&self) -> Result<String, DbusError>`
        * Ruft die Property `DaemonVersion` ab.
    * `pub async fn get_lid_is_closed(&self) -> Result<bool, DbusError>`
        * Ruft die Property `LidIsClosed` ab.
    * `pub async fn enumerate_devices(&self) -> Result<Vec<zbus::zvariant::ObjectPath>, DbusError>`
        * Ruft die Methode `EnumerateDevices` auf.
    * `pub async fn get_device_info(&self, device_path: &ObjectPath) -> Result<PowerDeviceInfo, DbusError>` (Helper-Struct `PowerDeviceInfo`)
        * Erstellt einen Proxy für das Gerät (`org.freedesktop.UPower.Device`).
        * Ruft relevante Properties ab (z.B. `BatteryLevel`, `State`, `IsCharging`, `TimeToEmpty`, `TimeToFull`, `Type`, `Model`, `Vendor`).
        * Abonniert `PropertiesChanged` Signale für dieses Gerät, um `SystemEvent::PowerDevicePropertiesChanged` zu senden.

4.  **Signal-Handling:**
    * **`DeviceAdded(ObjectPath)`:** Sendet `SystemEvent::PowerDeviceAdded(device_path)`
    * **`DeviceRemoved(ObjectPath)`:** Sendet `SystemEvent::PowerDeviceRemoved(device_path)`
    * **`PropertiesChanged` für spezifische Geräte:** Sendet `SystemEvent::PowerDevicePropertiesChanged(device_path, changed_properties)`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/upower_client.rs`
* `novade-system/src/dbus_interfaces/data_types.rs` (für `PowerDeviceInfo`, `PowerDeviceState`, `PowerDeviceType`, etc.)

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
    * `crate::dbus_interfaces::data_types::{PowerDeviceInfo, PowerDeviceState, PowerDeviceType}`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus::{Connection, Proxy, zbus::zvariant::ObjectPath}`
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `chrono::Duration` (für TimeToEmpty/Full)

**Kommunikationsmuster:**

* Ruft D-Bus-Methoden und Properties auf dem `UPower` Service auf.
* Empfängt D-Bus-Signale von `UPower` und sendet entsprechende `SystemEvent`s an den `EventBus`.

**Erwartete Ergebnisse/Outputs:**
Ein Client für UPower, der es NovaDE ermöglicht, den Batteriestatus und andere Power-Management-Informationen abzufragen und auf Änderungen zu reagieren.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `zbus::Connection` und `zbus::Proxy`.
    * Testen der Methoden `get_daemon_version`, `get_lid_is_closed`, `enumerate_devices`, `get_device_info`.
    * Testen des Signal-Handlings: Simulieren des Empfangs von `DeviceAdded` oder `PropertiesChanged` Signalen für Geräte und Überprüfen, ob die entsprechenden `SystemEvent`s über den gemockten `EventBus` gesendet werden.
* **Integration Tests (mit einem laufenden UPower-Dienst auf Laptop/System):**
    * Starten des Clients im Compositor.
    * Anschließen/Abziehen des Netzteils, Überprüfen des Ladezustands und der `SystemEvent`s.
    * Wenn auf einem Laptop: Öffnen/Schließen des Laptop-Deckels und Überprüfen des `LidIsClosed` Status und relevanter Events.

**Geschätzter Aufwand:** Mittel (ca. 4-6 Tage, da mehrere Geräte-Objekte und Properties abgefragt werden müssen)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `input` und `compositor`, widmen wir uns `dbus_interfaces`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/dbus_interfaces/error.rs`**: Fehlerdefinitionen sind immer die Basis.
2.  **`novade-system/src/dbus_interfaces/data_types.rs`**: Alle D-Bus-spezifischen Datenstrukturen, die von den Clients benötigt werden.
3.  **`novade-system/src/dbus_interfaces/logind_client.rs`**: Logind ist grundlegend für Power-Management und Sitzungs-Informationen.
4.  **`novade-system/src/dbus_interfaces/upower_client.rs`**: Direkte Abhängigkeit zum Power-Management-Status.
5.  **`novade-system/src/dbus_interfaces/network_manager_client.rs`**: Netzwerkstatus ist wichtig für die UI.
6.  **`novade-system/src/dbus_interfaces/secrets_client.rs`**: Für sichere Speicherung von Zugangsdaten.
7.  **`novade-system/src/dbus_interfaces/policykit_client.rs`**: Für Berechtigungsanfragen.
8.  **`novade-system/src/dbus_interfaces/portal_client.rs`**: Für Sandbox-Interaktionen (File Chooser, Notifications, etc.).
9.  **`novade-system/src/dbus_interfaces/notifications_server.rs`**: Der Server selbst, der Benachrichtigungen empfängt, sollte nach den Clients und der grundlegenden D-Bus-Fehlerbehandlung implementiert werden. Er hat eine Abhängigkeit zum NotificationService der Domänenschicht.
10. **`novade-system/src/dbus_interfaces/mod.rs`**: Der Hauptmodul, der alle Clients und den Server initialisiert, sollte zuletzt implementiert werden.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/dbus_interfaces` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/audio_management` Verzeichnisses.
### **novade-system/src/dbus_interfaces/secrets_client.rs**

**Verantwortlichkeit:**
Stellt einen D-Bus-Client für die `org.freedesktop.Secret.Service` Schnittstelle bereit. Ermöglicht die sichere Speicherung und Abfrage von Passwörtern und anderen sensiblen Daten über den Freedesktop Secret Service.

**Kern-Aufgaben (Tasks):**

1.  **`SecretsClient` Struct:**
    * `pub struct SecretsClient {`
        * `proxy: zbus::Proxy<'static>,`
        * `// ... ggf. ein Cache für offene Sammlungen oder Sitzungen`
    * `}`

2.  **`SecretsClient::new()` Funktion:**
    * `pub async fn new(connection: Connection) -> Result<Arc<Self>, DbusError>`
    * **Logik:**
        * Erstellt eine `zbus::Proxy` Instanz für den `org.freedesktop.Secret.Service` auf dem Session-Bus (üblicherweise).
        * Startet eine neue D-Bus-Sitzung, falls erforderlich (`OpenSession` Methode).
        * Gibt `Arc<Self>` zurück.

3.  **Implementierung der D-Bus-Methoden:**
    * `pub async fn open_session(&self, algorithm: &str, input: &[u8]) -> Result<(zbus::zvariant::ObjectPath, zbus::zvariant::Value), DbusError>`
        * Öffnet eine neue Sitzung zur Kommunikation mit dem Secret Service (z.B. für `plain` oder `dh-ietf1024`).
    * `pub async fn unlock(&self, collections: &[ObjectPath]) -> Result<(Vec<ObjectPath>, ObjectPath), DbusError>`
        * Entsperrt eine oder mehrere Sammlungen von Geheimnissen (z.B. Benutzer-Login-Sammlung).
    * `pub async fn search_items(&self, attributes: HashMap<&str, &str>) -> Result<(Vec<ObjectPath>, Vec<ObjectPath>), DbusError>`
        * Sucht nach Geheimnissen basierend auf Attributen.
    * `pub async fn get_secret(&self, secret_path: &ObjectPath, session_path: &ObjectPath) -> Result<Secret, DbusError>`
        * Ruft ein spezifisches Geheimnis ab, wofür eine offene Sitzung erforderlich ist.
        * `Secret` ist ein Helper-Struct: `pub struct Secret { pub session: ObjectPath, pub parameters: Vec<u8>, pub value: Vec<u8>, pub content_type: String }`
    * `pub async fn create_collection(&self, properties: HashMap<&str, &str>, alias: &str) -> Result<(ObjectPath, ObjectPath), DbusError>`
        * Erstellt eine neue Sammlung.
    * `pub async fn create_item(&self, collection_path: &ObjectPath, properties: HashMap<&str, &str>, secret: &Secret, replace_prompt: bool) -> Result<(ObjectPath, ObjectPath), DbusError>`
        * Erstellt ein neues Geheimnis-Element in einer Sammlung.
    * `pub async fn delete_item(&self, item_path: &ObjectPath) -> Result<(), DbusError>`
        * Löscht ein Geheimnis-Element.
    * `pub async fn delete_collection(&self, collection_path: &ObjectPath) -> Result<(), DbusError>`
        * Löscht eine Sammlung.

5.  **Handling von Prompts:**
    * Der Secret Service kann bei Operationen (z.B. Entsperren, Speichern) einen `Prompt` signalisieren, der eine Benutzerinteraktion erfordert (z.B. Passwortabfrage).
    * Dieser Client muss in der Lage sein, solche Prompts zu erkennen und an die UI-Schicht weiterzuleiten, damit NovaDE einen entsprechenden Dialog anzeigen kann. Dies könnte über einen `SystemEvent::DbusPromptRequired(ObjectPath)` geschehen, den die UI-Schicht abonniert. Die UI sendet dann das Ergebnis des Prompts zurück an den D-Bus (`Prompt::Completed`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/secrets_client.rs`
* `novade-system/src/dbus_interfaces/data_types.rs` (für `Secret` und andere Secret Service-spezifische Typen)

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
    * `crate::dbus_interfaces::data_types::Secret`
    * `novade_core::event_bus::EventBus` (für Prompt-Weiterleitung)
    * `novade_core::system_events::SystemEvent` (für Prompt-Weiterleitung)
* **Extern:**
    * `zbus::{Connection, Proxy, zbus::zvariant::{ObjectPath, Value}}`
    * `tokio::task`
    * `tracing`
    * `std::collections::HashMap`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Ruft D-Bus-Methoden auf dem `Secret.Service` auf.
* Kann Prompts über den `EventBus` an die UI-Schicht senden und auf deren Ergebnisse warten.

**Erwartete Ergebnisse/Outputs:**
Ein Client für den Freedesktop Secret Service, der es NovaDE und seinen Anwendungen ermöglicht, sensible Daten sicher zu speichern und abzurufen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `zbus::Connection` und `zbus::Proxy`.
    * Testen der Methodenaufrufe für `open_session`, `search_items`, `get_secret`, `create_item`, `delete_item`.
    * Simulieren von `Prompt` Signalen und Überprüfen der Event-Weiterleitung.
* **Integration Tests (mit `gnome-keyring-daemon` oder `kwalletd` im Hintergrund):**
    * Starten des Clients im Compositor.
    * Speichern und Abrufen von Test-Geheimnissen.
    * Testen der Entsperr- und Prompt-Mechanismen (erfordert manuelle Interaktion oder ein Test-Utility).

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da komplexe D-Bus-API, Sitzungsmanagement und Prompt-Handling)

---

### **novade-system/src/dbus_interfaces/policykit_client.rs**

**Verantwortlichkeit:**
Stellt einen D-Bus-Client für die `org.freedesktop.PolicyKit1` Schnittstelle bereit. Ermöglicht Anwendungen, Berechtigungsanfragen an PolicyKit zu stellen und Benutzer zur Authentifizierung aufzufordern.

**Kern-Aufgaben (Tasks):**

1.  **`PolicyKitClient` Struct:**
    * `pub struct PolicyKitClient {`
        * `proxy: zbus::Proxy<'static>,`
    * `}`

2.  **`PolicyKitClient::new()` Funktion:**
    * `pub async fn new(connection: Connection) -> Result<Arc<Self>, DbusError>`
    * **Logik:**
        * Erstellt eine `zbus::Proxy` Instanz für den `org.freedesktop.PolicyKit1.Authority` Service auf dem System-Bus.
        * Gibt `Arc<Self>` zurück.

3.  **Implementierung der D-Bus-Methoden:**
    * `pub async fn check_authorization(&self, action_id: &str, details: HashMap<&str, &str>) -> Result<AuthorizationResult, DbusError>`
        * **Logik:**
            * Ruft `proxy.call_method("CheckAuthorization", &(subject, action_id, details, flags, message_id, cancellable_fd))` auf.
            * `AuthorizationResult` ist ein Helper-Struct: `pub struct AuthorizationResult { pub is_authorized: bool, pub can_challenge: bool, pub details: HashMap<String, String> }`
            * Behandelt mögliche Prompts für die Authentifizierung, indem die `ObtainAuthorization` Methode aufgerufen wird, falls `can_challenge` `true` ist.
            * **Hinweis:** Die `CheckAuthorization` Methode in PolicyKit kann selbst einen Prompt auslösen. Der Client muss darauf vorbereitet sein, dies zu behandeln, ähnlich wie beim Secret Service. Die `ObtainAuthorization` Methode ist hier relevant.
            * `pub async fn obtain_authorization(&self, action_id: &str, details: HashMap<&str, &str>, window_id: u66, cancellable_fd: OwnedFd) -> Result<AuthorizationResult, DbusError>`
                * Diese Methode wird aufgerufen, wenn ein Prompt angezeigt werden muss. `window_id` ist hier irrelevant für Wayland, aber ein Platzhalter.
                * Die Kommunikation mit einem PolicyKit Agent (z.B. `pkexec`) ist komplex und beinhaltet ggf. das Starten eines externen Programms oder die Implementierung eines PolicyKit Agenten. Zunächst wird der Client nur die Basisanfragen stellen. Ein vollständiger Agent ist ein späteres Feature.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/policykit_client.rs`
* `novade-system/src/dbus_interfaces/data_types.rs` (für `AuthorizationResult`)

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
    * `crate::dbus_interfaces::data_types::AuthorizationResult`
* **Extern:**
    * `zbus::{Connection, Proxy, zbus::zvariant::{ObjectPath, OwnedFd}}`
    * `tokio::task`
    * `tracing`
    * `std::collections::HashMap`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Ruft D-Bus-Methoden auf dem `PolicyKit1.Authority` Service auf, um Berechtigungen zu überprüfen.
* Kann indirekt Benutzerinteraktionen für Authentifizierung auslösen.

**Erwartete Ergebnisse/Outputs:**
Ein Client für PolicyKit, der es NovaDE und seinen Anwendungen ermöglicht, Berechtigungen für privilegierte Aktionen zu überprüfen und ggf. zu erlangen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `zbus::Connection` und `zbus::Proxy`.
    * Testen der `check_authorization` Methode mit verschiedenen `action_id`s und simulierten Rückgabewerten (autorisiert, nicht autorisiert, kann herausfordern).
* **Integration Tests (mit einem laufenden PolicyKit-Daemon und polkit-test-rules):**
    * Starten des Clients im Compositor.
    * Ausführen von Aktionen, die PolicyKit-Berechtigungen erfordern (z.B. Herunterfahren, wenn es über PolicyKit geschützt ist), und Überprüfen des Verhaltens.
    * Testen der `obtain_authorization` Methode und der Benutzerinteraktion (manueller Test erforderlich).

**Geschätzter Aufwand:** Mittel-Hoch (ca. 6-9 Tage, da PolicyKit-API komplex sein kann, insbesondere im Zusammenhang mit Authentifizierung)

---

### **novade-system/src/dbus_interfaces/portal_client.rs**

**Verantwortlichkeit:**
Stellt einen D-Bus-Client für ausgewählte `org.freedesktop.portal.*` Schnittstellen bereit. Diese Portale dienen als sichere und standardisierte Wege für Flatpak- und andere sandboxed Anwendungen, um auf Systemressourcen und Funktionalitäten zuzugreifen, die normalerweise eingeschränkt wären (z.B. Dateiauswahl, Benachrichtigungen, Screenshots, Printing).

**Kern-Aufgaben (Tasks):**

1.  **`PortalClient` Struct:**
    * `pub struct PortalClient {`
        * `file_chooser_proxy: zbus::Proxy<'static>,`
        * `screenshot_proxy: zbus::Proxy<'static>,`
        * `request_proxy: zbus::Proxy<'static>,` // Für allgemeine Portal-Requests
        * `// ... ggf. weitere Proxies für andere Portale`
    * `}`

2.  **`PortalClient::new()` Funktion:**
    * `pub async fn new(connection: Connection) -> Result<Arc<Self>, DbusError>`
    * **Logik:**
        * Erstellt `zbus::Proxy` Instanzen für die relevanten Portal-Services (`org.freedesktop.portal.FileChooser`, `org.freedesktop.portal.Screenshot`, `org.freedesktop.portal.Request`) auf dem Session-Bus.
        * Gibt `Arc<Self>` zurück.

3.  **Implementierung der D-Bus-Methoden (für ausgewählte Portale):**
    * **FileChooser Portal (`org.freedesktop.portal.FileChooser`):**
        * `pub async fn open_file(&self, parent_window: &str, title: &str, options: HashMap<&str, zbus::zvariant::Value>) -> Result<FileChooserResponse, DbusError>`
            * Startet einen Dateiauswahl-Dialog. `parent_window` ist der Wayland-Fensterhandle (z.B. `x-scheme-handler/file/path/to/window-handle`).
            * `FileChooserResponse` ist ein Helper-Struct: `pub struct FileChooserResponse { pub response: u32, pub uris: Vec<String> }`
        * `pub async fn save_file(&self, parent_window: &str, title: &str, options: HashMap<&str, zbus::zvariant::Value>) -> Result<FileChooserResponse, DbusError>`
            * Startet einen Dateispeicher-Dialog.
    * **Screenshot Portal (`org.freedesktop.portal.Screenshot`):**
        * `pub async fn take_screenshot(&self, parent_window: &str, options: HashMap<&str, zbus::zvariant::Value>) -> Result<ScreenshotResponse, DbusError>`
            * Löst einen Screenshot aus.
            * `ScreenshotResponse` ist ein Helper-Struct: `pub struct ScreenshotResponse { pub response: u32, pub uri: String }`
    * **Request Portal (`org.freedesktop.portal.Request`):**
        * Dieses Portal wird von den anderen Portalen verwendet, um das Ergebnis einer Anfrage zu signalisieren (z.B. "FileChooser::Response"). Der `PortalClient` muss Signale von diesem `Request` Proxy abonnieren und die Ergebnisse verarbeiten.
        * `#[zbus::signal("Response")]` für den `Request` Proxy:
            * `pub async fn on_response(&self, request_handle: ObjectPath, response: u32, results: HashMap<String, zbus::zvariant::Value>)`
                * Diese Methode verarbeitet die Antworten der Portale und leitet sie an die entsprechende, auf den ursprünglichen Aufruf wartende Logik weiter (z.B. über `tokio::sync::oneshot` Channels).

4.  **Integration mit NovaDE UI/Compositor:**
    * Die Portale lösen oft die Anzeige von UI-Dialogen aus, die vom Compositor gerendert werden müssen (z.B. der Dateiauswahl-Dialog).
    * Der `PortalClient` muss eine Möglichkeit haben, diese UI-Anfragen an die UI-Schicht weiterzuleiten. Dies könnte über `SystemEvent`s geschehen, z.B. `SystemEvent::ShowFileChooserDialog(request_handle, initial_path, options)` und die UI-Schicht sendet dann das Ergebnis über einen Kanal zurück an den `PortalClient`, der es an das Portal zurückgibt.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/portal_client.rs`
* `novade-system/src/dbus_interfaces/data_types.rs` (für `FileChooserResponse`, `ScreenshotResponse` und andere Portal-spezifische Typen)

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
    * `crate::dbus_interfaces::data_types::{FileChooserResponse, ScreenshotResponse}`
    * `novade_core::event_bus::EventBus` (für die Weiterleitung von UI-Anfragen)
    * `novade_core::system_events::SystemEvent` (für die Weiterleitung von UI-Anfragen)
* **Extern:**
    * `zbus::{Connection, Proxy, zbus::zvariant::{ObjectPath, Value}}`
    * `tokio::task`
    * `tokio::sync::oneshot` (für das Warten auf Portal-Antworten)
    * `tracing`
    * `std::collections::HashMap`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Ruft D-Bus-Methoden auf den `freedesktop.portal` Services auf.
* Empfängt asynchrone D-Bus-Antwortsignale vom `freedesktop.portal.Request` Service.
* Leitet Anfragen für UI-Dialoge (Dateiauswahl, Screenshot-Bereich) an die UI-Schicht weiter und wartet auf deren Ergebnisse.

**Erwartete Ergebnisse/Outputs:**
Ein Client für Freedesktop Portale, der es NovaDE und seinen sandboxed Anwendungen ermöglicht, auf Systemressourcen sicher zuzugreifen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `zbus::Connection` und den `zbus::Proxy` Instanzen.
    * Testen der Methodenaufrufe für `open_file`, `save_file`, `take_screenshot`.
    * Simulieren der `Response` Signale vom `Request` Proxy und Überprüfen, ob die Ergebnisse korrekt verarbeitet werden.
* **Integration Tests (mit Flatpak-Anwendungen):**
    * Starten des Compositors mit dem `PortalClient`.
    * Starten einer Flatpak-Anwendung, die ein Dateiauswahl- oder Screenshot-Portal verwendet.
    * Überprüfen, ob der entsprechende Dialog in NovaDE angezeigt wird und die Interaktion funktioniert.

**Geschätzter Aufwand:** Hoch (ca. 10-15 Tage, da mehrere komplexe Portale und asynchrone Callback-Mechanismen implementiert werden müssen, plus UI-Integration)

---

### **novade-system/src/dbus_interfaces/data_types.rs**

**Verantwortlichkeit:**
Definiert spezifische Datentypen (Structs, Enums) für die D-Bus-Schnittstellen, die im `dbus_interfaces` Modul verwendet werden. Dies umfasst Typen, die für die Marshalling/Unmarshalling von D-Bus-Nachrichten notwendig sind und die Rohdaten in eine besser handhabbare, typsichere Form übersetzen.

**Kern-Aufgaben (Tasks):**

1.  **Definition von D-Bus-spezifischen Typen:**
    * **`Secret` Struct:**
        * `pub struct Secret { pub session: zbus::zvariant::ObjectPath, pub parameters: Vec<u8>, pub value: Vec<u8>, pub content_type: String }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `serde::Serialize`, `serde::Deserialize` (falls persistiert).
    * **`AuthorizationResult` Struct (PolicyKit):**
        * `pub struct AuthorizationResult { pub is_authorized: bool, pub can_challenge: bool, pub details: HashMap<String, String> }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`.
    * **`FileChooserResponse` Struct (Portal):**
        * `pub struct FileChooserResponse { pub response: u32, pub uris: Vec<String> }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`.
    * **`ScreenshotResponse` Struct (Portal):**
        * `pub struct ScreenshotResponse { pub response: u32, pub uri: String }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`.
    * **`PowerDeviceInfo` Struct (UPower):**
        * `pub struct PowerDeviceInfo { pub object_path: zbus::zvariant::ObjectPath, pub device_type: PowerDeviceType, pub model: String, pub vendor: String, pub serial: String, pub percentage: f64, pub state: PowerDeviceState, pub is_charging: bool, pub time_to_empty: Option<std::time::Duration>, pub time_to_full: Option<std::time::Duration>, // ... weitere relevante Felder}`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`.
    * **`PowerDeviceType` Enum:**
        * `pub enum PowerDeviceType { Battery, Mouse, Keyboard, Monitor, LinePower, ... }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`. Konvertierung von u32 zu diesem Enum.
    * **`PowerDeviceState` Enum:**
        * `pub enum PowerDeviceState { Unknown, Charging, Discharging, Empty, Full, PendingCharge, PendingDischarge, ... }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`. Konvertierung von u32 zu diesem Enum.
    * **`NetworkDeviceInfo` Struct (NetworkManager):**
        * `pub struct NetworkDeviceInfo { pub object_path: zbus::zvariant::ObjectPath, pub iface: String, pub device_type: NetworkDeviceType, pub state: NetworkDeviceState, // ... weitere relevante Felder wie MAC-Adresse, IP-Adressen (IPv4, IPv6) }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`.
    * **`NetworkDeviceType` Enum:**
        * `pub enum NetworkDeviceType { Unknown, Ethernet, Wifi, Bluetooth, Loopback, ... }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`. Konvertierung von u32 zu diesem Enum.
    * **`NetworkDeviceState` Enum:**
        * `pub enum NetworkDeviceState { Unknown, Unmanaged, Unavailable, Disconnected, Prepare, Config, Activated, Deactivating, Failed, ... }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`. Konvertierung von u32 zu diesem Enum.
    * **`NetworkConnectionInfo` Struct (NetworkManager):**
        * `pub struct NetworkConnectionInfo { pub object_path: zbus::zvariant::ObjectPath, pub id: String, pub uuid: String, pub connection_type: String, pub state: NetworkConnectionState, // ... weitere relevante Felder wie IP-Adressen, Gateway }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`.
    * **`NetworkConnectionState` Enum:**
        * `pub enum NetworkConnectionState { Unknown, Activating, Activated, Deactivating, Deactivated, ... }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`.
    * **`UserData` Struct (Logind):**
        * `pub struct UserData { pub uid: u32, pub gid: u32, pub name: String, pub seat: String, pub session: String, pub display: String, // ... weitere relevante Felder }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`.
    * Implementiere `From<zbus::zvariant::Value>` oder ähnliche `TryFrom` Traits, wo D-Bus-Werte in diese Rust-Typen konvertiert werden müssen.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `zbus::zvariant::{ObjectPath, Value}`
    * `std::collections::HashMap`
    * `std::time::Duration`
    * `serde::{Serialize, Deserialize}` (falls Persistenz benötigt wird)

**Kommunikationsmuster:**

* Diese Datenstrukturen werden als Parameter und Rückgabewerte für die D-Bus-Methoden in den Client-Modulen verwendet.

**Erwartete Ergebnisse/Outputs:**
Eine Sammlung von robusten, typsicheren und gut definierten Datenstrukturen, die die Interaktion mit D-Bus-Services vereinfachen und Fehler reduzieren.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `Default` Implementierungen (falls vorhanden).
    * Testen der `Clone`, `Debug`, `PartialEq` Ableitungen.
    * Testen der Konvertierungsfunktionen von D-Bus-Werten (z.B. von `u32` zu Enums) und die Fehlerbehandlung für ungültige Werte.
    * Testen der Serialisierung/Deserialisierung, falls `serde` verwendet wird.

**Geschätzter Aufwand:** Mittel (ca. 3-5 Tage, je nach Anzahl der benötigten Typen und deren Komplexität, aber meist reine Definitionsarbeit)

---

### **novade-system/src/audio_management/mod.rs**

**Verantwortlichkeit:**
Das `audio_management` Modul ist der zentrale Punkt für die Audio-Interaktion mit dem System, basierend auf PipeWire. Es verwaltet Audio-Streams, Geräte, Lautstärke und leitet relevante Audio-Ereignisse an höhere Schichten weiter.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/audio_management/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Audio-Operationen)
    * `data_types.rs` (Spezifische Datentypen für Audio-Geräte, Streams, etc.)
    * `pipewire_client.rs` (Implementierung des PipeWire-Clients)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Audio-Managements:**
    * `pub async fn initialize_audio_management(event_bus: EventBus) -> Result<AudioManager, AudioError>`
    * **Logik:**
        * Initialisiert die PipeWire-Verbindung (`pipewire_rs::Pipewire::new().await?`).
        * Erstellt eine Instanz von `pipewire_client::PipewireClient`.
        * Startet den PipeWire-Client-Event-Loop in einem separaten `tokio::spawn`-Task.
        * Gibt ein gebündeltes `AudioManager` Struct zurück, das Handles zum PipeWire-Client enthält.
    * **Fehlerbehandlung:** Fehler bei der PipeWire-Verbindung oder Client-Initialisierung.

2.  **`AudioManager` Struct:**
    * `pub struct AudioManager {`
        * `pub pipewire_client: Arc<PipewireClient>,`
    * `}`
    * Dient als Container für den PipeWire-Client, der von anderen System-Services oder der UI benötigt wird.

3.  **Event-Weiterleitung:**
    * Der `PipewireClient` muss asynchron auf PipeWire-Events hören (z.B. neue Audio-Geräte, Lautstärkeänderungen, Stream-Statusänderungen).
    * Diese Events werden in `SystemEvent`s übersetzt (z.B. `SystemEvent::AudioVolumeChanged`, `SystemEvent::AudioDeviceAdded`) und über den `EventBus` gesendet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_management/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::audio_management::error::AudioError`
    * `crate::audio_management::pipewire_client::PipewireClient`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `pipewire_rs` (für den Haupt-Client)
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Initialisiert die PipeWire-Verbindung.
* Instanziiert den PipeWire-Client.
* Client empfängt Events von PipeWire und wandelt sie in `SystemEvent`s um, die über den `EventBus` gesendet werden.
* Andere System-Services oder die UI rufen Methoden auf dem `PipewireClient` auf, um Audio-Operationen durchzuführen.

**Erwartete Ergebnisse/Outputs:**
Ein vollständig initialisiertes Audio-Subsystem, das NovaDE die Interaktion mit dem PipeWire-Server ermöglicht und Audio-Statusänderungen an das System weiterleitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `pipewire_rs` und des `EventBus`, um die Initialisierung und das Senden/Empfangen von Testdaten zu simulieren.
    * Testen der Fehlerbehandlung bei Verbindungsfehlern.
* **Integration Tests (mit realem PipeWire-Daemon):**
    * Starten des `AudioManager` im Compositor.
    * Verwenden von `pactl` (oder `pw-cli`) von der Kommandozeile, um Lautstärke zu ändern oder Geräte hinzuzufügen/entfernen und überprüfen, ob die korrekten `SystemEvent`s im `EventBus` ankommen.
    * Überprüfen der Abfrage von Audio-Geräten und Streams.

**Geschätzter Aufwand:** Mittel (ca. 3-5 Tage, da es die Integration mit PipeWire und das Handling von Events erfordert)

---

### **novade-system/src/audio_management/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `audio_management` Subsystem der Systemschicht. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für PipeWire-bezogene Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`AudioError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum AudioError {`
        * `#[error("PipeWire connection error: {0}")]`
        * `ConnectionError(#[from] pipewire_rs::Error),`
        * `#[error("PipeWire operation failed: {0}")]`
        * `OperationFailed(String),`
        * `#[error("Invalid audio device or stream: {0}")]`
        * `InvalidDeviceOrStream(String),`
        * `#[error("Unsupported audio feature: {0}")]`
        * `UnsupportedFeature(String),`
        * `#[error("Unknown audio error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `pipewire_rs::Error` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_management/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `pipewire_rs::Error`
    * `anyhow::Error`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `audio_management` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an den aufrufenden `CompositorService` oder die Top-Level-Anwendung propagiert, um dort geloggt oder dem Benutzer angezeigt zu werden.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Audio-Subsystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/audio_management/data_types.rs**

**Verantwortlichkeit:**
Definiert spezifische Datentypen (Structs, Enums) für das `audio_management` Subsystem. Dies umfasst Typen, die den Zustand von Audio-Geräten, Streams und der Lautstärke repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **Definition von Audio-spezifischen Typen:**
    * **`AudioDevice` Struct:**
        * `pub struct AudioDevice { pub id: u32, pub name: String, pub description: String, pub device_type: AudioDeviceType, pub is_default: bool, // ... weitere PipeWire-spezifische Metadaten}`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `Hash`.
    * **`AudioDeviceType` Enum:**
        * `pub enum AudioDeviceType { Sink, Source, Unknown }` (Ausgabe- vs. Eingabegeräte)
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `Hash`.
    * **`AudioStream` Struct:**
        * `pub struct AudioStream { pub id: u32, pub name: String, pub application_name: String, pub stream_type: AudioStreamType, pub volume: f64, pub is_muted: bool, pub device_id: Option<u32>, // Gerät, an das der Stream gebunden ist }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `Hash`.
    * **`AudioStreamType` Enum:**
        * `pub enum AudioStreamType { Playback, Capture, Unknown }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `Hash`.
    * **`VolumeInfo` Struct:**
        * `pub struct VolumeInfo { pub volume: f64, pub is_muted: bool }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `Default`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_management/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `std::collections::HashMap` (wenn Metadaten als Map gespeichert werden)
    * `std::hash::{Hash, Hasher}`

**Kommunikationsmuster:**

* Diese Datenstrukturen werden vom `PipewireClient` erstellt und verwendet, um den Audio-Zustand darzustellen.
* Sie werden über `SystemEvent`s an den `EventBus` gesendet und von der UI-Schicht zur Anzeige verwendet.

**Erwartete Ergebnisse/Outputs:**
Eine Sammlung von robusten, typsicheren und gut definierten Datenstrukturen, die den Audio-Zustand des Systems repräsentieren.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `Default` Implementierungen (falls vorhanden).
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` Ableitungen.
    * Testen der Konstruktoren und Feldbindungen.

**Geschätzter Aufwand:** Niedrig (ca. 1-2 Tage, hauptsächlich Definitionen)

---

### **novade-system/src/audio_management/pipewire_client.rs**

**Verantwortlichkeit:**
Implementiert den eigentlichen PipeWire-Client. Dies umfasst den Aufbau der Verbindung zum PipeWire-Daemon, das Monitoring von Audio-Geräten und Streams, das Einstellen von Lautstärken und das Senden relevanter Ereignisse an den `EventBus`.

**Kern-Aufgaben (Tasks):**

1.  **`PipewireClient` Struct:**
    * `pub struct PipewireClient {`
        * `pipewire_connection: Arc<pipewire_rs::Pipewire>,`
        * `event_bus: EventBus,`
        * `// Interne Zustände: Maps für Geräte und Streams nach ID`
        * `active_sinks: RwLock<HashMap<u32, AudioDevice>>,`
        * `active_sources: RwLock<HashMap<u32, AudioDevice>>,`
        * `active_playback_streams: RwLock<HashMap<u32, AudioStream>>,`
        * `active_capture_streams: RwLock<HashMap<u32, AudioStream>>,`
        * `// ... ggf. Standard-Sink/Source ID`
    * `}`

2.  **`PipewireClient::new()` Funktion:**
    * `pub async fn new(connection: Arc<pipewire_rs::Pipewire>, event_bus: EventBus) -> Result<Self, AudioError>`
    * **Logik:**
        * Initialisiert die internen `RwLock` HashMaps.
        * Registriert Callbacks für PipeWire-Events (`pw_core`, `pw_registry`, `pw_device`, `pw_stream`).
        * Startet den Haupt-Event-Loop für die PipeWire-Verbindung (`connection.run()`).

3.  **Implementierung der PipeWire-Event-Handler:**
    * **Registry Events (Node-Management):**
        * `on_global_added(global: &Global)`:
            * Erkennt neue Sink-, Source-, Playback- oder Capture-Nodes.
            * Erstellt `AudioDevice` oder `AudioStream` Instanzen.
            * Fügt sie den internen Maps hinzu und sendet `SystemEvent::AudioDeviceAdded` oder `SystemEvent::AudioStreamAdded`.
        * `on_global_removed(id: u32)`:
            * Entfernt Gerät/Stream aus den internen Maps.
            * Sendet `SystemEvent::AudioDeviceRemoved` oder `SystemEvent::AudioStreamRemoved`.
    * **Object Properties Changed Events:**
        * Überwacht Änderungen an `pw_device` und `pw_stream` Eigenschaften (z.B. Lautstärke, Stummschaltung, Metadaten).
        * Aktualisiert interne Zustände und sendet `SystemEvent::AudioVolumeChanged`, `SystemEvent::AudioMuteChanged`, `SystemEvent::AudioStreamPropertiesChanged`, `SystemEvent::AudioDevicePropertiesChanged`.

4.  **Implementierung der Public API (Methoden für Audio-Kontrolle und Abfragen):**
    * `pub async fn get_all_sinks(&self) -> Vec<AudioDevice>`
    * `pub async fn get_all_sources(&self) -> Vec<AudioDevice>`
    * `pub async fn get_all_playback_streams(&self) -> Vec<AudioStream>`
    * `pub async fn get_all_capture_streams(&self) -> Vec<AudioStream>`
    * `pub async fn get_default_sink_id(&self) -> Option<u32>`
    * `pub async fn set_sink_volume(&self, device_id: u32, volume: f64) -> Result<(), AudioError>`
        * Ruft `pw_device_set_param(volume)` oder ähnliches auf.
    * `pub async fn set_sink_muted(&self, device_id: u32, muted: bool) -> Result<(), AudioError>`
    * `pub async fn set_default_sink(&self, device_id: u32) -> Result<(), AudioError>`
        * Setzt die Eigenschaft `default.audio.sink` in PipeWire.
    * `pub async fn set_stream_volume(&self, stream_id: u32, volume: f64) -> Result<(), AudioError>`
    * `pub async fn set_stream_muted(&self, stream_id: u32, muted: bool) -> Result<(), AudioError>`

5.  **Run-Loop für den Client:**
    * `pub async fn run(self) -> Result<(), AudioError>`
        * Diese Funktion wird in einem `tokio::spawn` Task ausgeführt, um den asynchronen Event-Loop des PipeWire-Clients zu managen.
        * Sie sollte den PipeWire-Dispatcher (`pw_main_loop_run()` oder `pipewire_rs::Pipewire::run_loop()`) blockierend aufrufen und gleichzeitig die von `EventBus` empfangenen Befehle verarbeiten (z.B. Lautstärkeänderungen, die von der UI initiiert wurden). Ein `mpsc::channel` könnte hier für die Kommunikation zwischen dem Public API und dem internen PipeWire-Event-Loop genutzt werden.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_management/pipewire_client.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::audio_management::error::AudioError`
    * `crate::audio_management::data_types::{AudioDevice, AudioDeviceType, AudioStream, AudioStreamType, VolumeInfo}`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `pipewire_rs` (die Hauptbibliothek)
    * `tokio::task`
    * `tokio::sync::{RwLock, mpsc}`
    * `tracing`
    * `std::sync::Arc`
    * `std::collections::HashMap`

**Kommunikationsmuster:**

* Interagiert direkt mit der PipeWire-Bibliothek.
* Sendet `SystemEvent`s an den `EventBus`, wenn sich der Audio-Status ändert.
* Empfängt Befehle (z.B. Lautstärke ändern) über seine öffentliche API.

**Erwartete Ergebnisse/Outputs:**
Ein robuster PipeWire-Client, der den Audio-Zustand des Systems überwacht und steuert und relevante Informationen an NovaDE weitergibt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `pipewire_rs` (sehr anspruchsvoll, da C-Bindungen) oder Verwendung einer Test-PipeWire-Instanz.
    * Testen der Initialisierung und Fehlerbehandlung.
    * Simulieren von PipeWire-Global-Ereignissen (Added/Removed) und Überprüfen der internen Zustände und gesendeten `SystemEvent`s.
    * Simulieren von Property-Changed-Events und Überprüfen der Zustandsaktualisierungen und gesendeten Events.
    * Testen der Methoden zur Lautstärkeregelung und Stummschaltung.
* **Integration Tests (mit realem PipeWire-Daemon):**
    * Starten des `PipewireClient` und Ausführen realer Audio-Operationen.
    * Überprüfen der Konsistenz des internen Zustands mit `pw-cli` oder `pactl`.
    * Überprüfen der `SystemEvent`s bei Interaktionen.

**Geschätzter Aufwand:** Hoch (ca. 10-15 Tage, da tiefe Integration mit PipeWire und asynchrone Event-Verarbeitung)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `dbus_interfaces`, widmen wir uns `audio_management`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/audio_management/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/audio_management/data_types.rs`**: Datenstrukturen für Audio-Informationen.
3.  **`novade-system/src/audio_management/pipewire_client.rs`**: Die Kernlogik für die PipeWire-Interaktion, da sie die Basis für alle Audio-Funktionen bildet und Events generiert.
4.  **`novade-system/src/audio_management/mod.rs`**: Das Hauptmodul, das den `PipewireClient` initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/audio_management` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/mcp_client` Verzeichnisses.
### **novade-system/src/mcp_client/mod.rs**

**Verantwortlichkeit:**
Das `mcp_client` Modul ist die Brücke zum Model Context Protocol (MCP) Server. Es ermöglicht NovaDE, mit KI-Modellen zu kommunizieren, Anfragen zu senden und Antworten zu empfangen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/mcp_client/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für MCP-Interaktionen)
    * `data_types.rs` (Spezifische Datentypen für MCP-Nachrichten)
    * `client.rs` (Implementierung des MCP-Clients)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des MCP-Clients:**
    * `pub async fn initialize_mcp_client(event_bus: EventBus, config_service: Arc<ConfigService>) -> Result<McpClientManager, McpError>`
    * **Logik:**
        * Lädt die MCP-Client-Konfiguration über den `ConfigService` (z.B. MCP-Server-Adresse).
        * Erstellt eine Instanz von `client::McpClient`.
        * Stellt eine Verbindung zum MCP-Server her.
        * Startet den MCP-Client-Event-Loop (falls asynchron) in einem separaten `tokio::spawn`-Task.
        * Gibt ein gebündeltes `McpClientManager` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Konfiguration, Verbindung zum MCP-Server oder Client-Initialisierung.

2.  **`McpClientManager` Struct:**
    * `pub struct McpClientManager {`
        * `pub client: Arc<McpClient>,`
    * `}`
    * Dient als Container für den MCP-Client, der von anderen System-Services oder der Domänenschicht benötigt wird.

3.  **Event-Weiterleitung (falls MCP-Server Events sendet):**
    * Falls der MCP-Server asynchrone Events an den Client sendet (z.B. Modell-Updates, Verfügbarkeitsänderungen), müssen diese in `SystemEvent`s übersetzt und über den `EventBus` gesendet werden.

**Spezifische Artefekte/Dateien:**

* `novade-system/src/mcp_client/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::mcp_client::error::McpError`
    * `crate::mcp_client::client::McpClient`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent` (optional, falls MCP-Server Events sendet)
    * `novade_domain::config::service::ConfigService`
* **Extern:**
    * `mcp_client_rs` (oder eine ähnliche Bibliothek für MCP)
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Initialisiert den MCP-Client und stellt die Verbindung her.
* Instanziiert den MCP-Client.
* Andere System-Services oder die Domänenschicht rufen Methoden auf dem `McpClient` auf, um Anfragen an KI-Modelle zu senden.
* Empfängt Antworten vom MCP-Server.

**Erwartete Ergebnisse/Outputs:**
Ein vollständig initialisiertes Subsystem für die KI-Modell-Kommunikation, das NovaDE ermöglicht, KI-Funktionalitäten zu nutzen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `mcp_client_rs` (oder der internen Client-Logik) und des `ConfigService`, um die Initialisierung und das Senden/Empfangen von Testdaten zu simulieren.
    * Testen der Fehlerbehandlung bei Verbindungsfehlern oder ungültiger Konfiguration.
* **Integration Tests (mit einem laufenden MCP-Server):**
    * Starten des `McpClientManager` im Compositor oder einem dedizierten Test-Harness.
    * Senden von Test-Anfragen an den MCP-Server und Überprüfen der Antworten.
    * Simulieren von Server-Fehlern und Überprüfen der Fehlerbehandlung im Client.

**Geschätzter Aufwand:** Mittel (ca. 4-7 Tage, abhängig von der Komplexität der `mcp_client_rs` Bibliothek und der MCP-Protokolldetails)

---

### **novade-system/src/mcp_client/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `mcp_client` Subsystem der Systemschicht. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für MCP-bezogene Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`McpError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum McpError {`
        * `#[error("MCP connection error: {0}")]`
        * `ConnectionError(String),` // Kann spezifischer sein, z.B. von zugrunde liegender Transportbibliothek
        * `#[error("MCP request failed: {0}")]`
        * `RequestFailed(String),`
        * `#[error("Invalid MCP response: {0}")]`
        * `InvalidResponse(String),`
        * `#[error("Configuration error: {0}")]`
        * `ConfigError(#[from] novade_core::config::ConfigError),`
        * `#[error("Unknown MCP error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `novade_core::config::ConfigError` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/mcp_client/error.rs`

**Abhängigkeiten:**

* **Internal:**
    * `novade_core::config::ConfigError`
* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `mcp_client` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an den aufrufenden `CompositorService` oder die Top-Level-Anwendung propagiert, um dort geloggt oder dem Benutzer angezeigt zu werden.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das MCP-Subsystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/mcp_client/data_types.rs**

**Verantwortlichkeit:**
Definiert spezifische Datentypen (Structs, Enums) für die Kommunikation über das Model Context Protocol (MCP). Diese Typen repräsentieren die Anfragen an KI-Modelle und deren Antworten.

**Kern-Aufgaben (Tasks):**

1.  **Definition von MCP-spezifischen Typen:**
    * **`McpRequest` Struct:**
        * `pub struct McpRequest { pub model_id: String, pub input_data: McpInputData, pub context: Option<McpContext>, pub stream_response: bool }`
        * Ableitungen: `Debug`, `Clone`, `serde::Serialize`, `serde::Deserialize`.
    * **`McpInputData` Enum:**
        * `pub enum McpInputData { Text(String), Json(serde_json::Value), Bytes(Vec<u8>), // ... weitere unterstützte Eingabetypen }`
        * Ableitungen: `Debug`, `Clone`, `serde::Serialize`, `serde::Deserialize`.
    * **`McpContext` Struct:**
        * `pub struct McpContext { pub session_id: Option<String>, pub user_id: Option<String>, pub interaction_history: Vec<McpInteraction>, // ... weitere Kontext-Informationen }`
        * Ableitungen: `Debug`, `Clone`, `Default`, `serde::Serialize`, `serde::Deserialize`.
    * **`McpInteraction` Struct:**
        * `pub struct McpInteraction { pub role: McpRole, pub content: McpInputData, pub timestamp: chrono::DateTime<chrono::Utc> }`
        * Ableitungen: `Debug`, `Clone`, `serde::Serialize`, `serde::Deserialize`.
    * **`McpRole` Enum:**
        * `pub enum McpRole { User, Assistant, System, Tool }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `Hash`, `serde::Serialize`, `serde::Deserialize`.
    * **`McpResponse` Struct:**
        * `pub struct McpResponse { pub model_id: String, pub output_data: McpOutputData, pub tokens_used: Option<u32>, pub finish_reason: Option<String> }`
        * Ableitungen: `Debug`, `Clone`, `serde::Serialize`, `serde::Deserialize`.
    * **`McpOutputData` Enum:**
        * `pub enum McpOutputData { Text(String), Json(serde_json::Value), Bytes(Vec<u8>), StreamChunk(Vec<u8>), // Für Streaming-Antworten }`
        * Ableitungen: `Debug`, `Clone`, `serde::Serialize`, `serde::Deserialize`.
    * Implementiere `From` oder `TryFrom` Traits, wenn eine Konvertierung von/zu generischen JSON-Werten oder Bytes erforderlich ist.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/mcp_client/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `serde_json::Value`
    * `chrono::{DateTime, Utc}`
    * `std::collections::HashMap` (falls für Metadaten verwendet)

**Kommunikationsmuster:**

* Diese Datenstrukturen werden vom `McpClient` für das Senden von Anfragen und das Empfangen von Antworten an/von MCP-Servern verwendet.

**Erwartete Ergebnisse/Outputs:**
Eine Sammlung von robusten, typsicheren und gut definierten Datenstrukturen, die die Kommunikation mit KI-Modellen über das MCP-Protokoll ermöglichen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` (für Enums) Ableitungen.
    * Testen der Serialisierung und Deserialisierung (z.B. zu/von JSON) für jede Struktur, um die Korrektheit der Datenübertragung zu gewährleisten.
    * Testen von Edge-Cases für die Datenfelder (z.B. leere Strings, leere Vektoren, `None` Optionen).

**Geschätzter Aufwand:** Mittel (ca. 2-4 Tage, je nach Komplexität der MCP-Spezifikation und der Menge der benötigten Typen)

---

### **novade-system/src/mcp_client/client.rs**

**Verantwortlichkeit:**
Implementiert den eigentlichen Client für das Model Context Protocol. Dies umfasst den Verbindungsaufbau zum MCP-Server, das Senden von Anfragen und das Empfangen sowie Verarbeiten von Antworten.

**Kern-Aufgaben (Tasks):**

1.  **`McpClient` Struct:**
    * `pub struct McpClient {`
        * `server_address: String,`
        * `// ... interne Verbindungspools oder TcpStream/WebSocket-Handles`
        * `// Je nach Transport (HTTP, WebSocket, gRPC)`
        * `http_client: reqwest::Client,` // Beispiel für HTTP-basierten Client
        * `// ... Channels für asynchrone Antworten oder Streaming`
    * `}`

2.  **`McpClient::new()` Funktion:**
    * `pub async fn new(server_address: String) -> Result<Self, McpError>`
    * **Logik:**
        * Speichert die Server-Adresse.
        * Initialisiert den HTTP-Client (oder den entsprechenden Transport-Client).
        * Versucht eine initiale Verbindung herzustellen (optional, kann auch lazy im ersten Request erfolgen).
        * Gibt `Self` zurück.

3.  **Implementierung der Public API (Methoden für MCP-Interaktion):**
    * `pub async fn send_request(&self, request: McpRequest) -> Result<McpResponse, McpError>`
        * **Logik:**
            * Serialisiert die `McpRequest` in das entsprechende Format (z.B. JSON).
            * Sendet die Anfrage an den `server_address` über den konfigurierten Transport (z.B. HTTP POST an `/predict` Endpoint).
            * Wartet auf die Antwort.
            * Deserialisiert die Antwort in eine `McpResponse`.
            * **Fehlerbehandlung:** Netzwerkfehler, Server-Fehler (HTTP-Statuscodes, MCP-spezifische Fehlerantworten), Deserialisierungsfehler.
    * `pub async fn send_streaming_request(&self, request: McpRequest) -> Result<mpsc::Receiver<McpOutputData>, McpError>`
        * **Logik:**
            * Initialisiert eine Streaming-Verbindung (z.B. WebSocket oder Server-Sent Events über HTTP).
            * Sendet die Anfrage.
            * Gibt einen `mpsc::Receiver` zurück, über den die `McpOutputData::StreamChunk`s oder vollständigen `McpOutputData`s empfangen werden können.
            * **Fehlerbehandlung:** Wie `send_request`. Der Empfänger muss auch Fehlermeldungen verarbeiten können.
    * `pub async fn get_model_capabilities(&self, model_id: &str) -> Result<ModelCapabilities, McpError>`
        * Abfrage der Fähigkeiten eines spezifischen KI-Modells (z.B. unterstützte Eingabetypen, maximale Kontextlänge). `ModelCapabilities` wäre ein weiterer `data_types.rs` Struct.
    * `pub async fn get_available_models(&self) -> Result<Vec<ModelInfo>, McpError>`
        * Abfrage der Liste der verfügbaren KI-Modelle. `ModelInfo` wäre ein weiterer `data_types.rs` Struct.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/mcp_client/client.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::mcp_client::error::McpError`
    * `crate::mcp_client::data_types::{McpRequest, McpResponse, McpOutputData, ModelCapabilities, ModelInfo}`
* **Extern:**
    * `reqwest` (für HTTP-Kommunikation)
    * `tokio::sync::mpsc` (für Streaming-Antworten)
    * `serde_json`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Kommuniziert direkt mit dem externen MCP-Server über Netzwerkprotokolle (z.B. HTTP/1.1 oder HTTP/2, WebSockets).
* Stellt synchrone und asynchrone Methoden für die Interaktion mit dem MCP-Server bereit.

**Erwartete Ergebnisse/Outputs:**
Ein robuster MCP-Client, der NovaDE die nahtlose Kommunikation mit KI-Modellen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des Netzwerk-Transports (z.B. `reqwest::mock` oder eigene Mock-Implementierung).
    * Testen der Serialisierung von Anfragen und Deserialisierung von Antworten.
    * Testen der Fehlerpfade für Netzwerkfehler, ungültige Server-Antworten und MCP-spezifische Fehlercodes.
    * Testen der Streaming-Funktionalität mit simulierten Chunks.
* **Integration Tests (mit einem realen oder simulierten MCP-Server):**
    * Starten eines Test-MCP-Servers (oder Verwendung eines vorhandenen).
    * Senden realer Anfragen und Überprüfen der Antworten.
    * Testen von Edge-Cases wie sehr großen Anfragen/Antworten, langen Streaming-Sitzungen, Verbindungsabbrüchen.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da Implementierung eines Netzwerk-Clients, Parsing von Protokollen und Umgang mit Streaming komplex ist)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `audio_management`, widmen wir uns `mcp_client`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/mcp_client/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/mcp_client/data_types.rs`**: Datenstrukturen für MCP-Nachrichten.
3.  **`novade-system/src/mcp_client/client.rs`**: Die Kernlogik für die MCP-Kommunikation.
4.  **`novade-system/src/mcp_client/mod.rs`**: Das Hauptmodul, das den `McpClient` initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/mcp_client` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/window_mechanics` Verzeichnisses.
### **novade-system/src/window_mechanics/mod.rs**

**Verantwortlichkeit:**
Das `window_mechanics` Modul ist für die technische Umsetzung der Fenster-Policies verantwortlich, die in der Domänenschicht (`novade-domain::window_policy`) definiert sind. Es interagiert direkt mit dem Wayland-Compositor, um Fenster zu positionieren, zu tilen, ihren Fokus zu verwalten und andere Fenstermanagement-Operationen durchzuführen. Es stellt die Verbindung zwischen den abstrakten Fenster-Policies und der konkreten Compositor-Implementierung her.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/window_mechanics/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Fenstermanagement-Operationen)
    * `data_types.rs` (Spezifische Datentypen für Fensterzustände, Tiling-Modi etc.)
    * `manager.rs` (Implementierung des Window Mechanics Managers)
    * `layout_algorithms/` (Unterverzeichnis für verschiedene Tiling-Layout-Algorithmen)
        * `mod.rs` (Public API für Layout-Algorithmen)
        * `tiled.rs` (Implementierung für Kachel-Layouts)
        * `floating.rs` (Implementierung für schwebende Fenster)
        * `fullscreen.rs` (Implementierung für Vollbild-Fenster)
        * `stacked.rs` (Implementierung für gestapelte Fenster)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Window Mechanics Subsystems:**
    * `pub async fn initialize_window_mechanics(desktop_state: Arc<DesktopState>, event_bus: EventBus, window_policy_service: Arc<WindowPolicyService>) -> Result<WindowManager, WindowMechanicsError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::WindowManager`.
        * Der `WindowManager` registriert sich als Listener für relevante `DesktopEvent`s vom `DesktopState` (z.B. `WindowAdded`, `WindowRemoved`, `WindowGeometryChanged`, `WorkspaceChanged`).
        * Der `WindowManager` abonniert `DomainEvent::WindowPolicyChanged` vom `WindowPolicyService`, um auf Änderungen der Fenster-Policies zu reagieren.
        * Gibt ein gebündeltes `WindowManager` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung der Abhängigkeiten oder des Managers.

2.  **`WindowManager` Struct:**
    * `pub struct WindowManager {`
        * `desktop_state: Arc<DesktopState>,` // Für den Zugriff auf den aktuellen Compositor-Zustand
        * `event_bus: EventBus,`
        * `window_policy_service: Arc<WindowPolicyService>,`
        * `// Interner Zustand, z.B. Maps von Workspace-IDs zu Layout-Managern`
        * `// ... ggf. ein `RwLock` um den Zustand zu schützen.`
    * `}`
    * Dient als Container und Orchestrator für die Fenstermanagement-Logik.

3.  **Event-Handling:**
    * Der `WindowManager` muss auf eine Reihe von Events reagieren, um seine Aufgaben zu erfüllen:
        * **`DesktopEvent::WindowAdded(WindowHandle)`**: Ein neues Fenster wurde im Compositor erstellt. Der Manager muss die initiale Platzierung und Tiling-Regeln anwenden.
        * **`DesktopEvent::WindowRemoved(WindowHandle)`**: Ein Fenster wurde geschlossen. Der Manager muss das Layout aktualisieren.
        * **`DesktopEvent::WindowGeometryChanged(WindowHandle, new_geometry)`**: Ein Fenster wurde verschoben oder in der Größe geändert (vom Benutzer oder der Anwendung). Der Manager muss prüfen, ob dies mit den Policies übereinstimmt und ggf. eingreifen (z.B. Snapping, Tiling-Anpassung).
        * **`DesktopEvent::WorkspaceChanged(WorkspaceId)`**: Der aktive Workspace hat sich geändert. Der Manager muss das Layout für den neuen Workspace anwenden.
        * **`DesktopEvent::PointerFocusChanged(WindowHandle)`**: Der Fokus hat sich geändert. Der Manager muss die Fokus-Policy anwenden.
        * **`DomainEvent::WindowPolicyChanged(WindowPolicy)`**: Die Domänenschicht hat die Fenster-Policies aktualisiert. Der Manager muss diese neuen Regeln auf alle relevanten Fenster anwenden.

4.  **Integration mit `layout_algorithms`:**
    * Der `WindowManager` delegiert die eigentliche Berechnung der Fenstergeometrien an die Module im `layout_algorithms` Unterverzeichnis, basierend auf dem aktuellen Layout-Modus des Workspaces (aus der `WindowPolicyService`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_mechanics/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::window_mechanics::error::WindowMechanicsError`
    * `crate::window_mechanics::data_types::*`
    * `crate::window_mechanics::manager::WindowManager`
    * `crate::window_mechanics::layout_algorithms::*`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent` (für das Senden von Layout-Ergebnissen an den Compositor)
    * `novade_domain::window_policy::service::WindowPolicyService`
    * `novade_domain::window_policy::data_types::WindowPolicy`
    * `novade_system::compositor::state::DesktopState` (für den Zugriff auf den Compositor-Zustand)
    * `novade_system::compositor::data_types::{WindowHandle, WorkspaceId}`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `tokio::sync::RwLock`

**Kommunikationsmuster:**

* Empfängt Events vom `DesktopState` (Compositor) und dem `WindowPolicyService` (Domäne).
* Ruft Methoden des `WindowPolicyService` auf, um die aktuellen Policies abzurufen.
* Ruft Layout-Algorithmen auf, um Fenstergeometrien zu berechnen.
* Sendet `SystemEvent::WindowLayoutUpdated(WindowHandle, new_geometry)` an den `EventBus`, um den Compositor über neue Fensterpositionen und -größen zu informieren.
* Kann Befehle zum Wechseln von Workspaces oder Fokussieren von Fenstern über den `EventBus` an den Compositor senden.

**Erwartete Ergebnisse/Outputs:**
Ein vollständig initialisiertes Fenstermanagement-Subsystem, das Fenster auf dem Bildschirm gemäß den definierten Richtlinien anordnet, Größen ändert und fokussiert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `DesktopState`, `EventBus` und `WindowPolicyService`.
    * Testen der Initialisierung des `WindowManager`.
    * Simulieren von `DesktopEvent`s (Hinzufügen/Entfernen von Fenstern, Größenänderungen) und `DomainEvent::WindowPolicyChanged`. Überprüfen, ob die richtigen internen Methoden aufgerufen und die korrekten `SystemEvent::WindowLayoutUpdated` Events gesendet werden.
* **Integration Tests (mit einem minimalistischen Compositor-Harness):**
    * Starten des `WindowManager` zusammen mit einem simulierten `DesktopState`.
    * Hinzufügen von Test-Fenstern und Überprüfen, ob sie korrekt positioniert werden (durch Inspektieren des `DesktopState` oder der gesendeten Events).
    * Wechseln des Layout-Modus (z.B. von Tiled zu Floating) und Überprüfen der Neuordnung.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da komplexe Zustandsverwaltung, Event-Verarbeitung und Interaktion mit dem Compositor und der Domäne erforderlich ist)

---

### **novade-system/src/window_mechanics/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `window_mechanics` Subsystem der Systemschicht. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für Fenstermanagement-bezogene Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`WindowMechanicsError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum WindowMechanicsError {`
        * `#[error("Failed to apply window layout: {0}")]`
        * `LayoutApplicationFailed(String),`
        * `#[error("Invalid window handle: {0}")]`
        * `InvalidWindowHandle(String),`
        * `#[error("Policy service error: {0}")]`
        * `PolicyServiceError(#[from] novade_domain::window_policy::error::WindowPolicyError),`
        * `#[error("Compositor state error: {0}")]`
        * `CompositorStateError(String),` // Z.B. wenn der Compositor-Zustand inkonsistent ist
        * `#[error("Internal logic error: {0}")]`
        * `InternalError(String),`
        * `#[error("Unknown window mechanics error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `novade_domain::window_policy::error::WindowPolicyError` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_mechanics/error.rs`

**Abhängigkeiten:**

* **Intern:**
    * `novade_domain::window_policy::error::WindowPolicyError`
* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `window_mechanics` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an den aufrufenden `CompositorService` oder die Top-Level-Anwendung propagiert, um dort geloggt oder dem Benutzer angezeigt zu werden.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Fenstermanagement-Subsystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/window_mechanics/data_types.rs**

**Verantwortlichkeit:**
Definiert spezifische Datentypen (Structs, Enums) für das `window_mechanics` Subsystem. Diese Typen repräsentieren den Zustand von Fenstern, Workspaces und den verschiedenen Layout-Modi.

**Kern-Aufgaben (Tasks):**

1.  **Definition von Fenster- und Layout-spezifischen Typen:**
    * **`WindowLayoutMode` Enum:**
        * `pub enum WindowLayoutMode { Tiled, Floating, Fullscreen, Stacked, // ... weitere Modi wie Tabbed }`
        * Ableitungen: `Debug`, `Clone`, `Copy`, `Eq`, `PartialEq`, `Hash`, `Default`, `serde::Serialize`, `serde::Deserialize`.
    * **`TilingDirection` Enum (für Tiled-Layouts):**
        * `pub enum TilingDirection { Horizontal, Vertical }`
        * Ableitungen: `Debug`, `Clone`, `Copy`, `Eq`, `PartialEq`, `Hash`, `Default`, `serde::Serialize`, `serde::Deserialize`.
    * **`WorkspaceLayout` Struct:**
        * `pub struct WorkspaceLayout { pub mode: WindowLayoutMode, pub main_area_size: f64, // z.B. 0.5 für 50% des Bildschirms, nur für Tiled pub main_area_count: u33, // Anzahl der Fenster im Hauptbereich, nur für Tiled pub tiling_direction: TilingDirection, // nur für Tiled }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `Default`, `serde::Serialize`, `serde::Deserialize`.
        * Implementiere eine `new()`-Funktion.
    * **`WindowPosition` Struct:**
        * `pub struct WindowPosition { pub x: i32, pub y: i32, pub width: i32, pub height: i32 }`
        * Ableitungen: `Debug`, `Clone`, `Copy`, `Eq`, `PartialEq`, `Default`.
        * Implementiere Methoden für Geometrie-Operationen (z.B. `contains_point`, `intersects`).
    * **`WindowLayoutInfo` Struct:**
        * `pub struct WindowLayoutInfo { pub handle: novade_system::compositor::data_types::WindowHandle, pub position: WindowPosition, pub is_maximized: bool, pub is_minimized: bool, pub is_fullscreen: bool, pub is_floating: bool, pub workspace_id: novade_system::compositor::data_types::WorkspaceId, // ... weitere Layout-relevante Metadaten }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `Default`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_mechanics/data_types.rs`

**Abhängigkeiten:**

* **Intern:**
    * `novade_system::compositor::data_types::{WindowHandle, WorkspaceId}`
* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::collections::HashMap` (falls für Metadaten verwendet)

**Kommunikationsmuster:**

* Diese Datenstrukturen werden intern vom `WindowManager` und den Layout-Algorithmen verwendet.
* `WindowLayoutInfo` wird über `SystemEvent`s an den Compositor gesendet, um die Fensterdarstellung zu aktualisieren.

**Erwartete Ergebnisse/Outputs:**
Eine Sammlung von robusten, typsicheren und gut definierten Datenstrukturen, die die Konzepte des Fenstermanagements in NovaDE abbilden.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `Default` Implementierungen.
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` Ableitungen.
    * Testen der Geometrie-Operationen für `WindowPosition`.
    * Testen der Serialisierung und Deserialisierung für `WindowLayoutMode`, `TilingDirection`, `WorkspaceLayout`.
    * Testen von Edge-Cases für numerische Felder (z.B. Nullwerte, negative Werte).

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage, hauptsächlich Definitionen und einfache Logik für Geometrie)

---

### **novade-system/src/window_mechanics/manager.rs**

**Verantwortlichkeit:**
Implementiert den Haupt-Orchestrator für das Fenstermanagement. Der `WindowManager` ist für die Reaktion auf Ereignisse aus dem Compositor und der Domäne, die Anwendung der Fenster-Policies und die Delegation an die Layout-Algorithmen zuständig.

**Kern-Aufgaben (Tasks):**

1.  **`WindowManager` Struct:**
    * `pub struct WindowManager {`
        * `desktop_state: Arc<DesktopState>,`
        * `event_bus: EventBus,`
        * `window_policy_service: Arc<WindowPolicyService>,`
        * `// Interner Zustand: RwLock schützt den Zustand der Workspaces und ihrer Fenster.`
        * `workspace_layouts: RwLock<HashMap<WorkspaceId, WorkspaceLayout>>,`
        * `window_metadata: RwLock<HashMap<WindowHandle, WindowLayoutInfo>>,` // Aktuelle Layout-Info pro Fenster
        * `// Optional: Mapping von WindowHandle zu einem Mutex/Arc<LayoutAlgorithm> für Fenster-spezifische Layouts`
    * `}`

2.  **`WindowManager::new()` Funktion:**
    * `pub async fn new(desktop_state: Arc<DesktopState>, event_bus: EventBus, window_policy_service: Arc<WindowPolicyService>) -> Result<Self, WindowMechanicsError>`
    * **Logik:**
        * Initialisiert den `WindowManager` und seine internen Zustände.
        * Abonniert relevante `DesktopEvent`s vom `desktop_state.event_receiver()`.
        * Abonniert `DomainEvent::WindowPolicyChanged` vom `window_policy_service.event_receiver()`.
        * Startet einen `tokio::spawn` Task für den Event-Loop, der auf diese Events hört und sie verarbeitet.

3.  **Event-Loop (`run` Methode):**
    * `pub async fn run(self) -> Result<(), WindowMechanicsError>`
    * **Logik:**
        * Endlose Schleife, die `select!` über die Event-Receiver des `DesktopState` und des `WindowPolicyService` ausführt.
        * Bei `DesktopEvent::WindowAdded(handle)`:
            * Holt die aktuelle `WindowPolicy` für dieses Fenster (z.B. über `get_policy_for_window`).
            * Bestimmt den initialen `WindowLayoutMode` für den aktuellen Workspace.
            * Weist dem Fenster einen Workspace zu (z.B. aktuellen aktiven Workspace).
            * Wendet das Layout für das neue Fenster an (ruft `apply_layout` auf).
            * Aktualisiert `window_metadata`.
        * Bei `DesktopEvent::WindowRemoved(handle)`:
            * Entfernt das Fenster aus `window_metadata`.
            * Löst ein Re-Layout des betroffenen Workspaces aus (ruft `recalculate_layout` auf).
        * Bei `DesktopEvent::WindowGeometryChanged(handle, new_geom)`:
            * Prüft, ob die Änderung vom Benutzer oder der Anwendung kam.
            * Wenn es eine Benutzerinteraktion war und das Layout im Tiling-Modus ist, kann dies einen Wechsel zu `Floating` für dieses Fenster erzwingen oder Snapping-Logik anwenden.
            * Aktualisiert `window_metadata` und löst ggf. ein Re-Layout aus.
        * Bei `DesktopEvent::WorkspaceChanged(new_workspace_id)`:
            * Aktualisiert den aktiven Workspace in `desktop_state`.
            * Löst ein Re-Layout des neuen aktiven Workspaces aus (ruft `recalculate_layout` auf).
        * Bei `DesktopEvent::PointerFocusChanged(handle)`:
            * Setzt den Fokus im Compositor (indem ein `SystemEvent::SetWindowFocus` gesendet wird) basierend auf der Policy.
        * Bei `DomainEvent::WindowPolicyChanged(policy)`:
            * Aktualisiert die internen Policies.
            * Löst ein vollständiges Re-Layout aller Workspaces aus, da sich die Regeln geändert haben könnten.

4.  **Interne Hilfsfunktionen:**
    * `async fn apply_layout(&self, window_handle: WindowHandle, target_workspace_id: WorkspaceId) -> Result<(), WindowMechanicsError>`
        * **Logik:**
            * Bestimmt den aktuellen `WindowLayoutMode` des `target_workspace_id`.
            * Ruft den entsprechenden Layout-Algorithmus aus `layout_algorithms` auf (z.B. `layout_algorithms::tiled::apply_tiled_layout`).
            * Sendet `SystemEvent::WindowLayoutUpdated(handle, new_position)` für jedes betroffene Fenster an den `EventBus`.
    * `async fn recalculate_layout(&self, workspace_id: WorkspaceId) -> Result<(), WindowMechanicsError>`
        * Holt alle Fenster für den gegebenen Workspace.
        * Ruft `apply_layout` für jedes Fenster in diesem Workspace auf.
    * `async fn get_effective_policy(&self, window_handle: WindowHandle) -> WindowPolicy`
        * Fragt den `WindowPolicyService` nach der spezifischen Policy für das Fenster ab.
    * `async fn get_active_workspace_layout_mode(&self) -> WindowLayoutMode`
        * Holt den aktuellen Layout-Modus des aktiven Workspaces aus `workspace_layouts`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_mechanics/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::window_mechanics::error::WindowMechanicsError`
    * `crate::window_mechanics::data_types::{WindowLayoutMode, WorkspaceLayout, WindowLayoutInfo, WindowPosition, TilingDirection}`
    * `crate::window_mechanics::layout_algorithms` (Module `tiled`, `floating`, `fullscreen`, `stacked`)
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
    * `novade_domain::window_policy::service::WindowPolicyService`
    * `novade_domain::window_policy::data_types::WindowPolicy` (sowie die spezifischen Regeln und Typen der Policy-Daten)
    * `novade_domain::domain_events::DomainEvent`
    * `novade_system::compositor::state::DesktopState`
    * `novade_system::compositor::desktop_events::DesktopEvent`
    * `novade_system::compositor::data_types::{WindowHandle, WorkspaceId}`
* **Extern:**
    * `tokio::task`
    * `tokio::sync::{RwLock, mpsc, broadcast}`
    * `tracing`
    * `std::sync::Arc`
    * `std::collections::HashMap`

**Kommunikationsmuster:**

* Verbraucht Events vom `EventBus` (von `DesktopState` und `WindowPolicyService`).
* Schreibt in `DesktopState` (über `Arc<DesktopState>` Zugriff auf interne Zustände).
* Sendet `SystemEvent`s an den `EventBus`, um den Compositor zu aktualisieren.
* Ruft die verschiedenen `layout_algorithms` auf, um die Fenstergeometrien zu berechnen.

**Erwartete Ergebnisse/Outputs:**
Ein voll funktionsfähiger Fenstermanager, der Fenster dynamisch basierend auf System-Events und Domänen-Policies verwaltet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `DesktopState`, `EventBus` und `WindowPolicyService` sowie den `layout_algorithms`.
    * Testen der `new` Methode und des Event-Loop-Starts.
    * Simulieren von `WindowAdded`, `WindowRemoved`, `WindowGeometryChanged` Events und Überprüfen, ob `apply_layout` bzw. `recalculate_layout` aufgerufen werden.
    * Simulieren von `DomainEvent::WindowPolicyChanged` und Überprüfen des Re-Layout-Verhaltens.
    * Testen der `apply_layout` und `recalculate_layout` Funktionen mit verschiedenen `WindowLayoutMode`s und simulierten Fenstern.
    * Testen der Fehlerbehandlung bei ungültigen Handles oder Policy-Fehlern.
* **Integration Tests:**
    * Starten des `WindowManager` mit simulierten oder echten `DesktopState`, `EventBus` und `WindowPolicyService`.
    * Überprüfen, ob Fenster korrekt positioniert und skaliert werden, wenn sie hinzugefügt, entfernt oder der Layout-Modus geändert wird.
    * Testen von Fokus-Wechseln und deren Auswirkungen.

**Geschätzter Aufwand:** Hoch (ca. 12-18 Tage, da dies das Herzstück des Fenstermanagements ist und eine komplexe Event-Verarbeitung und Zustandsverwaltung erfordert)

---

### **novade-system/src/window_mechanics/layout_algorithms/mod.rs**

**Verantwortlichkeit:**
Das `layout_algorithms` Modul bietet eine Abstraktion für verschiedene Fenstermanagement-Layouts (z.B. Tiled, Floating, Fullscreen, Stacked). Es definiert Traits und gemeinsame Schnittstellen für Layout-Algorithmen und re-exportiert die einzelnen Implementierungen.

**Kern-Aufgaben (Tasks):**

1.  **`LayoutAlgorithm` Trait:**
    * `pub trait LayoutAlgorithm: Send + Sync {`
        * `/// Wendet das Layout auf die gegebenen Fenster an und gibt die berechneten Positionen zurück.`
        * `/// `windows`: Eine Liste von WindowLayoutInfo für alle Fenster, die verwaltet werden sollen.`
        * `/// `container_rect`: Das Rechteck (z.B. Monitor-Bereich oder Workspace-Bereich), in dem die Fenster angeordnet werden sollen.`
        * `/// `layout_config`: Spezifische Konfiguration für dieses Layout (z.B. WorkspaceLayout, Main-Area-Größe).`
        * `fn apply_layout(&self, windows: &[WindowLayoutInfo], container_rect: &WindowPosition, layout_config: &WorkspaceLayout) -> Result<HashMap<WindowHandle, WindowPosition>, WindowMechanicsError>;`
        * `/// Passt das Layout an eine einzelne Fensteränderung an, z.B. wenn ein Fenster verschoben wird.`
        * `/// (Optional, kann eine Standardimplementierung haben, die apply_layout für alle aufruft)`
        * `fn adjust_for_window_change(&self, changed_window: &WindowLayoutInfo, all_windows: &[WindowLayoutInfo], container_rect: &WindowPosition, layout_config: &WorkspaceLayout) -> Result<HashMap<WindowHandle, WindowPosition>, WindowMechanicsError> { /* ... */ }`
        * `fn get_layout_mode(&self) -> WindowLayoutMode;`
    * `}`

2.  **`LayoutAlgorithmFactory` (Optional):**
    * Ein Enum oder eine Factory-Funktion, um Instanzen von `LayoutAlgorithm` basierend auf `WindowLayoutMode` zu erstellen.
    * `pub fn create_layout_algorithm(mode: WindowLayoutMode) -> Arc<dyn LayoutAlgorithm>`

3.  **Re-Exporte der Layout-Implementierungen:**
    * `pub mod tiled;`
    * `pub mod floating;`
    * `pub mod fullscreen;`
    * `pub mod stacked;`
    * `pub use tiled::TiledLayoutAlgorithm;`
    * `pub use floating::FloatingLayoutAlgorithm;`
    * `pub use fullscreen::FullscreenLayoutAlgorithm;`
    * `pub use stacked::StackedLayoutAlgorithm;`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_mechanics/layout_algorithms/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::window_mechanics::error::WindowMechanicsError`
    * `crate::window_mechanics::data_types::{WindowLayoutMode, WindowPosition, WindowLayoutInfo, WorkspaceLayout}`
    * `crate::window_mechanics::layout_algorithms::tiled`
    * `crate::window_mechanics::layout_algorithms::floating`
    * `crate::window_mechanics::layout_algorithms::fullscreen`
    * `crate::window_mechanics::layout_algorithms::stacked`
    * `novade_system::compositor::data_types::WindowHandle`
* **Extern:**
    * `std::collections::HashMap`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Der `WindowManager` ruft die `apply_layout` Methode auf den Implementierungen des `LayoutAlgorithm` Traits auf.

**Erwartete Ergebnisse/Outputs:**
Eine klare Schnittstelle und Abstraktion für verschiedene Layout-Algorithmen, die eine einfache Erweiterung und Wartung ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `create_layout_algorithm` Factory-Funktion.
    * Sicherstellen, dass alle implementierten Layout-Algorithmen den `LayoutAlgorithm` Trait implementieren.

**Geschätzter Aufwand:** Niedrig (ca. 1-2 Tage, hauptsächlich Trait-Definition und Re-Exporte)

---

### **novade-system/src/window_mechanics/layout_algorithms/tiled.rs**

**Verantwortlichkeit:**
Implementiert den Tiling-Layout-Algorithmus, der Fenster automatisch in einem nicht-überlappenden Kachelmuster anordnet.

**Kern-Aufgaben (Tasks):**

1.  **`TiledLayoutAlgorithm` Struct:**
    * `pub struct TiledLayoutAlgorithm {}`
    * Implementiere `Default` und `Debug`.

2.  **Implementierung des `LayoutAlgorithm` Traits:**
    * `impl LayoutAlgorithm for TiledLayoutAlgorithm {`
        * `fn apply_layout(&self, windows: &[WindowLayoutInfo], container_rect: &WindowPosition, layout_config: &WorkspaceLayout) -> Result<HashMap<WindowHandle, WindowPosition>, WindowMechanicsError>`
            * **Logik:**
                * Überprüft `layout_config.main_area_size` und `layout_config.main_area_count`.
                * Sortiert die Fenster (z.B. nach der Reihenfolge der Hinzufügung oder Fokus-Historie).
                * Teilt den `container_rect` (z.B. Monitor-Größe) in einen Hauptbereich und einen Stack-Bereich auf, basierend auf `tiling_direction` (horizontal/vertikal).
                * Positioniert die ersten `main_area_count` Fenster im Hauptbereich.
                * Positioniert die restlichen Fenster im Stack-Bereich.
                * Berechnet die exakten `WindowPosition` für jedes Fenster im jeweiligen Bereich.
                * Handhabt, wenn es zu viele oder zu wenige Fenster für das Layout gibt.
                * Berücksichtigt Ränder/Padding zwischen den Fenstern (aus `ConfigService` oder Hardcoded).
                * Gibt eine `HashMap` von `WindowHandle` zu `WindowPosition` zurück.
            * **Fehlerbehandlung:** Wenn keine Fenster vorhanden sind oder die Konfiguration ungültig ist.
        * `fn get_layout_mode(&self) -> WindowLayoutMode { WindowLayoutMode::Tiled }`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_mechanics/layout_algorithms/tiled.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::window_mechanics::error::WindowMechanicsError`
    * `crate::window_mechanics::data_types::{WindowLayoutMode, WindowPosition, WindowLayoutInfo, WorkspaceLayout, TilingDirection}`
    * `novade_system::compositor::data_types::WindowHandle`
    * `crate::window_mechanics::layout_algorithms::LayoutAlgorithm`
* **Extern:**
    * `std::collections::HashMap`
    * `tracing`

**Kommunikationsmuster:**

* Wird vom `WindowManager` aufgerufen, um Fenster im Tiling-Modus anzuordnen.

**Erwartete Ergebnisse/Outputs:**
Ein Algorithmus, der Fenster effizient und ästhetisch in einem Kachelmuster anordnet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen von `apply_layout` mit einer unterschiedlichen Anzahl von Fenstern (0, 1, 2, viele).
    * Testen mit verschiedenen `main_area_count` und `main_area_size` Werten.
    * Testen mit `Horizontal` und `Vertical` `TilingDirection`.
    * Testen der Randbedingungen (z.B. Fenstergeometrie passt nicht perfekt).
    * Überprüfen der korrekten Berechnung der `WindowPosition` für jedes Fenster.
    * Testen der Fehlerbehandlung bei ungültigen Eingaben.

**Geschätzter Aufwand:** Mittel-Hoch (ca. 4-7 Tage, da geometrische Berechnungen und Edge-Cases sorgfältig behandelt werden müssen)

---

### **novade-system/src/window_mechanics/layout_algorithms/floating.rs**

**Verantwortlichkeit:**
Implementiert den Floating-Layout-Algorithmus, der Fenster nicht automatisch anordnet, sondern ihre Position und Größe beibehält und Überlappungen zulässt.

**Kern-Aufgaben (Tasks):**

1.  **`FloatingLayoutAlgorithm` Struct:**
    * `pub struct FloatingLayoutAlgorithm {}`
    * Implementiere `Default` und `Debug`.

2.  **Implementierung des `LayoutAlgorithm` Traits:**
    * `impl LayoutAlgorithm for FloatingLayoutAlgorithm {`
        * `fn apply_layout(&self, windows: &[WindowLayoutInfo], container_rect: &WindowPosition, _layout_config: &WorkspaceLayout) -> Result<HashMap<WindowHandle, WindowPosition>, WindowMechanicsError>`
            * **Logik:**
                * Für jedes Fenster in `windows`:
                    * Wenn das Fenster bereits eine Position hat (`WindowLayoutInfo::position`), behält es diese bei.
                    * Wenn es neu ist, sollte es eine Standard-Initialposition (z.B. mittig oder gestaffelt) und -größe erhalten, die aus den Compositor-Einstellungen oder einer initialen Heuristik stammen könnte. Die genaue Initialisierung des Fensters (Größe/Position) sollte idealerweise vom Compositor oder der App kommen. Dieses Layout sorgt nur dafür, dass es im Floating-Modus verbleibt.
                    * Optional: Kleine Anpassungen, um Fenster nicht komplett außerhalb des `container_rect` zu platzieren.
                * Gibt eine `HashMap` von `WindowHandle` zu `WindowPosition` zurück.
            * **Fehlerbehandlung:** Minimale Fehlerbehandlung, da die Logik einfach ist.
        * `fn get_layout_mode(&self) -> WindowLayoutMode { WindowLayoutMode::Floating }`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_mechanics/layout_algorithms/floating.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::window_mechanics::error::WindowMechanicsError`
    * `crate::window_mechanics::data_types::{WindowLayoutMode, WindowPosition, WindowLayoutInfo, WorkspaceLayout}`
    * `novade_system::compositor::data_types::WindowHandle`
    * `crate::window_mechanics::layout_algorithms::LayoutAlgorithm`
* **Extern:**
    * `std::collections::HashMap`
    * `tracing`

**Kommunikationsmuster:**

* Wird vom `WindowManager` aufgerufen, um Fenster im Floating-Modus zu verwalten.

**Erwartete Ergebnisse/Outputs:**
Ein Algorithmus, der die Position und Größe von Fenstern im Floating-Modus respektiert, anstatt sie automatisch anzuordnen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen von `apply_layout` mit Fenstern, die bereits eine Position haben.
    * Testen mit neuen Fenstern, die eine Standardposition erhalten sollten.
    * Testen, ob Fenster, die außerhalb des `container_rect` liegen, leicht angepasst werden.

**Geschätzter Aufwand:** Niedrig (ca. 2-3 Tage, da die Logik relativ einfach ist)

---

### **novade-system/src/window_mechanics/layout_algorithms/fullscreen.rs**

**Verantwortlichkeit:**
Implementiert den Fullscreen-Layout-Algorithmus, der ein einzelnes Fenster so anordnet, dass es den gesamten Bildschirm (oder `container_rect`) ausfüllt, ohne Ränder oder andere UI-Elemente.

**Kern-Aufgaben (Tasks):**

1.  **`FullscreenLayoutAlgorithm` Struct:**
    * `pub struct FullscreenLayoutAlgorithm {}`
    * Implementiere `Default` und `Debug`.

2.  **Implementierung des `LayoutAlgorithm` Traits:**
    * `impl LayoutAlgorithm for FullscreenLayoutAlgorithm {`
        * `fn apply_layout(&self, windows: &[WindowLayoutInfo], container_rect: &WindowPosition, _layout_config: &WorkspaceLayout) -> Result<HashMap<WindowHandle, WindowPosition>, WindowMechanicsError>`
            * **Logik:**
                * Wenn `windows` leer ist, gibt eine leere Map zurück.
                * Wählt das "führende" Fullscreen-Fenster aus (z.B. das erste oder das aktuell fokussierte).
                * Setzt dessen Position und Größe auf den gesamten `container_rect`.
                * Alle anderen Fenster auf dem Workspace sollten entweder verborgen oder minimiert werden, dies ist jedoch eine Compositor-Verantwortlichkeit, die durch Senden von `SystemEvent`s an den Compositor signalisiert werden sollte. Der Layout-Algorithmus gibt nur die Position des Fullscreen-Fensters zurück.
                * Gibt eine `HashMap` mit nur dem Fullscreen-Fenster und seiner neuen Position zurück.
            * **Fehlerbehandlung:** Wenn keine Fenster vorhanden sind, aber Fullscreen angefordert wird (sollte vom `WindowManager` abgefangen werden).
        * `fn get_layout_mode(&self) -> WindowLayoutMode { WindowLayoutMode::Fullscreen }`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_mechanics/layout_algorithms/fullscreen.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::window_mechanics::error::WindowMechanicsError`
    * `crate::window_mechanics::data_types::{WindowLayoutMode, WindowPosition, WindowLayoutInfo, WorkspaceLayout}`
    * `novade_system::compositor::data_types::WindowHandle`
    * `crate::window_mechanics::layout_algorithms::LayoutAlgorithm`
* **Extern:**
    * `std::collections::HashMap`
    * `tracing`

**Kommunikationsmuster:**

* Wird vom `WindowManager` aufgerufen, um ein Fenster im Fullscreen-Modus anzuordnen.

**Erwartete Ergebnisse/Outputs:**
Ein Algorithmus, der ein ausgewähltes Fenster den gesamten Anzeigebereich ausfüllen lässt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen von `apply_layout` mit einem einzelnen Fenster.
    * Testen mit mehreren Fenstern, um zu überprüfen, welches als Fullscreen-Fenster ausgewählt wird.
    * Überprüfen, ob die berechnete `WindowPosition` genau dem `container_rect` entspricht.

**Geschätzter Aufwand:** Niedrig (ca. 1-2 Tage, da die Logik sehr geradlinig ist)

---

### **novade-system/src/window_mechanics/layout_algorithms/stacked.rs**

**Verantwortlichkeit:**
Implementiert einen Stacked-Layout-Algorithmus, bei dem Fenster hintereinander gestapelt werden, oft mit einem sichtbaren Header oder Tab für jedes Fenster, das es erlaubt, den Fokus zu wechseln. Nur das oberste Fenster ist vollständig sichtbar.

**Kern-Aufgaben (Tasks):**

1.  **`StackedLayoutAlgorithm` Struct:**
    * `pub struct StackedLayoutAlgorithm {}`
    * Implementiere `Default` und `Debug`.

2.  **Implementierung des `LayoutAlgorithm` Traits:**
    * `impl LayoutAlgorithm for StackedLayoutAlgorithm {`
        * `fn apply_layout(&self, windows: &[WindowLayoutInfo], container_rect: &WindowPosition, layout_config: &WorkspaceLayout) -> Result<HashMap<WindowHandle, WindowPosition>, WindowMechanicsError>`
            * **Logik:**
                * Wählt das aktuell fokussierte oder das "führende" Fenster im Stack aus (z.B. das zuletzt hinzugefügte oder zuerst in der Liste).
                * Positioniert das führende Fenster so, dass es den größten Teil des `container_rect` einnimmt.
                * Die anderen Fenster werden hinter dem führenden Fenster gestapelt, möglicherweise mit einem kleinen Versatz (Offset) oder nur als "Header"/Tab sichtbar.
                * Die exakte Positionierung der "gestapelten" Fenster muss detailliert spezifiziert werden:
                    * **Option A (Minimalistisch):** Nur das fokussierte Fenster wird positioniert (auf `container_rect`). Andere Fenster erhalten eine unsichtbare Position oder es wird erwartet, dass der Compositor sie einfach hinter dem aktiven Fenster rendert.
                    * **Option B (Sichtbare Stacks):** Das fokussierte Fenster füllt den Hauptbereich. Am oberen oder unteren Rand des `container_rect` wird Platz für "Tabs" oder "Header" der anderen Fenster reserviert. Der Compositor muss dann in der Lage sein, diese "Tabs" zu rendern und Klicks darauf zu verarbeiten, um den Fokus zu wechseln. Diese Klicks würden dann als `DesktopEvent::WindowFocused` an den `WindowManager` gesendet.
                * Für diese Spezifikation wählen wir Option B, da es ein nützlicheres Layout darstellt. Die "Tabs" werden nicht vom Layout-Algorithmus gerendert, sondern deren Position im `container_rect` berechnet und der Compositor nutzt diese Info, um die Tabs zu platzieren.
                * Gibt eine `HashMap` von `WindowHandle` zu `WindowPosition` zurück.
            * **Fehlerbehandlung:** Wenn keine Fenster vorhanden sind.
        * `fn get_layout_mode(&self) -> WindowLayoutMode { WindowLayoutMode::Stacked }`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_mechanics/layout_algorithms/stacked.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::window_mechanics::error::WindowMechanicsError`
    * `crate::window_mechanics::data_types::{WindowLayoutMode, WindowPosition, WindowLayoutInfo, WorkspaceLayout}`
    * `novade_system::compositor::data_types::WindowHandle`
    * `crate::window_mechanics::layout_algorithms::LayoutAlgorithm`
* **Extern:**
    * `std::collections::HashMap`
    * `tracing`

**Kommunikationsmuster:**

* Wird vom `WindowManager` aufgerufen, um Fenster im Stacked-Modus anzuordnen.

**Erwartete Ergebnisse/Outputs:**
Ein Algorithmus, der Fenster hintereinander stapelt und das oberste Fenster sichtbar macht, während die anderen durch Header oder Tabs erreichbar sind.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen von `apply_layout` mit einem einzelnen Fenster (sollte den gesamten Bereich einnehmen).
    * Testen mit mehreren Fenstern: Überprüfen, ob das "führende" Fenster korrekt platziert ist und ob die berechneten Positionen für die "Tabs" (oder Header) der gestapelten Fenster korrekt sind (z.B. am oberen Rand).
    * Testen des Verhaltens bei Fokus-Wechsel (durch Simulieren des `windows` Arrays mit einem anderen fokussierten Fenster).

**Geschätzter Aufwand:** Mittel-Hoch (ca. 4-6 Tage, da die Logik für die Stapelung und die Berechnung der "Tab"-Positionen komplexer ist)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `mcp_client`, widmen wir uns `window_mechanics`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/window_mechanics/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/window_mechanics/data_types.rs`**: Datenstrukturen für Fenster und Layouts.
3.  **`novade-system/src/window_mechanics/layout_algorithms/mod.rs`**: Trait-Definition und Re-Exporte für Layout-Algorithmen.
4.  **`novade-system/src/window_mechanics/layout_algorithms/floating.rs`**: Einfachstes Layout, kann zuerst implementiert werden.
5.  **`novade-system/src/window_mechanics/layout_algorithms/fullscreen.rs`**: Ebenfalls relativ einfach.
6.  **`novade-system/src/window_mechanics/layout_algorithms/tiled.rs`**: Komplexer, da geometrische Berechnungen erforderlich sind.
7.  **`novade-system/src/window_mechanics/layout_algorithms/stacked.rs`**: Relativ komplex aufgrund der Stapel-Logik und der Notwendigkeit von "Tabs".
8.  **`novade-system/src/window_mechanics/manager.rs`**: Der Haupt-Orchestrator, der alle anderen Komponenten zusammenführt. Kann erst implementiert werden, wenn die Layout-Algorithmen und Datenstrukturen definiert sind.
9.  **`novade-system/src/window_mechanics/mod.rs`**: Das Hauptmodul, das den `WindowManager` initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/window_mechanics` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/power_management` Verzeichnisses.
### **novade-system/src/power_management/mod.rs**

**Verantwortlichkeit:**
Das `power_management` Modul ist für die Überwachung und Steuerung des Energieverbrauchs des Systems zuständig. Es interagiert hauptsächlich mit UPower (über D-Bus) und systemd-logind, um Batterieinformationen abzurufen, den Ladestatus zu überwachen und Aktionen wie Suspend, Hibernate oder Shutdown auszulösen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/power_management/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Energiemanagement-Operationen)
    * `data_types.rs` (Spezifische Datentypen für Energiegeräte und Aktionen)
    * `upower_monitor.rs` (Implementierung des UPower-D-Bus-Clients und Event-Monitors)
    * `logind_integrator.rs` (Implementierung für systemd-logind D-Bus-Interaktion)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Power Management Subsystems:**
    * `pub async fn initialize_power_management(event_bus: EventBus, dbus_connection: Connection) -> Result<PowerManager, PowerManagementError>`
    * **Logik:**
        * Erstellt eine Instanz von `upower_monitor::UPowerMonitor`.
        * Erstellt eine Instanz von `logind_integrator::LogindIntegrator`.
        * Startet den `UPowerMonitor` Event-Loop in einem separaten `tokio::spawn`-Task, um kontinuierlich UPower-Events zu überwachen.
        * Gibt ein gebündeltes `PowerManager` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung der D-Bus-Verbindung oder der Komponenten.

2.  **`PowerManager` Struct:**
    * `pub struct PowerManager {`
        * `upower_monitor: Arc<UPowerMonitor>,`
        * `logind_integrator: Arc<LogindIntegrator>,`
    * `}`
    * Dient als Container und Orchestrator für die Energiemanagement-Logik.

3.  **Event-Weiterleitung:**
    * Der `UPowerMonitor` empfängt D-Bus-Signale von UPower (z.B. `DeviceAdded`, `DeviceRemoved`, `PropertiesChanged`).
    * Diese UPower-Events werden in `SystemEvent`s übersetzt (z.B. `SystemEvent::BatteryStatusChanged`, `SystemEvent::PowerDeviceAdded`) und über den `EventBus` gesendet.
    * Der `LogindIntegrator` könnte ebenfalls Events von logind empfangen (z.B. `PrepareForShutdown`, `PrepareForSleep`) und als `SystemEvent`s weiterleiten, um die UI zu informieren.

4.  **Exponierte Funktionen zur Steuerung:**
    * Die `PowerManager` Instanz bietet über seine Komponenten (insbesondere `LogindIntegrator`) Methoden, um Aktionen wie Suspend, Hibernate oder Shutdown auszulösen.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_management::error::PowerManagementError`
    * `crate::power_management::upower_monitor::UPowerMonitor`
    * `crate::power_management::logind_integrator::LogindIntegrator`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
    * `novade_system::dbus_interfaces::upower_client::UPowerClient` (indirekt über UPowerMonitor)
    * `novade_system::dbus_interfaces::logind_client::LogindClient` (indirekt über LogindIntegrator)
* **Extern:**
    * `zbus::Connection`
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Initialisiert die D-Bus-Clients für UPower und logind.
* Überwacht UPower-Events und sendet sie an den `EventBus`.
* Empfängt Befehle über seine API, um Systemaktionen wie Suspend/Shutdown auszulösen.

**Erwartete Ergebnisse/Outputs:**
Ein vollständig initialisiertes Energiemanagement-Subsystem, das den Energie-Status des Systems überwacht, relevante Ereignisse bereitstellt und grundlegende Power-Aktionen auslösen kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `zbus::Connection` und den D-Bus-Clients (`UPowerClient`, `LogindClient`).
    * Testen der Initialisierung und Fehlerbehandlung.
    * Simulieren von UPower-Events und Überprüfen, ob die korrekten `SystemEvent`s an den `EventBus` gesendet werden.
    * Testen der Aufrufe an den `LogindIntegrator` für Suspend/Shutdown.
* **Integration Tests (mit realen UPower- und systemd-logind-Diensten):**
    * Starten des `PowerManager` im Compositor oder einem Test-Harness.
    * Überprüfen des initialen Batterie- und Gerätestatus.
    * Simulieren von Batterieänderungen (z.B. durch Entfernen des Netzteils) und Überprüfen der Events.
    * Manuelles Auslösen von Suspend/Shutdown über NovaDE-UI und Überprüfen der Systemreaktion (manuelle Bestätigung erforderlich).

**Geschätzter Aufwand:** Mittel (ca. 4-7 Tage, da D-Bus-Interaktion und Event-Handling)

---

### **novade-system/src/power_management/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `power_management` Subsystem der Systemschicht. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für Energiemanagement-bezogene Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`PowerManagementError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum PowerManagementError {`
        * `#[error("D-Bus error during power management operation: {0}")]`
        * `DbusError(#[from] crate::dbus_interfaces::error::DbusError),`
        * `#[error("Failed to parse UPower device information: {0}")]`
        * `ParsingError(String),`
        * `#[error("Unsupported power management feature: {0}")]`
        * `UnsupportedFeature(String),`
        * `#[error("Power management operation denied: {0}")]`
        * `PermissionDenied(String),`
        * `#[error("Unknown power management error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::dbus_interfaces::error::DbusError` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management/error.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `power_management` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an den aufrufenden `CompositorService` oder die Top-Level-Anwendung propagiert, um dort geloggt oder dem Benutzer angezeigt zu werden.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Energiemanagement-Subsystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/power_management/data_types.rs**

**Verantwortlichkeit:**
Definiert spezifische Datentypen (Structs, Enums) für das `power_management` Subsystem. Diese Typen repräsentieren den Zustand von Energiegeräten (Batterien, Netzteile) und die Arten von Power-Management-Aktionen.

**Kern-Aufgaben (Tasks):**

1.  **Definition von Power-Management-spezifischen Typen:**
    * **`PowerDeviceInfo` Struct:**
        * `pub struct PowerDeviceInfo { pub id: String, // UPower ObjectPath als String pub device_type: PowerDeviceType, pub model: String, pub vendor: String, pub serial: String, pub percentage: f64, pub state: PowerDeviceState, pub is_charging: bool, pub time_to_empty: Option<std::time::Duration>, pub time_to_full: Option<std::time::Duration>, pub energy_full: f64, pub energy_full_design: f64, pub voltage: f64, pub rate: f64, pub capacity: f64, // ... weitere relevante Felder aus UPower }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`.
    * **`PowerDeviceType` Enum:**
        * `pub enum PowerDeviceType { Battery, Mouse, Keyboard, Monitor, LinePower, Unknown }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
        * Implementiere `From<u32>` für die Konvertierung von UPower-Enums.
    * **`PowerDeviceState` Enum:**
        * `pub enum PowerDeviceState { Unknown, Charging, Discharging, Empty, Full, PendingCharge, PendingDischarge }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
        * Implementiere `From<u32>` für die Konvertierung von UPower-Enums.
    * **`PowerAction` Enum:**
        * `pub enum PowerAction { Suspend, Hibernate, Shutdown, Reboot, LockScreen }`
        * Ableitungen: `Debug`, `Clone`, `Copy`, `Eq`, `PartialEq`, `Hash`.
    * **`BatteryStatus` Struct:**
        * `pub struct BatteryStatus { pub percentage: f64, pub is_charging: bool, pub time_remaining: Option<std::time::Duration>, pub devices: Vec<PowerDeviceInfo>, }`
        * Ableitungen: `Debug`, `Clone`, `Default`, `Eq`, `PartialEq`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `std::time::Duration`
    * `serde::{Serialize, Deserialize}`
    * `std::collections::HashMap` (falls Metadaten als Map gespeichert werden)

**Kommunikationsmuster:**

* Diese Datenstrukturen werden vom `UPowerMonitor` erstellt, um den Power-Zustand darzustellen.
* Sie werden über `SystemEvent`s an den `EventBus` gesendet und von der UI-Schicht zur Anzeige verwendet.
* `PowerAction` wird als Parameter für die Methoden im `LogindIntegrator` verwendet.

**Erwartete Ergebnisse/Outputs:**
Eine Sammlung von robusten, typsicheren und gut definierten Datenstrukturen, die den Energiestatus des Systems repräsentieren und Aktionen steuern.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `Default` Implementierungen (falls vorhanden).
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` Ableitungen.
    * Testen der `From<u32>` Implementierungen für `PowerDeviceType` und `PowerDeviceState` mit gültigen und ungültigen Werten.
    * Testen der Serialisierung/Deserialisierung für relevante Structs/Enums.

**Geschätzter Aufwand:** Mittel (ca. 1-3 Tage, hauptsächlich Definitionen und Konvertierungslogik)

---

### **novade-system/src/power_management/upower_monitor.rs**

**Verantwortlichkeit:**
Implementiert die Überwachung von Energiegeräten über den UPower D-Bus-Dienst. Es agiert als D-Bus-Client, um den aktuellen Zustand abzufragen und auf Änderungen (Signale) zu reagieren, die es dann in `SystemEvent`s umwandelt und an den Event-Bus sendet.

**Kern-Aufgaben (Tasks):**

1.  **`UPowerMonitor` Struct:**
    * `pub struct UPowerMonitor {`
        * `upower_client: Arc<UPowerClient>,`
        * `event_bus: EventBus,`
        * `// Interner Cache des Gerätezustands, um Änderungen zu erkennen`
        * `cached_devices: RwLock<HashMap<ObjectPath, PowerDeviceInfo>>,`
    * `}`

2.  **`UPowerMonitor::new()` Funktion:**
    * `pub async fn new(dbus_connection: Connection, event_bus: EventBus) -> Result<Self, PowerManagementError>`
    * **Logik:**
        * Erstellt eine Instanz von `dbus_interfaces::upower_client::UPowerClient`.
        * Initialisiert den internen `cached_devices` HashMap.
        * Ruft initial alle vorhandenen Geräte über `upower_client.enumerate_devices()` ab und speichert sie im Cache.
        * Gibt `Self` zurück.

3.  **Event-Loop (`run` Methode):**
    * `pub async fn run(self) -> Result<(), PowerManagementError>`
    * **Logik:**
        * Registriert sich für die D-Bus-Signale von UPower:
            * `org.freedesktop.UPower.DeviceAdded(object_path)`
            * `org.freedesktop.UPower.DeviceRemoved(object_path)`
            * `org.freedesktop.DBus.Properties.PropertiesChanged(interface_name, changed_properties, invalidated_properties)` auf den Geräte-Objektpfaden (`org.freedesktop.UPower.Device`).
        * Endlose Schleife, die auf diese Signale hört.
        * Bei `DeviceAdded`:
            * Ruft `upower_client.get_device_properties(object_path)` auf.
            * Konvertiert die D-Bus-Properties in `PowerDeviceInfo`.
            * Speichert die neuen Geräte im Cache und sendet `SystemEvent::PowerDeviceAdded(PowerDeviceInfo)` an den `EventBus`.
        * Bei `DeviceRemoved`:
            * Entfernt das Gerät aus dem Cache und sendet `SystemEvent::PowerDeviceRemoved(object_path)` an den `EventBus`.
        * Bei `PropertiesChanged` (für ein UPower-Device):
            * Ruft die aktualisierten Eigenschaften vom UPower-Device ab.
            * Vergleicht sie mit dem `cached_devices` Zustand.
            * Wenn relevante Eigenschaften (z.B. `percentage`, `state`, `is_charging`) geändert wurden:
                * Aktualisiert den Cache.
                * Sendet `SystemEvent::BatteryStatusChanged(BatteryStatus)` oder `SystemEvent::PowerDevicePropertiesChanged(PowerDeviceInfo)` an den `EventBus`. Dabei muss die `BatteryStatus` von den `PowerDeviceInfo` Werten aller Batterien aggregiert werden.
        * Stellt sicher, dass die D-Bus-Verbindung stabil bleibt.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management/upower_monitor.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_management::error::PowerManagementError`
    * `crate::power_management::data_types::{PowerDeviceInfo, PowerDeviceType, PowerDeviceState, BatteryStatus}`
    * `crate::dbus_interfaces::upower_client::UPowerClient`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus::{Connection, zvariant::ObjectPath}`
    * `tokio::task`
    * `tokio::sync::RwLock`
    * `tracing`
    * `std::sync::Arc`
    * `std::collections::HashMap`

**Kommunikationsmuster:**

* Agiert als D-Bus-Client und abonniert D-Bus-Signale.
* Fragt den UPower-Dienst nach Geräteinformationen ab.
* Sendet `SystemEvent`s an den `EventBus`.

**Erwartete Ergebnisse/Outputs:**
Ein robuster UPower-Monitor, der den Energiestatus des Systems dynamisch verfolgt und Änderungen an NovaDE meldet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `UPowerClient` und `EventBus`.
    * Simulieren von `enumerate_devices` Antworten und Überprüfen des initialen Caches.
    * Simulieren von `DeviceAdded`, `DeviceRemoved` Signalen und Überprüfen der Cache-Updates und gesendeten Events.
    * Simulieren von `PropertiesChanged` Signalen mit verschiedenen Attributänderungen und Überprüfen der `BatteryStatus` Aggregation und gesendeten Events.
    * Testen der Konvertierung von D-Bus-Typen zu `PowerDeviceInfo`.
* **Integration Tests (mit realem UPower-Daemon):**
    * Starten des `UPowerMonitor` und Überprüfen des initialen Zustands.
    * Physisches Ein-/Ausstecken des Netzteils oder Entladen/Laden der Batterie und Überprüfen, ob die korrekten `SystemEvent`s generiert werden.
    * Verwenden von `upower --dump` zur Überprüfung der Konsistenz des UPower-Zustands mit dem, was vom Monitor gemeldet wird.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da komplexe D-Bus-Signale, Zustandsmanagement und Aggregation)

---

### **novade-system/src/power_management/logind_integrator.rs**

**Verantwortlichkeit:**
Integriert NovaDE mit dem systemd-logind D-Bus-Dienst, um Systemaktionen wie Suspend, Hibernate, Reboot und Shutdown auszulösen und den Zustand von Benutzersitzungen zu verwalten.

**Kern-Aufgaben (Tasks):**

1.  **`LogindIntegrator` Struct:**
    * `pub struct LogindIntegrator {`
        * `logind_client: Arc<LogindClient>,`
        * `event_bus: EventBus,`
        * `// Optional: Cache für Session-Informationen, wenn benötigt`
        * `// current_session_id: String,`
    * `}`

2.  **`LogindIntegrator::new()` Funktion:**
    * `pub async fn new(dbus_connection: Connection, event_bus: EventBus) -> Result<Self, PowerManagementError>`
    * **Logik:**
        * Erstellt eine Instanz von `dbus_interfaces::logind_client::LogindClient`.
        * Optional: Fragt die aktuelle Session-ID ab (`logind_client.get_session_by_pid()`).
        * Gibt `Self` zurück.

3.  **Implementierung der Public API für Systemaktionen:**
    * `pub async fn suspend(&self) -> Result<(), PowerManagementError>`
        * Ruft `logind_client.call_method("Suspend", &(false))` auf. (Parameter `_interactive` ist `false` für Non-Interactive Suspend).
        * Behandelt D-Bus-Fehler, insbesondere `org.freedesktop.DBus.Error.AccessDenied`.
    * `pub async fn hibernate(&self) -> Result<(), PowerManagementError>`
        * Ruft `logind_client.call_method("Hibernate", &(false))` auf.
    * `pub async fn shutdown(&self) -> Result<(), PowerManagementError>`
        * Ruft `logind_client.call_method("PowerOff", &(false))` auf.
    * `pub async fn reboot(&self) -> Result<(), PowerManagementError>`
        * Ruft `logind_client.call_method("Reboot", &(false))` auf.
    * `pub async fn lock_screen(&self) -> Result<(), PowerManagementError>`
        * Ruft `logind_client.call_method("LockSession", &(session_id))` auf, wobei `session_id` die aktuelle logind-Session-ID ist. NovaDE muss die eigene Session-ID kennen (z.B. über `logind_client.get_session_by_pid(current_pid)`).
        * Sendet `SystemEvent::LockScreenRequested` an den `EventBus`, um die UI-Schicht zur Anzeige eines Sperrbildschirms aufzufordern.
    * `pub async fn unlock_screen(&self) -> Result<(), PowerManagementError>`
        * Ruft `logind_client.call_method("UnlockSession", &(session_id))` auf.
        * Sendet `SystemEvent::UnlockScreenRequested`.

4.  **Handling von logind-Signalen (optional, aber empfohlen):**
    * `logind` kann Signale senden wie `PrepareForShutdown` oder `PrepareForSleep`. Der `LogindIntegrator` sollte diese abonnieren und entsprechende `SystemEvent`s (z.B. `SystemEvent::SystemPreparingForSleep`) an den `EventBus` senden, damit andere Komponenten des DE darauf reagieren können (z.B. Speichern des Zustands).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management/logind_integrator.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_management::error::PowerManagementError`
    * `crate::power_management::data_types::PowerAction`
    * `crate::dbus_interfaces::logind_client::LogindClient`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus::Connection`
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `std::process` (für `get_pid`)

**Kommunikationsmuster:**

* Agiert als D-Bus-Client, um Methoden auf dem `systemd-logind` Dienst aufzurufen.
* Kann D-Bus-Signale von `logind` abonnieren und `SystemEvent`s senden.
* Sendet `SystemEvent`s an den `EventBus` für Screen Lock/Unlock.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Integrator für systemd-logind, der NovaDE die sichere und privilegierte Ausführung von Systemaktionen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `LogindClient` und `EventBus`.
    * Testen der Methoden `suspend`, `hibernate`, `shutdown`, `reboot`, `lock_screen`, `unlock_screen` und Überprüfen der korrekten D-Bus-Methodenaufrufe und Parameter.
    * Simulieren von `AccessDenied` Fehlern vom `LogindClient`.
    * Testen der `SystemEvent` Generierung für Lock/Unlock und `PrepareForSleep/Shutdown` Signale.
* **Integration Tests (mit einem realen systemd-logind Dienst):**
    * Starten des `LogindIntegrator` in einer Testumgebung (Vorsicht bei realen Shutdown/Reboot-Tests!).
    * Testen von `lock_screen` und `unlock_screen` (manuell überprüfen, ob der Sperrbildschirm erscheint/verschwindet).
    * Für Suspend/Hibernate/Shutdown/Reboot, wenn möglich, Mocking auf OS-Ebene oder in einer VM, um tatsächliche Systemänderungen zu vermeiden. Alternativ: Nur Überprüfung der D-Bus-Aufrufe, wenn die tatsächliche Ausführung zu riskant ist.

**Geschätzter Aufwand:** Mittel (ca. 5-8 Tage, da D-Bus-Interaktion mit privilegierten Aktionen und Session-Management)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `window_mechanics`, widmen wir uns `power_management`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/power_management/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/power_management/data_types.rs`**: Datenstrukturen für Power-Informationen und Aktionen.
3.  **`novade-system/src/power_management/upower_monitor.rs`**: Da UPower für die Überwachung des Batteriestatus und anderer Geräte unerlässlich ist, ist dieser wichtig für die UI-Anzeige und automatisierte Reaktionen.
4.  **`novade-system/src/power_management/logind_integrator.rs`**: Für das Auslösen von Systemaktionen (Suspend, Shutdown, Lock Screen), die eine kritische Funktionalität darstellen.
5.  **`novade-system/src/power_management/mod.rs`**: Das Hauptmodul, das die Monitore und Integratoren initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/power_management` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/notification_manager` Verzeichnisses.
### **novade-system/src/notification_manager/mod.rs**

**Verantwortlichkeit:**
Das `notification_manager` Modul ist für den Empfang, die Verarbeitung und die Weiterleitung von Desktop-Benachrichtigungen zuständig. Es implementiert den D-Bus-Dienst `org.freedesktop.Notifications`, um Benachrichtigungen von Anwendungen (wie Firefox, Discord etc.) entgegenzunehmen. Anschließend leitet es diese Benachrichtigungen als `SystemEvent`s an die UI-Schicht zur Anzeige weiter und verwaltet den Lebenszyklus der Benachrichtigungen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/notification_manager/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Benachrichtigungs-Operationen)
    * `data_types.rs` (Spezifische Datentypen für Benachrichtigungen)
    * `dbus_service.rs` (Implementierung des `org.freedesktop.Notifications` D-Bus-Dienstes)
    * `manager.rs` (Interner Manager für Benachrichtigungen, z.B. Historie, Timeout)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Notification Management Subsystems:**
    * `pub async fn initialize_notification_manager(event_bus: EventBus, dbus_connection: Connection) -> Result<NotificationManagerService, NotificationError>`
    * **Logik:**
        * Erstellt eine Instanz von `dbus_service::NotificationDbusService` und registriert diesen als D-Bus-Dienst (`org.freedesktop.Notifications`) auf dem Session-Bus.
        * Erstellt eine Instanz von `manager::NotificationManager` (interner Zustand).
        * Die `NotificationDbusService` Instanz muss den `NotificationManager` nutzen, um empfangene Benachrichtigungen zu verarbeiten.
        * Startet die Event-Loops für den D-Bus-Service und den internen Manager in separaten `tokio::spawn`-Tasks.
        * Gibt ein gebündeltes `NotificationManagerService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung der D-Bus-Verbindung, Registrierung des Dienstes oder der Manager-Komponenten.

2.  **`NotificationManagerService` Struct:**
    * `pub struct NotificationManagerService {`
        * `dbus_service_handle: Arc<NotificationDbusService>,`
        * `internal_manager: Arc<NotificationManager>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Benachrichtigungs-Logik.

3.  **Benachrichtigungs-Fluss:**
    * Externe Anwendungen senden D-Bus-Methodenaufrufe an `org.freedesktop.Notifications` (`Notify` Methode).
    * `dbus_service.rs` empfängt diese Anfragen, parst sie und übergibt die Daten an `manager.rs`.
    * `manager.rs` verarbeitet die Benachrichtigung (z.B. vergibt eine ID, setzt Timeout, speichert sie in einer Historie).
    * `manager.rs` sendet dann ein `SystemEvent::NotificationReceived(Notification)` über den `EventBus` an die UI-Schicht.
    * Die UI-Schicht zeigt die Benachrichtigung an und kann Interaktionen zurücksenden (z.B. "close", "action clicked") als `SystemEvent`s an den `EventBus`.
    * `manager.rs` abonniert diese `SystemEvent`s, um den Zustand der Benachrichtigung zu aktualisieren oder Callback-Methoden an die ursprüngliche sendende Anwendung über D-Bus zu senden (`ActionInvoked`, `NotificationClosed`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_manager/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::notification_manager::error::NotificationError`
    * `crate::notification_manager::data_types::Notification`
    * `crate::notification_manager::dbus_service::NotificationDbusService`
    * `crate::notification_manager::manager::NotificationManager`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus::Connection`
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Implementiert einen D-Bus-Dienst, um Benachrichtigungen zu empfangen.
* Leitet empfangene Benachrichtigungen über den `EventBus` an die UI weiter.
* Empfängt UI-Interaktionen (z.B. Schließen) über den `EventBus` und sendet D-Bus-Signale zurück an die sendende Anwendung.

**Erwartete Ergebnisse/Outputs:**
Ein voll funktionsfähiges Benachrichtigungssystem, das Desktop-Benachrichtigungen von Anwendungen empfängt, verarbeitet und an die NovaDE-UI weiterleitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `zbus::Connection` und `EventBus`.
    * Testen der Initialisierung des D-Bus-Dienstes und des Managers.
    * Simulieren von `Notify` D-Bus-Aufrufen und Überprüfen, ob die Benachrichtigungen korrekt geparst und als `SystemEvent`s gesendet werden.
    * Simulieren von `SystemEvent`s von der UI (z.B. "close") und Überprüfen, ob die entsprechenden D-Bus-Signale (`ActionInvoked`, `NotificationClosed`) zurückgesendet werden.
* **Integration Tests (mit realen D-Bus-Diensten und `notify-send`):**
    * Starten des `NotificationManagerService`.
    * Verwenden von `notify-send` in einem Terminal, um Test-Benachrichtigungen zu senden und zu überprüfen, ob sie korrekt im NovaDE-UI angezeigt werden (oder ob die `SystemEvent`s korrekt generiert werden).
    * Testen von Aktionen auf Benachrichtigungen und Überprüfen der Callback-Funktionalität.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da D-Bus-Dienst-Implementierung, Protokoll-Parsing und Zustandsmanagement)

---

### **novade-system/src/notification_manager/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `notification_manager` Subsystem der Systemschicht. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für Benachrichtigungs-bezogene Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum NotificationError {`
        * `#[error("D-Bus error during notification operation: {0}")]`
        * `DbusError(#[from] zbus::Error),` // Direkter zbus Fehler, da D-Bus Service
        * `#[error("Invalid notification data: {0}")]`
        * `InvalidData(String),`
        * `#[error("Notification not found: {0}")]`
        * `NotFound(String),`
        * `#[error("Failed to process notification action: {0}")]`
        * `ActionProcessingFailed(String),`
        * `#[error("Unknown notification error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `zbus::Error` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_manager/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `zbus::Error`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `notification_manager` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an den aufrufenden `CompositorService` oder die Top-Level-Anwendung propagiert, um dort geloggt oder dem Benutzer angezeigt zu werden.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Benachrichtigungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/notification_manager/data_types.rs**

**Verantwortlichkeit:**
Definiert spezifische Datentypen (Structs, Enums) für das `notification_manager` Subsystem. Diese Typen repräsentieren Desktop-Benachrichtigungen gemäß der `org.freedesktop.Notifications` Spezifikation.

**Kern-Aufgaben (Tasks):**

1.  **Definition von Benachrichtigungs-spezifischen Typen:**
    * **`Notification` Struct:**
        * `pub struct Notification { pub id: u32, // Eindeutige ID der Benachrichtigung, 0 für neue pub app_name: String, pub replaces_id: u32, // ID der zu ersetzenden Benachrichtigung pub app_icon: String, // Icon-Name oder Pfad pub summary: String, // Kurzer Titel pub body: String, // Langer Text pub actions: Vec<(String, String)>, // (Action ID, Label) pub hints: HashMap<String, zbus::zvariant::Value>, // Zusätzliche Hinweise pub expire_timeout: i32, // Timeout in ms, -1 für niemals, 0 für Standard pub created_at: chrono::DateTime<chrono::Utc>, // Wann die Benachrichtigung empfangen wurde pub status: NotificationStatus, // Interner Status (z.B. angezeigt, geschlossen) }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `Default`.
        * Implementiere eine `new()`-Methode, die eine neue ID generiert und `created_at` setzt.
    * **`NotificationStatus` Enum:**
        * `pub enum NotificationStatus { New, Displayed, ClosedByUser, ClosedByTimeout, ActionInvoked, Dismissed }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
    * **`NotificationCapabilities` Struct:**
        * `pub struct NotificationCapabilities { pub body: bool, pub actions: bool, pub persistence: bool, pub sound: bool, // ... weitere Fähigkeiten, die der Notif-Server unterstützt }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `Default`.
        * Wird von `dbus_service.rs` in der `GetCapabilities` Methode verwendet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_manager/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `std::collections::HashMap`
    * `zbus::zvariant::Value`
    * `chrono::{DateTime, Utc}`
    * `serde::{Serialize, Deserialize}` (für interne Speicherung oder IPC, wenn nötig)

**Kommunikationsmuster:**

* Diese Datenstrukturen werden vom `NotificationDbusService` aus D-Bus-Nachrichten erstellt.
* Sie werden vom `NotificationManager` intern verwaltet.
* `Notification` Instanzen werden als Teil von `SystemEvent::NotificationReceived` über den `EventBus` gesendet.

**Erwartete Ergebnisse/Outputs:**
Eine Sammlung von robusten, typsicheren und gut definierten Datenstrukturen, die Desktop-Benachrichtigungen abbilden und deren Zustand verwalten.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `Default` Implementierungen.
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq` Ableitungen.
    * Testen der `new()`-Methode von `Notification` (ID-Generierung, Zeitstempel).
    * Testen der Konvertierung von D-Bus-Typen (z.B. `zbus::zvariant::Value`) in die `Notification` Felder (wird primär in `dbus_service.rs` getestet, aber die Struktur selbst sollte korrekt sein).
    * Testen von Edge-Cases für die Datenfelder (leere Strings, leere Vektoren, negative Timeouts).

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage, hauptsächlich Definitionen und grundlegende Logik)

---

### **novade-system/src/notification_manager/dbus_service.rs**

**Verantwortlichkeit:**
Implementiert den D-Bus-Dienst `org.freedesktop.Notifications`. Es ist der Endpunkt für externe Anwendungen, um Benachrichtigungen an NovaDE zu senden. Dieser Dienst parst die eingehenden D-Bus-Nachrichten und übergibt die Benachrichtigungsdaten an den internen `NotificationManager`.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationDbusService` Struct:**
    * `pub struct NotificationDbusService {`
        * `notification_manager: Arc<NotificationManager>,`
        * `event_bus: EventBus,` // Für D-Bus-Signale an die UI, z.B. wenn Notif geschlossen
        * `// Interner Zustand für D-Bus-Mapping, z.B. für ReplaceID und Notification ID`
    * `}`

2.  **`NotificationDbusService::new()` Funktion:**
    * `pub async fn new(notification_manager: Arc<NotificationManager>, event_bus: EventBus) -> Result<Self, NotificationError>`
    * **Logik:**
        * Speichert die Referenzen zum `NotificationManager` und `EventBus`.
        * Gibt `Self` zurück.

3.  **Implementierung des D-Bus-Interfaces (`org.freedesktop.Notifications`):**
    * Nutzt `zbus::fdo::Result` und `zbus::dbus_interface` Makros.
    * **`Notify` Method:**
        * `#[dbus_interface(name = "org.freedesktop.Notifications", method = "Notify")]`
        * `async fn notify(&self, app_name: String, replaces_id: u32, app_icon: String, summary: String, body: String, actions: Vec<String>, hints: HashMap<String, zbus::zvariant::Value>, expire_timeout: i32) -> zbus::fdo::Result<u32>`
            * **Logik:**
                * Parst die `actions` `Vec<String>` in `Vec<(String, String)>` (Action ID, Label).
                * Erstellt eine `Notification` Instanz aus den D-Bus-Parametern.
                * Ruft `notification_manager.add_notification(notification_instance)` auf.
                * Der `notification_manager` generiert eine neue ID für die Benachrichtigung (oder verwendet `replaces_id`).
                * Gibt die generierte/ersetzte ID zurück.
                * **Fehlerbehandlung:** Validierung der Eingabedaten, Fehler bei der Weiterleitung an den Manager.
    * **`GetCapabilities` Method:**
        * `#[dbus_interface(name = "org.freedesktop.Notifications", method = "GetCapabilities")]`
        * `fn get_capabilities(&self) -> zbus::fdo::Result<Vec<String>>`
            * **Logik:**
                * Gibt die unterstützten Fähigkeiten zurück (z.B. "body", "actions", "persistence", "sound"). Diese sollten in `data_types.rs` als `NotificationCapabilities` definiert sein.
    * **`CloseNotification` Method:**
        * `#[dbus_interface(name = "org.freedesktop.Notifications", method = "CloseNotification")]`
        * `async fn close_notification(&self, id: u32) -> zbus::fdo::Result<()>`
            * **Logik:**
                * Ruft `notification_manager.close_notification(id, CloseReason::Programmatically)` auf.
                * Sendet `SystemEvent::NotificationClosed(id, CloseReason)` an den `EventBus`, um die UI zu informieren.
    * **`GetServerInformation` Method:**
        * `#[dbus_interface(name = "org.freedesktop.Notifications", method = "GetServerInformation")]`
        * `fn get_server_information(&self) -> zbus::fdo::Result<(String, String, String, String)>`
            * **Logik:**
                * Gibt Informationen über den Benachrichtigungsserver zurück: `(name, vendor, version, spec_version)`. Z.B. `("NovaDE Notifications", "NovaDE Team", "0.1", "1.2")`.

4.  **D-Bus-Signale (zurück an die sendende Anwendung):**
    * Der `NotificationDbusService` muss D-Bus-Signale senden können, wenn eine Benachrichtigung geschlossen wird oder eine Aktion ausgelöst wird.
    * `#[dbus_interface(signal = "NotificationClosed")]`
    * `async fn notification_closed(&self, id: u32, reason: u32);` // reason: 1=expired, 2=dismissed by user, 3=closed programmatically, 4=undefined.
    * `#[dbus_interface(signal = "ActionInvoked")]`
    * `async fn action_invoked(&self, id: u32, action_key: String);`
    * Diese Signale werden vom `NotificationManager` ausgelöst (indem er die Methode auf dem `NotificationDbusService` aufruft), wenn er ein `SystemEvent` von der UI empfängt.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_manager/dbus_service.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::notification_manager::error::NotificationError`
    * `crate::notification_manager::data_types::{Notification, NotificationCapabilities, NotificationStatus}`
    * `crate::notification_manager::manager::NotificationManager`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus::{Connection, fdo::Result, dbus_interface}`
    * `zbus::zvariant::{ObjectPath, Value}`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `tracing`

**Kommunikationsmuster:**

* Implementiert den D-Bus-Server für `org.freedesktop.Notifications`.
* Empfängt D-Bus-Methodenaufrufe und parst sie.
* Ruft Methoden auf dem `NotificationManager` auf und sendet D-Bus-Signale.

**Erwartete Ergebnisse/Outputs:**
Ein robuster D-Bus-Dienst, der es externen Anwendungen ermöglicht, Benachrichtigungen über das standardmäßige FreeDesktop.org-Protokoll an NovaDE zu senden.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `NotificationManager` und `EventBus`.
    * Testen der `notify` Methode mit verschiedenen Parametern (verschiedene `app_name`, `summary`, `body`, `actions`, `hints`, `expire_timeout`).
    * Überprüfen, ob die `Notification` Instanz korrekt erstellt und an den `NotificationManager` übergeben wird.
    * Testen von `get_capabilities`, `close_notification`, `get_server_information`.
    * Simulieren von `NotificationManager` Aufrufen für `notification_closed` und `action_invoked` Signale und Überprüfen, ob die Signale korrekt gesendet werden.
* **Integration Tests (mit `zbus::blocking::Connection` und `notify-send`):**
    * Starten des `NotificationDbusService` auf einem Test-D-Bus-Bus.
    * Verwenden von `notify-send` oder einem anderen Client, um D-Bus-Methodenaufrufe an den Dienst zu senden.
    * Überprüfen der Rückgabewerte und der generierten Signale.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da D-Bus-Interface-Implementierung und strenge Protokollkonformität erforderlich ist)

---

### **novade-system/src/notification_manager/manager.rs**

**Verantwortlichkeit:**
Der `NotificationManager` ist das interne Herzstück des Benachrichtigungssystems. Er verwaltet den Lebenszyklus von Benachrichtigungen: Speichern, Aktualisieren, Timeout, und das Senden von Ereignissen an die UI sowie von Rückmeldungen an die sendenden Anwendungen.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationManager` Struct:**
    * `pub struct NotificationManager {`
        * `event_bus: EventBus,`
        * `// Arc<NotificationDbusService> wird nicht direkt hier gehalten, um Zirkelabhängigkeit zu vermeiden.`
        * `// Stattdessen wird über den EventBus kommuniziert, oder die D-Bus-Signale werden vom `NotificationDbusService` selbst ausgelöst, nachdem der Manager ihn dazu anweist.`
        * `active_notifications: RwLock<HashMap<u32, Notification>>,` // Aktive Benachrichtigungen
        * `next_notification_id: Arc<AtomicU32>,` // Atomarer Zähler für Benachrichtigungs-IDs
        * `// Sende-Kanäle für die D-Bus-Signale an den `NotificationDbusService` (oder eine Callback-Methode).`
        * `dbus_signal_sender: mpsc::Sender<NotificationSignalEvent>,` // Channel, um Signale an den DbusService zu senden
    * `}`

2.  **`NotificationManager::new()` Funktion:**
    * `pub async fn new(event_bus: EventBus, dbus_signal_sender: mpsc::Sender<NotificationSignalEvent>) -> Result<Self, NotificationError>`
    * **Logik:**
        * Initialisiert die internen HashMaps und den atomaren Zähler.
        * Abonniert relevante `SystemEvent`s vom `EventBus`, die von der UI kommen (z.B. "Benachrichtigung geschlossen", "Aktion geklickt").
        * Startet einen `tokio::spawn` Task für den Event-Loop, der auf diese Events hört.

3.  **`NotificationManager::add_notification()` Methode:**
    * `pub async fn add_notification(&self, mut notification: Notification) -> Result<u32, NotificationError>`
    * **Logik:**
        * Wenn `notification.replaces_id` ungleich 0 ist:
            * Sucht die zu ersetzende Benachrichtigung in `active_notifications`.
            * Aktualisiert diese mit den neuen Daten.
            * Sendet `SystemEvent::NotificationUpdated(notification_id)` an den `EventBus`.
            * Wenn nicht gefunden, behandelt als neue Benachrichtigung.
        * Wenn `notification.replaces_id` gleich 0 ist:
            * Generiert eine neue `notification.id` mit `next_notification_id.fetch_add(1, Ordering::SeqCst)`.
            * Speichert die neue Benachrichtigung in `active_notifications`.
            * Sendet `SystemEvent::NotificationReceived(notification)` an den `EventBus`.
        * Startet einen `tokio::spawn` Task für den `expire_timeout`, falls `expire_timeout > 0`. Dieser Task sollte nach Ablauf des Timeouts `close_notification` mit `CloseReason::Expired` aufrufen.
        * Gibt die `notification.id` zurück.

4.  **`NotificationManager::close_notification()` Methode:**
    * `pub async fn close_notification(&self, id: u32, reason: NotificationCloseReason) -> Result<(), NotificationError>`
    * **Logik:**
        * Entfernt die Benachrichtigung aus `active_notifications`.
        * Sendet `SystemEvent::NotificationClosed(id, reason)` an den `EventBus`, um die UI zu informieren.
        * Sendet ein `NotificationSignalEvent::NotificationClosed(id, reason_code)` über den `dbus_signal_sender` an den `NotificationDbusService`, der dann das D-Bus-Signal `NotificationClosed` an die ursprüngliche Anwendung sendet.

5.  **Event-Loop (`run` Methode):**
    * `async fn run(self) -> Result<(), NotificationError>`
    * **Logik:**
        * Schleife, die auf `SystemEvent`s vom `EventBus` wartet.
        * Bei `SystemEvent::NotificationActionInvoked(id, action_key)`:
            * Sucht die Benachrichtigung in `active_notifications`.
            * Sendet ein `NotificationSignalEvent::ActionInvoked(id, action_key)` über den `dbus_signal_sender`.
        * Bei `SystemEvent::NotificationUiClosed(id)`:
            * Ruft `self.close_notification(id, CloseReason::DismissedByUser)` auf.
        * Bei anderen relevanten Events (z.B. System-Suspend, die eine temporäre Pause von Benachrichtigungen erfordern könnten).

6.  **`NotificationSignalEvent` Enum:**
    * `pub enum NotificationSignalEvent { NotificationClosed(u32, u32), // id, reason_code ActionInvoked(u32, String), // id, action_key }`
    * Wird verwendet, um asynchron Signale an den `NotificationDbusService` zu senden.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_manager/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::notification_manager::error::NotificationError`
    * `crate::notification_manager::data_types::{Notification, NotificationStatus}`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tokio::sync::{RwLock, mpsc}`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `std::sync::atomic::{AtomicU32, Ordering}`
    * `tracing`
    * `chrono::Utc`
    * `std::time::Duration`

**Kommunikationsmuster:**

* Empfängt `Notification` Instanzen vom `NotificationDbusService` (indirekt über `add_notification`).
* Empfängt `SystemEvent`s von der UI über den `EventBus`.
* Sendet `SystemEvent`s an die UI über den `EventBus`.
* Sendet `NotificationSignalEvent`s an den `NotificationDbusService` über einen `mpsc::Sender` für D-Bus-Signale.

**Erwartete Ergebnisse/Outputs:**
Ein stabiler und reaktionsschneller Benachrichtigungs-Manager, der die Benachrichtigungs-Historie verwaltet und die korrekte Kommunikation zwischen Anwendungen, NovaDE-internen Komponenten und der UI sicherstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `EventBus` und `dbus_signal_sender`.
    * Testen von `add_notification`: neue Benachrichtigungen, Ersetzen von Benachrichtigungen, ID-Generierung, Starten des Timeouts.
    * Testen von `close_notification`: Entfernen aus dem Cache, Senden von `SystemEvent`s und D-Bus-Signalen.
    * Simulieren von `SystemEvent::NotificationActionInvoked` und `SystemEvent::NotificationUiClosed` und Überprüfen des Managers-Verhaltens.
    * Testen der Timeout-Logik (kann durch `tokio::time::advance` in Tests beschleunigt werden).
* **Integration Tests:**
    * Der `NotificationManager` ist stark mit dem `NotificationDbusService` und der UI (über EventBus) verknüpft. Integrationstests würden die Interaktionen zwischen diesen Komponenten testen.

**Geschätzter Aufwand:** Hoch (ca. 10-15 Tage, da komplexe Zustandsverwaltung, ID-Management, Timeout-Logik und asynchrone Kommunikation)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `power_management`, widmen wir uns `notification_manager`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/notification_manager/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/notification_manager/data_types.rs`**: Datenstrukturen für Benachrichtigungen.
3.  **`novade-system/src/notification_manager/manager.rs`**: Das Herzstück der Benachrichtigungsverwaltung. Es ist notwendig, dass die Kernlogik und das Zustandsmanagement stehen, bevor der D-Bus-Service ihn nutzen kann.
4.  **`novade-system/src/notification_manager/dbus_service.rs`**: Implementiert das D-Bus-Interface, das den `NotificationManager` als Backend nutzt.
5.  **`novade-system/src/notification_manager/mod.rs`**: Das Hauptmodul, das den D-Bus-Dienst und den Manager initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/notification_manager` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/screen_capture` Verzeichnisses, gefolgt von `dbus_interfaces`.
### **novade-system/src/screen_capture/mod.rs**

**Verantwortlichkeit:**
Das `screen_capture` Modul ermöglicht das Erstellen von Screenshots und Bildschirmaufzeichnungen. Es interagiert mit dem Wayland-Compositor (über PipeWire und/oder spezialisierte Wayland-Protokolle wie `xdg-desktop-portal` für Screencasting/Screenshots) und anderen Systemdiensten, um die Bildschirmdaten zu erfassen und zu speichern.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/screen_capture/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Screen-Capture-Operationen)
    * `data_types.rs` (Spezifische Datentypen für Capture-Optionen und -Ergebnisse)
    * `screenshot.rs` (Implementierung für Screenshot-Funktionalität)
    * `screencast.rs` (Implementierung für Bildschirmaufzeichnung)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Screen Capture Subsystems:**
    * `pub async fn initialize_screen_capture(event_bus: EventBus) -> Result<ScreenCaptureService, ScreenCaptureError>`
    * **Logik:**
        * Erstellt eine Instanz von `screenshot::ScreenshotCapturer`.
        * Erstellt eine Instanz von `screencast::ScreencastRecorder`.
        * Gibt ein gebündeltes `ScreenCaptureService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung der internen Komponenten oder der zugrunde liegenden Wayland/PipeWire-Verbindungen.

2.  **`ScreenCaptureService` Struct:**
    * `pub struct ScreenCaptureService {`
        * `pub screenshot_capturer: Arc<ScreenshotCapturer>,`
        * `pub screencast_recorder: Arc<ScreencastRecorder>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Bildschirmaufnahme-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `ScreenCaptureService` exponiert Methoden, um Screenshots aufzunehmen oder eine Bildschirmaufzeichnung zu starten/stoppen. Diese Methoden delegieren an die jeweiligen Untermodule.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/screen_capture/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::screen_capture::error::ScreenCaptureError`
    * `crate::screen_capture::data_types::*`
    * `crate::screen_capture::screenshot::ScreenshotCapturer`
    * `crate::screen_capture::screencast::ScreencastRecorder`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent` (optional, um Capture-Erfolge/Fehler zu melden)
* **Extern (potenziell):**
    * `xdg-desktop-portal` (über D-Bus, für Wayland-Kompatibilität)
    * `pipewire-rs` (für den Zugriff auf Video-Streams des Compositors)
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Der `ScreenCaptureService` wird von anderen System-Services oder der Domänenschicht aufgerufen, um Bildschirmaufnahmen zu initiieren.
* Es kann `SystemEvent`s an den `EventBus` senden, um den Abschluss einer Aufnahme oder Fehler zu signalisieren.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Subsystem, das in der Lage ist, Screenshots zu erstellen und Bildschirmaufzeichnungen durchzuführen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken der zugrunde liegenden Wayland-Protokolle oder PipeWire-Interaktionen.
    * Testen der Initialisierung des Dienstes und der Fehlerbehandlung.
* **Integration Tests (mit einem laufenden Wayland-Compositor und `xdg-desktop-portal`):**
    * Starten des `ScreenCaptureService` im Compositor oder einem Test-Harness.
    * Auslösen von Screenshots und Überprüfen, ob die Bilddateien korrekt gespeichert werden.
    * Starten und Stoppen von Bildschirmaufzeichnungen und Überprüfen der resultierenden Videodateien. Dies erfordert oft manuelle Überprüfung oder spezialisierte Test-Tools.

**Geschätzter Aufwand:** Mittel (ca. 4-7 Tage, da Interaktion mit Wayland-Protokollen und Dateiverwaltung)

---

### **novade-system/src/screen_capture/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `screen_capture` Subsystem der Systemschicht. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für Bildschirmaufnahme-bezogene Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`ScreenCaptureError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum ScreenCaptureError {`
        * `#[error("Failed to connect to desktop portal: {0}")]`
        * `PortalConnectionError(String),`
        * `#[error("Desktop portal request failed: {0}")]`
        * `PortalRequestFailed(String),`
        * `#[error("Screen capture cancelled by user or timeout")]`
        * `CaptureCancelled,`
        * `#[error("Unsupported capture method or format: {0}")]`
        * `UnsupportedFeature(String),`
        * `#[error("Failed to write output file: {0}")]`
        * `FileWriteError(#[from] std::io::Error),`
        * `#[error("Image processing error: {0}")]`
        * `ImageProcessingError(String),`
        * `#[error("Unknown screen capture error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `std::io::Error` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/screen_capture/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::io::Error`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `screen_capture` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an den aufrufenden `CompositorService` oder die Top-Level-Anwendung propagiert, um dort geloggt oder dem Benutzer angezeigt zu werden.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Bildschirmaufnahme-Subsystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/screen_capture/data_types.rs**

**Verantwortlichkeit:**
Definiert spezifische Datentypen (Structs, Enums) für das `screen_capture` Subsystem. Diese Typen repräsentieren Optionen für Bildschirmaufnahmen, Ergebnis-Metadaten und den Status von Aufzeichnungen.

**Kern-Aufgaben (Tasks):**

1.  **Definition von Screen-Capture-spezifischen Typen:**
    * **`CaptureRegion` Enum:**
        * `pub enum CaptureRegion { FullScreen, Monitor(u32), Window(novade_system::compositor::data_types::WindowHandle), Area(i32, i32, u32, u32), // x, y, width, height }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
    * **`ScreenshotOptions` Struct:**
        * `pub struct ScreenshotOptions { pub region: CaptureRegion, pub save_path: Option<PathBuf>, pub format: ImageFormat, pub include_cursor: bool }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`.
    * **`ImageFormat` Enum:**
        * `pub enum ImageFormat { Png, Jpeg, Bmp, // ... }`
        * Ableitungen: `Debug`, `Clone`, `Copy`, `Eq`, `PartialEq`, `Hash`, `serde::Serialize`, `serde::Deserialize`.
    * **`ScreencastOptions` Struct:**
        * `pub struct ScreencastOptions { pub region: CaptureRegion, pub save_path: PathBuf, pub format: VideoFormat, pub include_audio: bool, pub include_cursor: bool, pub framerate: u32 }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`.
    * **`VideoFormat` Enum:**
        * `pub enum VideoFormat { Webm, Mp4, // ... }`
        * Ableitungen: `Debug`, `Clone`, `Copy`, `Eq`, `PartialEq`, `Hash`, `serde::Serialize`, `serde::Deserialize`.
    * **`ScreencastStatus` Enum:**
        * `pub enum ScreencastStatus { Idle, Recording, Paused, Finished, Error(String) }`
        * Ableitungen: `Debug`, `Clone`, `Eq`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
    * **`ScreenshotResult` Struct:**
        * `pub struct ScreenshotResult { pub path: PathBuf, pub timestamp: chrono::DateTime<chrono::Utc>, pub size: (u32, u32) }`
        * Ableitungen: `Debug`, `Clone`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/screen_capture/data_types.rs`

**Abhängigkeiten:**

* **Internal:**
    * `novade_system::compositor::data_types::WindowHandle`
* **Extern:**
    * `std::path::PathBuf`
    * `serde::{Serialize, Deserialize}`
    * `chrono::{DateTime, Utc}`

**Kommunikationsmuster:**

* Diese Datenstrukturen werden als Parameter für die Methoden in `screenshot.rs` und `screencast.rs` verwendet.
* `ScreenshotResult` und `ScreencastStatus` werden ggf. über `SystemEvent`s an den `EventBus` gesendet.

**Erwartete Ergebnisse/Outputs:**
Eine Sammlung von robusten, typsicheren und gut definierten Datenstrukturen, die die Konfiguration und Ergebnisse von Bildschirmaufnahmen abbilden.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `Default` Implementierungen (falls vorhanden).
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq`, `Hash` Ableitungen.
    * Testen der Serialisierung/Deserialisierung für relevante Structs/Enums.
    * Testen von Edge-Cases für numerische Felder (z.B. Null-Breite/Höhe für `Area`).

**Geschätzter Aufwand:** Mittel (ca. 1-2 Tage, hauptsächlich Definitionen)

---

### **novade-system/src/screen_capture/screenshot.rs**

**Verantwortlichkeit:**
Implementiert die Logik zum Aufnehmen von Screenshots. Dies beinhaltet die Interaktion mit dem Wayland-Compositor (wahrscheinlich über `xdg-desktop-portal` oder direkte Wayland-Protokolle, falls verfügbar) und das Speichern der aufgenommenen Bilder.

**Kern-Aufgaben (Tasks):**

1.  **`ScreenshotCapturer` Struct:**
    * `pub struct ScreenshotCapturer {`
        * `// Abhängigkeiten für die Interaktion mit dem Wayland-Compositor / xdg-desktop-portal`
        * `// z.B. xdg_portal_client: Arc<XdgPortalClient>`
        * `event_bus: EventBus,`
    * `}`

2.  **`ScreenshotCapturer::new()` Funktion:**
    * `pub async fn new(event_bus: EventBus) -> Result<Self, ScreenCaptureError>`
    * **Logik:**
        * Initialisiert die notwendigen Clients für den Zugriff auf den Desktop-Portal-Dienst (oder Wayland-Protokolle).
        * Gibt `Self` zurück.

3.  **`ScreenshotCapturer::take_screenshot()` Methode:**
    * `pub async fn take_screenshot(&self, options: ScreenshotOptions) -> Result<ScreenshotResult, ScreenCaptureError>`
    * **Logik:**
        * **Anfrage an den Desktop-Portal:** Verwendet das `org.freedesktop.portal.Screenshot` D-Bus-Interface (via `xdg-desktop-portal`) um einen Screenshot anzufordern.
            * `Screenshot(window_handle, interactive, options_dict)`
            * `window_handle`: Kann 0 sein für gesamten Bildschirm oder die ID eines bestimmten Fensters.
            * `interactive`: Ob der Benutzer eine Region auswählen soll.
            * `options_dict`: Dict mit `x`, `y`, `width`, `height`, `cursor`, `modal`.
        * **Handhabung des Rückgabewertes:** Der Portal gibt eine URI zum Screenshot zurück (z.B. `file:///path/to/screenshot.png`).
        * **Bildverarbeitung/Speicherung:**
            * Liest das Bild von der URI (falls nicht bereits als `Vec<u8>` übergeben).
            * Konvertiert das Bild in das angeforderte `ImageFormat` (wenn nötig).
            * Speichert das Bild am `options.save_path`. Wenn kein Pfad angegeben, speichert es im Standard-Screenshot-Verzeichnis (`XDG_PICTURES_DIR/Screenshots`).
            * Fügt Metadaten wie den Zeitstempel hinzu.
            * Gibt `ScreenshotResult` zurück.
        * **Fehlerbehandlung:** Wenn der Portal-Aufruf fehlschlägt, der Benutzer abbricht, das Bild nicht gespeichert werden kann oder die Bildverarbeitung fehlschlägt.

**Spezifische Artefekte/Dateien:**

* `novade-system/src/screen_capture/screenshot.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::screen_capture::error::ScreenCaptureError`
    * `crate::screen_capture::data_types::{ScreenshotOptions, CaptureRegion, ImageFormat, ScreenshotResult}`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent` (optional für Erfolgsmeldungen)
    * `novade_system::compositor::data_types::WindowHandle`
    * `crate::dbus_interfaces::xdg_portal_client::XdgPortalClient` (hypothetische D-Bus-Client-Schnittstelle)
* **Extern:**
    * `image` crate (für Bildverarbeitung und -speicherung)
    * `zbus` (für D-Bus-Interaktion mit `xdg-desktop-portal`)
    * `tokio::fs`
    * `tracing`
    * `std::sync::Arc`
    * `std::path::PathBuf`

**Kommunikationsmuster:**

* Sendet D-Bus-Methodenaufrufe an `xdg-desktop-portal`.
* Empfängt D-Bus-Antworten.
* Schreibt Dateien auf das Dateisystem.

**Erwartete Ergebnisse/Outputs:**
Eine Funktion, die Screenshots in verschiedenen Formaten und Regionen aufnehmen und speichern kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `XdgPortalClient` und des Dateisystems.
    * Testen von `take_screenshot` mit verschiedenen `ScreenshotOptions` (Full Screen, Monitor, Window, Area).
    * Simulieren von erfolgreichen Portal-Antworten und Überprüfen der korrekten Bildverarbeitung und Dateispeicherung.
    * Simulieren von Portal-Fehlern (`CaptureCancelled`, `PortalRequestFailed`) und Überprüfen der Fehlerbehandlung.
    * Testen verschiedener `ImageFormat`s.
* **Integration Tests (mit einem laufenden `xdg-desktop-portal` und Wayland-Compositor):**
    * Auslösen von realen Screenshots und manuelles Überprüfen der generierten Dateien. Dies ist der wichtigste Test für diese Komponente.

**Geschätzter Aufwand:** Mittel-Hoch (ca. 5-8 Tage, da D-Bus-Interaktion, Dateiverwaltung und Bildverarbeitung)

---

### **novade-system/src/screen_capture/screencast.rs**

**Verantwortlichkeit:**
Implementiert die Logik zum Aufzeichnen des Bildschirms. Dies beinhaltet die Interaktion mit dem Wayland-Compositor (über PipeWire und `xdg-desktop-portal` für Screencasting) sowie die Video-Kodierung und Speicherung.

**Kern-Aufgaben (Tasks):**

1.  **`ScreencastRecorder` Struct:**
    * `pub struct ScreencastRecorder {`
        * `// Abhängigkeiten für PipeWire/xdg-desktop-portal`
        * `// z.B. xdg_portal_screencast_client: Arc<XdgPortalScreencastClient>`
        * `event_bus: EventBus,`
        * `// Interner Zustand für die Aufzeichnung: `AtomicBool` für `is_recording`, Option<Child> für Encoder-Prozess`
        * `status: Arc<RwLock<ScreencastStatus>>,`
        * `current_screencast_path: Arc<RwLock<Option<PathBuf>>>,`
    * `}`

2.  **`ScreencastRecorder::new()` Funktion:**
    * `pub async fn new(event_bus: EventBus) -> Result<Self, ScreenCaptureError>`
    * **Logik:**
        * Initialisiert die notwendigen Clients für den Zugriff auf den Desktop-Portal-Screencast-Dienst und/oder PipeWire-Komponenten.
        * Setzt den initialen `status` auf `Idle`.
        * Gibt `Self` zurück.

3.  **`ScreencastRecorder::start_screencast()` Methode:**
    * `pub async fn start_screencast(&self, options: ScreencastOptions) -> Result<(), ScreenCaptureError>`
    * **Logik:**
        * Überprüft den aktuellen `status`. Wenn bereits `Recording`, gibt einen Fehler zurück.
        * **Anfrage an den Desktop-Portal:** Verwendet das `org.freedesktop.portal.ScreenCast` D-Bus-Interface (via `xdg-desktop-portal`) um eine Bildschirmaufnahme anzufordern.
            * `SelectSources(window_handle, options_dict)`: Benutzer wählt Region/Monitor/Fenster aus.
            * `Start(portal_handle, stream_properties_dict, fd_array)`: Startet den Stream. Das Portal gibt einen PipeWire-Stream zurück (als File Descriptor).
        * **PipeWire-Integration:**
            * Der empfangene File Descriptor wird genutzt, um den PipeWire-Stream zu lesen.
            * Die Rohvideo-/Audio-Daten (falls `include_audio` true) werden von PipeWire abgegriffen.
        * **Video-Kodierung:**
            * Spawn eines externen Prozesses (z.B. `ffmpeg` oder `gstreamer`), der die PipeWire-Rohdaten empfängt und in das angeforderte `VideoFormat` kodiert und speichert. Der Recorder muss den stdin-Stream des Encoder-Prozesses füllen.
            * Speichert den `Child` Handle des Encoder-Prozesses.
        * Aktualisiert den `status` auf `Recording`.
        * Sendet `SystemEvent::ScreencastStarted(options.save_path)` an den `EventBus`.
        * **Fehlerbehandlung:** Wenn der Portal-Aufruf fehlschlägt, PipeWire-Verbindung fehlschlägt, Encoder-Prozess nicht gestartet werden kann.

4.  **`ScreencastRecorder::stop_screencast()` Methode:**
    * `pub async fn stop_screencast(&self) -> Result<(), ScreenCaptureError>`
    * **Logik:**
        * Überprüft den aktuellen `status`. Wenn `Idle`, gibt einen Fehler zurück.
        * Beendet den PipeWire-Stream (über den Portal-Handle).
        * Sendet ein Signal an den Encoder-Prozess, um ihn zu beenden (z.B. `SIGINT` oder Schließen des `stdin`).
        * Wartet auf das Beenden des Encoder-Prozesses.
        * Setzt den `status` auf `Finished`.
        * Sendet `SystemEvent::ScreencastFinished(self.current_screencast_path)` an den `EventBus`.
        * **Fehlerbehandlung:** Wenn der Encoder-Prozess nicht beendet werden kann oder das Speichern fehlschlägt.

5.  **`ScreencastRecorder::get_status()` Methode:**
    * `pub fn get_status(&self) -> ScreencastStatus`
    * Gibt den aktuellen Status der Bildschirmaufzeichnung zurück.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/screen_capture/screencast.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::screen_capture::error::ScreenCaptureError`
    * `crate::screen_capture::data_types::{ScreencastOptions, CaptureRegion, VideoFormat, ScreencastStatus}`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
    * `crate::dbus_interfaces::xdg_portal_screencast_client::XdgPortalScreencastClient` (hypothetische D-Bus-Client-Schnittstelle)
* **Extern:**
    * `zbus` (für D-Bus-Interaktion mit `xdg-desktop-portal`)
    * `tokio::process::Command` (für den externen Encoder-Prozess)
    * `tokio::io::AsyncWriteExt`
    * `tokio::sync::RwLock`
    * `tracing`
    * `std::sync::Arc`
    * `std::path::PathBuf`
    * `std::sync::atomic::{AtomicBool, Ordering}`

**Kommunikationsmuster:**

* Sendet D-Bus-Methodenaufrufe an `xdg-desktop-portal` für Screencasting.
* Interagiert mit PipeWire (indirekt über `xdg-desktop-portal` oder direkt über `pipewire-rs`).
* Startet und steuert externe Prozesse (z.B. `ffmpeg`).
* Schreibt Dateien auf das Dateisystem.
* Sendet `SystemEvent`s an den `EventBus`.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Bildschirmrekorder, der Video und optional Audio vom Bildschirm aufnehmen und in verschiedenen Formaten speichern kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `XdgPortalScreencastClient` und des `tokio::process::Command`.
    * Testen von `start_screencast`: Überprüfen der Portal-Aufrufe, des Startens des Encoder-Prozesses und der Statusänderung.
    * Testen von `stop_screencast`: Überprüfen des Beendens des Encoder-Prozesses und der Statusänderung.
    * Simulieren von Fehlern (Portal-Fehler, Encoder-Startfehler, Encoder-Absturz).
* **Integration Tests (mit einem laufenden `xdg-desktop-portal`, PipeWire und `ffmpeg`/`gstreamer`):**
    * Starten und Stoppen von realen Bildschirmaufzeichnungen.
    * Manuelles Überprüfen der resultierenden Videodateien (Qualität, Länge, Audio).
    * Testen von verschiedenen `CaptureRegion`s und `VideoFormat`s.

**Geschätzter Aufwand:** Sehr Hoch (ca. 10-15 Tage, da komplexe Interaktion mit mehreren Systemdiensten, externe Prozesse und Video/Audio-Pipelining)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `notification_manager`, widmen wir uns `screen_capture`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/screen_capture/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/screen_capture/data_types.rs`**: Datenstrukturen für Capture-Optionen und -Ergebnisse.
3.  **`novade-system/src/screen_capture/screenshot.rs`**: Screenshots sind oft einfacher zu implementieren als Screencasting, da sie keine kontinuierliche Datenverarbeitung erfordern.
4.  **`novade-system/src/screen_capture/screencast.rs`**: Screencasting ist komplexer aufgrund der Streaming-, Kodierungs- und externen Prozessverwaltung.
5.  **`novade-system/src/screen_capture/mod.rs`**: Das Hauptmodul, das die Capturer und Recorder initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/screen_capture` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/dbus_interfaces` Verzeichnisses, das die Grundlage für viele der bereits spezifizierten Module bildet.
### **novade-system/src/dbus_interfaces/mod.rs**

**Verantwortlichkeit:**
Das `dbus_interfaces` Modul dient als zentrale Sammlung von Rust-Schnittstellen (Clients und ggf. Services) für die Interaktion mit verschiedenen D-Bus-Diensten im System. Es kapselt die D-Bus-Kommunikationsdetails und stellt eine typsichere API für andere Module der Systemschicht bereit. Dies reduziert Boilerplate-Code und standardisiert den Zugriff auf systemweite D-Bus-Dienste.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/dbus_interfaces/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung der Clients)
    * `error.rs` (Fehlerbehandlung für D-Bus-Interaktionen)
    * `upower_client.rs` (Client für `org.freedesktop.UPower`)
    * `logind_client.rs` (Client für `org.freedesktop.login1`)
    * `xdg_portal_client.rs` (Client für `org.freedesktop.portal.Desktop` und Unter-Interfaces)
    * `network_manager_client.rs` (Client für `org.freedesktop.NetworkManager`)
    * `gsettings_client.rs` (Client für `org.gnome.gsettings`) - falls GSettings verwendet wird
    * `mpris_client.rs` (Client für `org.mpris.MediaPlayer2`) - für Mediensteuerung
    * `bluez_client.rs` (Client für `org.bluez`) - für Bluetooth-Geräte

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung der D-Bus-Clients:**
    * `pub async fn initialize_dbus_clients(connection: Connection) -> Result<DbusClients, DbusError>`
    * **Logik:**
        * Erstellt und initialisiert Instanzen aller benötigten D-Bus-Clients (z.B. `UPowerClient::new(connection.clone()).await?`).
        * Bündelt diese in einem `DbusClients` Struct.
    * **Fehlerbehandlung:** Fehler bei der D-Bus-Verbindung oder der Client-Erstellung.

2.  **`DbusClients` Struct:**
    * `pub struct DbusClients {`
        * `pub upower: Arc<UPowerClient>,`
        * `pub logind: Arc<LogindClient>,`
        * `pub xdg_portal: Arc<XdgPortalClient>,`
        * `pub network_manager: Arc<NetworkManagerClient>,`
        * `// ... weitere Clients`
    * `}`
    * Stellt eine zentrale Zugriffsmöglichkeit auf alle initialisierten D-Bus-Clients bereit.

3.  **Bereitstellung der Client-APIs:**
    * Dieses Modul re-exportiert die einzelnen Client-Module, sodass andere Teile des Systems direkt auf deren APIs zugreifen können (z.B. `dbus_interfaces::upower_client::UPowerClient`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
    * Alle individuellen Client-Module (z.B. `upower_client`, `logind_client` etc.).
* **Extern:**
    * `zbus::Connection`
    * `std::sync::Arc`
    * `tracing`

**Kommunikationsmuster:**

* Wird von den höherliegenden System-Modulen (z.B. `power_management`, `screen_capture`) verwendet, um auf D-Bus-Dienste zuzugreifen.
* Kapselt die Details der D-Bus-Interaktion.

**Erwartete Ergebnisse/Outputs:**
Ein zentraler Punkt für die Initialisierung und den Zugriff auf alle notwendigen D-Bus-Clients des Systems, was die Wiederverwendbarkeit und Wartbarkeit verbessert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `zbus::Connection` und den individuellen Client-Methoden.
    * Testen der `initialize_dbus_clients` Funktion: Sicherstellen, dass alle Clients korrekt instanziiert werden und Fehler bei der Initialisierung korrekt behandelt werden.
    * Überprüfen, ob die Clients korrekt in das `DbusClients` Struct gebündelt werden.
* **Integration Tests:**
    * Diese Tests würden hauptsächlich in den Modulen stattfinden, die die Clients nutzen (z.B. `power_management`), um die tatsächliche D-Bus-Kommunikation zu testen.

**Geschätzter Aufwand:** Niedrig (ca. 1-2 Tage, da hauptsächlich Initialisierung und Re-Exporte)

---

### **novade-system/src/dbus_interfaces/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `dbus_interfaces` Modul. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle D-Bus-bezogenen Probleme innerhalb der Systemschicht.

**Kern-Aufgaben (Tasks):**

1.  **`DbusError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum DbusError {`
        * `#[error("Failed to connect to D-Bus: {0}")]`
        * `ConnectionError(#[from] zbus::Error),`
        * `#[error("D-Bus method call failed: {0}")]`
        * `MethodCallError(String),`
        * `#[error("D-Bus property read/write failed: {0}")]`
        * `PropertyAccessError(String),`
        * `#[error("Invalid D-Bus data format: {0}")]`
        * `InvalidDataFormat(String),`
        * `#[error("D-Bus service or object not found: {0}")]`
        * `ServiceOrObjectNotFound(String),`
        * `#[error("Permission denied for D-Bus operation: {0}")]`
        * `PermissionDenied(String),`
        * `#[error("Operation timeout on D-Bus: {0}")]`
        * `OperationTimeout(String),`
        * `#[error("Unknown D-Bus error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `zbus::Error` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `zbus::Error`

**Kommunikationsmuster:**

* Wird von allen individuellen D-Bus-Client-Implementierungen (z.B. `upower_client.rs`) verwendet, um spezifische D-Bus-Fehler in generische `DbusError`s zu kapseln und zu signalisieren.
* Diese Fehler werden dann an die aufrufenden Module (z.B. `power_management`) propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für alle D-Bus-Interaktionen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/dbus_interfaces/upower_client.rs**

**Verantwortlichkeit:**
Implementiert den D-Bus-Client für den `org.freedesktop.UPower` Dienst. Dieser Client ermöglicht das Abfragen von Energiegeräteinformationen (Batterien, Netzteile) und das Abonnieren von Statusänderungen.

**Kern-Aufgaben (Tasks):**

1.  **`UPowerClient` Struct:**
    * `pub struct UPowerClient {`
        * `proxy: Proxy<'static>,` // zbus Proxy für den UPower-Dienst
    * `}`

2.  **`UPowerClient::new()` Funktion:**
    * `pub async fn new(connection: Connection) -> Result<Self, DbusError>`
    * **Logik:**
        * Erstellt eine `zbus::Proxy` Instanz für den `org.freedesktop.UPower` Dienst, Objektpfad `/org/freedesktop/UPower`, Interface `org.freedesktop.UPower`.
        * Gibt `Self` zurück.

3.  **Implementierung der UPower-API-Methoden:**
    * **`EnumerateDevices()`:**
        * `pub async fn enumerate_devices(&self) -> Result<Vec<ObjectPath>, DbusError>`
        * **Logik:** Ruft die D-Bus-Methode `EnumerateDevices` auf und konvertiert das Ergebnis in eine `Vec<ObjectPath>`.
    * **`GetDeviceProperties(object_path)`:**
        * `pub async fn get_device_properties(&self, device_path: &ObjectPath) -> Result<HashMap<String, zbus::zvariant::Value>, DbusError>`
        * **Logik:** Erstellt einen Proxy für das spezifische Geräte-Objekt (z.B. `/org/freedesktop/UPower/devices/battery_BAT0`). Ruft die D-Bus-Methode `GetAll` auf dem `org.freedesktop.UPower.Device` Interface dieses Proxys auf.
    * **`Wakeup()` (Optional, wenn NovaDE das System aufwecken muss):**
        * `pub async fn wakeup(&self) -> Result<(), DbusError>`
        * **Logik:** Ruft die D-Bus-Methode `Wakeup` auf dem UPower-Dienst auf.

4.  **Abonnieren von UPower-Signalen:**
    * `pub async fn receive_device_added_signals(&self) -> Result<Receiver<ObjectPath>, DbusError>`
        * **Logik:** Erstellt einen `zbus::fdo::Receiver` für das `DeviceAdded` Signal auf dem Haupt-UPower-Interface.
    * `pub async fn receive_device_removed_signals(&self) -> Result<Receiver<ObjectPath>, DbusError>`
        * **Logik:** Erstellt einen `zbus::fdo::Receiver` für das `DeviceRemoved` Signal.
    * **Hinweis:** Für `PropertiesChanged` Signale auf spezifischen Geräte-Objektpfaden (`org.freedesktop.UPower.Device`), muss der `UPowerMonitor` (im `power_management` Modul) eigene `Proxy` Instanzen für diese Geräte erstellen und deren `PropertiesChanged` Signale abonnieren, da es sich um separate Objekte handelt.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/upower_client.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
* **Extern:**
    * `zbus::{Connection, Proxy, zvariant::ObjectPath}`
    * `zbus::fdo::Result as ZbusResult`
    * `zbus::MessageHeader`
    * `zbus::Message`
    * `std::collections::HashMap`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Stellt eine typsichere Rust-API für den UPower-D-Bus-Dienst bereit.
* Kapselt alle D-Bus-Interaktionen (Methodenaufrufe und Signale).

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger D-Bus-Client für UPower, der es anderen Systemmodulen ermöglicht, den Energiestatus abzufragen und auf Änderungen zu reagieren.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken der `zbus::Connection` und `zbus::Proxy` Methoden, um D-Bus-Antworten zu simulieren.
    * Testen von `new`: Sicherstellen, dass der Proxy korrekt initialisiert wird.
    * Testen von `enumerate_devices`: Simulieren einer Liste von Objektpfaden und Überprüfen der Rückgabe.
    * Testen von `get_device_properties`: Simulieren von D-Bus-Property-Dictionaries und Überprüfen der korrekten Konvertierung.
    * Testen der Signal-Receiver: Simulieren des Empfangs von `DeviceAdded`/`Removed` Signalen.
    * Testen der Fehlerbehandlung bei D-Bus-Fehlern.
* **Integration Tests (mit einem laufenden UPower-Daemon):**
    * Starten des UPower-Clients und Ausführen der Methoden auf einem realen UPower-Dienst.
    * Überprüfen, ob die zurückgegebenen Daten mit `upower --dump` übereinstimmen.
    * Überprüfen des Empfangs von Signalen bei Änderungen des Batteriestatus (physisches Ein-/Ausstecken des Netzteils).

**Geschätzter Aufwand:** Mittel-Hoch (ca. 4-6 Tage, da D-Bus-Interaktion mit komplexen Datenstrukturen und Signal-Handling)

---

### **novade-system/src/dbus_interfaces/logind_client.rs**

**Verantwortlichkeit:**
Implementiert den D-Bus-Client für den `org.freedesktop.login1` (systemd-logind) Dienst. Dieser Client ermöglicht das Auslösen von Systemaktionen (Suspend, Hibernate, Reboot, Shutdown) und das Abfragen von Sitzungs-Informationen.

**Kern-Aufgaben (Tasks):**

1.  **`LogindClient` Struct:**
    * `pub struct LogindClient {`
        * `proxy: Proxy<'static>,` // zbus Proxy für den logind-Dienst
    * `}`

2.  **`LogindClient::new()` Funktion:**
    * `pub async fn new(connection: Connection) -> Result<Self, DbusError>`
    * **Logik:**
        * Erstellt eine `zbus::Proxy` Instanz für den `org.freedesktop.login1` Dienst, Objektpfad `/org/freedesktop/login1`, Interface `org.freedesktop.login1.Manager`.
        * Gibt `Self` zurück.

3.  **Implementierung der logind-API-Methoden:**
    * **`Suspend(interactive: bool)`:**
        * `pub async fn suspend(&self, interactive: bool) -> Result<(), DbusError>`
        * **Logik:** Ruft die D-Bus-Methode `Suspend` auf dem `Manager` Interface auf.
    * **`Hibernate(interactive: bool)`:**
        * `pub async fn hibernate(&self, interactive: bool) -> Result<(), DbusError>`
        * **Logik:** Ruft die D-Bus-Methode `Hibernate` auf.
    * **`PowerOff(interactive: bool)`:**
        * `pub async fn power_off(&self, interactive: bool) -> Result<(), DbusError>`
        * **Logik:** Ruft die D-Bus-Methode `PowerOff` auf.
    * **`Reboot(interactive: bool)`:**
        * `pub async fn reboot(&self, interactive: bool) -> Result<(), DbusError>`
        * **Logik:** Ruft die D-Bus-Methode `Reboot` auf.
    * **`LockSession(session_id: String)`:**
        * `pub async fn lock_session(&self, session_id: &str) -> Result<(), DbusError>`
        * **Logik:** Ruft die D-Bus-Methode `LockSession` auf dem entsprechenden Session-Objekt (z.B. `/org/freedesktop/login1/session/c2`).
    * **`UnlockSession(session_id: String)`:**
        * `pub async fn unlock_session(&self, session_id: &str) -> Result<(), DbusError>`
        * **Logik:** Ruft die D-Bus-Methode `UnlockSession` auf.
    * **`GetSessionByPID(pid: u32)`:**
        * `pub async fn get_session_by_pid(&self, pid: u32) -> Result<(ObjectPath, String), DbusError>`
        * **Logik:** Ruft die D-Bus-Methode `GetSessionByPID` auf und gibt den Objektpfad und die Session-ID zurück.

4.  **Abonnieren von logind-Signalen (Optional, aber empfohlen):**
    * `pub async fn receive_prepare_for_shutdown_signals(&self) -> Result<Receiver<bool>, DbusError>`
        * **Logik:** Erstellt einen `zbus::fdo::Receiver` für das `PrepareForShutdown` Signal.
    * `pub async fn receive_prepare_for_sleep_signals(&self) -> Result<Receiver<bool>, DbusError>`
        * **Logik:** Erstellt einen `zbus::fdo::Receiver` für das `PrepareForSleep` Signal.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/logind_client.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
* **Extern:**
    * `zbus::{Connection, Proxy, zvariant::ObjectPath}`
    * `zbus::fdo::Result as ZbusResult`
    * `zbus::MessageHeader`
    * `zbus::Message`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Stellt eine typsichere Rust-API für den systemd-logind D-Bus-Dienst bereit.
* Kapselt alle D-Bus-Interaktionen.

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger D-Bus-Client für systemd-logind, der es NovaDE ermöglicht, Systemaktionen auszulösen und auf Sitzungsänderungen zu reagieren.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken der `zbus::Connection` und `zbus::Proxy` Methoden.
    * Testen von `new`: Sicherstellen, dass der Proxy korrekt initialisiert wird.
    * Testen der System-Aktionsmethoden (`suspend`, `hibernate`, `power_off`, `reboot`): Simulieren von erfolgreichen und fehlerhaften D-Bus-Aufrufen (z.B. `AccessDenied`).
    * Testen von `lock_session`, `unlock_session` und `get_session_by_pid`.
    * Testen der Signal-Receiver für `PrepareForShutdown`/`PrepareForSleep`.
    * Testen der Fehlerbehandlung bei D-Bus-Fehlern.
* **Integration Tests (mit einem laufenden systemd-logind Dienst):**
    * Dies erfordert Vorsicht, da reale Systemaktionen ausgelöst werden. Testen in einer isolierten VM oder mit einem Dummy-logind-Dienst ist ratsam.
    * Testen von `lock_session` und `unlock_session` auf einer aktiven Sitzung.
    * Für Suspend/Hibernate/PowerOff/Reboot: Überprüfen, ob die D-Bus-Methoden korrekt aufgerufen werden (z.B. durch D-Bus-Monitoring-Tools), ohne unbedingt die Aktionen tatsächlich auszuführen.

**Geschätzter Aufwand:** Mittel-Hoch (ca. 4-7 Tage, da Interaktion mit privilegierten Systemdiensten und Sitzungsmanagement)

---

### **novade-system/src/dbus_interfaces/xdg_portal_client.rs**

**Verantwortlichkeit:**
Implementiert den D-Bus-Client für das `xdg-desktop-portal`. Dieses Portal bietet eine standardisierte Schnittstelle für Desktop-Umgebungen, um mit Flatpaks und anderen sandboxed Anwendungen zu interagieren, z.B. für Dateiauswahldialoge, Screenshots, Screencasting, Drucken und Benachrichtigungen (auch wenn Notifications in NovaDE direkt implementiert werden).

**Kern-Aufgaben (Tasks):**

1.  **`XdgPortalClient` Struct:**
    * `pub struct XdgPortalClient {`
        * `desktop_portal_proxy: Proxy<'static>,` // org.freedesktop.portal.Desktop
        * `screenshot_proxy: Proxy<'static>,` // org.freedesktop.portal.Screenshot
        * `screencast_proxy: Proxy<'static>,` // org.freedesktop.portal.ScreenCast
        * `// ... weitere Proxies für FileChooser, Print, OpenURI etc. bei Bedarf`
    * `}`

2.  **`XdgPortalClient::new()` Funktion:**
    * `pub async fn new(connection: Connection) -> Result<Self, DbusError>`
    * **Logik:**
        * Erstellt `zbus::Proxy` Instanzen für die relevanten D-Bus-Dienste und Interfaces:
            * `org.freedesktop.portal.Desktop` (Path `/org/freedesktop/portal/desktop`)
            * `org.freedesktop.portal.Screenshot` (Path `/org/freedesktop/portal/desktop`)
            * `org.freedesktop.portal.ScreenCast` (Path `/org/freedesktop/portal/desktop`)
            * (Optional: `org.freedesktop.portal.FileChooser`, `org.freedesktop.portal.Print`, etc.)
        * Gibt `Self` zurück.

3.  **Implementierung der Portal-API-Methoden (Beispiele):**
    * **`RequestScreenshot(window_handle, interactive, options)`:**
        * `pub async fn request_screenshot(&self, parent_window: Option<&str>, interactive: bool, options: HashMap<&str, zbus::zvariant::Value>) -> Result<ObjectPath, DbusError>`
        * **Logik:** Ruft die Methode `Screenshot` auf dem `org.freedesktop.portal.Screenshot` Interface auf. Gibt einen `ObjectPath` zum `Request` Objekt zurück, auf dem dann Signale empfangen werden, um das Ergebnis zu bekommen.
    * **`RequestScreencast(parent_window, options)`:**
        * `pub async fn request_screencast(&self, parent_window: Option<&str>, options: HashMap<&str, zbus::zvariant::Value>) -> Result<ObjectPath, DbusError>`
        * **Logik:** Ruft die Methode `CreateSession` auf dem `org.freedesktop.portal.ScreenCast` Interface auf, gefolgt von `SelectSources` und `Start`. Gibt ebenfalls einen `Request` `ObjectPath` zurück.
    * **`OpenFile(parent_window, title, options)` (FileChooser):**
        * `pub async fn open_file_chooser(&self, parent_window: Option<&str>, title: &str, options: HashMap<&str, zbus::zvariant::Value>) -> Result<ObjectPath, DbusError>`
        * **Logik:** Ruft die Methode `OpenFile` auf dem `org.freedesktop.portal.FileChooser` Interface auf.

4.  **Handling von Request-Signalen:**
    * Für asynchrone Portal-Operationen (wie Screenshot, Screencast, FileChooser) gibt der Portal ein `Request` Objekt auf einem dynamischen Pfad zurück.
    * Der `XdgPortalClient` muss eine generische Methode bereitstellen, um `Response` Signale auf diesen `Request` Objekten zu abonnieren.
    * `pub async fn receive_portal_response_signals(&self, request_path: ObjectPath) -> Result<Receiver<(u32, HashMap<String, zbus::zvariant::Value>)>, DbusError>`
        * **Logik:** Erstellt einen Receiver für das `Response` Signal auf dem spezifischen `request_path`. Das Response-Signal enthält den Status (success/error) und die Ergebnisse.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/xdg_portal_client.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
* **Extern:**
    * `zbus::{Connection, Proxy, zvariant::ObjectPath}`
    * `zbus::fdo::Result as ZbusResult`
    * `zbus::MessageHeader`
    * `zbus::Message`
    * `std::collections::HashMap`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Stellt eine typsichere Rust-API für die verschiedenen `xdg-desktop-portal` Interfaces bereit.
* Kapselt komplexe D-Bus-Interaktionen mit Request/Response-Objekten.

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger D-Bus-Client für `xdg-desktop-portal`, der NovaDE die Interaktion mit sandboxed Anwendungen und den Zugriff auf Systemfunktionen auf sichere und standardisierte Weise ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken der `zbus::Connection` und `zbus::Proxy` Methoden.
    * Testen von `new`: Sicherstellen, dass alle Proxies korrekt initialisiert werden.
    * Testen der `request_screenshot`, `request_screencast` (und optional `open_file_chooser`) Methoden: Simulieren der Rückgabe von `Request` Objektpfaden.
    * Testen von `receive_portal_response_signals`: Simulieren von `Response` Signalen mit Erfolgs- und Fehlerszenarien.
    * Testen der Fehlerbehandlung bei D-Bus-Fehlern.
* **Integration Tests (mit einem laufenden `xdg-desktop-portal` und einer unterstützenden Umgebung):**
    * Auslösen von realen Portal-Anfragen (Screenshot, Screencast, FileChooser).
    * Überprüfen, ob die Benutzeroberfläche des Portals erscheint und ob die Ergebnisse korrekt verarbeitet werden.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da komplexe D-Bus-Interaktionen mit asynchronen Request-Objekten und mehreren Schnittstellen)

---

### **novade-system/src/dbus_interfaces/network_manager_client.rs**

**Verantwortlichkeit:**
Implementiert den D-Bus-Client für den `org.freedesktop.NetworkManager` Dienst. Dieser Client ermöglicht das Abfragen des Netzwerkstatus, das Verwalten von Netzwerkverbindungen (WLAN, Ethernet) und das Reagieren auf Netzwerkereignisse.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkManagerClient` Struct:**
    * `pub struct NetworkManagerClient {`
        * `proxy: Proxy<'static>,` // zbus Proxy für den NetworkManager-Dienst
    * `}`

2.  **`NetworkManagerClient::new()` Funktion:**
    * `pub async fn new(connection: Connection) -> Result<Self, DbusError>`
    * **Logik:**
        * Erstellt eine `zbus::Proxy` Instanz für den `org.freedesktop.NetworkManager` Dienst, Objektpfad `/org/freedesktop/NetworkManager`, Interface `org.freedesktop.NetworkManager`.
        * Gibt `Self` zurück.

3.  **Implementierung der NetworkManager-API-Methoden (Beispiele):**
    * **`GetDevices()`:**
        * `pub async fn get_devices(&self) -> Result<Vec<ObjectPath>, DbusError>`
        * **Logik:** Ruft die D-Bus-Methode `GetDevices` auf und gibt eine Liste von Geräte-Objektpfaden zurück.
    * **`GetDeviceProperties(device_path)`:**
        * `pub async fn get_device_properties(&self, device_path: &ObjectPath) -> Result<HashMap<String, zbus::zvariant::Value>, DbusError>`
        * **Logik:** Erstellt einen Proxy für das spezifische Geräte-Objekt (`org.freedesktop.NetworkManager.Device.<Type>`) und ruft `GetAll` auf.
    * **`GetActiveConnections()`:**
        * `pub async fn get_active_connections(&self) -> Result<Vec<ObjectPath>, DbusError>`
        * **Logik:** Ruft die D-Bus-Methode `GetActiveConnections` auf und gibt eine Liste von aktiven Verbindungs-Objektpfaden zurück.
    * **`ActivateConnection(connection_path, device_path, specific_object_path)`:**
        * `pub async fn activate_connection(&self, connection: &ObjectPath, device: &ObjectPath, specific_object: &ObjectPath) -> Result<ObjectPath, DbusError>`
        * **Logik:** Ruft die Methode `ActivateConnection` auf dem `NetworkManager` Interface auf, um eine Netzwerkverbindung zu starten.
    * **`DeactivateConnection(active_connection_path)`:**
        * `pub async fn deactivate_connection(&self, active_connection: &ObjectPath) -> Result<(), DbusError>`
        * **Logik:** Ruft die Methode `DeactivateConnection` auf.
    * **`GetAccessPoints(wireless_device_path)` (für WLAN):**
        * `pub async fn get_access_points(&self, wireless_device_path: &ObjectPath) -> Result<Vec<ObjectPath>, DbusError>`
        * **Logik:** Erstellt einen Proxy für das WLAN-Gerät und ruft `GetAllAccessPoints` auf dem `org.freedesktop.NetworkManager.Device.Wireless` Interface auf.

4.  **Abonnieren von NetworkManager-Signalen:**
    * **`StateChanged(u32)`:**
        * `pub async fn receive_state_changed_signals(&self) -> Result<Receiver<u32>, DbusError>`
        * **Logik:** Erstellt einen Receiver für das `StateChanged` Signal auf dem Haupt-NetworkManager-Interface (Globaler Status).
    * **`PropertiesChanged` (auf Geräte-Objekten):**
        * Ähnlich wie bei UPower, müssen für spezifische Geräte-Eigenschaften (`org.freedesktop.NetworkManager.Device.PropertiesChanged`) separate Proxies für die Geräte-Objektpfade erstellt werden, um diese Signale zu abonnieren.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/network_manager_client.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
* **Extern:**
    * `zbus::{Connection, Proxy, zvariant::ObjectPath}`
    * `zbus::fdo::Result as ZbusResult`
    * `zbus::MessageHeader`
    * `zbus::Message`
    * `std::collections::HashMap`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Stellt eine typsichere Rust-API für den NetworkManager D-Bus-Dienst bereit.
* Kapselt alle D-Bus-Interaktionen (Methodenaufrufe und Signale).

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger D-Bus-Client für NetworkManager, der es NovaDE ermöglicht, den Netzwerkstatus zu überwachen, Verbindungen zu verwalten und auf Netzwerkereignisse zu reagieren.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken der `zbus::Connection` und `zbus::Proxy` Methoden.
    * Testen von `new`.
    * Testen der Methoden zum Abrufen von Geräten und Verbindungen (`get_devices`, `get_active_connections`, `get_device_properties`).
    * Simulieren des Aktivierens/Deaktivierens von Verbindungen.
    * Testen der Signal-Receiver für globale Statusänderungen.
    * Testen der Fehlerbehandlung.
* **Integration Tests (mit einem laufenden NetworkManager-Daemon):**
    * Starten des Clients und Abfragen des Netzwerkstatus.
    * Verbinden/Trennen von WLAN/Ethernet-Verbindungen (manuell oder über Skripte) und Überprüfen, ob die richtigen Signale empfangen und der Status korrekt aktualisiert wird.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da der NetworkManager D-Bus-API sehr umfangreich und komplex ist)

---

### **novade-system/src/dbus_interfaces/gsettings_client.rs**

**Verantwortlichkeit:**
Implementiert den D-Bus-Client für `org.gnome.SettingsDaemon.GSettings`. Dieser Client ermöglicht das Lesen und Schreiben von GSettings-Werten, die von GTK-Anwendungen und GNOME-Komponenten verwendet werden. Dies ist wichtig für die Kompatibilität mit bestehenden Anwendungen und die Bereitstellung eines konsistenten Benutzererlebnisses, wenn NovaDE GSettings als Konfigurationsquelle nutzt oder deren Änderungen überwachen muss.

**Kern-Aufgaben (Tasks):**

1.  **`GSettingsClient` Struct:**
    * `pub struct GSettingsClient {`
        * `proxy: Proxy<'static>,` // zbus Proxy für den GSettings-Dienst
    * `}`

2.  **`GSettingsClient::new()` Funktion:**
    * `pub async fn new(connection: Connection) -> Result<Self, DbusError>`
    * **Logik:**
        * Erstellt eine `zbus::Proxy` Instanz für den `org.gnome.SettingsDaemon.GSettings` Dienst, Objektpfad `/org/gnome/SettingsDaemon/GSettings`, Interface `org.gnome.SettingsDaemon.GSettings`.
        * **Alternative/Ergänzung:** Falls NovaDE direkt `gsettings` CLI oder `libgio` bindings nutzt, ist dieser D-Bus-Client nicht primär für *eigene* GSettings-Konfigurationen, sondern um *Änderungen anderer Anwendungen* an GSettings zu überwachen oder um die Werte auszulesen, die von anderen Anwendungen gesetzt wurden. Wenn NovaDE seine eigene Konfiguration hat, sollte diese über den `ConfigService` in der Domänenschicht laufen.
        * Gibt `Self` zurück.

3.  **Implementierung der GSettings-API-Methoden (Beispiele):**
    * **`Get(schema_id, key)`:**
        * `pub async fn get_value(&self, schema_id: &str, key: &str) -> Result<zbus::zvariant::Value, DbusError>`
        * **Logik:** Ruft die D-Bus-Methode `Get` auf dem GSettings-Dienst auf. Gibt den Wert als `zbus::zvariant::Value` zurück, der dann in den gewünschten Rust-Typ konvertiert werden muss.
    * **`Set(schema_id, key, value)`:**
        * `pub async fn set_value(&self, schema_id: &str, key: &str, value: zbus::zvariant::Value) -> Result<(), DbusError>`
        * **Logik:** Ruft die D-Bus-Methode `Set` auf. Der `value` muss als `zbus::zvariant::Value` übergeben werden.
    * **`Monitor(schema_id, key)`:**
        * `pub async fn monitor_key(&self, schema_id: &str, key: &str) -> Result<ObjectPath, DbusError>`
        * **Logik:** Ruft die Methode `Monitor` auf. Gibt einen `ObjectPath` zum `Monitor` Objekt zurück.

4.  **Abonnieren von GSettings-Signalen:**
    * Für `Monitor`-Objekte:
        * `pub async fn receive_change_signals(&self, monitor_path: ObjectPath) -> Result<Receiver<String>, DbusError>`
        * **Logik:** Erstellt einen Receiver für das `Changed` Signal auf dem spezifischen `Monitor` Objekt. Das Signal enthält den Namen des geänderten Schlüssels.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/gsettings_client.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
* **Extern:**
    * `zbus::{Connection, Proxy, zvariant::ObjectPath}`
    * `zbus::fdo::Result as ZbusResult`
    * `zbus::MessageHeader`
    * `zbus::Message`
    * `std::collections::HashMap`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Stellt eine typsichere Rust-API für den GSettings D-Bus-Dienst bereit.
* Ermöglicht das Lesen/Schreiben von Einstellungen und das Abonnieren von Änderungen.

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger D-Bus-Client für GSettings, der die Interaktion mit dem GSettings-Konfigurationssystem ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken der `zbus::Connection` und `zbus::Proxy` Methoden.
    * Testen von `new`.
    * Testen von `get_value` und `set_value` mit verschiedenen Schemas und Schlüsseln (simulierte Antworten).
    * Testen von `monitor_key` und dem Empfang von `Changed` Signalen.
    * Testen der Fehlerbehandlung.
* **Integration Tests (mit einem laufenden GSettings-Daemon, z.B. unter GNOME/XFCE):**
    * Abfragen und Setzen von GSettings-Werten und Überprüfen mit `gsettings get/set`.
    * Änderungen über `gsettings set` triggern und überprüfen, ob der Client die `Changed`-Signale empfängt.

**Geschätzter Aufwand:** Mittel (ca. 3-5 Tage, da D-Bus-Interaktion mit variablen Typen und Signal-Handling)

---

### **novade-system/src/dbus_interfaces/mpris_client.rs**

**Verantwortlichkeit:**
Implementiert den D-Bus-Client für das Media Player Remote Interfacing Specification (MPRIS) Protokoll (`org.mpris.MediaPlayer2`). Dieser Client ermöglicht NovaDE die Steuerung von Medienplayern (z.B. Pause, Play, Next, Previous) und das Abrufen von Informationen über den aktuellen Medienstatus (Titel, Interpret, Album, Fortschritt).

**Kern-Aufgaben (Tasks):**

1.  **`MprisClient` Struct:**
    * `pub struct MprisClient {`
        * `connection: Connection,` // Hält eine Referenz zur D-Bus-Verbindung
        * `// Interner Cache von Proxies für aktive Player`
        * `player_proxies: RwLock<HashMap<String, Proxy<'static>>>,` // Map: Bus-Name -> Proxy
    * `}`

2.  **`MprisClient::new()` Funktion:**
    * `pub async fn new(connection: Connection) -> Result<Self, DbusError>`
    * **Logik:**
        * Speichert die `connection`.
        * Initialisiert den `player_proxies` Cache.
        * Abonniert D-Bus-Signale für `NameOwnerChanged` für `org.mpris.MediaPlayer2` Namen, um neue/verschwindende Player zu erkennen.
        * Gibt `Self` zurück.

3.  **D-Bus-Signal-Handling (Discovering Players):**
    * Der `MprisClient` muss das `org.freedesktop.DBus.NameOwnerChanged` Signal abonnieren, um zu erkennen, wenn ein `org.mpris.MediaPlayer2` Name auf dem Bus erscheint oder verschwindet.
    * Wenn ein neuer Player erkannt wird:
        * Erstellt einen `Proxy` für den neuen Player (`org.mpris.MediaPlayer2.<player_name>`, `/org/mpris/MediaPlayer2`).
        * Fügt den Proxy zu `player_proxies` hinzu.
        * Sendet ein `SystemEvent::MediaPlayerAdded(player_name)` an den `EventBus`.
    * Wenn ein Player verschwindet:
        * Entfernt den Proxy aus `player_proxies`.
        * Sendet ein `SystemEvent::MediaPlayerRemoved(player_name)` an den `EventBus`.

4.  **Implementierung der MPRIS-API-Methoden (Beispiele):**
    * **`get_players()`:**
        * `pub async fn get_players(&self) -> Result<Vec<String>, DbusError>`
        * **Logik:** Fragt `connection.list_names()` ab und filtert nach Namen, die mit `org.mpris.MediaPlayer2.` beginnen.
    * **`get_playback_status(player_name)`:**
        * `pub async fn get_playback_status(&self, player_name: &str) -> Result<String, DbusError>`
        * **Logik:** Ruft die `PlaybackStatus` Property auf dem `org.mpris.MediaPlayer2.Player` Interface des spezifischen Players ab.
    * **`Youtube(player_name)`:**
        * `pub async fn get_metadata(&self, player_name: &str) -> Result<HashMap<String, zbus::zvariant::Value>, DbusError>`
        * **Logik:** Ruft die `Metadata` Property auf dem `org.mpris.MediaPlayer2.Player` Interface ab.
    * **`play_pause(player_name)`:**
        * `pub async fn play_pause(&self, player_name: &str) -> Result<(), DbusError>`
        * **Logik:** Ruft die `PlayPause` Methode auf dem `org.mpris.MediaPlayer2.Player` Interface auf.
    * **`next(player_name)`:**
        * `pub async fn next(&self, player_name: &str) -> Result<(), DbusError>`
        * **Logik:** Ruft die `Next` Methode auf.
    * **`previous(player_name)`:**
        * `pub async fn previous(&self, player_name: &str) -> Result<(), DbusError>`
        * **Logik:** Ruft die `Previous` Methode auf.
    * **`set_position(player_name, position_microseconds)`:**
        * `pub async fn set_position(&self, player_name: &str, position_microseconds: i64) -> Result<(), DbusError>`
        * **Logik:** Ruft die `SetPosition` Methode auf.

5.  **Abonnieren von MPRIS-Player-Signalen:**
    * **`PropertiesChanged` (auf Player-Objekten):**
        * `pub async fn receive_player_properties_changed_signals(&self, player_name: &str) -> Result<Receiver<(String, HashMap<String, zbus::zvariant::Value>, Vec<String>)>, DbusError>`
        * **Logik:** Erstellt einen Receiver für das `PropertiesChanged` Signal auf dem `org.mpris.MediaPlayer2.Player` Interface des spezifischen Players.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/mpris_client.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus::{Connection, Proxy, zvariant::ObjectPath}`
    * `zbus::fdo::Result as ZbusResult`
    * `zbus::MessageHeader`
    * `zbus::Message`
    * `std::collections::HashMap`
    * `tracing`
    * `std::sync::Arc`
    * `tokio::sync::RwLock`

**Kommunikationsmuster:**

* Stellt eine typsichere Rust-API für MPRIS-kompatible Medienplayer bereit.
* Erkennt dynamisch Player und abonniert deren Statusänderungen.
* Sendet `SystemEvent`s an den `EventBus` bei Player-Hinzufügung/Entfernung oder Statusänderungen.

**Erwartete Ergebnisse/Outputs:**
Ein robuster D-Bus-Client für MPRIS, der NovaDE ermöglicht, Medienplayer zu steuern und deren Status in der UI anzuzeigen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken der `zbus::Connection` und `zbus::Proxy` Methoden.
    * Testen von `new` und der Abonnement-Logik für `NameOwnerChanged`.
    * Simulieren des Hinzufügens/Entfernens von Player-Namen auf dem Bus und Überprüfen des `player_proxies` Caches und der gesendeten `SystemEvent`s.
    * Testen der Steuerungsmethoden (`play_pause`, `next`, `previous`, `set_position`) mit simulierten Player-Proxies.
    * Testen des Abrufens von Status (`get_playback_status`, `Youtube`).
    * Testen des Empfangs von `PropertiesChanged` Signalen von Player-Proxies.
* **Integration Tests (mit einem laufenden MPRIS-kompatiblen Player, z.B. VLC, Spotify):**
    * Starten des Clients und Überprüfen, ob der Player erkannt wird.
    * Steuern des Players über NovaDE (Play/Pause, Next/Previous) und manuelles Überprüfen der Player-Reaktion.
    * Änderungen am Player (z.B. Liedwechsel, Pause) und Überprüfen, ob die UI korrekt aktualisiert wird.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da komplexe dynamische Erkennung von Diensten und intensive Signal-Verarbeitung)

---

### **novade-system/src/dbus_interfaces/bluez_client.rs**

**Verantwortlichkeit:**
Implementiert den D-Bus-Client für den `org.bluez` Dienst. Dieser Client ermöglicht die Interaktion mit Bluetooth-Adaptern und -Geräten, das Scannen nach Geräten, das Koppeln, Verbinden und das Verwalten von Bluetooth-Profilen.

**Kern-Aufgaben (Tasks):**

1.  **`BluezClient` Struct:**
    * `pub struct BluezClient {`
        * `connection: Connection,` // Hält eine Referenz zur D-Bus-Verbindung
        * `adapter_proxies: RwLock<HashMap<ObjectPath, Proxy<'static>>>,` // Map: Adapter-Pfad -> Proxy
        * `device_proxies: RwLock<HashMap<ObjectPath, Proxy<'static>>>,` // Map: Geräte-Pfad -> Proxy
    * `}`

2.  **`BluezClient::new()` Funktion:**
    * `pub async fn new(connection: Connection) -> Result<Self, DbusError>`
    * **Logik:**
        * Speichert die `connection`.
        * Initialisiert die `adapter_proxies` und `device_proxies` Caches.
        * Ruft initial alle vorhandenen Adapter ab (`org.bluez.Manager.GetAdapters` oder `org.freedesktop.DBus.ObjectManager.GetManagedObjects`).
        * Abonniert D-Bus-Signale von `org.freedesktop.DBus.ObjectManager` (`InterfacesAdded`, `InterfacesRemoved`) um dynamische Adapter und Geräte zu erkennen.
        * Gibt `Self` zurück.

3.  **D-Bus-Signal-Handling (Discovering Adapters/Devices):**
    * **`InterfacesAdded(object_path, interfaces_and_properties)`:**
        * Wenn ein neues BlueZ-Adapter-Objekt erscheint, erstellt einen Proxy und fügt es zu `adapter_proxies` hinzu. Sendet `SystemEvent::BluetoothAdapterAdded`.
        * Wenn ein neues BlueZ-Geräte-Objekt erscheint, erstellt einen Proxy und fügt es zu `device_proxies` hinzu. Sendet `SystemEvent::BluetoothDeviceAdded`.
    * **`InterfacesRemoved(object_path, interfaces)`:**
        * Entfernt Proxies aus den Caches und sendet entsprechende `SystemEvent`s.

4.  **Implementierung der BlueZ-API-Methoden (Beispiele):**
    * **`GetAdapters()`:**
        * `pub async fn get_adapters(&self) -> Result<Vec<ObjectPath>, DbusError>`
        * **Logik:** Nutzt den `ObjectManager` um alle Adapter-Objekte zu finden.
    * **`StartDiscovery(adapter_path)`:**
        * `pub async fn start_discovery(&self, adapter_path: &ObjectPath) -> Result<(), DbusError>`
        * **Logik:** Ruft die Methode `StartDiscovery` auf dem `org.bluez.Adapter1` Interface des spezifischen Adapters auf.
    * **`StopDiscovery(adapter_path)`:**
        * `pub async fn stop_discovery(&self, adapter_path: &ObjectPath) -> Result<(), DbusError>`
        * **Logik:** Ruft die Methode `StopDiscovery` auf.
    * **`GetDevices(adapter_path)`:**
        * `pub async fn get_devices(&self, adapter_path: &ObjectPath) -> Result<Vec<ObjectPath>, DbusError>`
        * **Logik:** Ruft die `Devices` Property auf dem `org.bluez.Adapter1` Interface auf.
    * **`GetDeviceProperties(device_path)`:**
        * `pub async fn get_device_properties(&self, device_path: &ObjectPath) -> Result<HashMap<String, zbus::zvariant::Value>, DbusError>`
        * **Logik:** Erstellt einen Proxy für das Gerät und ruft `GetAll` auf dem `org.bluez.Device1` Interface auf.
    * **`Pair(device_path)`:**
        * `pub async fn pair_device(&self, device_path: &ObjectPath) -> Result<(), DbusError>`
        * **Logik:** Ruft die Methode `Pair` auf dem `org.bluez.Device1` Interface auf.
    * **`Connect(device_path)`:**
        * `pub async fn connect_device(&self, device_path: &ObjectPath) -> Result<(), DbusError>`
        * **Logik:** Ruft die Methode `Connect` auf dem `org.bluez.Device1` Interface auf.
    * **`Disconnect(device_path)`:**
        * `pub async fn disconnect_device(&self, device_path: &ObjectPath) -> Result<(), DbusError>`
        * **Logik:** Ruft die Methode `Disconnect` auf.
    * **`SetPowered(adapter_path, powered: bool)`:**
        * `pub async fn set_adapter_powered(&self, adapter_path: &ObjectPath, powered: bool) -> Result<(), DbusError>`
        * **Logik:** Setzt die `Powered` Property auf dem `org.bluez.Adapter1` Interface.

6.  **Abonnieren von BlueZ-Signalen:**
    * **`PropertiesChanged` (auf Adapter- und Geräte-Objekten):**
        * `pub async fn receive_properties_changed_signals(&self, object_path: ObjectPath) -> Result<Receiver<(String, HashMap<String, zbus::zvariant::Value>, Vec<String>)>, DbusError>`
        * **Logik:** Erstellt einen Receiver für das `PropertiesChanged` Signal auf den entsprechenden Interfaces (z.B. `org.bluez.Adapter1`, `org.bluez.Device1`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/dbus_interfaces/bluez_client.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::dbus_interfaces::error::DbusError`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus::{Connection, Proxy, zvariant::ObjectPath}`
    * `zbus::fdo::Result as ZbusResult`
    * `zbus::MessageHeader`
    * `zbus::Message`
    * `std::collections::HashMap`
    * `tracing`
    * `std::sync::Arc`
    * `tokio::sync::RwLock`

**Kommunikationsmuster:**

* Stellt eine typsichere Rust-API für den BlueZ D-Bus-Dienst bereit.
* Erkennt dynamisch Bluetooth-Adapter und -Geräte.
* Ermöglicht Steuerung (Scannen, Koppeln, Verbinden) und Abrufen von Statusinformationen.
* Sendet `SystemEvent`s an den `EventBus` bei Geräte-Hinzufügung/Entfernung oder Statusänderungen.

**Erwartete Ergebnisse/Outputs:**
Ein robuster D-Bus-Client für BlueZ, der NovaDE die vollständige Kontrolle über Bluetooth-Funktionen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken der `zbus::Connection` und `zbus::Proxy` Methoden.
    * Testen von `new` und der Abonnement-Logik für `InterfacesAdded`/`Removed`.
    * Simulieren des Hinzufügens/Entfernens von Adaptern/Geräten auf dem Bus.
    * Testen der Steuerungsmethoden (`start_discovery`, `stop_discovery`, `pair_device`, `connect_device`, `disconnect_device`, `set_adapter_powered`).
    * Testen des Abrufens von Informationen (`get_adapters`, `get_devices`, `get_device_properties`).
    * Testen des Empfangs von `PropertiesChanged` Signalen.
* **Integration Tests (mit einem laufenden BlueZ-Daemon und echten Bluetooth-Geräten):**
    * Starten des Clients und Überprüfen der Erkennung von Adaptern und Geräten.
    * Starten und Stoppen des Scans.
    * Koppeln und Verbinden mit einem Test-Bluetooth-Gerät (z.B. Kopfhörer, Maus) und Überprüfen der Funktionalität.
    * Deaktivieren/Aktivieren des Bluetooth-Adapters und Überprüfen der Statusänderungen in NovaDE.

**Geschätzter Aufwand:** Sehr Hoch (ca. 10-15 Tage, da BlueZ-API sehr umfangreich, dynamische Objekt-Erkennung und komplexe Interaktionen)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `screen_capture`, widmen wir uns `dbus_interfaces`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/dbus_interfaces/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/dbus_interfaces/upower_client.rs`**: Grundlegend für Energie-Management, relativ geradlinig.
3.  **`novade-system/src/dbus_interfaces/logind_client.rs`**: Wichtig für Systemaktionen, relativ geradlinig.
4.  **`novade-system/src/dbus_interfaces/xdg_portal_client.rs`**: Kritisch für Sandbox-Interaktion und Screenshots/Screencasting, komplexer aufgrund der Request-Objekte.
5.  **`novade-system/src/dbus_interfaces/network_manager_client.rs`**: Sehr umfangreich, aber für Netzwerkkonnektivität essenziell.
6.  **`novade-system/src/dbus_interfaces/mpris_client.rs`**: Dynamische Erkennung von Diensten und fortgeschrittenes Signal-Handling.
7.  **`novade-system/src/dbus_interfaces/gsettings_client.rs`**: Für Kompatibilität, aber weniger kritisch, wenn NovaDE eigene Konfiguration hat.
8.  **`novade-system/src/dbus_interfaces/bluez_client.rs`**: Sehr komplex aufgrund der Geräte- und Profilverwaltung.
9.  **`novade-system/src/dbus_interfaces/mod.rs`**: Das Hauptmodul, das alle Clients initialisiert und zusammenführt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/dbus_interfaces` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/config_service` Verzeichnisses.
---
### **novade-system/src/config_service/mod.rs**

**Verantwortlichkeit:**
Das `config_service` Modul ist für das Laden, Speichern und Verwalten der Konfigurationseinstellungen von NovaDE zuständig. Es stellt eine zentrale Schnittstelle für alle anderen System- und Domänenschicht-Module bereit, um auf persistente Einstellungen zuzugreifen und diese zu ändern. Es verarbeitet Änderungen und benachrichtigt über den `EventBus` andere interessierte Komponenten.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/config_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Konfigurations-Operationen)
    * `data_types.rs` (Definiert die Struktur der Konfigurationsdaten)
    * `manager.rs` (Interner Manager für den Konfigurationszustand und Dateisystem-Interaktionen)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Konfigurations-Subsystems:**
    * `pub async fn initialize_config_service(event_bus: EventBus) -> Result<ConfigService, ConfigError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::ConfigManager`.
        * Der `ConfigManager` versucht, die Konfiguration aus der Standarddatei (z.B. `$XDG_CONFIG_HOME/novade/config.toml` oder `$HOME/.config/novade/config.toml`) zu laden.
        * Falls die Datei nicht existiert oder fehlerhaft ist, wird eine Standardkonfiguration geladen/erstellt.
        * Gibt ein gebündeltes `ConfigService` Struct zurück.
    * **Fehlerbehandlung:** Fehler beim Laden oder Parsen der Konfigurationsdatei, Dateisystem-Zugriffsfehler.

2.  **`ConfigService` Struct:**
    * `pub struct ConfigService {`
        * `internal_manager: Arc<ConfigManager>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Konfigurations-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `ConfigService` exponiert Methoden zum Lesen, Schreiben und Abonnieren von Konfigurationsänderungen. Diese Methoden delegieren an den `internal_manager`.
    * **`get_config<T: DeserializeOwned + 'static>(&self) -> ConfigReadGuard<'_, T>`:**
        * Generische Methode, um einen Read-Lock auf die Konfiguration zu erhalten und diese in den gewünschten Typ zu deserialisieren.
    * **`update_config<F>(&self, update_fn: F) -> Result<(), ConfigError> where F: FnOnce(&mut NovadeConfig) -> bool + Send + 'static`:**
        * Methode zum atomaren Aktualisieren der Konfiguration. Die `update_fn` erhält einen mutierbaren Verweis auf die Konfiguration. Wenn `update_fn` `true` zurückgibt, wird die Änderung gespeichert und ein `SystemEvent` gesendet.
    * **`subscribe_to_config_changes(&self) -> EventReceiver<SystemEvent>`:**
        * Ermöglicht das Abonnieren von Konfigurationsänderungen über den `EventBus` (z.B. `SystemEvent::ConfigChanged`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/config_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::config_service::error::ConfigError`
    * `crate::config_service::data_types::NovadeConfig`
    * `crate::config_service::manager::ConfigManager`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `serde::de::DeserializeOwned`

**Kommunikationsmuster:**

* Wird von verschiedenen System- und Domänenschicht-Modulen aufgerufen, um Konfigurationsdaten zu lesen oder zu ändern.
* Sendet `SystemEvent::ConfigChanged` über den `EventBus`, wenn die Konfiguration aktualisiert wird.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Konfigurations-Subsystem, das eine konsistente und zentralisierte Verwaltung der NovaDE-Einstellungen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des Dateisystems oder des `ConfigManager`s.
    * Testen der Initialisierung mit vorhandener und fehlender Konfigurationsdatei.
    * Testen der `get_config` und `update_config` Methoden.
    * Überprüfen, ob `SystemEvent::ConfigChanged` korrekt gesendet wird.
* **Integration Tests (mit temporären Dateien):**
    * Erstellen temporärer Konfigurationsdateien.
    * Starten des `ConfigService` und Testen des Ladens/Speicherns der Konfiguration.
    * Mehrere Komponenten greifen gleichzeitig auf die Konfiguration zu, um Race Conditions zu testen.

**Geschätzter Aufwand:** Mittel (ca. 3-5 Tage, da Dateizugriff, Serialisierung/Deserialisierung und `RwLock` für atomare Updates)

---

### **novade-system/src/config_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `config_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für Konfigurations-bezogene Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`ConfigError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum ConfigError {`
        * `#[error("Failed to load configuration from '{path}': {source}")]`
        * `LoadError { path: PathBuf, #[source] source: std::io::Error },`
        * `#[error("Failed to parse configuration: {0}")]`
        * `ParseError(#[from] toml::de::Error),` // Wenn TOML verwendet wird
        * `#[error("Failed to serialize configuration: {0}")]`
        * `SerializeError(#[from] toml::ser::Error),`
        * `#[error("Failed to save configuration to '{path}': {source}")]`
        * `SaveError { path: PathBuf, #[source] source: std::io::Error },`
        * `#[error("Configuration key not found or invalid type: {0}")]`
        * `InvalidKeyOrType(String),`
        * `#[error("RwLock poisoned: {0}")]`
        * `Poisoned(String),`
        * `#[error("Unknown configuration error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `toml::de::Error`, `toml::ser::Error`, `anyhow::Error`.
    * Füge eine `From` Implementierung für `std::io::Error` hinzu, um sie in `LoadError` oder `SaveError` zu verpacken.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/config_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::io::Error`
    * `toml` (für `toml::de::Error`, `toml::ser::Error`)
    * `std::path::PathBuf`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `config_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an den aufrufenden `CompositorService` oder die Top-Level-Anwendung propagiert, um dort geloggt oder dem Benutzer angezeigt zu werden.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Konfigurationssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/config_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die Struktur der NovaDE-Konfigurationseinstellungen. Diese Struktur wird verwendet, um die Konfiguration zu laden, zu speichern und programmatisch darauf zuzugreifen. Es sollte alle anpassbaren Aspekte des NovaDE-Desktops abdecken.

**Kern-Aufgaben (Tasks):**

1.  **Definition des `NovadeConfig` Structs:**
    * `#[derive(Debug, Clone, PartialEq, Eq, Default, serde::Serialize, serde::Deserialize)]`
    * `pub struct NovadeConfig {`
        * `pub general: GeneralConfig,`
        * `pub power: PowerConfig,`
        * `pub appearance: AppearanceConfig,`
        * `pub desktop_environment: DesktopEnvironmentConfig,`
        * `pub keyboard_shortcuts: KeyboardShortcutsConfig,`
        * `pub privacy: PrivacyConfig,`
        * `pub applications: ApplicationsConfig,`
        * `// ... weitere Top-Level-Konfigurationskategorien`
    * `}`
    * Implementiere eine `default()`-Methode, die sinnvolle Standardwerte zurückgibt.

2.  **Definition von Unter-Structs für Konfigurationskategorien:**

    * **`GeneralConfig`:**
        * `pub struct GeneralConfig { pub language: String, pub timezone: String, pub startup_applications: Vec<String>, pub enable_telemetry: bool }`
    * **`PowerConfig`:**
        * `pub struct PowerConfig { pub screen_blank_delay_minutes: u32, pub suspend_after_minutes: u32, pub lid_close_action: LidCloseAction, pub critical_battery_action: CriticalBatteryAction }`
        * `pub enum LidCloseAction { Suspend, DoNothing, Ask }`
        * `pub enum CriticalBatteryAction { PowerOff, Suspend, Warn }`
    * **`AppearanceConfig`:**
        * `pub struct AppearanceConfig { pub theme_name: String, pub font_family: String, pub font_size: u32, pub wallpaper_path: PathBuf, pub icon_theme: String, pub accent_color: String }`
    * **`DesktopEnvironmentConfig`:**
        * `pub struct DesktopEnvironmentConfig { pub enable_compositing: bool, pub workspace_count: u32, pub animation_speed: f32, pub panel_position: PanelPosition, pub panel_auto_hide: bool, pub dock_position: DockPosition, pub dock_auto_hide: bool, pub notifications_position: NotificationsPosition }`
        * `pub enum PanelPosition { Top, Bottom, Left, Right }`
        * `pub enum DockPosition { Left, Right, Bottom }`
        * `pub enum NotificationsPosition { TopRight, TopLeft, BottomRight, BottomLeft }`
        * **Tab Leiste:** `pub tab_bar_enabled: bool, pub tab_bar_position: TabBarPosition, pub tab_bar_auto_hide: bool`
        * `pub enum TabBarPosition { Top, Bottom }`
        * **Spaces:** `pub spaces_enabled: bool, pub space_switching_animation: bool`
    * **`KeyboardShortcutsConfig`:**
        * `pub struct KeyboardShortcutsConfig { pub terminal_shortcut: String, pub browser_shortcut: String, pub file_manager_shortcut: String, pub logout_shortcut: String, pub lock_screen_shortcut: String, pub custom_shortcuts: HashMap<String, String> }`
    * **`PrivacyConfig`:**
        * `pub struct PrivacyConfig { pub remember_recent_files: bool, pub clear_temp_on_logout: bool, pub location_services_enabled: bool }`
    * **`ApplicationsConfig`:**
        * `pub struct ApplicationsConfig { pub default_browser: String, pub default_file_manager: String, pub default_terminal: String }`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/config_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::path::PathBuf`
    * `std::collections::HashMap`

**Kommunikationsmuster:**

* Diese Datenstrukturen werden vom `ConfigManager` geladen/gespeichert.
* Instanzen von `NovadeConfig` werden vom `ConfigService` für Lese- und Schreibvorgänge bereitgestellt.

**Erwartete Ergebnisse/Outputs:**
Ein vollständiges, typisiertes Schema für die NovaDE-Konfiguration, das robust serialisiert und deserialisiert werden kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `Default` Implementierung, um sicherzustellen, dass sinnvolle Standardwerte gesetzt werden.
    * Testen der `Clone`, `Debug`, `PartialEq`, `Eq` Ableitungen.
    * Testen der Serialisierung und Deserialisierung von Beispielkonfigurationen (inkl. Edge-Cases wie leere Listen, lange Strings).
    * Überprüfen, ob alle relevanten Felder im `NovadeConfig` Struct enthalten sind.

**Geschätzter Aufwand:** Mittel (ca. 4-6 Tage, da detaillierte Definitionen und das `Default`-Trait für alle Unter-Structs)

---

### **novade-system/src/config_service/manager.rs**

**Verantwortlichkeit:**
Der `ConfigManager` ist die interne Implementierung des Konfigurationsdienstes. Er verwaltet den aktuellen Konfigurationszustand im Speicher, lädt ihn aus der Datei, speichert ihn zurück und benachrichtigt über Änderungen.

**Kern-Aufgaben (Tasks):**

1.  **`ConfigManager` Struct:**
    * `pub struct ConfigManager {`
        * `config: Arc<RwLock<NovadeConfig>>,` // Der aktuelle Konfigurationszustand
        * `config_path: PathBuf,` // Pfad zur Konfigurationsdatei
        * `event_bus: EventBus,`
        * `// Interner Sende-Kanal für Dateispeicherungs-Anfragen (optional, für Debouncing/Batching)`
    * `}`

2.  **`ConfigManager::new()` Funktion:**
    * `pub async fn new(config_path: Option<PathBuf>, event_bus: EventBus) -> Result<Self, ConfigError>`
    * **Logik:**
        * Bestimmt den tatsächlichen `config_path`: Wenn `None`, Standardpfad `$XDG_CONFIG_HOME/novade/config.toml` oder `$HOME/.config/novade/config.toml` verwenden.
        * Versucht, die Konfiguration von `config_path` zu laden (`self.load_config()`).
        * Bei Fehler (Datei nicht gefunden, Parsing-Fehler) wird eine `NovadeConfig::default()` Instanz verwendet.
        * Initialisiert das `RwLock` mit der geladenen/Standard-Konfiguration.
        * Gibt `Self` zurück.

3.  **`ConfigManager::load_config()` Methode:**
    * `async fn load_config(path: &Path) -> Result<NovadeConfig, ConfigError>`
    * **Logik:**
        * Liest den Inhalt der Datei `path` asynchron (`tokio::fs::read`).
        * Deserialisiert den Inhalt als TOML in ein `NovadeConfig` Struct (`toml::from_str`).
        * **Fehlerbehandlung:** `LoadError` bei IO-Fehlern, `ParseError` bei ungültigem TOML.

4.  **`ConfigManager::save_config()` Methode:**
    * `async fn save_config(path: &Path, config: &NovadeConfig) -> Result<(), ConfigError>`
    * **Logik:**
        * Serialisiert das `NovadeConfig` Struct in einen TOML-String (`toml::to_string`).
        * Schreibt den String asynchron in die Datei `path` (`tokio::fs::write`).
        * Stellt sicher, dass das Elternverzeichnis existiert (`tokio::fs::create_dir_all`).
        * **Fehlerbehandlung:** `SerializeError` bei Serialisierungsfehlern, `SaveError` bei IO-Fehlern.

5.  **`ConfigManager::get_read_guard()` Methode:**
    * `pub fn get_read_guard(&self) -> tokio::sync::RwLockReadGuard<'_, NovadeConfig>`
    * **Logik:** Gibt einen Read-Lock auf die Konfiguration zurück. Dies ermöglicht anderen Modulen, die Konfiguration zu lesen, ohne sie zu mutieren.

6.  **`ConfigManager::update_config()` Methode:**
    * `pub async fn update_config<F>(&self, update_fn: F) -> Result<(), ConfigError> where F: FnOnce(&mut NovadeConfig) -> bool + Send + 'static`
    * **Logik:**
        * Erhält einen Write-Lock auf die Konfiguration (`self.config.write().await`).
        * Ruft die übergebene `update_fn` auf dem mutierbaren Konfigurations-Struct auf.
        * Wenn `update_fn` `true` zurückgibt (was signalisiert, dass Änderungen vorgenommen wurden):
            * Speichert die aktualisierte Konfiguration asynchron auf die Festplatte (`self.save_config()`).
            * Sendet `SystemEvent::ConfigChanged` über den `EventBus`.
        * **Fehlerbehandlung:** `Poisoned` wenn RwLock verunreinigt ist, Propagierung von `SaveError`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/config_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::config_service::error::ConfigError`
    * `crate::config_service::data_types::NovadeConfig`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::fs`
    * `tokio::sync::RwLock`
    * `toml`
    * `tracing`
    * `std::path::Path`
    * `std::path::PathBuf`
    * `std::sync::Arc`
    * `directories::ProjectDirs` (für Standard-Konfigurationspfad)

**Kommunikationsmuster:**

* Verwaltet den zentralen Konfigurationszustand.
* Interagiert direkt mit dem Dateisystem zum Laden und Speichern.
* Informiert über den `EventBus` über Konfigurationsänderungen.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Konfigurations-Manager, der die Persistenz und den synchronisierten Zugriff auf NovaDE-Einstellungen gewährleistet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking des Dateisystems oder `tokio::fs`):**
    * Testen von `load_config` für existierende, nicht existierende und fehlerhafte Dateien.
    * Testen von `save_config` für erfolgreiche Speicherung und IO-Fehler.
    * Testen von `update_config`:
        * Wenn `update_fn` `true` zurückgibt (Änderung und Speicherung).
        * Wenn `update_fn` `false` zurückgibt (keine Änderung, keine Speicherung).
        * Überprüfen, ob `SystemEvent::ConfigChanged` korrekt gesendet wird.
    * Testen des Verhaltens bei `RwLock` Verunreinigung.
* **Integration Tests (mit temporären Dateien):**
    * Starten des `ConfigManager` mit temporären Pfaden.
    * Schreiben und Lesen von Konfigurationen über die API.
    * Mehrere `update_config` Aufrufe gleichzeitig, um die Konsistenz des `RwLock`s zu testen.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da komplexe Zustandsverwaltung, atomare Operationen, Dateizugriff und Fehlerbehandlung)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `dbus_interfaces`, widmen wir uns `config_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/config_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/config_service/data_types.rs`**: Definition des Konfigurationsschemas. Dies ist grundlegend, da der Manager diese Struktur verwenden muss.
3.  **`novade-system/src/config_service/manager.rs`**: Die Kernlogik für das Laden, Speichern und Verwalten des Konfigurationszustands.
4.  **`novade-system/src/config_service/mod.rs`**: Das Hauptmodul, das den Manager initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/config_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/theme_manager` Verzeichnisses, um die visuellen Aspekte der NovaDE-Umgebung zu verwalten.
---
### **novade-system/src/theme_manager/mod.rs**

**Verantwortlichkeit:**
Das `theme_manager` Modul ist verantwortlich für das Laden, Anwenden und Verwalten von UI-Themes und Assets (z.B. Icons, Schriftarten, Cursor) für die NovaDE-Oberfläche. Es stellt sicher, dass die Desktop-Umgebung ein konsistentes visuelles Erscheinungsbild aufweist und ermöglicht Benutzern die Anpassung des Themas.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/theme_manager/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Theme-Operationen)
    * `theme.rs` (Definition der Theme-Struktur und Parsing-Logik)
    * `loader.rs` (Logik zum Auffinden und Laden von Theme-Ressourcen)
    * `data_types.rs` (Spezifische Datentypen für Theme-Informationen und Assets)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Theme-Subsystems:**
    * `pub async fn initialize_theme_manager(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<ThemeManager, ThemeError>`
    * **Logik:**
        * Erstellt eine Instanz von `loader::ThemeLoader`.
        * Ruft die aktuelle `theme_name` und `icon_theme` aus dem `config_service` ab.
        * Versucht, das Standard-Theme und Icon-Theme zu laden und anzuwenden.
        * Beginnt mit der Überwachung von Konfigurationsänderungen bezüglich des Themas und Icon-Themas über den `event_bus` (`SystemEvent::ConfigChanged`).
        * Gibt ein gebündeltes `ThemeManager` Struct zurück.
    * **Fehlerbehandlung:** Fehler beim Laden des Standard-Themes, des Icon-Themas oder initialer Konfigurationslesefehler.

2.  **`ThemeManager` Struct:**
    * `pub struct ThemeManager {`
        * `loader: Arc<ThemeLoader>,`
        * `active_theme: RwLock<Arc<Theme>>,` // Aktuell geladenes Theme
        * `active_icon_theme: RwLock<Arc<IconTheme>>,` // Aktuell geladenes Icon-Theme
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
    * `}`
    * Dient als Container und Zugangspunkt für die Theme-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `ThemeManager` exponiert Methoden zum Abrufen aktiver Themes, zum Anwenden neuer Themes und zum Abfragen von Theme-Ressourcen.
    * **`get_active_theme(&self) -> ThemeReadGuard`:**
        * Gibt einen Read-Lock auf das aktive `Theme` zurück.
    * **`get_active_icon_theme(&self) -> IconThemeReadGuard`:**
        * Gibt einen Read-Lock auf das aktive `IconTheme` zurück.
    * **`apply_theme(&self, theme_name: &str) -> Result<(), ThemeError>`:**
        * **Logik:**
            * Verwendet den `ThemeLoader` um das Theme mit `theme_name` zu laden.
            * Aktualisiert `active_theme`.
            * Benachrichtigt Komponenten, die visuelle Assets nutzen, über den `EventBus` (`SystemEvent::ThemeChanged`).
            * Speichert die Änderung im `config_service`.
    * **`apply_icon_theme(&self, icon_theme_name: &str) -> Result<(), ThemeError>`:**
        * **Logik:**
            * Verwendet den `ThemeLoader` um das Icon-Theme zu laden.
            * Aktualisiert `active_icon_theme`.
            * Benachrichtigt Komponenten über den `EventBus` (`SystemEvent::IconThemeChanged`).
            * Speichert die Änderung im `config_service`.
    * **`get_available_themes(&self) -> Result<Vec<String>, ThemeError>`:**
        * Listet alle gefundenen Theme-Namen auf.
    * **`get_available_icon_themes(&self) -> Result<Vec<String>, ThemeError>`:**
        * Listet alle gefundenen Icon-Theme-Namen auf.
    * **`get_themed_asset_path(&self, asset_type: AssetType, name: &str, size: u32) -> Option<PathBuf>`:**
        * Findet den Pfad zu einem bestimmten Asset (z.B. Icon, Cursor) im aktiven Theme oder Icon-Theme, unter Berücksichtigung von Größe und Skalierung.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `ThemeManager` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn die `theme_name` oder `icon_theme` in der Konfiguration geändert wird, löst der Task das erneute Laden und Anwenden des entsprechenden Themas aus.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/theme_manager/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::theme_manager::error::ThemeError`
    * `crate::theme_manager::theme::{Theme, IconTheme}`
    * `crate::theme_manager::loader::ThemeLoader`
    * `crate::theme_manager::data_types::{AssetType, ThemeReadGuard, IconThemeReadGuard}`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tokio::sync::RwLock`
    * `tracing`
    * `std::sync::Arc`
    * `std::path::PathBuf`

**Kommunikationsmuster:**

* Wird von der Domänenschicht und der UI-Schicht verwendet, um Theme-Informationen abzurufen und Themen zu wechseln.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Theme-Einstellungen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten über Theme-Änderungen zu informieren.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Theme-Management-Subsystem, das die dynamische Anwendung und Verwaltung von UI-Themes und Assets ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService` und `EventBus`.
    * Mocken des `ThemeLoader`s, um simulierte Theme-Dateien zu liefern.
    * Testen der Initialisierung, insbesondere das Laden des Standard-Themes.
    * Testen von `apply_theme` und `apply_icon_theme`: Überprüfen, ob das korrekte Theme geladen, der interne Zustand aktualisiert, der `ConfigService` benachrichtigt und die richtigen `SystemEvent`s gesendet werden.
    * Testen von `get_available_themes` und `get_available_icon_themes`.
    * Testen von `get_themed_asset_path` mit verschiedenen Asset-Typen und Größen.
    * Simulieren von `ConfigChanged` Events und Überprüfen, ob das Theme automatisch aktualisiert wird.
* **Integration Tests (mit echten/Test-Theme-Verzeichnissen):**
    * Einrichten eines Test-Dateisystems mit mehreren Themen und Icon-Themen.
    * Starten des `ThemeManager` und Testen des Ladens und Anwendens von Themen.
    * Manuelles oder programmatisches Ändern der Konfiguration und Überprüfen, ob NovaDE sein Erscheinungsbild ändert.
    * Überprüfen, ob die richtigen Asset-Pfade für reale Assets gefunden werden.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da Dateisystem-Scanning, Parsing von Theme-Strukturen, Zustandsverwaltung und Event-Handling)

---

### **novade-system/src/theme_manager/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `theme_manager` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für Theme-bezogene Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`ThemeError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum ThemeError {`
        * `#[error("Theme directory not found: {0}")]`
        * `ThemeNotFound(String),`
        * `#[error("Failed to load theme configuration file: {0}")]`
        * `ThemeConfigLoadError(#[from] std::io::Error),`
        * `#[error("Failed to parse theme configuration: {0}")]`
        * `ThemeConfigParseError(#[from] toml::de::Error),` // oder JSON, je nach Theme-Format
        * `#[error("Icon not found in active theme: {0}")]`
        * `IconNotFound(String),`
        * `#[error("Invalid theme asset path: {0}")]`
        * `InvalidAssetPath(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("RwLock poisoned: {0}")]`
        * `Poisoned(String),`
        * `#[error("Unknown theme error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `std::io::Error`, `toml::de::Error` (oder entsprechendes Parsing-Fehler-Trait), `crate::config_service::error::ConfigError` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/theme_manager/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::io::Error`
    * `toml` (wenn TOML für Theme-Definitionen verwendet wird)
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `theme_manager` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Theme-System.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/theme_manager/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `theme_manager` verwendet werden, um Theme-Informationen, Icon-Sets und Asset-Pfade zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`AssetType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq)]`
    * `pub enum AssetType { Icon, Cursor, Font, Wallpaper, Stylesheet }`

2.  **`ThemeReadGuard` Type Alias:**
    * `pub type ThemeReadGuard<'a> = tokio::sync::RwLockReadGuard<'a, Arc<Theme>>;`
    * Stellt einen typsicheren Alias für den Read-Lock auf das `Theme`-Struct bereit.

3.  **`IconThemeReadGuard` Type Alias:**
    * `pub type IconThemeReadGuard<'a> = tokio::sync::RwLockReadGuard<'a, Arc<IconTheme>>;`
    * Stellt einen typsicheren Alias für den Read-Lock auf das `IconTheme`-Struct bereit.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/theme_manager/data_types.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::theme_manager::theme::{Theme, IconTheme}`
* **Extern:**
    * `tokio::sync::RwLockReadGuard`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Diese Typen werden intern vom `theme_manager` und seinen Sub-Modulen verwendet.
* Die `*ReadGuard` Typen werden von der `ThemeManager`-API zurückgegeben, um einen sicheren Zugriff auf die aktiven Themes zu ermöglichen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Theme-Verwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen (`Debug`, `Clone`, `PartialEq`, `Eq`) für `AssetType`.
    * Sicherstellen, dass die `Type` Aliase korrekt definiert sind und die richtigen Generics verwenden.

**Geschätzter Aufwand:** Niedrig (ca. 0.5 Tage, hauptsächlich Definitionen)

---

### **novade-system/src/theme_manager/theme.rs**

**Verantwortlichkeit:**
Definiert die internen Datenstrukturen für ein UI-Theme und ein Icon-Theme, sowie die Logik zum Parsen ihrer jeweiligen Konfigurationsdateien (z.B. `index.theme`, `theme.toml`).

**Kern-Aufgaben (Tasks):**

1.  **`Theme` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Default, serde::Serialize, serde::Deserialize)]`
    * `pub struct Theme {`
        * `pub name: String,`
        * `pub description: Option<String>,`
        * `pub author: Option<String>,`
        * `pub version: Option<String>,`
        * `pub path: PathBuf,` // Wurzelverzeichnis des Themes
        * `pub gtk_theme_name: Option<String>,` // Name des zu verwendenden GTK-Themes
        * `pub icon_theme_name: Option<String>,` // Name des zu verwendenden Icon-Themes (Standard-Fallback)
        * `pub cursor_theme_name: Option<String>,` // Name des zu verwendenden Cursor-Themes
        * `pub font_config: Option<FontConfig>,`
        * `pub colors: HashMap<String, String>,` // Farbvariablen (z.B. "primary_background": "#1a1a1a")
        * `pub assets: HashMap<AssetType, PathBuf>,` // Pfade zu generischen Assets (z.B. "wallpaper": "path/to/wallpaper.png")
        * `// ... weitere theme-spezifische Einstellungen (z.B. Schatten, Rundungen)`
    * `}`

2.  **`FontConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Default, serde::Serialize, serde::Deserialize)]`
    * `pub struct FontConfig { pub font_family: Option<String>, pub font_size: Option<f32> }`

3.  **`IconTheme` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Default, serde::Serialize, serde::Deserialize)]`
    * `pub struct IconTheme {`
        * `pub name: String,`
        * `pub directories: Vec<IconDirectory>,` // Liste der Icon-Verzeichnisse mit Eigenschaften
        * `pub inherits: Vec<String>,` // Liste der übergeordneten Icon-Themes
        * `pub path: PathBuf,` // Wurzelverzeichnis des Icon-Themes
    * `}`

4.  **`IconDirectory` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Default, serde::Serialize, serde::Deserialize)]`
    * `pub struct IconDirectory {`
        * `pub name: String,` // Name des Unterverzeichnisses (z.B. "24x24/apps")
        * `pub size: u32,` // Basisgröße der Icons in diesem Verzeichnis
        * `pub threshold: Option<u32>,` // Maximaler Größenunterschied, für den dieses Verzeichnis geeignet ist
        * `pub max_size: Option<u32>,` // Maximale Größe (falls skalierbar)
        * `pub min_size: Option<u32>,` // Minimale Größe (falls skalierbar)
        * `pub context: Option<String>,` // "Actions", "Devices", "MimeTypes", etc.
    * `}`

5.  **`Theme::from_path()` Funktion:**
    * `pub async fn from_path(path: &Path) -> Result<Theme, ThemeError>`
    * **Logik:**
        * Konstruiert den Pfad zur Theme-Konfigurationsdatei (z.B. `path/theme.toml`).
        * Liest und deserialisiert die TOML-Datei in ein `Theme` Struct.
        * Setzt den `path` Feld des `Theme` Structs auf das übergebene Wurzelverzeichnis.
        * **Fehlerbehandlung:** `ThemeConfigLoadError`, `ThemeConfigParseError`.

6.  **`IconTheme::from_path()` Funktion:**
    * `pub async fn from_path(path: &Path) -> Result<IconTheme, ThemeError>`
    * **Logik:**
        * Konstruiert den Pfad zur Icon-Theme-Konfigurationsdatei (standardmäßig `path/index.theme` im FreeDesktop.org Standard-Format, daher muss hier eine INI-Parsing-Bibliothek verwendet werden, z.B. `ini` crate).
        * Liest und parst die INI-Datei.
        * Extrahiert `Name`, `Directories`, `Inherits` und andere relevante Informationen.
        * Parsen des `Directories`-Strings in eine Liste von `IconDirectory` structs.
        * Setzt den `path` Feld des `IconTheme` Structs.
        * **Fehlerbehandlung:** `ThemeConfigLoadError`, `ThemeConfigParseError`.

7.  **`IconTheme::get_icon_path()` Methode:**
    * `pub fn get_icon_path(&self, icon_name: &str, size: u32) -> Option<PathBuf>`
    * **Logik:**
        * Implementiert die FreeDesktop.org Icon Theme Spezifikation zum Auffinden des am besten passenden Icons:
            * Durchsucht `self.directories` nach dem besten Match basierend auf `size`, `min_size`, `max_size`, `threshold`.
            * Priorisiert exakte Größenmatches, dann skalierbare, dann die nächstgrößere/kleinere Größe.
            * Berücksichtigt die `context`.
            * Überprüft, ob die Icon-Datei (`.png`, `.svg`, `.xpm`) im entsprechenden Verzeichnis existiert.
            * Wenn kein Match gefunden, rekursiver Aufruf für `self.inherits` (lädt die geerbten Themes bei Bedarf).
        * Gibt den vollständigen Pfad zur Icon-Datei zurück.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/theme_manager/theme.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::theme_manager::error::ThemeError`
    * `crate::theme_manager::data_types::AssetType`
* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `toml` (für Theme-Konfiguration)
    * `ini` (für Icon-Theme `index.theme`)
    * `std::path::{Path, PathBuf}`
    * `std::collections::HashMap`
    * `tracing`
    * `tokio::fs`

**Kommunikationsmuster:**

* Diese Strukturen sind die primäre Darstellung von Themes im Speicher.
* Die `from_path` Funktionen werden vom `ThemeLoader` verwendet.
* Die `get_icon_path` Methode wird vom `ThemeManager` aufgerufen.

**Erwartete Ergebnisse/Outputs:**
Robuste Datenstrukturen und Parselogik für UI- und Icon-Themes, die dem FreeDesktop.org Standard entsprechen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen von `Theme::from_path` mit gültigen und ungültigen TOML-Dateien.
    * Testen von `IconTheme::from_path` mit gültigen und ungültigen `index.theme` Dateien.
    * Testen von `IconTheme::get_icon_path`:
        * Exakte Größenmatches.
        * Skalierung und Threshold-Logik.
        * Fallback zu geerbten Themes.
        * Icon nicht gefunden.
        * Verschiedene Icon-Formate (`.png`, `.svg`).
    * Testen der `Default`, `Clone`, `Debug`, `PartialEq`, `Eq`, `Serialize`, `Deserialize` Ableitungen.

**Geschätzter Aufwand:** Sehr Hoch (ca. 10-15 Tage, da komplexe Parsing-Logik für `index.theme` und die Icon-Suche-Logik gemäß Spezifikation)

---

### **novade-system/src/theme_manager/loader.rs**

**Verantwortlichkeit:**
Der `ThemeLoader` ist dafür zuständig, Theme- und Icon-Theme-Dateien im Dateisystem zu finden und zu laden. Er implementiert die FreeDesktop.org Spezifikation für Theme- und Icon-Theme-Pfade.

**Kern-Aufgaben (Tasks):**

1.  **`ThemeLoader` Struct:**
    * `pub struct ThemeLoader {`
        * `theme_paths: Vec<PathBuf>,` // Liste der Verzeichnisse, in denen nach Themes gesucht wird
        * `icon_theme_paths: Vec<PathBuf>,` // Liste der Verzeichnisse, in denen nach Icon-Themes gesucht wird
    * `}`

2.  **`ThemeLoader::new()` Funktion:**
    * `pub async fn new() -> Result<Self, ThemeError>`
    * **Logik:**
        * Initialisiert `theme_paths` und `icon_theme_paths` basierend auf den FreeDesktop.org XDG Base Directory Specification:
            * `XDG_DATA_HOME/themes`
            * `XDG_DATA_DIRS/themes`
            * `/usr/share/themes`
            * `/usr/local/share/themes`
            * Dasselbe für Icon-Themes (`icons` statt `themes`).
        * Entfernt Duplikate und stellt sicher, dass die Pfade existieren.
        * Gibt `Self` zurück.

3.  **`ThemeLoader::load_theme()` Methode:**
    * `pub async fn load_theme(&self, theme_name: &str) -> Result<Arc<Theme>, ThemeError>`
    * **Logik:**
        * Durchsucht `self.theme_paths` nach einem Unterverzeichnis mit dem Namen `theme_name`.
        * Wenn gefunden, ruft `Theme::from_path()` auf dem gefundenen Verzeichnis auf.
        * Cacht geladene Themes intern (`Arc<Theme>`) für Performance.
        * **Fehlerbehandlung:** `ThemeNotFound` wenn Theme nicht gefunden, Propagierung von `Theme::from_path` Fehlern.

4.  **`ThemeLoader::load_icon_theme()` Methode:**
    * `pub async fn load_icon_theme(&self, icon_theme_name: &str) -> Result<Arc<IconTheme>, ThemeError>`
    * **Logik:**
        * Durchsucht `self.icon_theme_paths` nach einem Unterverzeichnis mit dem Namen `icon_theme_name`.
        * Wenn gefunden, ruft `IconTheme::from_path()` auf dem gefundenen Verzeichnis auf.
        * Cacht geladene Icon-Themes intern (`Arc<IconTheme>`).
        * **Fehlerbehandlung:** `ThemeNotFound` wenn Icon-Theme nicht gefunden, Propagierung von `IconTheme::from_path` Fehlern.

5.  **`ThemeLoader::get_available_themes()` Methode:**
    * `pub async fn get_available_themes(&self) -> Result<Vec<String>, ThemeError>`
    * **Logik:**
        * Scannt alle `self.theme_paths` Verzeichnisse nach Unterverzeichnissen, die eine gültige `theme.toml` Datei (oder eine andere definierte Theme-Konfigurationsdatei) enthalten.
        * Liest den `Name` aus der Konfigurationsdatei, um den offiziellen Theme-Namen zu erhalten.
        * Gibt eine Liste der gefundenen Theme-Namen zurück.

6.  **`ThemeLoader::get_available_icon_themes()` Methode:**
    * `pub async fn get_available_icon_themes(&self) -> Result<Vec<String>, ThemeError>`
    * **Logik:**
        * Scannt alle `self.icon_theme_paths` Verzeichnisse nach Unterverzeichnissen, die eine gültige `index.theme` Datei enthalten.
        * Liest den `Name` aus der `index.theme` Datei.
        * Gibt eine Liste der gefundenen Icon-Theme-Namen zurück.

**Spezifische Artefekte/Dateien:**

* `novade-system/src/theme_manager/loader.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::theme_manager::error::ThemeError`
    * `crate::theme_manager::theme::{Theme, IconTheme}`
* **Extern:**
    * `tokio::fs`
    * `tokio::task`
    * `tracing`
    * `std::path::{Path, PathBuf}`
    * `std::sync::Arc`
    * `directories::BaseDirs` (für XDG-Pfade)
    * `dashmap` (für optionalen internen Cache)

**Kommunikationsmuster:**

* Wird vom `ThemeManager` verwendet, um Themes und Icon-Themes zu finden und zu laden.
* Kapselt die Dateisystem-Interaktionen und das Parsing der Theme-Verzeichnisse.

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger Theme-Loader, der Themes und Icon-Themes nach FreeDesktop.org Standardpfaden finden und laden kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking des Dateisystems):**
    * Mocken von `tokio::fs` Operationen, um simulierte Theme-Verzeichnisse und Dateien bereitzustellen.
    * Testen von `new`: Überprüfen der korrekten Initialisierung der Suchpfade.
    * Testen von `load_theme` und `load_icon_theme`:
        * Erfolgreiches Laden von Themes.
        * Theme/Icon-Theme nicht gefunden.
        * Fehler beim Parsen der Konfigurationsdatei.
    * Testen von `get_available_themes` und `get_available_icon_themes`:
        * Erkennung von Themes in verschiedenen Suchpfaden.
        * Behandlung von ungültigen Theme-Verzeichnissen.
* **Integration Tests (mit temporären Dateisystem-Strukturen):**
    * Erstellen einer echten temporären Verzeichnisstruktur, die die XDG-Spezifikation nachahmt, mit verschiedenen gültigen und ungültigen Themen.
    * Starten des `ThemeLoader`s und Ausführen der Methoden, um reale Dateisystem-Interaktionen zu testen.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da Dateisystem-Scanning, Pfad-Auflösung und Fehlerbehandlung)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `config_service`, widmen wir uns `theme_manager`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/theme_manager/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/theme_manager/data_types.rs`**: Definition der grundlegenden Datentypen.
3.  **`novade-system/src/theme_manager/theme.rs`**: Definition der `Theme` und `IconTheme` Strukturen und der Parselogik für ihre Konfigurationsdateien, einschließlich der komplexen `get_icon_path` Logik.
4.  **`novade-system/src/theme_manager/loader.rs`**: Die Logik zum Auffinden und Laden der Theme-Dateien, die `theme.rs` nutzt.
5.  **`novade-system/src/theme_manager/mod.rs`**: Das Hauptmodul, das den `ThemeLoader` initialisiert, den Zustand verwaltet und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/theme_manager` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/sound_manager` Verzeichnisses, um die Audio-Wiedergabe und -Steuerung zu verwalten.
---
### **novade-system/src/sound_manager/mod.rs**

**Verantwortlichkeit:**
Das `sound_manager` Modul ist verantwortlich für die Wiedergabe von Systemklängen, das Verwalten der Audio-Lautstärke und das Bereitstellen von Informationen über Audio-Geräte. Es abstrahiert die zugrunde liegende Audio-API (z.B. PipeWire/PulseAudio) und bietet eine einfache Schnittstelle für andere NovaDE-Komponenten.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/sound_manager/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Audio-Operationen)
    * `playback.rs` (Logik für die Wiedergabe von Sound-Dateien)
    * `mixer.rs` (Logik für die Lautstärke-Steuerung und Geräte-Verwaltung über PipeWire/PulseAudio)
    * `data_types.rs` (Definition von Audio-bezogenen Datentypen)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Sound-Subsystems:**
    * `pub async fn initialize_sound_manager(event_bus: EventBus) -> Result<SoundManager, SoundError>`
    * **Logik:**
        * Initialisiert den internen `mixer::Mixer` und `playback::PlaybackManager`.
        * Der `Mixer` stellt die Verbindung zur Audio-Server-API her (z.B. PipeWire/PulseAudio).
        * Registriert sich beim `EventBus` für relevante `SystemEvent`s (z.B. `VolumeControlEvent`).
        * Gibt ein gebündeltes `SoundManager` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Audio-Mixers oder der Verbindung zum Audio-Server.

2.  **`SoundManager` Struct:**
    * `pub struct SoundManager {`
        * `playback_manager: Arc<PlaybackManager>,`
        * `mixer: Arc<Mixer>,`
        * `event_bus: EventBus,`
    * `}`
    * Dient als Container und Zugangspunkt für die Audio-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `SoundManager` exponiert Methoden zur Sound-Wiedergabe, Lautstärke-Steuerung und zum Abfragen des Audio-Status. Diese Methoden delegieren an `playback_manager` und `mixer`.
    * **`play_system_sound(&self, sound_event: SoundEvent) -> Result<(), SoundError>`:**
        * **Logik:** Leitet die Anfrage an den `PlaybackManager` weiter.
        * **`SoundEvent`** wäre ein Enum (z.B. `Startup, Shutdown, Notification, Error, Click`).
    * **`set_master_volume(&self, volume_percent: u8) -> Result<(), SoundError>`:**
        * **Logik:** Leitet die Anfrage an den `Mixer` weiter, um die globale Lautstärke zu setzen.
    * **`get_master_volume(&self) -> Result<u8, SoundError>`:**
        * **Logik:** Ruft die aktuelle globale Lautstärke vom `Mixer` ab.
    * **`set_mute_status(&self, muted: bool) -> Result<(), SoundError>`:**
        * **Logik:** Leitet die Anfrage an den `Mixer` weiter, um den Master-Kanal stummzuschalten.
    * **`get_mute_status(&self) -> Result<bool, SoundError>`:**
        * **Logik:** Ruft den aktuellen Stumm-Status vom `Mixer` ab.
    * **`get_audio_devices(&self) -> Result<Vec<AudioDevice>, SoundError>`:**
        * **Logik:** Ruft eine Liste der verfügbaren Audio-Ausgabegeräte vom `Mixer` ab.
    * **`set_default_output_device(&self, device_id: &str) -> Result<(), SoundError>`:**
        * **Logik:** Setzt das Standard-Ausgabegerät über den `Mixer`.

4.  **Hintergrund-Task zum Abonnieren von `VolumeControlEvent`s:**
    * Der `SoundManager` sollte einen langlebigen Task starten, der auf `SystemEvent::VolumeControlEvent` hört. Diese Events werden typischerweise von der Hotkey-Verwaltung ausgelöst.
    * Bei Empfang eines `VolumeControlEvent` (z.B. `VolumeUp`, `VolumeDown`, `ToggleMute`) ruft der Task die entsprechenden `Mixer`-Methoden auf.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/sound_manager/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::sound_manager::error::SoundError`
    * `crate::sound_manager::playback::PlaybackManager`
    * `crate::sound_manager::mixer::Mixer`
    * `crate::sound_manager::data_types::{SoundEvent, AudioDevice}`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Wird von der Domänenschicht und der UI-Schicht verwendet, um Audio-Funktionen zu steuern.
* Interagiert mit dem `EventBus` für die Verarbeitung von Lautstärke-Tasten und zur Benachrichtigung über Statusänderungen (`SystemEvent::VolumeChanged`, `SystemEvent::MuteStatusChanged`, `SystemEvent::AudioDeviceAdded/Removed`).

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Sound-Management-Subsystem, das Systemklänge abspielen und grundlegende Audio-Einstellungen steuern kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `EventBus`, `PlaybackManager` und `Mixer`.
    * Testen der Initialisierung.
    * Testen der Weiterleitung von Aufrufen an `playback_manager` und `mixer`.
    * Simulieren von `SystemEvent::VolumeControlEvent` und Überprüfen, ob die korrekten `Mixer`-Methoden aufgerufen werden.
    * Überprüfen der Fehlerbehandlung und -propagation.
* **Integration Tests (mit aktivem Audio-System):**
    * Starten des `SoundManager` und Testen der Lautstärke-Steuerung (visuell überprüfen).
    * Abspielen von Systemklängen und Überprüfen, ob sie hörbar sind.
    * Ein-/Ausstecken von Audio-Geräten (Kopfhörer) und Überprüfen, ob `get_audio_devices` die Liste korrekt aktualisiert und ob `SystemEvent`s gesendet werden.
    * Testen der Stummschaltfunktion.

**Geschätzter Aufwand:** Hoch (ca. 6-9 Tage, da Kapselung von zwei Sub-Modulen und Event-Handling)

---

### **novade-system/src/sound_manager/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `sound_manager` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Audio-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`SoundError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum SoundError {`
        * `#[error("Failed to initialize audio backend: {0}")]`
        * `BackendInitError(String),`
        * `#[error("Failed to connect to audio server: {0}")]`
        * `AudioServerConnectError(String),`
        * `#[error("Audio device not found: {0}")]`
        * `DeviceNotFound(String),`
        * `#[error("Invalid volume level: {0}")]`
        * `InvalidVolume(u8),`
        * `#[error("Failed to play sound: {0}")]`
        * `PlaybackError(String),`
        * `#[error("Sound file not found: {0}")]`
        * `SoundFileNotFound(String),`
        * `#[error("Failed to parse sound file: {0}")]`
        * `SoundFileParseError(String),`
        * `#[error("Unknown sound error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `anyhow::Error` und alle spezifischen Fehler von den gewählten Audio-Backend-Bibliotheken.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/sound_manager/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * Spezifische Fehler-Typen der verwendeten Audio-Bibliotheken (z.B. `pipewire::Error`, `pulseaudio::Error`, `rodio::Error`).

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `sound_manager` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Sound-System.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/sound_manager/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `sound_manager` verwendet werden, um Audio-Informationen und Systemklang-Ereignisse zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`SoundEvent` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]`
    * `pub enum SoundEvent {`
        * `Startup,`
        * `Shutdown,`
        * `Login,`
        * `Logout,`
        * `Notification,`
        * `Warning,`
        * `Error,`
        * `Click,`
        * `Drag,`
        * `Drop,`
        * `VolumeChange,`
        * `ScreenLock,`
        * `ScreenUnlock,`
        * `WindowOpen,`
        * `WindowClose,`
        * `Minimize,`
        * `Maximize,`
        * `// ... weitere spezifische Systemklänge`
    * `}`
    * `pub fn default_sound_file(&self) -> &'static str`
        * **Logik:** Eine Methode, die für jedes `SoundEvent` den Standard-Sound-Dateinamen zurückgibt (z.B. "startup.ogg", "notification.ogg").

2.  **`AudioDevice` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct AudioDevice {`
        * `pub id: String,` // Eindeutiger Bezeichner des Geräts (z.B. Port-ID, Udev-Pfad)
        * `pub name: String,` // Anzeigename des Geräts (z.B. "Built-in Audio Analog Stereo")
        * `pub description: String,` // Detailliertere Beschreibung
        * `pub is_default: bool,` // Ist dies das aktuelle Standardgerät?
        * `pub is_output: bool,` // Ist dies ein Ausgabegerät?
        * `pub is_input: bool,` // Ist dies ein Eingabegerät?
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/sound_manager/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::collections::HashMap` (falls für die `default_sound_file` Map verwendet)

**Kommunikationsmuster:**

* Diese Typen werden intern vom `sound_manager` und seinen Sub-Modulen verwendet.
* `SoundEvent` wird von der `play_system_sound` Methode verwendet.
* `AudioDevice` wird von `get_audio_devices` zurückgegeben.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für Audio-Operationen und Systemklang-Ereignisse.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für `SoundEvent` und `AudioDevice`.
    * Testen der `default_sound_file` Methode, um sicherzustellen, dass die richtigen Dateinamen zurückgegeben werden.
    * Testen der Serialisierung und Deserialisierung von `SoundEvent` und `AudioDevice`.

**Geschätzter Aufwand:** Niedrig (ca. 1-2 Tage, hauptsächlich Definitionen und `default_sound_file` Logik)

---

### **novade-system/src/sound_manager/playback.rs**

**Verantwortlichkeit:**
Das `PlaybackManager` Modul ist spezifisch für die Wiedergabe von Systemklang-Dateien zuständig. Es lädt Sound-Assets und spielt sie bei Bedarf ab. Es verwendet eine geeignete Audio-Wiedergabe-Bibliothek (z.B. `rodio` für einfache Wiedergabe von WAV/OGG).

**Kern-Aufgaben (Tasks):**

1.  **`PlaybackManager` Struct:**
    * `pub struct PlaybackManager {`
        * `audio_sink: rodio::Sink,` // Der Audio-Sink für die Wiedergabe
        * `sound_assets: RwLock<HashMap<SoundEvent, Vec<u8>>>,` // Cache für geladene Sound-Dateien
    * `}`

2.  **`PlaybackManager::new()` Funktion:**
    * `pub async fn new() -> Result<Self, SoundError>`
    * **Logik:**
        * Initialisiert eine `rodio::Sink` Instanz.
        * Lädt die Standard-Systemklang-Dateien (definiert in `data_types::SoundEvent::default_sound_file()`) in den `sound_assets` Cache. Dies kann asynchron erfolgen.
        * **Hinweis:** Sound-Dateien sollten aus einem definierten Systempfad geladen werden (z.B. `/usr/share/sounds/nova/`, `~/.local/share/sounds/nova/`).
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** Fehler beim Initialisieren des Audio-Sinks, Laden/Parsen von Sound-Dateien.

3.  **`PlaybackManager::play_sound()` Methode:**
    * `pub async fn play_sound(&self, sound_event: SoundEvent) -> Result<(), SoundError>`
    * **Logik:**
        * Überprüft, ob der Sound für `sound_event` im `sound_assets` Cache vorhanden ist.
        * Falls nicht vorhanden, versucht, die Sound-Datei dynamisch zu laden und in den Cache aufzunehmen.
        * Erstellt einen `rodio::Decoder` aus den geladenen Bytes.
        * Fügt den Decoder dem `audio_sink` hinzu, um den Sound abzuspielen.
        * Spieldauer und Lautstärke-Anpassungen (falls über API zugänglich).
        * **Fehlerbehandlung:** `SoundFileNotFound`, `SoundFileParseError`, `PlaybackError`.

4.  **`PlaybackManager::load_sound_file()` Methode:**
    * `async fn load_sound_file(file_path: &Path) -> Result<Vec<u8>, SoundError>`
    * **Logik:**
        * Liest die Datei `file_path` asynchron (`tokio::fs::read`).
        * **Fehlerbehandlung:** `SoundFileNotFound`, `SoundFileParseError` (falls Format nicht erkannt wird).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/sound_manager/playback.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::sound_manager::error::SoundError`
    * `crate::sound_manager::data_types::SoundEvent`
* **Extern:**
    * `rodio::{Sink, Decoder, Source}`
    * `tokio::fs`
    * `tracing`
    * `std::path::{Path, PathBuf}`
    * `std::collections::HashMap`
    * `tokio::sync::RwLock`

**Kommunikationsmuster:**

* Wird vom `SoundManager` verwendet, um spezifische Systemklänge abzuspielen.
* Kapselt die Details der Audio-Wiedergabe mit `rodio`.

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger Sound-Playback-Manager, der verschiedene Systemklänge asynchron und effizient abspielen kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken von `rodio::Sink` und `tokio::fs`.
    * Testen von `new`: Sicherstellen, dass der Sink initialisiert und Standard-Sounds geladen werden (oder der Ladeversuch korrekt fehlschlägt).
    * Testen von `play_sound`:
        * Erfolgreiche Wiedergabe von gecachten Sounds.
        * Erfolgreiches dynamisches Laden und Abspielen von Sounds.
        * Fehler bei fehlender Sound-Datei.
        * Fehler beim Parsen der Sound-Datei.
    * Testen von `load_sound_file` mit gültigen und ungültigen Pfaden/Dateien.
* **Integration Tests (mit realen Sound-Dateien und Audio-Ausgabe):**
    * Einrichten eines Test-Verzeichnisses mit einigen .ogg oder .wav Dateien.
    * Starten des `PlaybackManager` und Testen, ob die Sounds abgespielt werden können.
    * Überprüfen, ob Sounds auch dann abgespielt werden, wenn sie nicht vorab gecacht wurden.

**Geschätzter Aufwand:** Mittel-Hoch (ca. 4-7 Tage, da Audio-Playback, Caching und Dateisystem-Interaktionen)

---

### **novade-system/src/sound_manager/mixer.rs**

**Verantwortlichkeit:**
Das `Mixer` Modul ist für die Interaktion mit dem System-Audio-Server zuständig, um die globale Lautstärke zu steuern, Stummschaltstatus zu verwalten und Audio-Geräteinformationen abzurufen. Es wird die PipeWire-API oder die PulseAudio-API direkt über Rust-Bindings verwenden. Für diese Spezifikation wird PipeWire als primäre Wahl angenommen, da es moderner ist.

**Kern-Aufgaben (Tasks):**

1.  **`Mixer` Struct:**
    * `pub struct Mixer {`
        * `pipewire_client: Arc<PipewireClient>,` // Interner Client für PipeWire-Interaktionen
        * `active_volume: RwLock<u8>,`
        * `active_mute_status: RwLock<bool>,`
        * `event_bus: EventBus,`
        * `// Weitere interne Strukturen zur Speicherung von Geräten/Streams`
    * `}`

2.  **`Mixer::new()` Funktion:**
    * `pub async fn new(event_bus: EventBus) -> Result<Self, SoundError>`
    * **Logik:**
        * Initialisiert eine Verbindung zum PipeWire-Daemon (oder PulseAudio). Dies kann die Verwendung einer Bibliothek wie `pipewire` crate oder `libpulse-binding` erfordern.
        * Ruft den aktuellen Master-Lautstärke-Status und Stummschaltstatus ab.
        * Beginnt mit der Überwachung von PipeWire-Events (z.B. Lautstärkeänderungen, Geräte-Hinzufügungen/Entfernungen) und sendet entsprechende `SystemEvent`s an den `EventBus`.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `AudioServerConnectError`, `BackendInitError`.

3.  **Implementierung der Lautstärke- und Stummschalt-Steuerung:**
    * **`set_master_volume(&self, volume_percent: u8) -> Result<(), SoundError>`:**
        * **Logik:** Konvertiert den Prozentwert in einen PipeWire-Lautstärkebereich (z.B. 0.0-1.0) und sendet die Anweisung an den PipeWire-Server. Aktualisiert `active_volume` und sendet `SystemEvent::VolumeChanged`.
    * **`get_master_volume(&self) -> Result<u8, SoundError>`:**
        * **Logik:** Fragt den PipeWire-Server nach der aktuellen Master-Lautstärke ab und konvertiert sie zurück in Prozent.
    * **`set_mute_status(&self, muted: bool) -> Result<(), SoundError>`:**
        * **Logik:** Sendet die Stummschaltanweisung an den PipeWire-Server. Aktualisiert `active_mute_status` und sendet `SystemEvent::MuteStatusChanged`.
    * **`get_mute_status(&self) -> Result<bool, SoundError>`:**
        * **Logik:** Fragt den PipeWire-Server nach dem aktuellen Stumm-Status ab.

4.  **Implementierung der Geräte-Verwaltung:**
    * **`get_audio_devices(&self) -> Result<Vec<AudioDevice>, SoundError>`:**
        * **Logik:** Fragt den PipeWire-Server nach allen Audio-Ausgabe- und Eingabegeräten ab. Mappt die PipeWire-Geräteinformationen auf das `AudioDevice` Struct.
    * **`set_default_output_device(&self, device_id: &str) -> Result<(), SoundError>`:**
        * **Logik:** Sendet eine Anweisung an den PipeWire-Server, um das Standard-Ausgabegerät basierend auf der `device_id` zu ändern.

5.  **PipeWire/PulseAudio Event-Listener (Hintergrund-Task):**
    * Ein oder mehrere asynchrone Tasks, die auf Änderungen vom Audio-Server lauschen.
    * Bei Lautstärkeänderungen, Stummschaltänderungen, dem Hinzufügen/Entfernen von Geräten:
        * Aktualisiert den internen Zustand (`active_volume`, `active_mute_status`, Geräte-Liste).
        * Sendet entsprechende `SystemEvent`s (`SystemEvent::VolumeChanged`, `SystemEvent::MuteStatusChanged`, `SystemEvent::AudioDeviceAdded`, `SystemEvent::AudioDeviceRemoved`) über den `EventBus`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/sound_manager/mixer.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::sound_manager::error::SoundError`
    * `crate::sound_manager::data_types::AudioDevice`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern (Beispiel für PipeWire):**
    * `pipewire as pw` (oder `libspa` für tiefergehende Interaktion)
    * `tokio::task`
    * `tokio::sync::RwLock`
    * `tracing`
    * `std::sync::Arc`
    * `futures::StreamExt` (für Event-Listener)

**Kommunikationsmuster:**

* Wird vom `SoundManager` verwendet, um systemweite Audio-Einstellungen zu steuern.
* Kapselt die komplexe Interaktion mit dem System-Audio-Server.
* Benachrichtigt über den `EventBus` über Statusänderungen.

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger Audio-Mixer, der mit dem System-Audio-Server kommuniziert, um Lautstärke, Stummschaltung und Geräte zu verwalten und Änderungen zu überwachen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `pipewire` (oder PulseAudio) Clients.
    * Testen von `new`: Sicherstellen, dass die Verbindung initialisiert und der Status abgefragt wird.
    * Testen von `set_master_volume` und `set_mute_status`: Simulieren erfolgreiche und fehlerhafte Aufrufe an den Audio-Server und Überprüfen der internen Zustandsänderungen und Event-Sendungen.
    * Testen von `get_master_volume` und `get_mute_status`.
    * Testen von `get_audio_devices` und `set_default_output_device`: Simulieren von Geräte-Listen und deren Änderungen.
    * Simulieren von PipeWire-Events und Überprüfen, ob die korrekten `SystemEvent`s gesendet werden.
* **Integration Tests (mit laufendem PipeWire/PulseAudio-Daemon):**
    * Starten des `Mixer`s und Überprüfen der Initialisierung.
    * Ändern der Lautstärke/Mute-Status über die NovaDE-API und Überprüfen über ein externes Tool (`pactl` oder `pw-cli`).
    * Ändern der Lautstärke/Mute-Status über ein externes Tool und Überprüfen, ob NovaDE die Events empfängt und seinen internen Zustand aktualisiert.
    * Ein-/Ausstecken von Audio-Geräten und Überprüfen der Erkennung.

**Geschätzter Aufwand:** Sehr Hoch (ca. 10-15 Tage, da tiefe Interaktion mit System-Audio-API, Event-Handling und dynamisches Gerätemanagement)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `theme_manager`, widmen wir uns `sound_manager`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/sound_manager/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/sound_manager/data_types.rs`**: Definition der grundlegenden Datentypen für Audio.
3.  **`novade-system/src/sound_manager/playback.rs`**: Implementierung der Sound-Wiedergabe, die für Systemklänge essenziell ist. Relativ unabhängig vom komplexeren Mixer.
4.  **`novade-system/src/sound_manager/mixer.rs`**: Die komplexe Logik für die Interaktion mit dem Audio-Server.
5.  **`novade-system/src/sound_manager/mod.rs`**: Das Hauptmodul, das die anderen Komponenten initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/sound_manager` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/power_management` Verzeichnisses, um die Energieverwaltung des Systems zu steuern.
---
### **novade-system/src/power_management/mod.rs**

**Verantwortlichkeit:**
Das `power_management` Modul ist verantwortlich für die Überwachung des System-Energieverbrauchs, die Verwaltung von Energie-Einstellungen (z.B. Bildschirm ausschalten, Suspend, Hibernate) und die Reaktion auf kritische Batterieereignisse. Es integriert sich mit System-APIs wie `UPower` oder `systemd-logind`.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/power_management/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Energieverwaltungs-Operationen)
    * `monitor.rs` (Logik zur Überwachung von Batterie-/AC-Status und Kritischen Ereignissen)
    * `actions.rs` (Implementierung von Aktionen wie Suspend, Hibernate, Shutdown)
    * `data_types.rs` (Definition von Energie-bezogenen Datentypen)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Energieverwaltungs-Subsystems:**
    * `pub async fn initialize_power_manager(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<PowerManager, PowerError>`
    * **Logik:**
        * Erstellt eine Instanz von `monitor::PowerMonitor` und `actions::PowerActions`.
        * Der `PowerMonitor` stellt die Verbindung zur zugrunde liegenden System-API (z.B. D-Bus für `UPower` oder `systemd-logind`) her und beginnt mit der Überwachung des Energie-Status.
        * Ruft die initialen Energie-Einstellungen aus dem `config_service` ab (z.B. `screen_blank_delay_minutes`, `suspend_after_minutes`, `lid_close_action`, `critical_battery_action`).
        * Beginnt mit der Überwachung von Konfigurationsänderungen bezüglich der Energieeinstellungen über den `event_bus` (`SystemEvent::ConfigChanged`).
        * Startet einen Hintergrund-Task, der auf Energie-Events vom `PowerMonitor` und `ConfigService`-Änderungen reagiert.
        * Gibt ein gebündeltes `PowerManager` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Monitors oder der Verbindung zu System-APIs.

2.  **`PowerManager` Struct:**
    * `pub struct PowerManager {`
        * `monitor: Arc<PowerMonitor>,`
        * `actions: Arc<PowerActions>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `// Interne Zustandsvariablen für Timer (z.B. für Bildschirm ausschalten, Suspend)`
        * `// Mutex/RwLock für den Zugriff auf diese Zustandsvariablen`
    * `}`
    * Dient als Container und Zugangspunkt für die Energieverwaltungs-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `PowerManager` exponiert Methoden zum Abrufen des Energie-Status und zum Auslösen von Energie-Aktionen.
    * **`get_battery_status(&self) -> Result<BatteryStatus, PowerError>`:**
        * **Logik:** Delegiert an den `PowerMonitor` und gibt den aktuellen Batteriestatus zurück.
    * **`request_suspend(&self) -> Result<(), PowerError>`:**
        * **Logik:** Delegiert an `PowerActions` zum Initiieren des Suspend-Modus.
    * **`request_hibernate(&self) -> Result<(), PowerError>`:**
        * **Logik:** Delegiert an `PowerActions` zum Initiieren des Hibernate-Modus.
    * **`request_shutdown(&self) -> Result<(), PowerError>`:**
        * **Logik:** Delegiert an `PowerActions` zum Initiieren des Herunterfahrens.
    * **`request_reboot(&self) -> Result<(), PowerError>`:**
        * **Logik:** Delegiert an `PowerActions` zum Initiieren des Neustarts.
    * **`prevent_sleep(&self, reason: &str) -> Result<SleepInhibitor, PowerError>`:**
        * **Logik:** Erstellt einen Sleep Inhibitor über `PowerActions`, um den Schlafmodus zu verhindern (z.B. während Videowiedergabe). Gibt ein Handle zurück, das beim Drop die Inhibierung freigibt.

4.  **Hintergrund-Task für Energie-Events und Konfigurationsänderungen:**
    * Der `PowerManager` startet einen langlebigen Task, der:
        * Auf Events vom `PowerMonitor` hört (z.B. Batterie-Ladezustand ändert sich, Netzteil angeschlossen/getrennt, kritischer Batteriestand, Deckel geschlossen).
        * Auf `SystemEvent::ConfigChanged` hört, um aktualisierte `PowerConfig`-Einstellungen zu laden.
        * Basierend auf den Konfigurationseinstellungen und Monitor-Events Aktionen auslöst:
            * **Bildschirm ausschalten:** Timer starten, wenn keine Benutzeraktivität und Netzteil nicht angeschlossen ist, basierend auf `screen_blank_delay_minutes`. Bei Ablauf Bildschirm ausschalten (`DisplayService::blank_screen`).
            * **Suspend nach Inaktivität:** Timer starten, wenn keine Benutzeraktivität und Netzteil nicht angeschlossen ist, basierend auf `suspend_after_minutes`. Bei Ablauf `request_suspend()`.
            * **Deckel zu:** Wenn Laptop-Deckel geschlossen (`LidCloseEvent`), Aktion gemäß `lid_close_action` in der Konfiguration ausführen (z.B. `request_suspend()`). Wenn `Ask`, `NotificationService` verwenden.
            * **Kritischer Batteriestand:** Wenn Batteriestand unter kritischem Wert (`CriticalBatteryEvent`), Aktion gemäß `critical_battery_action` (z.B. `request_power_off()`, `request_suspend()`, `NotificationService::show_warning`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_management::error::PowerError`
    * `crate::power_management::monitor::{PowerMonitor, BatteryStatus}`
    * `crate::power_management::actions::{PowerActions, SleepInhibitor}`
    * `crate::power_management::data_types::{LidCloseAction, CriticalBatteryAction}`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
    * `novade_system::display_service::DisplayService` (für Bildschirm ausschalten)
    * `novade_system::notification_service::NotificationService` (für Benachrichtigungen)
* **Extern:**
    * `tokio::task`
    * `tokio::time::{sleep, Duration}`
    * `tracing`
    * `std::sync::Arc`
    * `tokio::sync::Mutex` (für Timer-Steuerung)

**Kommunikationsmuster:**

* Wird von der Domänenschicht und der UI-Schicht verwendet, um Energie-Informationen abzurufen und Aktionen auszulösen.
* Interagiert mit dem `ConfigService` zum Laden und Speichern von Energie-Einstellungen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten über Energie-Statusänderungen zu informieren (z.B. `SystemEvent::BatteryStatusChanged`, `SystemEvent::PowerSourceChanged`).
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Energieverwaltungs-Subsystem, das den Energie-Status überwacht und das Systemverhalten entsprechend den Benutzereinstellungen und kritischen Ereignissen anpasst.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `PowerMonitor` und `PowerActions`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration.
    * Testen der Weiterleitung von API-Aufrufen an `PowerMonitor` und `PowerActions`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Timer und Aktionen korrekt aktualisiert werden.
    * Simulieren von `BatteryStatusChanged`, `LidCloseEvent`, `CriticalBatteryEvent` vom `PowerMonitor` und Überprüfen, ob die richtigen Aktionen (Suspend, Shutdown, Benachrichtigung) ausgelöst werden.
    * Testen der `prevent_sleep` Funktionalität.
* **Integration Tests (mit D-Bus Mocking oder realer Hardware):**
    * Starten des `PowerManager` in einer Testumgebung (ggf. mit `dbus-daemon --session` und Mocking von `UPower`).
    * Simulieren von Batterieänderungen und AC-Anschluss/Trennung und Beobachten des Systemverhaltens.
    * Testen der automatischen Suspend/Bildschirm-Ausschalt-Timer (ggf. mit beschleunigter Zeit).
    * Testen der Deckel-zu-Aktionen und kritischen Batterie-Aktionen.

**Geschätzter Aufwand:** Sehr Hoch (ca. 10-15 Tage, da komplexe Zustandsverwaltung, Timer-Logik, Integration mit ConfigService und Reaktion auf mehrere Event-Typen)

---

### **novade-system/src/power_management/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `power_management` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Energieverwaltungs-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`PowerError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum PowerError {`
        * `#[error("Failed to connect to system power daemon: {0}")]`
        * `DaemonConnectError(String),`
        * `#[error("Failed to query power status: {0}")]`
        * `StatusQueryError(String),`
        * `#[error("Failed to perform power action: {0}")]`
        * `ActionFailed(String),`
        * `#[error("Invalid power state: {0}")]`
        * `InvalidState(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("D-Bus error: {0}")]`
        * `DBusError(#[from] zbus::Error),` // Wenn `zbus` für D-Bus-Interaktion verwendet wird
        * `#[error("Unknown power management error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `zbus::Error` (oder die entsprechende D-Bus-Fehlerklasse) und `anyhow::Error`.

**Spezifische Artefekte/Dateien:**

* `novade-system/src/power_management/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `zbus::Error` (oder entsprechende D-Bus-Bibliothek)
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `power_management` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Energieverwaltungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/power_management/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `power_management` verwendet werden, um den Batterie- und Energie-Status sowie Konfigurationsoptionen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`BatteryStatus` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct BatteryStatus {`
        * `pub percentage: u8,` // Aktueller Ladezustand (0-100)
        * `pub is_charging: bool,` // Ist das Gerät gerade am Laden?
        * `pub on_ac_power: bool,` // Ist das Gerät an Netzstrom angeschlossen?
        * `pub time_remaining: Option<Duration>,` // Geschätzte Restzeit (laden oder entladen)
        * `pub health: Option<BatteryHealth>,` // Batteriezustand (z.B. "Gut", "Verschlissen")
    * `}`

2.  **`BatteryHealth` Enum:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub enum BatteryHealth { Good, Degraded, Critical }`

3.  **`LidCloseAction` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, Default, serde::Serialize, serde::Deserialize)]`
    * `pub enum LidCloseAction { Suspend, DoNothing, Ask, PowerOff }`
    * Wird in `config_service::data_types::PowerConfig` verwendet.

4.  **`CriticalBatteryAction` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, Default, serde::Serialize, serde::Deserialize)]`
    * `pub enum CriticalBatteryAction { PowerOff, Suspend, Warn }`
    * Wird in `config_service::data_types::PowerConfig` verwendet.

5.  **`PowerEventType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq)]`
    * `pub enum PowerEventType {`
        * `BatteryStatusChanged(BatteryStatus),`
        * `PowerSourceChanged(bool),` // true für AC, false für Batterie
        * `LidCloseEvent,`
        * `CriticalBatteryEvent,`
        * `ScreenBlankRequest,` // Anforderung zum Ausschalten des Bildschirms durch Inaktivität
        * `SuspendRequest,` // Anforderung zum Suspend durch Inaktivität
    * `}`
    * Diese Events werden vom `PowerMonitor` an den `PowerManager` gesendet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::time::Duration`

**Kommunikationsmuster:**

* Diese Typen werden intern vom `power_management` Modul verwendet.
* `BatteryStatus` wird von `get_battery_status` zurückgegeben.
* `LidCloseAction` und `CriticalBatteryAction` stammen aus dem `ConfigService`.
* `PowerEventType` wird zwischen `PowerMonitor` und `PowerManager` ausgetauscht.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Energieverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Niedrig (ca. 1-2 Tage, hauptsächlich Definitionen)

---

### **novade-system/src/power_management/monitor.rs**

**Verantwortlichkeit:**
Der `PowerMonitor` ist für die Kommunikation mit dem System-Energie-Management-Daemon (z.B. `UPower` über D-Bus, oder `systemd-logind` über D-Bus) zuständig. Er überwacht den Batteriestatus, den AC-Status, den Deckelstatus und sendet Events an den `PowerManager` bei Änderungen.

**Kern-Aufgaben (Tasks):**

1.  **`PowerMonitor` Struct:**
    * `pub struct PowerMonitor {`
        * `dbus_connection: zbus::Connection,` // D-Bus Verbindung
        * `event_sender: tokio::sync::mpsc::Sender<PowerEventType>,` // Sender für interne Events zum PowerManager
        * `// Interne Caches für den letzten bekannten Zustand, um nur bei Änderungen Events zu senden`
    * `}`

2.  **`PowerMonitor::new()` Funktion:**
    * `pub async fn new(event_sender: tokio::sync::mpsc::Sender<PowerEventType>) -> Result<Self, PowerError>`
    * **Logik:**
        * Stellt eine Verbindung zum System-D-Bus her (`zbus::Connection::system().await`).
        * Überprüft die Verfügbarkeit von `org.freedesktop.UPower` oder `org.freedesktop.login1` (systemd-logind).
        * Initialisiert die internen Caches für den Batteriestatus.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `DaemonConnectError`, `DBusError`.

3.  **`PowerMonitor::start_monitoring()` Methode:**
    * `pub async fn start_monitoring(self: Arc<Self>)`
    * **Logik:**
        * Startet asynchrone Tasks, die D-Bus-Signale von `UPower` (für Batterie/AC) und `systemd-logind` (für Deckel-Status, Suspend/Shutdown-Requests) abonnieren.
        * Bei Empfang relevanter Signale:
            * Aktualisiert den internen Cache.
            * Erstellt die entsprechende `PowerEventType` (z.B. `BatteryStatusChanged`, `LidCloseEvent`, `PowerSourceChanged`).
            * Sendet das Event über `event_sender` an den `PowerManager`.
        * Regelmäßiges Polling für Status-Updates, falls D-Bus-Signale nicht granular genug sind oder als Fallback.
        * **Beispiel für UPower-Signale:**
            * `org.freedesktop.UPower.DeviceAdded`
            * `org.freedesktop.UPower.DeviceRemoved`
            * `org.freedesktop.UPower.Device: PropertiesChanged` (für Ladezustand, AC-Status)
        * **Beispiel für systemd-logind-Signale:**
            * `org.freedesktop.login1.Manager: PrepareForSleep(bool)` (für Suspend-Vorbereitung)
            * `org.freedesktop.login1.Manager: LidSwitch(bool)`
            * `org.freedesktop.login1.Manager: UserActive(bool)`
        * **Fehlerbehandlung:** Loggt D-Bus-Fehler, versucht aber die Überwachung aufrechtzuerhalten.

4.  **`PowerMonitor::get_current_battery_status()` Methode:**
    * `pub async fn get_current_battery_status(&self) -> Result<BatteryStatus, PowerError>`
    * **Logik:**
        * Fragt `UPower` (oder `systemd-logind`) aktiv nach dem aktuellen Batteriestatus ab.
        * Mappt die UPower-Informationen auf das `BatteryStatus` Struct.
        * **Fehlerbehandlung:** `StatusQueryError`, `DBusError`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management/monitor.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_management::error::PowerError`
    * `crate::power_management::data_types::{BatteryStatus, PowerEventType}`
* **Extern:**
    * `zbus` (für D-Bus-Interaktion)
    * `tokio::task`
    * `tokio::sync::mpsc`
    * `tracing`
    * `std::sync::Arc`
    * `futures::StreamExt`

**Kommunikationsmuster:**

* Der `PowerMonitor` ist eine Quelle für Energie-bezogene Events, die er über einen MPSC-Kanal an den `PowerManager` sendet.
* Wird vom `PowerManager` aufgerufen, um den initialen Status abzufragen und die Überwachung zu starten.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Energie-Monitor, der System-Energie-Ereignisse und -Statusänderungen zuverlässig erkennt und weiterleitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit D-Bus Mocking):**
    * Mocken von `zbus::Connection` und den entsprechenden D-Bus-Proxies, um simulierte D-Bus-Antworten und Signale zu liefern.
    * Testen von `new`: Überprüfen der Verbindungsinitialisierung und Daemon-Verfügbarkeit.
    * Testen von `get_current_battery_status` mit verschiedenen simulierten UPower-Antworten.
    * Simulieren von D-Bus-Signalen (`PropertiesChanged`, `LidSwitch`) und Überprüfen, ob die korrekten `PowerEventType`s an den Sender gesendet werden.
* **Integration Tests (mit realem D-Bus und Hardware/virtueller Hardware):**
    * Starten des `PowerMonitor` auf einem System mit `UPower` und `systemd-logind`.
    * Manuelles Ändern des Batterie-/AC-Status (z.B. Netzteil ziehen) und des Deckelstatus (Laptop auf/zu) und Beobachten, ob die Events korrekt empfangen und weitergeleitet werden.
    * Überprüfen der Langlebigkeit des Monitoring-Tasks.

**Geschätzter Aufwand:** Sehr Hoch (ca. 10-15 Tage, da komplexe D-Bus-Interaktion, Signal-Parsing und Hintergrundüberwachung)

---

### **novade-system/src/power_management/actions.rs**

**Verantwortlichkeit:**
Das `PowerActions` Modul ist für die Ausführung von Energie-Aktionen wie Suspend, Hibernate, Reboot und Shutdown zuständig. Es verwendet die entsprechenden System-APIs, in der Regel D-Bus-Methoden von `systemd-logind` oder `UPower`. Es ermöglicht auch das Inhibieren des Schlafmodus.

**Kern-Aufgaben (Tasks):**

1.  **`PowerActions` Struct:**
    * `pub struct PowerActions {`
        * `dbus_connection: zbus::Connection,`
        * `// Optional: Vec<Arc<zbus::blocking::OwnedProxy>> für SleepInhibitors`
    * `}`

2.  **`PowerActions::new()` Funktion:**
    * `pub async fn new() -> Result<Self, PowerError>`
    * **Logik:**
        * Stellt eine Verbindung zum System-D-Bus her (`zbus::Connection::system().await`).
        * Überprüft die Verfügbarkeit der relevanten Schnittstellen (z.B. `org.freedesktop.login1.Manager`).
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `DaemonConnectError`, `DBusError`.

3.  **Implementierung der Energie-Aktionen:**
    * **`request_suspend(&self) -> Result<(), PowerError>`:**
        * **Logik:** Ruft die D-Bus-Methode `Suspend()` auf dem `org.freedesktop.login1.Manager` Interface auf.
        * **Fehlerbehandlung:** `ActionFailed`, `DBusError`.
    * **`request_hibernate(&self) -> Result<(), PowerError>`:**
        * **Logik:** Ruft die D-Bus-Methode `Hibernate()` auf dem `org.freedesktop.login1.Manager` Interface auf.
        * **Fehlerbehandlung:** `ActionFailed`, `DBusError`.
    * **`request_reboot(&self) -> Result<(), PowerError>`:**
        * **Logik:** Ruft die D-Bus-Methode `Reboot()` auf dem `org.freedesktop.login1.Manager` Interface auf. Optional kann ein `force` Parameter übergeben werden.
        * **Fehlerbehandlung:** `ActionFailed`, `DBusError`.
    * **`request_shutdown(&self) -> Result<(), PowerError>`:**
        * **Logik:** Ruft die D-Bus-Methode `PowerOff()` auf dem `org.freedesktop.login1.Manager` Interface auf. Optional kann ein `force` Parameter übergeben werden.
        * **Fehlerbehandlung:** `ActionFailed`, `DBusError`.

4.  **`SleepInhibitor` Struct und Implementierung:**
    * `pub struct SleepInhibitor {`
        * `_proxy: zbus::Proxy<'static>,` // Der Proxy zum D-Bus-Objekt des Inhibitors
    * `}`
    * **`PowerActions::prevent_sleep(&self, reason: &str) -> Result<SleepInhibitor, PowerError>`:**
        * **Logik:** Ruft die D-Bus-Methode `Inhibit()` auf dem `org.freedesktop.login1.Manager` Interface auf.
        * Parameter: `what` (z.B. "sleep"), `who` (z.B. "NovaDE"), `mode` ("delay" oder "block"), `reason` (der übergebene String).
        * Gibt ein `SleepInhibitor` Struct zurück, das einen Proxy zum D-Bus-Objekt des Inhibitors hält.
        * **Fehlerbehandlung:** `ActionFailed`, `DBusError`.
    * **`impl Drop for SleepInhibitor`:**
        * **Logik:** Beim Droppen des `SleepInhibitor`-Objekts wird die Inhibierung über den D-Bus freigegeben (implizit durch das Fallenlassen des D-Bus-Proxys, oder explizit durch eine `Uninhibit()`-Methode, falls verfügbar/notwendig).
        * **Fehlerbehandlung:** Fehler beim Freigeben sollten geloggt, aber nicht paniert werden.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management/actions.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_management::error::PowerError`
* **Extern:**
    * `zbus` (für D-Bus-Interaktion)
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Wird vom `PowerManager` verwendet, um systemweite Energie-Aktionen auszuführen.
* Kapselt die D-Bus-Interaktionen für Suspend, Hibernate, Reboot, Shutdown und Sleep Inhibitor.

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiges Modul zum Ausführen von Energie-Aktionen und zur Steuerung des Schlafmodus.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit D-Bus Mocking):**
    * Mocken von `zbus::Connection` und den `systemd-logind` Proxies.
    * Testen von `new`: Sicherstellen der Verbindungsinitialisierung.
    * Testen von `request_suspend`, `request_hibernate`, `request_reboot`, `request_shutdown`: Simulieren erfolgreiche und fehlerhafte D-Bus-Aufrufe.
    * Testen von `prevent_sleep`: Simulieren des `Inhibit` Aufrufs und des Droppens des `SleepInhibitor`, um das `Uninhibit` zu simulieren.
* **Integration Tests (mit realem D-Bus und systemd):**
    * Starten des `PowerActions` auf einem System mit `systemd-logind`.
    * Testen von `request_suspend` etc. (mit Vorsicht, da dies das System in den Schlaf schickt/herunterfährt).
    * Testen von `prevent_sleep` und Überprüfen, ob das System für die Dauer des `SleepInhibitor`s wach bleibt (ggf. durch `loginctl list-inhibitors`).

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da D-Bus-Interaktion und Management von Inhibit-Locks)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `sound_manager`, widmen wir uns `power_management`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/power_management/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/power_management/data_types.rs`**: Definition der grundlegenden Datentypen für Energieverwaltung.
3.  **`novade-system/src/power_management/actions.rs`**: Implementierung der Kern-Aktionen (Suspend, Shutdown etc.) und des Sleep Inhibitors. Diese können unabhängig getestet werden.
4.  **`novade-system/src/power_management/monitor.rs`**: Die Überwachungslogik, die auf Systemereignisse reagiert und Daten liefert.
5.  **`novade-system/src/power_management/mod.rs`**: Das Hauptmodul, das die anderen Komponenten initialisiert, die Konfiguration integriert und die globale Logik für das Energieverhalten steuert.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/power_management` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/input_service` Verzeichnisses, um die Eingabe von Tastatur und Maus zu verwalten.
---
### **novade-system/src/input_service/mod.rs**

**Verantwortlichkeit:**
Das `input_service` Modul ist die zentrale Schnittstelle für die Verwaltung und Verarbeitung von Benutzereingaben (Tastatur, Maus, Touchpad). Es abstrahiert die zugrunde liegende Eingabesubsysteme (z.B. `libinput`, `evdev` oder `winit` für Wayland/X11 Events) und übersetzt rohe Eingabeereignisse in hochrangige `InputEvent`s, die an andere System- und Domänenschicht-Komponenten weitergeleitet werden. Es ist auch für die Hotkey-Erkennung und -Weiterleitung verantwortlich.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/input_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Eingabe-Operationen)
    * `event_translator.rs` (Logik zum Übersetzen roher Events in `InputEvent`s)
    * `hotkey_manager.rs` (Verwaltung von Hotkeys und deren Aktionen)
    * `device_manager.rs` (Erkennung und Konfiguration von Eingabegeräten)
    * `data_types.rs` (Definition von Eingabe-bezogenen Datentypen)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Eingabe-Subsystems:**
    * `pub async fn initialize_input_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<InputService, InputError>`
    * **Logik:**
        * Erstellt eine Instanz von `device_manager::DeviceManager`.
        * Erstellt eine Instanz von `event_translator::EventTranslator`.
        * Erstellt eine Instanz von `hotkey_manager::HotkeyManager`, die die Hotkey-Definitionen aus dem `config_service` lädt.
        * Startet einen oder mehrere Hintergrund-Tasks, die rohe Eingabeereignisse vom System lesen (z.B. über `libinput` Kontexte oder `winit` Event-Loop) und diese über den `EventTranslator` verarbeiten.
        * Diese übersetzten `InputEvent`s werden dann an den `HotkeyManager` zur Hotkey-Erkennung und an den `EventBus` gesendet.
        * Beginnt mit der Überwachung von Konfigurationsänderungen bezüglich der Tastenkombinationen über den `event_bus` (`SystemEvent::ConfigChanged`).
        * Gibt ein gebündeltes `InputService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung von `libinput`, D-Bus-Verbindungen oder dem Laden der Hotkey-Konfiguration.

2.  **`InputService` Struct:**
    * `pub struct InputService {`
        * `device_manager: Arc<DeviceManager>,`
        * `hotkey_manager: Arc<HotkeyManager>,`
        * `event_bus: EventBus,`
        * `// Interner Kanal für rohe Eingabeereignisse, die vom Event-Loop gelesen werden`
    * `}`
    * Dient als Container und Zugangspunkt für die Eingabe-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `InputService` exponiert Methoden zur Abfrage von Eingabegeräten und zur dynamischen Aktualisierung von Hotkeys.
    * **`get_connected_devices(&self) -> Result<Vec<InputDevice>, InputError>`:**
        * **Logik:** Delegiert an den `DeviceManager` um eine Liste der erkannten Eingabegeräte zurückzugeben.
    * **`update_keyboard_layout(&self, layout: &str) -> Result<(), InputError>`:**
        * **Logik:** Delegiert an den `DeviceManager` oder eine entsprechende System-API (z.B. `XKB common`, `systemd-locale`) um das Tastaturlayout zu ändern.
    * **`register_hotkey_action(&self, shortcut: &str, action_id: &str) -> Result<(), InputError>`:**
        * **Logik:** Fügt dem `HotkeyManager` eine neue Hotkey-Definition hinzu oder aktualisiert eine bestehende. Speichert die Änderung im `config_service`.
    * **`unregister_hotkey_action(&self, shortcut: &str) -> Result<(), InputError>`:**
        * **Logik:** Entfernt eine Hotkey-Definition. Speichert die Änderung im `config_service`.
    * **`send_synthetic_event(&self, event: SyntheticInputEvent) -> Result<(), InputError>`:**
        * **Logik:** Ermöglicht das Senden von simulierten Eingabeereignissen (z.B. für Tests oder Automatisierung). Implementierung kann `evdev` oder `libinput` Emulation nutzen.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `InputService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn die `keyboard_shortcuts` in der Konfiguration geändert werden, löst der Task das Neuladen der Hotkey-Definitionen im `HotkeyManager` aus.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input_service::error::InputError`
    * `crate::input_service::event_translator::{EventTranslator, RawInputEvent}`
    * `crate::input_service::hotkey_manager::HotkeyManager`
    * `crate::input_service::device_manager::DeviceManager`
    * `crate::input_service::data_types::{InputEvent, InputDevice, SyntheticInputEvent}`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `tokio::sync::mpsc` (für Event-Kanäle)
    * `libinput` (Rust-Bindings für libinput, z.B. `libinput-rs`) oder `winit` (für Cross-Plattform-Eingabe)
    * `xkbcommon-rs` (für Tastaturlayouts, falls X11/Wayland spezifisch)

**Kommunikationsmuster:**

* Ist der primäre Consumer von rohen System-Eingabeereignissen.
* Übersetzt diese in hochrangige `InputEvent`s.
* Sendet `InputEvent`s (Mausbewegungen, Klicks, Tastendrücke) an den `EventBus`.
* Sendet spezifische `SystemEvent`s (z.B. `VolumeControlEvent`, `BrightnessControlEvent`, `ScreenshotEvent`) an den `EventBus`, wenn ein Hotkey erkannt wird.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Hotkey-Einstellungen.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Eingabe-Subsystem, das Benutzereingaben verarbeitet, Hotkeys erkennt und relevante Events an das System sendet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `DeviceManager`, `EventTranslator` und `HotkeyManager`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Hotkeys.
    * Testen der Weiterleitung von API-Aufrufen an die Sub-Komponenten.
    * Simulieren von `RawInputEvent`s über interne Kanäle und Überprüfen, ob `InputEvent`s an den `EventBus` gesendet werden.
    * Simulieren von `RawInputEvent`s, die Hotkeys auslösen, und Überprüfen, ob die korrekten `SystemEvent`s gesendet werden.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die Hotkeys neu geladen werden.
* **Integration Tests (mit `evdev` oder `libinput` Testumgebung):**
    * Starten des `InputService` in einer Testumgebung (ggf. mit `libinput debug-events` zur Verifizierung).
    * Simulieren von Tastatur- und Maus-Eingaben (manuell oder über `uinput`).
    * Überprüfen, ob die `InputEvent`s korrekt generiert und an den `EventBus` gesendet werden.
    * Testen der Hotkey-Funktionalität mit tatsächlichen Tastenkombinationen.
    * Testen des Wechsels von Tastaturlayouts.

**Geschätzter Aufwand:** Sehr Hoch (ca. 12-18 Tage, da komplexe Interaktion mit niedrigeren System-Eingabe-APIs, Event-Verarbeitung, Hotkey-Erkennung und Zustandsverwaltung)

---

### **novade-system/src/input_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `input_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Eingabe-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`InputError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum InputError {`
        * `#[error("Failed to initialize input backend: {0}")]`
        * `BackendInitError(String),` // Z.B. libinput Kontext konnte nicht erstellt werden
        * `#[error("Failed to read input event: {0}")]`
        * `EventReadError(#[from] std::io::Error),`
        * `#[error("Input device not found: {0}")]`
        * `DeviceNotFound(String),`
        * `#[error("Invalid hotkey definition: {0}")]`
        * `InvalidHotkey(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("D-Bus error: {0}")]`
        * `DBusError(String),` // Wenn D-Bus für XKB oder andere Konfig verwendet wird
        * `#[error("Unknown input error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `std::io::Error`, `crate::config_service::error::ConfigError` und `anyhow::Error`.
    * Füge spezifische Fehler von `libinput-rs` oder `xkbcommon-rs` hinzu, falls diese nicht generisch genug sind.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::io::Error`
    * Spezifische Fehler-Typen von `libinput-rs` oder `xkbcommon-rs`.
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `input_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Eingabesystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/input_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `input_service` verwendet werden, um verschiedene Arten von Eingabeereignissen, Geräten und Hotkey-Definitionen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`InputEvent` Enum:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub enum InputEvent {`
        * `Keyboard(KeyboardEvent),`
        * `Pointer(PointerEvent),`
        * `Tablet(TabletEvent),` // Falls Tablet-Unterstützung geplant ist
        * `Touch(TouchEvent),` // Für Touchscreens
        * `Gesture(GestureEvent),` // Multi-Touch Gesten
    * `}`

2.  **`KeyboardEvent` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct KeyboardEvent {`
        * `pub key: KeyCode,` // KeyCode Enum (z.B. A, Enter, F1, LeftShift)
        * `pub state: ButtonState,` // Pressed, Released
        * `pub modifiers: ModifiersState,` // Aktive Modifier (Shift, Ctrl, Alt, Super)
        * `pub timestamp: u64,`
        * `pub raw_keycode: u32,` // Raw-Scan-Code
    * `}`

3.  **`PointerEvent` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct PointerEvent {`
        * `pub event_type: PointerEventType,`
        * `pub x: f64,` // X-Koordinate
        * `pub y: f64,` // Y-Koordinate
        * `pub delta_x: f64,` // Relative Bewegung in X
        * `pub delta_y: f64,` // Relative Bewegung in Y
        * `pub button: Option<MouseButton>,` // Welche Maustaste gedrückt/losgelassen
        * `pub scroll_delta_x: f64,` // Horizontaler Scroll-Delta
        * `pub scroll_delta_y: f64,` // Vertikaler Scroll-Delta
        * `pub modifiers: ModifiersState,`
        * `pub timestamp: u64,`
    * `}`

4.  **`PointerEventType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub enum PointerEventType { Motion, ButtonPress, ButtonRelease, AxisScroll }`

5.  **`MouseButton` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum MouseButton { Left, Right, Middle, Back, Forward, Other(u32) }`

6.  **`ButtonState` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum ButtonState { Pressed, Released }`

7.  **`KeyCode` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]`
    * `pub enum KeyCode {`
        * `KeyA, KeyB, ..., KeyZ,`
        * `Digit0, ..., Digit9,`
        * `F1, ..., F12,`
        * `Enter, Space, Tab, Backspace, Escape,`
        * `LeftShift, RightShift, LeftControl, RightControl, LeftAlt, RightAlt, LeftSuper, RightSuper,`
        * `ArrowUp, ArrowDown, ArrowLeft, ArrowRight,`
        * `CapsLock, NumLock, ScrollLock,`
        * `// ... weitere spezifische Tasten, inkl. Multimedia-Tasten`
        * `Unknown(u32),` // Für unbekannte Keycodes
    * `}`

8.  **`ModifiersState` Struct (Bitflags):**
    * `#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, serde::Serialize, serde::Deserialize)]`
    * `pub struct ModifiersState {`
        * `pub shift: bool,`
        * `pub control: bool,`
        * `pub alt: bool,`
        * `pub super_key: bool,`
        * `// ... weitere (z.B. CapsLock, NumLock)`
    * `}`
    * Implementiere Methoden wie `contains()`, `is_empty()`.

9.  **`InputDevice` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct InputDevice {`
        * `pub id: String,`
        * `pub name: String,`
        * `pub device_type: DeviceType,` // Keyboard, Mouse, Touchpad, Tablet
        * `pub enabled: bool,`
        * `pub path: PathBuf,` // E.g., /dev/input/eventX
        * `pub properties: HashMap<String, String>,` // Z.B. "DPI", "acceleration_profile"
    * `}`

10. **`DeviceType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum DeviceType { Keyboard, Mouse, Touchpad, Tablet, Touchscreen, Other }`

11. **`Hotkey` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]`
    * `pub struct Hotkey {`
        * `pub shortcut: String,` // String-Repräsentation, z.B. "Ctrl+Shift+A", "Super+Space"
        * `pub action_id: String,` // Interner Bezeichner für die auszuführende Aktion
    * `}`

12. **`SyntheticInputEvent` Enum (für `send_synthetic_event`):**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub enum SyntheticInputEvent {`
        * `KeyboardPress(KeyCode, ModifiersState),`
        * `KeyboardRelease(KeyCode, ModifiersState),`
        * `MouseMove(f64, f64),`
        * `MouseClick(MouseButton),`
        * `// ... weitere für Tests/Automatisierung`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::collections::HashMap`
    * `std::path::PathBuf`

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Eingabeereignissen im gesamten System.
* Sie werden vom `EventTranslator` erzeugt, vom `HotkeyManager` verarbeitet und an den `EventBus` gesendet.
* `Hotkey` wird im `ConfigService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Set von Datentypen für die Eingabebehandlung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.
    * Testen der `ModifiersState` Methoden (z.B. `contains`).
    * Testen der Konvertierung von Rohdaten (z.B. `libinput` Tasten-Codes) in `KeyCode` und umgekehrt (dieser Teil könnte eher im `EventTranslator` getestet werden, aber die Mappings selbst sind hier relevant).

**Geschätzter Aufwand:** Hoch (ca. 5-8 Tage, da viele Enums/Structs und Mappings definiert werden müssen)

---

### **novade-system/src/input_service/event_translator.rs**

**Verantwortlichkeit:**
Der `EventTranslator` ist für die Umwandlung von rohen, plattformspezifischen Eingabeereignissen (z.B. von `libinput` oder `winit`) in die generischen `InputEvent`s von NovaDE verantwortlich. Er normalisiert die verschiedenen Eingabequellen.

**Kern-Aufgaben (Tasks):**

1.  **`EventTranslator` Struct:**
    * `pub struct EventTranslator {`
        * `current_modifiers: AtomicU64,` // Aktueller Zustand der Modifikatortasten (Shift, Ctrl, Alt, Super)
        * `// Mappings von rohen Keycodes zu NovaDE::KeyCode`
    * `}`

2.  **`EventTranslator::new()` Funktion:**
    * `pub fn new() -> Self`
    * **Logik:** Initialisiert die internen Mappings und den Modifikatorzustand.

3.  **`EventTranslator::translate_libinput_event()` Methode:**
    * `pub fn translate_libinput_event(&self, event: &libinput::Event) -> Option<InputEvent>`
    * **Logik:**
        * Nimmt ein `libinput::Event` entgegen.
        * Matcht den Event-Typ (KeyboardEvent, PointerEvent, TouchEvent, GestureEvent, DeviceEvent).
        * Für KeyboardEvents: Extrahiert `KeyCode`, `ButtonState` und `ModifiersState`. Aktualisiert `current_modifiers`.
        * Für PointerEvents: Extrahiert X/Y-Koordinaten, Delta, Button, Scroll-Delta.
        * Erstellt und gibt ein `InputEvent` zurück.
        * Filtert irrelevante Events oder ignoriert Events, die nicht übersetzt werden können.
        * **Hinweis:** Die Abbildung von `libinput` Keycodes auf `KeyCode` erfordert eine umfangreiche `match` Anweisung oder eine `HashMap`.
        * **Fehlerbehandlung:** Wenn ein Event nicht übersetzt werden kann, `None` zurückgeben oder einen Fehler loggen.

4.  **`EventTranslator::translate_winit_event()` Methode (alternativ/zusätzlich für GUI-Anwendungen):**
    * `pub fn translate_winit_event(&self, event: &winit::event::Event) -> Option<InputEvent>`
    * **Logik:** Ähnlich wie `translate_libinput_event`, aber für `winit`-Events. Dies ist relevant, wenn NovaDE selbst eine `winit`-basierte Oberfläche hat.

5.  **`EventTranslator::update_modifiers()` Methode:**
    * `fn update_modifiers(&self, key: KeyCode, state: ButtonState)`
    * **Logik:** Aktualisiert den `current_modifiers` Atomic basierend auf gedrückten/losgelassenen Modifier-Tasten (Shift, Ctrl, Alt, Super).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/event_translator.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input_service::data_types::{InputEvent, KeyboardEvent, PointerEvent, ButtonState, KeyCode, ModifiersState, MouseButton, PointerEventType}`
* **Extern:**
    * `libinput` (oder `winit`)
    * `std::sync::atomic::{AtomicU64, Ordering}`
    * `tracing`
    * `std::collections::HashMap` (für Mappings)

**Kommunikationsmuster:**

* Empfängt rohe Events von `DeviceManager` oder dem Event-Loop.
* Sendet übersetzte `InputEvent`s an den `HotkeyManager` und den `EventBus`.

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger Event-Übersetzer, der plattformspezifische Eingabeereignisse in konsistente NovaDE-InputEvent-Typen umwandelt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen von `translate_libinput_event` (oder `winit_event`) mit verschiedenen simulierten rohen Events (Tastendrücke, Mausklicks, Bewegungen, Scrolls, Modifier-Kombinationen).
    * Überprüfen, ob die korrekten `InputEvent` Typen und Datenfelder generiert werden.
    * Testen der `update_modifiers` Logik, um sicherzustellen, dass der Modifikator-Zustand korrekt verfolgt wird.
    * Testen von Edge-Cases wie unbekannten Keycodes.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da komplexe Mapping-Logik und Zustand der Modifikatortasten)

---

### **novade-system/src/input_service/hotkey_manager.rs**

**Verantwortlichkeit:**
Der `HotkeyManager` ist dafür verantwortlich, definierte Tastenkombinationen (Hotkeys) zu erkennen und die entsprechenden Systemaktionen auszulösen, indem er `SystemEvent`s über den `EventBus` sendet. Er lädt Hotkey-Definitionen aus der Konfiguration.

**Kern-Aufgaben (Tasks):**

1.  **`HotkeyManager` Struct:**
    * `pub struct HotkeyManager {`
        * `hotkeys: RwLock<HashMap<String, String>>,` // Map: "Ctrl+Shift+A" -> "screenshot"
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `active_modifiers: AtomicU64,` // Der aktuell gedrückte Modifikatorzustand
        * `// Interner Zustand für Hotkey-Erkennung (z.B. gedrückte Tasten für Kombinationen)`
    * `}`

2.  **`HotkeyManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<Self, InputError>`
    * **Logik:**
        * Lädt die `keyboard_shortcuts` aus dem `config_service` und füllt die `hotkeys` HashMap.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `ConfigServiceError`.

3.  **`HotkeyManager::handle_input_event()` Methode:**
    * `pub async fn handle_input_event(&self, event: InputEvent) -> Result<bool, InputError>`
    * **Logik:**
        * Nimmt ein `InputEvent` (von `EventTranslator`) entgegen.
        * Wenn es sich um ein `KeyboardEvent` handelt:
            * Aktualisiert den internen `active_modifiers` Zustand basierend auf dem `KeyboardEvent`.
            * Überprüft, ob die gedrückte Taste in Kombination mit den aktiven Modifikatoren einem definierten Hotkey in der `hotkeys` Map entspricht.
            * Implementiert eine Logik zur Normalisierung der Tastenkombination (z.B. "Control+Shift+A" ist dasselbe wie "Ctrl+Shift+a").
            * Wenn ein Hotkey erkannt wird:
                * Mappt die `action_id` auf einen spezifischen `SystemEvent` (z.B. "terminal_shortcut" -> `SystemEvent::LaunchTerminal`).
                * Sendet diesen `SystemEvent` an den `EventBus`.
                * Gibt `true` zurück, um anzuzeigen, dass das Event von einem Hotkey konsumiert wurde (optional, kann je nach Systemdesign variieren).
            * **Hinweis:** Dies erfordert eine sorgfältige Parsing- und Vergleichslogik für Hotkey-Strings.
        * Wenn es sich um ein anderes `InputEvent` handelt, gibt es `false` zurück.
        * **Fehlerbehandlung:** Internes Loggen von Fehlern bei Hotkey-Parsing oder unerwarteten Aktionen.

4.  **`HotkeyManager::update_hotkeys_from_config()` Methode:**
    * `pub async fn update_hotkeys_from_config(&self) -> Result<(), InputError>`
    * **Logik:**
        * Liest die neuesten `keyboard_shortcuts` aus dem `config_service`.
        * Aktualisiert die interne `hotkeys` HashMap.
        * Wird vom `InputService` aufgerufen, wenn `SystemEvent::ConfigChanged` empfangen wird.

5.  **`HotkeyManager::add_or_update_hotkey()` Methode:**
    * `pub async fn add_or_update_hotkey(&self, shortcut: String, action_id: String) -> Result<(), InputError>`
    * **Logik:**
        * Fügt den Hotkey zur internen `hotkeys` HashMap hinzu oder aktualisiert ihn.
        * Ruft `config_service.update_config()` auf, um die Änderung zu speichern.
        * **Fehlerbehandlung:** `InvalidHotkey` wenn der Shortcut-String nicht parsbar ist.

6.  **`HotkeyManager::remove_hotkey()` Methode:**
    * `pub async fn remove_hotkey(&self, shortcut: &str) -> Result<(), InputError>`
    * **Logik:**
        * Entfernt den Hotkey aus der internen `hotkeys` HashMap.
        * Ruft `config_service.update_config()` auf, um die Änderung zu speichern.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/hotkey_manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input_service::error::InputError`
    * `crate::input_service::data_types::{InputEvent, KeyboardEvent, KeyCode, ModifiersState, Hotkey}`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::sync::RwLock`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `std::sync::atomic::{AtomicU64, Ordering}`
    * `tracing`

**Kommunikationsmuster:**

* Empfängt `InputEvent`s (hauptsächlich `KeyboardEvent`s) von `EventTranslator`.
* Sendet `SystemEvent`s an den `EventBus`, wenn ein Hotkey ausgelöst wird.
* Interagiert mit dem `ConfigService` zum Laden und Speichern von Hotkey-Definitionen.

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger Hotkey-Manager, der Tastenkombinationen erkennt und vordefinierte Systemaktionen auslöst.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService` und `EventBus`.
    * Testen von `new`: Sicherstellen, dass Hotkeys korrekt aus der Konfiguration geladen werden.
    * Testen von `handle_input_event`:
        * Erkennung einfacher Hotkeys (z.B. "F1").
        * Erkennung von Hotkeys mit Modifikatoren (z.B. "Ctrl+A", "Super+Space").
        * Hotkeys, die nicht übereinstimmen.
        * Korrekte Sendung von `SystemEvent`s an den `EventBus`.
        * Umgang mit Groß-/Kleinschreibung bei Hotkeys.
        * Testen der internen Modifikator-Zustandsverfolgung.
    * Testen von `add_or_update_hotkey` und `remove_hotkey`: Überprüfen der internen `hotkeys` Map und der Interaktion mit `ConfigService`.
    * Testen von `update_hotkeys_from_config`.

**Geschätzter Aufwand:** Sehr Hoch (ca. 8-12 Tage, da Parsing von Hotkey-Strings, komplexe Abgleichslogik, Zustandsverwaltung und Interaktion mit zwei anderen System-Modulen)

---

### **novade-system/src/input_service/device_manager.rs**

**Verantwortlichkeit:**
Der `DeviceManager` ist für die Erkennung, Auflistung und grundlegende Konfiguration von Eingabegeräten (Tastaturen, Mäuse, Touchpads) zuständig. Er interagiert mit dem zugrunde liegenden Eingabesubsystem (z.B. `libinput`) um Informationen über angeschlossene Geräte zu erhalten und diese ggf. zu konfigurieren.

**Kern-Aufgaben (Tasks):**

1.  **`DeviceManager` Struct:**
    * `pub struct DeviceManager {`
        * `libinput_context: libinput::Context,` // Der libinput Kontext
        * `devices: RwLock<HashMap<String, InputDevice>>,` // Aktuell erkannte Geräte
        * `event_bus: EventBus,`
    * `}`

2.  **`DeviceManager::new()` Funktion:**
    * `pub async fn new(event_bus: EventBus) -> Result<Self, InputError>`
    * **Logik:**
        * Erstellt einen neuen `libinput::Context`. Dies kann die D-Bus-Schnittstelle von `systemd-logind` für den direkten Zugriff auf Eingabegeräte erfordern (wenn `libinput` ohne X-Server verwendet wird).
        * Scannt initial alle vorhandenen Eingabegeräte und füllt die `devices` HashMap.
        * Startet einen Hintergrund-Task zum Monitoring von `libinput` Geräte-Events.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `BackendInitError` bei Problemen mit dem libinput Kontext oder D-Bus-Verbindung.

3.  **`DeviceManager::start_device_monitoring()` Methode:**
    * `pub async fn start_device_monitoring(self: Arc<Self>)`
    * **Logik:**
        * Erstellt einen Event-Loop über den `libinput_context`.
        * Lauscht auf `libinput::Event::DeviceAdded` und `libinput::Event::DeviceRemoved` Events.
        * Bei `DeviceAdded`: Erstellt ein `InputDevice` Struct aus den `libinput` Geräteinformationen, fügt es zur `devices` HashMap hinzu und sendet `SystemEvent::InputDeviceAdded` an den `EventBus`.
        * Bei `DeviceRemoved`: Entfernt das Gerät aus der `devices` HashMap und sendet `SystemEvent::InputDeviceRemoved` an den `EventBus`.
        * Loggt Fehler oder unbekannte Event-Typen.
        * Leitet alle anderen relevanten `libinput` Events (z.B. Tastendrücke, Mausbewegungen) an den `EventTranslator` weiter (über einen Kanal, der im `InputService` gehalten wird).

4.  **`DeviceManager::get_connected_devices()` Methode:**
    * `pub fn get_connected_devices(&self) -> Vec<InputDevice>`
    * **Logik:** Gibt eine geklonte Liste der aktuell erkannten `InputDevice`s zurück.

5.  **`DeviceManager::configure_device()` Methode:**
    * `pub async fn configure_device(&self, device_id: &str, settings: HashMap<String, String>) -> Result<(), InputError>`
    * **Logik:**
        * Findet das Gerät mit `device_id` in der internen Liste.
        * Verwendet die `libinput`-API, um spezifische Einstellungen auf dem Gerät anzuwenden (z.B. Touchpad-Empfindlichkeit, Tap-to-Click, Maus-Beschleunigung).
        * **Hinweis:** Dies erfordert detaillierte Kenntnisse der `libinput`-Konfigurations-APIs.
        * **Fehlerbehandlung:** `DeviceNotFound`, `ActionFailed` bei Konfigurationsfehlern.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/device_manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input_service::error::InputError`
    * `crate::input_service::data_types::{InputDevice, DeviceType}`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `libinput` (Rust-Bindings für libinput)
    * `tokio::task`
    * `tokio::sync::RwLock`
    * `tokio::sync::mpsc` (für Kommunikation mit EventTranslator)
    * `tracing`
    * `std::sync::Arc`
    * `std::collections::HashMap`

**Kommunikationsmuster:**

* Erkennt neue/entfernte Eingabegeräte und sendet `SystemEvent`s an den `EventBus`.
* Leitet rohe `libinput` Events zur weiteren Verarbeitung an den `EventTranslator` weiter.
* Stellt eine API zur Verfügung, um Informationen über Geräte abzurufen und sie zu konfigurieren.

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger Gerätemanager, der Eingabegeräte erkennt und grundlegend konfiguriert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit `libinput` Mocking):**
    * Mocken des `libinput::Context` und seiner Event-Emission.
    * Testen von `new`: Sicherstellen der Initialisierung des Kontextes und des Scannens von Geräten.
    * Simulieren von `DeviceAdded` und `DeviceRemoved` Events und Überprüfen, ob die interne `devices` HashMap aktualisiert und die korrekten `SystemEvent`s gesendet werden.
    * Testen von `get_connected_devices`.
    * Simulieren von `libinput` Events für Tastendrücke/Mausbewegungen und Überprüfen, ob sie korrekt an den internen Kanal weitergeleitet werden.
    * Mocken von `libinput` Geräte-Konfigurationsmethoden für `configure_device`.
* **Integration Tests (mit realen Geräten oder `uinput`):**
    * Starten des `DeviceManager` auf einem System mit `libinput` installiert.
    * Ein-/Ausstecken von USB-Tastaturen/Mäusen und Überprüfen, ob sie erkannt werden und Events generiert werden.
    * Verwenden von `uinput` (falls möglich) um virtuelle Geräte zu erstellen und deren Erkennung zu testen.
    * Testen von `configure_device` mit tatsächlichen Konfigurationsänderungen auf einem echten Gerät (z.B. Maus-DPI ändern).

**Geschätzter Aufwand:** Sehr Hoch (ca. 10-15 Tage, da tiefe Integration mit `libinput`, D-Bus, Event-Looping und Gerät-Zustandsverwaltung)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `power_management`, widmen wir uns `input_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/input_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/input_service/data_types.rs`**: Definition der grundlegenden Datentypen für Eingabeereignisse und Geräte. Dies ist umfangreich und sollte frühzeitig fertiggestellt werden.
3.  **`novade-system/src/input_service/device_manager.rs`**: Zuständig für die Erkennung der Geräte und das Lesen der rohen Events vom System. Sendet diese Events an den `EventTranslator`.
4.  **`novade-system/src/input_service/event_translator.rs`**: Nimmt die rohen Events vom `DeviceManager` und wandelt sie in die generischen `InputEvent`s um.
5.  **`novade-system/src/input_service/hotkey_manager.rs`**: Nutzt die generischen `InputEvent`s vom `EventTranslator`, um Hotkeys zu erkennen und Systemaktionen auszulösen.
6.  **`novade-system/src/input_service/mod.rs`**: Das Hauptmodul, das alle anderen Komponenten initialisiert, die Konfiguration integriert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/input_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/notification_service` Verzeichnisses, um Desktop-Benachrichtigungen zu verwalten.
---
### **novade-system/src/notification_service/mod.rs**

**Verantwortlichkeit:**
Das `notification_service` Modul ist für die Verwaltung und Anzeige von Desktop-Benachrichtigungen zuständig. Es implementiert den FreeDesktop.org Desktop Notifications Specification (D-Bus `org.freedesktop.Notifications` Service) und bietet eine API für interne NovaDE-Komponenten sowie externe Anwendungen, um Benachrichtigungen zu senden.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/notification_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung des D-Bus-Service)
    * `error.rs` (Fehlerbehandlung für Benachrichtigungs-Operationen)
    * `manager.rs` (Interne Logik zur Verwaltung und Anzeige von Benachrichtigungen)
    * `data_types.rs` (Definition von Benachrichtigungs-bezogenen Datentypen)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Benachrichtigungs-Subsystems:**
    * `pub async fn initialize_notification_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<NotificationService, NotificationError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::NotificationManager`, die für die eigentliche Anzeige der Benachrichtigungen auf der UI zuständig ist.
        * Registriert den D-Bus-Service `org.freedesktop.Notifications` und seine Methoden (`Notify`, `GetCapabilities`, `CloseNotification`, `GetServerInformation`) auf dem Session-Bus.
        * Verbindet die D-Bus-Methoden mit der Logik im `NotificationManager`.
        * Ruft die initialen Benachrichtigungseinstellungen aus dem `config_service` ab (z.B. `do_not_disturb_mode`, `display_timeout_seconds`, `notification_position`).
        * Beginnt mit der Überwachung von Konfigurationsänderungen bezüglich der Benachrichtigungen über den `event_bus` (`SystemEvent::ConfigChanged`).
        * Gibt ein gebündeltes `NotificationService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Registrierung des D-Bus-Services oder der Initialisierung des `NotificationManager`s.

2.  **`NotificationService` Struct:**
    * `pub struct NotificationService {`
        * `manager: Arc<NotificationManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `dbus_connection: Arc<zbus::Connection>,` // Die D-Bus-Verbindung
    * `}`
    * Dient als Container und Zugangspunkt für die Benachrichtigungs-Logik und den D-Bus-Service.

3.  **Implementierung des D-Bus `org.freedesktop.Notifications` Interfaces:**
    * Die `NotificationService` selbst oder ein delegiertes Objekt implementiert die erforderlichen D-Bus-Methoden:
    * `fn Notify(...) -> u32` (die Benachrichtigungs-ID)
    * `fn GetCapabilities() -> Vec<String>`
    * `fn CloseNotification(id: u32)`
    * `fn GetServerInformation() -> (String, String, String, String)`
    * **Logik für `Notify`:**
        * Empfängt die Parameter gemäß Spezifikation (app_name, replaces_id, app_icon, summary, body, actions, hints, expire_timeout).
        * Validiert die Eingaben.
        * Erstellt ein internes `Notification` Struct aus den D-Bus-Parametern.
        * Leitet die `Notification` an den `NotificationManager` zur Anzeige weiter.
        * Gibt eine eindeutige Benachrichtigungs-ID zurück.
        * Behandelt `replaces_id` für Updates bestehender Benachrichtigungen.
    * **Logik für `CloseNotification`:**
        * Leitet die Anforderung an den `NotificationManager` weiter, um eine Benachrichtigung mit der gegebenen ID zu schließen.
    * **Logik für `GetCapabilities`:**
        * Gibt die unterstützten Fähigkeiten zurück (z.B. `body`, `actions`, `persistence`, `x-scheme`).
    * **Logik für `GetServerInformation`:**
        * Gibt Informationen über den Benachrichtigungs-Server zurück (z.B. "NovaDE Notification Service", "NovaDE", "1.0", "1.2").

4.  **Bereitstellung von internen API-Methoden:**
    * Methoden, die von anderen NovaDE-Komponenten direkt aufgerufen werden können, ohne den D-Bus zu verwenden.
    * **`show_notification(&self, notification: Notification) -> Result<u32, NotificationError>`:**
        * **Logik:** Eine interne Methode, die direkt den `NotificationManager` aufruft, um eine Benachrichtigung anzuzeigen.
    * **`close_notification(&self, id: u32) -> Result<(), NotificationError>`:**
        * **Logik:** Interne Methode zum Schließen einer Benachrichtigung.

5.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `NotificationService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Benachrichtigungseinstellungen (z.B. `do_not_disturb_mode`, `notification_position`) geändert werden, informiert der Task den `NotificationManager`, damit dieser sein Verhalten anpassen kann.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::notification_service::error::NotificationError`
    * `crate::notification_service::manager::NotificationManager`
    * `crate::notification_service::data_types::Notification`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus` (für D-Bus-Interaktion und Service-Registrierung)
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `std::collections::HashMap` (für die D-Bus `hints` und `actions`)

**Kommunikationsmuster:**

* Stellt einen D-Bus-Service für externe Anwendungen bereit.
* Stellt eine interne API für NovaDE-Komponenten bereit.
* Interagiert mit dem `ConfigService` zum Laden und Speichern von Benachrichtigungseinstellungen.
* Sendet `SystemEvent::NotificationDisplayed`, `SystemEvent::NotificationClosed` (durch Benutzer oder Timeout) und `SystemEvent::NotificationActionInvoked` (bei Klick auf Button in Benachrichtigung) über den `EventBus`.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Benachrichtigungs-Subsystem, das dem FreeDesktop.org Standard entspricht, Benachrichtigungen empfangen, anzeigen und verwalten kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit D-Bus Mocking):**
    * Mocken des `zbus::Connection` und des `NotificationManager`.
    * Testen der D-Bus-Service-Registrierung.
    * Simulieren von `Notify` D-Bus-Aufrufen und Überprüfen, ob die Parameter korrekt in `Notification` Structs umgewandelt und an den `NotificationManager` weitergeleitet werden.
    * Testen von `GetCapabilities`, `CloseNotification` und `GetServerInformation`.
    * Testen der internen `show_notification` und `close_notification` Methoden.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob der `NotificationManager` über Konfigurationsänderungen informiert wird.
* **Integration Tests (mit `busctl` oder `notify-send`):**
    * Starten des `NotificationService`.
    * Verwenden von `notify-send` oder `busctl` um Benachrichtigungen zu senden und zu schließen.
    * Überprüfen, ob die Benachrichtigungen auf dem Desktop angezeigt werden (visuell) und ob die korrekten `SystemEvent`s ausgelöst werden.
    * Testen von Benachrichtigungen mit Aktionen und Überprüfen, ob `NotificationActionInvoked` Events gesendet werden.
    * Testen von `do_not_disturb_mode` und `notification_position` durch Ändern der Konfiguration.

**Geschätzter Aufwand:** Sehr Hoch (ca. 10-15 Tage, da D-Bus-Service-Implementierung, Event-Handling, Zustandsverwaltung und UI-Integration)

---

### **novade-system/src/notification_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `notification_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Benachrichtigungs-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum NotificationError {`
        * `#[error("Failed to connect to D-Bus session bus: {0}")]`
        * `DBusConnectError(#[from] zbus::Error),`
        * `#[error("Failed to register D-Bus service: {0}")]`
        * `DBusServiceRegistrationError(String),`
        * `#[error("Notification with ID {0} not found")]`
        * `NotificationNotFound(u32),`
        * `#[error("Invalid notification parameter: {0}")]`
        * `InvalidParameter(String),`
        * `#[error("Failed to display notification: {0}")]`
        * `DisplayError(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Unknown notification error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `zbus::Error`, `crate::config_service::error::ConfigError` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `zbus::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `notification_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Benachrichtigungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/notification_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `notification_service` verwendet werden, um Benachrichtigungen, ihre Attribute und Aktionen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`Notification` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct Notification {`
        * `pub id: u32,` // Eindeutige ID der Benachrichtigung (0 für neue Benachrichtigung)
        * `pub app_name: String,`
        * `pub app_icon: Option<String>,` // Pfad zum Icon oder Icon-Name
        * `pub summary: String,` // Titel der Benachrichtigung
        * `pub body: Option<String>,` // Haupttext der Benachrichtigung (HTML-Markup möglich)
        * `pub actions: Vec<NotificationAction>,` // Interaktive Buttons
        * `pub hints: HashMap<String, zbus::zvariant::Value<'static>>,` // Spezifische Hinweise (z.B. "urgency", "category")
        * `pub expire_timeout: Option<Duration>,` // Anzeigedauer der Benachrichtigung
        * `pub timestamp: SystemTime,` // Zeitpunkt der Erstellung
        * `pub dismiss_reason: Option<DismissReason>,` // Wie die Benachrichtigung geschlossen wurde
    * `}`

2.  **`NotificationAction` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct NotificationAction {`
        * `pub id: String,` // Eindeutige ID für die Aktion
        * `pub label: String,` // Anzeigename des Buttons
    * `}`

3.  **`DismissReason` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum DismissReason {`
        * `Expired,` // Durch Timeout geschlossen
        * `DismissedByUser,` // Vom Benutzer explizit geschlossen
        * `ClosedByCall,` // Durch `CloseNotification` D-Bus-Aufruf geschlossen
        * `Undefined,` // Undefinierter Grund
    * `}`

4.  **`NotificationConfig` Struct (aus `config_service/data_types.rs`):**
    * Sollte hier nur referenziert werden, da es bereits an anderer Stelle definiert ist.
    * `pub struct NotificationConfig {`
        * `pub do_not_disturb_mode: bool,`
        * `pub display_timeout_seconds: u64,`
        * `pub notification_position: NotificationPosition,`
        * `pub max_notifications: u32,` // Maximale Anzahl gleichzeitig angezeigter Benachrichtigungen
        * `pub enable_sound: bool,`
        * `// ... weitere Einstellungen (z.B. blacklist_apps)`
    * `}`

5.  **`NotificationPosition` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, Default, serde::Serialize, serde::Deserialize)]`
    * `pub enum NotificationPosition {`
        * `#[default]`
        * `TopRight,`
        * `TopLeft,`
        * `BottomRight,`
        * `BottomLeft,`
        * `Center,`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::collections::HashMap`
    * `std::time::{Duration, SystemTime}`
    * `zbus::zvariant::Value` (für D-Bus `hints`)

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Benachrichtigungen im System.
* `Notification` wird vom D-Bus-Service empfangen und an den `NotificationManager` weitergeleitet.
* `NotificationConfig` wird vom `ConfigService` geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für das Benachrichtigungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen der `Notification` und `NotificationAction`.
    * Sicherstellen, dass `NotificationPosition::default()` korrekt ist.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage, da Strukturierung der komplexen Notification-Daten)

---

### **novade-system/src/notification_service/manager.rs**

**Verantwortlichkeit:**
Der `NotificationManager` ist das Herzstück des Benachrichtigungs-Services. Er ist verantwortlich für die interne Verwaltung der Benachrichtigungen (Speicherung, Lebenszyklus), die Anwendung der Benutzerpräferenzen (Position, Timeout, DND-Modus) und die Zusammenarbeit mit der UI-Schicht, um die Benachrichtigungen tatsächlich auf dem Bildschirm anzuzeigen.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationManager` Struct:**
    * `pub struct NotificationManager {`
        * `active_notifications: RwLock<HashMap<u32, Notification>>,` // Aktuell angezeigte Benachrichtigungen
        * `next_notification_id: AtomicU32,`
        * `config: RwLock<NotificationConfig>,`
        * `event_bus: EventBus,`
        * `// Optional: Handle zum UI-Komponenten-Manager, um Benachrichtigungs-Widgets zu erstellen/aktualisieren`
    * `}`

2.  **`NotificationManager::new()` Funktion:**
    * `pub async fn new(initial_config: NotificationConfig, event_bus: EventBus) -> Result<Self, NotificationError>`
    * **Logik:**
        * Initialisiert die `active_notifications` Map und die `next_notification_id`.
        * Setzt die initiale `config`.
        * Gibt `Self` zurück.

3.  **`NotificationManager::display_notification()` Methode:**
    * `pub async fn display_notification(&self, mut notification: Notification) -> Result<u32, NotificationError>`
    * **Logik:**
        * Generiert eine neue `id`, wenn `notification.id` 0 ist, ansonsten wird eine vorhandene Benachrichtigung mit dieser `id` aktualisiert.
        * Überprüft den `do_not_disturb_mode` in `self.config`. Wenn aktiv, loggt die Benachrichtigung, zeigt sie aber nicht an (oder nur persistente).
        * Wenn `max_notifications` erreicht, älteste Benachrichtigung schließen.
        * Wendet `notification_position` und `display_timeout_seconds` aus `self.config` an.
        * **Kommunikation mit UI:** Sendet ein Event an die UI-Schicht, um ein neues Benachrichtigungs-Widget zu erstellen oder ein bestehendes zu aktualisieren. Dies könnte ein spezifischer `SystemEvent::DisplayNotificationUi` sein, der das `Notification` Struct enthält.
        * Startet einen Timer für `expire_timeout` (falls definiert und nicht persistent). Nach Ablauf des Timers ruft es `close_notification_internal` auf mit `DismissReason::Expired`.
        * Fügt die Benachrichtigung zu `active_notifications` hinzu.
        * Sendet `SystemEvent::NotificationDisplayed(notification.id)` an den `EventBus`.
        * Gibt die vergebene/aktualisierte `id` zurück.
        * **Fehlerbehandlung:** `DisplayError` wenn die UI-Kommunikation fehlschlägt oder andere Probleme auftreten.

4.  **`NotificationManager::close_notification()` Methode:**
    * `pub async fn close_notification(&self, id: u32, reason: DismissReason) -> Result<(), NotificationError>`
    * **Logik:**
        * Ruft `close_notification_internal` auf.

5.  **`NotificationManager::close_notification_internal()` (Private Hilfsmethode):**
    * `async fn close_notification_internal(&self, id: u32, reason: DismissReason) -> Result<(), NotificationError>`
    * **Logik:**
        * Entfernt die Benachrichtigung mit `id` aus `active_notifications`.
        * Stoppt den zugehörigen Timeout-Timer.
        * **Kommunikation mit UI:** Sendet ein Event an die UI-Schicht, um das Benachrichtigungs-Widget zu entfernen (`SystemEvent::RemoveNotificationUi(id)`).
        * Sendet `SystemEvent::NotificationClosed(id, reason)` an den `EventBus`.
        * **Fehlerbehandlung:** `NotificationNotFound` wenn die ID nicht existiert.

6.  **`NotificationManager::handle_notification_action()` Methode (vom UI-Event):**
    * `pub async fn handle_notification_action(&self, id: u32, action_id: String) -> Result<(), NotificationError>`
    * **Logik:**
        * Wird von der UI aufgerufen, wenn ein Benutzer auf eine Aktionsschaltfläche in einer Benachrichtigung klickt.
        * Sendet `SystemEvent::NotificationActionInvoked(id, action_id)` an den `EventBus`.
        * Schließt optional die Benachrichtigung, abhängig von den `hints` der Benachrichtigung oder der Konfiguration.

7.  **`NotificationManager::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: NotificationConfig)`
    * **Logik:** Aktualisiert die interne `config` und wendet gegebenenfalls Änderungen auf aktive Benachrichtigungen an (z.B. neue Position).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::notification_service::error::NotificationError`
    * `crate::notification_service::data_types::{Notification, DismissReason, NotificationConfig}`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tokio::time::sleep`
    * `tokio::sync::RwLock`
    * `std::collections::HashMap`
    * `std::sync::atomic::{AtomicU32, Ordering}`
    * `std::sync::Arc`
    * `tracing`

**Kommunikationsmuster:**

* Erhält Benachrichtigungsanfragen von `mod.rs` (vom D-Bus oder intern).
* Verwaltet den Lebenszyklus von Benachrichtigungen.
* Sendet Events an den `EventBus`, um die UI zu steuern und andere Komponenten über Benachrichtigungsaktionen zu informieren.
* Empfängt Konfigurationsupdates vom `NotificationService`.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Benachrichtigungs-Manager, der Benachrichtigungen intern speichert, ihre Lebenszyklen steuert und mit der UI für die Anzeige interagiert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `EventBus`.
    * Testen von `new`.
    * Testen von `display_notification`:
        * Erstellung neuer IDs.
        * Aktualisierung bestehender Benachrichtigungen.
        * Anwendung von `do_not_disturb_mode`.
        * Anwendung von `max_notifications`.
        * Sendung von `SystemEvent::DisplayNotificationUi` und `SystemEvent::NotificationDisplayed`.
        * Starten des Timeout-Timers.
    * Testen von `close_notification` (und `close_notification_internal`):
        * Entfernung aus `active_notifications`.
        * Stoppen des Timers.
        * Sendung von `SystemEvent::RemoveNotificationUi` und `SystemEvent::NotificationClosed`.
        * Behandlung von `NotificationNotFound`.
    * Testen von `handle_notification_action`: Sendung von `SystemEvent::NotificationActionInvoked`.
    * Testen von `update_config`.
* **Integration Tests (mit realer UI-Mockup):**
    * Starten des `NotificationManager` mit einem einfachen UI-Mockup, das `SystemEvent::DisplayNotificationUi` empfängt und eine visuelle Darstellung zeigt.
    * Senden von Benachrichtigungen mit verschiedenen Parametern (Timeout, Aktionen, DND-Modus).
    * Überprüfen des Verhaltens (Anzeige, Schließen, Aktionen).

**Geschätzter Aufwand:** Sehr Hoch (ca. 8-12 Tage, da komplexe Zustandsverwaltung, Timer, Event-Handling und Interaktion mit UI-Schicht)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `input_service`, widmen wir uns `notification_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/notification_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/notification_service/data_types.rs`**: Definition der grundlegenden Datentypen für Benachrichtigungen.
3.  **`novade-system/src/notification_service/manager.rs`**: Die Kernlogik zur Verwaltung und Anzeige von Benachrichtigungen, die die Datenstrukturen nutzt.
4.  **`novade-system/src/notification_service/mod.rs`**: Das Hauptmodul, das den D-Bus-Service initialisiert, den `NotificationManager` instanziiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/notification_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/display_service` Verzeichnisses, um die Display-Verwaltung, Helligkeitssteuerung und Bildschirm-Sperre zu kontrollieren.
---
### **novade-system/src/display_service/mod.rs**

**Verantwortlichkeit:**
Das `display_service` Modul ist verantwortlich für die Interaktion mit dem Anzeigeserver (Wayland Compositor wie `smithay` oder X11) zur Verwaltung von Bildschirmen, Helligkeitssteuerung, Bildschirm-Sperrung und Farbprofilen. Es abstrahiert die zugrunde liegenden Grafik-APIs und bietet eine konsistente Schnittstelle für andere NovaDE-Komponenten.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/display_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Display-Operationen)
    * `manager.rs` (Interne Logik für Bildschirmverwaltung, Helligkeitssteuerung)
    * `data_types.rs` (Definition von Display-bezogenen Datentypen)
    * `screen_locker.rs` (Logik für die Bildschirmsperre)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Display-Subsystems:**
    * `pub async fn initialize_display_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<DisplayService, DisplayError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::DisplayManager`, die die Verbindung zum Anzeigeserver herstellt (z.B. über Wayland-Protokolle, XRandR/XF86VidMode für X11).
        * Erstellt eine Instanz von `screen_locker::ScreenLocker`, falls die Bildschirmsperre über eine separate Komponente gehandhabt wird.
        * Ruft die initialen Display-Einstellungen aus dem `config_service` ab (z.B. `brightness`, `night_light_enabled`, `screen_blank_delay_minutes`).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Display-Einstellungen zu laden.
        * Gibt ein gebündeltes `DisplayService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Verbindung zum Anzeigeserver oder der Initialisierung der Sub-Komponenten.

2.  **`DisplayService` Struct:**
    * `pub struct DisplayService {`
        * `manager: Arc<DisplayManager>,`
        * `screen_locker: Arc<ScreenLocker>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
    * `}`
    * Dient als Container und Zugangspunkt für die Display-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `DisplayService` exponiert Methoden zur Abfrage von Display-Informationen und zur Steuerung von Display-Funktionen.
    * **`get_connected_displays(&self) -> Result<Vec<DisplayInfo>, DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um eine Liste der erkannten Bildschirme mit ihren Eigenschaften zurückzugeben.
    * **`set_primary_display(&self, display_id: &str) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um den primären Bildschirm zu setzen.
    * **`set_display_resolution(&self, display_id: &str, resolution: Resolution) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um die Auflösung eines Bildschirms zu ändern.
    * **`set_display_brightness(&self, brightness_percent: u8) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um die globale Bildschirmhelligkeit anzupassen. Sendet `SystemEvent::BrightnessChanged`.
    * **`get_display_brightness(&self) -> Result<u8, DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um die aktuelle globale Bildschirmhelligkeit abzufragen.
    * **`blank_screen(&self) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um den/die Bildschirm(e) auszuschalten (dunkel zu schalten).
    * **`unblank_screen(&self) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um den/die Bildschirm(e) wieder einzuschalten.
    * **`lock_screen(&self) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `ScreenLocker`, um den Bildschirm zu sperren.
        * Sendet `SystemEvent::ScreenLocked`.
    * **`unlock_screen(&self) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `ScreenLocker`, um den Bildschirm zu entsperren (nach erfolgreicher Authentifizierung).
        * Sendet `SystemEvent::ScreenUnlocked`.
    * **`activate_night_light(&self, enabled: bool) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um den Nachtlicht-Modus zu aktivieren/deaktivieren (Anpassung der Farbtemperatur).
        * Speichert die Änderung im `config_service`.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `DisplayService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn die relevanten Display-Einstellungen in der Konfiguration geändert werden, werden die Sub-Komponenten (z.B. `DisplayManager` für Nachtlicht, `ScreenLocker` für Timeout) informiert.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::display_service::error::DisplayError`
    * `crate::display_service::manager::DisplayManager`
    * `crate::display_service::screen_locker::ScreenLocker`
    * `crate::display_service::data_types::{DisplayInfo, Resolution}`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `wayland-client` (für Wayland-Protokolle, z.B. `wlr-output-management`, `xdg-output`)
    * `xrandr` / `x11rb` (für X11)
    * `backlight` crate (für Helligkeit, `sysfs` oder `DDC/CI`)

**Kommunikationsmuster:**

* Wird von der Domänenschicht und der UI-Schicht verwendet, um Display-Informationen abzurufen und Aktionen auszulösen.
* Interagiert mit dem `ConfigService` zum Laden und Speichern von Display-Einstellungen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten und andere Systemdienste über Display-Statusänderungen zu informieren (z.B. `SystemEvent::DisplayConnected`, `SystemEvent::BrightnessChanged`, `SystemEvent::ScreenLocked`).
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Display-Subsystem, das Bildschirme verwalten, Helligkeit steuern und den Bildschirm sperren kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `DisplayManager` und `ScreenLocker`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration.
    * Testen der Weiterleitung von API-Aufrufen an `DisplayManager` und `ScreenLocker`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
* **Integration Tests (mit virtuellen Displays oder realer Hardware):**
    * Starten des `DisplayService` in einer Testumgebung (z.B. mit einem virtuellen X-Server oder einem simulierten Wayland-Compositor).
    * Testen der Erkennung und Konfiguration von Displays (Auflösung, Primärbildschirm).
    * Testen der Helligkeitssteuerung (visuell oder durch Abfragen der Helligkeit über System-APIs).
    * Testen von `blank_screen` und `unblank_screen`.
    * Testen der Bildschirmsperre und -entsperrung (ggf. mit einem simplen Authentifizierungs-Mockup).

**Geschätzter Aufwand:** Sehr Hoch (ca. 12-18 Tage, da komplexe Interaktion mit Grafik-APIs, Zustandsverwaltung und Event-Handling)

---

### **novade-system/src/display_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `display_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Display-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`DisplayError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum DisplayError {`
        * `#[error("Failed to connect to display server: {0}")]`
        * `ServerConnectError(String),` // Z.B. Wayland Compositor nicht erreichbar, X-Server nicht gefunden
        * `#[error("Display not found: {0}")]`
        * `DisplayNotFound(String),`
        * `#[error("Invalid resolution or refresh rate: {0}")]`
        * `InvalidResolution(String),`
        * `#[error("Failed to set brightness: {0}")]`
        * `BrightnessControlError(String),`
        * `#[error("Screen lock failed: {0}")]`
        * `ScreenLockError(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Wayland protocol error: {0}")]`
        * `WaylandProtocolError(String),` // Spezifisch für Wayland
        * `#[error("X11 error: {0}")]`
        * `X11Error(String),` // Spezifisch für X11
        * `#[error("Unknown display error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError` und `anyhow::Error`. Füge spezifische Fehler von `wayland-client`, `x11rb` oder `backlight` hinzu.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * Spezifische Fehler-Typen von `wayland-client`, `x11rb`, `backlight`.
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `display_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Display-System.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---

### **novade-system/src/display_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `display_service` verwendet werden, um Bildschirme, ihre Eigenschaften und Konfigurationsoptionen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`DisplayInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct DisplayInfo {`
        * `pub id: String,` // Eindeutiger Bezeichner des Displays (z.B. Output-Name in Wayland/X11)
        * `pub name: String,` // Anzeigename (z.B. "Laptop Screen", "HDMI-1")
        * `pub current_resolution: Resolution,`
        * `pub available_resolutions: Vec<Resolution>,`
        * `pub current_refresh_rate_mhz: u32,`
        * `pub available_refresh_rates_mhz: Vec<u32>,`
        * `pub position_x: i32,` // X-Koordinate auf dem virtuellen Desktop
        * `pub position_y: i32,` // Y-Koordinate auf dem virtuellen Desktop
        * `pub is_primary: bool,`
        * `pub is_enabled: bool,`
        * `pub make: Option<String>,`
        * `pub model: Option<String>,`
        * `pub serial: Option<String>,`
    * `}`

2.  **`Resolution` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]`
    * `pub struct Resolution {`
        * `pub width: u332,`
        * `pub height: u32,`
    * `}`

3.  **`NightLightConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct NightLightConfig {`
        * `pub enabled: bool,`
        * `pub temperature_kelvin: u16,` // Farbtemperatur in Kelvin (z.B. 4500)
        * `pub schedule_enabled: bool,`
        * `pub schedule_start_time: Option<String>,` // "HH:MM"
        * `pub schedule_end_time: Option<String>,` // "HH:MM"
    * `}`

4.  **`ScreenLockConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct ScreenLockConfig {`
        * `pub enabled: bool,`
        * `pub lock_after_minutes: u32,` // Nach wie vielen Minuten Inaktivität sperren
        * `pub on_suspend_lock: bool,` // Beim Suspend sperren
        * `pub show_clock_on_lock_screen: bool,`
        * `pub background_image_path: Option<PathBuf>,`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::path::PathBuf`

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Display-Informationen und Konfigurationen im System.
* `DisplayInfo` wird von `get_connected_displays` zurückgegeben.
* `NightLightConfig` und `ScreenLockConfig` stammen aus dem `ConfigService`.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Display-Verwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage, da Strukturierung der Display-Daten und Konfigurationen)

---

### **novade-system/src/display_service/manager.rs**

**Verantwortlichkeit:**
Der `DisplayManager` ist die primäre Schnittstelle zur Interaktion mit dem Grafik-Backend (Wayland Compositor oder X11-Server). Er ist für das Abrufen von Bildschirm-Informationen, das Ändern von Auflösungen/Positionen, die Helligkeitssteuerung und die Implementierung des Nachtlicht-Modus verantwortlich.

**Kern-Aufgaben (Tasks):**

1.  **`DisplayManager` Struct:**
    * `pub struct DisplayManager {`
        * `// Interner Client für Wayland- oder X11-Verbindungen (z.B. smithay client für Wayland, x11rb::Connection für X11)`
        * `connected_displays: RwLock<HashMap<String, DisplayInfo>>,` // Aktuell erkannte Displays
        * `current_brightness_percent: AtomicU8,`
        * `night_light_enabled: AtomicBool,`
        * `event_bus: EventBus,`
        * `// Optional: Handles zu Protokoll-spezifischen Clients (z.B. wlr-output-management, xrandr_ext)`
    * `}`

2.  **`DisplayManager::new()` Funktion:**
    * `pub async fn new(event_bus: EventBus) -> Result<Self, DisplayError>`
    * **Logik:**
        * Stellt eine Verbindung zum Display-Server her (Wayland: `wayland-client::Display::connect_to_env()`, X11: `x11rb::connect`).
        * Initialisiert die notwendigen Protokoll-Clients (Wayland: `wlr-output-management`, `xdg-output`; X11: `xrandr`, `xf86vidmode`).
        * Scannt initial alle vorhandenen Displays und füllt die `connected_displays` HashMap.
        * Ruft die aktuelle Helligkeit ab.
        * Startet einen Hintergrund-Task, der auf Änderungen an den Displays lauscht (z.B. Hotplug, Moduswechsel) und `SystemEvent::DisplayConnected`/`DisplayDisconnected` sendet.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `ServerConnectError` bei Problemen mit der Verbindung zum Display-Server.

3.  **`DisplayManager::get_connected_displays()` Methode:**
    * `pub fn get_connected_displays(&self) -> Vec<DisplayInfo>`
    * **Logik:** Gibt eine geklonte Liste der aktuell erkannten `DisplayInfo`s zurück.

4.  **`DisplayManager::set_primary_display()` Methode:**
    * `pub async fn set_primary_display(&self, display_id: &str) -> Result<(), DisplayError>`
    * **Logik:**
        * Findet das Display mit `display_id`.
        * Verwendet die Display-Server-API (Wayland: `wlr-output-manager::set_primary()`, X11: `XRANDR_SET_PRIMARY`) um den primären Bildschirm zu setzen.
        * Aktualisiert den internen Zustand und sendet `SystemEvent::DisplayConfigChanged`.
        * **Fehlerbehandlung:** `DisplayNotFound`, `WaylandProtocolError`, `X11Error`.

5.  **`DisplayManager::set_display_resolution()` Methode:**
    * `pub async fn set_display_resolution(&self, display_id: &str, resolution: Resolution) -> Result<(), DisplayError>`
    * **Logik:**
        * Findet das Display und überprüft, ob die `resolution` unterstützt wird.
        * Verwendet die Display-Server-API (Wayland: `wlr-output-manager::set_mode()`, X11: `XRANDR_SET_MODE`) um die Auflösung zu ändern.
        * Aktualisiert den internen Zustand und sendet `SystemEvent::DisplayConfigChanged`.
        * **Fehlerbehandlung:** `DisplayNotFound`, `InvalidResolution`, `WaylandProtocolError`, `X11Error`.

6.  **`DisplayManager::set_display_brightness()` Methode:**
    * `pub async fn set_display_brightness(&self, brightness_percent: u8) -> Result<(), DisplayError>`
    * **Logik:**
        * Konvertiert den Prozentwert in den vom Backend erwarteten Bereich.
        * Verwendet die System-API zur Helligkeitssteuerung (z.B. `sysfs` oder `ddcutil` für externen Monitor, `XF86VidMode` für X11, `wlr-output-manager` für Wayland).
        * Aktualisiert `current_brightness_percent` und sendet `SystemEvent::BrightnessChanged(brightness_percent)`.
        * **Fehlerbehandlung:** `BrightnessControlError`.

7.  **`DisplayManager::get_display_brightness()` Methode:**
    * `pub async fn get_display_brightness(&self) -> Result<u8, DisplayError>`
    * **Logik:** Fragt die aktuelle Helligkeit ab und konvertiert sie in Prozent.

8.  **`DisplayManager::blank_screen()` und `unblank_screen()` Methoden:**
    * `pub async fn blank_screen(&self) -> Result<(), DisplayError>`
    * `pub async fn unblank_screen(&self) -> Result<(), DisplayError>`
    * **Logik:**
        * Verwendet die Display-Server-API, um den/die Bildschirm(e) auszuschalten/einzuschalten (z.B. `DPMS` für X11, `wlr-output-manager` für Power-States).
        * **Fehlerbehandlung:** `DisplayError` wenn die Aktion fehlschlägt.

9.  **`DisplayManager::set_night_light_state()` Methode:**
    * `pub async fn set_night_light_state(&self, enabled: bool, temperature_kelvin: u16) -> Result<(), DisplayError>`
    * **Logik:**
        * Aktiviert/Deaktiviert das Nachtlicht.
        * Verwendet eine API wie `redshift` oder eine direkte Anpassung der Farbtemperatur über das Display-Backend (falls verfügbar).
        * Aktualisiert `night_light_enabled` und sendet `SystemEvent::NightLightStateChanged`.
        * **Fehlerbehandlung:** `DisplayError` wenn die Anpassung fehlschlägt.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::display_service::error::DisplayError`
    * `crate::display_service::data_types::{DisplayInfo, Resolution}`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern (Beispiele):**
    * `wayland-client` / `smithay` (für Wayland)
    * `x11rb` / `xrandr` / `xf86vidmode` (für X11)
    * `backlight` (für Helligkeit)
    * `tokio::task`
    * `tokio::sync::RwLock`
    * `std::sync::atomic::{AtomicU8, AtomicBool}`
    * `tracing`
    * `std::sync::Arc`
    * `std::collections::HashMap`

**Kommunikationsmuster:**

* Wird vom `DisplayService` verwendet, um mit dem Display-Server zu kommunizieren.
* Überwacht Display-Änderungen und sendet `SystemEvent`s an den `EventBus`.

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger Display-Manager, der Display-Eigenschaften lesen und steuern kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend-Mocking):**
    * Mocken des Wayland/X11-Clients und der Helligkeits-APIs.
    * Testen von `new`: Sicherstellen der Verbindungsinitialisierung und initialen Geräteerkennung.
    * Testen von `get_connected_displays` mit simulierten Daten.
    * Testen von `set_primary_display`, `set_display_resolution`, `set_display_brightness`: Simulieren erfolgreiche und fehlerhafte Backend-Aufrufe und Überprüfen der internen Zustandsänderungen und Event-Sendungen.
    * Simulieren von Display-Hotplug-Events und Überprüfen der `SystemEvent`s.
    * Testen von `blank_screen`, `unblank_screen`.
    * Testen von `set_night_light_state`.
* **Integration Tests (mit virtuellen Displays oder realer Hardware):**
    * Starten des `DisplayManager` auf einem System mit Wayland/X11.
    * Testen der Display-Erkennung (z.B. Monitor anschließen/trennen).
    * Testen von Auflösungs- und Helligkeitsänderungen (visuell überprüfen).
    * Testen des Nachtlicht-Modus (visuell überprüfen).

**Geschätzter Aufwand:** Sehr Hoch (ca. 15-20 Tage, da tiefe Interaktion mit Grafik-Backend, Protokollen und dynamischen Änderungen)

---

### **novade-system/src/display_service/screen_locker.rs**

**Verantwortlichkeit:**
Der `ScreenLocker` ist für die Funktionalität der Bildschirmsperre zuständig. Er interagiert mit dem Authentifizierungsdienst (`AuthService`) zur Benutzerverifizierung und stellt sicher, dass der Bildschirm gesperrt und der Inhalt geschützt ist. Er ist auch für die Anzeige des Sperrbildschirms auf der UI verantwortlich.

**Kern-Aufgaben (Tasks):**

1.  **`ScreenLocker` Struct:**
    * `pub struct ScreenLocker {`
        * `auth_service: Arc<AuthService>,`
        * `event_bus: EventBus,`
        * `config: RwLock<ScreenLockConfig>,`
        * `is_locked: AtomicBool,`
        * `// Optional: Handle zum UI-Komponenten-Manager, um den Sperrbildschirm anzuzeigen/auszublenden`
    * `}`

2.  **`ScreenLocker::new()` Funktion:**
    * `pub async fn new(auth_service: Arc<AuthService>, event_bus: EventBus, initial_config: ScreenLockConfig) -> Result<Self, DisplayError>`
    * **Logik:**
        * Initialisiert mit dem bereitgestellten `AuthService` und `EventBus`.
        * Setzt die initiale `config`.
        * Gibt `Self` zurück.

3.  **`ScreenLocker::lock_screen()` Methode:**
    * `pub async fn lock_screen(&self) -> Result<(), DisplayError>`
    * **Logik:**
        * Wenn der Bildschirm bereits gesperrt ist, nichts tun.
        * Setzt `is_locked` auf `true`.
        * **Kommunikation mit UI:** Sendet ein Event an die UI-Schicht, um den Sperrbildschirm anzuzeigen (`SystemEvent::ShowLockScreenUi`). Dies sollte idealerweise den gesamten Desktop überlagern und Eingaben abfangen.
        * Optional: `DisplayManager::blank_screen()` aufrufen, wenn der Sperrbildschirm nach einer gewissen Zeit den Bildschirm ausschalten soll.
        * Sendet `SystemEvent::ScreenLocked` an den `EventBus`.
        * **Fehlerbehandlung:** `ScreenLockError` wenn das Anzeigen des Sperrbildschirms fehlschlägt.

4.  **`ScreenLocker::unlock_screen()` Methode:**
    * `pub async fn unlock_screen(&self, password: &str) -> Result<(), DisplayError>`
    * **Logik:**
        * Ruft `auth_service.authenticate_user(username, password)` auf (der `username` müsste von der Session oder über eine API vom `AuthService` verfügbar sein).
        * Wenn die Authentifizierung erfolgreich ist:
            * Setzt `is_locked` auf `false`.
            * **Kommunikation mit UI:** Sendet ein Event an die UI-Schicht, um den Sperrbildschirm auszublenden (`SystemEvent::HideLockScreenUi`).
            * Optional: `DisplayManager::unblank_screen()` aufrufen.
            * Sendet `SystemEvent::ScreenUnlocked` an den `EventBus`.
            * Gibt `Ok(())` zurück.
        * Wenn die Authentifizierung fehlschlägt:
            * Sendet `SystemEvent::AuthenticationFailed` (ggf. spezifisch für Sperrbildschirm).
            * Gibt einen Fehler zurück (`ScreenLockError("Authentication failed")`).

5.  **`ScreenLocker::is_locked()` Methode:**
    * `pub fn is_locked(&self) -> bool`
    * **Logik:** Gibt den aktuellen Sperrstatus zurück.

6.  **`ScreenLocker::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: ScreenLockConfig)`
    * **Logik:** Aktualisiert die interne `config`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_service/screen_locker.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::display_service::error::DisplayError`
    * `crate::display_service::data_types::ScreenLockConfig`
    * `crate::auth_service::AuthService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
    * `novade_system::display_service::manager::DisplayManager` (Optional, für blank/unblank)
* **Extern:**
    * `tokio::task`
    * `tokio::sync::RwLock`
    * `std::sync::atomic::{AtomicBool, Ordering}`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Wird vom `DisplayService` verwendet, um den Bildschirm zu sperren/entsperren.
* Interagiert mit dem `AuthService` für die Authentifizierung.
* Sendet Events an den `EventBus`, um die UI zu steuern und andere Komponenten über den Sperrstatus zu informieren.
* Empfängt Konfigurationsupdates vom `DisplayService`.

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger Bildschirmsperrdienst, der den Bildschirm auf Befehl sperrt und nach erfolgreicher Authentifizierung entsperrt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `AuthService` und `EventBus`.
    * Testen von `new`.
    * Testen von `lock_screen`: Sicherstellen, dass `is_locked` auf `true` gesetzt und `SystemEvent::ShowLockScreenUi` sowie `SystemEvent::ScreenLocked` gesendet werden.
    * Testen von `unlock_screen`:
        * Erfolgreiche Authentifizierung: `is_locked` auf `false`, `SystemEvent::HideLockScreenUi`, `SystemEvent::ScreenUnlocked`.
        * Fehlgeschlagene Authentifizierung: `is_locked` bleibt `true`, `SystemEvent::AuthenticationFailed`.
    * Testen von `is_locked`.
    * Testen von `update_config`.
* **Integration Tests (mit realer UI-Mockup und Authentifizierung):**
    * Starten des `ScreenLocker` mit einem minimalen `AuthService` und einem UI-Mockup für den Sperrbildschirm.
    * Manuelles Sperren/Entsperren und Überprüfen der visuellen Änderungen und der Authentifizierung.
    * Testen des Verhaltens bei falschem Passwort.

**Geschätzter Aufwand:** Mittel-Hoch (ca. 6-9 Tage, da Interaktion mit AuthService, UI-Integration und Zustandsverwaltung)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `notification_service`, widmen wir uns `display_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/display_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/display_service/data_types.rs`**: Definition der grundlegenden Datentypen für Displays und ihre Konfiguration.
3.  **`novade-system/src/display_service/manager.rs`**: Die Kernlogik zur Interaktion mit dem Grafik-Backend (Wayland/X11), Helligkeitssteuerung und Night Light.
4.  **`novade-system/src/display_service/screen_locker.rs`**: Implementierung des Sperrbildschirms, der den `AuthService` und UI-Interaktion benötigt.
5.  **`novade-system/src/display_service/mod.rs`**: Das Hauptmodul, das alle anderen Komponenten initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/display_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/app_launcher` Verzeichnisses, um die Anwendungsstart- und -management-Funktionen zu kontrollieren.
---
### **novade-system/src/app_launcher/mod.rs**

**Verantwortlichkeit:**
Das `app_launcher` Modul ist das zentrale Systemdienst zum Starten, Verwalten und Überwachen von Desktop-Anwendungen. Es fungiert als Abstraktionsschicht über den zugrunde liegenden Prozessmanagement-APIs (z.B. `std::process`, `systemd-run`, D-Bus `org.freedesktop.Application` Protokolle). Es ist verantwortlich für das Auffinden von Anwendungen (via `.desktop`-Dateien), das Starten von Prozessen und die grundlegende Prozessüberwachung.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/app_launcher/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Anwendungsstart-Operationen)
    * `manager.rs` (Logik für das Auffinden, Starten und Überwachen von Anwendungen)
    * `data_types.rs` (Definition von Anwendungs-bezogenen Datentypen)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Anwendungs-Launchers:**
    * `pub async fn initialize_app_launcher(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<AppLauncher, AppLauncherError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::ApplicationManager`, die für das Scannen von `.desktop`-Dateien und die Verwaltung der Anwendungsliste zuständig ist.
        * Ruft initial konfigurierte Pfade für `.desktop`-Dateien aus dem `config_service` ab (z.B. `~/.local/share/applications`, `/usr/share/applications`).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Pfade oder andere Launcher-Einstellungen zu laden.
        * Gibt ein gebündeltes `AppLauncher` Struct zurück.
    * **Fehlerbehandlung:** Fehler beim Scannen von Anwendungspfaden oder der Initialisierung des `ApplicationManager`.

2.  **`AppLauncher` Struct:**
    * `pub struct AppLauncher {`
        * `manager: Arc<ApplicationManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
    * `}`
    * Dient als Container und Zugangspunkt für die Anwendungs-Start-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `AppLauncher` exponiert Methoden zum Abrufen von Anwendungsinformationen und zum Starten von Anwendungen.
    * **`list_applications(&self) -> Result<Vec<ApplicationInfo>, AppLauncherError>`:**
        * **Logik:** Delegiert an den `ApplicationManager`, um eine Liste aller erkannten Anwendungen zurückzugeben.
    * **`find_application(&self, app_id: &str) -> Result<ApplicationInfo, AppLauncherError>`:**
        * **Logik:** Delegiert an den `ApplicationManager`, um Informationen zu einer spezifischen Anwendung basierend auf ihrer ID zu finden.
    * **`launch_application(&self, app_id: &str, args: Option<Vec<String>>) -> Result<LaunchedApplication, AppLauncherError>`:**
        * **Logik:**
            * Delegiert an den `ApplicationManager`, um die Anwendung mit der gegebenen `app_id` zu starten.
            * Übergibt `args` an den Anwendungsprozess.
            * Sendet `SystemEvent::ApplicationLaunched` an den `EventBus`.
            * Gibt ein `LaunchedApplication` Handle zurück, das grundlegende Prozessinformationen und Methoden zur Interaktion enthält.
            * Beachtet `NoDisplay` und `Hidden` Felder in `.desktop` Dateien.
        * **Fehlerbehandlung:** `ApplicationNotFound`, `LaunchError`, `ExecPermissionError`.
    * **`terminate_application(&self, pid: u32) -> Result<(), AppLauncherError>`:**
        * **Logik:** Versucht, den Prozess mit der gegebenen PID elegant zu beenden (SIGTERM).
        * **Fehlerbehandlung:** `ProcessNotFound`, `PermissionDenied`.
    * **`kill_application(&self, pid: u32) -> Result<(), AppLauncherError>`:**
        * **Logik:** Erzwingt die Beendigung des Prozesses mit der gegebenen PID (SIGKILL).
        * **Fehlerbehandlung:** `ProcessNotFound`, `PermissionDenied`.
    * **`set_default_application(&self, mime_type: &str, app_id: &str) -> Result<(), AppLauncherError>`:**
        * **Logik:** Aktualisiert die Standardanwendung für einen bestimmten MIME-Typ im `config_service`.
        * Dies würde eine Interaktion mit dem `ConfigService` und potenziell einer System-MIME-Datenbank (z.B. `shared-mime-info`) erfordern.
    * **`get_default_application(&self, mime_type: &str) -> Result<Option<ApplicationInfo>, AppLauncherError>`:**
        * **Logik:** Ruft die Standardanwendung für einen MIME-Typ ab.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `AppLauncher` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn die `application_paths` in der Konfiguration geändert werden, löst der Task ein erneutes Scannen der Anwendungen im `ApplicationManager` aus.

**Spezifische Artefekte/Dateien:**

* `novade-system/src/app_launcher/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::app_launcher::error::AppLauncherError`
    * `crate::app_launcher::manager::ApplicationManager`
    * `crate::app_launcher::data_types::{ApplicationInfo, LaunchedApplication}`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `std::process::Command`
    * `xdg` crate (für XDG Base Directory Specification)
    * `freedesktop-desktop-entry` crate (für `.desktop` Dateien Parsen)
    * `mime_guess` (für MIME-Typen)

**Kommunikationsmuster:**

* Ist der primäre Consumer von Anwendungsstart-Anfragen von der Domänenschicht und der UI.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Anwendungspfaden und Standardanwendungen.
* Sendet `SystemEvent::ApplicationLaunched` und `SystemEvent::ApplicationTerminated` (oder `Exited`) an den `EventBus`.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Anwendungs-Launcher-Subsystem, das Anwendungen finden, starten und verwalten kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `ApplicationManager`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und des Scannens.
    * Testen der Weiterleitung von API-Aufrufen an den `ApplicationManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände (z.B. neu geladene Anwendungen) korrekt aktualisiert werden.
* **Integration Tests (mit Dummy `.desktop` Dateien und Prozessen):**
    * Erstellen von temporären `.desktop`-Dateien für Dummy-Anwendungen.
    * Starten des `AppLauncher`.
    * Testen von `list_applications` und `find_application`.
    * Testen von `launch_application` mit der Dummy-Anwendung und Überprüfen, ob der Prozess gestartet wird und `SystemEvent::ApplicationLaunched` gesendet wird.
    * Testen von `terminate_application` und `kill_application` an der Dummy-Anwendung.
    * Testen von `set_default_application` und `get_default_application`.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da `.desktop`-Datei-Parsing, Prozess-Management und Event-Handling)

---
### **novade-system/src/app_launcher/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `app_launcher` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Anwendungsstart-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`AppLauncherError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum AppLauncherError {`
        * `#[error("Application not found: {0}")]`
        * `ApplicationNotFound(String),`
        * `#[error("Failed to parse .desktop file: {0}")]`
        * `DesktopFileParseError(String),`
        * `#[error("Failed to launch application: {0}")]`
        * `LaunchError(String),`
        * `#[error("Process not found: {0}")]`
        * `ProcessNotFound(u32),`
        * `#[error("Permission denied: {0}")]`
        * `PermissionDenied(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("I/O error: {0}")]`
        * `IoError(#[from] std::io::Error),`
        * `#[error("Unknown app launcher error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `std::io::Error` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/app_launcher/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::io::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `app_launcher` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Anwendungs-Launcher-System.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/app_launcher/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `app_launcher` verwendet werden, um Anwendungsdefinitionen, gestartete Prozesse und zugehörige Metadaten zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`ApplicationInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct ApplicationInfo {`
        * `pub id: String,` // Desktop Entry ID (z.B. "firefox.desktop")
        * `pub name: String,` // Name der Anwendung (z.B. "Firefox Web Browser")
        * `pub generic_name: Option<String>,` // Generischer Name (z.B. "Web Browser")
        * `pub comment: Option<String>,` // Beschreibung
        * `pub icon: Option<String>,` // Icon-Name oder Pfad
        * `pub exec: String,` // Ausführbarer Befehl
        * `pub terminal: bool,` // Gibt an, ob die Anwendung in einem Terminal gestartet werden soll
        * `pub categories: Vec<String>,` // Anwendungs-Kategorien (z.B. "Network", "WebBrowser")
        * `pub mime_types: Vec<String>,` // Unterstützte MIME-Typen
        * `pub no_display: bool,` // Sollte nicht im Menü angezeigt werden
        * `pub hidden: bool,` // Ist versteckt
        * `pub startup_wm_class: Option<String>,` // WM_CLASS für Fenstermanager
        * `pub startup_notify: bool,` // Sollte der WM über den Start benachrichtigt werden?
        * `pub desktop_file_path: PathBuf,` // Pfad zur .desktop-Datei
    * `}`

2.  **`LaunchedApplication` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct LaunchedApplication {`
        * `pub pid: u32,` // Prozess-ID
        * `pub app_id: String,` // ID der gestarteten Anwendung
        * `pub command: String,` // Der exakte Befehl, der ausgeführt wurde
        * `pub started_at: SystemTime,`
        * `pub is_running: Arc<AtomicBool>,` // Dynamischer Status, ob der Prozess noch läuft
        * `// Optional: Handle zum std::process::Child Objekt, um mit dem Prozess zu interagieren`
    * `}`

3.  **`ProcessStatus` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum ProcessStatus { Running, Exited(i32), Terminated, Killed }`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/app_launcher/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::path::PathBuf`
    * `std::time::SystemTime`
    * `std::sync::Arc`
    * `std::sync::atomic::AtomicBool`

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Anwendungs- und Prozessinformationen im System.
* `ApplicationInfo` wird von `list_applications` und `find_application` zurückgegeben.
* `LaunchedApplication` wird von `launch_application` zurückgegeben und im `ApplicationManager` verwaltet.

**Erwartete Ergebnisse/Outputs:**
Ein umfassendes und gut strukturiertes Set von Datentypen für die Anwendungsverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.
    * Testen der `is_running` Logik in `LaunchedApplication` (wenn relevant).

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage, da Strukturierung der komplexen Anwendungs- und Prozessdaten)

---
### **novade-system/src/app_launcher/manager.rs**

**Verantwortlichkeit:**
Der `ApplicationManager` ist für das Auffinden und Parsen von `.desktop`-Dateien, das Speichern und Abrufen der Liste der verfügbaren Anwendungen und das eigentliche Starten und Überwachen von Anwendungsprozessen verantwortlich. Er agiert als die Kernlogik des `app_launcher` Moduls.

**Kern-Aufgaben (Tasks):**

1.  **`ApplicationManager` Struct:**
    * `pub struct ApplicationManager {`
        * `applications: RwLock<HashMap<String, ApplicationInfo>>,` // Map: app_id -> ApplicationInfo
        * `monitored_processes: RwLock<HashMap<u32, LaunchedApplication>>,` // Map: pid -> LaunchedApplication
        * `event_bus: EventBus,`
        * `desktop_file_paths: RwLock<Vec<PathBuf>>,` // Pfade, in denen nach .desktop-Dateien gesucht wird
    * `}`

2.  **`ApplicationManager::new()` Funktion:**
    * `pub async fn new(initial_desktop_file_paths: Vec<PathBuf>, event_bus: EventBus) -> Result<Self, AppLauncherError>`
    * **Logik:**
        * Initialisiert die internen Maps.
        * Ruft `scan_applications()` auf, um die anfängliche Liste der Anwendungen zu füllen.
        * Startet einen Hintergrund-Task, der periodisch nach Änderungen an den `.desktop`-Dateien sucht oder auf `inotify` Events hört, um die Anwendungsliste dynamisch zu aktualisieren.
        * Startet einen Hintergrund-Task zum Überwachen der gestarteten Prozesse auf deren Beendigung.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `IoError` beim Lesen von Verzeichnissen, `DesktopFileParseError` beim Parsen.

3.  **`ApplicationManager::scan_applications()` Methode:**
    * `async fn scan_applications(&self) -> Result<(), AppLauncherError>`
    * **Logik:**
        * Durchsucht die konfigurierten `desktop_file_paths`.
        * Verwendet `freedesktop-desktop-entry` um jede `.desktop`-Datei zu parsen.
        * Erstellt eine `ApplicationInfo` für jede gültige Datei.
        * Füllt die `applications` HashMap.
        * Ignoriert oder loggt Fehler für ungültige oder nicht lesbare Dateien.
        * Sollte auch den XDG `mimeapps.list` und `defaults.list` für Standard-MIME-Anwendungen scannen, um diese Informationen später für `get_default_application` zu verwenden.
    * **Fehlerbehandlung:** Aggregiert Fehler oder loggt sie.

4.  **`ApplicationManager::list_applications()` Methode:**
    * `pub fn list_applications(&self) -> Vec<ApplicationInfo>`
    * **Logik:** Gibt eine geklonte Liste aller in `applications` gespeicherten `ApplicationInfo`s zurück.

5.  **`ApplicationManager::find_application()` Methode:**
    * `pub fn find_application(&self, app_id: &str) -> Result<ApplicationInfo, AppLauncherError>`
    * **Logik:** Sucht die `ApplicationInfo` in der `applications` HashMap nach der `app_id`.
    * **Fehlerbehandlung:** `ApplicationNotFound`.

6.  **`ApplicationManager::launch_application()` Methode:**
    * `pub async fn launch_application(&self, app_id: &str, args: Option<Vec<String>>) -> Result<LaunchedApplication, AppLauncherError>`
    * **Logik:**
        * Ruft die `ApplicationInfo` für die `app_id` ab.
        * Konstruiert den vollständigen Befehl (`exec`) unter Berücksichtigung von `args` und Platzhaltern (%f, %u, %F, %U, %c, %k).
        * Verwendet `std::process::Command` um die Anwendung zu starten.
        * Handhabt `terminal: true` Anwendungen, indem ein Terminal-Emulator (z.B. `xterm`, `gnome-terminal`) gestartet wird, der dann die eigentliche Anwendung ausführt.
        * Wenn `startup_notify` gesetzt ist, sendet es die Benachrichtigung an den WM (z.B. über D-Bus `org.freedesktop.Application` StartupNotify Protocol).
        * Erstellt eine `LaunchedApplication` Instanz.
        * Fügt die `LaunchedApplication` zu `monitored_processes` hinzu.
        * Startet einen Task, der den Prozess auf sein Beenden überwacht.
        * Sendet `SystemEvent::ApplicationLaunched` an den `EventBus`.
        * Gibt die `LaunchedApplication` zurück.
    * **Fehlerbehandlung:** `ApplicationNotFound`, `LaunchError`, `IoError`.

7.  **`ApplicationManager::terminate_process()` Methode:**
    * `pub async fn terminate_process(&self, pid: u32) -> Result<(), AppLauncherError>`
    * **Logik:**
        * Findet den Prozess in `monitored_processes`.
        * Sendet ein `SIGTERM` Signal an den Prozess.
        * Wartet kurz auf die Beendigung.
        * **Fehlerbehandlung:** `ProcessNotFound`, `PermissionDenied`, oder Fehler beim Senden des Signals.

8.  **`ApplicationManager::kill_process()` Methode:**
    * `pub async fn kill_process(&self, pid: u32) -> Result<(), AppLauncherError>`
    * **Logik:**
        * Findet den Prozess.
        * Sendet ein `SIGKILL` Signal an den Prozess.
        * **Fehlerbehandlung:** `ProcessNotFound`, `PermissionDenied`, oder Fehler beim Senden des Signals.

9.  **`ApplicationManager::monitor_process_exit()` (Private Hilfsmethode):**
    * `async fn monitor_process_exit(self: Arc<Self>, pid: u32, mut child_handle: tokio::process::Child)`
    * **Logik:**
        * Wartet auf die Beendigung des `child_handle` (z.B. `child_handle.wait().await`).
        * Entfernt den Prozess aus `monitored_processes`.
        * Sendet `SystemEvent::ApplicationTerminated(pid, exit_code)` an den `EventBus`.

10. **`ApplicationManager::update_desktop_file_paths()` Methode:**
    * `pub async fn update_desktop_file_paths(&self, new_paths: Vec<PathBuf>)`
    * **Logik:** Aktualisiert die `desktop_file_paths` und löst ein erneutes `scan_applications()` aus.

11. **`ApplicationManager::get_default_application()` Methode (für MIME-Typen):**
    * `pub fn get_default_application(&self, mime_type: &str) -> Result<Option<ApplicationInfo>, AppLauncherError>`
    * **Logik:**
        * Sucht in einer internen oder externen (z.B. XDG-konformen) MIME-Standard-Anwendungs-Datenbank.
        * Gibt die entsprechende `ApplicationInfo` zurück.
        * **Fehlerbehandlung:** Fehler beim Zugriff auf die MIME-Datenbank.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/app_launcher/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::app_launcher::error::AppLauncherError`
    * `crate::app_launcher::data_types::{ApplicationInfo, LaunchedApplication, ProcessStatus}`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::process::Command`
    * `tokio::task`
    * `tokio::sync::RwLock`
    * `std::collections::HashMap`
    * `std::path::PathBuf`
    * `std::sync::Arc`
    * `tracing`
    * `freedesktop-desktop-entry`
    * `glob` (für Wildcards in Pfaden)
    * `inotify-rs` oder ähnliches (für Dateisystem-Monitoring)

**Kommunikationsmuster:**

* Wird vom `AppLauncher` verwendet.
* Sendet `SystemEvent`s an den `EventBus` über Anwendungsstarts und -beendigungen.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Anwendungs-Manager, der Anwendungen finden, starten und ihren Lebenszyklus überwachen kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `EventBus` und des Dateisystems (für `.desktop`-Dateien).
    * Testen von `new`: Sicherstellen der Initialisierung und des initialen Scans.
    * Testen von `scan_applications` mit verschiedenen `.desktop`-Dateien (gültig, ungültig, fehlende Felder).
    * Testen von `list_applications` und `find_application`.
    * Testen von `launch_application`:
        * Korrekte Befehlskonstruktion.
        * Starten eines Dummy-Prozesses.
        * Behandlung von `terminal: true`.
        * Sendung von `SystemEvent::ApplicationLaunched`.
    * Testen von `terminate_process` und `kill_process` mit simulierten Prozessen.
    * Testen von `monitor_process_exit`: Sicherstellen, dass `SystemEvent::ApplicationTerminated` gesendet wird, wenn ein Prozess beendet wird.
    * Testen von `update_desktop_file_paths`.
    * Testen von `get_default_application`.
* **Integration Tests (mit realen Dummy-Anwendungen):**
    * Starten des `ApplicationManager`.
    * Starten einer einfachen Shell-Skript-Anwendung (z.B. `sleep 5`).
    * Überprüfen der Prozess-IDs und des `is_running` Status.
    * Testen des Terminate/Kill-Verhaltens.
    * Beobachten der `SystemEvent`s im `EventBus`.

**Geschätzter Aufwand:** Sehr Hoch (ca. 10-15 Tage, da komplexes `.desktop`-Parsing, Prozess-Management, Async-Operationen und Dateisystem-Monitoring)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `display_service`, widmen wir uns `app_launcher`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/app_launcher/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/app_launcher/data_types.rs`**: Definition der grundlegenden Datentypen für Anwendungen und Prozesse.
3.  **`novade-system/src/app_launcher/manager.rs`**: Die Kernlogik für das Auffinden, Starten und Überwachen von Anwendungen.
4.  **`novade-system/src/app_launcher/mod.rs`**: Das Hauptmodul, das den `ApplicationManager` initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/app_launcher` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/network_manager` Verzeichnisses, um die Netzwerk-Verwaltung zu kontrollieren.
---
### **novade-system/src/network_manager/mod.rs**

**Verantwortlichkeit:**
Das `network_manager` Modul ist die zentrale Schnittstelle für die Verwaltung von Netzwerkkonnektivität. Es interagiert mit dem zugrunde liegenden System-Netzwerkdienst (z.B. `NetworkManager` D-Bus API, `systemd-networkd`) um Netzwerkgeräte zu erkennen, Verbindungen zu verwalten (Wi-Fi, Ethernet, Bluetooth-Tethering), den Netzwerkstatus zu überwachen und netzwerkbezogene Einstellungen zu konfigurieren.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/network_manager/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Netzwerk-Operationen)
    * `manager.rs` (Logik für Geräte- und Verbindungsverwaltung)
    * `data_types.rs` (Definition von Netzwerk-bezogenen Datentypen)
    * `dbus_api.rs` (D-Bus-spezifische Interaktionen, z.B. für `NetworkManager` Daemon)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Netzwerk-Subsystems:**
    * `pub async fn initialize_network_manager(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<NetworkManagerService, NetworkError>`
    * **Logik:**
        * Stellt eine D-Bus-Verbindung zum `NetworkManager` Daemon her (oder einem anderen geeigneten Backend).
        * Erstellt eine Instanz von `manager::NetworkConnectionManager`, die die eigentliche Logik zur Geräte- und Verbindungsverwaltung enthält.
        * Ruft die initialen Netzwerkeinstellungen aus dem `config_service` ab (z.B. `known_wifi_networks`, `ethernet_priority`).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Netzwerkeinstellungen zu laden.
        * Registriert D-Bus-Signale vom `NetworkManager` Daemon, um Änderungen am Netzwerkstatus zu erkennen (z.B. `StateChanged`, `DeviceAdded`, `DeviceRemoved`, `PropertiesChanged`).
        * Gibt ein gebündeltes `NetworkManagerService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der D-Bus-Verbindung oder der Initialisierung des `NetworkConnectionManager`.

2.  **`NetworkManagerService` Struct:**
    * `pub struct NetworkManagerService {`
        * `manager: Arc<NetworkConnectionManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `dbus_connection: Arc<zbus::Connection>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Netzwerk-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `NetworkManagerService` exponiert Methoden zur Abfrage von Netzwerkinformationen und zur Steuerung von Netzwerkfunktionen.
    * **`get_network_status(&self) -> Result<NetworkStatus, NetworkError>`:**
        * **Logik:** Delegiert an den `NetworkConnectionManager`, um den aktuellen globalen Netzwerkstatus zurückzugeben (z.B. online, offline, verbunden mit WLAN, verbunden mit Ethernet).
    * **`list_network_devices(&self) -> Result<Vec<NetworkDeviceInfo>, NetworkError>`:**
        * **Logik:** Delegiert an den `NetworkConnectionManager`, um eine Liste aller erkannten Netzwerkgeräte zurückzugeben (Wi-Fi-Adapter, Ethernet-Ports, Bluetooth-Modems).
    * **`list_available_wifi_networks(&self, device_id: &str) -> Result<Vec<WifiNetworkInfo>, NetworkError>`:**
        * **Logik:** Delegiert an den `NetworkConnectionManager`, um eine Liste der verfügbaren Wi-Fi-Netzwerke für ein spezifisches Gerät zurückzugeben. Führt ggf. einen Scan durch.
    * **`connect_to_wifi(&self, device_id: &str, ssid: &str, password: Option<&str>) -> Result<(), NetworkError>`:**
        * **Logik:** Delegiert an den `NetworkConnectionManager`, um eine Verbindung zu einem Wi-Fi-Netzwerk herzustellen. Speichert das Netzwerk ggf. in der Konfiguration. Sendet `SystemEvent::NetworkConnected`.
        * **Fehlerbehandlung:** `ConnectionFailed`, `AuthenticationFailed`.
    * **`disconnect_wifi(&self, device_id: &str) -> Result<(), NetworkError>`:**
        * **Logik:** Delegiert an den `NetworkConnectionManager`, um die aktuelle Wi-Fi-Verbindung zu trennen. Sendet `SystemEvent::NetworkDisconnected`.
    * **`enable_wifi(&self, device_id: &str, enable: bool) -> Result<(), NetworkError>`:**
        * **Logik:** Delegiert an den `NetworkConnectionManager`, um einen Wi-Fi-Adapter zu aktivieren oder deaktivieren.
    * **`get_current_ip_address(&self, device_id: &str) -> Result<Option<String>, NetworkError>`:**
        * **Logik:** Delegiert an den `NetworkConnectionManager`, um die aktuelle IP-Adresse für ein Gerät abzufragen.
    * **`get_known_networks(&self) -> Result<Vec<KnownNetwork>, NetworkError>`:**
        * **Logik:** Ruft die Liste der bekannten Netzwerke (aus `config_service`) ab.
    * **`add_known_network(&self, network: KnownNetwork) -> Result<(), NetworkError>`:**
        * **Logik:** Fügt ein Netzwerk zur Konfiguration der bekannten Netzwerke hinzu. Speichert im `config_service`.
    * **`remove_known_network(&self, ssid: &str) -> Result<(), NetworkError>`:**
        * **Logik:** Entfernt ein Netzwerk aus der Konfiguration der bekannten Netzwerke. Speichert im `config_service`.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `NetworkManagerService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Netzwerkeinstellungen (z.B. `known_wifi_networks`) in der Konfiguration geändert werden, werden die Sub-Komponenten (z.B. `NetworkConnectionManager`) informiert.

5.  **Hintergrund-Task zum Abonnieren von D-Bus-Signalen:**
    * Ein weiterer Task sollte D-Bus-Signale vom `NetworkManager` Daemon abonnieren und diese in `SystemEvent`s übersetzen, um den `EventBus` zu informieren (z.B. `SystemEvent::NetworkConnected`, `SystemEvent::NetworkDisconnected`, `SystemEvent::WifiScanFinished`, `SystemEvent::NetworkDeviceAdded`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/network_manager/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::network_manager::error::NetworkError`
    * `crate::network_manager::manager::NetworkConnectionManager`
    * `crate::network_manager::data_types::{NetworkStatus, NetworkDeviceInfo, WifiNetworkInfo, KnownNetwork}`
    * `crate::network_manager::dbus_api` (wenn D-Bus-Interaktionen in einem separaten Modul gekapselt werden)
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus` (für D-Bus-Interaktion)
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Ist der primäre Consumer von Netzwerk-Anfragen von der Domänenschicht und der UI.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Netzwerkeinstellungen (z.B. bekannte WLANs).
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten und andere Systemdienste über Netzwerkstatusänderungen zu informieren (z.B. `SystemEvent::NetworkConnected`, `SystemEvent::NetworkDisconnected`, `SystemEvent::WifiScanFinished`).
* Empfängt D-Bus-Signale vom System-Netzwerkdienst.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Netzwerk-Manager-Subsystem, das Netzwerkkonnektivität verwalten und den Status überwachen kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit D-Bus Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `NetworkConnectionManager` und der `zbus` Verbindung.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und der D-Bus-Verbindung.
    * Testen der Weiterleitung von API-Aufrufen an den `NetworkConnectionManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von D-Bus-Signalen vom `NetworkManager` Daemon und Überprüfen, ob die korrekten `SystemEvent`s an den `EventBus` gesendet werden.
* **Integration Tests (mit realem `NetworkManager` Daemon):**
    * Starten des `NetworkManagerService` auf einem System mit laufendem `NetworkManager` Daemon.
    * Testen von `get_network_status`, `list_network_devices`, `list_available_wifi_networks`.
    * Manuelles Verbinden/Trennen von WLAN-Netzwerken und Überprüfen der `SystemEvent`s.
    * Testen der `connect_to_wifi` und `disconnect_wifi` Methoden mit realen Netzwerken (ggf. Test-SSIDs).
    * Testen des Aktivierens/Deaktivierens von Wi-Fi.

**Geschätzter Aufwand:** Sehr Hoch (ca. 10-15 Tage, da komplexe D-Bus-Interaktion, asynchrone Netzwerkoperationen und Event-Handling)

---
### **novade-system/src/network_manager/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `network_manager` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Netzwerk-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum NetworkError {`
        * `#[error("Failed to connect to D-Bus: {0}")]`
        * `DBusConnectError(#[from] zbus::Error),`
        * `#[error("Network device not found: {0}")]`
        * `DeviceNotFound(String),`
        * `#[error("Failed to scan for Wi-Fi networks: {0}")]`
        * `WifiScanError(String),`
        * `#[error("Failed to connect to network: {0}")]`
        * `ConnectionFailed(String),`
        * `#[error("Authentication failed for network: {0}")]`
        * `AuthenticationFailed(String),`
        * `#[error("Operation not supported by device: {0}")]`
        * `OperationNotSupported(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("NetworkManager D-Bus error: {0}")]`
        * `NetworkManagerDBusError(String),`
        * `#[error("Unknown network error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `zbus::Error`, `crate::config_service::error::ConfigError` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/network_manager/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `zbus::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `network_manager` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Netzwerk-System.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/network_manager/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `network_manager` verwendet werden, um Netzwerkgeräte, Verbindungen, Statusinformationen und Konfigurationsoptionen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkStatus` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum NetworkStatus {`
        * `Online,`
        * `LimitedConnectivity,`
        * `Offline,`
        * `Connecting(String),` // Z.B. "Connecting to Wifi: MyHomeNetwork"
        * `Unknown,`
    * `}`

2.  **`NetworkDeviceInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct NetworkDeviceInfo {`
        * `pub id: String,` // Gerätename (z.B. "wlo1", "eth0")
        * `pub name: String,` // Anzeigename (z.B. "Wi-Fi", "Ethernet")
        * `pub device_type: NetworkDeviceType,`
        * `pub state: NetworkDeviceState,`
        * `pub ipv4_address: Option<String>,`
        * `pub ipv6_address: Option<String>,`
        * `pub mac_address: String,`
        * `pub is_connected: bool,`
        * `pub current_connection_ssid: Option<String>,` // Für WLAN
        * `pub driver: Option<String>,`
    * `}`

3.  **`NetworkDeviceType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum NetworkDeviceType { Wifi, Ethernet, Bluetooth, Loopback, VPN, Bridge, Other }`

4.  **`NetworkDeviceState` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum NetworkDeviceState { Unavailable, Disconnected, Preparing, Connecting, Connected, Activated, Deactivating, Failed, Unknown }`

5.  **`WifiNetworkInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct WifiNetworkInfo {`
        * `pub ssid: String,`
        * `pub signal_strength_percent: u8,` // 0-100
        * `pub security: WifiSecurityType,`
        * `pub is_connected: bool,`
        * `pub bssid: String,`
        * `pub frequency_mhz: u32,`
    * `}`

6.  **`WifiSecurityType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum WifiSecurityType { None, WEP, WPA, WPA2, WPA3, Enterprise, Unknown }`

7.  **`KnownNetwork` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct KnownNetwork {`
        * `pub ssid: String,`
        * `pub network_type: NetworkDeviceType,`
        * `pub password: Option<String>,` // Verschlüsselt im Config-File
        * `pub autoconnect: bool,`
        * `pub priority: i32,`
        * `pub ipv4_method: IpConfigMethod,`
        * `pub ipv6_method: IpConfigMethod,`
        * `// Weitere spezifische Felder je nach Netzwerktyp (z.B. VPN-Details)`
    * `}`

8.  **`IpConfigMethod` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum IpConfigMethod { Dhcp, Manual, LinkLocal, Disabled }`

9.  **`ManualIpConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct ManualIpConfig {`
        * `pub address: String,` // Z.B. "192.168.1.100/24"
        * `pub gateway: String,`
        * `pub dns_servers: Vec<String>,`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/network_manager/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Netzwerk-Informationen und Konfigurationen im System.
* Sie werden vom `NetworkConnectionManager` erzeugt und von der API des `NetworkManagerService` verwendet.
* `KnownNetwork` wird im `ConfigService` gespeichert.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Netzwerk-Verwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Mittel (ca. 3-4 Tage, da detaillierte Netzwerk-Datenstrukturen benötigt werden)

---
### **novade-system/src/network_manager/manager.rs**

**Verantwortlichkeit:**
Der `NetworkConnectionManager` ist die Kernlogik des Netzwerk-Subsystems. Er abstrahiert die Interaktion mit dem System-Netzwerkdienst (z.B. NetworkManager D-Bus-Schnittstelle) und verwaltet den Zustand der Netzwerkgeräte und Verbindungen. Er ist dafür verantwortlich, Anfragen von `mod.rs` in Aufrufe an das Backend zu übersetzen und dessen Antworten in NovaDE-Datentypen umzuwandeln.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkConnectionManager` Struct:**
    * `pub struct NetworkConnectionManager {`
        * `dbus_proxy: Arc<dbus_api::NetworkManagerProxy>,` // Proxy für NetworkManager D-Bus API
        * `active_devices: RwLock<HashMap<String, NetworkDeviceInfo>>,`
        * `known_networks_config: RwLock<HashMap<String, KnownNetwork>>,` // SSD -> KnownNetwork
        * `event_bus: EventBus,`
        * `current_network_status: AtomicCell<NetworkStatus>,`
        * `// Optional: Listener für D-Bus-Signale von NetworkManager`
    * `}`

2.  **`NetworkConnectionManager::new()` Funktion:**
    * `pub async fn new(initial_known_networks: Vec<KnownNetwork>, event_bus: EventBus, dbus_connection: Arc<zbus::Connection>) -> Result<Self, NetworkError>`
    * **Logik:**
        * Erstellt einen D-Bus-Proxy für den `NetworkManager` Daemon.
        * Initialisiert `active_devices` durch Abfragen aller vorhandenen Geräte über den D-Bus-Proxy.
        * Füllt `known_networks_config`.
        * Initialisiert `current_network_status` durch Abfragen des aktuellen Status.
        * Startet Hintergrund-Tasks zum Abonnieren relevanter D-Bus-Signale (z.B. DeviceAdded, DeviceRemoved, StateChanged, PropertiesChanged) und zur Aktualisierung des internen Zustands sowie zum Senden von `SystemEvent`s an den `EventBus`.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `DBusConnectError`, `NetworkManagerDBusError`.

3.  **`NetworkConnectionManager::get_network_status()` Methode:**
    * `pub fn get_network_status(&self) -> NetworkStatus`
    * **Logik:** Gibt den Wert von `current_network_status` zurück.

4.  **`NetworkConnectionManager::list_network_devices()` Methode:**
    * `pub async fn list_network_devices(&self) -> Result<Vec<NetworkDeviceInfo>, NetworkError>`
    * **Logik:**
        * Ruft über den D-Bus-Proxy die Liste der Netzwerkgeräte vom `NetworkManager` Daemon ab.
        * Konvertiert die D-Bus-Repräsentation in `NetworkDeviceInfo` Structs.
        * Aktualisiert die interne `active_devices` HashMap.
        * Gibt die Liste zurück.
    * **Fehlerbehandlung:** `NetworkManagerDBusError`.

5.  **`NetworkConnectionManager::list_available_wifi_networks()` Methode:**
    * `pub async fn list_available_wifi_networks(&self, device_id: &str) -> Result<Vec<WifiNetworkInfo>, NetworkError>`
    * **Logik:**
        * Findet das WLAN-Gerät über `device_id`.
        * Ruft über den D-Bus-Proxy einen Scan der verfügbaren WLAN-Netzwerke auf dem Gerät auf.
        * Wartet auf den Abschluss des Scans und ruft die Ergebnisse ab.
        * Konvertiert die Ergebnisse in `WifiNetworkInfo` Structs.
        * Sendet `SystemEvent::WifiScanFinished`.
        * Gibt die Liste zurück.
    * **Fehlerbehandlung:** `DeviceNotFound`, `OperationNotSupported`, `WifiScanError`, `NetworkManagerDBusError`.

6.  **`NetworkConnectionManager::connect_to_wifi()` Methode:**
    * `pub async fn connect_to_wifi(&self, device_id: &str, ssid: &str, password: Option<&str>) -> Result<(), NetworkError>`
    * **Logik:**
        * Findet das WLAN-Gerät.
        * Verwendet den D-Bus-Proxy, um eine neue Verbindung zu erstellen oder eine bestehende zu aktivieren.
        * Übergibt die SSID und optional das Passwort.
        * Überwacht den Verbindungsstatus über D-Bus-Signale.
        * Speichert die Verbindung in `known_networks_config` (wenn noch nicht vorhanden und Autoconnect gewünscht).
        * Sendet `SystemEvent::NetworkConnected`.
        * **Fehlerbehandlung:** `DeviceNotFound`, `AuthenticationFailed`, `ConnectionFailed`, `NetworkManagerDBusError`.

7.  **`NetworkConnectionManager::disconnect_wifi()` Methode:**
    * `pub async fn disconnect_wifi(&self, device_id: &str) -> Result<(), NetworkError>`
    * **Logik:**
        * Findet das Gerät.
        * Verwendet den D-Bus-Proxy, um die Verbindung zu trennen.
        * Sendet `SystemEvent::NetworkDisconnected`.
        * **Fehlerbehandlung:** `DeviceNotFound`, `NetworkManagerDBusError`.

8.  **`NetworkConnectionManager::enable_wifi()` Methode:**
    * `pub async fn enable_wifi(&self, device_id: &str, enable: bool) -> Result<(), NetworkError>`
    * **Logik:**
        * Verwendet den D-Bus-Proxy, um den Wi-Fi-Status des Geräts zu ändern.
        * **Fehlerbehandlung:** `DeviceNotFound`, `NetworkManagerDBusError`.

9.  **`NetworkConnectionManager::get_current_ip_address()` Methode:**
    * `pub async fn get_current_ip_address(&self, device_id: &str) -> Result<Option<String>, NetworkError>`
    * **Logik:** Fragt die IP-Adresse des Geräts über den D-Bus-Proxy ab.

10. **`NetworkConnectionManager::update_known_networks()` Methode:**
    * `pub async fn update_known_networks(&self, new_known_networks: Vec<KnownNetwork>)`
    * **Logik:** Aktualisiert die interne `known_networks_config` HashMap. Dies wird durch `SystemEvent::ConfigChanged` ausgelöst.

11. **Hintergrund-Task zum D-Bus-Signal-Monitoring:**
    * Ein dedizierter Task, der kontinuierlich D-Bus-Signale vom `NetworkManager` Daemon empfängt (z.B. `PropertiesChanged`, `StateChanged`, `DeviceAdded`, `DeviceRemoved`, `AccessPointAdded`, `AccessPointRemoved`).
    * Diese Signale werden dann in `SystemEvent`s übersetzt und an den `event_bus` gesendet.
    * Beispiele für Events: `SystemEvent::NetworkConnected`, `SystemEvent::NetworkDisconnected`, `SystemEvent::NetworkDeviceAdded`, `SystemEvent::NetworkDeviceRemoved`, `SystemEvent::WifiAccessPointChanged`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/network_manager/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::network_manager::error::NetworkError`
    * `crate::network_manager::data_types::{NetworkStatus, NetworkDeviceInfo, NetworkDeviceType, NetworkDeviceState, WifiNetworkInfo, KnownNetwork}`
    * `crate::network_manager::dbus_api::NetworkManagerProxy`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus`
    * `tokio::task`
    * `tokio::sync::RwLock`
    * `crossbeam_utils::atomic::AtomicCell`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `tracing`

**Kommunikationsmuster:**

* Wird vom `NetworkManagerService` verwendet.
* Kommuniziert direkt mit dem System-NetworkManager über D-Bus.
* Sendet `SystemEvent`s an den `EventBus` bei Zustandsänderungen im Netzwerk.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Netzwerkverbindungs-Manager, der den Netzwerkstatus abrufen, Geräte und Verbindungen verwalten und auf Systemereignisse reagieren kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit D-Bus Proxy Mocking):**
    * Mocken des `dbus_api::NetworkManagerProxy` und `EventBus`.
    * Testen von `new`: Sicherstellen der Initialisierung und des initialen Scans/Statusabfrage.
    * Testen von `list_network_devices`, `list_available_wifi_networks`: Simulieren von D-Bus-Antworten und Überprüfen der korrekten Datenkonvertierung.
    * Testen von `connect_to_wifi`, `disconnect_wifi`: Simulieren erfolgreicher/fehlerhafter D-Bus-Aufrufe und der Sendung von `SystemEvent`s.
    * Testen des internen D-Bus-Signal-Monitoring-Tasks (simulieren von D-Bus-Signalen und Überprüfen der `SystemEvent`s).
    * Testen von `update_known_networks`.
* **Integration Tests (mit realem `NetworkManager` Daemon):**
    * Starten des `NetworkConnectionManager` und Überprüfen, ob er den realen Netzwerkstatus korrekt widerspiegelt.
    * Verbinden/Trennen von WLANs manuell oder über `nmcli`/`gnome-control-center` und Überprüfen, ob die `SystemEvent`s korrekt im `EventBus` ankommen.
    * Testen des Scannens von WLANs.

**Geschätzter Aufwand:** Sehr Hoch (ca. 12-18 Tage, da tiefe D-Bus-Interaktion, asynchrone Zustandsverwaltung und Signal-Handling)

---
### **novade-system/src/network_manager/dbus_api.rs**

**Verantwortlichkeit:**
Dieses Modul kapselt die direkte Interaktion mit der D-Bus-API des `NetworkManager` Daemons. Es stellt eine Typsichere Schnittstelle für die `NetworkConnectionManager` bereit, um die Komplexität der D-Bus-Kommunikation zu verbergen. Es sollte `zbus` oder ähnliche D-Bus-Client-Bibliotheken verwenden.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkManagerProxy` Struct:**
    * `pub struct NetworkManagerProxy<'a> {`
        * `inner: NetworkManagerOrgNetworkManager<'a>,` // zbus generated proxy
        * `// Weitere Proxies für spezifische Objekte (z.B. WifiDevice, ActiveConnection)`
    * `}`

2.  **`NetworkManagerProxy::new()` Funktion:**
    * `pub async fn new(connection: &Arc<zbus::Connection>) -> Result<Self, NetworkError>`
    * **Logik:** Erstellt die `zbus`-Proxies für den `org.freedesktop.NetworkManager` Service und die benötigten Interfaces.

3.  **Methoden zum Interagieren mit dem NetworkManager Daemon:**
    * Diese Methoden sind direkte Wrapper um die D-Bus-Methoden des `NetworkManager` Daemons.
    * **`get_state(&self) -> Result<u32, NetworkError>`:**
        * Ruft den globalen Status ab (entspricht `NetworkManager.State` Property).
    * **`get_all_devices(&self) -> Result<Vec<zbus::zvariant::OwnedObjectPath>, NetworkError>`:**
        * Ruft eine Liste von D-Bus-Objektpfaden für alle Netzwerkgeräte ab.
    * **`get_device_properties(&self, device_path: &zbus::zvariant::OwnedObjectPath) -> Result<HashMap<String, zbus::zvariant::OwnedValue>, NetworkError>`:**
        * Ruft die Eigenschaften eines spezifischen Geräts ab (z.B. Typ, State, IP-Adressen).
    * **`request_wifi_scan(&self, wifi_device_path: &zbus::zvariant::OwnedObjectPath) -> Result<(), NetworkError>`:**
        * Löst einen WLAN-Scan auf einem bestimmten WLAN-Gerät aus.
    * **`get_access_points(&self, wifi_device_path: &zbus::zvariant::OwnedObjectPath) -> Result<Vec<zbus::zvariant::OwnedObjectPath>, NetworkError>`:**
        * Ruft eine Liste von D-Bus-Objektpfaden für verfügbare Access Points ab.
    * **`get_access_point_properties(&self, ap_path: &zbus::zvariant::OwnedObjectPath) -> Result<HashMap<String, zbus::zvariant::OwnedValue>, NetworkError>`:**
        * Ruft die Eigenschaften eines Access Points ab (SSID, Signalstärke, Sicherheit).
    * **`activate_connection(&self, connection_path: &zbus::zvariant::OwnedObjectPath, device_path: &zbus::zvariant::OwnedObjectPath, specific_object: &zbus::zvariant::OwnedObjectPath) -> Result<zbus::zvariant::OwnedObjectPath, NetworkError>`:**
        * Aktiviert eine spezifische Netzwerkverbindung.
    * **`deactivate_connection(&self, active_connection_path: &zbus::zvariant::OwnedObjectPath) -> Result<(), NetworkError>`:**
        * Deaktiviert eine aktive Netzwerkverbindung.
    * **`add_and_activate_connection(&self, connection_settings: HashMap<String, HashMap<String, zbus::zvariant::OwnedValue>>, device_path: &zbus::zvariant::OwnedObjectPath) -> Result<(zbus::zvariant::OwnedObjectPath, zbus::zvariant::OwnedObjectPath), NetworkError>`:**
        * Erstellt eine neue Verbindung und versucht, sie zu aktivieren.
    * **`enable_wifi_device(&self, device_path: &zbus::zvariant::OwnedObjectPath, enable: bool) -> Result<(), NetworkError>`:**
        * Setzt den Wi-Fi-Status eines Geräts.
    * **Hinweis:** Für jede D-Bus-Methode und jedes Property, das im `NetworkConnectionManager` benötigt wird, muss hier eine entsprechende Wrapper-Methode erstellt werden. Die Konvertierung von `zbus::zvariant::OwnedValue` in spezifische Rust-Typen erfolgt hier.

4.  **Methoden zum Abonnieren von D-Bus-Signalen:**
    * `pub async fn receive_state_changed_signals(&self) -> impl Stream<Item = u32>`
    * `pub async fn receive_device_added_signals(&self) -> impl Stream<Item = zbus::zvariant::OwnedObjectPath>`
    * `// ... weitere für DeviceRemoved, PropertiesChanged (auf Geräten, Access Points etc.)`
    * **Logik:** Erstellt `zbus::fdo::PropertiesChanged` oder spezifische Signal-Streams, die vom `NetworkConnectionManager` abonniert werden können.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/network_manager/dbus_api.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::network_manager::error::NetworkError`
* **Extern:**
    * `zbus` (insbesondere die generierten Proxies wie `zbus::fdo::NetworkManager::OrgNetworkManager`)
    * `zbus::zvariant::{OwnedObjectPath, OwnedValue}`
    * `futures::stream::Stream`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `tracing`

**Kommunikationsmuster:**

* Wird ausschließlich vom `NetworkConnectionManager` verwendet.
* Kümmert sich um die Low-Level-D-Bus-Kommunikation.

**Erwartete Ergebnisse/Outputs:**
Eine typsichere und einfach zu bedienende Schnittstelle zur D-Bus-API des `NetworkManager` Daemons.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit `zbus::Connection` Mocking):**
    * Mocken der `zbus::Connection` und der erwarteten D-Bus-Antworten.
    * Testen jeder Wrapper-Methode in `NetworkManagerProxy`, um sicherzustellen, dass die D-Bus-Aufrufe korrekt formuliert und die Antworten korrekt geparst werden.
    * Simulieren des Empfangs von D-Bus-Signalen und Überprüfen, ob die Streams die korrekten Daten liefern.
* **Integration Tests (mit realem `NetworkManager` Daemon):**
    * Starten des `NetworkManagerProxy` und Ausführen einiger einfacher Abfragen (z.B. `get_state`, `get_all_devices`) um die reale Kommunikation zu verifizieren.
    * Dies sollte sicherstellen, dass die `zbus`-Proxies korrekt generiert und die D-Bus-Spezifikation eingehalten wird.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da detaillierte Kenntnis der NetworkManager D-Bus-API und sorgfältige Wrapper-Erstellung erforderlich)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `app_launcher`, widmen wir uns `network_manager`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/network_manager/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/network_manager/data_types.rs`**: Definition der grundlegenden Datentypen für Netzwerkgeräte und Verbindungen.
3.  **`novade-system/src/network_manager/dbus_api.rs`**: Kapselung der direkten D-Bus-Interaktionen, da dies eine wichtige Abstraktion für den Manager ist.
4.  **`novade-system/src/network_manager/manager.rs`**: Die Kernlogik zur Verwaltung von Netzwerkverbindungen und -geräten, die den `dbus_api` nutzt.
5.  **`novade-system/src/network_manager/mod.rs`**: Das Hauptmodul, das den `NetworkConnectionManager` initialisiert, D-Bus-Signale überwacht und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/network_manager` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/audio_service` Verzeichnisses, um die Audio-Verwaltung zu kontrollieren.
---
### **novade-system/src/audio_service/mod.rs**

**Verantwortlichkeit:**
Das `audio_service` Modul ist für die systemweite Audioverwaltung zuständig. Es abstrahiert die zugrunde liegende Audio-API (z.B. PipeWire, PulseAudio oder ALSA) und bietet eine einheitliche Schnittstelle für andere NovaDE-Komponenten zur Steuerung von Lautstärke, Wiedergabe/Aufnahme-Geräten, Audio-Streams und Benachrichtigungssounds.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/audio_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Audio-Operationen)
    * `manager.rs` (Interne Logik für Audiogeräte- und Stream-Verwaltung)
    * `data_types.rs` (Definition von Audio-bezogenen Datentypen)
    * `pipewire_backend.rs` (Implementierung für PipeWire)
    * `pulseaudio_backend.rs` (Implementierung für PulseAudio - Optional, wenn beide unterstützt werden)
    * `alsa_backend.rs` (Implementierung für ALSA - Optional)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Audio-Subsystems:**
    * `pub async fn initialize_audio_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<AudioService, AudioError>`
    * **Logik:**
        * Erkennt das verfügbare Audio-Backend (PipeWire, PulseAudio, ALSA) und initialisiert den entsprechenden Backend-Client (`pipewire_backend::PipewireClient` etc.).
        * Erstellt eine Instanz von `manager::AudioManager`, die die Abstraktion über dem Backend bildet und den Zustand verwaltet.
        * Ruft die initialen Audio-Einstellungen aus dem `config_service` ab (z.B. `master_volume_percent`, `default_output_device`, `notification_sound_enabled`).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Audio-Einstellungen zu laden.
        * Registriert sich für Events vom Audio-Backend (z.B. Gerät hinzugefügt/entfernt, Lautstärke geändert, Stream gestartet/beendet).
        * Gibt ein gebündeltes `AudioService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Verbindung zum Audio-Server oder der Initialisierung des `AudioManager`.

2.  **`AudioService` Struct:**
    * `pub struct AudioService {`
        * `manager: Arc<AudioManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
    * `}`
    * Dient als Container und Zugangspunkt für die Audio-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `AudioService` exponiert Methoden zur Abfrage von Audio-Informationen und zur Steuerung von Audio-Funktionen.
    * **`get_master_volume_percent(&self) -> Result<u8, AudioError>`:**
        * **Logik:** Delegiert an den `AudioManager`, um die aktuelle globale Master-Lautstärke abzufragen.
    * **`set_master_volume_percent(&self, volume_percent: u8) -> Result<(), AudioError>`:**
        * **Logik:** Delegiert an den `AudioManager`, um die globale Master-Lautstärke anzupassen. Sendet `SystemEvent::MasterVolumeChanged`.
        * Speichert die Lautstärke persistierend im `config_service`.
    * **`toggle_master_mute(&self) -> Result<bool, AudioError>`:**
        * **Logik:** Delegiert an den `AudioManager`, um den globalen Master-Mute-Status umzuschalten. Sendet `SystemEvent::MasterMuteToggled`.
    * **`is_master_muted(&self) -> Result<bool, AudioError>`:**
        * **Logik:** Delegiert an den `AudioManager`, um den aktuellen Master-Mute-Status abzufragen.
    * **`list_audio_devices(&self, device_type: DeviceType) -> Result<Vec<AudioDeviceInfo>, AudioError>`:**
        * **Logik:** Delegiert an den `AudioManager`, um eine Liste der erkannten Wiedergabe- oder Aufnahme-Geräte zurückzugeben.
    * **`set_default_output_device(&self, device_id: &str) -> Result<(), AudioError>`:**
        * **Logik:** Delegiert an den `AudioManager`, um das Standard-Wiedergabegerät zu setzen. Sendet `SystemEvent::DefaultOutputDeviceChanged`.
        * Speichert die Einstellung im `config_service`.
    * **`set_default_input_device(&self, device_id: &str) -> Result<(), AudioError>`:**
        * **Logik:** Delegiert an den `AudioManager`, um das Standard-Aufnahmegerät zu setzen. Sendet `SystemEvent::DefaultInputDeviceChanged`.
        * Speichert die Einstellung im `config_service`.
    * **`play_sound_effect(&self, sound_effect: SoundEffectType) -> Result<(), AudioError>`:**
        * **Logik:** Delegiert an den `AudioManager`, um einen vordefinierten Soundeffekt abzuspielen (z.B. für Benachrichtigungen, Klick-Sounds). Überprüft `notification_sound_enabled` aus der Konfiguration.
    * **`list_audio_streams(&self, stream_type: StreamType) -> Result<Vec<AudioStreamInfo>, AudioError>`:**
        * **Logik:** Delegiert an den `AudioManager`, um eine Liste der aktiven Audio-Streams (Wiedergabe oder Aufnahme) zurückzugeben.
    * **`set_stream_volume(&self, stream_id: u32, volume_percent: u8) -> Result<(), AudioError>`:**
        * **Logik:** Delegiert an den `AudioManager`, um die Lautstärke eines spezifischen Streams anzupassen.
    * **`toggle_stream_mute(&self, stream_id: u32) -> Result<(), AudioError>`:**
        * **Logik:** Delegiert an den `AudioManager`, um den Mute-Status eines spezifischen Streams umzuschalten.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `AudioService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Audio-Einstellungen in der Konfiguration geändert werden, werden die Sub-Komponenten (`AudioManager`) informiert.

5.  **Hintergrund-Task zum Abonnieren von Backend-Events:**
    * Ein weiterer Task sollte Events vom ausgewählten Audio-Backend (PipeWire, PulseAudio) abonnieren und diese in `SystemEvent`s übersetzen, um den `EventBus` zu informieren (z.B. `SystemEvent::AudioDeviceAdded`, `SystemEvent::AudioDeviceRemoved`, `SystemEvent::MasterVolumeChanged`, `SystemEvent::StreamStarted`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::audio_service::error::AudioError`
    * `crate::audio_service::manager::AudioManager`
    * `crate::audio_service::data_types::{AudioDeviceInfo, DeviceType, AudioStreamInfo, StreamType, SoundEffectType}`
    * `crate::audio_service::pipewire_backend::PipewireClient` (oder andere Backends)
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Ist der primäre Consumer von Audio-Anfragen von der Domänenschicht und der UI.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Audio-Einstellungen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten und andere Systemdienste über Audio-Statusänderungen zu informieren (z.B. `SystemEvent::MasterVolumeChanged`, `SystemEvent::AudioDeviceAdded`).
* Empfängt Events vom gewählten Audio-Backend.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Audio-Subsystem, das die Audiowiedergabe und -aufnahme steuern und den Status überwachen kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus` und des gewählten Audio-Backend-Clients.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und der Backend-Verbindung.
    * Testen der Weiterleitung von API-Aufrufen an den `AudioManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von Events vom Audio-Backend und Überprüfen, ob die korrekten `SystemEvent`s an den `EventBus` gesendet werden.
* **Integration Tests (mit realem Audio-System):**
    * Starten des `AudioService` auf einem System mit laufendem PipeWire/PulseAudio.
    * Testen von `get_master_volume_percent`, `set_master_volume_percent`, `toggle_master_mute` (visuell und/oder durch Abfragen über `pactl`/`wpctl`).
    * Testen von `list_audio_devices`.
    * Abspielen von Soundeffekten und Überprüfen der Audioausgabe.
    * Starten einer Anwendung, die Audio abspielt, und Testen der `list_audio_streams` und `set_stream_volume` Methoden.

**Geschätzter Aufwand:** Sehr Hoch (ca. 10-15 Tage, da Interaktion mit komplexen Audio-APIs, Event-Handling und Zustandsverwaltung)

---
### **novade-system/src/audio_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `audio_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Audio-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`AudioError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum AudioError {`
        * `#[error("Failed to connect to audio server: {0}")]`
        * `ServerConnectError(String),` // Z.B. PipeWire/PulseAudio Daemon nicht erreichbar
        * `#[error("Audio device not found: {0}")]`
        * `DeviceNotFound(String),`
        * `#[error("Audio stream not found: {0}")]`
        * `StreamNotFound(u32),`
        * `#[error("Invalid volume percentage: {0}")]`
        * `InvalidVolume(u8),`
        * `#[error("Failed to set audio property: {0}")]`
        * `SetPropertyError(String),`
        * `#[error("Failed to play sound effect: {0}")]`
        * `SoundEffectPlayError(String),`
        * `#[error("Backend specific error: {0}")]`
        * `BackendError(String),` // Wrapper für PipeWire/PulseAudio/ALSA spezifische Fehler
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("I/O error: {0}")]`
        * `IoError(#[from] std::io::Error),`
        * `#[error("Unknown audio error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `std::io::Error` und `anyhow::Error`. Füge spezifische Fehler von `pipewire`, `libpulse-binding` etc. hinzu.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::io::Error`
    * `pipewire` crate's error types (wenn genutzt)
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `audio_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Audio-System.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/audio_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `audio_service` verwendet werden, um Audiogeräte, Audio-Streams, Lautstärke-Informationen und Soundeffekte zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`AudioDeviceInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct AudioDeviceInfo {`
        * `pub id: String,` // Eindeutiger Bezeichner des Geräts (z.B. Node ID in PipeWire, Index in PulseAudio)
        * `pub name: String,` // Anzeigename (z.B. "Built-in Audio Analog Stereo")
        * `pub description: Option<String>,`
        * `pub device_type: DeviceType,`
        * `pub is_default: bool,`
        * `pub is_muted: bool,`
        * `pub volume_percent: u8,` // 0-100
        * `pub port_name: Option<String>,` // Aktiver Port (z.B. "Headphones", "Speakers")
        * `pub priority: i32,` // Gerätepriorität
    * `}`

2.  **`DeviceType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum DeviceType { Output, Input, Unknown }`

3.  **`AudioStreamInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct AudioStreamInfo {`
        * `pub id: u32,` // Eindeutiger Stream-ID
        * `pub name: String,` // Anwendungsname oder Stream-Name
        * `pub stream_type: StreamType,`
        * `pub application_id: Option<String>,` // App ID, falls bekannt
        * `pub device_id: String,` // ID des Geräts, an das der Stream gebunden ist
        * `pub is_muted: bool,`
        * `pub volume_percent: u8,`
        * `pub latency_ms: Option<u32>,`
    * `}`

4.  **`StreamType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum StreamType { Playback, Recording, Unknown }`

5.  **`SoundEffectType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum SoundEffectType {`
        * `Notification,`
        * `ButtonClick,`
        * `Login,`
        * `Logout,`
        * `Error,`
        * `// ... weitere spezifische Soundeffekte`
    * `}`

6.  **`AudioConfig` Struct (aus `config_service/data_types.rs`):**
    * Sollte hier nur referenziert werden, da es bereits an anderer Stelle definiert ist.
    * `pub struct AudioConfig {`
        * `pub master_volume_percent: u8,`
        * `pub master_muted: bool,`
        * `pub default_output_device_id: Option<String>,`
        * `pub default_input_device_id: Option<String>,`
        * `pub notification_sound_enabled: bool,`
        * `pub sound_effect_volume_percent: u8,`
        * `// ... weitere Einstellungen`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Audio-Informationen und Konfigurationen im System.
* Sie werden vom `AudioManager` erzeugt und von der API des `AudioService` verwendet.
* `AudioConfig` wird im `ConfigService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Audio-Verwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage, da detaillierte Audio-Datenstrukturen benötigt werden)

---
### **novade-system/src/audio_service/manager.rs**

**Verantwortlichkeit:**
Der `AudioManager` ist die Kernlogik des Audio-Subsystems. Er abstrahiert die Interaktion mit dem spezifischen Audio-Backend (z.B. PipeWireClient) und verwaltet den Zustand der Audiogeräte und -streams. Er ist dafür verantwortlich, Anfragen von `mod.rs` in Aufrufe an das Backend zu übersetzen und dessen Antworten in NovaDE-Datentypen umzuwandeln.

**Kern-Aufgaben (Tasks):**

1.  **`AudioManager` Struct:**
    * `pub struct AudioManager {`
        * `backend: Arc<dyn AudioBackend + Send + Sync>,` // Trait-Objekt für das gewählte Backend
        * `active_devices: RwLock<HashMap<String, AudioDeviceInfo>>,` // id -> AudioDeviceInfo
        * `active_streams: RwLock<HashMap<u32, AudioStreamInfo>>,` // id -> AudioStreamInfo
        * `event_bus: EventBus,`
        * `current_master_volume_percent: AtomicU8,`
        * `current_master_muted: AtomicBool,`
        * `notification_sound_enabled: AtomicBool,`
        * `sound_effect_volume_percent: AtomicU8,`
    * `}`

2.  **`AudioManager::new()` Funktion:**
    * `pub async fn new(backend: Arc<dyn AudioBackend + Send + Sync>, initial_audio_config: AudioConfig, event_bus: EventBus) -> Result<Self, AudioError>`
    * **Logik:**
        * Initialisiert mit dem bereitgestellten Backend und `EventBus`.
        * Füllt `active_devices` und `active_streams` durch Abfragen des Backends.
        * Setzt `current_master_volume_percent`, `current_master_muted`, `notification_sound_enabled` und `sound_effect_volume_percent` basierend auf `initial_audio_config`.
        * Startet Hintergrund-Tasks zum Abonnieren von Backend-Events (Geräteänderungen, Lautstärkeänderungen, Stream-Änderungen) und zur Aktualisierung des internen Zustands sowie zum Senden von `SystemEvent`s an den `EventBus`.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `ServerConnectError` oder `BackendError` bei Backend-Initialisierung.

3.  **`AudioBackend` Trait:**
    * `pub trait AudioBackend: Debug + Send + Sync {`
        * `async fn get_master_volume(&self) -> Result<u8, AudioError>;`
        * `async fn set_master_volume(&self, volume_percent: u8) -> Result<(), AudioError>;`
        * `async fn get_master_mute(&self) -> Result<bool, AudioError>;`
        * `async fn set_master_mute(&self, muted: bool) -> Result<(), AudioError>;`
        * `async fn list_devices(&self, device_type: DeviceType) -> Result<Vec<AudioDeviceInfo>, AudioError>;`
        * `async fn set_default_device(&self, device_id: &str, device_type: DeviceType) -> Result<(), AudioError>;`
        * `async fn play_sound_file(&self, file_path: &Path) -> Result<(), AudioError>;`
        * `async fn list_streams(&self, stream_type: StreamType) -> Result<Vec<AudioStreamInfo>, AudioError>;`
        * `async fn set_stream_volume(&self, stream_id: u32, volume_percent: u8) -> Result<(), AudioError>;`
        * `async fn set_stream_mute(&self, stream_id: u32, muted: bool) -> Result<(), AudioError>;`
        * `// Async stream von Events, z.B. für volume_changed, device_added, stream_started`
        * `fn subscribe_to_events(&self) -> Box<dyn Stream<Item = BackendEvent> + Send + Unpin>;`
    * `}`

4.  **`AudioManager::get_master_volume_percent()` Methode:**
    * `pub fn get_master_volume_percent(&self) -> u8`
    * **Logik:** Gibt den Wert von `current_master_volume_percent` zurück.

5.  **`AudioManager::set_master_volume_percent()` Methode:**
    * `pub async fn set_master_volume_percent(&self, volume_percent: u8) -> Result<(), AudioError>`
    * **Logik:**
        * Ruft `self.backend.set_master_volume(volume_percent)` auf.
        * Aktualisiert `current_master_volume_percent`.
        * Sendet `SystemEvent::MasterVolumeChanged(volume_percent)` an den `EventBus`.

6.  **`AudioManager::toggle_master_mute()` Methode:**
    * `pub async fn toggle_master_mute(&self) -> Result<bool, AudioError>`
    * **Logik:**
        * Ruft den aktuellen Mute-Status über das Backend ab.
        * Ruft `self.backend.set_master_mute(!current_mute_status)` auf.
        * Aktualisiert `current_master_muted`.
        * Sendet `SystemEvent::MasterMuteToggled(!current_mute_status)`.
        * Gibt den neuen Status zurück.

7.  **`AudioManager::list_audio_devices()` Methode:**
    * `pub async fn list_audio_devices(&self, device_type: DeviceType) -> Result<Vec<AudioDeviceInfo>, AudioError>`
    * **Logik:** Ruft `self.backend.list_devices(device_type)` auf und gibt die Ergebnisse zurück.

8.  **`AudioManager::set_default_output_device()` / `set_default_input_device()` Methoden:**
    * `pub async fn set_default_output_device(&self, device_id: &str) -> Result<(), AudioError>`
    * `pub async fn set_default_input_device(&self, device_id: &str) -> Result<(), AudioError>`
    * **Logik:** Rufen `self.backend.set_default_device(device_id, DeviceType::Output/Input)` auf und senden entsprechende `SystemEvent`s.

9.  **`AudioManager::play_sound_effect()` Methode:**
    * `pub async fn play_sound_effect(&self, sound_effect: SoundEffectType) -> Result<(), AudioError>`
    * **Logik:**
        * Überprüft `notification_sound_enabled`. Wenn false und es eine Benachrichtigung ist, Abbruch.
        * Bestimmt den Dateipfad für den Soundeffekt (aus internen Ressourcen oder Konfiguration).
        * Ruft `self.backend.play_sound_file(file_path)` auf.
        * **Fehlerbehandlung:** `SoundEffectPlayError`.

10. **`AudioManager::list_audio_streams()` Methode:**
    * `pub async fn list_audio_streams(&self, stream_type: StreamType) -> Result<Vec<AudioStreamInfo>, AudioError>`
    * **Logik:** Ruft `self.backend.list_streams(stream_type)` auf und gibt die Ergebnisse zurück.

11. **`AudioManager::set_stream_volume()` / `toggle_stream_mute()` Methoden:**
    * `pub async fn set_stream_volume(&self, stream_id: u32, volume_percent: u8) -> Result<(), AudioError>`
    * `pub async fn toggle_stream_mute(&self, stream_id: u32) -> Result<(), AudioError>`
    * **Logik:** Delegieren an das Backend und aktualisieren den internen Stream-Zustand.

12. **`AudioManager::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: AudioConfig)`
    * **Logik:** Aktualisiert die internen `Atomic` Werte für `master_volume_percent`, `master_muted`, `notification_sound_enabled`, `sound_effect_volume_percent`. Wendet ggf. Änderungen direkt über das Backend an (z.B. wenn Master-Lautstärke direkt geändert wurde).

13. **Hintergrund-Task zum Backend-Event-Monitoring:**
    * Ein dedizierter Task, der den `subscribe_to_events()` Stream des Backends konsumiert.
    * Bei jedem empfangenen `BackendEvent` aktualisiert er den internen Zustand (`active_devices`, `active_streams`, Lautstärke etc.) und sendet die entsprechenden `SystemEvent`s an den `event_bus`.
    * Beispiele für BackendEvent -> SystemEvent: `VolumeChanged -> SystemEvent::MasterVolumeChanged`, `DeviceAdded -> SystemEvent::AudioDeviceAdded`, `StreamStarted -> SystemEvent::AudioStreamStarted`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::audio_service::error::AudioError`
    * `crate::audio_service::data_types::{AudioDeviceInfo, DeviceType, AudioStreamInfo, StreamType, SoundEffectType, AudioConfig}`
    * `crate::audio_service::pipewire_backend` (oder andere Backends, implementieren `AudioBackend` trait)
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `std::sync::atomic::{AtomicU8, AtomicBool, Ordering}`
    * `std::collections::HashMap`
    * `tracing`
    * `futures::stream::Stream`
    * `std::path::Path`

**Kommunikationsmuster:**

* Wird vom `AudioService` verwendet.
* Kommuniziert mit dem spezifischen Audio-Backend über das `AudioBackend` Trait.
* Sendet `SystemEvent`s an den `EventBus` bei Zustandsänderungen im Audio-System.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Audio-Manager, der Audio-Eigenschaften lesen und steuern, Soundeffekte abspielen und auf Systemereignisse reagieren kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit `AudioBackend` Mocking):**
    * Erstellen eines Mock-`AudioBackend` Implementierung, die vordefinierte Antworten liefert und Aufrufe protokolliert.
    * Mocken des `EventBus`.
    * Testen von `new`: Sicherstellen der Initialisierung und des initialen Scans/Statusabfrage vom Mock-Backend.
    * Testen von `get_master_volume_percent`, `set_master_volume_percent`, `toggle_master_mute`: Sicherstellen, dass die Aufrufe an das Mock-Backend weitergeleitet werden und die internen Zustände/Events korrekt sind.
    * Testen von `list_audio_devices`, `set_default_output_device`, `play_sound_effect`, `list_audio_streams`, `set_stream_volume`.
    * Testen des Backend-Event-Monitoring-Tasks: Simulieren von Events vom Mock-Backend und Überprüfen, ob die korrekten `SystemEvent`s gesendet werden.
    * Testen von `update_config`.
* **Integration Tests (mit realem Audio-System und Backend):**
    * Starten des `AudioManager` mit einem realen Backend (z.B. `PipewireClient`).
    * Testen der Steuerung von Lautstärke und Mute.
    * Überprüfen der Gerätelisten und Stream-Informationen.
    * Manuelles Ändern der Systemlautstärke (z.B. über Tastenkürzel oder `pactl`/`wpctl`) und Überprüfen, ob `SystemEvent::MasterVolumeChanged` empfangen wird.
    * Starten einer Anwendung, die Audio abspielt, und Überprüfen, ob der Stream erkannt und entsprechende Events gesendet werden.

**Geschätzter Aufwand:** Sehr Hoch (ca. 12-18 Tage, da Implementierung des `AudioBackend` Trait und komplexe Zustandsverwaltung und Event-Handling)

---
### **novade-system/src/audio_service/pipewire_backend.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert das `AudioBackend` Trait speziell für PipeWire. Es ist für die direkte Kommunikation mit dem PipeWire-Daemon über dessen Rust-Bindings verantwortlich, um Audio-Funktionen zu steuern und Events zu empfangen.

**Kern-Aufgaben (Tasks):**

1.  **`PipewireClient` Struct:**
    * `pub struct PipewireClient {`
        * `core: pw::core::Core,` // PipeWire Core
        * `context: pw::context::Context,` // PipeWire Context
        * `main_loop: Arc<pw::main_loop::MainLoop>,` // PipeWire MainLoop für Async-Events
        * `output_nodes: RwLock<HashMap<u32, pw::node::Node>>,` // Cached Output Nodes
        * `input_nodes: RwLock<HashMap<u32, pw::node::Node>>,` // Cached Input Nodes
        * `stream_nodes: RwLock<HashMap<u32, pw::node::Node>>,` // Cached Stream Nodes
        * `backend_event_sender: mpsc::Sender<BackendEvent>,` // Sender für Events an AudioManager
        * `// Listener für Node-Events, Core-Events etc.`
    * `}`

2.  **`PipewireClient::new()` Funktion:**
    * `pub async fn new() -> Result<Self, AudioError>`
    * **Logik:**
        * Initialisiert das PipeWire-System (`pw::init()`).
        * Erstellt eine `pw::main_loop::MainLoop` (z.B. `new_tokio_loop()`).
        * Verbindet mit dem PipeWire-Daemon (`pw::core::Core::connect`).
        * Erstellt den `pw::context::Context`.
        * Registriert Listener für relevante PipeWire-Events (z.B. `pw::node::Node::add_listener`, `pw::core::Core::add_listener`).
        * Scannt initiale Nodes (Geräte und Streams) und füllt die internen Caches.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `ServerConnectError`, `BackendError`.

3.  **Implementierung des `AudioBackend` Trait für `PipewireClient`:**

    * **`get_master_volume(&self) -> Result<u8, AudioError>`:**
        * **Logik:** Abfragen der Lautstärke des Standard-Outputs (z.B. über den `pw::node::Node` des Standard-Ausgabegeräts). PipeWire hat kein "Master Volume" im traditionellen Sinne, daher muss hier eine Abstraktion implementiert werden, die entweder ein spezifisches Gerät (z.B. `Built-in Audio Analog Stereo`) als Master betrachtet oder eine gewichtete Lautstärke aller Ausgabegeräte berechnet. Konvertierung von PipeWire-Lautstärken (0.0-1.0) zu 0-100%.
    * **`set_master_volume(&self, volume_percent: u8) -> Result<(), AudioError>`:**
        * **Logik:** Setzt die Lautstärke des als Master definierten Ausgabegeräts.
    * **`get_master_mute(&self) -> Result<bool, AudioError>`:**
        * **Logik:** Abfragen des Mute-Status des Standard-Outputs.
    * **`set_master_mute(&self, muted: bool) -> Result<(), AudioError>`:**
        * **Logik:** Setzt den Mute-Status des Standard-Outputs.
    * **`list_devices(&self, device_type: DeviceType) -> Result<Vec<AudioDeviceInfo>, AudioError>`:**
        * **Logik:** Iteriert über die PipeWire-Nodes und filtert nach Gerätetyp (z.B. `Port`s, `Device`s). Konvertiert PipeWire-Metadaten in `AudioDeviceInfo`. Beachtet `node.info().params().get("Prop:device.profile")` für Port-Namen etc.
    * **`set_default_device(&self, device_id: &str, device_type: DeviceType) -> Result<(), AudioError>`:**
        * **Logik:** Setzt das Standardgerät über die PipeWire-API (z.B. durch `pw::core::Core::set_property` auf `context.info().settings().default_audio_sink` oder ähnliche Mechanismen).
    * **`play_sound_file(&self, file_path: &Path) -> Result<(), AudioError>`:**
        * **Logik:** Erstellt einen transienten PipeWire-Stream (`pw::stream::Stream::new`) und spielt die WAV/OGG-Datei ab. Muss Audio-Daten in Chunks an den Stream senden.
    * **`list_streams(&self, stream_type: StreamType) -> Result<Vec<AudioStreamInfo>, AudioError>;`:**
        * **Logik:** Iteriert über die PipeWire-Nodes und filtert nach Streams (z.B. `pw::node::Node::info().client().name()`). Konvertiert in `AudioStreamInfo`.
    * **`set_stream_volume(&self, stream_id: u32, volume_percent: u8) -> Result<(), AudioError>;`:**
        * **Logik:** Findet den Stream-Node und setzt die Lautstärke über dessen Properties.
    * **`set_stream_mute(&self, stream_id: u32, muted: bool) -> Result<(), AudioError>;`:**
        * **Logik:** Findet den Stream-Node und setzt den Mute-Status.
    * **`subscribe_to_events(&self) -> Box<dyn Stream<Item = BackendEvent> + Send + Unpin>;`:**
        * **Logik:** Der `PipewireClient` muss PipeWire-Events (`NodeAdded`, `NodeRemoved`, `NodePropertiesChanged` etc.) in `BackendEvent`s übersetzen und diese über einen `mpsc::channel` senden, dessen Receiver als Stream zurückgegeben wird.

4.  **`BackendEvent` Enum (Intern im `audio_service/manager.rs` oder `data_types.rs`):**
    * `pub enum BackendEvent {`
        * `MasterVolumeChanged(u8),`
        * `MasterMuteToggled(bool),`
        * `DeviceAdded(AudioDeviceInfo),`
        * `DeviceRemoved(String),`
        * `DevicePropertiesChanged(AudioDeviceInfo),` // Aktualisierte Info
        * `StreamAdded(AudioStreamInfo),`
        * `StreamRemoved(u32),`
        * `StreamPropertiesChanged(AudioStreamInfo),`
    * `}`
    * Diese Events werden von den PipeWire-Listenern erzeugt und an den `AudioManager` gesendet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_service/pipewire_backend.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::audio_service::error::AudioError`
    * `crate::audio_service::data_types::{AudioDeviceInfo, DeviceType, AudioStreamInfo, StreamType}`
    * Trait `AudioBackend`
* **Extern:**
    * `pipewire` crate (für PipeWire-Bindings)
    * `tokio::sync::RwLock`
    * `tokio::sync::mpsc`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `std::path::Path`
    * `tracing`
    * `futures::stream::Stream`
    * `bytes` (für Audio-Daten)

**Kommunikationsmuster:**

* Wird vom `AudioManager` instanziiert und verwendet.
* Kommuniziert direkt mit dem PipeWire-Daemon.
* Sendet interne `BackendEvent`s an den `AudioManager` über einen Channel.

**Erwartete Ergebnisse/Outputs:**
Eine funktionsfähige Implementierung des `AudioBackend` Trait für PipeWire, die alle notwendigen Audio-Funktionen bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit PipeWire Mocking/Simulierung):**
    * Verwendung von PipeWire's Test-Tools oder Mocking der PipeWire-Bindings (falls möglich), um Geräte- und Stream-Änderungen zu simulieren.
    * Testen jeder Methode (`get_master_volume`, `set_master_volume` etc.), um sicherzustellen, dass sie die korrekten PipeWire-API-Aufrufe machen und die Ergebnisse korrekt konvertieren.
    * Testen der Event-Emittierung: Sicherstellen, dass simulierte PipeWire-Events korrekt in `BackendEvent`s umgewandelt und gesendet werden.
* **Integration Tests (mit realem PipeWire Daemon):**
    * Starten des `PipewireClient` auf einem System mit laufendem PipeWire.
    * Testen aller `AudioBackend`-Methoden und Überprüfen des Verhaltens über `pw-cli` oder andere PipeWire-Tools.
    * Testen des Event-Monitorings: Manuelles Ändern von Lautstärke, Hinzufügen/Entfernen von Geräten (z.B. USB-Headset) und Überprüfen, ob die `BackendEvent`s empfangen werden.

**Geschätzter Aufwand:** Sehr Hoch (ca. 15-25 Tage, da tiefe Kenntnisse der PipeWire-API und event-gesteuerter Programmierung erforderlich sind)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `network_manager`, widmen wir uns `audio_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/audio_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/audio_service/data_types.rs`**: Definition der grundlegenden Datentypen für Audio-Komponenten.
3.  **`novade-system/src/audio_service/pipewire_backend.rs`**: Implementierung des spezifischen PipeWire-Backends, da dies die komplexeste und tiefste Systeminteraktion erfordert. Dieses Modul definiert das `AudioBackend` Trait und seine Implementierung.
4.  **`novade-system/src/audio_service/manager.rs`**: Die Kernlogik zur Verwaltung von Audiogeräten und -streams, die das `AudioBackend` Trait verwendet.
5.  **`novade-system/src/audio_service/mod.rs`**: Das Hauptmodul, das das Backend und den `AudioManager` initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/audio_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/power_manager` Verzeichnisses, um die Energieverwaltung zu kontrollieren.
---
### **novade-system/src/power_manager/mod.rs**

**Verantwortlichkeit:**
Das `power_manager` Modul ist die zentrale Schnittstelle für die systemweite Energieverwaltung. Es abstrahiert die zugrunde liegenden System-APIs (z.B. `UPower` D-Bus API, `sysfs` für Batterieinformationen, `logind` für Suspend/Hibernate) und bietet eine einheitliche Schnittstelle für andere NovaDE-Komponenten zur Abfrage des Energiestatus, zur Verwaltung von Energiesparplänen und zur Initiierung von Systemzustandsänderungen (Suspend, Hibernate, Reboot, Shutdown).

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/power_manager/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Energie-Operationen)
    * `manager.rs` (Logik für den Energiestatus, Energiesparpläne und Systemaktionen)
    * `data_types.rs` (Definition von Energie-bezogenen Datentypen)
    * `upower_backend.rs` (Implementierung für UPower D-Bus)
    * `logind_backend.rs` (Implementierung für logind D-Bus)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Energie-Subsystems:**
    * `pub async fn initialize_power_manager(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<PowerManagerService, PowerError>`
    * **Logik:**
        * Stellt eine D-Bus-Verbindung zum `UPower` und `logind` Daemons her (oder anderen geeigneten Backends).
        * Erstellt eine Instanz von `manager::PowerStateManager`, die die eigentliche Logik zur Energieverwaltung enthält.
        * Ruft die initialen Energiespareinstellungen aus dem `config_service` ab (z.B. `screen_idle_timeout`, `sleep_on_lid_close`, `low_battery_threshold`).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Energieeinstellungen zu laden.
        * Registriert D-Bus-Signale von `UPower` und `logind` Daemons, um Änderungen am Energiestatus zu erkennen (z.B. `BatteryLevelChanged`, `LidClosed`, `PrepareForSleep`).
        * Gibt ein gebündeltes `PowerManagerService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der D-Bus-Verbindung oder der Initialisierung des `PowerStateManager`.

2.  **`PowerManagerService` Struct:**
    * `pub struct PowerManagerService {`
        * `manager: Arc<PowerStateManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `upower_dbus_connection: Arc<zbus::Connection>,`
        * `logind_dbus_connection: Arc<zbus::Connection>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Energie-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `PowerManagerService` exponiert Methoden zur Abfrage von Energieinformationen und zur Steuerung von Energiesparfunktionen und Systemaktionen.
    * **`get_battery_status(&self) -> Result<BatteryStatus, PowerError>`:**
        * **Logik:** Delegiert an den `PowerStateManager`, um den aktuellen Batteriestatus abzurufen (Ladezustand, Ladezustand, verbleibende Zeit, Kapazität).
    * **`list_power_devices(&self) -> Result<Vec<PowerDeviceInfo>, PowerError>`:**
        * **Logik:** Delegiert an den `PowerStateManager`, um eine Liste aller erkannten Energiegeräte zurückzugeben (Batterien, Netzteile, USVs).
    * **`get_current_power_profile(&self) -> Result<PowerProfile, PowerError>`:**
        * **Logik:** Delegiert an den `PowerStateManager`, um das aktuell aktive Energieprofil abzurufen.
    * **`set_power_profile(&self, profile: PowerProfile) -> Result<(), PowerError>`:**
        * **Logik:** Delegiert an den `PowerStateManager`, um das Energieprofil zu ändern (z.B. "Balanced", "Power Saver", "Performance"). Speichert die Einstellung im `config_service`.
    * **`suspend(&self) -> Result<(), PowerError>`:**
        * **Logik:** Delegiert an den `PowerStateManager`, um das System in den Suspend-Modus zu versetzen.
    * **`hibernate(&self) -> Result<(), PowerError>`:**
        * **Logik:** Delegiert an den `PowerStateManager`, um das System in den Hibernate-Modus zu versetzen.
    * **`reboot(&self) -> Result<(), PowerError>`:**
        * **Logik:** Delegiert an den `PowerStateManager`, um das System neu zu starten.
    * **`shutdown(&self) -> Result<(), PowerError>`:**
        * **Logik:** Delegiert an den `PowerStateManager`, um das System herunterzufahren.
    * **`inhibit_sleep(&self, reason: &str, application_id: &str, timeout_ms: Option<u32>) -> Result<InhibitCookie, PowerError>`:**
        * **Logik:** Delegiert an den `PowerStateManager`, um zu verhindern, dass das System in den Schlaf geht (z.B. während Videowiedergabe). Gibt ein Inhibit-Cookie zurück.
    * **`uninhibit_sleep(&self, cookie: InhibitCookie) -> Result<(), PowerError>`:**
        * **Logik:** Delegiert an den `PowerStateManager`, um eine zuvor gesetzte Schlaf-Inhibierung aufzuheben.
    * **`is_lid_closed(&self) -> Result<bool, PowerError>`:**
        * **Logik:** Delegiert an den `PowerStateManager`, um den Status des Laptop-Deckels abzufragen.
    * **`get_screen_brightness(&self) -> Result<u8, PowerError>`:**
        * **Logik:** Delegiert an den `PowerStateManager`, um die aktuelle Bildschirmhelligkeit abzufragen.
    * **`set_screen_brightness(&self, brightness_percent: u8) -> Result<(), PowerError>`:**
        * **Logik:** Delegiert an den `PowerStateManager`, um die Bildschirmhelligkeit zu setzen. Speichert die Einstellung im `config_service`.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `PowerManagerService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Energieeinstellungen (z.B. `screen_idle_timeout`, `low_battery_threshold`) in der Konfiguration geändert werden, werden die Sub-Komponenten (`PowerStateManager`) informiert.

5.  **Hintergrund-Task zum Abonnieren von D-Bus-Signalen:**
    * Ein weiterer Task sollte D-Bus-Signale vom `UPower` und `logind` Daemons abonnieren und diese in `SystemEvent`s übersetzen, um den `EventBus` zu informieren (z.B. `SystemEvent::BatteryLevelChanged`, `SystemEvent::LidStateChanged`, `SystemEvent::PrepareForSleep`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_manager/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_manager::error::PowerError`
    * `crate::power_manager::manager::PowerStateManager`
    * `crate::power_manager::data_types::{BatteryStatus, PowerDeviceInfo, PowerProfile, InhibitCookie}`
    * `crate::power_manager::upower_backend`
    * `crate::power_manager::logind_backend`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus` (für D-Bus-Interaktion)
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Ist der primäre Consumer von Energie-Anfragen von der Domänenschicht und der UI.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Energieeinstellungen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten und andere Systemdienste über Energie-Statusänderungen zu informieren (z.B. `SystemEvent::BatteryLevelChanged`, `SystemEvent::LidStateChanged`).
* Empfängt D-Bus-Signale von System-Energiediensten.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Energie-Manager-Subsystem, das den Energiestatus abfragen, Energiesparpläne verwalten und Systemaktionen initiieren kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit D-Bus Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `PowerStateManager` und der `zbus` Verbindungen.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und der D-Bus-Verbindung.
    * Testen der Weiterleitung von API-Aufrufen an den `PowerStateManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von D-Bus-Signalen vom `UPower` und `logind` Daemons und Überprüfen, ob die korrekten `SystemEvent`s an den `EventBus` gesendet werden.
* **Integration Tests (mit realem `UPower` und `logind` Daemons):**
    * Starten des `PowerManagerService` auf einem System mit laufenden Daemons.
    * Testen von `get_battery_status`, `list_power_devices`, `is_lid_closed`, `get_screen_brightness`.
    * Testen von `set_power_profile`.
    * **Vorsicht bei `suspend`, `hibernate`, `reboot`, `shutdown` in automatisierten Tests:** Diese sollten nur in isolierten Testumgebungen oder mit manueller Bestätigung durchgeführt werden. Man kann testen, ob die D-Bus-Aufrufe korrekt initiiert werden, ohne den tatsächlichen Systemzustand zu ändern, indem man die D-Bus-Backend-Implementierungen mockt.
    * Testen von `inhibit_sleep` und `uninhibit_sleep`.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da D-Bus-Interaktion mit mehreren Systemdiensten, Event-Handling und sensible Systemaktionen)

---
### **novade-system/src/power_manager/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `power_manager` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Energie-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`PowerError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum PowerError {`
        * `#[error("Failed to connect to D-Bus: {0}")]`
        * `DBusConnectError(#[from] zbus::Error),`
        * `#[error("Power device not found: {0}")]`
        * `DeviceNotFound(String),`
        * `#[error("Battery not found or not present.")]`
        * `BatteryNotFound,`
        * `#[error("Unsupported power operation: {0}")]`
        * `UnsupportedOperation(String),`
        * `#[error("Permission denied for power operation: {0}")]`
        * `PermissionDenied(String),`
        * `#[error("System action failed: {0}")]`
        * `SystemActionFailed(String),` // Z.B. Suspend/Hibernate fehlgeschlagen
        * `#[error("Invalid brightness percentage: {0}")]`
        * `InvalidBrightness(u8),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("UPower D-Bus error: {0}")]`
        * `UPowerDBusError(String),`
        * `#[error("logind D-Bus error: {0}")]`
        * `LogindDBusError(String),`
        * `#[error("Unknown power error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `zbus::Error`, `crate::config_service::error::ConfigError` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_manager/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `zbus::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `power_manager` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Energie-System.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/power_manager/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `power_manager` verwendet werden, um Energiestatus, Geräteinformationen, Energiesparpläne und Inhibit-Cookies zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`BatteryStatus` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct BatteryStatus {`
        * `pub percentage: u8,` // 0-100
        * `pub is_charging: bool,`
        * `pub time_to_empty_minutes: Option<u32>,` // Verbleibende Laufzeit bei Entladung
        * `pub time_to_full_minutes: Option<u32>,` // Verbleibende Ladezeit
        * `pub cycle_count: Option<u32>,`
        * `pub capacity_percent: Option<u8>,` // Ursprüngliche Kapazität vs. aktuelle Kapazität
        * `pub state: BatteryState,`
        * `pub health: BatteryHealth,`
    * `}`

2.  **`BatteryState` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum BatteryState { Charging, Discharging, Full, Empty, Unknown }`

3.  **`BatteryHealth` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum BatteryHealth { Good, Degraded, Bad, Unknown }`

4.  **`PowerDeviceInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct PowerDeviceInfo {`
        * `pub id: String,` // Eindeutiger Bezeichner des Geräts (z.B. UPower ObjectPath)
        * `pub name: String,` // Anzeigename (z.B. "Battery", "AC Adapter")
        * `pub device_type: PowerDeviceType,`
        * `pub is_present: bool,`
        * `pub is_rechargeable: bool,`
        * `pub model: Option<String>,`
        * `pub vendor: Option<String>,`
        * `pub serial: Option<String>,`
        * `pub battery_status: Option<BatteryStatus>,` // Nur wenn device_type Battery ist
    * `}`

5.  **`PowerDeviceType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum PowerDeviceType { Battery, ACAdapter, UPS, Other }`

6.  **`PowerProfile` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum PowerProfile { Balanced, PowerSaver, Performance, Custom, Unknown }`

7.  **`InhibitCookie` Struct:**
    * `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]`
    * `pub struct InhibitCookie(u32);` // Eindeutiger Identifier für eine Inhibit-Anfrage

8.  **`PowerConfig` Struct (aus `config_service/data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct PowerConfig {`
        * `pub screen_idle_timeout_seconds: u32,`
        * `pub sleep_on_lid_close: bool,`
        * `pub low_battery_threshold_percent: u8,`
        * `pub critical_battery_threshold_percent: u8,`
        * `pub default_power_profile: PowerProfile,`
        * `pub dim_screen_on_battery: bool,`
        * `pub auto_suspend_on_idle: bool,`
        * `pub suspend_timeout_seconds: u32,`
        * `pub screen_brightness_percent: u8,`
        * `// ... weitere Einstellungen`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_manager/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Energie-Informationen und Konfigurationen im System.
* Sie werden vom `PowerStateManager` erzeugt und von der API des `PowerManagerService` verwendet.
* `PowerConfig` wird im `ConfigService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Energieverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage, da detaillierte Energie-Datenstrukturen benötigt werden)

---
### **novade-system/src/power_manager/manager.rs**

**Verantwortlichkeit:**
Der `PowerStateManager` ist die Kernlogik des Energie-Subsystems. Er abstrahiert die Interaktion mit den spezifischen Power-Backends (`upower_backend`, `logind_backend`) und verwaltet den Zustand der Energiegeräte und System-Power-Status. Er ist dafür verantwortlich, Anfragen von `mod.rs` in Aufrufe an die Backends zu übersetzen und deren Antworten in NovaDE-Datentypen umzuwandeln. Er verwaltet auch die Inhibit-Logik.

**Kern-Aufgaben (Tasks):**

1.  **`PowerStateManager` Struct:**
    * `pub struct PowerStateManager {`
        * `upower_backend: Arc<dyn UPowerBackend + Send + Sync>,`
        * `logind_backend: Arc<dyn LogindBackend + Send + Sync>,`
        * `event_bus: EventBus,`
        * `battery_status: RwLock<Option<BatteryStatus>>,` // Cached Battery Status
        * `power_devices: RwLock<HashMap<String, PowerDeviceInfo>>,` // id -> PowerDeviceInfo
        * `current_power_profile: AtomicCell<PowerProfile>,`
        * `inhibit_cookies: RwLock<HashMap<InhibitCookie, (String, String)>>,` // Cookie -> (App ID, Reason)
        * `next_inhibit_cookie_id: AtomicU32,`
        * `// Optional: Timer für Idle-Detection, Screen-Dimming, etc.`
    * `}`

2.  **`PowerStateManager::new()` Funktion:**
    * `pub async fn new(upower_backend: Arc<dyn UPowerBackend + Send + Sync>, logind_backend: Arc<dyn LogindBackend + Send + Sync>, initial_power_config: PowerConfig, event_bus: EventBus) -> Result<Self, PowerError>`
    * **Logik:**
        * Initialisiert mit den bereitgestellten Backends und `EventBus`.
        * Füllt `power_devices` und `battery_status` durch Abfragen der Backends.
        * Setzt `current_power_profile` und andere Konfigurationseinstellungen basierend auf `initial_power_config`.
        * Startet Hintergrund-Tasks zum Abonnieren von Backend-Events (Geräteänderungen, Batteriestatusänderungen, Lid-Zustand, PrepareForSleep) und zur Aktualisierung des internen Zustands sowie zum Senden von `SystemEvent`s an den `EventBus`.
        * Initialisiert den Idle-Timer basierend auf `screen_idle_timeout_seconds`.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** Fehler bei der Backend-Initialisierung.

3.  **`UPowerBackend` Trait:**
    * `pub trait UPowerBackend: Debug + Send + Sync {`
        * `async fn get_all_devices(&self) -> Result<Vec<PowerDeviceInfo>, PowerError>;`
        * `async fn get_battery_status(&self) -> Result<Option<BatteryStatus>, PowerError>;`
        * `async fn get_lid_is_closed(&self) -> Result<bool, PowerError>;`
        * `async fn get_screen_brightness(&self) -> Result<u8, PowerError>;` // Kann auch über sysfs gehen
        * `async fn set_screen_brightness(&self, brightness_percent: u8) -> Result<(), PowerError>;` // Kann auch über sysfs gehen
        * `fn subscribe_to_events(&self) -> Box<dyn Stream<Item = BackendEvent> + Send + Unpin>;`
    * `}`

4.  **`LogindBackend` Trait:**
    * `pub trait LogindBackend: Debug + Send + Sync {`
        * `async fn suspend(&self) -> Result<(), PowerError>;`
        * `async fn hibernate(&self) -> Result<(), PowerError>;`
        * `async fn reboot(&self) -> Result<(), PowerError>;`
        * `async fn shutdown(&self) -> Result<(), PowerError>;`
        * `async fn inhibit_sleep(&self, reason: &str, application_id: &str, timeout_ms: Option<u32>) -> Result<u32, PowerError>;` // Returns cookie
        * `async fn uninhibit_sleep(&self, cookie: u32) -> Result<(), PowerError>;`
        * `fn subscribe_to_events(&self) -> Box<dyn Stream<Item = BackendEvent> + Send + Unpin>;` // For PrepareForSleep, etc.
    * `}`

5.  **`PowerStateManager::get_battery_status()` Methode:**
    * `pub fn get_battery_status(&self) -> Result<BatteryStatus, PowerError>`
    * **Logik:** Gibt den Wert aus dem `battery_status` Cache zurück oder aktualisiert ihn bei Bedarf über das Backend.

6.  **`PowerStateManager::list_power_devices()` Methode:**
    * `pub async fn list_power_devices(&self) -> Result<Vec<PowerDeviceInfo>, PowerError>`
    * **Logik:** Ruft `self.upower_backend.get_all_devices()` auf und gibt die Ergebnisse zurück. Aktualisiert den Cache.

7.  **`PowerStateManager::get_current_power_profile()` / `set_power_profile()` Methoden:**
    * `pub fn get_current_power_profile(&self) -> PowerProfile`
    * `pub async fn set_power_profile(&self, profile: PowerProfile) -> Result<(), PowerError>`
    * **Logik:** `set_power_profile` würde eine entsprechende D-Bus-Methode auf `org.freedesktop.UPower.Battery` oder ein `systemd-rfkill`-Äquivalent aufrufen, um das Profil zu ändern. Aktualisiert `current_power_profile`. Sendet `SystemEvent::PowerProfileChanged`.

8.  **`PowerStateManager::suspend()` / `hibernate()` / `reboot()` / `shutdown()` Methoden:**
    * `pub async fn suspend(&self) -> Result<(), PowerError>`
    * `pub async fn hibernate(&self) -> Result<(), PowerError>`
    * `pub async fn reboot(&self) -> Result<(), PowerError>`
    * `pub async fn shutdown(&self) -> Result<(), PowerError>`
    * **Logik:** Delegieren an `self.logind_backend` und senden entsprechende `SystemEvent`s (z.B. `SystemEvent::SystemSuspending`).

9.  **`PowerStateManager::inhibit_sleep()` / `uninhibit_sleep()` Methoden:**
    * `pub async fn inhibit_sleep(&self, reason: &str, application_id: &str, timeout_ms: Option<u32>) -> Result<InhibitCookie, PowerError>`
    * `pub async fn uninhibit_sleep(&self, cookie: InhibitCookie) -> Result<(), PowerError>`
    * **Logik:** Delegieren an `self.logind_backend`. Speichern den `InhibitCookie` und die zugehörigen Informationen in `inhibit_cookies`. Bei Timeout oder Uninhibit, entfernen aus der Map.

10. **`PowerStateManager::is_lid_closed()` Methode:**
    * `pub async fn is_lid_closed(&self) -> Result<bool, PowerError>`
    * **Logik:** Ruft `self.upower_backend.get_lid_is_closed()` auf.

11. **`PowerStateManager::get_screen_brightness()` / `set_screen_brightness()` Methoden:**
    * `pub async fn get_screen_brightness(&self) -> Result<u8, PowerError>`
    * `pub async fn set_screen_brightness(&self, brightness_percent: u8) -> Result<(), PowerError>`
    * **Logik:** Delegieren an `self.upower_backend` (oder spezifisches Backend für Helligkeit, z.B. über `sysfs` oder `xrandr`).

12. **`PowerStateManager::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: PowerConfig)`
    * **Logik:** Aktualisiert interne Konfigurationen und passt entsprechend Verhalten an (z.B. Start/Stopp von Idle-Timern, Anwenden des Standard-Power-Profils).

13. **Hintergrund-Tasks zum Backend-Event-Monitoring:**
    * Separate Tasks für `upower_backend` und `logind_backend` Streams.
    * Bei jedem empfangenen `BackendEvent` aktualisiert der Task den internen Zustand (`battery_status`, `power_devices` etc.) und sendet die entsprechenden `SystemEvent`s an den `event_bus`.
    * Beispiele für BackendEvent -> SystemEvent: `BatteryLevelChanged -> SystemEvent::BatteryLevelChanged`, `LidStateChanged -> SystemEvent::LidStateChanged`, `PrepareForSleep -> SystemEvent::PrepareForSleep`.

14. **Idle-Management-Task:**
    * Ein Task, der Benutzereingaben überwacht (über `input_service` Events).
    * Wenn keine Eingabe für `screen_idle_timeout_seconds` erfolgt, dimmt es den Bildschirm oder geht in den Suspend, basierend auf der Konfiguration (`dim_screen_on_battery`, `auto_suspend_on_idle`).
    * Berücksichtigt aktive `InhibitCookie`s.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_manager/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_manager::error::PowerError`
    * `crate::power_manager::data_types::{BatteryStatus, PowerDeviceInfo, PowerProfile, InhibitCookie, PowerConfig}`
    * `crate::power_manager::upower_backend::{self, UPowerBackend}`
    * `crate::power_manager::logind_backend::{self, LogindBackend}`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tokio::sync::RwLock`
    * `crossbeam_utils::atomic::AtomicCell`
    * `std::sync::Arc`
    * `std::sync::atomic::{AtomicU32, Ordering}`
    * `std::collections::HashMap`
    * `tracing`
    * `futures::stream::Stream`

**Kommunikationsmuster:**

* Wird vom `PowerManagerService` verwendet.
* Kommuniziert mit den spezifischen Power-Backends über die `UPowerBackend` und `LogindBackend` Traits.
* Sendet `SystemEvent`s an den `EventBus` bei Zustandsänderungen im Energie-System.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Energie-Manager, der den System-Energiestatus überwachen, Systemaktionen initiieren und auf Energiesparereignisse reagieren kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Erstellen von Mock-`UPowerBackend` und `LogindBackend` Implementierungen, die vordefinierte Antworten liefern und Aufrufe protokollieren.
    * Mocken des `EventBus`.
    * Testen von `new`: Sicherstellen der Initialisierung und des initialen Scans/Statusabfrage von den Mock-Backends.
    * Testen von `get_battery_status`, `list_power_devices`, `is_lid_closed`, `get_screen_brightness`: Sicherstellen, dass die Aufrufe an die Mock-Backends weitergeleitet werden und die internen Zustände/Events korrekt sind.
    * Testen von `set_power_profile`.
    * Testen von `inhibit_sleep` und `uninhibit_sleep` mit dem Mock-LogindBackend.
    * Testen des Backend-Event-Monitoring-Tasks: Simulieren von Events von den Mock-Backends und Überprüfen, ob die korrekten `SystemEvent`s gesendet werden.
    * Testen der Idle-Logik: Simulieren von Inaktivität und Überprüfen, ob die richtigen Aktionen ausgelöst werden (z.B. Dimmen, Suspend-Inhibierung respektieren).
* **Integration Tests (mit realen Daemons):**
    * Starten des `PowerStateManager` mit realen `UPowerBackend` und `LogindBackend`.
    * Testen aller Methoden, die den Status abfragen (Batterie, Geräte, Lid).
    * Testen von `set_screen_brightness`.
    * **Vorsicht bei Systemaktionen:** Systemaktionen wie `suspend`, `hibernate`, `reboot`, `shutdown` sollten mit höchster Vorsicht getestet werden und idealerweise nur durch manuelle Validierung oder in speziell dafür vorgesehenen, isolierten Testumgebungen. Der Fokus der automatisierten Tests sollte hier auf dem korrekten Aufruf der D-Bus-Methoden liegen.
    * Testen der `Inhibit`-Funktion: Manuell ein `inhibit` setzen und überprüfen, ob der Bildschirm nicht ausgeht, oder das System nicht in den Schlaf geht.

**Geschätzter Aufwand:** Sehr Hoch (ca. 12-18 Tage, da Interaktion mit mehreren D-Bus-Diensten, komplexe Zustandsverwaltung, Idle-Detection und sensible Systemaktionen)

---
### **novade-system/src/power_manager/upower_backend.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert das `UPowerBackend` Trait speziell für die Interaktion mit dem `UPower` D-Bus-Daemon. Es ist für die direkte Kommunikation mit UPower über dessen D-Bus-Schnittstelle verantwortlich, um Energieinformationen abzufragen und Events zu empfangen.

**Kern-Aufgaben (Tasks):**

1.  **`UPowerClient` Struct:**
    * `pub struct UPowerClient<'a> {`
        * `upower_proxy: UPowerOrgFreedesktopUPower<'a>,` // zbus generated proxy for /org/freedesktop/UPower
        * `// Optional: Proxies für individuelle UPower-Geräte-Objekte`
        * `backend_event_sender: mpsc::Sender<BackendEvent>,` // Sender für Events an PowerStateManager
    * `}`

2.  **`UPowerClient::new()` Funktion:**
    * `pub async fn new(connection: &Arc<zbus::Connection>) -> Result<Self, PowerError>`
    * **Logik:**
        * Erstellt den `zbus`-Proxy für den `org.freedesktop.UPower` Service.
        * Registriert Listener für relevante UPower-Signale (z.B. `DeviceAdded`, `DeviceRemoved`, `PropertiesChanged` auf Geräten).
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `DBusConnectError`, `UPowerDBusError`.

3.  **Implementierung des `UPowerBackend` Trait für `UPowerClient`:**

    * **`get_all_devices(&self) -> Result<Vec<PowerDeviceInfo>, PowerError>`:**
        * **Logik:** Ruft die `EnumerateDevices` Methode oder iteriert über die `Devices` Property des UPower-Hauptobjekts.
        * Für jeden Objektpfad eines Geräts, erstellt einen Geräte-Proxy und fragt dessen Properties ab (z.B. `Type`, `State`, `Percentage`, `TimeToEmpty`, `IsCharging`, `LidIsClosed`, `Brightness`).
        * Konvertiert die D-Bus-Daten in `PowerDeviceInfo` und `BatteryStatus`.
    * **`get_battery_status(&self) -> Result<Option<BatteryStatus>, PowerError>`:**
        * **Logik:** Findet das primäre Batteriegerät (oder das erste gefundene) und fragt dessen relevante Eigenschaften ab, um ein `BatteryStatus` zu erstellen.
    * **`get_lid_is_closed(&self) -> Result<bool, PowerError>`:**
        * **Logik:** Fragt die `LidIsClosed` Property des UPower-Hauptobjekts ab.
    * **`get_screen_brightness(&self) -> Result<u8, PowerError>`:**
        * **Logik:** Fragt die `Brightness` Property des Display-Geräts in UPower ab. Alternativ oder zusätzlich kann direkt `/sys/class/backlight/*/brightness` gelesen werden. Wenn UPower dies nicht direkt bereitstellt, muss hier eine Fallback-Implementierung (z.B. `sysfs_backend` oder `xrandr_backend`) oder eine direkte Interaktion mit `sysfs` erfolgen.
    * **`set_screen_brightness(&self, brightness_percent: u8) -> Result<(), PowerError>`:**
        * **Logik:** Setzt die `Brightness` Property des Display-Geräts in UPower. Auch hier: Falls UPower das nicht direkt unterstützt, muss eine andere Methode (z.B. `sysfs_backend`, `xrandr_backend`) verwendet werden.
    * **`subscribe_to_events(&self) -> Box<dyn Stream<Item = BackendEvent> + Send + Unpin>;`:**
        * **Logik:** Der `UPowerClient` muss UPower-Signale (`DeviceAdded`, `DeviceRemoved`, `PropertiesChanged` auf `/org/freedesktop/UPower/devices/*` Objekten) abonnieren.
        * Diese Signale werden dann in `BackendEvent`s übersetzt und über den `mpsc::channel` gesendet.
        * Beispiele für Signal-Handling: Wenn `org.freedesktop.UPower.Device.PropertiesChanged` auf einem Batterieobjekt empfangen wird, `BackendEvent::BatteryLevelChanged` senden. Wenn `org.freedesktop.UPower.PropertiesChanged` auf dem Hauptobjekt empfangen wird und `LidIsClosed` sich ändert, `BackendEvent::LidStateChanged` senden.

4.  **`BackendEvent` Enum (Intern im `power_manager/manager.rs` oder `data_types.rs`):**
    * `pub enum BackendEvent {`
        * `BatteryLevelChanged(BatteryStatus),`
        * `LidStateChanged(bool),`
        * `PowerDeviceAdded(PowerDeviceInfo),`
        * `PowerDeviceRemoved(String),` // ID des entfernten Geräts
        * `PowerDevicePropertiesChanged(PowerDeviceInfo),`
        * `ScreenBrightnessChanged(u8),`
        * `// ... weitere spezifische Events`
    * `}`
    * Diese Events werden von den UPower D-Bus-Signal-Listenern erzeugt und an den `PowerStateManager` gesendet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_manager/upower_backend.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_manager::error::PowerError`
    * `crate::power_manager::data_types::{BatteryStatus, PowerDeviceInfo, PowerDeviceType}`
    * Trait `UPowerBackend`
* **Extern:**
    * `zbus` (insbesondere die generierten Proxies wie `zbus::fdo::UPower::OrgFreedesktopUPower`)
    * `zbus::zvariant::{OwnedObjectPath, OwnedValue}`
    * `tokio::sync::mpsc`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `tracing`
    * `futures::stream::Stream`
    * `std::path::PathBuf` (für sysfs Fallback)
    * `tokio::fs` (für sysfs Fallback)

**Kommunikationsmuster:**

* Wird vom `PowerStateManager` instanziiert und verwendet.
* Kommuniziert direkt mit dem `UPower` D-Bus-Daemon.
* Sendet interne `BackendEvent`s an den `PowerStateManager` über einen Channel.

**Erwartete Ergebnisse/Outputs:**
Eine funktionsfähige Implementierung des `UPowerBackend` Trait, die Energieinformationen von UPower abrufen und Events weiterleiten kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit `zbus::Connection` Mocking):**
    * Mocken der `zbus::Connection` und der erwarteten UPower D-Bus-Antworten.
    * Testen jeder Wrapper-Methode in `UPowerClient`, um sicherzustellen, dass die D-Bus-Aufrufe korrekt formuliert und die Antworten korrekt geparst werden.
    * Simulieren des Empfangs von UPower D-Bus-Signalen und Überprüfen, ob die Streams die korrekten `BackendEvent`s liefern.
* **Integration Tests (mit realem `UPower` Daemon):**
    * Starten des `UPowerClient` auf einem System mit laufendem UPower.
    * Testen aller `UPowerBackend`-Methoden und Überprüfen des Verhaltens über `upower -d` oder ähnliche Tools.
    * Testen des Event-Monitorings: Manuelles Ändern des Ladezustands, Anschließen/Trennen des Netzteils, Schließen/Öffnen des Laptop-Deckels und Überprüfen, ob die `BackendEvent`s empfangen werden.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da detaillierte Kenntnis der UPower D-Bus-API und sorgfältige Wrapper-Erstellung erforderlich)

---
### **novade-system/src/power_manager/logind_backend.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert das `LogindBackend` Trait speziell für die Interaktion mit dem `systemd-logind` D-Bus-Daemon. Es ist für die Initiierung von Systemaktionen (Suspend, Hibernate, Reboot, Shutdown) und die Verwaltung von Schlaf-Inhibierungen verantwortlich.

**Kern-Aufgaben (Tasks):**

1.  **`LogindClient` Struct:**
    * `pub struct LogindClient<'a> {`
        * `manager_proxy: LogindOrgFreedesktopLoginManager<'a>,` // zbus generated proxy for /org/freedesktop/login1
        * `session_proxy: Option<LogindOrgFreedesktopLoginSession<'a>>,` // Optional: Proxy für aktuelle Session
        * `backend_event_sender: mpsc::Sender<BackendEvent>,` // Sender für Events an PowerStateManager
    * `}`

2.  **`LogindClient::new()` Funktion:**
    * `pub async fn new(connection: &Arc<zbus::Connection>) -> Result<Self, PowerError>`
    * **Logik:**
        * Erstellt den `zbus`-Proxy für den `org.freedesktop.login1` Service.
        * Versucht, den aktuellen Session-Pfad über `GetSessionByPID` (PID des NovaDE-Prozesses) zu ermitteln und einen Session-Proxy zu erstellen.
        * Registriert Listener für relevante logind-Signale (z.B. `PrepareForSleep`, `PrepareForShutdown`).
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `DBusConnectError`, `LogindDBusError`.

3.  **Implementierung des `LogindBackend` Trait für `LogindClient`:**

    * **`suspend(&self) -> Result<(), PowerError>`:**
        * **Logik:** Ruft die `Suspend` Methode des `logind` Managers auf.
    * **`hibernate(&self) -> Result<(), PowerError>`:**
        * **Logik:** Ruft die `Hibernate` Methode des `logind` Managers auf.
    * **`reboot(&self) -> Result<(), PowerError>`:**
        * **Logik:** Ruft die `Reboot` Methode des `logind` Managers auf.
    * **`shutdown(&self) -> Result<(), PowerError>`:**
        * **Logik:** Ruft die `PowerOff` Methode des `logind` Managers auf.
    * **`inhibit_sleep(&self, reason: &str, application_id: &str, timeout_ms: Option<u32>) -> Result<u32, PowerError>`:**
        * **Logik:** Ruft die `Inhibit` Methode des `logind` Managers oder der aktuellen Session auf.
        * Parameter: `what` ("sleep"), `who` (Application ID), `mode` ("block"), `hint` (Reason).
        * Gibt das erhaltene Cookie zurück.
    * **`uninhibit_sleep(&self, cookie: u32) -> Result<(), PowerError>`:**
        * **Logik:** logind hat keine direkte `Uninhibit`-Methode mit Cookie. Das Inhibit-Handle wird typischerweise durch das Schließen der D-Bus-Verbindung oder durch den Timeout der Inhibierung aufgehoben. Wenn ein Cookie-basiertes `Uninhibit` benötigt wird, müsste NovaDE die D-Bus-File-Descriptor der Inhibits verwalten und schließen, oder die `logind` API genauer prüfen, wie eine Inhibierung explizit beendet wird. Alternativ könnte die `InhibitCookie` intern in NovaDE verwaltet und die D-Bus-Verbindung, die die Inhibierung hält, geschlossen werden, wenn der `uninhibit_sleep` Aufruf erfolgt.
        * **Alternative Implementierung:** Wenn `logind` keine direkte `Uninhibit` API per Cookie bietet, müsste NovaDE für jeden `inhibit` Aufruf eine separate D-Bus-Verbindung oder ein separates D-Bus-File-Descriptor-Handle halten. Beim Aufruf von `uninhibit_sleep` würde NovaDE dann das entsprechende Handle schließen. Dies ist komplexer, als eine einfache D-Bus-Methode aufzurufen. Der `zbus` `Inhibit` Proxy könnte eine `close()` Methode bereitstellen.
    * **`subscribe_to_events(&self) -> Box<dyn Stream<Item = BackendEvent> + Send + Unpin>;`:**
        * **Logik:** Der `LogindClient` muss logind-Signale (`PrepareForSleep`, `PrepareForShutdown`) abonnieren.
        * Diese Signale werden dann in `BackendEvent`s übersetzt und über den `mpsc::channel` gesendet.

4.  **`BackendEvent` Enum (Intern im `power_manager/manager.rs` oder `data_types.rs`):**
    * `pub enum BackendEvent {`
        * `PrepareForSleep(bool),` // True = entering sleep, False = waking up
        * `PrepareForShutdown(bool),` // True = entering shutdown/reboot, False = canceling
        * `// ... weitere spezifische Events (z.B. UserSessionChanged, IdleHint)`
    * `}`
    * Diese Events werden von den logind D-Bus-Signal-Listenern erzeugt und an den `PowerStateManager` gesendet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_manager/logind_backend.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_manager::error::PowerError`
    * Trait `LogindBackend`
* **Extern:**
    * `zbus` (insbesondere die generierten Proxies wie `zbus::fdo::login1::OrgFreedesktopLoginManager`, `OrgFreedesktopLoginSession`)
    * `zbus::zvariant::{OwnedObjectPath, OwnedValue}`
    * `tokio::sync::mpsc`
    * `std::sync::Arc`
    * `tracing`
    * `futures::stream::Stream`

**Kommunikationsmuster:**

* Wird vom `PowerStateManager` instanziiert und verwendet.
* Kommuniziert direkt mit dem `systemd-logind` D-Bus-Daemon.
* Sendet interne `BackendEvent`s an den `PowerStateManager` über einen Channel.

**Erwartete Ergebnisse/Outputs:**
Eine funktionsfähige Implementierung des `LogindBackend` Trait, die Systemaktionen initiieren und Schlaf-Inhibierungen verwalten kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit `zbus::Connection` Mocking):**
    * Mocken der `zbus::Connection` und der erwarteten logind D-Bus-Antworten.
    * Testen jeder Wrapper-Methode in `LogindClient`, um sicherzustellen, dass die D-Bus-Aufrufe korrekt formuliert und die Antworten korrekt geparst werden.
    * Simulieren des Empfangs von logind D-Bus-Signalen und Überprüfen, ob die Streams die korrekten `BackendEvent`s liefern.
* **Integration Tests (mit realem `systemd-logind` Daemon):**
    * Starten des `LogindClient` auf einem System mit laufendem `systemd-logind`.
    * Testen von `inhibit_sleep` und `uninhibit_sleep`. Überprüfen, ob der Inhibit tatsächlich wirkt (z.B. durch Warten auf Idle-Suspend, der dann nicht eintritt).
    * **Extrem wichtig:** Die Systemaktionen (`suspend`, `hibernate`, `reboot`, `shutdown`) sollten in Integrationstests nur mit größter Vorsicht und wenn überhaupt, nur in einer isolierten Testumgebung (z.B. VM Snapshotting, Testcontainer mit `systemd`) durchgeführt werden, da sie den Test-Host neu starten oder beenden würden. Der Fokus sollte hier auf dem korrekten Aufruf der D-Bus-Methoden liegen.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da detaillierte Kenntnis der logind D-Bus-API, Inhibit-Mechanismen und sensible Systemaktionen)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `audio_service`, widmen wir uns `power_manager`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/power_manager/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/power_manager/data_types.rs`**: Definition der grundlegenden Datentypen für Energieverwaltung.
3.  **`novade-system/src/power_manager/upower_backend.rs`**: Implementierung des spezifischen UPower-Backends.
4.  **`novade-system/src/power_manager/logind_backend.rs`**: Implementierung des spezifischen logind-Backends.
5.  **`novade-system/src/power_manager/manager.rs`**: Die Kernlogik zur Verwaltung von Energie und Systemaktionen, die die UPower- und logind-Backends nutzt.
6.  **`novade-system/src/power_manager/mod.rs`**: Das Hauptmodul, das die Backends und den `PowerStateManager` initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/power_manager` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/input_service` Verzeichnisses, um die Eingabegeräte zu kontrollieren.
---
### **novade-system/src/input_service/mod.rs**

**Verantwortlichkeit:**
Das `input_service` Modul ist die zentrale Schnittstelle für die Verwaltung von Eingabegeräten und die Verarbeitung von Eingabeereignissen. Es abstrahiert die zugrunde liegenden System-APIs (z.B. `libinput`, `evdev`, `Xinput`) und bietet eine einheitliche Schnittstelle für andere NovaDE-Komponenten, um Eingabegeräte zu erkennen, deren Status abzufragen und konfigurieren zu können sowie Eingabeereignisse zu empfangen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/input_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Eingabe-Operationen)
    * `manager.rs` (Logik für Geräteverwaltung und Event-Dispatching)
    * `data_types.rs` (Definition von Eingabe-bezogenen Datentypen)
    * `libinput_backend.rs` (Implementierung für `libinput`)
    * `key_mapper.rs` (Zuständig für Tastenbelegung und Tastenkombinationen)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Eingabe-Subsystems:**
    * `pub async fn initialize_input_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<InputService, InputError>`
    * **Logik:**
        * Erkennt das verfügbare Eingabe-Backend (primär `libinput`).
        * Erstellt eine Instanz von `manager::InputEventManager`, die die eigentliche Logik zur Geräteverwaltung und Event-Verarbeitung enthält.
        * Ruft die initialen Eingabeeinstellungen aus dem `config_service` ab (z.B. `keyboard_layout`, `mouse_speed`, `touchpad_tap_to_click`).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Eingabeeinstellungen zu laden.
        * Startet den Event-Loop des `libinput` Backends, um kontinuierlich Eingabeereignisse zu lesen.
        * Registriert sich für Events vom Eingabe-Backend (z.B. Gerät hinzugefügt/entfernt, Tastenanschläge, Mausbewegungen).
        * Gibt ein gebündeltes `InputService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Backends oder des `InputEventManager`.

2.  **`InputService` Struct:**
    * `pub struct InputService {`
        * `manager: Arc<InputEventManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
    * `}`
    * Dient als Container und Zugangspunkt für die Eingabe-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `InputService` exponiert Methoden zur Abfrage von Eingabeinformationen und zur Steuerung von Eingabegeräten.
    * **`list_input_devices(&self) -> Result<Vec<InputDeviceInfo>, InputError>`:**
        * **Logik:** Delegiert an den `InputEventManager`, um eine Liste aller erkannten Eingabegeräte zurückzugeben (Tastaturen, Mäuse, Touchpads, Joysticks).
    * **`get_device_settings(&self, device_id: &str) -> Result<InputDeviceSettings, InputError>`:**
        * **Logik:** Delegiert an den `InputEventManager`, um die aktuellen Einstellungen für ein spezifisches Gerät abzurufen.
    * **`set_keyboard_layout(&self, layout: &str) -> Result<(), InputError>`:**
        * **Logik:** Delegiert an den `InputEventManager`, um das Tastaturlayout systemweit zu setzen. Speichert die Einstellung im `config_service`. Sendet `SystemEvent::KeyboardLayoutChanged`.
    * **`set_mouse_acceleration(&self, device_id: &str, acceleration: f64) -> Result<(), InputError>`:**
        * **Logik:** Delegiert an den `InputEventManager`, um die Mausbeschleunigung für ein Gerät anzupassen. Speichert die Einstellung im `config_service`.
    * **`set_touchpad_tap_to_click(&self, device_id: &str, enable: bool) -> Result<(), InputError>`:**
        * **Logik:** Delegiert an den `InputEventManager`, um "Tap-to-Click" für ein Touchpad zu aktivieren/deaktivieren. Speichert die Einstellung im `config_service`.
    * **`get_active_keyboard_layout(&self) -> Result<String, InputError>`:**
        * **Logik:** Delegiert an den `InputEventManager`, um das aktuell aktive Tastaturlayout abzufragen.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `InputService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Eingabeeinstellungen in der Konfiguration geändert werden, werden die Sub-Komponenten (`InputEventManager`) informiert.

5.  **Hintergrund-Task zum Abonnieren von Backend-Events:**
    * Ein weiterer Task sollte Events vom ausgewählten Eingabe-Backend (`libinput_backend`) abonnieren und diese in `SystemEvent`s übersetzen, um den `EventBus` zu informieren.
    * Beispiele: `SystemEvent::InputDeviceAdded`, `SystemEvent::InputDeviceRemoved`, `SystemEvent::KeyPressed`, `SystemEvent::KeyReleased`, `SystemEvent::MouseMoved`, `SystemEvent::MouseScrolled`, `SystemEvent::TouchEvent`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input_service::error::InputError`
    * `crate::input_service::manager::InputEventManager`
    * `crate::input_service::data_types::{InputDeviceInfo, InputDeviceSettings}`
    * `crate::input_service::libinput_backend::LibinputClient`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Ist der primäre Consumer von Eingabe-Anfragen von der Domänenschicht und der UI.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Eingabeeinstellungen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten und andere Systemdienste über Eingabe-Statusänderungen oder Ereignisse zu informieren.
* Empfängt Events vom gewählten Eingabe-Backend.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Eingabe-Subsystem, das Eingabegeräte verwalten und Eingabeereignisse verarbeiten kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus` und des gewählten Eingabe-Backend-Clients.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und der Backend-Verbindung.
    * Testen der Weiterleitung von API-Aufrufen an den `InputEventManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von Events vom Eingabe-Backend und Überprüfen, ob die korrekten `SystemEvent`s an den `EventBus` gesendet werden.
* **Integration Tests (mit realen Eingabegeräten):**
    * Starten des `InputService` auf einem System mit angeschlossenen Eingabegeräten.
    * Testen von `list_input_devices` und `get_device_settings`.
    * Manuelles Ändern von Tastaturlayouts, Maus-/Touchpad-Einstellungen über NovaDE-UI oder System-Tools und Überprüfen, ob die Änderungen erkannt und Events gesendet werden.
    * Simulieren von Tastenanschlägen, Mausbewegungen und Touchpad-Gesten und Überprüfen, ob die entsprechenden `SystemEvent`s im `EventBus` ankommen.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da Interaktion mit Low-Level-Eingabe-APIs, Event-Handling und Konfigurationsmanagement)

---
### **novade-system/src/input_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `input_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Eingabe-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`InputError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum InputError {`
        * `#[error("Failed to initialize input backend: {0}")]`
        * `BackendInitializationFailed(String),`
        * `#[error("Input device not found: {0}")]`
        * `DeviceNotFound(String),`
        * `#[error("Failed to set device property: {0}")]`
        * `SetPropertyError(String),`
        * `#[error("Unsupported input operation for device: {0}")]`
        * `UnsupportedOperation(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Backend specific error: {0}")]`
        * `BackendError(String),` // Wrapper für libinput spezifische Fehler
        * `#[error("I/O error: {0}")]`
        * `IoError(#[from] std::io::Error),`
        * `#[error("Unknown input error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `std::io::Error` und `anyhow::Error`. Füge spezifische Fehler von `libinput` hinzu.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::io::Error`
    * `libinput-sys` (oder `libinput` Rust crate's error types, wenn genutzt)
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `input_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Eingabe-System.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/input_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `input_service` verwendet werden, um Eingabegeräte, deren Eigenschaften, Einstellungen und Ereignisse zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`InputDeviceInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct InputDeviceInfo {`
        * `pub id: String,` // Eindeutiger Bezeichner des Geräts (z.B. libinput device ID, udev path)
        * `pub name: String,` // Anzeigename (z.B. "Logitech USB Mouse", "AT Translated Set 2 keyboard")
        * `pub device_type: InputDeviceType,`
        * `pub vendor_id: u16,`
        * `pub product_id: u16,`
        * `pub is_builtin: bool,`
        * `pub settings: InputDeviceSettings,` // Aktuelle Einstellungen des Geräts
    * `}`

2.  **`InputDeviceType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum InputDeviceType { Keyboard, Pointer, Touchpad, Tablet, Touch, Joystick, Other }`
    * `Pointer` umfasst Maus und Trackball.

3.  **`InputDeviceSettings` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct InputDeviceSettings {`
        * `pub mouse_acceleration_profile: Option<MouseAccelerationProfile>,`
        * `pub mouse_speed_factor: Option<f64>,` // Skalierungsfaktor für Mausbewegung
        * `pub touchpad_tap_to_click: Option<bool>,`
        * `pub touchpad_natural_scrolling: Option<bool>,`
        * `pub touchpad_scroll_method: Option<TouchpadScrollMethod>,`
        * `pub keyboard_layout: Option<String>,` // Z.B. "de", "us"
        * `pub keyboard_repeat_rate: Option<u32>,` // Tastenwiederholrate (ms)
        * `pub keyboard_repeat_delay: Option<u32>,` // Tastenwiederholverzögerung (ms)
        * `// Weitere gerätespezifische Einstellungen hinzufügen`
    * `}`

4.  **`MouseAccelerationProfile` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum MouseAccelerationProfile { Adaptive, Flat, Custom }`

5.  **`TouchpadScrollMethod` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum TouchpadScrollMethod { TwoFinger, Edge, OnArea, None }`

6.  **`InputEvent` Enum (für den `EventBus`):**
    * Dies ist eine Verallgemeinerung der niedrig-level Events, die vom `libinput_backend` kommen und durch `key_mapper` verarbeitet werden.
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub enum InputEvent {`
        * `KeyPressed(Key),`
        * `KeyReleased(Key),`
        * `MouseMoved { delta_x: f64, delta_y: f64 },`
        * `MouseButtonPressed(MouseButton),`
        * `MouseButtonReleased(MouseButton),`
        * `MouseScrolled { delta_x: f64, delta_y: f64, scroll_method: ScrollMethod },`
        * `TouchpadTap(u32, TouchpadTapButton),` // Finger-ID, Button
        * `TouchpadScroll { delta_x: f64, delta_y: f64, fingers: u32 },`
        * `TouchEvent { id: u32, x: f64, y: f64, state: TouchState },`
        * `GestureEvent(Gesture),` // Pinch, Swipe etc.
        * `DeviceAdded(InputDeviceInfo),`
        * `DeviceRemoved(String),`
        * `// ... weitere spezifische Events (z.B. Joystick-Achsenbewegung)`
    * `}`

7.  **`Key` Struct/Enum (für `KeyPressed`/`KeyReleased`):**
    * `#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]`
    * `pub struct Key {`
        * `pub code: u32,` // Scancode oder Keysym
        * `pub name: String,` // Z.B. "Space", "A", "LeftShift"
        * `pub modifiers: Vec<KeyModifier>,` // Aktive Modifier (Shift, Ctrl, Alt)
    * `}`

8.  **`KeyModifier` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]`
    * `pub enum KeyModifier { Shift, Ctrl, Alt, Super, Fn }`

9.  **`MouseButton` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum MouseButton { Left, Right, Middle, Back, Forward, Other(u32) }`

10. **`ScrollMethod` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum ScrollMethod { Vertical, Horizontal, Pixels, Lines }`

11. **`TouchpadTapButton` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum TouchpadTapButton { Left, Right, Middle }`

12. **`TouchState` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum TouchState { Down, Motion, Up }`

13. **`Gesture` Enum:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub enum Gesture {`
        * `Pinch { fingers: u32, scale: f64, angle_delta: f64 },`
        * `Swipe { fingers: u32, direction: SwipeDirection, speed_x: f64, speed_y: f64 },`
        * `// ... weitere Gesten`
    * `}`

14. **`SwipeDirection` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum SwipeDirection { Up, Down, Left, Right }`

15. **`InputConfig` Struct (aus `config_service/data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct InputConfig {`
        * `pub keyboard_layout: String,`
        * `pub keyboard_repeat_rate: u32,`
        * `pub keyboard_repeat_delay: u32,`
        * `pub mouse_speed_factor: f64,`
        * `pub mouse_acceleration_profile: MouseAccelerationProfile,`
        * `pub touchpad_tap_to_click: bool,`
        * `pub touchpad_natural_scrolling: bool,`
        * `pub touchpad_scroll_method: TouchpadScrollMethod,`
        * `// ... weitere Einstellungen`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Eingabe-Informationen und Konfigurationen im System.
* Sie werden vom `InputEventManager` erzeugt und von der API des `InputService` verwendet.
* `InputEvent` wird über den `EventBus` gesendet.
* `InputConfig` wird im `ConfigService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Eingabeverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Mittel (ca. 3-4 Tage, da detaillierte Eingabe-Datenstrukturen und Event-Definitionen benötigt werden)

---
### **novade-system/src/input_service/manager.rs**

**Verantwortlichkeit:**
Der `InputEventManager` ist die Kernlogik des Eingabe-Subsystems. Er abstrahiert die Interaktion mit dem spezifischen Eingabe-Backend (`libinput_backend`), verwaltet den Zustand der Eingabegeräte und verarbeitet Eingabeereignisse. Er ist dafür verantwortlich, Roh-Events vom Backend in standardisierte `InputEvent`s umzuwandeln und diese über den `EventBus` zu dispatchieren. Er wendet auch systemweite Eingabeeinstellungen an.

**Kern-Aufgaben (Tasks):**

1.  **`InputEventManager` Struct:**
    * `pub struct InputEventManager {`
        * `backend: Arc<dyn InputBackend + Send + Sync>,` // Trait-Objekt für das gewählte Backend
        * `event_bus: EventBus,`
        * `active_devices: RwLock<HashMap<String, InputDeviceInfo>>,` // id -> InputDeviceInfo
        * `current_config: RwLock<InputConfig>,` // Aktuelle Input-Konfiguration
        * `key_mapper: Arc<KeyMapper>,` // Für Tastenkombinationen und Re-Mapping
        * `// Optional: Map für device-spezifische Einstellungen, die nicht global sind`
    * `}`

2.  **`InputEventManager::new()` Funktion:**
    * `pub async fn new(backend: Arc<dyn InputBackend + Send + Sync>, initial_input_config: InputConfig, event_bus: EventBus) -> Result<Self, InputError>`
    * **Logik:**
        * Initialisiert mit dem bereitgestellten Backend und `EventBus`.
        * Initialisiert `active_devices` durch Abfragen aller vorhandenen Geräte über das Backend.
        * Setzt `current_config` basierend auf `initial_input_config`.
        * Initialisiert `KeyMapper` mit initialem Tastaturlayout und anderen relevanten Einstellungen.
        * Startet einen Hintergrund-Task zum Abonnieren von Backend-Events (Geräteänderungen, Tastenanschläge, Mausbewegungen etc.) und zur Verarbeitung sowie zum Senden von `SystemEvent`s an den `EventBus`.
        * Wendet die initialen Konfigurationseinstellungen auf die Geräte an (z.B. Mausgeschwindigkeit, Tastaturlayout).
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** Fehler bei der Backend-Initialisierung.

3.  **`InputBackend` Trait:**
    * `pub trait InputBackend: Debug + Send + Sync {`
        * `async fn list_devices(&self) -> Result<Vec<InputDeviceInfo>, InputError>;`
        * `async fn get_device_settings(&self, device_id: &str) -> Result<InputDeviceSettings, InputError>;`
        * `async fn set_keyboard_layout(&self, layout: &str) -> Result<(), InputError>;`
        * `async fn set_pointer_acceleration(&self, device_id: &str, profile: MouseAccelerationProfile, factor: f64) -> Result<(), InputError>;`
        * `async fn set_touchpad_tap_to_click(&self, device_id: &str, enable: bool) -> Result<(), InputError>;`
        * `async fn set_touchpad_natural_scrolling(&self, device_id: &str, enable: bool) -> Result<(), InputError>;`
        * `async fn set_touchpad_scroll_method(&self, device_id: &str, method: TouchpadScrollMethod) -> Result<(), InputError>;`
        * `async fn set_keyboard_repeat_rate(&self, rate: u32, delay: u32) -> Result<(), InputError>;`
        * `async fn get_active_keyboard_layout(&self) -> Result<String, InputError>;`
        * `fn subscribe_to_events(&self) -> Box<dyn Stream<Item = RawInputEvent> + Send + Unpin>;` // Raw events from backend
    * `}`

4.  **`RawInputEvent` Enum (Intern im `libinput_backend.rs`):**
    * Repräsentiert die Events direkt vom `libinput` Backend, die noch nicht in `InputEvent` konvertiert wurden.
    * `pub enum RawInputEvent { Key(u32, KeyState), Motion(f64, f64), Touch(u32, f64, f64, TouchState), // ... }`

5.  **`InputEventManager::list_input_devices()` Methode:**
    * `pub async fn list_input_devices(&self) -> Result<Vec<InputDeviceInfo>, InputError>`
    * **Logik:** Ruft `self.backend.list_devices()` auf und gibt die Ergebnisse zurück. Aktualisiert den Cache.

6.  **`InputEventManager::get_device_settings()` Methode:**
    * `pub async fn get_device_settings(&self, device_id: &str) -> Result<InputDeviceSettings, InputError>`
    * **Logik:** Ruft `self.backend.get_device_settings(device_id)` auf.

7.  **`InputEventManager::set_keyboard_layout()` Methode:**
    * `pub async fn set_keyboard_layout(&self, layout: &str) -> Result<(), InputError>`
    * **Logik:**
        * Ruft `self.backend.set_keyboard_layout(layout)` auf.
        * Aktualisiert `current_config.keyboard_layout`.
        * Informiert `key_mapper` über die Layout-Änderung.
        * Sendet `SystemEvent::KeyboardLayoutChanged(layout.to_string())`.

8.  **`InputEventManager::set_mouse_acceleration()` / `set_touchpad_tap_to_click()` etc. Methoden:**
    * **Logik:** Delegieren an `self.backend` und aktualisieren `current_config`.

9.  **`InputEventManager::get_active_keyboard_layout()` Methode:**
    * `pub async fn get_active_keyboard_layout(&self) -> Result<String, InputError>`
    * **Logik:** Ruft `self.backend.get_active_keyboard_layout()` auf.

10. **`InputEventManager::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: InputConfig)`
    * **Logik:** Aktualisiert die interne `current_config` und wendet die Änderungen auf die Geräte über das Backend an (z.B. `set_pointer_acceleration`, `set_touchpad_tap_to_click`). Informiert `key_mapper` über relevante Änderungen.

11. **Hintergrund-Task zum Backend-Event-Processing:**
    * Ein dedizierter Task, der den `subscribe_to_events()` Stream des Backends konsumiert.
    * Bei jedem empfangenen `RawInputEvent`:
        * Verarbeitet das Raw-Event:
            * **Tastenereignisse:** Sendet an den `key_mapper` zur Interpretation (welche Taste, welche Modifier sind aktiv, ist es eine Tastenkombination?). `KeyMapper` gibt dann die endgültigen `Key` Events zurück.
            * **Mausbewegungen:** Konvertiert Roh-Delta in `MouseMoved`.
            * **Touchpad-Events:** Konvertiert in `TouchpadTap`, `TouchpadScroll`, `TouchEvent`, `GestureEvent`.
        * Übersetzt das verarbeitete Event in das entsprechende `SystemEvent`.
        * Sendet das `SystemEvent` an den `event_bus`.
    * Beispiele für RawInputEvent -> InputEvent -> SystemEvent:
        * `RawInputEvent::Key(scancode, state) -> key_mapper.process(scancode, state) -> InputEvent::KeyPressed(Key) -> SystemEvent::KeyPressed(Key)`
        * `RawInputEvent::Motion(dx, dy) -> InputEvent::MouseMoved { dx, dy } -> SystemEvent::MouseMoved { dx, dy }`
        * `RawInputEvent::DeviceAdded(info) -> InputEvent::DeviceAdded(info) -> SystemEvent::InputDeviceAdded(info)`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input_service::error::InputError`
    * `crate::input_service::data_types::{InputDeviceInfo, InputDeviceType, InputDeviceSettings, MouseAccelerationProfile, TouchpadScrollMethod, InputEvent, Key, KeyModifier, MouseButton, ScrollMethod, TouchpadTapButton, TouchState, Gesture, SwipeDirection, InputConfig}`
    * `crate::input_service::libinput_backend::{self, InputBackend, RawInputEvent}`
    * `crate::input_service::key_mapper::KeyMapper`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `std::collections::HashMap`
    * `tracing`
    * `futures::stream::Stream`

**Kommunikationsmuster:**

* Wird vom `InputService` verwendet.
* Kommuniziert mit dem spezifischen Eingabe-Backend über das `InputBackend` Trait.
* Nutzt `KeyMapper` für die Interpretation von Tastenereignissen.
* Sendet `SystemEvent`s an den `EventBus` bei Eingabeereignissen oder Zustandsänderungen.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Eingabe-Event-Manager, der Eingaben von verschiedenen Geräten verarbeiten, Einstellungen anwenden und systemweite Ereignisse auslösen kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Erstellen eines Mock-`InputBackend` Implementierung, die vordefinierte `RawInputEvent`s liefert und Aufrufe protokolliert.
    * Mocken des `EventBus` und `KeyMapper`.
    * Testen von `new`: Sicherstellen der Initialisierung und des initialen Scans/Statusabfrage vom Mock-Backend.
    * Testen von `list_input_devices`, `get_device_settings`, `set_keyboard_layout` etc.: Sicherstellen, dass die Aufrufe an das Mock-Backend weitergeleitet werden und die internen Zustände/Events korrekt sind.
    * Testen des Event-Processing-Tasks: Simulieren von `RawInputEvent`s vom Mock-Backend und Überprüfen, ob sie korrekt in `InputEvent`s umgewandelt und als `SystemEvent`s an den `EventBus` gesendet werden (unter Berücksichtigung des `KeyMapper`).
    * Testen von `update_config`.
* **Integration Tests (mit realen Eingabegeräten und Backend):**
    * Starten des `InputEventManager` mit einem realen Backend (`LibinputClient`).
    * Testen aller `InputBackend`-Methoden und Überprüfen des Verhaltens über CLI-Tools (`libinput debug-events`, `xinput`) oder durch visuelle Bestätigung.
    * Testen des Event-Monitorings: Physisches Drücken von Tasten, Bewegen der Maus, Ausführen von Touchpad-Gesten und Überprüfen, ob die entsprechenden `SystemEvent`s im `EventBus` ankommen.

**Geschätzter Aufwand:** Sehr Hoch (ca. 12-18 Tage, da Low-Level-Eingabebehandlung, Event-Transformation, gerätespezifische Einstellungen und die Interaktion mit dem KeyMapper)

---
### **novade-system/src/input_service/libinput_backend.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert das `InputBackend` Trait speziell für die Interaktion mit der `libinput` Bibliothek. Es ist für das Öffnen von Eingabegeräten, das Lesen von Roh-Eingabeereignissen und das Anwenden von gerätespezifischen Einstellungen über `libinput` verantwortlich.

**Kern-Aufgaben (Tasks):**

1.  **`LibinputClient` Struct:**
    * `pub struct LibinputClient {`
        * `libinput_context: libinput::Context,` // libinput context
        * `event_source: libinput::Device<'static>,` // Event source for polling
        * `backend_event_sender: mpsc::Sender<RawInputEvent>,` // Sender für Raw-Events an InputEventManager
        * `// Optional: Map von libinput::Device zu NovaDE::InputDeviceInfo`
    * `}`

2.  **`LibinputClient::new()` Funktion:**
    * `pub async fn new() -> Result<Self, InputError>`
    * **Logik:**
        * Erstellt einen `libinput::Context`.
        * Verwendet `libinput::udev::new_from_udev` oder `libinput::path::new_from_path` (je nach Berechtigungen und System).
        * Setzt den `libinput_context` auf "normal mode" oder "seat mode" (abhängig von den Anforderungen).
        * Startet den internen `libinput` Event-Polling-Loop.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `BackendInitializationFailed` (z.B. keine Berechtigungen, libinput-Initialisierung fehlgeschlagen).

3.  **Implementierung des `InputBackend` Trait für `LibinputClient`:**

    * **`list_devices(&self) -> Result<Vec<InputDeviceInfo>, InputError>`:**
        * **Logik:** Iteriert über die Geräte im `libinput_context` (`libinput.get_device_list()`).
        * Für jedes `libinput::Device`, extrahiert Informationen wie Name, Product ID, Vendor ID, Typen (Tastatur, Maus, Touchpad).
        * Erstellt initiale `InputDeviceInfo` und `InputDeviceSettings` basierend auf `libinput` Properties (z.B. `libinput_device_config_accel_get_profiles`, `libinput_device_config_tap_get_enabled`).
    * **`get_device_settings(&self, device_id: &str) -> Result<InputDeviceSettings, InputError>`:**
        * **Logik:** Findet das `libinput::Device` anhand der `device_id` und fragt dessen aktuelle Konfigurationseinstellungen ab.
    * **`set_keyboard_layout(&self, layout: &str) -> Result<(), InputError>`:**
        * **Logik:** libinput selbst verwaltet keine Tastaturlayouts. Dies muss typischerweise über `xkbcommon` oder direkt über die X11/Wayland-Display-Server-APIs erfolgen. Wenn NovaDE Wayland-native ist, müsste dies über den Wayland-Protokoll-Composer geschehen.
        * **Alternative:** Wenn NovaDE einen eigenen Compositor verwendet, ist dieser für das Setzen des Layouts verantwortlich. Dieses Backend könnte dann nur signalisieren, dass das Layout geändert werden soll. Oder es wird ein `xkbcommon` Kontext erstellt und dessen Layout angewendet.
        * **Annahme für jetzt:** Dies ist ein Platzhalter und erfordert eine engere Integration mit dem Compositor oder einer separaten `xkbcommon`-basierte Logik im `manager.rs` oder einem neuen Modul. Für MVP kann es auch eine externe Shell-Befehls-Ausführung sein (z.B. `localectl set-keymap`).
    * **`set_pointer_acceleration(&self, device_id: &str, profile: MouseAccelerationProfile, factor: f64) -> Result<(), InputError>`:**
        * **Logik:** Findet das `libinput::Device` und verwendet `libinput_device_config_accel_set_profile` und `libinput_device_config_accel_set_speed`.
    * **`set_touchpad_tap_to_click(&self, device_id: &str, enable: bool) -> Result<(), InputError>`:**
        * **Logik:** Findet das `libinput::Device` und verwendet `libinput_device_config_tap_set_enabled`.
    * **`set_touchpad_natural_scrolling(&self, device_id: &str, enable: bool) -> Result<(), InputError>`:**
        * **Logik:** Findet das `libinput::Device` und verwendet `libinput_device_config_scroll_set_natural_scroll_enabled`.
    * **`set_touchpad_scroll_method(&self, device_id: &str, method: TouchpadScrollMethod) -> Result<(), InputError>`:**
        * **Logik:** Findet das `libinput::Device` und verwendet `libinput_device_config_scroll_set_method`.
    * **`set_keyboard_repeat_rate(&self, rate: u32, delay: u32) -> Result<(), InputError>;`:**
        * **Logik:** Ähnlich wie Tastaturlayout: Dies wird oft vom Display-Server oder einer separaten Tastatur-Konfigurations-Utility gehandhabt. `libinput` selbst hat keine direkte API dafür. Eventuell muss hier auch ein externer Aufruf (z.B. `xset r rate`) erfolgen oder es ist Aufgabe des Compositors.
    * **`get_active_keyboard_layout(&self) -> Result<String, InputError>;`:**
        * **Logik:** Auch hier müsste der Compositor oder ein `xkbcommon` Kontext befragt werden, da `libinput` dies nicht direkt bereitstellt.
    * **`subscribe_to_events(&self) -> Box<dyn Stream<Item = RawInputEvent> + Send + Unpin>;`:**
        * **Logik:** Startet einen asynchronen Task, der kontinuierlich `libinput_context.dispatch()` aufruft und die empfangenen `libinput::Event`s verarbeitet.
        * Konvertiert `libinput::Event`s in die interne `RawInputEvent` Repräsentation und sendet sie über den `mpsc::channel`.
        * Handhabt verschiedene Event-Typen: `libinput::Event::Key`, `libinput::Event::PointerMotion`, `libinput::Event::Touchpad`, `libinput::Event::DeviceAdded`, `libinput::Event::DeviceRemoved`.

4.  **`RawInputEvent` Enum:**
    * `pub enum RawInputEvent {`
        * `Key { device_id: String, code: u32, state: KeyState },`
        * `Motion { device_id: String, delta_x: f64, delta_y: f64 },`
        * `Button { device_id: String, button: u32, state: ButtonState },`
        * `Scroll { device_id: String, delta_v: f64, delta_h: f64, method: ScrollMethod },`
        * `Touch { device_id: String, slot: i32, x: f64, y: f64, pressure: f64, state: TouchState },`
        * `Gesture { device_id: String, gesture_type: GestureType, fingers: u32, data: GestureData },`
        * `DeviceAdded(InputDeviceInfo),`
        * `DeviceRemoved(String),`
    * `}`

5.  **`KeyState` Enum:**
    * `pub enum KeyState { Pressed, Released }`

6.  **`ButtonState` Enum:**
    * `pub enum ButtonState { Pressed, Released }`

7.  **`TouchState` Enum (für Raw-Events):**
    * `pub enum TouchState { Down, Up, Motion }`

8.  **`GestureType` Enum und `GestureData` Structs (für Raw-Events):**
    * Detailliertere Repräsentation der Roh-Gestendaten von `libinput`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/libinput_backend.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input_service::error::InputError`
    * `crate::input_service::data_types::{InputDeviceInfo, InputDeviceSettings, InputDeviceType, MouseAccelerationProfile, TouchpadScrollMethod, ScrollMethod}`
    * Trait `InputBackend`
* **Extern:**
    * `libinput` crate (Rust bindings for libinput)
    * `tokio::task`
    * `tokio::sync::mpsc`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `tracing`
    * `futures::stream::Stream`
    * `udev` crate (für device enumeration, wenn nicht direkt über libinput)

**Kommunikationsmuster:**

* Wird vom `InputEventManager` instanziiert und verwendet.
* Kommuniziert direkt mit der `libinput` Bibliothek.
* Sendet interne `RawInputEvent`s an den `InputEventManager` über einen Channel.

**Erwartete Ergebnisse/Outputs:**
Eine funktionsfähige Implementierung des `InputBackend` Trait für `libinput`, die Roh-Eingabeereignisse liest und gerätespezifische Einstellungen anwenden kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit `libinput` Mocking/Simulierung):**
    * Verwendung von `libinput` Test-Tools (z.B. `libinput-debug-events --enable-touch-gestures`) oder Mocking der `libinput` Bibliothek (falls möglich), um Geräte- und Ereignisströme zu simulieren.
    * Testen jeder Methode (`list_devices`, `set_pointer_acceleration` etc.), um sicherzustellen, dass sie die korrekten `libinput`-API-Aufrufe machen und die Ergebnisse korrekt konvertieren.
    * Testen der Event-Emittierung: Sicherstellen, dass simulierte `libinput::Event`s korrekt in `RawInputEvent`s umgewandelt und gesendet werden.
* **Integration Tests (mit realen Eingabegeräten und `libinput`):**
    * Starten des `LibinputClient` auf einem System mit angeschlossenen Eingabegeräten.
    * Testen aller `InputBackend`-Methoden und Überprüfen des Verhaltens über `libinput debug-events` oder durch physische Interaktion.
    * Testen des Event-Monitorings: Physisches Drücken von Tasten, Bewegen der Maus, Ausführen von Touchpad-Gesten und Überprüfen, ob die `RawInputEvent`s korrekt vom Backend gelesen werden.

**Geschätzter Aufwand:** Sehr Hoch (ca. 15-25 Tage, da tiefe Kenntnisse der `libinput` API, Event-Loop-Integration und genaue Event-Konvertierung erforderlich sind; Tastaturlayout/Repeat-Rate können zusätzliche Komplexität durch Display-Server-Interaktion mit sich bringen)

---
### **novade-system/src/input_service/key_mapper.rs**

**Verantwortlichkeit:**
Das `key_mapper` Modul ist für die Interpretation von Tastaturereignissen, die Verwaltung von Tastenkombinationen (Shortcuts) und die mögliche Neu-Zuordnung von Tasten verantwortlich. Es übersetzt rohe Tastencodes von `libinput_backend` in bedeutungsvollere `Key` Events und erkennt vordefinierte Shortcuts.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/input_service/`
    * `key_mapper.rs` (Dieses Modul)

**Kern-Aufgaben (Tasks):**

1.  **`KeyMapper` Struct:**
    * `pub struct KeyMapper {`
        * `xkb_context: RwLock<xkbcommon::xkb::Context>,` // XKB context for keymap handling
        * `xkb_state: RwLock<xkbcommon::xkb::State>,` // XKB state for modifier tracking and keycode to keysym conversion
        * `active_shortcuts: RwLock<HashMap<Shortcut, ShortcutAction>>,` // Konfigurierte Shortcuts
        * `current_modifiers: AtomicUsize,` // Bitmaske der aktuell gedrückten Modifier-Tasten
        * `// Optional: Dead-key / compose-key state`
    * `}`

2.  **`KeyMapper::new()` Funktion:**
    * `pub async fn new(initial_keyboard_layout: &str) -> Result<Self, InputError>`
    * **Logik:**
        * Initialisiert einen `xkbcommon::xkb::Context`.
        * Lädt ein Keymap basierend auf dem `initial_keyboard_layout` (z.B. `xkbcommon::xkb::Keymap::new_from_names`).
        * Erstellt einen `xkbcommon::xkb::State` aus dem Keymap.
        * Lädt initial konfigurierte `active_shortcuts` (z.B. aus einer Konfigurationsdatei oder einem Standardset).
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** Fehler beim Laden des Keymaps oder Initialisieren des XKB-Kontextes.

3.  **`Shortcut` Struct (Intern oder in `data_types.rs`):**
    * `#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]`
    * `pub struct Shortcut {`
        * `pub key_code: u32,` // Haupt-Keycode
        * `pub modifiers: Vec<KeyModifier>,` // Benötigte Modifier (Ctrl, Shift, Alt, Super)
    * `}`

4.  **`ShortcutAction` Enum (Intern oder in `data_types.rs`):**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum ShortcutAction {`
        * `LaunchApp(String),` // App-ID
        * `RunCommand(String),`
        * `ToggleVolumeMute,`
        * `IncreaseVolume,`
        * `DecreaseVolume,`
        * `Screenshot,`
        * `ToggleWorkspace,`
        * `// ... weitere Aktionen`
    * `}`

5.  **`KeyMapper::process_key_event()` Methode:**
    * `pub async fn process_key_event(&self, device_id: &str, scancode: u32, key_state: KeyState) -> Vec<InputEvent>`
    * **Logik:**
        * Aktualisiert den `xkb_state` mit dem neuen Scancode und Zustand (`xkb_state.update_key`).
        * Aktualisiert die interne `current_modifiers` Bitmaske basierend auf dem `xkb_state`.
        * Konvertiert den Scancode in einen `keysym` und dann in einen Zeichen-String (wenn es sich um eine Text-Taste handelt, z.B. 'A', 'b', '1').
        * Erstellt ein `InputEvent::KeyPressed` oder `InputEvent::KeyReleased` mit dem `Key` Struct (enthält Scancode, Name, Modifier).
        * **Shortcut-Erkennung:** Wenn `key_state` `Pressed` ist, überprüft, ob die Kombination aus `scancode` und `current_modifiers` einer der `active_shortcuts` entspricht. Wenn ja, fügt ein `InputEvent::ShortcutTriggered(ShortcutAction)` hinzu (oder ein spezifischeres Event).
        * Gibt eine `Vec<InputEvent>` zurück, da ein einzelnes physisches Tastaturereignis zu mehreren logischen Events führen kann (z.B. Shortcut + Text-Input).

6.  **`KeyMapper::set_keyboard_layout()` Methode:**
    * `pub async fn set_keyboard_layout(&self, layout: &str) -> Result<(), InputError>`
    * **Logik:**
        * Erstellt ein neues `xkbcommon::xkb::Keymap` und `xkbcommon::xkb::State` basierend auf dem neuen Layout.
        * Aktualisiert die internen `RwLock`s.

7.  **`KeyMapper::add_shortcut()` / `remove_shortcut()` Methode:**
    * `pub async fn add_shortcut(&self, shortcut: Shortcut, action: ShortcutAction) -> Result<(), InputError>`
    * `pub async fn remove_shortcut(&self, shortcut: &Shortcut) -> Result<(), InputError>`
    * **Logik:** Fügt Shortcuts zur `active_shortcuts` Map hinzu oder entfernt sie. Speichert Änderungen persistierend über den `ConfigService` (nicht direkt hier, sondern durch den `InputEventManager`).

8.  **`KeyMapper::get_active_shortcuts()` Methode:**
    * `pub fn get_active_shortcuts(&self) -> Vec<(Shortcut, ShortcutAction)>`
    * **Logik:** Gibt eine Liste der aktuell konfigurierten Shortcuts zurück.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/key_mapper.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input_service::error::InputError`
    * `crate::input_service::data_types::{InputEvent, Key, KeyModifier, KeyState}` (KeyState hier für interne Verarbeitung)
* **Extern:**
    * `xkbcommon` crate (Rust bindings for libxkbcommon)
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `std::sync::atomic::{AtomicUsize, Ordering}`
    * `std::collections::HashMap`
    * `tracing`

**Kommunikationsmuster:**

* Wird vom `InputEventManager` verwendet, um Tastatur-Raw-Events zu verarbeiten.
* Empfängt Layout-Updates vom `InputEventManager`.

**Erwartete Ergebnisse/Outputs:**
Eine funktionsfähige Tasten-Mapper-Komponente, die Tastatureingaben interpretiert, Modifier-Status verwaltet und konfigurierte Tastenkombinationen erkennt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken von `xkbcommon` (falls nötig und möglich, ansonsten reale `xkbcommon` verwenden).
    * Testen der `new` Funktion mit verschiedenen Layouts.
    * Testen von `process_key_event`:
        * Einzelne Tastenanschläge (A, B, Space).
        * Tasten mit Modifikatoren (Shift+A, Ctrl+C).
        * Komplexe Tastenkombinationen (Ctrl+Alt+T).
        * Überprüfen, ob `InputEvent::KeyPressed`, `InputEvent::KeyReleased` und `InputEvent::ShortcutTriggered` korrekt generiert werden.
        * Testen von Dead Keys/Compose Keys (optional, komplex).
    * Testen von `set_keyboard_layout` und `get_active_keyboard_layout`.
    * Testen von `add_shortcut` und `remove_shortcut`.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da komplexe Interaktion mit `libxkbcommon` und Logik für Shortcut-Erkennung)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `power_manager`, widmen wir uns `input_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/input_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/input_service/data_types.rs`**: Definition der grundlegenden Datentypen für Eingabe-Komponenten und Events.
3.  **`novade-system/src/input_service/libinput_backend.rs`**: Implementierung des spezifischen `libinput`-Backends, da dies die komplexeste und tiefste Systeminteraktion erfordert und die Roh-Events bereitstellt.
4.  **`novade-system/src/input_service/key_mapper.rs`**: Die Logik zur Interpretation von Tastatur-Roh-Events und zur Erkennung von Shortcuts, die vom `libinput_backend` kommen.
5.  **`novade-system/src/input_service/manager.rs`**: Die Kernlogik zur Verwaltung von Eingabegeräten und zum Event-Dispatching, die das `libinput_backend` und den `key_mapper` nutzt.
6.  **`novade-system/src/input_service/mod.rs`**: Das Hauptmodul, das das Backend, den Manager und den KeyMapper initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/input_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/display_manager` Verzeichnisses, um die Display-Verwaltung zu kontrollieren.
---
### **novade-system/src/display_manager/mod.rs**

**Verantwortlichkeit:**
Das `display_manager` Modul ist die zentrale Schnittstelle für die Verwaltung von Displays und Grafikausgabe. Es abstrahiert die zugrunde liegenden System-APIs (z.B. DRM/KMS, Wayland-Komponierung, X11 RandR) und bietet eine einheitliche Schnittstelle für andere NovaDE-Komponenten zur Erkennung, Konfiguration und Verwaltung von Monitoren, Auflösungen, Bildwiederholraten, Skalierung und Bildschirmhelligkeit. Es ist auch der Einstiegspunkt für die Komponierung des Desktops.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/display_manager/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Display-Operationen)
    * `manager.rs` (Logik für Display-Erkennung, Konfiguration und Komponierung)
    * `data_types.rs` (Definition von Display-bezogenen Datentypen)
    * `drm_backend.rs` (Implementierung für DRM/KMS, primär für Wayland-Kompositor)
    * `x11_backend.rs` (Implementierung für X11 RandR, falls X11-Support benötigt wird)
    * `wayland_compositor.rs` (Wayland-spezifische Kompositor-Logik)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Display-Subsystems:**
    * `pub async fn initialize_display_manager(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<DisplayManagerService, DisplayError>`
    * **Logik:**
        * Bestimmt das bevorzugte oder unterstützte Display-Backend (Wayland/DRM-KMS oder X11). Priorität sollte Wayland/DRM-KMS sein.
        * Erstellt eine Instanz von `manager::DisplayManager` (oder `manager::WaylandCompositor` direkt, wenn NovaDE ein Wayland-Kompositor ist), die die eigentliche Logik zur Display-Verwaltung und -Komponierung enthält.
        * Ruft die initialen Display-Einstellungen aus dem `config_service` ab (z.B. `primary_output`, `resolution`, `refresh_rate`, `scaling_factor`, `night_light_enabled`).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Display-Einstellungen zu laden.
        * Startet den Display-Server (Kompositor), falls NovaDE ein Wayland-Kompositor ist, oder verbindet sich mit einem bestehenden X11-Server.
        * Registriert sich für Events vom Display-Backend (z.B. Monitor angeschlossen/entfernt, Auflösungsänderung, Helligkeitsänderung).
        * Gibt ein gebündeltes `DisplayManagerService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Backend-Initialisierung oder der Verbindung zum Display-Server.

2.  **`DisplayManagerService` Struct:**
    * `pub struct DisplayManagerService {`
        * `manager: Arc<DisplayManager>,` // oder `WaylandCompositor`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
    * `}`
    * Dient als Container und Zugangspunkt für die Display-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `DisplayManagerService` exponiert Methoden zur Abfrage und Steuerung von Display-Einstellungen.
    * **`list_outputs(&self) -> Result<Vec<OutputInfo>, DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um eine Liste aller erkannten physikalischen oder virtuellen Displays zurückzugeben.
    * **`get_output_settings(&self, output_id: &str) -> Result<OutputSettings, DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um die aktuellen Einstellungen für einen spezifischen Output abzurufen.
    * **`set_output_resolution(&self, output_id: &str, resolution: Resolution, refresh_rate: u32) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um die Auflösung und Bildwiederholrate eines Outputs zu ändern. Speichert die Einstellung im `config_service`. Sendet `SystemEvent::OutputSettingsChanged`.
    * **`set_output_scaling(&self, output_id: &str, scale: f64) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um den Skalierungsfaktor eines Outputs zu ändern. Speichert die Einstellung im `config_service`. Sendet `SystemEvent::OutputSettingsChanged`.
    * **`set_primary_output(&self, output_id: &str) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um den primären Output zu setzen. Speichert die Einstellung im `config_service`. Sendet `SystemEvent::PrimaryOutputChanged`.
    * **`set_output_enabled(&self, output_id: &str, enabled: bool) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um einen Output zu aktivieren oder zu deaktivieren.
    * **`set_output_position(&self, output_id: &str, x: i32, y: i32) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um die Position eines Outputs im virtuellen Desktop-Bereich zu setzen.
    * **`get_screen_brightness(&self, output_id: Option<&str>) -> Result<u8, DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um die Bildschirmhelligkeit eines spezifischen oder des primären Displays abzufragen. (Kann auch in `power_manager` sein, aber hier ist für Display-spezifische Helligkeit besser).
    * **`set_screen_brightness(&self, output_id: Option<&str>, brightness_percent: u8) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um die Bildschirmhelligkeit zu setzen. Speichert die Einstellung im `config_service`. Sendet `SystemEvent::ScreenBrightnessChanged`.
    * **`enable_night_light(&self, enable: bool) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um die Nachtlichtfunktion zu aktivieren/deaktivieren. Speichert die Einstellung im `config_service`.
    * **`set_night_light_temperature(&self, temperature_k: u32) -> Result<(), DisplayError>`:**
        * **Logik:** Delegiert an den `DisplayManager`, um die Farbtemperatur des Nachtlichts einzustellen. Speichert die Einstellung im `config_service`.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `DisplayManagerService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Display-Einstellungen in der Konfiguration geändert werden, werden die Sub-Komponenten (`DisplayManager` oder `WaylandCompositor`) informiert.

5.  **Hintergrund-Task zum Abonnieren von Backend-Events:**
    * Ein weiterer Task sollte Events vom ausgewählten Display-Backend (`drm_backend` oder `x11_backend` oder `wayland_compositor`) abonnieren und diese in `SystemEvent`s übersetzen, um den `EventBus` zu informieren.
    * Beispiele: `SystemEvent::OutputConnected`, `SystemEvent::OutputDisconnected`, `SystemEvent::OutputSettingsChanged`, `SystemEvent::ScreenBrightnessChanged`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_manager/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::display_manager::error::DisplayError`
    * `crate::display_manager::manager::DisplayManager` (oder `wayland_compositor::WaylandCompositor`)
    * `crate::display_manager::data_types::{OutputInfo, OutputSettings, Resolution}`
    * `crate::display_manager::drm_backend`
    * `crate::display_manager::x11_backend`
    * `crate::display_manager::wayland_compositor`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Ist der primäre Consumer von Display-Anfragen von der Domänenschicht und der UI.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Display-Einstellungen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten und andere Systemdienste über Display-Statusänderungen oder Ereignisse zu informieren.
* Empfängt Events vom gewählten Display-Backend/Kompositor.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Display-Subsystem, das Displays verwalten, konfigurieren und Events bezüglich der Anzeige verarbeiten kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus` und des gewählten Display-Backend-Clients/Kompositors.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und der Backend-Verbindung.
    * Testen der Weiterleitung von API-Aufrufen an den `DisplayManager`/`WaylandCompositor`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von Events vom Display-Backend und Überprüfen, ob die korrekten `SystemEvent`s an den `EventBus` gesendet werden.
* **Integration Tests (mit realer Hardware/Display-Server):**
    * Starten des `DisplayManagerService` auf einem System mit angeschlossenen Displays.
    * Testen von `list_outputs`, `get_output_settings`.
    * Manuelles Ändern von Auflösungen, Skalierungen, Primär-Outputs über NovaDE-UI oder System-Tools und Überprüfen, ob die Änderungen erkannt und Events gesendet werden.
    * Testen von Helligkeits- und Nachtlicht-Funktionen.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da Interaktion mit Low-Level-Grafik-APIs oder Display-Servern, Event-Handling und Konfigurationsmanagement komplex sein können)

---
### **novade-system/src/display_manager/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `display_manager` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Display-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`DisplayError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum DisplayError {`
        * `#[error("Failed to initialize display backend: {0}")]`
        * `BackendInitializationFailed(String),`
        * `#[error("Output not found: {0}")]`
        * `OutputNotFound(String),`
        * `#[error("Unsupported resolution or refresh rate for output '{0}': {1}@{2}Hz")]`
        * `UnsupportedMode(String, u32, u32),`
        * `#[error("Failed to set display property: {0}")]`
        * `SetPropertyError(String),`
        * `#[error("Permission denied for display operation: {0}")]`
        * `PermissionDenied(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Backend specific error: {0}")]`
        * `BackendError(String),` // Wrapper für DRM, X11 oder Wayland Composer spezifische Fehler
        * `#[error("I/O error: {0}")]`
        * `IoError(#[from] std::io::Error),`
        * `#[error("Unknown display error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `std::io::Error` und `anyhow::Error`. Füge spezifische Fehler von DRM/X11/Wayland-Bibliotheken hinzu.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_manager/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::io::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `display_manager` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Display-System.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/display_manager/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `display_manager` verwendet werden, um Display-Outputs, deren Fähigkeiten, Einstellungen und Ereignisse zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`OutputInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct OutputInfo {`
        * `pub id: String,` // Eindeutiger Bezeichner des Outputs (z.B. DRM-Connector Name, XRandR Output Name)
        * `pub name: String,` // Anzeigename (z.B. "DP-1", "HDMI-A-1", "Laptop Display")
        * `pub model: Option<String>,`
        * `pub vendor: Option<String>,`
        * `pub serial: Option<String>,`
        * `pub is_connected: bool,`
        * `pub is_primary: bool,`
        * `pub current_settings: OutputSettings,`
        * `pub supported_modes: Vec<VideoMode>,` // Liste der unterstützten Auflösungen und Bildwiederholraten
        * `pub supported_scales: Vec<f64>,` // Liste der unterstützten Skalierungsfaktoren
        * `pub physical_size_mm: Option<Size2D>,` // Physikalische Größe des Displays in mm
    * `}`

2.  **`OutputSettings` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct OutputSettings {`
        * `pub enabled: bool,`
        * `pub x_pos: i32,`
        * `pub y_pos: i32,`
        * `pub resolution: Resolution,`
        * `pub refresh_rate: u32,` // in Hz
        * `pub scaling_factor: f64,` // Z.B. 1.0, 1.25, 2.0
        * `pub rotation: Rotation,`
        * `pub brightness_percent: u8,` // 0-100
        * `pub night_light_active: bool,`
        * `pub night_light_temperature_k: u32,` // Farbtemperatur in Kelvin (z.B. 6500K für normal, 2700K für warm)
    * `}`

3.  **`Resolution` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]`
    * `pub struct Resolution {`
        * `pub width: u32,`
        * `pub height: u32,`
    * `}`

4.  **`VideoMode` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]`
    * `pub struct VideoMode {`
        * `pub resolution: Resolution,`
        * `pub refresh_rate: u32,` // in Hz
    * `}`

5.  **`Rotation` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum Rotation { Normal, Left, Right, Inverted }`

6.  **`Size2D` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct Size2D {`
        * `pub width: u32,`
        * `pub height: u32,`
    * `}`

7.  **`DisplayConfig` Struct (aus `config_service/data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct DisplayConfig {`
        * `pub primary_output_id: Option<String>,`
        * `pub outputs: HashMap<String, PerOutputConfig>,` // id -> settings
        * `pub night_light_enabled: bool,`
        * `pub night_light_temperature_k: u32,`
        * `pub screen_brightness_percent: u8,` // Globaler Fallback oder für alle Outputs
        * `// ... weitere Einstellungen`
    * `}`

8.  **`PerOutputConfig` Struct (innerhalb `DisplayConfig`):**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct PerOutputConfig {`
        * `pub resolution: Option<Resolution>,`
        * `pub refresh_rate: Option<u32>,`
        * `pub scaling_factor: Option<f64>,`
        * `pub x_pos: Option<i32>,`
        * `pub y_pos: Option<i32>,`
        * `pub rotation: Option<Rotation>,`
        * `pub brightness_percent: Option<u8>,`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_manager/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::collections::HashMap`

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Display-Informationen und Konfigurationen im System.
* Sie werden vom `DisplayManager` (oder `WaylandCompositor`) erzeugt und von der API des `DisplayManagerService` verwendet.
* `DisplayConfig` wird im `ConfigService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Display-Verwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage, da detaillierte Display-Datenstrukturen und Konfigurationsoptionen benötigt werden)

---
### **novade-system/src/display_manager/manager.rs**

**Verantwortlichkeit:**
Der `DisplayManager` ist die Kernlogik des Display-Subsystems (falls NovaDE kein vollständiger Wayland-Kompositor ist und sich auf X11 oder ein anderes Backend stützt). Er abstrahiert die Interaktion mit dem spezifischen Display-Backend (`drm_backend` oder `x11_backend`), verwaltet den Zustand der Displays und wendet Konfigurationseinstellungen an. Im Wayland-Fall wird ein Großteil dieser Logik direkt im `wayland_compositor.rs` oder sogar in einem spezifischen `libdisplay` oder `wlroots` Wrapper behandelt. Für die aktuelle Spezifikation nehmen wir an, dass `DisplayManager` als Abstraktionsschicht agiert, die je nach gewähltem Backend unterschiedliche Implementierungen nutzt.

**Kern-Aufgaben (Tasks):**

1.  **`DisplayManager` Struct:**
    * `pub struct DisplayManager {`
        * `backend: Arc<dyn DisplayBackend + Send + Sync>,` // Trait-Objekt für das gewählte Backend
        * `event_bus: EventBus,`
        * `active_outputs: RwLock<HashMap<String, OutputInfo>>,` // id -> OutputInfo
        * `current_config: RwLock<DisplayConfig>,` // Aktuelle Display-Konfiguration
        * `// Optional: Timer für Night Light, Helligkeitsanpassung`
    * `}`

2.  **`DisplayManager::new()` Funktion:**
    * `pub async fn new(backend: Arc<dyn DisplayBackend + Send + Sync>, initial_display_config: DisplayConfig, event_bus: EventBus) -> Result<Self, DisplayError>`
    * **Logik:**
        * Initialisiert mit dem bereitgestellten Backend und `EventBus`.
        * Initialisiert `active_outputs` durch Abfragen aller vorhandenen Displays über das Backend.
        * Setzt `current_config` basierend auf `initial_display_config`.
        * Startet einen Hintergrund-Task zum Abonnieren von Backend-Events (Output angeschlossen/entfernt, Modusänderungen) und zur Verarbeitung sowie zum Senden von `SystemEvent`s an den `EventBus`.
        * Wendet die initialen Konfigurationseinstellungen auf die Displays an (z.B. Auflösungen, Skalierungen, Positionen, Night Light Status).
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** Fehler bei der Backend-Initialisierung.

3.  **`DisplayBackend` Trait:**
    * `pub trait DisplayBackend: Debug + Send + Sync {`
        * `async fn list_outputs(&self) -> Result<Vec<OutputInfo>, DisplayError>;`
        * `async fn get_output_settings(&self, output_id: &str) -> Result<OutputSettings, DisplayError>;`
        * `async fn set_output_mode(&self, output_id: &str, resolution: Resolution, refresh_rate: u32) -> Result<(), DisplayError>;`
        * `async fn set_output_scale(&self, output_id: &str, scale: f64) -> Result<(), DisplayError>;`
        * `async fn set_output_position(&self, output_id: &str, x: i32, y: i32) -> Result<(), DisplayError>;`
        * `async fn set_output_enabled(&self, output_id: &str, enabled: bool) -> Result<(), DisplayError>;`
        * `async fn set_screen_brightness(&self, output_id: &str, brightness_percent: u8) -> Result<(), DisplayError>;`
        * `async fn apply_night_light_color_temperature(&self, temperature_k: u32) -> Result<(), DisplayError>;` // Global
        * `async fn disable_night_light(&self) -> Result<(), DisplayError>;`
        * `fn subscribe_to_events(&self) -> Box<dyn Stream<Item = BackendDisplayEvent> + Send + Unpin>;` // Raw events from backend
    * `}`

4.  **`BackendDisplayEvent` Enum (Intern im `drm_backend.rs`/`x11_backend.rs`):**
    * Repräsentiert die Events direkt vom Backend, die noch nicht in `SystemEvent` konvertiert wurden.
    * `pub enum BackendDisplayEvent {`
        * `OutputConnected(OutputInfo),`
        * `OutputDisconnected(String),` // ID des entfernten Outputs
        * `OutputSettingsChanged(OutputInfo),` // Z.B. Auflösung, Position
        * `BrightnessChanged { output_id: String, brightness_percent: u8 },`
    * `}`

5.  **`DisplayManager::list_outputs()` Methode:**
    * `pub async fn list_outputs(&self) -> Result<Vec<OutputInfo>, DisplayError>`
    * **Logik:** Ruft `self.backend.list_outputs()` auf und aktualisiert den Cache `active_outputs`.

6.  **`DisplayManager::get_output_settings()` Methode:**
    * `pub async fn get_output_settings(&self, output_id: &str) -> Result<OutputSettings, DisplayError>`
    * **Logik:** Ruft `self.backend.get_output_settings(output_id)` auf oder den gecachten Wert aus `active_outputs`.

7.  **`DisplayManager::set_output_resolution()` Methode:**
    * `pub async fn set_output_resolution(&self, output_id: &str, resolution: Resolution, refresh_rate: u32) -> Result<(), DisplayError>`
    * **Logik:**
        * Validiert den Modus gegen `supported_modes` des Outputs.
        * Ruft `self.backend.set_output_mode(output_id, resolution, refresh_rate)` auf.
        * Aktualisiert `active_outputs` und `current_config`.
        * Sendet `SystemEvent::OutputSettingsChanged(OutputInfo)`.

8.  **`DisplayManager::set_output_scaling()` / `set_primary_output()` etc. Methoden:**
    * **Logik:** Delegieren an `self.backend` und aktualisieren `current_config` sowie senden entsprechende `SystemEvent`s. `set_primary_output` aktualisiert den `is_primary` Flag in `OutputInfo`.

9.  **`DisplayManager::set_screen_brightness()` Methode:**
    * `pub async fn set_screen_brightness(&self, output_id: Option<&str>, brightness_percent: u8) -> Result<(), DisplayError>`
    * **Logik:**
        * Wenn `output_id` gegeben, delegiert an `self.backend.set_screen_brightness(output_id, brightness_percent)`.
        * Wenn `output_id` `None`, wendet die Helligkeit auf alle Outputs an (oder den primären), abhängig von der Backend-Fähigkeit.
        * Aktualisiert `current_config` und sendet `SystemEvent::ScreenBrightnessChanged`.

10. **`DisplayManager::enable_night_light()` / `set_night_light_temperature()` Methoden:**
    * **Logik:** Delegieren an `self.backend.apply_night_light_color_temperature` oder `disable_night_light`. Aktualisieren `current_config` und senden entsprechende `SystemEvent`s.

11. **`DisplayManager::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: DisplayConfig)`
    * **Logik:** Aktualisiert die interne `current_config` und wendet die Änderungen auf die Displays über das Backend an.

12. **Hintergrund-Task zum Backend-Event-Processing:**
    * Ein dedizierter Task, der den `subscribe_to_events()` Stream des Backends konsumiert.
    * Bei jedem empfangenen `BackendDisplayEvent`:
        * Aktualisiert den internen Zustand (`active_outputs`).
        * Übersetzt das Event in das entsprechende `SystemEvent`.
        * Sendet das `SystemEvent` an den `event_bus`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_manager/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::display_manager::error::DisplayError`
    * `crate::display_manager::data_types::{OutputInfo, OutputSettings, Resolution, VideoMode, Rotation, Size2D, DisplayConfig, PerOutputConfig}`
    * `crate::display_manager::drm_backend::{self, DrmBackendClient}` (oder `x11_backend::{self, X11BackendClient}`)
    * Trait `DisplayBackend`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `std::collections::HashMap`
    * `tracing`
    * `futures::stream::Stream`

**Kommunikationsmuster:**

* Wird vom `DisplayManagerService` verwendet.
* Kommuniziert mit dem spezifischen Display-Backend über das `DisplayBackend` Trait.
* Sendet `SystemEvent`s an den `EventBus` bei Display-Ereignissen oder Zustandsänderungen.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Display-Manager, der Display-Informationen abfragen, Einstellungen anwenden und auf Display-Events reagieren kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Erstellen eines Mock-`DisplayBackend` Implementierung, die vordefinierte Antworten liefert und Aufrufe protokolliert.
    * Mocken des `EventBus`.
    * Testen von `new`: Sicherstellen der Initialisierung und des initialen Scans/Statusabfrage vom Mock-Backend.
    * Testen von `list_outputs`, `get_output_settings`, `set_output_resolution` etc.: Sicherstellen, dass die Aufrufe an das Mock-Backend weitergeleitet werden und die internen Zustände/Events korrekt sind.
    * Testen des Backend-Event-Processing-Tasks: Simulieren von `BackendDisplayEvent`s vom Mock-Backend und Überprüfen, ob sie korrekt in `SystemEvent`s umgewandelt und an den `EventBus` gesendet werden.
    * Testen von `update_config`.
* **Integration Tests (mit realer Hardware/Display-Server):**
    * Starten des `DisplayManager` mit einem realen Backend (`DrmBackendClient` oder `X11BackendClient`).
    * Testen aller `DisplayBackend`-Methoden und Überprüfen des Verhaltens über CLI-Tools (`xrandr`, `modetest`) oder durch visuelle Bestätigung.
    * Testen des Event-Monitorings: Physisches Anschließen/Trennen von Monitoren, Ändern von Auflösungen über externe Tools und Überprüfen, ob die `SystemEvent`s im `EventBus` ankommen.

**Geschätzter Aufwand:** Sehr Hoch (ca. 12-18 Tage, da komplexe Interaktion mit Display-Server-APIs oder Kernel-Schnittstellen, Event-Verarbeitung und Zustandsmanagement)

---
### **novade-system/src/display_manager/drm_backend.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert das `DisplayBackend` Trait speziell für die direkte Interaktion mit dem Linux-Kernel DRM/KMS (Direct Rendering Manager / Kernel ModeSetting) Subsystem. Dies ist die bevorzugte Methode für einen Wayland-Kompositor, um Displays zu verwalten. Es ist für das Öffnen von DRM-Geräten, das Erkennen von Connectoren und Encodern, das Setzen von Videomodi und das Empfangen von Hotplug-Ereignissen verantwortlich.

**Kern-Aufgaben (Tasks):**

1.  **`DrmBackendClient` Struct:**
    * `pub struct DrmBackendClient {`
        * `drm_device_path: PathBuf,` // Z.B. /dev/dri/card0
        * `drm_fd: RawFd,` // File Descriptor des DRM-Geräts
        * `drm_connector_info: RwLock<HashMap<String, drm::control::ConnectorInfo>>,` // Cached info
        * `drm_encoder_info: RwLock<HashMap<u32, drm::control::EncoderInfo>>,`
        * `drm_crtc_info: RwLock<HashMap<u32, drm::control::CrtcInfo>>,`
        * `event_source_sender: mpsc::Sender<BackendDisplayEvent>,` // Sender für Events an DisplayManager
        * `// Optional: Allocator für Framebuffers, Rentgen-Funktionalität`
    * `}`

2.  **`DrmBackendClient::new()` Funktion:**
    * `pub async fn new(drm_device_path: PathBuf) -> Result<Self, DisplayError>`
    * **Logik:**
        * Öffnet das DRM-Gerät (`/dev/dri/cardX`).
        * Führt eine anfängliche DRM-Kontrolle ab (Connectors, Encoders, CRTCs, Planes).
        * Identifiziert verfügbare Outputs und deren unterstützte Modi.
        * Registriert sich für DRM-Hotplug-Events (z.B. über `epoll` oder `poll` auf dem DRM-FD).
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `IoError`, `BackendInitializationFailed` (z.B. keine Berechtigungen, Gerät nicht gefunden).

3.  **Implementierung des `DisplayBackend` Trait für `DrmBackendClient`:**

    * **`list_outputs(&self) -> Result<Vec<OutputInfo>, DisplayError>`:**
        * **Logik:** Iteriert über die erkannten DRM-Connectors.
        * Für jeden Connector, fragt die aktuellen Informationen ab (Name, Status, verbundene Modi, Encoder, CRTC).
        * Konvertiert die DRM-Daten in `OutputInfo` und `OutputSettings`.
    * **`get_output_settings(&self, output_id: &str) -> Result<OutputSettings, DisplayError>`:**
        * **Logik:** Findet den Connector anhand des `output_id` (Connector-Name) und fragt dessen aktuelle Einstellungen ab.
    * **`set_output_mode(&self, output_id: &str, resolution: Resolution, refresh_rate: u32) -> Result<(), DisplayError>`:**
        * **Logik:**
            * Findet den Connector, den Encoder und CRTC, die für den `output_id` relevant sind.
            * Findet den passenden `drm::control::Mode` für die angegebene `resolution` und `refresh_rate`.
            * Führt einen KMS-Atomic-Commit durch, um den Modus auf dem CRTC zu setzen und den Connector mit dem CRTC und Encoder zu verbinden.
    * **`set_output_scale(&self, output_id: &str, scale: f64) -> Result<(), DisplayError>`:**
        * **Logik:** `libdrm` selbst hat keine direkte Skalierungs-API. Skalierung wird typischerweise auf Kompositor-Ebene (Wayland) oder durch XRandR-Erweiterungen (X11) gehandhabt. Wenn NovaDE ein Wayland-Kompositor ist, wird die Skalierung im `wayland_compositor.rs` implementiert. Das Backend könnte hier eine Eigenschaft des CRTCs setzen, falls dies direkt unterstützt wird (z.B. über spezielle DRM-Properties). Für MVP kann dies ein NOP sein oder als `UnsupportedOperation` Fehler behandelt werden.
    * **`set_output_position(&self, output_id: &str, x: i32, y: i32) -> Result<(), DisplayError>`:**
        * **Logik:** Setzt die CRTC-Position im virtuellen Framebuffer über einen KMS-Atomic-Commit.
    * **`set_output_enabled(&self, output_id: &str, enabled: bool) -> Result<(), DisplayError>`:**
        * **Logik:** Führt einen KMS-Atomic-Commit durch, um den Connector mit einem CRTC zu verbinden (aktivieren) oder zu trennen (deaktivieren).
    * **`set_screen_brightness(&self, output_id: &str, brightness_percent: u8) -> Result<(), DisplayError>`:**
        * **Logik:** DRM/KMS bietet oft keine direkte Helligkeitskontrolle über den Connector. Dies wird typischerweise über `/sys/class/backlight` (systemweite Helligkeits-Sysfs) oder über D-Bus (`UPower` oder proprietäre APIs) gehandhabt. Dieses Backend könnte versuchen, die `/sys/class/backlight` Schnittstelle direkt zu steuern, wenn sie für das Gerät verfügbar ist. Dies erfordert jedoch oft Root-Rechte oder spezielle Berechtigungen. Eine alternative wäre, diese Funktionalität dem `power_manager` zu überlassen. Für MVP könnte es hier als `UnsupportedOperation` gekennzeichnet sein.
    * **`apply_night_light_color_temperature(&self, temperature_k: u32) -> Result<(), DisplayError>;`:**
        * **Logik:** `libdrm` bietet in der Regel keine direkte API für Farbtemperatur-Anpassungen. Dies wird typischerweise durch Shaders auf Kompositor-Ebene (Wayland) oder über X11-Gamma-Rampen (`xgamma`) gehandhabt. Wenn NovaDE ein Wayland-Kompositor ist, wäre dies Teil des Renderns. Für MVP könnte es hier ein NOP oder `UnsupportedOperation` sein.
    * **`disable_night_light(&self) -> Result<(), DisplayError>;`:**
        * **Logik:** Entsprechend zur Aktivierung.
    * **`subscribe_to_events(&self) -> Box<dyn Stream<Item = BackendDisplayEvent> + Send + Unpin>;`:**
        * **Logik:** Startet einen asynchronen Task, der den DRM-FD auf `DRM_EVENT_HOTPLUG` überwacht.
        * Bei Hotplug-Events (Monitor an-/abgesteckt), liest die Connector-Informationen neu und sendet `BackendDisplayEvent::OutputConnected` oder `BackendDisplayEvent::OutputDisconnected`.
        * Kann auch auf Property-Änderungen an DRM-Objekten hören.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_manager/drm_backend.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::display_manager::error::DisplayError`
    * `crate::display_manager::data_types::{OutputInfo, OutputSettings, Resolution, VideoMode, Rotation, Size2D}`
    * Trait `DisplayBackend`
* **Extern:**
    * `drm` crate (Rust bindings for libdrm)
    * `nix` crate (für `open`, `ioctl` etc.)
    * `tokio::fs` (für `sysfs` Pfade, falls Helligkeit hier kontrolliert wird)
    * `tokio::task`
    * `tokio::sync::mpsc`
    * `std::collections::HashMap`
    * `std::path::PathBuf`
    * `std::os::unix::io::RawFd`
    * `tracing`
    * `futures::stream::Stream`

**Kommunikationsmuster:**

* Wird vom `DisplayManager` oder `WaylandCompositor` instanziiert und verwendet.
* Kommuniziert direkt mit dem Linux-Kernel DRM/KMS.
* Sendet interne `BackendDisplayEvent`s an den `DisplayManager` über einen Channel.

**Erwartete Ergebnisse/Outputs:**
Eine funktionsfähige Implementierung des `DisplayBackend` Trait für DRM/KMS, die Displays auf niedriger Ebene verwalten kann. Dies ist ein kritischer Bestandteil für einen Wayland-Kompositor.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit `libdrm` Mocking/Simulierung):**
    * Mocken der `libdrm` Funktionen, um vordefinierte Hardware-Antworten und Events zu simulieren.
    * Testen jeder Wrapper-Methode, um sicherzustellen, dass die `libdrm`-API-Aufrufe korrekt formuliert und die Ergebnisse korrekt konvertiert werden.
    * Simulieren des Empfangs von DRM-Hotplug-Events und Überprüfen, ob die Streams die korrekten `BackendDisplayEvent`s liefern.
* **Integration Tests (mit realer DRM-Hardware):**
    * **Achtung:** DRM-Tests können das System stark beeinflussen und sind oft nur in isolierten Umgebungen (VMs mit GPU-Passthrough) sicher.
    * Starten des `DrmBackendClient` auf einem System mit DRM-fähiger GPU.
    * Testen von `list_outputs` und Überprüfen der erkannten Outputs mit `modetest` oder `dmesg`.
    * Testen von `set_output_mode` (Auflösung, Bildwiederholrate). Visuelle Überprüfung der Änderung.
    * Testen von `set_output_enabled` (Monitor ein-/ausschalten).
    * Testen der Event-Erkennung: Physisches An- und Abstecken eines Monitors und Überprüfen, ob die `BackendDisplayEvent`s korrekt empfangen werden.

**Geschätzter Aufwand:** Sehr Hoch (ca. 20-30 Tage, da tiefe Kenntnisse der DRM/KMS-API, Kernel-Interaktion, Atomic-Commits und Event-Loop-Integration erforderlich sind)

---
### **novade-system/src/display_manager/x11_backend.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert das `DisplayBackend` Trait für die Interaktion mit einem bestehenden X11-Display-Server über die XRandR-Erweiterung. Es ist eine Fallback-Option oder für den Fall, dass NovaDE als traditionelle X11-Desktop-Umgebung entwickelt wird.

**Kern-Aufgaben (Tasks):**

1.  **`X11BackendClient` Struct:**
    * `pub struct X11BackendClient {`
        * `xconn: Arc<xcb::Connection>,` // XCB connection
        * `screen_idx: i32,` // Index des Standard-Bildschirms
        * `event_source_sender: mpsc::Sender<BackendDisplayEvent>,` // Sender für Events an DisplayManager
    * `}`

2.  **`X11BackendClient::new()` Funktion:**
    * `pub async fn new() -> Result<Self, DisplayError>`
    * **Logik:**
        * Stellt eine XCB-Verbindung zum X-Server her.
        * Überprüft, ob die XRandR-Erweiterung verfügbar ist.
        * Fragt den initialen XRandR-Zustand ab (Outputs, Modes, CRTCs).
        * Registriert sich für XRandR-Events (z.B. `RRNotify`, `RRScreenChangeNotify`).
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `BackendInitializationFailed` (X-Server nicht erreichbar, XRandR nicht verfügbar), `IoError`.

3.  **Implementierung des `DisplayBackend` Trait für `X11BackendClient`:**

    * **`list_outputs(&self) -> Result<Vec<OutputInfo>, DisplayError>`:**
        * **Logik:** Führt eine XRandR-Abfrage durch, um alle Outputs, deren verbundenen CRTCs und verfügbaren Modes zu erhalten.
        * Konvertiert XRandR-Daten in `OutputInfo` und `OutputSettings`.
    * **`get_output_settings(&self, output_id: &str) -> Result<OutputSettings, DisplayError>`:**
        * **Logik:** Fragt die aktuellen Einstellungen des spezifischen XRandR-Outputs ab.
    * **`set_output_mode(&self, output_id: &str, resolution: Resolution, refresh_rate: u32) -> Result<(), DisplayError>`:**
        * **Logik:**
            * Findet den XRandR-Output und den gewünschten Mode.
            * Verwendet `xcb_randr_set_crtc_config` oder ähnliche Funktionen, um den Modus zu setzen.
    * **`set_output_scale(&self, output_id: &str, scale: f64) -> Result<(), DisplayError>`:**
        * **Logik:** Setzt den Skalierungsfaktor über `xcb_randr_set_crtc_transform` oder die `Xft` DPI-Einstellung (systemweit, nicht Output-spezifisch). Dies kann komplex sein, da X11 keine native per-Output-Skalierung wie Wayland bietet. Für hohe DPI kann man den virtuellen Desktop vergrößern und dann die Ausgabe auf die physikalische Größe skalieren, was aber Performance-Probleme verursachen kann. Für MVP kann dies nur rudimentär oder gar nicht unterstützt werden, oder es wird ein `UnsupportedOperation` Fehler zurückgegeben.
    * **`set_output_position(&self, output_id: &str, x: i32, y: i32) -> Result<(), DisplayError>`:**
        * **Logik:** Verwendet `xcb_randr_set_crtc_config`, um die Position des CRTCs zu ändern.
    * **`set_output_enabled(&self, output_id: &str, enabled: bool) -> Result<(), DisplayError>`:**
        * **Logik:** Setzt den Output-Status über XRandR (verbindet/trennt von CRTC).
    * **`set_screen_brightness(&self, output_id: &str, brightness_percent: u8) -> Result<(), DisplayError>`:**
        * **Logik:** Verwendet `xcb_randr_set_output_gamma` um die Helligkeit über Gamma-Rampen anzupassen. Dies ist eine "Pseudo-Helligkeit", da sie nur die Farbintensität ändert, nicht die Hintergrundbeleuchtung. Echte Helligkeitskontrolle geht über `sysfs` oder D-Bus (`UPower`).
    * **`apply_night_light_color_temperature(&self, temperature_k: u32) -> Result<(), DisplayError>;`:**
        * **Logik:** Verwendet `xcb_randr_set_output_gamma` mit berechneten Gamma-Werten, um die Farbtemperatur anzupassen. Erfordert Mathematik zur Umrechnung von Kelvin in RGB-Gamma-Kurven.
    * **`disable_night_light(&self) -> Result<(), DisplayError>;`:**
        * **Logik:** Setzt die Gamma-Werte auf Standard (1.0).
    * **`subscribe_to_events(&self) -> Box<dyn Stream<Item = BackendDisplayEvent> + Send + Unpin>;`:**
        * **Logik:** Startet einen asynchronen Task, der XCB-Events polled (`xcb_wait_for_event`).
        * Filtert nach XRandR-Events (`RRNotify`, `RRScreenChangeNotify`).
        * Konvertiert die XRandR-Events in die interne `BackendDisplayEvent` Repräsentation und sendet sie über den `mpsc::channel`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_manager/x11_backend.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::display_manager::error::DisplayError`
    * `crate::display_manager::data_types::{OutputInfo, OutputSettings, Resolution, VideoMode, Rotation, Size2D}`
    * Trait `DisplayBackend`
* **Extern:**
    * `xcb` crate (Rust bindings for XCB, mit `randr` Feature)
    * `tokio::task`
    * `tokio::sync::mpsc`
    * `std::collections::HashMap`
    * `std::sync::Arc`
    * `tracing`
    * `futures::stream::Stream`
    * `color_space` (für Kelvin zu RGB Konvertierung für Night Light)

**Kommunikationsmuster:**

* Wird vom `DisplayManager` instanziiert und verwendet.
* Kommuniziert direkt mit dem X11-Display-Server über XCB/XRandR.
* Sendet interne `BackendDisplayEvent`s an den `DisplayManager` über einen Channel.

**Erwartete Ergebnisse/Outputs:**
Eine funktionsfähige Implementierung des `DisplayBackend` Trait für X11/XRandR, die Displays verwalten kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit `xcb` Mocking/Simulierung):**
    * Mocken der `xcb` Funktionen, um vordefinierte X-Server-Antworten und Events zu simulieren.
    * Testen jeder Wrapper-Methode, um sicherzustellen, dass die XCB-API-Aufrufe korrekt formuliert und die Ergebnisse korrekt konvertiert werden.
    * Simulieren des Empfangs von XRandR-Events und Überprüfen, ob die Streams die korrekten `BackendDisplayEvent`s liefern.
* **Integration Tests (mit realem X-Server):**
    * Starten des `X11BackendClient` in einer X11-Sitzung.
    * Testen von `list_outputs` und Überprüfen der erkannten Outputs mit `xrandr`.
    * Testen von `set_output_mode`, `set_output_position`, `set_output_enabled` und `set_screen_brightness`. Visuelle Überprüfung der Änderungen.
    * Testen des Event-Monitorings: Physisches An- und Abstecken eines Monitors oder Ändern der Auflösung über `xrandr` und Überprüfen, ob die `BackendDisplayEvent`s korrekt empfangen werden.
    * Testen von `apply_night_light_color_temperature`.

**Geschätzter Aufwand:** Hoch (ca. 10-15 Tage, da detaillierte Kenntnisse der XCB/XRandR-API, Event-Loop-Integration und Besonderheiten von X11-Skalierung/Helligkeit erforderlich sind)

---
### **novade-system/src/display_manager/wayland_compositor.rs**

**Verantwortlichkeit:**
Dieses Modul ist die zentrale Komponente, wenn NovaDE als nativer Wayland-Kompositor agiert. Es implementiert die Wayland-Protokolle, verwaltet Clients, komponiert Szenen und rendert diese auf den DRM-Layern. Es nutzt direkt das `drm_backend` für die Hardware-Interaktion. Es ist *kein* weiteres `DisplayBackend` Trait, sondern die konkrete Implementierung des Wayland-Display-Servers selbst.

**Kern-Aufgaben (Tasks):**

1.  **`WaylandCompositor` Struct:**
    * `pub struct WaylandCompositor {`
        * `display_handle: wl_display::Display,` // Wayland display handle
        * `event_loop: Rc<RefCell<Calloop<State>>>,` // Calloop event loop for Wayland events
        * `state: Rc<RefCell<State>>,` // Global compositor state (clients, surfaces, outputs, input, etc.)
        * `drm_client: Arc<DrmBackendClient>,` // Interaktion mit DRM-Hardware
        * `input_manager: Arc<InputEventManager>,` // Für Eingabe-Handling
        * `event_bus: EventBus,` // Für System-Events
        * `// Weitere Manager für Shell-Protokolle, XDG-Shell, etc.`
    * `}`

2.  **`State` Struct (Intern in `wayland_compositor.rs`):**
    * `pub struct State {`
        * `outputs: HashMap<String, OutputInfo>,` // Gemanagte Outputs
        * `surfaces: Vec<Rc<RefCell<Surface>>>,` // Wayland-Oberflächen von Clients
        * `input_state: InputState,` // Aktueller Eingabestatus
        * `last_render_time: Instant,`
        * `// ... weitere interne Zustände`
    * `}`

3.  **`WaylandCompositor::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus, drm_client: Arc<DrmBackendClient>, input_manager: Arc<InputEventManager>) -> Result<Self, DisplayError>`
    * **Logik:**
        * Initialisiert einen `wl_display::Display`.
        * Erstellt einen `calloop` Event Loop.
        * Initialisiert den `State` Struct.
        * Bindet Wayland-Protokolle: `wl_compositor`, `wl_subcompositor`, `wl_shm`, `xdg_shell`, `wlr_layer_shell`, `wlr_output_manager`, `wlr_data_device`, etc.
        * Fügt die `drm_client` und `input_manager` als Quellen für Events (z.B. Hotplug, Input Events) zum Event Loop hinzu.
        * Startet den Wayland-Socket-Listening (z.B. `WAYLAND_DISPLAY=wayland-0`).
        * Beginnt den initialen Scan der Outputs über `drm_client`.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** Fehler bei der Wayland-Initialisierung, Socket-Erstellung, DRM-Client-Fehler.

4.  **`WaylandCompositor::run()` Funktion:**
    * `pub async fn run(&self) -> Result<(), DisplayError>`
    * **Logik:**
        * Startet den `calloop` Event Loop. Dieser Loop verarbeitet alle Wayland-Client-Anfragen, DRM-Events, Input-Events, Timer etc.
        * Enthält die Haupt-Kompositor-Loop:
            * Verarbeitet Events von Clients.
            * Aktualisiert den Szenengraph.
            * Render auf den DRM-Output (über `drm_client` oder OpenGL/Vulkan Kontext).
            * Swap Buffers.
            * Planen des nächsten Frames.

5.  **`WaylandCompositor` API-Methoden (Die Methoden, die vom `DisplayManagerService` aufgerufen werden, werden hier implementiert, indem sie den internen `State` manipulieren und/oder den `drm_client` nutzen):**

    * **`list_outputs()`:** Delegiert an `drm_client.list_outputs()` und aktualisiert den `State`.
    * **`get_output_settings()`:** Ruft aus dem `State` ab.
    * **`set_output_resolution()`:** Setzt den Modus über `drm_client`. Aktualisiert den `State`.
    * **`set_output_scaling()`:**
        * **Logik:** Setzt den Skalierungsfaktor für den Output. Im Wayland-Kontext bedeutet dies, dass die Pixel von Client-Oberflächen im Verhältnis zur physikalischen Ausgabe gerendert werden. Wayland unterstützt dies nativ. Dies beeinflusst das Rendering in der Kompositions-Phase.
        * Aktualisiert den `State` und den `drm_client` (falls DRM-Skalierungseigenschaften vorhanden sind).
    * **`set_output_position()`:** Manipuliert die Position des Outputs im virtuellen Desktop-Layout im `State` und verwendet `drm_client` zum Setzen der CRTC-Position.
    * **`set_output_enabled()`:** Aktiviert/deaktiviert den Output über `drm_client`.
    * **`set_screen_brightness()`:**
        * **Logik:** Ruft `drm_client.set_screen_brightness()` auf (falls dort implementiert) oder verwaltet dies auf Kompositor-Ebene (z.B. durch Anwenden eines Helligkeits-Shaders auf den finalen Render-Buffer).
    * **`apply_night_light_color_temperature()` / `disable_night_light()`:**
        * **Logik:** Implementiert die Farbtemperatur-Anpassung durch Anwenden von Color-Matrix-Transformationen oder Shaders auf die gerenderten Szenen. Dies ist eine Kompositor-spezifische Funktion.

6.  **Event-Handling:**
    * Der Kompositor muss Events von `drm_client` (Hotplug, etc.) und `input_manager` (Key, Motion, Touch) verarbeiten.
    * Empfangene Events werden in den internen `State` des Kompositors integriert, um z.B. Oberflächen zu bewegen, Tastatur-Fokus zu wechseln oder Gesten zu verarbeiten.
    * Dispatched `SystemEvent`s an den `event_bus` basierend auf internen Aktionen (z.B. `SystemEvent::OutputConnected`).

7.  **Rendering-Pipeline (sehr rudimentär skizziert):**
    * **Framebuffer Management:** Zuweisen von DRM-Framebuffers für jeden Output.
    * **Scene Graph:** Repräsentiert alle zu rendernden Oberflächen (Fenster, Panels, Desktophintergrund) mit ihren Positionen, Größen, Transformationen.
    * **Renderer:** Nutzt OpenGL ES oder Vulkan (mit EGL/Wl_EGL_Backend) um die Scene auf die Framebuffers zu rendern.
    * **Buffer Swap:** `drm_client.page_flip()` nach dem Rendern.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_manager/wayland_compositor.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::display_manager::error::DisplayError`
    * `crate::display_manager::data_types::{OutputInfo, OutputSettings, Resolution, VideoMode, Rotation, Size2D}`
    * `crate::display_manager::drm_backend::DrmBackendClient`
    * `crate::input_service::manager::InputEventManager`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `wayland-server` crate (Rust bindings for Wayland server API)
    * `wayland-protocols` crate (für `xdg_shell`, `wlr_layer_shell` etc.)
    * `calloop` crate (für Event Loop)
    * `tokio::task`
    * `std::sync::Arc`
    * `std::rc::Rc`
    * `std::cell::RefCell`
    * `std::collections::HashMap`
    * `tracing`
    * `ash` (für Vulkan) oder `egl` / `glow` (für OpenGL ES)
    * `winit` (könnte für Fensterverwaltung verwendet werden, aber für Compositor eher ungeeignet)
    * `smithay` (wenn ein bestehendes Wayland-Compositor-Framework verwendet wird, dringend empfohlen!)

**Kommunikationsmuster:**

* Der primäre Wayland-Kompositor, der mit Wayland-Clients kommuniziert.
* Nutzt `DrmBackendClient` für Hardware-Interaktion und `InputEventManager` für Eingabe.
* Sendet `SystemEvent`s an den `EventBus`.

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiger Wayland-Kompositor, der Wayland-Clients hosten, Displays verwalten und den Desktop rendern kann. Dies ist der Kern der NovaDE-Grafikumgebung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking/Integration von `smithay` Test-Utilities):**
    * Mocken von `drm_client` und `input_manager`.
    * Testen der Wayland-Protokoll-Bindungen (z.B. das Verhalten von `xdg_shell` Clients zu simulieren).
    * Testen der Szenen-Graph-Manipulation.
    * Testen der Event-Verarbeitung (z.B. wie ein Key-Event den Fokus ändert).
* **Integration Tests (mit realer Hardware und Wayland-Clients):**
    * **Sehr komplex und ressourcenintensiv.**
    * Starten des `WaylandCompositor` auf einem System mit DRM-Hardware.
    * Starten von Beispiel-Wayland-Clients (z.B. `weston-terminal`, `gedit --wayland`).
    * Überprüfen der Fensterpositionierung, Skalierung, Interaktion mit Eingabegeräten.
    * Testen von Multi-Monitor-Setups.
    * Testen von Helligkeit und Nachtlichteffekten.

**Geschätzter Aufwand:** Extrem Hoch (ca. 60-120 Tage, da ein Wayland-Kompositor ein äußerst komplexes und umfangreiches Projekt ist, das eine tiefe Expertise in Grafik-Rendering, Protokoll-Implementierung und Systemprogrammierung erfordert. Die Verwendung eines Frameworks wie `smithay` kann den Aufwand erheblich reduzieren, aber es bleibt eine der anspruchsvollsten Komponenten.)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `input_service`, widmen wir uns `display_manager`. Die Reihenfolge hängt stark davon ab, ob NovaDE ein nativer Wayland-Kompositor ist oder auf X11/Wayland aufbaut:

**Option A: NovaDE als nativer Wayland-Kompositor (Empfohlen für modernes DE):**

1.  **`novade-system/src/display_manager/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/display_manager/data_types.rs`**: Definition der grundlegenden Datentypen für Displays und deren Einstellungen.
3.  **`novade-system/src/display_manager/drm_backend.rs`**: Dies ist der essentielle Low-Level-Treiber für den Wayland-Kompositor. Er muss als erstes implementiert werden.
4.  **`novade-system/src/display_manager/wayland_compositor.rs`**: Dies ist die Kernkomponente des Display-Managements, die den `drm_backend` direkt nutzt. Die `DisplayManager` Logik in `manager.rs` wird hier integriert oder von diesem Modul abstrahiert. Die API-Methoden von `DisplayManagerService` werden direkt vom Kompositor bereitgestellt.
5.  **`novade-system/src/display_manager/manager.rs`**: Wenn NovaDE ein Wayland-Kompositor ist, wird dieses Modul eine dünne Wrapper-Schicht um `wayland_compositor.rs` sein, die das `DisplayBackend` Trait *nicht* implementiert, sondern die Funktionen des Kompositors direkt als API bereitstellt. Oder es entfällt komplett, wenn `wayland_compositor` die API direkt bereitstellt. **Für dieses Dokument wird `manager.rs` eine Abstraktionsschicht bleiben, die den Kompositor nutzt.**
6.  **`novade-system/src/display_manager/x11_backend.rs`**: (Optional) Nur wenn X11-Anwendungen auf dem Wayland-Kompositor über XWayland laufen sollen. Die Implementierung wäre dann Teil des `wayland_compositor` (als XWayland-Bridge). Wenn NovaDE *kein* X11-Support hat, wird dieses Modul weggelassen.

**Option B: NovaDE als traditionelle X11-Desktop-Umgebung oder als Shell auf einem bestehenden Wayland-Kompositor (seltenere Fälle):**

1.  **`novade-system/src/display_manager/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/display_manager/data_types.rs`**: Definition der grundlegenden Datentypen.
3.  **`novade-system/src/display_manager/x11_backend.rs`**: Falls X11 die primäre Display-API ist.
4.  **`novade-system/src/display_manager/drm_backend.rs`**: (Optional) Nur für direkte Helligkeitskontrolle oder wenn tiefergehende Hardware-Infos benötigt werden, aber nicht für den Haupt-Display-Loop.
5.  **`novade-system/src/display_manager/manager.rs`**: Die Kernlogik zur Verwaltung von Displays, die das `x11_backend` nutzt.
6.  **`novade-system/src/display_manager/wayland_compositor.rs`**: (Optional) Wenn NovaDE als Shell auf einem bestehenden Wayland-Kompositor läuft, könnte dieses Modul die Interaktion mit dem Wayland-Kompositor herstellen, aber es würde selbst *kein* Kompositor sein. Es würde das `DisplayBackend` Trait implementieren und über Wayland-Protokolle mit dem externen Kompositor sprechen.

**Für die Fortsetzung des Plans wird Option A angenommen, da dies der zukunftsweisendere Weg für ein modernes Linux-Desktop-Environment ist.**

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/display_manager` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/notification_service` Verzeichnisses, um die System-Benachrichtigungen zu kontrollieren.
---
### **novade-system/src/notification_service/mod.rs**

**Verantwortlichkeit:**
Das `notification_service` Modul ist für die Verwaltung und Anzeige von Systembenachrichtigungen zuständig. Es implementiert das Desktop Notifications Specification (freedesktop.org) und bietet eine API für Anwendungen und Systemkomponenten, um Benachrichtigungen zu senden, sowie eine Oberfläche zur Anzeige und Interaktion mit diesen Benachrichtigungen. Es verwaltet den Lebenszyklus von Benachrichtigungen, die Anzeige-Priorität und Benutzerinteraktionen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/notification_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Benachrichtigungs-Operationen)
    * `manager.rs` (Logik für Benachrichtigungsverwaltung und -anzeige)
    * `data_types.rs` (Definition von Benachrichtigungs-bezogenen Datentypen)
    * `dbus_interface.rs` (Implementierung des D-Bus-Schnittstelle für Benachrichtigungen)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Benachrichtigungs-Subsystems:**
    * `pub async fn initialize_notification_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<NotificationService, NotificationError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::NotificationManager`, die die eigentliche Logik zur Benachrichtigungsverwaltung enthält.
        * Initialisiert den D-Bus-Server für Benachrichtigungen, der eingehende Benachrichtigungsanfragen von Anwendungen über die freedesktop.org-Spezifikation entgegennimmt.
        * Ruft initiale Einstellungen für Benachrichtigungen aus dem `config_service` ab (z.B. `display_position`, `timeout_seconds`, `do_not_disturb`).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Benachrichtigungseinstellungen zu laden.
        * Gibt ein gebündeltes `NotificationService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder der D-Bus-Schnittstelle.

2.  **`NotificationService` Struct:**
    * `pub struct NotificationService {`
        * `manager: Arc<NotificationManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
    * `}`
    * Dient als Container und Zugangspunkt für die Benachrichtigungslogik.

3.  **Bereitstellung von API-Methoden:**
    * Der `NotificationService` exponiert Methoden zur Steuerung und Abfrage von Benachrichtigungen.
    * `pub async fn show_notification(&self, notification: Notification) -> Result<u32, NotificationError>`
        * **Logik:** Nimmt eine `Notification` entgegen, weist eine eindeutige ID zu und delegiert an den `NotificationManager` zur Anzeige. Gibt die zugewiesene ID zurück. Dies ist die interne API für Systemkomponenten.
    * `pub async fn close_notification(&self, id: u32) -> Result<(), NotificationError>`
        * **Logik:** Delegiert an den `NotificationManager`, um eine spezifische Benachrichtigung zu schließen.
    * `pub async fn get_history(&self) -> Result<Vec<Notification>, NotificationError>`
        * **Logik:** Delegiert an den `NotificationManager`, um eine Liste der kürzlich angezeigten oder noch aktiven Benachrichtigungen zurückzugeben.
    * `pub async fn set_do_not_disturb(&self, enable: bool) -> Result<(), NotificationError>`
        * **Logik:** Delegiert an den `NotificationManager`, um den "Nicht stören"-Modus zu aktivieren/deaktivieren. Speichert die Einstellung im `config_service`. Sendet `SystemEvent::DoNotDisturbChanged`.
    * `pub async fn get_capabilities(&self) -> Result<Vec<String>, NotificationError>`
        * **Logik:** Delegiert an den `NotificationManager`, um die unterstützten Fähigkeiten des Benachrichtigungsdienstes zurückzugeben (gemäß freedesktop.org Spezifikation, z.B. "body", "actions", "persistence").

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `NotificationService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Benachrichtigungseinstellungen in der Konfiguration geändert werden, werden die Sub-Komponenten (`NotificationManager`) informiert.

5.  **Hintergrund-Task zum Abonnieren von D-Bus-Anfragen:**
    * Ein Task, der die vom `dbus_interface` empfangenen Benachrichtigungsanfragen von externen Anwendungen entgegennimmt und diese an den `NotificationManager` weiterleitet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::notification_service::error::NotificationError`
    * `crate::notification_service::manager::NotificationManager`
    * `crate::notification_service::data_types::Notification`
    * `crate::notification_service::dbus_interface::NotificationDbusServer`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Ist der primäre Empfänger von Benachrichtigungsanfragen von Anwendungen (über D-Bus) und Systemkomponenten (direkter API-Aufruf).
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Benachrichtigungseinstellungen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten über neue Benachrichtigungen, geschlossene Benachrichtigungen oder Änderungen im "Nicht stören"-Modus zu informieren.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Benachrichtigungs-Subsystem, das Benachrichtigungen von Anwendungen empfangen, anzeigen und verwalten kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus` und `NotificationManager`.
    * Testen der Initialisierung und des Ladens initialer Konfiguration.
    * Testen der Weiterleitung von API-Aufrufen an den `NotificationManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von D-Bus-Anfragen und Überprüfen der Weiterleitung an den `NotificationManager`.
* **Integration Tests:**
    * Starten des `NotificationService` und des D-Bus-Servers.
    * Verwenden von `notify-send` (oder einer anderen D-Bus-fähigen Anwendung), um Benachrichtigungen zu senden. Überprüfen, ob sie intern empfangen und verarbeitet werden.
    * Testen der `set_do_not_disturb` Funktion und der Persistenz über den `ConfigService`.

**Geschätzter Aufwand:** Mittel (ca. 5-7 Tage, da D-Bus-Integration, Lebenszyklusmanagement und Konfigurationsbindung)

---
### **novade-system/src/notification_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `notification_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Benachrichtigungs-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum NotificationError {`
        * `#[error("D-Bus initialization failed: {0}")]`
        * `DbusInitializationFailed(String),`
        * `#[error("Notification with ID {0} not found.")]`
        * `NotificationNotFound(u32),`
        * `#[error("Invalid notification data: {0}")]`
        * `InvalidNotificationData(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("D-Bus error: {0}")]`
        * `DbusError(#[from] zbus::Error),`
        * `#[error("I/O error: {0}")]`
        * `IoError(#[from] std::io::Error),`
        * `#[error("Unknown notification error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `zbus::Error`, `std::io::Error` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::io::Error`
    * `zbus::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `notification_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Benachrichtigungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/notification_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `notification_service` verwendet werden, um Benachrichtigungen, deren Eigenschaften und Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`Notification` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct Notification {`
        * `pub id: u32,` // Eindeutige ID der Benachrichtigung, 0 für neue Benachrichtigung
        * `pub app_name: String,`
        * `pub app_icon: Option<String>,` // Icon-Name oder Pfad
        * `pub summary: String,` // Kurzer Titel
        * `pub body: Option<String>,` // Haupttext, kann HTML enthalten
        * `pub category: Option<String>,` // Z.B. "device.added", "device.removed"
        * `pub urgency: UrgencyLevel,`
        * `pub actions: Vec<NotificationAction>,` // Interaktive Buttons
        * `pub timeout_ms: i33,` // Anzeigedauer in Millisekunden, -1 für persistent
        * `pub timestamp: DateTime<Utc>,` // Zeitpunkt der Erstellung
        * `pub hints: HashMap<String, Value>,` // Spezifische Hints (gemäß Spezifikation)
        * `pub transient: bool,` // Ob die Benachrichtigung in der Historie gespeichert werden soll
    * `}`

2.  **`UrgencyLevel` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum UrgencyLevel { Low, Normal, Critical }`

3.  **`NotificationAction` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct NotificationAction {`
        * `pub id: String,` // Eindeutige ID für die Aktion
        * `pub label: String,` // Anzeigetext des Buttons
    * `}`

4.  **`NotificationResponse` Enum:**
    * Wird vom `NotificationManager` gesendet, wenn der Benutzer mit einer Benachrichtigung interagiert.
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub enum NotificationResponse {`
        * `ActionInvoked { notification_id: u32, action_id: String },`
        * `Dismissed { notification_id: u32, reason: DismissReason },`
    * `}`

5.  **`DismissReason` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum DismissReason { Expired, UserDismissed, ClosedByCall, ContentInvalid }`

6.  **`NotificationConfig` Struct (aus `config_service/data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct NotificationConfig {`
        * `pub display_position: DisplayPosition,` // Z.B. TopRight, BottomLeft
        * `pub default_timeout_seconds: u32,`
        * `pub do_not_disturb: bool,`
        * `pub show_in_history: bool,` // Ob auch transiente Benachrichtigungen in der Historie landen
        * `pub max_history_items: u32,`
        * `pub play_sound_on_notification: bool,`
        * `pub allowed_app_ids: Option<Vec<String>>,` // Whitelist/Blacklist
        * `pub blocked_app_ids: Option<Vec<String>>,`
        * `// ... weitere Einstellungen`
    * `}`

7.  **`DisplayPosition` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum DisplayPosition { TopLeft, TopRight, BottomLeft, BottomRight, Center }`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `chrono::{DateTime, Utc}`
    * `std::collections::HashMap`
    * `zvariant::Value` (für D-Bus Hints)

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Benachrichtigungsinformationen und Konfigurationen im System.
* Sie werden vom `NotificationManager` erzeugt und von der API des `NotificationService` verwendet.
* `NotificationConfig` wird im `ConfigService` gespeichert und geladen.
* `NotificationResponse` wird vom `NotificationManager` an den `EventBus` gesendet.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Benachrichtigungsverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.
    * Testen der Konvertierung von D-Bus-Typen (`zvariant::Value`) in die internen Typen, falls solche Konvertierungsfunktionen hier definiert werden.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage, da detaillierte Benachrichtigungs-Datenstrukturen und Konfigurationsoptionen benötigt werden, inklusive D-Bus-Aspekte)

---
### **novade-system/src/notification_service/manager.rs**

**Verantwortlichkeit:**
Der `NotificationManager` ist die Kernlogik des Benachrichtigungs-Subsystems. Er verwaltet den Lebenszyklus von Benachrichtigungen, deren Anzeige-Priorität und Benutzerinteraktionen. Er ist verantwortlich für das Queuing von Benachrichtigungen, die Anwendung von Konfigurationseinstellungen (z.B. "Nicht stören"-Modus, Timeout) und das Senden von relevanten Events an die UI oder andere Komponenten.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationManager` Struct:**
    * `pub struct NotificationManager {`
        * `event_bus: EventBus,`
        * `active_notifications: RwLock<HashMap<u32, Notification>>,` // Aktuell angezeigte Benachrichtigungen
        * `notification_history: RwLock<Vec<Notification>>,` // Kürzlich geschlossene/abgelaufene Benachrichtigungen
        * `current_config: RwLock<NotificationConfig>,` // Aktuelle Benachrichtigungskonfiguration
        * `next_notification_id: AtomicU32,` // Atomarer Zähler für Benachrichtigungs-IDs
        * `do_not_disturb_active: AtomicBool,`
    * `}`

2.  **`NotificationManager::new()` Funktion:**
    * `pub async fn new(initial_notification_config: NotificationConfig, event_bus: EventBus) -> Result<Self, NotificationError>`
    * **Logik:**
        * Initialisiert mit dem bereitgestellten `EventBus`.
        * Setzt `current_config` basierend auf `initial_notification_config`.
        * Initialisiert `active_notifications`, `notification_history` und den `next_notification_id`.
        * Setzt `do_not_disturb_active` basierend auf der initialen Konfiguration.
        * Startet einen Hintergrund-Task zum Verwalten von Benachrichtigungs-Timeouts.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** Keine spezifischen Fehler während der Initialisierung.

3.  **`NotificationManager::show_notification()` Methode:**
    * `pub async fn show_notification(&self, mut notification: Notification) -> Result<u32, NotificationError>`
    * **Logik:**
        * Weist der Benachrichtigung eine eindeutige ID zu, wenn `notification.id` 0 ist.
        * Wendet Konfigurationseinstellungen an:
            * Wenn `do_not_disturb_active` ist, wird die Benachrichtigung nicht angezeigt (oder nur in der Historie gespeichert), es sei denn, sie ist `Critical`.
            * Wendet `default_timeout_seconds` an, wenn `timeout_ms` 0 ist.
        * Fügt die Benachrichtigung zu `active_notifications` hinzu.
        * Sendet `SystemEvent::NotificationDisplayed(notification.clone())` an den `event_bus`.
        * Plant einen Timeout-Task, wenn `timeout_ms` > 0. Nach Ablauf des Timeouts wird `close_notification` intern aufgerufen mit `DismissReason::Expired`.
        * Gibt die zugewiesene `id` zurück.

4.  **`NotificationManager::close_notification()` Methode:**
    * `pub async fn close_notification(&self, id: u32, reason: DismissReason) -> Result<(), NotificationError>`
    * **Logik:**
        * Entfernt die Benachrichtigung aus `active_notifications`.
        * Wenn `transient` false ist oder `show_in_history` in der Konfiguration aktiv ist, fügt die Benachrichtigung zur `notification_history` hinzu.
        * Stellt sicher, dass die `notification_history` die `max_history_items` nicht überschreitet (älteste Elemente entfernen).
        * Sendet `SystemEvent::NotificationClosed(id, reason)` an den `event_bus`.
        * Sendet `SystemEvent::NotificationResponse(NotificationResponse::Dismissed { notification_id: id, reason })`.

5.  **`NotificationManager::action_invoked()` Methode (intern vom D-Bus-Server aufgerufen):**
    * `pub async fn action_invoked(&self, notification_id: u32, action_id: String) -> Result<(), NotificationError>`
    * **Logik:**
        * Überprüft, ob die `notification_id` existiert.
        * Sendet `SystemEvent::NotificationResponse(NotificationResponse::ActionInvoked { notification_id, action_id })` an den `event_bus`.
        * Könnte optional die Benachrichtigung nach der Aktion schließen.

6.  **`NotificationManager::get_history()` Methode:**
    * `pub async fn get_history(&self) -> Result<Vec<Notification>, NotificationError>`
    * **Logik:** Gibt den Inhalt von `notification_history` zurück.

7.  **`NotificationManager::set_do_not_disturb()` Methode:**
    * `pub async fn set_do_not_disturb(&self, enable: bool) -> Result<(), NotificationError>`
    * **Logik:**
        * Setzt `do_not_disturb_active`.
        * Aktualisiert `current_config.do_not_disturb`.
        * Informiert den `ConfigService` über die Änderung (indirekt über `NotificationService`).
        * Sendet `SystemEvent::DoNotDisturbChanged(enable)`.

8.  **`NotificationManager::get_capabilities()` Methode:**
    * `pub fn get_capabilities(&self) -> Vec<String>`
    * **Logik:** Gibt die unterstützten Fähigkeiten als String-Liste zurück. Beispiel: `["body", "actions", "body-markup", "persistence"]`.

9.  **`NotificationManager::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: NotificationConfig)`
    * **Logik:** Aktualisiert die interne `current_config`. Passt den Zustand an (z.B. `do_not_disturb_active`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::notification_service::error::NotificationError`
    * `crate::notification_service::data_types::{Notification, UrgencyLevel, NotificationAction, NotificationResponse, DismissReason, NotificationConfig}`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tokio::time`
    * `tokio::sync::RwLock`
    * `std::sync::atomic::{AtomicU32, AtomicBool, Ordering}`
    * `std::collections::HashMap`
    * `tracing`
    * `chrono::Utc`

**Kommunikationsmuster:**

* Wird vom `NotificationService` verwendet, um Benachrichtigungen zu verarbeiten.
* Sendet `SystemEvent`s an den `EventBus` bei Benachrichtigungs-Lebenszyklusänderungen oder Benutzerinteraktionen.
* Empfängt Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Benachrichtigungs-Manager, der den Lebenszyklus von Benachrichtigungen handhabt, Konfigurationen anwendet und Ereignisse an das System verteilt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken des `EventBus`.
    * Testen von `show_notification`:
        * Zuweisung von IDs.
        * Anwendung von Timeouts (simulieren und prüfen, ob `close_notification` aufgerufen wird).
        * Behandlung von `do_not_disturb`.
        * Überprüfen, ob die korrekten `SystemEvent::NotificationDisplayed` gesendet werden.
    * Testen von `close_notification`:
        * Entfernung aus `active_notifications`.
        * Hinzufügen zur Historie und Größenbeschränkung.
        * Senden von `SystemEvent::NotificationClosed` und `SystemEvent::NotificationResponse`.
    * Testen von `action_invoked` und `get_history`.
    * Testen von `set_do_not_disturb` und `update_config`.

**Geschätzter Aufwand:** Mittel (ca. 5-8 Tage, da Lebenszyklusmanagement, Queuing und Event-Handling)

---
### **novade-system/src/notification_service/dbus_interface.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert die D-Bus-Schnittstelle für den Benachrichtigungsdienst gemäß der freedesktop.org Desktop Notifications Specification. Es fungiert als Bridge zwischen externen Anwendungen, die Benachrichtigungen über D-Bus senden, und dem internen `NotificationManager`.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationDbusServer` Struct:**
    * `pub struct NotificationDbusServer {`
        * `manager: Arc<NotificationManager>,` // Referenz zum NotificationManager
        * `conn: zbus::Connection,` // D-Bus connection
    * `}`

2.  **`NotificationDbusServer::new()` Funktion:**
    * `pub async fn new(manager: Arc<NotificationManager>) -> Result<Self, NotificationError>`
    * **Logik:**
        * Stellt eine Verbindung zum Session D-Bus her (`zbus::Connection::session`).
        * Registriert einen Objekt-Server für den Pfad `/org/freedesktop/Notifications`.
        * Requestiert den D-Bus-Namen `org.freedesktop.Notifications`.
        * Fügt die Implementierung des `org.freedesktop.Notifications` Interfaces hinzu.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `DbusInitializationFailed`, `DbusError`.

3.  **Implementierung des `org.freedesktop.Notifications` D-Bus-Interfaces:**
    * Verwendet `zbus::interface` Makros.
    * Methoden, die implementiert werden müssen:
        * `#[zbus(property)] Capabilities() -> Result<Vec<String>, zbus::fdo::Error>`
            * **Logik:** Delegiert an `manager.get_capabilities()`.
        * `#[zbus(property)] ServerInformation() -> Result<(String, String, String, String), zbus::fdo::Error>`
            * **Logik:** Gibt Informationen über den Benachrichtigungsserver zurück (Name, Vendor, Version, Spec Version). Z.B. `("NovaDE Notifications", "NovaDE Team", "0.1", "1.2")`.
        * `#[zbus(name = "Notify")] pub async fn notify(`
            * `app_name: String,`
            * `replaces_id: u32,`
            * `app_icon: String,`
            * `summary: String,`
            * `body: String,`
            * `actions: Vec<String>,` // Pairs of (id, label)
            * `hints: HashMap<String, zvariant::Value>,`
            * `expire_timeout: i32,`
            * `) -> Result<u32, zbus::fdo::Error>`
            * **Logik:**
                * Konvertiert die D-Bus-Parameter in das interne `Notification` Struct.
                * Besondere Behandlung für `actions` (Paare in `NotificationAction` umwandeln) und `hints`.
                * Wenn `replaces_id` > 0 ist, wird diese ID im `Notification` Struct gesetzt, um eine bestehende Benachrichtigung zu ersetzen.
                * Delegiert die erstellte `Notification` an `manager.show_notification()`.
                * Gibt die zugewiesene `notification_id` zurück.
        * `#[zbus(name = "CloseNotification")] pub async fn close_notification(`
            * `id: u32,`
            * `) -> Result<(), zbus::fdo::Error>`
            * **Logik:** Delegiert an `manager.close_notification(id, DismissReason::ClosedByCall)`.

    * Signale, die vom Server emittiert werden können:
        * `#[zbus(signal)] NotificationClosed(id: u32, reason: u32)`
            * **Logik:** Wird vom `manager` über den `EventBus` empfangen (`SystemEvent::NotificationClosed`) und hier als D-Bus-Signal emittiert. `reason` muss auf den D-Bus-spezifischen Enum-Wert abgebildet werden.
        * `#[zbus(signal)] ActionInvoked(id: u32, action_key: String)`
            * **Logik:** Wird vom `manager` über den `EventBus` empfangen (`SystemEvent::NotificationResponse::ActionInvoked`) und hier als D-Bus-Signal emittiert.

4.  **Hintergrund-Task zum D-Bus-Loop:**
    * `pub async fn run_dbus_loop(&self) -> Result<(), NotificationError>`
    * **Logik:** Startet den D-Bus-Event-Loop (`zbus::Connection::run`). Dieser Loop verarbeitet eingehende D-Bus-Nachrichten und emittiert Signale.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/dbus_interface.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::notification_service::error::NotificationError`
    * `crate::notification_service::manager::NotificationManager`
    * `crate::notification_service::data_types::{Notification, NotificationAction, UrgencyLevel, DismissReason}`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus` crate (für D-Bus-Kommunikation)
    * `zvariant` crate (für D-Bus-Datentypen)
    * `tokio::task`
    * `std::sync::Arc`
    * `std::collections::HashMap`
    * `tracing`
    * `chrono::{DateTime, Utc}`

**Kommunikationsmuster:**

* Fungiert als D-Bus-Server und Schnittstelle für externe Anwendungen.
* Delegiert eingehende Anfragen an den `NotificationManager`.
* Empfängt Events vom `NotificationManager` (über den `EventBus`) und wandelt sie in D-Bus-Signale um.

**Erwartete Ergebnisse/Outputs:**
Eine voll funktionsfähige D-Bus-Schnittstelle, die es Anwendungen ermöglicht, Benachrichtigungen an NovaDE zu senden und Aktionen von diesen Benachrichtigungen zu empfangen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `NotificationManager` und des `zbus::Connection`.
    * Testen der Konvertierung von D-Bus-Parametern zu internen `Notification`-Typen und umgekehrt.
    * Simulieren von eingehenden D-Bus-Methodenaufrufen (`Notify`, `CloseNotification`) und Überprüfen, ob die Aufrufe korrekt an den Mock-Manager weitergeleitet werden.
    * Simulieren, dass der Mock-Manager Events sendet, und Überprüfen, ob die korrekten D-Bus-Signale emittiert werden.
* **Integration Tests (mit realem D-Bus):**
    * Starten des `NotificationDbusServer` und des gesamten `NotificationService`.
    * Verwenden von `notify-send` (oder einer D-Bus-Client-Bibliothek in einer anderen Sprache), um Benachrichtigungen mit verschiedenen Parametern zu senden (mit/ohne Icon, mit/ohne Body, mit Actions, mit Hints). Überprüfen, ob die Benachrichtigungen korrekt angezeigt werden und Aktionen funktionieren.
    * Manuelles Schließen von Benachrichtigungen und Überprüfen, ob das `NotificationClosed` Signal emittiert wird.
    * Testen des `GetCapabilities` und `GetServerInformation` Methoden.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da tiefe Kenntnisse der D-Bus-Spezifikation und `zbus` API erforderlich sind, sowie sorgfältige Parameter-Konvertierung und Signal-Handling)

---

**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `display_manager`, widmen wir uns `notification_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/notification_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/notification_service/data_types.rs`**: Definition der grundlegenden Datentypen für Benachrichtigungen und deren Konfiguration.
3.  **`novade-system/src/notification_service/manager.rs`**: Die Kernlogik zur Verwaltung des Benachrichtigungs-Lebenszyklus und der Konfiguration.
4.  **`novade-system/src/notification_service/dbus_interface.rs`**: Die Implementierung der D-Bus-Schnittstelle, die auf dem `NotificationManager` aufbaut.
5.  **`novade-system/src/notification_service/mod.rs`**: Das Hauptmodul, das den Manager und die D-Bus-Schnittstelle initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/notification_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/session_manager` Verzeichnisses, um die Benutzer-Sitzungen zu kontrollieren.
---
### **novade-system/src/session_manager/mod.rs**

**Verantwortlichkeit:**
Das `session_manager` Modul ist das Herzstück der Benutzer-Sitzungsverwaltung in NovaDE. Es ist verantwortlich für den Start, die Verwaltung und das Beenden von Benutzersitzungen. Dies umfasst die Integration mit dem Display-Manager (Login-Screen), die Verwaltung von Systemdiensten, das Speichern des Sitzungszustands und das Initiieren von Aktionen wie Herunterfahren, Neustarten oder Abmelden. Es muss auch die Integration mit `systemd-logind` oder ähnlichen Subsystemen gewährleisten.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/session_manager/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Sitzungs-Operationen)
    * `manager.rs` (Logik für Sitzungsverwaltung)
    * `data_types.rs` (Definition von Sitzungs-bezogenen Datentypen)
    * `logind_integration.rs` (Integration mit `systemd-logind`)
    * `dbus_interface.rs` (Optionale D-Bus-Schnittstelle für Sitzungs-Management)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Sitzungs-Subsystems:**
    * `pub async fn initialize_session_manager(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<SessionManagerService, SessionError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::SessionManager`.
        * Initialisiert die Integration mit `systemd-logind` über `logind_integration::LogindClient`.
        * Registriert NovaDE als Benutzersitzung bei `logind` (z.B. über `RequestSession` oder ähnliche Methoden).
        * Setzt Umgebungsvariablen, die für die Desktop-Sitzung relevant sind (z.B. `XDG_SESSION_TYPE`, `WAYLAND_DISPLAY`, `DISPLAY`).
        * Lädt initiale Sitzungseinstellungen aus dem `config_service` (z.B. `autostart_applications`, `default_session_type`).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Sitzungseinstellungen zu laden.
        * Gibt ein gebündeltes `SessionManagerService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder der `logind`-Integration.

2.  **`SessionManagerService` Struct:**
    * `pub struct SessionManagerService {`
        * `manager: Arc<SessionManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `logind_client: Arc<LogindClient>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Sitzungslogik.

3.  **Bereitstellung von API-Methoden:**
    * Der `SessionManagerService` exponiert Methoden zur Steuerung und Abfrage von Sitzungs-Einstellungen.
    * `pub async fn start_desktop_session(&self) -> Result<(), SessionError>`
        * **Logik:** Initialisiert den NovaDE-Desktop. Dies beinhaltet das Starten der UI-Shell, des Wallpapers, des Panels, etc. Sendet `SystemEvent::DesktopSessionStarted`.
    * `pub async fn logout(&self) -> Result<(), SessionError>`
        * **Logik:** Initiiert den Abmeldevorgang. Speichert den Sitzungszustand, beendet alle NovaDE-Komponenten und sendet ein D-Bus-Signal an `logind` zum Beenden der Sitzung. Sendet `SystemEvent::UserLoggedOut`.
    * `pub async fn shutdown(&self) -> Result<(), SessionError>`
        * **Logik:** Initiiert den Herunterfahrvorgang. Speichert den Sitzungszustand, beendet alle NovaDE-Komponenten und sendet ein D-Bus-Signal an `logind` zum Herunterfahren des Systems. Sendet `SystemEvent::SystemShutdown`.
    * `pub async fn reboot(&self) -> Result<(), SessionError>`
        * **Logik:** Initiiert den Neustartvorgang. Speichert den Sitzungszustand, beendet alle NovaDE-Komponenten und sendet ein D-Bus-Signal an `logind` zum Neustarten des Systems. Sendet `SystemEvent::SystemReboot`.
    * `pub async fn suspend(&self) -> Result<(), SessionError>`
        * **Logik:** Initiiert den Suspend-Vorgang. Delegiert an `logind_client.suspend()`. Sendet `SystemEvent::SystemSuspended`.
    * `pub async fn lock_screen(&self) -> Result<(), SessionError>`
        * **Logik:** Initiert das Sperren des Bildschirms. Sendet `SystemEvent::ScreenLocked`. Der Lock-Screen-Manager (separate Komponente in der UI-Schicht) muss auf dieses Event reagieren.
    * `pub async fn is_locked(&self) -> bool`
        * **Logik:** Gibt den aktuellen Sperrstatus zurück.
    * `pub async fn save_session_state(&self) -> Result<(), SessionError>`
        * **Logik:** Delegiert an den `SessionManager`, um den aktuellen Sitzungszustand (z.B. geöffnete Anwendungen, Fensterpositionen) über den `ConfigService` zu speichern.
    * `pub async fn load_session_state(&self) -> Result<(), SessionError>`
        * **Logik:** Delegiert an den `SessionManager`, um den zuletzt gespeicherten Sitzungszustand zu laden und entsprechende Aktionen einzuleiten (z.B. Anwendungen starten).

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `SessionManagerService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Sitzungseinstellungen in der Konfiguration geändert werden, werden die Sub-Komponenten (`SessionManager`) informiert.

5.  **Hintergrund-Task zum Abonnieren von `logind` Events:**
    * Ein Task, der Events von `logind_client` (z.B. `PrepareForShutdown`, `PrepareForSleep`, `SessionRemoved`) abonniert und diese in `SystemEvent`s übersetzt, um den `EventBus` zu informieren.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/session_manager/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::session_manager::error::SessionError`
    * `crate::session_manager::manager::SessionManager`
    * `crate::session_manager::data_types::{SessionConfig, SessionState}`
    * `crate::session_manager::logind_integration::LogindClient`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`

**Kommunikationsmuster:**

* Ist der primäre Controller für den Lebenszyklus der Desktop-Sitzung.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Sitzungseinstellungen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten und andere Systemdienste über Sitzungs-Statusänderungen oder kritische Aktionen zu informieren.
* Empfängt Events von `logind_client`.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Sitzungs-Subsystem, das den Lebenszyklus der NovaDE-Desktop-Sitzung verwalten und steuern kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus` und `LogindClient`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und der `logind`-Verbindung.
    * Testen der Weiterleitung von API-Aufrufen an den `SessionManager` und `LogindClient`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von `logind` Events (z.B. `PrepareForShutdown`) und Überprüfen, ob die korrekten `SystemEvent`s an den `EventBus` gesendet werden.
* **Integration Tests (mit `systemd-logind` Mock/Echt):**
    * Starten des `SessionManagerService` in einer Testumgebung mit einem laufenden `systemd-logind`.
    * Testen von `logout`, `shutdown`, `reboot`, `suspend` und Überprüfen, ob die entsprechenden `logind`-Methoden aufgerufen werden und das System wie erwartet reagiert (in einer VM oder Testumgebung).
    * Testen der `lock_screen` Funktionalität (prüfen, ob das Event gesendet wird).
    * Testen des Speicherns und Ladens des Sitzungszustands.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da komplexe Interaktion mit `systemd-logind` und Lebenszyklusmanagement)

---
### **novade-system/src/session_manager/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `session_manager` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Sitzungs-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`SessionError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum SessionError {`
        * `#[error("Failed to connect to systemd-logind: {0}")]`
        * `LogindConnectionFailed(String),`
        * `#[error("Logind operation failed: {0}")]`
        * `LogindOperationFailed(String),`
        * `#[error("Session not active or not found: {0}")]`
        * `SessionNotFound(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("D-Bus error: {0}")]`
        * `DbusError(#[from] zbus::Error),`
        * `#[error("I/O error: {0}")]`
        * `IoError(#[from] std::io::Error),`
        * `#[error("Permission denied for session operation: {0}")]`
        * `PermissionDenied(String),`
        * `#[error("Unknown session error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `zbus::Error`, `std::io::Error` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/session_manager/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::io::Error`
    * `zbus::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `session_manager` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Sitzungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/session_manager/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `session_manager` verwendet werden, um Sitzungszustände, -einstellungen und verwandte Informationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`SessionConfig` Struct (aus `config_service/data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct SessionConfig {`
        * `pub autostart_applications: Vec<String>,` // Liste der .desktop-Dateien oder Binärnamen
        * `pub remember_running_applications: bool,`
        * `pub restore_last_session: bool,`
        * `pub idle_timeout_seconds: u32,` // Zeit bis zum automatischen Sperren oder Suspend
        * `pub suspend_on_lid_close: bool,`
        * `pub session_type: SessionType,` // Wayland oder X11
        * `// ... weitere Einstellungen`
    * `}`

2.  **`SessionState` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct SessionState {`
        * `pub last_active_applications: Vec<ApplicationInfo>,` // Liste der Anwendungen, die beim letzten Logout liefen
        * `pub desktop_layout_info: Option<DesktopLayoutState>,` // Informationen über Fensterpositionen, Workspaces etc.
        * `pub last_login_timestamp: DateTime<Utc>,`
        * `pub current_user_id: u32,`
        * `pub current_username: String,`
    * `}`

3.  **`ApplicationInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct ApplicationInfo {`
        * `pub app_id: String,` // Desktop-Datei-ID oder Name der Anwendung
        * `pub window_title: Option<String>,`
        * `pub command_line: Option<String>,` // Kommandozeile zum Wiederherstellen
        * `pub workspace_id: Option<u32>,`
        * `pub position: Option<Rectangle>,`
        * `// ... weitere Eigenschaften`
    * `}`

4.  **`DesktopLayoutState` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct DesktopLayoutState {`
        * `pub active_workspace_id: u32,`
        * `pub workspaces: Vec<WorkspaceState>,`
        * `// ... weitere Layout-Details`
    * `}`

5.  **`WorkspaceState` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct WorkspaceState {`
        * `pub id: u32,`
        * `pub name: String,`
        * `pub windows: Vec<WindowLayoutInfo>,`
        * `// ...`
    * `}`

6.  **`WindowLayoutInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct WindowLayoutInfo {`
        * `pub app_id: String,`
        * `pub window_id: u32,` // Wayland-Shell-Surface-ID oder X11-Window-ID
        * `pub position: Rectangle,`
        * `pub size: Size2D,`
        * `pub state: WindowState,` // Maximized, Minimized, Fullscreen
        * `// ...`
    * `}`

7.  **`Rectangle` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct Rectangle {`
        * `pub x: i32,`
        * `pub y: i32,`
        * `pub width: u32,`
        * `pub height: u32,`
    * `}`

8.  **`Size2D` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct Size2D {`
        * `pub width: u32,`
        * `pub height: u32,`
    * `}`

9.  **`WindowState` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum WindowState { Normal, Maximized, Minimized, Fullscreen, TiledLeft, TiledRight }`

10. **`SessionType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum SessionType { Wayland, X11 }`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/session_manager/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `chrono::{DateTime, Utc}`
    * `std::collections::HashMap` (falls für zukünftige erweiterbare Datenstrukturen benötigt)

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Sitzungsinformationen und Konfigurationen im System.
* `SessionState` wird vom `SessionManager` erstellt, gespeichert und geladen.
* `SessionConfig` wird im `ConfigService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Sitzungsverwaltung und den Sitzungszustand.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Mittel (ca. 2-3 Tage, da detaillierte Strukturen für Sitzungszustand und Fensterverwaltung notwendig sind)

---
### **novade-system/src/session_manager/manager.rs**

**Verantwortlichkeit:**
Der `SessionManager` ist die Kernlogik des Sitzungs-Subsystems. Er verwaltet den Lebenszyklus der Desktop-Sitzung, einschließlich des Startens von Autostart-Anwendungen, des Speicherns und Wiederherstellens des Sitzungszustands und der Koordinierung mit `systemd-logind` für kritische Systemaktionen.

**Kern-Aufgaben (Tasks):**

1.  **`SessionManager` Struct:**
    * `pub struct SessionManager {`
        * `event_bus: EventBus,`
        * `config_service: Arc<ConfigService>,`
        * `logind_client: Arc<LogindClient>,`
        * `current_config: RwLock<SessionConfig>,`
        * `current_session_state: RwLock<SessionState>,`
        * `is_locked: AtomicBool,`
        * `// Optional: Manager für laufende Anwendungen zur Statusverfolgung`
    * `}`

2.  **`SessionManager::new()` Funktion:**
    * `pub async fn new(initial_session_config: SessionConfig, event_bus: EventBus, config_service: Arc<ConfigService>, logind_client: Arc<LogindClient>) -> Result<Self, SessionError>`
    * **Logik:**
        * Initialisiert mit den bereitgestellten Abhängigkeiten.
        * Setzt `current_config` und lädt den letzten `SessionState` aus dem `config_service`, falls `restore_last_session` aktiviert ist.
        * Setzt `is_locked` auf `false`.
        * Startet den internen `logind_client` Event-Listener, um auf `PrepareForShutdown`, `PrepareForSleep` etc. zu reagieren.
        * Gibt `Self` zurück.

3.  **`SessionManager::start_desktop_session()` Methode:**
    * `pub async fn start_desktop_session(&self) -> Result<(), SessionError>`
    * **Logik:**
        * Verarbeitet Autostart-Anwendungen basierend auf `current_config.autostart_applications`.
            * Nutzt `tokio::process::Command` oder eine Wrapper-Funktion, um Anwendungen zu starten.
        * Wenn `current_config.restore_last_session` aktiv ist, lädt und initiiert die Wiederherstellung des `SessionState` (z.B. indem es den `ApplicationManager` oder den `WindowManagementService` auffordert, Anwendungen neu zu starten oder Fenster neu zu positionieren). Dies würde `SystemEvent::RestoreApplicationSession` Events aussenden, auf die andere Dienste reagieren.
        * Sendet `SystemEvent::DesktopSessionStarted`.

4.  **`SessionManager::logout()` Methode:**
    * `pub async fn logout(&self) -> Result<(), SessionError>`
    * **Logik:**
        * Ruft `save_session_state()` auf, wenn konfiguriert.
        * Sendet `SystemEvent::PrepareForLogout` an den `EventBus`, um Anwendungen eine Chance zum Speichern zu geben.
        * Startet einen Timer, um nicht reagierende Anwendungen nach einer gewissen Zeit zwangsweise zu beenden.
        * Wartet auf Bestätigung oder Timeout von Anwendungen.
        * Ruft `logind_client.terminate_session()` oder `logind_client.power_off()`/`reboot()` mit einem Logout-Flag auf.
        * Sendet `SystemEvent::UserLoggedOut`.

5.  **`SessionManager::shutdown()` / `reboot()` / `suspend()` Methoden:**
    * **Logik:**
        * Ruft `save_session_state()` auf, wenn konfiguriert.
        * Sendet `SystemEvent::PrepareForShutdown`, `PrepareForReboot` oder `PrepareForSuspend` an den `EventBus`.
        * Wartet auf Bestätigung oder Timeout von Anwendungen.
        * Ruft die entsprechenden `logind_client` Methoden auf (`power_off`, `reboot`, `suspend`).
        * Sendet `SystemEvent::SystemShutdown`, `SystemEvent::SystemReboot` oder `SystemEvent::SystemSuspended`.

6.  **`SessionManager::lock_screen()` Methode:**
    * `pub async fn lock_screen(&self) -> Result<(), SessionError>`
    * **Logik:**
        * Setzt `is_locked` auf `true`.
        * Sendet `SystemEvent::ScreenLocked`. Der Lock-Screen-Manager (UI-Schicht) muss auf dieses Event reagieren, um die Lock-Screen-Oberfläche anzuzeigen.

7.  **`SessionManager::unlock_screen()` Methode (intern/von Lock-Screen aufgerufen):**
    * `pub async fn unlock_screen(&self) -> Result<(), SessionError>`
    * **Logik:**
        * Setzt `is_locked` auf `false`.
        * Sendet `SystemEvent::ScreenUnlocked`. Der Lock-Screen-Manager muss auf dieses Event reagieren, um die Lock-Screen-Oberfläche zu verstecken.

8.  **`SessionManager::save_session_state()` Methode:**
    * `pub async fn save_session_state(&self) -> Result<(), SessionError>`
    * **Logik:**
        * Sammelt Informationen über laufende Anwendungen und ihren Zustand (Fensterpositionen, Workspaces) über den `ApplicationManager` und `WindowManagementService`.
        * Erstellt ein `SessionState` Objekt.
        * Speichert das `SessionState` Objekt über den `ConfigService`.

9.  **`SessionManager::load_session_state()` Methode:**
    * `pub async fn load_session_state(&self) -> Result<(), SessionError>`
    * **Logik:**
        * Lädt das `SessionState` Objekt aus dem `ConfigService`.
        * Aktualisiert `current_session_state`.
        * Gibt das geladene `SessionState` Objekt zurück, sodass `start_desktop_session` es verwenden kann.

10. **`SessionManager::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: SessionConfig)`
    * **Logik:** Aktualisiert die interne `current_config`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/session_manager/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::session_manager::error::SessionError`
    * `crate::session_manager::data_types::{SessionConfig, SessionState, ApplicationInfo, DesktopLayoutState, WindowLayoutInfo, WindowState, SessionType}`
    * `crate::session_manager::logind_integration::LogindClient`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
    * `// Abhängigkeiten von ApplicationManager und WindowManagementService für save/load_session_state`
* **Extern:**
    * `tokio::task`
    * `tokio::sync::RwLock`
    * `tokio::process::Command`
    * `std::sync::Arc`
    * `std::sync::atomic::{AtomicBool, Ordering}`
    * `tracing`
    * `chrono::Utc`

**Kommunikationsmuster:**

* Wird vom `SessionManagerService` verwendet.
* Interagiert mit `ConfigService` für Konfiguration und Zustandsspeicherung.
* Kommuniziert mit `logind_client` für Systemaktionen.
* Sendet `SystemEvent`s an den `EventBus` für Lebenszyklusereignisse.
* Empfängt Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Sitzungs-Manager, der den Lebenszyklus der Desktop-Sitzung handhabt, Anwendungen startet, den Zustand speichert und Aktionen wie Herunterfahren koordiniert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus` und `LogindClient`.
    * Testen von `new`: Sicherstellen der Initialisierung und des Ladens initialer Konfiguration/Zustand.
    * Testen von `start_desktop_session`: Überprüfen, ob Autostart-Anwendungen simuliert gestartet werden und `RestoreApplicationSession` Events gesendet werden.
    * Testen von `logout`, `shutdown`, `reboot`, `suspend`: Überprüfen, ob `save_session_state` aufgerufen wird (wenn konfiguriert) und die korrekten `logind_client` Methoden aufgerufen werden, sowie `SystemEvent`s gesendet werden.
    * Testen von `lock_screen` und `unlock_screen`: Überprüfen der `is_locked` Flag und der gesendeten `SystemEvent`s.
    * Testen von `save_session_state` und `load_session_state`: Sicherstellen, dass die Daten korrekt serialisiert/deserialisiert und über den Mock-`ConfigService` gespeichert/geladen werden.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da komplexe Zustandsverwaltung, Prozess-Management und `logind`-Integration)

---
### **novade-system/src/session_manager/logind_integration.rs**

**Verantwortlichkeit:**
Dieses Modul ist für die Interaktion mit dem `systemd-logind` D-Bus-Dienst zuständig. Es bietet eine Schnittstelle, um die Benutzersitzung bei `logind` zu registrieren, Systemaktionen (Herunterfahren, Neustarten, Suspendieren) anzufordern und auf `logind`-Ereignisse zu reagieren.

**Kern-Aufgaben (Tasks):**

1.  **`LogindClient` Struct:**
    * `pub struct LogindClient {`
        * `proxy: ManagerProxy<'static>,` // Zbus Proxy für org.freedesktop.login1.Manager
        * `session_proxy: Option<SessionProxy<'static>>,` // Optionaler Proxy für die spezifische Sitzung
        * `session_id: RwLock<Option<String>>,` // Aktuelle Logind-Sitzungs-ID
        * `event_sender: mpsc::Sender<LogindEvent>,` // Sender für interne Logind-Events
    * `}`

2.  **`LogindClient::new()` Funktion:**
    * `pub async fn new() -> Result<Self, SessionError>`
    * **Logik:**
        * Stellt eine Verbindung zum System D-Bus her (`zbus::Connection::system`).
        * Erstellt einen `ManagerProxy` für `org.freedesktop.login1` auf dem Pfad `/org/freedesktop/login1`.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `LogindConnectionFailed`, `DbusError`.

3.  **`LogindClient::register_session()` Funktion:**
    * `pub async fn register_session(&self, display_var: String) -> Result<(), SessionError>`
    * **Logik:**
        * Ruft `proxy.request_session()` auf, um eine neue Logind-Sitzung anzufordern.
        * Überprüft die erhaltene Sitzungs-ID und speichert sie.
        * Erstellt einen `SessionProxy` für die spezifische Sitzung (`/org/freedesktop/login1/session/auto_generated_id`).
        * Sendet `SystemEvent::SessionRegistered(session_id)` an den `EventBus`.
        * Startet einen Hintergrund-Task zum Monitoring der Sitzung und zum Handling von `Release` Signalen.
    * **Fehlerbehandlung:** `LogindOperationFailed`, `DbusError`.

4.  **`LogindClient::terminate_session()` Funktion:**
    * `pub async fn terminate_session(&self) -> Result<(), SessionError>`
    * **Logik:**
        * Ruft `session_proxy.terminate()` auf.
        * Setzt `session_id` auf `None`.

5.  **`LogindClient::power_off()` / `reboot()` / `suspend()` Funktionen:**
    * `pub async fn power_off(&self, interactive: bool) -> Result<(), SessionError>`
    * `pub async fn reboot(&self, interactive: bool) -> Result<(), SessionError>`
    * `pub async fn suspend(&self, interactive: bool) -> Result<(), SessionError>`
    * **Logik:**
        * Ruft die entsprechenden Methoden auf dem `ManagerProxy` auf (`power_off`, `reboot`, `suspend`). Der `interactive` Parameter sollte auf `true` gesetzt werden, damit `logind` den Benutzer über die Aktion informiert und gegebenenfalls nach Berechtigungen fragt.

6.  **`LogindClient::lock_session()` / `unlock_session()` Funktionen:**
    * `pub async fn lock_session(&self) -> Result<(), SessionError>`
    * `pub async fn unlock_session(&self) -> Result<(), SessionError>`
    * **Logik:**
        * Ruft `session_proxy.lock()` oder `session_proxy.unlock()` auf. Dies dient dazu, `logind` über den Sperrstatus der Sitzung zu informieren.

7.  **`LogindClient::subscribe_to_events()` Funktion:**
    * `pub fn subscribe_to_events(&self) -> Box<dyn Stream<Item = LogindEvent> + Send + Unpin>;`
    * **Logik:** Startet einen Hintergrund-Task, der D-Bus-Signale von `logind` abonniert:
        * `PrepareForShutdown(bool)`: Signalisiert bevor das System herunterfährt/neu startet.
        * `PrepareForSleep(bool)`: Signalisiert bevor das System suspendiert/hiberniert.
        * `SessionRemoved(String)`: Signalisiert, wenn eine Sitzung beendet wird.
        * Diese D-Bus-Signale werden in das interne `LogindEvent` Enum konvertiert und über den `mpsc::channel` gesendet.

8.  **`LogindEvent` Enum (Intern im `logind_integration.rs`):**
    * `pub enum LogindEvent {`
        * `PrepareForShutdown(bool),` // true for about to shutdown, false for completed
        * `PrepareForSleep(bool),` // true for about to sleep, false for awaken
        * `SessionRemoved(String),`
        * `// ... weitere relevante Events`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/session_manager/logind_integration.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::session_manager::error::SessionError`
* **Extern:**
    * `zbus` crate (für D-Bus-Kommunikation)
    * `zbus_systemd_codegen::logind` (für generierte Proxies von `org.freedesktop.login1`)
    * `tokio::task`
    * `tokio::sync::mpsc`
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `tracing`
    * `futures::stream::Stream`

**Kommunikationsmuster:**

* Wird vom `SessionManager` instanziiert und verwendet.
* Kommuniziert direkt mit dem `systemd-logind` D-Bus-Dienst.
* Sendet interne `LogindEvent`s über einen Channel an den `SessionManager`.

**Erwartete Ergebnisse/Outputs:**
Eine robuste Schnittstelle zu `systemd-logind`, die eine sichere und konforme Sitzungs- und Systemverwaltung ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit `zbus` Mocking/Fake D-Bus):**
    * Mocken des `zbus::Connection` und der `ManagerProxy`/`SessionProxy` Methoden, um vordefinierte D-Bus-Antworten und Signale zu simulieren.
    * Testen von `new` und `register_session`: Sicherstellen, dass die korrekten D-Bus-Methoden aufgerufen und die Session-ID korrekt behandelt wird.
    * Testen von `power_off`, `reboot`, `suspend`, `terminate_session`, `lock_session`, `unlock_session`: Sicherstellen, dass die richtigen D-Bus-Methoden mit den korrekten Parametern aufgerufen werden.
    * Simulieren von `PrepareForShutdown`, `PrepareForSleep` und `SessionRemoved` Signalen und Überprüfen, ob die `LogindEvent`s über den Stream korrekt empfangen werden.
* **Integration Tests (mit realem `systemd-logind`):**
    * **Sehr vorsichtig in einer VM oder isolierten Umgebung durchführen!**
    * Starten des `LogindClient` und Registrieren einer Test-Sitzung.
    * Testen von `power_off`, `reboot`, `suspend` und Überprüfen, ob das System tatsächlich die Aktion ausführt.
    * Testen von `lock_session`/`unlock_session` und Beobachten des Systemverhaltens.
    * Simulieren von Systemaktionen außerhalb von NovaDE (z.B. `systemctl poweroff` von einer anderen Konsole) und Überprüfen, ob der `LogindClient` die `PrepareForShutdown` Events korrekt empfängt.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da D-Bus-Integration, asynchrone Signalverarbeitung und Umgang mit System-APIs)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `notification_service`, widmen wir uns `session_manager`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/session_manager/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/session_manager/data_types.rs`**: Definition der grundlegenden Datentypen für Sitzungen und deren Zustand.
3.  **`novade-system/src/session_manager/logind_integration.rs`**: Die Basis für die Kommunikation mit `systemd-logind`. Dies muss vor dem Manager implementiert werden, da der Manager davon abhängt.
4.  **`novade-system/src/session_manager/manager.rs`**: Die Kernlogik zur Verwaltung des Sitzungs-Lebenszyklus, die auf `logind_integration` aufbaut.
5.  **`novade-system/src/session_manager/mod.rs`**: Das Hauptmodul, das den Manager und die `logind`-Integration initialisiert und die öffentliche API bereitstellt.
6.  **`novade-system/src/session_manager/dbus_interface.rs`**: (Optional) Falls eine separate D-Bus-Schnittstelle für externe Anwendungen zum Sitzungs-Management (außerhalb der `logind`-D-Bus-Schnittstelle) benötigt wird. Für MVP ist dies wahrscheinlich nicht erforderlich, da `logind` die meisten dieser Aufgaben übernimmt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/session_manager` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/application_manager` Verzeichnisses, um Anwendungen zu verwalten.
---
### **novade-system/src/application_manager/mod.rs**

**Verantwortlichkeit:**
Das `application_manager` Modul ist für die Erkennung, den Start, die Beendigung und die Verwaltung von Anwendungen im NovaDE-System zuständig. Es fungiert als zentraler Punkt für die Interaktion mit Anwendungen und deren Integration in die Desktop-Umgebung. Dies beinhaltet das Parsen von `.desktop`-Dateien, die Verwaltung von laufenden Prozessen und die Bereitstellung einer API für andere Systemkomponenten, um Anwendungen zu starten oder zu beenden.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/application_manager/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Anwendungs-Operationen)
    * `manager.rs` (Logik für Anwendungsverwaltung, Prozess-Tracking)
    * `data_types.rs` (Definition von Anwendungs-bezogenen Datentypen)
    * `desktop_parser.rs` (Parsing von `.desktop`-Dateien)
    * `dbus_interface.rs` (Optionale D-Bus-Schnittstelle, z.B. für `org.kde.krunner` oder `org.gnome.Shell.AppSystem`)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Anwendungs-Subsystems:**
    * `pub async fn initialize_application_manager(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<ApplicationManagerService, ApplicationError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::ApplicationManager`.
        * Initialisiert den `desktop_parser` und scannt Standardpfade (`XDG_DATA_DIRS`) nach `.desktop`-Dateien, um eine initiale Liste der verfügbaren Anwendungen zu erstellen.
        * Lädt initiale Anwendungs- und Startkonfigurationen aus dem `config_service` (z.B. bevorzugte Anwendungen, Dateityp-Assoziationen).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Startet einen Hintergrund-Task, der Dateisystemereignisse in den `XDG_DATA_DIRS` überwacht, um Änderungen an `.desktop`-Dateien zu erkennen und den Anwendungs-Cache zu aktualisieren.
        * Gibt ein gebündeltes `ApplicationManagerService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder dem Scannen von `.desktop`-Dateien.

2.  **`ApplicationManagerService` Struct:**
    * `pub struct ApplicationManagerService {`
        * `manager: Arc<ApplicationManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
    * `}`
    * Dient als Container und Zugangspunkt für die Anwendungslogik.

3.  **Bereitstellung von API-Methoden:**
    * Der `ApplicationManagerService` exponiert Methoden zur Steuerung und Abfrage von Anwendungen.
    * `pub async fn get_available_applications(&self) -> Result<Vec<ApplicationInfo>, ApplicationError>`
        * **Logik:** Delegiert an den `ApplicationManager`, um eine Liste aller erkannten Anwendungen zurückzugeben.
    * `pub async fn launch_application(&self, app_id: &str, args: Vec<String>) -> Result<u32, ApplicationError>`
        * **Logik:** Sucht die `ApplicationInfo` für die gegebene `app_id`. Ruft `manager.launch_application()` auf. Gibt die PID des Hauptprozesses zurück. Sendet `SystemEvent::ApplicationLaunched(app_id, pid)`.
    * `pub async fn terminate_application(&self, pid: u32) -> Result<(), ApplicationError>`
        * **Logik:** Delegiert an den `ApplicationManager`, um eine Anwendung über ihre PID zu beenden. Sendet `SystemEvent::ApplicationTerminated(pid)`.
    * `pub async fn get_running_applications(&self) -> Result<Vec<ApplicationInstance>, ApplicationError>`
        * **Logik:** Delegiert an den `ApplicationManager`, um eine Liste der aktuell laufenden Anwendungsinstanzen zurückzugeben.
    * `pub async fn get_application_info(&self, app_id: &str) -> Result<ApplicationInfo, ApplicationError>`
        * **Logik:** Delegiert an den `ApplicationManager`, um detaillierte Informationen zu einer spezifischen Anwendung zu erhalten.
    * `pub async fn handle_open_with(&self, file_path: &Path, mime_type: &str) -> Result<(), ApplicationError>`
        * **Logik:** Ermittelt die Standardanwendung für den gegebenen `mime_type` (aus `ConfigService` oder Systemstandard). Startet die Anwendung mit dem Dateipfad als Argument.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `ApplicationManagerService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Anwendungs- oder Startkonfigurationen geändert werden, werden die Sub-Komponenten (`ApplicationManager`) informiert.

5.  **Hintergrund-Task zum Monitoring von `.desktop`-Dateien:**
    * Ein Task, der mittels `notify` crate oder ähnlichem Dateisystemänderungen in den `XDG_DATA_DIRS` überwacht. Bei Änderungen wird der `desktop_parser` ausgelöst, um den Anwendungs-Cache neu aufzubauen und `SystemEvent::ApplicationsUpdated` zu senden.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/application_manager/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::application_manager::error::ApplicationError`
    * `crate::application_manager::manager::ApplicationManager`
    * `crate::application_manager::data_types::{ApplicationInfo, ApplicationInstance, ApplicationConfig}`
    * `crate::application_manager::desktop_parser::DesktopParser`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `std::path::Path`
    * `notify` crate (für Dateisystem-Monitoring)

**Kommunikationsmuster:**

* Ist der primäre Controller für den Start und die Verwaltung von Anwendungen.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Anwendungs- und Startkonfigurationen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten und andere Systemdienste über den Anwendungs-Lebenszyklus zu informieren.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Anwendungs-Subsystem, das Anwendungen finden, starten, beenden und deren Status verwalten kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus` und `ApplicationManager`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und des Scannens von (Mock-)`.desktop`-Dateien.
    * Testen der Weiterleitung von API-Aufrufen an den `ApplicationManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von Dateisystem-Änderungen (z.B. `.desktop`-Datei hinzugefügt/entfernt) und Überprüfen, ob der Anwendungs-Cache aktualisiert und `SystemEvent::ApplicationsUpdated` gesendet wird.
* **Integration Tests:**
    * Starten des `ApplicationManagerService` mit echten oder simulierten `.desktop`-Dateiverzeichnissen.
    * Testen von `get_available_applications` und `get_application_info` mit bekannten `.desktop`-Dateien.
    * Testen von `launch_application` mit einem einfachen Testprogramm (z.B. `echo` oder ein kleines GUI-App), und Überprüfen, ob der Prozess gestartet und die PID korrekt zurückgegeben wird.
    * Testen von `terminate_application` und Überprüfen, ob der Prozess beendet wird.
    * Testen von `handle_open_with` mit verschiedenen Dateitypen.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da Parsing, Prozess-Management und Dateisystem-Monitoring komplex sind)

---
### **novade-system/src/application_manager/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `application_manager` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Anwendungs-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`ApplicationError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum ApplicationError {`
        * `#[error("Application with ID '{0}' not found.")]`
        * `ApplicationNotFound(String),`
        * `#[error("Failed to parse .desktop file: {0}")]`
        * `DesktopFileParseError(String),`
        * `#[error("Failed to launch application: {0}")]`
        * `LaunchError(String),`
        * `#[error("Process with PID {0} not found or already terminated.")]`
        * `ProcessNotFound(u32),`
        * `#[error("Failed to terminate process: {0}")]`
        * `TerminationError(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("I/O error: {0}")]`
        * `IoError(#[from] std::io::Error),`
        * `#[error("Unknown application error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `std::io::Error` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/application_manager/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::io::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `application_manager` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Anwendungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/application_manager/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `application_manager` verwendet werden, um Anwendungsdefinitionen, laufende Instanzen und Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`ApplicationInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct ApplicationInfo {`
        * `pub id: String,` // Desktop-Datei-ID (z.B. "firefox.desktop")
        * `pub name: String,` // Anzeigename (z.B. "Firefox Web Browser")
        * `pub icon: Option<String>,` // Icon-Name oder Pfad
        * `pub command: String,` // Auszuführender Befehl
        * `pub categories: Vec<String>,` // Z.B. "Network", "WebBrowser"
        * `pub mime_types: Vec<String>,` // Unterstützte MIME-Typen
        * `pub no_display: bool,` // Ob die Anwendung in Menüs angezeigt werden soll
        * `pub startup_notify: bool,` // Ob der Start der Anwendung visuell signalisiert werden soll
        * `pub terminal: bool,` // Ob die Anwendung in einem Terminal gestartet werden muss
        * `pub exec_args_count: u32,` // Anzahl der %f/%u Argumente im Exec-String
        * `pub desktop_file_path: PathBuf,` // Vollständiger Pfad zur .desktop-Datei
    * `}`

2.  **`ApplicationInstance` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct ApplicationInstance {`
        * `pub pid: u32,` // Prozess-ID
        * `pub app_id: String,` // Referenz auf die ApplicationInfo.id
        * `pub started_at: DateTime<Utc>,`
        * `pub command_line: String,`
        * `pub window_ids: Vec<u32>,` // Zugeordnete Fenster-IDs (vom WindowManagementService)
    * `}`

3.  **`ApplicationConfig` Struct (aus `config_service/data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct ApplicationConfig {`
        * `pub default_applications: HashMap<String, String>,` // MIME-Typ -> App ID
        * `pub blocked_applications: Vec<String>,` // Liste von App IDs, die nicht gestartet werden sollen
        * `pub autostart_delay_ms: u32,` // Verzögerung für Autostart-Anwendungen
        * `// ... weitere Einstellungen`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/application_manager/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `chrono::{DateTime, Utc}`
    * `std::collections::HashMap`
    * `std::path::PathBuf`

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Anwendungsdefinitionen und laufenden Instanzen im System.
* `ApplicationInfo` wird vom `desktop_parser` erstellt und vom `ApplicationManager` verwaltet.
* `ApplicationInstance` wird vom `ApplicationManager` verwaltet und von `save_session_state` des `SessionManager` verwendet.
* `ApplicationConfig` wird im `ConfigService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Anwendungsverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Niedrig (ca. 1-2 Tage, da Strukturen für Anwendungs-Metadaten und Laufzeitinformationen)

---
### **novade-system/src/application_manager/desktop_parser.rs**

**Verantwortlichkeit:**
Das `desktop_parser` Modul ist für das Parsen von `.desktop`-Dateien gemäß der Desktop Entry Specification (freedesktop.org) zuständig. Es liest die Informationen aus diesen Dateien und konvertiert sie in das interne `ApplicationInfo`-Struct.

**Kern-Aufgaben (Tasks):**

1.  **`DesktopParser` Struct:**
    * `pub struct DesktopParser;` // Wahrscheinlich ein statisches/Utility-Struct

2.  **`DesktopParser::parse_file()` Funktion:**
    * `pub fn parse_file(path: &Path) -> Result<ApplicationInfo, ApplicationError>`
    * **Logik:**
        * Liest den Inhalt der `.desktop`-Datei.
        * Parst die Schlüssel-Wert-Paare (z.B. `Name=`, `Exec=`, `Icon=`, `Categories=`, `MimeType=`).
        * Behandelt Lokalisierungen (z.B. `Name[de]=`).
        * Beachtet die `NoDisplay` und `Hidden` Felder.
        * Erstellt eine `ApplicationInfo`-Instanz.
    * **Fehlerbehandlung:** `IoError` (Datei nicht gefunden/lesbar), `DesktopFileParseError` (ungültiges Format).

3.  **`DesktopParser::scan_directories()` Funktion:**
    * `pub async fn scan_directories(paths: &[PathBuf]) -> Result<Vec<ApplicationInfo>, ApplicationError>`
    * **Logik:**
        * Durchläuft rekursiv die angegebenen Verzeichnisse (`XDG_DATA_DIRS`).
        * Sucht nach Dateien mit der Endung `.desktop`.
        * Ruft `parse_file()` für jede gefundene `.desktop`-Datei auf.
        * Filtert ungültige oder versteckte Einträge heraus.
        * Sammelt alle gültigen `ApplicationInfo`-Instanzen.
    * **Fehlerbehandlung:** Sammelt Fehler, gibt aber im Erfolgsfall die gefundenen gültigen Anwendungen zurück.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/application_manager/desktop_parser.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::application_manager::error::ApplicationError`
    * `crate::application_manager::data_types::ApplicationInfo`
* **Extern:**
    * `std::path::Path`
    * `std::path::PathBuf`
    * `tokio::fs`
    * `walkdir` crate (für rekursives Dateisystem-Scanning)
    * `ini` crate (oder ähnliches für INI-ähnliches Parsing)
    * `tracing`

**Kommunikationsmuster:**

* Wird vom `ApplicationManager` verwendet, um Anwendungsdefinitionen zu laden.

**Erwartete Ergebnisse/Outputs:**
Eine Sammlung von `ApplicationInfo`-Objekten, die die im System verfügbaren Anwendungen repräsentieren.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen von `parse_file` mit gültigen `.desktop`-Dateien (verschiedene Varianten: mit/ohne Icon, mit/ohne Body, mit Actions, mit Hints, mit Lokalisierungen).
    * Testen von `parse_file` mit fehlerhaften `.desktop`-Dateien (ungültiges Format, fehlende Pflichtfelder) und Überprüfen der Fehlerbehandlung.
    * Testen von `scan_directories` mit einem Testverzeichnis, das eine Mischung aus gültigen, ungültigen und versteckten `.desktop`-Dateien enthält.

**Geschätzter Aufwand:** Mittel (ca. 3-5 Tage, da genaue Einhaltung der Desktop Entry Specification erforderlich ist, inkl. Lokalisierung und Exec-String-Parsing)

---
### **novade-system/src/application_manager/manager.rs**

**Verantwortlichkeit:**
Der `ApplicationManager` ist die Kernlogik für die Verwaltung von Anwendungen. Er hält den Überblick über alle verfügbaren Anwendungen, startet und beendet Prozesse, verfolgt laufende Anwendungsinstanzen und ist für die Zuordnung von Prozessen zu Anwendungsdefinitionen verantwortlich.

**Kern-Aufgaben (Tasks):**

1.  **`ApplicationManager` Struct:**
    * `pub struct ApplicationManager {`
        * `event_bus: EventBus,`
        * `config_service: Arc<ConfigService>,`
        * `available_applications: RwLock<HashMap<String, ApplicationInfo>>,` // App ID -> ApplicationInfo
        * `running_applications: RwLock<HashMap<u32, ApplicationInstance>>,` // PID -> ApplicationInstance
        * `// Optional: Map for tracking app_id -> PIDs for multi-instance apps`
    * `}`

2.  **`ApplicationManager::new()` Funktion:**
    * `pub async fn new(initial_applications: Vec<ApplicationInfo>, config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<Self, ApplicationError>`
    * **Logik:**
        * Initialisiert mit dem `EventBus` und `ConfigService`.
        * Füllt `available_applications` mit den `initial_applications`.
        * Lädt Anwendungs-Konfigurationen (z.B. Standardanwendungen) aus dem `config_service`.
        * Gibt `Self` zurück.

3.  **`ApplicationManager::update_available_applications()` Methode:**
    * `pub async fn update_available_applications(&self, new_applications: Vec<ApplicationInfo>)`
    * **Logik:** Aktualisiert die `available_applications` Map und sendet `SystemEvent::ApplicationsUpdated`.

4.  **`ApplicationManager::get_available_applications()` Methode:**
    * `pub async fn get_available_applications(&self) -> Vec<ApplicationInfo>`
    * **Logik:** Gibt eine Kopie der Liste der `available_applications` zurück.

5.  **`ApplicationManager::get_application_info()` Methode:**
    * `pub async fn get_application_info(&self, app_id: &str) -> Result<ApplicationInfo, ApplicationError>`
    * **Logik:** Sucht die `ApplicationInfo` in der `available_applications` Map. Gibt `ApplicationNotFound` zurück, wenn nicht gefunden.

6.  **`ApplicationManager::launch_application()` Methode:**
    * `pub async fn launch_application(&self, app_id: &str, args: Vec<String>) -> Result<u32, ApplicationError>`
    * **Logik:**
        * Ruft `get_application_info()` für `app_id` ab.
        * Baut den auszuführenden Befehl zusammen, ersetzt `Exec` Argumente (`%f`, `%u` etc.) mit den bereitgestellten `args`.
        * Behandelt `Terminal=true` (startet die Anwendung in einem Terminal-Emulator).
        * Nutzt `tokio::process::Command` um den Prozess zu starten.
        * Überprüft, ob der Start erfolgreich war.
        * Erstellt eine `ApplicationInstance` und fügt sie zu `running_applications` hinzu.
        * Startet einen Hintergrund-Task, der auf das Beenden des Prozesses wartet (oder dessen Absturz), um `running_applications` zu aktualisieren und `SystemEvent::ApplicationTerminated` zu senden.
        * Gibt die PID des gestarteten Prozesses zurück.
    * **Fehlerbehandlung:** `ApplicationNotFound`, `LaunchError`.

7.  **`ApplicationManager::terminate_application()` Methode:**
    * `pub async fn terminate_application(&self, pid: u32) -> Result<(), ApplicationError>`
    * **Logik:**
        * Sucht die `ApplicationInstance` für die gegebene `pid`.
        * Sendet ein `SIGTERM` (oder ähnliches Signal) an den Prozess.
        * Wartet auf das Beenden des Prozesses. Bei Timeout, sendet `SIGKILL`.
        * Entfernt die Instanz aus `running_applications`.
        * Sendet `SystemEvent::ApplicationTerminated(pid)`.
    * **Fehlerbehandlung:** `ProcessNotFound`, `TerminationError`.

8.  **`ApplicationManager::get_running_applications()` Methode:**
    * `pub async fn get_running_applications(&self) -> Vec<ApplicationInstance>`
    * **Logik:** Gibt eine Kopie der Liste der `running_applications` zurück.

9.  **`ApplicationManager::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: ApplicationConfig)`
    * **Logik:** Aktualisiert die interne `current_config`.

10. **`ApplicationManager::get_default_application_for_mime_type()` Methode:**
    * `pub async fn get_default_application_for_mime_type(&self, mime_type: &str) -> Option<ApplicationInfo>`
    * **Logik:** Sucht in `current_config.default_applications` nach dem `mime_type`. Wenn gefunden, ruft `get_application_info()` auf. Wenn nicht gefunden, fällt auf Systemstandards zurück (z.B. XDG-MIME-Datenbank, falls implementiert).

11. **`ApplicationManager::associate_window_with_application()` Methode (Intern, von WindowManagementService aufgerufen):**
    * `pub async fn associate_window_with_application(&self, pid: u32, window_id: u32) -> Result<(), ApplicationError>`
    * **Logik:** Fügt `window_id` zur `window_ids` Liste der entsprechenden `ApplicationInstance` hinzu.

12. **`ApplicationManager::disassociate_window_from_application()` Methode (Intern, von WindowManagementService aufgerufen):**
    * `pub async fn disassociate_window_from_application(&self, window_id: u32) -> Result<(), ApplicationError>`
    * **Logik:** Entfernt `window_id` aus allen `ApplicationInstance`s.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/application_manager/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::application_manager::error::ApplicationError`
    * `crate::application_manager::data_types::{ApplicationInfo, ApplicationInstance, ApplicationConfig}`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tokio::process::Command`
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `std::collections::HashMap`
    * `tracing`
    * `nix::sys::signal` (für Prozess-Signale)

**Kommunikationsmuster:**

* Wird vom `ApplicationManagerService` verwendet.
* Interagiert mit `ConfigService` für Konfiguration.
* Sendet `SystemEvent`s an den `EventBus` bei Anwendungs-Lebenszyklusänderungen.
* Empfängt `ApplicationInfo` von `desktop_parser`.
* Interagiert mit `WindowManagementService` zur Zuordnung von Fenstern zu Prozessen.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Anwendungs-Manager, der das Starten und Beenden von Anwendungen orchestriert, deren Status verfolgt und als zentrale Quelle für Anwendungsdaten dient.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService` und `EventBus`.
    * Testen von `new` und `update_available_applications`.
    * Testen von `get_application_info` (gefunden/nicht gefunden).
    * Testen von `launch_application`:
        * Simulieren des Prozessstarts und der PID-Rückgabe.
        * Überprüfen, ob `ApplicationInstance` korrekt erstellt und hinzugefügt wird.
        * Überprüfen, ob `SystemEvent::ApplicationLaunched` gesendet wird.
        * Testen der Exec-Argument-Ersetzung.
        * Testen des Terminal-Starts.
    * Testen von `terminate_application`:
        * Simulieren des Prozess-Beendens (SIGTERM/SIGKILL).
        * Überprüfen, ob die Instanz aus `running_applications` entfernt und `SystemEvent::ApplicationTerminated` gesendet wird.
    * Testen von `get_running_applications`.
    * Testen von `associate_window_with_application` und `disassociate_window_from_application`.
* **Integration Tests:**
    * Starten des `ApplicationManager` mit einem echten `ConfigService` und `EventBus`.
    * Starten und Beenden von realen Testanwendungen (z.B. `sleep` oder ein kleines GUI-Programm) und Überprüfen des Verhaltens und der `running_applications` Map.
    * Testen des Verfolgens von Kindprozessen, falls die gestartete Anwendung weitere Prozesse spawnt.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da Prozess-Management, IPC und Status-Tracking komplex sind)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `session_manager`, widmen wir uns `application_manager`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/application_manager/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/application_manager/data_types.rs`**: Definition der grundlegenden Datentypen für Anwendungen und deren Instanzen.
3.  **`novade-system/src/application_manager/desktop_parser.rs`**: Dies ist eine Kernkomponente, die für die Erkennung von Anwendungen unerlässlich ist. Sie muss vor dem Manager implementiert werden, da der Manager die geparsten Daten benötigt.
4.  **`novade-system/src/application_manager/manager.rs`**: Die Kernlogik zur Verwaltung des Anwendungs-Lebenszyklus, die auf dem `desktop_parser` und den `data_types` aufbaut.
5.  **`novade-system/src/application_manager/mod.rs`**: Das Hauptmodul, das den Manager und den Parser initialisiert und die öffentliche API bereitstellt.
6.  **`novade-system/src/application_manager/dbus_interface.rs`**: (Optional) Falls eine separate D-Bus-Schnittstelle für externe Anwendungen zum Anwendungs-Management benötigt wird. Dies ist für MVP wahrscheinlich nicht erforderlich, da der `ApplicationManagerService` intern aufgerufen werden kann.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/application_manager` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/window_management_service` Verzeichnisses, um die Fensterverwaltung zu implementieren.
---
### **novade-system/src/window_management_service/mod.rs**

**Verantwortlichkeit:**
Das `window_management_service` Modul ist das zentrale System für die Verwaltung aller grafischen Fenster auf dem NovaDE-Desktop. Es ist verantwortlich für die Interaktion mit dem Compositor (Wayland oder X11), die Verwaltung des Fensterzustands (Position, Größe, Minimierung, Maximierung), die Abbildung von Fenstern auf Anwendungen, die Bereitstellung von Informationen über Fenster und das Handling von Fenster-Events (Schließen, Fokusänderung, etc.). Es muss auch Multi-Monitor-Setups und virtuelle Workspaces unterstützen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/window_management_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Fenster-Operationen)
    * `manager.rs` (Logik für Fensterverwaltung, Workspace-Management)
    * `data_types.rs` (Definition von Fenster- und Workspace-bezogenen Datentypen)
    * `compositor_integration.rs` (Abstraktionsschicht für Compositor-spezifische APIs, z.B. Wayland oder X11)
    * `dbus_interface.rs` (Optionale D-Bus-Schnittstelle, z.B. für EWMH oder `org.kde.KWin`)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Fenster-Management-Subsystems:**
    * `pub async fn initialize_window_management_service(config_service: Arc<ConfigService>, event_bus: EventBus, application_manager: Arc<ApplicationManagerService>) -> Result<WindowManagementService, WindowManagementError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::WindowManager`.
        * Initialisiert die Compositor-Integration über `compositor_integration::CompositorClient`, basierend auf der aktuellen `SessionType` (Wayland/X11).
        * Registriert sich beim Compositor, um Fenster-Events zu erhalten (Fenster erstellen, zerstören, fokusieren, verschieben, größenändern).
        * Lädt initiale Fenster- und Workspace-Einstellungen aus dem `config_service` (z.B. `default_workspace_count`, `window_snapping_enabled`).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Startet einen Hintergrund-Task, der auf Fenster-Events vom `CompositorClient` hört und diese an den `WindowManager` weiterleitet.
        * Gibt ein gebündeltes `WindowManagementService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder der Compositor-Integration.

2.  **`WindowManagementService` Struct:**
    * `pub struct WindowManagementService {`
        * `manager: Arc<WindowManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `application_manager: Arc<ApplicationManagerService>,`
        * `compositor_client: Arc<dyn CompositorClient + Send + Sync>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Fensterlogik.

3.  **Bereitstellung von API-Methoden:**
    * Der `WindowManagementService` exponiert Methoden zur Steuerung und Abfrage von Fenstern und Workspaces.
    * `pub async fn get_all_windows(&self) -> Result<Vec<WindowInfo>, WindowManagementError>`
        * **Logik:** Delegiert an den `WindowManager`, um eine Liste aller aktuell verwalteten Fenster zurückzugeben.
    * `pub async fn close_window(&self, window_id: u32) -> Result<(), WindowManagementError>`
        * **Logik:** Delegiert an den `WindowManager`, um ein spezifisches Fenster zu schließen. Sendet `SystemEvent::WindowClosed(window_id)`.
    * `pub async fn minimize_window(&self, window_id: u32) -> Result<(), WindowManagementError>`
        * **Logik:** Delegiert an den `WindowManager`, um ein Fenster zu minimieren. Sendet `SystemEvent::WindowMinimized(window_id)`.
    * `pub async fn maximize_window(&self, window_id: u32) -> Result<(), WindowManagementError>`
        * **Logik:** Delegiert an den `WindowManager`, um ein Fenster zu maximieren. Sendet `SystemEvent::WindowMaximized(window_id)`.
    * `pub async fn restore_window(&self, window_id: u32) -> Result<(), WindowManagementError>`
        * **Logik:** Delegiert an den `WindowManager`, um ein Fenster wiederherzustellen. Sendet `SystemEvent::WindowRestored(window_id)`.
    * `pub async fn set_window_position(&self, window_id: u32, x: i32, y: i32) -> Result<(), WindowManagementError>`
        * **Logik:** Delegiert an den `WindowManager`, um die Position eines Fensters zu ändern.
    * `pub async fn set_window_size(&self, window_id: u32, width: u32, height: u32) -> Result<(), WindowManagementError>`
        * **Logik:** Delegiert an den `WindowManager`, um die Größe eines Fensters zu ändern.
    * `pub async fn focus_window(&self, window_id: u32) -> Result<(), WindowManagementError>`
        * **Logik:** Delegiert an den `WindowManager`, um den Fokus auf ein Fenster zu setzen. Sendet `SystemEvent::WindowFocused(window_id)`.
    * `pub async fn get_active_window(&self) -> Result<Option<WindowInfo>, WindowManagementError>`
        * **Logik:** Delegiert an den `WindowManager`, um Informationen über das aktuell fokussierte Fenster zu erhalten.
    * `pub async fn get_workspaces(&self) -> Result<Vec<WorkspaceInfo>, WindowManagementError>`
        * **Logik:** Delegiert an den `WindowManager`, um eine Liste aller virtuellen Workspaces zurückzugeben.
    * `pub async fn switch_workspace(&self, workspace_id: u32) -> Result<(), WindowManagementError>`
        * **Logik:** Delegiert an den `WindowManager`, um zu einem anderen Workspace zu wechseln. Sendet `SystemEvent::WorkspaceSwitched(workspace_id)`.
    * `pub async fn move_window_to_workspace(&self, window_id: u32, workspace_id: u32) -> Result<(), WindowManagementError>`
        * **Logik:** Delegiert an den `WindowManager`, um ein Fenster auf einen anderen Workspace zu verschieben. Sendet `SystemEvent::WindowMovedToWorkspace(window_id, workspace_id)`.
    * `pub async fn add_workspace(&self) -> Result<u32, WindowManagementError>`
        * **Logik:** Delegiert an den `WindowManager`, um einen neuen Workspace hinzuzufügen. Sendet `SystemEvent::WorkspaceAdded(new_workspace_id)`.
    * `pub async fn remove_workspace(&self, workspace_id: u32) -> Result<(), WindowManagementError>`
        * **Logik:** Delegiert an den `WindowManager`, um einen Workspace zu entfernen (Fenster verschieben oder schließen). Sendet `SystemEvent::WorkspaceRemoved(workspace_id)`.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `WindowManagementService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Fenster- oder Workspace-Einstellungen geändert werden, werden die Sub-Komponenten (`WindowManager`) informiert.

5.  **Hintergrund-Task zum Verarbeiten von Compositor-Events:**
    * Ein Task, der den Event-Stream vom `CompositorClient` abonniert. Jedes empfangene Compositor-Event (z.B. neues Fenster, Fokuswechsel) wird vom `WindowManagementService` verarbeitet:
        * Der `WindowManager` wird aktualisiert.
        * Das `ApplicationManagerService` wird über neue Fenster und deren zugehörige PIDs informiert (`associate_window_with_application`).
        * Relevante `SystemEvent`s werden an den `EventBus` gesendet (z.B. `WindowCreated`, `WindowFocused`, `WindowClosed`, `WindowMoved`, `WindowResized`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_management_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::window_management_service::error::WindowManagementError`
    * `crate::window_management_service::manager::WindowManager`
    * `crate::window_management_service::data_types::{WindowInfo, WorkspaceInfo, WindowConfig}`
    * `crate::window_management_service::compositor_integration::{CompositorClient, CompositorEvent}`
    * `crate::config_service::ConfigService`
    * `crate::application_manager::ApplicationManagerService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `futures::stream::StreamExt` (für Event-Stream-Verarbeitung)

**Kommunikationsmuster:**

* Ist der primäre Controller für die Interaktion mit dem Compositor und die Verwaltung von Fenstern.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Fenster- und Workspace-Einstellungen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten und andere Systemdienste über Fenster- und Workspace-Änderungen zu informieren.
* Empfängt Events vom `CompositorClient`.
* Informiert den `ApplicationManagerService` über neue Fenster und deren Zuordnung zu Anwendungen.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Fenster-Management-Subsystem, das Fenster und Workspaces effektiv verwalten kann, mit tiefer Integration in den Compositor.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `ApplicationManagerService` und `CompositorClient`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und der Verbindung zum Mock-Compositor.
    * Testen der Weiterleitung von API-Aufrufen an den `WindowManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von `CompositorEvent`s (z.B. `WindowCreated`, `WindowFocused`) und Überprüfen, ob die korrekten `SystemEvent`s an den `EventBus` gesendet und der `ApplicationManagerService` korrekt aufgerufen wird.
* **Integration Tests (mit realem Compositor, falls möglich, oder dedizierter Test-Compositor):**
    * Starten des `WindowManagementService` und eines Test-Compositors (z.B. `wayland-compositor` oder `xorg-server` in einer virtuellen Umgebung).
    * Starten von Test-Anwendungen, die Fenster öffnen, schließen, minimieren, maximieren und verschieben.
    * Überprüfen, ob der `WindowManagementService` diese Aktionen korrekt registriert und die entsprechenden `SystemEvent`s emittiert.
    * Testen der Workspace-Switching-Funktionalität.
    * Überprüfen der Interaktion mit dem `ApplicationManagerService` für die Fenster-App-Zuordnung.

**Geschätzter Aufwand:** Sehr hoch (ca. 10-15 Tage, da tiefe Integration mit dem Compositor, komplexes Zustandsmanagement und Event-Verarbeitung notwendig sind)

---
### **novade-system/src/window_management_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `window_management_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Fenster-Management-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`WindowManagementError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum WindowManagementError {`
        * `#[error("Window with ID {0} not found.")]`
        * `WindowNotFound(u32),`
        * `#[error("Workspace with ID {0} not found.")]`
        * `WorkspaceNotFound(u32),`
        * `#[error("Compositor connection failed: {0}")]`
        * `CompositorConnectionFailed(String),`
        * `#[error("Compositor operation failed: {0}")]`
        * `CompositorOperationFailed(String),`
        * `#[error("Invalid window state transition.")]`
        * `InvalidWindowStateTransition,`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Application manager error: {0}")]`
        * `ApplicationManagerError(#[from] crate::application_manager::error::ApplicationError),`
        * `#[error("I/O error: {0}")]`
        * `IoError(#[from] std::io::Error),`
        * `#[error("Unknown window management error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `crate::application_manager::error::ApplicationError`, `std::io::Error` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_management_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::io::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`
    * `crate::application_manager::error::ApplicationError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `window_management_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Fensterverwaltungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/window_management_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `window_management_service` verwendet werden, um Fenster, Workspaces, Monitore und deren Eigenschaften zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`WindowInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct WindowInfo {`
        * `pub id: u32,` // Eindeutige ID des Fensters (compositor-spezifisch, z.B. XID oder Wayland-Surface-ID)
        * `pub title: String,`
        * `pub app_id: Option<String>,` // Zugeordnete Anwendungs-ID (aus .desktop-Datei)
        * `pub pid: Option<u32>,` // Prozess-ID der Anwendung, die das Fenster besitzt
        * `pub class_name: Option<String>,` // X11 WM_CLASS oder Wayland app_id
        * `pub position: Rectangle,`
        * `pub size: Size2D,`
        * `pub state: WindowState,`
        * `pub workspace_id: u32,` // Aktueller Workspace
        * `pub decorated: bool,` // Ob das Fenster Client-Side oder Server-Side dekoriert ist
        * `pub always_on_top: bool,`
        * `pub minimized: bool,`
        * `pub maximized: bool,`
        * `pub fullscreen: bool,`
        * `pub resizable: bool,`
        * `pub movable: bool,`
        * `pub transient_for: Option<u32>,` // Parent window ID
        * `pub is_dialog: bool,`
    * `}`

2.  **`WindowState` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum WindowState { Normal, Maximized, Minimized, Fullscreen, TiledLeft, TiledRight }`
    * (Wiederholung aus `session_manager::data_types`, hier neu definieren oder als gemeinsame Core-Typen in `novade_core::data_types` verschieben) -> **Entscheidung: Gemeinsame Core-Typen in `novade_core::data_types`!**

3.  **`WorkspaceInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct WorkspaceInfo {`
        * `pub id: u32,`
        * `pub name: String,`
        * `pub is_active: bool,`
        * `pub monitor_id: u32,` // Monitor, zu dem der Workspace gehört
        * `pub windows: Vec<u32>,` // Liste der Fenster-IDs auf diesem Workspace
    * `}`

4.  **`MonitorInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct MonitorInfo {`
        * `pub id: u32,`
        * `pub name: String,` // Z.B. "DP-1"
        * `pub make: String,`
        * `pub model: String,`
        * `pub resolution: Size2D,`
        * `pub position: Point2D,` // Top-Left-Corner in globalen Koordinaten
        * `pub is_primary: bool,`
        * `pub current_workspace_id: u32,`
    * `}`

5.  **`Rectangle` Struct (aus `novade_core::data_types`):**
    * `pub struct Rectangle { pub x: i32, pub y: i32, pub width: u32, pub height: u32 }`

6.  **`Size2D` Struct (aus `novade_core::data_types`):**
    * `pub struct Size2D { pub width: u32, pub height: u32 }`

7.  **`Point2D` Struct (neu, wenn nötig):**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct Point2D { pub x: i32, pub y: i32 }`

8.  **`WindowConfig` Struct (aus `config_service/data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct WindowConfig {`
        * `pub default_workspace_count: u32,`
        * `pub window_snapping_enabled: bool,`
        * `pub window_gap_size: u32,`
        * `pub title_bar_height: u32,`
        * `pub animate_window_transitions: bool,`
        * `pub focus_follows_mouse: bool,`
        * `// ... weitere Einstellungen`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_management_service/data_types.rs`

**Abhängigkeiten:**

* **Intern:**
    * `novade_core::data_types::{Rectangle, Size2D, WindowState}` (Import dieser gemeinsamen Typen)
* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::collections::HashMap` (falls für zukünftige erweiterbare Datenstrukturen benötigt)

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Fenster-, Workspace- und Monitorinformationen im System.
* Sie werden vom `WindowManager` erstellt, verwaltet und von der API des `WindowManagementService` verwendet.
* `WindowConfig` wird im `ConfigService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Fensterverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Mittel (ca. 2-4 Tage, da detaillierte Strukturen für Fensterzustand, Metadaten und Multi-Monitor/Workspace-Management notwendig sind)

---
### **novade-system/src/window_management_service/compositor_integration.rs**

**Verantwortlichkeit:**
Dieses Modul bietet eine Abstraktionsschicht für die Kommunikation mit dem zugrunde liegenden Compositor (Wayland oder X11). Es definiert ein Trait `CompositorClient`, das die gemeinsame Schnittstelle für Compositor-Operationen und Event-Handling bereitstellt, und implementiert dann spezifische Clients (z.B. `WaylandClient`, `X11Client`).

**Kern-Aufgaben (Tasks):**

1.  **`CompositorClient` Trait:**
    * `#[async_trait]`
    * `pub trait CompositorClient: Send + Sync {`
        * `async fn new(event_bus: EventBus, config_service: Arc<ConfigService>, application_manager: Arc<ApplicationManagerService>) -> Result<Self, WindowManagementError> where Self: Sized;`
        * `async fn get_all_windows(&self) -> Result<Vec<WindowInfo>, WindowManagementError>;`
        * `async fn close_window(&self, window_id: u32) -> Result<(), WindowManagementError>;`
        * `async fn minimize_window(&self, window_id: u32) -> Result<(), WindowManagementError>;`
        * `async fn maximize_window(&self, window_id: u32) -> Result<(), WindowManagementError>;`
        * `async fn restore_window(&self, window_id: u32) -> Result<(), WindowManagementError>;`
        * `async fn set_window_position(&self, window_id: u32, x: i32, y: i32) -> Result<(), WindowManagementError>;`
        * `async fn set_window_size(&self, window_id: u32, width: u32, height: u32) -> Result<(), WindowManagementError>;`
        * `async fn focus_window(&self, window_id: u32) -> Result<(), WindowManagementError>;`
        * `async fn get_active_window_id(&self) -> Result<Option<u32>, WindowManagementError>;`
        * `async fn get_all_monitors(&self) -> Result<Vec<MonitorInfo>, WindowManagementError>;`
        * `async fn set_input_focus_to_window(&self, window_id: u32) -> Result<(), WindowManagementError>;`
        * `fn event_stream(&self) -> Box<dyn Stream<Item = CompositorEvent> + Send + Unpin>;`
    * `}`

2.  **`CompositorEvent` Enum:**
    * `#[derive(Debug, Clone)]`
    * `pub enum CompositorEvent {`
        * `WindowCreated { id: u32, parent_pid: Option<u32> },` // parent_pid for initial app association
        * `WindowDestroyed { id: u32 },`
        * `WindowFocused { id: u32 },`
        * `WindowUnfocused { id: u32 },`
        * `WindowMoved { id: u32, new_position: Point2D },`
        * `WindowResized { id: u32, new_size: Size2D },`
        * `WindowStateChanged { id: u32, new_state: WindowState },`
        * `MonitorAdded { monitor_info: MonitorInfo },`
        * `MonitorRemoved { monitor_id: u32 },`
        * `MonitorResized { monitor_id: u32, new_resolution: Size2D },`
        * `KeyboardInput { key_code: u32, state: InputState },` // Raw keyboard input
        * `MouseInput { x: i32, y: i32, button: MouseButton, state: InputState },`
        * `// ... weitere Events wie Drag & Drop, Compositor Shutdown etc.`
    * `}`

3.  **`InputState` Enum (für Keyboard/Mouse Input):**
    * `#[derive(Debug, Clone, PartialEq, Eq)]`
    * `pub enum InputState { Pressed, Released }`

4.  **`MouseButton` Enum (für Mouse Input):**
    * `#[derive(Debug, Clone, PartialEq, Eq)]`
    * `pub enum MouseButton { Left, Right, Middle, Other(u32) }`

5.  **`WaylandClient` Implementierung (im Idealfall in `wayland_integration.rs`):**
    * `pub struct WaylandClient { ... }`
    * **Logik:**
        * Nutzt eine Wayland-Client-Bibliothek (z.B. `wayland-client`, `smithay-client-toolkit`, `wlroots` für Compositor-Seite) und `zbus` für Wayland-spezifische D-Bus-Schnittstellen (wie `wlr-layer-shell`, `xdg-shell`).
        * Implementiert alle `CompositorClient`-Trait-Methoden durch Interaktion mit dem Wayland-Compositor.
        * Startet einen Event-Loop, der auf Wayland-Events hört und diese in `CompositorEvent`s konvertiert und über den `event_stream` sendet.
        * Das Mapping von Wayland-Surface-IDs zu PIDs muss über Protokolle wie `xdg-shell` oder `_NET_WM_PID` (XWayland) erfolgen.

6.  **`X11Client` Implementierung (im Idealfall in `x11_integration.rs`):**
    * `pub struct X11Client { ... }`
    * **Logik:**
        * Nutzt eine X11-Client-Bibliothek (z.B. `x11rb`).
        * Implementiert alle `CompositorClient`-Trait-Methoden durch Interaktion mit dem X11-Server (X Window System Protokoll).
        * Nutzt EWMH (Extended Window Manager Hints) und ICCCM (Inter-Client Communication Conventions Manual) zur Verwaltung von Fenstern und deren Eigenschaften.
        * Startet einen Event-Loop, der auf X11-Events hört und diese in `CompositorEvent`s konvertiert und über den `event_stream` sendet.
        * Das Mapping von XIDs zu PIDs erfolgt über EWMH (`_NET_WM_PID`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_management_service/compositor_integration.rs`
* (Zukünftig: `novade-system/src/window_management_service/wayland_client.rs`)
* (Zukünftig: `novade-system/src/window_management_service/x11_client.rs`)

**Abhängigkeiten:**

* **Intern:**
    * `crate::window_management_service::error::WindowManagementError`
    * `crate::window_management_service::data_types::{WindowInfo, MonitorInfo, Rectangle, Size2D}`
    * `novade_core::data_types::{WindowState}`
    * `novade_core::event_bus::EventBus`
    * `crate::config_service::ConfigService`
    * `crate::application_manager::ApplicationManagerService`
* **Extern:**
    * `async_trait` crate
    * `futures::stream::Stream`
    * `tokio::sync::mpsc`
    * `tracing`
    * `// Wayland-spezifische crates (wayland-client, zbus, smithay-client-toolkit etc.)`
    * `// X11-spezifische crates (x11rb)`

**Kommunikationsmuster:**

* Wird vom `WindowManagementService` verwendet, um den Compositor zu abstrahieren.
* Sendet `CompositorEvent`s über den Event-Stream an den `WindowManagementService`.

**Erwartete Ergebnisse/Outputs:**
Eine flexible Abstraktionsschicht für Compositor-Interaktionen, die es NovaDE ermöglicht, sowohl auf Wayland als auch auf X11 zu laufen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking des Compositor-APIs):**
    * Mocken der zugrunde liegenden Wayland/X11-Bibliotheken, um simulierte Compositor-Antworten und Events zu generieren.
    * Testen jeder Methode des `CompositorClient`-Traits (z.B. `close_window`, `set_window_position`) und Überprüfen, ob die korrekten Low-Level-Calls an den Mock-Compositor erfolgen.
    * Simulieren von Compositor-Events und Überprüfen, ob die `event_stream` korrekte `CompositorEvent`s emittiert.
* **Integration Tests (mit realem Compositor/Test-Compositor):**
    * **Für Wayland/X11-Clients ist ein voll funktionsfähiger Test-Compositor (oder ein realer) unerlässlich.**
    * Starten des `WaylandClient` oder `X11Client` mit einem Test-Compositor.
    * Starten von Test-Anwendungen, die Fenster erstellen, manipulieren (bewegen, größenändern, minimieren) und schließen.
    * Überprüfen, ob der Client diese Fenster korrekt erkennt, deren Eigenschaften abrufen kann und die entsprechenden `CompositorEvent`s sendet.
    * Testen der Fähigkeit, Fenster über die Client-Methoden zu steuern und die Auswirkungen auf dem Compositor zu beobachten.

**Geschätzter Aufwand:** Sehr hoch (ca. 15-25 Tage pro Compositor-Implementierung, da dies die komplexeste und kritischste Integration mit dem Grafik-Stack ist. Wayland ist hier besonders herausfordernd aufgrund seiner Protokoll-basierten Natur und der Notwendigkeit, Client-seitige Bibliotheken zu verwenden oder eigene Protokollimplementierungen zu erstellen.)

---
### **novade-system/src/window_management_service/manager.rs**

**Verantwortlichkeit:**
Der `WindowManager` ist die Kernlogik des Fenster-Management-Subsystems. Er verwaltet den internen Zustand aller Fenster, Workspaces und Monitore. Er verarbeitet Events vom Compositor, wendet Fensterregeln an (z.B. Snapping, Tiling) und orchestriert die Kommunikation mit dem `ApplicationManager` zur Zuordnung von Fenstern zu Anwendungen.

**Kern-Aufgaben (Tasks):**

1.  **`WindowManager` Struct:**
    * `pub struct WindowManager {`
        * `event_bus: EventBus,`
        * `config_service: Arc<ConfigService>,`
        * `application_manager: Arc<ApplicationManagerService>,`
        * `compositor_client: Arc<dyn CompositorClient + Send + Sync>,`
        * `windows: RwLock<HashMap<u32, WindowInfo>>,` // window_id -> WindowInfo
        * `workspaces: RwLock<HashMap<u32, WorkspaceInfo>>,` // workspace_id -> WorkspaceInfo
        * `monitors: RwLock<HashMap<u32, MonitorInfo>>,` // monitor_id -> MonitorInfo
        * `next_workspace_id: AtomicU32,`
        * `active_workspace_id: AtomicU32,`
        * `last_focused_window_id: RwLock<Option<u32>>,`
        * `current_config: RwLock<WindowConfig>,`
    * `}`

2.  **`WindowManager::new()` Funktion:**
    * `pub async fn new(`
        * `event_bus: EventBus,`
        * `config_service: Arc<ConfigService>,`
        * `application_manager: Arc<ApplicationManagerService>,`
        * `compositor_client: Arc<dyn CompositorClient + Send + Sync>,`
    * `) -> Result<Self, WindowManagementError>`
    * **Logik:**
        * Initialisiert alle Felder.
        * Lädt initiale `WindowConfig` aus dem `config_service`.
        * Ruft `compositor_client.get_all_monitors()` ab, um die initialen Monitor-Informationen zu laden und `monitors` zu füllen.
        * Erstellt eine Standardanzahl von Workspaces basierend auf `default_workspace_count` in der Konfiguration und füllt `workspaces`.
        * Ruft `compositor_client.get_all_windows()` ab, um initial vorhandene Fenster zu registrieren und die `windows` Map zu füllen. Dabei wird versucht, die App-ID und PID über den `ApplicationManager` zu ermitteln.
        * Setzt den `active_workspace_id` auf den ersten Workspace.
        * Gibt `Self` zurück.

3.  **`WindowManager::handle_compositor_event()` Methode:**
    * `pub async fn handle_compositor_event(&self, event: CompositorEvent) -> Result<(), WindowManagementError>`
    * **Logik:** Verarbeitet eingehende `CompositorEvent`s:
        * **`WindowCreated`**:
            * Ruft `compositor_client.get_window_info(id)` ab, um detaillierte Infos zu erhalten.
            * Versucht, die `app_id` und `pid` zu ermitteln (z.B. über `parent_pid` oder durch Abfragen des `ApplicationManager`).
            * Ruft `application_manager.associate_window_with_application(pid, id)` auf.
            * Fügt das Fenster zu `windows` hinzu.
            * Weist das Fenster dem aktuellen aktiven Workspace zu.
            * Sendet `SystemEvent::WindowCreated(window_info)`.
        * **`WindowDestroyed`**:
            * Entfernt Fenster aus `windows` und aus dem zugehörigen Workspace.
            * Ruft `application_manager.disassociate_window_from_application(id)` auf.
            * Sendet `SystemEvent::WindowClosed(id)`.
        * **`WindowFocused`**:
            * Aktualisiert `last_focused_window_id`.
            * Sendet `SystemEvent::WindowFocused(id)`.
        * **`WindowMoved` / `WindowResized`**:
            * Aktualisiert die Position/Größe im `WindowInfo` Struct.
            * Sendet `SystemEvent::WindowMoved` oder `SystemEvent::WindowResized`.
        * **`WindowStateChanged`**:
            * Aktualisiert den `WindowState` im `WindowInfo` Struct (Minimiert, Maximiert, Vollbild).
            * Sendet `SystemEvent::WindowMinimized`, `WindowMaximized`, `WindowRestored`, `WindowFullscreenChanged`.
        * **`MonitorAdded` / `MonitorRemoved` / `MonitorResized`**:
            * Aktualisiert die `monitors` Map.
            * Passt Workspaces entsprechend an (z.B. Zuweisung zu einem anderen Monitor).
            * Sendet `SystemEvent::MonitorAdded`, `MonitorRemoved`, `MonitorResized`.
        * **Input Events (`KeyboardInput`, `MouseInput`):**
            * Werden möglicherweise für globale Tastatur-Shortcuts oder Mausgesten an eine separate `InputService` Komponente weitergeleitet. Zunächst hier nur als Event vorhanden.

4.  **`WindowManager::get_all_windows()` Methode:**
    * `pub async fn get_all_windows(&self) -> Vec<WindowInfo>`
    * **Logik:** Gibt alle verwalteten Fenster zurück.

5.  **`WindowManager::get_window_info()` Methode:**
    * `pub async fn get_window_info(&self, window_id: u32) -> Result<WindowInfo, WindowManagementError>`
    * **Logik:** Gibt `WindowInfo` für eine bestimmte ID zurück.

6.  **`WindowManager::close_window()` Methode:**
    * `pub async fn close_window(&self, window_id: u32) -> Result<(), WindowManagementError>`
    * **Logik:** Ruft `compositor_client.close_window(window_id)` auf. Das `WindowDestroyed` Event wird dann vom Compositor kommen und die interne Zustandsänderung auslösen.

7.  **`WindowManager::minimize_window()` / `maximize_window()` / `restore_window()` Methoden:**
    * `pub async fn minimize_window(&self, window_id: u32) -> Result<(), WindowManagementError>`
    * `pub async fn maximize_window(&self, window_id: u32) -> Result<(), WindowManagementError>`
    * `pub async fn restore_window(&self, window_id: u32) -> Result<(), WindowManagementError>`
    * **Logik:** Rufen die entsprechenden Methoden auf `compositor_client` auf. Die `WindowStateChanged` Events werden dann vom Compositor kommen.

8.  **`WindowManager::set_window_position()` / `set_window_size()` Methoden:**
    * `pub async fn set_window_position(&self, window_id: u32, x: i32, y: i32) -> Result<(), WindowManagementError>`
    * `pub async fn set_window_size(&self, window_id: u32, width: u32, height: u32) -> Result<(), WindowManagementError>`
    * **Logik:** Rufen die entsprechenden Methoden auf `compositor_client` auf. Die `WindowMoved`/`WindowResized` Events werden dann vom Compositor kommen.

9.  **`WindowManager::focus_window()` Methode:**
    * `pub async fn focus_window(&self, window_id: u32) -> Result<(), WindowManagementError>`
    * **Logik:** Ruft `compositor_client.set_input_focus_to_window(window_id)` auf. Das `WindowFocused` Event wird dann vom Compositor kommen.

10. **`WindowManager::get_workspaces()` Methode:**
    * `pub async fn get_workspaces(&self) -> Vec<WorkspaceInfo>`
    * **Logik:** Gibt alle verwalteten Workspaces zurück.

11. **`WindowManager::switch_workspace()` Methode:**
    * `pub async fn switch_workspace(&self, workspace_id: u32) -> Result<(), WindowManagementError>`
    * **Logik:**
        * Überprüft, ob der Workspace existiert.
        * Aktualisiert `active_workspace_id`.
        * Informiert den Compositor (falls eine Compositor-Methode dafür existiert) oder delegiert an die UI zur Anzeigeänderung.
        * Verschiebt alle Fenster vom alten zum neuen Workspace im Compositor (z.B. über `compositor_client.move_window_to_workspace`, falls unterstützt).
        * Sendet `SystemEvent::WorkspaceSwitched(workspace_id)`.

12. **`WindowManager::move_window_to_workspace()` Methode:**
    * `pub async fn move_window_to_workspace(&self, window_id: u32, target_workspace_id: u32) -> Result<(), WindowManagementError>`
    * **Logik:**
        * Aktualisiert `window_id` in `windows` und `workspaces` Maps.
        * Informiert den Compositor über die Bewegung (falls eine Compositor-Methode dafür existiert).
        * Sendet `SystemEvent::WindowMovedToWorkspace(window_id, target_workspace_id)`.

13. **`WindowManager::add_workspace()` Methode:**
    * `pub async fn add_workspace(&self) -> Result<u32, WindowManagementError>`
    * **Logik:**
        * Erzeugt eine neue `workspace_id`.
        * Erstellt eine neue `WorkspaceInfo`.
        * Fügt den Workspace zur `workspaces` Map hinzu.
        * Sendet `SystemEvent::WorkspaceAdded(new_workspace_id)`.

14. **`WindowManager::remove_workspace()` Methode:**
    * `pub async fn remove_workspace(&self, workspace_id: u32) -> Result<(), WindowManagementError>`
    * **Logik:**
        * Überprüft, ob der Workspace existiert und nicht der letzte ist.
        * Verschiebt alle Fenster vom zu entfernenden Workspace auf einen anderen (z.B. den aktiven oder den nächsten).
        * Entfernt den Workspace aus der `workspaces` Map.
        * Sendet `SystemEvent::WorkspaceRemoved(workspace_id)`.

15. **`WindowManager::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: WindowConfig)`
    * **Logik:** Aktualisiert die interne `current_config`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/window_management_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::window_management_service::error::WindowManagementError`
    * `crate::window_management_service::data_types::{WindowInfo, WorkspaceInfo, MonitorInfo, WindowConfig}`
    * `crate::window_management_service::compositor_integration::{CompositorClient, CompositorEvent}`
    * `crate::config_service::ConfigService`
    * `crate::application_manager::ApplicationManagerService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
    * `novade_core::data_types::{Rectangle, Size2D, WindowState, Point2D}`
* **Extern:**
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `std::sync::atomic::{AtomicU32, Ordering}`
    * `std::collections::HashMap`
    * `tracing`

**Kommunikationsmuster:**

* Ist die zentrale Instanz, die den Zustand des Fenstersystems verwaltet.
* Empfängt und verarbeitet alle `CompositorEvent`s.
* Ruft Methoden auf dem `CompositorClient` auf, um Fensteraktionen auszuführen.
* Kommuniziert mit dem `ApplicationManagerService` zur Zuordnung von Fenstern zu Anwendungen.
* Sendet `SystemEvent`s an den `EventBus` bei allen relevanten Fenster- und Workspace-Änderungen.
* Interagiert mit dem `ConfigService` für Konfigurations-Updates.

**Erwartete Ergebnisse/Outputs:**
Ein umfassender und konsistenter Window Manager, der alle Fenster- und Workspace-Operationen handhabt und den Zustand des Desktops widerspiegelt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `ApplicationManagerService` und `CompositorClient`.
    * Testen der Initialisierung: Sicherstellen, dass initialer Zustand von Fenstern, Workspaces und Monitoren korrekt aus dem Mock-Compositor geladen wird.
    * Testen der `handle_compositor_event` Methode mit verschiedenen `CompositorEvent`s (Erstellen, Zerstören, Fokus, Bewegen, Größenändern, Zustandsänderungen, Monitor-Events) und Überprüfen, ob:
        * Der interne Zustand (`windows`, `workspaces`, `monitors`) korrekt aktualisiert wird.
        * Die richtigen `SystemEvent`s an den `EventBus` gesendet werden.
        * Der `ApplicationManagerService` korrekt über Fenster-App-Zuordnungen informiert wird.
    * Testen der API-Methoden (`close_window`, `minimize_window`, `switch_workspace` etc.) und Überprüfen, ob sie die korrekten Methoden auf dem Mock-`CompositorClient` aufrufen und die internen Zustände konsistent halten.
    * Testen der Workspace-Operationen (Hinzufügen, Entfernen, Verschieben von Fenstern).

**Geschätzter Aufwand:** Sehr hoch (ca. 12-18 Tage, da komplexes Zustandsmanagement, Event-Handling von verschiedenen Quellen und Orchestrierung mit anderen Systemdiensten)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `application_manager`, widmen wir uns `window_management_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/window_management_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/window_management_service/data_types.rs`**: Definition der grundlegenden Datentypen für Fenster, Workspaces und Monitore. **Wichtig: Stellen Sie sicher, dass `Rectangle`, `Size2D` und `WindowState` nach `novade_core::data_types` verschoben werden, falls noch nicht geschehen, um Duplikate zu vermeiden.**
3.  **`novade-system/src/window_management_service/compositor_integration.rs`**: Die Abstraktionsschicht für die Kommunikation mit dem Compositor. Dies ist die kritischste Abhängigkeit für den Manager. Die Implementierungen für Wayland (`wayland_client.rs`) und X11 (`x11_client.rs`) sollten hier als separate Dateien innerhalb des `compositor_integration` Moduls oder als Submodule in einem `compositor_clients` Verzeichnis liegen.
4.  **`novade-system/src/window_management_service/manager.rs`**: Die Kernlogik zur Verwaltung des Fenster- und Workspace-Zustands, die auf `compositor_integration` und den `data_types` aufbaut.
5.  **`novade-system/src/window_management_service/mod.rs`**: Das Hauptmodul, das den Manager und die Compositor-Integration initialisiert und die öffentliche API bereitstellt.
6.  **`novade-system/src/window_management_service/dbus_interface.rs`**: (Optional) Falls eine D-Bus-Schnittstelle für externe Window-Manager-Clients (z.B. für Kompatibilität mit bestehenden Tools) benötigt wird. Für MVP wahrscheinlich nicht erforderlich.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/window_management_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/input_service` Verzeichnisses, um Tastatur- und Mauseingaben zu verarbeiten.
---
### **novade-system/src/input_service/mod.rs**

**Verantwortlichkeit:**
Das `input_service` Modul ist die zentrale Komponente für die Verarbeitung aller Benutzereingaben (Tastatur, Maus, Touch, etc.) in NovaDE. Es abstrahiert die verschiedenen Eingabequellen (z.B. `libinput` für Wayland, XInput für X11) und stellt eine einheitliche Schnittstelle für andere Systemkomponenten bereit, um auf Eingabeereignisse zu reagieren. Es ist verantwortlich für die Weiterleitung von Ereignissen an den richtigen Empfänger (z.B. fokussiertes Fenster), die Verwaltung von Tastatur-Layouts und die Handhabung von globalen Tastenkombinationen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/input_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Eingabe-Operationen)
    * `manager.rs` (Logik für Eingabeverwaltung, Tastatur-Layouts, globalen Shortcuts)
    * `data_types.rs` (Definition von Eingabe-bezogenen Datentypen)
    * `event_handler.rs` (Abstraktionsschicht für Compositor-spezifische Eingabeereignisse)
    * `input_device_manager.rs` (Erkennung und Verwaltung von Eingabegeräten, z.B. über `libinput`)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Eingabe-Subsystems:**
    * `pub async fn initialize_input_service(config_service: Arc<ConfigService>, event_bus: EventBus, window_management_service: Arc<WindowManagementService>) -> Result<InputService, InputError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::InputManager`.
        * Initialisiert den `input_device_manager` (z.B. `libinput`-Kontext) zur Erkennung und Überwachung von Eingabegeräten.
        * Initialisiert den `event_handler`, der auf rohe Eingabeereignisse vom Compositor oder direkt von `libinput` hört.
        * Lädt initiale Eingabeeinstellungen aus dem `config_service` (z.B. Tastatur-Layouts, Mausgeschwindigkeit, globale Tastenkombinationen).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Startet einen Hintergrund-Task, der auf Eingabeereignisse vom `event_handler` hört und diese an den `InputManager` weiterleitet.
        * Gibt ein gebündeltes `InputService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers, des Geräte-Managers oder des Event-Handlers.

2.  **`InputService` Struct:**
    * `pub struct InputService {`
        * `manager: Arc<InputManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `window_management_service: Arc<WindowManagementService>,`
        * `input_device_manager: Arc<InputDeviceManager>,`
        * `event_handler: Arc<dyn InputEventHandler + Send + Sync>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Eingabelogik.

3.  **Bereitstellung von API-Methoden:**
    * Der `InputService` exponiert Methoden zur Abfrage und Steuerung von Eingabe-Einstellungen.
    * `pub async fn get_keyboard_layouts(&self) -> Result<Vec<String>, InputError>`
        * **Logik:** Delegiert an den `InputManager`, um eine Liste der verfügbaren Tastatur-Layouts zurückzugeben.
    * `pub async fn set_keyboard_layout(&self, layout: &str) -> Result<(), InputError>`
        * **Logik:** Delegiert an den `InputManager`, um das Tastatur-Layout zu ändern. Dies sollte das Compositor-Backend entsprechend konfigurieren. Sendet `SystemEvent::KeyboardLayoutChanged(layout)`.
    * `pub async fn get_active_keyboard_layout(&self) -> Result<String, InputError>`
        * **Logik:** Delegiert an den `InputManager`.
    * `pub async fn register_global_shortcut(&self, shortcut: &str, action: String) -> Result<(), InputError>`
        * **Logik:** Delegiert an den `InputManager`, um eine globale Tastenkombination zu registrieren. Die `action` ist ein String, der ein `SystemEvent` auslöst oder eine Methode aufruft.
    * `pub async fn unregister_global_shortcut(&self, shortcut: &str) -> Result<(), InputError>`
        * **Logik:** Delegiert an den `InputManager`.
    * `pub async fn get_connected_devices(&self) -> Result<Vec<InputDeviceInfo>, InputError>`
        * **Logik:** Delegiert an den `InputDeviceManager`.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `InputService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Eingabeeinstellungen geändert werden, werden die Sub-Komponenten (`InputManager`) informiert.

5.  **Hintergrund-Task zum Verarbeiten von Eingabeereignissen:**
    * Ein Task, der den Event-Stream vom `InputEventHandler` abonniert. Jedes empfangene Eingabeereignis wird vom `InputService` verarbeitet:
        * Der `InputManager` verarbeitet das Ereignis (z.B. Tastenkombinationen, Mausbewegungen).
        * Wenn es sich um eine globale Tastenkombination handelt, wird das entsprechende `SystemEvent` (oder ein interner Befehl) ausgelöst.
        * Wenn es sich um ein fensterspezifisches Ereignis handelt, wird es an das aktuell fokussierte Fenster weitergeleitet (über den Compositor oder eine interne Methode des `WindowManagementService`).
        * Relevante `SystemEvent`s werden an den `EventBus` gesendet (z.B. `GlobalShortcutTriggered`, `MouseButtonPressed`, `KeyboardKeyPressed`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input_service::error::InputError`
    * `crate::input_service::manager::InputManager`
    * `crate::input_service::data_types::{InputConfig, InputEvent, GlobalShortcut, InputDeviceInfo}`
    * `crate::input_service::event_handler::{InputEventHandler, InputEventSource}`
    * `crate::input_service::input_device_manager::InputDeviceManager`
    * `crate::config_service::ConfigService`
    * `crate::window_management_service::WindowManagementService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `futures::stream::StreamExt` (für Event-Stream-Verarbeitung)

**Kommunikationsmuster:**

* Ist der primäre Controller für die Verarbeitung und Weiterleitung von Benutzereingaben.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Eingabeeinstellungen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten und andere Systemdienste über Eingabeereignisse oder globale Aktionen zu informieren.
* Empfängt Roh-Eingabeereignisse vom `InputEventHandler`.
* Interagiert mit dem `WindowManagementService`, um Eingaben an Fenster weiterzuleiten oder den Fokus zu ändern.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Eingabe-Subsystem, das Benutzereingaben zuverlässig verarbeitet, globale Tastenkombinationen handhabt und Eingaben an die richtigen Empfänger weiterleitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `WindowManagementService`, `InputDeviceManager` und `InputEventHandler`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration.
    * Testen der Weiterleitung von API-Aufrufen an den `InputManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von `InputEvent`s (z.B. Tastenanschläge, Mausbewegungen) vom Mock-`InputEventHandler` und Überprüfen, ob:
        * Globale Tastenkombinationen korrekt erkannt und die entsprechenden `SystemEvent`s ausgelöst werden.
        * Fensterspezifische Ereignisse korrekt an den Mock-`WindowManagementService` weitergeleitet werden.
        * `SystemEvent`s für allgemeine Eingaben (z.B. `MouseButtonPressed`) gesendet werden.
* **Integration Tests (mit realer Eingabe-Infrastruktur oder dediziertem Test-Compositor):**
    * Starten des `InputService` in einer Testumgebung mit einem laufenden Compositor, der Eingabeereignisse bereitstellt (oder direkt `libinput` verwenden).
    * Simulieren von Tastatureingaben und Mausbewegungen (z.B. über `evdev` oder ein Test-Tool).
    * Überprüfen, ob globale Tastenkombinationen funktionieren (z.B. `Alt+F4` zum Schließen eines Fensters).
    * Überprüfen, ob Eingaben an fokussierte Fenster korrekt weitergeleitet werden.
    * Testen des Wechsels von Tastatur-Layouts.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da tiefe Integration mit System-Eingabe-APIs, Event-Verarbeitung und Management von Tastatur-Layouts und Shortcuts)

---
### **novade-system/src/input_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `input_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Eingabe-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`InputError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum InputError {`
        * `#[error("Failed to initialize input device manager: {0}")]`
        * `DeviceManagerInitFailed(String),`
        * `#[error("Failed to open input device: {0}")]`
        * `DeviceOpenFailed(String),`
        * `#[error("Invalid keyboard layout: {0}")]`
        * `InvalidKeyboardLayout(String),`
        * `#[error("Shortcut registration failed: {0}")]`
        * `ShortcutRegistrationFailed(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Window management service error: {0}")]`
        * `WindowManagementError(#[from] crate::window_management_service::error::WindowManagementError),`
        * `#[error("I/O error: {0}")]`
        * `IoError(#[from] std::io::Error),`
        * `#[error("Unknown input error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `crate::window_management_service::error::WindowManagementError`, `std::io::Error` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::io::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`
    * `crate::window_management_service::error::WindowManagementError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `input_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Eingabesystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/input_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `input_service` verwendet werden, um Eingabeereignisse, globale Tastenkombinationen, Geräteinformationen und Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`InputConfig` Struct (aus `config_service/data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct InputConfig {`
        * `pub keyboard_layouts: Vec<String>,`
        * `pub active_keyboard_layout: String,`
        * `pub mouse_speed: f32,`
        * `pub natural_scrolling: bool,`
        * `pub global_shortcuts: HashMap<String, String>,` // Shortcut String (z.B. "Ctrl+Alt+T") -> Action String (z.B. "launch_terminal")
        * `// ... weitere Einstellungen`
    * `}`

2.  **`InputEvent` Enum:**
    * `#[derive(Debug, Clone, PartialEq)]`
    * `pub enum InputEvent {`
        * `Keyboard { key_code: u32, state: InputState, modifiers: Modifiers },`
        * `MouseMotion { x: i32, y: i32, delta_x: f64, delta_y: f64 },`
        * `MouseButton { button: MouseButton, state: InputState, x: i32, y: i32, modifiers: Modifiers },`
        * `Scroll { delta_x: f64, delta_y: f64, scroll_axis: ScrollAxis },`
        * `Touch { id: i32, x: i32, y: i32, state: InputState },`
        * `DeviceAdded { info: InputDeviceInfo },`
        * `DeviceRemoved { id: String },`
    * `}`

3.  **`InputState` Enum (aus `novade_core::data_types`):**
    * `pub enum InputState { Pressed, Released }`

4.  **`MouseButton` Enum (aus `novade_core::data_types`):**
    * `pub enum MouseButton { Left, Right, Middle, Other(u32) }`

5.  **`ScrollAxis` Enum:**
    * `#[derive(Debug, Clone, PartialEq)]`
    * `pub enum ScrollAxis { Vertical, Horizontal }`

6.  **`Modifiers` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, Default)]`
    * `pub struct Modifiers {`
        * `pub shift: bool,`
        * `pub control: bool,`
        * `pub alt: bool,`
        * `pub super_key: bool,` // Windows/Meta key
        * `pub caps_lock: bool,`
        * `pub num_lock: bool,`
    * `}`

7.  **`GlobalShortcut` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct GlobalShortcut {`
        * `pub shortcut_string: String,` // z.B. "Ctrl+Alt+T"
        * `pub key_code: u32,`
        * `pub modifiers: Modifiers,`
        * `pub action: String,` // Name der auszuführenden Aktion, z.B. "launch_terminal", "screenshot"
    * `}`

8.  **`InputDeviceInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct InputDeviceInfo {`
        * `pub id: String,` // Eindeutige Geräte-ID
        * `pub name: String,`
        * `pub device_type: DeviceType,`
        * `pub vendor_id: u32,`
        * `pub product_id: u32,`
        * `pub is_active: bool,`
    * `}`

9.  **`DeviceType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum DeviceType { Keyboard, Pointer, Touch, Tablet, Other }`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/data_types.rs`

**Abhängigkeiten:**

* **Intern:**
    * `novade_core::data_types::{InputState, MouseButton}` (Import dieser gemeinsamen Typen)
* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::collections::HashMap`

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Eingabeinformationen und Konfigurationen im System.
* `InputEvent` wird vom `InputEventHandler` erzeugt und vom `InputManager` verarbeitet.
* `GlobalShortcut` wird vom `InputManager` registriert und verwendet.
* `InputDeviceInfo` wird vom `InputDeviceManager` erzeugt.
* `InputConfig` wird im `ConfigService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Eingabeverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.
    * Testen der `Modifiers` Struct Methoden (z.B. Kombination von Modifikatoren).

**Geschätzter Aufwand:** Mittel (ca. 1-2 Tage, da detaillierte Strukturen für verschiedene Eingabeereignisse und Geräteinformationen notwendig sind)

---
### **novade-system/src/input_service/event_handler.rs**

**Verantwortlichkeit:**
Dieses Modul ist die Abstraktionsschicht, die rohe Eingabeereignisse vom System empfängt und in das interne `InputEvent`-Format von NovaDE übersetzt. Es muss mit verschiedenen Backend-Technologien (z.B. Wayland Compositor oder `libinput` für DRM/KMS, XInput für X11) umgehen können.

**Kern-Aufgaben (Tasks):**

1.  **`InputEventHandler` Trait:**
    * `#[async_trait]`
    * `pub trait InputEventHandler: Send + Sync {`
        * `async fn new(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<Self, InputError> where Self: Sized;`
        * `fn event_stream(&self) -> Box<dyn Stream<Item = InputEvent> + Send + Unpin>;`
        * `async fn start_event_loop(&self) -> Result<(), InputError>;`
    * `}`

2.  **`InputEventSource` Enum (für die Instanziierung des korrekten Handlers):**
    * `pub enum InputEventSource {`
        * `WaylandCompositor,`
        * `X11Server,`
        * `LibinputDirect,`
    * `}`
    * Eine Factory-Funktion, die basierend auf `SessionType` den richtigen Handler instanziiert.

3.  **`WaylandInputHandler` Implementierung (im Idealfall in `wayland_input_handler.rs`):**
    * `pub struct WaylandInputHandler { ... }`
    * **Logik:**
        * Nutzt `wayland-client` oder `smithay-client-toolkit` um Eingabeereignisse vom Wayland Compositor zu empfangen (z.B. `wl_keyboard`, `wl_pointer`, `wl_touch` Protokolle).
        * Übersetzt diese Roh-Wayland-Events in `InputEvent`s.
        * Stellt den Event-Stream bereit.

4.  **`X11InputHandler` Implementierung (im Idealfall in `x11_input_handler.rs`):**
    * `pub struct X11InputHandler { ... }`
    * **Logik:**
        * Nutzt `x11rb` oder `xcb` zur Interaktion mit dem X11-Server und zum Empfang von X11-Eingabeereignissen.
        * Behandelt XKB (X Keyboard Extension) für Tastatur-Layouts und Modifikatoren.
        * Übersetzt diese Roh-X11-Events in `InputEvent`s.
        * Stellt den Event-Stream bereit.

5.  **`LibinputHandler` Implementierung (im Idealfall in `libinput_handler.rs`):**
    * `pub struct LibinputHandler { ... }`
    * **Logik:**
        * Nutzt die `libinput` Bibliothek (via FFI oder `libinput-rs` crate) um direkt mit `/dev/input` Geräten zu interagieren. Dies ist relevant für Compositors, die `libinput` nutzen, oder für DRM/KMS-basierte Setups.
        * Erfordert korrekte Berechtigungen (z.B. Mitgliedschaft in der `input` Gruppe).
        * Übersetzt `libinput` Events in `InputEvent`s.
        * Stellt den Event-Stream bereit.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/event_handler.rs`
* (Zukünftig: `novade-system/src/input_service/wayland_input_handler.rs`)
* (Zukünftig: `novade-system/src/input_service/x11_input_handler.rs`)
* (Zukünftig: `novade-system/src/input_service/libinput_handler.rs`)

**Abhängigkeiten:**

* **Intern:**
    * `crate::input_service::error::InputError`
    * `crate::input_service::data_types::{InputEvent, InputState, MouseButton, Modifiers, ScrollAxis}`
    * `novade_core::event_bus::EventBus`
    * `crate::config_service::ConfigService`
* **Extern:**
    * `async_trait` crate
    * `futures::stream::Stream`
    * `tokio::sync::mpsc`
    * `tracing`
    * `// Wayland-spezifische crates (wayland-client, smithay-client-toolkit etc.)`
    * `// X11-spezifische crates (x11rb)`
    * `// libinput-spezifische crates (libinput-rs)`
    * `xkbcommon` (für Tastatur-Layouts)

**Kommunikationsmuster:**

* Wird vom `InputService` instanziiert und verwendet.
* Sendet `InputEvent`s über den Event-Stream an den `InputService`.

**Erwartete Ergebnisse/Outputs:**
Eine flexible Abstraktionsschicht, die es NovaDE ermöglicht, Eingabeereignisse von verschiedenen Quellen zu empfangen und in einem einheitlichen Format zu verarbeiten.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking der Backend-Bibliotheken):**
    * Mocken der zugrunde liegenden Wayland/X11/Libinput-Bibliotheken, um simulierte Roh-Eingabeereignisse zu generieren.
    * Testen, ob die Handler diese Roh-Events korrekt in `InputEvent`s übersetzen.
    * Testen der korrekten Handhabung von Tastatur-Modifikatoren und -Layouts.
    * Überprüfen des Event-Streams auf korrekte Event-Generierung.
* **Integration Tests (mit realer Hardware/Compositor):**
    * Starten des jeweiligen Handlers in einer isolierten Testumgebung.
    * Physische Interaktion mit Tastatur und Maus.
    * Überprüfen, ob die generierten `InputEvent`s korrekt sind und die erwarteten Werte enthalten (z.B. korrekter KeyCode, Modifier-Zustand).

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage pro Handler-Implementierung, da tiefe Kenntnisse der jeweiligen Eingabe-Protokolle/APIs und präzise Event-Konvertierung erforderlich sind)

---
### **novade-system/src/input_service/input_device_manager.rs**

**Verantwortlichkeit:**
Der `input_device_manager` ist für die Erkennung, Überwachung und Konfiguration von Eingabegeräten (Tastaturen, Mäuse, Touchpads etc.) im System zuständig. Er verwendet typischerweise `libinput` unter Linux, um Geräteinformationen abzurufen und zu verwalten.

**Kern-Aufgaben (Tasks):**

1.  **`InputDeviceManager` Struct:**
    * `pub struct InputDeviceManager {`
        * `libinput_context: libinput::Context,` // libinput-Kontext
        * `event_sender: mpsc::Sender<InputEvent>,` // Sender für Geräte-Events
        * `config_service: Arc<ConfigService>,`
        * `// Optional: Map for device-specific configurations`
    * `}`

2.  **`InputDeviceManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>) -> Result<Self, InputError>`
    * **Logik:**
        * Initialisiert einen `libinput` Kontext. Unter Wayland wird dieser oft vom Compositor bereitgestellt oder es wird ein `udev`-basiertes Backend verwendet.
        * Sucht nach vorhandenen Eingabegeräten und fügt sie dem Kontext hinzu.
        * Ladet gerätespezifische Konfigurationen aus dem `config_service`.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `DeviceManagerInitFailed`.

3.  **`InputDeviceManager::start_device_monitoring()` Funktion:**
    * `pub fn start_device_monitoring(self: Arc<Self>) -> mpsc::Receiver<InputEvent>`
    * **Logik:**
        * Startet einen dedizierten Hintergrund-Task, der ständig neue `libinput` Events polled.
        * Bei `libinput::Event::DeviceAdded`:
            * Erstellt eine `InputDeviceInfo` und sendet `InputEvent::DeviceAdded`.
            * Wendet gerätespezifische Einstellungen an (z.B. Mausgeschwindigkeit, natural scrolling).
        * Bei `libinput::Event::DeviceRemoved`:
            * Sendet `InputEvent::DeviceRemoved`.
        * Andere Eingabe-Events (Keyboard, Pointer, Touch) werden an den `InputEventHandler` weitergeleitet oder hier in `InputEvent`s konvertiert und über den `event_sender` gesendet (Abhängig von der Architektur, ob der `InputEventHandler` oder der `InputDeviceManager` die Events liest). Wenn der `InputEventHandler` direkt mit dem Compositor interagiert, ist dieser `event_sender` eventuell nur für `DeviceAdded`/`Removed` gedacht. **Entscheidung: Der `InputDeviceManager` ist primär für die Geräteverwaltung, nicht für den kontinuierlichen Event-Stream. Die `InputEventHandler`s sind dafür zuständig.** Daher sendet dieser Manager nur `DeviceAdded`/`Removed` Events.
        * Gibt den `mpsc::Receiver` zurück.

4.  **`InputDeviceManager::get_connected_devices()` Methode:**
    * `pub async fn get_connected_devices(&self) -> Result<Vec<InputDeviceInfo>, InputError>`
    * **Logik:** Fragt den `libinput_context` nach aktuell verbundenen Geräten ab und konvertiert sie in `InputDeviceInfo`.

5.  **`InputDeviceManager::configure_device()` Methode:**
    * `pub async fn configure_device(&self, device_id: &str, settings: InputDeviceSettings) -> Result<(), InputError>`
    * **Logik:** Sucht das Gerät im `libinput_context` und wendet spezifische Einstellungen an (z.B. Mausgeschwindigkeit, Tap-to-Click für Touchpads).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/input_device_manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input_service::error::InputError`
    * `crate::input_service::data_types::{InputDeviceInfo, DeviceType, InputEvent}`
    * `crate::config_service::ConfigService`
* **Extern:**
    * `libinput` crate (oder `libinput-rs` Rust-Binding)
    * `tokio::task`
    * `tokio::sync::mpsc`
    * `std::sync::Arc`
    * `tracing`

**Kommunikationsmuster:**

* Wird vom `InputService` instanziiert und verwendet.
* Sendet `InputEvent::DeviceAdded`/`DeviceRemoved` Events an den `InputService`.
* Interagiert mit dem `ConfigService` für gerätespezifische Konfigurationen.

**Erwartete Ergebnisse/Outputs:**
Ein zuverlässiger Manager für Eingabegeräte, der das System über neue oder entfernte Geräte informiert und deren Konfiguration erlaubt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking von `libinput`):**
    * Mocken des `libinput::Context` und seiner Methoden.
    * Testen der `new` Funktion.
    * Simulieren von `libinput::Event::DeviceAdded` und `libinput::Event::DeviceRemoved` und Überprüfen, ob die korrekten `InputEvent`s über den `event_sender` gesendet werden.
    * Testen von `get_connected_devices`.
    * Testen von `configure_device` und Überprüfen, ob die Konfigurations-Methoden des Mock-`libinput` aufgerufen werden.
* **Integration Tests (mit realer Hardware):**
    * Starten des `InputDeviceManager` auf einem Linux-System.
    * Anschließen und Trennen von USB-Mäusen, Tastaturen etc.
    * Überprüfen, ob die `DeviceAdded`/`DeviceRemoved` Events korrekt registriert werden.
    * Testen der Konfiguration von realen Geräten (z.B. Mausgeschwindigkeit ändern) und Überprüfen der Auswirkungen.

**Geschätzter Aufwand:** Mittel (ca. 4-6 Tage, da `libinput`-Integration und Geräte-Management)

---
### **novade-system/src/input_service/manager.rs**

**Verantwortlichkeit:**
Der `InputManager` ist die Kernlogik des Eingabe-Subsystems. Er verarbeitet die abstrakten `InputEvent`s, die vom `InputEventHandler` kommen, erkennt globale Tastenkombinationen, verwaltet den Zustand der Tastatur (Modifikatoren, Tastenanschläge) und leitet relevante Events an den `WindowManagementService` weiter.

**Kern-Aufgaben (Tasks):**

1.  **`InputManager` Struct:**
    * `pub struct InputManager {`
        * `event_bus: EventBus,`
        * `config_service: Arc<ConfigService>,`
        * `window_management_service: Arc<WindowManagementService>,`
        * `current_config: RwLock<InputConfig>,`
        * `active_modifiers: RwLock<Modifiers>,`
        * `pressed_keys: RwLock<HashSet<u32>>,` // Set of currently pressed key codes
        * `global_shortcuts: RwLock<HashMap<String, GlobalShortcut>>,` // Shortcut String -> GlobalShortcut
        * `// Optional: Keybinding map for faster lookup`
    * `}`

2.  **`InputManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus, window_management_service: Arc<WindowManagementService>) -> Result<Self, InputError>`
    * **Logik:**
        * Initialisiert alle Felder.
        * Lädt die initiale `InputConfig` aus dem `config_service`.
        * Registriert die initialen `global_shortcuts` in der internen Map.
        * Gibt `Self` zurück.

3.  **`InputManager::handle_input_event()` Methode:**
    * `pub async fn handle_input_event(&self, event: InputEvent) -> Result<(), InputError>`
    * **Logik:** Verarbeitet eingehende `InputEvent`s:
        * **`Keyboard`**:
            * Aktualisiert `active_modifiers` und `pressed_keys` basierend auf `state`.
            * **Erkennung globaler Tastenkombinationen:** Iteriert über `global_shortcuts`. Für jeden `Pressed`-Event, prüft, ob die aktuellen `pressed_keys` und `active_modifiers` eine registrierte Tastenkombination erfüllen.
                * Bei Treffer: Führt die zugehörige `action` aus (z.B. durch Aufruf einer internen Methode oder Senden eines spezifischen `SystemEvent`s). Beispiel: `launch_terminal` ruft `application_manager.launch_application()` auf.
                * Sendet `SystemEvent::GlobalShortcutTriggered(action_name, shortcut_string)`.
            * Sendet `SystemEvent::KeyboardKeyPressed` oder `KeyboardKeyReleased`.
            * Weiterleitung des Events an das fokussierte Fenster (über `window_management_service.send_keyboard_event_to_window()`, falls diese Methode dort existiert, oder indirekt über den Compositor).
        * **`MouseMotion`**:
            * Sendet `SystemEvent::MouseMoved`.
            * Weiterleitung an den Compositor für Cursor-Bewegung.
        * **`MouseButton`**:
            * Sendet `SystemEvent::MouseButtonPressed` oder `MouseButtonReleased`.
            * Weiterleitung an das fokussierte Fenster oder Compositor für Klick-Events.
        * **`Scroll`**:
            * Sendet `SystemEvent::MouseScrolled`.
            * Weiterleitung an das fokussierte Fenster oder Compositor.
        * **`Touch`**:
            * Sendet `SystemEvent::TouchBegan`, `TouchMoved`, `TouchEnded`.
            * Weiterleitung an den Compositor.
        * **`DeviceAdded` / `DeviceRemoved`**:
            * Sendet `SystemEvent::InputDeviceAdded` oder `InputDeviceRemoved`.
            * Kann interne Caches für Geräteinformationen aktualisieren (obwohl der `InputDeviceManager` dafür primär zuständig ist).

4.  **`InputManager::get_keyboard_layouts()` Methode:**
    * `pub async fn get_keyboard_layouts(&self) -> Vec<String>`
    * **Logik:** Gibt die verfügbaren Layouts zurück (könnten aus `xkbcommon` oder einer Konfigurationsdatei stammen).

5.  **`InputManager::set_keyboard_layout()` Methode:**
    * `pub async fn set_keyboard_layout(&self, layout: &str) -> Result<(), InputError>`
    * **Logik:**
        * Aktualisiert `current_config.active_keyboard_layout`.
        * Informiert den Compositor (über `window_management_service.set_keyboard_layout()`, falls diese Methode dort existiert, oder direkt über `event_handler`).
        * Sendet `SystemEvent::KeyboardLayoutChanged(layout)`.

6.  **`InputManager::get_active_keyboard_layout()` Methode:**
    * `pub async fn get_active_keyboard_layout(&self) -> String`
    * **Logik:** Gibt den aktuellen aktiven Layout-Namen zurück.

7.  **`InputManager::register_global_shortcut()` Methode:**
    * `pub async fn register_global_shortcut(&self, shortcut_string: &str, action: String) -> Result<(), InputError>`
    * **Logik:**
        * Parst `shortcut_string` in `key_code` und `modifiers`.
        * Erstellt ein `GlobalShortcut`-Objekt.
        * Fügt es zur `global_shortcuts` Map hinzu.
        * Kann auch eine Registrierung beim Compositor/X-Server auslösen (`grab_key`), um globale Events abzufangen.

8.  **`InputManager::unregister_global_shortcut()` Methode:**
    * `pub async fn unregister_global_shortcut(&self, shortcut_string: &str) -> Result<(), InputError>`
    * **Logik:** Entfernt den Shortcut aus der Map und löst eine De-Registrierung beim Compositor/X-Server aus.

9.  **`InputManager::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: InputConfig)`
    * **Logik:** Aktualisiert die interne `current_config` und re-registriert globale Shortcuts, falls diese sich geändert haben.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/input_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::input_service::error::InputError`
    * `crate::input_service::data_types::{InputConfig, InputEvent, GlobalShortcut, Modifiers, InputState, MouseButton}`
    * `crate::config_service::ConfigService`
    * `crate::window_management_service::WindowManagementService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `std::collections::{HashMap, HashSet}`
    * `tracing`
    * `// Optional: xkbcommon-rs`

**Kommunikationsmuster:**

* Ist die zentrale Logik für die Verarbeitung von Eingabeereignissen.
* Empfängt `InputEvent`s vom `InputService` (der sie vom `InputEventHandler` bekommt).
* Ruft Methoden auf dem `WindowManagementService` auf, um Events an Fenster weiterzuleiten oder den Fokus zu ändern.
* Sendet `SystemEvent`s an den `EventBus` bei allen relevanten Eingabe- und Shortcut-Aktionen.
* Interagiert mit dem `ConfigService` für Konfigurations-Updates.

**Erwartete Ergebnisse/Outputs:**
Ein reaktionsschneller und intelligenter Input Manager, der Benutzereingaben interpretiert, globale Aktionen auslöst und Eingaben an die richtigen Systemkomponenten weiterleitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus` und `WindowManagementService`.
    * Testen von `new`: Sicherstellen, dass initiale Konfiguration und Shortcuts geladen werden.
    * Testen von `handle_input_event` mit verschiedenen `InputEvent`s:
        * **Keyboard Events:** Überprüfen der korrekten Aktualisierung von `active_modifiers` und `pressed_keys`. Simulieren von Tastenanschlägen, die eine globale Tastenkombination auslösen, und Überprüfen, ob die entsprechende `action` ausgeführt (oder das `SystemEvent` gesendet) wird. Testen von Edge Cases (z.B. mehrere Modifikatoren, schnelle Tastendrücke).
        * **Mouse Events:** Überprüfen, ob die korrekten `SystemEvent`s gesendet werden.
        * Testen der Weiterleitung von Events an den Mock-`WindowManagementService`.
    * Testen von `register_global_shortcut` und `unregister_global_shortcut`.
    * Testen von `set_keyboard_layout` und `get_active_keyboard_layout`.
* **Integration Tests:**
    * Starten des `InputManager` mit echten oder simulierten Abhängigkeiten, die reale `InputEvent`s erzeugen.
    * Testen realer globaler Tastenkombinationen (z.B. `Win+L` zum Sperren des Bildschirms, `PrintScreen` für Screenshots).
    * Überprüfen der korrekten Tastatur-Layout-Umschaltung.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da komplexe Event-Verarbeitung, Zustandsmanagement für Tastatur und Erkennung von Tastenkombinationen)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `window_management_service`, widmen wir uns `input_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/input_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/input_service/data_types.rs`**: Definition der grundlegenden Datentypen für Eingabeereignisse, globale Shortcuts und Geräte. **Wichtig: Stellen Sie sicher, dass `InputState` und `MouseButton` nach `novade_core::data_types` verschoben werden, falls noch nicht geschehen, um Duplikate zu vermeiden.**
3.  **`novade-system/src/input_service/event_handler.rs`**: Die Abstraktionsschicht, die Roh-Eingabeereignisse vom System empfängt. Die spezifischen Implementierungen (`wayland_input_handler.rs`, `x11_input_handler.rs`, `libinput_handler.rs`) sollten hier als separate Dateien innerhalb des `event_handler` Moduls oder als Submodule in einem `input_handlers` Verzeichnis liegen.
4.  **`novade-system/src/input_service/input_device_manager.rs`**: Verantwortlich für die Erkennung und Verwaltung von Eingabegeräten (z.B. über `libinput`). Dies muss vor dem Manager implementiert werden, um Geräteinformationen bereitzustellen.
5.  **`novade-system/src/input_service/manager.rs`**: Die Kernlogik zur Verarbeitung von Eingabeereignissen und Erkennung globaler Tastenkombinationen. Baut auf `event_handler` und `input_device_manager` auf.
6.  **`novade-system/src/input_service/mod.rs`**: Das Hauptmodul, das den Manager, den Event-Handler und den Geräte-Manager initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/input_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/settings_manager` Verzeichnisses, um die Systemkonfiguration zu verwalten.
---
### **novade-system/src/settings_manager/mod.rs**

**Verantwortlichkeit:**
Das `settings_manager` Modul ist für die Verwaltung von NovaDE-Systemeinstellungen zuständig. Es bietet eine konsistente API zum Lesen, Schreiben und Überwachen von Konfigurationsänderungen. Es agiert als Abstraktionsschicht über dem eigentlichen persistenten Speichermechanismus (`config_service`) und kann zusätzliche Logik für Validierung, Standardwerte und Migrationen enthalten. Es ist der zentrale Punkt für UI-Komponenten und andere Systemdienste, um auf Konfigurationen zuzugreifen und diese zu ändern.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/settings_manager/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Einstellungs-Operationen)
    * `manager.rs` (Logik für Einstellungsverwaltung, Validierung, Benachrichtigungen)
    * `data_types.rs` (Definition von Einstellungs-bezogenen Datentypen und Strukturen)
    * `schema.rs` (Definition des Konfigurationsschemas, z.B. JSON Schema oder Typed Structs)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Einstellungs-Subsystems:**
    * `pub async fn initialize_settings_manager(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<SettingsManagerService, SettingsError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::SettingsManager`.
        * Lädt die initiale Konfiguration über den `config_service`.
        * Validiert die geladenen Einstellungen gegen das `schema.rs`.
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen vom `ConfigService` zu laden und zu verarbeiten.
        * Gibt ein gebündeltes `SettingsManagerService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers, beim Laden der Konfiguration oder bei der Validierung.

2.  **`SettingsManagerService` Struct:**
    * `pub struct SettingsManagerService {`
        * `manager: Arc<SettingsManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
    * `}`
    * Dient als Container und Zugangspunkt für die Einstellungslogik.

3.  **Bereitstellung von API-Methoden:**
    * Der `SettingsManagerService` exponiert Methoden zum Abrufen und Ändern von Einstellungen.
    * `pub async fn get_setting<T: DeserializeOwned + 'static>(&self, key: &str) -> Result<T, SettingsError>`
        * **Logik:** Delegiert an den `SettingsManager`, um einen Wert für den gegebenen Schlüssel zu lesen. Verwendet `serde` für die Typkonvertierung.
    * `pub async fn set_setting<T: Serialize + 'static>(&self, key: &str, value: T) -> Result<(), SettingsError>`
        * **Logik:** Delegiert an den `SettingsManager`, um einen Wert für den gegebenen Schlüssel zu setzen. Validiert den Wert gegebenenfalls gegen das Schema. Speichert die Änderung über den `config_service`. Sendet `SystemEvent::ConfigChanged` mit dem spezifischen Schlüssel.
    * `pub async fn get_all_settings(&self) -> Result<AllSettings, SettingsError>`
        * **Logik:** Gibt das gesamte Konfigurationsobjekt zurück.
    * `pub async fn reset_setting(&self, key: &str) -> Result<(), SettingsError>`
        * **Logik:** Setzt eine spezifische Einstellung auf ihren Standardwert zurück. Speichert über den `config_service`. Sendet `SystemEvent::ConfigChanged`.
    * `pub async fn reset_all_settings_to_default(&self) -> Result<(), SettingsError>`
        * **Logik:** Setzt alle Einstellungen auf die Standardwerte zurück. Speichert über den `config_service`. Sendet `SystemEvent::ConfigChanged`.
    * `pub fn subscribe_to_setting_changes<T: DeserializeOwned + 'static>(&self, key: &str) -> EventReceiver<T>`
        * **Logik:** Bietet eine Möglichkeit, spezifische Änderungen an Einstellungen zu abonnieren. Nutzt den `EventBus`, um nur relevante `ConfigChanged` Events zu filtern und zu deserialisieren.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `SettingsManagerService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn der `ConfigService` eine Änderung meldet, wird der `SettingsManager` intern aktualisiert.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/settings_manager/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::settings_manager::error::SettingsError`
    * `crate::settings_manager::manager::SettingsManager`
    * `crate::settings_manager::data_types::AllSettings` (Haupt-Konfigurations-Struct)
    * `crate::settings_manager::schema::ConfigSchema` (falls separates Schema-Modul)
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `serde::{Serialize, Deserialize, de::DeserializeOwned}`

**Kommunikationsmuster:**

* Ist die primäre Schnittstelle für alle Systemkomponenten und UI-Elemente, die Einstellungen lesen oder schreiben müssen.
* Nutzt den `ConfigService` für den persistenten Speicher.
* Sendet `SystemEvent::ConfigChanged` an den `EventBus`, um andere Komponenten über Änderungen zu informieren.
* Empfängt `SystemEvent::ConfigChanged` vom `ConfigService` bei externen Änderungen an der Konfigurationsdatei.

**Erwartete Ergebnisse/Outputs:**
Ein robustes Einstellungs-Subsystem, das eine typsichere und konsistente Verwaltung aller NovaDE-Konfigurationen ermöglicht.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService` und `EventBus`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und der Validierung.
    * Testen von `get_setting` mit vorhandenen und nicht vorhandenen Schlüsseln.
    * Testen von `set_setting` mit gültigen und ungültigen Werten (basierend auf Mock-Schema). Überprüfen, ob `ConfigService::save_config` aufgerufen und `SystemEvent::ConfigChanged` gesendet wird.
    * Testen von `reset_setting` und `reset_all_settings_to_default`.
    * Simulieren von `SystemEvent::ConfigChanged` (vom Mock-`ConfigService`) und Überprüfen, ob der interne Zustand des `SettingsManager` korrekt aktualisiert wird.
    * Testen von `subscribe_to_setting_changes` und Überprüfen, ob Abonnenten korrekte Events erhalten.
* **Integration Tests:**
    * Starten des `SettingsManagerService` mit einem echten `ConfigService` (der auf einer temporären Datei basiert).
    * Speichern und Laden von Einstellungen und Überprüfen, ob die Änderungen persistent sind und korrekt von anderen Komponenten erkannt werden.
    * Testen des Verhaltens bei ungültigen Konfigurationsdateien (falls zutreffend).

**Geschätzter Aufwand:** Mittel (ca. 5-7 Tage, da Schema-Validierung, typisierte Zugriffe und Event-Handling)

---
### **novade-system/src/settings_manager/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `settings_manager` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Einstellungs-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`SettingsError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum SettingsError {`
        * `#[error("Setting with key '{0}' not found.")]`
        * `SettingNotFound(String),`
        * `#[error("Failed to parse setting '{0}': {1}")]`
        * `ParsingError(String, String),`
        * `#[error("Invalid setting value for key '{0}': {1}")]`
        * `ValidationError(String, String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Serialization error: {0}")]`
        * `SerializationError(#[from] serde_json::Error),`
        * `#[error("I/O error: {0}")]`
        * `IoError(#[from] std::io::Error),`
        * `#[error("Unknown settings error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `serde_json::Error`, `std::io::Error` und `anyhow::Error`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/settings_manager/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `serde_json::Error`
    * `std::io::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `settings_manager` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Einstellungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/settings_manager/data_types.rs**

**Verantwortlichkeit:**
Definiert die hierarchische Struktur und die einzelnen Datentypen aller konfigurierbaren NovaDE-Einstellungen. Diese Typen sind direkt deserialisierbar von der Konfigurationsdatei und serialisierbar für den Speicher.

**Kern-Aufgaben (Tasks):**

1.  **`AllSettings` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct AllSettings {`
        * `pub general: GeneralConfig,`
        * `pub display: DisplayConfig,`
        * `pub appearance: AppearanceConfig,`
        * `pub keyboard: KeyboardConfig,`
        * `pub mouse: MouseConfig,`
        * `pub sound: SoundConfig,`
        * `pub network: NetworkConfig,`
        * `pub power: PowerConfig,`
        * `pub application: ApplicationConfig,` // Import from `application_manager::data_types`
        * `pub window_management: WindowConfig,` // Import from `window_management_service::data_types`
        * `pub input: InputConfig,` // Import from `input_service::data_types`
        * `// ... weitere Top-Level-Kategorien`
    * `}`
    * Implementiere die `Default` Trait, um Standardwerte für alle Einstellungen zu definieren.

2.  **`GeneralConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct GeneralConfig {`
        * `pub language: String,` // z.B. "en_US", "de_DE"
        * `pub timezone: String,`
        * `pub run_on_startup_services: Vec<String>,`
        * `pub enable_animations: bool,`
        * `// ...`
    * `}`
    * Implementiere `Default`.

3.  **`DisplayConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct DisplayConfig {`
        * `pub primary_monitor_id: Option<u32>,`
        * `pub scale_factor: f32,`
        * `pub refresh_rate: u32,`
        * `pub resolution: Option<Size2D>,` // Use `novade_core::data_types::Size2D`
        * `pub night_light_enabled: bool,`
        * `pub night_light_temperature: u32,`
        * `// ...`
    * `}`
    * Implementiere `Default`.

4.  **`AppearanceConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct AppearanceConfig {`
        * `pub theme_name: String,`
        * `pub icon_theme_name: String,`
        * `pub font_family: String,`
        * `pub font_size: u32,`
        * `pub accent_color: String,` // Hex code, e.g., "#0078D7"
        * `pub desktop_background_image: Option<PathBuf>,`
        * `pub enable_blur: bool,`
        * `// ...`
    * `}`
    * Implementiere `Default`.

5.  **`KeyboardConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct KeyboardConfig {`
        * `pub active_layout: String,` // z.B. "de", "us"
        * `pub available_layouts: Vec<String>,`
        * `pub repeat_delay_ms: u32,`
        * `pub repeat_rate_chars_per_sec: u32,`
        * `pub global_shortcuts: HashMap<String, String>,` // Shortcut String -> Action String
        * `// ...`
    * `}`
    * Implementiere `Default`.

6.  **`MouseConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct MouseConfig {`
        * `pub cursor_theme: String,`
        * `pub cursor_size: u32,`
        * `pub pointer_speed: f32,`
        * `pub natural_scrolling: bool,`
        * `pub click_method: ClickMethod,`
        * `// ...`
    * `}`
    * Implementiere `Default`.

7.  **`ClickMethod` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum ClickMethod { SingleClick, DoubleClick }`

8.  **`SoundConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct SoundConfig {`
        * `pub master_volume: u8,` // 0-100
        * `pub system_sounds_enabled: bool,`
        * `pub input_device: Option<String>,`
        * `pub output_device: Option<String>,`
        * `// ...`
    * `}`
    * Implementiere `Default`.

9.  **`NetworkConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct NetworkConfig {`
        * `pub wired_enabled: bool,`
        * `pub wireless_enabled: bool,`
        * `pub wifi_networks: Vec<WifiNetworkConfig>,`
        * `pub proxy_settings: ProxySettings,`
        * `// ...`
    * `}`
    * Implementiere `Default`.

10. **`WifiNetworkConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct WifiNetworkConfig {`
        * `pub ssid: String,`
        * `pub auto_connect: bool,`
        * `pub password: Option<String>,` // Verschlüsselt im Speicher!
        * `// ...`
    * `}`
    * Implementiere `Default`.

11. **`ProxySettings` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct ProxySettings {`
        * `pub enabled: bool,`
        * `pub proxy_type: ProxyType,`
        * `pub host: Option<String>,`
        * `pub port: Option<u16>,`
        * `// ...`
    * `}`
    * Implementiere `Default`.

12. **`ProxyType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum ProxyType { None, Http, Https, Socks }`

13. **`PowerConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct PowerConfig {`
        * `pub screen_blank_delay_min: u32,`
        * `pub suspend_delay_min: u32,`
        * `pub lid_action_on_battery: LidAction,`
        * `pub lid_action_on_ac: LidAction,`
        * `// ...`
    * `}`
    * Implementiere `Default`.

14. **`LidAction` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum LidAction { DoNothing, Suspend, Hibernate, Shutdown }`

15. **Importierte Konfigurations-Structs:**
    * `pub use crate::application_manager::data_types::ApplicationConfig;`
    * `pub use crate::window_management_service::data_types::WindowConfig;`
    * `pub use crate::input_service::data_types::InputConfig;`
    * (Stellen Sie sicher, dass diese Structs in ihren jeweiligen Modulen als `pub` deklariert sind.)

**Spezifische Artefakte/Dateien:**

* `novade-system/src/settings_manager/data_types.rs`

**Abhängigkeiten:**

* **Intern:**
    * `novade_core::data_types::Size2D`
    * `crate::application_manager::data_types::ApplicationConfig`
    * `crate::window_management_service::data_types::WindowConfig`
    * `crate::input_service::data_types::InputConfig`
* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::collections::HashMap`
    * `std::path::PathBuf`

**Kommunikationsmuster:**

* Diese Typen definieren die Struktur der gesamten NovaDE-Konfiguration, die im `ConfigService` gespeichert und vom `SettingsManager` verwaltet wird.

**Erwartete Ergebnisse/Outputs:**
Eine umfassende und gut strukturierte Sammlung von Datentypen, die alle konfigurierbaren Aspekte des NovaDE-Systems abbilden.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.
    * Testen der `Default` Implementierungen, um sicherzustellen, dass alle Felder sinnvolle Standardwerte erhalten.
    * Stichprobenartige Tests für tiefer verschachtelte Strukturen.

**Geschätzter Aufwand:** Hoch (ca. 4-6 Tage, da viele Structs und Enums mit Standardwerten und korrekter Serde-Implementierung)

---
### **novade-system/src/settings_manager/schema.rs**

**Verantwortlichkeit:**
Das `schema` Modul definiert die Validierungsregeln und Metadaten für die NovaDE-Systemeinstellungen. Es kann verwendet werden, um die Gültigkeit von Konfigurationswerten zu überprüfen und UI-Komponenten bei der Generierung von Einstellungsdialogen zu unterstützen. Die Validierung sollte beim Laden und Schreiben von Einstellungen erfolgen.

**Kern-Aufgaben (Tasks):**

1.  **Schema-Definition (Option 1: Rust-Typed Schema):**
    * Definieren Sie eine `ConfigSchema` Struktur oder Trait, das Validierungslogik für die `AllSettings` und ihre Unter-Structs enthält.
    * `pub trait ValidateSettings {`
        * `fn validate(&self) -> Result<(), SettingsError>;`
    * `}`
    * Implementieren Sie `ValidateSettings` für `AllSettings` und jede Konfigurations-Struktur (`GeneralConfig`, `DisplayConfig` etc.). Die Implementierung würde einfache Bereichsprüfungen (z.B. Lautstärke 0-100), Formatprüfungen (z.B. Hex-Farbcodes), oder logische Abhängigkeiten umfassen.

2.  **Schema-Definition (Option 2: JSON Schema (External oder Embedded)):**
    * Wenn JSON Schema verwendet wird, könnte dieses Modul Funktionen zum Laden und Parsen des Schemas bereitstellen.
    * `pub fn load_schema() -> Result<serde_json::Value, SettingsError>` (lädt Schema aus Datei oder String).
    * `pub fn validate_settings(settings: &AllSettings, schema: &serde_json::Value) -> Result<(), SettingsError>` (validiert ein `AllSettings` Objekt gegen das Schema).
    * Dies erfordert eine externe JSON-Schema-Validierungsbibliothek (z.B. `jsonschema`).

3.  **Metadaten für UI (Optional, aber empfohlen):**
    * Zusätzlich zur Validierung kann das Schema Metadaten für UI-Generierung bereitstellen (z.B. Anzeigenamen, Beschreibungen, Wertbereiche, Typen für Eingabefelder).
    * Dies könnte als Teil der `AllSettings` Datentypen durch Attribute geschehen (z.B. `#[setting(name = "Language", description = "System UI language")]`) oder in einer separaten Struktur definiert werden.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/settings_manager/schema.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::settings_manager::error::SettingsError`
    * `crate::settings_manager::data_types::AllSettings` (und ihre Unter-Structs)
* **Extern:**
    * `serde_json` (wenn JSON Schema verwendet wird)
    * `jsonschema` crate (wenn JSON Schema validiert wird)
    * `regex` crate (für Regex-basierte Validierung)

**Kommunikationsmuster:**

* Wird vom `SettingsManager` verwendet, um Konfigurationsdaten zu validieren.
* Kann von UI-Komponenten verwendet werden, um dynamische Einstellungsdialoge zu erstellen.

**Erwartete Ergebnisse/Outputs:**
Ein Mechanismus zur Validierung der Systemkonfiguration, der die Datenintegrität gewährleistet. Optional: Eine Quelle für UI-Metadaten.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der `validate` Methode für jede Konfigurations-Struktur mit gültigen und ungültigen Werten.
    * Überprüfen, ob die richtigen `ValidationError`s für ungültige Eingaben erzeugt werden.
    * Wenn JSON Schema verwendet wird, Testen des Ladens und der Validierung des Schemas.

**Geschätzter Aufwand:** Mittel (ca. 3-5 Tage, abhängig von der Komplexität des Schemas und der Wahl zwischen Rust-Typed und JSON Schema)

---
### **novade-system/src/settings_manager/manager.rs**

**Verantwortlichkeit:**
Der `SettingsManager` ist die Kernlogik für die Verwaltung der NovaDE-Systemeinstellungen. Er hält den aktuellen Zustand der Konfiguration, führt Validierungen durch und benachrichtigt andere Systemkomponenten über Änderungen.

**Kern-Aufgaben (Tasks):**

1.  **`SettingsManager` Struct:**
    * `pub struct SettingsManager {`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `current_settings: RwLock<AllSettings>,`
        * `// Optional: Sender/Receiver für interne Updates, falls nötig`
    * `}`

2.  **`SettingsManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<Self, SettingsError>`
    * **Logik:**
        * Initialisiert `config_service` und `event_bus`.
        * Ruft `config_service.load_config()` auf, um die `AllSettings` zu laden.
        * Wenn keine Konfiguration gefunden wird oder ein Fehler auftritt, initialisiert mit `AllSettings::default()`.
        * Validiert die geladenen oder Standard-Einstellungen mit dem `schema` Modul.
        * Speichert die (potenziell neuen Default-) Einstellungen über `config_service.save_config()`.
        * Gibt `Self` zurück.

3.  **`SettingsManager::get_setting()` Methode:**
    * `pub async fn get_setting<T: DeserializeOwned + 'static>(&self, key: &str) -> Result<T, SettingsError>`
    * **Logik:**
        * Verwendet `serde_json::to_value` um den `AllSettings` Struct in ein `serde_json::Value` zu konvertieren.
        * Nutzt `serde_json::from_value` und eine Pfad-basierte Abfrage (z.B. "general.language") um den gewünschten Wert zu extrahieren und in Typ `T` zu deserialisieren.
        * Gibt `SettingNotFound` oder `ParsingError` zurück, wenn der Schlüssel nicht gefunden oder die Deserialisierung fehlschlägt.

4.  **`SettingsManager::set_setting()` Methode:**
    * `pub async fn set_setting<T: Serialize + 'static>(&self, key: &str, value: T) -> Result<(), SettingsError>`
    * **Logik:**
        * Validiert die `value` gegen das entsprechende Schema (wenn das Schema Metadaten für einzelne Pfade bietet).
        * Aktualisiert den `current_settings` RwLock. Dies kann das Klonen und Neuanlegen des `AllSettings` Structs oder eine mutable Referenz mittels `RwLock::write()` erfordern.
        * Speichert die gesamte aktualisierte Konfiguration über `config_service.save_config(&new_settings)`.
        * Sendet `SystemEvent::ConfigChanged(key.to_string())` an den `EventBus`.

5.  **`SettingsManager::get_all_settings()` Methode:**
    * `pub async fn get_all_settings(&self) -> AllSettings`
    * **Logik:** Gibt eine Kopie der `current_settings` zurück.

6.  **`SettingsManager::reset_setting()` Methode:**
    * `pub async fn reset_setting(&self, key: &str) -> Result<(), SettingsError>`
    * **Logik:**
        * Läd die Standardwerte (`AllSettings::default()`).
        * Extrahiert den Standardwert für den gegebenen `key`.
        * Ruft `set_setting` mit diesem Standardwert auf.

7.  **`SettingsManager::reset_all_settings_to_default()` Methode:**
    * `pub async fn reset_all_settings_to_default(&self) -> Result<(), SettingsError>`
    * **Logik:**
        * Setzt `current_settings` auf `AllSettings::default()`.
        * Speichert diese über `config_service.save_config()`.
        * Sendet `SystemEvent::ConfigChanged("all".to_string())` oder ein spezifischeres Event.

8.  **`SettingsManager::handle_config_changed_event()` Methode (intern, wird vom `SettingsManagerService` aufgerufen):**
    * `pub async fn handle_config_changed_event(&self, event_key: String)`
    * **Logik:**
        * Wenn `event_key` "all" ist oder sich auf eine Top-Level-Kategorie bezieht, lädt die gesamte Konfiguration neu von `config_service`.
        * Validiert die neu geladenen Einstellungen.
        * Aktualisiert `current_settings`.
        * Dies ist wichtig, um externe Änderungen an der Konfigurationsdatei zu reflektieren.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/settings_manager/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::settings_manager::error::SettingsError`
    * `crate::settings_manager::data_types::AllSettings` (und ihre Unter-Structs)
    * `crate::settings_manager::schema` (für Validierung)
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `serde::{Serialize, Deserialize, de::DeserializeOwned}`
    * `serde_json`
    * `json_pointer` crate (für Pfad-basierte Zugriffe)

**Kommunikationsmuster:**

* Wird vom `SettingsManagerService` verwendet.
* Interagiert mit dem `ConfigService` für persistente Speicherung.
* Verwendet das `schema` Modul zur Validierung.
* Sendet `SystemEvent::ConfigChanged` an den `EventBus`.
* Empfängt `SystemEvent::ConfigChanged` (von `ConfigService` via `SettingsManagerService`) um interne Zustände zu synchronisieren.

**Erwartete Ergebnisse/Outputs:**
Ein konsistenter und zuverlässiger Manager für alle NovaDE-Einstellungen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService` und `EventBus`.
    * Testen von `new`: Sicherstellen, dass Standardwerte geladen werden, wenn die Konfiguration leer ist, und dass die Validierung angewendet wird.
    * Testen von `get_setting` mit verschiedenen Pfaden und Typen.
    * Testen von `set_setting` mit gültigen und ungültigen Werten, und Überprüfen, ob `save_config` und `ConfigChanged` Events ausgelöst werden.
    * Testen von `reset_setting` und `reset_all_settings_to_default`.
    * Testen von `handle_config_changed_event` um zu überprüfen, ob externe Konfigurationsänderungen korrekt verarbeitet und der interne Zustand aktualisiert werden.
* **Integration Tests:**
    * Starten des `SettingsManager` mit einem echten `ConfigService` und `EventBus`.
    * Simulieren von Lese- und Schreibzugriffen auf Einstellungen und Überprüfen der Konsistenz über den Event-Bus und die persistenten Speicher.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da komplexe Pfad-basierte Zugriffe, Validierung und Event-Propagation)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `input_service`, widmen wir uns `settings_manager`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/settings_manager/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/settings_manager/data_types.rs`**: Definition aller Konfigurationsstrukturen. Dies ist eine Kernkomponente, da alle Einstellungen hier typisiert sind.
3.  **`novade-system/src/settings_manager/schema.rs`**: Definition des Schemas und der Validierungslogik. Baut auf den `data_types` auf.
4.  **`novade-system/src/settings_manager/manager.rs`**: Die Kernlogik zur Verwaltung, Validierung und Benachrichtigung von Einstellungen. Baut auf den `data_types` und `schema` auf.
5.  **`novade-system/src/settings_manager/mod.rs`**: Das Hauptmodul, das den Manager initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/settings_manager` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/notification_service` Verzeichnisses.
---
### **novade-system/src/notification_service/mod.rs**

**Verantwortlichkeit:**
Das `notification_service` Modul ist das zentrale System für die Anzeige und Verwaltung von Benachrichtigungen in NovaDE. Es empfängt Benachrichtigungen von Anwendungen (über D-Bus), Systemdiensten und internen Komponenten, verarbeitet diese gemäß Benutzerpräferenzen und leitet sie zur Anzeige an die UI weiter. Es ist auch für die Verwaltung des Benachrichtigungsverlaufs und die Handhabung von Aktionen auf Benachrichtigungen zuständig.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/notification_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Benachrichtigungs-Operationen)
    * `manager.rs` (Logik für Benachrichtigungsverwaltung, Filterung, Verlauf)
    * `data_types.rs` (Definition von Benachrichtigungs-bezogenen Datentypen)
    * `dbus_interface.rs` (D-Bus-Schnittstelle für `org.freedesktop.Notifications` Protokoll)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Benachrichtigungs-Subsystems:**
    * `pub async fn initialize_notification_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<NotificationService, NotificationError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::NotificationManager`.
        * Initialisiert die D-Bus-Schnittstelle über `dbus_interface::NotificationDbusServer`, um Benachrichtigungen von externen Anwendungen zu empfangen.
        * Lädt initiale Benachrichtigungseinstellungen aus dem `config_service` (z.B. `do_not_disturb_enabled`, `notification_timeout`, `blocked_applications`).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Startet einen Hintergrund-Task, der auf Benachrichtigungen von der `NotificationDbusServer` hört und diese an den `NotificationManager` weiterleitet.
        * Gibt ein gebündeltes `NotificationService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder der D-Bus-Schnittstelle.

2.  **`NotificationService` Struct:**
    * `pub struct NotificationService {`
        * `manager: Arc<NotificationManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `dbus_server: Arc<dbus_interface::NotificationDbusServer>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Benachrichtigungslogik.

3.  **Bereitstellung von API-Methoden:**
    * Der `NotificationService` exponiert Methoden zur Steuerung und Abfrage von Benachrichtigungen.
    * `pub async fn show_notification(&self, notification: Notification) -> Result<u32, NotificationError>`
        * **Logik:** Leitet die Benachrichtigung an den `NotificationManager` weiter, der sie verarbeitet und an die UI zur Anzeige sendet. Gibt die ID der Benachrichtigung zurück.
    * `pub async fn close_notification(&self, id: u32) -> Result<(), NotificationError>`
        * **Logik:** Leitet die Anforderung an den `NotificationManager` weiter, um eine Benachrichtigung zu schließen.
    * `pub async fn get_notification_history(&self) -> Result<Vec<Notification>, NotificationError>`
        * **Logik:** Leitet die Anforderung an den `NotificationManager` weiter, um den Benachrichtigungsverlauf abzurufen.
    * `pub async fn clear_notification_history(&self) -> Result<(), NotificationError>`
        * **Logik:** Leitet die Anforderung an den `NotificationManager` weiter, um den Benachrichtigungsverlauf zu löschen.
    * `pub async fn set_do_not_disturb(&self, enabled: bool) -> Result<(), NotificationError>`
        * **Logik:** Aktualisiert die Konfiguration über den `SettingsManagerService` (oder direkt über `config_service`) und informiert den `NotificationManager`. Sendet `SystemEvent::DoNotDisturbChanged`.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `NotificationService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Benachrichtigungseinstellungen geändert werden, werden die Sub-Komponenten (`NotificationManager`) informiert.

5.  **Hintergrund-Task zum Verarbeiten von D-Bus-Benachrichtigungen:**
    * Ein Task, der den Event-Stream von der `NotificationDbusServer` abonniert. Jede empfangene D-Bus-Benachrichtigung wird vom `NotificationService` verarbeitet:
        * Der `NotificationManager` wird mit der neuen Benachrichtigung aktualisiert.
        * Das `SystemEvent::NotificationReceived` wird an den `EventBus` gesendet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::notification_service::error::NotificationError`
    * `crate::notification_service::manager::NotificationManager`
    * `crate::notification_service::data_types::{Notification, NotificationConfig}`
    * `crate::notification_service::dbus_interface::NotificationDbusServer`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
    * `crate::settings_manager::SettingsManagerService` (optional, falls Einstellungen darüber geändert werden)
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `futures::stream::StreamExt` (für Event-Stream-Verarbeitung)

**Kommunikationsmuster:**

* Ist der primäre Controller für die Anzeige und Verwaltung von Benachrichtigungen.
* Interagiert mit dem `ConfigService` (oder `SettingsManagerService`) zum Speichern und Laden von Benachrichtigungseinstellungen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten und andere Systemdienste über neue, geschlossene oder geänderte Benachrichtigungen zu informieren.
* Empfängt D-Bus-Nachrichten über die `NotificationDbusServer`.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Benachrichtigungs-Subsystem, das Benachrichtigungen von verschiedenen Quellen empfangen, verarbeiten und anzeigen kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `NotificationManager` und `NotificationDbusServer`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und der Verbindung zum Mock-D-Bus-Server.
    * Testen der Weiterleitung von API-Aufrufen an den `NotificationManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von D-Bus-Benachrichtigungen vom Mock-`NotificationDbusServer` und Überprüfen, ob der `NotificationManager` korrekt aufgerufen und `SystemEvent::NotificationReceived` gesendet wird.
* **Integration Tests (mit D-Bus):**
    * Starten des `NotificationService` und einer Testanwendung, die D-Bus-Benachrichtigungen sendet (z.B. `notify-send`).
    * Überprüfen, ob die Benachrichtigungen korrekt empfangen und verarbeitet werden.
    * Testen der `do_not_disturb` Funktion.
    * Überprüfen des Benachrichtigungsverlaufs.

**Geschätzter Aufwand:** Hoch (ca. 6-8 Tage, da D-Bus-Integration, Benachrichtigungslogik und Verlaufsverwaltung notwendig sind)

---
### **novade-system/src/notification_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `notification_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Benachrichtigungs-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum NotificationError {`
        * `#[error("Notification with ID {0} not found.")]`
        * `NotificationNotFound(u32),`
        * `#[error("D-Bus connection failed: {0}")]`
        * `DBusConnectionFailed(String),`
        * `#[error("Failed to register D-Bus service: {0}")]`
        * `DBusServiceRegistrationFailed(String),`
        * `#[error("Failed to send D-Bus reply: {0}")]`
        * `DBusReplyFailed(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Unknown notification error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `anyhow::Error` (und potenziell `zbus::Error` falls `zbus` direkt verwendet wird).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `// zbus::Error (falls zbus direkt verwendet wird)`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `notification_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Benachrichtigungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/notification_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `notification_service` verwendet werden, um Benachrichtigungen, ihre Eigenschaften und zugehörige Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`Notification` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct Notification {`
        * `pub id: u32,` // Eindeutige ID der Benachrichtigung (von Server zugewiesen)
        * `pub app_name: String,`
        * `pub app_icon: Option<String>,` // Pfad zu Icon oder Icon-Name
        * `pub summary: String,` // Titel der Benachrichtigung
        * `pub body: String,` // Inhalt der Benachrichtigung
        * `pub actions: Vec<NotificationAction>,` // Interaktive Aktionen
        * `pub hints: HashMap<String, String>,` // Zusätzliche Metadaten (z.B. Kategorie, urgency)
        * `pub expire_timeout_ms: i32,` // -1 for persistent, 0 for default, >0 for specific timeout
        * `pub timestamp: u64,` // Unix-Timestamp der Erstellung
        * `pub closed_reason: Option<NotificationClosedReason>,` // Wie die Benachrichtigung geschlossen wurde
    * `}`

2.  **`NotificationAction` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub struct NotificationAction {`
        * `pub id: String,` // Eindeutige ID für die Aktion
        * `pub label: String,` // Anzeigename der Aktion
    * `}`

3.  **`NotificationClosedReason` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum NotificationClosedReason {`
        * `Expired,` // Benachrichtigung ist abgelaufen
        * `DismissedByUser,` // Benutzer hat sie geschlossen
        * `ClosedByCall,` // Von einem API-Aufruf geschlossen
        * `Undefined,` // Undefinierter Grund
    * `}`

4.  **`NotificationConfig` Struct (aus `settings_manager::data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct NotificationConfig {`
        * `pub do_not_disturb_enabled: bool,`
        * `pub default_timeout_ms: u32,`
        * `pub display_position: NotificationDisplayPosition,`
        * `pub blocked_applications: Vec<String>,` // App-Namen, deren Benachrichtigungen blockiert werden
        * `pub sound_enabled: bool,`
        * `pub history_limit: u32,`
        * `// ...`
    * `}`

5.  **`NotificationDisplayPosition` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum NotificationDisplayPosition { TopRight, TopLeft, BottomRight, BottomLeft }`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::collections::HashMap`

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Benachrichtigungsinformationen im System.
* `Notification` Objekte werden vom `NotificationDbusServer` empfangen und vom `NotificationManager` verwaltet.
* `NotificationConfig` wird im `SettingsManagerService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Benachrichtigungsverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Mittel (ca. 1-2 Tage, da detaillierte Strukturen für Benachrichtigungen, Aktionen und Status notwendig sind)

---
### **novade-system/src/notification_service/dbus_interface.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert den D-Bus-Server für das `org.freedesktop.Notifications` Protokoll. Es ist der primäre Eingangspunkt für Anwendungen, um Benachrichtigungen an NovaDE zu senden.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationDbusServer` Struct:**
    * `pub struct NotificationDbusServer {`
        * `connection: zbus::Connection,`
        * `notification_sender: mpsc::Sender<Notification>,` // Sender für neue Benachrichtigungen
        * `event_bus: EventBus,`
        * `// ...`
    * `}`

2.  **`NotificationDbusServer::new()` Funktion:**
    * `pub async fn new(event_bus: EventBus) -> Result<Self, NotificationError>`
    * **Logik:**
        * Stellt eine Verbindung zum Session D-Bus her.
        * Registriert den Dienst `org.freedesktop.Notifications` und das Objekt `/org/freedesktop/Notifications`.
        * Startet einen Hintergrund-Task, der auf eingehende D-Bus-Methodenaufrufe (z.B. `Notify`, `CloseNotification`, `GetCapabilities`, `GetServerInformation`) hört.
        * Gibt `Self` zurück und den `mpsc::Receiver` für empfangene Benachrichtigungen.
    * **Fehlerbehandlung:** `DBusConnectionFailed`, `DBusServiceRegistrationFailed`.

3.  **`Notify` D-Bus-Methode Implementierung:**
    * `async fn Notify(&self, app_name: &str, replaces_id: u32, app_icon: &str, summary: &str, body: &str, actions: &[&str], hints: &HashMap<String, zbus::zvariant::Value<'_>>, expire_timeout: i32) -> zbus::fdo::Result<u32>`
    * **Logik:**
        * Erzeugt eine neue `Notification` Instanz aus den D-Bus-Argumenten. Generiert eine neue, eindeutige ID (oder verwendet `replaces_id`).
        * Sendet die `Notification` über den `notification_sender` an den `NotificationService`.
        * Gibt die generierte Benachrichtigungs-ID zurück.

4.  **`CloseNotification` D-Bus-Methode Implementierung:**
    * `async fn CloseNotification(&self, id: u32) -> zbus::fdo::Result<()>`
    * **Logik:**
        * Sendet ein internes Signal oder Event an den `NotificationManager`, um die Benachrichtigung mit der gegebenen ID zu schließen.
        * Sendet ein `NotificationClosed` D-Bus-Signal.

5.  **`GetCapabilities` D-Bus-Methode Implementierung:**
    * `async fn GetCapabilities(&self) -> zbus::fdo::Result<Vec<String>>`
    * **Logik:**
        * Gibt eine Liste der unterstützten Fähigkeiten zurück (z.B. "body", "actions", "icon-json", "persistence").

6.  **`GetServerInformation` D-Bus-Methode Implementierung:**
    * `async fn GetServerInformation(&self) -> zbus::fdo::Result<(String, String, String, String)>`
    * **Logik:**
        * Gibt Server-Informationen zurück (Name, Vendor, Version, Spec Version). Z.B. "NovaDE Notification Service", "NovaDE", "0.1", "1.2".

7.  **`NotificationClosed` D-Bus-Signal:**
    * `#[zbus(signal)]`
    * `async fn NotificationClosed(id: u32, reason: u32);`
    * **Logik:** Dieses Signal wird gesendet, wenn eine Benachrichtigung geschlossen wird (manuell, abgelaufen etc.).

8.  **`ActionInvoked` D-Bus-Signal:**
    * `#[zbus(signal)]`
    * `async fn ActionInvoked(id: u32, action_key: &str);`
    * **Logik:** Dieses Signal wird gesendet, wenn ein Benutzer eine Aktion auf einer Benachrichtigung auswählt. Dies muss von der UI-Komponente, die die Benachrichtigung anzeigt, ausgelöst werden.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/dbus_interface.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::notification_service::error::NotificationError`
    * `crate::notification_service::data_types::{Notification, NotificationAction, NotificationClosedReason}`
    * `novade_core::event_bus::EventBus`
* **Extern:**
    * `zbus` crate (für D-Bus-Kommunikation)
    * `tokio::sync::mpsc`
    * `std::collections::HashMap`
    * `tracing`

**Kommunikationsmuster:**

* Ist der direkte D-Bus-Schnittpunkt für externe Anwendungen.
* Empfängt D-Bus-Methodenaufrufe.
* Sendet `Notification` Objekte über einen Kanal an den `NotificationService`.
* Sendet D-Bus-Signale (`NotificationClosed`, `ActionInvoked`) zurück an D-Bus-Clients.

**Erwartete Ergebnisse/Outputs:**
Eine voll funktionsfähige D-Bus-Schnittstelle, die es NovaDE ermöglicht, den `org.freedesktop.Notifications` Standard zu erfüllen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking von `zbus`):**
    * Mocken der `zbus::Connection` und zugehöriger Methoden.
    * Testen der `new` Funktion und der Dienstregistrierung.
    * Simulieren von `Notify` D-Bus-Aufrufen und Überprüfen, ob die `notification_sender` korrekte `Notification`-Objekte erhält.
    * Simulieren von `CloseNotification` und Überprüfen, ob die internen Signale/Events gesendet werden.
    * Testen von `GetCapabilities` und `GetServerInformation`.
    * Überprüfen, ob `NotificationClosed` und `ActionInvoked` Signale korrekt generiert werden.
* **Integration Tests (mit realem D-Bus):**
    * Starten des `NotificationDbusServer` in einer Testumgebung mit einem laufenden D-Bus-Daemon.
    * Verwenden von `dbus-send` oder einer Testanwendung (z.B. geschrieben in Python mit `pydbus`) um Benachrichtigungen zu senden und Aktionen aufzurufen.
    * Überprüfen, ob die Benachrichtigungen korrekt empfangen werden und die Signale zurückkommen.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da komplexe D-Bus-Protokoll-Implementierung und Signal-Handling)

---
### **novade-system/src/notification_service/manager.rs**

**Verantwortlichkeit:**
Der `NotificationManager` ist die Kernlogik des Benachrichtigungs-Subsystems. Er verwaltet den internen Zustand aller aktiven und vergangenen Benachrichtigungen, wendet Benutzerpräferenzen (z.B. "Bitte nicht stören", Blocklisten) an und orchestratiert die Lebenszyklen der Benachrichtigungen.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationManager` Struct:**
    * `pub struct NotificationManager {`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `active_notifications: RwLock<HashMap<u32, Notification>>,` // id -> Notification
        * `notification_history: RwLock<Vec<Notification>>,` // Chronologischer Verlauf
        * `current_config: RwLock<NotificationConfig>,`
        * `next_notification_id: AtomicU32,`
    * `}`

2.  **`NotificationManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<Self, NotificationError>`
    * **Logik:**
        * Initialisiert alle Felder.
        * Lädt die initiale `NotificationConfig` aus dem `config_service`.
        * Gibt `Self` zurück.

3.  **`NotificationManager::process_new_notification()` Methode:**
    * `pub async fn process_new_notification(&self, mut notification: Notification) -> Result<u32, NotificationError>`
    * **Logik:**
        * **Filterung:** Prüft, ob `current_config.do_not_disturb_enabled` ist oder ob `notification.app_name` in `blocked_applications` ist. Wenn ja, wird die Benachrichtigung verworfen oder nur zum Verlauf hinzugefügt.
        * **ID-Verwaltung:** Weist der Benachrichtigung eine neue eindeutige ID zu, wenn `notification.id` 0 ist oder ersetzt eine bestehende Benachrichtigung, wenn `notification.replaces_id` > 0.
        * **Timeout-Berechnung:** Setzt den tatsächlichen Timeout basierend auf `expire_timeout_ms` und `current_config.default_timeout_ms`.
        * Fügt die Benachrichtigung zu `active_notifications` hinzu.
        * Fügt die Benachrichtigung zum `notification_history` hinzu und beschneidet den Verlauf, wenn `history_limit` überschritten wird.
        * Sendet `SystemEvent::NotificationDisplayed(notification.clone())` an den `EventBus`, um die UI zu informieren.
        * Startet einen `tokio::task` für den Timeout, der nach Ablauf die Benachrichtigung schließt und `SystemEvent::NotificationClosed` sendet.
        * Gibt die ID der verarbeiteten Benachrichtigung zurück.

4.  **`NotificationManager::close_notification()` Methode:**
    * `pub async fn close_notification(&self, id: u32, reason: NotificationClosedReason) -> Result<(), NotificationError>`
    * **Logik:**
        * Entfernt die Benachrichtigung aus `active_notifications`.
        * Aktualisiert den `closed_reason` in der entsprechenden Benachrichtigung im `notification_history`.
        * Sendet `SystemEvent::NotificationClosed(id, reason)`.
        * Stoppt den zugehörigen Timeout-Task, falls aktiv.

5.  **`NotificationManager::invoke_action()` Methode:**
    * `pub async fn invoke_action(&self, notification_id: u32, action_id: &str) -> Result<(), NotificationError>`
    * **Logik:**
        * Findet die Benachrichtigung mit `notification_id`.
        * Sendet `SystemEvent::NotificationActionInvoked(notification_id, action_id.to_string())` an den `EventBus`. Die UI oder eine andere Komponente ist dafür verantwortlich, dieses Event zu verarbeiten und die spezifische Aktion auszuführen.
        * Kann die Benachrichtigung schließen, nachdem die Aktion ausgelöst wurde (abhängig von Konfiguration/Typ).

6.  **`NotificationManager::get_notification_history()` Methode:**
    * `pub async fn get_notification_history(&self) -> Vec<Notification>`
    * **Logik:** Gibt eine Kopie des `notification_history` zurück.

7.  **`NotificationManager::clear_notification_history()` Methode:**
    * `pub async fn clear_notification_history(&self) -> Result<(), NotificationError>`
    * **Logik:** Leert den `notification_history`.

8.  **`NotificationManager::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: NotificationConfig)`
    * **Logik:** Aktualisiert die interne `current_config`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::notification_service::error::NotificationError`
    * `crate::notification_service::data_types::{Notification, NotificationAction, NotificationClosedReason, NotificationConfig}`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::sync::RwLock`
    * `tokio::time::{sleep, Duration}`
    * `std::sync::Arc`
    * `std::sync::atomic::{AtomicU32, Ordering}`
    * `std::collections::HashMap`
    * `tracing`

**Kommunikationsmuster:**

* Ist die zentrale Logik für die Verarbeitung und Verwaltung von Benachrichtigungen.
* Empfängt `Notification` Objekte vom `NotificationService` (der sie von `NotificationDbusServer` bekommt).
* Sendet `SystemEvent`s an den `EventBus` bei allen relevanten Benachrichtigungs-Änderungen (Anzeige, Schließen, Aktionen).
* Interagiert mit dem `ConfigService` für Konfigurations-Updates.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Benachrichtigungs-Manager, der den Lebenszyklus von Benachrichtigungen steuert, Benutzerpräferenzen berücksichtigt und einen Verlauf führt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService` und `EventBus`.
    * Testen von `new`: Sicherstellen, dass initiale Konfiguration geladen wird.
    * Testen von `process_new_notification`:
        * Überprüfen der ID-Generierung und des Ersetzungsmechanismus.
        * Testen der Filterung (DND, Blockliste).
        * Überprüfen des Hinzufügens zu `active_notifications` und `notification_history`.
        * Simulieren des Timeouts und Überprüfen, ob die Benachrichtigung geschlossen und das entsprechende `SystemEvent` gesendet wird.
        * Überprüfen, ob `SystemEvent::NotificationDisplayed` gesendet wird.
    * Testen von `close_notification`: Überprüfen des Entfernens aus `active_notifications` und der Aktualisierung im Verlauf, sowie des Sendens von `SystemEvent::NotificationClosed`.
    * Testen von `invoke_action`: Überprüfen, ob `SystemEvent::NotificationActionInvoked` gesendet wird.
    * Testen von `get_notification_history` und `clear_notification_history`.
    * Testen von `update_config` und dessen Auswirkungen auf die Filterung und Timeouts.
* **Integration Tests:**
    * Starten des `NotificationManager` mit echten oder simulierten Abhängigkeiten, die reale `Notification`-Objekte erzeugen.
    * Senden von Benachrichtigungen mit unterschiedlichen Eigenschaften (Timeout, Aktionen, Blocklisten).
    * Manuelles Schließen von Benachrichtigungen und Auslösen von Aktionen.
    * Überprüfen des Benachrichtigungsverlaufs und der konsistenten Zustandsänderungen.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da komplexes Zustandsmanagement, Timeout-Handling, Filterung und Event-Propagation)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `settings_manager`, widmen wir uns `notification_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/notification_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/notification_service/data_types.rs`**: Definition aller Benachrichtigungs- und Konfigurationsstrukturen.
3.  **`novade-system/src/notification_service/dbus_interface.rs`**: Implementierung der D-Bus-Schnittstelle. Dies muss frühzeitig erfolgen, da dies der primäre Eingangspunkt für Benachrichtigungen ist.
4.  **`novade-system/src/notification_service/manager.rs`**: Die Kernlogik zur Verarbeitung, Filterung und Verwaltung des Lebenszyklus von Benachrichtigungen. Baut auf den `data_types` und den Ereignissen vom `dbus_interface` auf.
5.  **`novade-system/src/notification_service/mod.rs`**: Das Hauptmodul, das den Manager und die D-Bus-Schnittstelle initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/notification_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/power_management_service` Verzeichnisses.
---
### **novade-system/src/power_management_service/mod.rs**

**Verantwortlichkeit:**
Das `power_management_service` Modul ist das zentrale System für die Verwaltung der Energieeinstellungen in NovaDE. Es überwacht den Batteriestatus, die Stromversorgung und die Systemauslastung, wendet Benutzerpräferenzen an (z.B. Bildschirm ausschalten, Suspend nach Inaktivität, Aktionen beim Zuklappen des Laptops) und reagiert auf kritische Energieereignisse (z.B. niedriger Batteriestand). Es interagiert mit dem Kernel oder spezifischen System-APIs, um diese Funktionen bereitzustellen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/power_management_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Energieverwaltungs-Operationen)
    * `manager.rs` (Logik für Energieverwaltung, Inaktivitätserkennung, Aktionsausführung)
    * `data_types.rs` (Definition von Energie-bezogenen Datentypen)
    * `udisks_interface.rs` (D-Bus-Schnittstelle für `org.freedesktop.UPower` und `org.freedesktop.UDisks2` Protokolle)
    * `systemd_interface.rs` (D-Bus-Schnittstelle für `org.freedesktop.login1` und `org.freedesktop.systemd1` Protokolle)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Energieverwaltungs-Subsystems:**
    * `pub async fn initialize_power_management_service(config_service: Arc<ConfigService>, event_bus: EventBus, window_management_service: Arc<WindowManagementService>) -> Result<PowerManagementService, PowerManagementError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::PowerManager`.
        * Initialisiert die D-Bus-Schnittstellen zu `UPower`, `UDisks2`, `login1` und `systemd1` über `udisks_interface::UDisksInterface` und `systemd_interface::SystemdInterface`.
        * Lädt initiale Energieeinstellungen aus dem `config_service` (z.B. Bildschirm-Timeout, Suspend-Verzögerung, Aktionen bei geschlossenem Deckel).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Startet einen Hintergrund-Task, der auf Energie-bezogene D-Bus-Signale (z.B. Batteriestatusänderungen, Lid-Switch-Events) hört und diese an den `PowerManager` weiterleitet.
        * Registriert sich beim System für Inaktivitätsbenachrichtigungen oder implementiert eigene Inaktivitätserkennung (z.B. durch Überwachung von `InputService` Events).
        * Gibt ein gebündeltes `PowerManagementService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder der D-Bus-Schnittstellen.

2.  **`PowerManagementService` Struct:**
    * `pub struct PowerManagementService {`
        * `manager: Arc<PowerManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `udisks_interface: Arc<udisks_interface::UDisksInterface>,`
        * `systemd_interface: Arc<systemd_interface::SystemdInterface>,`
        * `window_management_service: Arc<WindowManagementService>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Energieverwaltungslogik.

3.  **Bereitstellung von API-Methoden:**
    * Der `PowerManagementService` exponiert Methoden zur Abfrage und Steuerung der Energieverwaltung.
    * `pub async fn get_power_status(&self) -> Result<PowerStatus, PowerManagementError>`
        * **Logik:** Delegiert an den `PowerManager`, um den aktuellen Batteriestatus und den Ladezustand abzurufen.
    * `pub async fn suspend(&self) -> Result<(), PowerManagementError>`
        * **Logik:** Delegiert an den `PowerManager`, der dann über `systemd_interface` den Suspend-Befehl an `systemd-logind` sendet.
    * `pub async fn hibernate(&self) -> Result<(), PowerManagementError>`
        * **Logik:** Delegiert an den `PowerManager`, der den Hibernate-Befehl über `systemd_interface` sendet.
    * `pub async fn shutdown(&self) -> Result<(), PowerManagementError>`
        * **Logik:** Delegiert an den `PowerManager`, der den Shutdown-Befehl über `systemd_interface` sendet.
    * `pub async fn reboot(&self) -> Result<(), PowerManagementError>`
        * **Logik:** Delegiert an den `PowerManager`, der den Reboot-Befehl über `systemd_interface` sendet.
    * `pub async fn set_screen_blank_delay(&self, delay_minutes: u32) -> Result<(), PowerManagementError>`
        * **Logik:** Aktualisiert die Konfiguration (über `SettingsManagerService` oder direkt `config_service`) und informiert den `PowerManager`. Löst `SystemEvent::ConfigChanged` aus.
    * `pub async fn set_lid_action(&self, action: LidAction, on_battery: bool) -> Result<(), PowerManagementError>`
        * **Logik:** Aktualisiert die Konfiguration und informiert den `PowerManager`. Löst `SystemEvent::ConfigChanged` aus.
    * `pub async fn inhibit_suspend(&self, app_name: String, reason: String) -> Result<u32, PowerManagementError>`
        * **Logik:** Delegiert an den `PowerManager`, der dann über `systemd_interface` ein Suspend-Inhibit an `systemd-logind` anfordert. Gibt eine Inhibit-ID zurück.
    * `pub async fn uninhibit_suspend(&self, inhibit_id: u32) -> Result<(), PowerManagementError>`
        * **Logik:** Delegiert an den `PowerManager`, der das Inhibit über `systemd_interface` freigibt.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `PowerManagementService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Energieeinstellungen geändert werden, werden die Sub-Komponenten (`PowerManager`) informiert.

5.  **Hintergrund-Task zum Verarbeiten von D-Bus-Signalen:**
    * Ein Task, der den Event-Stream von `UDisksInterface` und `SystemdInterface` abonniert. Jedes empfangene D-Bus-Signal wird vom `PowerManagementService` verarbeitet:
        * Der `PowerManager` wird mit der neuen Energieinformation aktualisiert (z.B. `PowerStatusChanged`, `LidSwitchClosed`).
        * Entsprechende `SystemEvent`s werden an den `EventBus` gesendet (z.B. `BatteryLevelChanged`, `LidClosed`, `PowerSourceChanged`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_management_service::error::PowerManagementError`
    * `crate::power_management_service::manager::PowerManager`
    * `crate::power_management_service::data_types::{PowerStatus, LidAction, PowerConfig}`
    * `crate::power_management_service::udisks_interface::UDisksInterface`
    * `crate::power_management_service::systemd_interface::SystemdInterface`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
    * `crate::window_management_service::WindowManagementService` (für Bildschirmaktionen)
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `futures::stream::StreamExt` (für Event-Stream-Verarbeitung)

**Kommunikationsmuster:**

* Ist der primäre Controller für die Energieverwaltung.
* Interagiert mit dem `ConfigService` (oder `SettingsManagerService`) zum Speichern und Laden von Energieeinstellungen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten und andere Systemdienste über Energieereignisse zu informieren.
* Empfängt D-Bus-Signale von `UDisksInterface` und `SystemdInterface`.
* Kann mit dem `WindowManagementService` interagieren, um den Bildschirm auszuschalten oder zu sperren.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Energieverwaltungs-Subsystem, das den Energieverbrauch überwacht und auf Systemereignisse und Benutzerpräferenzen reagiert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `PowerManager`, `UDisksInterface` und `SystemdInterface`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration.
    * Testen der Weiterleitung von API-Aufrufen an den `PowerManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von D-Bus-Signalen (z.B. Batteriestatus, Lid-Switch) von den Mock-D-Bus-Schnittstellen und Überprüfen, ob der `PowerManager` korrekt aufgerufen und entsprechende `SystemEvent`s gesendet werden.
* **Integration Tests (mit D-Bus):**
    * Starten des `PowerManagementService` in einer Testumgebung mit laufenden `upowerd` und `systemd-logind` Prozessen.
    * Simulieren von Batteriewechseln oder Lid-Events (falls möglich über Test-Tools).
    * Testen von Suspend/Hibernate/Shutdown-Aufrufen und Überprüfen der Systemreaktion (Vorsicht: Dies kann den Testserver beeinflussen).
    * Testen von Inhibit-Anfragen.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da D-Bus-Integrationen, Energieüberwachung und Aktionsausführung notwendig sind)

---
### **novade-system/src/power_management_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `power_management_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Energieverwaltungs-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`PowerManagementError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum PowerManagementError {`
        * `#[error("Failed to connect to D-Bus: {0}")]`
        * `DBusConnectionFailed(String),`
        * `#[error("D-Bus method call failed: {0}")]`
        * `DBusMethodCallFailed(String),`
        * `#[error("Invalid power action requested: {0}")]`
        * `InvalidPowerAction(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Unknown power management error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `anyhow::Error` (und potenziell `zbus::Error` falls `zbus` direkt verwendet wird).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `// zbus::Error (falls zbus direkt verwendet wird)`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `power_management_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Energieverwaltungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/power_management_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `power_management_service` verwendet werden, um Energieinformationen, Batteriestatus und zugehörige Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`PowerStatus` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct PowerStatus {`
        * `pub battery_level: u8,` // 0-100%
        * `pub is_charging: bool,`
        * `pub on_ac_power: bool,`
        * `pub time_to_empty_minutes: Option<u32>,`
        * `pub time_to_full_minutes: Option<u32>,`
        * `pub power_source_name: String,` // z.B. "Battery", "AC"
        * `pub battery_health_percent: Option<u8>,`
        * `pub device_names: Vec<String>,` // Names of power devices
    * `}`

2.  **`LidAction` Enum (aus `settings_manager::data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub enum LidAction { DoNothing, Suspend, Hibernate, Shutdown }`

3.  **`PowerConfig` Struct (aus `settings_manager::data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct PowerConfig {`
        * `pub screen_blank_delay_min: u32,`
        * `pub suspend_delay_min: u32,`
        * `pub lid_action_on_battery: LidAction,`
        * `pub lid_action_on_ac: LidAction,`
        * `pub low_battery_threshold_percent: u8,`
        * `pub critical_battery_threshold_percent: u8,`
        * `pub enable_notifications_low_battery: bool,`
        * `// ...`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
* **Intern:**
    * `crate::settings_manager::data_types::{LidAction, PowerConfig}` (oder direkter Import, wenn `settings_manager` diese als `pub` exponiert)

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Energieinformationen im System.
* `PowerStatus` Objekte werden vom `UDisksInterface` generiert und vom `PowerManager` verwaltet.
* `PowerConfig` wird im `SettingsManagerService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Energieverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/power_management_service/udisks_interface.rs**

**Verantwortlichkeit:**
Dieses Modul stellt die Schnittstelle zu `UDisks2` und `UPower` über D-Bus bereit. Es ist verantwortlich für das Abfragen des Batteriestatus, der Stromversorgung und das Empfangen von Signalen über Änderungen dieser Zustände.

**Kern-Aufgaben (Tasks):**

1.  **`UDisksInterface` Struct:**
    * `pub struct UDisksInterface {`
        * `upower_proxy: UPowerProxy<'static>,` // Proxy für UPower D-Bus Service
        * `udisks2_manager_proxy: UDisks2ManagerProxy<'static>,` // Proxy für UDisks2 Manager
        * `status_sender: mpsc::Sender<PowerStatus>,` // Sender für PowerStatus-Updates
        * `event_bus: EventBus,`
        * `// ...`
    * `}`
    * `UPowerProxy` und `UDisks2ManagerProxy` sind hier Platzhalter für `zbus::Proxy` oder ähnliche typisierte Proxies, die von `zbus` generiert werden könnten.

2.  **`UDisksInterface::new()` Funktion:**
    * `pub async fn new(event_bus: EventBus) -> Result<Self, PowerManagementError>`
    * **Logik:**
        * Stellt eine Verbindung zum System D-Bus her.
        * Erzeugt Proxies für `org.freedesktop.UPower` und `org.freedesktop.UDisks2`.
        * Startet einen Hintergrund-Task, der D-Bus-Signale von `UPower` überwacht (z.B. `PropertiesChanged`, `DeviceAdded`, `DeviceRemoved`).
        * Initialisiert den `status_sender` und gibt den dazugehörigen `mpsc::Receiver` zurück.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `DBusConnectionFailed`, `DBusMethodCallFailed`.

3.  **`UDisksInterface::get_current_power_status()` Methode:**
    * `pub async fn get_current_power_status(&self) -> Result<PowerStatus, PowerManagementError>`
    * **Logik:**
        * Ruft Methoden auf dem `UPowerProxy` auf, um den globalen Batteriestatus und die Ladezustände abzufragen.
        * Iteriert über angeschlossene Energiegeräte (Batterien, Netzteile) und aggregiert deren Informationen.
        * Konvertiert die D-Bus-Antworten in eine `PowerStatus` Struktur.

4.  **Hintergrund-Task zum Abonnieren von UPower-Signalen:**
    * Ein Task, der auf D-Bus-Signale von `org.freedesktop.UPower` hört:
        * Bei `PropertiesChanged` (z.B. `IsCharging`, `BatteryLevel`): Ruft `get_current_power_status()` auf und sendet den aktualisierten `PowerStatus` über `status_sender`. Sendet `SystemEvent::BatteryLevelChanged` oder `PowerSourceChanged` an den `EventBus`.
        * Bei `DeviceAdded` / `DeviceRemoved`: Ruft `get_current_power_status()` auf und sendet den aktualisierten `PowerStatus`. Sendet `SystemEvent::PowerDeviceAdded` / `PowerDeviceRemoved`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management_service/udisks_interface.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_management_service::error::PowerManagementError`
    * `crate::power_management_service::data_types::PowerStatus`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus` crate (für D-Bus-Kommunikation)
    * `tokio::sync::mpsc`
    * `tracing`

**Kommunikationsmuster:**

* Wird vom `PowerManagementService` instanziiert und verwendet.
* Stellt den `PowerManager` mit aktuellen `PowerStatus`-Informationen und Updates über einen Kanal bereit.
* Sendet `SystemEvent`s an den `EventBus` bei relevanten Energie-Änderungen.

**Erwartete Ergebnisse/Outputs:**
Eine zuverlässige Schnittstelle zur Überwachung des Batteriestatus und der Stromversorgung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking von `zbus`):**
    * Mocken der `zbus::Connection` und der D-Bus-Proxies.
    * Testen der `new` Funktion und der Proxy-Erstellung.
    * Simulieren von D-Bus-Antworten für `get_current_power_status` und Überprüfen der korrekten `PowerStatus`-Konvertierung.
    * Simulieren von `UPower` D-Bus-Signalen (`PropertiesChanged`, `DeviceAdded`) und Überprüfen, ob `status_sender` korrekte `PowerStatus`-Updates erhält und `SystemEvent`s gesendet werden.
* **Integration Tests (mit realem D-Bus):**
    * Starten des `UDisksInterface` in einer Testumgebung mit laufendem `upowerd` und `udisksd`.
    * Abfragen des aktuellen Energiestatus.
    * Beobachten von Änderungen (z.B. Stecker ziehen/stecken, Batteriestand ändern, falls simulierbar) und Überprüfen, ob die entsprechenden Updates empfangen werden.

**Geschätzter Aufwand:** Hoch (ca. 5-7 Tage, da D-Bus-Integration und Parsing komplexer Strukturen)

---
### **novade-system/src/power_management_service/systemd_interface.rs**

**Verantwortlichkeit:**
Dieses Modul stellt die Schnittstelle zu `systemd-logind` und `systemd` über D-Bus bereit. Es ist verantwortlich für das Auslösen von Suspend, Hibernate, Shutdown und Reboot, sowie das Verwalten von Suspend-Inhibits und das Empfangen von Lid-Switch-Events.

**Kern-Aufgaben (Tasks):**

1.  **`SystemdInterface` Struct:**
    * `pub struct SystemdInterface {`
        * `login1_proxy: Login1Proxy<'static>,` // Proxy für systemd-logind
        * `systemd_manager_proxy: SystemdManagerProxy<'static>,` // Proxy für systemd Service Manager
        * `lid_event_sender: mpsc::Sender<LidSwitchEvent>,` // Sender für Lid-Switch-Events
        * `event_bus: EventBus,`
        * `active_inhibits: Arc<RwLock<HashMap<u32, String>>>,` // Map of active inhibit IDs
    * `}`
    * `Login1Proxy` und `SystemdManagerProxy` sind hier Platzhalter für `zbus::Proxy` oder ähnliche typisierte Proxies.

2.  **`SystemdInterface::new()` Funktion:**
    * `pub async fn new(event_bus: EventBus) -> Result<Self, PowerManagementError>`
    * **Logik:**
        * Stellt eine Verbindung zum System D-Bus her.
        * Erzeugt Proxies für `org.freedesktop.login1` und `org.freedesktop.systemd1`.
        * Startet einen Hintergrund-Task, der D-Bus-Signale von `systemd-logind` überwacht (z.B. `LidSwitchMonitor`).
        * Initialisiert den `lid_event_sender` und gibt den dazugehörigen `mpsc::Receiver` zurück.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `DBusConnectionFailed`, `DBusMethodCallFailed`.

3.  **`SystemdInterface::suspend()` Methode:**
    * `pub async fn suspend(&self) -> Result<(), PowerManagementError>`
    * **Logik:** Ruft die `Suspend()` Methode auf dem `login1_proxy` auf.

4.  **`SystemdInterface::hibernate()` Methode:**
    * `pub async fn hibernate(&self) -> Result<(), PowerManagementError>`
    * **Logik:** Ruft die `Hibernate()` Methode auf dem `login1_proxy` auf.

5.  **`SystemdInterface::power_off()` Methode:**
    * `pub async fn power_off(&self) -> Result<(), PowerManagementError>`
    * **Logik:** Ruft die `PowerOff()` Methode auf dem `login1_proxy` auf.

6.  **`SystemdInterface::reboot()` Methode:**
    * `pub async fn reboot(&self) -> Result<(), PowerManagementError>`
    * **Logik:** Ruft die `Reboot()` Methode auf dem `login1_proxy` auf.

7.  **`SystemdInterface::inhibit_sleep()` Methode:**
    * `pub async fn inhibit_sleep(&self, app_name: &str, reason: &str) -> Result<u32, PowerManagementError>`
    * **Logik:**
        * Ruft die `Inhibit()` Methode auf dem `login1_proxy` auf (Parameter: "sleep", `app_name`, `reason`, "block").
        * Die Methode gibt einen Dateideskriptor zurück, der geöffnet gehalten werden muss, um das Inhibit aufrechtzuerhalten. Eine interne Liste von `inhibit_fds` muss verwaltet werden.
        * Gibt eine eindeutige Inhibit-ID zurück.

8.  **`SystemdInterface::uninhibit_sleep()` Methode:**
    * `pub async fn uninhibit_sleep(&self, inhibit_id: u32) -> Result<(), PowerManagementError>`
    * **Logik:**
        * Schließt den Dateideskriptor, der mit der `inhibit_id` assoziiert ist.
        * Entfernt die ID aus der internen Liste.

9.  **Hintergrund-Task zum Abonnieren von login1-Signalen:**
    * Ein Task, der auf D-Bus-Signale von `org.freedesktop.login1` hört:
        * Bei `LidSwitchMonitor` Signal (oder `PrepareForSleep` etc.): Sendet `LidSwitchEvent` über `lid_event_sender`. Sendet `SystemEvent::LidClosed` oder `LidOpened` an den `EventBus`.
        * Bei `PrepareForShutdown` / `PrepareForSleep`: Informiert den `PowerManager`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management_service/systemd_interface.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_management_service::error::PowerManagementError`
    * `crate::power_management_service::data_types::LidAction`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus` crate (für D-Bus-Kommunikation)
    * `tokio::sync::mpsc`
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `std::collections::HashMap`
    * `tracing`
    * `// Optionale Crate für Dateideskriptoren, z.B. nix`

**Kommunikationsmuster:**

* Wird vom `PowerManagementService` instanziiert und verwendet.
* Stellt dem `PowerManager` die Möglichkeit zur Verfügung, Systemaktionen auszulösen und Lid-Events zu empfangen.
* Sendet `SystemEvent`s an den `EventBus` bei relevanten Systemereignissen.

**Erwartete Ergebnisse/Outputs:**
Eine zuverlässige Schnittstelle zur Steuerung von System-Energieaktionen und zum Empfang von Lid-Switch-Events.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking von `zbus`):**
    * Mocken der `zbus::Connection` und der D-Bus-Proxies.
    * Testen der `new` Funktion und der Proxy-Erstellung.
    * Simulieren von D-Bus-Methodenaufrufen (`Suspend`, `Inhibit`) und Überprüfen der korrekten D-Bus-Interaktion.
    * Simulieren von `login1` D-Bus-Signalen (`LidSwitchMonitor`) und Überprüfen, ob `lid_event_sender` korrekte Events erhält und `SystemEvent`s gesendet werden.
    * Testen der `inhibit_sleep` und `uninhibit_sleep` Logik (Verwaltung der `active_inhibits`).
* **Integration Tests (mit realem D-Bus):**
    * Starten des `SystemdInterface` in einer Testumgebung mit laufendem `systemd-logind`.
    * Testen von Suspend/Hibernate/Shutdown/Reboot-Aufrufen (Vorsicht: Dies kann den Testserver beeinflussen!).
    * Testen von Inhibit-Anfragen und Überprüfen, ob das System am Schlafen gehindert wird.
    * Simulieren von Lid-Öffnen/Schließen und Überprüfen der Signal-Empfang.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da komplexe D-Bus-Protokoll-Implementierung, Dateideskriptor-Handling für Inhibits)

---
### **novade-system/src/power_management_service/manager.rs**

**Verantwortlichkeit:**
Der `PowerManager` ist die Kernlogik des Energieverwaltungs-Subsystems. Er verwaltet den aktuellen Energie-Zustand, wendet Benutzerpräferenzen (basierend auf `PowerConfig`) an, reagiert auf Batteriestatusänderungen, Inaktivität und Lid-Switch-Events, und löst entsprechende Systemaktionen aus.

**Kern-Aufgaben (Tasks):**

1.  **`PowerManager` Struct:**
    * `pub struct PowerManager {`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `window_management_service: Arc<WindowManagementService>,`
        * `udisks_interface: Arc<UDisksInterface>,`
        * `systemd_interface: Arc<SystemdInterface>,`
        * `current_config: RwLock<PowerConfig>,`
        * `current_power_status: RwLock<PowerStatus>,`
        * `inactivity_timer: RwLock<Option<tokio::task::JoinHandle<()>>>,` // Timer für Inaktivität
        * `active_inhibits: RwLock<HashMap<u32, String>>,` // ID -> Grund des Inhibits
    * `}`

2.  **`PowerManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus, window_management_service: Arc<WindowManagementService>, udisks_interface: Arc<UDisksInterface>, systemd_interface: Arc<SystemdInterface>) -> Result<Self, PowerManagementError>`
    * **Logik:**
        * Initialisiert alle Felder.
        * Lädt die initiale `PowerConfig` aus dem `config_service`.
        * Ruft `udisks_interface.get_current_power_status()` auf, um den initialen `PowerStatus` zu erhalten.
        * Startet Hintergrund-Tasks zum Abonnieren von `udisks_interface` (für `PowerStatus` Updates) und `systemd_interface` (für `LidSwitchEvents`).
        * Gibt `Self` zurück.

3.  **`PowerManager::handle_power_status_update()` Methode (intern, vom `PowerManagementService` aufgerufen):**
    * `pub async fn handle_power_status_update(&self, new_status: PowerStatus)`
    * **Logik:**
        * Aktualisiert `current_power_status`.
        * Sendet `SystemEvent::BatteryLevelChanged` und `SystemEvent::PowerSourceChanged` an den `EventBus`, wenn relevant.
        * Prüft auf niedrigen/kritischen Batteriestand und löst `SystemEvent::LowBatteryWarning` oder `CriticalBatteryWarning` aus und kann Benachrichtigungen über den `notification_service` senden.
        * Kann Aktionen basierend auf Batteriestand auslösen (z.B. automatisches Suspend bei kritischem Stand).

4.  **`PowerManager::handle_lid_switch_event()` Methode (intern, vom `PowerManagementService` aufgerufen):**
    * `pub async fn handle_lid_switch_event(&self, event: LidSwitchEvent)`
    * **Logik:**
        * Bei `LidSwitchEvent::Closed`:
            * Ermittelt die korrekte `LidAction` aus `current_config` basierend auf `on_ac_power`.
            * Führt die entsprechende Aktion aus: `DoNothing`, `Suspend`, `Hibernate`, `Shutdown` (delegiert an `systemd_interface`).
            * Sendet `SystemEvent::LidClosed`.
        * Bei `LidSwitchEvent::Opened`:
            * Sendet `SystemEvent::LidOpened`.

5.  **`PowerManager::handle_inactivity_event()` Methode (intern, durch externen Timer oder InputService ausgelöst):**
    * `pub async fn handle_inactivity_event(&self)`
    * **Logik:**
        * Prüft, ob `screen_blank_delay_min` oder `suspend_delay_min` in der `current_config` gesetzt sind.
        * Wenn ja, prüft, ob Inhibit-Anfragen vorliegen. Wenn nicht, führt die entsprechende Aktion aus:
            * Bildschirm aus (`window_management_service.blank_screen()`).
            * Suspend (`self.suspend()`).
        * Sendet `SystemEvent::InactivityDetected`.

6.  **`PowerManager::start_inactivity_timer()` und `reset_inactivity_timer()` Methoden:**
    * Diese Methoden würden einen `tokio::time::sleep` Task verwalten, der bei Inaktivität `handle_inactivity_event` aufruft. Jede Benutzerinteraktion (vom `InputService` gemeldet) würde den Timer zurücksetzen.

7.  **`PowerManager::suspend()`, `hibernate()`, `shutdown()`, `reboot()` Methoden:**
    * **Logik:** Diese öffentlichen Methoden (von `PowerManagementService` aufgerufen) delegieren die eigentlichen Systemaufrufe an `systemd_interface`. Bevor die Aktion ausgeführt wird, kann eine `SystemEvent::PrepareForSleep` (oder `Shutdown` etc.) gesendet werden, damit Anwendungen sich vorbereiten können.

8.  **`PowerManager::inhibit_suspend()` und `uninhibit_suspend()` Methoden:**
    * **Logik:** Diese Methoden delegieren an `systemd_interface` und verwalten die interne `active_inhibits` Map. Der `inactivity_timer` muss die `active_inhibits` berücksichtigen, bevor er eine Aktion auslöst.

9.  **`PowerManager::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: PowerConfig)`
    * **Logik:** Aktualisiert die interne `current_config` und kann den `inactivity_timer` neu starten oder anpassen, wenn sich die Verzögerungen geändert haben.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_management_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_management_service::error::PowerManagementError`
    * `crate::power_management_service::data_types::{PowerStatus, LidAction, PowerConfig}`
    * `crate::power_management_service::udisks_interface::UDisksInterface`
    * `crate::power_management_service::systemd_interface::SystemdInterface`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
    * `crate::window_management_service::WindowManagementService`
    * `crate::notification_service::NotificationService` (für Warnungen bei niedrigem Batteriestand)
* **Extern:**
    * `tokio::sync::RwLock`
    * `tokio::time::{sleep, Duration}`
    * `tokio::task::JoinHandle`
    * `std::sync::Arc`
    * `std::collections::HashMap`
    * `tracing`

**Kommunikationsmuster:**

* Ist die zentrale Logik für die Energieverwaltung.
* Empfängt Energie- und Lid-Events von `UDisksInterface` und `SystemdInterface`.
* Sendet `SystemEvent`s an den `EventBus` bei allen relevanten Energie-Änderungen und Aktionen.
* Interagiert mit dem `ConfigService` für Konfigurations-Updates.
* Ruft Methoden auf `WindowManagementService` auf, um den Bildschirm zu steuern.
* Ruft Methoden auf `NotificationService` auf, um Warnungen zu senden.

**Erwartete Ergebnisse/Outputs:**
Ein intelligenter Energie-Manager, der den Energieverbrauch des Systems basierend auf Benutzerpräferenzen und Systemereignissen steuert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `WindowManagementService`, `UDisksInterface` und `SystemdInterface`.
    * Testen von `new`: Sicherstellen, dass initiale Konfiguration und Status geladen werden.
    * Testen von `handle_power_status_update`: Simulieren verschiedener Batteriestände und Überprüfen, ob korrekte `SystemEvent`s gesendet werden und Warnungen ausgelöst werden.
    * Testen von `handle_lid_switch_event`: Simulieren von Lid-Schließereignissen und Überprüfen, ob die korrekte `LidAction` basierend auf der Konfiguration ausgeführt wird (mocken der Systemd-Aufrufe).
    * Testen der Inaktivitätserkennung: Starten und Zurücksetzen des Timers, Simulieren von Inaktivität und Überprüfen, ob Bildschirm aus/Suspend-Aktionen ausgelöst werden (unter Berücksichtigung von Inhibits).
    * Testen von `inhibit_suspend` und `uninhibit_suspend` und Überprüfen, ob der Manager den Inhibit-Zustand korrekt verwaltet und der Inaktivitätstimer darauf reagiert.
    * Testen von `update_config` und seinen Auswirkungen.
* **Integration Tests:**
    * Starten des `PowerManager` mit echten oder simulierten Abhängigkeiten.
    * Simulieren realer Szenarien: Laptop schließen, Batteriestand unter Schwellenwert, Inaktivität.
    * Überprüfen, ob die Systemaktionen korrekt ausgeführt werden und die UI über den Event-Bus informiert wird.

**Geschätzter Aufwand:** Hoch (ca. 9-14 Tage, da komplexe Zustandsmanagement, Timer, D-Bus-Interaktionen und Aktionslogik)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `notification_service`, widmen wir uns `power_management_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/power_management_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/power_management_service/data_types.rs`**: Definition der Energie-bezogenen Datentypen.
3.  **`novade-system/src/power_management_service/udisks_interface.rs`**: Implementierung der D-Bus-Schnittstelle zu `UPower` und `UDisks2`. Dies ist für die Überwachung des Batteriestatus und der Stromversorgung notwendig.
4.  **`novade-system/src/power_management_service/systemd_interface.rs`**: Implementierung der D-Bus-Schnittstelle zu `systemd-logind` und `systemd`. Dies ist für Systemaktionen wie Suspend und Lid-Events notwendig.
5.  **`novade-system/src/power_management_service/manager.rs`**: Die Kernlogik zur Verarbeitung von Energieereignissen, Anwendung von Konfigurationen und Auslösung von Systemaktionen. Baut auf den `data_types` und den Schnittstellen zu `udisks_interface` und `systemd_interface` auf.
6.  **`novade-system/src/power_management_service/mod.rs`**: Das Hauptmodul, das den Manager und die D-Bus-Schnittstellen initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/power_management_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/session_manager` Verzeichnisses.
---
### **novade-system/src/session_manager/mod.rs**

**Verantwortlichkeit:**
Das `session_manager` Modul ist für die Verwaltung von Benutzersitzungen in NovaDE zuständig. Es kümmert sich um den Start, die Beendigung und das Sperren von Sitzungen, die Authentifizierung von Benutzern und die Interaktion mit dem Display-Manager. Es gewährleistet einen sicheren und stabilen Übergang zwischen den Sitzungszuständen und die korrekte Handhabung von Anmelde- und Abmeldeereignissen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/session_manager/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Sitzungs-Operationen)
    * `manager.rs` (Logik für Sitzungsverwaltung, Authentifizierung, Zustandsübergänge)
    * `data_types.rs` (Definition von Sitzungs-bezogenen Datentypen)
    * `login_service.rs` (Implementierung des Login-Prozesses, z.B. PAM-Interaktion)
    * `display_manager_interface.rs` (Interaktion mit dem Display-Manager über D-Bus oder andere Protokolle)
    * `dbus_interface.rs` (D-Bus-Schnittstelle für `org.freedesktop.login1` und `org.freedesktop.ConsoleKit`)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Sitzungs-Subsystems:**
    * `pub async fn initialize_session_manager(config_service: Arc<ConfigService>, event_bus: EventBus, input_service: Arc<InputService>) -> Result<SessionManagerService, SessionManagerError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::SessionManager`.
        * Initialisiert die Interaktion mit dem Display-Manager über `display_manager_interface`.
        * Initialisiert die D-Bus-Schnittstelle über `dbus_interface::LoginDbusInterface`, um auf `systemd-logind` und `ConsoleKit` zuzugreifen.
        * Lädt initiale Sitzungseinstellungen aus dem `config_service` (z.B. automatisches Sperren nach Inaktivität).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Startet einen Hintergrund-Task, der auf Inaktivitätssignale vom `InputService` hört, um die automatische Sperrung auszulösen.
        * Gibt ein gebündeltes `SessionManagerService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder der Schnittstellen.

2.  **`SessionManagerService` Struct:**
    * `pub struct SessionManagerService {`
        * `manager: Arc<SessionManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `input_service: Arc<InputService>,`
        * `display_manager_interface: Arc<display_manager_interface::DisplayManagerInterface>,`
        * `dbus_interface: Arc<dbus_interface::LoginDbusInterface>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Sitzungslogik.

3.  **Bereitstellung von API-Methoden:**
    * Der `SessionManagerService` exponiert Methoden zur Steuerung und Abfrage von Sitzungen.
    * `pub async fn login_user(&self, username: &str, password: &str) -> Result<(), SessionManagerError>`
        * **Logik:** Delegiert an den `login_service` für die Authentifizierung und an den `manager`, um die Sitzung zu starten.
    * `pub async fn logout_user(&self) -> Result<(), SessionManagerError>`
        * **Logik:** Delegiert an den `manager`, um die aktuelle Sitzung zu beenden.
    * `pub async fn lock_session(&self) -> Result<(), SessionManagerError>`
        * **Logik:** Delegiert an den `manager`, der die Sitzung sperrt (z.B. über den Display-Manager oder ein internes Lock-Screen).
    * `pub async fn unlock_session(&self, password: &str) -> Result<(), SessionManagerError>`
        * **Logik:** Delegiert an den `manager` und den `login_service` zur Authentifizierung und Entsperrung.
    * `pub async fn get_current_session_info(&self) -> Result<SessionInfo, SessionManagerError>`
        * **Logik:** Delegiert an den `manager`, um Informationen über die aktuelle Sitzung abzurufen.
    * `pub async fn switch_to_user_session(&self, username: &str) -> Result<(), SessionManagerError>`
        * **Logik:** Delegiert an den `manager`, um eine andere Benutzersitzung zu aktivieren.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `SessionManagerService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Sitzungseinstellungen geändert werden, werden die Sub-Komponenten (`SessionManager`) informiert.

5.  **Hintergrund-Task zum Abonnieren von Inaktivitäts-Events:**
    * Ein Task, der auf `SystemEvent::InactivityDetected` vom `InputService` hört. Nach einer konfigurierbaren Verzögerung wird `lock_session()` aufgerufen.

6.  **Hintergrund-Task zum Verarbeiten von D-Bus-Signalen:**
    * Ein Task, der den Event-Stream von der `LoginDbusInterface` abonniert. Jedes empfangene D-Bus-Signal (z.B. `SessionNew`, `SessionRemoved`, `PrepareForShutdown`) wird vom `SessionManagerService` verarbeitet und an den `SessionManager` weitergeleitet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/session_manager/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::session_manager::error::SessionManagerError`
    * `crate::session_manager::manager::SessionManager`
    * `crate::session_manager::data_types::SessionInfo`
    * `crate::session_manager::login_service::LoginService`
    * `crate::session_manager::display_manager_interface::DisplayManagerInterface`
    * `crate::session_manager::dbus_interface::LoginDbusInterface`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
    * `crate::input_service::InputService`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `futures::stream::StreamExt`

**Kommunikationsmuster:**

* Ist der primäre Controller für die Sitzungsverwaltung.
* Interagiert mit dem `ConfigService` (oder `SettingsManagerService`) zum Speichern und Laden von Sitzungseinstellungen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten und andere Systemdienste über Sitzungsänderungen zu informieren (z.B. `SessionLocked`, `SessionUnlocked`, `UserLoggedIn`, `UserLoggedOut`).
* Empfängt Events vom `InputService` für Inaktivitätserkennung.
* Empfängt D-Bus-Signale von `LoginDbusInterface`.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes und funktionsfähiges Sitzungs-Subsystem, das die Benutzeranmeldung, -abmeldung und -sperrung sicher und zuverlässig verwaltet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `InputService`, `SessionManager`, `DisplayManagerInterface` und `LoginDbusInterface`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und der Verbindung zu den Mock-Schnittstellen.
    * Testen der Weiterleitung von API-Aufrufen an den `SessionManager` und `login_service`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von `SystemEvent::InactivityDetected` und Überprüfen, ob der Sperr-Prozess ausgelöst wird.
    * Simulieren von D-Bus-Signalen von `LoginDbusInterface` und Überprüfen, ob der `SessionManager` korrekt aufgerufen wird.
* **Integration Tests:**
    * Starten des `SessionManagerService` in einer Testumgebung mit einem echten `systemd-logind` (falls nicht gemockt).
    * Testen des Login/Logout-Flusses mit einem Testbenutzer.
    * Testen des Sperrens und Entsperrens der Sitzung.
    * Testen der automatischen Sperrung nach Inaktivität.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da PAM-Interaktion, D-Bus-Schnittstellen und kritische Systemintegration)

---
### **novade-system/src/session_manager/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `session_manager` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Sitzungs-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`SessionManagerError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum SessionManagerError {`
        * `#[error("Authentication failed: {0}")]`
        * `AuthenticationFailed(String),`
        * `#[error("Session already active.")]`
        * `SessionAlreadyActive,`
        * `#[error("No active session found.")]`
        * `NoActiveSession,`
        * `#[error("D-Bus connection failed: {0}")]`
        * `DBusConnectionFailed(String),`
        * `#[error("D-Bus method call failed: {0}")]`
        * `DBusMethodCallFailed(String),`
        * `#[error("PAM error: {0}")]`
        * `PamError(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Unknown session manager error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `anyhow::Error` (und potenziell `zbus::Error`, `pam::Error`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/session_manager/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `// zbus::Error (falls zbus direkt verwendet wird)`
    * `// pam::Error (falls pam verwendet wird)`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `session_manager` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Sitzungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/session_manager/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `session_manager` verwendet werden, um Sitzungsinformationen und zugehörige Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`SessionInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct SessionInfo {`
        * `pub session_id: String,`
        * `pub user_name: String,`
        * `pub uid: u32,`
        * `pub display_name: String,`
        * `pub session_type: SessionType,`
        * `pub is_active: bool,`
        * `pub is_locked: bool,`
        * `pub login_time: u64,` // Unix-Timestamp
        * `pub seat_id: Option<String>,`
        * `pub desktop_environment: String,` // z.B. "NovaDE"
    * `}`

2.  **`SessionType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum SessionType { User, LoginScreen, System }`

3.  **`SessionConfig` Struct (aus `settings_manager::data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct SessionConfig {`
        * `pub auto_lock_on_inactivity_enabled: bool,`
        * `pub auto_lock_delay_min: u32,`
        * `pub require_password_on_resume: bool,`
        * `pub default_display_manager: String,` // z.B. "NovaDE-DM", "LightDM", "GDM"
        * `pub enable_fast_user_switching: bool,`
        * `// ...`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/session_manager/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
* **Intern:**
    * `crate::settings_manager::data_types::SessionConfig` (oder direkter Import)

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Sitzungsinformationen im System.
* `SessionInfo` Objekte werden vom `SessionManager` erstellt und verwaltet.
* `SessionConfig` wird im `SettingsManagerService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Sitzungsverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/session_manager/login_service.rs**

**Verantwortlichkeit:**
Das `login_service` Modul ist für die Benutzerauthentifizierung und die Verwaltung von Anmelde- und Abmeldevorgängen auf niedriger Ebene zuständig. Es interagiert mit dem Pluggable Authentication Modules (PAM) Framework, um die Sicherheit und Flexibilität der Authentifizierung zu gewährleisten.

**Kern-Aufgaben (Tasks):**

1.  **`LoginService` Struct:**
    * `pub struct LoginService {`
        * `// Optional: pam_conv_handler für Interaktion mit PAM-Modulen (z.B. für 2FA, GUI-Prompts)`
    * `}`

2.  **`LoginService::new()` Funktion:**
    * `pub fn new() -> Self`
    * **Logik:** Einfache Initialisierung des Dienstes.

3.  **`LoginService::authenticate_user()` Methode:**
    * `pub async fn authenticate_user(&self, username: &str, password: &str) -> Result<(), SessionManagerError>`
    * **Logik (PAM-basiert):**
        * Initialisiert eine PAM-Transaktion (z.B. mit dem Dienstnamen "login" oder "nova_login").
        * Setzt den Benutzernamen für die PAM-Transaktion.
        * Verwendet `pam::authenticate()` um die Authentifizierung durchzuführen.
        * Bei Erfolg: Gibt `Ok(())` zurück.
        * Bei Fehler: Konvertiert PAM-Fehlercodes in `SessionManagerError::AuthenticationFailed`. Behandelt spezifische PAM-Antworten (z.B. `PAM_AUTH_ERR`, `PAM_CRED_INSUFFICIENT`).
        * **Hinweis:** Die Interaktion mit PAM ist synchron und könnte in einem `tokio::task::spawn_blocking` Block ausgeführt werden, um den async-Kontext nicht zu blockieren.

4.  **`LoginService::create_session()` Methode:**
    * `pub async fn create_session(&self, username: &str, session_type: SessionType) -> Result<SessionInfo, SessionManagerError>`
    * **Logik (PAM/systemd-logind-basiert):**
        * Nach erfolgreicher Authentifizierung:
            * Verwendet PAM, um eine neue Sitzung zu starten (z.B. `pam::open_session()`).
            * Interagiert mit `systemd-logind` über D-Bus (`LoginDbusInterface`), um eine neue Logind-Sitzung zu registrieren. Hierbei wird ein `session_id` von `logind` erhalten.
            * Setzt Umgebungsvariablen für die Sitzung (z.B. `DISPLAY`, `XDG_SESSION_TYPE`, `XDG_SESSION_ID`).
            * Gibt ein `SessionInfo` Objekt zurück.
        * **Hinweis:** Auch hier kann `spawn_blocking` für PAM-Operationen notwendig sein.

5.  **`LoginService::close_session()` Methode:**
    * `pub async fn close_session(&self, session_id: &str) -> Result<(), SessionManagerError>`
    * **Logik (PAM/systemd-logind-basiert):**
        * Interagiert mit `systemd-logind` über D-Bus, um die Sitzung zu beenden (`TerminateSession`).
        * Verwendet PAM, um die Sitzung zu schließen (`pam::close_session()`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/session_manager/login_service.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::session_manager::error::SessionManagerError`
    * `crate::session_manager::data_types::{SessionInfo, SessionType}`
    * `crate::session_manager::dbus_interface::LoginDbusInterface` (für Interaktion mit systemd-logind)
* **Extern:**
    * `pam` crate (oder ähnliche Schnittstelle zu PAM)
    * `tokio::task::spawn_blocking` (für synchrone PAM-Aufrufe)
    * `tracing`

**Kommunikationsmuster:**

* Wird vom `SessionManager` verwendet, um Authentifizierung und Sitzungserstellung/-beendigung durchzuführen.
* Direkte Interaktion mit dem System (PAM, D-Bus zu systemd-logind).

**Erwartete Ergebnisse/Outputs:**
Ein sicherer und zuverlässiger Authentifizierungs- und Sitzungsmanager auf Systemebene.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken der PAM-Interaktionen (z.B. durch eine Mock-Implementierung des `pam` Crate) und der `LoginDbusInterface`.
    * Testen von `authenticate_user` mit korrekten und inkorrekten Anmeldeinformationen.
    * Testen von `create_session`: Sicherstellen, dass eine `SessionInfo` mit korrekten Daten zurückgegeben wird und PAM- sowie D-Bus-Aufrufe erfolgen.
    * Testen von `close_session`: Sicherstellen, dass die entsprechenden PAM- und D-Bus-Aufrufe zum Beenden der Sitzung erfolgen.
* **Integration Tests (mit realer PAM-Konfiguration und systemd-logind):**
    * Einrichten einer Test-PAM-Konfiguration für NovaDE.
    * Ausführen von Login/Logout-Tests mit realen Benutzern und Passwörtern (in einer isolierten Umgebung).
    * Überprüfen, ob tatsächliche Systemressourcen (z.B. cgroups, Sitzungs-IDs) korrekt erstellt und bereinigt werden.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da PAM-Integration und korrekte Fehlerbehandlung komplex sind)

---
### **novade-system/src/session_manager/display_manager_interface.rs**

**Verantwortlichkeit:**
Dieses Modul ist für die Interaktion mit dem Display-Manager (DM) verantwortlich. Es kann Befehle an den DM senden, um Anmelde- und Abmeldebildschirme zu steuern, die Sitzung zu sperren oder zu entsperren, und um Benutzer zwischen Sitzungen zu wechseln. Die genaue Implementierung hängt vom verwendeten DM ab (z.B. GDM, LightDM, oder ein proprietärer NovaDE-DM).

**Kern-Aufgaben (Tasks):**

1.  **`DisplayManagerInterface` Trait:**
    * `pub trait DisplayManagerInterface: Send + Sync {`
        * `async fn show_login_screen(&self) -> Result<(), SessionManagerError>;`
        * `async fn hide_login_screen(&self) -> Result<(), SessionManagerError>;`
        * `async fn lock_screen(&self) -> Result<(), SessionManagerError>;`
        * `async fn unlock_screen(&self) -> Result<(), SessionManagerError>;`
        * `async fn switch_to_greeter(&self) -> Result<(), SessionManagerError>;` // Wechsel zum Anmeldebildschirm
        * `async fn switch_to_user_session(&self, session_id: &str) -> Result<(), SessionManagerError>;`
    * `}`

2.  **`NovaDEDisplayManager` Struct (Implementierung für NovaDE's eigenen DM):**
    * `pub struct NovaDEDisplayManager {`
        * `event_bus: EventBus,`
        * `// Interne Zustände oder Kanäle zur Kommunikation mit dem NovaDE-DM-Prozess`
    * `}`

3.  **`NovaDEDisplayManager::new()` Funktion:**
    * `pub fn new(event_bus: EventBus) -> Arc<Self>`
    * **Logik:** Initialisiert die Schnittstelle. Kann interne Kommunikationskanäle zum NovaDE-DM-Prozess aufbauen (z.B. IPC, Unix Sockets).

4.  **Implementierung des `DisplayManagerInterface` Trait für `NovaDEDisplayManager`:**
    * Alle Methoden delegieren an die interne Logik, um Befehle an den NovaDE-DM-Prozess zu senden.
    * `show_login_screen()`: Startet den DM-Prozess oder signalisiert ihm, den Anmeldebildschirm anzuzeigen.
    * `lock_screen()`: Signalisiert dem DM, den Sperrbildschirm anzuzeigen.
    * `unlock_screen()`: Signalisiert dem DM, den Sperrbildschirm zu schließen.

5.  **Optionale Implementierungen für andere DMs (z.B. LightDM, GDM):**
    * Falls NovaDE andere DMs unterstützen soll, wären hier weitere Implementierungen des `DisplayManagerInterface` Trait erforderlich, die deren spezifische D-Bus-APIs oder Konfigurationsdateien nutzen.
    * Z.B. `LightDMInterface` könnte D-Bus-Methoden auf `org.freedesktop.DisplayManager` aufrufen.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/session_manager/display_manager_interface.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::session_manager::error::SessionManagerError`
    * `novade_core::event_bus::EventBus`
* **Extern:**
    * `tokio` (für IPC/Async-Kommunikation)
    * `tracing`
    * `std::sync::Arc`
    * `zbus` (falls D-Bus-APIs anderer DMs verwendet werden)

**Kommunikationsmuster:**

* Wird vom `SessionManager` verwendet, um den Display-Manager zu steuern.
* Die Interaktion kann über D-Bus, Unix Sockets oder andere IPC-Mechanismen erfolgen.

**Erwartete Ergebnisse/Outputs:**
Eine Abstraktionsschicht zur Interaktion mit verschiedenen Display-Managern, beginnend mit einer spezifischen Implementierung für NovaDE's eigenen DM.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken der internen Kommunikationskanäle zum DM-Prozess.
    * Testen jeder Methode des `DisplayManagerInterface` und Überprüfen, ob die korrekten Nachrichten an den Mock-DM gesendet werden.
* **Integration Tests:**
    * Starten des `DisplayManagerInterface` zusammen mit einem simulierten oder echten NovaDE-DM-Prozess.
    * Auslösen von Aktionen wie `lock_screen()` und visuelle Überprüfung, ob der Sperrbildschirm erscheint.

**Geschätzter Aufwand:** Mittel bis Hoch (ca. 5-8 Tage, stark abhängig von der Komplexität der DM-Interaktion)

---
### **novade-system/src/session_manager/dbus_interface.rs**

**Verantwortlichkeit:**
Dieses Modul implementiert die D-Bus-Schnittstelle zu `systemd-logind` und potenziell zu `ConsoleKit` (für ältere Systeme oder Kompatibilität). Es ist verantwortlich für die Abfrage von Sitzungsinformationen und das Empfangen von Signalen über Sitzungsänderungen (z.B. neue Sitzung, Sitzung beendet, Benutzerwechsel).

**Kern-Aufgaben (Tasks):**

1.  **`LoginDbusInterface` Struct:**
    * `pub struct LoginDbusInterface {`
        * `manager_proxy: Login1ManagerProxy<'static>,` // Proxy für org.freedesktop.login1
        * `session_monitor_sender: mpsc::Sender<SessionEvent>,` // Sender für Sitzungs-Events
        * `event_bus: EventBus,`
    * `}`
    * `Login1ManagerProxy` ist ein Platzhalter für den `zbus::Proxy` für den `org.freedesktop.login1` Dienst.

2.  **`LoginDbusInterface::new()` Funktion:**
    * `pub async fn new(event_bus: EventBus) -> Result<Self, SessionManagerError>`
    * **Logik:**
        * Stellt eine Verbindung zum System D-Bus her.
        * Erzeugt einen Proxy für den `org.freedesktop.login1` Dienst und das Objekt `/org/freedesktop/login1`.
        * Startet einen Hintergrund-Task, der auf D-Bus-Signale von `systemd-logind` hört (z.B. `SessionNew`, `SessionRemoved`, `PrepareForSleep`, `UserNew`).
        * Initialisiert den `session_monitor_sender` und gibt den dazugehörigen `mpsc::Receiver` zurück.
        * Gibt `Self` zurück.
    * **Fehlerbehandlung:** `DBusConnectionFailed`, `DBusMethodCallFailed`.

3.  **`LoginDbusInterface::get_sessions()` Methode:**
    * `pub async fn get_sessions(&self) -> Result<Vec<SessionInfo>, SessionManagerError>`
    * **Logik:** Ruft die `ListSessions()` Methode auf dem `manager_proxy` auf und konvertiert die D-Bus-Antwort in eine Liste von `SessionInfo` Objekten.

4.  **`LoginDbusInterface::get_session_by_id()` Methode:**
    * `pub async fn get_session_by_id(&self, session_id: &str) -> Result<SessionInfo, SessionManagerError>`
    * **Logik:** Ruft die `GetSession()` Methode auf dem `manager_proxy` auf und konvertiert die D-Bus-Antwort.

5.  **`LoginDbusInterface::activate_session()` Methode:**
    * `pub async fn activate_session(&self, session_id: &str) -> Result<(), SessionManagerError>`
    * **Logik:** Ruft die `ActivateSession()` Methode auf dem `manager_proxy` auf.

6.  **`LoginDbusInterface::lock_session()` Methode:**
    * `pub async fn lock_session(&self, session_id: &str) -> Result<(), SessionManagerError>`
    * **Logik:** Ruft die `Lock()` Methode auf dem D-Bus-Objekt für die spezifische Sitzung auf (erfordert einen separaten Proxy für die Sitzung selbst).

7.  **`LoginDbusInterface::unlock_session()` Methode:**
    * `pub async fn unlock_session(&self, session_id: &str) -> Result<(), SessionManagerError>`
    * **Logik:** Ruft die `Unlock()` Methode auf dem D-Bus-Objekt für die spezifische Sitzung auf.

8.  **Hintergrund-Task zum Abonnieren von logind-Signalen:**
    * Ein Task, der auf D-Bus-Signale von `org.freedesktop.login1` hört:
        * Bei `SessionNew` Signal: Erstellt ein `SessionInfo` Objekt und sendet es über `session_monitor_sender`. Sendet `SystemEvent::UserLoggedIn`.
        * Bei `SessionRemoved` Signal: Sendet `SystemEvent::UserLoggedOut`.
        * Bei `PrepareForSleep` / `PrepareForShutdown`: Sendet `SystemEvent::SystemPreparingForSleep` / `SystemPreparingForShutdown`.
        * Bei `ActiveSessionChanged`: Sendet `SystemEvent::ActiveSessionChanged`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/session_manager/dbus_interface.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::session_manager::error::SessionManagerError`
    * `crate::session_manager::data_types::SessionInfo`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `zbus` crate (für D-Bus-Kommunikation)
    * `tokio::sync::mpsc`
    * `tracing`

**Kommunikationsmuster:**

* Wird vom `SessionManagerService` und `LoginService` verwendet.
* Bietet eine Abstraktion über die D-Bus-API von `systemd-logind`.
* Sendet D-Bus-Signale über einen Kanal an den `SessionManager` zur internen Verarbeitung.
* Sendet `SystemEvent`s an den `EventBus`.

**Erwartete Ergebnisse/Outputs:**
Eine robuste Schnittstelle zur Interaktion mit `systemd-logind` für Sitzungsverwaltung auf niedriger Ebene.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking von `zbus`):**
    * Mocken der `zbus::Connection` und der D-Bus-Proxies.
    * Testen der `new` Funktion und der Proxy-Erstellung.
    * Simulieren von D-Bus-Antworten für `get_sessions` und `get_session_by_id` und Überprüfen der korrekten `SessionInfo`-Konvertierung.
    * Simulieren von D-Bus-Methodenaufrufen (`activate_session`, `lock_session`) und Überprüfen, ob die korrekten D-Bus-Aufrufe erfolgen.
    * Simulieren von `logind` D-Bus-Signalen (`SessionNew`, `SessionRemoved`) und Überprüfen, ob `session_monitor_sender` korrekte Events erhält und `SystemEvent`s gesendet werden.
* **Integration Tests (mit realem D-Bus):**
    * Starten des `LoginDbusInterface` in einer Testumgebung mit laufendem `systemd-logind`.
    * Abfragen der aktuellen Sitzungen.
    * Simulieren von Benutzerwechseln oder An- und Abmeldungen (falls möglich über Test-Tools) und Überprüfen, ob die Signale empfangen werden.

**Geschätzter Aufwand:** Hoch (ca. 6-9 Tage, da komplexe D-Bus-Protokoll-Implementierung und Signal-Handling)

---
### **novade-system/src/session_manager/manager.rs**

**Verantwortlichkeit:**
Der `SessionManager` ist die Kernlogik des Sitzungs-Subsystems. Er verwaltet den internen Zustand der Benutzersitzungen, orchestratiert den Login-/Logout-Prozess, handhabt das Sperren und Entsperren und reagiert auf systemweite Sitzungsereignisse.

**Kern-Aufgaben (Tasks):**

1.  **`SessionManager` Struct:**
    * `pub struct SessionManager {`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `input_service: Arc<InputService>,`
        * `login_service: Arc<LoginService>,`
        * `display_manager_interface: Arc<dyn DisplayManagerInterface>,`
        * `dbus_interface: Arc<LoginDbusInterface>,`
        * `current_session_info: RwLock<Option<SessionInfo>>,`
        * `current_config: RwLock<SessionConfig>,`
        * `inactivity_timer: RwLock<Option<tokio::task::JoinHandle<()>>>,`
    * `}`

2.  **`SessionManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus, input_service: Arc<InputService>, login_service: Arc<LoginService>, display_manager_interface: Arc<dyn DisplayManagerInterface>, dbus_interface: Arc<LoginDbusInterface>) -> Result<Self, SessionManagerError>`
    * **Logik:**
        * Initialisiert alle Felder.
        * Lädt die initiale `SessionConfig` aus dem `config_service`.
        * Versucht, die aktuelle Sitzungsinformation über `dbus_interface.get_sessions()` abzurufen (z.B. wenn NovaDE während einer bestehenden Sitzung startet).
        * Startet einen Hintergrund-Task, der auf Inaktivitäts-Events vom `InputService` hört, um den Inaktivitätstimer zu verwalten.
        * Startet einen Hintergrund-Task, der auf `SessionEvent`s von `dbus_interface` hört.
        * Gibt `Self` zurück.

3.  **`SessionManager::login_user()` Methode:**
    * `pub async fn login_user(&self, username: &str, password: &str) -> Result<(), SessionManagerError>`
    * **Logik:**
        * Ruft `login_service.authenticate_user()` auf.
        * Bei Erfolg: Ruft `login_service.create_session()` auf.
        * Aktualisiert `current_session_info`.
        * Ruft `display_manager_interface.hide_login_screen()` auf.
        * Sendet `SystemEvent::UserLoggedIn(session_info.clone())` an den `EventBus`.
        * Startet den Inaktivitätstimer, falls `auto_lock_on_inactivity_enabled`.

4.  **`SessionManager::logout_user()` Methode:**
    * `pub async fn logout_user(&self) -> Result<(), SessionManagerError>`
    * **Logik:**
        * Stoppt den Inaktivitätstimer.
        * Ruft `login_service.close_session()` für die aktuelle Sitzung auf.
        * Ruft `display_manager_interface.show_login_screen()` oder `switch_to_greeter()` auf.
        * Setzt `current_session_info` auf `None`.
        * Sendet `SystemEvent::UserLoggedOut`.

5.  **`SessionManager::lock_session()` Methode:**
    * `pub async fn lock_session(&self) -> Result<(), SessionManagerError>`
    * **Logik:**
        * Überprüft, ob eine Sitzung aktiv ist.
        * Ruft `display_manager_interface.lock_screen()` auf.
        * Aktualisiert `current_session_info.is_locked = true`.
        * Sendet `SystemEvent::SessionLocked`.
        * Stoppt den Inaktivitätstimer.

6.  **`SessionManager::unlock_session()` Methode:**
    * `pub async fn unlock_session(&self, password: &str) -> Result<(), SessionManagerError>`
    * **Logik:**
        * Ruft `login_service.authenticate_user()` auf (mit dem Benutzernamen der gesperrten Sitzung).
        * Bei Erfolg: Ruft `display_manager_interface.unlock_screen()` auf.
        * Aktualisiert `current_session_info.is_locked = false`.
        * Sendet `SystemEvent::SessionUnlocked`.
        * Startet den Inaktivitätstimer neu.

7.  **`SessionManager::switch_to_user_session()` Methode:**
    * `pub async fn switch_to_user_session(&self, username: &str) -> Result<(), SessionManagerError>`
    * **Logik:**
        * Findet die Sitzungs-ID des Zielbenutzers.
        * Ruft `display_manager_interface.switch_to_user_session()` auf.
        * Aktualisiert `current_session_info` und sendet `SystemEvent::ActiveSessionChanged`.

8.  **`SessionManager::get_current_session_info()` Methode:**
    * `pub async fn get_current_session_info(&self) -> Option<SessionInfo>`
    * **Logik:** Gibt eine Kopie von `current_session_info` zurück.

9.  **`SessionManager::handle_inactivity_event()` Methode (intern, durch den Inaktivitätstimer ausgelöst):**
    * `pub async fn handle_inactivity_event(&self)`
    * **Logik:**
        * Wenn `auto_lock_on_inactivity_enabled` ist, ruft `lock_session()` auf.

10. **`SessionManager::handle_dbus_session_event()` Methode (intern, vom `SessionManagerService` aufgerufen):**
    * `pub async fn handle_dbus_session_event(&self, event: SessionEvent)`
    * **Logik:**
        * Verarbeitet Events von `LoginDbusInterface` (z.B. `SessionNew`, `SessionRemoved`, `PrepareForSleep`).
        * Aktualisiert `current_session_info` entsprechend.
        * Sendet relevante `SystemEvent`s an den `EventBus`.

11. **`SessionManager::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: SessionConfig)`
    * **Logik:** Aktualisiert die interne `current_config` und passt den Inaktivitätstimer an.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/session_manager/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::session_manager::error::SessionManagerError`
    * `crate::session_manager::data_types::{SessionInfo, SessionType, SessionConfig}`
    * `crate::session_manager::login_service::LoginService`
    * `crate::session_manager::display_manager_interface::{DisplayManagerInterface, NovaDEDisplayManager}`
    * `crate::session_manager::dbus_interface::{LoginDbusInterface, SessionEvent}`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
    * `crate::input_service::InputService`
* **Extern:**
    * `tokio::sync::RwLock`
    * `tokio::time::{sleep, Duration}`
    * `tokio::task::JoinHandle`
    * `std::sync::Arc`
    * `tracing`

**Kommunikationsmuster:**

* Ist die zentrale Logik für die Sitzungsverwaltung.
* Empfängt Events von `InputService` und `LoginDbusInterface`.
* Sendet `SystemEvent`s an den `EventBus` bei allen relevanten Sitzungs-Änderungen.
* Interagiert mit `LoginService` für Authentifizierung und Sitzungs-Öffnen/-Schließen.
* Interagiert mit `DisplayManagerInterface` zur Steuerung des Anmelde- und Sperrbildschirms.
* Interagiert mit `ConfigService` für Konfigurations-Updates.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Sitzungs-Manager, der Benutzeranmeldung, -abmeldung, Sperrung und Entsperrung sicher und kontextsensitiv handhabt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken aller Abhängigkeiten (`ConfigService`, `EventBus`, `InputService`, `LoginService`, `DisplayManagerInterface`, `LoginDbusInterface`).
    * Testen von `new`: Sicherstellen, dass initiale Konfiguration und Status geladen werden.
    * Testen des Login-Flows (`login_user`): Überprüfen, ob Authentifizierung, Sitzungserstellung und DM-Interaktionen korrekt delegiert und Events gesendet werden.
    * Testen des Logout-Flows (`logout_user`): Überprüfen der korrekten Schließung und Events.
    * Testen von `lock_session` und `unlock_session` mit Authentifizierung.
    * Testen der Inaktivitätserkennung und des automatischen Sperrens.
    * Simulieren von D-Bus-Sitzungsereignissen (`handle_dbus_session_event`) und Überprüfen, ob der interne Zustand und die gesendeten Events korrekt sind.
    * Testen von `switch_to_user_session`.
* **Integration Tests:**
    * Starten des `SessionManager` mit echten oder simulierten Abhängigkeiten.
    * Simulieren kompletter Login/Logout/Lock/Unlock-Zyklen und Überprüfen der Konsistenz der internen Zustände und der ausgelösten `SystemEvent`s.
    * Testen der Interaktion mit dem Display-Manager und PAM (falls Integrationstests dies zulassen).

**Geschätzter Aufwand:** Sehr hoch (ca. 10-15 Tage, da es die Orchestrierung vieler kritischer Komponenten umfasst)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `power_management_service`, widmen wir uns `session_manager`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/session_manager/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/session_manager/data_types.rs`**: Definition der Sitzungs-bezogenen Datentypen.
3.  **`novade-system/src/session_manager/login_service.rs`**: Implementierung der Authentifizierung und der grundlegenden Sitzungserstellung/Schließung (PAM-Interaktion). Dies ist eine Basis für den Manager.
4.  **`novade-system/src/session_manager/dbus_interface.rs`**: Implementierung der D-Bus-Schnittstelle zu `systemd-logind`. Dies ist notwendig, um System-Sitzungsereignisse zu überwachen und Systemaktionen auszulösen.
5.  **`novade-system/src/session_manager/display_manager_interface.rs`**: Abstraktionsschicht und Implementierung für die Interaktion mit dem Display-Manager. Diese Schnittstelle ist kritisch für die UI-bezogene Sitzungssteuerung.
6.  **`novade-system/src/session_manager/manager.rs`**: Die Kernlogik, die alle oben genannten Komponenten orchestriert, um die vollständige Sitzungsverwaltung zu ermöglichen.
7.  **`novade-system/src/session_manager/mod.rs`**: Das Hauptmodul, das den Manager und alle seine Sub-Komponenten initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/session_manager` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/system_monitor` Verzeichnisses.
---
### **novade-system/src/system_monitor/mod.rs**

**Verantwortlichkeit:**
Das `system_monitor` Modul ist für die Sammlung, Verarbeitung und Bereitstellung von Systemressourcendaten zuständig. Es überwacht CPU-Auslastung, Speicherverbrauch, Festplattenaktivität, Netzwerknutzung und andere wichtige Systemmetriken. Diese Daten sind entscheidend für die Anzeige im NovaDE-Systemmonitor-Widget, für Leistungsoptimierungen und zur Erkennung von Systemengpässen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/system_monitor/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Systemmonitor-Operationen)
    * `manager.rs` (Logik für die Datensammlung, -verarbeitung und Aggregation)
    * `data_types.rs` (Definition von Systemmetrik-Datentypen)
    * `sysinfo_collector.rs` (Implementierung der Datensammlung mittels `sysinfo` Crate)
    * `procfs_collector.rs` (Optionale Implementierung der Datensammlung mittels `procfs` Crate für detailliertere Linux-spezifische Daten)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Systemmonitor-Subsystems:**
    * `pub async fn initialize_system_monitor_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<SystemMonitorService, SystemMonitorError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::SystemMonitorManager`.
        * Initialisiert den `sysinfo_collector::SysinfoCollector` (und optional `procfs_collector::ProcfsCollector`).
        * Startet einen periodischen Hintergrund-Task, der in konfigurierbaren Intervallen (z.B. alle 1-5 Sekunden) Systemdaten sammelt und an den `SystemMonitorManager` sendet.
        * Lädt initiale Konfigurationen aus dem `config_service` (z.B. Abtastintervalle, zu überwachende Komponenten).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Gibt ein gebündeltes `SystemMonitorService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder der Datenkollektoren.

2.  **`SystemMonitorService` Struct:**
    * `pub struct SystemMonitorService {`
        * `manager: Arc<SystemMonitorManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
    * `}`
    * Dient als Container und Zugangspunkt für die Systemmonitor-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `SystemMonitorService` exponiert Methoden zum Abrufen von Systemmetriken.
    * `pub async fn get_current_system_metrics(&self) -> Result<SystemMetrics, SystemMonitorError>`
        * **Logik:** Delegiert an den `SystemMonitorManager`, um die zuletzt gesammelten aggregierten Systemmetriken abzurufen.
    * `pub async fn get_process_list(&self) -> Result<Vec<ProcessInfo>, SystemMonitorError>`
        * **Logik:** Delegiert an den `SystemMonitorManager`, um eine Liste der aktuell laufenden Prozesse abzurufen.
    * `pub async fn kill_process(&self, pid: u32) -> Result<(), SystemMonitorError>`
        * **Logik:** Delegiert an den `SystemMonitorManager`, der dann den `sysinfo_collector` (oder direkten OS-Aufruf) verwendet, um den Prozess zu beenden.
    * `pub async fn set_monitoring_interval_ms(&self, interval_ms: u64) -> Result<(), SystemMonitorError>`
        * **Logik:** Aktualisiert die Konfiguration (über `SettingsManagerService` oder direkt `config_service`) und informiert den `SystemMonitorManager`, der den Datensammlungs-Task neu startet oder anpasst. Löst `SystemEvent::ConfigChanged` aus.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `SystemMonitorService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Überwachungseinstellungen geändert werden, werden die Sub-Komponenten (`SystemMonitorManager`) informiert.

5.  **Hintergrund-Task zur periodischen Datensammlung:**
    * Ein Task, der in einem konfigurierbaren Intervall (z.B. von `current_config.monitoring_interval_ms`) den `sysinfo_collector` aufruft, um `SystemMetrics` zu sammeln, und diese dann über einen Kanal an den `SystemMonitorManager` sendet.
    * Sendet `SystemEvent::SystemMetricsUpdated(metrics)` an den `EventBus` nach jeder erfolgreichen Sammlung.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/system_monitor/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::system_monitor::error::SystemMonitorError`
    * `crate::system_monitor::manager::SystemMonitorManager`
    * `crate::system_monitor::data_types::{SystemMetrics, ProcessInfo, SystemMonitorConfig}`
    * `crate::system_monitor::sysinfo_collector::SysinfoCollector`
    * `crate::system_monitor::procfs_collector::ProcfsCollector` (optional)
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tokio::time::{interval, Duration}`
    * `tracing`
    * `std::sync::Arc`
    * `futures::stream::StreamExt`

**Kommunikationsmuster:**

* Ist der primäre Controller für die Systemüberwachung.
* Interagiert mit dem `ConfigService` (oder `SettingsManagerService`) zum Speichern und Laden von Überwachungseinstellungen.
* Sendet `SystemEvent`s an den `EventBus`, um UI-Komponenten und andere Systemdienste über aktualisierte Systemmetriken zu informieren.
* Periodische Abfragen von `SysinfoCollector`.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Systemmonitor-Subsystem, das kontinuierlich Systemressourcendaten sammelt und bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `SystemMonitorManager` und `SysinfoCollector`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und des Starts des Sammel-Tasks.
    * Testen der Weiterleitung von API-Aufrufen an den `SystemMonitorManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob der Sammel-Task korrekt neu konfiguriert wird.
    * Simulieren von periodischen Datenlieferungen vom Mock-`SysinfoCollector` und Überprüfen, ob der `SystemMonitorManager` korrekt aufgerufen und `SystemEvent::SystemMetricsUpdated` gesendet wird.
* **Integration Tests:**
    * Starten des `SystemMonitorService` mit realen `SysinfoCollector` Instanzen.
    * Überprüfen, ob periodisch korrekte Systemmetriken gesammelt und über den `EventBus` gesendet werden (z.B. durch Abonnieren des `SystemEvent::SystemMetricsUpdated`).
    * Testen der `kill_process` Funktionalität auf einem Testprozess (Vorsicht, dass dies keine kritischen Systemprozesse betrifft).

**Geschätzter Aufwand:** Hoch (ca. 6-9 Tage, da periodische Datensammlung, Fehlerbehandlung und Event-Propagierung notwendig sind)

---
### **novade-system/src/system_monitor/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `system_monitor` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Systemüberwachungs-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`SystemMonitorError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum SystemMonitorError {`
        * `#[error("Failed to collect system data: {0}")]`
        * `DataCollectionFailed(String),`
        * `#[error("Process with PID {0} not found or permission denied.")]`
        * `ProcessNotFoundOrDenied(u32),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Unknown system monitor error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `anyhow::Error` (und potenziell `sysinfo::Error` falls direkt verwendet).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/system_monitor/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `// sysinfo::Error (falls sysinfo direkt verwendet wird)`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `system_monitor` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Systemüberwachungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/system_monitor/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `system_monitor` verwendet werden, um Systemmetriken, Prozessinformationen und zugehörige Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`SystemMetrics` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct SystemMetrics {`
        * `pub cpu_usage_percent: f32,` // Aggregierte CPU-Auslastung (0.0 - 100.0)
        * `pub memory_total_bytes: u64,`
        * `pub memory_used_bytes: u64,`
        * `pub swap_total_bytes: u64,`
        * `pub swap_used_bytes: u64,`
        * `pub disk_read_bytes_per_sec: u64,`
        * `pub disk_write_bytes_per_sec: u64,`
        * `pub network_rx_bytes_per_sec: u64,`
        * `pub network_tx_bytes_per_sec: u64,`
        * `pub processes_running: u64,`
        * `pub uptime_seconds: u66,`
        * `pub kernel_version: String,`
        * `pub os_version: String,`
        * `pub host_name: String,`
        * `// Weitere detaillierte Metriken könnten hier hinzugefügt werden (z.B. pro CPU-Kern, pro Disk)`
    * `}`

2.  **`ProcessInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct ProcessInfo {`
        * `pub pid: u32,`
        * `pub parent_pid: Option<u33>,`
        * `pub name: String,`
        * `pub status: String,` // z.B. "Running", "Sleeping", "Stopped"
        * `pub cpu_usage_percent: f32,`
        * `pub memory_usage_bytes: u64,`
        * `pub command: String,`
        * `pub exe_path: String,`
        * `pub user_id: Option<u32>,`
        * `pub group_id: Option<u32>,`
        * `pub start_time_ms: u64,`
    * `}`

3.  **`SystemMonitorConfig` Struct (aus `settings_manager::data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct SystemMonitorConfig {`
        * `pub monitoring_interval_ms: u64,`
        * `pub enable_cpu_monitoring: bool,`
        * `pub enable_memory_monitoring: bool,`
        * `pub enable_disk_io_monitoring: bool,`
        * `pub enable_network_io_monitoring: bool,`
        * `pub history_retention_seconds: u64,` // Wie lange historische Daten gespeichert werden
        * `// ...`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/system_monitor/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Systemüberwachungsinformationen im System.
* `SystemMetrics` und `ProcessInfo` Objekte werden vom `SystemMonitorManager` generiert und verwaltet.
* `SystemMonitorConfig` wird im `SettingsManagerService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Systemüberwachung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/system_monitor/sysinfo_collector.rs**

**Verantwortlichkeit:**
Dieses Modul ist eine Wrapper-Schicht um das `sysinfo` Crate, um Systemmetriken und Prozessinformationen zu sammeln. Es bietet eine plattformübergreifende Möglichkeit, auf diese Daten zuzugreifen.

**Kern-Aufgaben (Tasks):**

1.  **`SysinfoCollector` Struct:**
    * `pub struct SysinfoCollector {`
        * `sys: sysinfo::System,`
        * `last_network_rx: u66,` // Für Delta-Berechnung der Netzwerk-IO
        * `last_network_tx: u66,`
        * `last_disk_read: u66,` // Für Delta-Berechnung der Disk-IO
        * `last_disk_write: u66,`
    * `}`

2.  **`SysinfoCollector::new()` Funktion:**
    * `pub fn new() -> Self`
    * **Logik:** Erstellt eine neue Instanz von `sysinfo::System` und initialisiert die Delta-Zähler.

3.  **`SysinfoCollector::update_all()` Methode:**
    * `pub fn update_all(&mut self) -> Result<(), SystemMonitorError>`
    * **Logik:**
        * Ruft `sys.refresh_all()` oder spezifische `refresh_` Methoden auf, um alle Systeminformationen zu aktualisieren.
        * **Hinweis:** Dies ist ein potenziell teurer Vorgang und sollte im `spawn_blocking` Kontext des `SystemMonitorManager` aufgerufen werden.

4.  **`SysinfoCollector::collect_system_metrics()` Methode:**
    * `pub fn collect_system_metrics(&mut self) -> Result<SystemMetrics, SystemMonitorError>`
    * **Logik:**
        * Ruft `self.update_all()` auf, um die Daten zu aktualisieren.
        * Extrahiert CPU-Auslastung (`sys.global_cpu_info().cpu_usage()`).
        * Extrahiert Speicherinformationen (`sys.total_memory()`, `sys.used_memory()`).
        * Extrahiert Swap-Informationen (`sys.total_swap()`, `sys.used_swap()`).
        * Berechnet Disk-IO-Deltas (`sys.disks()`, `sys.disks_total_written_bytes()`, `sys.disks_total_read_bytes()`).
        * Berechnet Netzwerk-IO-Deltas (`sys.networks()`, `sys.networks().iter().total_received_bytes()`, `total_transmitted_bytes()`).
        * Zählt laufende Prozesse (`sys.processes().len()`).
        * Holt Uptime, Kernel- und OS-Version, Hostname.
        * Baut ein `SystemMetrics` Objekt zusammen.
        * **Fehlerbehandlung:** Wandelt `sysinfo` Fehler (falls direkt exponiert) in `SystemMonitorError::DataCollectionFailed` um.

5.  **`SysinfoCollector::collect_process_list()` Methode:**
    * `pub fn collect_process_list(&mut self) -> Result<Vec<ProcessInfo>, SystemMonitorError>`
    * **Logik:**
        * Ruft `self.update_all()` auf.
        * Iteriert über `sys.processes()` und konvertiert jede `sysinfo::Process` in eine `ProcessInfo` Struktur.
        * Berechnet CPU-Nutzung pro Prozess.
        * **Fehlerbehandlung:** Behandelt potenzielle Fehler beim Zugriff auf Prozessinformationen.

6.  **`SysinfoCollector::kill_process()` Methode:**
    * `pub fn kill_process(&mut self, pid: u32) -> Result<(), SystemMonitorError>`
    * **Logik:**
        * Findet den Prozess mit `sys.process(sysinfo::Pid::from_u32(pid))`.
        * Ruft `process.kill()` auf.
        * **Fehlerbehandlung:** `ProcessNotFoundOrDenied`, `DataCollectionFailed` (falls Kill fehlschlägt).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/system_monitor/sysinfo_collector.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::system_monitor::error::SystemMonitorError`
    * `crate::system_monitor::data_types::{SystemMetrics, ProcessInfo}`
* **Extern:**
    * `sysinfo` crate
    * `tracing`
    * `tokio::task::spawn_blocking` (wird vom `SystemMonitorManager` verwendet, nicht hier im Modul selbst)

**Kommunikationsmuster:**

* Wird vom `SystemMonitorManager` instanziiert und verwendet, um Systemdaten zu sammeln.
* Bietet die Low-Level-Interaktion mit dem Betriebssystem über das `sysinfo` Crate.

**Erwartete Ergebnisse/Outputs:**
Ein funktionaler Datenkollektor, der zuverlässig Systemmetriken und Prozessinformationen über das `sysinfo` Crate bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking von `sysinfo` oder isolierten Umgebungen):**
    * Erstellen von Mock-Implementierungen für `sysinfo::System` oder Verwenden von Test-Binärdateien, die kontrollierte `sysinfo` Ausgaben liefern.
    * Testen von `collect_system_metrics` und `collect_process_list` mit vorab definierten `sysinfo` Daten.
    * Überprüfen der korrekten Umwandlung von `sysinfo`-Typen in NovaDE-`data_types`.
    * Testen der Delta-Berechnungen für Disk- und Netzwerk-IO.
    * Testen von `kill_process` mit einem Mock-Prozess.
* **Integration Tests (auf einer echten Maschine):**
    * Ausführen des Kollektors auf einem Testsystem und Überprüfen, ob die gesammelten Metriken den tatsächlichen Systemmetriken entsprechen (z.B. Vergleich mit `htop`, `free`, `iostat`).
    * Vorsichtige Tests von `kill_process` an einem nicht-kritischen, selbst gestarteten Testprozess.

**Geschätzter Aufwand:** Mittel (ca. 4-6 Tage, da `sysinfo`-Interaktion und Datenaggregation)

---
### **novade-system/src/system_monitor/procfs_collector.rs** (Optional, für Linux-spezifische Detaillierung)

**Verantwortlichkeit:**
Dieses optionale Modul ist eine spezialisierte Ergänzung zum `sysinfo_collector`, um detailliertere, Linux-spezifische Systemmetriken und Prozessinformationen direkt aus dem `/proc` und `/sys` Dateisystem zu sammeln. Es wird verwendet, wenn `sysinfo` nicht genügend Granularität oder spezifische Datenpunkte bietet.

**Kern-Aufgaben (Tasks):**

1.  **`ProcfsCollector` Struct:**
    * `pub struct ProcfsCollector {`
        * `// Optional: last_cpu_stats, last_net_dev_stats für Delta-Berechnungen`
    * `}`

2.  **`ProcfsCollector::new()` Funktion:**
    * `pub fn new() -> Result<Self, SystemMonitorError>`
    * **Logik:** Überprüft, ob `/proc` und `/sys` zugänglich sind. Initialisiert interne Zustände.

3.  **`ProcfsCollector::collect_detailed_cpu_metrics()` Methode:**
    * `pub fn collect_detailed_cpu_metrics(&mut self) -> Result<Vec<CpuCoreUsage>, SystemMonitorError>`
    * **Logik:**
        * Liest `/proc/stat`.
        * Parst CPU-Statistiken pro Kern und berechnet die Nutzung seit dem letzten Aufruf.
        * Gibt eine Liste von `CpuCoreUsage` (einem neuen Datentyp in `data_types.rs` für pro-Kern-Daten) zurück.

4.  **`ProcfsCollector::collect_detailed_network_metrics()` Methode:**
    * `pub fn collect_detailed_network_metrics(&mut self) -> Result<Vec<NetworkInterfaceMetrics>, SystemMonitorError>`
    * **Logik:**
        * Liest `/proc/net/dev`.
        * Parst Netzwerk-Statistiken pro Schnittstelle und berechnet Sende-/Empfangsraten.
        * Gibt eine Liste von `NetworkInterfaceMetrics` zurück.

5.  **`ProcfsCollector::collect_detailed_disk_metrics()` Methode:**
    * `pub fn collect_detailed_disk_metrics(&mut self) -> Result<Vec<DiskMetrics>, SystemMonitorError>`
    * **Logik:**
        * Liest `/proc/diskstats`.
        * Parst Disk-Statistiken und berechnet Lese-/Schreibaktivität, Warteschlangenlängen.
        * Gibt eine Liste von `DiskMetrics` zurück.

6.  **`ProcfsCollector::get_process_cmdline()` Methode:**
    * `pub fn get_process_cmdline(&self, pid: u32) -> Result<String, SystemMonitorError>`
    * **Logik:** Liest `/proc/<pid>/cmdline`.

7.  **`ProcfsCollector::get_process_environment()` Methode:**
    * `pub fn get_process_environment(&self, pid: u32) -> Result<HashMap<String, String>, SystemMonitorError>`
    * **Logik:** Liest `/proc/<pid>/environ`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/system_monitor/procfs_collector.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::system_monitor::error::SystemMonitorError`
    * `crate::system_monitor::data_types::{CpuCoreUsage, NetworkInterfaceMetrics, DiskMetrics}` (neue Typen)
* **Extern:**
    * `procfs` crate (oder direktes Lesen von `/proc` Dateien)
    * `std::collections::HashMap`
    * `tracing`
    * `tokio::fs` (für async File-I/O, falls direkt gelesen wird)
    * `tokio::io::AsyncReadExt`

**Kommunikationsmuster:**

* Wird optional vom `SystemMonitorManager` verwendet, um spezifische, tiefergehende Linux-Metriken zu erhalten, die über die Standard-`sysinfo`-Daten hinausgehen.
* Erfordert Lesezugriff auf das `/proc` und `/sys` Dateisystem.

**Erwartete Ergebnisse/Outputs:**
Ein spezialisierter Datenkollektor für Linux-Systeme, der fein granulare Systemmetriken bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Mocken des Dateisystems (z.B. mit `mock_fs` oder durch Erstellen temporärer `/proc`-Strukturen).
    * Testen der Parsing-Logik für `/proc/stat`, `/proc/net/dev` etc. mit Beispielinhalten.
    * Überprüfen der Delta-Berechnungen.
* **Integration Tests (auf einem Linux-System):**
    * Ausführen des Kollektors auf einem Linux-System und Vergleichen der Ausgabe mit nativen Tools wie `cat /proc/stat`, `ip -s link`, `iostat`.

**Geschätzter Aufwand:** Mittel (ca. 4-7 Tage, da Parsing von `/proc` Dateien und spezifische Linux-APIs)

---
### **novade-system/src/system_monitor/manager.rs**

**Verantwortlichkeit:**
Der `SystemMonitorManager` ist die Kernlogik des Systemmonitor-Subsystems. Er orchestriert die Datensammlung, aggregiert die Metriken, verwaltet historische Daten und stellt die konsolidierten Systeminformationen bereit. Er reagiert auf Konfigurationsänderungen und informiert andere Systemkomponenten über Aktualisierungen.

**Kern-Aufgaben (Tasks):**

1.  **`SystemMonitorManager` Struct:**
    * `pub struct SystemMonitorManager {`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `sysinfo_collector: Arc<tokio::sync::Mutex<SysinfoCollector>>,` // Mutex, da sysinfo nicht Sync ist
        * `procfs_collector: Option<Arc<tokio::sync::Mutex<ProcfsCollector>>>,` // Optional, mit Mutex
        * `current_metrics: RwLock<SystemMetrics>,`
        * `process_list: RwLock<Vec<ProcessInfo>>,`
        * `metrics_history: RwLock<Vec<(u64, SystemMetrics)>>,` // (Timestamp, Metrics)
        * `current_config: RwLock<SystemMonitorConfig>,`
        * `collection_task_handle: RwLock<Option<tokio::task::JoinHandle<()>>>,` // Handle zum Steuern des periodischen Tasks
    * `}`

2.  **`SystemMonitorManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<Self, SystemMonitorError>`
    * **Logik:**
        * Initialisiert alle Felder.
        * Erstellt eine Instanz von `SysinfoCollector`.
        * Erstellt optional eine Instanz von `ProcfsCollector` (nur auf Linux).
        * Lädt die initiale `SystemMonitorConfig` aus dem `config_service`.
        * Startet den periodischen `collection_task` über `self.start_collection_task()`.
        * Gibt `Self` zurück.

3.  **`SystemMonitorManager::start_collection_task()` Methode:**
    * `async fn start_collection_task(self: Arc<Self>)`
    * **Logik:**
        * Beendet den bestehenden Task, falls vorhanden.
        * Startet einen neuen `tokio::task::spawn` Task.
        * **Innerhalb des Tasks:**
            * Verwendet `tokio::time::interval` mit `current_config.monitoring_interval_ms`.
            * In jeder Iteration:
                * Ruft `tokio::task::spawn_blocking` auf, um die synchronen `sysinfo_collector.collect_system_metrics()` und `collect_process_list()` Methoden aufzurufen (oder `procfs_collector` Methoden).
                * Bei Erfolg:
                    * Aktualisiert `current_metrics` und `process_list`.
                    * Fügt neue Metriken zum `metrics_history` hinzu und bereinigt alte Einträge basierend auf `history_retention_seconds`.
                    * Sendet `SystemEvent::SystemMetricsUpdated(current_metrics.clone())` an den `EventBus`.
                * Bei Fehler: Loggt den Fehler.

4.  **`SystemMonitorManager::get_current_system_metrics()` Methode:**
    * `pub async fn get_current_system_metrics(&self) -> SystemMetrics`
    * **Logik:** Gibt eine Kopie der `current_metrics` zurück.

5.  **`SystemMonitorManager::get_process_list()` Methode:**
    * `pub async fn get_process_list(&self) -> Vec<ProcessInfo>`
    * **Logik:** Gibt eine Kopie der `process_list` zurück.

6.  **`SystemMonitorManager::get_metrics_history()` Methode:**
    * `pub async fn get_metrics_history(&self) -> Vec<(u64, SystemMetrics)>`
    * **Logik:** Gibt eine Kopie der `metrics_history` zurück.

7.  **`SystemMonitorManager::kill_process()` Methode:**
    * `pub async fn kill_process(&self, pid: u32) -> Result<(), SystemMonitorError>`
    * **Logik:**
        * Ruft `tokio::task::spawn_blocking` auf, um `sysinfo_collector.lock().await.kill_process(pid)` aufzurufen.
        * Bei Erfolg: Sendet `SystemEvent::ProcessKilled(pid)`.

8.  **`SystemMonitorManager::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: SystemMonitorConfig)`
    * **Logik:**
        * Aktualisiert die interne `current_config`.
        * Ruft `self.start_collection_task()` erneut auf, um den periodischen Sammel-Task mit der neuen Konfiguration neu zu starten (insbesondere bei Änderung von `monitoring_interval_ms`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/system_monitor/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::system_monitor::error::SystemMonitorError`
    * `crate::system_monitor::data_types::{SystemMetrics, ProcessInfo, SystemMonitorConfig}`
    * `crate::system_monitor::sysinfo_collector::SysinfoCollector`
    * `crate::system_monitor::procfs_collector::ProcfsCollector` (optional)
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::sync::{RwLock, Mutex}`
    * `tokio::time::{interval, Duration}`
    * `tokio::task::{JoinHandle, spawn, spawn_blocking}`
    * `std::sync::Arc`
    * `tracing`
    * `futures::StreamExt` (für Interval-Stream)

**Kommunikationsmuster:**

* Ist die zentrale Logik für die Systemüberwachung.
* Orchestriert die Datensammlung mit `SysinfoCollector` (und optional `ProcfsCollector`).
* Sendet `SystemEvent`s an den `EventBus` bei aktualisierten Metriken und Prozessereignissen.
* Interagiert mit `ConfigService` für Konfigurations-Updates.

**Erwartete Ergebnisse/Outputs:**
Ein robuster System-Monitor-Manager, der kontinuierlich Systemdaten sammelt, verarbeitet und für Abfragen und Events bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `SysinfoCollector` und `ProcfsCollector`.
    * Testen von `new`: Sicherstellen, dass initiale Konfiguration geladen und der Sammel-Task gestartet wird.
    * Testen von `start_collection_task`: Simulieren von Intervallen und Überprüfen, ob `collect_system_metrics` und `collect_process_list` des Mock-Kollektors aufgerufen werden, und ob `SystemMetricsUpdated` Events gesendet werden.
    * Testen der `metrics_history` Verwaltung (Hinzufügen, Bereinigen).
    * Testen von `get_current_system_metrics`, `get_process_list`, `get_metrics_history`.
    * Testen von `kill_process`: Überprüfen, ob der Aufruf an den Mock-Kollektor delegiert und `ProcessKilled` Event gesendet wird.
    * Testen von `update_config` und dem Neustart des Sammel-Tasks.
* **Integration Tests:**
    * Starten des `SystemMonitorManager` mit realen `SysinfoCollector` (und `ProcfsCollector`) Instanzen.
    * Überprüfen, ob Metriken korrekt gesammelt, aggregiert und in der Historie gespeichert werden.
    * Überprüfen der End-to-End-Funktionalität von `kill_process` mit einem Testprozess.

**Geschätzter Aufwand:** Sehr hoch (ca. 10-15 Tage, da periodische, asynchrone Datensammlung, Sperrmechanismen, Historienverwaltung und Interaktion mit synchronen Low-Level-Kollektoren)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `session_manager`, widmen wir uns `system_monitor`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/system_monitor/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/system_monitor/data_types.rs`**: Definition der Systemmetrik-Datentypen. Hier müssen auch die neuen Typen für pro-Kern-CPU, Netzwerkschnittstellen und Disks für `procfs_collector` definiert werden, falls dieser verwendet wird.
3.  **`novade-system/src/system_monitor/sysinfo_collector.rs`**: Implementierung des plattformübergreifenden Datenkollektors. Dies ist die primäre Datenquelle.
4.  **`novade-system/src/system_monitor/procfs_collector.rs`**: Implementierung des optionalen, Linux-spezifischen Datenkollektors, falls detailliertere Metriken benötigt werden. Dies kann parallel zum `sysinfo_collector` entwickelt werden, da es eine Ergänzung ist.
5.  **`novade-system/src/system_monitor/manager.rs`**: Die Kernlogik, die die Datenkollektoren orchestriert, Metriken aggregiert, den Zustand verwaltet und die Historie führt.
6.  **`novade-system/src/system_monitor/mod.rs`**: Das Hauptmodul, das den Manager und seine Sub-Komponenten initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/system_monitor` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/wallpaper_service` Verzeichnisses.
---
### **novade-system/src/wallpaper_service/mod.rs**

**Verantwortlichkeit:**
Das `wallpaper_service` Modul verwaltet die Desktop-Hintergrundbilder (Wallpapers) von NovaDE. Es ist verantwortlich für das Laden, Anwenden und Wechseln von Wallpapers, sowohl statisch als auch dynamisch (z.B. Diashows). Es interagiert mit dem `config_service` zum Speichern von Präferenzen und mit dem `event_bus`, um UI-Komponenten über Änderungen zu informieren.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/wallpaper_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Wallpaper-Operationen)
    * `manager.rs` (Logik für die Wallpaper-Verwaltung, Diashows, Pfad-Auflösung)
    * `data_types.rs` (Definition von Wallpaper-bezogenen Datentypen)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Wallpaper-Subsystems:**
    * `pub async fn initialize_wallpaper_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<WallpaperService, WallpaperError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::WallpaperManager`.
        * Lädt die initiale Wallpaper-Konfiguration aus dem `config_service` (z.B. aktuelles Wallpaper, Diashow-Einstellungen, Pfade).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Startet optional einen Hintergrund-Task, um die Diashow zu verwalten, falls aktiviert.
        * Gibt ein gebündeltes `WallpaperService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder beim Laden der initialen Konfiguration.

2.  **`WallpaperService` Struct:**
    * `pub struct WallpaperService {`
        * `manager: Arc<WallpaperManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
    * `}`
    * Dient als Container und Zugangspunkt für die Wallpaper-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `WallpaperService` exponiert Methoden zur Steuerung und Abfrage des Wallpapers.
    * `pub async fn set_static_wallpaper(&self, image_path: &Path) -> Result<(), WallpaperError>`
        * **Logik:** Delegiert an den `manager`, um das angegebene Bild als statisches Wallpaper zu setzen. Aktualisiert den `config_service` und sendet `SystemEvent::WallpaperChanged`.
    * `pub async fn set_slideshow_wallpaper(&self, folder_path: &Path, interval_seconds: u64, shuffle: bool) -> Result<(), WallpaperError>`
        * **Logik:** Delegiert an den `manager`, um eine Diashow zu starten. Aktualisiert den `config_service` und sendet `SystemEvent::WallpaperChanged`. Startet den Diashow-Timer.
    * `pub async fn stop_slideshow(&self) -> Result<(), WallpaperError>`
        * **Logik:** Delegiert an den `manager`, um eine laufende Diashow zu stoppen. Aktualisiert den `config_service`.
    * `pub async fn get_current_wallpaper_info(&self) -> Result<WallpaperInfo, WallpaperError>`
        * **Logik:** Delegiert an den `manager`, um Informationen über das aktuell eingestellte Wallpaper (Pfad, Typ) abzurufen.
    * `pub async fn get_available_wallpapers(&self, search_path: Option<&Path>) -> Result<Vec<PathBuf>, WallpaperError>`
        * **Logik:** Delegiert an den `manager`, um verfügbare Wallpaper-Bilder in den Standardpfaden oder einem angegebenen Pfad zu finden.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `WallpaperService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Wallpaper-Einstellungen geändert werden, werden die Sub-Komponenten (`WallpaperManager`) informiert und Aktionen wie das Neustarten der Diashow ausgelöst.

5.  **Hintergrund-Task zur Verwaltung der Diashow (im Manager implementiert, vom Service gestartet):**
    * Wenn eine Diashow aktiviert ist, wird ein periodischer Timer gestartet. Bei jedem Tick wählt der `WallpaperManager` das nächste Bild und wendet es an.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/wallpaper_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::wallpaper_service::error::WallpaperError`
    * `crate::wallpaper_service::manager::WallpaperManager`
    * `crate::wallpaper_service::data_types::WallpaperInfo`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `std::path::{Path, PathBuf}`
    * `futures::stream::StreamExt`

**Kommunikationsmuster:**

* Ist der primäre Controller für die Wallpaper-Verwaltung.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Wallpaper-Einstellungen.
* Sendet `SystemEvent::WallpaperChanged` an den `EventBus`, um UI-Komponenten (z.B. den Desktop-Renderer) über Wallpaper-Änderungen zu informieren.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Wallpaper-Subsystem, das die Anzeige und den Wechsel von Desktop-Hintergrundbildern verwaltet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus` und `WallpaperManager`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration.
    * Testen der Weiterleitung von API-Aufrufen an den `WallpaperManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden (z.B. Diashow-Timer neu gestartet).
    * Überprüfen, ob `SystemEvent::WallpaperChanged` korrekt gesendet wird, wenn das Wallpaper geändert wird.
* **Integration Tests:**
    * Starten des `WallpaperService` in einer Testumgebung mit einem Dateisystem-Mock oder einem echten Testverzeichnis für Bilder.
    * Testen des Setzens eines statischen Wallpapers.
    * Testen des Startens, Stoppens und des Wechsels der Diashow (durch Beschleunigung des Timers).
    * Überprüfen, ob der `EventBus` die korrekten `WallpaperChanged` Ereignisse sendet.

**Geschätzter Aufwand:** Mittel (ca. 4-6 Tage, da Dateisystem-Interaktion und Diashow-Logik)

---
### **novade-system/src/wallpaper_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `wallpaper_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Wallpaper-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`WallpaperError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum WallpaperError {`
        * `#[error("Image file not found: {0}")]`
        * `FileNotFound(PathBuf),`
        * `#[error("Failed to load image: {0}")]`
        * `ImageLoadFailed(String),`
        * `#[error("Unsupported image format: {0}")]`
        * `UnsupportedImageFormat(String),`
        * `#[error("Directory not found or not readable: {0}")]`
        * `DirectoryError(PathBuf, String),`
        * `#[error("No images found in directory: {0}")]`
        * `NoImagesInDirectory(PathBuf),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Unknown wallpaper error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `anyhow::Error` (und potenziell Bildverarbeitungs-Crate-Fehler).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/wallpaper_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::path::PathBuf`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `wallpaper_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Wallpaper-System.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/wallpaper_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `wallpaper_service` verwendet werden, um Wallpaper-Informationen und zugehörige Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`WallpaperInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct WallpaperInfo {`
        * `pub wallpaper_type: WallpaperType,`
        * `pub current_path: PathBuf,`
        * `pub display_mode: DisplayMode,` // z.B. "Stretch", "Center", "Fill", "Fit", "Tile"
        * `pub color: Option<String>,` // Hintergrundfarbe, wenn das Bild nicht den gesamten Bildschirm füllt (Hex-String oder RGB-String)
    * `}`

2.  **`WallpaperType` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum WallpaperType { Static, Slideshow }`

3.  **`DisplayMode` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum DisplayMode { Stretch, Center, Fill, Fit, Tile }`

4.  **`WallpaperConfig` Struct (aus `settings_manager::data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct WallpaperConfig {`
        * `pub active_wallpaper: WallpaperInfo,` // Enthält Typ, Pfad, Modus
        * `pub slideshow_folder: Option<PathBuf>,`
        * `pub slideshow_interval_seconds: u64,`
        * `pub slideshow_shuffle: bool,`
        * `pub default_wallpaper_paths: Vec<PathBuf>,` // Systempfade für vorinstallierte Wallpapers
        * `// ...`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/wallpaper_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::path::PathBuf`
* **Intern:**
    * `crate::settings_manager::data_types::WallpaperConfig` (oder direkter Import)

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Wallpaper-Informationen im System.
* `WallpaperInfo` Objekte werden vom `WallpaperManager` erstellt und verwaltet.
* `WallpaperConfig` wird im `SettingsManagerService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Wallpaper-Verwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/wallpaper_service/manager.rs**

**Verantwortlichkeit:**
Der `WallpaperManager` ist die Kernlogik des Wallpaper-Subsystems. Er verwaltet den aktuellen Wallpaper-Zustand, lädt und cached Bilder, führt Diashows aus und ist für die Anwendung der Wallpaper zuständig. Er interagiert mit dem Dateisystem und dem `config_service`.

**Kern-Aufgaben (Tasks):**

1.  **`WallpaperManager` Struct:**
    * `pub struct WallpaperManager {`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `current_wallpaper: RwLock<WallpaperInfo>,`
        * `current_slideshow_timer: RwLock<Option<tokio::task::JoinHandle<()>>>,`
        * `slideshow_images: RwLock<Vec<PathBuf>>,`
        * `slideshow_index: RwLock<usize>,`
        * `slideshow_shuffle_rng: RwLock<Option<rand::rngs::ThreadRng>>,`
        * `current_config: RwLock<WallpaperConfig>,`
    * `}`

2.  **`WallpaperManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<Self, WallpaperError>`
    * **Logik:**
        * Initialisiert alle Felder.
        * Lädt die initiale `WallpaperConfig` aus dem `config_service`.
        * Setzt das initiale Wallpaper basierend auf der geladenen Konfiguration (`self.apply_wallpaper_from_config()`).
        * Startet den Diashow-Timer, falls in der Konfiguration aktiviert.
        * Gibt `Self` zurück.

3.  **`WallpaperManager::set_static_wallpaper()` Methode:**
    * `pub async fn set_static_wallpaper(&self, image_path: &Path) -> Result<(), WallpaperError>`
    * **Logik:**
        * Überprüft, ob die Bilddatei existiert und lesbar ist.
        * Stoppt eine eventuell laufende Diashow (`self.stop_slideshow_internal()`).
        * Erstellt ein neues `WallpaperInfo` Objekt vom Typ `Static`.
        * Aktualisiert `current_wallpaper`.
        * Persistiert die Änderung im `config_service`.
        * Sendet `SystemEvent::WallpaperChanged(self.current_wallpaper.read().await.clone())` an den `EventBus`.

4.  **`WallpaperManager::set_slideshow_wallpaper()` Methode:**
    * `pub async fn set_slideshow_wallpaper(&self, folder_path: &Path, interval_seconds: u64, shuffle: bool) -> Result<(), WallpaperError>`
    * **Logik:**
        * Überprüft, ob der Ordner existiert und lesbar ist.
        * Scannt den Ordner nach unterstützten Bilddateien und füllt `slideshow_images`.
        * Wenn `shuffle` aktiviert ist, mischt die Liste.
        * Stoppt eine eventuell laufende Diashow (`self.stop_slideshow_internal()`).
        * Erstellt ein neues `WallpaperInfo` Objekt vom Typ `Slideshow`.
        * Aktualisiert `current_wallpaper`.
        * Persistiert die Änderung im `config_service`.
        * Startet einen neuen Diashow-Timer-Task (`self.start_slideshow_timer()`).
        * Sendet `SystemEvent::WallpaperChanged(self.current_wallpaper.read().await.clone())` an den `EventBus`.

5.  **`WallpaperManager::stop_slideshow()` Methode:**
    * `pub async fn stop_slideshow(&self) -> Result<(), WallpaperError>`
    * **Logik:** Ruft `self.stop_slideshow_internal()` auf.

6.  **`WallpaperManager::get_current_wallpaper_info()` Methode:**
    * `pub async fn get_current_wallpaper_info(&self) -> WallpaperInfo`
    * **Logik:** Gibt eine Kopie von `current_wallpaper` zurück.

7.  **`WallpaperManager::get_available_wallpapers()` Methode:**
    * `pub async fn get_available_wallpapers(&self, search_path: Option<&Path>) -> Result<Vec<PathBuf>, WallpaperError>`
    * **Logik:**
        * Sucht in den konfigurierten `default_wallpaper_paths` (aus `current_config`) und/oder dem optionalen `search_path`.
        * Iteriert durch Verzeichnisse und filtert nach unterstützten Bildformaten (z.B. `.jpg`, `.png`, `.jpeg`).
        * Gibt eine Liste der gefundenen Bildpfade zurück.

8.  **`WallpaperManager::apply_wallpaper_from_config()` Methode (intern):**
    * `async fn apply_wallpaper_from_config(&self)`
    * **Logik:** Wird bei Initialisierung und Konfigurationsänderungen aufgerufen. Überprüft den `wallpaper_type` in `current_config.active_wallpaper` und ruft `set_static_wallpaper` oder `set_slideshow_wallpaper` intern auf, um den Zustand wiederherzustellen.

9.  **`WallpaperManager::start_slideshow_timer()` und `stop_slideshow_internal()` Methoden (intern):**
    * `async fn start_slideshow_timer(self: Arc<Self>)`
        * Startet einen `tokio::time::interval` Task.
        * **Innerhalb des Tasks:** Wählt das nächste Bild aus `slideshow_images`, aktualisiert `current_wallpaper` und sendet `SystemEvent::WallpaperChanged`. Behandelt Shuffle-Logik.
    * `async fn stop_slideshow_internal(&self)`
        * Stoppt den `current_slideshow_timer` und setzt das Handle auf `None`.

10. **`WallpaperManager::update_config()` Methode (intern, vom Service aufgerufen bei `SystemEvent::ConfigChanged`):**
    * `pub async fn update_config(&self, new_config: WallpaperConfig)`
    * **Logik:** Aktualisiert die interne `current_config` und ruft `self.apply_wallpaper_from_config()` erneut auf, um die neuen Einstellungen anzuwenden (z.B. geänderter Diashow-Intervall).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/wallpaper_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::wallpaper_service::error::WallpaperError`
    * `crate::wallpaper_service::data_types::{WallpaperInfo, WallpaperType, DisplayMode, WallpaperConfig}`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::sync::RwLock`
    * `tokio::time::{interval, Duration}`
    * `tokio::task::JoinHandle`
    * `std::sync::Arc`
    * `std::path::{Path, PathBuf}`
    * `rand` crate (für Shuffle)
    * `tracing`
    * `walkdir` (für Dateisystem-Scans)
    * `image` crate (optional, zum Überprüfen/Laden von Bildern, oder später in der UI-Schicht)

**Kommunikationsmuster:**

* Ist die zentrale Logik für die Wallpaper-Verwaltung.
* Interagiert mit dem Dateisystem zum Laden und Scannen von Bildern.
* Sendet `SystemEvent::WallpaperChanged` an den `EventBus`, um UI-Komponenten zu informieren.
* Empfängt Konfigurations-Updates über `update_config`.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Wallpaper-Manager, der statische und Diashow-Wallpaper verwalten kann, die Konfiguration persistiert und Änderungen an das System kommuniziert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService` und `EventBus`.
    * Mocken der Dateisystem-Operationen (z.B. mit `mock_fs` oder durch Erstellen temporärer Dateien/Verzeichnisse).
    * Testen von `new`: Sicherstellen, dass die initiale Konfiguration geladen und das Wallpaper angewendet wird.
    * Testen von `set_static_wallpaper`: Überprüfen, ob die interne Info aktualisiert, die Konfiguration gespeichert und `WallpaperChanged` Event gesendet wird.
    * Testen von `set_slideshow_wallpaper`: Überprüfen des Scans nach Bildern, des Shufflings, des Starts des Timers und der Event-Sendung.
    * Testen von `stop_slideshow`: Sicherstellen, dass der Timer beendet wird.
    * Testen des Diashow-Timers: Simulieren von Ticks und Überprüfen des Bildwechsels und der Events.
    * Testen von `get_available_wallpapers` mit verschiedenen Pfaden und Bildtypen.
    * Testen von `update_config` und dem erneuten Anwenden der Konfiguration.
* **Integration Tests:**
    * Starten des `WallpaperManager` mit echten Dateisystem-Operationen (in einem isolierten Testverzeichnis).
    * Überprüfen, ob Wallpaper-Dateien korrekt gefunden und geladen werden.
    * Beobachten von `WallpaperChanged` Events bei tatsächlichen Wallpaper-Wechseln und Diashows.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da Dateisystem-Interaktion, Diashow-Logik, Timer-Management und Persistenz)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `system_monitor`, widmen wir uns `wallpaper_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/wallpaper_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/wallpaper_service/data_types.rs`**: Definition der Wallpaper-bezogenen Datentypen.
3.  **`novade-system/src/wallpaper_service/manager.rs`**: Die Kernlogik zur Verwaltung von statischen und Diashow-Wallpapers, zur Interaktion mit dem Dateisystem und zur Persistenz der Konfiguration.
4.  **`novade-system/src/wallpaper_service/mod.rs`**: Das Hauptmodul, das den Manager initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/wallpaper_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/file_manager_service` Verzeichnisses.
---
### **novade-system/src/file_manager_service/mod.rs**

**Verantwortlichkeit:**
Das `file_manager_service` Modul bietet Kernfunktionen für die Dateiverwaltung innerhalb von NovaDE. Es ermöglicht den Zugriff auf Dateisystemoperationen wie Lesen von Verzeichnissen, Kopieren, Verschieben, Löschen, Umbenennen von Dateien und Ordnern sowie die Verwaltung von Lesezeichen und den Papierkorb. Es interagiert mit dem `config_service` für Präferenzen und dem `event_bus` für Benachrichtigungen über Dateisystemänderungen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/file_manager_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Dateimanager-Operationen)
    * `manager.rs` (Logik für Dateisystemoperationen, Lesezeichen, Papierkorb)
    * `data_types.rs` (Definition von Dateisystem-bezogenen Datentypen)
    * `trash_manager.rs` (Spezifische Logik für den Papierkorb)
    * `thumbnail_generator.rs` (Generierung von Miniaturansichten für Dateien)
    * `file_watcher.rs` (Überwachung von Dateisystemänderungen)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Dateimanager-Subsystems:**
    * `pub async fn initialize_file_manager_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<FileManagerService, FileManagerError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::FileManager`.
        * Initialisiert den `trash_manager::TrashManager`.
        * Initialisiert den `thumbnail_generator::ThumbnailGenerator`.
        * Initialisiert den `file_watcher::FileWatcher`.
        * Lädt initiale Konfigurationen aus dem `config_service` (z.B. Standardpfade, Lesezeichen, Papierkorb-Einstellungen).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Startet den `FileWatcher`, um relevante Verzeichnisse zu überwachen.
        * Gibt ein gebündeltes `FileManagerService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder der Sub-Komponenten.

2.  **`FileManagerService` Struct:**
    * `pub struct FileManagerService {`
        * `manager: Arc<FileManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `file_watcher: Arc<file_watcher::FileWatcher>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Dateimanager-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `FileManagerService` exponiert Methoden zur Steuerung der Dateiverwaltung.
    * `pub async fn list_directory(&self, path: &Path) -> Result<Vec<FileInfo>, FileManagerError>`
        * **Logik:** Delegiert an den `manager`, um den Inhalt eines Verzeichnisses aufzulisten.
    * `pub async fn create_directory(&self, path: &Path) -> Result<(), FileManagerError>`
        * **Logik:** Delegiert an den `manager`, um ein neues Verzeichnis zu erstellen. Sendet `SystemEvent::FileSystemChanged`.
    * `pub async fn create_file(&self, path: &Path) -> Result<(), FileManagerError>`
        * **Logik:** Delegiert an den `manager`, um eine neue leere Datei zu erstellen. Sendet `SystemEvent::FileSystemChanged`.
    * `pub async fn copy_item(&self, source: &Path, destination: &Path) -> Result<(), FileManagerError>`
        * **Logik:** Delegiert an den `manager` für den Kopiervorgang. Sendet `SystemEvent::FileSystemChanged`.
    * `pub async fn move_item(&self, source: &Path, destination: &Path) -> Result<(), FileManagerError>`
        * **Logik:** Delegiert an den `manager` für den Verschiebevorgang. Sendet `SystemEvent::FileSystemChanged`.
    * `pub async fn delete_item(&self, path: &Path) -> Result<(), FileManagerError>`
        * **Logik:** Delegiert an den `manager` für das direkte Löschen (ohne Papierkorb). Sendet `SystemEvent::FileSystemChanged`.
    * `pub async fn trash_item(&self, path: &Path) -> Result<(), FileManagerError>`
        * **Logik:** Delegiert an den `manager` (der den `trash_manager` verwendet) für das Verschieben in den Papierkorb. Sendet `SystemEvent::FileSystemChanged`.
    * `pub async fn restore_from_trash(&self, item_id: &str, destination: &Path) -> Result<(), FileManagerError>`
        * **Logik:** Delegiert an den `manager` (der den `trash_manager` verwendet) zum Wiederherstellen aus dem Papierkorb. Sendet `SystemEvent::FileSystemChanged`.
    * `pub async fn empty_trash(&self) -> Result<(), FileManagerError>`
        * **Logik:** Delegiert an den `manager` (der den `trash_manager` verwendet), um den Papierkorb zu leeren. Sendet `SystemEvent::FileSystemChanged`.
    * `pub async fn rename_item(&self, old_path: &Path, new_name: &str) -> Result<(), FileManagerError>`
        * **Logik:** Delegiert an den `manager` zum Umbenennen. Sendet `SystemEvent::FileSystemChanged`.
    * `pub async fn get_item_info(&self, path: &Path) -> Result<FileInfo, FileManagerError>`
        * **Logik:** Delegiert an den `manager`, um detaillierte Informationen zu erhalten.
    * `pub async fn get_thumbnail(&self, path: &Path, size: u32) -> Result<Option<Vec<u8>>, FileManagerError>`
        * **Logik:** Delegiert an den `manager` (der den `thumbnail_generator` verwendet), um ein Thumbnail abzurufen oder zu generieren.
    * `pub async fn add_bookmark(&self, path: &Path) -> Result<(), FileManagerError>`
        * **Logik:** Delegiert an den `manager`, um ein Lesezeichen hinzuzufügen. Aktualisiert den `config_service`.
    * `pub async fn remove_bookmark(&self, path: &Path) -> Result<(), FileManagerError>`
        * **Logik:** Delegiert an den `manager`, um ein Lesezeichen zu entfernen. Aktualisiert den `config_service`.
    * `pub async fn get_bookmarks(&self) -> Result<Vec<PathBuf>, FileManagerError>`
        * **Logik:** Delegiert an den `manager`, um die Liste der Lesezeichen abzurufen.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `FileManagerService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen (z.B. Standard-Lesezeichen, Papierkorb-Größenbeschränkungen) zu laden und an den `FileManager` weiterzugeben.

5.  **Hintergrund-Task zum Abonnieren von Dateisystem-Events:**
    * Der `FileManagerService` abonniert den Event-Stream vom `file_watcher`. Jedes empfangene Dateisystem-Event (Erstellung, Änderung, Löschung) wird in ein `SystemEvent::FileSystemChanged` konvertiert und an den `EventBus` gesendet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/file_manager_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::file_manager_service::error::FileManagerError`
    * `crate::file_manager_service::manager::FileManager`
    * `crate::file_manager_service::data_types::{FileInfo, FileManagerConfig}`
    * `crate::file_manager_service::trash_manager::TrashManager`
    * `crate::file_manager_service::thumbnail_generator::ThumbnailGenerator`
    * `crate::file_manager_service::file_watcher::FileWatcher`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `std::path::{Path, PathBuf}`
    * `futures::stream::StreamExt`

**Kommunikationsmuster:**

* Ist der primäre Controller für die Dateiverwaltung.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Dateimanager-Einstellungen und Lesezeichen.
* Sendet `SystemEvent::FileSystemChanged` an den `EventBus`, um UI-Komponenten und andere Systemdienste über Dateisystemänderungen zu informieren.
* Empfängt Events vom `FileWatcher` und leitet sie als `SystemEvent::FileSystemChanged` weiter.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes und funktionsfähiges Dateimanager-Subsystem, das grundlegende und erweiterte Dateisystemoperationen sicher und zuverlässig ausführt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `FileManager`, `TrashManager`, `ThumbnailGenerator` und `FileWatcher`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und der Verbindung zu den Mock-Schnittstellen.
    * Testen der Weiterleitung von API-Aufrufen an den `FileManager` und seine Sub-Komponenten.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von Dateisystem-Events vom Mock-`FileWatcher` und Überprüfen, ob `SystemEvent::FileSystemChanged` gesendet wird.
* **Integration Tests:**
    * Starten des `FileManagerService` in einer Testumgebung mit einem temporären Dateisystem (z.B. `tempfile` Crate).
    * Ausführen von Dateioperationen (Erstellen, Kopieren, Verschieben, Löschen, Umbenennen) und Überprüfen der Dateisystemänderungen.
    * Testen der Papierkorb-Funktionalität (Verschieben, Wiederherstellen, Leeren).
    * Testen der Lesezeichenverwaltung.
    * Testen der Thumbnail-Generierung (mit echten Bilddateien).
    * Überprüfen, ob der `EventBus` die korrekten `FileSystemChanged` Ereignisse sendet.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da komplexe Dateisystemoperationen, Fehlerbehandlung, Papierkorb, Thumbnails und Dateiüberwachung)

---
### **novade-system/src/file_manager_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `file_manager_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Dateimanager-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`FileManagerError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum FileManagerError {`
        * `#[error("Path does not exist: {0}")]`
        * `PathNotFound(PathBuf),`
        * `#[error("Permission denied for path: {0}")]`
        * `PermissionDenied(PathBuf),`
        * `#[error("IO error: {0}")]`
        * `IoError(#[from] std::io::Error),`
        * `#[error("Item already exists: {0}")]`
        * `ItemAlreadyExists(PathBuf),`
        * `#[error("Invalid path: {0}")]`
        * `InvalidPath(PathBuf),`
        * `#[error("Failed to parse metadata for: {0}")]`
        * `MetadataError(PathBuf),`
        * `#[error("Trash operation failed: {0}")]`
        * `TrashError(String),`
        * `#[error("Thumbnail generation failed: {0}")]`
        * `ThumbnailError(String),`
        * `#[error("File watcher error: {0}")]`
        * `FileWatcherError(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Unknown file manager error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `std::io::Error`, `crate::config_service::error::ConfigError`, `anyhow::Error` (und potenziell Fehler aus Thumbnail-/Trash-Crates).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/file_manager_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::io::Error`
    * `std::path::PathBuf`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `file_manager_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Dateimanager-System.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/file_manager_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `file_manager_service` verwendet werden, um Datei- und Verzeichnisinformationen, Lesezeichen und Dateimanager-spezifische Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`FileInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct FileInfo {`
        * `pub path: PathBuf,`
        * `pub name: String,`
        * `pub is_directory: bool,`
        * `pub is_file: bool,`
        * `pub is_symlink: bool,`
        * `pub size: u64,` // Größe in Bytes (für Dateien)
        * `pub last_modified: u64,` // Unix-Timestamp
        * `pub created: u64,` // Unix-Timestamp
        * `pub permissions: String,` // z.B. "rwxr-xr-x"
        * `pub owner_id: u32,`
        * `pub group_id: u32,`
        * `pub mime_type: Option<String>,`
        * `pub is_hidden: bool,`
    * `}`

2.  **`TrashInfo` Struct (für Papierkorb-Einträge):**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct TrashInfo {`
        * `pub id: String,` // Eindeutige ID des Papierkorb-Eintrags
        * `pub original_path: PathBuf,`
        * `pub trashed_time: u64,` // Unix-Timestamp wann in den Papierkorb verschoben
        * `pub size: u64,` // Größe des Objekts, als es in den Papierkorb verschoben wurde
        * `pub is_directory: bool,`
    * `}`

3.  **`ThumbnailRequest` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct ThumbnailRequest {`
        * `pub path: PathBuf,`
        * `pub size: u32,` // Gewünschte Größe (z.B. 64, 128, 256)
    * `}`

4.  **`FileManagerConfig` Struct (aus `settings_manager::data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct FileManagerConfig {`
        * `pub show_hidden_files: bool,`
        * `pub show_file_extensions: bool,`
        * `pub default_open_path: PathBuf,`
        * `pub bookmarks: Vec<PathBuf>,`
        * `pub trash_auto_clean_enabled: bool,`
        * `pub trash_max_age_days: u32,`
        * `pub trash_max_size_gb: u32,`
        * `pub default_thumbnail_size: u32,`
        * `// ...`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/file_manager_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::path::{Path, PathBuf}`
    * `std::collections::HashMap`
* **Intern:**
    * `crate::settings_manager::data_types::FileManagerConfig` (oder direkter Import)

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Dateisysteminformationen im System.
* `FileInfo` und `TrashInfo` Objekte werden vom `FileManager` generiert und verwaltet.
* `FileManagerConfig` wird im `SettingsManagerService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Dateiverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/file_manager_service/trash_manager.rs**

**Verantwortlichkeit:**
Das `trash_manager` Modul implementiert die Logik für den Benutzer-Papierkorb gemäß dem XDG Base Directory Specification (oder ähnlichen Standards). Es verwaltet das Verschieben von Dateien und Ordnern in den Papierkorb, das Wiederherstellen und das endgültige Löschen.

**Kern-Aufgaben (Tasks):**

1.  **`TrashManager` Struct:**
    * `pub struct TrashManager {`
        * `trash_dir: PathBuf,`
        * `info_dir: PathBuf,`
        * `files_dir: PathBuf,`
        * `// Eine interne Map zur Nachverfolgung der gelöschten Elemente für den schnellen Zugriff`
        * `// private_trash_entries: RwLock<HashMap<String, TrashInfo>>,`
        * `config: RwLock<FileManagerConfig>,` // Für Papierkorb-Größenbeschränkungen etc.
    * `}`

2.  **`TrashManager::new()` Funktion:**
    * `pub async fn new(config: FileManagerConfig) -> Result<Self, FileManagerError>`
    * **Logik:**
        * Bestimmt den Speicherort des Papierkorbs (z.B. `$XDG_DATA_HOME/Trash` oder `$HOME/.local/share/Trash`).
        * Erstellt die notwendigen Verzeichnisse: `trash_dir`, `info_dir`, `files_dir`.
        * Lädt vorhandene `.trashinfo`-Dateien, um den internen Zustand des Papierkorbs wiederherzustellen.
        * Gibt `Self` zurück.

3.  **`TrashManager::trash_item()` Methode:**
    * `pub async fn trash_item(&self, path: &Path) -> Result<TrashInfo, FileManagerError>`
    * **Logik:**
        * Überprüft, ob der `path` existiert.
        * Generiert eine eindeutige ID für das Element.
        * Erstellt eine `.trashinfo`-Datei im `info_dir`, die den Originalpfad, Löschzeitpunkt etc. enthält.
        * Verschiebt die Originaldatei oder das Originalverzeichnis in das `files_dir` des Papierkorbs und benennt sie mit der eindeutigen ID um.
        * Erstellt ein `TrashInfo` Objekt und gibt es zurück.
        * Behandelt Duplikate, falls ein Element mit gleichem Namen bereits im Papierkorb ist (z.B. durch Anhängen einer Zahl).

4.  **`TrashManager::restore_item()` Methode:**
    * `pub async fn restore_item(&self, item_id: &str, destination_path: &Path) -> Result<(), FileManagerError>`
    * **Logik:**
        * Sucht die `.trashinfo`-Datei und das zugehörige Element im `files_dir` anhand der `item_id`.
        * Verschiebt das Element vom `files_dir` zum `destination_path`.
        * Löscht die zugehörige `.trashinfo`-Datei.
        * Behandelt Kollisionen am Zielpfad (z.B. indem eine Zahl angehängt wird, wenn der Name bereits existiert).

5.  **`TrashManager::delete_item_permanently()` Methode:**
    * `pub async fn delete_item_permanently(&self, item_id: &str) -> Result<(), FileManagerError>`
    * **Logik:**
        * Findet die `.trashinfo`-Datei und das zugehörige Element im `files_dir`.
        * Löscht das Element im `files_dir` und die `.trashinfo`-Datei endgültig.

6.  **`TrashManager::empty_trash()` Methode:**
    * `pub async fn empty_trash(&self) -> Result<(), FileManagerError>`
    * **Logik:**
        * Löscht rekursiv alle Inhalte im `files_dir` und `info_dir`.
        * Setzt den internen Zustand zurück.

7.  **`TrashManager::get_trash_contents()` Methode:**
    * `pub async fn get_trash_contents(&self) -> Result<Vec<TrashInfo>, FileManagerError>`
    * **Logik:**
        * Scannt das `info_dir` nach `.trashinfo`-Dateien.
        * Parst diese Dateien und gibt eine Liste von `TrashInfo` Objekten zurück.

8.  **`TrashManager::clean_old_or_large_items()` Methode (intern, durch den Manager getriggert):**
    * `async fn clean_old_or_large_items(&self)`
    * **Logik:**
        * Implementiert die Logik für die automatische Papierkorb-Bereinigung basierend auf `trash_auto_clean_enabled`, `trash_max_age_days` und `trash_max_size_gb` aus der Konfiguration.
        * Identifiziert und löscht die ältesten oder größten Elemente, bis die Grenzwerte eingehalten werden.

9.  **`TrashManager::update_config()` Methode:**
    * `pub async fn update_config(&self, new_config: FileManagerConfig)`
    * **Logik:** Aktualisiert die interne `config` und ruft ggf. `clean_old_or_large_items()` auf.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/file_manager_service/trash_manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::file_manager_service::error::FileManagerError`
    * `crate::file_manager_service::data_types::{TrashInfo, FileManagerConfig}`
* **Extern:**
    * `tokio::fs`
    * `tokio::io`
    * `tokio::sync::RwLock`
    * `std::path::{Path, PathBuf}`
    * `uuid` crate (für eindeutige IDs)
    * `time` crate (für Zeitstempel)
    * `tracing`
    * `serde_json` (für `.trashinfo` Parsing/Serialisierung)

**Kommunikationsmuster:**

* Wird vom `FileManager` verwendet, um Papierkorb-Operationen auszuführen.
* Persistiert Informationen im Dateisystem (`.trashinfo` Dateien).

**Erwartete Ergebnisse/Outputs:**
Ein funktionsfähiges Papierkorb-System, das Dateien sicher in den Papierkorb verschieben, wiederherstellen und endgültig löschen kann, inklusive automatischer Bereinigung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Dateisystem-Mocking):**
    * Mocken von `tokio::fs` Operationen oder Verwenden von `tempfile` für isolierte Tests.
    * Testen von `trash_item`: Überprüfen, ob die Datei verschoben, `.trashinfo` erstellt und korrekt ist.
    * Testen von `restore_item`: Überprüfen, ob die Datei zurückverschoben und `.trashinfo` gelöscht wird.
    * Testen von `delete_item_permanently`: Überprüfen, ob beide Dateien gelöscht werden.
    * Testen von `empty_trash`: Überprüfen der vollständigen Leerung.
    * Testen von `get_trash_contents`: Überprüfen der korrekten Erfassung der Einträge.
    * Testen der `clean_old_or_large_items` Logik mit simulierten Alters- und Größenbedingungen.
* **Integration Tests:**
    * Ausführen von Papierkorb-Operationen in einer echten Dateisystemumgebung (mit Testdateien) und manuelle Überprüfung der `$HOME/.local/share/Trash` Inhalte.

**Geschätzter Aufwand:** Hoch (ca. 6-9 Tage, da komplexe Dateisystem-Interaktion, Metadaten-Verwaltung und Automatisierungslogik)

---
### **novade-system/src/file_manager_service/thumbnail_generator.rs**

**Verantwortlichkeit:**
Das `thumbnail_generator` Modul ist für die Erstellung und Verwaltung von Miniaturansichten (Thumbnails) für verschiedene Dateitypen zuständig. Es verwendet ein Caching-System, um die Leistung zu optimieren und die Generierung von Thumbnails bei Bedarf zu handhaben.

**Kern-Aufgaben (Tasks):**

1.  **`ThumbnailGenerator` Struct:**
    * `pub struct ThumbnailGenerator {`
        * `cache_dir: PathBuf,` // Speicherort für generierte Thumbnails (z.B. `$XDG_CACHE_HOME/thumbnails`)
        * `thumbnail_queue: Arc<tokio::sync::mpsc::Sender<ThumbnailRequest>>,` // Kanal für Thumbnail-Generierungsanfragen
        * `// Optional: Map für In-Memory-Cache von Thumbnails, die kürzlich abgerufen wurden`
        * `// in_memory_cache: tokio::sync::RwLock<LruCache<PathBuf, Vec<u8>>>,`
    * `}`

2.  **`ThumbnailGenerator::new()` Funktion:**
    * `pub async fn new() -> Result<Self, FileManagerError>`
    * **Logik:**
        * Bestimmt den Cache-Speicherort.
        * Erstellt den Cache-Ordner, falls nicht vorhanden.
        * Erstellt einen `mpsc::channel` für die Thumbnail-Generierungsanfragen.
        * Startet einen Hintergrund-Task (`self.start_generator_task()`), der Anfragen aus dem `thumbnail_queue` verarbeitet.
        * Gibt `Self` zurück.

3.  **`ThumbnailGenerator::get_thumbnail()` Methode:**
    * `pub async fn get_thumbnail(&self, path: &Path, size: u32) -> Result<Option<Vec<u8>>, FileManagerError>`
    * **Logik:**
        * Generiert einen Hash oder eindeutigen Namen für das Thumbnail basierend auf `path` und `size` (und ggf. Dateimodifikationszeitpunkt).
        * Überprüft, ob das Thumbnail bereits im Cache (`cache_dir`) existiert.
        * Falls ja, liest das Thumbnail aus dem Cache und gibt es zurück.
        * Falls nein:
            * Überprüft den Dateityp (MIME-Typ oder Dateiendung).
            * Sendet eine `ThumbnailRequest` an die `thumbnail_queue`.
            * Blockiert (oder wartet auf ein Event), bis das Thumbnail generiert und im Cache gespeichert wurde, oder gibt `None` zurück, wenn es nicht sofort verfügbar ist. Eine bessere UX wäre, das UI zuerst anzuzeigen und das Thumbnail asynchron zu laden.

4.  **`ThumbnailGenerator::generate_thumbnail_for_file()` Methode (intern, vom Hintergrund-Task aufgerufen):**
    * `async fn generate_thumbnail_for_file(path: &Path, size: u32, cache_path: &Path) -> Result<(), FileManagerError>`
    * **Logik:**
        * Wählt den passenden Generierungsmechanismus basierend auf dem Dateityp:
            * **Bilder:** Verwendet ein Bildverarbeitungs-Crate (z.B. `image` oder `resvg` für SVGs) zum Laden, Skalieren und Speichern des Bildes im Cache.
            * **Videos:** Verwendet externe Tools (z.B. `ffmpeg` über `tokio::process::Command`) zum Extrahieren eines Frames.
            * **PDFs:** Verwendet externe Tools (z.B. `poppler-utils` oder eine Rust-PDF-Bibliothek) zum Rendern der ersten Seite.
            * **Textdateien:** Generiert ein generisches Text-Dokument-Icon oder eine Vorschau des Inhalts.
        * Speichert das generierte Thumbnail im `cache_path`.
        * Protokolliert Fehler bei der Generierung.

5.  **`ThumbnailGenerator::start_generator_task()` Methode (intern):**
    * `async fn start_generator_task(receiver: tokio::sync::mpsc::Receiver<ThumbnailRequest>, cache_dir: PathBuf)`
    * **Logik:**
        * Ein langlebiger Task, der kontinuierlich `ThumbnailRequest`s aus dem `receiver` empfängt.
        * Für jede Anfrage ruft er `generate_thumbnail_for_file()` auf.
        * **Hinweis:** Dies sollte `tokio::task::spawn_blocking` verwenden, wenn die Generierung CPU-intensiv ist oder externe synchrone Programme aufruft.

6.  **`ThumbnailGenerator::clear_cache()` Methode:**
    * `pub async fn clear_cache(&self) -> Result<(), FileManagerError>`
    * **Logik:** Löscht alle Inhalte des `cache_dir`.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/file_manager_service/thumbnail_generator.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::file_manager_service::error::FileManagerError`
    * `crate::file_manager_service::data_types::ThumbnailRequest`
* **Extern:**
    * `tokio::fs`
    * `tokio::process::Command` (für externe Tools wie `ffmpeg`)
    * `tokio::sync::mpsc`
    * `tokio::task::spawn` und `spawn_blocking`
    * `image` crate (für Bildverarbeitung)
    * `walkdir` (für Cache-Bereinigung)
    * `tracing`
    * `blake3` oder `sha2` (für Hashing von Pfaden für Cache-Keys)
    * `mime_guess` (zum Bestimmen des Dateityps)
    * `lru::LruCache` (optional, für In-Memory-Cache)

**Kommunikationsmuster:**

* Wird vom `FileManager` verwendet, um Thumbnails zu generieren und abzurufen.
* Arbeitet asynchron im Hintergrund, um die UI-Reaktionsfähigkeit zu gewährleisten.
* Schreibt in das Dateisystem-Cache-Verzeichnis.

**Erwartete Ergebnisse/Outputs:**
Ein effizienter Thumbnail-Generator mit Caching, der bei Bedarf Miniaturansichten für verschiedene Dateitypen bereitstellt.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Dateisystem-Mocking und Image-Mocking):**
    * Mocken der Dateisystem-Operationen (Erstellen/Lesen des Caches).
    * Mocken des `image` Crate oder der externen `ffmpeg`/`poppler` Aufrufe.
    * Testen von `get_thumbnail` mit vorhandenen und nicht vorhandenen Thumbnails im Cache.
    * Testen von `generate_thumbnail_for_file` für verschiedene Dateitypen (Bilder, Videos, PDFs) und Größen.
    * Überprüfen der korrekten Cache-Dateipfad-Generierung.
* **Integration Tests:**
    * Starten des `ThumbnailGenerator` in einer isolierten Testumgebung mit echten Bild-, Video- und PDF-Dateien.
    * Überprüfen, ob Thumbnails korrekt generiert und im Cache gespeichert werden.
    * Messen der Leistung und des Speicherverbrauchs bei der Generierung vieler Thumbnails.

**Geschätzter Aufwand:** Sehr hoch (ca. 8-12 Tage, da komplexe Bild-/Video-/PDF-Verarbeitung, Caching, asynchrone Verarbeitung und externe Tool-Integration)

---
### **novade-system/src/file_manager_service/file_watcher.rs**

**Verantwortlichkeit:**
Das `file_watcher` Modul ist für die Überwachung von Dateisystemänderungen in bestimmten Verzeichnissen zuständig. Es nutzt ein plattformspezifisches Event-System (z.B. `inotify` unter Linux, `FSEvents` unter macOS, `ReadDirectoryChangesW` unter Windows), um Benachrichtigungen über Dateierstellung, -löschung, -änderung und -umbenennung zu erhalten.

**Kern-Aufgaben (Tasks):**

1.  **`FileWatcher` Struct:**
    * `pub struct FileWatcher {`
        * `watcher: notify::RecommendedWatcher,`
        * `event_sender: tokio::sync::mpsc::Sender<notify::Event>,`
        * `// Liste der aktuell überwachten Pfade`
        * `watched_paths: tokio::sync::RwLock<HashSet<PathBuf>>,`
    * `}`

2.  **`FileWatcher::new()` Funktion:**
    * `pub async fn new() -> Result<Self, FileManagerError>`
    * **Logik:**
        * Erstellt einen `tokio::sync::mpsc::channel` für den Event-Stream.
        * Erstellt einen `notify::RecommendedWatcher`, der die Events an den `event_sender` sendet.
        * Startet einen Hintergrund-Task, der den `event_receiver` abhört und die `notify::Event`s verarbeitet.
        * Gibt `Self` zurück.

3.  **`FileWatcher::watch()` Methode:**
    * `pub async fn watch(&self, path: &Path, recursive: notify::RecursiveMode) -> Result<(), FileManagerError>`
    * **Logik:**
        * Fügt den Pfad zum `watcher` hinzu (`self.watcher.watch(path, recursive)`).
        * Fügt den Pfad zur internen `watched_paths` Liste hinzu.
        * **Fehlerbehandlung:** Wenn der Pfad nicht existiert oder Berechtigungen fehlen.

4.  **`FileWatcher::unwatch()` Methode:**
    * `pub async fn unwatch(&self, path: &Path) -> Result<(), FileManagerError>`
    * **Logik:**
        * Entfernt den Pfad vom `watcher` (`self.watcher.unwatch(path)`).
        * Entfernt den Pfad aus der internen `watched_paths` Liste.

5.  **`FileWatcher::events()` Methode:**
    * `pub fn events(&self) -> tokio::sync::mpsc::Receiver<notify::Event>`
    * **Logik:** Gibt einen Receiver zurück, über den externe Komponenten die Dateisystem-Events abonnieren können.

6.  **Hintergrund-Task zum Verarbeiten von `notify` Events (intern):**
    * `async fn event_processing_task(mut receiver: tokio::sync::mpsc::Receiver<notify::Event>, event_bus: EventBus)`
    * **Logik:**
        * Schleife, die auf Events vom `notify` Watcher wartet.
        * Für jedes `notify::Event`:
            * Konvertiert das `notify::Event` in ein `SystemEvent::FileSystemChanged` (oder eine spezifischere Variante wie `FileSystemItemCreated`, `FileSystemItemDeleted`, `FileSystemItemModified`, `FileSystemItemRenamed`).
            * Sendet das konvertierte `SystemEvent` an den `event_bus`.
            * **Hinweis:** Die Granularität der `SystemEvent`s kann hier je nach Anforderung angepasst werden. Ein einzelnes `FileSystemChanged` Event, das nur den betroffenen Pfad enthält, ist eine einfache Startlösung.

7.  **`FileWatcher::get_watched_paths()` Methode:**
    * `pub async fn get_watched_paths(&self) -> Vec<PathBuf>`
    * **Logik:** Gibt eine Liste der aktuell überwachten Pfade zurück.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/file_manager_service/file_watcher.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::file_manager_service::error::FileManagerError`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `notify` crate (für plattformübergreifende Dateisystem-Überwachung)
    * `tokio::sync::mpsc`
    * `tokio::task`
    * `tokio::sync::RwLock`
    * `std::path::PathBuf`
    * `std::collections::HashSet`
    * `tracing`
    * `futures::stream::StreamExt`

**Kommunikationsmuster:**

* Wird vom `FileManagerService` instanziiert und zur Überwachung von Verzeichnissen verwendet.
* Stellt einen `mpsc::Receiver` bereit, über den andere Komponenten (insbesondere der `FileManagerService`) Dateisystem-Events empfangen können.
* Sendet `SystemEvent`s an den `EventBus`.

**Erwartete Ergebnisse/Outputs:**
Ein zuverlässiger Dateisystem-Watcher, der Änderungen in überwachten Verzeichnissen erkennt und weiterleitet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking von `notify`):**
    * Mocken des `notify::RecommendedWatcher` und Simulieren von `notify::Event`s.
    * Testen von `watch` und `unwatch`: Überprüfen, ob die internen `watched_paths` korrekt aktualisiert werden.
    * Simulieren von `notify::Event`s und Überprüfen, ob der `event_processing_task` diese korrekt in `SystemEvent::FileSystemChanged` umwandelt und an den `EventBus` sendet.
* **Integration Tests (auf einem echten System):**
    * Starten des `FileWatcher` und Überwachen eines temporären Verzeichnisses.
    * Erstellen, Löschen, Modifizieren und Umbenennen von Dateien in diesem Verzeichnis.
    * Überprüfen, ob die korrekten `SystemEvent::FileSystemChanged` Ereignisse auf dem `EventBus` empfangen werden.
    * Testen der rekursiven Überwachung.

**Geschätzter Aufwand:** Mittel bis Hoch (ca. 5-8 Tage, da asynchrone Event-Verarbeitung und plattformspezifische `notify` Integration)

---
### **novade-system/src/file_manager_service/manager.rs**

**Verantwortlichkeit:**
Der `FileManager` ist die Kernlogik des Dateimanager-Subsystems. Er führt die eigentlichen Dateisystemoperationen aus, verwaltet Lesezeichen und koordiniert sich mit dem Papierkorb-Manager und dem Thumbnail-Generator.

**Kern-Aufgaben (Tasks):**

1.  **`FileManager` Struct:**
    * `pub struct FileManager {`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `trash_manager: Arc<TrashManager>,`
        * `thumbnail_generator: Arc<ThumbnailGenerator>,`
        * `current_config: RwLock<FileManagerConfig>,`
    * `}`

2.  **`FileManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus, trash_manager: Arc<TrashManager>, thumbnail_generator: Arc<ThumbnailGenerator>) -> Result<Self, FileManagerError>`
    * **Logik:**
        * Initialisiert alle Felder.
        * Lädt die initiale `FileManagerConfig` aus dem `config_service`.
        * Gibt `Self` zurück.

3.  **`FileManager::list_directory()` Methode:**
    * `pub async fn list_directory(&self, path: &Path) -> Result<Vec<FileInfo>, FileManagerError>`
    * **Logik:**
        * Überprüft, ob der Pfad existiert und ein Verzeichnis ist.
        * Listet die Einträge im Verzeichnis auf (`tokio::fs::read_dir`).
        * Für jeden Eintrag:
            * Holt Metadaten (`tokio::fs::metadata`).
            * Extrahiert `FileInfo` (Name, Größe, Typ, Modifikationszeit, Berechtigungen, MIME-Typ, etc.).
            * Filtert versteckte Dateien, falls `show_hidden_files` in `current_config` `false` ist.
        * Gibt eine Liste von `FileInfo`s zurück.
        * **Fehlerbehandlung:** `PathNotFound`, `PermissionDenied`, `IoError`.

4.  **`FileManager::create_directory()` Methode:**
    * `pub async fn create_directory(&self, path: &Path) -> Result<(), FileManagerError>`
    * **Logik:** Ruft `tokio::fs::create_dir_all(path)` auf.

5.  **`FileManager::create_file()` Methode:**
    * `pub async fn create_file(&self, path: &Path) -> Result<(), FileManagerError>`
    * **Logik:** Ruft `tokio::fs::File::create(path)` auf und schließt die Datei sofort.

6.  **`FileManager::copy_item()` Methode:**
    * `pub async fn copy_item(&self, source: &Path, destination: &Path) -> Result<(), FileManagerError>`
    * **Logik:**
        * Wenn `source` ein Verzeichnis ist: rekursives Kopieren (`fs_extra::dir::copy`).
        * Wenn `source` eine Datei ist: `tokio::fs::copy`.
        * **Hinweis:** Große Kopiervorgänge sollten überwacht und ggf. als `spawn_blocking` ausgeführt werden.

7.  **`FileManager::move_item()` Methode:**
    * `pub async fn move_item(&self, source: &Path, destination: &Path) -> Result<(), FileManagerError>`
    * **Logik:** Ruft `tokio::fs::rename(source, destination)` auf.

8.  **`FileManager::delete_item()` Methode:**
    * `pub async fn delete_item(&self, path: &Path) -> Result<(), FileManagerError>`
    * **Logik:**
        * Wenn `path` ein Verzeichnis ist: `tokio::fs::remove_dir_all`.
        * Wenn `path` eine Datei ist: `tokio::fs::remove_file`.

9.  **`FileManager::trash_item()` Methode:**
    * `pub async fn trash_item(&self, path: &Path) -> Result<(), FileManagerError>`
    * **Logik:** Delegiert an `self.trash_manager.trash_item(path)`.

10. **`FileManager::restore_from_trash()` Methode:**
    * `pub async fn restore_from_trash(&self, item_id: &str, destination: &Path) -> Result<(), FileManagerError>`
    * **Logik:** Delegiert an `self.trash_manager.restore_item(item_id, destination)`.

11. **`FileManager::empty_trash()` Methode:**
    * `pub async fn empty_trash(&self) -> Result<(), FileManagerError>`
    * **Logik:** Delegiert an `self.trash_manager.empty_trash()`.

12. **`FileManager::rename_item()` Methode:**
    * `pub async fn rename_item(&self, old_path: &Path, new_name: &str) -> Result<(), FileManagerError>`
    * **Logik:**
        * Baut den neuen Pfad zusammen.
        * Ruft `tokio::fs::rename(old_path, new_path)` auf.

13. **`FileManager::get_item_info()` Methode:**
    * `pub async fn get_item_info(&self, path: &Path) -> Result<FileInfo, FileManagerError>`
    * **Logik:** Holt Metadaten und konvertiert sie in ein `FileInfo` Objekt.

14. **`FileManager::get_thumbnail()` Methode:**
    * `pub async fn get_thumbnail(&self, path: &Path, size: u32) -> Result<Option<Vec<u8>>, FileManagerError>`
    * **Logik:** Delegiert an `self.thumbnail_generator.get_thumbnail(path, size)`.

15. **`FileManager::add_bookmark()` Methode:**
    * `pub async fn add_bookmark(&self, path: &Path) -> Result<(), FileManagerError>`
    * **Logik:**
        * Fügt den Pfad zur `bookmarks` Liste in `current_config` hinzu (mit `RwLock` Schreibzugriff).
        * Persistiert die aktualisierte Konfiguration über `config_service.save_config()`.

16. **`FileManager::remove_bookmark()` Methode:**
    * `pub async fn remove_bookmark(&self, path: &Path) -> Result<(), FileManagerError>`
    * **Logik:**
        * Entfernt den Pfad aus der `bookmarks` Liste in `current_config`.
        * Persistiert die aktualisierte Konfiguration.

17. **`FileManager::get_bookmarks()` Methode:**
    * `pub async fn get_bookmarks(&self) -> Vec<PathBuf>`
    * **Logik:** Gibt eine Kopie der `bookmarks` aus `current_config` zurück.

18. **`FileManager::update_config()` Methode (intern, vom Service aufgerufen bei `SystemEvent::ConfigChanged`):**
    * `pub async fn update_config(&self, new_config: FileManagerConfig)`
    * **Logik:** Aktualisiert die interne `current_config` und informiert den `trash_manager` über neue Papierkorb-Einstellungen.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/file_manager_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::file_manager_service::error::FileManagerError`
    * `crate::file_manager_service::data_types::{FileInfo, FileManagerConfig}`
    * `crate::file_manager_service::trash_manager::TrashManager`
    * `crate::file_manager_service::thumbnail_generator::ThumbnailGenerator`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
* **Extern:**
    * `tokio::fs`
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `std::path::{Path, PathBuf}`
    * `tracing`
    * `mime_guess` (für MIME-Typ-Erkennung)
    * `fs_extra` (für rekursive Kopiervorgänge)

**Kommunikationsmuster:**

* Ist die zentrale Logik für die Dateimanager-Funktionalität.
* Interagiert direkt mit dem Dateisystem über `tokio::fs`.
* Delegiert an `TrashManager` und `ThumbnailGenerator`.
* Interagiert mit `ConfigService` für Konfigurations-Updates und Persistenz von Lesezeichen.
* Sendet keine direkten Events, da der `FileManagerService` diese Aufgabe übernimmt, indem er auf die Events des `FileWatcher` hört.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Dateimanager, der alle erforderlichen Dateisystemoperationen ausführt, Lesezeichen verwaltet und mit dem Papierkorb und Thumbnail-Generator interagiert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Dateisystem-Mocking und Mocking der Sub-Komponenten):**
    * Mocken von `tokio::fs` und den Schnittstellen von `TrashManager` und `ThumbnailGenerator`.
    * Testen von `list_directory`: Überprüfen der korrekten Erfassung von `FileInfo`s und des Filterns versteckter Dateien.
    * Testen von `create_directory`, `create_file`, `copy_item`, `move_item`, `delete_item`, `rename_item`: Überprüfen, ob die richtigen `tokio::fs` Aufrufe erfolgen.
    * Testen der Delegierung an `trash_manager` und `thumbnail_generator`.
    * Testen von `add_bookmark` und `remove_bookmark`: Überprüfen der Aktualisierung der internen `bookmarks` Liste und des Aufrufs von `config_service.save_config()`.
    * Testen von `get_item_info` und `get_bookmarks`.
    * Testen von `update_config`.
* **Integration Tests:**
    * Starten des `FileManager` mit realen `TrashManager` und `ThumbnailGenerator` Instanzen in einer isolierten Testumgebung (temporäres Dateisystem).
    * Ausführen komplexer Szenarien (z.B. Kopieren großer Verzeichnisse, Verschieben zwischen Laufwerken, gleichzeitiges Löschen und Erstellen).
    * Überprüfen der End-to-End-Funktionalität der Dateisystemoperationen.

**Geschätzter Aufwand:** Sehr hoch (ca. 10-15 Tage, da viele Dateisystemoperationen, Fehlerbehandlung und Koordination mit anderen Diensten)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `wallpaper_service`, widmen wir uns `file_manager_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/file_manager_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/file_manager_service/data_types.rs`**: Definition der Datentypen für Dateien, Papierkorb, Thumbnails.
3.  **`novade-system/src/file_manager_service/trash_manager.rs`**: Implementierung der Papierkorb-Logik.
4.  **`novade-system/src/file_manager_service/thumbnail_generator.rs`**: Implementierung des Thumbnail-Generators.
5.  **`novade-system/src/file_manager_service/file_watcher.rs`**: Implementierung des Dateisystem-Watchers.
6.  **`novade-system/src/file_manager_service/manager.rs`**: Die Kernlogik des Dateimanagers, die alle vorherigen Komponenten orchestriert und die Dateisystemoperationen ausführt.
7.  **`novade-system/src/file_manager_service/mod.rs`**: Das Hauptmodul, das den Manager und seine Sub-Komponenten initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/file_manager_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/application_launcher_service` Verzeichnisses.
---
### **novade-system/src/application_launcher_service/mod.rs**

**Verantwortlichkeit:**
Das `application_launcher_service` Modul ist für das Auffinden, Indizieren, Starten und Verwalten von Anwendungen zuständig. Es integriert sich mit dem XDG Desktop Entry Specification, um installierte Anwendungen systemweit zu erkennen. Es bietet Funktionen zum Suchen, Filtern und Kategorisieren von Anwendungen und zur Verwaltung von Startparametern.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/application_launcher_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Anwendungsstarter-Operationen)
    * `manager.rs` (Logik für das Indizieren, Suchen und Starten von Anwendungen)
    * `data_types.rs` (Definition von Anwendungs-bezogenen Datentypen)
    * `desktop_entry_parser.rs` (Parsing von `.desktop`-Dateien)
    * `app_monitor.rs` (Optional: Überwachung laufender Anwendungen)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Anwendungsstarter-Subsystems:**
    * `pub async fn initialize_application_launcher_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<ApplicationLauncherService, ApplicationLauncherError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::ApplicationLauncherManager`.
        * Initialisiert den `desktop_entry_parser::DesktopEntryParser`.
        * Initialisiert den `app_monitor::ApplicationMonitor` (falls implementiert).
        * Startet einen Hintergrund-Task zum Indizieren von Anwendungen (`manager.index_applications()`). Dies sollte periodisch oder bei Dateisystemänderungen in relevanten XDG-Pfaden erfolgen.
        * Lädt initiale Konfigurationen aus dem `config_service` (z.B. bevorzugte Suchpfade, Kategorien).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Gibt ein gebündeltes `ApplicationLauncherService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder der Sub-Komponenten, oder beim initialen Indizierungslauf.

2.  **`ApplicationLauncherService` Struct:**
    * `pub struct ApplicationLauncherService {`
        * `manager: Arc<ApplicationLauncherManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
    * `}`
    * Dient als Container und Zugangspunkt für die Anwendungsstarter-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `ApplicationLauncherService` exponiert Methoden zur Interaktion mit Anwendungen.
    * `pub async fn get_all_applications(&self) -> Result<Vec<ApplicationInfo>, ApplicationLauncherError>`
        * **Logik:** Delegiert an den `manager`, um eine Liste aller indizierten Anwendungen abzurufen.
    * `pub async fn search_applications(&self, query: &str) -> Result<Vec<ApplicationInfo>, ApplicationLauncherError>`
        * **Logik:** Delegiert an den `manager`, um Anwendungen basierend auf einem Suchbegriff (Name, Beschreibung, Keywords) zu finden.
    * `pub async fn get_applications_by_category(&self, category: &str) -> Result<Vec<ApplicationInfo>, ApplicationLauncherError>`
        * **Logik:** Delegiert an den `manager`, um Anwendungen nach XDG-Kategorie zu filtern.
    * `pub async fn launch_application(&self, app_id: &str, args: Option<Vec<String>>) -> Result<u32, ApplicationLauncherError>`
        * **Logik:** Delegiert an den `manager`, um eine Anwendung mit einer bestimmten ID (Desktop Entry ID) und optionalen Argumenten zu starten. Gibt die Prozess-ID (PID) zurück.
        * Sendet `SystemEvent::ApplicationLaunched(app_id.to_string(), pid)`.
    * `pub async fn get_application_info(&self, app_id: &str) -> Result<ApplicationInfo, ApplicationLauncherError>`
        * **Logik:** Delegiert an den `manager`, um detaillierte Informationen zu einer spezifischen Anwendung abzurufen.
    * `pub async fn refresh_application_index(&self) -> Result<(), ApplicationLauncherError>`
        * **Logik:** Delegiert an den `manager`, um den Anwendungsindex neu aufzubauen (z.B. nach der Installation einer neuen App). Sendet `SystemEvent::ApplicationIndexUpdated`.
    * `pub async fn get_running_applications(&self) -> Result<Vec<RunningApplicationInfo>, ApplicationLauncherError>`
        * **Logik:** Delegiert an den `manager` (der den `app_monitor` verwendet), um Informationen über aktuell laufende Anwendungen abzurufen. (Optional)

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `ApplicationLauncherService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Einstellungen (z.B. zusätzliche Anwendungs-Suchpfade) geändert werden, werden die Sub-Komponenten (`ApplicationLauncherManager`) informiert.

5.  **Hintergrund-Task zur automatischen Index-Aktualisierung (optional):**
    * Dies könnte durch einen `FileWatcher` in den XDG-Anwendungspfaden ausgelöst werden, der dann den `refresh_application_index` des Managers triggert.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/application_launcher_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::application_launcher_service::error::ApplicationLauncherError`
    * `crate::application_launcher_service::manager::ApplicationLauncherManager`
    * `crate::application_launcher_service::data_types::{ApplicationInfo, RunningApplicationInfo, ApplicationLauncherConfig}`
    * `crate::application_launcher_service::desktop_entry_parser::DesktopEntryParser`
    * `crate::application_launcher_service::app_monitor::ApplicationMonitor` (optional)
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `std::path::{Path, PathBuf}`
    * `futures::stream::StreamExt`
    * `// xdg` crate (zum Auffinden von XDG-Pfaden)

**Kommunikationsmuster:**

* Ist der primäre Controller für die Anwendungsverwaltung.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Anwendungsstarter-Einstellungen.
* Sendet `SystemEvent::ApplicationLaunched` und `SystemEvent::ApplicationIndexUpdated` an den `EventBus`, um UI-Komponenten und andere Systemdienste zu informieren.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Anwendungsstarter-Subsystem, das Anwendungen finden, starten und ihren Status überwachen kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `ApplicationLauncherManager`, `DesktopEntryParser` und `ApplicationMonitor`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und des Starts des Indizierungsprozesses.
    * Testen der Weiterleitung von API-Aufrufen an den `ApplicationLauncherManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Überprüfen, ob `SystemEvent::ApplicationLaunched` und `SystemEvent::ApplicationIndexUpdated` korrekt gesendet werden.
* **Integration Tests:**
    * Starten des `ApplicationLauncherService` in einer Testumgebung mit einem Dateisystem-Mock, das `.desktop`-Dateien enthält.
    * Testen der Indexierung von Anwendungen, der Suche und des Startens von Dummy-Anwendungen (z.B. einfache Shell-Skripte).
    * Überprüfen, ob der `EventBus` die korrekten `ApplicationLaunched` und `ApplicationIndexUpdated` Ereignisse sendet.

**Geschätzter Aufwand:** Hoch (ca. 6-9 Tage, da Indizierung von Systemdateien, Prozess-Start und Event-Handling)

---
### **novade-system/src/application_launcher_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `application_launcher_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Anwendungsstarter-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`ApplicationLauncherError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum ApplicationLauncherError {`
        * `#[error("Application with ID '{0}' not found.")]`
        * `ApplicationNotFound(String),`
        * `#[error("Failed to parse desktop entry file: {0}")]`
        * `DesktopEntryParseError(PathBuf, String),`
        * `#[error("Failed to execute application '{0}': {1}")]`
        * `ExecutionFailed(String, String),`
        * `#[error("Missing or invalid 'Exec' field in desktop entry for '{0}'.")]`
        * `InvalidExecField(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Unknown application launcher error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `anyhow::Error` (und potenziell `std::io::Error` für Prozessausführung).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/application_launcher_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
    * `std::path::PathBuf`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `application_launcher_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Anwendungsstarter-System.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/application_launcher_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `application_launcher_service` verwendet werden, um Anwendungsinformationen, deren Start- und Laufzeitdaten sowie zugehörige Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`ApplicationInfo` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct ApplicationInfo {`
        * `pub id: String,` // Desktop Entry ID (z.B. "firefox.desktop")
        * `pub name: String,`
        * `pub generic_name: Option<String>,`
        * `pub comment: Option<String>,`
        * `pub exec: String,` // Ausführbarer Befehl
        * `pub icon: Option<String>,` // Icon-Name oder Pfad
        * `pub categories: Vec<String>,`
        * `pub keywords: Vec<String>,`
        * `pub terminal: bool,` // Ob die App in einem Terminal gestartet werden soll
        * `pub no_display: bool,` // Ob die App im Menü angezeigt werden soll
        * `pub startup_notify: bool,` // Ob der Start Benachrichtigung auslösen soll
        * `pub desktop_entry_path: PathBuf,` // Pfad zur .desktop Datei
    * `}`

2.  **`RunningApplicationInfo` Struct (Optional, falls `app_monitor` implementiert):**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct RunningApplicationInfo {`
        * `pub pid: u32,`
        * `pub app_id: Option<String>,` // Verknüpfung zur ApplicationInfo
        * `pub process_name: String,`
        * `pub title: Option<String>,` // Fenstertitel (wenn verfügbar)
        * `pub icon: Option<String>,` // Icon der laufenden App
        * `pub start_time: u64,` // Unix-Timestamp
        * `pub cpu_usage_percent: f32,`
        * `pub memory_usage_bytes: u64,`
    * `}`

3.  **`ApplicationLauncherConfig` Struct (aus `settings_manager::data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct ApplicationLauncherConfig {`
        * `pub additional_app_paths: Vec<PathBuf>,` // Zusätzliche Verzeichnisse zum Scannen
        * `pub default_terminal_emulator: String,` // Welches Terminal für terminal=true Apps verwendet werden soll
        * `pub auto_refresh_index: bool,`
        * `// ...`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/application_launcher_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::path::PathBuf`
* **Intern:**
    * `crate::settings_manager::data_types::ApplicationLauncherConfig` (oder direkter Import)

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Anwendungs- und Prozessinformationen im System.
* `ApplicationInfo` Objekte werden vom `ApplicationLauncherManager` generiert und verwaltet.
* `RunningApplicationInfo` wird optional vom `ApplicationMonitor` generiert.
* `ApplicationLauncherConfig` wird im `SettingsManagerService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für den Anwendungsstarter.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/application_launcher_service/desktop_entry_parser.rs**

**Verantwortlichkeit:**
Das `desktop_entry_parser` Modul ist für das Parsen von XDG `.desktop`-Dateien zuständig. Es extrahiert alle relevanten Informationen aus diesen Dateien, um `ApplicationInfo`-Objekte zu erstellen.

**Kern-Aufgaben (Tasks):**

1.  **`DesktopEntryParser` Struct:**
    * `pub struct DesktopEntryParser {}` // Dieses Struct ist wahrscheinlich zustandslos

2.  **`DesktopEntryParser::parse()` Funktion:**
    * `pub async fn parse(path: &Path) -> Result<ApplicationInfo, ApplicationLauncherError>`
    * **Logik:**
        * Liest den Inhalt der `.desktop`-Datei.
        * Verwendet eine Parsing-Bibliothek (z.B. `ini` oder `freedesktop_entry_parser`) oder implementiert eine einfache Parser-Logik, um Schlüssel-Wert-Paare zu extrahieren.
        * Sucht nach den relevanten Feldern wie `Name`, `GenericName`, `Comment`, `Exec`, `Icon`, `Categories`, `Keywords`, `Terminal`, `NoDisplay`, `StartupNotify`.
        * Beachtet die XDG Desktop Entry Specification für die Behandlung von übersetzten Feldern (z.B. `Name[de]`).
        * Baut ein `ApplicationInfo` Objekt zusammen.
        * **Fehlerbehandlung:** `DesktopEntryParseError` bei fehlenden kritischen Feldern oder fehlerhafter Syntax.

3.  **`DesktopEntryParser::get_xdg_paths()` Funktion:**
    * `pub fn get_xdg_paths() -> Vec<PathBuf>`
    * **Logik:**
        * Liefert die Standard-XDG-Pfade, in denen `.desktop`-Dateien normalerweise gefunden werden (z.B. `/usr/share/applications`, `$HOME/.local/share/applications`).
        * Nutzt dafür idealerweise das `xdg` Crate.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/application_launcher_service/desktop_entry_parser.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::application_launcher_service::error::ApplicationLauncherError`
    * `crate::application_launcher_service::data_types::ApplicationInfo`
* **Extern:**
    * `tokio::fs`
    * `std::path::Path`
    * `tracing`
    * `xdg` crate (zum Auffinden von XDG-Pfaden)
    * `ini` crate oder `freedesktop_entry_parser` crate (für INI-Parsing)

**Kommunikationsmuster:**

* Wird vom `ApplicationLauncherManager` verwendet, um `.desktop`-Dateien zu verarbeiten.

**Erwartete Ergebnisse/Outputs:**
Ein Parser, der `.desktop`-Dateien korrekt in `ApplicationInfo`-Objekte umwandeln kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mock-Dateien):**
    * Erstellen von Test-`.desktop`-Dateien mit verschiedenen gültigen und ungültigen Inhalten.
    * Testen von `parse` mit diesen Dateien, um die korrekte Extraktion aller Felder zu überprüfen, inklusive Übersetzungen und speziellen Zeichen.
    * Testen der Fehlerbehandlung bei fehlenden obligatorischen Feldern oder Syntaxfehlern.
    * Testen von `get_xdg_paths`, um sicherzustellen, dass die korrekten Standardpfade zurückgegeben werden.

**Geschätzter Aufwand:** Mittel (ca. 3-5 Tage, da Parsen von spezifischen Dateiformaten und XDG-Spezifikation)

---
### **novade-system/src/application_launcher_service/app_monitor.rs** (Optional)

**Verantwortlichkeit:**
Das `app_monitor` Modul ist optional und für die Überwachung von laufenden Anwendungen zuständig. Es kann Fensterinformationen (Titel, Icons) und Prozessstatistiken (CPU, Speicher) erfassen, um eine Liste der "aktiven" Anwendungen für z.B. einen Task-Manager oder eine Taskleiste bereitzustellen. Dies ist plattformabhängig und kann erhebliche Integrationstiefe erfordern.

**Kern-Aufgaben (Tasks):**

1.  **`ApplicationMonitor` Struct:**
    * `pub struct ApplicationMonitor {`
        * `// Interner Zustand, z.B. eine Map von PID zu RunningApplicationInfo`
        * `// process_map: tokio::sync::RwLock<HashMap<u32, RunningApplicationInfo>>`
        * `// System-Monitor Instanz oder direkter Zugriff auf sysinfo`
        * `sysinfo_system: tokio::sync::Mutex<sysinfo::System>,`
        * `// Optional: Bibliotheken für Fenstermanagement-Interaktion (z.B. xcb, winapi)`
    * `}`

2.  **`ApplicationMonitor::new()` Funktion:**
    * `pub async fn new() -> Result<Self, ApplicationLauncherError>`
    * **Logik:** Initialisiert die benötigten Systemressourcen (z.B. `sysinfo::System` Instanz, Verbindung zum X Server für X11-Systeme).

3.  **`ApplicationMonitor::refresh_running_applications()` Methode:**
    * `pub async fn refresh_running_applications(&self) -> Result<Vec<RunningApplicationInfo>, ApplicationLauncherError>`
    * **Logik:**
        * Nutzt das `sysinfo` Crate, um eine Liste aller laufenden Prozesse abzurufen.
        * Für jeden Prozess:
            * Versucht, den Fenstertitel und das Icon zu erhalten (plattformspezifisch: z.B. X11 mit `xcb` für `_NET_WM_NAME`, `_NET_WM_ICON`).
            * Ordnet den Prozess ggf. einer bekannten `ApplicationInfo` zu (z.B. durch Vergleich von `exec` Pfad oder Prozessnamen).
            * Erfasst CPU- und Speichernutzung vom `sysinfo` Crate.
            * Baut ein `RunningApplicationInfo` Objekt zusammen.
        * Aktualisiert den internen Zustand (`process_map`).
        * Gibt die Liste der `RunningApplicationInfo` zurück.
        * **Hinweis:** Dies ist ein teurer Vorgang und sollte `tokio::task::spawn_blocking` verwenden.

4.  **`ApplicationMonitor::get_running_applications()` Methode:**
    * `pub async fn get_running_applications(&self) -> Result<Vec<RunningApplicationInfo>, ApplicationLauncherError>`
    * **Logik:** Gibt eine Kopie der intern gecachten `RunningApplicationInfo` Liste zurück.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/application_launcher_service/app_monitor.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::application_launcher_service::error::ApplicationLauncherError`
    * `crate::application_launcher_service::data_types::RunningApplicationInfo`
* **Extern:**
    * `tokio::sync::RwLock` oder `Mutex`
    * `tokio::task::spawn_blocking`
    * `sysinfo` crate (für Prozessstatistiken)
    * `tracing`
    * **Plattformspezifisch:**
        * `xcb` (für Linux/X11)
        * `winapi` (für Windows)
        * `core_foundation` oder `cocoa` (für macOS)

**Kommunikationsmuster:**

* Wird vom `ApplicationLauncherManager` (oder direkt vom `ApplicationLauncherService`) verwendet, um Informationen über laufende Anwendungen zu erhalten.
* Kann periodisch aufgerufen werden, um den Zustand der laufenden Anwendungen zu aktualisieren.

**Erwartete Ergebnisse/Outputs:**
Ein Modul, das Informationen über laufende Anwendungen sammeln kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking von `sysinfo` und Plattform-APIs):**
    * Mocken von `sysinfo::System` und den plattformspezifischen Fenstermanager-APIs.
    * Simulieren von laufenden Prozessen und Fenstern.
    * Testen von `refresh_running_applications`, um die korrekte Extraktion und Zuordnung von Informationen zu überprüfen.
* **Integration Tests (auf einer echten Maschine):**
    * Starten des `ApplicationMonitor` und Überprüfen, ob die gelieferten `RunningApplicationInfo` mit den tatsächlichen laufenden Prozessen und Fenstern übereinstimmen (z.B. Vergleich mit `htop`, Task-Manager).
    * Starten von Testanwendungen und Überprüfen, ob sie korrekt erkannt werden.

**Geschätzter Aufwand:** Sehr hoch (ca. 10-15 Tage, da plattformspezifische APIs, Prozess- und Fenstermanagement-Interaktion)

---
### **novade-system/src/application_launcher_service/manager.rs**

**Verantwortlichkeit:**
Der `ApplicationLauncherManager` ist die Kernlogik des Anwendungsstarter-Subsystems. Er ist verantwortlich für das Indizieren von Anwendungen, das Speichern des Anwendungs-Cache, das Suchen nach Anwendungen und deren Start. Er koordiniert sich mit dem `DesktopEntryParser` und optional dem `ApplicationMonitor`.

**Kern-Aufgaben (Tasks):**

1.  **`ApplicationLauncherManager` Struct:**
    * `pub struct ApplicationLauncherManager {`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `desktop_entry_parser: Arc<DesktopEntryParser>,`
        * `application_monitor: Option<Arc<ApplicationMonitor>>,` // Optional
        * `indexed_applications: RwLock<HashMap<String, ApplicationInfo>>,` // App ID -> ApplicationInfo
        * `current_config: RwLock<ApplicationLauncherConfig>,`
    * `}`

2.  **`ApplicationLauncherManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus, desktop_entry_parser: Arc<DesktopEntryParser>, application_monitor: Option<Arc<ApplicationMonitor>>) -> Result<Self, ApplicationLauncherError>`
    * **Logik:**
        * Initialisiert alle Felder.
        * Lädt die initiale `ApplicationLauncherConfig` aus dem `config_service`.
        * Führt einen initialen `index_applications()` Lauf aus, um den Anwendungs-Cache aufzubauen.
        * Gibt `Self` zurück.

3.  **`ApplicationLauncherManager::index_applications()` Methode:**
    * `pub async fn index_applications(&self) -> Result<(), ApplicationLauncherError>`
    * **Logik:**
        * Holt die XDG-Standardpfade von `DesktopEntryParser::get_xdg_paths()`.
        * Fügt die in `current_config.additional_app_paths` konfigurierten Pfade hinzu.
        * Iteriert rekursiv durch diese Pfade, um `.desktop`-Dateien zu finden (`walkdir` Crate).
        * Für jede `.desktop`-Datei:
            * Ruft `desktop_entry_parser.parse()` auf.
            * Bei Erfolg: Fügt die `ApplicationInfo` zur `indexed_applications` HashMap hinzu (mit `RwLock` Schreibzugriff).
        * Bereinigt veraltete Einträge aus `indexed_applications`, die nicht mehr gefunden wurden.
        * Sendet `SystemEvent::ApplicationIndexUpdated` an den `EventBus`.
        * **Hinweis:** Dieser Vorgang sollte `tokio::task::spawn_blocking` verwenden, da er Dateisystem-I/O und Parsing beinhaltet.

4.  **`ApplicationLauncherManager::get_all_applications()` Methode:**
    * `pub async fn get_all_applications(&self) -> Vec<ApplicationInfo>`
    * **Logik:** Gibt eine Liste aller Werte aus der `indexed_applications` HashMap zurück.

5.  **`ApplicationLauncherManager::search_applications()` Methode:**
    * `pub async fn search_applications(&self, query: &str) -> Vec<ApplicationInfo>`
    * **Logik:**
        * Durchsucht die `indexed_applications` nach Anwendungen, deren `name`, `generic_name`, `comment` oder `keywords` den `query` enthalten (case-insensitive).
        * Implementiert eine einfache Ranking-Logik (z.B. exakte Übereinstimmungen zuerst, dann Präfixe, dann Teilstücke).
        * Gibt eine gefilterte und sortierte Liste von `ApplicationInfo` zurück.

6.  **`ApplicationLauncherManager::get_applications_by_category()` Methode:**
    * `pub async fn get_applications_by_category(&self, category: &str) -> Vec<ApplicationInfo>`
    * **Logik:** Filtert `indexed_applications` nach Anwendungen, die die angegebene XDG-Kategorie enthalten.

7.  **`ApplicationLauncherManager::launch_application()` Methode:**
    * `pub async fn launch_application(&self, app_id: &str, args: Option<Vec<String>>) -> Result<u32, ApplicationLauncherError>`
    * **Logik:**
        * Sucht die `ApplicationInfo` anhand der `app_id` in `indexed_applications`.
        * Holt den `exec`-Befehl und parst ihn (Entfernen von `%u`, `%f` etc. Platzhaltern gemäß XDG-Spezifikation).
        * Wenn `terminal` `true` ist, präfigiert den Befehl mit dem konfigurierten `default_terminal_emulator`.
        * Führt den Befehl mit `tokio::process::Command` aus.
        * Gibt die PID des gestarteten Prozesses zurück.
        * Sendet `SystemEvent::ApplicationLaunched(app_id.to_string(), pid)` an den `EventBus`.

8.  **`ApplicationLauncherManager::get_application_info()` Methode:**
    * `pub async fn get_application_info(&self, app_id: &str) -> Result<ApplicationInfo, ApplicationLauncherError>`
    * **Logik:** Sucht die `ApplicationInfo` anhand der `app_id` und gibt sie zurück, falls gefunden.

9.  **`ApplicationLauncherManager::get_running_applications()` Methode (Optional):**
    * `pub async fn get_running_applications(&self) -> Result<Vec<RunningApplicationInfo>, ApplicationLauncherError>`
    * **Logik:** Delegiert an `self.application_monitor.refresh_running_applications()` (falls vorhanden).

10. **`ApplicationLauncherManager::update_config()` Methode (intern, vom Service aufgerufen bei `SystemEvent::ConfigChanged`):**
    * `pub async fn update_config(&self, new_config: ApplicationLauncherConfig)`
    * **Logik:**
        * Aktualisiert die interne `current_config`.
        * Wenn `additional_app_paths` oder `auto_refresh_index` geändert wurden, sollte `index_applications()` erneut aufgerufen werden.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/application_launcher_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::application_launcher_service::error::ApplicationLauncherError`
    * `crate::application_launcher_service::data_types::{ApplicationInfo, RunningApplicationInfo, ApplicationLauncherConfig}`
    * `crate::application_launcher_service::desktop_entry_parser::DesktopEntryParser`
    * `crate::application_launcher_service::app_monitor::ApplicationMonitor` (optional)
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::sync::RwLock`
    * `tokio::process::Command`
    * `tokio::task::spawn_blocking`
    * `std::sync::Arc`
    * `std::collections::HashMap`
    * `std::path::PathBuf`
    * `walkdir` crate (zum Durchsuchen von Verzeichnissen)
    * `tracing`

**Kommunikationsmuster:**

* Ist die zentrale Logik für den Anwendungsstarter.
* Nutzt `DesktopEntryParser` zur Verarbeitung von `.desktop`-Dateien.
* Nutzt `ApplicationMonitor` zur Überwachung laufender Anwendungen.
* Interagiert mit `ConfigService` für Konfigurations-Updates.
* Sendet `SystemEvent::ApplicationLaunched` und `SystemEvent::ApplicationIndexUpdated` an den `EventBus`.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Anwendungsstarter-Manager, der Anwendungen effizient indizieren, suchen, starten und optional überwachen kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `DesktopEntryParser` und `ApplicationMonitor`.
    * Testen von `new` und dem initialen `index_applications` Lauf.
    * Testen von `index_applications`: Simulieren des Parsens von `.desktop`-Dateien und Überprüfen der korrekten Füllung von `indexed_applications` und der Event-Sendung.
    * Testen von `get_all_applications`, `search_applications` (mit verschiedenen Suchbegriffen und Erwartungen) und `get_applications_by_category`.
    * Testen von `launch_application`: Mocken von `tokio::process::Command` und Überprüfen der korrekten Befehlszusammenstellung und PID-Rückgabe sowie der Event-Sendung.
    * Testen von `get_application_info` und `get_running_applications`.
    * Testen von `update_config` und des erneuten Indizierungslaufs.
* **Integration Tests:**
    * Starten des `ApplicationLauncherManager` mit realen `DesktopEntryParser` und `ApplicationMonitor` (falls implementiert).
    * Erstellen eines temporären Verzeichnisses mit echten (oder vereinfachten) `.desktop`-Dateien.
    * Testen der End-to-End-Indexierung, Suche und des Startens von Shell-Skripten.
    * Beobachten der `SystemEvent`s auf dem `EventBus`.

**Geschätzter Aufwand:** Sehr hoch (ca. 10-15 Tage, da Indizierung, Suchlogik, Prozess-Start, XDG-Spezifikation und Fehlerbehandlung)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `file_manager_service`, widmen wir uns `application_launcher_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/application_launcher_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/application_launcher_service/data_types.rs`**: Definition der Datentypen für Anwendungen und laufende Prozesse.
3.  **`novade-system/src/application_launcher_service/desktop_entry_parser.rs`**: Implementierung des Parsers für `.desktop`-Dateien.
4.  **`novade-system/src/application_launcher_service/app_monitor.rs`**: Optional, aber wenn implementiert, sollte es hier folgen. Ermöglicht die Überwachung laufender Anwendungen.
5.  **`novade-system/src/application_launcher_service/manager.rs`**: Die Kernlogik für Indizierung, Suche, Start und Management von Anwendungen.
6.  **`novade-system/src/application_launcher_service/mod.rs`**: Das Hauptmodul, das den Manager und seine Sub-Komponenten initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/application_launcher_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/notification_service` Verzeichnisses.
---
### **novade-system/src/notification_service/mod.rs**

**Verantwortlichkeit:**
Das `notification_service` Modul verwaltet System- und Anwendungsbenachrichtigungen. Es empfängt Benachrichtigungsanfragen von verschiedenen Quellen, verarbeitet sie (z.B. Filterung, DND-Modus, Persistenz) und stellt sie für die Anzeige in der UI bereit. Es implementiert den FreeDesktop.org Desktop Notifications Specification.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/notification_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Benachrichtigungs-Operationen)
    * `manager.rs` (Logik für Benachrichtigungs-Verwaltung, Persistenz, DND-Modus)
    * `data_types.rs` (Definition von Benachrichtigungs-bezogenen Datentypen)
    * `dbus_server.rs` (Implementierung des D-Bus Servers für externe Benachrichtigungen)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Benachrichtigungs-Subsystems:**
    * `pub async fn initialize_notification_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<NotificationService, NotificationError>`
    * **Logik:**
        * Erstellt eine Instanz von `manager::NotificationManager`.
        * Initialisiert den `dbus_server::DBusServer` und startet ihn, um auf D-Bus-Benachrichtigungsanfragen zu hören.
        * Lädt initiale Konfigurationen aus dem `config_service` (z.B. DND-Status, Anzeigedauer, Benachrichtigungsverlauf).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Abonniert den `EventBus` für interne `SystemEvent::ShowNotification` Ereignisse.
        * Gibt ein gebündeltes `NotificationService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder des D-Bus Servers.

2.  **`NotificationService` Struct:**
    * `pub struct NotificationService {`
        * `manager: Arc<NotificationManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `dbus_server_handle: tokio::task::JoinHandle<()>,` // Handle zum Verwalten des D-Bus Server Tasks
    * `}`
    * Dient als Container und Zugangspunkt für die Benachrichtigungs-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `NotificationService` exponiert Methoden zur Interaktion mit Benachrichtigungen.
    * `pub async fn send_notification(&self, notification_data: &Notification) -> Result<u32, NotificationError>`
        * **Logik:** Delegiert an den `manager`, um eine Benachrichtigung zu verarbeiten und zu speichern. Gibt eine eindeutige Benachrichtigungs-ID zurück. Sendet `SystemEvent::NotificationAdded`.
    * `pub async fn close_notification(&self, notification_id: u32) -> Result<(), NotificationError>`
        * **Logik:** Delegiert an den `manager`, um eine Benachrichtigung zu schließen/entfernen. Sendet `SystemEvent::NotificationClosed`.
    * `pub async fn get_all_notifications(&self) -> Result<Vec<Notification>, NotificationError>`
        * **Logik:** Delegiert an den `manager`, um alle aktiven oder kürzlich geschlossenen Benachrichtigungen abzurufen.
    * `pub async fn get_notification_history(&self) -> Result<Vec<Notification>, NotificationError>`
        * **Logik:** Delegiert an den `manager`, um den vollständigen Benachrichtigungsverlauf abzurufen.
    * `pub async fn clear_all_notifications(&self) -> Result<(), NotificationError>`
        * **Logik:** Delegiert an den `manager`, um alle Benachrichtigungen zu löschen. Sendet `SystemEvent::NotificationsCleared`.
    * `pub async fn set_dnd_mode(&self, enabled: bool) -> Result<(), NotificationError>`
        * **Logik:** Delegiert an den `manager`, um den "Bitte nicht stören"-Modus zu aktivieren/deaktivieren. Aktualisiert den `config_service`. Sendet `SystemEvent::DNDModeChanged`.
    * `pub async fn is_dnd_mode_enabled(&self) -> Result<bool, NotificationError>`
        * **Logik:** Delegiert an den `manager`, um den aktuellen DND-Status abzurufen.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `NotificationService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Einstellungen (z.B. DND-Status) geändert werden, werden die Sub-Komponenten (`NotificationManager`) informiert.

5.  **Hintergrund-Task zum Abonnieren von internen Benachrichtigungs-Events:**
    * Der `NotificationService` sollte auf `SystemEvent::ShowNotification` hören, um Benachrichtigungen, die von anderen internen Systemdiensten ausgelöst werden, entgegenzunehmen und über `send_notification` an den `manager` weiterzuleiten.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::notification_service::error::NotificationError`
    * `crate::notification_service::manager::NotificationManager`
    * `crate::notification_service::data_types::{Notification, NotificationConfig}`
    * `crate::notification_service::dbus_server::DBusServer`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `futures::stream::StreamExt`

**Kommunikationsmuster:**

* Ist der primäre Controller für das Benachrichtigungssystem.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Benachrichtigungseinstellungen.
* Empfängt Benachrichtigungen über D-Bus und den internen `EventBus`.
* Sendet `SystemEvent::NotificationAdded`, `SystemEvent::NotificationClosed`, `SystemEvent::NotificationsCleared`, `SystemEvent::DNDModeChanged` an den `EventBus`, um UI-Komponenten und andere Systemdienste zu informieren.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Benachrichtigungs-Subsystem, das Benachrichtigungen empfangen, verwalten und für die Anzeige bereitstellen kann, inklusive D-Bus-Integration.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `NotificationManager` und `DBusServer`.
    * Testen der Initialisierung, insbesondere des Starts des D-Bus Servers und des Abonnierens von Events.
    * Testen der Weiterleitung von API-Aufrufen an den `NotificationManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren des Empfangs von `SystemEvent::ShowNotification` und Überprüfen, ob `send_notification` aufgerufen wird.
    * Überprüfen, ob die korrekten `SystemEvent::Notification*` Ereignisse gesendet werden.
* **Integration Tests:**
    * Starten des `NotificationService` in einer Testumgebung.
    * Senden von Benachrichtigungen über die D-Bus-Schnittstelle (z.B. mit `busctl` oder einer D-Bus-Client-Bibliothek im Test).
    * Senden von internen `SystemEvent::ShowNotification` Ereignissen.
    * Überprüfen, ob die Benachrichtigungen korrekt im `NotificationManager` verarbeitet und abgerufen werden können.
    * Überprüfen, ob der `EventBus` die korrekten Benachrichtigungs-Ereignisse sendet.
    * Testen des DND-Modus und seiner Auswirkungen auf eingehende Benachrichtigungen.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da D-Bus-Integration, Historienverwaltung und DND-Logik)

---
### **novade-system/src/notification_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `notification_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Benachrichtigungs-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum NotificationError {`
        * `#[error("Notification with ID '{0}' not found.")]`
        * `NotificationNotFound(u32),`
        * `#[error("Failed to connect to D-Bus: {0}")]`
        * `DBusConnectionFailed(String),`
        * `#[error("Failed to register D-Bus service/interface: {0}")]`
        * `DBusRegistrationFailed(String),`
        * `#[error("Invalid notification data: {0}")]`
        * `InvalidNotificationData(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Unknown notification error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `anyhow::Error` (und potenziell Fehler aus D-Bus-Crates).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `notification_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Benachrichtigungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/notification_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `notification_service` verwendet werden, um Benachrichtigungen, deren Attribute und zugehörige Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`Notification` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct Notification {`
        * `pub id: u32,` // Eindeutige ID der Benachrichtigung (von Server zugewiesen)
        * `pub app_name: String,`
        * `pub replaces_id: Option<u32>,` // ID der zu ersetzenden Benachrichtigung
        * `pub app_icon: Option<String>,` // Icon-Name oder Pfad
        * `pub summary: String,` // Titel der Benachrichtigung
        * `pub body: String,` // Haupttext der Benachrichtigung
        * `pub actions: Vec<NotificationAction>,` // Liste der klickbaren Aktionen
        * `pub hints: NotificationHints,` // Zusätzliche Hinweise (z.B. Timeout, Kategorien)
        * `pub expires_at: Option<u64>,` // Unix-Timestamp wann die Benachrichtigung automatisch geschlossen werden soll
        * `pub created_at: u64,` // Unix-Timestamp wann die Benachrichtigung erstellt wurde
        * `pub is_closed: bool,` // Flag, ob die Benachrichtigung geschlossen wurde
        * `pub closed_reason: Option<NotificationClosedReason>,` // Grund für das Schließen
    * `}`

2.  **`NotificationAction` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct NotificationAction {`
        * `pub key: String,` // Eindeutiger Schlüssel für die Aktion
        * `pub label: String,` // Anzeigetext der Aktion
    * `}`

3.  **`NotificationHints` Struct:**
    * `#[derive(Debug, Default, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct NotificationHints {`
        * `pub category: Option<String>,` // FreeDesktop.org Benachrichtigungskategorie (z.B. "device", "email")
        * `pub desktop_entry: Option<String>,` // Desktop Entry ID der anfordernden Anwendung
        * `pub resident: Option<bool>,` // Ob die Benachrichtigung persistent sein soll
        * `pub urgency: Option<NotificationUrgency>,`
        * `pub x: Option<i32>,` // X-Koordinate (optional)
        * `pub y: Option<i32>,` // Y-Koordinate (optional)
        * `pub transient: Option<bool>,` // Ob die Benachrichtigung nicht im Verlauf gespeichert werden soll
        * `// ... weitere Hints gemäß Spezifikation`
    * `}`

4.  **`NotificationUrgency` Enum:**
    * `#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum NotificationUrgency { Low, Normal, Critical }`

5.  **`NotificationClosedReason` Enum:**
    * `#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum NotificationClosedReason { Expired, DismissedByUser, CalledAction, ClosedByApp }`

6.  **`NotificationConfig` Struct (aus `settings_manager::data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct NotificationConfig {`
        * `pub do_not_disturb_mode: bool,`
        * `pub default_timeout_seconds: u32,`
        * `pub show_notification_previews: bool,`
        * `pub persist_history_days: u32,`
        * `pub blocked_app_ids: Vec<String>,` // Anwendungen, deren Benachrichtigungen blockiert werden
        * `// ...`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::collections::HashMap`
* **Intern:**
    * `crate::settings_manager::data_types::NotificationConfig` (oder direkter Import)

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Benachrichtigungsinformationen im System.
* `Notification` Objekte werden vom `NotificationManager` generiert, verwaltet und gespeichert.
* `NotificationConfig` wird im `SettingsManagerService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für das Benachrichtigungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.
    * Überprüfen der Standardwerte und optionalen Felder.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/notification_service/dbus_server.rs**

**Verantwortlichkeit:**
Das `dbus_server` Modul implementiert den D-Bus-Server für den Notification Service. Es exponiert die `org.freedesktop.Notifications` Schnittstelle, um Benachrichtigungen von anderen Anwendungen (z.B. Firefox, Thunderbird, Terminal-Benachrichtigungen) zu empfangen und zu verarbeiten.

**Kern-Aufgaben (Tasks):**

1.  **`DBusServer` Struct:**
    * `pub struct DBusServer {`
        * `manager_sender: tokio::sync::mpsc::Sender<NotificationDataForManager>,` // Sender zum NotificationManager
        * `connection_handle: tokio::task::JoinHandle<()>,` // Handle für den D-Bus Event-Loop Task
    * `}`

2.  **`NotificationDataForManager` Enum/Struct:**
    * Eine interne Repräsentation der D-Bus-Daten, die an den Manager gesendet werden.
    * `pub enum NotificationDataForManager {`
        * `Show(String, u32, String, String, String, Vec<String>, HashMap<String, zbus::zvariant::Value>, i32),` // Parameter aus Notify-Methode
        * `Close(u32),`
        * `GetCapabilities,`
        * `GetServerInformation,`
    * `}`

3.  **`DBusServer::new()` Funktion:**
    * `pub async fn new(manager_sender: tokio::sync::mpsc::Sender<NotificationDataForManager>) -> Result<Self, NotificationError>`
    * **Logik:**
        * Stellt eine Verbindung zum Session D-Bus her (`zbus::Connection::session`).
        * Registriert den Service-Namen `org.freedesktop.Notifications`.
        * Registriert die Schnittstelle `org.freedesktop.Notifications` auf dem Pfad `/org/freedesktop/Notifications`.
        * Startet einen Hintergrund-Task, der den D-Bus-Event-Loop ausführt und eingehende Methodenaufrufe (`Notify`, `CloseNotification`, `GetCapabilities`, `GetServerInformation`) empfängt.
        * Leitet die geparsten Daten an den `manager_sender` weiter.
        * Gibt `Self` zurück.

4.  **Implementierung der D-Bus-Methoden:**
    * `Notify(app_name: String, replaces_id: u32, app_icon: String, summary: String, body: String, actions: Vec<String>, hints: HashMap<String, zbus::zvariant::Value>, expire_timeout: i32) -> Result<u32, zbus::Error>`
        * **Logik:** Empfängt die Parameter, konvertiert sie in ein `NotificationDataForManager::Show` und sendet es an den `manager_sender`. Gibt die vom Manager zugewiesene Benachrichtigungs-ID zurück.
    * `CloseNotification(id: u32) -> Result<(), zbus::Error>`
        * **Logik:** Sendet `NotificationDataForManager::Close` an den `manager_sender`.
    * `GetCapabilities() -> Result<Vec<String>, zbus::Error>`
        * **Logik:** Sendet `NotificationDataForManager::GetCapabilities` an den `manager_sender` und wartet auf Antwort. Gibt unterstützte Fähigkeiten zurück (z.B. "actions", "body", "hints", "body-markup", "persistence").
    * `GetServerInformation() -> Result<(String, String, String, String), zbus::Error>`
        * **Logik:** Sendet `NotificationDataForManager::GetServerInformation` an den `manager_sender` und wartet auf Antwort. Gibt Server-Informationen zurück (Name, Vendor, Version, Spec Version).

5.  **Implementierung der D-Bus-Signale:**
    * `ActionInvoked(id: u32, action_key: String)`
        * **Logik:** Wird vom `NotificationManager` ausgelöst, wenn eine Aktion einer Benachrichtigung angeklickt wird.
    * `NotificationClosed(id: u32, reason: u32)`
        * **Logik:** Wird vom `NotificationManager` ausgelöst, wenn eine Benachrichtigung geschlossen wird (z.B. durch Timeout oder Benutzer).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/dbus_server.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::notification_service::error::NotificationError`
    * `crate::notification_service::data_types` (für Konvertierung von D-Bus-Typen in interne Typen)
* **Extern:**
    * `zbus` crate (für D-Bus-Kommunikation)
    * `tokio::sync::mpsc`
    * `tokio::task`
    * `std::collections::HashMap`
    * `tracing`

**Kommunikationsmuster:**

* Stellt eine D-Bus-Schnittstelle für externe Anwendungen bereit.
* Empfängt D-Bus-Methodenaufrufe und leitet sie an den `NotificationManager` weiter.
* Empfängt Signale vom `NotificationManager` und sendet sie über D-Bus.

**Erwartete Ergebnisse/Outputs:**
Ein funktionierender D-Bus-Server, der Benachrichtigungsanfragen von anderen Anwendungen empfangen und die FreeDesktop.org Spezifikation implementieren kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking von `zbus`):**
    * Mocken von `zbus::Connection` und Simulieren von eingehenden D-Bus-Methodenaufrufen.
    * Testen der korrekten Weiterleitung der geparsten Daten an den `manager_sender`.
    * Testen der `GetCapabilities` und `GetServerInformation` Methoden.
    * Simulieren des Empfangs von Antworten vom `manager_sender` und Überprüfen der korrekten Rückgabe an D-Bus.
* **Integration Tests (mit echtem D-Bus):**
    * Starten des `DBusServer` und des `NotificationManager` in einer Testumgebung.
    * Verwenden von `busctl` oder einer D-Bus-Client-Bibliothek (z.B. `zbus::blocking::Connection` im Test-Setup) um:
        * `Notify` Aufrufe zu senden und die empfangene ID zu überprüfen.
        * `CloseNotification` Aufrufe zu senden.
        * `GetCapabilities` und `GetServerInformation` abzufragen.
    * Abonnieren der D-Bus-Signale `ActionInvoked` und `NotificationClosed` und Überprüfen, ob sie korrekt ausgelöst werden.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da D-Bus-Spezifikation, Asynchronität und Fehlerbehandlung)

---
### **novade-system/src/notification_service/manager.rs**

**Verantwortlichkeit:**
Der `NotificationManager` ist die Kernlogik des Benachrichtigungssystems. Er speichert und verwaltet Benachrichtigungen, verarbeitet eingehende Anfragen (inkl. DND-Modus-Prüfung), weist IDs zu, verwaltet den Benachrichtigungsverlauf und löst D-Bus-Signale aus.

**Kern-Aufgaben (Tasks):**

1.  **`NotificationManager` Struct:**
    * `pub struct NotificationManager {`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `notifications: RwLock<HashMap<u32, Notification>>,` // Aktive und kürzlich geschlossene Benachrichtigungen
        * `next_notification_id: Arc<AtomicU32>,` // Atomarer Zähler für eindeutige IDs
        * `current_config: RwLock<NotificationConfig>,`
        * `dbus_sender_for_manager: tokio::sync::mpsc::Receiver<NotificationDataForManager>,` // Empfänger vom DBusServer
        * `dbus_signal_sender: tokio::sync::mpsc::Sender<DBusSignal>,` // Sender zu DBusServer für Signale
    * `}`

2.  **`DBusSignal` Enum:**
    * `pub enum DBusSignal { ActionInvoked(u32, String), NotificationClosed(u32, u32) }`

3.  **`NotificationManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus, dbus_sender_for_manager: tokio::sync::mpsc::Receiver<NotificationDataForManager>, dbus_signal_sender: tokio::sync::mpsc::Sender<DBusSignal>) -> Result<Self, NotificationError>`
    * **Logik:**
        * Initialisiert alle Felder.
        * Lädt die initiale `NotificationConfig` aus dem `config_service`.
        * Lädt den Benachrichtigungsverlauf aus dem persistierten Speicher (falls vorhanden und konfiguriert).
        * Startet einen Hintergrund-Task, der den `dbus_sender_for_manager` abhört und D-Bus-Anfragen verarbeitet (`self.handle_dbus_requests_task()`).
        * Startet optional einen Hintergrund-Task für Timeout-Management (`self.timeout_management_task()`).
        * Gibt `Self` zurück.

4.  **`NotificationManager::send_notification()` Methode:**
    * `pub async fn send_notification(&self, notification_data: Notification) -> Result<u32, NotificationError>`
    * **Logik:**
        * **DND-Modus-Prüfung:** Wenn DND aktiviert und die Benachrichtigung keine "critical" Urgency hat, wird die Benachrichtigung stillschweigend verworfen oder nur in den Verlauf aufgenommen.
        * **App-Blockierung:** Prüft `blocked_app_ids` in `current_config`. Wenn die `app_name` blockiert ist, wird die Benachrichtigung verworfen.
        * **ID-Zuweisung/Ersetzen:**
            * Wenn `replaces_id` in `notification_data` vorhanden ist, wird versucht, eine bestehende Benachrichtigung zu ersetzen.
            * Andernfalls wird eine neue eindeutige `id` von `next_notification_id` generiert.
        * Setzt `created_at` auf den aktuellen Timestamp.
        * Berechnet `expires_at` basierend auf `expire_timeout` und `default_timeout_seconds` aus der Konfiguration.
        * Fügt die Benachrichtigung zur `notifications` HashMap hinzu.
        * Speichert die Benachrichtigung persistent (falls konfiguriert).
        * Sendet `SystemEvent::NotificationAdded(notification.clone())` an den `EventBus`.
        * Gibt die zugewiesene `id` zurück.

5.  **`NotificationManager::close_notification()` Methode:**
    * `pub async fn close_notification(&self, notification_id: u32, reason: NotificationClosedReason) -> Result<(), NotificationError>`
    * **Logik:**
        * Sucht die Benachrichtigung in `notifications`.
        * Setzt `is_closed` auf `true` und `closed_reason`.
        * Speichert den aktualisierten Zustand persistent.
        * Sendet `SystemEvent::NotificationClosed(notification_id, reason)` an den `EventBus`.
        * Löst `DBusSignal::NotificationClosed(notification_id, reason_code)` an den D-Bus-Server aus.

6.  **`NotificationManager::get_all_notifications()` Methode:**
    * `pub async fn get_all_notifications(&self) -> Vec<Notification>`
    * **Logik:** Gibt alle **nicht geschlossenen** Benachrichtigungen aus `notifications` zurück.

7.  **`NotificationManager::get_notification_history()` Methode:**
    * `pub async fn get_notification_history(&self) -> Vec<Notification>`
    * **Logik:** Gibt alle Benachrichtigungen aus `notifications` zurück, auch die geschlossenen, optional gefiltert nach `persist_history_days`.

8.  **`NotificationManager::clear_all_notifications()` Methode:**
    * `pub async fn clear_all_notifications(&self) -> Result<(), NotificationError>`
    * **Logik:** Löscht alle Benachrichtigungen aus `notifications` und aus dem persistenten Speicher. Sendet `SystemEvent::NotificationsCleared`.

9.  **`NotificationManager::set_dnd_mode()` Methode:**
    * `pub async fn set_dnd_mode(&self, enabled: bool) -> Result<(), NotificationError>`
    * **Logik:**
        * Aktualisiert `do_not_disturb_mode` in `current_config`.
        * Persistiert die Konfiguration über `config_service.save_config()`.
        * Sendet `SystemEvent::DNDModeChanged(enabled)` an den `EventBus`.

10. **`NotificationManager::is_dnd_mode_enabled()` Methode:**
    * `pub async fn is_dnd_mode_enabled(&self) -> bool`
    * **Logik:** Gibt den Wert von `current_config.do_not_disturb_mode` zurück.

11. **`NotificationManager::handle_dbus_requests_task()` Methode (intern):**
    * `async fn handle_dbus_requests_task(self: Arc<Self>, mut receiver: tokio::sync::mpsc::Receiver<NotificationDataForManager>)`
    * **Logik:**
        * Schleife, die auf `NotificationDataForManager` Events vom D-Bus-Server wartet.
        * Verarbeitet `Show`, `Close`, `GetCapabilities`, `GetServerInformation` durch Aufruf der entsprechenden `send_notification`, `close_notification` oder internen Helferfunktionen.
        * Antwortet auf D-Bus-Anfragen (`zbus::Message`).

12. **`NotificationManager::timeout_management_task()` Methode (intern):**
    * `async fn timeout_management_task(self: Arc<Self>)`
    * **Logik:**
        * Periodischer Task, der die `notifications` HashMap durchläuft.
        * Schließt Benachrichtigungen, deren `expires_at` überschritten ist, mit `NotificationClosedReason::Expired`.

13. **`NotificationManager::handle_action_invoked()` Methode (intern):**
    * `pub async fn handle_action_invoked(&self, notification_id: u32, action_key: String)`
    * **Logik:**
        * Findet die Benachrichtigung.
        * Löst `DBusSignal::ActionInvoked(notification_id, action_key)` an den D-Bus-Server aus.
        * Schließt die Benachrichtigung mit `NotificationClosedReason::CalledAction`.

14. **`NotificationManager::update_config()` Methode (intern, vom Service aufgerufen bei `SystemEvent::ConfigChanged`):**
    * `pub async fn update_config(&self, new_config: NotificationConfig)`
    * **Logik:** Aktualisiert die interne `current_config`. Führt ggf. eine Bereinigung des Verlaufs durch, wenn `persist_history_days` geändert wurde.

15. **Persistenz-Logik (intern):**
    * `async fn load_history(&self) -> Result<(), NotificationError>`
    * `async fn save_history(&self) -> Result<(), NotificationError>`
    * **Logik:** Lädt und speichert den Benachrichtigungsverlauf (z.B. in einer JSON-Datei im Konfigurationsverzeichnis).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/notification_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::notification_service::error::NotificationError`
    * `crate::notification_service::data_types::{Notification, NotificationAction, NotificationHints, NotificationUrgency, NotificationClosedReason, NotificationConfig}`
    * `crate::notification_service::dbus_server::{DBusServer, NotificationDataForManager, DBusSignal}` (für interne Kommunikationstypen)
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::sync::{RwLock, mpsc}`
    * `tokio::task`
    * `std::sync::{Arc, atomic::{AtomicU32, Ordering}}`
    * `std::collections::HashMap`
    * `time` crate (für Zeitstempel)
    * `serde_json` (für Persistenz)
    * `tracing`

**Kommunikationsmuster:**

* Ist die zentrale Logik für die Benachrichtigungsverwaltung.
* Empfängt D-Bus-Anfragen vom `DBusServer` und interne `SystemEvent::ShowNotification`s.
* Sendet D-Bus-Signale an den `DBusServer`.
* Interagiert mit `ConfigService` für Konfigurations-Updates und Persistenz.
* Sendet `SystemEvent::NotificationAdded`, `SystemEvent::NotificationClosed` etc. an den `EventBus`.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Benachrichtigungs-Manager, der die FreeDesktop.org Spezifikation implementiert, Benachrichtigungen speichert, filtert, schließt und den Verlauf verwaltet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus`, und der `mpsc::Sender`/`Receiver` Kanäle.
    * Testen von `send_notification`:
        * DND-Modus-Filterung (mit und ohne kritische Dringlichkeit).
        * App-Blockierung.
        * ID-Zuweisung und Ersetzung.
        * `expires_at` Berechnung.
        * Überprüfen der Speicherung in `notifications` und der Event-Sendung.
    * Testen von `close_notification`: Überprüfen des `is_closed`-Flags, des `closed_reason`, der Event-Sendung und des D-Bus-Signal-Auslösens.
    * Testen von `get_all_notifications` und `get_notification_history`.
    * Testen von `clear_all_notifications`.
    * Testen von `set_dnd_mode` und `is_dnd_mode_enabled`.
    * Testen des `handle_dbus_requests_task` durch Senden von `NotificationDataForManager` Events und Überprüfen der Manager-Aktionen.
    * Testen des `timeout_management_task` (durch Simulieren von Zeitablauf).
    * Testen der Persistenz (Speichern/Laden des Verlaufs).
* **Integration Tests:**
    * Starten des `NotificationManager` mit realen `ConfigService` und `EventBus` (in einer Testumgebung).
    * Simulieren einer Abfolge von Benachrichtigungen über den D-Bus-Kanal und den internen EventBus.
    * Überprüfen der Zustände des Managers (aktive Benachrichtigungen, Verlauf).
    * Testen der Interaktion mit der Konfiguration und der Persistenz.

**Geschätzter Aufwand:** Sehr hoch (ca. 10-15 Tage, da komplexe Zustandsverwaltung, D-Bus-Interaktion, Zeitmanagement, Persistenz und Filtersystem)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `application_launcher_service`, widmen wir uns `notification_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/notification_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/notification_service/data_types.rs`**: Definition der Datentypen für Benachrichtigungen und deren Attribute.
3.  **`novade-system/src/notification_service/dbus_server.rs`**: Implementierung des D-Bus-Servers, da er der externe Eingangspunkt für Benachrichtigungen ist.
4.  **`novade-system/src/notification_service/manager.rs`**: Die Kernlogik für die Benachrichtigungsverwaltung, die die D-Bus-Anfragen und internen Events verarbeitet.
5.  **`novade-system/src/notification_service/mod.rs`**: Das Hauptmodul, das den Manager und den D-Bus-Server initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/notification_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/power_manager_service` Verzeichnisses.
---
### **novade-system/src/power_manager_service/mod.rs**

**Verantwortlichkeit:**
Das `power_manager_service` Modul ist für die Überwachung und Steuerung von Energieeinstellungen des Systems zuständig. Es liest den Batteriestatus, überwacht den AC-Anschluss, verwaltet Energiesparpläne und ermöglicht Aktionen wie Suspend, Hibernate, Reboot und Shutdown. Es interagiert mit dem `config_service` für Präferenzen und dem `event_bus` für Zustandsänderungen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/power_manager_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Power Manager-Operationen)
    * `manager.rs` (Logik für Energieverwaltung, Statusüberwachung und Aktionen)
    * `data_types.rs` (Definition von Energie-bezogenen Datentypen)
    * `system_power_interface.rs` (Plattformspezifische Schnittstelle zu OS-Energie-APIs)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Power Manager-Subsystems:**
    * `pub async fn initialize_power_manager_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<PowerManagerService, PowerManagerError>`
    * **Logik:**
        * Erstellt eine Instanz von `system_power_interface::SystemPowerInterface` (plattformspezifisch).
        * Erstellt eine Instanz von `manager::PowerManager`.
        * Lädt initiale Konfigurationen aus dem `config_service` (z.B. Timeout für Display-Abschaltung, Suspend-Verhalten bei Inaktivität, kritischer Batteriestand).
        * Startet einen Hintergrund-Task, der periodisch den Batteriestatus und den AC-Anschluss überwacht und `SystemEvent::BatteryStatusChanged` oder `SystemEvent::PowerSourceChanged` sendet.
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Gibt ein gebündeltes `PowerManagerService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder der System-Schnittstelle.

2.  **`PowerManagerService` Struct:**
    * `pub struct PowerManagerService {`
        * `manager: Arc<PowerManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
    * `}`
    * Dient als Container und Zugangspunkt für die Energieverwaltungslogik.

3.  **Bereitstellung von API-Methoden:**
    * Der `PowerManagerService` exponiert Methoden zur Steuerung der Energieverwaltung.
    * `pub async fn get_battery_status(&self) -> Result<BatteryStatus, PowerManagerError>`
        * **Logik:** Delegiert an den `manager`, um den aktuellen Batteriestatus abzurufen.
    * `pub async fn is_ac_connected(&self) -> Result<bool, PowerManagerError>`
        * **Logik:** Delegiert an den `manager`, um den Status des AC-Anschlusses abzurufen.
    * `pub async fn suspend(&self) -> Result<(), PowerManagerError>`
        * **Logik:** Delegiert an den `manager`, um das System in den Suspend-Modus zu versetzen. Sendet `SystemEvent::SystemSuspended`.
    * `pub async fn hibernate(&self) -> Result<(), PowerManagerError>`
        * **Logik:** Delegiert an den `manager`, um das System in den Hibernate-Modus zu versetzen. Sendet `SystemEvent::SystemHibernated`.
    * `pub async fn reboot(&self) -> Result<(), PowerManagerError>`
        * **Logik:** Delegiert an den `manager`, um das System neu zu starten.
    * `pub async fn shutdown(&self) -> Result<(), PowerManagerError>`
        * **Logik:** Delegiert an den `manager`, um das System herunterzufahren.
    * `pub async fn set_display_timeout(&self, seconds: u32) -> Result<(), PowerManagerError>`
        * **Logik:** Delegiert an den `manager`, um den Bildschirm-Timeout einzustellen. Aktualisiert den `config_service`.
    * `pub async fn prevent_sleep(&self, reason: String) -> Result<u32, PowerManagerError>`
        * **Logik:** Delegiert an den `manager`, um das System vor dem Einschlafen zu bewahren (z.B. für Multimedia-Wiedergabe). Gibt eine Session-ID zurück.
    * `pub async fn allow_sleep(&self, session_id: u32) -> Result<(), PowerManagerError>`
        * **Logik:** Delegiert an den `manager`, um eine zuvor angeforderte Schlafverhinderung aufzuheben.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `PowerManagerService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Einstellungen (z.B. Energiepläne, Helligkeit) geändert werden, werden die Sub-Komponenten (`PowerManager`) informiert.

5.  **Hintergrund-Task zur Systemstatus-Überwachung:**
    * Ein Task, der periodisch (z.B. alle 5-10 Sekunden) `manager.get_battery_status()` und `manager.is_ac_connected()` aufruft. Bei Änderungen werden entsprechende `SystemEvent::BatteryStatusChanged` und `SystemEvent::PowerSourceChanged` an den `EventBus` gesendet.
    * Ein weiterer Task könnte die Systeminaktivität überwachen und bei Erreichen eines Schwellenwerts (aus der Konfiguration) Suspend- oder Display-Off-Aktionen triggern.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_manager_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_manager_service::error::PowerManagerError`
    * `crate::power_manager_service::manager::PowerManager`
    * `crate::power_manager_service::data_types::{BatteryStatus, PowerManagerConfig}`
    * `crate::power_manager_service::system_power_interface::SystemPowerInterface`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tokio::time`
    * `tracing`
    * `std::sync::Arc`
    * `futures::stream::StreamExt`

**Kommunikationsmuster:**

* Ist der primäre Controller für die Energieverwaltung.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Energieeinstellungen.
* Sendet `SystemEvent::BatteryStatusChanged`, `SystemEvent::PowerSourceChanged`, `SystemEvent::SystemSuspended`, `SystemEvent::SystemHibernated` an den `EventBus`, um UI-Komponenten und andere Systemdienste zu informieren.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes und funktionsfähiges Power Manager-Subsystem, das den Energie status überwacht und System-Energieaktionen steuern kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `PowerManager` und `SystemPowerInterface`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und des Starts der Überwachungs-Tasks.
    * Testen der Weiterleitung von API-Aufrufen an den `PowerManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von Batteriestatus- und Stromquellenänderungen durch den Mock-`SystemPowerInterface` und Überprüfen, ob die korrekten `SystemEvent`s gesendet werden.
* **Integration Tests:**
    * Starten des `PowerManagerService` in einer Testumgebung (ggf. mit einer simulierten Plattform-Schnittstelle).
    * Testen der Abfrage des Batteriestatus und des AC-Anschlusses.
    * Auslösen von Suspend/Hibernate/Reboot/Shutdown (Vorsicht in Testumgebung, kann Hardware-Interaktion erfordern oder gemockt werden).
    * Überprüfen, ob der `EventBus` die korrekten Energie-Ereignisse sendet.

**Geschätzter Aufwand:** Hoch (ca. 6-9 Tage, da System-Interaktion, plattformspezifische APIs und periodische Überwachung)

---
### **novade-system/src/power_manager_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `power_manager_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Energieverwaltungs-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`PowerManagerError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum PowerManagerError {`
        * `#[error("Failed to retrieve battery status: {0}")]`
        * `BatteryStatusFailed(String),`
        * `#[error("Failed to perform system power action: {0}")]`
        * `SystemPowerActionFailed(String),`
        * `#[error("Failed to prevent system sleep: {0}")]`
        * `PreventSleepFailed(String),`
        * `#[error("Invalid sleep prevention session ID: {0}")]`
        * `InvalidSleepPreventionSessionId(u32),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Platform specific error: {0}")]`
        * `PlatformError(String),`
        * `#[error("Unknown power manager error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `anyhow::Error` (und potenziell plattformspezifische Fehler).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_manager_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `power_manager_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Energieverwaltungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/power_manager_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `power_manager_service` verwendet werden, um Batteriestatus, Energiequellen und zugehörige Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`BatteryStatus` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct BatteryStatus {`
        * `pub percentage: u8,` // 0-100%
        * `pub charging: bool,`
        * `pub discharging: bool,`
        * `pub time_remaining_minutes: Option<u32>,` // Geschätzte Restzeit in Minuten
        * `pub health_percent: Option<u8>,` // Batteriezustand (z.B. Kapazität im Vergleich zur Design-Kapazität)
        * `pub voltage: Option<f32>,` // Spannung
        * `pub current: Option<f32>,` // Strom (A)
        * `pub power_watt: Option<f32>,` // Aktueller Verbrauch/Ladeleistung (W)
        * `pub capacity_full_design_mwh: Option<u32>,` // Design-Kapazität in mWh
        * `pub capacity_full_mwh: Option<u32>,` // Aktuelle volle Kapazität in mWh
    * `}`

2.  **`PowerManagerConfig` Struct (aus `settings_manager::data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct PowerManagerConfig {`
        * `pub screen_timeout_ac_seconds: u32,`
        * `pub screen_timeout_battery_seconds: u32,`
        * `pub suspend_on_inactivity_ac_minutes: Option<u32>,`
        * `pub suspend_on_inactivity_battery_minutes: Option<u32>,`
        * `pub critical_battery_percentage: u8,`
        * `pub low_battery_percentage: u8,`
        * `pub critical_battery_action: SystemPowerAction,` // z.B. Suspend, Shutdown
        * `pub lid_close_action_ac: SystemPowerAction,`
        * `pub lid_close_action_battery: SystemPowerAction,`
        * `pub enable_adaptive_brightness: bool,`
        * `// ...`
    * `}`

3.  **`SystemPowerAction` Enum:**
    * `#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum SystemPowerAction { None, Suspend, Hibernate, Shutdown, Reboot }`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_manager_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
* **Intern:**
    * `crate::settings_manager::data_types::PowerManagerConfig` (oder direkter Import)

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Energieinformationen im System.
* `BatteryStatus` Objekte werden vom `PowerManager` und `SystemPowerInterface` generiert.
* `PowerManagerConfig` wird im `SettingsManagerService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Energieverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.
    * Überprüfen der Standardwerte und optionalen Felder.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/power_manager_service/system_power_interface.rs**

**Verantwortlichkeit:**
Das `system_power_interface` Modul bietet eine plattformspezifische Abstraktionsschicht für den Zugriff auf Betriebssystem-APIs zur Energieverwaltung. Dies ist entscheidend, da Energieaktionen und das Abrufen des Batteriestatus je nach Betriebssystem (Linux, Windows, macOS) stark variieren.

**Kern-Aufgaben (Tasks):**

1.  **`SystemPowerInterface` Struct:**
    * `pub struct SystemPowerInterface {`
        * `// Plattformspezifische Handles/Clients hier, z.B. zbus::Connection für UPower/Logind unter Linux`
        * `// oder sysinfo::System für grundlegende Infos.`
        * `sysinfo_system: tokio::sync::Mutex<sysinfo::System>,`
        * `#[cfg(target_os = "linux")]`
        * `upower_proxy: Option<Arc<zbus::Proxy<'static>>>,` // Für UPower-Interaktion
        * `#[cfg(target_os = "linux")]`
        * `logind_proxy: Option<Arc<zbus::Proxy<'static>>>,` // Für Logind/Systemd-Interaktion
    * `}`

2.  **`SystemPowerInterface::new()` Funktion:**
    * `pub async fn new() -> Result<Self, PowerManagerError>`
    * **Logik:**
        * Initialisiert eine `sysinfo::System` Instanz.
        * **Plattformspezifisch:**
            * **Linux:** Versucht, Verbindungen zu D-Bus-Diensten wie UPower (für Batteriestatus) und Logind/Systemd (für Suspend/Hibernate/Shutdown) herzustellen und Proxys zu erstellen. Wenn D-Bus-Verbindungen fehlschlagen, fällt es auf `sysinfo` als grundlegende Fallback-Lösung zurück.
            * **Windows:** Initialisiert benötigte Windows-APIs (z.B. `winapi::um::powerbase::*`, `winapi::um::handleapi::*`).
            * **macOS:** Initialisiert benötigte macOS-Frameworks (z.B. IOKit).
        * Gibt `Self` zurück.
        * **Fehlerbehandlung:** `PlatformError` bei Problemen mit nativen APIs.

3.  **`SystemPowerInterface::get_battery_status()` Methode:**
    * `pub async fn get_battery_status(&self) -> Result<BatteryStatus, PowerManagerError>`
    * **Logik:**
        * **Plattformspezifisch:**
            * **Linux:** Bevorzugt UPower D-Bus API, sonst `sysinfo`. Parsen der Daten in `BatteryStatus`.
            * **Windows:** Nutzt `GetSystemPowerStatus` oder WMI.
            * **macOS:** Nutzt IOKit APIs.
        * **Hinweis:** Dies sollte `tokio::task::spawn_blocking` verwenden, da native API-Aufrufe blockierend sein können.

4.  **`SystemPowerInterface::is_ac_connected()` Methode:**
    * `pub async fn is_ac_connected(&self) -> Result<bool, PowerManagerError>`
    * **Logik:**
        * **Plattformspezifisch:**
            * **Linux:** UPower oder `sysinfo`.
            * **Windows:** `GetSystemPowerStatus`.
            * **macOS:** IOKit.
        * **Hinweis:** `tokio::task::spawn_blocking` kann hier ebenfalls angemessen sein.

5.  **`SystemPowerInterface::suspend()` Methode:**
    * `pub async fn suspend(&self) -> Result<(), PowerManagerError>`
    * **Logik:**
        * **Plattformspezifisch:**
            * **Linux:** Über D-Bus an Logind/Systemd (`org.freedesktop.login1.Manager.Suspend` oder `org.freedesktop.login1.Manager.SuspendWithFlags`).
            * **Windows:** `SetSuspendState`.
            * **macOS:** `IOPMSleepSystem()`.
        * **Hinweis:** Muss blockierend sein, bis das System schläft oder ein Fehler auftritt. `tokio::task::spawn_blocking`.

6.  **`SystemPowerInterface::hibernate()` Methode:**
    * `pub async fn hibernate(&self) -> Result<(), PowerManagerError>`
    * **Logik:**
        * **Plattformspezifisch:**
            * **Linux:** Über D-Bus an Logind/Systemd (`org.freedesktop.login1.Manager.Hibernate`).
            * **Windows:** `SetSuspendState` mit Hibernate-Flag.
            * **macOS:** `IOPSystemShutdown()`.
        * **Hinweis:** `tokio::task::spawn_blocking`.

7.  **`SystemPowerInterface::reboot()` Methode:**
    * `pub async fn reboot(&self) -> Result<(), PowerManagerError>`
    * **Logik:**
        * **Plattformspezifisch:**
            * **Linux:** Über D-Bus an Logind/Systemd (`org.freedesktop.login1.Manager.Reboot`).
            * **Windows:** `ExitWindowsEx(EWX_REBOOT, ...)`
            * **macOS:** `reboot(RB_AUTOBOOT)`.
        * **Hinweis:** `tokio::task::spawn_blocking`.

8.  **`SystemPowerInterface::shutdown()` Methode:**
    * `pub async fn shutdown(&self) -> Result<(), PowerManagerError>`
    * **Logik:**
        * **Plattformspezifisch:**
            * **Linux:** Über D-Bus an Logind/Systemd (`org.freedesktop.login1.Manager.PowerOff`).
            * **Windows:** `ExitWindowsEx(EWX_SHUTDOWN, ...)`
            * **macOS:** `poweroff(RB_HALT)`.
        * **Hinweis:** `tokio::task::spawn_blocking`.

9.  **`SystemPowerInterface::set_display_timeout()` Methode:**
    * `pub async fn set_display_timeout(&self, seconds: u32) -> Result<(), PowerManagerError>`
    * **Logik:** Plattformspezifische Einstellung des Display-Timeouts (z.B. über D-Bus an `org.gnome.SettingsDaemon.Power` oder `org.kde.KScreen` unter Linux, Registery unter Windows, Power Management APIs unter macOS).

10. **`SystemPowerInterface::prevent_sleep()` Methode (Optional, für Wake-Locks):**
    * `pub async fn prevent_sleep(&self, reason: String) -> Result<u32, PowerManagerError>`
    * **Logik:**
        * **Plattformspezifisch:**
            * **Linux:** D-Bus an Logind/Systemd (`org.freedesktop.login1.Manager.Inhibit`). Gibt eine Inhibit-FD zurück, die gehalten werden muss.
            * **Windows:** `SetThreadExecutionState`.
            * **macOS:** `IOPMAssertionCreate`.
        * Gibt eine Session-ID oder Handle zurück.

11. **`SystemPowerInterface::allow_sleep()` Methode (Optional, für Wake-Locks):**
    * `pub async fn allow_sleep(&self, session_id: u32) -> Result<(), PowerManagerError>`
    * **Logik:** Enthebt die Schlafverhinderung unter Verwendung der Session-ID/des Handles.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_manager_service/system_power_interface.rs`
* `novade-system/src/power_manager_service/linux.rs` (oder ähnliche, für plattformspezifische Implementierungen)
* `novade-system/src/power_manager_service/windows.rs`
* `novade-system/src/power_manager_service/macos.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_manager_service::error::PowerManagerError`
    * `crate::power_manager_service::data_types::{BatteryStatus, SystemPowerAction}`
* **Extern:**
    * `tokio::task::spawn_blocking`
    * `sysinfo` crate (für grundlegende Systeminformationen)
    * `tracing`
    * `std::sync::Arc`
    * **Plattformspezifisch:**
        * `zbus` (für Linux D-Bus)
        * `libc` (für Linux `reboot`/`poweroff` Syscalls, falls D-Bus nicht verfügbar)
        * `winapi` (für Windows APIs)
        * `core_foundation`, `io_kit_sys` (für macOS IOKit)

**Kommunikationsmuster:**

* Wird vom `PowerManager` verwendet, um mit den darunterliegenden Betriebssystem-APIs zu interagieren.
* Ist die einzige Komponente, die direkten (und unsicheren, falls FFI) Zugriff auf native Energie-APIs hat.

**Erwartete Ergebnisse/Outputs:**
Eine stabile, plattformübergreifende Schnittstelle zur Energieverwaltung des Betriebssystems.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking von OS-APIs/D-Bus):**
    * Mocken von `sysinfo` und D-Bus-Aufrufen (für Linux).
    * Simulieren verschiedener Batteriestatus und AC-Zustände.
    * Testen der `get_battery_status` und `is_ac_connected` Methoden.
    * Testen, ob die richtigen Systembefehle (Suspend, Hibernate, etc.) mit den richtigen Parametern aufgerufen werden (dies erfordert oft ein starkes Mocking oder Stubbing der nativen API-Aufrufe, um echte Systemaktionen zu vermeiden).
    * Testen der Fehlerbehandlung bei fehlgeschlagenen Systemaufrufen.
* **Integration Tests (auf dedizierten Testmaschinen pro OS oder VM):**
    * Ausführen von Tests auf realer Hardware oder VMs für jede unterstützte Plattform.
    * Tatsächliches Auslösen von Suspend/Hibernate/Reboot/Shutdown (unter Kontrolle und mit automatisiertem Recovery-Mechanismus).
    * Überprüfen der Reaktion des Systems auf Schlafverhinderungsanfragen.
    * Messung des Batteriestatus und des AC-Zustands in Echtzeit.

**Geschätzter Aufwand:** Sehr hoch (ca. 12-18 Tage, da plattformspezifische Implementierungen, FFI-Aufrufe, Interaktion mit kritischen OS-APIs und umfangreiche Tests auf mehreren Systemen)

---
### **novade-system/src/power_manager_service/manager.rs**

**Verantwortlichkeit:**
Der `PowerManager` ist die Kernlogik des Energieverwaltungssystems. Er orchestriert die Interaktion mit der plattformspezifischen `SystemPowerInterface`, wendet Energiesparpläne an, verwaltet Schlafverhinderungen (Wake-Locks) und reagiert auf Systeminaktivität und kritische Batteriezustände.

**Kern-Aufgaben (Tasks):**

1.  **`PowerManager` Struct:**
    * `pub struct PowerManager {`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `system_power_interface: Arc<SystemPowerInterface>,`
        * `current_config: RwLock<PowerManagerConfig>,`
        * `// Zähler für Inaktivität`
        * `last_user_activity: Arc<AtomicU64>,` // Unix-Timestamp der letzten Benutzeraktivität
        * `// Aktive Schlafverhinderungssitzungen (Wake-Locks)`
        * `active_sleep_inhibitors: RwLock<HashMap<u32, String>>,` // Session ID -> Reason
        * `next_inhibitor_id: Arc<AtomicU32>,`
    * `}`

2.  **`PowerManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus, system_power_interface: Arc<SystemPowerInterface>) -> Result<Self, PowerManagerError>`
    * **Logik:**
        * Initialisiert alle Felder.
        * Lädt die initiale `PowerManagerConfig` aus dem `config_service`.
        * Gibt `Self` zurück.

3.  **`PowerManager::get_battery_status()` Methode:**
    * `pub async fn get_battery_status(&self) -> Result<BatteryStatus, PowerManagerError>`
    * **Logik:** Delegiert an `self.system_power_interface.get_battery_status()`.

4.  **`PowerManager::is_ac_connected()` Methode:**
    * `pub async fn is_ac_connected(&self) -> Result<bool, PowerManagerError>`
    * **Logik:** Delegiert an `self.system_power_interface.is_ac_connected()`.

5.  **`PowerManager::suspend()` Methode:**
    * `pub async fn suspend(&self) -> Result<(), PowerManagerError>`
    * **Logik:** Delegiert an `self.system_power_interface.suspend()`.

6.  **`PowerManager::hibernate()` Methode:**
    * `pub async fn hibernate(&self) -> Result<(), PowerManagerError>`
    * **Logik:** Delegiert an `self.system_power_interface.hibernate()`.

7.  **`PowerManager::reboot()` Methode:**
    * `pub async fn reboot(&self) -> Result<(), PowerManagerError>`
    * **Logik:** Delegiert an `self.system_power_interface.reboot()`.

8.  **`PowerManager::shutdown()` Methode:**
    * `pub async fn shutdown(&self) -> Result<(), PowerManagerError>`
    * **Logik:** Delegiert an `self.system_power_interface.shutdown()`.

9.  **`PowerManager::set_display_timeout()` Methode:**
    * `pub async fn set_display_timeout(&self, seconds: u32) -> Result<(), PowerManagerError>`
    * **Logik:** Delegiert an `self.system_power_interface.set_display_timeout(seconds)`. Aktualisiert zusätzlich den `config_service` mit der neuen Einstellung.

10. **`PowerManager::update_last_user_activity()` Methode:**
    * `pub async fn update_last_user_activity(&self)`
    * **Logik:** Aktualisiert den `last_user_activity` Timestamp auf die aktuelle Zeit. Sollte von UI-Komponenten oder dem `input_manager_service` aufgerufen werden.

11. **`PowerManager::prevent_sleep()` Methode:**
    * `pub async fn prevent_sleep(&self, reason: String) -> Result<u32, PowerManagerError>`
    * **Logik:**
        * Generiert eine neue `session_id` von `next_inhibitor_id`.
        * Speichert die `reason` und `session_id` in `active_sleep_inhibitors`.
        * Ruft `self.system_power_interface.prevent_sleep(reason)` auf und verwendet den zurückgegebenen Handle/ID, um ihn intern zu verwalten (falls die Plattform-Schnittstelle einen solchen benötigt).
        * Gibt die `session_id` zurück.

12. **`PowerManager::allow_sleep()` Methode:**
    * `pub async fn allow_sleep(&self, session_id: u32) -> Result<(), PowerManagerError>`
    * **Logik:**
        * Entfernt den Eintrag aus `active_sleep_inhibitors`.
        * Ruft `self.system_power_interface.allow_sleep(session_id)` auf.

13. **`PowerManager::update_config()` Methode (intern, vom Service aufgerufen bei `SystemEvent::ConfigChanged`):**
    * `pub async fn update_config(&self, new_config: PowerManagerConfig)`
    * **Logik:**
        * Aktualisiert die interne `current_config`.
        * Ruft `set_display_timeout` mit den neuen Werten auf.
        * Informiert die `SystemPowerInterface` über relevante Änderungen.

14. **`PowerManager::handle_inactivity()` Methode (intern, vom periodischen Task im Service aufgerufen):**
    * `async fn handle_inactivity(self: Arc<Self>)`
    * **Logik:**
        * Berechnet die Zeit seit der letzten Benutzeraktivität.
        * Ruft `is_ac_connected()` ab.
        * Holt den relevanten `screen_timeout` und `suspend_on_inactivity` Wert aus `current_config` (je nach AC-Status).
        * Wenn der Bildschirm-Timeout erreicht ist und keine aktiven Schlafverhinderungen vorliegen, sendet es `SystemEvent::DisplayStateChanged(false)` und schaltet den Bildschirm aus (über `SystemPowerInterface`).
        * Wenn der Suspend-Inaktivitäts-Timeout erreicht ist, und keine aktiven Schlafverhinderungen vorliegen, ruft es `self.suspend()` oder `self.hibernate()` auf, basierend auf der Konfiguration.
        * **Wichtig:** Dies ist ein komplexer Task, der genau getaktet werden muss.

15. **`PowerManager::handle_battery_status()` Methode (intern, vom periodischen Task im Service aufgerufen):**
    * `async fn handle_battery_status(self: Arc<Self>, status: BatteryStatus)`
    * **Logik:**
        * Prüft, ob der `percentage` unter `low_battery_percentage` oder `critical_battery_percentage` fällt.
        * Löst `SystemEvent::BatteryLow` oder `SystemEvent::BatteryCritical` aus.
        * Wenn der kritische Schwellenwert erreicht ist und der Akku entladen wird, führt es die `critical_battery_action` (Suspend/Shutdown) aus.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/power_manager_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::power_manager_service::error::PowerManagerError`
    * `crate::power_manager_service::data_types::{BatteryStatus, PowerManagerConfig, SystemPowerAction}`
    * `crate::power_manager_service::system_power_interface::SystemPowerInterface`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::sync::RwLock`
    * `std::sync::{Arc, atomic::{AtomicU64, AtomicU32, Ordering}}`
    * `std::collections::HashMap`
    * `time` crate (für Zeitstempel)
    * `tracing`

**Kommunikationsmuster:**

* Ist die zentrale Logik für die Energieverwaltung.
* Delegiert alle OS-spezifischen Aktionen an die `SystemPowerInterface`.
* Interagiert mit `ConfigService` für Konfigurations-Updates.
* Sendet verschiedene `SystemEvent`s an den `EventBus`, um Systemzustandsänderungen zu signalisieren.
* Empfängt `SystemEvent::ConfigChanged` und `SystemEvent::UserActivity` (implizit über `update_last_user_activity`).

**Erwartete Ergebnisse/Outputs:**
Ein robuster Power Manager, der den Systemenergiezustand überwacht, auf Inaktivität und Batteriezustände reagiert und Systemenergieaktionen steuert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus` und `SystemPowerInterface`.
    * Testen von `get_battery_status`, `is_ac_connected`, `suspend`, `hibernate`, `reboot`, `shutdown`, `set_display_timeout` durch Überprüfen der korrekten Delegierung an den Mock-`SystemPowerInterface`.
    * Testen von `update_last_user_activity`.
    * Testen von `prevent_sleep` und `allow_sleep`: Überprüfen der Verwaltung der `active_sleep_inhibitors` und der Delegierung an `SystemPowerInterface`.
    * Testen von `update_config` und seiner Auswirkungen auf Einstellungen und Aktionen.
    * Testen von `handle_inactivity`: Simulieren verschiedener Inaktivitätszeiten, AC-Zustände und Schlafverhinderungen, um die korrekten Aktionen (Display aus, Suspend) und Events zu überprüfen.
    * Testen von `handle_battery_status`: Simulieren verschiedener Batterieladungen und AC-Zustände, um die korrekten Events und Aktionen bei niedrigem/kritischem Batteriestand zu überprüfen.
* **Integration Tests:**
    * Starten des `PowerManager` mit einer realen (oder auf einer VM kontrollierten) `SystemPowerInterface`.
    * Automatisierte Tests, die den Batteriestand simulieren oder real auslesen.
    * Testen der Inaktivitätsreaktionen durch Simulation von Benutzerinaktivität.
    * Überprüfung der End-to-End-Funktionalität der Energieaktionen.

**Geschätzter Aufwand:** Sehr hoch (ca. 10-15 Tage, da komplexe Zustandsverwaltung, Logik für Energiepläne, Inaktivität, Batteriemanagement und Interaktion mit kritischen Systemfunktionen)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `notification_service`, widmen wir uns `power_manager_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/power_manager_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/power_manager_service/data_types.rs`**: Definition der Datentypen für Batteriestatus und Konfiguration.
3.  **`novade-system/src/power_manager_service/system_power_interface.rs`**: Implementierung der plattformspezifischen Schnittstelle zu den OS-Energie-APIs. Dies ist die Basis für alle weiteren Funktionen.
4.  **`novade-system/src/power_manager_service/manager.rs`**: Die Kernlogik für die Energieverwaltung, die die `SystemPowerInterface` orchestriert und Energiepläne, Inaktivität und Batteriezustände verarbeitet.
5.  **`novade-system/src/power_manager_service/mod.rs`**: Das Hauptmodul, das den Manager und seine Sub-Komponenten initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/power_manager_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/keyboard_manager_service` Verzeichnisses.
---
### **novade-system/src/keyboard_manager_service/mod.rs**

**Verantwortlichkeit:**
Das `keyboard_manager_service` Modul ist für die globale Verwaltung von Tastatureingaben, Tastenkombinationen (Hotkeys), Tastaturbelegungen und Eingabemethoden zuständig. Es fängt Tastaturereignisse ab, leitet sie an relevante Systemkomponenten weiter und ermöglicht die Konfiguration von Tastaturpräferenzen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/keyboard_manager_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Tastatur-Operationen)
    * `manager.rs` (Logik für Hotkey-Registrierung, Layout-Verwaltung, Event-Verarbeitung)
    * `data_types.rs` (Definition von Tastatur-bezogenen Datentypen)
    * `keyboard_backend.rs` (Plattformspezifische Schnittstelle zu OS-Tastatur-APIs/Eingabesystemen)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Tastatur-Subsystems:**
    * `pub async fn initialize_keyboard_manager_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<KeyboardManagerService, KeyboardManagerError>`
    * **Logik:**
        * Erstellt eine Instanz von `keyboard_backend::KeyboardBackend` (plattformspezifisch).
        * Erstellt eine Instanz von `manager::KeyboardManager`.
        * Lädt initiale Konfigurationen aus dem `config_service` (z.B. Tastaturbelegungen, Hotkey-Definitionen, Wiederholungsverzögerung).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Startet einen Hintergrund-Task, der Tastaturereignisse vom `KeyboardBackend` liest und diese über den `EventBus` als `SystemEvent::KeyboardEvent` sendet.
        * Gibt ein gebündeltes `KeyboardManagerService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder des Backends.

2.  **`KeyboardManagerService` Struct:**
    * `pub struct KeyboardManagerService {`
        * `manager: Arc<KeyboardManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `backend_event_handle: tokio::task::JoinHandle<()>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Tastaturlogik.

3.  **Bereitstellung von API-Methoden:**
    * Der `KeyboardManagerService` exponiert Methoden zur Interaktion mit der Tastatur.
    * `pub async fn get_current_layout(&self) -> Result<KeyboardLayout, KeyboardManagerError>`
        * **Logik:** Delegiert an den `manager`, um das aktuelle Tastaturlayout abzurufen.
    * `pub async fn set_layout(&self, layout_id: &str) -> Result<(), KeyboardManagerError>`
        * **Logik:** Delegiert an den `manager`, um das Tastaturlayout zu ändern. Aktualisiert den `config_service`. Sendet `SystemEvent::KeyboardLayoutChanged`.
    * `pub async fn get_available_layouts(&self) -> Result<Vec<KeyboardLayout>, KeyboardManagerError>`
        * **Logik:** Delegiert an den `manager`, um eine Liste der verfügbaren Tastaturlayouts abzurufen.
    * `pub async fn register_hotkey(&self, hotkey: Hotkey) -> Result<(), KeyboardManagerError>`
        * **Logik:** Delegiert an den `manager`, um eine globale Tastenkombination zu registrieren.
    * `pub async fn unregister_hotkey(&self, hotkey_id: &str) -> Result<(), KeyboardManagerError>`
        * **Logik:** Delegiert an den `manager`, um eine registrierte Tastenkombination aufzuheben.
    * `pub async fn simulate_key_press(&self, key: &str, modifiers: Vec<Modifier>) -> Result<(), KeyboardManagerError>`
        * **Logik:** Delegiert an den `manager` und dann an das `KeyboardBackend`, um einen Tastendruck zu simulieren.
    * `pub async fn get_keyboard_settings(&self) -> Result<KeyboardConfig, KeyboardManagerError>`
        * **Logik:** Ruft die aktuelle Konfiguration aus dem `config_service` ab.
    * `pub async fn update_keyboard_settings(&self, config: KeyboardConfig) -> Result<(), KeyboardManagerError>`
        * **Logik:** Speichert die Konfiguration über den `config_service` und benachrichtigt den Manager.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `KeyboardManagerService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Einstellungen (z.B. Layout, Hotkeys) geändert werden, werden die Sub-Komponenten (`KeyboardManager`, `KeyboardBackend`) informiert.

5.  **Hintergrund-Task zum Abfangen von Tastaturereignissen:**
    * Ein Task, der einen Stream von `KeyboardEvent`s vom `KeyboardBackend` liest.
    * Jedes empfangene Ereignis wird an den `manager` zur Hotkey-Verarbeitung weitergeleitet.
    * Unverbrauchte Ereignisse (nicht Hotkeys) werden als `SystemEvent::KeyboardEvent` an den `EventBus` gesendet.
    * Benutzeraktivität wird an den `power_manager_service` gemeldet (über `SystemEvent::UserActivity`).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/keyboard_manager_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::keyboard_manager_service::error::KeyboardManagerError`
    * `crate::keyboard_manager_service::manager::KeyboardManager`
    * `crate::keyboard_manager_service::data_types::{KeyboardEvent, KeyboardLayout, Hotkey, Modifier, KeyboardConfig}`
    * `crate::keyboard_manager_service::keyboard_backend::KeyboardBackend`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `futures::stream::StreamExt`

**Kommunikationsmuster:**

* Ist der primäre Controller für die Tastaturverwaltung.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Tastatureinstellungen.
* Empfängt rohe Tastaturereignisse vom `KeyboardBackend`.
* Sendet `SystemEvent::KeyboardEvent`, `SystemEvent::HotkeyTriggered`, `SystemEvent::KeyboardLayoutChanged`, `SystemEvent::UserActivity` an den `EventBus`, um UI-Komponenten und andere Systemdienste zu informieren.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Tastatur-Subsystem, das Tastatureingaben abfangen, Hotkeys verarbeiten und Tastaturbelegungen steuern kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `KeyboardManager` und `KeyboardBackend`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und des Starts der Event-Listener.
    * Testen der Weiterleitung von API-Aufrufen an den `KeyboardManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von `KeyboardEvent`s vom Mock-`KeyboardBackend` und Überprüfen, ob sie korrekt an den `KeyboardManager` zur Hotkey-Verarbeitung und an den `EventBus` weitergeleitet werden.
* **Integration Tests:**
    * Starten des `KeyboardManagerService` in einer Testumgebung (ggf. mit einem simulierten `KeyboardBackend` für virtuelle Tastaturereignisse).
    * Registrieren von Hotkeys und Simulieren von Tastatureingaben, um die Auslösung der Hotkeys zu überprüfen.
    * Testen des Layout-Wechsels.
    * Überprüfen, ob `SystemEvent::KeyboardEvent` und `SystemEvent::HotkeyTriggered` korrekt gesendet werden.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da komplexe Event-Verarbeitung, Hotkey-Registrierung und plattformspezifische Eingabesysteme)

---
### **novade-system/src/keyboard_manager_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `keyboard_manager_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Tastatur-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`KeyboardManagerError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum KeyboardManagerError {`
        * `#[error("Hotkey '{0}' already registered.")]`
        * `HotkeyAlreadyRegistered(String),`
        * `#[error("Hotkey '{0}' not found.")]`
        * `HotkeyNotFound(String),`
        * `#[error("Keyboard layout '{0}' not found or invalid.")]`
        * `LayoutNotFound(String),`
        * `#[error("Failed to set keyboard layout: {0}")]`
        * `LayoutChangeFailed(String),`
        * `#[error("Failed to simulate key press: {0}")]`
        * `SimulateKeyPressFailed(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Platform specific error: {0}")]`
        * `PlatformError(String),`
        * `#[error("Unknown keyboard manager error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `anyhow::Error` (und potenziell plattformspezifische Fehler).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/keyboard_manager_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `keyboard_manager_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Tastaturverwaltungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/keyboard_manager_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `keyboard_manager_service` verwendet werden, um Tastaturereignisse, Layouts, Hotkeys und zugehörige Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`KeyboardEvent` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct KeyboardEvent {`
        * `pub key_code: u32,` // Scancode oder Keycode (plattformabhängig, kann in einem RawEvent sein)
        * `pub event_type: KeyEventType,` // Press, Release
        * `pub modifiers: Vec<Modifier>,`
        * `pub timestamp: u64,`
        * `pub symbol: Option<String>,` // Key symbol (e.g., "A", "Space", "Enter")
    * `}`

2.  **`KeyEventType` Enum:**
    * `#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum KeyEventType { Press, Release }`

3.  **`Modifier` Enum:**
    * `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]`
    * `pub enum Modifier { Shift, Ctrl, Alt, Super, Fn }`

4.  **`KeyboardLayout` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct KeyboardLayout {`
        * `pub id: String,` // Eindeutiger Layout-Bezeichner (z.B. "us", "de", "fr")
        * `pub name: String,` // Anzeigename (z.B. "German (QWERTZ)")
        * `pub indicator: Option<String>,` // Kurzname für die Anzeige (z.B. "DE")
    * `}`

5.  **`Hotkey` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct Hotkey {`
        * `pub id: String,` // Eindeutiger Bezeichner für den Hotkey
        * `pub keys: Vec<KeyCombination>,` // Liste der Tasten oder Tastenkombinationen, die den Hotkey auslösen
        * `pub action: HotkeyAction,` // Die Aktion, die ausgeführt werden soll
        * `pub description: Option<String>,`
        * `pub enabled: bool,`
    * `}`

6.  **`KeyCombination` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct KeyCombination {`
        * `pub key_code: u32,` // Der Haupt-Key-Code
        * `pub modifiers: Vec<Modifier>,`
    * `}`

7.  **`HotkeyAction` Enum:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub enum HotkeyAction {`
        * `LaunchApplication(String),` // App ID
        * `ExecuteCommand(String),` // Shell command
        * `ToggleSetting(String),` // Setting key
        * `ChangeLayout(String),` // Layout ID
        * `OpenQuickLauncher,`
        * `TakeScreenshot,`
        * `// ... weitere Aktionen`
    * `}`

8.  **`KeyboardConfig` Struct (aus `settings_manager::data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct KeyboardConfig {`
        * `pub current_layout_id: String,`
        * `pub available_layouts: Vec<String>,`
        * `pub hotkeys: Vec<Hotkey>,`
        * `pub key_repeat_delay_ms: u32,`
        * `pub key_repeat_rate_hz: u32,`
        * `// ...`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/keyboard_manager_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::collections::HashMap`
* **Intern:**
    * `crate::settings_manager::data_types::KeyboardConfig` (oder direkter Import)

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Tastaturinformationen im System.
* `KeyboardEvent`s werden vom `KeyboardBackend` generiert und an den `KeyboardManager` weitergeleitet.
* `Hotkey`s und `KeyboardLayout`s werden im `KeyboardManager` verwaltet und in der `KeyboardConfig` gespeichert.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Tastaturverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.
    * Überprüfen der Standardwerte und optionalen Felder.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/keyboard_manager_service/keyboard_backend.rs**

**Verantwortlichkeit:**
Das `keyboard_backend` Modul ist die plattformspezifische Schnittstelle zur Erfassung von globalen Tastatureingaben und zur Steuerung von Tastaturhardware (z.B. Layout-Wechsel, Tastenwiederholung). Es muss privilegierte Zugriffe auf das Betriebssystem nutzen, um globale Tastaturereignisse abzufangen und synthetische Tastendrücke zu generieren.

**Kern-Aufgaben (Tasks):**

1.  **`KeyboardBackend` Struct:**
    * `pub struct KeyboardBackend {`
        * `// Plattformspezifische Handles/Clients hier`
        * `#[cfg(target_os = "linux")]`
        * `xkb_context: Option<Arc<xkbcommon::xkb::Context>>,`
        * `#[cfg(target_os = "linux")]`
        * `evdev_device: Option<tokio::fs::File>,` // Direkter Zugriff auf /dev/input/eventX
        * `#[cfg(target_os = "linux")]`
        * `wayland_compositor: Option<Arc<wayland_client::Display>>,` // Für Wayland-Integration
        * `// ... weitere plattformspezifische Felder`
    * `}`

2.  **`KeyboardBackend::new()` Funktion:**
    * `pub async fn new() -> Result<Self, KeyboardManagerError>`
    * **Logik:**
        * **Plattformspezifisch:**
            * **Linux (X11):** Initialisiert eine XCB-Verbindung und registriert einen globalen Key-Grab. Nutzt `xkbcommon` für Layout-Mapping.
            * **Linux (Wayland):** Interagiert mit dem Wayland-Compositor über entsprechende Protokolle (z.B. `wlr-layer-shell`, `xdg-shell`) oder falls NovaDE selbst der Compositor ist, direkt mit den Eingabeereignissen. Dies ist komplexer und erfordert ein tiefes Verständnis des Wayland-Protokolls.
            * **Windows:** Nutzt `SetWindowsHookEx` (WH_KEYBOARD_LL) für globale Hooks.
            * **macOS:** Nutzt `CGEventTap` für globale Ereignisse.
        * Erfordert wahrscheinlich erhöhte Berechtigungen.
        * Gibt `Self` zurück.
        * **Fehlerbehandlung:** `PlatformError` bei Problemen mit nativen APIs oder Berechtigungen.

3.  **`KeyboardBackend::keyboard_event_stream()` Methode:**
    * `pub fn keyboard_event_stream(&self) -> impl Stream<Item = KeyboardEvent>`
    * **Logik:**
        * Liefert einen asynchronen Stream von `KeyboardEvent`s.
        * Dieser Stream muss systemweite Tastaturereignisse (KeyPress, KeyRelease) abfangen.
        * Die rohen Keycodes des OS werden in `KeyboardEvent` Typen umgewandelt.
        * **Plattformspezifisch:** Implementierung basiert auf den oben genannten APIs (XCB, evdev, SetWindowsHookEx, CGEventTap).
        * **Hinweis:** Dies ist der kritischste und komplexeste Teil des Moduls.

4.  **`KeyboardBackend::set_layout()` Methode:**
    * `pub async fn set_layout(&self, layout_id: &str) -> Result<(), KeyboardManagerError>`
    * **Logik:**
        * **Plattformspezifisch:**
            * **Linux (X11):** XKB-Konfiguration über XCB.
            * **Linux (Wayland):** Über `wlr-input-inhibitor` oder ähnliche Protokolle, um dem Compositor mitzuteilen, das Layout zu ändern.
            * **Windows:** `LoadKeyboardLayout`, `ActivateKeyboardLayout`.
            * **macOS:** Cocoa/Carbon APIs.
        * **Hinweis:** `tokio::task::spawn_blocking` kann hier angemessen sein.

5.  **`KeyboardBackend::get_current_layout()` Methode:**
    * `pub async fn get_current_layout(&self) -> Result<KeyboardLayout, KeyboardManagerError>`
    * **Logik:** Ruft das aktuell aktive Tastaturlayout vom OS ab.

6.  **`KeyboardBackend::get_available_layouts()` Methode:**
    * `pub async fn get_available_layouts(&self) -> Result<Vec<KeyboardLayout>, KeyboardManagerError>`
    * **Logik:** Listet alle vom OS unterstützten Tastaturlayouts auf.

7.  **`KeyboardBackend::simulate_key_press()` Methode:**
    * `pub async fn simulate_key_press(&self, key: &str, modifiers: Vec<Modifier>) -> Result<(), KeyboardManagerError>`
    * **Logik:**
        * Generiert synthetische Tastendrücke (Press und Release) mit den angegebenen Modifikatoren.
        * **Plattformspezifisch:**
            * **Linux (X11):** `XTestFakeKeyEvent`.
            * **Windows:** `SendInput`.
            * **macOS:** `CGEventPost`.
        * **Hinweis:** `tokio::task::spawn_blocking` kann hier angemessen sein.

8.  **`KeyboardBackend::set_key_repeat_rate()` und `set_key_repeat_delay()` Methoden:**
    * `pub async fn set_key_repeat_rate(&self, rate_hz: u32) -> Result<(), KeyboardManagerError>`
    * `pub async fn set_key_repeat_delay(&self, delay_ms: u32) -> Result<(), KeyboardError>`
    * **Logik:** Setzt die System-weiten Tastaturwiederholungsraten.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/keyboard_manager_service/keyboard_backend.rs`
* `novade-system/src/keyboard_manager_service/linux.rs` (oder ähnliche, für plattformspezifische Implementierungen)
* `novade-system/src/keyboard_manager_service/windows.rs`
* `novade-system/src/keyboard_manager_service/macos.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::keyboard_manager_service::error::KeyboardManagerError`
    * `crate::keyboard_manager_service::data_types::{KeyboardEvent, KeyboardLayout, Modifier, KeyEventType}`
* **Extern:**
    * `tokio::task::spawn_blocking`
    * `tokio::fs` (für evdev)
    * `futures::stream::Stream`
    * `tracing`
    * `std::sync::Arc`
    * **Plattformspezifisch:**
        * `xkbcommon`, `x11rb`, `libevdev` (Linux)
        * `wayland-client`, `wayland-protocols` (Linux Wayland)
        * `winapi`, `windows` crate (Windows)
        * `core_foundation`, `core_graphics`, `cocoa` (macOS)

**Kommunikationsmuster:**

* Bietet die Low-Level-Schnittstelle zur Tastaturhardware und den OS-Eingabesystemen.
* Sendet rohe Tastaturereignisse an den `KeyboardManager`.
* Empfängt Anfragen zur Änderung von Layouts oder zur Simulation von Tastendrücken vom `KeyboardManager`.

**Erwartete Ergebnisse/Outputs:**
Eine stabile, plattformübergreifende Schnittstelle zur Tastatursteuerung und Ereigniserfassung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking von OS-APIs/Hardware):**
    * Mocken aller plattformspezifischen Bibliotheken (z.B. `x11rb`, `winapi`, `CGEventTap`).
    * Simulieren von Tastendrücken und Überprüfen, ob `keyboard_event_stream` die korrekten `KeyboardEvent`s liefert.
    * Testen der `set_layout`, `get_current_layout`, `get_available_layouts` Methoden mit simulierten OS-Antworten.
    * Testen von `simulate_key_press` durch Überprüfen, ob die richtigen API-Aufrufe getätigt werden.
    * Testen der Fehlerbehandlung bei fehlgeschlagenen Systemaufrufen oder fehlenden Berechtigungen.
* **Integration Tests (auf dedizierten Testmaschinen pro OS oder VM):**
    * **Vorsicht:** Diese Tests können echte Tastaturereignisse beeinflussen und sollten nur in isolierten Umgebungen durchgeführt werden.
    * Starten des `KeyboardBackend` und physisches Drücken von Tasten, um zu überprüfen, ob die Ereignisse korrekt erfasst werden.
    * Testen des Layout-Wechsels durch physisches Überprüfen des Layouts nach dem API-Aufruf.
    * Testen von `simulate_key_press` durch Starten einer Texteditor-Anwendung und Überprüfen, ob die simulierten Tasten korrekt eingegeben werden.

**Geschätzter Aufwand:** Sehr hoch (ca. 12-18 Tage, da plattformspezifische Low-Level-Interaktion, Event-Grabbing, und komplexe FFI-Integration)

---
### **novade-system/src/keyboard_manager_service/manager.rs**

**Verantwortlichkeit:**
Der `KeyboardManager` ist die Kernlogik des Tastaturverwaltungssystems. Er verarbeitet die rohen Tastaturereignisse vom `KeyboardBackend`, identifiziert und löst registrierte globale Hotkeys aus, verwaltet den aktuellen Tastaturstatus (gedrückte Tasten, Modifikatoren) und ist für die Verwaltung der Tastaturbelegungen zuständig.

**Kern-Aufgaben (Tasks):**

1.  **`KeyboardManager` Struct:**
    * `pub struct KeyboardManager {`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `keyboard_backend: Arc<KeyboardBackend>,`
        * `current_config: RwLock<KeyboardConfig>,`
        * `registered_hotkeys: RwLock<HashMap<String, Hotkey>>,` // Hotkey ID -> Hotkey
        * `active_modifiers: RwLock<HashSet<Modifier>>,`
        * `pressed_keys: RwLock<HashSet<u32>>,` // Set of currently pressed raw key codes
    * `}`

2.  **`KeyboardManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus, keyboard_backend: Arc<KeyboardBackend>) -> Result<Self, KeyboardManagerError>`
    * **Logik:**
        * Initialisiert alle Felder.
        * Lädt die initiale `KeyboardConfig` aus dem `config_service`.
        * Registriert alle in der Konfiguration definierten Hotkeys beim `keyboard_backend` (falls das Backend eine solche Registrierung benötigt, ansonsten werden Hotkeys im Manager selbst erkannt).
        * Setzt das initiale Tastaturlayout über den `keyboard_backend`.
        * Gibt `Self` zurück.

3.  **`KeyboardManager::handle_keyboard_event()` Methode (intern, vom Service aufgerufen):**
    * `pub async fn handle_keyboard_event(&self, event: KeyboardEvent)`
    * **Logik:**
        * Aktualisiert `active_modifiers` und `pressed_keys` basierend auf `event.event_type`.
        * **Hotkey-Erkennung:**
            * Prüft, ob die aktuelle Tastenkombination (basierend auf `pressed_keys` und `active_modifiers`) mit einem registrierten `Hotkey` übereinstimmt.
            * Bei Übereinstimmung:
                * Ruft die zugehörige `HotkeyAction` auf.
                * Sendet `SystemEvent::HotkeyTriggered(hotkey_id.clone(), hotkey_action.clone())` an den `EventBus`.
                * Kennzeichnet das Event als "verbraucht", sodass es nicht an den `EventBus` als `KeyboardEvent` weitergeleitet wird (falls Hotkeys Events "konsumieren" sollen).
        * Wenn das Event nicht von einem Hotkey verbraucht wurde, sendet es `SystemEvent::KeyboardEvent(event)` an den `EventBus`.
        * Aktualisiert den `last_user_activity` Timestamp im `power_manager_service` (indirekt über `SystemEvent::UserActivity`).

4.  **`KeyboardManager::get_current_layout()` Methode:**
    * `pub async fn get_current_layout(&self) -> Result<KeyboardLayout, KeyboardManagerError>`
    * **Logik:** Delegiert an `self.keyboard_backend.get_current_layout()`.

5.  **`KeyboardManager::set_layout()` Methode:**
    * `pub async fn set_layout(&self, layout_id: &str) -> Result<(), KeyboardManagerError>`
    * **Logik:**
        * Validiert `layout_id` gegen verfügbare Layouts.
        * Delegiert an `self.keyboard_backend.set_layout(layout_id)`.
        * Aktualisiert `current_config.current_layout_id` und speichert die Konfiguration.
        * Sendet `SystemEvent::KeyboardLayoutChanged(layout_id.to_string())` an den `EventBus`.

6.  **`KeyboardManager::get_available_layouts()` Methode:**
    * `pub async fn get_available_layouts(&self) -> Result<Vec<KeyboardLayout>, KeyboardManagerError>`
    * **Logik:** Delegiert an `self.keyboard_backend.get_available_layouts()`.

7.  **`KeyboardManager::register_hotkey()` Methode:**
    * `pub async fn register_hotkey(&self, hotkey: Hotkey) -> Result<(), KeyboardManagerError>`
    * **Logik:**
        * Prüft, ob die `hotkey.id` bereits registriert ist.
        * Fügt den `Hotkey` zur `registered_hotkeys` HashMap hinzu.
        * Aktualisiert die `current_config.hotkeys` und speichert die Konfiguration.

8.  **`KeyboardManager::unregister_hotkey()` Methode:**
    * `pub async fn unregister_hotkey(&self, hotkey_id: &str) -> Result<(), KeyboardManagerError>`
    * **Logik:**
        * Entfernt den `Hotkey` aus `registered_hotkeys`.
        * Aktualisiert die `current_config.hotkeys` und speichert die Konfiguration.

9.  **`KeyboardManager::simulate_key_press()` Methode:**
    * `pub async fn simulate_key_press(&self, key: &str, modifiers: Vec<Modifier>) -> Result<(), KeyboardManagerError>`
    * **Logik:** Delegiert an `self.keyboard_backend.simulate_key_press(key, modifiers)`.

10. **`KeyboardManager::update_config()` Methode (intern, vom Service aufgerufen bei `SystemEvent::ConfigChanged`):**
    * `pub async fn update_config(&self, new_config: KeyboardConfig)`
    * **Logik:**
        * Aktualisiert die interne `current_config`.
        * Registriert/Unregistriert Hotkeys bei Bedarf (Vergleich `new_config.hotkeys` mit `current_config.hotkeys`).
        * Setzt Tastaturwiederholungsraten und Verzögerungen über `keyboard_backend`.
        * Setzt das Tastaturlayout, falls es sich geändert hat.

11. **`KeyboardManager::execute_hotkey_action()` Methode (intern):**
    * `async fn execute_hotkey_action(&self, action: &HotkeyAction)`
    * **Logik:**
        * Matcht den `HotkeyAction` Enum-Typ und führt die entsprechende Aktion aus:
            * `LaunchApplication(app_id)`: Ruft `application_launcher_service.launch_application()` auf.
            * `ExecuteCommand(command)`: Führt den Befehl mit `tokio::process::Command` aus.
            * `ToggleSetting(setting_key)`: Interagiert mit `config_service`, um eine Einstellung umzuschalten.
            * `ChangeLayout(layout_id)`: Ruft `self.set_layout()` auf.
            * `OpenQuickLauncher`: Sendet `SystemEvent::OpenQuickLauncher`.
            * `TakeScreenshot`: Sendet `SystemEvent::TakeScreenshot`.
            * Nutzt den `event_bus` und andere Services, um die Aktionen auszuführen.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/keyboard_manager_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::keyboard_manager_service::error::KeyboardManagerError`
    * `crate::keyboard_manager_service::data_types::{KeyboardEvent, KeyboardLayout, Hotkey, KeyCombination, HotkeyAction, Modifier, KeyEventType, KeyboardConfig}`
    * `crate::keyboard_manager_service::keyboard_backend::KeyboardBackend`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
    * `crate::application_launcher_service::ApplicationLauncherService` (für LaunchApplication)
* **Extern:**
    * `tokio::sync::RwLock`
    * `tokio::process::Command`
    * `std::sync::Arc`
    * `std::collections::{HashMap, HashSet}`
    * `tracing`

**Kommunikationsmuster:**

* Ist die zentrale Logik für die Tastaturereignisverarbeitung.
* Empfängt rohe Events vom `KeyboardBackend`.
* Delegiert Layout- und Simulation-Anfragen an den `KeyboardBackend`.
* Interagiert mit `ConfigService` für Konfiguration und Speicherung.
* Sendet verschiedene `SystemEvent`s an den `EventBus`, insbesondere `HotkeyTriggered`.
* Ruft andere Systemdienste auf, um `HotkeyAction`s auszuführen.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Tastatur-Manager, der globale Tastaturereignisse verarbeitet, Hotkeys erkennt und auslöst sowie Tastaturbelegungen und -einstellungen verwaltet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `KeyboardBackend` und `ApplicationLauncherService`.
    * Testen von `new` und dem Laden/Anwenden der initialen Konfiguration (Hotkeys, Layout).
    * Testen von `handle_keyboard_event`:
        * Korrektes Aktualisieren von `active_modifiers` und `pressed_keys`.
        * Hotkey-Erkennung mit verschiedenen Kombinationen (einzelne Taste, Modifikatoren, Sequenzen falls unterstützt).
        * Überprüfen, ob `SystemEvent::HotkeyTriggered` gesendet wird, wenn ein Hotkey erkannt wird.
        * Überprüfen, ob `SystemEvent::KeyboardEvent` gesendet wird, wenn kein Hotkey ausgelöst wird.
        * Testen der Konsumierung von Events durch Hotkeys.
    * Testen von `register_hotkey` und `unregister_hotkey`.
    * Testen von `set_layout` und `get_current_layout`, `get_available_layouts` (Delegierung).
    * Testen von `simulate_key_press` (Delegierung).
    * Testen von `update_config` und der korrekten Neukonfiguration.
    * Testen von `execute_hotkey_action` für alle `HotkeyAction` Varianten (dabei die aufgerufenen Services mocken).
* **Integration Tests:**
    * Starten des `KeyboardManager` mit realen (oder auf einer VM kontrollierten) `KeyboardBackend`.
    * Registrieren echter Hotkeys und physisches Auslösen.
    * Überprüfen der korrekten Ausführung der `HotkeyAction` (z.B. Starten einer Testanwendung, Umschalten einer Testeinstellung).
    * Beobachtung des `EventBus` für die gesendeten `SystemEvent`s.

**Geschätzter Aufwand:** Sehr hoch (ca. 10-15 Tage, da komplexe Hotkey-Logik, Event-Filterung, und Interaktion mit anderen Services)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `power_manager_service`, widmen wir uns `keyboard_manager_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/keyboard_manager_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/keyboard_manager_service/data_types.rs`**: Definition der Datentypen für Tastaturereignisse, Layouts und Hotkeys.
3.  **`novade-system/src/keyboard_manager_service/keyboard_backend.rs`**: Implementierung der plattformspezifischen Schnittstelle für Tastaturereignisse und Hardware-Steuerung. Dies ist die Basis.
4.  **`novade-system/src/keyboard_manager_service/manager.rs`**: Die Kernlogik für die Tastaturereignisverarbeitung, Hotkey-Erkennung und -ausführung sowie die Layout-Verwaltung.
5.  **`novade-system/src/keyboard_manager_service/mod.rs`**: Das Hauptmodul, das den Manager und seine Sub-Komponenten initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/keyboard_manager_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/audio_manager_service` Verzeichnisses.
---
### **novade-system/src/audio_manager_service/mod.rs**

**Verantwortlichkeit:**
Das `audio_manager_service` Modul ist für die systemweite Verwaltung von Audioeinstellungen zuständig. Es steuert die Lautstärke, die Auswahl der Audioausgabe- und -eingabegeräte, die Balance und die Stummschaltung. Es überwacht Audioereignisse und interagiert mit dem `config_service` für Präferenzen und dem `event_bus` für Zustandsänderungen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/audio_manager_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Audio Manager-Operationen)
    * `manager.rs` (Logik für Lautstärkesteuerung, Geräteauswahl und Statusüberwachung)
    * `data_types.rs` (Definition von Audio-bezogenen Datentypen)
    * `audio_backend.rs` (Plattformspezifische Schnittstelle zu OS-Audio-APIs)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Audio-Subsystems:**
    * `pub async fn initialize_audio_manager_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<AudioManagerService, AudioManagerError>`
    * **Logik:**
        * Erstellt eine Instanz von `audio_backend::AudioBackend` (plattformspezifisch).
        * Erstellt eine Instanz von `manager::AudioManager`.
        * Lädt initiale Konfigurationen aus dem `config_service` (z.B. Standard-Ausgabegerät, letzte Lautstärke, Balance).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Startet einen Hintergrund-Task, der Audioereignisse vom `AudioBackend` liest und diese über den `EventBus` als `SystemEvent::AudioVolumeChanged`, `SystemEvent::AudioMuted`, `SystemEvent::DefaultAudioOutputChanged`, etc. sendet.
        * Gibt ein gebündeltes `AudioManagerService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder des Backends.

2.  **`AudioManagerService` Struct:**
    * `pub struct AudioManagerService {`
        * `manager: Arc<AudioManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `backend_event_handle: tokio::task::JoinHandle<()>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Audio-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `AudioManagerService` exponiert Methoden zur Interaktion mit dem Audiosystem.
    * `pub async fn get_master_volume(&self) -> Result<f32, AudioManagerError>`
        * **Logik:** Delegiert an den `manager`, um die aktuelle Master-Lautstärke abzurufen (0.0 - 1.0).
    * `pub async fn set_master_volume(&self, volume: f32) -> Result<(), AudioManagerError>`
        * **Logik:** Delegiert an den `manager`, um die Master-Lautstärke zu setzen. Aktualisiert den `config_service`. Sendet `SystemEvent::AudioVolumeChanged`.
    * `pub async fn is_muted(&self) -> Result<bool, AudioManagerError>`
        * **Logik:** Delegiert an den `manager`, um den Stummschaltungsstatus abzurufen.
    * `pub async fn set_muted(&self, muted: bool) -> Result<(), AudioManagerError>`
        * **Logik:** Delegiert an den `manager`, um das System stummzuschalten oder die Stummschaltung aufzuheben. Aktualisiert den `config_service`. Sendet `SystemEvent::AudioMuted`.
    * `pub async fn get_audio_devices(&self, device_type: AudioDeviceType) -> Result<Vec<AudioDevice>, AudioManagerError>`
        * **Logik:** Delegiert an den `manager`, um eine Liste der verfügbaren Audio-Ausgabe- oder -Eingabegeräte abzurufen.
    * `pub async fn set_default_output_device(&self, device_id: &str) -> Result<(), AudioManagerError>`
        * **Logik:** Delegiert an den `manager`, um das Standard-Ausgabegerät zu setzen. Aktualisiert den `config_service`. Sendet `SystemEvent::DefaultAudioOutputChanged`.
    * `pub async fn get_default_output_device(&self) -> Result<Option<AudioDevice>, AudioManagerError>`
        * **Logik:** Delegiert an den `manager`, um das aktuelle Standard-Ausgabegerät abzurufen.
    * `pub async fn get_audio_settings(&self) -> Result<AudioConfig, AudioManagerError>`
        * **Logik:** Ruft die aktuelle Konfiguration aus dem `config_service` ab.
    * `pub async fn update_audio_settings(&self, config: AudioConfig) -> Result<(), AudioManagerError>`
        * **Logik:** Speichert die Konfiguration über den `config_service` und benachrichtigt den Manager.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `AudioManagerService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Einstellungen (z.B. Standardgeräte) geändert werden, werden die Sub-Komponenten (`AudioManager`, `AudioBackend`) informiert.

5.  **Hintergrund-Task zum Abfangen von Audio-Ereignissen:**
    * Ein Task, der einen Stream von Audio-Zustandsänderungen vom `AudioBackend` liest.
    * Jede empfangene Änderung (Lautstärke, Stummschaltung, Geräteänderung) wird als entsprechendes `SystemEvent` an den `EventBus` gesendet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_manager_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::audio_manager_service::error::AudioManagerError`
    * `crate::audio_manager_service::manager::AudioManager`
    * `crate::audio_manager_service::data_types::{AudioDevice, AudioDeviceType, AudioConfig}`
    * `crate::audio_manager_service::audio_backend::AudioBackend`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `futures::stream::StreamExt`

**Kommunikationsmuster:**

* Ist der primäre Controller für die Audioverwaltung.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Audioeinstellungen.
* Empfängt Audio-Zustandsänderungen vom `AudioBackend`.
* Sendet `SystemEvent::AudioVolumeChanged`, `SystemEvent::AudioMuted`, `SystemEvent::DefaultAudioOutputChanged`, `SystemEvent::AudioDeviceAdded`, `SystemEvent::AudioDeviceRemoved` an den `EventBus`, um UI-Komponenten und andere Systemdienste zu informieren.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Audio-Subsystem, das die systemweite Lautstärke, Stummschaltung und Auswahl von Audio-Geräten steuern kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `AudioManager` und `AudioBackend`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und des Starts der Event-Listener.
    * Testen der Weiterleitung von API-Aufrufen an den `AudioManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von Audio-Zustandsänderungen vom Mock-`AudioBackend` und Überprüfen, ob die korrekten `SystemEvent`s an den `EventBus` gesendet werden.
* **Integration Tests:**
    * Starten des `AudioManagerService` in einer Testumgebung (ggf. mit einem simulierten `AudioBackend` für virtuelle Audio-Geräte).
    * Testen des Setzens und Abrufens der Lautstärke und des Stummschaltungsstatus.
    * Testen der Abfrage und Auswahl von Audio-Geräten.
    * Überprüfen, ob `SystemEvent::Audio*` Events korrekt gesendet werden.

**Geschätzter Aufwand:** Hoch (ca. 6-9 Tage, da Event-Verarbeitung, und plattformspezifische Audio-APIs)

---
### **novade-system/src/audio_manager_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `audio_manager_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Audio-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`AudioManagerError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum AudioManagerError {`
        * `#[error("Failed to get audio device information: {0}")]`
        * `DeviceInformationFailed(String),`
        * `#[error("Audio device with ID '{0}' not found.")]`
        * `DeviceNotFound(String),`
        * `#[error("Failed to set audio volume: {0}")]`
        * `SetVolumeFailed(String),`
        * `#[error("Failed to set mute state: {0}")]`
        * `SetMuteFailed(String),`
        * `#[error("Failed to set default audio device: {0}")]`
        * `SetDefaultDeviceFailed(String),`
        * `#[error("Invalid volume value: {0}")]`
        * `InvalidVolume(f32),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Platform specific audio backend error: {0}")]`
        * `PlatformError(String),`
        * `#[error("Unknown audio manager error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `anyhow::Error` (und potenziell plattformspezifische Fehler).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_manager_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `audio_manager_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Audioverwaltungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/audio_manager_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `audio_manager_service` verwendet werden, um Audio-Geräte, Lautstärke-Informationen und zugehörige Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`AudioDevice` Struct:**
    * `#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]`
    * `pub struct AudioDevice {`
        * `pub id: String,` // Eindeutige ID des Geräts (vom OS/Backend bereitgestellt)
        * `pub name: String,` // Anzeigename des Geräts (z.B. "Lautsprecher (Realtek High Definition Audio)")
        * `pub device_type: AudioDeviceType,`
        * `pub is_default: bool,` // Ob dies das aktuelle Standardgerät ist
        * `pub description: Option<String>,` // Weitere Details zum Gerät
    * `}`

2.  **`AudioDeviceType` Enum:**
    * `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]`
    * `pub enum AudioDeviceType { Output, Input }`

3.  **`AudioConfig` Struct (aus `settings_manager::data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct AudioConfig {`
        * `pub master_volume: f32,` // 0.0 - 1.0
        * `pub master_muted: bool,`
        * `pub default_output_device_id: Option<String>,`
        * `pub default_input_device_id: Option<String>,`
        * `pub output_device_volumes: HashMap<String, f32>,` // Device ID -> Volume (falls granular gesteuert)
        * `pub input_device_volumes: HashMap<String, f32>,`
        * `// ...`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_manager_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::collections::HashMap`
* **Intern:**
    * `crate::settings_manager::data_types::AudioConfig` (oder direkter Import)

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Audioinformationen im System.
* `AudioDevice` Objekte werden vom `AudioBackend` generiert und an den `AudioManager` weitergeleitet.
* `AudioConfig` wird im `SettingsManagerService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Audioverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.
    * Überprüfen der Standardwerte und optionalen Felder.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/audio_manager_service/audio_backend.rs**

**Verantwortlichkeit:**
Das `audio_backend` Modul ist die plattformspezifische Abstraktionsschicht für den Zugriff auf Betriebssystem-APIs zur Audioverwaltung. Es ist verantwortlich für die Interaktion mit den Audio-Subsystemen des OS (z.B. PulseAudio/PipeWire unter Linux, Core Audio unter macOS, WASAPI/DirectSound unter Windows), um Lautstärke zu steuern, Stummschaltung zu verwalten und Audio-Geräte aufzulisten/auszuwählen.

**Kern-Aufgaben (Tasks):**

1.  **`AudioBackend` Trait/Struct:**
    * Es ist vorteilhaft, hier ein Trait zu definieren, um plattformspezifische Implementierungen zu abstrahieren.
    * `#[cfg(target_os = "linux")]`
    * `pub struct LinuxAudioBackend { /* PulseAudio/PipeWire client handles */ }`
    * `#[cfg(target_os = "windows")]`
    * `pub struct WindowsAudioBackend { /* WASAPI/CoreAudio client handles */ }`
    * `#[cfg(target_os = "macos")]`
    * `pub struct MacOSAudioBackend { /* CoreAudio client handles */ }`

2.  **`AudioBackend::new()` Funktion (konstruktor der konkreten Implementierung):**
    * `pub async fn new() -> Result<Self, AudioManagerError>`
    * **Logik:**
        * **Plattformspezifisch:**
            * **Linux:** Versucht eine Verbindung zu PulseAudio (via `libpulse-binding` oder `pulseaudio-rs`) oder PipeWire (via `pipewire-rs` oder D-Bus an `wireplumber`).
            * **Windows:** Initialisiert WASAPI oder DirectSound-Schnittstellen.
            * **macOS:** Initialisiert Core Audio APIs.
        * Gibt die konkrete Implementierung zurück.
        * **Fehlerbehandlung:** `PlatformError` bei Problemen mit nativen APIs oder fehlenden Servern (z.B. PulseAudio nicht aktiv).

3.  **`AudioBackend::get_master_volume()` Methode:**
    * `pub async fn get_master_volume(&self) -> Result<f32, AudioManagerError>`
    * **Logik:** Ruft die globale Master-Lautstärke des Systems ab.
        * **Hinweis:** Dies sollte `tokio::task::spawn_blocking` verwenden, da native API-Aufrufe blockierend sein können.

4.  **`AudioBackend::set_master_volume()` Methode:**
    * `pub async fn set_master_volume(&self, volume: f32) -> Result<(), AudioManagerError>`
    * **Logik:** Setzt die globale Master-Lautstärke des Systems. (`volume` sollte zwischen 0.0 und 1.0 liegen).
        * **Hinweis:** `tokio::task::spawn_blocking`.

5.  **`AudioBackend::is_muted()` Methode:**
    * `pub async fn is_muted(&self) -> Result<bool, AudioManagerError>`
    * **Logik:** Prüft, ob das System stummgeschaltet ist.
        * **Hinweis:** `tokio::task::spawn_blocking`.

6.  **`AudioBackend::set_muted()` Methode:**
    * `pub async fn set_muted(&self, muted: bool) -> Result<(), AudioManagerError>`
    * **Logik:** Schaltet das System stumm oder hebt die Stummschaltung auf.
        * **Hinweis:** `tokio::task::spawn_blocking`.

7.  **`AudioBackend::get_audio_devices()` Methode:**
    * `pub async fn get_audio_devices(&self, device_type: AudioDeviceType) -> Result<Vec<AudioDevice>, AudioManagerError>`
    * **Logik:** Listet alle verfügbaren Audio-Geräte des angegebenen Typs (Output/Input) auf.
        * **Hinweis:** `tokio::task::spawn_blocking`.

8.  **`AudioBackend::set_default_output_device()` Methode:**
    * `pub async fn set_default_output_device(&self, device_id: &str) -> Result<(), AudioManagerError>`
    * **Logik:** Setzt das Standard-Ausgabegerät des Systems.
        * **Hinweis:** `tokio::task::spawn_blocking`.

9.  **`AudioBackend::get_default_output_device()` Methode:**
    * `pub async fn get_default_output_device(&self) -> Result<Option<AudioDevice>, AudioManagerError>`
    * **Logik:** Ruft das aktuell konfigurierte Standard-Ausgabegerät ab.
        * **Hinweis:** `tokio::task::spawn_blocking`.

10. **`AudioBackend::audio_event_stream()` Methode:**
    * `pub fn audio_event_stream(&self) -> impl Stream<Item = AudioBackendEvent>`
    * **Logik:** Liefert einen asynchronen Stream von `AudioBackendEvent`s, die Zustandsänderungen im Audiosystem repräsentieren (z.B. Lautstärkeänderung, Stummschaltung, Hinzufügen/Entfernen von Geräten, Standardgerätwechsel).
        * `AudioBackendEvent` wäre ein internes Enum, z.B. `VolumeChanged(f32)`, `Muted(bool)`, `DefaultOutputChanged(String)`, `DeviceAdded(AudioDevice)`.
        * **Plattformspezifisch:** Benötigt Event-Listener des Audio-Subsystems (z.B. PulseAudio-Events, WASAPI-Callbacks, Core Audio-Listener). Dies ist ein langlebiger, nicht-blockierender Task.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_manager_service/audio_backend.rs`
* `novade-system/src/audio_manager_service/linux.rs` (oder ähnliche, für plattformspezifische Implementierungen)
* `novade-system/src/audio_manager_service/windows.rs`
* `novade-system/src/audio_manager_service/macos.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::audio_manager_service::error::AudioManagerError`
    * `crate::audio_manager_service::data_types::{AudioDevice, AudioDeviceType}`
* **Extern:**
    * `tokio::task::spawn_blocking`
    * `futures::stream::Stream`
    * `tracing`
    * `std::sync::Arc`
    * **Plattformspezifisch:**
        * `libpulse-binding`, `pulseaudio-rs`, `pipewire-rs`, `zbus` (für Linux)
        * `windows` crate (für Windows WASAPI/CoreAudio)
        * `core_audio`, `core_foundation` (für macOS Core Audio)

**Kommunikationsmuster:**

* Bietet die Low-Level-Schnittstelle zum Audiosystem des Betriebssystems.
* Sendet Audio-Zustandsänderungen über den `audio_event_stream()` an den `AudioManager`.
* Empfängt Anfragen zur Lautstärke- oder Geräteänderung vom `AudioManager`.

**Erwartete Ergebnisse/Outputs:**
Eine stabile, plattformübergreifende Schnittstelle zur Audio-Hardware und den OS-Audio-Subsystemen.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking von OS-Audio-APIs/Hardware):**
    * Mocken aller plattformspezifischen Bibliotheken (z.B. PulseAudio-Client, WASAPI).
    * Simulieren von Lautstärkeänderungen und Überprüfen, ob `audio_event_stream` die korrekten `AudioBackendEvent`s liefert.
    * Testen der `get_master_volume`, `set_master_volume`, `is_muted`, `set_muted`, `get_audio_devices`, `set_default_output_device`, `get_default_output_device` Methoden mit simulierten OS-Antworten.
    * Testen der Fehlerbehandlung bei fehlgeschlagenen Systemaufrufen.
* **Integration Tests (auf dedizierten Testmaschinen pro OS oder VM):**
    * Starten des `AudioBackend` und Ausführen von Lautstärkeänderungen, Stummschaltung und Geräteauswahl, um die korrekte Funktion zu überprüfen.
    * Physisches Ändern der Lautstärke (z.B. über Hardware-Tasten) und Überprüfen, ob die Ereignisse im `audio_event_stream` korrekt erfasst werden.
    * Testen von Audioausgabe über verschiedene Geräte.

**Geschätzter Aufwand:** Sehr hoch (ca. 10-15 Tage, da plattformspezifische Low-Level-Interaktion, Event-Listener, und komplexe FFI-Integration)

---
### **novade-system/src/audio_manager_service/manager.rs**

**Verantwortlichkeit:**
Der `AudioManager` ist die Kernlogik des Audioverwaltungssystems. Er orchestriert die Interaktion mit dem plattformspezifischen `AudioBackend`, verwaltet die Audio-Einstellungen basierend auf der `AudioConfig` und löst Events bei Änderungen aus.

**Kern-Aufgaben (Tasks):**

1.  **`AudioManager` Struct:**
    * `pub struct AudioManager {`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `audio_backend: Arc<dyn AudioBackendTrait + Send + Sync>,` // Verwende ein Trait-Objekt für Abstraktion
        * `current_config: RwLock<AudioConfig>,`
    * `}`

2.  **`AudioManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus, audio_backend: Arc<dyn AudioBackendTrait + Send + Sync>) -> Result<Self, AudioManagerError>`
    * **Logik:**
        * Initialisiert alle Felder.
        * Lädt die initiale `AudioConfig` aus dem `config_service`.
        * Wendet die geladene Konfiguration auf das `audio_backend` an (z.B. setzt die letzte bekannte Master-Lautstärke und den Standardausgabe-Gerät).
        * Gibt `Self` zurück.

3.  **`AudioManager::handle_backend_event()` Methode (intern, vom Service aufgerufen):**
    * `pub async fn handle_backend_event(&self, event: AudioBackendEvent)`
    * **Logik:**
        * Verarbeitet `AudioBackendEvent`s vom `AudioBackend`.
        * Bei `VolumeChanged(volume)`: Aktualisiert die interne `current_config.master_volume` und sendet `SystemEvent::AudioVolumeChanged(volume)` an den `EventBus`. Speichert die aktualisierte Konfiguration.
        * Bei `Muted(muted)`: Aktualisiert `current_config.master_muted` und sendet `SystemEvent::AudioMuted(muted)`. Speichert die aktualisierte Konfiguration.
        * Bei `DefaultOutputChanged(device_id)`: Aktualisiert `current_config.default_output_device_id` und sendet `SystemEvent::DefaultAudioOutputChanged(device_id)`. Speichert die aktualisierte Konfiguration.
        * Bei `DeviceAdded(device)`: Sendet `SystemEvent::AudioDeviceAdded(device)`.
        * Bei `DeviceRemoved(device_id)`: Sendet `SystemEvent::AudioDeviceRemoved(device_id)`.

4.  **`AudioManager::get_master_volume()` Methode:**
    * `pub async fn get_master_volume(&self) -> Result<f32, AudioManagerError>`
    * **Logik:** Delegiert an `self.audio_backend.get_master_volume()`.

5.  **`AudioManager::set_master_volume()` Methode:**
    * `pub async fn set_master_volume(&self, volume: f32) -> Result<(), AudioManagerError>`
    * **Logik:**
        * Validiert den `volume` Wert (0.0 - 1.0).
        * Delegiert an `self.audio_backend.set_master_volume(volume)`.
        * Aktualisiert `current_config.master_volume` und speichert die Konfiguration.
        * Sendet `SystemEvent::AudioVolumeChanged(volume)` an den `EventBus`.

6.  **`AudioManager::is_muted()` Methode:**
    * `pub async fn is_muted(&self) -> Result<bool, AudioManagerError>`
    * **Logik:** Delegiert an `self.audio_backend.is_muted()`.

7.  **`AudioManager::set_muted()` Methode:**
    * `pub async fn set_muted(&self, muted: bool) -> Result<(), AudioManagerError>`
    * **Logik:**
        * Delegiert an `self.audio_backend.set_muted(muted)`.
        * Aktualisiert `current_config.master_muted` und speichert die Konfiguration.
        * Sendet `SystemEvent::AudioMuted(muted)` an den `EventBus`.

8.  **`AudioManager::get_audio_devices()` Methode:**
    * `pub async fn get_audio_devices(&self, device_type: AudioDeviceType) -> Result<Vec<AudioDevice>, AudioManagerError>`
    * **Logik:** Delegiert an `self.audio_backend.get_audio_devices(device_type)`.

9.  **`AudioManager::set_default_output_device()` Methode:**
    * `pub async fn set_default_output_device(&self, device_id: &str) -> Result<(), AudioManagerError>`
    * **Logik:**
        * Validiert `device_id` gegen die Liste der verfügbaren Ausgabegeräte.
        * Delegiert an `self.audio_backend.set_default_output_device(device_id)`.
        * Aktualisiert `current_config.default_output_device_id` und speichert die Konfiguration.
        * Sendet `SystemEvent::DefaultAudioOutputChanged(device_id.to_string())` an den `EventBus`.

10. **`AudioManager::get_default_output_device()` Methode:**
    * `pub async fn get_default_output_device(&self) -> Result<Option<AudioDevice>, AudioManagerError>`
    * **Logik:** Delegiert an `self.audio_backend.get_default_output_device()`.

11. **`AudioManager::update_config()` Methode (intern, vom Service aufgerufen bei `SystemEvent::ConfigChanged`):**
    * `pub async fn update_config(&self, new_config: AudioConfig)`
    * **Logik:**
        * Aktualisiert die interne `current_config`.
        * Vergleicht `new_config.master_volume` mit `current_config.master_volume` und setzt die Lautstärke über das Backend, falls unterschiedlich.
        * Vergleicht `new_config.master_muted` mit `current_config.master_muted` und setzt den Mute-Status über das Backend, falls unterschiedlich.
        * Vergleicht `new_config.default_output_device_id` mit `current_config.default_output_device_id` und setzt das Standardgerät über das Backend, falls unterschiedlich.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/audio_manager_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::audio_manager_service::error::AudioManagerError`
    * `crate::audio_manager_service::data_types::{AudioDevice, AudioDeviceType, AudioConfig}`
    * `crate::audio_manager_service::audio_backend::{AudioBackendTrait, AudioBackendEvent}`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::sync::RwLock`
    * `std::sync::Arc`
    * `tracing`

**Kommunikationsmuster:**

* Ist die zentrale Logik für die Audioverwaltung.
* Empfängt Audio-Zustandsänderungen vom `AudioBackend` und übersetzt sie in `SystemEvent`s.
* Delegiert alle OS-spezifischen Aktionen (Setzen von Lautstärke, Geräten) an das `AudioBackend`.
* Interagiert mit `ConfigService` für Konfiguration und Speicherung.
* Sendet verschiedene `SystemEvent`s an den `EventBus`, um Systemzustandsänderungen zu signalisieren.
* Empfängt `SystemEvent::ConfigChanged` zur Aktualisierung der eigenen Einstellungen.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Audio Manager, der den System-Audiozustand überwacht, auf Änderungen reagiert und Audio-Aktionen steuert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus` und `AudioBackend` (verwenden Sie ein Mock-Implementierung des `AudioBackendTrait`).
    * Testen von `new` und dem Laden/Anwenden der initialen Konfiguration.
    * Testen von `handle_backend_event`:
        * Simulieren verschiedener `AudioBackendEvent`s und Überprüfen, ob die interne `current_config` korrekt aktualisiert und die entsprechenden `SystemEvent`s gesendet werden.
        * Überprüfen der Konfigurationsspeicherung nach Änderungen.
    * Testen von `get_master_volume`, `is_muted`, `get_audio_devices`, `get_default_output_device` durch Überprüfen der korrekten Delegierung an den Mock-`AudioBackend`.
    * Testen von `set_master_volume`, `set_muted`, `set_default_output_device`:
        * Überprüfen der korrekten Delegierung an den Mock-`AudioBackend`.
        * Überprüfen der Aktualisierung der internen `current_config` und des `ConfigService`.
        * Überprüfen der Event-Sendung an den `EventBus`.
    * Testen von `update_config` und der korrekten Anwendung neuer Einstellungen auf das Backend.
* **Integration Tests:**
    * Starten des `AudioManager` mit einem realen (oder auf einer VM kontrollierten) `AudioBackend`.
    * Automatisierte Tests, die Lautstärke, Stummschaltung und Geräteauswahl manipulieren und die Reaktionen des Managers (z.B. über den `EventBus`) überprüfen.
    * Überprüfung der End-to-End-Funktionalität des Audio-Managements.

**Geschätzter Aufwand:** Sehr hoch (ca. 8-12 Tage, da komplexe Zustandsverwaltung, Event-Verarbeitung, und Interaktion mit dem plattformspezifischen Backend)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `keyboard_manager_service`, widmen wir uns `audio_manager_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/audio_manager_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/audio_manager_service/data_types.rs`**: Definition der Datentypen für Audio-Geräte und Konfiguration.
3.  **`novade-system/src/audio_manager_service/audio_backend.rs`**: Implementierung der plattformspezifischen Schnittstelle für Audio-Steuerung und Ereignisse. Dies ist die Basis.
4.  **`novade-system/src/audio_manager_service/manager.rs`**: Die Kernlogik für die Audioverwaltung, die das `AudioBackend` orchestriert und Audio-Einstellungen sowie Ereignisse verarbeitet.
5.  **`novade-system/src/audio_manager_service/mod.rs`**: Das Hauptmodul, das den Manager und seine Sub-Komponenten initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/audio_manager_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/display_manager_service` Verzeichnisses.
---
### **novade-system/src/display_manager_service/mod.rs**

**Verantwortlichkeit:**
Das `display_manager_service` Modul ist für die globale Verwaltung von Anzeigeeinstellungen zuständig. Es steuert die Helligkeit, die Bildschirmkonfiguration (Auflösung, Bildwiederholfrequenz, Ausrichtung, Multi-Monitor-Setups) und den Display-Zustand (Ein/Aus). Es überwacht Display-Ereignisse und interagiert mit dem `config_service` für Präferenzen und dem `event_bus` für Zustandsänderungen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/display_manager_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Display Manager-Operationen)
    * `manager.rs` (Logik für Helligkeitssteuerung, Monitorverwaltung, Display-Status)
    * `data_types.rs` (Definition von Display-bezogenen Datentypen)
    * `display_backend.rs` (Plattformspezifische Schnittstelle zu OS-Display-APIs)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Display-Subsystems:**
    * `pub async fn initialize_display_manager_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<DisplayManagerService, DisplayManagerError>`
    * **Logik:**
        * Erstellt eine Instanz von `display_backend::DisplayBackend` (plattformspezifisch).
        * Erstellt eine Instanz von `manager::DisplayManager`.
        * Lädt initiale Konfigurationen aus dem `config_service` (z.B. primärer Monitor, Auflösungen, Helligkeit, Nachtlicht-Einstellungen).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Startet einen Hintergrund-Task, der Display-Ereignisse vom `DisplayBackend` liest und diese über den `EventBus` als `SystemEvent::DisplayStateChanged`, `SystemEvent::DisplayConfigurationChanged`, `SystemEvent::BrightnessChanged` sendet.
        * Gibt ein gebündeltes `DisplayManagerService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder des Backends.

2.  **`DisplayManagerService` Struct:**
    * `pub struct DisplayManagerService {`
        * `manager: Arc<DisplayManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `backend_event_handle: tokio::task::JoinHandle<()>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Display-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `DisplayManagerService` exponiert Methoden zur Interaktion mit dem Anzeigesystem.
    * `pub async fn get_brightness(&self) -> Result<f32, DisplayManagerError>`
        * **Logik:** Delegiert an den `manager`, um die aktuelle Bildschirmhelligkeit abzurufen (0.0 - 1.0).
    * `pub async fn set_brightness(&self, brightness: f32) -> Result<(), DisplayManagerError>`
        * **Logik:** Delegiert an den `manager`, um die Bildschirmhelligkeit zu setzen. Aktualisiert den `config_service`. Sendet `SystemEvent::BrightnessChanged`.
    * `pub async fn get_display_state(&self) -> Result<bool, DisplayManagerError>`
        * **Logik:** Delegiert an den `manager`, um den Ein-/Aus-Zustand des Displays abzurufen.
    * `pub async fn set_display_state(&self, on: bool) -> Result<(), DisplayManagerError>`
        * **Logik:** Delegiert an den `manager`, um das Display ein- oder auszuschalten. Sendet `SystemEvent::DisplayStateChanged`.
    * `pub async fn get_connected_monitors(&self) -> Result<Vec<Monitor>, DisplayManagerError>`
        * **Logik:** Delegiert an den `manager`, um eine Liste der aktuell verbundenen Monitore abzurufen.
    * `pub async fn set_monitor_config(&self, config: MonitorConfig) -> Result<(), DisplayManagerError>`
        * **Logik:** Delegiert an den `manager`, um die Konfiguration eines bestimmten Monitors (Auflösung, Bildwiederholfrequenz, Position, Ausrichtung) zu ändern. Aktualisiert den `config_service`. Sendet `SystemEvent::DisplayConfigurationChanged`.
    * `pub async fn apply_display_arrangement(&self, arrangement: DisplayArrangement) -> Result<(), DisplayManagerError>`
        * **Logik:** Delegiert an den `manager`, um eine vollständige Anzeigekonfiguration (inkl. Multi-Monitor-Anordnung) anzuwenden. Aktualisiert den `config_service`. Sendet `SystemEvent::DisplayConfigurationChanged`.
    * `pub async fn get_display_settings(&self) -> Result<DisplayConfig, DisplayManagerError>`
        * **Logik:** Ruft die aktuelle Konfiguration aus dem `config_service` ab.
    * `pub async fn update_display_settings(&self, config: DisplayConfig) -> Result<(), DisplayManagerError>`
        * **Logik:** Speichert die Konfiguration über den `config_service` und benachrichtigt den Manager.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `DisplayManagerService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Einstellungen (z.B. Monitor-Arrangement, Helligkeit) geändert werden, werden die Sub-Komponenten (`DisplayManager`, `DisplayBackend`) informiert.

5.  **Hintergrund-Task zum Abfangen von Display-Ereignissen:**
    * Ein Task, der einen Stream von Display-Zustandsänderungen vom `DisplayBackend` liest.
    * Jede empfangene Änderung (Helligkeit, Display-Ein/Aus, Monitor-Hinzufügen/Entfernen, Auflösungsänderung) wird als entsprechendes `SystemEvent` an den `EventBus` gesendet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_manager_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::display_manager_service::error::DisplayManagerError`
    * `crate::display_manager_service::manager::DisplayManager`
    * `crate::display_manager_service::data_types::{Monitor, MonitorConfig, DisplayArrangement, DisplayConfig}`
    * `crate::display_manager_service::display_backend::DisplayBackend`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `futures::stream::StreamExt`

**Kommunikationsmuster:**

* Ist der primäre Controller für die Displayverwaltung.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Anzeigeeinstellungen.
* Empfängt Display-Zustandsänderungen vom `DisplayBackend`.
* Sendet `SystemEvent::DisplayStateChanged`, `SystemEvent::DisplayConfigurationChanged`, `SystemEvent::BrightnessChanged`, `SystemEvent::MonitorConnected`, `SystemEvent::MonitorDisconnected` an den `EventBus`, um UI-Komponenten und andere Systemdienste zu informieren.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Display-Subsystem, das die systemweite Helligkeit, Monitor-Konfiguration und den Display-Zustand steuern kann.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `DisplayManager` und `DisplayBackend`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und des Starts der Event-Listener.
    * Testen der Weiterleitung von API-Aufrufen an den `DisplayManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von Display-Zustandsänderungen vom Mock-`DisplayBackend` und Überprüfen, ob die korrekten `SystemEvent`s an den `EventBus` gesendet werden.
* **Integration Tests:**
    * Starten des `DisplayManagerService` in einer Testumgebung (ggf. mit einem simulierten `DisplayBackend`).
    * Testen des Setzens und Abrufens der Helligkeit.
    * Testen des Ein- und Ausschaltens des Displays (virtuell oder mit speziellem Setup).
    * Testen der Abfrage und des Setzens von Monitor-Konfigurationen (Auflösung, Position).
    * Überprüfen, ob `SystemEvent::Display*` Events korrekt gesendet werden.

**Geschätzter Aufwand:** Hoch (ca. 7-10 Tage, da komplexe Grafik-APIs und Event-Verarbeitung)

---
### **novade-system/src/display_manager_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `display_manager_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Display-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`DisplayManagerError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum DisplayManagerError {`
        * `#[error("Failed to get display information: {0}")]`
        * `DisplayInformationFailed(String),`
        * `#[error("Monitor with ID '{0}' not found.")]`
        * `MonitorNotFound(String),`
        * `#[error("Failed to set brightness: {0}")]`
        * `SetBrightnessFailed(String),`
        * `#[error("Failed to set display state (on/off): {0}")]`
        * `SetDisplayStateFailed(String),`
        * `#[error("Failed to apply monitor configuration: {0}")]`
        * `ApplyMonitorConfigFailed(String),`
        * `#[error("Failed to apply display arrangement: {0}")]`
        * `ApplyDisplayArrangementFailed(String),`
        * `#[error("Invalid brightness value: {0}")]`
        * `InvalidBrightness(f32),`
        * `#[error("Invalid resolution or refresh rate for monitor '{0}'.")]`
        * `InvalidMonitorMode(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Platform specific display backend error: {0}")]`
        * `PlatformError(String),`
        * `#[error("Unknown display manager error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `anyhow::Error` (und potenziell plattformspezifische Fehler).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_manager_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `display_manager_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Displayverwaltungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/display_manager_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `display_manager_service` verwendet werden, um Monitore, Display-Modi, Helligkeit und zugehörige Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`Monitor` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct Monitor {`
        * `pub id: String,` // Eindeutige ID des Monitors (vom OS/Backend bereitgestellt)
        * `pub name: String,` // Anzeigename (z.B. "Dell U2721DE")
        * `pub is_primary: bool,`
        * `pub current_mode: DisplayMode,`
        * `pub available_modes: Vec<DisplayMode>,` // Liste der unterstützten Auflösungen und Bildwiederholfrequenzen
        * `pub position_x: i32,` // X-Position in virtuellen Pixeln
        * `pub position_y: i32,` // Y-Position in virtuellen Pixeln
        * `pub orientation: DisplayOrientation,` // Ausrichtung (Normal, 90 Grad, etc.)
        * `pub physical_width_mm: Option<u32>,`
        * `pub physical_height_mm: Option<u32>,`
    * `}`

2.  **`DisplayMode` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct DisplayMode {`
        * `pub width: u32,` // Auflösung Breite
        * `pub height: u32,` // Auflösung Höhe
        * `pub refresh_rate_hz: u32,` // Bildwiederholfrequenz
        * `pub preferred: bool,` // Ob dies der vom Monitor bevorzugte Modus ist
    * `}`

3.  **`DisplayOrientation` Enum:**
    * `#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum DisplayOrientation { Normal, Rotated90, Rotated180, Rotated270 }`

4.  **`MonitorConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct MonitorConfig {`
        * `pub monitor_id: String,`
        * `pub mode: DisplayMode,`
        * `pub position_x: i32,`
        * `pub position_y: i32,`
        * `pub orientation: DisplayOrientation,`
        * `pub is_primary: bool,`
        * `pub enabled: bool,` // Monitor aktivieren/deaktivieren
    * `}`

5.  **`DisplayArrangement` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct DisplayArrangement {`
        * `pub configs: Vec<MonitorConfig>,`
        * `pub active_arrangement_id: Option<String>,` // Für vordefinierte Profile
    * `}`

6.  **`DisplayConfig` Struct (aus `settings_manager::data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct DisplayConfig {`
        * `pub brightness: f32,` // Systemweite Helligkeit
        * `pub current_arrangement: DisplayArrangement,`
        * `pub saved_arrangements: HashMap<String, DisplayArrangement>,` // Benutzerdefinierte Profile
        * `pub night_light_enabled: bool,`
        * `pub night_light_temperature: u32,` // Farbtemperatur in Kelvin
        * `pub night_light_schedule: Option<NightLightSchedule>,`
        * `pub adaptive_brightness_enabled: bool,`
        * `// ...`
    * `}`

7.  **`NightLightSchedule` Enum (Optional):**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub enum NightLightSchedule {`
        * `SunsetToSunrise,`
        * `Manual(u32, u32),` // Startzeit (Minuten seit Mitternacht), Endzeit
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_manager_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::collections::HashMap`
* **Intern:**
    * `crate::settings_manager::data_types::DisplayConfig` (oder direkter Import)

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Display-Informationen im System.
* `Monitor` Objekte werden vom `DisplayBackend` generiert.
* `DisplayConfig` wird im `SettingsManagerService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Displayverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.
    * Überprüfen der Standardwerte und optionalen Felder.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/display_manager_service/display_backend.rs**

**Verantwortlichkeit:**
Das `display_backend` Modul ist die plattformspezifische Abstraktionsschicht für den Zugriff auf Betriebssystem-APIs zur Display- und Grafikkartenverwaltung. Es ist verantwortlich für die Interaktion mit den Grafik-Subsystemen des OS (z.B. RandR/DRM/KMS unter Linux, DXGI/GDI unter Windows, Core Graphics/Display Services unter macOS), um Helligkeit zu steuern, Monitore zu erkennen, Modi zu setzen und Display-Ereignisse zu überwachen.

**Kern-Aufgaben (Tasks):**

1.  **`DisplayBackendTrait` Trait (für Abstraktion):**
    * `#[async_trait::async_trait]`
    * `pub trait DisplayBackendTrait: Send + Sync {`
        * `async fn get_brightness(&self, monitor_id: Option<&str>) -> Result<f32, DisplayManagerError>;`
        * `async fn set_brightness(&self, monitor_id: Option<&str>, brightness: f32) -> Result<(), DisplayManagerError>;`
        * `async fn get_display_state(&self, monitor_id: Option<&str>) -> Result<bool, DisplayManagerError>;`
        * `async fn set_display_state(&self, monitor_id: Option<&str>, on: bool) -> Result<(), DisplayManagerError>;`
        * `async fn get_connected_monitors(&self) -> Result<Vec<Monitor>, DisplayManagerError>;`
        * `async fn apply_monitor_config(&self, config: &MonitorConfig) -> Result<(), DisplayManagerError>;`
        * `async fn apply_display_arrangement(&self, arrangement: &DisplayArrangement) -> Result<(), DisplayManagerError>;`
        * `async fn display_event_stream(&self) -> Pin<Box<dyn Stream<Item = DisplayBackendEvent> + Send>>;`
        * `// Optional: Night Light / Color Temperature`
        * `async fn set_night_light_enabled(&self, enabled: bool) -> Result<(), DisplayManagerError>;`
        * `async fn set_color_temperature(&self, temperature: u32) -> Result<(), DisplayManagerError>;`
        * `// Optional: Adaptive Brightness`
        * `async fn set_adaptive_brightness_enabled(&self, enabled: bool) -> Result<(), DisplayManagerError>;`
    * `}`

2.  **Konkrete `DisplayBackend` Implementierungen:**
    * `#[cfg(target_os = "linux")]`
    * `pub struct LinuxDisplayBackend { /* xcb::Connection, drm::Client, etc. */ }`
    * `#[cfg(target_os = "windows")]`
    * `pub struct WindowsDisplayBackend { /* IDXGIOutput, HDC, etc. */ }`
    * `#[cfg(target_os = "macos")]`
    * `pub struct MacOSDisplayBackend { /* CGDisplayServices, etc. */ }`

3.  **`new()` Funktion für jede Implementierung:**
    * `pub async fn new() -> Result<Self, DisplayManagerError>`
    * **Logik:**
        * **Plattformspezifisch:**
            * **Linux (X11):** Initialisiert `xcb` für RandR-Interaktion.
            * **Linux (Wayland):** Interagiert mit dem Wayland-Compositor über `wlr-output-management` oder andere Protokolle (falls NovaDE nicht der Compositor ist). Wenn NovaDE der Compositor ist, interagiert es direkt mit KMS/DRM.
            * **Windows:** Initialisiert DXGI (DirectX Graphics Infrastructure) oder GDI APIs.
            * **macOS:** Initialisiert `Core Graphics` und `Display Services` APIs.
        * Gibt die konkrete Implementierung zurück.
        * **Fehlerbehandlung:** `PlatformError` bei Problemen mit nativen APIs oder Berechtigungen.

4.  **`DisplayBackendEvent` Enum (intern):**
    * `#[derive(Debug, Clone, PartialEq)]`
    * `pub enum DisplayBackendEvent {`
        * `BrightnessChanged(f32, Option<String>),` // (new_brightness, monitor_id)
        * `DisplayStateChanged(bool, Option<String>),` // (is_on, monitor_id)
        * `MonitorConnected(Monitor),`
        * `MonitorDisconnected(String),` // Monitor ID
        * `DisplayConfigurationChanged(String),` // Monitor ID (or global change)
        * `// ... weitere Events wie z.B. Night Light Status changes`
    * `}`

**Implementierung der Trait-Methoden (für jede Plattform):**

* **`get_brightness` / `set_brightness`:**
    * **Linux (X11):** XRANDR Property `Backlight`.
    * **Linux (Wayland):** Über Compositor-Protokolle.
    * **Windows:** `SetMonitorBrightness` (DDC/CI) oder `WmiMonitorBrightnessMethods` (WMI).
    * **macOS:** `IOKit` oder `Display Services`.
* **`get_display_state` / `set_display_state`:**
    * **Linux (X11):** RandR Power Management.
    * **Linux (Wayland):** Compositor-Protokolle.
    * **Windows:** `SendMessage(WM_SYSCOMMAND, SC_MONITORPOWER)`.
    * **macOS:** `IOPMSleepSystem()`.
* **`get_connected_monitors`:**
    * **Linux (X11):** `xcb_randr_get_screen_resources_current`, `xcb_randr_get_outputs`.
    * **Linux (Wayland):** `wlr-output-management` oder interne Compositor-Status.
    * **Windows:** `EnumDisplayMonitors`, `GetMonitorInfo`.
    * **macOS:** `CGGetOnlineDisplayList`.
* **`apply_monitor_config` / `apply_display_arrangement`:**
    * **Linux (X11):** `xcb_randr_set_screen_config`, `xcb_randr_set_crtc_config`.
    * **Linux (Wayland):** Über Compositor-Protokolle zum Anwenden von Output-Konfigurationen.
    * **Windows:** `ChangeDisplaySettingsEx`.
    * **macOS:** `CGConfigureDisplayMode`.
* **`display_event_stream`:**
    * **Linux (X11):** `xcb_randr_notify` Events.
    * **Linux (Wayland):** Event-Listener des Compositors.
    * **Windows:** `WM_DISPLAYCHANGE` oder `RegisterDeviceNotification`.
    * **macOS:** `CGDisplayRegisterReconfigurationCallback`.
    * Dies ist ein langlebiger asynchroner Task, der Events in `DisplayBackendEvent` umwandelt und über einen `mpsc::channel` sendet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_manager_service/display_backend.rs`
* `novade-system/src/display_manager_service/linux.rs`
* `novade-system/src/display_manager_service/windows.rs`
* `novade-system/src/display_manager_service/macos.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::display_manager_service::error::DisplayManagerError`
    * `crate::display_manager_service::data_types::{Monitor, DisplayMode, DisplayOrientation, MonitorConfig, DisplayArrangement}`
* **Extern:**
    * `tokio::task::spawn_blocking`
    * `futures::stream::Stream`
    * `async_trait`
    * `tracing`
    * `std::sync::Arc`
    * `std::pin::Pin`
    * `tokio::sync::mpsc`
    * **Plattformspezifisch:**
        * `x11rb`, `xkbcommon`, `drm-rs` (Linux X11/DRM)
        * `wayland-client`, `wayland-protocols` (Linux Wayland)
        * `windows` crate (Windows)
        * `core_graphics`, `core_foundation` (macOS)

**Kommunikationsmuster:**

* Bietet die Low-Level-Schnittstelle zu den Anzeigesubsystemen des Betriebssystems.
* Sendet Display-Zustandsänderungen über den `display_event_stream()` an den `DisplayManager`.
* Empfängt Anfragen zur Helligkeits-, Zustands- oder Konfigurationsänderung vom `DisplayManager`.

**Erwartete Ergebnisse/Outputs:**
Eine stabile, plattformübergreifende Schnittstelle zur Display-Steuerung und Ereigniserfassung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking von OS-Display-APIs):**
    * Mocken aller plattformspezifischen Bibliotheken (z.B. XrandR-Binding, DXGI-Schnittstelle).
    * Simulieren von Helligkeitsänderungen, Monitor-An-/Abmeldungen und Auflösungsänderungen und Überprüfen, ob `display_event_stream` die korrekten `DisplayBackendEvent`s liefert.
    * Testen der `get_brightness`, `set_brightness`, `get_display_state`, `set_display_state`, `get_connected_monitors`, `apply_monitor_config`, `apply_display_arrangement` Methoden mit simulierten OS-Antworten.
    * Testen der Fehlerbehandlung bei fehlgeschlagenen Systemaufrufen.
* **Integration Tests (auf dedizierten Testmaschinen pro OS oder VM):**
    * **Vorsicht:** Diese Tests können echte Display-Einstellungen beeinflussen und sollten nur in isolierten Umgebungen durchgeführt werden.
    * Starten des `DisplayBackend` und Ausführen von Helligkeitsänderungen, Display-Ein/Aus und Monitor-Konfigurationen, um die korrekte Funktion zu überprüfen.
    * Physisches Hinzufügen/Entfernen von Monitoren (falls möglich) und Überprüfen, ob die Ereignisse im `display_event_stream` korrekt erfasst werden.
    * Überprüfung der angezeigten Auflösung und Anordnung nach Konfigurationsänderungen.

**Geschätzter Aufwand:** Sehr hoch (ca. 15-20 Tage, da komplexe plattformspezifische Grafikschnittstellen, Event-Listener, und umfangreiche Konfigurationsmöglichkeiten)

---
### **novade-system/src/display_manager_service/manager.rs**

**Verantwortlichkeit:**
Der `DisplayManager` ist die Kernlogik des Displayverwaltungssystems. Er orchestriert die Interaktion mit dem plattformspezifischen `DisplayBackend`, verwaltet die Anzeigeeinstellungen basierend auf der `DisplayConfig` und löst Events bei Änderungen aus. Er ist auch für die Implementierung von Features wie Nachtlicht und adaptiver Helligkeit verantwortlich, falls das Backend diese nicht nativ unterstützt.

**Kern-Aufgaben (Tasks):**

1.  **`DisplayManager` Struct:**
    * `pub struct DisplayManager {`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `display_backend: Arc<dyn DisplayBackendTrait + Send + Sync>,`
        * `current_config: RwLock<DisplayConfig>,`
        * `// Timer/Handles für Nachtlicht und adaptive Helligkeit`
        * `night_light_task: Arc<Mutex<Option<tokio::task::JoinHandle<()>>>>,`
        * `adaptive_brightness_task: Arc<Mutex<Option<tokio::task::JoinHandle<()>>>>,`
    * `}`

2.  **`DisplayManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus, display_backend: Arc<dyn DisplayBackendTrait + Send + Sync>) -> Result<Self, DisplayManagerError>`
    * **Logik:**
        * Initialisiert alle Felder.
        * Lädt die initiale `DisplayConfig` aus dem `config_service`.
        * Wendet die geladene Konfiguration auf das `display_backend` an (z.B. setzt Helligkeit, bevorzugte Anordnung).
        * Startet die Hintergrund-Tasks für Nachtlicht und adaptive Helligkeit basierend auf der initialen Konfiguration.
        * Gibt `Self` zurück.

3.  **`DisplayManager::handle_backend_event()` Methode (intern, vom Service aufgerufen):**
    * `pub async fn handle_backend_event(&self, event: DisplayBackendEvent)`
    * **Logik:**
        * Verarbeitet `DisplayBackendEvent`s vom `DisplayBackend`.
        * Bei `BrightnessChanged(brightness, monitor_id)`: Aktualisiert die interne `current_config.brightness` (oder monitoreigene Helligkeit) und sendet `SystemEvent::BrightnessChanged(brightness, monitor_id)` an den `EventBus`. Speichert die aktualisierte Konfiguration.
        * Bei `DisplayStateChanged(is_on, monitor_id)`: Sendet `SystemEvent::DisplayStateChanged(is_on, monitor_id)`.
        * Bei `MonitorConnected(monitor)`: Fügt den Monitor zur internen Liste der verbundenen Monitore hinzu, aktualisiert ggf. die `current_arrangement` und sendet `SystemEvent::MonitorConnected(monitor)`. Speichert die Konfiguration.
        * Bei `MonitorDisconnected(monitor_id)`: Entfernt den Monitor aus der internen Liste, aktualisiert die `current_arrangement` und sendet `SystemEvent::MonitorDisconnected(monitor_id)`. Speichert die Konfiguration.
        * Bei `DisplayConfigurationChanged(monitor_id)`: Ruft die aktuelle Konfiguration erneut ab und sendet `SystemEvent::DisplayConfigurationChanged(monitor_id)`.

4.  **`DisplayManager::get_brightness()` Methode:**
    * `pub async fn get_brightness(&self, monitor_id: Option<&str>) -> Result<f32, DisplayManagerError>`
    * **Logik:** Delegiert an `self.display_backend.get_brightness(monitor_id)`.

5.  **`DisplayManager::set_brightness()` Methode:**
    * `pub async fn set_brightness(&self, brightness: f32) -> Result<(), DisplayManagerError>`
    * **Logik:**
        * Validiert den `brightness` Wert (0.0 - 1.0).
        * Delegiert an `self.display_backend.set_brightness(None, brightness)` (für globale Helligkeit).
        * Aktualisiert `current_config.brightness` und speichert die Konfiguration.
        * Sendet `SystemEvent::BrightnessChanged(brightness, None)` an den `EventBus`.

6.  **`DisplayManager::get_display_state()` Methode:**
    * `pub async fn get_display_state(&self, monitor_id: Option<&str>) -> Result<bool, DisplayManagerError>`
    * **Logik:** Delegiert an `self.display_backend.get_display_state(monitor_id)`.

7.  **`DisplayManager::set_display_state()` Methode:**
    * `pub async fn set_display_state(&self, on: bool) -> Result<(), DisplayManagerError>`
    * **Logik:**
        * Delegiert an `self.display_backend.set_display_state(None, on)` (für alle Displays).
        * Sendet `SystemEvent::DisplayStateChanged(on, None)` an den `EventBus`.

8.  **`DisplayManager::get_connected_monitors()` Methode:**
    * `pub async fn get_connected_monitors(&self) -> Result<Vec<Monitor>, DisplayManagerError>`
    * **Logik:** Delegiert an `self.display_backend.get_connected_monitors()`.

9.  **`DisplayManager::set_monitor_config()` Methode:**
    * `pub async fn set_monitor_config(&self, config: MonitorConfig) -> Result<(), DisplayManagerError>`
    * **Logik:**
        * Validiert die `config` gegen verfügbare Modi des Monitors.
        * Aktualisiert die `current_arrangement` in `current_config`.
        * Delegiert an `self.display_backend.apply_monitor_config(&config)`.
        * Speichert die aktualisierte Konfiguration.
        * Sendet `SystemEvent::DisplayConfigurationChanged(config.monitor_id)` an den `EventBus`.

10. **`DisplayManager::apply_display_arrangement()` Methode:**
    * `pub async fn apply_display_arrangement(&self, arrangement: DisplayArrangement) -> Result<(), DisplayManagerError>`
    * **Logik:**
        * Delegiert an `self.display_backend.apply_display_arrangement(&arrangement)`.
        * Aktualisiert `current_config.current_arrangement` und speichert die Konfiguration.
        * Sendet `SystemEvent::DisplayConfigurationChanged("global".to_string())` an den `EventBus`.

11. **`DisplayManager::update_config()` Methode (intern, vom Service aufgerufen bei `SystemEvent::ConfigChanged`):**
    * `pub async fn update_config(&self, new_config: DisplayConfig)`
    * **Logik:**
        * Aktualisiert die interne `current_config`.
        * Vergleicht `new_config.brightness` und setzt Helligkeit über Backend, falls unterschiedlich.
        * Vergleicht `new_config.current_arrangement` und wendet Arrangement über Backend an, falls unterschiedlich.
        * Startet/Stoppt/Aktualisiert den Nachtlicht-Task basierend auf `night_light_enabled`, `night_light_temperature` und `night_light_schedule`.
        * Startet/Stoppt den adaptiven Helligkeits-Task basierend auf `adaptive_brightness_enabled`.

12. **`DisplayManager::run_night_light_task()` Methode (intern):**
    * `async fn run_night_light_task(self: Arc<Self>)`
    * **Logik:**
        * Periodisch (z.B. alle 5 Minuten) prüft die aktuelle Zeit und die `night_light_schedule`.
        * Wenn der Nachtlicht-Zeitraum aktiv ist, setzt es die Farbtemperatur über `display_backend.set_color_temperature()`.
        * Verwendet `time` crate, um Sonnenauf- und -untergang basierend auf dem Standort zu berechnen, falls `SunsetToSunrise` gewählt ist.

13. **`DisplayManager::run_adaptive_brightness_task()` Methode (intern):**
    * `async fn run_adaptive_brightness_task(self: Arc<Self>)`
    * **Logik:**
        * Periodisch (z.B. alle 10 Sekunden) liest es den Umgebungslichtsensor (falls vorhanden und vom `hardware_monitor_service` bereitgestellt, ansonsten ein Fallback).
        * Passt die Helligkeit über `display_backend.set_brightness()` an.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/display_manager_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::display_manager_service::error::DisplayManagerError`
    * `crate::display_manager_service::data_types::{Monitor, DisplayMode, DisplayOrientation, MonitorConfig, DisplayArrangement, DisplayConfig, NightLightSchedule}`
    * `crate::display_manager_service::display_backend::{DisplayBackendTrait, DisplayBackendEvent}`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
    * `crate::hardware_monitor_service::HardwareMonitorService` (für Umgebungslichtsensor, optional)
* **Extern:**
    * `tokio::sync::{RwLock, Mutex}`
    * `tokio::time`
    * `std::sync::Arc`
    * `tracing`
    * `time` crate (für Zeitzonen und Datums-/Uhrzeitberechnungen)
    * `async_trait`

**Kommunikationsmuster:**

* Ist die zentrale Logik für die Displayverwaltung.
* Empfängt Display-Zustandsänderungen vom `DisplayBackend` und übersetzt sie in `SystemEvent`s.
* Delegiert alle OS-spezifischen Aktionen (Setzen von Helligkeit, Zuständen, Konfigurationen) an das `DisplayBackend`.
* Interagiert mit `ConfigService` für Konfiguration und Speicherung.
* Sendet verschiedene `SystemEvent`s an den `EventBus`, um Systemzustandsänderungen zu signalisieren.
* Empfängt `SystemEvent::ConfigChanged` zur Aktualisierung der eigenen Einstellungen.
* Kann den `HardwareMonitorService` abfragen.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Display Manager, der den System-Display-Zustand überwacht, auf Änderungen reagiert, Display-Aktionen steuert und erweiterte Features wie Nachtlicht und adaptive Helligkeit implementiert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus` und `DisplayBackend`.
    * Testen von `new` und dem Laden/Anwenden der initialen Konfiguration.
    * Testen von `handle_backend_event`: Simulieren verschiedener `DisplayBackendEvent`s und Überprüfen, ob die interne `current_config` korrekt aktualisiert und die entsprechenden `SystemEvent`s gesendet werden.
    * Testen von `get_brightness`, `set_brightness`, `get_display_state`, `set_display_state`, `get_connected_monitors`, `set_monitor_config`, `apply_display_arrangement` durch Überprüfen der korrekten Delegierung an den Mock-`DisplayBackend` und der Event-Sendung.
    * Testen von `update_config` und der korrekten Anwendung neuer Einstellungen auf das Backend sowie der Steuerung der Hintergrund-Tasks (Nachtlicht, adaptive Helligkeit).
    * **Nachtlicht-Task Tests:** Mocken der Zeit und des Standorts, um zu überprüfen, ob die Farbtemperatur zu den richtigen Zeiten gesetzt wird.
    * **Adaptive Helligkeit Task Tests:** Mocken der Sensorwerte, um zu überprüfen, ob die Helligkeit korrekt angepasst wird.
* **Integration Tests:**
    * Starten des `DisplayManager` mit einem realen (oder auf einer VM kontrollierten) `DisplayBackend`.
    * Automatisierte Tests, die Helligkeit, Display-Zustand und Monitor-Konfigurationen manipulieren und die Reaktionen des Managers (z.B. über den `EventBus`) überprüfen.
    * Testen von Nachtlicht und adaptiver Helligkeit in einer kontrollierten Umgebung (ggf. mit simuliertem Umgebungslichtsensor).
    * Überprüfung der End-to-End-Funktionalität des Display-Managements.

**Geschätzter Aufwand:** Sehr hoch (ca. 12-18 Tage, da komplexe Zustandsverwaltung, Event-Verarbeitung, Interaktion mit dem plattformspezifischen Backend und Implementierung von intelligenten Features)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `audio_manager_service`, widmen wir uns `display_manager_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/display_manager_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/display_manager_service/data_types.rs`**: Definition der Datentypen für Monitore, Modi und Konfigurationen.
3.  **`novade-system/src/display_manager_service/display_backend.rs`**: Implementierung der plattformspezifischen Schnittstelle für Display-Steuerung und Ereignisse. Dies ist die Basis.
4.  **`novade-system/src/display_manager_service/manager.rs`**: Die Kernlogik für die Displayverwaltung, die das `DisplayBackend` orchestriert und Display-Einstellungen, Ereignisse, Nachtlicht und adaptive Helligkeit verarbeitet.
5.  **`novade-system/src/display_manager_service/mod.rs`**: Das Hauptmodul, das den Manager und seine Sub-Komponenten initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/display_manager_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/network_manager_service` Verzeichnisses.
---
### **novade-system/src/network_manager_service/mod.rs**

**Verantwortlichkeit:**
Das `network_manager_service` Modul ist für die systemweite Verwaltung von Netzwerkkonnektivität zuständig. Es ermöglicht das Auflisten, Verbinden und Trennen von Netzwerkgeräten (Wi-Fi, Ethernet, Bluetooth-Tethering, Mobilfunk), die Konfiguration von Netzwerkprofilen und die Überwachung des Netzwerkstatus. Es interagiert mit dem `config_service` für gespeicherte Verbindungen und dem `event_bus` für Statusänderungen.

**Verzeichnis-/Modulstruktur:**

* `novade-system/src/network_manager_service/`
    * `mod.rs` (Dieses Modul, Haupt-API und Initialisierung)
    * `error.rs` (Fehlerbehandlung für Network Manager-Operationen)
    * `manager.rs` (Logik für Netzwerkgeräte-Management, Verbindungsprofile und Statusüberwachung)
    * `data_types.rs` (Definition von Netzwerk-bezogenen Datentypen)
    * `network_backend.rs` (Plattformspezifische Schnittstelle zu OS-Netzwerk-APIs)

**Kern-Aufgaben (Tasks):**

1.  **Initialisierung des Netzwerk-Subsystems:**
    * `pub async fn initialize_network_manager_service(config_service: Arc<ConfigService>, event_bus: EventBus) -> Result<NetworkManagerService, NetworkManagerError>`
    * **Logik:**
        * Erstellt eine Instanz von `network_backend::NetworkBackend` (plattformspezifisch).
        * Erstellt eine Instanz von `manager::NetworkManager`.
        * Lädt initiale Konfigurationen aus dem `config_service` (z.B. gespeicherte WLAN-Netzwerke, bevorzugte Verbindungen).
        * Startet einen Hintergrund-Task, der auf `SystemEvent::ConfigChanged` hört, um aktualisierte Einstellungen zu laden.
        * Startet einen Hintergrund-Task, der Netzwerkereignisse vom `NetworkBackend` liest und diese über den `EventBus` als `SystemEvent::NetworkStatusChanged`, `SystemEvent::WifiNetworksUpdated`, `SystemEvent::NetworkDeviceAdded`, etc. sendet.
        * Gibt ein gebündeltes `NetworkManagerService` Struct zurück.
    * **Fehlerbehandlung:** Fehler bei der Initialisierung des Managers oder des Backends.

2.  **`NetworkManagerService` Struct:**
    * `pub struct NetworkManagerService {`
        * `manager: Arc<NetworkManager>,`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `backend_event_handle: tokio::task::JoinHandle<()>,`
    * `}`
    * Dient als Container und Zugangspunkt für die Netzwerk-Logik.

3.  **Bereitstellung von API-Methoden:**
    * Der `NetworkManagerService` exponiert Methoden zur Interaktion mit dem Netzwerksystem.
    * `pub async fn get_network_status(&self) -> Result<NetworkStatus, NetworkManagerError>`
        * **Logik:** Delegiert an den `manager`, um den aktuellen globalen Netzwerkstatus abzurufen (verbunden, getrennt, offline).
    * `pub async fn get_network_devices(&self) -> Result<Vec<NetworkDevice>, NetworkManagerError>`
        * **Logik:** Delegiert an den `manager`, um eine Liste der erkannten Netzwerkadapter abzurufen.
    * `pub async fn get_wifi_networks(&self) -> Result<Vec<WifiNetwork>, NetworkManagerError>`
        * **Logik:** Delegiert an den `manager`, um eine Liste der verfügbaren WLAN-Netzwerke (nach Scan) abzurufen.
    * `pub async fn scan_wifi_networks(&self) -> Result<(), NetworkManagerError>`
        * **Logik:** Delegiert an den `manager`, um einen WLAN-Scan zu initiieren.
    * `pub async fn connect_to_network(&self, connection_request: NetworkConnectionRequest) -> Result<(), NetworkManagerError>`
        * **Logik:** Delegiert an den `manager`, um eine Verbindung zu einem Netzwerk herzustellen (WLAN, Ethernet). `NetworkConnectionRequest` enthält Details wie SSID, Passwort, etc.
    * `pub async fn disconnect_from_network(&self, device_id: &str) -> Result<(), NetworkManagerError>`
        * **Logik:** Delegiert an den `manager`, um eine bestehende Netzwerkverbindung zu trennen.
    * `pub async fn save_network_profile(&self, profile: NetworkProfile) -> Result<(), NetworkManagerError>`
        * **Logik:** Delegiert an den `manager`, um ein Netzwerkprofil zu speichern. Aktualisiert den `config_service`.
    * `pub async fn delete_network_profile(&self, profile_id: &str) -> Result<(), NetworkManagerError>`
        * **Logik:** Delegiert an den `manager`, um ein Netzwerkprofil zu löschen. Aktualisiert den `config_service`.
    * `pub async fn get_network_settings(&self) -> Result<NetworkConfig, NetworkManagerError>`
        * **Logik:** Ruft die aktuelle Konfiguration aus dem `config_service` ab.
    * `pub async fn update_network_settings(&self, config: NetworkConfig) -> Result<(), NetworkManagerError>`
        * **Logik:** Speichert die Konfiguration über den `config_service` und benachrichtigt den Manager.

4.  **Hintergrund-Task zum Abonnieren von Konfigurationsänderungen:**
    * Der `NetworkManagerService` sollte einen langlebigen Task starten, der auf `SystemEvent::ConfigChanged` hört. Wenn relevante Einstellungen (z.B. gespeicherte Profile, DNS-Server) geändert werden, werden die Sub-Komponenten (`NetworkManager`, `NetworkBackend`) informiert.

5.  **Hintergrund-Task zum Abfangen von Netzwerk-Ereignissen:**
    * Ein Task, der einen Stream von Netzwerk-Zustandsänderungen vom `NetworkBackend` liest.
    * Jede empfangene Änderung (Verbindungsstatus, WLAN-Netzwerke, Geräte-Hinzufügen/Entfernen, IP-Adressänderung) wird als entsprechendes `SystemEvent` an den `EventBus` gesendet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/network_manager_service/mod.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::network_manager_service::error::NetworkManagerError`
    * `crate::network_manager_service::manager::NetworkManager`
    * `crate::network_manager_service::data_types::{NetworkStatus, NetworkDevice, WifiNetwork, NetworkConnectionRequest, NetworkProfile, NetworkConfig}`
    * `crate::network_manager_service::network_backend::NetworkBackend`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::{EventBus, EventReceiver}`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::task`
    * `tracing`
    * `std::sync::Arc`
    * `futures::stream::StreamExt`

**Kommunikationsmuster:**

* Ist der primäre Controller für die Netzwerkverwaltung.
* Interagiert mit dem `ConfigService` zum Speichern und Laden von Netzwerkeinstellungen und Profilen.
* Empfängt Netzwerk-Zustandsänderungen vom `NetworkBackend`.
* Sendet `SystemEvent::NetworkStatusChanged`, `SystemEvent::WifiNetworksUpdated`, `SystemEvent::NetworkDeviceAdded`, `SystemEvent::NetworkDeviceRemoved`, `SystemEvent::NetworkConnected`, `SystemEvent::NetworkDisconnected`, `SystemEvent::IpAddressChanged` an den `EventBus`, um UI-Komponenten und andere Systemdienste zu informieren.
* Empfängt `SystemEvent::ConfigChanged` für Konfigurationsupdates.

**Erwartete Ergebnisse/Outputs:**
Ein initialisiertes Netzwerk-Subsystem, das die systemweite Netzwerkkonnektivität überwacht und steuert.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Backend Mocking):**
    * Mocken des `ConfigService`, `EventBus`, `NetworkManager` und `NetworkBackend`.
    * Testen der Initialisierung, insbesondere des Ladens initialer Konfiguration und des Starts der Event-Listener.
    * Testen der Weiterleitung von API-Aufrufen an den `NetworkManager`.
    * Simulieren von `SystemEvent::ConfigChanged` und Überprüfen, ob die internen Zustände korrekt aktualisiert werden.
    * Simulieren von Netzwerk-Zustandsänderungen vom Mock-`NetworkBackend` und Überprüfen, ob die korrekten `SystemEvent`s an den `EventBus` gesendet werden.
* **Integration Tests:**
    * Starten des `NetworkManagerService` in einer Testumgebung (ggf. mit einem simulierten `NetworkBackend` oder in einer VM mit kontrolliertem Netzwerkzugriff).
    * Testen des Verbindens/Trennens von WLAN-Netzwerken mit und ohne Passwörtern.
    * Testen des Speicherns/Löschens von Netzwerkprofilen.
    * Überprüfen des globalen Netzwerkstatus und der Liste der Netzwerkgeräte.
    * Überprüfen, ob `SystemEvent::Network*` Events korrekt gesendet werden.

**Geschätzter Aufwand:** Hoch (ca. 8-12 Tage, da komplexe Netzwerk-APIs, Authentifizierung und Event-Verarbeitung)

---
### **novade-system/src/network_manager_service/error.rs**

**Verantwortlichkeit:**
Definiert spezifische Fehlertypen für das `network_manager_service` Subsystem. Dies ermöglicht eine granulare Fehlerbehandlung und -propagation für alle Netzwerk-bezogenen Probleme.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkManagerError` Enum:**
    * `#[derive(Debug, thiserror::Error)]`
    * `pub enum NetworkManagerError {`
        * `#[error("Failed to get network device information: {0}")]`
        * `DeviceInformationFailed(String),`
        * `#[error("Network device with ID '{0}' not found.")]`
        * `DeviceNotFound(String),`
        * `#[error("Network '{0}' not found or out of range.")]`
        * `NetworkNotFound(String),`
        * `#[error("Failed to connect to network: {0}")]`
        * `ConnectionFailed(String),`
        * `#[error("Failed to disconnect from network: {0}")]`
        * `DisconnectionFailed(String),`
        * `#[error("Authentication failed for network '{0}'.")]`
        * `AuthenticationFailed(String),`
        * `#[error("Network profile '{0}' already exists.")]`
        * `ProfileAlreadyExists(String),`
        * `#[error("Network profile '{0}' not found.")]`
        * `ProfileNotFound(String),`
        * `#[error("Config service error: {0}")]`
        * `ConfigServiceError(#[from] crate::config_service::error::ConfigError),`
        * `#[error("Platform specific network backend error: {0}")]`
        * `PlatformError(String),`
        * `#[error("Unknown network manager error: {0}")]`
        * `Other(#[from] anyhow::Error),`
    * `}`
    * Implementiere `From` für `crate::config_service::error::ConfigError`, `anyhow::Error` (und potenziell plattformspezifische Fehler).

**Spezifische Artefakte/Dateien:**

* `novade-system/src/network_manager_service/error.rs`

**Abhängigkeiten:**

* **Extern:**
    * `thiserror::Error`
    * `anyhow::Error`
* **Intern:**
    * `crate::config_service::error::ConfigError`

**Kommunikationsmuster:**

* Wird von allen Modulen innerhalb des `network_manager_service` Verzeichnisses verwendet, um Fehler zu signalisieren.
* Fehler werden an die aufrufende Domänenschicht oder UI-Komponenten propagiert.

**Erwartete Ergebnisse/Outputs:**
Ein konsistentes und informatives Fehlermanagement für das Netzwerkverwaltungssystem.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Erstellung jeder Fehler-Variante.
    * Testen der `From` Implementierungen.
    * Überprüfen der Fehlermeldungen mit `to_string()`.

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1 Tag, hauptsächlich Definitionen)

---
### **novade-system/src/network_manager_service/data_types.rs**

**Verantwortlichkeit:**
Definiert die spezifischen Datentypen, die vom `network_manager_service` verwendet werden, um Netzwerkgeräte, Verbindungen, Status und zugehörige Konfigurationen zu repräsentieren.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkStatus` Enum:**
    * `#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum NetworkStatus { Disconnected, Connecting, Connected, LimitedConnectivity, CaptivePortal, Offline }`

2.  **`NetworkDevice` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct NetworkDevice {`
        * `pub id: String,` // Eindeutige ID des Geräts (z.B. MAC-Adresse, Adaptername)
        * `pub name: String,` // Anzeigename (z.B. "Wi-Fi", "Ethernet")
        * `pub device_type: NetworkDeviceType,`
        * `pub is_enabled: bool,`
        * `pub connection_status: NetworkStatus,`
        * `pub ip_address: Option<String>,`
        * `pub mac_address: Option<String>,`
        * `pub connected_to_network_id: Option<String>,` // ID des aktuell verbundenen Netzwerks/Profils
    * `}`

3.  **`NetworkDeviceType` Enum:**
    * `#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum NetworkDeviceType { Wifi, Ethernet, BluetoothTethering, MobileData }`

4.  **`WifiNetwork` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct WifiNetwork {`
        * `pub ssid: String,`
        * `pub bssid: String,` // MAC-Adresse des Access Points
        * `pub signal_strength: u8,` // 0-100%
        * `pub security_type: WifiSecurityType,`
        * `pub is_connected: bool,`
        * `pub is_remembered: bool,` // Ob ein Profil für dieses Netzwerk existiert
    * `}`

5.  **`WifiSecurityType` Enum:**
    * `#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum WifiSecurityType { None, Wep, WpaPersonal, WpaEnterprise, Wpa2Personal, Wpa2Enterprise, Wpa3Personal, Wpa3Enterprise, Unknown }`

6.  **`NetworkConnectionRequest` Struct:**
    * `#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]`
    * `pub struct NetworkConnectionRequest {`
        * `pub device_id: String,` // Welches Gerät soll verwendet werden
        * `pub network_id: String,` // Z.B. SSID für WLAN, oder Profil-ID
        * `pub password: Option<String>,` // Für gesicherte Netzwerke
        * `pub save_profile: bool,`
        * `pub profile_name: Option<String>,` // Name des zu speichernden Profils
        * `pub ip_config_type: IpConfigType,`
        * `pub manual_ip_config: Option<ManualIpConfig>,`
    * `}`

7.  **`NetworkProfile` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct NetworkProfile {`
        * `pub id: String,` // Eindeutige ID des Profils (z.B. "wifi-home")
        * `pub name: String,` // Anzeigename
        * `pub device_type: NetworkDeviceType,`
        * `pub ssid: Option<String>,` // Nur für WLAN
        * `pub security_type: Option<WifiSecurityType>,` // Nur für WLAN
        * `pub password: Option<String>,` // Gespeichertes Passwort (verschlüsselt)
        * `pub auto_connect: bool,`
        * `pub priority: i32,`
        * `pub ip_config_type: IpConfigType,`
        * `pub manual_ip_config: Option<ManualIpConfig>,`
        * `pub dns_servers: Vec<String>,`
    * `}`

8.  **`IpConfigType` Enum:**
    * `#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]`
    * `pub enum IpConfigType { Dhcp, Manual }`

9.  **`ManualIpConfig` Struct:**
    * `#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]`
    * `pub struct ManualIpConfig {`
        * `pub ip_address: String,`
        * `pub subnet_mask: String,`
        * `pub gateway: String,`
    * `}`

10. **`NetworkConfig` Struct (aus `settings_manager::data_types.rs`):**
    * Sollte hier nur referenziert werden.
    * `pub struct NetworkConfig {`
        * `pub saved_profiles: HashMap<String, NetworkProfile>,` // Profile ID -> NetworkProfile
        * `pub enable_wifi: bool,`
        * `pub enable_ethernet: bool,`
        * `pub primary_dns: Option<String>,`
        * `pub secondary_dns: Option<String>,`
        * `// ...`
    * `}`

**Spezifische Artefakte/Dateien:**

* `novade-system/src/network_manager_service/data_types.rs`

**Abhängigkeiten:**

* **Extern:**
    * `serde::{Serialize, Deserialize}`
    * `std::collections::HashMap`
* **Intern:**
    * `crate::settings_manager::data_types::NetworkConfig` (oder direkter Import)

**Kommunikationsmuster:**

* Diese Typen sind die primäre Darstellung von Netzwerkinformationen im System.
* `NetworkDevice` und `WifiNetwork` Objekte werden vom `NetworkBackend` generiert.
* `NetworkProfile` und `NetworkConfig` werden im `SettingsManagerService` gespeichert und geladen.

**Erwartete Ergebnisse/Outputs:**
Klar definierte und typsichere Datentypen für die Netzwerkverwaltung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests:**
    * Testen der Ableitungen für alle Enums und Structs.
    * Testen der Serialisierung und Deserialisierung von Beispielinstanzen.
    * Überprüfen der Standardwerte und optionalen Felder.
    * Validierung von IP-Adressen und Masken (falls zutreffend).

**Geschätzter Aufwand:** Niedrig (ca. 0.5-1.5 Tage, hauptsächlich Definitionen und leichte Validierung)

---
### **novade-system/src/network_manager_service/network_backend.rs**

**Verantwortlichkeit:**
Das `network_backend` Modul ist die plattformspezifische Abstraktionsschicht für den Zugriff auf Betriebssystem-APIs zur Netzwerkverwaltung. Es ist verantwortlich für die Interaktion mit den Netzwerk-Subsystemen des OS (z.B. NetworkManager/systemd-networkd unter Linux, WinRT/Netsh unter Windows, Network.framework unter macOS), um Netzwerkgeräte zu erkennen, WLAN-Scans durchzuführen, Verbindungen herzustellen/zu trennen und den Netzwerkstatus zu überwachen.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkBackendTrait` Trait (für Abstraktion):**
    * `#[async_trait::async_trait]`
    * `pub trait NetworkBackendTrait: Send + Sync {`
        * `async fn get_network_status(&self) -> Result<NetworkStatus, NetworkManagerError>;`
        * `async fn get_network_devices(&self) -> Result<Vec<NetworkDevice>, NetworkManagerError>;`
        * `async fn get_wifi_networks(&self) -> Result<Vec<WifiNetwork>, NetworkManagerError>;`
        * `async fn scan_wifi_networks(&self) -> Result<(), NetworkManagerError>;`
        * `async fn connect_to_network(&self, request: NetworkConnectionRequest) -> Result<(), NetworkManagerError>;`
        * `async fn disconnect_from_network(&self, device_id: &str) -> Result<(), NetworkManagerError>;`
        * `async fn enable_device(&self, device_id: &str) -> Result<(), NetworkManagerError>;`
        * `async fn disable_device(&self, device_id: &str) -> Result<(), NetworkManagerError>;`
        * `async fn save_network_profile(&self, profile: &NetworkProfile) -> Result<(), NetworkManagerError>;`
        * `async fn delete_network_profile(&self, profile_id: &str) -> Result<(), NetworkManagerError>;`
        * `async fn network_event_stream(&self) -> Pin<Box<dyn Stream<Item = NetworkBackendEvent> + Send>>;`
    * `}`

2.  **Konkrete `NetworkBackend` Implementierungen:**
    * `#[cfg(target_os = "linux")]`
    * `pub struct LinuxNetworkBackend { /* zbus::Connection to NetworkManager, etc. */ }`
    * `#[cfg(target_os = "windows")]`
    * `pub struct WindowsNetworkBackend { /* Windows.Networking.Connectivity APIs, etc. */ }`
    * `#[cfg(target_os = "macos")]`
    * `pub struct MacOSNetworkBackend { /* Network.framework APIs, etc. */ }`

3.  **`new()` Funktion für jede Implementierung:**
    * `pub async fn new() -> Result<Self, NetworkManagerError>`
    * **Logik:**
        * **Plattformspezifisch:**
            * **Linux:** Initialisiert eine D-Bus-Verbindung zu NetworkManager.
            * **Windows:** Initialisiert die COM-Objekte für Netzwerk-APIs (z.B. `Windows.Networking.Connectivity`).
            * **macOS:** Initialisiert die entsprechenden Frameworks.
        * Gibt die konkrete Implementierung zurück.
        * **Fehlerbehandlung:** `PlatformError` bei Problemen mit nativen APIs oder fehlenden Diensten.

4.  **`NetworkBackendEvent` Enum (intern):**
    * `#[derive(Debug, Clone, PartialEq)]`
    * `pub enum NetworkBackendEvent {`
        * `StatusChanged(NetworkStatus, Option<String>),` // (new_status, device_id)
        * `WifiNetworksScanned(Vec<WifiNetwork>),`
        * `DeviceAdded(NetworkDevice),`
        * `DeviceRemoved(String),` // Device ID
        * `Connected(String, String),` // (device_id, network_id/profile_id)
        * `Disconnected(String, String),` // (device_id, network_id/profile_id)
        * `IpAddressChanged(String, String),` // (device_id, new_ip_address)
        * `// ... weitere Events wie z.B. DNS-Änderungen`
    * `}`

**Implementierung der Trait-Methoden (für jede Plattform):**

* **`get_network_status`:** Ruft den globalen Konnektivitätsstatus ab.
* **`get_network_devices`:** Listet alle Netzwerkadapter auf und deren aktuellen Zustand.
* **`get_wifi_networks` / `scan_wifi_networks`:**
    * **Linux:** D-Bus-Aufrufe an NetworkManager (`/org/freedesktop/NetworkManager/AccessPoint`).
    * **Windows:** `Windows.Devices.WiFi` oder `Native Wifi API`.
    * **macOS:** `CoreWLAN` Framework.
* **`connect_to_network`:** Stellt eine Verbindung her, ggf. mit Authentifizierung.
* **`disconnect_from_network`:** Trennt eine aktive Verbindung.
* **`enable_device` / `disable_device`:** Aktiviert/Deaktiviert einen Netzwerkadapter.
* **`save_network_profile` / `delete_network_profile`:** Speichert/Löscht Verbindungsprofile (z.B. WLAN-Passwörter).
* **`network_event_stream`:**
    * **Linux:** D-Bus `PropertiesChanged` Signale vom NetworkManager.
    * **Windows:** `Windows.Networking.Connectivity.NetworkInformation` events.
    * **macOS:** `Network.framework` change notifications.
    * Dies ist ein langlebiger asynchroner Task, der Events in `NetworkBackendEvent` umwandelt und über einen `mpsc::channel` sendet.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/network_manager_service/network_backend.rs`
* `novade-system/src/network_manager_service/linux.rs`
* `novade-system/src/network_manager_service/windows.rs`
* `novade-system/src/network_manager_service/macos.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::network_manager_service::error::NetworkManagerError`
    * `crate::network_manager_service::data_types::{NetworkStatus, NetworkDevice, WifiNetwork, NetworkConnectionRequest, NetworkProfile}`
* **Extern:**
    * `tokio::task::spawn_blocking` (für blockierende FFI-Aufrufe)
    * `futures::stream::Stream`
    * `async_trait`
    * `tracing`
    * `std::sync::Arc`
    * `std::pin::Pin`
    * `tokio::sync::mpsc`
    * **Plattformspezifisch:**
        * `zbus`, `rtnetlink` (Linux)
        * `windows` crate (Windows)
        * `network-framework` (macOS - ggf. FFI-Wrapper)

**Kommunikationsmuster:**

* Bietet die Low-Level-Schnittstelle zu den Netzwerk-Subsystemen des Betriebssystems.
* Sendet Netzwerk-Zustandsänderungen über den `network_event_stream()` an den `NetworkManager`.
* Empfängt Anfragen zur Verbindungsherstellung, -trennung, Geräte-Aktivierung/Deaktivierung und Profilverwaltung vom `NetworkManager`.

**Erwartete Ergebnisse/Outputs:**
Eine stabile, plattformübergreifende Schnittstelle zur Netzwerk-Steuerung und Ereigniserfassung.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking von OS-Netzwerk-APIs):**
    * Mocken aller plattformspezifischen Bibliotheken (z.B. D-Bus-Client für NetworkManager).
    * Simulieren von Netzwerkstatusänderungen, WLAN-Scan-Ergebnissen, Geräte-An-/Abmeldungen und Überprüfen, ob `network_event_stream` die korrekten `NetworkBackendEvent`s liefert.
    * Testen der `get_network_status`, `get_network_devices`, `get_wifi_networks`, `scan_wifi_networks`, `connect_to_network`, `disconnect_from_network`, `save_network_profile`, `delete_network_profile` Methoden mit simulierten OS-Antworten.
    * Testen der Fehlerbehandlung bei fehlgeschlagenen Systemaufrufen.
* **Integration Tests (auf dedizierten Testmaschinen pro OS oder VM):**
    * **Vorsicht:** Diese Tests können die Netzwerkverbindung des Testsystems beeinflussen und sollten nur in isolierten Umgebungen durchgeführt werden.
    * Starten des `NetworkBackend` und Ausführen von WLAN-Scans, Verbindungsaufbau zu Test-APs und Trennung, um die korrekte Funktion zu überprüfen.
    * Physisches Hinzufügen/Entfernen von Netzwerkadaptern (falls möglich) und Überprüfen, ob die Ereignisse im `network_event_stream` korrekt erfasst werden.
    * Überprüfung der IP-Konfiguration nach Verbindungsaufbau.

**Geschätzter Aufwand:** Sehr hoch (ca. 15-20 Tage, da komplexe plattformspezifische Netzwerkschnittstellen, Authentifizierung, Event-Listener und Profilverwaltung)

---
### **novade-system/src/network_manager_service/manager.rs**

**Verantwortlichkeit:**
Der `NetworkManager` ist die Kernlogik des Netzwerkverwaltungssystems. Er orchestriert die Interaktion mit dem plattformspezifischen `NetworkBackend`, verwaltet die Netzwerk-Einstellungen und Profile basierend auf der `NetworkConfig` und löst Events bei Änderungen aus. Er ist auch für die automatische Verbindung zu bevorzugten Netzwerken verantwortlich.

**Kern-Aufgaben (Tasks):**

1.  **`NetworkManager` Struct:**
    * `pub struct NetworkManager {`
        * `config_service: Arc<ConfigService>,`
        * `event_bus: EventBus,`
        * `network_backend: Arc<dyn NetworkBackendTrait + Send + Sync>,`
        * `current_config: RwLock<NetworkConfig>,`
        * `active_connections: RwLock<HashMap<String, String>>,` // device_id -> network_id/profile_id
    * `}`

2.  **`NetworkManager::new()` Funktion:**
    * `pub async fn new(config_service: Arc<ConfigService>, event_bus: EventBus, network_backend: Arc<dyn NetworkBackendTrait + Send + Sync>) -> Result<Self, NetworkManagerError>`
    * **Logik:**
        * Initialisiert alle Felder.
        * Lädt die initiale `NetworkConfig` aus dem `config_service`.
        * Versucht, sich automatisch mit bevorzugten Netzwerken zu verbinden, basierend auf `current_config.saved_profiles` und den aktuell verfügbaren Netzwerken.
        * Gibt `Self` zurück.

3.  **`NetworkManager::handle_backend_event()` Methode (intern, vom Service aufgerufen):**
    * `pub async fn handle_backend_event(&self, event: NetworkBackendEvent)`
    * **Logik:**
        * Verarbeitet `NetworkBackendEvent`s vom `NetworkBackend`.
        * Bei `StatusChanged(status, device_id)`:
            * Aktualisiert den internen Status des Geräts.
            * Sendet `SystemEvent::NetworkStatusChanged(status, device_id)`.
            * Wenn der Status `Connected` ist, aktualisiert `active_connections`. Wenn `Disconnected`, entfernt die Verbindung.
        * Bei `WifiNetworksScanned(networks)`: Sendet `SystemEvent::WifiNetworksUpdated(networks)`.
        * Bei `DeviceAdded(device)`: Fügt das Gerät zur internen Liste hinzu und sendet `SystemEvent::NetworkDeviceAdded(device)`.
        * Bei `DeviceRemoved(device_id)`: Entfernt das Gerät und sendet `SystemEvent::NetworkDeviceRemoved(device_id)`.
        * Bei `Connected(device_id, network_id)`: Aktualisiert `active_connections` und sendet `SystemEvent::NetworkConnected(device_id, network_id)`.
        * Bei `Disconnected(device_id, network_id)`: Entfernt aus `active_connections` und sendet `SystemEvent::NetworkDisconnected(device_id, network_id)`.
        * Bei `IpAddressChanged(device_id, ip_address)`: Sendet `SystemEvent::IpAddressChanged(device_id, ip_address)`.

4.  **`NetworkManager::get_network_status()` Methode:**
    * `pub async fn get_network_status(&self) -> Result<NetworkStatus, NetworkManagerError>`
    * **Logik:** Delegiert an `self.network_backend.get_network_status()`.

5.  **`NetworkManager::get_network_devices()` Methode:**
    * `pub async fn get_network_devices(&self) -> Result<Vec<NetworkDevice>, NetworkManagerError>`
    * **Logik:** Delegiert an `self.network_backend.get_network_devices()`.

6.  **`NetworkManager::get_wifi_networks()` Methode:**
    * `pub async fn get_wifi_networks(&self) -> Result<Vec<WifiNetwork>, NetworkManagerError>`
    * **Logik:** Delegiert an `self.network_backend.get_wifi_networks()`.

7.  **`NetworkManager::scan_wifi_networks()` Methode:**
    * `pub async fn scan_wifi_networks(&self) -> Result<(), NetworkManagerError>`
    * **Logik:** Delegiert an `self.network_backend.scan_wifi_networks()`.

8.  **`NetworkManager::connect_to_network()` Methode:**
    * `pub async fn connect_to_network(&self, request: NetworkConnectionRequest) -> Result<(), NetworkManagerError>`
    * **Logik:**
        * Wenn `request.save_profile` wahr ist: Speichert das Profil über `self.save_network_profile()`.
        * Delegiert die Verbindungsanfrage an `self.network_backend.connect_to_network(&request)`.
        * Bei Erfolg: Aktualisiert `active_connections` und speichert die Konfiguration.

9.  **`NetworkManager::disconnect_from_network()` Methode:**
    * `pub async fn disconnect_from_network(&self, device_id: &str) -> Result<(), NetworkManagerError>`
    * **Logik:**
        * Delegiert an `self.network_backend.disconnect_from_network(device_id)`.
        * Bei Erfolg: Entfernt die Verbindung aus `active_connections` und speichert die Konfiguration.

10. **`NetworkManager::save_network_profile()` Methode:**
    * `pub async fn save_network_profile(&self, profile: NetworkProfile) -> Result<(), NetworkManagerError>`
    * **Logik:**
        * Fügt das `profile` zu `current_config.saved_profiles` hinzu.
        * Speichert die aktualisierte Konfiguration über den `config_service`.
        * Delegiert an `self.network_backend.save_network_profile(&profile)`.

11. **`NetworkManager::delete_network_profile()` Methode:**
    * `pub async fn delete_network_profile(&self, profile_id: &str) -> Result<(), NetworkManagerError>`
    * **Logik:**
        * Entfernt das Profil aus `current_config.saved_profiles`.
        * Speichert die aktualisierte Konfiguration über den `config_service`.
        * Delegiert an `self.network_backend.delete_network_profile(profile_id)`.

12. **`NetworkManager::update_config()` Methode (intern, vom Service aufgerufen bei `SystemEvent::ConfigChanged`):**
    * `pub async fn update_config(&self, new_config: NetworkConfig)`
    * **Logik:**
        * Aktualisiert die interne `current_config`.
        * Vergleicht `new_config.enable_wifi` und `new_config.enable_ethernet` und aktiviert/deaktiviert Geräte über das Backend.
        * Wendet Änderungen an den DNS-Servern über das Backend an.
        * Löst gegebenenfalls automatische Verbindungsversuche aus, wenn neue Profile hinzugefügt oder Prioritäten geändert wurden.

13. **`NetworkManager::auto_connect_to_preferred_network()` Methode (intern, Task):**
    * `async fn auto_connect_to_preferred_network(self: Arc<Self>)`
    * **Logik:**
        * Periodisch (z.B. alle 30 Sekunden bei Nicht-Verbindung) scannt verfügbare WLAN-Netzwerke.
        * Vergleicht diese mit den gespeicherten Profilen in `current_config.saved_profiles` (Priorität berücksichtigen).
        * Wenn ein bevorzugtes Netzwerk verfügbar ist und keine Verbindung besteht, initiiert einen Verbindungsversuch über `connect_to_network()`.
        * Wird auch durch `NetworkBackendEvent::WifiNetworksScanned` oder `NetworkDeviceAdded` getriggert.

**Spezifische Artefakte/Dateien:**

* `novade-system/src/network_manager_service/manager.rs`

**Abhängigkeiten:**

* **Intern:**
    * `crate::network_manager_service::error::NetworkManagerError`
    * `crate::network_manager_service::data_types::{NetworkStatus, NetworkDevice, WifiNetwork, NetworkConnectionRequest, NetworkProfile, NetworkConfig}`
    * `crate::network_manager_service::network_backend::{NetworkBackendTrait, NetworkBackendEvent}`
    * `crate::config_service::ConfigService`
    * `novade_core::event_bus::EventBus`
    * `novade_core::system_events::SystemEvent`
* **Extern:**
    * `tokio::sync::RwLock`
    * `tokio::time`
    * `std::sync::Arc`
    * `std::collections::HashMap`
    * `tracing`
    * `async_trait`

**Kommunikationsmuster:**

* Ist die zentrale Logik für die Netzwerkverwaltung.
* Empfängt Netzwerk-Zustandsänderungen vom `NetworkBackend` und übersetzt sie in `SystemEvent`s.
* Delegiert alle OS-spezifischen Aktionen (Verbinden, Trennen, Scannen, Geräte-Aktivierung, Profil-Management) an das `NetworkBackend`.
* Interagiert mit `ConfigService` für Konfiguration und Speicherung.
* Sendet verschiedene `SystemEvent`s an den `EventBus`, um Systemzustandsänderungen zu signalisieren.
* Empfängt `SystemEvent::ConfigChanged` zur Aktualisierung der eigenen Einstellungen.

**Erwartete Ergebnisse/Outputs:**
Ein robuster Network Manager, der den System-Netzwerkzustand überwacht, auf Änderungen reagiert, Netzwerk-Aktionen steuert und automatische Verbindungsversuche zu bevorzugten Netzwerken verwaltet.

**Teststrategie (Modul-spezifisch):**

* **Unit Tests (mit Mocking):**
    * Mocken des `ConfigService`, `EventBus` und `NetworkBackend`.
    * Testen von `new` und dem Laden/Anwenden der initialen Konfiguration sowie dem initialen Auto-Connect-Versuch.
    * Testen von `handle_backend_event`: Simulieren verschiedener `NetworkBackendEvent`s und Überprüfen, ob die interne `NetworkConfig` und `active_connections` korrekt aktualisiert und die entsprechenden `SystemEvent`s gesendet werden.
    * Testen von `get_network_status`, `get_network_devices`, `get_wifi_networks`, `scan_wifi_networks` durch Überprüfen der korrekten Delegierung an den Mock-`NetworkBackend`.
    * Testen von `connect_to_network`, `disconnect_from_network`, `save_network_profile`, `delete_network_profile`: Überprüfen der korrekten Delegierung an den Mock-`NetworkBackend`, der Aktualisierung der internen Zustände (`current_config`, `active_connections`) und des `ConfigService`, sowie der Event-Sendung.
    * Testen von `update_config` und der korrekten Anwendung neuer Einstellungen auf das Backend und der Auslösung von Auto-Connect.
    * **Auto-Connect-Task Tests:** Mocken der Scan-Ergebnisse und des Profilspeichers, um zu überprüfen, ob der Manager versucht, sich mit dem richtigen bevorzugten Netzwerk zu verbinden.
* **Integration Tests:**
    * Starten des `NetworkManager` mit einem realen (oder auf einer VM kontrollierten) `NetworkBackend`.
    * Automatisierte Tests, die WLAN-Scans, Verbindungsaufbau, -trennung und Profilverwaltung durchführen und die Reaktionen des Managers (z.B. über den `EventBus`) überprüfen.
    * Testen des Auto-Connect-Features in einer Testumgebung mit mehreren WLANs und vordefinierten Profilen.
    * Überprüfung der End-to-End-Funktionalität des Netzwerk-Managements.

**Geschätzter Aufwand:** Sehr hoch (ca. 12-18 Tage, da komplexe Zustandsverwaltung, Event-Verarbeitung, Interaktion mit dem plattformspezifischen Backend und Implementierung von intelligenten Verbindungslogiken)

---
**Priorisierung der Systemschicht Module (Fortsetzung):**

Nach `display_manager_service`, widmen wir uns `network_manager_service`. Hier ist die vorgeschlagene Reihenfolge:

1.  **`novade-system/src/network_manager_service/error.rs`**: Fehlerdefinitionen zuerst.
2.  **`novade-system/src/network_manager_service/data_types.rs`**: Definition der Datentypen für Netzwerkgeräte, Verbindungen, Profile und Konfigurationen.
3.  **`novade-system/src/network_manager_service/network_backend.rs`**: Implementierung der plattformspezifischen Schnittstelle für Netzwerk-Steuerung und Ereignisse. Dies ist die Basis.
4.  **`novade-system/src/network_manager_service/manager.rs`**: Die Kernlogik für die Netzwerkverwaltung, die das `NetworkBackend` orchestriert, Netzwerk-Einstellungen, Profile, automatische Verbindungen und Ereignisse verarbeitet.
5.  **`novade-system/src/network_manager_service/mod.rs`**: Das Hauptmodul, das den Manager und seine Sub-Komponenten initialisiert und die öffentliche API bereitstellt.

Dies vervollständigt die detaillierte Spezifikation des `novade-system/src/network_manager_service` Verzeichnisses. Der nächste Schritt wäre die Dekomposition des `novade-system/src/bluetooth_manager_service` Verzeichnisses.