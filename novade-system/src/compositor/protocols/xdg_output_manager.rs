// novade-system/src/compositor/protocols/xdg_output_manager.rs
// Implementation of the zxdg_output_manager_v1 Wayland protocol

use smithay::{
    delegate_xdg_output, // Smithay's delegate macro for this protocol
    reexports::{
        wayland_protocols::xdg::xdg_output::zv1::server::{
            zxdg_output_manager_v1::{self, ZxdgOutputManagerV1, Request as ManagerRequest, Event as ManagerEvent},
            zxdg_output_v1::{self, ZxdgOutputV1, Request as XdgOutputRequest, Event as XdgOutputEvent},
        },
        wayland_server::{
            protocol::wl_output, // This protocol extends wl_output functionality
            Client, DisplayHandle, GlobalDispatch, Dispatch, Resource, UserData,
        },
        calloop::LoopHandle,
    },
    utils::{Serial, Logical, Physical, Point, Size, Transform}, // For geometry and output properties
    wayland::output::{Output, OutputHandler, OutputManagerState, Mode, Scale}, // Smithay's Output and related types
    // If we need to access Window information to determine which output a window is on:
    // desktop::{Window, Space},
};
use std::sync::{Arc, Mutex};
use thiserror::Error;
use tracing::{info, warn, error, debug};

// Placeholder for DesktopState or the main compositor state (e.g., NovaCompositorState)
// This state will need to hold `OutputManagerState` and provide access to `Output` instances.
#[derive(Debug, Default)]
pub struct DesktopState {
    // This is the same placeholder.
    // For XDG Output Manager, it would need to manage or access:
    // - OutputManagerState (from smithay::wayland::output)
    // - The list of all active Smithay `Output` objects.
    // - Detailed properties of each output (name, description, logical/physical size, position, scale).
}

#[derive(Debug, Error)]
pub enum XdgOutputManagerError {
    #[error("Output not found or wl_output is not valid")]
    OutputNotFound,
    #[error("XDG Output object already exists for this wl_output")]
    XdgOutputExists,
}

// UserData for ZxdgOutputV1 resource.
// This might store a reference to the Smithay `Output` it corresponds to,
// or simply be unit if all info is retrieved via the wl_output.
#[derive(Debug, Clone)]
pub struct XdgOutputUserData {
    pub wl_output: wl_output::WlOutput, // The underlying wl_output this xdg_output is for
}


// The main compositor state (e.g., NovaCompositorState) would implement OutputHandler (for wl_output)
// and potentially parts of the dispatch for zxdg_output_manager_v1.
// Smithay's `delegate_xdg_output` macro handles much of the boilerplate for associating
// ZxdgOutputV1 with an existing wl_output and its Smithay `Output` representation.
//
// Example (conceptual, actual delegation is more nuanced):
// pub struct NovaCompositorState {
//     ...
//     pub output_manager_state: OutputManagerState, // Manages Smithay `Output`s
//     // Smithay's xdg-output handling doesn't require a specific *manager* state struct like xdg-shell.
//     // The `delegate_xdg_output` macro works with your main compositor state `D`
//     // and expects `D` to implement `OutputHandler` (for wl_output) and `Dispatch` for the xdg-output objects.
//     ...
// }
//
// // D (NovaCompositorState) needs to implement OutputHandler for wl_output
// impl OutputHandler for NovaCompositorState {
//     fn output_state(&mut self) -> &mut OutputManagerState {
//         &mut self.output_manager_state
//     }
//     // ... other OutputHandler methods ...
// }
//
// // And Dispatch for ZxdgOutputManagerV1 and ZxdgOutputV1
// delegate_xdg_output!(NovaCompositorState);


// No specific XdgOutputManagerHandler trait from Smithay.
// The logic is embedded in the Dispatch implementations generated by `delegate_xdg_output`.
// We need to ensure our main state `D` can provide `OutputManagerState` and handle `wl_output`s.

/// Call this function when an `Output`'s properties change (position, size, name, description).
/// It will find the associated `ZxdgOutputV1` object (if any) and send updated events.
///
/// - `output`: The Smithay `Output` object whose properties have changed.
///
/// `D` is your main compositor state.
pub fn on_output_changed<D>(
    _compositor_state: &mut D, // Your main compositor state, might be needed if XdgOutputV1 user_data needs update
    output: &Output,        // The Smithay Output that changed
) where
    D: 'static, // Constraints on D depend on how ZxdgOutputV1 state is managed.
                // If ZxdgOutputV1 user data needs access to D, it's more complex.
                // Smithay's `delegate_xdg_output` handles sending updates automatically
                // when the underlying `Output`'s properties change, provided the
                // `ZxdgOutputV1` resource is correctly associated (which the delegate does).
{
    info!("Output {:?} changed. Notifying associated ZxdgOutputV1 clients.", output.name());

    // Smithay's `Output::user_data()` can store `XdgOutputUserData` (or similar)
    // which holds the `ZxdgOutputV1` resource.
    // However, `delegate_xdg_output` works by associating the `ZxdgOutputV1` resource
    // directly with the `wl_output` it's created for.
    // When `Output::set_name`, `Output::set_description`, `Output::set_logical_position`,
    // `Output::set_logical_size` are called on the Smithay `Output`, the delegate mechanism
    // should automatically find any `ZxdgOutputV1` associated with that `Output`'s `wl_output`
    // and send the appropriate `logical_position`, `logical_size`, `name`, `description` events.

    // Therefore, this explicit `on_output_changed` function might only be needed if:
    // 1. We are not using `delegate_xdg_output` and are manually managing ZxdgOutputV1. (Unlikely)
    // 2. Some properties change that the delegate doesn't automatically pick up. (Also unlikely for standard ones)
    // 3. We need to trigger additional logic in the compositor beyond just sending protocol events.

    // Let's assume `delegate_xdg_output` handles this.
    // If we needed to do it manually, it would look something like:
    /*
    if let Some(xdg_output_resource) = find_xdg_output_for_smithay_output(output) { // Hypothetical lookup
        let (x, y) = output.logical_position().unwrap_or_default().into();
        xdg_output_resource.logical_position(x, y);

        let (w, h) = output.logical_size().unwrap_or_default().into();
        xdg_output_resource.logical_size(w, h);

        if let Some(name) = output.name_clone() {
            xdg_output_resource.name(name);
        }
        if let Some(description) = output.description_clone() {
            xdg_output_resource.description(description);
        }
        // ... and potentially send `done()` if it's a new batch of changes.
        // Smithay's Output changes usually trigger individual events.
        // `zxdg_output_v1.done()` is sent after all initial state or a batch of updates.
    }
    */
    debug!(
        "Relying on delegate_xdg_output to send updates for Output {:?}",
        output.name()
    );
}


/// Initializes and registers the ZxdgOutputManagerV1 global.
/// `D` is your main compositor state type.
pub fn init_xdg_output_manager<D>(
    display: &DisplayHandle,
    // loop_handle: LoopHandle<'static, D>, // If needed
) -> Result<(), Box<dyn std::error::Error>>
where
    D: GlobalDispatch<ZxdgOutputManagerV1, ()> +
       Dispatch<ZxdgOutputManagerV1, (), D> +
       Dispatch<ZxdgOutputV1, XdgOutputUserData, D> + // UserData for ZxdgOutputV1
       OutputHandler + // D must implement OutputHandler for wl_output management
       'static,
       // D must also own OutputManagerState.
{
    info!("Initializing ZxdgOutputManagerV1 global (xdg-output-unstable-v1)");

    // The ZxdgOutputManagerV1 global itself is fairly simple.
    // Its main purpose is to allow clients to get an ZxdgOutputV1 object for a given wl_output.
    display.create_global::<D, ZxdgOutputManagerV1, _>(
        3, // protocol version of xdg-output-unstable-v1 is 3
        () // GlobalData for the manager (unit)
    )?;

    // Ensure `delegate_xdg_output!(D)` is called in your main compositor state setup.
    // This macro handles:
    // - Dispatching ZxdgOutputManagerV1 requests (specifically `get_xdg_output`).
    //   When `get_xdg_output(id, wl_output_resource)` is called:
    //     - It creates the `ZxdgOutputV1` resource (`id`).
    //     - It associates this `ZxdgOutputV1` resource with the provided `wl_output_resource`.
    //     - It populates the `ZxdgOutputV1` with initial state (name, description, position, size)
    //       by querying the Smithay `Output` corresponding to `wl_output_resource`.
    //       This requires `D` to implement `OutputHandler` to find the Smithay `Output`.
    //     - It sends `logical_position`, `logical_size`, `name`, `description`, and then `done()`.
    // - Dispatching ZxdgOutputV1 requests (destroy).
    // - Automatically sending ZxdgOutputV1 events when properties of the underlying Smithay `Output` change.

    info!("ZxdgOutputManagerV1 global initialized.");
    Ok(())
}

// TODO:
// - Output Management Core Logic:
//   - The compositor must have robust management of its `smithay::wayland::output::Output` objects.
//     This includes detecting connected outputs (e.g., via DRM backend), configuring their modes,
//     positions (layout), scales, and transforms.
//   - When these properties are set or changed on a Smithay `Output` object (e.g., `Output::set_logical_position`),
//     the `delegate_xdg_output` mechanism should automatically propagate these changes to any
//     `ZxdgOutputV1` client objects associated with that output.
// - Accurate Output Properties:
//   - Ensure that the name, description, logical position, and logical size reported by `ZxdgOutputV1`
//     accurately reflect the state of the corresponding Smithay `Output` and the physical display.
//     - Logical position/size depends on the compositor's layout of outputs in the global space.
//     - Name and description should be meaningful (e.g., from EDID or backend).
// - State Integration:
//   - `OutputManagerState` (managing Smithay `Output`s) must be part of `NovaCompositorState`.
//   - `NovaCompositorState` must implement `OutputHandler`.
//   - `delegate_xdg_output!(NovaCompositorState);` macro must be used.
// - "Done" Events:
//   - Ensure `zxdg_output_v1.done()` events are sent correctly after the initial burst of state
//     when an `ZxdgOutputV1` is created, and after any subsequent batch of changes (if applicable,
//     though individual property changes usually trigger individual events followed by `done` implicitly
//     by the delegate if it batches, or just individual events). Smithay's delegate handles this.
// - Testing:
//   - Use clients that utilize `zxdg_output_manager_v1` to query output information (e.g., some
//     panels, window managers, or tools like `wlr-randr` or `wayland-info`).
//   - Verify that clients receive correct and up-to-date information when outputs are added/removed
//     or their configurations (position, size, scale affecting logical size) change.
//   - Test with multi-monitor setups in various layouts (e.g., side-by-side, stacked).

// Ensure this module is declared in `novade-system/src/compositor/protocols/mod.rs`
// pub mod xdg_output_manager;
