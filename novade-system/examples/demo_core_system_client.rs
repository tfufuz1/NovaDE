// ANCHOR: Header
//! # NovaDE CoreSystem D-Bus Client Demo
//!
//! This example demonstrates how to interact with the `org.novade.CoreSystem` D-Bus service.
//! It showcases:
//!   - Connecting to the session D-Bus.
//!   - Creating a proxy for the `CoreSystemInterface`.
//!   - Calling methods like `ping`, `register_component`, `query_component_status`, etc.
//!   - Listening for signals like `ComponentRegistered`.
//!
//! # Prerequisites
//!
//! To run this example, the `CoreSystemService` must be running and available on the
//! session D-Bus under the name `org.novade.CoreSystem` at the path `/org/novade/CoreSystem`.
//!
//! You can typically run the service using another example or by integrating it into
//! the main NovaDE application startup. For instance, an example service runner might be:
//!
//! ```no_run
//! // (in a separate example file, e.g., run_core_system_service.rs)
//! use novade_system::dbus_integration::DbusServiceManager;
//! use std::sync::Arc;
//! use anyhow::Result;
//!
//! #[tokio::main]
//! async fn main() -> Result<()> {
//!     // Setup tracing/logging
//!     let subscriber = tracing_subscriber::FmtSubscriber::builder()
//!         .with_max_level(tracing::Level::INFO)
//!         .finish();
//!     tracing::subscriber::set_global_default(subscriber)?;
//!
//!     tracing::info!("Starting CoreSystem D-Bus Service example runner...");
//!     let dbus_manager = Arc::new(DbusServiceManager::new_session().await?);
//!     dbus_manager.serve_core_system_service().await?;
//!     tracing::info!("CoreSystem D-Bus Service is up and running. Press Ctrl+C to exit.");
//!
//!     // Keep the service running until interrupted
//!     tokio::signal::ctrl_c().await?;
//!     tracing::info!("Shutting down CoreSystem D-Bus Service.");
//!     Ok(())
//! }
//! ```

// ANCHOR: Crates
use anyhow::{Context, Result};
use futures_util::stream::StreamExt;
use novade_system::dbus_interfaces::core_system_interface::{
    ComponentInfo, ComponentStatus, CoreSystemInterfaceProxy, // Use the generated proxy
};
use std::collections::HashMap;
use std::time::Duration;
use zbus::{Connection, ProxyDefault};
use zbus::zvariant::OwnedObjectPath;

// ANCHOR: MainFunction
#[tokio::main]
async fn main() -> Result<()> {
    // Setup tracing/logging (optional, but good for examples)
    let subscriber = tracing_subscriber::FmtSubscriber::builder()
        .with_max_level(tracing::Level::INFO)
        .finish();
    tracing::subscriber::set_global_default(subscriber)
        .context("Failed to set global default tracing subscriber")?;

    tracing::info!("Starting CoreSystem D-Bus client demo...");

    // ANCHOR: ConnectToSessionBus
    let connection = Connection::session().await
        .context("Failed to connect to the D-Bus session bus")?;
    tracing::info!("Connected to D-Bus session bus: {}", connection.unique_name().map_or_else(|| String::from("<unknown>"), |n| n.to_string()));

    // ANCHOR: CreateProxy
    // Create a proxy for the CoreSystem service.
    // The `CoreSystemInterfaceProxy` is generated by `zbus::dbus_proxy` if the trait is in scope
    // and the necessary zbus features are enabled.
    // We must ensure `novade_system::dbus_interfaces::core_system_interface::CoreSystemInterface`
    // is accessible and correctly defined for proxy generation to work.
    // If `CoreSystemInterfaceProxy` is not found, it means it's not generated.
    // This usually happens if the trait is not correctly defined or if the macro is not working as expected.
    // For this example, we assume `CoreSystemInterfaceProxy` is correctly generated by zbus.
    let proxy = CoreSystemInterfaceProxy::builder(&connection)
        .destination("org.novade.CoreSystem")?
        .path("/org/novade/CoreSystem")?
        .build()
        .await
        .context("Failed to build CoreSystemInterface proxy. Is the service running?")?;

    tracing::info!("Successfully created D-Bus proxy for org.novade.CoreSystem");

    // ANCHOR: CallPing
    tracing::info!("Calling Ping method...");
    let ping_response = proxy.ping("Hello from Client Demo".to_string()).await?;
    tracing::info!("Ping response: {}", ping_response);

    // ANCHOR: CallGetServiceVersion
    tracing::info!("Calling ServiceVersion property...");
    let version = proxy.service_version().await?;
    tracing::info!("Service version: {}", version);

    // ANCHOR: ListenForComponentRegisteredSignal
    tracing::info!("Listening for ComponentRegistered signals for 10 seconds...");
    let mut signal_stream = proxy.receive_component_registered().await?;

    // Spawn a task to register a component after a short delay
    // This is to ensure the signal listener is active when the signal is emitted.
    let register_proxy = proxy.clone();
    tokio::spawn(async move {
        tokio::time::sleep(Duration::from_secs(1)).await;
        tracing::info!("(Async Task) Attempting to register a demo component...");
        let mut metadata = HashMap::new();
        metadata.insert("version".to_string(), "0.1.0-demo".to_string());
        metadata.insert("author".to_string(), "ClientDemo".to_string());

        let object_path_str = "/org/novade/DemoComponent";
        let owned_path = OwnedObjectPath::try_from(object_path_str)
            .expect("Failed to create valid OwnedObjectPath for demo component");

        match register_proxy.register_component(
            "org.novade.DemoComponent".to_string(),
            owned_path,
            ComponentStatus::Active,
            metadata,
        ).await {
            Ok(success) => tracing::info!("(Async Task) Demo component registration successful: {}", success),
            Err(e) => tracing::error!("(Async Task) Demo component registration failed: {}", e),
        }
    });

    // ANCHOR: HandleSignals
    // Listen for signals for a limited time
    let signal_timeout = tokio::time::timeout(Duration::from_secs(10), signal_stream.next()).await;

    match signal_timeout {
        Ok(Some(signal_args)) => {
            // The actual type of `signal_args` depends on how zbus delivers signal arguments.
            // It's often a struct generated by `#[dbus_interface(signal_args)]` or a tuple.
            // Assuming ComponentInfo is the direct argument type based on trait definition:
            let component_info: ComponentInfo = signal_args.args().await?.get().expect("Signal args structure error");
            tracing::info!(
                "Received ComponentRegistered signal for component: {}, path: {}, status: {:?}",
                component_info.name,
                component_info.object_path,
                component_info.status
            );
        }
        Ok(None) => {
            tracing::info!("Signal stream ended before receiving a ComponentRegistered signal.");
        }
        Err(_) => { // Timeout
            tracing::info!("No ComponentRegistered signal received within 10 seconds.");
        }
    }

    // ANCHOR: CallListComponents
    tracing::info!("Calling ListComponents method...");
    let components = proxy.list_components().await?;
    tracing::info!("Currently registered components ({}):", components.len());
    for comp in components {
        tracing::info!(
            "  - Name: {}, Path: {}, Status: {:?}, Metadata: {:?}",
            comp.name,
            comp.object_path,
            comp.status,
            comp.metadata
        );
    }

    // ANCHOR: CallQueryComponentStatus (for the component registered by the async task)
    tracing::info!("Querying status for 'org.novade.DemoComponent'...");
    match proxy.query_component_status("org.novade.DemoComponent".to_string()).await {
        Ok(status) => tracing::info!("Status of 'org.novade.DemoComponent': {:?}", status),
        Err(e) => tracing::error!("Failed to query status for 'org.novade.DemoComponent': {}", e),
    }

    // ANCHOR: CallUnregisterComponent (for the component registered by the async task)
    tracing::info!("Attempting to unregister 'org.novade.DemoComponent'...");
    match proxy.unregister_component("org.novade.DemoComponent".to_string()).await {
        Ok(success) => tracing::info!("Unregistration of 'org.novade.DemoComponent' successful: {}", success),
        Err(e) => tracing::error!("Failed to unregister 'org.novade.DemoComponent': {}", e),
    }

    // ANCHOR: CallListComponentsAgain
    tracing::info!("Calling ListComponents method again after unregistration...");
    let components_after = proxy.list_components().await?;
    tracing::info!("Currently registered components ({}):", components_after.len());
    for comp in components_after {
        tracing::info!(
            "  - Name: {}, Path: {}, Status: {:?}, Metadata: {:?}",
            comp.name,
            comp.object_path,
            comp.status,
            comp.metadata
        );
    }

    tracing::info!("CoreSystem D-Bus client demo finished successfully.");
    Ok(())
}
