//! Winit backend for the NovaDE compositor.
//!
//! This module provides a backend that runs the compositor within a Winit window,
//! primarily for development and testing. It uses `softbuffer` for CPU-based
//! rendering into the Winit window, allowing the compositor to be displayed
//! on an existing desktop environment.
//!
//! ## How it Works (Conceptual)
//!
//! -   `WinitBackendData` initializes a Winit window, a `softbuffer` graphics context
//!     for that window, and Smithay's `WinitInputBackend` to process Winit input events.
//! -   The Winit event loop (which would typically run on the main thread or a dedicated
//!     backend thread) captures Winit events (`winit::event::Event`).
//! -   `WinitBackendData::handle_winit_event` processes these raw Winit events:
//!     -   Input events are converted by `WinitInputBackend` into Smithay's generic
//!         `InputEvent`s and sent to the main compositor event loop (Calloop) via a channel.
//!     -   Window events like resize or scale factor changes update the `softbuffer` surface
//!         and the compositor's `Output` state. These changes are also signaled to Calloop.
//!     -   Redraw requests trigger a `WinitBackendEvent::Refresh` to Calloop.
//!     -   Close requests signal Calloop to terminate.
//! -   When the Calloop loop determines a refresh is needed (e.g., due to `WinitBackendEvent::Refresh`
//!     or client activity), it would (conceptually) call `WinitBackendData::render`.
//! -   `WinitBackendData::render` uses the `SimpleSoftwareRenderer` (from `crate::compositor::render`)
//!     to draw the current scene (from `NovaCompositorState.space`) onto the `softbuffer`'s pixel buffer,
//!     which is then presented to the Winit window.
//!
//! **Note:** The actual Winit event loop execution and its integration with Calloop
//! (e.g., running Winit on a separate thread and using its proxy, or using `calloop-winit`)
//! is complex and managed outside this file, typically in `core.rs` or `main.rs`. This
//! file defines the Winit-specific data structures and event handling logic.

#![allow(unused_variables)]
#![allow(dead_code)]

use crate::compositor::render::SimpleSoftwareRenderer;
use crate::compositor::state::NovaCompositorState;

use smithay::{
    backend::{
        input::{InputEvent, KeyboardKeyEvent, PointerAxisEvent, PointerButtonEvent, PointerMotionEvent},
        renderer::software::SoftwareRenderer,
        winit::{self as smithay_winit, WinitEvent, WinitEventLoop, WinitGraphicsBackend, WinitInputBackend},
    },
    desktop::Space,
    output::{Mode, Output, PhysicalProperties, Scale, Transform},
    reexports::{
        calloop::{channel::Channel, EventLoop as CalloopEventLoop, PostAction},
        winit::{
            dpi::{LogicalSize, PhysicalPosition, PhysicalSize},
            event::{Event, WindowEvent},
            event_loop::{ControlFlow, EventLoop, EventLoopBuilder, EventLoopProxy},
            platform::run_return::EventLoopExtRunReturn,
            window::{Window as WinitWindow, WindowBuilder},
        },
    },
    utils::{Point, Rectangle, SERIAL_COUNTER},
};

use softbuffer::{Context as SoftBufferContext, Surface as SoftBufferSurface}; // Renamed for clarity
use std::{cell::RefCell, rc::Rc, time::Duration};

const OUTPUT_NAME: &str = "winit"; // Default name for the Output representing the Winit window.

/// Events generated by the Winit backend and sent to the main compositor event loop (Calloop).
#[derive(Debug)]
pub enum WinitBackendEvent {
    /// An input event processed by `WinitInputBackend`.
    Input(InputEvent<smithay_winit::WinitInput>),
    /// The Winit window was resized.
    Resized {
        new_size: PhysicalSize<u32>,
        new_scale_factor: f64,
    },
    /// The Winit window's content needs to be redrawn.
    Refresh,
    /// The Winit window received a request to close (e.g., user clicked the close button).
    CloseRequested,
}

/// Encapsulates all data structures required for the Winit backend.
///
/// This includes the Winit window itself, the `softbuffer` context and surface for rendering,
/// Smithay's `WinitInputBackend` for input processing, and the `SimpleSoftwareRenderer`
/// for drawing the compositor's scene.
pub struct WinitBackendData {
    /// The Winit window instance.
    window: WinitWindow,
    /// The `softbuffer` graphics context associated with the window.
    graphics_context: SoftBufferContext,
    /// The `softbuffer` surface used for drawing pixel data into the window.
    surface: SoftBufferSurface,
    /// Smithay's helper for processing Winit input events into a generic format.
    input_backend: WinitInputBackend,
    /// The software renderer used to draw client surfaces.
    renderer: SimpleSoftwareRenderer,
    /// Current physical size of the Winit window.
    size: PhysicalSize<u32>,
    /// Current scale factor of the Winit window.
    scale_factor: f64,
    /// Logger instance for this backend.
    logger: slog::Logger,
}

impl WinitBackendData {
    /// Creates a new `WinitBackendData` instance.
    ///
    /// This involves:
    /// - Creating a Winit window.
    /// - Initializing `softbuffer` by creating a `Context` and `Surface` for the window.
    /// - Initializing `WinitInputBackend` for input processing.
    /// - Initializing `SimpleSoftwareRenderer`.
    ///
    /// # Arguments
    ///
    /// * `event_loop`: The Winit `EventLoop` to which the window will be associated.
    /// * `logger`: A `slog::Logger` for logging.
    ///
    /// # Returns
    ///
    /// * `Ok(Self)` if initialization is successful.
    /// * `Err(String)` if any part of the initialization fails (e.g., window creation, softbuffer setup).
    pub fn new(event_loop: &EventLoop<()>, logger: slog::Logger) -> Result<Self, String> {
        let window = WindowBuilder::new()
            .with_title("NovaDE (Winit)")
            .with_inner_size(LogicalSize::new(1024.0, 768.0)) // Default window size
            .build(event_loop)
            .map_err(|e| format!("Failed to create winit window: {}", e))?;

        let size = window.inner_size();
        let scale_factor = window.scale_factor();

        // Safety: The window handle must be valid and remain valid for the lifetime of Context/Surface.
        // This is generally true if WinitBackendData owns the window.
        let graphics_context = unsafe { SoftBufferContext::new(&window) }
            .map_err(|e| format!("Failed to create softbuffer context: {}", e))?;
        let mut surface = unsafe { SoftBufferSurface::new(&graphics_context, &window) }
            .map_err(|e| format!("Failed to create softbuffer surface: {}", e))?;

        surface
            .resize(
                size.width.try_into().expect("Window width is zero or too large for u16"),
                size.height.try_into().expect("Window height is zero or too large for u16"),
            )
            .map_err(|e| format!("Failed to resize softbuffer surface: {}", e))?;

        let input_backend = WinitInputBackend::new(logger.clone())
            .map_err(|e| format!("Failed to create winit input backend: {}", e))?; // Smithay 0.3 requires logger

        let renderer = SimpleSoftwareRenderer::new(logger.clone());
        // Inform the renderer about the initial size and scale.
        // renderer.resize((size.width as i32, size.height as i32), scale_factor); // If renderer uses this

        slog::info!(
            logger,
            "Winit backend initialized with size {:?}, scale factor {}",
            size,
            scale_factor
        );

        Ok(Self {
            window,
            graphics_context,
            surface,
            input_backend,
            renderer,
            size,
            scale_factor,
            logger,
        })
    }

    /// Handles a raw Winit event, processes it, and sends corresponding `WinitBackendEvent`s
    /// to the main compositor loop via the provided channel sender.
    ///
    /// This method should be called from the Winit event loop for each received event.
    ///
    /// # Arguments
    ///
    /// * `event`: The raw `winit::event::Event` to process.
    /// * `compositor_state`: A mutable reference to `NovaCompositorState` to update
    ///   things like the `Output`'s mode or scale.
    /// * `backend_event_sender`: A `calloop::channel::ChannelSender` to send
    ///   processed `WinitBackendEvent`s to the main Calloop event loop.
    ///
    /// # Returns
    ///
    /// * `ControlFlow`: Winit's `ControlFlow` enum, typically `ControlFlow::Poll` or
    ///   `ControlFlow::Exit` if a close request was handled.
    pub fn handle_winit_event(
        &mut self,
        event: &Event<()>,
        compositor_state: &mut NovaCompositorState,
        backend_event_sender: &Channel<WinitBackendEvent>,
    ) -> ControlFlow {
        let mut control_flow = ControlFlow::Poll;

        if let Some(winit_event) = smithay_winit::WinitEvent::from_raw(event, &self.window) {
            match winit_event {
                WinitEvent::Input(event) => {
                    self.input_backend.on_input_event(event, |smithay_input_event| {
                        if let Err(e) = backend_event_sender.send(WinitBackendEvent::Input(smithay_input_event)) {
                            slog::error!(self.logger, "Error sending input event from Winit backend: {}", e);
                        }
                    });
                }
                WinitEvent::Window(WindowEvent::Resized(new_size)) => {
                    slog::info!(self.logger, "Winit window resized to {:?}", new_size);
                    self.size = new_size;
                    if let Err(e) = self.surface.resize(
                        new_size.width.try_into().expect("Resize width too large"),
                        new_size.height.try_into().expect("Resize height too large"),
                    ) {
                        slog::error!(self.logger, "Failed to resize softbuffer surface: {}", e);
                    }
                    // self.renderer.resize((new_size.width as i32, new_size.height as i32), self.scale_factor);

                    let mode = Mode { size: (new_size.width as i32, new_size.height as i32).into(), refresh: 60_000 }; // Assuming 60Hz
                    compositor_state.output.change_current_state(Some(mode), None, Some(self.scale_factor as f32), None);
                    compositor_state.space.map_output(&compositor_state.output, (0,0));

                    if let Err(e) = backend_event_sender.send(WinitBackendEvent::Resized { new_size, new_scale_factor: self.scale_factor }) {
                         slog::error!(self.logger, "Error sending resize event: {}", e);
                    }
                }
                WinitEvent::Window(WindowEvent::ScaleFactorChanged { scale_factor, new_inner_size }) => {
                    slog::info!(self.logger, "Winit window scale factor changed to {}, new size {:?}", scale_factor, new_inner_size);
                    self.scale_factor = scale_factor;
                    self.size = *new_inner_size;
                    // self.renderer.resize((*new_inner_size.width as i32, *new_inner_size.height as i32), scale_factor);

                    let mode = Mode { size: (self.size.width as i32, self.size.height as i32).into(), refresh: 60_000 };
                    compositor_state.output.change_current_state(Some(mode), None, Some(self.scale_factor as f32), None);

                     if let Err(e) = backend_event_sender.send(WinitBackendEvent::Resized { new_size: self.size, new_scale_factor: self.scale_factor }) {
                         slog::error!(self.logger, "Error sending scale factor change event: {}", e);
                    }
                }
                WinitEvent::Window(WindowEvent::CloseRequested) => {
                    slog::info!(self.logger, "Winit window close requested.");
                     if let Err(e) = backend_event_sender.send(WinitBackendEvent::CloseRequested) {
                         slog::error!(self.logger, "Error sending close requested event: {}", e);
                    }
                    control_flow = ControlFlow::Exit;
                }
                WinitEvent::Window(WindowEvent::RedrawRequested) => {
                     if let Err(e) = backend_event_sender.send(WinitBackendEvent::Refresh) {
                         slog::error!(self.logger, "Error sending refresh event: {}", e);
                    }
                }
                _ => {}
            }
        } else if let Event::LoopDestroyed = event {
            slog::info!(self.logger, "Winit event loop destroyed.");
            control_flow = ControlFlow::Exit;
        }

        control_flow
    }

    /// Renders the current compositor scene to the Winit window using `softbuffer`.
    ///
    /// This method retrieves a mutable pixel buffer from the `softbuffer::Surface`,
    /// calls the `SimpleSoftwareRenderer` to draw the scene (from `compositor_state.space`)
    /// into this buffer, and then presents the buffer to the window.
    ///
    /// # Arguments
    /// * `compositor_state`: A read-only reference to `NovaCompositorState` to access
    ///   the `Space`, `Output`, and other necessary data for rendering.
    ///
    /// # Returns
    /// * `Ok(())` if rendering and presentation were successful.
    /// * `Err(String)` if any step failed (e.g., getting buffer, rendering, presentation).
    ///
    /// TODO: Implement proper damage tracking to optimize rendering. Currently uses `buffer_age = 0`.
    pub fn render(&mut self, compositor_state: &NovaCompositorState) -> Result<(), String> {
        let mut buffer_view = self.surface.buffer_mut()
            .map_err(|e| format!("Failed to get softbuffer mutable buffer: {}", e))?;

        let output = compositor_state.window_output();
        // Use current size from self, as output_mode might not be updated if resize handling is partial
        let (buffer_width, buffer_height) = (self.size.width, self.size.height);

        let buffer_age = 0; // Placeholder for damage tracking. 0 implies full redraw.

        self.renderer.render_output(
            &compositor_state.space,
            output,
            buffer_age,
            &mut buffer_view, // Dereferences to &mut [u32] or similar, then must be reinterpreted as &mut [u8] if renderer expects bytes.
                               // Softbuffer's buffer_mut() gives BufferViewMut which is &mut [u32].
                               // SimpleSoftwareRenderer expects &mut [u8]. This needs careful handling.
                               // For now, assuming render_output can adapt or this is resolved.
                               // A common pattern: `unsafe { std::slice::from_raw_parts_mut(buffer_view.as_mut_ptr() as *mut u8, buffer_view.len() * 4) }`
                               // This is UNSAFE. A safe way is to iterate and copy pixel by pixel if formats differ or do a safe transmute.
                               // For this sketch, we'll assume render_output handles the u32 slice or it's adapted.
                               // Let's assume render_output is adapted to work with a slice of u32 if that's what softbuffer provides,
                               // or that softbuffer can provide u8 directly.
                               // The SimpleSoftwareRenderer was written to expect &mut [u8].
                               // We will need to adjust one or the other.
                               // For now, this will be a conceptual call.
            buffer_width,
            buffer_height,
            buffer_width * 4, // Assuming XRGB8888 (4 bytes per pixel)
        ).map_err(|e| format!("Software rendering failed: {:?}", e))?; // Assuming Error implements Debug

        buffer_view.present()
            .map_err(|e| format!("Failed to present softbuffer: {}", e))?;
        Ok(())
    }

    /// Returns a reference to the Winit window.
    pub fn window(&self) -> &WinitWindow {
        &self.window
    }
}

/// Placeholder function demonstrating conceptual structure for running a Winit backend.
///
/// **This function is not directly used in the current single-threaded Calloop setup in `core.rs`.**
/// It outlines how one might structure a Winit event loop if it were run, for example,
/// on a separate thread, sending events back to a Calloop loop.
///
/// A proper integration usually involves `calloop-winit` or careful manual proxying of events
/// if Winit and Calloop are to share the main thread or communicate across threads.
pub fn run_winit_backend_event_loop_conceptual(
    // These arguments are examples of what such a function might take.
    // mut calloop_proxy: EventLoopProxy<WinitBackendEvent>, // To send events to Calloop
    // mut compositor_state_accessor: impl FnMut() -> std::cell::RefMut<NovaCompositorState>, // To access state
) -> Result<(), Box<dyn std::error::Error>> {

    let logger = slog::Logger::root(slog::Discard, slog::o!()); // Example logger
    slog::info!(logger, "Conceptual Winit backend event loop starting.");

    // let winit_event_loop = EventLoopBuilder::new().build();
    // let mut backend_data = WinitBackendData::new(&winit_event_loop, logger.clone())?;
    // let mut compositor_state_guard = compositor_state_accessor(); // Get mutable access to state

    // winit_event_loop.run(move |event, _, control_flow| {
    //     *control_flow = backend_data.handle_winit_event(
    //         &event,
    //         &mut compositor_state_guard, // Requires careful state management if shared
    //         &calloop_proxy, // This would actually be a ChannelSender
    //     );
    //     if *control_flow == ControlFlow::Exit {
    //         // Perform cleanup
    //     }
    // });

    // This function would not return in a typical Winit setup unless `run_return` is used.
    Ok(())
}
```
