# NovaDE: Technische Gesamtspezifikation und Richtliniensammlung

## 1. Einleitung

Dieses Dokument dient als zentrale technische Gesamtspezifikation und Richtliniensammlung für die Linux Desktop-Umgebung 'NovaDE'. Es hat zum Ziel, ein umfassendes Verständnis des Gesamtsystems zu ermöglichen und sicherzustellen, dass alle technischen Anforderungen, die sich aus den Beschreibungen der Nutzererfahrung (UX) ergeben, adäquat berücksichtigt und integriert werden. Die Spezifikation richtet sich an Entwickler, Architekten, Tester und alle weiteren Stakeholder, die an der Entwicklung, Wartung und Erweiterung von NovaDE beteiligt sind.

Eine präzise und detaillierte technische Spezifikation ist unerlässlich für den Erfolg komplexer Softwareprojekte.1 Sie minimiert Risiken durch frühzeitige Definition von Erwartungen und Randbedingungen, verbessert die Kommunikation zwischen den Beteiligten durch Schaffung einer gemeinsamen Referenz und steigert die Effizienz im Entwicklungsprozess.1 Studien belegen, dass detaillierte Spezifikationen Implementierungszeiten und Kosten durch Last-Minute-Änderungen signifikant reduzieren können.1 Dieses Dokument legt den Grundstein für Qualität, Wartbarkeit und Skalierbarkeit von NovaDE.2

### 1.1. Zweck und Geltungsbereich

Der Zweck dieses Dokuments ist die Definition der technischen Architektur, der Kernkomponenten, der Entwicklungsprozesse und der Qualitätsstandards für NovaDE. Es umfasst:

- Eine detaillierte Beschreibung der Systemarchitektur und ihrer Komponenten.
- Funktionale und nicht-funktionale Anforderungen, die sich aus der angestrebten Nutzererfahrung ableiten.
- Technologische Entscheidungen und deren Begründungen.
- Richtlinien für Entwicklung, Code-Qualität, Testing, Dokumentation und Sicherheit.
- Schnittstellendefinitionen für die Interaktion zwischen Komponenten und mit externen Systemen.
- Richtlinien für die Systemintegration und Erweiterbarkeit.

Der Geltungsbereich erstreckt sich auf alle Aspekte der NovaDE-Software, von den Low-Level-Systemdiensten bis hin zu den Benutzeroberflächenkomponenten. Es dient als maßgebliche Referenz für alle Entwicklungsaktivitäten.

### 1.2. Zielgruppe

Dieses Dokument richtet sich primär an:

- **Softwarearchitekten und -entwickler:** Für das Design, die Implementierung und Wartung von NovaDE-Komponenten.
- **Qualitätssicherungsingenieure und Tester:** Für die Erstellung von Testplänen und die Verifizierung der Systemanforderungen.
- **Projektmanager und Produktmanager:** Für das Verständnis der technischen Grundlagen und zur Planung von Entwicklungszyklen.
- **Systemintegratoren und Drittanbieter-Entwickler:** Für die Integration von Anwendungen und die Entwicklung von Erweiterungen für NovaDE.
- **Technische Redakteure:** Für die Erstellung von Endbenutzer- und Entwicklerdokumentation.

Die klare und präzise Formulierung soll auch nicht-technischen Stakeholdern ein grundlegendes Verständnis ermöglichen, wobei technische Details für Experten ausreichend tiefgehend behandelt werden.1

### 1.3. Definitionen und Akronyme

Eine umfassende Liste von Definitionen und Akronymen, die in diesem Dokument verwendet werden, findet sich im Anhang (Abschnitt 8.1). Dies dient der Vermeidung von Mehrdeutigkeiten und stellt ein einheitliches Verständnis sicher.4

### 1.4. Referenzierte Dokumente

Alle externen Dokumente, Standards und Spezifikationen, auf die in diesem Text Bezug genommen wird, sind im Anhang (Abschnitt 8.2) aufgeführt. Dies gewährleistet die Nachvollziehbarkeit und ermöglicht den Zugriff auf weiterführende Informationen.2

## 2. Systemübersicht und Architektur

Dieser Abschnitt beschreibt die übergeordnete Architektur von NovaDE und die Kernkomponenten, aus denen sich die Desktop-Umgebung zusammensetzt. Die Architektur ist darauf ausgelegt, eine moderne, performante und flexible Nutzererfahrung zu ermöglichen, basierend auf aktuellen Technologien wie Wayland, GTK4 und Rust.

### 2.1. Systemarchitektur

NovaDE folgt einer modularen Architektur, die eine klare Trennung der Verantwortlichkeiten zwischen den einzelnen Komponenten anstrebt. Dies fördert die Wartbarkeit, Testbarkeit und unabhängige Entwicklung der Systemteile. Die Architektur basiert auf einem Wayland-Compositor als Kernstück, der für die Darstellung und Verwaltung von Fenstern zuständig ist. Darauf aufbauend existieren eine Desktop-Shell für die Nutzerinteraktion, ein Session-Manager für den Lebenszyklus der Desktop-Sitzung sowie diverse Systemdienste für Hintergrundaufgaben und die Integration mit der Hardware und anderen Software-Subsystemen.

Die Kommunikation zwischen den Prozessen erfolgt primär über D-Bus für Steuerungs- und Benachrichtigungsaufgaben sowie über das Wayland-Protokoll für die Display-Server-Kommunikation. PipeWire wird für das Multimedia-Routing und -Management eingesetzt. Die Verwendung von Rust als primäre Programmiersprache zielt auf Systemsicherheit und Performance ab.

Die Architektur muss die Skalierbarkeit und Zuverlässigkeit des Systems sicherstellen.1 Eine gut dokumentierte Architektur ist entscheidend, um das System zu verstehen, weiterzuentwickeln und zu skalieren, da sonst wichtige Informationen verloren gehen können.3

### 2.2. Kernkomponenten und ihre Verantwortlichkeiten

Die folgende Tabelle listet die Kernkomponenten von NovaDE, ihre Hauptverantwortlichkeiten, die eingesetzten Schlüsseltechnologien und ihre wesentlichen Interaktionen auf.

**Tabelle 1: Kernkomponenten und ihre Verantwortlichkeiten**

|   |   |   |   |
|---|---|---|---|
|**Komponente**|**Hauptverantwortlichkeiten**|**Schlüsseltechnologien**|**Wesentliche Interaktionen**|
|**NovaDE Compositor**|Fenster-Management, Darstellung, Eingabeverarbeitung, Implementierung des Wayland-Protokolls, Compositing-Effekte.|Wayland, Smithay (Rust-Bibliothek), EGL, evdev (Kernel)|Empfängt Eingabeereignisse vom Kernel (evdev), kommuniziert mit Clients über Wayland-Protokoll, rendert Fensterinhalte auf den Bildschirm (KMS).5 Stellt sicher, dass keine Bildrisse (Tearing) auftreten und Fensterattribute korrekt dargestellt werden.5|
|**NovaDE Shell**|Bereitstellung der primären Benutzeroberfläche (Panel, Anwendungsstarter, Task-Manager, System-Tray, Desktop-Hintergrund, Widgets).|GTK4, Rust|Interagiert mit dem Compositor zur Platzierung und Darstellung von Shell-Elementen, startet Anwendungen, kommuniziert mit dem Session Manager und Systemdiensten über D-Bus für Statusinformationen und Aktionen. Lädt Menüs aus Builder-Ressourcen.7|
|**NovaDE Session Manager**|Verwaltung des Lebenszyklus einer Benutzersitzung (Login, Logout, Sperren), Starten der Kernkomponenten (Compositor, Shell, erforderliche Dienste).|D-Bus, systemd (optional für Service-Management)|Authentifiziert Benutzer, startet den Compositor und die Shell, verwaltet Umgebungsvariablen, kommuniziert mit systemd für den Start/Stopp von User-Services, reagiert auf Power-Management-Events über D-Bus.8|
|**NovaDE Settings Daemon**|Verwaltung und Bereitstellung globaler und benutzerspezifischer Einstellungen (Theme, Schriftarten, Eingabegeräte, Monitoreinstellungen).|D-Bus, GSettings (oder äquivalente Rust-Implementierung)|Stellt Einstellungen über D-Bus bereit, auf die Anwendungen und Shell-Komponenten zugreifen können. Liest Einstellungen aus Konfigurationsdateien (z.B. `settings.ini` für GTK) und ggf. DConf.9 Ermöglicht Anwendungen, systemweite Einstellungen zu überschreiben (mit Vorsicht zu verwenden).9|
|**NovaDE Notification Service**|Empfang, Verwaltung und Anzeige von Desktop-Benachrichtigungen von Anwendungen und Systemdiensten.|D-Bus (Freedesktop Notification Specification), GTK4|Empfängt Benachrichtigungsanfragen über D-Bus, verwaltet eine Warteschlange, zeigt Benachrichtigungen gemäß den Benutzereinstellungen an (z.B. Pop-ups, Benachrichtigungscenter). Interagiert mit der Shell zur Darstellung.|
|**NovaDE Power Manager**|Überwachung des Batteriestatus, Verwaltung von Energieeinstellungen, Behandlung von Suspend/Hibernate-Zuständen, Bildschirmhelligkeit.|D-Bus, UPower (oder direkte Kernel-Schnittstellen)|Kommuniziert mit UPower (oder äquivalent) für Batteriestatus, implementiert Energieprofile, initiiert Suspend/Hibernate über D-Bus-Aufrufe an `logind` oder systemd.8|
|**NovaDE Workspace Manager**|Verwaltung virtueller Desktops/Arbeitsbereiche, Fensterplatzierung über Arbeitsbereiche hinweg.|Integriert in Shell und Compositor|Ermöglicht dem Benutzer das Erstellen, Wechseln und Verwalten von Arbeitsbereichen. Der Compositor ist für die tatsächliche Zuordnung von Fenstern zu Arbeitsbereichen und deren Darstellung zuständig. Die Shell stellt die UI-Elemente zur Interaktion bereit. Die Logik kann komplex sein und erfordert eine sorgfältige Verwaltung von Zuständen und Übergängen, ähnlich wie bei Projektmanagement-Tools.10|
|**PipeWire Integration**|Audio- und Video-Stream-Management, Hardware-Abstraktion für Multimedia, Screen-Sharing-Unterstützung.|PipeWire, WirePlumber (Session Manager)|Stellt Audio- und Video-Funktionalität für Anwendungen bereit, ermöglicht Screen-Sharing unter Wayland, verwaltet Audiogeräte und -profile. Interagiert mit dem Kernel (ALSA) und Anwendungen.12 Bietet Ersatz für PulseAudio und JACK.13|
|**D-Bus Broker**|Vermittlung der Interprozesskommunikation zwischen NovaDE-Komponenten und Anwendungen.|D-Bus Daemon (z.B. `dbus-daemon` oder `dbus-broker`)|Stellt System- und Session-Busse bereit, über die Dienste ihre Funktionalität anbieten (Methoden, Signale, Eigenschaften) und Clients diese nutzen können.8|
|**XWayland Server**|Ausführung von X11-Anwendungen unter der Wayland-basierten NovaDE-Umgebung.|XWayland, Xorg-Server-Codebase|Dient als Kompatibilitätsschicht, indem ein X-Server innerhalb der Wayland-Sitzung läuft und X11-Clients mit dem Wayland-Compositor kommunizieren können. Dies ist notwendig, da nicht alle Anwendungen native Wayland-Unterstützung bieten.15|
|**Model Context Protocol (MCP) Integration (optional)**|Ermöglicht die strukturierte Interaktion von KI-Modellen (z.B. in einem KI-Assistenten) mit externen Daten und Diensten innerhalb von NovaDE.|MCP (JSON-RPC basiert)|Ein MCP-Host (z.B. ein KI-Assistent in NovaDE) kommuniziert mit MCP-Servern (Dienste, die Werkzeuge/Ressourcen bereitstellen). Ermöglicht KI-gesteuerte Aktionen wie Kalenderverwaltung oder sicheren Datenzugriff.17 Erfordert strenge Sicherheitsmaßnahmen.19|

### 2.3. Technologiestack

Der Technologiestack von NovaDE ist sorgfältig ausgewählt, um moderne Anforderungen an Leistung, Sicherheit und Entwicklereffizienz zu erfüllen.

- **Programmiersprache:** Rust wird als primäre Sprache für die Entwicklung von Kernkomponenten eingesetzt. Die Stärken von Rust in Bezug auf Speichersicherheit ohne Garbage Collector, Nebenläufigkeit und Performance machen es zu einer idealen Wahl für Systemsoftware wie eine Desktop-Umgebung. Die Rust API Guidelines 21 und der Rust Style Guide 22 sind maßgeblich für die Codeentwicklung.
- **Display Server Protokoll:** Wayland 5 ist das Fundament für die Display-Server-Architektur. Es bietet im Vergleich zu X11 eine modernere, sicherere und effizientere Basis, indem es die Rolle des Display-Servers und des Compositors vereint und viele Altlasten von X11 vermeidet.5 Herausforderungen bei der Wayland-Adoption, wie Kompatibilität mit älteren Anwendungen und spezifische Funktionen (z.B. Screen-Sharing, Drag-and-Drop), werden durch XWayland und Protokollerweiterungen sowie Bibliotheken wie PipeWire adressiert.15
- **Compositor-Bibliothek:** Smithay 5 dient als Bibliothek für die Entwicklung des Wayland-Compositors in Rust. Smithay stellt Bausteine für Wayland-Compositoren bereit und zielt auf Sicherheit, Modularität und eine High-Level-API ab.24 Da Smithay eine Bibliothek und kein Framework ist, bietet es hohe Flexibilität, erfordert aber auch mehr Eigenverantwortung bei der Implementierung der Compositor-Logik. Die Dokumentation und Community-Unterstützung von Smithay sind wichtige Ressourcen.24 Aktuelle Herausforderungen und Entwicklungen in Smithay (z.B. bezüglich Input-Handling, XWayland-Integration, Puffer-Management) müssen kontinuierlich beobachtet werden.26
- **UI Toolkit:** GTK4 9 wird für die Entwicklung der Desktop-Shell und anderer grafischer Anwendungen innerhalb von NovaDE verwendet. GTK4 bietet moderne Rendering-Fähigkeiten, CSS-basiertes Theming 27 und gute Integration mit Wayland. Die Rust-Bindings (`gtk4-rs`) 7 ermöglichen eine idiomatische Entwicklung in Rust. Die Architektur von GTK4-Anwendungen, insbesondere die Nutzung von `GtkApplication` 7, fördert eine strukturierte Anwendungsentwicklung.
- **Interprozesskommunikation (IPC):** D-Bus 8 ist der Standardmechanismus für die IPC zwischen NovaDE-Komponenten und zwischen Anwendungen und dem System. D-Bus ermöglicht es Diensten, Methoden, Signale und Eigenschaften bereitzustellen. Design-Richtlinien für D-Bus APIs, wie die Minimierung von Roundtrips und die Nutzung des Typsystems, sind für Performance und Robustheit entscheidend.30 Sicherheitsaspekte, insbesondere auf dem System-Bus, müssen berücksichtigt werden.30
- **Multimedia-Framework:** PipeWire 12 wird für das Management von Audio- und Videoströmen eingesetzt. PipeWire bietet geringe Latenz, flexible Graphen-basierte Verarbeitung und Kompatibilität mit PulseAudio-, JACK- und ALSA-Anwendungen.12 WirePlumber dient als Session-Manager für PipeWire und handhabt die Verbindungslogik und Profilverwaltung.13 Die Konfiguration von PipeWire erfolgt über Dateien und D-Bus, und es integriert sich mit XDG Portals für Screen-Sharing.12
- **Build-System:** Meson wird in Kombination mit Cargo für das Bauen von Rust-Projekten und deren Integration mit C-Bibliotheken (wie GTK) verwendet.34 Meson handhabt Abhängigkeiten von Nicht-Rust-Komponenten und die Installation von systemweiten Dateien, während Cargo die Rust-spezifischen Bauprozesse steuert. Es ist wichtig, `extern crate` zu vermeiden und stattdessen Abhängigkeiten in Meson zu deklarieren, um eine korrekte Nachverfolgung zu gewährleisten.35 Meson generiert auch `rust-project.json` für eine bessere IDE-Integration mit `rust-analyzer`.35
- **Versionskontrolle:** Git wird für die Versionskontrolle des gesamten NovaDE-Quellcodes verwendet.

### 2.4. Architekturdiagramm

Ein detailliertes Architekturdiagramm, das die Kernkomponenten, ihre Beziehungen und die wichtigsten Kommunikationspfade visualisiert, ist für das Verständnis des Systems unerlässlich. Dieses Diagramm sollte die Interaktionen über Wayland, D-Bus und PipeWire klar darstellen. Die Verwendung von Modellen wie dem C4-Modell (Context, Containers, Components, Code) kann hierbei hilfreich sein, um verschiedene Abstraktionsebenen darzustellen.36 Softwarearchitektur-Dokumentation nutzt oft Diagramme (z.B. UML) und textuelle Beschreibungen, um das Systemdesign zu erklären.3

_(An dieser Stelle würde ein Diagramm eingefügt werden, das die oben beschriebenen Komponenten und ihre Interaktionen zeigt. Da dies textbasiert ist, wird das Diagramm hier nicht visuell dargestellt, sondern seine Erstellung als Teil der Spezifikation gefordert.)_

Das Diagramm sollte folgende Elemente umfassen:

- **Kontext-Diagramm (Level 1):** Zeigt NovaDE im Kontext des Betriebssystems und der Benutzer.
- **Container-Diagramm (Level 2):** Zeigt die wichtigsten laufenden Prozesse/Dienste von NovaDE (Compositor, Shell, Session Manager etc.) und deren Hauptkommunikationswege (Wayland, D-Bus, PipeWire).
- **Komponenten-Diagramm (Level 3):** Detailliert die internen Hauptmodule innerhalb eines Containers, z.B. die Module des Compositors oder der Shell.

Diese visuelle Darstellung ergänzt die textuellen Beschreibungen und erleichtert das schnelle Erfassen der Systemstruktur.3

## 3. Detaillierte Komponentenspezifikationen

Dieser Abschnitt geht detailliert auf die Spezifikationen der einzelnen Kernkomponenten von NovaDE ein, die in Abschnitt 2.2 identifiziert wurden. Für jede Komponente werden ihre spezifischen Verantwortlichkeiten, Schnittstellen, technischen Anforderungen und Designüberlegungen beschrieben.

### 3.1. Wayland Compositor (Smithay-basiert)

Der NovaDE Wayland Compositor ist die zentrale Komponente für die grafische Darstellung und Interaktion. Er basiert auf der Smithay-Bibliothek.5

- **Verantwortlichkeiten:**
    
    - Implementierung des Wayland-Server-Protokolls und relevanter Erweiterungen (z.B. `xdg-shell`, `xdg-decoration`, `layer-shell`, `input-method`, `screencopy`).
    - Fenstermanagement: Platzierung, Stapelung, Größenänderung, Minimierung, Maximierung von Fenstern.
    - Compositing: Zusammenführen der Inhalte verschiedener Fenster und Oberflächen zu einem finalen Bild für den Bildschirm. Dies beinhaltet Transparenz, Schatten und optionale Animationen/Effekte.
    - Eingabeverarbeitung: Empfang von Eingabeereignissen (Maus, Tastatur, Touch) vom Kernel (via `libinput`/`evdev`) und Weiterleitung an die entsprechenden Client-Fenster oder die Shell.5 Dies beinhaltet die Transformation von Bildschirmkoordinaten zu lokalen Fensterkoordinaten.6
    - Ausgabemanagement: Konfiguration von Monitoren (Auflösung, Bildwiederholrate, Position), Unterstützung für Multi-Monitor-Setups und Hot-Plugging.
    - Verwaltung von Oberflächenrollen (`wl_surface` roles), insbesondere der Subsurface-Rolle.25
    - Koordination mit XWayland für die Unterstützung von X11-Anwendungen.
- **Schnittstellen:**
    
    - **Wayland-Protokoll:** Kommunikation mit Wayland-Clients (Anwendungen, Shell).
    - **Kernel Mode Setting (KMS) / Direct Rendering Manager (DRM):** Direkte Interaktion mit der Grafikhardware für die Bildausgabe.5
    - **`libinput` (oder äquivalente Smithay-Integration):** Für die Verarbeitung von Eingabegeräteereignissen.
    - **D-Bus:** Für die Kommunikation mit anderen NovaDE-Diensten (z.B. Settings Daemon für Theme-Änderungen, Power Manager für Helligkeitssteuerung).
- **Technische Anforderungen und Designüberlegungen:**
    
    - **Performance:** Geringe Latenz bei Eingabe und Darstellung ist kritisch. Effiziente Nutzung von GPU-Ressourcen durch EGL und OpenGL ES / Vulkan. Zero-Copy-Mechanismen, wo möglich, um die CPU-Auslastung zu minimieren.12
    - **Stabilität und Sicherheit:** Als Kernkomponente muss der Compositor extrem robust sein. Die Speichersicherheit von Rust trägt hierzu bei. Sicherheitslücken im X11-Protokoll sollen durch Waylands Design vermieden werden.5
    - **Modularität (Smithay-Ansatz):** Smithay ist eine Bibliothek, kein Framework.24 Dies gibt NovaDE-Entwicklern volle Kontrolle über die Compositor-Architektur und -Logik, bedeutet aber auch mehr Verantwortung für die Implementierung von Kernfunktionalitäten. Die Auswahl und Integration von Smithay-Modulen (z.B. für `xdg-shell`, Client-Handling, Rendering) muss sorgfältig erfolgen. Die Dokumentation von Smithay (`docs.rs` und für den Master-Branch) ist eine wichtige Ressource.24
    - **Atomare Updates:** Wayland ist darauf ausgelegt, atomare Updates zu ermöglichen, um Tearing und inkonsistente Fensterzustände zu vermeiden.5 Dies muss im Compositor korrekt implementiert werden, insbesondere bei der Anwendung von Zustandsänderungen von Oberflächen und Subsurfaces.25 Smithay's `CompositorState` und `SurfaceData` helfen bei der kohärenten Verwaltung von Oberflächenzuständen und der Anwendung von Double-Buffered State.25
    - **Damage Tracking:** Effizientes Damage Tracking ist notwendig, um nur die Teile des Bildschirms neu zu zeichnen, die sich geändert haben. Dies ist entscheidend für die Performance und Energieeffizienz.
    - **XWayland-Integration:** Nahtlose und performante Integration von XWayland ist für die Abwärtskompatibilität unerlässlich. Herausforderungen wie Tastatur-Grabs 26 oder spezifische Fenstergeometrien 26 müssen adressiert werden.
    - **Unterstützung für Protokollerweiterungen:** Eine klare Strategie für die Unterstützung und Implementierung neuer und optionaler Wayland-Protokollerweiterungen ist notwendig, um mit der Entwicklung des Wayland-Ökosystems Schritt zu halten.
    - **Fehlerbehandlung:** Robuste Fehlerbehandlung bei ungültigen Client-Anfragen oder internen Fehlern. Smithay bietet Mechanismen zur Erkennung von Problemen wie ungültige Fenstergeometrien oder Rollen-Neuzuweisungen vor der Zerstörung.26
    - **Konfigurierbarkeit:** Bereitstellung von Optionen zur Anpassung des Compositor-Verhaltens (z.B. Animationen, Effekte) über den Settings Daemon.

Die Entwicklung eines Wayland-Compositors mit Smithay erfordert ein tiefes Verständnis des Wayland-Protokolls und der Linux-Grafik- und Eingabe-Subsysteme. Die aktive Community und die Issue-Tracker von Smithay 26 sind wichtige Quellen für Problemlösungen und Best Practices.

### 3.2. Desktop Shell (GTK4-basiert)

Die NovaDE Shell ist die primäre Schnittstelle für den Benutzer und basiert auf GTK4 und Rust.

- **Verantwortlichkeiten:**
    
    - Bereitstellung und Verwaltung von UI-Elementen wie Panel(s), Anwendungsstarter (Launcher), Task-Manager, System-Tray-Bereich, Desktop-Hintergrund und Desktop-Widgets.
    - Starten von Anwendungen und Verwalten laufender Anwendungsfenster (in Koordination mit dem Compositor).
    - Anzeige von Systemstatusinformationen (Netzwerk, Lautstärke, Akku etc.).
    - Integration mit dem Notification Service zur Anzeige von Benachrichtigungen.
    - Verwaltung von Arbeitsbereichen/virtuellen Desktops.
    - Bereitstellung von Suchfunktionen (Anwendungen, Dateien, Einstellungen).
    - Integration von `GtkApplication` für Menüleisten und automatische Ressourcenladung (z.B. Icons, Menüdefinitionen aus UI-Dateien).7
- **Schnittstellen:**
    
    - **Wayland-Protokoll:** Als Wayland-Client kommuniziert die Shell mit dem NovaDE Compositor, um ihre UI-Elemente als Wayland-Oberflächen (z.B. mittels `layer-shell` für Panels) darzustellen und Eingaben zu empfangen.
    - **D-Bus:** Kommunikation mit dem Session Manager (z.B. für Logout/Shutdown-Aktionen), Settings Daemon (für Theme- und Einstellungsänderungen), Notification Service, Power Manager und anderen Systemdiensten.
    - **GTK4 API:** Für die Erstellung und Verwaltung der UI-Elemente.
    - **PipeWire:** Indirekt über Portale oder Bibliotheken für Funktionen wie Lautstärkeregelung oder Mediensteuerung.
- **Technische Anforderungen und Designüberlegungen:**
    
    - **Performance und Reaktionsfähigkeit:** Die Shell muss auch bei hoher Systemlast flüssig und reaktionsschnell bleiben. Effiziente Nutzung von GTK4-Rendering und Minimierung von blockierenden Operationen im Hauptthread.
    - **Anpassbarkeit und Theming:** Umfangreiche Anpassungsmöglichkeiten für den Benutzer (Position und Inhalt von Panels, Themes, Icons, Schriftarten). GTK4-CSS wird für das Theming verwendet.27 Die Shell muss auf Änderungen der GTK-Einstellungen (z.B. `gtk-application-prefer-dark-theme` 9) reagieren.
    - **Modularität:** Einzelne Shell-Komponenten (z.B. Panel, Launcher, Widgets) sollten möglichst modular und austauschbar gestaltet sein, um Erweiterbarkeit und alternative Implementierungen zu ermöglichen.
    - **Barrierefreiheit (Accessibility):** Einhaltung von Standards für Barrierefreiheit unter Verwendung der AT-Context-APIs von GTK.28
    - **Multi-Monitor-Unterstützung:** Korrekte Darstellung und Verwaltung von Shell-Elementen auf mehreren Monitoren mit unterschiedlichen Auflösungen und DPI-Einstellungen.
    - **Zustandsverwaltung:** Effiziente Verwaltung des Zustands der Shell (z.B. geöffnete Menüs, aktive Widgets). Rust-Muster für die Zustandsverwaltung (z.B. Verwendung von `Arc<RwLock<T>>` oder `Rc<RefCell<T>>` je nach Threading-Modell 37, oder dedizierte State-Management-Bibliotheken wie `stateflow` 38 bei komplexen Zustandsautomaten) sind relevant.
    - **Integration mit `GtkApplication`:** Nutzung von `GtkApplication` für die Hauptanwendungslogik der Shell, um von dessen Features wie Anwendungs-Uniqueness, Session-Management-Integration und automatischer Ressourcenladung (Menüs, Icons) zu profitieren.7 Menüs können über `gtk/menus.ui` geladen und über `menu_by_id()` dynamisch manipuliert werden.7
    - **Icon-Handling:** Nutzung des `GtkIconTheme` und automatisches Hinzufügen von Ressourcenpfaden für anwendungsspezifische Icons.7

Die Entwicklung der Shell erfordert ein gutes Verständnis von GTK4, ereignisgesteuerter Programmierung und der Interaktion mit dem Wayland-Compositor und D-Bus-Diensten.

### 3.3. Session Manager

Der NovaDE Session Manager ist verantwortlich für den Lebenszyklus der Benutzersitzung.

- **Verantwortlichkeiten:**
    
    - Benutzerauthentifizierung (typischerweise delegiert an PAM oder einen Display Manager).
    - Starten der Kernkomponenten von NovaDE beim Login (Compositor, Shell, Settings Daemon, etc.).
    - Verwaltung von Umgebungsvariablen für die Sitzung.
    - Behandlung von Sitzungsereignissen wie Sperren, Abmelden, Herunterfahren, Neustarten.
    - Koordination mit `systemd-logind` (falls vorhanden) für Sitzungsmanagement und Hardware-Zugriffsrechte.
    - Bereitstellung einer D-Bus-Schnittstelle für andere Komponenten, um Sitzungsaktionen auszulösen (z.B. Logout-Button in der Shell).
- **Schnittstellen:**
    
    - **PAM (Pluggable Authentication Modules):** Für die Benutzerauthentifizierung.
    - **D-Bus:** Kommunikation mit `systemd-logind` und Bereitstellung einer eigenen D-Bus-Schnittstelle für Sitzungssteuerung. Andere NovaDE-Komponenten (z.B. Shell, Power Manager) interagieren über D-Bus mit dem Session Manager.8
    - **Prozessmanagement:** Starten und Überwachen der Kernprozesse der Desktop-Umgebung.
- **Technische Anforderungen und Designüberlegungen:**
    
    - **Sicherheit:** Sichere Handhabung von Authentifizierungsdaten und Sitzungsinformationen.
    - **Robustheit:** Zuverlässiges Starten und Beenden der Desktop-Umgebung. Fehler beim Start einzelner Komponenten müssen ggf. abgefangen und behandelt werden.
    - **Integration mit Systemdiensten:** Enge Integration mit `systemd-logind` oder alternativen Mechanismen zur Verwaltung von Sitzungen und Gerätezugriff (z.B. für DRM/KMS). PipeWire erfordert beispielsweise eine korrekte Sitzungseinrichtung für Geräte-ACLs.12
    - **Konfigurierbarkeit:** Möglichkeit zur Konfiguration von Autostart-Anwendungen und Sitzungsparametern.
    - **Schneller Start:** Optimierung der Startsequenz für ein schnelles Hochfahren der Desktop-Umgebung.

### 3.4. Settings Daemon und Konfigurationsmanagement

Der Settings Daemon zentralisiert die Verwaltung von System- und Benutzereinstellungen.

- **Verantwortlichkeiten:**
    
    - Bereitstellung einer zentralen Anlaufstelle für das Lesen und Schreiben von Konfigurationseinstellungen.
    - Verwaltung von Einstellungen für Erscheinungsbild (Theme, Icons, Schriftarten, Hintergrund), Hardware (Monitore, Eingabegeräte, Energieoptionen) und Verhalten der Desktop-Umgebung.
    - Benachrichtigung von interessierten Anwendungen und Komponenten über Einstellungsänderungen.
    - Laden von Standardeinstellungen und Zusammenführen mit benutzerspezifischen Anpassungen.
    - GTK-Einstellungen: Der Daemon ist verantwortlich für die Bereitstellung von GTK-spezifischen Einstellungen (z.B. `gtk-theme-name`, `gtk-font-name`, `gtk-application-prefer-dark-theme`). Diese werden typischerweise über einen XSettings-Manager (unter X11) oder einen Settings-Portal/DConf (unter Wayland) geteilt.9 GTK liest auch Standardwerte aus `settings.ini`-Dateien.9
- **Schnittstellen:**
    
    - **D-Bus:** Hauptschnittstelle für Anwendungen und Shell-Komponenten, um Einstellungen abzufragen und (ggf. mit entsprechenden Rechten) zu ändern. Signale werden verwendet, um über Änderungen zu informieren.
    - **Konfigurations-Backends:** Interaktion mit Speichermechanismen für Einstellungen (z.B. GSettings/DConf, INI-Dateien, XML-Dateien).
    - **XSettings-Protokoll (optional, für XWayland-Kompatibilität):** Falls erforderlich, um Einstellungen für X11-Anwendungen bereitzustellen.
- **Technische Anforderungen und Designüberlegungen:**
    
    - **Konsistenz:** Sicherstellung, dass alle Komponenten auf einen konsistenten Satz von Einstellungen zugreifen.
    - **Performance:** Schneller Zugriff auf Einstellungen und effiziente Benachrichtigung bei Änderungen. Caching-Mechanismen können hier sinnvoll sein.39
    - **Granularität:** Feingranulare Einstellungsoptionen, um eine detaillierte Anpassung durch den Benutzer zu ermöglichen.
    - **Schema-Definition:** Ein klares Schema für alle Konfigurationsparameter, inklusive Datentypen, erlaubter Werte und Standardwerte (siehe Tabelle 4 im Anhang).
    - **Migration:** Strategien für die Migration von Einstellungen bei Updates der Desktop-Umgebung.
    - **Sicherheit:** Zugriffskontrolle für das Ändern systemweiter oder sicherheitsrelevanter Einstellungen.
    - **Global Settings Management:** Die Verwaltung globaler Einstellungen ist ein kritischer Aspekt für die Stabilität und Konsistenz großer Anwendungen.39 Eine zentrale Konfigurationsverwaltung reduziert das Risiko von Ausfällen und Sicherheitslücken durch Nachverfolgbarkeit von Änderungen und Durchsetzung von Richtlinien.40

Eine Herausforderung beim Konfigurationsmanagement ist die Balance zwischen Flexibilität für den Benutzer und der Komplexität der Verwaltung. Eine klare Struktur und gute Werkzeuge zur Konfiguration sind entscheidend.

### 3.5. Notification Service

Der Notification Service ist für die Anzeige von Desktop-Benachrichtigungen zuständig.

- **Verantwortlichkeiten:**
    
    - Implementierung der Freedesktop Desktop Notifications Specification.
    - Empfang von Benachrichtigungsanfragen von Anwendungen und Systemdiensten.
    - Verwaltung einer Warteschlange für Benachrichtigungen.
    - Anzeige von Benachrichtigungen als Pop-ups oder in einem Benachrichtigungscenter, gemäß den Benutzereinstellungen und dem aktuellen Systemzustand (z.B. "Nicht stören"-Modus).
    - Unterstützung für Aktionen in Benachrichtigungen.
    - Persistenz von Benachrichtigungen (optional, für ein Benachrichtigungscenter).
- **Schnittstellen:**
    
    - **D-Bus:** Empfängt Benachrichtigungsanfragen über die standardisierte D-Bus-Schnittstelle (`org.freedesktop.Notifications`).
    - **NovaDE Shell:** Interagiert mit der Shell zur Darstellung der Benachrichtigungs-UI.
    - **Settings Daemon:** Abfrage von Benutzereinstellungen bezüglich Benachrichtigungen (z.B. Position, Timeout, "Nicht stören"-Modus).
- **Technische Anforderungen und Designüberlegungen:**
    
    - **Zuverlässigkeit:** Benachrichtigungen müssen zuverlässig zugestellt und angezeigt werden.41
    - **Performance:** Der Dienst darf das System nicht übermäßig belasten, auch bei vielen eingehenden Benachrichtigungen.
    - **Anpassbarkeit:** Benutzer sollten das Aussehen und Verhalten von Benachrichtigungen anpassen können.
    - **Regel-Engine (optional):** Eine erweiterte Implementierung könnte eine Regel-Engine enthalten, um Benachrichtigungen basierend auf Quelle, Inhalt oder Systemzustand unterschiedlich zu behandeln (z.B. Priorisierung, Stummschaltung).42 Eine solche Engine würde aus einer Sammlung von Regeln, einem Eingabemechanismus, Trigger-Bedingungen und Aktionen bestehen.42
    - **Rate Limiting und Queuing:** Um eine Überlastung des Systems oder des Benutzers zu vermeiden, sollten Mechanismen für Rate Limiting und Queuing implementiert werden.41
    - **Logging:** Detailliertes Logging zur Fehlerbehebung und Nachverfolgung von Benachrichtigungsflüssen.41
    - **Datenbankschema (für Persistenz):** Falls Benachrichtigungen persistiert werden, ist ein gut designtes Datenbankschema für Benutzerpräferenzen, Anfragen und Zustellstatus erforderlich.41

Die Architektur eines Benachrichtigungssystems umfasst typischerweise einen Client (die Anwendung, die die Benachrichtigung sendet), einen Notification Server (der die Anfragen verarbeitet und in die Warteschlange stellt) und einen Notification Executor (der die Benachrichtigungen über die entsprechenden Kanäle zustellt).44

### 3.6. Weitere Systemdienste (z.B. Power Management, Workspace Management)

Neben den oben genannten Hauptkomponenten können weitere spezialisierte Systemdienste existieren.

- **Power Manager:**
    
    - **Verantwortlichkeiten:** Überwachung des Batteriestatus, Umschaltung zwischen Energieprofilen, Initiierung von Suspend/Hibernate, Steuerung der Bildschirmhelligkeit, Reaktion auf Deckel-Schließen-Events bei Laptops.
    - **Schnittstellen:** D-Bus (Interaktion mit `UPower`, `systemd-logind`, Settings Daemon, Shell).
    - **Anforderungen:** Geringer Ressourcenverbrauch, zuverlässige Reaktion auf Energieereignisse.
- **Workspace Manager:**
    
    - **Verantwortlichkeiten:** Logik für die Verwaltung von virtuellen Desktops/Arbeitsbereichen, Verschieben von Fenstern zwischen Arbeitsbereichen, Speichern und Wiederherstellen von Fensteranordnungen pro Arbeitsbereich (optional). Die Implementierung ist oft eng mit dem Compositor und der Shell verwoben.
    - **Schnittstellen:** Interne APIs mit Compositor und Shell, D-Bus für die Steuerung durch externe Tools oder Skripte.
    - **Anforderungen:** Effiziente Verwaltung von Fensterzuständen, intuitive Bedienung. Die Komplexität der Workspace-Verwaltung kann mit der von Projektmanagement-Tools verglichen werden, bei denen es darum geht, Aufgaben (Fenster) in verschiedenen Kontexten (Arbeitsbereichen) zu organisieren und den Überblick zu behalten.10 Funktionen wie das "Verpacken" von Fenstern in Ordner-ähnliche Strukturen oder das Speichern und Abrufen von Layouts (Screensets) sind denkbare Erweiterungen.10
- **Model Context Protocol (MCP) Host (optional, falls KI-Funktionen integriert werden):**
    
    - **Verantwortlichkeiten:** Dient als Container oder Koordinator für MCP-Client-Instanzen innerhalb von NovaDE (z.B. ein KI-Assistent). Verwaltet den Lebenszyklus, Sicherheitspolicies (Berechtigungen, Benutzerautorisierung, Zustimmung) und die Interaktion zwischen KI-Modellen und MCP-Servern (externe Werkzeuge und Datenquellen).17
    - **Schnittstellen:** MCP (JSON-RPC über lokale Prozesse oder HTTP-Streams), interne APIs mit der KI-Anwendung, D-Bus für die Systemintegration.
    - **Anforderungen:** Starke Authentifizierung zwischen Host, Client und Servern, explizite und bereichsbezogene Autorisierung, Eingabevalidierung und Ausgabesanitisierung, Ratenbegrenzung, Überwachung und Logging.19 Die Sicherheit ist hier von größter Bedeutung, da MCP den Zugriff auf sensible Daten und Systemfunktionen ermöglichen kann.19 Ein kompromittierter MCP-Server könnte Daten stehlen oder Befehle manipulieren.19

Die Notwendigkeit und das Design weiterer Dienste ergeben sich aus den spezifischen Anforderungen der Nutzererfahrung und den geplanten Features von NovaDE.

## 4. Nicht-funktionale Anforderungen (NFRs)

Nicht-funktionale Anforderungen definieren, _wie_ das System seine Funktionen ausführt, und sind entscheidend für die Qualität und Akzeptanz der Software.45 Sie müssen spezifisch, messbar, erreichbar, relevant und zeitgebunden (SMART) formuliert werden. Die Vernachlässigung von NFRs kann dazu führen, dass eine Software trotz voller Funktionalität die Erwartungen der Nutzer nicht erfüllt.46

### 4.1. Performance

- **Reaktionszeiten:**
    - Start der Desktop-Umgebung (vom Login bis zur vollen Nutzbarkeit): <5 Sekunden auf Zielhardware.
    - Start typischer Anwendungen (Texteditor, Browser): <2 Sekunden.
    - Öffnen des Anwendungsstarters: <300 ms.
    - Fensteroperationen (Öffnen, Schließen, Minimieren, Verschieben, Größenänderung): Visuell unmittelbar, Latenz <50 ms.
    - Shell-Animationen und -Effekte: Mindestens 60 FPS, um Flüssigkeit zu gewährleisten.
- **Ressourcennutzung:**
    - Leerlauf-CPU-Auslastung des Desktops (ohne laufende Anwendungen): <5% auf einem einzelnen Kern der Zielhardware.
    - RAM-Nutzung der Kern-Desktop-Prozesse (Compositor, Shell, Session Manager) im Leerlauf: <512 MB insgesamt.
    - Die Performance-Anforderungen müssen unter Berücksichtigung der aktuellen Systemlast spezifiziert werden.45
- **Datendurchsatz (falls relevant, z.B. für Dateioperationen im Dateimanager):** Spezifische Metriken je nach Anwendungsfall.
- **PipeWire Latenz:** Für Audio-Anwendungen ist eine geringe Latenz wichtig. PipeWire ermöglicht die Konfiguration von Quanten und Raten, um die Latenz zu beeinflussen (z.B. 11 ms für Bluetooth-Headsets, 90 ms für Video-Apps bei 48 kHz).12 Die Latenz wird als Verhältnis von Quantum zu Rate berechnet.12

### 4.2. Stabilität und Zuverlässigkeit

- **Mean Time Between Failures (MTBF):** Für Kernkomponenten (Compositor, Shell) wird ein MTBF von >1000 Betriebsstunden angestrebt.
- **Fehlertoleranz:** Absturz einer einzelnen Anwendung darf nicht zur Instabilität des gesamten Desktops führen. Der Compositor muss robust gegenüber fehlerhaften Clients sein.
- **Wiederherstellbarkeit:** Im Falle eines Absturzes einer Kernkomponente (z.B. Shell) soll ein automatischer Neustart ohne Datenverlust der laufenden Anwendungen (soweit möglich) erfolgen.
- **Verfügbarkeit:** Die Verfügbarkeit des Systems sollte hoch sein, z.B. 99.9%.46 Dies muss unter Berücksichtigung der finanziellen und kritischen Auswirkungen von Ausfallzeiten definiert werden.45

### 4.3. Sicherheit

- **Zugriffskontrolle:** Strikte Trennung von Benutzerprivilegien und Systemprivilegien. Prozesse laufen mit minimal notwendigen Rechten (Principle of Least Privilege).
- **Datenschutz:** Schutz sensibler Benutzerdaten (Passwörter, private Dateien) vor unbefugtem Zugriff. Einhaltung relevanter Datenschutzbestimmungen (z.B. DSGVO).
- **Wayland-Sicherheitsmodell:** Wayland ist inhärent sicherer als X11, da Clients isolierter sind und keinen direkten Zugriff auf die Eingaben oder Fensterinhalte anderer Clients haben.5 Der Compositor agiert als Gatekeeper.
- **D-Bus-Sicherheit:** Der System-Bus von D-Bus verfügt über Sicherheitsmechanismen, die einschränken, welche Prozesse Namen besitzen oder Methodenaufrufe senden dürfen.30 Session-Busse gelten typischerweise nicht als Sicherheitsgrenze innerhalb der Benutzersitzung.30
- **Sicherheitsupdates:** Ein klar definierter Prozess für die schnelle Bereitstellung von Sicherheitsupdates.
- **Schutz vor Angriffen:** Maßnahmen zum Schutz vor gängigen Angriffsvektoren (z.B. SQL-Injection, XSS bei Web-basierten Komponenten – falls vorhanden, Code Injection durch unsichere Plugin-Schnittstellen).
- **MCP-Sicherheit (falls implementiert):** Starke Authentifizierung, explizite Autorisierung, Eingabevalidierung, Ausgabesanitisierung, Ratenbegrenzung und Sandboxing sind für MCP-Komponenten unerlässlich.17 Die Verwendung von nicht überprüften MCP-Paketen stellt ein Risiko dar.20

### 4.4. Skalierbarkeit

- **Anzahl gleichzeitiger Anwendungen:** Das System muss auch bei einer großen Anzahl (>50) gleichzeitig laufender Anwendungen performant und stabil bleiben.
- **Multi-Monitor-Unterstützung:** Unterstützung für mindestens 4 Monitore mit unterschiedlichen Auflösungen und DPI-Einstellungen ohne signifikanten Performanceverlust.
- **Anpassung an Hardware:** Das System soll auf einer breiten Palette von Hardware, von Low-End-Laptops bis zu High-End-Workstations, zufriedenstellend laufen. Dies kann unterschiedliche Konfigurationsprofile erfordern.
- **PipeWire Skalierbarkeit:** PipeWire ist darauf ausgelegt, eine große Anzahl von Multimedia-Streams effizient zu verwalten.12

### 4.5. Wartbarkeit

- **Code-Komplexität:** Reduzierung der Code-Komplexität durch modulare Bauweise und klare Schnittstellen.47 Verwendung von Code-Qualitäts-Tools (Linters, statische Analyse).
- **Dokumentation:** Umfassende und aktuelle Entwicklerdokumentation (API-Referenzen, Architektur-Beschreibungen).1
- **Testbarkeit:** Hohe Testabdeckung durch Unit-, Integrations- und UI-Tests.2
- **Logging und Debugging:** Aussagekräftige Log-Meldungen und gute Debugging-Unterstützung.
- **Standardisierte Formate und Prozesse:** Einhaltung von Coding-Standards und Entwicklungsprozessen.1
- Die Wartbarkeit wird durch die Lesbarkeit und Verständlichkeit des Codes beeinflusst. Klare Namenskonventionen und eine konsistente Code-Struktur sind hierfür wichtig.48

### 4.6. Benutzbarkeit (Usability)

Obwohl primär durch UX-Spezifikationen definiert, hat die Benutzbarkeit auch technische Implikationen:

- **Konsistenz:** Einheitliches Erscheinungsbild und Verhalten über alle NovaDE-Komponenten hinweg.
- **Barrierefreiheit (Accessibility):** Einhaltung von a11y-Standards (z.B. WCAG für Web-Inhalte, entsprechende GTK-Richtlinien). Wayland selbst hat Herausforderungen im Bereich Barrierefreiheit, die durch Protokollerweiterungen und Toolkit-Unterstützung adressiert werden müssen.23
- **Internationalisierung (i18n) und Lokalisierung (l10n):** Unterstützung für verschiedene Sprachen und regionale Formate.
- **Konfigurierbarkeit:** Einfache und verständliche Anpassungsmöglichkeiten für den Benutzer.
- Messbare Usability-Ziele sollten auf Basis von Benutzertests (ggf. mit Prototypen oder Konkurrenzprodukten) festgelegt werden.45

### 4.7. Kompatibilität

- **Anwendungskompatibilität:**
    - Native Wayland-Anwendungen (GTK, Qt): Vollständige Unterstützung.
    - X11-Anwendungen: Unterstützung über XWayland.15 Es muss sichergestellt werden, dass gängige X11-Anwendungen (Browser, Office-Suiten, Spiele) unter XWayland zufriedenstellend funktionieren. Bekannte Probleme mit XWayland (z.B. bei spezifischen Anwendungen wie Krita, Discord, OBS 15) müssen adressiert oder dokumentiert werden.
    - Flatpak/Snap-Anwendungen: Integration über XDG Desktop Portals für den Zugriff auf Systemressourcen.6
- **Hardwarekompatibilität:** Unterstützung für gängige Grafikchips (Intel, AMD, NVIDIA – letztere oft mit proprietären Treibern und spezifischen Herausforderungen unter Wayland), Eingabegeräte und Peripherie.
- **Freedesktop.org-Standards:** Einhaltung relevanter Standards für Interoperabilität (z.B. Desktop Entry Specification, Icon Theme Specification, MIME-Type System, Notification Specification).

Die Dokumentation von NFRs sollte in Zusammenarbeit mit verschiedenen Stakeholdern erfolgen und NFRs sollten mit Geschäftszielen verknüpft werden.45 Es ist wichtig, Einschränkungen durch Drittanbieter-APIs oder bestehende Architekturen zu berücksichtigen.45 Eine separate Verfolgung von NFRs und regelmäßige Überprüfung wird empfohlen.46

## 5. Schnittstellenspezifikationen

Dieser Abschnitt definiert die wichtigsten internen und externen Schnittstellen von NovaDE. Eine klare Definition dieser Schnittstellen ist entscheidend für die modulare Entwicklung und die Interoperabilität der Komponenten.

### 5.1. Interne APIs (zwischen NovaDE-Komponenten)

- **D-Bus Schnittstellen:**
    
    - **Definition:** Jede NovaDE-Komponente, die Dienste für andere Komponenten bereitstellt (z.B. Settings Daemon, Session Manager, Notification Service), exponiert eine oder mehrere D-Bus-Schnittstellen. Diese Schnittstellen definieren Objekte, Methoden, Signale und Eigenschaften.8
    - **Designrichtlinien:**
        - Verwendung sprechender Namen für Dienste, Pfade, Schnittstellen, Methoden und Signale (z.B. `org.novade.Settings`, `/org/novade/Settings`, `org.novade.Settings.Interface`, `GetSetting`, `SettingChanged`). Versionierung sollte in Namen inkludiert werden, um API-inkompatible Änderungen zu handhaben (z.B. `org.novade.MyService1`).30
        - Minimierung der Anzahl von Roundtrips durch gut gestaltete Methoden (z.B. Rückgabe mehrerer verwandter Werte in einer Methode statt mehrerer einzelner Aufrufe).30
        - Nutzung des D-Bus-Typsystems: Strukturierte Daten (Structs, Arrays, Dictionaries) sollten nativen D-Bus-Typen anstelle von serialisierten Strings vorgezogen werden. Enumerierte Werte als Unsigned Integers übertragen, um String-Parsing zu vermeiden und die Nachrichten kompakter zu halten.30
        - Klare Dokumentation jeder Schnittstelle, ihrer Methoden, Argumente, Rückgabewerte und Signale. Die Bedeutung von Enum-Werten muss dokumentiert werden.30
        - Verwendung von `org.freedesktop.DBus.Properties` für den Zugriff auf Eigenschaften, anstatt spezifischer Get/Set-Methoden für jede Eigenschaft.30
    - **Sicherheit:** D-Bus-Richtlinien (Policy-Dateien) definieren, welche Benutzer oder Prozesse auf welche Schnittstellen und Methoden zugreifen dürfen, insbesondere auf dem System-Bus.
    - **Beispiele:**
        - Session Manager: `org.novade.SessionManager.Logout()`, `org.novade.SessionManager.CanShutdownChanged (Signal)`.
        - Settings Daemon: `org.novade.Settings.GetValue(category, key)`, `org.novade.Settings.SetValue(category, key, value)`, `org.novade.Settings.ValueChanged (Signal)`.
- **Wayland Protokollerweiterungen (falls spezifisch für NovaDE):**
    
    - Falls NovaDE eigene, private Wayland-Protokollerweiterungen für die Kommunikation zwischen dem Compositor und der Shell (oder anderen internen Clients) benötigt, müssen diese hier spezifiziert werden.
    - **Definition:** XML-basierte Protokolldateien, die neue Interfaces, Requests, Events und Enums definieren.6
    - **Generierung:** C-Header und Glue-Code können mit `wayland-scanner` generiert werden.5 Für Rust werden entsprechende Generatoren oder manuelle Bindings benötigt.
    - **Stabilität:** Private Protokolle sollten als instabil betrachtet und klar als solche gekennzeichnet werden, um externe Abhängigkeiten zu vermeiden.
- **Interne Rust-Bibliotheks-APIs (Crates):**
    
    - NovaDE wird voraussichtlich aus mehreren Rust-Crates bestehen. Die öffentlichen APIs dieser Crates (Funktionen, Structs, Traits, Enums, Module) müssen klar definiert und dokumentiert sein (`rustdoc`).
    - **Richtlinien:** Einhaltung der offiziellen Rust API Guidelines.21 Dies beinhaltet Aspekte wie Namenskonventionen (C-CASE, C-CONV, C-GETTER, C-ITER), Implementierung gängiger Traits (C-COMMON-TRAITS wie `Debug`, `Clone`, `Send`, `Sync`), Fehlerbehandlung (C-GOOD-ERR), Dokumentation (C-CRATE-DOC, C-EXAMPLE) und Zukunftsfähigkeit (C-STRUCT-PRIVATE, C-SEALED).
    - **Modularität:** Crates sollten klar definierte Verantwortlichkeiten haben und lose gekoppelt sein.

### 5.2. Externe APIs (für Drittanbieter-Anwendungen)

- **Wayland Protokoll:**
    
    - NovaDE implementiert Standard-Wayland-Protokolle und -Erweiterungen (z.B. `xdg-shell`, `xdg-decoration`, `wl_output`, `wl_seat`). Anwendungen interagieren mit NovaDE primär über diese Protokolle.
    - Die unterstützten Protokolle und deren Versionen müssen dokumentiert werden.
    - Wayland ist ein asynchrones, objektorientiertes Protokoll. Clients fordern Dienste vom Compositor an, indem sie Methoden auf Objekten aufrufen. Der Compositor sendet Informationen an Clients, indem Objekte Ereignisse auslösen.6
- **D-Bus Schnittstellen (öffentlich):**
    
    - NovaDE kann ausgewählte D-Bus-Schnittstellen für Drittanbieter-Anwendungen bereitstellen (z.B. für Statusinformationen, Abfrage von Desktop-Funktionen).
    - Diese Schnittstellen müssen stabil, versioniert und gut dokumentiert sein.
    - Beispiel: Eine Schnittstelle, um die aktuelle Theme-Farbe oder den "Nicht stören"-Status abzufragen.
- **XDG Desktop Portals:**
    
    - Für sandboxed Anwendungen (Flatpak, Snap) ist die Interaktion über XDG Desktop Portals der bevorzugte Weg, um auf Systemressourcen zuzugreifen (Dateiauswahl, Öffnen von URIs, Drucken, Screen-Sharing etc.).
    - NovaDE muss die Backend-Implementierungen für die relevanten Portale bereitstellen (z.B. `xdg-desktop-portal-novade` oder Nutzung von generischen Backends wie `xdg-desktop-portal-gtk`). PipeWire integriert sich mit Portalen für Screen-Sharing.6
- **Freedesktop.org Standards:**
    
    - Anwendungen verlassen sich auf die Einhaltung von Freedesktop.org-Standards durch die Desktop-Umgebung für eine nahtlose Integration. Dazu gehören:
        - Desktop Entry Specification (`.desktop`-Dateien für Anwendungsmenüs).
        - Icon Theme Specification (Auffinden und Anzeigen von Icons).
        - MIME Applications Associations (Zuordnung von Dateitypen zu Anwendungen).
        - Desktop Notifications Specification (bereits durch den Notification Service abgedeckt).
        - Status Notifier Item Specification (für System-Tray-Icons, falls unterstützt).

### 5.3. Model Context Protocol (MCP) Schnittstellen (falls zutreffend)

Falls NovaDE KI-gestützte Funktionen integriert, die auf dem Model Context Protocol basieren, sind dessen Schnittstellen relevant.

- **MCP-Architektur:** MCP verwendet eine Client-Server-Architektur. Die KI-Anwendung (z.B. ein Desktop-Assistent) fungiert als Host und betreibt einen MCP-Client. Externe Integrationen (Tools, Datenquellen) laufen als MCP-Server.17
- **Kommunikation:** Erfolgt über standardisierte JSON-RPC-Nachrichten.17
    - Beispielhafte Methoden: `tools/list` (um verfügbare Werkzeuge aufzulisten), `tools/call` (um ein Werkzeug mit Parametern aufzurufen).17
- **MCP-Primitive:**
    - **Tools:** Vom Modell gesteuerte API-Aufrufe oder Operationen (z.B. Datei schreiben, Kalendereintrag erstellen).18
    - **Resources:** Von der Anwendung gesteuerte kontextuelle Daten (z.B. Dateiinhalte, Git-Historie).18
    - **Prompts:** Vom Benutzer gesteuerte Vorlagen oder Anweisungen (z.B. Slash-Befehle).18
- **Sicherheitsaspekte:** Da MCP den Zugriff auf externe Dienste und potenziell sensible Daten ermöglicht, sind strenge Sicherheitsmaßnahmen unerlässlich:
    - **Authentifizierung:** Starke Authentifizierung zwischen Host, Client und Server (z.B. API-Keys, Tokens, mTLS).19 Clients sollten nur mit vertrauenswürdigen, whitelisted Servern verbinden.19
    - **Autorisierung:** Explizite, bereichsbezogene Autorisierung nach dem Prinzip der geringsten Rechte.19
    - **Eingabevalidierung und Ausgabesanitisierung:** Alle über MCP fließenden Daten müssen als potenziell bösartig behandelt und validiert/sanitisiert werden, um Injection-Angriffe oder Verwirrung des KI-Modells zu verhindern.19
    - **Ratenbegrenzung und Ressourcenbeschränkungen:** Um Missbrauch oder Überlastung zu verhindern.19
    - **Überwachung und Logging:** Zur Nachverfolgung von Aktivitäten und Erkennung von Anomalien.19
    - Die Integration von MCP erhöht das Risiko von Supply-Chain-Angriffen und Compliance-Verletzungen, wenn nicht sorgfältig gehandhabt.20

Die Definition und Dokumentation dieser Schnittstellen muss klar, präzise und für die jeweilige Zielgruppe verständlich sein.1 Die Verwendung von API-Beschreibungssprachen (z.B. OpenAPI für HTTP-basierte D-Bus-Alternativen, falls vorhanden, oder XML für Wayland-Protokolle) kann die Konsistenz und Maschinenlesbarkeit verbessern.

## 6. Entwicklungsrichtlinien und -standards

Dieser Abschnitt legt die Richtlinien und Standards für den Entwicklungsprozess von NovaDE fest. Ziel ist es, eine hohe Codequalität, Wartbarkeit, Konsistenz und Effizienz im gesamten Projekt sicherzustellen. Die Einhaltung dieser Richtlinien ist für alle Mitwirkenden verbindlich.

### 6.1. Programmierrichtlinien (Rust)

Die Entwicklung von NovaDE-Komponenten in Rust folgt den offiziellen und Community-etablierten Best Practices.

- **Rust Edition:** Verwendung der neuesten stabilen Rust Edition (z.B. 2021 oder neuer), um von aktuellen Sprachfeatures und Verbesserungen zu profitieren. Für Meson-Projekte ist die Angabe `rust_std=2018` (oder neuer) in den `project(default_options)` wichtig, um `extern crate` zu vermeiden.35
- **Offizielle Rust API Guidelines:** Strikte Einhaltung der Rust API Guidelines.21 Dies umfasst:
    - **Naming Conventions (C-CASE, C-CONV, C-GETTER, C-ITER, C-ITER-TY, C-FEATURE, C-WORD-ORDER):** Konforme Benennung von Crates, Modulen, Typen, Funktionen, Variablen etc.
    - **Interoperabilität (C-COMMON-TRAITS, C-CONV-TRAITS, C-COLLECT, C-SEND-SYNC, C-GOOD-ERR, C-NUM-FMT, C-RW-VALUE):** Implementierung gängiger Traits (`Debug`, `Clone`, `Eq`, `PartialEq`, `Ord`, `PartialOrd`, `Hash`, `Display`, `Default`, `Send`, `Sync`, `From`, `AsRef`, `AsMut`, `FromIterator`, `Extend`), sinnvolle Fehlertypen, Formatierungsoptionen für Zahlentypen.
    - **Macros (C-EVOCATIVE, C-MACRO-ATTR, C-ANYWHERE, C-MACRO-VIS, C-MACRO-TY):** Wohlgeformte und intuitive Makros.
    - **Dokumentation (C-CRATE-DOC, C-EXAMPLE, C-QUESTION-MARK, C-FAILURE, C-LINK, C-METADATA, C-RELNOTES, C-HIDDEN):** Umfassende Dokumentation (siehe auch Abschnitt 6.7).
    - **Vorhersagbarkeit (C-SMART-PTR, C-CONV-SPECIFIC, C-METHOD, C-NO-OUT, C-OVERLOAD, C-DEREF, C-CTOR):** Code soll sich so verhalten, wie er aussieht.
    - **Flexibilität (C-INTERMEDIATE, C-CALLER-CONTROL, C-GENERIC, C-OBJECT):** APIs sollen diverse Anwendungsfälle unterstützen.
    - **Typsicherheit (C-NEWTYPE, C-CUSTOM-TYPE, C-BITFLAG, C-BUILDER):** Effektive Nutzung des Typsystems.
    - **Verlässlichkeit (C-VALIDATE, C-DTOR-FAIL, C-DTOR-BLOCK):** Robuster Code, der Argumente validiert und in Destruktoren nicht fehlschlägt oder blockiert.
    - **Debuggability (C-DEBUG, C-DEBUG-NONEMPTY):** Alle öffentlichen Typen implementieren `Debug`.
    - **Zukunftsfähigkeit (C-SEALED, C-STRUCT-PRIVATE, C-NEWTYPE-HIDE, C-STRUCT-BOUNDS, C-STABLE, C-PERMISSIVE):** Design für Weiterentwicklung ohne Breaking Changes.
- **Rust Style Guide:** Einhaltung des offiziellen Rust Style Guide 22 für Code-Formatierung (Einrückung, Zeilenlänge, Kommentare, Attribute). Die Verwendung von `rustfmt` mit der Standardkonfiguration wird dringend empfohlen, um Konsistenz zu gewährleisten und unnötige Diskussionen über Stilfragen zu vermeiden.22
    - Einrückung: 4 Leerzeichen, keine Tabs.
    - Maximale Zeilenlänge: 100 Zeichen.
    - Kommentare: Bevorzugt Zeilenkommentare (`//`).
    - Attribute: Jedes Attribut auf eigener Zeile.
- **Clippy:** Regelmäßige Verwendung von Clippy (`cargo clippy`) zur Identifizierung von idiomatischen Verbesserungen und häufigen Fehlern. Alle Clippy-Warnungen (mindestens die Standard-Lints) müssen vor dem Mergen von Code behoben werden.
- **Fehlerbehandlung:**
    - Bevorzugung von `Result<T, E>` für Fehler, die behandelt werden können.
    - Verwendung der `thiserror`-Crate zur Erstellung spezifischer, aussagekräftiger Fehlertypen für Bibliotheken.49 `thiserror` reduziert Boilerplate durch automatische Implementierung von `std::error::Error` und `Display` und ermöglicht einfaches Hinzufügen von Kontext und Komposition von Fehlertypen.50 Die `#[from]`-Attribut ist nützlich für die Konvertierung von Fehlern aus anderen Bibliotheken.51
    - Die `anyhow`-Crate kann für Anwendungs-Code verwendet werden, wo es weniger auf spezifische Fehlertypen ankommt und einfache Fehlerpropagation gewünscht ist.52 `anyhow` ist jedoch ein opaquer Fehlertyp, der eine Fehlerbehandlung durch den Aufrufer erschwert und eher für das "Durchreichen" von Fehlern gedacht ist.52
    - Panics sollten auf nicht behebbare Fehler beschränkt sein (z.B. Programmierfehler, inkonsistente Zustände). Bibliotheks-Code sollte möglichst nicht panicen.
    - Fehlermeldungen sollten kontextbezogen und für Entwickler hilfreich sein.
- **Unsafe Code:** Die Verwendung von `unsafe` Rust ist auf ein absolutes Minimum zu beschränken und nur dort einzusetzen, wo es unumgänglich ist (z.B. FFI, direkte Hardware-Interaktion). Jeder `unsafe`-Block muss detailliert kommentiert werden, um die Notwendigkeit und die erfüllten Sicherheitsbedingungen zu rechtfertigen.
- **Nebenläufigkeit (Concurrency):** Nutzung der Rust-eigenen Sicherheitsmechanismen für Nebenläufigkeit (Ownership, Borrowing, `Send`, `Sync`). Bevorzugung von High-Level-Abstraktionen (z.B. `async/await`, `tokio`, `crossbeam`) gegenüber manueller Thread- und Mutex-Verwaltung.
- **Abhängigkeitsmanagement (Cargo):**
    - Sorgfältige Auswahl von externen Crates. Bevorzugung von gut gewarteten, stabilen und weit verbreiteten Bibliotheken.
    - Regelmäßige Überprüfung und Aktualisierung von Abhängigkeiten (`cargo update`).
    - Minimierung der Anzahl von Abhängigkeiten, um Build-Zeiten und Angriffsflächen klein zu halten.
    - Verwendung von semantischer Versionierung.
- **Modulstruktur:** Code sollte logisch in Modulen und Crates organisiert sein, um die Lesbarkeit und Wartbarkeit zu verbessern.53 Domain-Driven Design (DDD) Prinzipien können bei der Strukturierung komplexer Domänen helfen 54, ebenso wie Event-Sourcing-Muster für zustandsbehaftete Systeme, die eine Historie von Änderungen benötigen.56
- **Performance:** Code sollte unter Berücksichtigung von Performance geschrieben werden, ohne jedoch verfrühte Optimierung zu betreiben. Profiling-Tools sind zur Identifizierung von Engpässen einzusetzen.

### 6.2. Code-Review-Prozess

Code-Reviews sind ein integraler Bestandteil des Entwicklungsprozesses, um Code-Qualität, Konsistenz und Wissensaustausch zu gewährleisten.47

- **Review-Pflicht:** Jeder Code-Beitrag (Feature, Bugfix) muss vor dem Mergen in den Hauptentwicklungszweig von mindestens einer anderen Person (idealerweise zwei) gereviewt werden.
- **Review-Kriterien:**
    - Korrektheit und Funktionalität gemäß den Anforderungen.
    - Einhaltung der Programmierrichtlinien (Abschnitt 6.1).
    - Lesbarkeit, Verständlichkeit und Wartbarkeit des Codes.
    - Angemessene Testabdeckung (Unit- und Integrationstests).
    - Aktualität und Korrektheit der Dokumentation (API-Docs, Kommentare).
    - Performance-Implikationen.
    - Sicherheitsaspekte.
    - Keine Einführung von Regressionen.
- **Werkzeuge:** Verwendung von Plattformen wie GitLab oder GitHub für Merge Requests und Inline-Kommentare.
- **Konstruktives Feedback:** Reviews sollten konstruktiv, respektvoll und auf den Code fokussiert sein. Ziel ist die Verbesserung des Codes und des gemeinsamen Verständnisses.
- **Verantwortung des Autors:** Der Autor ist verantwortlich für die Adressierung der Review-Kommentare und die Sicherstellung der Code-Qualität.
- **Zeitnahe Reviews:** Reviews sollten zeitnah durchgeführt werden, um den Entwicklungsfluss nicht unnötig zu blockieren.

Durch Code-Reviews können Fehler frühzeitig erkannt, die Codequalität verbessert und das Wissen im Team verteilt werden. Ein Senior-Kollege kann beispielsweise ineffiziente Datenbankabfragen identifizieren und Optimierungen vorschlagen, die die Performance erheblich verbessern.47

### 6.3. Versionskontrollstrategie (Git)

Eine konsistente Versionskontrollstrategie ist entscheidend für die Zusammenarbeit und Nachverfolgbarkeit.

- **Branching-Modell:** Empfohlen wird ein Modell wie Git Flow oder ein einfacheres GitHub/GitLab Flow.
    - `main` (oder `master`): Enthält stabilen, produktionsreifen Code. Direkte Commits sind verboten.
    - `develop`: Hauptentwicklungszweig, von dem Feature-Branches abzweigen und in den sie zurückgemerged werden.
    - Feature-Branches (`feature/name-des-features`): Für die Entwicklung neuer Funktionen.
    - Release-Branches (`release/version-nummer`): Zur Vorbereitung von Releases (Stabilisierung, Bugfixing).
    - Hotfix-Branches (`hotfix/problem-beschreibung`): Für dringende Korrekturen an produktivem Code.
- **Commit-Nachrichten:**
    - Müssen klar, prägnant und im Imperativ formuliert sein (z.B. "Fix: Behebe Absturz beim Fenster schließen").
    - Sollten eine Zusammenfassungszeile (max. 50 Zeichen) und optional einen detaillierteren Body enthalten.
    - Bezugnahme auf Issue-Nummern (z.B. "Fixes #123").
- **Merging:**
    - Bevorzugung von Merge Requests (Pull Requests) für alle Änderungen an `develop` und `main`.
    - Squash-Merges oder Rebase-Merges können verwendet werden, um die Commit-Historie sauber zu halten, abhängig von der Teampräferenz.
- **Tagging:** Releases auf dem `main`-Branch müssen mit einer Versionsnummer getaggt werden (gemäß Semantischer Versionierung, z.B. `v1.2.3`).
- **Code-Formatierung vor Commit:** Es wird empfohlen, Code vor dem Commit automatisch mit `rustfmt` zu formatieren (z.B. über Git Hooks).

### 6.4. Teststrategie und -richtlinien

Eine umfassende Teststrategie ist unerlässlich, um die Qualität und Zuverlässigkeit von NovaDE sicherzustellen.2

- **Testarten:**
    
    - **Unit-Tests (Rust: `#[test]` in Modulen):** Testen isolierter Code-Einheiten (Funktionen, Methoden).59 Sie werden typischerweise in derselben Datei wie der zu testende Code oder in einem Untermodul `tests` (z.B. `#[cfg(test)] mod tests {... }`) definiert.59
        - Jede öffentliche Funktion und Methode sollte Unit-Tests haben.
        - Private Funktionen können indirekt über öffentliche Schnittstellen oder direkt getestet werden, wenn sie komplexe Logik enthalten.
    - **Integrationstests (Rust: in `tests`-Verzeichnis):** Testen die Interaktion zwischen verschiedenen Modulen oder Crates.59 Sie greifen auf die öffentliche API der Library zu.59
        - Fokus auf Schnittstellen und Datenflüsse zwischen Komponenten.
        - Beispiel: Testen der D-Bus-Kommunikation zwischen zwei NovaDE-Diensten.
    - **UI-/Funktionstests:** Testen der Benutzeroberfläche und End-to-End-Workflows aus Sicht des Benutzers.
        - Werkzeuge wie `dogtail` (für Accessibility-basierte UI-Automatisierung) oder spezifische Test-Frameworks für Wayland/GTK könnten evaluiert werden.
        - Diese Tests sind oft aufwendiger zu erstellen und zu warten.
    - **Performancetests:** Überprüfung der nicht-funktionalen Anforderungen bezüglich Performance (Reaktionszeiten, Ressourcennutzung).58
        - Definierte Benchmarks und Testszenarien.
    - **Dokumentationstests (`rustdoc`):** Sicherstellung, dass Code-Beispiele in der Dokumentation korrekt sind und kompilieren.59 Alle Beispiele in der Dokumentation sollten testbar sein (`/// ```rust... ///`).
- **Testabdeckung:** Anstreben einer hohen Code-Abdeckung (z.B. > 80% für Kernkomponenten). Tools wie `tarpaulin` oder `grcov` können zur Messung verwendet werden. Testabdeckung allein ist jedoch kein Garant für Qualität; die Qualität der Tests ist ebenso wichtig.47
    
- **Testdatenmanagement:** Strategien für die Erstellung und Verwaltung von Testdaten, insbesondere für UI- und Integrationstests.
    
- **Mocking/Stubbing:** Verwendung von Mocking-Frameworks (z.B. `mockall` in Rust) oder manuellen Stubs, um Komponenten während Unit- und Integrationstests zu isolieren.
    
- **Rust Testing Best Practices:**
    
    - Verwendung von Assertions-Makros (`assert!`, `assert_eq!`, `assert_ne!`, `should_panic`).59 `pretty_assertions` kann für bessere Fehlermeldungen bei Vergleichen großer Objekte verwendet werden.62
    - Deskriptive Testfunktionsnamen (z.B. `test_login_success`, `test_render_panel_with_widgets`).59
    - Klare Definition des Testzwecks.59
    - Setup- und Teardown-Logik für Tests, die einen bestimmten Zustand erfordern (z.B. temporäre Dateien mit `tempfile` 62, Initialisierung von Testdatenbanken).
    - Testen von asynchronem Code mit `#[tokio::test]` oder äquivalenten Attributen für den verwendeten Async-Runtime.62
    - Organisation von gemeinsam genutzten Test-Hilfsfunktionen in einem `tests/common` Modul oder einer lokalen `dev-dependency` Crate.62
    - Erwägung von Property-basiertem Testen (z.B. mit `proptest` 62) für Funktionen, die eine breite Palette von Eingaben verarbeiten, um Eigenschaften über zufällige Eingaben zu verifizieren.
    - Erwägung von Mutations-Tests (z.B. mit `cargo-mutants` 62) für kritische Komponenten, um die Effektivität der Testsuite zu bewerten. Ein "gefangener" Mutant (Test schlägt fehl) ist ein gutes Zeichen, ein "verpasster" Mutant (kein Test schlägt fehl) deutet auf eine Lücke in der Testabdeckung hin.62
    - Für Kommandozeilenanwendungen (falls Teile von NovaDE als solche implementiert sind oder Test-Harnesses dies erfordern), können `assert_cmd` und `predicates` für Blackbox-Tests verwendet werden.60 `assert_fs` hilft beim Setup von Dateisystemzuständen für Tests.60

Die Testanforderungen 2 und die Notwendigkeit, verschiedene Aspekte wie Unit-, Integrations-, Benutzerakzeptanz- und Performancetests abzudecken 58, unterstreichen die Bedeutung einer mehrschichtigen Teststrategie.

### 6.5. Continuous Integration und Continuous Delivery (CI/CD)

Automatisierte CI/CD-Pipelines sind entscheidend für eine konsistente und zuverlässige Softwareentwicklung und -bereitstellung.47

- **Implementierung von CI/CD-Pipelines:** Verwendung von Werkzeugen wie GitLab CI, GitHub Actions oder Jenkins.
- **Automatisierte Schritte:**
    - **Build:** Kompilierung des Codes bei jedem Commit/Merge Request auf allen Zielplattformen.
    - **Tests:** Automatische Ausführung aller Unit-, Integrations- und Dokumentationstests.
    - **Static Analysis:** Ausführung von `rustfmt --check`, `cargo clippy` und ggf. weiteren statischen Analysewerkzeugen.
    - **Code Coverage Reports:** Generierung von Testabdeckungsberichten.
- **Deployment-Strategie:**
    - Automatisierte Bereitstellung auf Staging-/Testumgebungen nach erfolgreichen Builds auf dem `develop`-Zweig.
    - Für Produktionsreleases:
        - **Kleine Batches (Small Deploys):** Änderungen in kleineren, inkrementellen Updates häufig bereitstellen, um das Risiko kritischer Fehler zu reduzieren und Rollbacks zu erleichtern.47 Anstatt ein komplettes Redesign auf einmal auszurollen, einzelne Komponenten über mehrere Tage verteilen.47
        - **Feature Flags:** Neue Features zunächst für eine Untergruppe von Benutzern aktivieren, um sie in einer kontrollierten Umgebung zu testen, bevor sie für alle ausgerollt werden.47
- **Artefakt-Management:** Speicherung und Versionierung von Build-Artefakten (Binärdateien, Debug-Symbole, Pakete).

CI/CD reduziert die Bereitstellungszeit von Stunden auf Minuten und stellt sicher, dass Qualitätsprüfungen niemals übersprungen werden.47

### 6.6. Fehlerbehandlung, Logging und Debugging

Robuste Mechanismen für Fehlerbehandlung, Logging und Debugging sind für die Entwicklung und Wartung eines komplexen Systems wie NovaDE unerlässlich.

- **Fehlerbehandlung (Error Handling):**
    
    - **Rusts `Result<T, E>`:** Standard für fallible Operationen.
    - **`thiserror`:** Für die Definition spezifischer, semantisch reicher Fehlertypen in Bibliotheks-Crates.49 Dies ermöglicht es Aufrufern, Fehler programmatisch zu behandeln und zu unterscheiden. `thiserror` hilft, Boilerplate zu reduzieren und klare Fehlermeldungen zu generieren.50 Es wird empfohlen, eine Hierarchie von Fehlertypen zu erstellen, wobei spezifischere Fehler in allgemeinere Fehler überführt werden können (z.B. `ParseError::DecryptionError(DecryptionError)`).49
    - **`anyhow`:** Kann für Anwendungs-Code oder an den oberen Rändern von Bibliotheken verwendet werden, um Fehler einfach zu propagieren, wenn eine detaillierte Fehlerbehandlung durch den Aufrufer nicht erforderlich ist.52 Es ist jedoch zu beachten, dass `anyhow::Error` ein opaker Typ ist, der die Introspektion erschwert.52
    - **Panics:** Sollten vermieden werden, außer bei nicht behebbaren Programmierfehlern oder inkonsistenten Zuständen, die ein sofortiges Beenden erfordern. Bibliotheken dürfen nicht panicen (C-FAILURE 21).
    - **Fehlerkontext:** Fehler sollten ausreichend Kontextinformationen enthalten, um die Ursache des Fehlers nachvollziehen zu können. Bibliotheken wie `eyre` (ähnlich `anyhow`, aber mit Fokus auf Kontext) können hierfür verwendet werden, obwohl das Hinzufügen von Kontext ergonomische Herausforderungen mit sich bringen kann.52
    - Die Entscheidung, ob ein Fehler spezifisch (mit `thiserror`) oder generisch (mit `anyhow`) behandelt wird, hängt davon ab, ob Aufrufer die Fehler introspektieren und unterschiedlich darauf reagieren müssen.49
- **Logging:**
    
    - **Logging Facade:** Verwendung der `log`-Crate als Standard-Logging-Fassade.
    - **Logging Backend:** Ein konfigurierbares Backend wie `env_logger` (einfach) oder `tracing` (strukturierter, leistungsfähiger) sollte verwendet werden.
    - **Log-Level:** Klare Definition der Verwendung von Log-Levels (ERROR, WARN, INFO, DEBUG, TRACE).
        - ERROR: Kritische Fehler, die die Funktionalität beeinträchtigen.
        - WARN: Unerwartete Situationen oder potenzielle Probleme.
        - INFO: Allgemeine Betriebsinformationen, wichtige Ereignisse.
        - DEBUG: Detaillierte Informationen zur Fehlerdiagnose für Entwickler.
        - TRACE: Sehr detaillierte Informationen, typischerweise für tiefgreifendes Debugging.
    - **Log-Nachrichten-Inhalt:** Log-Nachrichten sollten Zeitstempel, Modul-/Funktionsname, Thread-ID und die eigentliche Nachricht enthalten. Strukturierte Logs (z.B. JSON-Format) können die Analyse erleichtern.
    - **PII (Personally Identifiable Information):** Keine sensiblen Benutzerdaten (Passwörter, private Inhalte) in Logs schreiben.
- **Debugging:**
    
    - **`Debug` Trait:** Alle öffentlichen Typen müssen `std::fmt::Debug` implementieren (C-DEBUG 21). Die `Debug`-Repräsentation sollte niemals leer sein (C-DEBUG-NONEMPTY 21).
    - **Debug-Symbole:** Entwicklungs-Builds müssen Debug-Symbole enthalten, um die Verwendung von Debuggern wie GDB oder LLDB zu ermöglichen. `rust-gdb` oder `rust-lldb` können die Debugging-Erfahrung für Rust-Code verbessern.
    - **Spezifische Debugging-Werkzeuge:**
        - Für Wayland: Debugging-Tools wie `weston-debug` oder Wayland-Protokoll-Logger.
        - Für GTK: GTK Inspector.
        - Für PipeWire: `pw-dump`, `pw-top`, `pw-cli`, `helvum`, `qpwgraph`.12
    - **Core Dumps:** Konfiguration des Systems zur Erstellung von Core Dumps bei Abstürzen von NovaDE-Prozessen zur Post-Mortem-Analyse.

### 6.7. Dokumentationsstandards und -pflege

Eine umfassende und aktuelle Dokumentation ist entscheidend für die Wartbarkeit, Erweiterbarkeit und Nutzung von NovaDE.1 Sie sollte als integraler Bestandteil des Entwicklungsprozesses betrachtet werden, nicht als nachträgliche Aufgabe.3

- **`rustdoc` als primäres Werkzeug:** Die API-Dokumentation wird direkt im Rust-Quellcode mit `rustdoc`-Kommentaren (`///` für Items, `//!` für Module) geschrieben.61
    
- **Inhaltsanforderungen für API-Dokumentation:**
    
    - **Crate-Level-Dokumentation (`//!` in `lib.rs` oder `main.rs`):** Eine gründliche Einführung in das Crate, seinen Zweck, Hauptfunktionen und ein Anwendungsbeispiel.21
    - **Dokumentation aller öffentlichen Items:** Jede öffentliche Funktion, Methode, Struct, Enum, Trait und Makro muss dokumentiert werden.61 Die erste Zeile sollte eine prägnante Zusammenfassung sein.63
    - **Code-Beispiele:** Für jedes öffentliche Item sollte mindestens ein lauffähiges Code-Beispiel (`/// ```rust... ///`) bereitgestellt werden, das mit `cargo test --doc` getestet werden kann.21 Beispiele sollten den `?`-Operator verwenden, nicht `try!` oder `unwrap` (C-QUESTION-MARK 21).
    - **Fehler, Panics, Sicherheit:** Dokumentation von Fehlerbedingungen (welche Fehler können zurückgegeben werden), Situationen, die zu Panics führen können, und Sicherheitsüberlegungen bei `unsafe` Code (C-FAILURE 21, 61).
    - **Markdown-Nutzung:** Effektive Verwendung von Markdown für Strukturierung (Überschriften wie `# Examples`, `# Panics`, `# Errors`, `# Safety` 61), Listen, Code-Blöcke, Tabellen und Links zu anderen Teilen der Dokumentation (Intra-Doc-Links) oder externen Ressourcen.61
    - Vermeidung von Implementierungsdetails in der öffentlichen API-Dokumentation, wenn sie für den Benutzer nicht relevant sind (C-HIDDEN 21).
- **`Cargo.toml` Metadaten:** Die `Cargo.toml`-Datei jedes Crates muss vollständige Metadaten enthalten: `authors`, `description`, `license`, `homepage`, `documentation` (Link zur `docs.rs`-Seite), `repository`, `keywords`, `categories` (C-METADATA 21).
    
- **Release Notes / Changelog:** Jedes Release muss von Release Notes begleitet werden, die alle signifikanten Änderungen, neuen Features, Bugfixes und Breaking Changes dokumentieren (C-RELNOTES 21). Das Format "Keep a Changelog" wird empfohlen.
    
- **Technische Gesamtspezifikation (dieses Dokument):** Dieses Dokument selbst ist eine zentrale Säule der Dokumentation. Es muss als "lebendiges Dokument" gepflegt und bei jeder signifikanten Architektur- oder Designänderung aktualisiert werden.1 Agile Methoden helfen, mit sich ändernden Anforderungen umzugehen, und die Dokumentation muss diesen Änderungen folgen.65
    
- **UX-Dokumentation Anbindung:** UX-Anforderungen und Design-Entscheidungen sollten mit den technischen Komponenten und Spezifikationen verknüpft werden.66 Dies stellt sicher, dass die technische Implementierung die beabsichtigte Nutzererfahrung widerspiegelt. UX-Dokumentation sollte als Produkt-Asset behandelt und versioniert werden.67
    
- **Zielgruppenorientierung:** Dokumentation sollte für die jeweilige Zielgruppe (Entwickler, Endbenutzer, Systemadministratoren) verständlich und relevant sein.3
    
- **Konsistenz und Klarheit:** Verwendung einheitlicher Terminologie und klarer, präziser Sprache. Vermeidung von Ambiguität und unnötigem Jargon.1
    
- **Pflegeprozess:**
    
    - Dokumentationsupdates sind Teil der "Definition of Done" für jede Entwicklungsaufgabe.
    - Dokumentationsänderungen unterliegen dem Code-Review-Prozess.
    - Regelmäßige Überprüfung der gesamten Dokumentation auf Aktualität und Korrektheit.

Die Herausforderung, Dokumentation synchron mit einer sich schnell entwickelnden Desktop-Umgebung zu halten, ist erheblich. Dies erfordert Disziplin und die Integration von Dokumentationsaufgaben in den Kernentwicklungsworkflow. Wenn Code-Änderungen erst dann als abgeschlossen gelten, wenn die zugehörige Dokumentation (API-Dokumente, Benutzerhandbücher bei Betroffenheit und diese Spezifikation selbst) ebenfalls aktualisiert und überprüft wurde, wird die Dokumentation zu einem proaktiven Bestandteil der Entwicklung und nicht zu einem nachträglichen Gedanken.3 Dies kann durch die Verknüpfung von Dokumentationsaufgaben mit Entwicklungsaufgaben in einem Issue-Tracker unterstützt werden.

## 7. Richtlinien für Systemintegration und Erweiterungen

Dieser Abschnitt behandelt, wie NovaDE erweitert werden kann und wie es sich in das breitere Linux-Ökosystem integriert. Eine gut definierte Strategie für Erweiterbarkeit und Integration ist entscheidend für die Flexibilität und Akzeptanz der Desktop-Umgebung.

### 7.1. Plugin-Architektur und -entwicklung (Falls zutreffend)

Sollte NovaDE ein Plugin-System zur Erweiterung seiner Kernkomponenten (z.B. für Shell-Widgets, Compositor-Effekte, Dateimanager-Erweiterungen) unterstützen, müssen folgende Aspekte definiert werden:

- **Plugin-API:**
    - **Stabilität:** Klare Definition der Stabilität der Plugin-API (z.B. SemVer für die API). Breaking Changes müssen sorgfältig verwaltet und kommuniziert werden.
    - **Versionierung:** Ein Mechanismus zur Versionierung von Plugins und der Plugin-API, um Kompatibilitätsprobleme zu vermeiden.
    - **Sprachbindung:** Definition, in welchen Sprachen Plugins entwickelt werden können (z.B. nur Rust, oder auch C, Python über FFI).
    - **Funktionsumfang:** Welche Aspekte von NovaDE können durch Plugins erweitert oder modifiziert werden?
- **Verpackung und Entdeckung:** Wie werden Plugins paketiert, installiert und vom System erkannt (z.B. spezifische Verzeichnisse, Metadaten-Dateien)?
- **Ressourcenmanagement und Sandboxing:**
    - Wie werden Ressourcen (Speicher, CPU) von Plugins verwaltet?
    - Gibt es Sandboxing-Mechanismen, um die Auswirkungen fehlerhafter oder bösartiger Plugins zu begrenzen? Dies ist besonders wichtig, wenn Plugins in privilegierten Prozessen laufen.
- **Entwicklungsrichtlinien für Plugin-Ersteller:**
    - Dokumentation der Plugin-API.
    - Best Practices für die Entwicklung stabiler und sicherer Plugins.
    - Beispiel-Plugins.

Eine gut durchdachte Plugin-Architektur kann die Flexibilität und das Community-Engagement erheblich steigern, birgt aber auch Komplexität und potenzielle Sicherheitsrisiken. Die Balance zwischen diesen Aspekten ist entscheidend. Die Prinzipien des Model Context Protocol (MCP) 17, obwohl für KI-Systeme entwickelt, bieten wertvolle Anregungen für die Gestaltung sicherer Plugin-Systeme, insbesondere hinsichtlich Authentifizierung, Autorisierung und Sandboxing 19, falls Plugins weitreichende Fähigkeiten besitzen. Wenn Plugins beispielsweise auf D-Bus-Schnittstellen zugreifen oder beliebigen Code ausführen können, ist das Sicherheitsmodell (siehe Abschnitt 7.3) von größter Bedeutung.

### 7.2. Integration von Drittanbieter-Anwendungen

NovaDE muss eine nahtlose Integration von Standard-Linux-Anwendungen gewährleisten.

- **Verhalten von Anwendungen:**
    - **Native Wayland-Anwendungen:** GTK- und Qt-Anwendungen, die Wayland nativ unterstützen, sollten ohne Probleme laufen und alle relevanten Wayland-Protokolle (z.B. `xdg-shell` für Fensterdekorationen, `input-method-unstable-v2` für Eingabemethoden) nutzen können.
    - **X11-Anwendungen:** Unterstützung über XWayland ist kritisch für die Abwärtskompatibilität.15 Die Performance und Stabilität von XWayland muss für gängige Anwendungen sichergestellt sein. Probleme, die bei der Nutzung von XWayland auftreten (z.B. Fensterdekorationen, globale Tastenkürzel, Screen-Sharing bei bestimmten Apps 15), müssen aktiv angegangen oder klar dokumentiert werden.
    - **Electron-basierte Anwendungen:** Diese laufen oft standardmäßig unter X11 (via XWayland) oder können mit Flags (`--enable-features=UseOzonePlatform --ozone-platform=wayland`) für native Wayland-Unterstützung gestartet werden. NovaDE sollte beide Szenarien unterstützen.
- **Freedesktop.org Standards:** Die Einhaltung von Freedesktop.org-Standards ist fundamental für eine gute Integration:
    - **Desktop Entries (`.desktop`-Dateien):** Für die Anzeige von Anwendungen in Menüs und Startern, inklusive Aktionen und MIME-Typ-Assoziationen.
    - **Icon Themes:** Korrekte Handhabung von Icon-Themes gemäß der Spezifikation.
    - **MIME Types:** Systemweite Datenbank für MIME-Typen und deren zugeordnete Anwendungen.
    - **Notifications:** Empfang und Anzeige von Benachrichtigungen gemäß der Freedesktop Notification Specification.
- **XDG Desktop Portals:** Für sandboxed Anwendungen (Flatpak, Snap) sind XDG Desktop Portals der Standardmechanismus, um sicher auf Systemressourcen zuzugreifen.6 NovaDE muss die notwendigen Portal-Backends bereitstellen oder sicherstellen, dass generische Backends (wie `xdg-desktop-portal-gtk`) korrekt funktionieren. Dies betrifft Funktionen wie:
    - Dateiauswahl (`org.freedesktop.portal.FileChooser`).
    - Öffnen von URIs (`org.freedesktop.portal.OpenURI`).
    - Drucken (`org.freedesktop.portal.Print`).
    - Screen-Sharing und -Aufnahme (`org.freedesktop.portal.ScreenCast`), oft in Verbindung mit PipeWire.12
    - Globale Einstellungen (`org.freedesktop.portal.Settings`).

### 7.3. Sicherheitsrichtlinien für Erweiterungen und Plugins

Die Sicherheit von Erweiterungen und Plugins ist von größter Bedeutung, da sie potenziell tief in das System eingreifen können.

- **Berechtigungsmodell:**
    - Falls ein Plugin-System existiert, muss ein klares Berechtigungsmodell definiert werden. Welche Ressourcen und APIs darf ein Plugin standardmäßig nutzen?
    - Können Benutzer Berechtigungen für Plugins granular verwalten?
    - Das Prinzip der geringsten Rechte (Least Privilege) muss angewendet werden: Ein Plugin sollte nur die Berechtigungen erhalten, die es für seine Funktion unbedingt benötigt.
- **Code-Review und Vetting:**
    - Für offiziell unterstützte oder in einem Community-Repository angebotene Plugins sollte ein Code-Review-Prozess etabliert werden, um Sicherheitslücken und bösartigen Code zu identifizieren.
    - Klare Richtlinien für die Aufnahme von Plugins in offizielle Repositories.
- **Richtlinien für sichere Plugin-Entwicklung:**
    - **Eingabevalidierung:** Alle Eingaben, die ein Plugin von externen Quellen oder dem Benutzer erhält, müssen sorgfältig validiert werden.
    - **Ausgabesanitisierung:** Daten, die von einem Plugin an andere Systemteile oder zur Anzeige weitergegeben werden, müssen ggf. sanitisiert werden.
    - **Fehlerbehandlung:** Robuste Fehlerbehandlung, um Abstürze oder instabile Zustände zu vermeiden.
    - **Ressourcenmanagement:** Sorgfältiger Umgang mit Speicher und anderen Systemressourcen, um Lecks oder übermäßige Nutzung zu vermeiden.
- **Sandboxing (falls möglich):** Wenn technisch machbar, sollten Plugins in einer Sandbox-Umgebung ausgeführt werden, um ihren Zugriff auf das System zu beschränken.
- **Anlehnung an MCP-Sicherheitsprinzipien:** Die für das Model Context Protocol diskutierten Sicherheitsüberlegungen 19 sind auch für NovaDE-Plugins relevant, falls diese signifikante Fähigkeiten haben:
    - **Starke Authentifizierung:** Falls Plugins als separate Prozesse laufen oder von extern geladen werden, Mechanismen zur Verifizierung ihrer Identität.
    - **Bereichsbezogene Autorisierung:** Ein Plugin, das z.B. nur das Wetter anzeigt, benötigt keinen Zugriff auf das Dateisystem.
    - **Ratenbegrenzung:** Verhindern, dass ein fehlerhaftes oder bösartiges Plugin das System durch exzessive API-Aufrufe lahmlegt.

Ein kompromittiertes Plugin kann die Sicherheit der gesamten Desktop-Umgebung untergraben. Daher müssen diese Richtlinien streng durchgesetzt und Entwickler entsprechend geschult werden.

## 8. Anhang

### 8.1. Glossar technischer Begriffe

|   |   |
|---|---|
|**Begriff**|**Definition**|
|**API**|Application Programming Interface: Eine Schnittstelle, die von einer Softwarekomponente bereitgestellt wird, damit andere Softwarekomponenten mit ihr interagieren können.|
|**ALSA**|Advanced Linux Sound Architecture: Eine Kernel-Komponente für Soundkarten-Treiber und eine API für Audio-Anwendungen.12|
|**Compositor**|Eine Software, die die grafischen Ausgaben verschiedener Anwendungen entgegennimmt und zu einem Gesamtbild für den Bildschirm zusammensetzt. Unter Wayland ist der Compositor auch der Display-Server.5|
|**Crate**|Eine Kompilierungs-Einheit in Rust, entweder eine Bibliothek oder eine ausführbare Datei.|
|**CSS**|Cascading Style Sheets: Eine Stylesheet-Sprache, die verwendet wird, um das Aussehen von Dokumenten (typischerweise Webseiten, aber auch GTK4-Anwendungen) zu beschreiben.27|
|**D-Bus**|Ein Nachrichtenbus-System, das die Interprozesskommunikation (IPC) zwischen Anwendungen und Diensten unter Linux ermöglicht.8|
|**DRM**|Direct Rendering Manager: Ein Subsystem des Linux-Kernels, das eine Schnittstelle zu modernen Grafikkarten für Operationen wie Mode-Setting und Speicherverwaltung bereitstellt. Wayland-Compositoren nutzen DRM direkt.5|
|**EGL**|Eine Schnittstelle zwischen Khronos Rendering APIs (wie OpenGL ES oder OpenVG) und dem zugrundeliegenden nativen Plattform-Fenstersystem. Wayland-Compositoren verwenden EGL.6|
|**evdev**|Ein generisches Eingabeereignis-Interface im Linux-Kernel, das Roh-Eingabeereignisse von Geräten wie Tastaturen, Mäusen und Touchscreens bereitstellt.5|
|**FFI**|Foreign Function Interface: Ein Mechanismus, mit dem eine in einer Programmiersprache geschriebene Funktion von einer anderen Programmiersprache aufgerufen werden kann.|
|**Freedesktop.org (XDG)**|Ein Projekt, das Standards und Spezifikationen für die Interoperabilität von Desktop-Umgebungen unter Linux und anderen Unix-artigen Systemen entwickelt.|
|**GSettings**|Ein High-Level-API für Einstellungen in GLib-basierten Anwendungen, das typischerweise DConf als Backend verwendet.|
|**GTK (GIMP Toolkit)**|Ein plattformübergreifendes Widget-Toolkit zur Erstellung grafischer Benutzeroberflächen. GTK4 ist die aktuelle Hauptversion.28|
|**IPC**|Inter-Process Communication: Mechanismen, die es verschiedenen Prozessen ermöglichen, miteinander zu kommunizieren und Daten auszutauschen.|
|**KMS**|Kernel Mode Setting: Ein Verfahren, bei dem der Kernel für die Einstellung des Anzeigemodus (Auflösung, Farbtiefe, Bildwiederholfrequenz) zuständig ist, anstatt des X-Servers oder eines Userspace-Treibers.6|
|**libinput**|Eine Bibliothek, die Eingabegeräte über Kernel-Events (wie evdev) verarbeitet und eine standardisierte Schnittstelle für Wayland-Compositoren und X.Org-Treiber bereitstellt.|
|**MCP**|Model Context Protocol: Ein offener Standard, der die strukturierte Interaktion von KI-Modellen mit externen Daten und Diensten ermöglicht.17|
|**Meson**|Ein Build-System, das auf Benutzerfreundlichkeit, Geschwindigkeit und die Erzeugung korrekter Builds ausgelegt ist. Wird oft für C/C++-Projekte und zunehmend auch für Rust-Projekte in Kombination mit Cargo verwendet.34|
|**NFR**|Non-Functional Requirement: Eine Anforderung, die beschreibt, wie ein System eine bestimmte Funktion ausführen soll (z.B. Performance, Sicherheit), im Gegensatz zu funktionalen Anforderungen, die beschreiben, was das System tun soll.45|
|**PAM**|Pluggable Authentication Modules: Ein Mechanismus unter Linux, der es ermöglicht, Authentifizierungsdienste modular zu integrieren.|
|**PipeWire**|Ein Server und eine API für die Verarbeitung von Audio- und Videoströmen unter Linux. Es zielt darauf ab, PulseAudio und JACK zu ersetzen und bietet geringe Latenz und Flexibilität.12|
|**Rust**|Eine Systemprogrammiersprache, die auf Sicherheit (insbesondere Speichersicherheit) und Performance ausgelegt ist.|
|**rustdoc**|Das Standardwerkzeug in Rust zur Generierung von Dokumentation aus Quellcode-Kommentaren.61|
|**Shell (Desktop Shell)**|Die grafische Benutzeroberfläche einer Desktop-Umgebung, die Elemente wie Panels, Anwendungsstarter und Fensterdekorationen bereitstellt.|
|**Smithay**|Eine Rust-Bibliothek zur Erstellung von Wayland-Compositoren und Utilities.5|
|**Wayland**|Ein Kommunikationsprotokoll, das die Kommunikation zwischen einem Display-Server (dem Wayland-Compositor) und seinen Clients (Anwendungen) spezifiziert. Es soll X11 ersetzen.5|
|**WirePlumber**|Ein modularer Session- und Policy-Manager für PipeWire, der Verbindungen zwischen Geräten und Streams verwaltet und Richtlinien durchsetzt.13|
|**XDG Desktop Portals**|Eine Schnittstelle, die es sandboxed Anwendungen (wie Flatpak oder Snap) ermöglicht, sicher auf Ressourcen außerhalb ihrer Sandbox zuzugreifen (z.B. Dateiauswahl, Drucken).6|
|**XSettings**|Ein Protokoll für X11, das es ermöglicht, Einstellungen (wie Theme, Schriftarten) systemweit zu teilen. GTK kann XSettings unter X11 oder XWayland nutzen.9|
|**XWayland**|Ein X-Server, der als Wayland-Client läuft und es ermöglicht, X11-Anwendungen in einer Wayland-Sitzung auszuführen.15|

### 8.2. Referenzierte Dokumente und Standards

- **Rust Language & Tooling:**
    - The Rust Programming Language Book: [https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)
    - Rust API Guidelines: [https://rust-lang.github.io/api-guidelines/](https://rust-lang.github.io/api-guidelines/) (21)
    - Rust Style Guide: [https://doc.rust-lang.org/nightly/style-guide/](https://doc.rust-lang.org/nightly/style-guide/) (22)
    - Rustdoc - How to write documentation: [https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html](https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html) (63)
    - Cargo Book: [https://doc.rust-lang.org/cargo/](https://doc.rust-lang.org/cargo/)
    - The `thiserror` Crate: [https://crates.io/crates/thiserror](https://crates.io/crates/thiserror)
    - The `anyhow` Crate: [https://crates.io/crates/anyhow](https://crates.io/crates/anyhow)
- **Wayland & Compositing:**
    - Wayland Protocol Documentation: [https://wayland.freedesktop.org/docs/html/](https://wayland.freedesktop.org/docs/html/) (6)
    - Smithay Project:(https://github.com/Smithay/smithay) (24)
    - Smithay Documentation (master): [https://smithay.github.io/smithay/smithay/](https://smithay.github.io/smithay/smithay/) (25)
    - XDG Shell Protocol: [https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/stable/xdg-shell/xdg-shell.xml](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/stable/xdg-shell/xdg-shell.xml)
- **GTK4 & UI:**
    - GTK4 API Reference: [https://docs.gtk.org/gtk4/](https://docs.gtk.org/gtk4/) (28)
    - GTK4 Rust Bindings (`gtk4-rs`): [https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/](https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/) (7)
    - GTK CSS Properties: [https://docs.gtk.org/gtk4/css-properties.html](https://docs.gtk.org/gtk4/css-properties.html) (27)
- **Interprozesskommunikation & Multimedia:**
    - D-Bus Specification: [https://dbus.freedesktop.org/doc/dbus-specification.html](https://dbus.freedesktop.org/doc/dbus-specification.html) (14)
    - PipeWire Documentation: [https://pipewire.org/](https://pipewire.org/) (12)
    - WirePlumber Documentation: [https://pipewire.pages.freedesktop.org/wireplumber/](https://pipewire.pages.freedesktop.org/wireplumber/)
- **Freedesktop.org Standards:**
    - Desktop Entry Specification: [https://specifications.freedesktop.org/desktop-entry-spec/latest/](https://specifications.freedesktop.org/desktop-entry-spec/latest/)
    - Icon Theme Specification: [https://specifications.freedesktop.org/icon-theme-spec/latest/](https://specifications.freedesktop.org/icon-theme-spec/latest/)
    - Desktop Notifications Specification: [https://specifications.freedesktop.org/notification-spec/latest/](https://specifications.freedesktop.org/notification-spec/latest/)
    - XDG Base Directory Specification: [https://specifications.freedesktop.org/basedir-spec/latest/](https://specifications.freedesktop.org/basedir-spec/latest/)
    - XDG Desktop Portal Documentation: [https://flatpak.github.io/xdg-desktop-portal/docs/](https://flatpak.github.io/xdg-desktop-portal/docs/)
- **Build System:**
    - Meson Build System Manual: [https://mesonbuild.com/Manual.html](https://mesonbuild.com/Manual.html) (35)
- **Model Context Protocol (MCP) (falls zutreffend):**
    - MCP Introduction (Stytch Blog): 17
    - MCP Overview (OpenCV Blog): 18
    - MCP Security Considerations (Writer Engineering Blog): 19
- **Software Development Best Practices (Allgemein):**
    - OpsLevel - Standards in Software Development: 47
    - Bocasay - Guide to Writing Functional and Technical Specifications: 1
    - Heretto - Technical Specifications: 2
    - WWG - How to Write a Technical Specification: 58
    - Document360 - Software Architecture Documentation: 3
    - Softkraft - How to Write Software Requirements: 4
    - Pulsion - Software Development Best Practices: 48

### Tabelle 4: Konfigurationsparameter und Standardwerte (Auszug/Beispiel)

Diese Tabelle dient als Referenz für wichtige konfigurierbare Parameter innerhalb von NovaDE. Eine vollständige Liste wird im Laufe der Entwicklung gepflegt und erweitert.

|   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|
|**Parametername**|**Komponente**|**Beschreibung**|**Datentyp**|**Standardwert**|**Erlaubte Werte / Bereich**|**Geltungsbereich**|
|`gtk-theme-name`|GTK Settings|Name des zu verwendenden GTK-Themes.|String|"NovaDE-Default"|Name eines installierten GTK-Themes (z.B. "Adwaita", "NovaDE-Dark")|User/System|
|`gtk-font-name`|GTK Settings|Standardschriftart und -größe (z.B. "Cantarell 11").|String|"Sans 10"|Gültige Pango-Schriftartbeschreibung|User/System|
|`gtk-application-prefer-dark-theme`|GTK Settings|Ob Anwendungen ein dunkles Theme bevorzugen sollen, falls vom Theme unterstützt.9|Boolean|`false`|`true`, `false`|User|
|`org.novade.compositor.enableAnimations`|NovaDE Compositor|Aktiviert/Deaktiviert Fensteranimationen (z.B. Minimieren, Öffnen).|Boolean|`true`|`true`, `false`|User|
|`org.novade.compositor.animationSpeedFactor`|NovaDE Compositor|Faktor zur Skalierung der Animationsgeschwindigkeit (1.0 = normal).|Float|`1.0`|`0.1` - `5.0`|User|
|`org.novade.shell.panel.position`|NovaDE Shell|Position des Hauptpanels auf dem Bildschirm.|Enum|"top"|"top", "bottom", "left", "right"|User|
|`org.novade.shell.panel.autohide`|NovaDE Shell|Ob das Panel automatisch ausgeblendet werden soll.|Boolean|`false`|`true`, `false`|User|
|`org.novade.notifications.popupTimeoutSeconds`|NovaDE Notification Service|Anzeigedauer von Benachrichtigungs-Popups in Sekunden (0 = manuell schließen).|Integer|`5`|`0` - `60`|User|
|`org.novade.power.suspendOnIdleMinutes`|NovaDE Power Manager|Zeit in Minuten, nach der das System bei Inaktivität in den Suspend-Modus wechselt (0 = deaktiviert).|Integer|`30`|`0` - `1440`|User|
|`org.novade.input.mouse.accelerationProfile`|NovaDE Settings Daemon (Input)|Beschleunigungsprofil für die Maus.|Enum|"adaptive"|"adaptive", "flat"|User|
|`pipewire.alsa.force-rate`|PipeWire (ALSA Emulation)|Erzwingt eine bestimmte Samplerate für ALSA-Anwendungen (z.B. 48000 Hz).|Integer|`0` (auto)|`0`, `44100`, `48000`, `96000` etc. (siehe PipeWire Doku)|System/User|
|`pipewire.bluetooth.autoswitch-to-headset-profile`|PipeWire (WirePlumber Bluetooth Config)|Automatisches Umschalten auf HSP/HFP-Profil bei eingehendem Anruf/Aufnahme.13|Boolean|`true`|`true`, `false`|User|

Diese Tabelle ist entscheidend für Administratoren, fortgeschrittene Benutzer und Entwickler, um das Systemverhalten zu verstehen, anzupassen und Fehler zu diagnostizieren. Sie zentralisiert Informationen, die andernfalls über verschiedene Komponentendokumentationen verstreut wären, und verbessert so die Transparenz und Verwaltbarkeit von NovaDE.39

## 9. Schlussfolgerungen und Empfehlungen

Diese Technische Gesamtspezifikation und Richtliniensammlung für NovaDE legt den Grundstein für eine strukturierte, qualitativ hochwertige und zukunftssichere Entwicklung der Desktop-Umgebung. Durch die detaillierte Ausarbeitung der Architektur, der Kernkomponenten, der nicht-funktionalen Anforderungen, der Schnittstellen und der Entwicklungsrichtlinien wird ein gemeinsames Verständnis geschaffen und ein Rahmen für alle Beteiligten etabliert.

**Wesentliche Prinzipien und Erkenntnisse:**

1. **Modularität und klare Schnittstellen:** Die Zerlegung von NovaDE in klar definierte Kernkomponenten mit wohldefinierten Schnittstellen (primär D-Bus und Wayland) ist fundamental für Wartbarkeit, Testbarkeit und parallele Entwicklung.1 Die Verwendung von Rust fördert zusätzlich die Erstellung sicherer und performanter Module.
2. **Technologische Basis:** Die Wahl von Wayland, Smithay, GTK4, PipeWire und Rust als Kerntechnologien positioniert NovaDE als moderne und leistungsfähige Desktop-Umgebung. Dies bringt jedoch auch spezifische Herausforderungen mit sich (z.B. Wayland-Adoption, Komplexität von Smithay als Bibliothek), die kontinuierliche Aufmerksamkeit erfordern.5
3. **Nicht-funktionale Anforderungen (NFRs):** Performance, Stabilität, Sicherheit und Benutzbarkeit sind keine nachrangigen Aspekte, sondern müssen von Beginn an in Design und Implementierung berücksichtigt und durch messbare Kriterien spezifiziert werden.45
4. **Entwicklungsdisziplin:** Die Einhaltung der festgelegten Programmierrichtlinien (insbesondere der Rust API und Style Guides), des Code-Review-Prozesses und der Teststrategie ist unerlässlich für die langfristige Gesundheit des Projekts.21
5. **Lebendige Dokumentation:** Diese Spezifikation und die zugehörige API-Dokumentation (`rustdoc`) müssen kontinuierlich gepflegt und als integraler Bestandteil des Entwicklungsprozesses behandelt werden. Veraltete Dokumentation ist ein erhebliches Projektrisiko.3 Die Verknüpfung von UX-Anforderungen mit technischen Spezifikationen ist hierbei ein wichtiger Aspekt.66
6. **Sicherheit als Fundament:** Insbesondere bei Systemkomponenten wie einem Compositor und bei der Integration von Erweiterungen oder Protokollen wie MCP müssen Sicherheitsaspekte (Least Privilege, Sandboxing, Validierung) höchste Priorität haben.19
7. **Iterative Entwicklung und Anpassungsfähigkeit:** Die Softwareentwicklung, insbesondere für ein komplexes System wie eine Desktop-Umgebung, ist ein iterativer Prozess. Die hier festgelegten Richtlinien sollten Flexibilität für Anpassungen und Weiterentwicklungen ermöglichen, beispielsweise durch agile Methoden und die Bereitschaft, auf Feedback und neue technologische Entwicklungen zu reagieren.65

**Empfehlungen für die weitere Vorgehensweise:**

1. **Implementierung der Kernarchitektur:** Fokus auf die stabile Implementierung des Wayland-Compositors, der grundlegenden Shell-Funktionen und der D-Bus-basierten Dienste als Fundament.
2. **Aufbau der CI/CD-Infrastruktur:** Frühzeitige Einrichtung von CI/CD-Pipelines, um automatisierte Tests und Qualitätsprüfungen von Beginn an zu etablieren.47
3. **Detaillierte API-Spezifikation und -Dokumentation:** Parallele Entwicklung der `rustdoc`-API-Dokumentation für alle öffentlichen Schnittstellen der Kern-Crates.
4. **Kontinuierliche Überprüfung und Anpassung dieser Spezifikation:** Regelmäßige Reviews dieses Dokuments im Entwicklungsteam, um sicherzustellen, dass es den aktuellen Stand und die zukünftige Ausrichtung von NovaDE widerspiegelt.
5. **Community-Einbindung (falls zutreffend):** Bei Open-Source-Projekten ist die frühzeitige Einbindung einer Community für Feedback und Beiträge wertvoll. Klare Dokumentation und Richtlinien sind hierfür eine Voraussetzung.

Die konsequente Anwendung der in diesem Dokument dargelegten Prinzipien und Richtlinien wird maßgeblich dazu beitragen, dass NovaDE zu einer robusten, performanten und benutzerfreundlichen Desktop-Umgebung wird, die den Anforderungen der Nutzer gerecht wird und eine solide Basis für zukünftige Erweiterungen bietet.


**Allgemeine Projekt-Gesamtspezifikation: Linux Desktop-Umgebung "NovaDE"**

**I. Vision und Projektziele**

- **Vision:** NovaDE (Nova Desktop Environment) ist eine innovative Linux-Desktop-Umgebung, die eine moderne, schnelle, intuitive und KI-gestützte Benutzererfahrung schafft. Sie ist optimiert für Entwickler, Kreative und alltägliche Nutzer und zielt darauf ab, Produktivität und Freude an der Interaktion mit dem System zu maximieren.
- **Kernziele:**
    1. **Performance:** Eine durchgehend schnelle und reaktionsschnelle Umgebung ohne spürbare Verzögerungen.
    2. **Intuition:** Eine Benutzeroberfläche, die sich natürlich anfühlt, leicht erlernbar ist und den Nutzer intelligent unterstützt, ohne bevormundend zu wirken.
    3. **Modernität:** Einsatz aktueller Technologien und Designprinzipien, um eine zeitgemäße und zukunftssichere Plattform zu bieten.
    4. **Modularität & Wartbarkeit:** Eine klare Architektur, die einfache Erweiterbarkeit, Testbarkeit und Wartung ermöglicht.
    5. **Anpassbarkeit:** Dem Benutzer weitreichende Möglichkeiten zur Personalisierung des Erscheinungsbildes und Verhaltens der Umgebung bieten.
    6. **KI-Integration:** Nahtlose und sichere Integration von KI-Funktionen als hilfreiche Assistenz, stets unter voller Benutzerkontrolle.
    7. **Stabilität & Sicherheit:** Höchste Priorität auf Systemstabilität und Datensicherheit durch den Einsatz geeigneter Technologien und Entwicklungspraktiken.

**II. Architektonischer Überblick: Geschichtete Architektur**

NovaDE basiert auf einer strengen, vier-schichtigen Architektur, um Modularität, lose Kopplung und hohe Kohäsion innerhalb der Schichten zu gewährleisten. Jede Schicht hat klar definierte Verantwortlichkeiten und kommuniziert mit anderen Schichten ausschließlich über wohldefinierte Schnittstellen.

1. **Kernschicht (Core Layer)**
    
    - **Verantwortlichkeiten:** Enthält die absolut grundlegendsten, systemweit genutzten Elemente. Dies umfasst:
        - Fundamentale Datentypen (z.B. `Point<T>`, `Size<T>`, `Rect<T>`, `Color`, `WorkspaceId`, `WindowIdentifier`, `TokenIdentifier`, `SettingKey`).
        - Allgemeine Dienstprogramme und Hilfsfunktionen (z.B. String-Manipulation, mathematische Helfer, die keine spezifische Domänenlogik enthalten).
        - Basis-Infrastruktur für Konfigurationsparsing und -zugriff (Primitive zum Laden/Speichern, aber nicht die Konfigurationswerte selbst).
        - Initialisierung und Konfiguration des globalen Logging-Frameworks (`tracing`).
        - Allgemeine Fehlerdefinitionen und -Traits (z.B. ein Basis-`CoreError`-Enum mit `thiserror`), die als Grundlage für spezifischere Fehler in höheren Schichten dienen.
    - **Abhängigkeiten:** Keine Abhängigkeiten zu anderen Schichten von NovaDE. Minimale externe Abhängigkeiten (Rust `std`, `uuid`, `chrono`, `thiserror`, `tracing`, `serde`, `toml`, `once_cell`).
    - **Interaktionen:** Stellt seine Funktionalität allen darüberliegenden Schichten (Domäne, System, UI) zur Verfügung.
2. **Domänenschicht (Domain Layer)**
    
    - **Verantwortlichkeiten:** Beinhaltet die gesamte Kernlogik und die Geschäftsregeln der Desktop-Umgebung, unabhängig von spezifischen UI-Implementierungen oder Systemdetails (wie D-Bus oder Wayland-Protokollen). Dies umfasst:
        - **`domain::theming`:** Logik der Theming-Engine, Verwaltung von Design-Tokens (`TokenIdentifier`, `TokenValue`, `RawToken`, `ThemeDefinition`), Regeln zur Anwendung von Themes (Hell/Dunkel, Akzentfarben), dynamische Theme-Wechsel. Stellt den `AppliedThemeState` bereit.
        - **`domain::workspaces`:** Umfassende Verwaltungslogik für Arbeitsbereiche ("Spaces"). Definiert die `Workspace`-Entität, Regeln für die Zuweisung von Fenstern (`WindowIdentifier`) zu `WorkspaceId`s, Orchestrierung aller Workspaces (`WorkspaceManager`), Verwaltung des aktiven Workspace und Persistenz der Workspace-Konfiguration (`WorkspaceConfigProvider`, `WorkspaceSnapshot`).
        - **`domain::user_centric_services`:**
            - **KI-Interaktionsmanagement:** Logik für KI-Interaktionen (`AIInteractionContext`), Verwaltung von Benutzereinwilligungen (`AIConsent`, `AIConsentStatus`) für KI-Modelle und Datenkategorien (`AIDataCategory`), Verwaltung von KI-Modellprofilen (`AIModelProfile`).
            - **Benachrichtigungsmanagement:** Kernlogik zur Verwaltung von Benachrichtigungen (`Notification`, `NotificationAction`), Historie, Filterung, Priorisierung (`NotificationUrgency`), "Bitte nicht stören"-Modus.
        - **`domain::notifications_rules`:** Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf konfigurierbaren Regeln (`NotificationRule`, `RuleCondition`, `RuleAction`).
        - **`domain::global_settings_and_state_management`:** Repräsentation, Logik zur Verwaltung und Konsistenz globaler Desktop-Einstellungen (`GlobalDesktopSettings`, `SettingPath`, `SettingValue`). Validierung und Persistenz von Einstellungen (delegiert an Kernschicht).
        - **`domain::window_management_policy`:** Definition von High-Level-Regeln und Richtlinien für Fensterplatzierung, Logik für automatisches Tiling (Layout-Typen wie Spalten, Spiralen), Snapping-Verhalten, Fenstergruppierung und Gap-Management. _Diese Schicht definiert die "Policy", die Systemschicht die "Mechanik"._
    - **Abhängigkeiten:** Nutzt ausschließlich die Kernschicht.
    - **Interaktionen:** Stellt Logik, Zustand und Geschäftsregeln für die Systemschicht und die Benutzeroberflächenschicht bereit, oft über definierte Service-Traits und durch das Aussenden von domain-spezifischen Events (z.B. `ThemeChangedEvent`, `WorkspaceEvent`, `SettingChangedEvent`).
3. **Systemschicht (System Layer)**
    
    - **Verantwortlichkeiten:** Implementiert die Interaktion mit dem zugrundeliegenden Betriebssystem, der Hardware und externen Systemdiensten. Setzt die von der Domänenschicht definierten Richtlinien technisch um.
        - **`system::compositor`:** Smithay-basierter Wayland-Compositor. Verwaltung von Wayland-Clients, Oberflächen (`WlSurface`), Pufferbehandlung (SHM, DMABUF), Implementierung von Wayland-Protokollen serverseitig (`xdg-shell`, `wlr-layer-shell-unstable-v1`, `xdg-decoration-unstable-v1`, `wlr-output-management-unstable-v1`, `wlr-output-power-management-unstable-v1` etc.), XWayland-Integration. Orchestriert das Rendering (delegiert an Renderer-Interface).
        - **`system::input`:** `libinput`-basierte Eingabeverarbeitung. Verarbeitung von Tastatur-, Maus-, Touchpad-Ereignissen. Gestenerkennung. Seat-Management (`SeatState`, `SeatHandler`), Fokus-Handling auf Wayland-Ebene, xkbcommon-Integration für Tastaturlayouts.
        - **`system::dbus`:** Schnittstellenmodule (via `zbus`) für die Interaktion mit System-D-Bus-Diensten: `NetworkManager`, `UPower`, `logind`, `org.freedesktop.Notifications` (Service-Seite, die `domain::user_centric_services::NotificationService` nutzt), `org.freedesktop.secrets` (Freedesktop Secret Service API), `PolicyKit (polkit)`. Enthält D-Bus Service- und Client-Implementierungen.
        - **`system::outputs`:** Verwaltung von Anzeigeausgängen. Implementierung der Server-Seite von `wlr-output-management-unstable-v1` und `wlr-output-power-management-unstable-v1`. Handhabung von Monitorkonfigurationen (Auflösung, Position, Aktivierung, Skalierung, DPMS).
        - **`system::audio`:** Client-Integration für PipeWire (via `pipewire-rs`) zur Steuerung der Systemlautstärke, Auswahl von Audio-Geräten und Verwaltung von Anwendungs-Streams.
        - **`system::mcp`:** Implementierung des Model Context Protocol (MCP) Clients (via `mcp_client_rs`), der die sichere Kommunikation mit MCP-Servern (lokal oder remote) abwickelt, basierend auf Anweisungen und Kontextdaten aus `domain::user_centric_services::AIInteractionLogicService`.
        - **`system::portals`:** Backend-Implementierung für XDG Desktop Portals (`org.freedesktop.portal.FileChooser`, `org.freedesktop.portal.Screenshot` etc.) zur Bereitstellung sicherer Schnittstellen für sandboxed und native Anwendungen.
        - **`system::window_mechanics`:** Konkrete Implementierung der Fenstermanagement-"Mechanik" basierend auf den Richtlinien aus `domain::window_management_policy`. Dies umfasst Fensterpositionierung, Größenänderung, Stapelreihenfolge, Anwendung von Tiling-Layouts, Fokusübergänge und die technische Umsetzung von Fensterdekorationen (serverseitig falls SSD oder in Koordination mit CSD). Stellt die technische Basis für die "Intelligente Tab-Leiste" bereit, indem sie Fensterinformationen und Gruppierungen verwaltet.
    - **Abhängigkeiten:** Nutzt Funktionalität der Kernschicht und der Domänenschicht (z.B. um Domänenregeln anzuwenden, Zustände abzufragen, Konfigurationen zu lesen).
    - **Interaktionen:** Stellt systemnahe Dienste und Ereignisse für die Benutzeroberflächenschicht bereit (z.B. Fenstergeometrie, Eingabeereignisse, Statusänderungen von Systemdiensten). Empfängt Befehle von der UI-Schicht (z.B. Fenster verschieben, Space wechseln, Fokus anfordern) und setzt diese technisch um.
4. **Benutzeroberflächenschicht (User Interface Layer)**
    
    - **Verantwortlichkeiten:** Ist verantwortlich für die Darstellung der gesamten grafischen Benutzeroberfläche und die direkte Interaktion mit dem Benutzer. Basiert vollständig auf GTK4 und den `gtk4-rs` Bindings.
        - **`ui::shell`:** Implementierung der Haupt-Shell-UI:
            - `PanelWidget`: Kontroll- und Systemleiste(n) mit Modulen (`AppMenuButton`, `WorkspaceIndicatorWidget`, `ClockDateTimeWidget`, `SystemTrayEquivalentWidget`, `QuickSettingsButtonWidget`, `NotificationCenterButtonWidget`, `NetworkIndicatorWidget`, `PowerIndicatorWidget`, `AudioIndicatorWidget`).
            - `SmartTabBarWidget`: Intelligente Tab-Leiste pro "Space" mit `ApplicationTabWidget`s.
            - `QuickSettingsPanelWidget`: Ausklappbares Panel für Schnelleinstellungen.
            - `WorkspaceSwitcherWidget`: Adaptive linke Seitenleiste mit `SpaceIconWidget`s zur Navigation zwischen "Spaces".
            - `QuickActionDockWidget`: Konfigurierbares Dock für Schnellzugriffe mit `DockItemWidget`s.
            - `NotificationCenterPanelWidget`: Anzeige von Benachrichtigungsliste und -historie mit `NotificationWidget`s.
        - **`ui::control_center`:** Modulare GTK4-Anwendung für alle Systemeinstellungen (`AppearanceSettingsWidget`, `NetworkSettingsWidget` etc.).
        - **`ui::widgets`:** Implementierung des Widget-Systems:
            - `RightSidebarWidget`: Adaptive rechte Seitenleiste.
            - `WidgetManagerService` (logische UI-Komponente).
            - `WidgetPickerPopover`.
            - `PlacedWidgetWidget` und `ActualWidget` (Basis für `ClockWidget`, `CalendarWidget`, `WeatherWidget`, `SystemMonitorWidget` etc.).
        - **`ui::window_manager_frontend`:** UI-Aspekte des Fenstermanagements:
            - Client-Side Decorations (CSD) Logik (z.B. via `Gtk::HeaderBar`).
            - `OverviewModeWidget`: Fenster- und Workspace-Übersicht.
            - `AltTabSwitcherWidget`: Traditioneller Fensterwechsler.
        - **`ui::notifications_frontend`:** `NotificationPopupWidget` zur Anzeige von Pop-up-Benachrichtigungen.
        - **`ui::theming_gtk`:** Anwendung der von `domain::theming` generierten CSS-Stile auf GTK-Widgets über `Gtk::CssProvider`. Logik zur Anforderung von Theme-Wechseln.
        - **`ui::components`:** Sammlung wiederverwendbarer, anwendungsspezifischer GTK4-Widgets (z.B. `StyledButtonWidget`, `ModalDialogWidget`).
        - **`ui::speed_dial`:** GTK4-Implementierung der Speed-Dial-Startansicht für leere Workspaces.
        - **`ui::command_palette`:** GTK4-Implementierung der kontextuellen Befehlspaletten-UI (`CommandPalettePopover`).
    - **Abhängigkeiten:** Nutzt Funktionalität aller darunterliegenden Schichten (Kern, Domäne, System).
    - **Interaktionen:** Empfängt Eingabeereignisse von der Systemschicht. Visualisiert Zustände und Daten aus der Domänen- und Systemschicht. Löst Aktionen und Zustandsänderungen in der Domänen- und Systemschicht aus, basierend auf Benutzerinteraktionen. Abonniert Events der unteren Schichten, um sich dynamisch zu aktualisieren.

**III. Technologie-Stack (Verbindliche Auswahl)**

|Bereich|Technologie/Standard|Begründung|
|:--|:--|:--|
|Programmiersprache|**Rust**|Überlegene Speichersicherheit ohne Garbage Collector, Performance "close-to-the-metal", starkes Typsystem zur Fehlervermeidung zur Kompilierzeit, moderne Nebenläufigkeitskonzepte. Zukunftssichere Wahl für Systemsoftware.|
|Build-System|**Meson**|Modern, einfach, schnell, exzellente Unterstützung für Rust und C/C++ (für externe Abhängigkeiten), Integration von CMake-basierten Abhängigkeiten via Subprojekte (WrapDB, CMake-Modul).|
|GUI-Toolkit|**GTK4** (mit `gtk4-rs` Bindings)|Modernes, aktiv entwickeltes Toolkit mit erstklassiger Wayland-Unterstützung, robusten Rust-Bindings. CSS-basiertes Theming für flexible und standardisierte Anpassung. Dynamischer Theme-Wechsel zur Laufzeit. Starke Integration ins GNOME-Ökosystem.|
|Wayland Compositor & Bibliotheken|**Smithay Toolkit**|In Rust geschriebene Bibliothek zum Erstellen von Wayland-Compositoren. Perfekte Passung zur Hauptprogrammiersprache Rust, vermeidet C-Bindings für Kernkomponenten des Compositors. Modular, flexibel, aktive Entwicklung, Fokus auf Sicherheit.|
|Essentielle Wayland-Protokolle|`wayland.xml` (Basis), `xdg-shell` (Fenster), `wlr-layer-shell-unstable-v1` (Shell-UI), `xdg-decoration-unstable-v1` (Dekorationen), `wlr-foreign-toplevel-management-unstable-v1` (Fensterliste), `wlr-output-management-unstable-v1` (Monitore), `wlr-output-power-management-unstable-v1` (Monitor-Energie), `input-method-unstable-v1`, `text-input-unstable-v3` (Eingabemethoden), Wayland Core (Zwischenablage/DND), `presentation-time`, `viewporter`, `linux-dmabuf-unstable-v1`, `idle-notify-unstable-v1`. XWayland für Kompatibilität (unterstützt durch Smithay).|Standardisierte Schnittstellen für alle Kernfunktionen einer Desktop-Umgebung unter Wayland. Die Auswahl von `wlr-*`-Protokollen erfolgt zugunsten der verfügbaren Funktionalität in der Rust/Smithay-Welt.|
|Inter-Prozess-Kommunikation (IPC)|**D-Bus** (mit `zbus` Crate)|De-facto-Standard für IPC im Linux-Desktop-Bereich. Nahtlose Integration mit essenziellen Systemdiensten (NetworkManager, UPower, logind, PolicyKit, Benachrichtigungsdienst, Secret Service).|
|KI-Integration|**Model Context Protocol (MCP)** (mit `mcp_client_rs` Crate)|Offener Standard für sichere, standardisierte Verbindung von KI-Modellen (LLMs) mit externen Werkzeugen und Anwendungen. Client-Server-Architektur, definierte Nachrichtenformate. Ermöglicht Anbindung lokaler und Cloud-basierter Modelle, Benutzerkontrolle über Datenzugriffe.|
|Eingabeverarbeitung|**libinput** (integriert via Smithay)|Standardbibliothek unter Linux für die Verarbeitung von Eingabeereignissen auf niedrigem Niveau. Robuste Unterstützung für Touchpad-Gesten. Konsistente und präzise Eingabebehandlung.|
|Audio-Management|**PipeWire** (mit `pipewire-rs` Crate)|Moderner Standard für Audio- und Video-Management unter Linux. Geringe Latenz, flexible Routing-Möglichkeiten, sandboxed Architektur. Kompatibilitätsschichten für PulseAudio-, JACK- und ALSA-Anwendungen.|
|Geheimnisverwaltung|**Freedesktop Secret Service API** (via D-Bus, z.B. mit `secret-service-rs` Crate)|Standardmechanismus zum sicheren Speichern von sensiblen Daten wie Passwörtern oder API-Schlüsseln. Implementierungen wie GNOME Keyring oder KWallet stellen diesen Dienst bereit.|
|Rechteverwaltung|**PolicyKit (polkit)** (via D-Bus)|Standardmechanismus unter Linux zur Autorisierung privilegierter Aktionen durch unprivilegierte Anwendungen nach Benutzerauthentifizierung.|
|Theming-Implementierung (UI)|**Token-basiertes System**, implementiert über **GTK4 CSS Custom Properties (`var()`)** und `@define-color` (als Fallback/Ergänzung).|Abstraktionsebene über konkreten Designwerten (Farben, Schriftgrößen, Abstände). Änderungen an Token-Definitionen (Domänenschicht) werden zur Laufzeit angewendet, was dynamische Theme-Umschaltung ohne Neustart ermöglicht.|
|Sandboxing-Interaktion|**XDG Desktop Portals** (via D-Bus, z.B. mit `xdg-portal-rs` Crate)|Standardisierte D-Bus-Schnittstellen für sandboxed Anwendungen (und native Apps) zum sicheren Zugriff auf Ressourcen außerhalb ihrer Sandbox (Dateidialoge, Kamera-/Mikrofonzugriff, Screencasting etc.). Backend-Implementierung durch NovaDE.|

In Google Sheets exportieren

**IV. Entwicklungsrichtlinien (Verbindlich)**

Diese Richtlinien gewährleisten Konsistenz, Qualität und Wartbarkeit des Codes über das gesamte Projekt.

1. **Programmiersprache Rust:**
    
    - **Stil und Formatierung:** Verbindliche Nutzung von `rustfmt` mit der Standardkonfiguration des Projekts. Maximale Zeilenlänge: 100 Zeichen. Einrückung: 4 Leerzeichen. Kommentare: `//` bevorzugt, `///` oder `//!` für `rustdoc`.
    - **API-Design:** Strikte Befolgung der Rust API Guidelines Checklist (Namensgebung RFC 430 Casing, Trait-Implementierungen, Fehlerbehandlung, Dokumentation, Generics, Newtypes, Builder-Pattern, private Felder, versiegelte Traits wo sinnvoll).
    - **Fehlerbehandlung:**
        - Ausschließliche Verwendung des `thiserror`-Crates zur Definition von benutzerdefinierten, spezifischen Fehler-Enums pro Modul in allen Schichten.
        - Fehler werden über `Result<T, E>` zurückgegeben.
        - Panics (`unwrap()`, `expect()`) sind in Bibliotheks-/Kern-/Domänen-/System-Code strengstens verboten. Ausnahme: `expect()` in Tests oder bei nachweislich nicht behebbaren internen Invariantenverletzungen mit aussagekräftiger Begründung im `expect()`-Aufruf.
        - `#[error("...")]`-Nachrichten müssen klar, prägnant und kontextbezogen sein. Sensible Daten dürfen niemals in Fehlermeldungen erscheinen.
        - Die `source()`-Kette von Fehlern muss durch korrekte Verwendung von `#[source]` und `#[from]` erhalten bleiben.
    - **Logging & Tracing:**
        - Verbindliche Nutzung des `tracing`-Crate-Frameworks für strukturiertes, kontextbezogenes Logging.
        - Verwendung von Spans (`#[tracing::instrument]`) für wichtige Funktionen und Operationen zur Kontextualisierung.
        - Definition und Einhaltung von Standard-Logging-Levels (ERROR, WARN, INFO, DEBUG, TRACE).
        - Sensible Daten dürfen niemals geloggt werden.
    - **Nebenläufigkeit:** Nutzung von Rusts `async/await` für I/O-gebundene oder langlaufende Operationen, insbesondere in der UI- und Systemschicht, um Blockaden zu vermeiden. Verwendung von `tokio` als primäre asynchrone Runtime, wo eine dedizierte Runtime benötigt wird (z.B. für Netzwerkdienste in der Systemschicht). Für GTK-spezifische asynchrone Aufgaben in der UI-Schicht `glib::MainContext::spawn_local`. Thread-sichere Datenstrukturen (`Arc`, `Mutex` von `parking_lot` oder `std::sync`) für geteilte Zustände.
    - **Crate-Struktur:** Logische Aufteilung des Projekts in mehrere Crates (z.B. `novade-core`, `novade-domain`, `novade-system`, `novade-ui`, sowie spezifische Crates für größere Komponenten wie `novade-compositor`, `novade-shell`). Klare öffentliche APIs (`pub`) und interne Modulstruktur (`pub(crate)`).
2. **Versionskontrolle & Branching:**
    
    - **System:** Git.
    - **Modell:** GitHub Flow. Der `main`-Branch repräsentiert stets den neuesten stabilen, potenziell auslieferbaren Zustand.
    - **Workflow:** Feature-Entwicklung erfolgt in kurzlebigen Branches, die von `main` abzweigen. Pull Requests (PRs) sind für das Mergen in `main` obligatorisch. Jeder PR erfordert mindestens ein positives Code-Review von einem anderen Teammitglied und das Bestehen aller CI-Prüfungen.
    - **Commit-Nachrichten:** Einhaltung der Conventional Commits Spezifikation zur Nachvollziehbarkeit und automatisierten Changelog-Generierung.
3. **Teststrategie:**
    
    - **Unit-Tests:** Obligatorisch für alle Komponenten der Kern- und Domänenschicht sowie für Logik-Komponenten der System- und UI-Schicht. Direkt neben dem zu testenden Code (`#[cfg(test)]`). Hohe Codeabdeckung wird angestrebt.
    - **Integrationstests:** Im `tests/`-Verzeichnis auf Crate-Ebene. Testen das Zusammenspiel verschiedener Module oder Schichten und die Interaktion mit (gemockten) externen Schnittstellen.
    - **Compositor-Tests (Systemschicht):** Evaluierung und Einsatz von verschachtelten/headless Wayland-Backends (unterstützt durch Smithay) oder spezialisierten Test-Clients zur Verifizierung der Kernlogik des Compositors (Fensterplatzierung, Protokollimplementierungen).
    - **UI-Tests (UI-Schicht):** Nutzung von Accessibility-APIs zur Inspektion und Steuerung von Widgets, Simulation von Eingabeereignissen auf Wayland-Ebene. Evaluierung von Frameworks für visuelle Regressionstests für GTK4/Rust.
    - **Continuous Integration (CI) Pipeline:**
        - Automatische Ausführung aller definierten Tests (Unit, Integration) bei jedem Push und PR.
        - Prüfungen für Code-Formatierung (`cargo fmt --check`).
        - Linting (`cargo clippy -- -D warnings` mit projektspezifischer Clippy-Konfiguration).
        - Prüfung auf Sicherheitslücken in Abhängigkeiten (`cargo audit`).
        - Ein Merge in `main` ist nur bei erfolgreichem Durchlauf aller CI-Prüfungen gestattet.
4. **Dokumentation:**
    
    - **Code-Dokumentation (`rustdoc`):**
        - Umfassende `rustdoc`-Kommentare (`///` oder `//!`) sind für alle öffentlichen APIs (Crates, Module, Funktionen, Typen, Felder, Traits) zwingend erforderlich.
        - Dokumentation muss nicht nur beschreiben, _was_ eine Komponente tut, sondern auch _warum_ sie existiert und _wie_ sie korrekt verwendet wird.
        - Muss Erklärungen zur Logik, zu Invarianten, zu möglichen Fehlerbedingungen (`# Errors`-Sektion) und zu Sicherheitsaspekten (`# Safety`-Sektion für `unsafe` Code, der strikt zu minimieren ist) enthalten.
        - Aussagekräftige Code-Beispiele (`#[doc(inline)]` oder in separaten `examples/`-Verzeichnissen) sind essenziell.
    - **Architektur-Dokumentation:**
        - Dieses Gesamtspezifikationsdokument dient als zentrales Referenzdokument.
        - High-Level-Architekturdiagramme (Schichtendiagramme, Komponentendiagramme, C4-Modell-Elemente wo sinnvoll) müssen erstellt und aktuell gehalten werden, um das Gesamtsystem und die Interaktionen zwischen den Hauptkomponenten zu beschreiben. Diese sind Teil dieses Dokuments oder als separate, verlinkte Artefakte zu pflegen.
    - **READMEs:** Jedes Crate und jede größere, eigenständige Komponente muss eine `README.md`-Datei besitzen, die den Zweck, die Hauptfunktionen, Build-Anweisungen und grundlegende Nutzungsanweisungen beschreibt.
    - **Metadaten:** Alle `Cargo.toml`-Dateien müssen vollständige und korrekte Metadaten enthalten (`authors`, `description`, `license`, `repository`, `homepage`, `documentation`, `keywords`, `categories`). Dies ist wichtig für die interne Verwaltung, potenzielle Veröffentlichung und Auffindbarkeit.
    - **Benutzer- und Entwicklerdokumentation:** Parallel zur Entwicklung sind Konzepte für eine separate Benutzerdokumentation (Anleitung zur Bedienung der Desktop-Umgebung) und weiterführende Entwicklerdokumentation (z.B. Anleitungen zum Erstellen von Widgets oder Plugins, detaillierte API-Referenzen über `rustdoc` hinaus) zu erstellen.

**V. Initiale Schicht- und Komponentenspezifikationen (Struktur)**

Die detaillierten Spezifikationen für jede Komponente jeder Schicht (wie in den vorherigen Antworten teilweise bereits skizziert) werden als separate, untergeordnete Dokumente oder Abschnitte dieser Gesamtspezifikation geführt. Sie folgen einer einheitlichen Struktur:

1. **Modul-/Komponentenübersicht:** Zweck, Verantwortlichkeiten, Design-Rationale.
2. **Datenstrukturen und Typdefinitionen:** Detaillierte Definition aller relevanten `struct`s, `enum`s, `trait`s und Typaliase in Rust-Syntax, inklusive aller Felder, Varianten und abgeleiteten Traits (z.B. `Debug`, `Clone`, `Serialize`, `Deserialize`, `Default`, `thiserror::Error`). Tabellarische Übersichten für komplexe Typen.
3. **Öffentliche API und Interne Schnittstellen:** Exakte Signaturen aller öffentlichen Funktionen/Methoden. Beschreibung von Vor- und Nachbedingungen, Logik/Algorithmen der Methoden. Spezifikation von Events (Payload-Struktur, Publisher, Subscriber, Auslösebedingungen).
4. **Fehlerbehandlung:** Definition des modulspezifischen Fehler-Enums mit `thiserror`, inklusive aller Varianten, `#[error(...)]`-Nachrichten und der Handhabung von `#[source]` und `#[from]`.
5. **Interaktionen und Abhängigkeiten:** Beschreibung der Interaktionen mit anderen Modulen/Komponenten derselben Schicht und mit Modulen/Komponenten anderer Schichten.
6. **Detaillierte Implementierungsschritte:** Eine schrittweise Anleitung für die Implementierung, die die Erstellung von Dateien, die Definition von Typen und die Implementierung von Methoden und Logik umfasst.
7. **Testaspekte:** Identifikation testkritischer Logik, Beispiele für Testfälle, Hinweise zu Mocking-Strategien.

**VI. Deployment-Überlegungen**

1. **Paketierung:**
    - **Zielformate:** Primär native Pakete für gängige Linux-Distributionen (z.B. `.deb` für Debian/Ubuntu, `.rpm` für Fedora/openSUSE).
    - **Flatpak:** Evaluierung und potenzielle Bereitstellung der gesamten Desktop-Umgebung oder wichtiger Teile davon als Flatpak zur distributionsunabhängigen Installation und für Entwickler-SDKs.
    - **Build-Prozess:** Der Meson-Build-Prozess muss Artefakte für diese Paketformate erstellen können, inklusive korrekter Handhabung von Abhängigkeiten, Installation von Desktop-Dateien (`.desktop`), Icons, Themes, Konfigurationsdateien und systemd-Units.
2. **Systemintegration:**
    - **Display Manager:** Konfiguration für gängige Display Manager (GDM, LightDM, SDDM) zur Auswahl von NovaDE als Sitzung.
    - **systemd User Sessions:** Korrekte Einrichtung von systemd User Sessions für NovaDE.
    - **PAM-Module:** Sicherstellung der Kompatibilität und ggf. Bereitstellung spezifischer PAM-Konfigurationen für Login und Authentifizierung.
    - **XDG Base Directory Specification:** Strikte Einhaltung für alle benutzer- und systemweiten Konfigurations-, Daten- und Cache-Dateien (`$XDG_CONFIG_HOME`, `$XDG_DATA_HOME`, `$XDG_CACHE_HOME`, `$XDG_CONFIG_DIRS`, `$XDG_DATA_DIRS`).
3. **Konfiguration:**
    - Bereitstellung einer sinnvollen Standardkonfiguration für alle Aspekte der Desktop-Umgebung.
    - Klare Mechanismen für Benutzer, um diese Standardeinstellungen über grafische Oberflächen (`ui::control_center`) und ggf. Konfigurationsdateien zu überschreiben.
    - Trennung von Systemkonfiguration (typischerweise in `/etc`) und Benutzerkonfiguration (in `$XDG_CONFIG_HOME`).
4. **Updates:**
    - **Strategie:** Primär über die Paketmanager der jeweiligen Distributionen. Für Flatpak-Installationen über den Flatpak-Update-Mechanismus.
    - **Versionierung:** Semantische Versionierung (SemVer) für das Gesamtprojekt und für kritische Bibliotheks-Crates.
    - **Konfigurationsmigration:** Mechanismen oder Richtlinien zur Handhabung von Änderungen an Konfigurationsformaten oder -schlüsseln bei Updates, um Datenverlust oder Inkompatibilitäten zu vermeiden (z.B. automatische Migration, klare Hinweise für Benutzer).

**VII. Schlussfolgerung**

Diese technische Gesamtspezifikation legt das verbindliche Fundament für die Entwicklung der Linux-Desktop-Umgebung NovaDE. Sie definiert eine klare, geschichtete Architektur, wählt einen modernen und robusten Technologie-Stack basierend auf Rust, Wayland, GTK4 und Smithay und etabliert detaillierte Entwicklungsrichtlinien für Qualität, Konsistenz und Wartbarkeit.

Die präzisen Entscheidungen bezüglich Architektur, Technologien und Richtlinien bilden die unumstößliche Grundlage für die nachfolgenden, detaillierten Implementierungsleitfäden der einzelnen Schichten und Komponenten. Durch die konsequente und disziplinierte Einhaltung dieser Spezifikation wird eine hochwertige, moderne, sichere, performante und anpassungsfähige Desktop-Umgebung entstehen, die den hohen Anforderungen von Entwicklern, Kreativen und alltäglichen Nutzern gerecht wird und eine intuitive, effiziente und persönliche Benutzererfahrung bietet. Dieses Dokument ist lebendig und wird bei Bedarf unter strenger Einhaltung der übergeordneten Vision und Architekturprinzipien aktualisiert.

# Finale Beschreibung

**Willkommen zu Ihrer neuen Linux Desktop-Erfahrung – Intelligent, Intuitiv, Persönlich**

Stellen Sie sich eine Desktop-Umgebung vor, die nicht nur modern aussieht und sich unglaublich schnell anfühlt, sondern auch mitdenkt und sich Ihnen anpasst. Wir haben den Linux-Desktop von Grund auf neu gestaltet, um Ihnen ein Werkzeug an die Hand zu geben, das Ihre Kreativität beflügelt, Ihre Produktivität steigert und Ihnen bei alltäglichen Aufgaben als intelligenter Partner zur Seite steht – egal ob Sie gestalten, entwickeln, kommunizieren oder einfach die digitale Welt erkunden.

**Eine Benutzeroberfläche, die begeistert und intuitiv führt**

Das Herzstück ist eine Benutzeroberfläche, die Eleganz und Funktionalität meisterhaft vereint. Freuen Sie sich auf eine klare, dunkle Ästhetik (tiefe Grau- und Blautöne bilden eine beruhigende Basis), die durch gezielte, von Ihnen wählbare Akzentfarben – vielleicht ein dynamisches Korallrot oder ein beruhigendes Hellblau – zum Leben erweckt wird. Präzise Konturen und subtile Effekte wie optionale Transluzenz bestimmter Panel-Hintergründe oder ein feines Leuchten aktiver Elemente schaffen eine hochwertige Anmutung.

- **Mühelose Navigation, klare Sicht:** Finden Sie sich sofort zurecht. Menüs, Einstellungen und Systeminformationen sind logisch aufgebaut und leicht erreichbar. Weniger Suchen, mehr Erledigen – das ist unser Versprechen. Die Darstellung ist stets scharf und gut lesbar, dank heller Schrift auf dunklem Grund.
- **Reaktionsschnell und flüssig:** Erleben Sie eine Oberfläche, die ohne Verzögerung auf jede Ihrer Aktionen reagiert. Fenster öffnen sich zügig, Animationen – beispielsweise beim Ein- und Ausklappen der Seitenleisten oder beim Wechseln der Ansichten – sind geschmeidig und unterstützen ein angenehmes, modernes Bediengefühl, ohne jemals aufdringlich zu wirken. Die moderne Wayland-Technologie im Hintergrund macht dies möglich.
- **Ihr persönlicher Stil (Theming):** Machen Sie diesen Desktop zu Ihrem ganz persönlichen Arbeitsplatz. Ein fortschrittliches Theming-System erlaubt es Ihnen, dynamisch zur Laufzeit zwischen verschiedenen Designs zu wechseln – beispielsweise von einem konzentrierten Dunkelmodus zu einem helleren Arbeitsmodus für sonnige Tage. Und das Beste: Wählen Sie Ihre systemweite Lieblings-Akzentfarbe, die sich konsistent durch die gesamte Umgebung und unterstützte Anwendungen zieht. All das, ohne dass Sie etwas neu starten müssen.
- **Intelligente Anpassung:** Die Umgebung lernt mit Ihnen. Häufig genutzte Funktionen und Anwendungen können priorisiert und Layouts basierend auf Ihren Gewohnheiten angepasst werden. Das Ziel: Ihren Arbeitsfluss optimieren und unnötige Kontextwechsel minimieren.
- **Fensterkontrolle – Meisterhaft einfach:** Sie haben die volle Kontrolle. Ändern Sie Fenstertitel, passen Sie Größen stufenlos an oder wechseln Sie mühelos zwischen minimierten, maximierten und ablenkungsfreien Vollbildzuständen. Die Fensterverwaltung ist so intelligent gestaltet, dass Ihr Multitasking-Erlebnis nahtlos und effizient wird.

**Ihre Schaltzentrale – Die Interaktionskomponenten im Detail**

Wir haben jede Komponente sorgfältig entworfen, um Ihnen die Arbeit so angenehm und effizient wie nur möglich zu gestalten:

- **Ihre Hauptoberfläche (Shell-UI):**
    - **Kontroll- und Systemleiste(n):** Am oberen (oder unteren, je nach Wunsch) Bildschirmrand finden Sie eine elegante Leiste. Von hier aus haben Sie schnellen Zugriff auf wichtige Systemfunktionen wie Netzwerk, Lautstärke und Akkuanzeige. Auch das neue, zentrale Benachrichtigungszentrum und eine Übersicht Ihrer laufenden Anwendungen sind hier integriert. Ein optionaler, feiner Leuchtakzent am Rand der Leiste unterstreicht das hochwertige Design.
    - **Intelligente Tab-Leiste pro "Space":** Jeder Ihrer Arbeitsbereiche ("Spaces") verfügt über eine eigene, horizontale Tab-Leiste direkt im Hauptbereich. Hier sehen Sie prominent die Anwendung(en), die Sie für diesen Space als "gepinnt" definiert haben – sei es eine einzelne Anwendung oder eine praktische Split-View-Ansicht. Die Tabs selbst sind modern gestaltet mit abgerundeten oberen Ecken, wobei der aktive Tab durch Ihre gewählte Akzentfarbe hervorgehoben wird. Weitere, nicht gepinnte Anwendungen des Spaces erscheinen dezent als kleinere Tabs oder in einer Überlauf-Liste.
    - **Quick-Settings-Panel:** Direkt aus der Systemleiste herausgeklappt, bietet dieses Panel schnellen Zugriff auf häufig benötigte Einstellungen wie WLAN, Bluetooth, Lautstärke oder den Wechsel in den Dark Mode – ganz ohne den Umweg über das vollständige Control Center.
- **Control Center (Alle Einstellungen fest im Griff):** Eine zentrale, klar strukturierte und modular aufgebaute Ansicht für sämtliche Systemeinstellungen. Konfigurieren Sie Ihr Netzwerk, Bluetooth-Geräte, Audioeinstellungen, Bildschirmhelligkeit und vieles mehr. Dank kontextsensitiver Schnelleinstellungen erledigen Sie viele Anpassungen mit nur wenigen Klicks und sehen bei vielen Optionen direkt eine Live-Vorschau Ihrer Änderungen.
- **Schnellaktionsdock (Ihr persönlicher Schnellzugriff):** Ein von Ihnen frei konfigurierbarer Bereich – schwebend oder am Rand angedockt – in dem Sie Ihre wichtigsten Anwendungen, häufig benötigte Dateien oder oft ausgeführte Aktionen ablegen können. Das Dock kann Ihnen basierend auf Ihrem Kontext auch intelligente Aktionsvorschläge machen und lässt sich vollständig über Tastaturkürzel bedienen.
- **Seitenleisten und Widgets (Information und Organisation auf einen Blick):**
    - **Adaptive Seitenleisten:** Optional können Sie links und rechts des Bildschirms adaptive Seitenleisten einblenden. Diese haben einen leicht abgesetzten, dezent transluzenten Hintergrund und dienen als Heimat für Navigationselemente und nützliche Widgets.
    - **Linke Seitenleiste (Navigation & "Spaces"):** Hier finden Sie den innovativen **Workspace-Switcher**. Im eingeklappten Zustand zeigt er für jeden Ihrer "Spaces" (Arbeitsbereiche) nur ein Icon – entweder das der dort primär "angepinnten" Anwendung oder ein von Ihnen gewähltes Symbol für den Space. Dies ermöglicht einen extrem schnellen visuellen Wechsel zwischen Ihren Arbeitskontexten. Der aktive Space wird dabei dezent hervorgehoben. Bei Mouse-Over oder einer spezifischen Geste klappt der Switcher auf und zeigt zusätzlich den Namen des Spaces sowie optional eine Miniaturansicht oder eine Liste der darin geöffneten Fenster. Auch Elemente wie eine globale Suche oder Schnellzugriffe auf den Anwendungsstarter und die Einstellungen sind hier elegant integriert.
    - **Rechte Seitenleiste (Informative Widgets):** Hier können Sie eine Vielzahl von Widgets platzieren, die Ihnen wichtige Informationen auf einen Blick liefern – von der Uhrzeit und dem Kalender über Wettervorhersagen bis hin zu einem Systemmonitor für CPU- und RAM-Auslastung. Die Widgets sind interaktiv und erlauben oft schnelle Aktionen direkt aus dem Widget heraus (z.B. die Musikwiedergabe steuern oder ein To-Do-Element abhaken).
    - **Drag & Drop Anpassung:** Sowohl die Inhalte der Seitenleisten als auch die Widgets selbst lassen sich einfach per Drag & Drop an Ihre persönlichen Bedürfnisse anpassen.
- **Speed-Dial und Übersichtsmodus (Navigation und Fenster-Management neu definiert):**
    - **Speed-Dial:** Ihre persönliche Startansicht, wenn Sie einen neuen, leeren Arbeitsbereich öffnen. Hier finden Sie nicht nur Ihre Favoriten, sondern auch intelligente Vorschläge für häufig genutzte Anwendungen, kürzlich geöffnete Dokumente oder oft ausgeführte Aktionen – basierend auf Ihren Nutzungsmustern und dem aktuellen Kontext. Die Oberfläche ist anpassbar und verfügt über eine integrierte Suchfunktion.
    - **Übersichtsmodus (Ihr Fenster-Cockpit):** Mit einer einfachen Geste oder einem Tastendruck wechseln Sie in einen eleganten Übersichtsmodus. Hier sehen Sie alle geöffneten Fenster des aktuellen Arbeitsbereichs (oder optional aller Bereiche) als interaktive, verkleinerte Kacheln mit einer Live-Vorschau ihres Inhalts. Der Hintergrund tritt dabei dezent in den Hintergrund (abgedunkelt oder mit Unschärfe), um den Fokus klar auf Ihre Fenster zu legen. Wählen Sie Fenster direkt aus, schließen Sie sie oder verschieben Sie sie mühelos per Drag & Drop zwischen Ihren "Spaces", die im Übersichtsmodus ebenfalls übersichtlich dargestellt werden. Optional können Sie sich Fenster auch gruppiert pro Anwendung anzeigen lassen.
- **Eingabe- und Fokusmanagement (Präzise und komfortabel):**
    - Die Navigation mit der Tastatur ist ein integraler Bestandteil. Logische Tab-Reihenfolgen und eine durchgängige Pfeiltastensteuerung ermöglichen eine effiziente Bedienung auch ohne Maus.
    - Das System stellt sicher, dass immer klar ersichtlich ist, welches Element gerade den Fokus hat, beispielsweise durch einen feinen Rahmen in Ihrer gewählten Akzentfarbe.
    - Für Geräte mit Touchpad bieten wir eine nahtlos integrierte **Gestensteuerung**, die auf präziser `libinput`-Verarbeitung basiert. Wechseln Sie Arbeitsflächen, öffnen Sie die Übersicht oder zeigen Sie alle Fenster einer Anwendung mit intuitiven Multi-Touch-Gesten.
- **Kontextuelle Befehlspalette (Der direkte Draht zu Aktionen):** Für Power-User und alle, die gerne tippen: Eine textbasierte Befehlspalette (standardmäßig aufrufbar via `Super+Space`) ermöglicht es Ihnen, durch Eingabe von Suchbegriffen blitzschnell Aktionen auszuführen, die für den _aktuellen Anwendungs- oder Desktop-Kontext_ relevant sind. Starten Sie Anwendungen, finden Sie spezifische Einstellungen, führen Sie kontextbezogene Befehle aus (z.B. "Neuen Ordner erstellen", wenn der Dateimanager aktiv ist) oder rufen Sie Systemfunktionen auf. Intelligentes Fuzzy-Matching hilft Ihnen dabei, auch dann das Richtige zu finden, wenn Sie sich nicht an den exakten Namen erinnern.

**Der Intelligente Kern – Ihre KI-Assistenz mit Sicherheit und Kontrolle**

Diese Desktop-Umgebung integriert künstliche Intelligenz als unaufdringlichen, hilfreichen Assistenten – stets unter Ihrer vollen Kontrolle und mit höchstem Augenmerk auf Sicherheit und Datenschutz.

- **Sicher und Standardisiert:** Wir nutzen das offene **Model Context Protocol (MCP)**, um Ihren Desktop sicher mit lokalen oder Cloud-basierten Sprachmodellen (LLMs) zu verbinden. Das ermöglicht leistungsstarke KI-Funktionen, ohne Ihre Daten unnötig preiszugeben oder Sie an einen bestimmten Anbieter zu binden.
- **Ihre Zustimmung zählt:** Keine KI-Aktion ohne Ihr Wissen! Bevor eine KI-Funktion auf Ihre Daten zugreift (z.B. eine Datei analysiert) oder eine Systemeinstellung ändert, werden Sie über einen klaren, verständlichen Dialog um Ihre **explizite Zustimmung** gebeten. Sie sehen genau, _was_ die KI tun möchte und _warum_, und können jederzeit "Erlauben" oder "Ablehnen". Sie behalten die volle Kontrolle über Ihre Daten und Ihr System.
- **Feingranulare Berechtigungen:** Ein intelligentes System verwaltet detailliert, welche Aktionen die KI oder bestimmte Widgets durchführen dürfen, basierend auf dem Prinzip der geringsten notwendigen Rechte.
- **Praktische KI-Funktionen im Alltag:**
    - **Intelligente Sprachsteuerung:** Sprechen Sie Befehle wie "Öffne meine E-Mails", "Wie wird das Wetter morgen?" oder "Aktiviere den Nicht-Stören-Modus". Die KI interpretiert Ihre Anweisungen und führt die Aktionen sicher aus – nach Ihrer Zustimmung, falls erforderlich.
    - **Automatisierte Dateiaufgaben:** Lassen Sie die KI den Inhalt von Dokumenten zusammenfassen, Daten aus Verzeichnissen analysieren oder Textentwürfe für E-Mails erstellen. Sie entscheiden, auf welche Dateien oder Ordner die KI zugreifen darf.
    - **Kontextbezogene Web-Informationen in Widgets:** Widgets in Ihrer Seitenleiste können dynamisch relevante Informationen aus dem Web anzeigen, die von der KI basierend auf Ihrer aktuellen Aufgabe vorgeschlagen werden – sicher und ohne Ihre Privatsphäre zu gefährden, da Inhalte vor der Anzeige entsprechend aufbereitet werden.
- **Sichere Speicherung:** Sensible Daten wie Ihre API-Schlüssel für Cloud-basierte KI-Dienste werden sicher im System über die etablierte Freedesktop Secret Service API gespeichert und niemals im Klartext abgelegt.

**Systemintegration und Plattformfunktionen – Nahtlos, Leistungsstark und Sicher**

Diese Desktop-Umgebung ist tief mit den modernen Technologien Ihres Linux-Systems verwoben, um Ihnen eine stabile, sichere und performante Erfahrung zu bieten.

- **Moderne Display-Technologie (Wayland):** Die Basis bildet Wayland, ein modernes und sicheres Display-Server-Protokoll. Das bedeutet für Sie eine ruckelfreie Darstellung, verbesserte Sicherheit und eine zukunftssichere Plattform. Für ältere Anwendungen, die Wayland noch nicht nativ unterstützen, sorgt XWayland für nahtlose Kompatibilität. Die Fensterverwaltung nutzt standardisierte Protokolle wie XDG-Shell für ein konsistentes und vorhersagbares Verhalten.
- **Reibungslose Kommunikation (D-Bus):** Unsichtbar, aber essentiell: D-Bus ermöglicht die reibungslose Kommunikation zwischen verschiedenen Teilen des Desktops und wichtigen Systemdiensten – beispielsweise für die Energieverwaltung (UPower), Netzwerkkonfigurationen (NetworkManager), das Empfangen und Anzeigen von Benachrichtigungen oder die sichere Speicherung von Passwörtern und Schlüsseln.
- **Sicherheit bei wichtigen Aktionen (PolicyKit):** Wenn eine Anwendung oder eine Einstellung erweiterte Rechte benötigt (z.B. um System-Updates zu installieren oder Energieeinstellungen wie den Ruhezustand zu ändern), stellt PolicyKit sicher, dass solche Operationen nur mit Ihrer ausdrücklichen Zustimmung erfolgen, typischerweise nach Eingabe Ihres Passworts.
- **Präzise Eingabeverarbeitung (libinput):** Ihre Eingaben über Tastatur, Maus oder Touchpad werden dank der Integration von libinput präzise und zuverlässig verarbeitet, was zu einer direkten und genauen Interaktion führt.
- **Optimale Darstellung auf allen Bildschirmen:** Verwalten Sie mühelos mehrere Monitore. Die Umgebung unterstützt unterschiedliche Auflösungen, individuelle Skalierungsfaktoren für hochauflösende Displays (HiDPI) und flexible Anordnungen Ihrer Bildschirme.
- **Volle Klangkontrolle (Audio-Management):** Passen Sie die Systemlautstärke einfach an, wählen Sie Ihre bevorzugten Audio-Ein- und Ausgabegeräte und verwalten Sie die Klangeinstellungen für ein optimales Hörerlebnis.
- **Effiziente Energienutzung:** Die Umgebung arbeitet intelligent mit den Energiediensten Ihres Systems zusammen, um Energieprofile zu unterstützen und einen reibungslosen Übergang in den Standby- oder Ruhezustand und wieder zurück zu gewährleisten.

**Anwendungs- und Workspace-Management – Perfekt Organisiert und Hocheffizient**

Behalten Sie stets den Überblick und die Kontrolle über Ihre Anwendungen und Aufgaben.

- **Fortschrittliche Fensterverwaltung mit Intelligenz:** Neben den grundlegenden Funktionen bietet die Umgebung erweiterte Möglichkeiten zur Anordnung Ihrer Fenster. Nutzen Sie Funktionen wie **automatisches Kacheln (Tiling)**, bei dem Fenster den Bildschirm optimal ausnutzen, oder **Snapping**, bei dem Fenster an Bildschirmrändern oder anderen Fenstern "einrasten". Sie können aus verschiedenen **konfigurierbaren Tiling-Layouts** (z.B. Kacheln, Spalten, Spiralen) wählen und sogar Tiling-, Stacking- (überlappend) und Floating-Fenster (frei beweglich) nahtlos innerhalb desselben Arbeitsbereichs mischen. Einstellbare **Lücken (Gaps)** zwischen den Fenstern sorgen für visuelle Klarheit. Das System bietet zudem intelligente Vorschläge für Fensteranordnungen, ähnlich den Snap Layouts unter Windows, die sich an den verfügbaren Bildschirmplatz anpassen. Auch die Darstellung von Fensterdekorationen (Rahmen, Titelleisten) wird flexibel und stilkonsistent gehandhabt.
- **Virtuelle Desktops als "Spaces" (Workspace-Management):** Organisieren Sie Ihre Arbeit in verschiedenen, thematisch getrennten Arbeitsbereichen, genannt "Spaces". Erstellen Sie Spaces dynamisch, wenn Sie sie benötigen – vielleicht einen für Arbeit, einen für private Projekte und einen weiteren für Kommunikation. Weisen Sie jedem Space optional ein **eigenes Icon, eine individuelle Akzentfarbe oder sogar ein spezifisches Hintergrundbild** zu, um sie visuell sofort unterscheiden zu können. "Pinnen" Sie Ihre Hauptanwendung(en) oder eine Split-View-Ansicht an jeden Space, um Ihren Fokus zu definieren. Wechseln Sie blitzschnell zwischen diesen Spaces über Gesten, Tastenkürzel oder den eleganten Workspace-Switcher in der Seitenleiste. Ihre Workspace-Konfigurationen und Fensteranordnungen können zwischen Sitzungen gespeichert werden.
- **Intelligente Anwendungssteuerung:** Starten, beenden und überwachen Sie Ihre Anwendungen mit Leichtigkeit. Das System merkt sich kürzlich und häufig genutzte Anwendungen, um Ihnen im Speed-Dial oder der Befehlspalette intelligente und zeitsparende Vorschläge zu machen.

**Diese Desktop-Umgebung ist mehr als nur eine Oberfläche. Sie ist Ihr persönlicher, intelligenter und sicherer digitaler Arbeitsplatz, der sich Ihren Bedürfnissen anpasst und Ihnen hilft, das Beste aus Ihrem Linux-System herauszuholen – intuitiv, effizient und mit Stil.**

# Abläufe und Anwendungsfälle

**Grundphilosophie der Benutzererfahrung:** Unsere Desktop-Umgebung soll sich anfühlen wie eine natürliche Erweiterung der Denk- und Arbeitsweise des Nutzers. Jede Interaktion ist darauf ausgelegt, Reibung zu minimieren, Kontextwechsel intelligent zu gestalten und proaktive Unterstützung anzubieten, ohne bevormundend zu wirken. Die dunkle, elegante Ästhetik mit gezielten Akzentfarben schafft eine fokussierte und angenehme Arbeitsatmosphäre. Flüssige Animationen sind nicht nur schmückendes Beiwerk, sondern visuelles Feedback, das Aktionen verständlich macht und die wahrgenommene Geschwindigkeit erhöht.

**Typische Nutzerabläufe und das Zusammenspiel der Komponenten:**

**Szenario 1: Der Entwickler startet in seinen Tag**

1. **Systemstart und Login:** Der Entwickler startet sein System. Der Login-Bildschirm präsentiert sich im gleichen dunklen, eleganten Stil wie der Desktop selbst. Nach erfolgreichem Login (unterstützt durch die Systemsicherheitsmechanismen) wird der Desktop blitzschnell geladen.
2. **Der erste Blick – Der "Space" für Entwicklung:**
    - Der Entwickler landet standardmäßig in seinem "Development-Space", den er gestern so verlassen hat. Dieser "Space" hat ein von ihm gewähltes Icon (z.B. ein Zahnrad) und eine dezente blaue Akzentfarbe, die ihm hilft, ihn sofort von seinem "Kommunikations-Space" (mit einer Sprechblase und grüner Akzentfarbe) zu unterscheiden.
    - **Intelligente Tab-Leiste:** Oben im "Development-Space" zeigt die Tab-Leiste prominent seine "angepinnte" Hauptanwendung: seinen Code-Editor (z.B. VS Code). Daneben, ebenfalls als "gepinnt" definiert, ein Terminal in einer Split-View. Diese Tabs sind klar beschriftet und der aktive Tab (Code-Editor) ist mit der primären Systemakzentfarbe (Korallrot) hervorgehoben.
    - **Linke Seitenleiste (Workspace-Switcher):** Im eingeklappten Zustand sieht er die Icons seiner Spaces: das Zahnrad für "Development", die Sprechblase für "Kommunikation" und ein Icon für seinen "Design-Space". Das Zahnrad-Icon ist hervorgehoben, da dies der aktive Space ist.
3. **Projekt öffnen und Arbeitsumgebung einrichten:**
    - **Kontextuelle Befehlspalette (`Super+Space`):** Der Entwickler drückt `Super+Space`. Die Befehlspalette erscheint als dunkles Overlay. Er tippt "projekt anaconda". Dank Fuzzy-Matching und Kenntnis seines aktuellen "Development-Space" (Kontext!) schlägt die Palette "Projekt 'Anaconda' in VS Code öffnen" und "Terminal in Projekt 'Anaconda' öffnen" vor. Er wählt die erste Option.
    - VS Code (als XWayland-Anwendung oder native Wayland-Anwendung, gemanagt durch `xdg-shell`) startet und wird automatisch dem "Development-Space" zugeordnet, da er von dort aus initiiert wurde. Die **Intelligente Tab-Leiste** könnte jetzt, falls VS Code Fokus hat, kontextrelevante Aktionen oder Informationen aus VS Code anzeigen (zukünftige Erweiterung, erfordert Plugin-System oder standardisierte App-Integration).
    - **Automatisches Tiling:** Der Entwickler öffnet ein zweites Terminal. Da er für diesen "Development-Space" ein Spalten-Tiling-Layout konfiguriert hat, ordnet sich das neue Terminalfenster automatisch rechts neben dem bestehenden Split-View (Code-Editor + erstes Terminal) an. Die konfigurierbaren Gaps zwischen den Fenstern sorgen für eine klare visuelle Trennung.
4. **Recherche und Dokumentation:**
    - **Rechte Seitenleiste (Widgets):** Er hat ein Widget für Notizen und eines für Web-Lesezeichen in der rechten Seitenleiste. Er zieht per Drag & Drop einen Link aus seinem Browser in das Lesezeichen-Widget. Das Widget zeigt eine Vorschau und speichert den Link.
    - **KI-Unterstützung (Einwilligung vorausgesetzt):** Er markiert einen komplexen Code-Abschnitt in VS Code, öffnet die Befehlspalette und tippt "code erklären". Die KI-Integration (via MCP-Client) sendet den Code-Schnipsel (nach expliziter Zustimmung, die er zuvor für "Code-Analyse durch lokales KI-Modell" erteilt hat) an ein lokales Sprachmodell. Die Erklärung erscheint in einem unaufdringlichen Pop-up oder direkt in der Seitenleiste in einem KI-Widget.
5. **Schneller Wechsel zum Kommunikations-Space:**
    - Eine **Benachrichtigung** erscheint dezent (gestaltet im Dark Mode Stil, mit korallrotem Akzent für die Dringlichkeit "wichtig"): "Neue Nachricht von Team-Chat". Ein Klick auf die Benachrichtigung oder eine definierte Geste (z.B. Drei-Finger-Wisch nach links auf dem Touchpad) wechselt zum "Kommunikations-Space".
    - **Linke Seitenleiste (Workspace-Switcher):** Das Sprechblasen-Icon wird hervorgehoben.
    - **Intelligente Tab-Leiste:** Zeigt nun den "angepinnten" Team-Chat-Client und daneben seinen E-Mail-Client.
6. **Meeting und Bildschirmfreigabe:**
    - Er startet einen Videoanruf. Die Anfrage zur Bildschirmfreigabe wird über ein **XDG Desktop Portal** sicher gehandhabt. Er wählt aus, nur das Anwendungsfenster des Team-Chats freizugeben.
    - **Quick-Settings-Panel:** Während des Anrufs passt er schnell die Mikrofonlautstärke über das Quick-Settings-Panel in der Systemleiste an.

**Szenario 2: Die Content Creatorin gestaltet und publiziert**

1. **Kreativer Arbeitsplatz – Der "Design-Space":**
    - Die Creatorin wechselt in ihren "Design-Space". Dieser hat ein Pinsel-Icon und eine violette Akzentfarbe. Ihr Grafikprogramm und ein Ordner mit Projektdateien sind hier als Tabs "angepinnt". Der Space hat ein individuelles, inspirierendes Hintergrundbild.
2. **Arbeiten mit mehreren Monitoren und Farbkonsistenz:**
    - Sie arbeitet mit zwei Monitoren. Die Desktop-Umgebung erkennt die unterschiedlichen Auflösungen und wendet die korrekten Skalierungsfaktoren an. Das **Token-basierte Theming** sorgt dafür, dass die Farben auf beiden Bildschirmen konsistent dargestellt werden (unter der Annahme korrekter Farbprofile auf Systemebene).
    - Das Grafikprogramm läuft auf dem Hauptmonitor, während sie auf dem zweiten Monitor Referenzbilder und Notizen geöffnet hat, die sich dank der flexiblen Fensterverwaltung (Floating-Fenster im selben Space) frei anordnen lassen.
3. **Widgets als Inspirationsquelle:**
    - In ihrer rechten Seitenleiste hat sie ein Widget, das Bilder von einer von ihr abonnierten Design-Plattform anzeigt. Ein anderes Widget zeigt aktuelle Farbpaletten-Trends (könnte KI-gestützt sein).
4. **Übersichtsmodus für Projektmanagement:**
    - Sie aktiviert den **Übersichtsmodus**, um alle geöffneten Dateien, Programmfenster und Notizen ihres aktuellen Projekts auf einen Blick zu sehen. Sie gruppiert per Drag & Drop einige Referenzbilder zu einer temporären visuellen Gruppe direkt im Übersichtsmodus.
5. **Veröffentlichung und Sprachbefehle:**
    - Nach Fertigstellung eines Designs sagt sie: "Neuer Entwurf 'Frühlingskampagne' in Cloud-Ordner 'Abgeschlossen' verschieben und Benachrichtigung an Projektleiter senden."
    - Die KI (nach Zustimmung für Dateizugriff und E-Mail-Versand) führt die Dateioperation aus und öffnet einen E-Mail-Entwurf mit einer vordefinierten Nachricht.
    - Der Fortschritt der Datei-Synchronisation wird dezent in einem Widget oder der Systemleiste angezeigt.

**Szenario 3: Der Alltagsnutzer surft, organisiert und personalisiert**

1. **Intuitive Ersteinrichtung und Anpassung:**
    - Der Nutzer startet die Umgebung zum ersten Mal. Ein kurzer, interaktiver Willkommens-Guide erklärt die wichtigsten Konzepte wie "Spaces", die Befehlspalette und die Seitenleisten.
    - **Control Center:** Er öffnet das Control Center. Die Module sind klar benannt. Er möchte das Erscheinungsbild anpassen. Unter "Erscheinungsbild" wählt er den "Dark Mode" (der bereits Standard ist) und als Akzentfarbe ein leuchtendes Grün. Die Änderungen werden sofort live in der Vorschau des Control Centers und auf dem gesamten Desktop sichtbar.
    - **Schnellaktionsdock:** Er zieht seine Lieblingsanwendungen (Browser, E-Mail, Musik-Player) per Drag & Drop in das Schnellaktionsdock am unteren Bildschirmrand.
2. **Web-Browse und Organisation in "Spaces":**
    - Er erstellt einen neuen "Space" namens "Urlaubsplanung" und weist ihm ein Palmen-Icon zu.
    - In diesem Space "pinnt" er seinen Webbrowser an die **Intelligente Tab-Leiste**. Er öffnet mehrere Tabs für Hotels, Flüge und Aktivitäten. Die Tab-Leiste zeigt den aktiven Webseiten-Tab deutlich an.
3. **Interaktive Widgets und schnelle Informationen:**
    - Er fügt der rechten Seitenleiste ein Wetter-Widget und ein Kalender-Widget hinzu. Das Wetter-Widget zeigt die aktuelle Temperatur und eine Vorhersage. Ein Klick auf einen Tag im Kalender-Widget könnte eine detailliertere Tagesansicht oder eine Verknüpfung zu seiner Kalenderanwendung öffnen.
4. **Multitasking und der Übersichtsmodus:**
    - Er hat mehrere Fenster geöffnet. Mit einer Geste auf dem Touchpad (z.B. Vier-Finger-Wisch nach oben) aktiviert er den **Übersichtsmodus**. Alle Fenster seines "Urlaubsplanungs-Space" werden übersichtlich als Kacheln angezeigt. Er klickt auf das Fenster mit den Hotelbuchungen, um es in den Vordergrund zu holen.
5. **Befehlspalette für schnelle Aktionen:**
    - Er möchte die Bildschirmhelligkeit reduzieren. Statt ins Control Center zu gehen, drückt er `Super+Space` und tippt "helligkeit". Die Befehlspalette schlägt "Bildschirmhelligkeit anpassen" vor. Mit den Pfeiltasten kann er direkt in der Palette einen Schieberegler bedienen oder einen Prozentwert eingeben.
6. **Benachrichtigungen im Blick:**
    - Eine Benachrichtigung über ein abgeschlossenes Software-Update erscheint. Er kann sie direkt mit einem "OK"-Button in der Benachrichtigung schließen oder später im **Benachrichtigungszentrum** in der Systemleiste nachlesen.

**Zusammenspiel und Intuition – Das "Wie" und "Warum":**

- **Kontextsensitivität:** Die "Intelligente Tab-Leiste" und die "Kontextuelle Befehlspalette" sind Schlüsselelemente, die dem Nutzer basierend auf dem aktuellen "Space" oder der aktiven Anwendung relevante Werkzeuge und Aktionen anbieten. Dies reduziert die kognitive Last und macht häufige Aktionen schneller zugänglich.
- **Visuelle Hierarchie und Konsistenz:** Die dunkle Grundästhetik lenkt den Fokus auf den Inhalt. Akzentfarben werden gezielt eingesetzt, um aktive Zustände, wichtige Informationen oder Benutzerinteraktionspunkte hervorzuheben. Die Formensprache (scharfe Kanten für Hauptbereiche, abgerundete Ecken für interaktive Elemente) ist durchgängig und schafft ein harmonisches Gesamtbild.
- **Direkte Manipulation:** Features wie Drag & Drop (für Widgets, Fenster zwischen Spaces im Übersichtsmodus, Dateien ins Dock) und interaktive Widgets vermitteln ein Gefühl direkter Kontrolle und machen die Bedienung greifbar.
- **Nahtlose Übergänge:** Flüssige Animationen beim Öffnen des Übersichtsmodus, beim Wechseln von "Spaces" oder beim Ein-/Ausklappen von Seitenleisten sind nicht nur optisch ansprechend, sondern helfen dem Nutzer auch, die räumlichen Beziehungen und Zustandsänderungen im System besser zu verstehen.
- **Anpassung als Kernprinzip:** Von der Wahl der Akzentfarbe über die Konfiguration der "Spaces" (Icons, gepinnte Apps, Hintergründe) bis hin zur Bestückung der Seitenleisten und des Docks – der Nutzer kann die Umgebung an seine individuellen Bedürfnisse und Vorlieben anpassen. Das Token-basierte Theming ist die technische Grundlage dafür.
- **KI als unaufdringlicher Helfer:** Die KI drängt sich nicht in den Vordergrund, sondern bietet Unterstützung an, wo sie sinnvoll ist (z.B. Vorschläge im Speed-Dial, Code-Erklärung, Sprachbefehle). Das explizite Einwilligungsmanagement stellt sicher, dass der Nutzer immer die Kontrolle behält.
**Technische Gesamtspezifikation & Richtlinien: Linux Desktop-Umgebung "NovaDE" (Kompakte Gesamtdefinition inkl. Features)**

**I. Vision und Kernziele**

- **Vision:** NovaDE (Nova Desktop Environment) ist eine innovative Linux-Desktop-Umgebung, die eine moderne, schnelle, intuitive und KI-gestützte Benutzererfahrung schafft. Sie ist optimiert für Entwickler, Kreative und alltägliche Nutzer und zielt darauf ab, Produktivität und Freude an der Interaktion mit dem System zu maximieren.
- **Kernziele:** Performance, Intuition, Modernität, Modularität & Wartbarkeit, Anpassbarkeit, sichere KI-Integration, Stabilität & Sicherheit.

**II. Architektonischer Überblick: Vier-Schichten-Architektur**

NovaDE basiert auf einer strengen, vier-schichtigen Architektur (Kern, Domäne, System, Benutzeroberfläche) für Modularität, lose Kopplung und hohe Kohäsion. Kommunikation erfolgt über wohldefinierte Schnittstellen.

1. **Kernschicht (Core Layer):**
    
    - **Verantwortlichkeiten:** Fundamentale Datentypen (z.B. `Point<T>`, `Color`), Dienstprogramme, Konfigurationsprimitive (TOML, Serde), Logging (`tracing`), Basis-Fehler (`thiserror`).
    - **Featurespiegelung:** Stellt die atomaren Bausteine für alle visuellen und logischen Elemente bereit.
2. **Domänenschicht (Domain Layer):**
    
    - **Verantwortlichkeiten:** UI-unabhängige Geschäftslogik.
        - `domain::theming`: Logik für das Erscheinungsbild, Design-Token-Verwaltung, dynamische Theme-Wechsel (Hell/Dunkel, Akzentfarben).
        - `domain::workspaces`: Verwaltung von Arbeitsbereichen ("Spaces"), Fensterzuweisung, Workspace-Orchestrierung und -Persistenz.
        - `domain::user_centric_services`: Logik für KI-Interaktionen (inkl. Einwilligungsmanagement für Datenkategorien wie `FileSystemRead`, `ClipboardAccess`), Benachrichtigungsverwaltung.
        - `domain::notifications_rules`: Regelbasierte, dynamische Verarbeitung von Benachrichtigungen.
        - `domain::global_settings_and_state_management`: Verwaltung globaler Desktop-Einstellungen.
        - `domain::window_management_policy`: Richtlinien für Fensterplatzierung, automatisches Tiling (Layouts: Spalten, Spiralen), Snapping, Fenstergruppierung, Gap-Management.
    - **Featurespiegelung:** Definiert _was_ personalisierbar ist (Themes, Akzente), _wie_ Arbeitsbereiche funktionieren (Spaces mit Icons, gepinnten Apps), _wie_ KI sicher und mit Zustimmung agiert und _welche_ Regeln für Fenster gelten.
3. **Systemschicht (System Layer):**
    
    - **Verantwortlichkeiten:** OS-Interaktion, technische Umsetzung der Domänenrichtlinien.
        - `system::compositor`: Smithay-basierter Wayland-Compositor (Implementierung von `xdg-shell`, `wlr-layer-shell-unstable-v1`, etc.), XWayland.
        - `system::input`: `libinput`-basierte Eingabeverarbeitung, Gestenerkennung, Seat-Management (`xkbcommon`).
        - `system::dbus`: `zbus`-Schnittstellen zu Systemdiensten (NetworkManager, UPower, logind, org.freedesktop.Notifications, org.freedesktop.secrets, PolicyKit).
        - `system::outputs`: Monitorkonfiguration (Auflösung, Skalierung, DPMS über `wlr-output-management`).
        - `system::audio`: PipeWire-Client (`pipewire-rs`) für Audio-Management.
        - `system::mcp`: MCP-Client (`mcp_client_rs`) für KI-Modell-Kommunikation.
        - `system::portals`: Backend für XDG Desktop Portals (FileChooser, Screenshot).
        - `system::window_mechanics`: Technische Umsetzung des Fenstermanagements (Positionierung, Anwendung von Tiling-Layouts, Fokus, Fensterdekorationen). Technische Basis für die "Intelligente Tab-Leiste".
    - **Featurespiegelung:** Ermöglicht flüssige Darstellung (Wayland), präzise Eingabe (`libinput`, Gesten), Integration mit Systemdiensten für Energie, Netzwerk, Sound (PipeWire) und sichere KI-Kommunikation (MCP). Setzt Fensterregeln (Tiling, Snapping) technisch um.
4. **Benutzeroberflächenschicht (User Interface Layer):**
    
    - **Verantwortlichkeiten:** Grafische Darstellung, Benutzerinteraktion (GTK4, `gtk4-rs`).
        - `ui::shell`:
            - **Kontroll-/Systemleiste(n) (PanelWidget):** Module für AppMenu, Workspace-Indikator, Uhr, System-Tray, Schnelleinstellungen, Benachrichtigungszentrum, Netzwerk-, Energie-, Audio-Indikatoren. _Elegante Leiste mit optionalem Leuchtakzent._
            - **Intelligente Tab-Leiste (SmartTabBarWidget):** Pro "Space", mit ApplicationTabWidgets für "angepinnte" Apps/Split-Views, aktive Tabs mit Akzentfarbe. _Moderne Tabs mit abgerundeten oberen Ecken._
            - **Schnelleinstellungs-Panel (QuickSettingsPanelWidget):** Ausklappbar für WLAN, Bluetooth, Lautstärke, Dark Mode.
            - **Workspace-Switcher (WorkspaceSwitcherWidget):** Adaptive linke Seitenleiste mit SpaceIconWidgets (Icons der gepinnten App oder benutzerdefiniert) für schnelle Navigation zwischen "Spaces", mit Hervorhebung des aktiven Space. _Bei Mouse-Over/Geste aufklappbar mit Namen/Vorschau._
            - **Schnellaktionsdock (QuickActionDockWidget):** Konfigurierbares Dock (schwebend/angedockt) für Apps, Dateien, Aktionen; intelligente Vorschläge, Tastaturbedienung.
            - **Benachrichtigungszentrum (NotificationCenterPanelWidget):** Anzeige von Benachrichtigungsliste und -historie.
        - `ui::control_center`: Modulare GTK4-Anwendung für alle Systemeinstellungen (Erscheinungsbild, Netzwerk, etc.) mit Live-Vorschau.
        - `ui::widgets`:
            - **Adaptive rechte Seitenleiste (RightSidebarWidget):** Optional, mit dezent transluzentem Hintergrund für informative Widgets (Uhr, Kalender, Wetter, Systemmonitor), per Drag & Drop anpassbar.
            - WidgetManagerService, WidgetPickerPopover.
        - `ui::window_manager_frontend`:
            - **Client-Side Decorations (CSD):** Logik (z.B. via `Gtk::HeaderBar`).
            - **Übersichtsmodus (OverviewModeWidget):** Fenster- und Workspace-Übersicht als interaktive Kacheln mit Live-Vorschau, Drag & Drop von Fenstern zwischen Spaces. _Hintergrund abgedunkelt/unscharf._
            - AltTabSwitcherWidget.
        - `ui::notifications_frontend`: **Pop-up-Benachrichtigungen (NotificationPopupWidget):** Dezent, im Dark Mode Stil mit Akzentfarbe für Dringlichkeit.
        - `ui::theming_gtk`: Anwendung von CSS-Stilen aus `domain::theming` via `GtkCssProvider`.
        - `ui::speed_dial`: GTK4-Implementierung der Startansicht für leere Workspaces mit Favoriten und intelligenten Vorschlägen.
        - `ui::command_palette`: GTK4-Implementierung der kontextuellen Befehlspalette (`Super+Space`).
    - **Featurespiegelung:** Setzt die gesamte beschriebene Nutzererfahrung um: dunkle Ästhetik mit Akzentfarben, Panel(s), intelligente Tab-Leiste, adaptive Seitenleisten mit Widgets, Workspace-Switcher, Schnellaktionsdock, Control Center, Speed-Dial, Übersichtsmodus und die kontextuelle Befehlspalette. Ermöglicht die Personalisierung und direkte Manipulation.

**III. Technologie-Stack (Verbindliche Auswahl)**

Rust, Meson, GTK4 (`gtk4-rs`), Smithay Toolkit, Wayland (xdg-shell, wlr-Protokolle), D-Bus (`zbus`), Model Context Protocol (MCP), `libinput`, PipeWire (`pipewire-rs`), Freedesktop Secret Service API, PolicyKit, Token-basiertes CSS-Theming, XDG Desktop Portals.

**IV. Entwicklungsrichtlinien (Verbindlich)**

- **Rust:** `rustfmt`, Rust API Guidelines, `thiserror` pro Modul, `Result<T,E>`, `tracing` für Logging, `async/await` (Tokio, GLib).
- **Allgemein:** Git (GitHub Flow), Conventional Commits, umfassende Tests (Unit, Integration, Compositor, UI), CI-Pipeline, detaillierte Dokumentation (rustdoc, Architektur, READMEs).

**V. Deployment-Überlegungen**

Native Pakete (.deb, .rpm), Flatpak (evaluieren), Integration mit Display Managern, `systemd` User Sessions, PAM, XDG Base Directory Specification. SemVer.
**Grundprinzip der Kommunikation:**

Die Kommunikation zwischen den Schichten erfolgt primär über wohldefinierte öffentliche APIs (oft Rust-Traits, die von Service-Strukturen implementiert werden) und durch ein Event-System. Direkte Abhängigkeiten existieren typischerweise nur von einer höheren zu einer unmittelbar tieferen Schicht.

**Schnittstellen im Detail:**

**1. Kernschicht (Core Layer) zu allen höheren Schichten (Domäne, System, UI)**

- **Bereitgestellte Funktionalität durch die Kernschicht:**
    - **`core::types`**:
        - **Datentypen**: Stellt fundamentale Datentypen wie `Point<T>`, `Size<T>`, `Rect<T>`, `RectInt`, `Color`, `Orientation`, `Uuid` und `DateTime<Utc>` bereit.
        - **Nutzung**: Diese Typen werden direkt in den höheren Schichten für Geometrieberechnungen, Farbangaben, Identifikatoren und Zeitstempel verwendet.
    - **`core::errors`**:
        - **Fehlertypen**: Definiert den Basis-Fehlertyp `CoreError` und die Strategie für Modul-spezifische Fehler mit `thiserror`.
        - **Nutzung**: Höhere Schichten wrappen Fehler aus der Kernschicht oft in ihre eigenen spezifischeren Fehlertypen mittels `#[from]` oder `#[source]` auf `CoreError` oder spezifischen Kernschicht-Modulfehlern. Die Fehlerkette (`source()`) bleibt dabei erhalten.
    - **`core::logging`**:
        - **Logging-API**: Stellt Initialisierungsroutinen (`initialize_logging`) und die Konvention zur Verwendung von `tracing`-Makros (`trace!`, `debug!`, `info!`, `warn!`, `error!`) bereit.
        - **Nutzung**: Alle höheren Schichten verwenden die `tracing`-Makros für strukturiertes Logging. `initialize_logging` wird typischerweise vom Hauptanwendungsbinary (UI-Schicht oder Anwendungs-Root) aufgerufen.
    - **`core::config`**:
        - **Konfigurations-API**: Stellt Funktionen zum Laden (`load_core_config`) und globalen Zugriff (`get_core_config`) auf Kernkonfigurationen (`CoreConfig` ) bereit. Definiert `ConfigError`.
        - **Nutzung**:
            - **Domänenschicht**: Module wie `domain::settings_persistence_iface` (z.B. `FilesystemConfigProvider` ) und `domain::workspaces::config` nutzen Kernschicht-Dienste zum Lesen/Schreiben von Konfigurationsdateien.
            - **Andere Schichten**: Können `get_core_config()` für den Zugriff auf Kern-spezifische Einstellungen verwenden. Die Kernkonfiguration wird nach der Initialisierung als unveränderlich betrachtet.
    - **`core::utils`**:
        - **Hilfsfunktionen**: Stellt allgemeine, zustandslose Hilfsfunktionen bereit.
        - **Nutzung**: Direkte Verwendung durch alle höheren Schichten nach Bedarf.

**2. Domänenschicht (Domain Layer) zu Systemschicht (System Layer) und Benutzeroberflächenschicht (User Interface Layer)**

- **Bereitgestellte Funktionalität durch die Domänenschicht:**
    - **Logik und Zustand**: Die Domänenschicht stellt ihre Geschäftslogik und Zustandsinformationen über öffentliche APIs ihrer Service-Komponenten (oft als Traits definiert) und durch das Aussenden von domänenspezifischen Events bereit.
    - **Fehlertypen**: Jedes Domänenmodul definiert eigene `thiserror`-basierte Fehler-Enums (z.B. `ThemingError`, `WorkspaceCoreError`, `WindowAssignmentError`, `WorkspaceManagerError`, `WorkspaceConfigError`, `AIInteractionError`, `NotificationError`, `GlobalSettingsError` ).
    - **Events**: Domänenspezifische Events werden ausgelöst, um andere Schichten über Zustandsänderungen zu informieren (z.B. `ThemeChangedEvent`, `WorkspaceEvent`, `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`, `NotificationPostedEvent`, `SettingChangedEvent` ).
- **Nutzung durch die Systemschicht:**
    - **Domänenregeln anwenden**: Die Systemschicht wendet die von der Domänenschicht definierten Richtlinien technisch an.
        - `system::compositor` interagiert mit `domain::window_management` für Platzierungsrichtlinien.
        - `system::window_mechanics` setzt die Policy aus `domain::window_management_policy` technisch um.
    - **Zustände abfragen**: Liest Zustände und Konfigurationen aus der Domänenschicht.
        - MCP-Client (`system::mcp`) interagiert mit `AIInteractionLogicService` für Einwilligungen und Kontext.
        - D-Bus Handler (`system::dbus`) für Benachrichtigungen nutzt `NotificationService`.
    - **Fehlerbehandlung**: Fehler aus der Domänenschicht werden von der Systemschicht behandelt oder weiterpropagiert (ggf. gewrappt).
    - **Event-Konsum**: Die Systemschicht kann auf Domänen-Events reagieren (z.B. Compositor passt Sichtbarkeit bei `ActiveWorkspaceChanged` an ).
- **Nutzung durch die Benutzeroberflächenschicht (UI Layer):**
    - **Zustandsdarstellung**: Visualisiert Zustände und Daten aus der Domänenschicht.
        - `ui::theming_gtk` konsumiert `AppliedThemeState` von `ThemingEngine`.
        - `ui::shell` und `ui::control_center` nutzen `GlobalSettingsService` und `WorkspaceManager`.
    - **Geschäftslogik auslösen**: Löst Aktionen und Zustandsänderungen in der Domänenschicht basierend auf Benutzerinteraktionen aus.
    - **Fehlerbehandlung**: Behandelt Fehler aus der Domänenschicht und stellt sie ggf. benutzerfreundlich dar.
    - **Event-Konsum**: Abonniert Domänen-Events, um sich dynamisch zu aktualisieren.

**Spezifische Domänen-Service-Schnittstellen (Beispiele):**

- **`ThemingEngine` API**:
    - Methoden: `new()`, `get_current_theme_state()`, `get_available_themes()`, `get_current_configuration()`, `update_configuration()`, `reload_themes_and_tokens()`, `subscribe_to_theme_changes()`.
    - Events: `ThemeChangedEvent`.
- **`WorkspaceManager` API**:
    - Methoden: `new()`, `create_workspace()`, `delete_workspace()`, `set_active_workspace()`, `assign_window_to_active_workspace()`, `save_configuration()`, etc.
    - Events: `WorkspaceCreated`, `WorkspaceDeleted`, `ActiveWorkspaceChanged`, etc.
- **`AIInteractionLogicService` Trait API**:
    - Methoden: `initiate_interaction()`, `get_interaction_context()`, `provide_consent()`, `get_consent_for_model()`, `store_consent()`, `load_model_profiles()`, etc.
    - Events: `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`.
- **`NotificationService` Trait API**:
    - Methoden: `post_notification()`, `get_notification()`, `mark_as_read()`, `dismiss_notification()`, `set_do_not_disturb()`, etc.
    - Events: `NotificationPostedEvent`, `NotificationDismissedEvent`, etc.
- **`GlobalSettingsService` Trait API**:
    - Methoden: `load_settings()`, `save_settings()`, `get_current_settings()`, `update_setting()`, `get_setting()`, `reset_to_defaults()`, etc.
    - Events: `SettingChangedEvent`, `SettingsLoadedEvent`, `SettingsSavedEvent`.

**3. Systemschicht (System Layer) zu Benutzeroberflächenschicht (User Interface Layer)**

- **Bereitgestellte Funktionalität durch die Systemschicht:**
    - **Systemnahe Dienste und Ereignisse**: Stellt der UI-Schicht Informationen und Ereignisse bereit, die direkt vom Betriebssystem oder der Hardware stammen.
        - Fenstergeometrie, Fokusänderungen, neue Fenster
        - Eingabeereignisse (Tastatur, Maus, Touch, Gesten)
        - Statusänderungen von Systemdiensten (Netzwerk, Energie, Audio)
        - Monitor-/Output-Änderungen
    - **Technische Umsetzung von UI-Befehlen**: Empfängt Befehle von der UI-Schicht (z.B. Fenster verschieben, Space wechseln, Fokus anfordern) und setzt diese technisch um.
    - **Renderer-Schnittstelle**: Obwohl nicht direkt von der UI-Schicht konsumiert, stellt `system::compositor::renderer_interface` eine Abstraktion für das Rendering bereit, die vom Compositor genutzt wird, um die UI-Elemente darzustellen.
    - **Fehlertypen**: Jedes Systemschicht-Modul definiert eigene `thiserror`-basierte Fehler-Enums (z.B. `CompositorCoreError`, `ShmError`, `XdgShellError`, `InputError`, `RendererError` ).
- **Nutzung durch die Benutzeroberflächenschicht (UI Layer):**
    - **Empfang von Eingabeereignissen**: Die UI-Schicht empfängt verarbeitete Eingabeereignisse von der Systemschicht, um darauf zu reagieren (z.B. Klicks auf Buttons, Tastatureingaben in Textfeldern).
    - **Visualisierung von Systemzuständen**: Stellt Informationen dar, die von der Systemschicht bereitgestellt werden (z.B. aktive Fenster, Netzwerkstatus, Batterieladung, Audio-Lautstärke).
        - `ui::shell` und `ui::window_manager_frontend` interagieren mit `system::compositor` und `system::input` für Fenster- und Fokusinformationen.
        - UI-Indikatoren reagieren auf Events von `system::dbus` (UPower, NetworkManager) und `system::audio` (PipeWire).
    - **Auslösen von Systemaktionen**: Sendet Befehle an die Systemschicht basierend auf Benutzerinteraktionen (z.B. Klick auf "Fenster schließen", Auswahl eines anderen Netzwerks).
    - **Fehlerbehandlung**: Behandelt Fehler von der Systemschicht oder leitet sie an den Benutzer weiter.
    - **Event-Konsum**: Abonniert System-Events, um die UI dynamisch zu aktualisieren (z.B. Fokusänderung, neues Fenster, Output-Änderung).

**Spezifische Systemschicht-Schnittstellen (Beispiele für Interaktion mit UI):**

- **Compositor (`system::compositor`)**:
    - Stellt `WlSurface`-Informationen und Fensterstruktur bereit. Meldet Fensterzustände (Titel, AppID, Geometrie) an `ui::shell` und `ui::window_manager_frontend`.
    - Empfängt Befehle zur Fokusänderung von der UI.
- **Eingabeverarbeitung (`system::input`)**:
    - Sendet Fokusänderungs-Events und Cursor-Informationen an `ui::shell`.
    - Empfängt Befehle zur Fokusänderung von der UI.
- **D-Bus Clients (`system::dbus`)**:
    - `upower_client` sendet `UPowerEvent` (Batteriestatus) an UI.
    - `logind_client` sendet `LogindEvent` (Suspend, Sitzungssperre) an UI, kann `LockSession` von UI empfangen.
    - `networkmanager_client` sendet Netzwerkstatus-Events an UI.
    - `secrets_client` interagiert mit UI für Prompts.
- **Output-Management (`system::outputs`)**:
    - Meldet Output-Änderungen an `ui::shell` und `ui::control_center`.
    - Empfängt Konfigurationsbefehle (Auflösung, Skalierung) von `ui::control_center`.
- **Audio-Management (`system::audio`)**:
    - Sendet `AudioEvent` (Geräte-/Stream-Änderungen, Lautstärke) an UI.
    - Empfängt `AudioCommand` (Lautstärke ändern) von UI.
- **MCP-Client (`system::mcp`)**:
    - Stellt KI-Funktionen für UI-Elemente wie die Befehlspalette bereit.
    - Empfängt Anfragen von der UI.
- **XDG Desktop Portals (`system::portals`)**:
    - Interagiert mit `ui::shell`/`ui::components` zur Anzeige von Dialogen (FileChooser, Screenshot).

**Zusammenfassende Prinzipien der Schnittstellen:**

1. **Klare Verantwortlichkeiten**: Jede Schicht hat definierte Aufgaben, und die Schnittstellen spiegeln diese wider.
2. **Lose Kopplung**: Kommunikation erfolgt über APIs und Events, um direkte Abhängigkeiten von Implementierungsdetails zu minimieren.
3. **Hohe Kohäsion**: Module innerhalb einer Schicht arbeiten eng zusammen, aber die Schicht als Ganzes hat eine klar definierte externe Schnittstelle.
4. **Einheitliche Fehlerbehandlung**: Die `thiserror`-basierte Strategie wird über alle Schichten hinweg verwendet, wobei Fehler weitergeleitet oder spezifisch behandelt werden. Die `source()`-Kette ist wichtig.
5. **Event-gesteuerte Updates**: Viele Zustandsänderungen werden über Events kommuniziert, was eine reaktive und entkoppelte Architektur fördert.

Diese Spezifikation der internen Schnittstellen ist entscheidend, um sicherzustellen, dass die verschiedenen Schichten der NovaDE kohärent zusammenarbeiten und die Gesamtziele des Projekts – Performance, Intuition, Modernität, Modularität, Anpassbarkeit, sichere KI-Integration und Stabilität – erreicht werden können.**Technische Spezifikation der internen Schnittstellen zwischen den Schichten der Linux Desktop-Umgebung "NovaDE"**

Diese Spezifikation beschreibt die Art und Weise, wie die vier Hauptarchitekturschichten von NovaDE – Kernschicht, Domänenschicht, Systemschicht und Benutzeroberflächenschicht – miteinander interagieren. Die Kommunikation erfolgt primär über wohldefinierte öffentliche APIs, die oft als Rust-Traits implementiert sind, sowie über ein Event-System zur Signalisierung von Zustandsänderungen.

**1. Schnittstelle: Kernschicht (Core Layer) zu höheren Schichten (Domäne, System, UI)**

Die Kernschicht stellt fundamentale Bausteine und Dienste bereit, die von allen darüberliegenden Schichten genutzt werden.

- **Bereitgestellte Funktionalität:**
    - **`core::types`**: Definiert grundlegende, universell einsetzbare Datentypen.
        - **Schnittstelle**: Direkte Verwendung von Typen wie `Point<T>`, `Size<T>`, `Rect<T>`, `RectInt`, `Color`, `Orientation` sowie `uuid::Uuid` und `chrono::DateTime<Utc>` durch die höheren Schichten.
        - **Beispielhafte Nutzung**: Die Domänenschicht verwendet `Color` für Theming-Definitionen, die Systemschicht `RectInt` für Fenstergeometrien, und die UI-Schicht `Point<T>` für die Positionierung von Elementen.
    - **`core::errors`**: Stellt eine Basis-Fehlerbehandlungsstrategie und den `CoreError`-Typ bereit.
        - **Schnittstelle**: Höhere Schichten können `CoreError` oder spezifischere Fehler aus Kernmodulen mittels `#[from]` oder `#[source]` in ihre eigenen Fehlertypen wrappen. Die Fehlerursachenkette (`source()`) wird dabei beibehalten.
        - **Beispielhafte Nutzung**: Ein `ConfigError` in `domain::workspaces::config` kann einen `CoreError::Io` wrappen, der beim Lesen einer Datei in `core::config` aufgetreten ist.
    - **`core::logging`**: Definiert die Logging-Infrastruktur basierend auf `tracing`.
        - **Schnittstelle**: Alle höheren Schichten verwenden die `tracing`-Makros (`trace!`, `info!`, etc.) für ihre Logging-Ausgaben. Die Funktion `core::logging::initialize_logging()` wird typischerweise einmalig von der Anwendung (z.B. UI-Schicht) beim Start aufgerufen.
    - **`core::config`**: Stellt Primitive zum Laden, Parsen und Zugreifen auf Kernkonfigurationen bereit.
        - **Schnittstelle**: Funktionen wie `load_core_config(custom_path: Option<PathBuf>) -> Result<CoreConfig, ConfigError>` und `get_core_config() -> &'static CoreConfig` für den globalen Zugriff. Die `CoreConfig`-Struktur selbst ist Teil der Schnittstelle.
        - **Beispielhafte Nutzung**: `domain::settings_persistence_iface` (oder eine konkrete Implementierung wie `FilesystemConfigProvider` ) nutzt diese API, um Basiskonfigurationen zu lesen, die dann von der Domänenschicht weiterverarbeitet werden.
    - **`core::utils`**: Bietet allgemeine Hilfsfunktionen.
        - **Schnittstelle**: Direkte Nutzung der öffentlichen Funktionen durch alle höheren Schichten.

**2. Schnittstelle: Domänenschicht (Domain Layer) zu Systemschicht und Benutzeroberflächenschicht**

Die Domänenschicht kapselt die Geschäftslogik und den Kernzustand der Desktop-Umgebung.

- **Bereitgestellte Funktionalität:**
    
    - **Service-APIs (Traits)**: Öffentliche Schnittstellen werden primär durch Rust-Traits definiert, die von Service-Strukturen innerhalb der Domänenmodule implementiert werden.
        - `domain::theming::ThemingEngine`: Methoden wie `get_current_theme_state()`, `update_configuration()`.
        - `domain::workspaces::WorkspaceManager`: Methoden wie `create_workspace()`, `set_active_workspace()`.
        - `domain::user_centric_services::AIInteractionLogicService`: Methoden wie `initiate_interaction()`, `provide_consent()`.
        - `domain::user_centric_services::NotificationService`: Methoden wie `post_notification()`, `get_active_notifications()`.
        - `domain::global_settings_and_state_management::GlobalSettingsService`: Methoden wie `load_settings()`, `update_setting()`.
    - **Datenstrukturen**: Öffentliche Datenstrukturen, die Zustände oder Konfigurationen repräsentieren (z.B. `AppliedThemeState`, `Workspace`, `Notification`, `GlobalDesktopSettings` ).
    - **Events**: Domänenspezifische Events, die Zustandsänderungen signalisieren.
        - Beispiele: `ThemeChangedEvent`, `WorkspaceEvent` (z.B. `ActiveWorkspaceChanged` ), `NotificationPostedEvent`, `SettingChangedEvent`.
    - **Fehlertypen**: Modulspezifische Fehler-Enums (z.B. `ThemingError`, `WorkspaceManagerError`, `AIInteractionError`, `GlobalSettingsError` ).
- **Nutzung durch die Systemschicht:**
    
    - Die Systemschicht konsumiert die Service-APIs der Domänenschicht, um Geschäftsregeln anzuwenden und Zustände abzufragen.
        - Der `system::compositor` nutzt `domain::window_management_policy` für Fensterplatzierungsrichtlinien.
        - Der `system::mcp` Client interagiert mit `AIInteractionLogicService` für Einwilligungsprüfungen und Kontextinformationen.
        - `system::dbus` (für Benachrichtigungen) interagiert mit `NotificationService`.
    - Die Systemschicht kann auf Domänen-Events reagieren, um ihr Verhalten anzupassen (z.B. Umschalten der sichtbaren Surfaces im Compositor bei `ActiveWorkspaceChanged` ).
    - Fehler aus der Domänenschicht werden in der Systemschicht behandelt oder weitergeleitet.
- **Nutzung durch die Benutzeroberflächenschicht:**
    
    - Die UI-Schicht nutzt die Service-APIs der Domänenschicht, um Daten für die Darstellung abzurufen und Benutzeraktionen in Domänenlogik umzusetzen.
        - `ui::control_center` verwendet `GlobalSettingsService` zum Anzeigen und Ändern von Einstellungen.
        - `ui::shell` interagiert mit `WorkspaceManager` für die Workspace-Darstellung und -Navigation.
        - `ui::theming_gtk` reagiert auf `ThemeChangedEvent` und wendet Stile an.
    - Die UI-Schicht abonniert Domänen-Events, um ihre Ansichten dynamisch zu aktualisieren.
    - Fehler aus der Domänenschicht werden von der UI-Schicht behandelt und dem Benutzer ggf. in verständlicher Form präsentiert.

**3. Schnittstelle: Systemschicht (System Layer) zu Benutzeroberflächenschicht (UI Layer)**

Die Systemschicht stellt der UI-Schicht systemnahe Dienste und Ereignisse zur Verfügung und setzt deren Befehle technisch um.

- **Bereitgestellte Funktionalität:**
    
    - **Systemereignisse und -zustände**:
        - **Fensterinformationen**: Geometrie, Titel, AppID, Fokusstatus von Fenstern (aus `system::compositor` und `system::xdg_shell`).
        - **Eingabeereignisse**: Verarbeitete Tastatur-, Maus-, Touch- und Gestenereignisse (aus `system::input`).
        - **Output-Informationen**: Verfügbare Monitore, Auflösungen, Skalierungsfaktoren (aus `system::outputs`).
        - **Status von Systemdiensten**: Netzwerkverbindungen (`system::dbus::networkmanager_client` ), Energiestatus (`system::dbus::upower_client` ), Audiostatus (`system::audio` ).
        - **Sitzungsereignisse**: Sperren, Abmelden (von `system::dbus::logind_client` ).
    - **Ausführung von UI-Befehlen**:
        - Fenstermanipulationen (Verschieben, Größe ändern, Fokus setzen), initiiert durch die UI, werden vom `system::compositor` und `system::window_mechanics` umgesetzt.
        - Workspace-Wechsel.
        - Anpassung von Systemeinstellungen (z.B. Bildschirmhelligkeit, Lautstärke), die von `system::outputs` bzw. `system::audio` ausgeführt werden.
    - **Fehlertypen**: Modulspezifische Fehler-Enums (z.B. `CompositorCoreError`, `InputError` ).
- **Nutzung durch die Benutzeroberflächenschicht:**
    
    - **Darstellung von Systeminformationen**: Die UI visualisiert die von der Systemschicht bereitgestellten Zustände.
        - Fensterlisten, Titelleisten, Fokus-Hervorhebungen basieren auf Daten von `system::compositor`.
        - Netzwerk-, Batterie-, Audio-Indikatoren in `ui::shell` zeigen Daten von `system::dbus` und `system::audio`.
    - **Reaktion auf Eingabeereignisse**: UI-Elemente reagieren auf verarbeitete Eingabeereignisse, um Aktionen auszulösen.
    - **Initiierung von Systemaktionen**: Benutzerinteraktionen in der UI führen zu Befehlsaufrufen an die Systemschicht.
        - Klick auf "Lauter"-Button in `ui::shell` ruft eine Funktion in `system::audio` auf.
        - Auswahl eines anderen Monitorsetups in `ui::control_center` sendet Befehl an `system::outputs`.
    - **Dialoge über XDG Portals**: `ui::shell` oder `ui::components` interagieren mit `system::portals` für Datei-Auswahl- oder Screenshot-Dialoge.
    - Die UI-Schicht behandelt Fehler von der Systemschicht und informiert ggf. den Benutzer.
    - Die UI-Schicht reagiert auf Systemereignisse (z.B. `ActiveWorkspaceChanged` indirekt über Änderungen der sichtbaren Fenster, `DeviceAdded` für Eingabegeräte), um ihre Darstellung anzupassen.

**4. Allgemeine Kommunikationsmuster**

- **Synchrone Aufrufe**: Direkte Methodenaufrufe an Services oder Funktionen der tieferen Schicht für Anfragen, die eine sofortige Antwort erfordern oder direkte Zustandsmanipulationen durchführen.
- **Asynchrone Operationen**: Wo sinnvoll (z.B. I/O-gebundene Operationen in der Systemschicht oder langlaufende Prozesse in der Domänenschicht), werden `async/await` und entsprechende Runtimes (Tokio, GLib-Kontext) verwendet.
- **Event-Broadcasting**: Für entkoppelte Benachrichtigungen über Zustandsänderungen. Oft mittels `tokio::sync::broadcast` oder ähnlichen Mechanismen.
- **Fehlerpropagation**: Konsequente Nutzung von `Result<T, E>` und dem `?`-Operator. Fehler werden entweder behandelt oder an die aufrufende Schicht weitergegeben, wobei die `source()`-Kette erhalten bleibt.

Diese detaillierte Spezifikation der internen Schnittstellen dient als Grundlage für eine modulare, wartbare und robuste Entwicklung der NovaDE. Die klare Trennung der Verantwortlichkeiten und die wohldefinierten Kommunikationswege sind entscheidend für den Erfolg des Projekts.

## Spezifikation und Implementierungsanleitung für die NovaDE-Systemschicht

**Ziel:** Erstellung einer robusten, performanten und modularen Systemschicht für die Nova Desktop Environment (NovaDE) in Rust. Diese Schicht interagiert mit dem Betriebssystem, der Hardware und externen Diensten und setzt die Richtlinien der Domänenschicht technisch um. Sie stellt die Grundlage für die Benutzeroberflächenschicht dar.

**Kernmodule und ihre Hauptverantwortlichkeiten:**

1. **`system::compositor`**: Smithay-basierter Wayland-Compositor; Fenster-Lebenszyklus, Protokoll-Implementierung (XDG-Shell, Layer-Shell etc.), Renderer-Abstraktion, XWayland.
2. **`system::input`**: `libinput`-basierte Eingabeverarbeitung; Seat-Management, `xkbcommon`-Integration, Event-Übersetzung für Tastatur, Zeiger, Touch, Gesten.
3. **`system::dbus_interfaces`**: `zbus`-basierte Clients für Systemdienste (NetworkManager, UPower, logind, Secrets, PolicyKit) und Server für `org.freedesktop.Notifications`.
4. **`system::audio_management`**: `pipewire-rs`-basierte PipeWire-Integration; Geräte- und Stream-Management, Lautstärkeregelung.
5. **`system::mcp_client`**: `mcp_client_rs`-basierter Client für das Model Context Protocol; sichere KI-Modell-Kommunikation.
6. **`system::window_mechanics`**: Technische Umsetzung der Fenster-Policies aus der Domänenschicht (Positionierung, Tiling, Fokus).
7. **`system::power_management`**: DPMS-Steuerung, Reaktion auf Inaktivität und logind-Ereignisse.
8. **`system::event_bridge`**: Zentraler Hub für systeminterne Events via `tokio::sync::broadcast`.

**Technologie-Stack (Auszug für Systemschicht):** Rust, Smithay, `libinput`, `xkbcommon`, `zbus`, `pipewire-rs`, `mcp_client_rs`, `calloop`, `tokio`.

**Entwicklungsrichtlinien:** Modulare Fehlerbehandlung (`thiserror`), strukturiertes Logging (`tracing`), `async/await` für nebenläufige Operationen.

**Folgend nun die detaillierten, feingranularen Schnittstellenspezifikationen pro Modul, die als direkte Implementierungsanweisung für eine KI-gestützte Entwicklung dienen.**

---

## Ultra-Feingranulare Schnittstellenspezifikation: NovaDE Systemschicht (`novade-system`)

Dieser Implementierungsleitfaden ist so konzipiert, dass er von einem autonomen KI-Entwicklungsagenten (z.B. Manus AI) direkt zur Codegenerierung verwendet werden kann. Jede Komponente, Datenstruktur, Methode und Interaktion ist explizit definiert, um Interpretationsspielraum zu minimieren.

### Modul 0: Vorbemerkungen und Globale Systemschicht-Konventionen

- **Crate-Name:** `novade-system`
- **Abhängigkeiten (exemplarisch, in `Cargo.toml` zu definieren):**
    - `novade-core = { path = "../novade-core" }`
    - `novade-domain = { path = "../novade-domain" }`
    - `smithay = "0.10.0"` (Version prüfen und Features nach Bedarf: `renderer_gl`, `backend_libinput`, `backend_session`, `backend_udev`, `backend_drm`, `desktop`, `xwayland`)
    - `wayland-server = "0.30"` (Smithay-kompatible Version)
    - `wayland-protocols = { version = "0.30", features = ["server", "unstable_protocols"] }`
    - `calloop = "0.12"`
    - `libinput = "0.9"`
    - `xkbcommon = "0.7"`
    - `zbus = { version = "3.15", default-features = false, features = ["tokio"] }` (Version prüfen)
    - `pipewire = "0.8"` (Version prüfen, ggf. `libspa`)
    - `mcp_client_rs = "0.2.0"` (Version prüfen)
    - `tokio = { version = "1.37", features = ["full"] }`
    - `async-trait = "0.1"`
    - `thiserror = "1.0"`
    - `tracing = "0.1"`
    - `uuid = { version = "1.8", features = ["v4"] }`
    - `serde = { version = "1.0", features = ["derive"] }`
    - `serde_json = "1.0"`
- **Fehlerbehandlung:** Jedes Submodul definiert ein eigenes `Error`-Enum mit `#[derive(Debug, thiserror::Error)]`. Fehler aus Bibliotheken werden mit `#[source]` oder `#[from]` gewrappt.
- **Logging:** `tracing::{trace, debug, info, warn, error}` Makros verwenden.
- **Asynchronität:** `async fn` für Operationen, die blockieren könnten. `calloop` für die Compositor-Hauptschleife, `tokio` für D-Bus, MCP und andere nebenläufige Tasks.

### Modul 1: `system::compositor`

Zweck: Implementierung des Wayland-Compositors.

#### 1.1. Submodul: `system::compositor::errors`

Datei: `src/compositor/errors.rs`

- **Enum `CompositorError`**:
    - Varianten (mit `#[error("...")]` und ggf. `#[source]` / `#[from]`):
        - `GlobalCreationFailed { name: String, details: String }`
        - `SurfaceRoleError(#[from] smithay::wayland::compositor::SurfaceRoleError)`
        - `ClientDataMissing { client_id_str: String }` (ClientId zu String für `Display`)
        - `SurfaceDataMissing { surface_id_str: String }` (WlSurface Debug zu String)
        - `InvalidSurfaceState { surface_id_str: String, reason: String }`
        - `RendererInitializationFailed(String)`
        - `DisplayOrLoopCreationFailed(String)`
        - `XWaylandInitializationFailed(String)`
        - `DrmBackendError { details: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
        - `LibinputBackendError(String)`
        - `SessionError(String)`
        - `XdgShellError(#[from] crate::compositor::xdg_shell::errors::XdgShellError)` (aus eigenem Submodul)
        - `LayerShellError(#[from] crate::compositor::layer_shell::errors::LayerShellError)` (aus eigenem Submodul)
        - `OutputManagementError(#[from] crate::compositor::output_management::errors::OutputManagementError)` (aus eigenem Submodul)

#### 1.2. Submodul: `system::compositor::types` (oder direkt in `core::state` und `surface_management`)

Datei: `src/compositor/types.rs` (oder aufgeteilt)

- **Struct `ClientCompositorData`** (für `Client::data_map`):
    - `compositor_state: smithay::wayland::compositor::CompositorClientState`
    - `xdg_shell_client_data: smithay::wayland::shell::xdg::XdgWmBaseClientData` (oder `XdgShellClientData` je nach Smithay Version)
- **Struct `SurfaceData`** (für `WlSurface::data_map`):
    - `id: uuid::Uuid`
    - `client_id_str: String`
    - `role: std::sync::Mutex<Option<String>>`
    - `current_buffer_info: std::sync::Mutex<Option<AttachedBufferInfo>>`
    - `texture_handle: std::sync::Mutex<Option<Box<dyn crate::compositor::renderer_interface::RenderableTexture>>>`
    - `damage_buffer_coords: std::sync::Mutex<Vec<smithay::utils::Rectangle<i32, smithay::utils::Buffer>>>`
    - `opaque_region_surface_local: std::sync::Mutex<Option<smithay::utils::Region<smithay::utils::Logical>>>`
    - `input_region_surface_local: std::sync::Mutex<Option<smithay::utils::Region<smithay::utils::Logical>>>`
    - `parent: std::sync::Mutex<Option<wayland_server::Weak<wayland_server::protocol::wl_surface::WlSurface>>>`
    - `children: std::sync::Mutex<Vec<wayland_server::Weak<wayland_server::protocol::wl_surface::WlSurface>>>`
    - `surface_viewporter_state: std::sync::Mutex<smithay::wayland::viewporter::SurfaceState>`
    - `surface_presentation_state: std::sync::Mutex<smithay::wayland::presentation::SurfaceState>`
    - `user_data_map: smithay::reexports::wayland_server::backend::UserDataMap` (für Shell-spezifische Daten)
    - **Methoden:** `new(client_id_str: String) -> Self`, `set_role(&self, role: &str) -> Result<(), CompositorError>`, `get_role(&self) -> Option<String>`.
- **Struct `AttachedBufferInfo`**:
    - `buffer: wayland_server::protocol::wl_buffer::WlBuffer`
    - `scale: i32`
    - `transform: smithay::utils::Transform`
    - `dimensions: smithay::utils::Size<i32, smithay::utils::Buffer>`

#### 1.3. Submodul: `system::compositor::core`

Datei: `src/compositor/core/state.rs`

- **Struct `DesktopState`** (zentraler Zustand, Details aus Gesamtspezifikation und System-Details):
    - **Felder (Auswahl):**
        - `display_handle: smithay::reexports::wayland_server::DisplayHandle`
        - `loop_handle: smithay::reexports::calloop::LoopHandle<'static, Self>`
        - `clock: smithay::utils::Clock<u64>`
        - `compositor_state: smithay::wayland::compositor::CompositorState`
        - `shm_state: smithay::wayland::shm::ShmState`
        - `presentation_state: smithay::wayland::presentation::PresentationState`
        - `viewporter_state: smithay::wayland::viewporter::ViewporterState`
        - `xdg_shell_state: smithay::wayland::shell::xdg::XdgShellState`
        - `xdg_activation_state: smithay::wayland::xdg_activation::XdgActivationState`
        - `layer_shell_state: smithay::wayland::shell::wlr_layer::WlrLayerShellState`
        - `decoration_state: smithay::wayland::shell::xdg::decoration::XdgDecorationState`
        - `space: std::sync::Arc<std::sync::Mutex<smithay::desktop::Space<ManagedWindow>>>`
        - `windows: std::sync::Arc<std::sync::Mutex<std::collections::HashMap<crate::domain::workspaces::core::types::WindowIdentifier, Arc<ManagedWindow>>>>`
        - `seat_state: smithay::input::SeatState<Self>`
        - `seat: smithay::input::Seat<Self>`
        - `seat_name: String`
        - `input_method_manager_state: smithay::wayland::input_method::InputMethodManagerState`
        - `keyboard_data_map: std::sync::Arc<std::sync::Mutex<std::collections::HashMap<String, crate::input::keyboard::xkb_config::XkbKeyboardData>>>`
        - `current_cursor_status: std::sync::Arc<std::sync::Mutex<smithay::input::pointer::CursorImageStatus>>`
        - `pointer_location: std::sync::Arc<std::sync::Mutex<smithay::utils::Point<f64, smithay::utils::Logical>>>`
        - `output_manager_state: smithay::wayland::output::OutputManagerState`
        - `wlr_output_manager_v1_state: smithay::wayland::output_manager::OutputManagerState` (für wlr-output-management)
        - `wlr_output_power_manager_v1_state: smithay::wayland::output_power_manager::OutputPowerManagerState` (für wlr-output-power-management)
        - `data_device_state: smithay::wayland::selection::data_device::DataDeviceState`
        - `renderer: Option<Box<dyn crate::compositor::renderer_interface::FrameRenderer>>` (wird nach Backend-Init gesetzt)
        - `domain_services: Arc<crate::domain::DomainServices>` (Sammelstruktur für Domänen-Service-Handles)
        - `system_event_bridge: Arc<crate::event_bridge::SystemEventBridge>`
        - `active_backend_data: std::sync::Mutex<Option<ActiveBackendData>>` (Enum für DRM, Winit etc. Daten)
        - `wayland_globals: Option<NovaDEWaylandGlobals>` (Struct, das `GlobalId`s hält)
    - **Konstruktor:** `pub fn new(loop_handle, display_handle, domain_services, system_event_bridge) -> Self` (initialisiert alle Smithay-States).
    - **Methoden:** `pub fn create_all_wayland_globals(&mut self) -> Result<(), CompositorError>` (registriert alle Globals).
- **Implementierung von `smithay::wayland::compositor::CompositorHandler` für `DesktopState`**:
    - `compositor_state(&mut self) -> &mut CompositorState`: `&mut self.compositor_state`
    - `client_compositor_state<'a>(&self, client: &'a Client) -> &'a CompositorClientState`: `&client.get_data::<ClientCompositorData>().unwrap().compositor_state`
    - `commit(&mut self, surface: &WlSurface)`: Logik wie in spezifiziert (Puffer-Handling, Schaden, Rollen-Dispatch, Sync-Subsurfaces). Verwendet `with_surface_data_mut` für Zugriff auf `SurfaceData`.
    - `new_surface(&mut self, surface: &WlSurface)`: `surface.data_map().insert_if_missing_threadsafe(|| Arc::new(SurfaceData::new(...))); add_destruction_hook(...)`.
    - `new_subsurface(&mut self, surface: &WlSurface, parent: &WlSurface)`: Verlinkt Parent/Child in `SurfaceData`.
    - `destroyed(&mut self, surface: &WlSurface)`: Hauptsächlich für Logging und ggf. explizite Benachrichtigung anderer Teile von `DesktopState`, die `WlSurface` direkt referenzieren (obwohl `destruction_hook` bevorzugt wird).
- **Implementierung von `smithay::wayland::shm::ShmHandler` und `smithay::wayland::buffer::BufferHandler` für `DesktopState`**:
    - `shm_state(&self) -> &ShmState`: `&self.shm_state`
    - `buffer_destroyed(&mut self, buffer: &WlBuffer)`: Benachrichtigt Renderer zur Freigabe von Texturen, die mit diesem `buffer` assoziiert sind (Identifikation über `SurfaceData`).

#### 1.4. Submodul: `system::compositor::xdg_shell`

Datei: `src/compositor/xdg_shell/errors.rs`, `types.rs`, `handlers.rs`

- **Enum `XdgShellError`**: (Wie in spezifiziert)
- **Struct `ManagedWindow`** (Implementiert `smithay::desktop::Window`):
    - **Felder:** `id: uuid::Uuid`, `domain_id: crate::domain::workspaces::core::types::WindowIdentifier`, `xdg_surface: smithay::desktop::WindowSurface` (hält `ToplevelSurface` oder `PopupSurface`), `current_geometry: smithay::utils::Rectangle<i32, smithay::utils::Logical>`, `is_mapped: bool`, `requested_size`, `min_size`, `max_size`, `parent_window_domain_id: Option<DomainWindowIdentifier>`.
    - **Methoden:** `new_toplevel(...)`, `new_popup(...)`, `wl_surface()`, Methoden des `Window`-Traits (send_configure, set_activated, etc. – rufen Methoden auf `self.xdg_surface` auf).
- **Implementierung `smithay::wayland::shell::xdg::XdgShellHandler` für `DesktopState`**:
    - `xdg_shell_state(&mut self) -> &mut XdgShellState`: `&mut self.xdg_shell_state`
    - `new_toplevel(&mut self, surface: ToplevelSurface)`: Erstellt `ManagedWindow`, fordert initiale Geometrie von `domain::window_management_policy_service` an, sendet initiales `configure`, fügt zu `self.space` und `self.windows` hinzu.
    - `new_popup(&mut self, surface: PopupSurface, positioner: PositionerState)`: Erstellt `ManagedWindow` (als Popup), berechnet Geometrie basierend auf `positioner` und Parent, sendet `configure`, fügt zu `self.windows` hinzu.
    - `map_toplevel(&mut self, surface: &ToplevelSurface)`: Setzt `managed_window.is_mapped = true`, benachrichtigt Domäne (`workspace_manager_service.assign_window_to_active_workspace`), fordert Re-Layout.
    - `unmap_toplevel(&mut self, surface: &ToplevelSurface)`: Setzt `is_mapped = false`, benachrichtigt Domäne, entfernt aus `space`.
    - `ack_configure(&mut self, surface: WlSurface, configure_data: XdgSurfaceConfigureUserData)`: Verarbeitet Client-Bestätigung.
    - **Request-Handler** (`toplevel_request_set_title`, `toplevel_request_set_maximized`, `move_request`, `resize_request`, etc.):
        1. Findet `ManagedWindow` für das `ToplevelSurface`/`PopupSurface`.
        2. Aktualisiert den Zustand im `ManagedWindow` und/oder dessen Smithay `XdgToplevelSurfaceData`/`XdgPopupSurfaceData`.
        3. Interagiert mit `self.domain_services.window_policy_service` für Validierung oder Policy-Anpassungen.
        4. Sendet bei Bedarf neue `configure`-Events an den Client.
        5. Für `move` und `resize`: Startet einen interaktiven Grab über `self.seat.start_pointer_grab(...)` mit einer spezifischen Grab-Handler-Implementierung (siehe `system::window_mechanics`).
    - `toplevel_destroyed(&mut self, toplevel: ToplevelSurface)` / `popup_destroyed(&mut self, popup: PopupSurface)`: Entfernt `ManagedWindow` aus `self.space` und `self.windows`, benachrichtigt Domäne.

#### 1.5. Submodul: `system::compositor::layer_shell`

Datei: `src/compositor/layer_shell/errors.rs`, `types.rs`, `handlers.rs`

- **Enum `LayerShellError`**: `InvalidLayerSurfaceState`, `NamespaceAlreadyTaken`.
- **Struct `ManagedLayerSurface`** (Implementiert `smithay::desktop::LayerSurface`):
    - **Felder:** `id: uuid::Uuid`, `domain_id: crate::domain::workspaces::core::types::WindowIdentifier` (für Panel/Dock-Identifikation), `layer_surface: smithay::wayland::shell::wlr_layer::LayerSurface`, `current_geometry`, `is_mapped`.
- **Implementierung `smithay::wayland::shell::wlr_layer::LayerShellHandler` für `DesktopState`**:
    - `layer_shell_state(&mut self) -> &mut WlrLayerShellState`: `&mut self.layer_shell_state`
    - `new_layer_surface(&mut self, surface: LayerSurface, output: Option<Output>, layer: Layer, namespace: String)`: Erstellt `ManagedLayerSurface`, validiert Namespace, konfiguriert Layer und Anker, sendet initiales `configure`. Fügt zu `smithay::desktop::layer_map_for_output(output).map_layer(&layer_surface)`.
    - `layer_surface_commit(&mut self, surface: &LayerSurface)`: Reagiert auf Puffer-Commits, aktualisiert ggf. Geometrie basierend auf Client-Requests.
    - `layer_surface_destroyed(&mut self, surface: &LayerSurface)`: Entfernt aus Layer Map.

#### 1.6. Weitere `system::compositor` Submodule (Struktur analog)

- **`decoration`**: `XdgDecorationHandler` für `xdg-decoration-unstable-v1`. Verwaltet `XdgDecorationState`.
- **`output_management`**: Implementierung von `smithay::wayland::output::OutputHandler`, `smithay::wayland::output_manager::OutputManagerHandler` (für `wlr-output-management-unstable-v1`) und `smithay::wayland::xdg_output::XdgOutputHandler` (für `xdg-output-unstable-v1`). `DesktopState` hält `OutputManagerState`.
- **`input_method`**: `InputMethodHandler`, `TextInputHandler`. `DesktopState` hält `InputMethodManagerState`, `TextInputManagerState`.
- **`screencopy`**: Implementierung von `wlr-screencopy-unstable-v1` (benötigt Zugriff auf Renderer).
- **`data_device`**: `DataDeviceHandler`, `PrimarySelectionHandler`. `DesktopState` hält `DataDeviceState`, `PrimarySelectionState`.
- **`xwayland`**: `XWayland`, `X11Wm`, `XwmHandler`. Starten und Verwalten des XWayland-Servers.
- **`renderer_interface`**:
    - Trait `RenderableTexture: Send + Sync + std::fmt::Debug { fn id(&self) -> uuid::Uuid; fn bind(&self, slot: u32) -> Result<()>; fn width_px(&self) -> u32; ... }`
    - Trait `FrameRenderer: Send + Sync { fn new(...) -> Result<Self>; fn render_frame(...); fn present_frame(...); fn create_texture_from_shm(...); ... }`
    - Enum `RenderElement { Surface { texture, geometry, damage, ... }, Cursor { ... } }`
- **`drm_gbm_renderer` / `winit_renderer`**: Konkrete Implementierungen von `FrameRenderer`.

### Modul 2: `system::input`

Zweck: Eingabeverarbeitung.

#### 2.1. Submodul: `system::input::errors`

Datei: `src/input/errors.rs`

- **Enum `InputError`**: (Wie in spezifiziert) `SeatCreationFailed`, `CapabilityAdditionFailed`, `XkbConfigError`, `LibinputError`, `LibinputSessionError`, `SeatNotFound`, `KeyboardHandleNotFound`, etc.

#### 2.2. Submodul: `system::input::types` (oder in `keyboard`, `pointer` etc.)

Datei: `src/input/types.rs`

- **Struct `XkbConfig`** (aus `smithay::input::keyboard::KeyboardConfig`)
- **Struct `XkbKeyboardData`**:
    - `context: xkbcommon::xkb::Context`
    - `keymap: xkbcommon::xkb::Keymap`
    - `state: xkbcommon::xkb::State`
    - `repeat_timer: Option<calloop::TimerHandle>`
    - `repeat_info: Option<(u32 /* libinput keycode */, xkbcommon::xkb::Keycode /* xkb keycode */, SmithayModifiersState, std::time::Duration, std::time::Duration)>`
    - `focused_surface_on_seat: Option<wayland_server::Weak<WlSurface>>`
    - `repeat_key_serial: Option<smithay::utils::Serial>`
    - **Methoden:** `new(config: &XkbConfig) -> Result<Self, InputError>`, `update_xkb_state_from_modifiers(...)`.
- **Event `InputDeviceHotplugEvent`** (für `system::event_bridge`):
    - `device_name: String`
    - `device_type: String` (z.B. "keyboard", "pointer", "touch")
    - `event_type: HotplugType (Added | Removed)`

#### 2.3. Submodul: `system::input::seat_manager`

Datei: `src/input/seat_manager.rs`

- **`DesktopState` Implementierung von `smithay::input::SeatHandler`**:
    - `seat_state(&mut self) -> &mut SeatState<Self>`: `&mut self.seat_state`
    - `focus_changed(&mut self, seat: &Seat<Self>, focused_surface: Option<&WlSurface>)`: Aktualisiert internen Fokus-Cache (`self.active_input_surface`), benachrichtigt Domänenschicht (`domain::window_management_policy` oder `workspace_manager`) über Fokuswechsel. _Wichtig:_ `KeyboardHandle::set_focus` löst dies aus; hier nicht erneut `set_focus` rufen.
    - `cursor_image(&mut self, seat: &Seat<Self>, image: CursorImageStatus)`: Aktualisiert `self.current_cursor_status`, benachrichtigt Renderer zur Neudarstellung des Cursors. Bei `Named(name)`: Logik zum Laden von Cursorthemes (ggf. `libwayland-cursor` oder eigene Implementierung).
- **Funktion `pub fn create_seat(state: &mut DesktopState, display_handle: &DisplayHandle, seat_name: String) -> Result<(), InputError>`**:
    1. `seat = state.seat_state.new_wl_seat(display_handle, seat_name.clone(), ...);`
    2. `state.seats.insert(seat_name.clone(), seat.clone());` (Oder `state.seat = seat.clone()` für primären Seat).
    3. Initialisiere `XkbKeyboardData` für diesen Seat in `state.keyboard_data_map`.
    4. Fähigkeiten (Keyboard, Pointer, Touch) werden später hinzugefügt, wenn `LibinputInputBackend` Geräte meldet.

#### 2.4. Submodul: `system::input::libinput_handler`

Datei: `src/input/libinput_handler/mod.rs` (und ggf. `session_interface.rs`)

- **Struct `LibinputSessionInterface`** (implementiert `smithay::backend::input::LibinputInterface`): Kapselt `smithay::backend::session::Session` (z.B. `LogindSession` oder `DirectSession`). Methoden `open_restricted`, `close_restricted`.
- **Funktion `pub fn init_libinput_backend<S: Session + 'static>(session_interface: Rc<RefCell<S>>) -> Result<LibinputInputBackend, InputError>`**: Erstellt `LibinputInputBackend`.
- **Funktion `pub fn register_libinput_event_source(loop_handle: &LoopHandle<DesktopState>, backend: LibinputInputBackend, seat_name_for_callback: String) -> Result<calloop::Source<LibinputInputBackend>, InputError>`**: Fügt Backend zur `calloop`-Schleife hinzu. Callback ruft `process_input_event`.
- **Funktion `pub fn process_input_event(desktop_state: &mut DesktopState, event: InputEvent<LibinputInputBackend>, seat_name: &str)`**:
    1. Holt `Seat<DesktopState>` für `seat_name`.
    2. `match event`:
        - `DeviceAdded { device }`: `tracing::info!(...)`. Prüft `device.capabilities()`. Wenn z.B. `Keyboard` und Seat noch keine Tastatur hat: `seat.add_keyboard(XkbConfig::default(), 200, 25)?`. Analog für Pointer, Touch. Sendet `InputDeviceHotplugEvent`.
        - `DeviceRemoved { device }`: `tracing::info!(...)`. Entfernt Capabilities vom Seat. Sendet `InputDeviceHotplugEvent`.
        - `Keyboard { event }`: Ruft `crate::input::keyboard::key_event_translator::handle_keyboard_event(...)`.
        - `PointerMotion { event }`: Ruft `crate::input::pointer::pointer_event_translator::handle_pointer_motion_event(...)`.
        - (Analog für `PointerMotionAbsolute`, `PointerButton`, `PointerAxis`, `TouchDown`, `TouchUp`, `TouchMotion`, `TouchFrame`, `TouchCancel`, `Gesture*`).

#### 2.5. Submodule: `system::input::keyboard`, `system::input::pointer`, `system::input::touch`, `system::input::gestures`

- **`keyboard::key_event_translator::handle_keyboard_event(...)`**:
    1. Holt `KeyboardHandle<DesktopState>` und `XkbKeyboardData`.
    2. Konvertiert `libinput keycode` zu `xkbcommon keycode` (`+8`).
    3. `xkb_data.state.update_key(...)`.
    4. Holt `SmithayModifiersState` von `xkb_data.state`.
    5. `keyboard_handle.modifiers(serial, mods_state, ...)`
    6. Wenn `KeyState::Pressed`: `keyboard_handle.key(serial, time, xkb_keycode, KeyState::Pressed, ...)`. Tastenwiederholung einrichten/aktualisieren (via `calloop::TimerHandle` in `XkbKeyboardData`, Callback sendet erneut `key` Event mit neuem Serial).
    7. Wenn `KeyState::Released`: `keyboard_handle.key(...)`. Tastenwiederholung abbrechen.
- **`keyboard::focus::set_keyboard_focus(...)`**:
    1. Holt `KeyboardHandle<DesktopState>` und `XkbKeyboardData`.
    2. `keyboard_handle.set_focus(target_surface_option, serial, ...)` (Smithay sendet `enter`/`leave`).
    3. Aktualisiert `xkb_data.focused_surface_on_seat`.
    4. Benachrichtigt Domäne (via `desktop_state.domain_services...` oder `SystemEventBridge`).
- **`pointer::pointer_event_translator::handle_pointer_motion_event(...)`**:
    1. Holt `PointerHandle<DesktopState>`.
    2. Aktualisiert `desktop_state.pointer_location` basierend auf `event.delta()`.
    3. `let (new_focus_surface, surface_local_coords) = find_surface_and_coords_at_global_point(desktop_state, desktop_state.pointer_location)`.
    4. `pointer_handle.motion(time, new_focus_surface.as_ref(), serial, desktop_state.pointer_location, surface_local_coords, ...)` (Smithay sendet `enter`/`leave`/`motion`).
    5. Aktualisiert `desktop_state.active_input_surface`.
- **`find_surface_and_coords_at_global_point(...)`**: Iteriert `desktop_state.space.elements_under(global_pos)`, prüft `input_region` von `SurfaceData`.
- (Analog für andere Zeiger- und Touch-Events, die entsprechende `PointerHandle`- und `TouchHandle`-Methoden aufrufen).

---

(Die Spezifikationen für die Module `system::dbus_interfaces`, `system::audio_management`, `system::mcp_client`, `system::window_mechanics`, `system::power_management` und `system::event_bridge` würden mit derselben Detailtiefe folgen, basierend auf den vorherigen Antworten und den Quelldokumenten.)

**Dieser ultra-feingranulare Implementierungsleitfaden für die Systemschicht, beginnend mit dem Compositor und der Eingabeverarbeitung, legt eine präzise Basis für die Entwicklung. Die konsequente Anwendung der definierten Strukturen, Methoden, Fehler und Events durch einen KI-Agenten soll zu einer robusten und korrekten Implementierung führen.**

Ultra-Feinspezifikation und Implementierungsleitfaden der internen Schnittstellen der Linux Desktop-Umgebung "NovaDE"EinleitungDieses Dokument dient als erweiterte technische Spezifikation und detaillierter Implementierungsleitfaden für die internen Schnittstellen zwischen den vier Hauptarchitekturschichten der Linux Desktop-Umgebung "NovaDE": Kernschicht (Core Layer), Domänenschicht (Domain Layer), Systemschicht (System Layer) und Benutzeroberflächenschicht (UI Layer). Die Kommunikation zwischen diesen Schichten erfolgt primär über wohldefinierte öffentliche APIs, die häufig als Rust-Traits implementiert sind, sowie über ein robustes Event-System zur Signalisierung von Zustandsänderungen. Ziel dieses Dokuments ist es, eine lückenlose Ultra-Feinspezifikation bereitzustellen, die Entwicklern eine direkte Implementierung ohne eigene Entwurfsentscheidungen ermöglicht. Alle relevanten Aspekte wurden recherchiert, entschieden und präzise spezifiziert, um Klarheit und Konsistenz über das gesamte System hinweg zu gewährleisten.Die hier dargelegten Spezifikationen sind entscheidend, um die kohärente Zusammenarbeit der verschiedenen Schichten sicherzustellen und die übergeordneten Projektziele – Performance, Intuition, Modernität, Modularität, Anpassbarkeit, sichere KI-Integration und Stabilität – zu erreichen.1. Schnittstelle: Kernschicht (Core Layer) zu höheren Schichten (Domäne, System, UI)Die Kernschicht stellt fundamentale Bausteine und Dienste bereit, die von allen darüberliegenden Schichten genutzt werden. Diese Dienste sind so konzipiert, dass sie maximale Wiederverwendbarkeit und minimale Abhängigkeiten für die höheren Schichten gewährleisten.1.1. Bereitgestellte Funktionalität1.1.1. core::typesDefiniert grundlegende, universell einsetzbare Datentypen.
Schnittstelle: Direkte Verwendung von Typen wie Point<T>, Size<T>, Rect<T>, RectInt, Color, Orientation sowie uuid::Uuid und chrono::DateTime<Utc> durch die höheren Schichten.
Beispielhafte Nutzung: Die Domänenschicht verwendet Color für Theming-Definitionen, die Systemschicht RectInt für Fenstergeometrien, und die UI-Schicht Point<T> für die Positionierung von Elementen.
1.1.2. core::errorsStellt eine Basis-Fehlerbehandlungsstrategie und den CoreError-Typ bereit.
Schnittstelle: Höhere Schichten können CoreError oder spezifischere Fehler aus Kernmodulen mittels #[from] oder #[source] in ihre eigenen Fehlertypen wrappen. Die Fehlerursachenkette (source()) wird dabei beibehalten.1
Beispielhafte Nutzung: Ein ConfigError in domain::workspaces::config kann einen CoreError::Io wrappen, der beim Lesen einer Datei in core::config aufgetreten ist.
1.1.3. core::loggingDefiniert die Logging-Infrastruktur basierend auf tracing.
Schnittstelle: Alle höheren Schichten verwenden die tracing-Makros (trace!, info!, etc.) für ihre Logging-Ausgaben. Die Funktion core::logging::initialize_logging() wird typischerweise einmalig von der Anwendung (z.B. UI-Schicht) beim Start aufgerufen.
1.1.4. core::configStellt Primitive zum Laden, Parsen und Zugreifen auf Kernkonfigurationen bereit.
Schnittstelle: Funktionen wie load_core_config(custom_path: Option<PathBuf>) -> Result<CoreConfig, ConfigError> und get_core_config() -> &'static CoreConfig für den globalen Zugriff. Die CoreConfig-Struktur selbst ist Teil der Schnittstelle.
Beispielhafte Nutzung: domain::settings_persistence_iface (oder eine konkrete Implementierung wie FilesystemConfigProvider) nutzt diese API, um Basiskonfigurationen zu lesen, die dann von der Domänenschicht weiterverarbeitet werden.
1.1.5. core::utilsBietet allgemeine Hilfsfunktionen.
Schnittstelle: Direkte Nutzung der öffentlichen Funktionen durch alle höheren Schichten.
1.2. Ultra-Feinspezifikation: Modul core::config::loaderDieses interne Modul ist für das Laden und Parsen von Konfigurationsdateien für das öffentliche core::config API zuständig.1.2.1. Modulübersicht
Zweck: Implementiert die Logik zum Auffinden, Lesen und Deserialisieren der Kernkonfigurationsdatei (core.json oder ein anderes gewähltes Format).
Interne Abhängigkeiten: core::types (für PathBuf), core::errors::CoreError, super::types::CoreConfig (die öffentliche Konfigurationsstruktur), super::errors::ConfigError.
Externe Abhängigkeiten: serde, serde_json (oder toml, etc.), std::fs, std::path, std::io.
1.2.2. Interne Datenstrukturen
struct RawCoreConfig

Datei: nova_de/core/src/config/raw_types.rs
Zweck: Dient der direkten Deserialisierung der Konfigurationsdatei. Dies ermöglicht Flexibilität bei der Versionierung und Validierung der Konfiguration, bevor sie in die öffentliche CoreConfig-Struktur überführt wird. Felder sind typischerweise Option<T>, um fehlende Werte abzufangen und Defaults anzuwenden.
Attribute: Spiegeln die Felder von CoreConfig, jedoch als Option<String>, Option<bool>, etc. Beispiel:
Rust// nova_de/core/src/config/raw_types.rs
use serde::Deserialize;

#
pub(super) struct RawCoreConfig {
    pub(super) log_level: Option<String>,
    pub(super) default_theme_name: Option<String>,
    pub(super) enable_experimental_features: Option<bool>,
    // Weitere Felder entsprechend CoreConfig
}


Sichtbarkeit: pub(super) innerhalb des core::config Moduls.


1.2.3. Fehlerbehandlung: ConfigError
Datei: nova_de/core/src/config/errors.rs (oder in core::errors integriert)
Definition:
Rust// nova_de/core/src/config/errors.rs
use std::io;
use std::path::PathBuf;
use thiserror::Error;

#
pub enum ConfigError {
    #
    NotFound { searched_paths: Vec<PathBuf> },

    #[error("I/O error accessing config file at {path:?}")]
    Io {
        path: PathBuf,
        #[source]
        source: io::Error,
    },

    #[error("Failed to parse config file at {path:?}")]
    ParseError {
        path: PathBuf,
        #[source]
        source: serde_json::Error, // Oder anderer Deserialisierungsfehler
        content_snippet: String, // Ein kurzer Ausschnitt des fehlerhaften Inhalts
    },

    #[error("Invalid configuration value for key '{key}': {message}")]
    InvalidValue { key: String, message: String },

    #[error("Could not determine home directory")]
    HomeDirectoryNotFound,
}

Die Verwendung von thiserror ermöglicht eine klare Fehlerdefinition und -verkettung.1
1.2.4. Interne Funktionen

fn resolve_config_path(custom_path: Option<&PathBuf>) -> Result<PathBuf, ConfigError>

Datei: nova_de/core/src/config/loader.rs
Zweck: Bestimmt den zu ladenden Konfigurationspfad gemäß der XDG Base Directory Specification und optionalen benutzerdefinierten Pfaden.
Parameter:

custom_path: Option<&PathBuf> (const): Ein optional vom Benutzer bereitgestellter Pfad.


Rückgabe: Result<PathBuf, ConfigError> - Der aufgelöste Pfad oder ein ConfigError::NotFound.
Implementierungsschritte:

Wenn custom_path Some(path) ist:

Prüfen, ob path existiert. Wenn ja, Ok(path.clone()) zurückgeben.
Wenn nicht, Err(ConfigError::NotFound { searched_paths: vec![path.clone()] }) zurückgeben (oder spezifischerer Fehler).


Andernfalls XDG-Pfade prüfen:

xdg_config_home = std::env::var("XDG_CONFIG_HOME").map(PathBuf::from).or_else(|_| dirs::home_dir().map(|h| h.join(".config"))).ok_or(ConfigError::HomeDirectoryNotFound)?;
user_path = xdg_config_home.join("novade/core.json");
Wenn user_path existiert, Ok(user_path) zurückgeben.


Systemweite XDG-Pfade prüfen:

xdg_config_dirs = std::env::var("XDG_CONFIG_DIRS").map(|dirs| dirs.split(':').map(PathBuf::from).collect::<Vec<_>>()).unwrap_or_else(|_| vec!);
Für jeden dir in xdg_config_dirs:

system_path = dir.join("novade/core.json");
Wenn system_path existiert, Ok(system_path) zurückgeben.




Fallback-Systempfad prüfen:

fallback_path = PathBuf::from("/etc/novade/core.json");
Wenn fallback_path existiert, Ok(fallback_path) zurückgeben.


Wenn keine Datei gefunden wurde, Err(ConfigError::NotFound { searched_paths:... }) mit allen geprüften Pfaden zurückgeben.


Vorbedingungen: Keine.
Nachbedingungen: Gibt einen validen, existierenden Pfad zurück oder einen Fehler.



fn read_config_file(path: &Path) -> Result<String, ConfigError>

Datei: nova_de/core/src/config/loader.rs
Zweck: Liest den Inhalt der Konfigurationsdatei.
Parameter:

path: &Path (const): Pfad zur Konfigurationsdatei.


Rückgabe: Result<String, ConfigError> - Dateiinhalt als String oder ein ConfigError::Io.
Implementierungsschritte:

std::fs::read_to_string(path).map_err(|e| ConfigError::Io { path: path.to_path_buf(), source: e })


Vorbedingungen: path ist ein valider Pfad.
Nachbedingungen: Gibt den Dateiinhalt zurück oder einen I/O-Fehler.



fn parse_raw_config(content: &str, path: &Path) -> Result<RawCoreConfig, ConfigError>

Datei: nova_de/core/src/config/loader.rs
Zweck: Parst den String-Inhalt in die RawCoreConfig-Struktur.
Parameter:

content: &str (const): Der zu parsende String-Inhalt.
path: &Path (const): Der Pfad der Konfigurationsdatei (für Fehlerberichte).


Rückgabe: Result<RawCoreConfig, ConfigError> - Die geparste Rohkonfiguration oder ein ConfigError::ParseError.
Implementierungsschritte:

serde_json::from_str(content).map_err(|e| ConfigError::ParseError { path: path.to_path_buf(), source: e, content_snippet: content.chars().take(100).collect() })


Vorbedingungen: content ist ein valider String.
Nachbedingungen: Gibt die geparste Rohkonfiguration zurück oder einen Parse-Fehler.



fn convert_raw_to_core_config(raw_config: RawCoreConfig, config_path: &Path) -> Result<CoreConfig, ConfigError>

Datei: nova_de/core/src/config/loader.rs
Zweck: Konvertiert RawCoreConfig in CoreConfig, wendet Standardwerte an und validiert Werte.
Parameter:

raw_config: RawCoreConfig: Die geparste Rohkonfiguration.
config_path: &Path: Pfad zur Konfigurationsdatei für Fehlerberichte und Kontext.


Rückgabe: Result<CoreConfig, ConfigError> - Die validierte CoreConfig oder ein ConfigError::InvalidValue.
Implementierungsschrite:

Erstelle eine CoreConfig-Instanz.
Für jedes Feld in RawCoreConfig:

Wenn Some(value), validiere value. Bei Ungültigkeit, Err(ConfigError::InvalidValue { key: "...", message: "..." }) zurückgeben.
Wenn None, verwende einen hartcodierten Standardwert für CoreConfig.
Beispiel: log_level = raw_config.log_level.unwrap_or_else(|| "info".to_string());
Validierung für log_level: Muss einer der unterstützten Werte sein (z.B. "trace", "debug", "info", "warn", "error").


Ok(core_config) zurückgeben.


Vorbedingungen: raw_config ist vorhanden.
Nachbedingungen: Gibt eine valide CoreConfig zurück oder einen Fehler bei ungültigen Werten.


1.2.5. Öffentliche Funktion (innerhalb core::config)
pub(super) fn load_and_parse_core_config(custom_path: Option<PathBuf>) -> Result<CoreConfig, ConfigError>

Datei: nova_de/core/src/config/mod.rs (ruft Funktionen aus loader.rs auf)
Zweck: Orchestriert den gesamten Lade- und Parse-Vorgang. Dies ist die Hauptfunktion, die von der öffentlichen API load_core_config genutzt wird.
Parameter:

custom_path: Option<PathBuf>: Optionaler benutzerdefinierter Pfad.


Rückgabe: Result<CoreConfig, ConfigError>.
Implementierungsschritte:

let resolved_path = loader::resolve_config_path(custom_path.as_ref())?;
let content = loader::read_config_file(&resolved_path)?;
let raw_config = loader::parse_raw_config(&content, &resolved_path)?;
loader::convert_raw_to_core_config(raw_config, &resolved_path)


Vorbedingungen: Keine.
Nachbedingungen: Gibt eine geladene und validierte CoreConfig zurück oder einen entsprechenden ConfigError.


Die Trennung von RawCoreConfig und CoreConfig ist eine bewährte Methode, um die API stabil zu halten, während interne Repräsentationen oder Konfigurationsdateiformate versioniert oder migriert werden können. Dies erhöht die Robustheit und Wartbarkeit des Konfigurationssystems.1.3. Ultra-Feinspezifikation: Modul core::types_moduleDieses Modul ist das Fundament für viele Datenaustauschoperationen innerhalb von NovaDE.1.3.1. Modulübersicht
Zweck: Definition und Implementierung fundamentaler, wiederverwendbarer Datentypen wie geometrische Primitiven (Point, Size, Rect), Color und Orientation. Stellt auch uuid::Uuid und chrono::DateTime<Utc> für das gesamte System bereit.
Dateistruktur:

nova_de/core/src/types/mod.rs: Hauptmoduldatei, exportiert alle Typen.
nova_de/core/src/types/point.rs: Definition von Point<T>.
nova_de/core/src/types/size.rs: Definition von Size<T>.
nova_de/core/src/types/rect.rs: Definition von Rect<T> und RectInt.
nova_de/core/src/types/color.rs: Definition von Color und ColorParseError.
nova_de/core/src/types/orientation.rs: Definition von Orientation.


Abhängigkeiten: uuid (mit Features "serde", "v4"), chrono (mit Feature "serde").5
1.3.2. Datentyp-SpezifikationenPoint<T>
Datei: nova_de/core/src/types/point.rs
Definition:
Rust#
#
pub struct Point<T> {
    pub x: T,
    pub y: T,
}


Attribute:

x: T - Sichtbarkeit: pub. X-Koordinate.
y: T - Sichtbarkeit: pub. Y-Koordinate.


Methoden:

pub const fn new(x: T, y: T) -> Self: Erzeugt einen neuen Punkt.
pub fn map<U, F>(&self, f: F) -> Point<U> where F: Fn(T) -> U, T: Copy: Mappt die Koordinaten zu einem neuen Typ.
Für T: std::ops::Add<Output = T> + Copy:

pub fn offset(&self, dx: T, dy: T) -> Self: Verschiebt den Punkt um (dx, dy).


Für T: std::ops::Sub<Output = T> + Copy:

pub fn vector_to(&self, other: &Point<T>) -> Point<T>: Erzeugt einen Vektor (als Punkt) von self zu other.




Invarianten: Keine über die Typ-Constraints von T hinaus.
Size<T>
Datei: nova_de/core/src/types/size.rs
Definition:
Rust#
#
pub struct Size<T> {
    pub w: T, // width
    pub h: T, // height
}


Attribute:

w: T - Sichtbarkeit: pub. Breite.
h: T - Sichtbarkeit: pub. Höhe.


Methoden:

pub const fn new(w: T, h: T) -> Self: Erzeugt eine neue Größe.
pub fn map<U, F>(&self, f: F) -> Size<U> where F: Fn(T) -> U, T: Copy: Mappt Breite und Höhe zu einem neuen Typ.
Für T: std::ops::Mul<Output = T> + Copy:

pub fn area(&self) -> T: Berechnet die Fläche.


Für T: PartialOrd + Default:

pub fn is_empty(&self) -> bool where T: Default + PartialEq: Prüft, ob Breite oder Höhe null sind (abhängig von T::default()).




Invarianten: Wenn T ein numerischer Typ ist, sollten w und h typischerweise nicht-negativ sein. Dies wird jedoch nicht aktiv erzwungen, außer durch Nutzungskonventionen oder spezifische Konstruktoren in höheren Schichten.
Rect<T>
Datei: nova_de/core/src/types/rect.rs
Definition:
Rustuse super::{Point, Size}; // Import Point und Size aus dem gleichen Modul

#
#
pub struct Rect<T> {
    pub origin: Point<T>,
    pub size: Size<T>,
}

pub type RectInt = Rect<i32>;


Attribute:

origin: Point<T> - Sichtbarkeit: pub. Ursprungspunkt (typischerweise linke obere Ecke).
size: Size<T> - Sichtbarkeit: pub. Ausmaße des Rechtecks.


Methoden (Beispiele für T: Copy + PartialOrd + std::ops::Add<Output = T> + std::ops::Sub<Output = T>):

pub const fn new(x: T, y: T, w: T, h: T) -> Self: Erzeugt ein neues Rechteck.
pub fn from_points(p1: Point<T>, p2: Point<T>) -> Self: Erzeugt ein Rechteck aus zwei gegenüberliegenden Punkten (normalisiert).
pub fn x(&self) -> T: Gibt self.origin.x zurück.
pub fn y(&self) -> T: Gibt self.origin.y zurück.
pub fn width(&self) -> T: Gibt self.size.w zurück.
pub fn height(&self) -> T: Gibt self.size.h zurück.
pub fn right(&self) -> T: Gibt self.origin.x + self.size.w zurück.
pub fn bottom(&self) -> T: Gibt self.origin.y + self.size.h zurück.
pub fn contains_point(&self, point: &Point<T>) -> bool: Prüft, ob ein Punkt innerhalb des Rechtecks liegt.
pub fn intersects(&self, other: &Rect<T>) -> bool: Prüft, ob sich dieses Rechteck mit einem anderen überschneidet.
pub fn intersection(&self, other: &Rect<T>) -> Option<Rect<T>>: Berechnet die Schnittmenge mit einem anderen Rechteck.
pub fn union(&self, other: &Rect<T>) -> Rect<T>: Berechnet die Vereinigungsmenge mit einem anderen Rechteck.
pub fn translated(&self, dx: T, dy: T) -> Self: Erzeugt ein verschobenes Rechteck.
pub fn inflated(&self, dw: T, dh: T) -> Self: Erzeugt ein Rechteck, dessen Größe um dw und dh geändert wurde (Zentrum bleibt gleich).


Invarianten: Analog zu Size<T>, sollten size.w und size.h typischerweise nicht-negativ sein.
Color
Datei: nova_de/core/src/types/color.rs
Definition:
Rustuse thiserror::Error;

#
#
pub struct Color {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}

#
pub enum ColorParseError {
    #
    InvalidFormat(String),
    #[error("Invalid hex digit in string '{input}' at component '{component}'.")]
    InvalidHexDigit { input: String, component: String },
    #[error("Hex string '{0}' has incorrect length.")]
    InvalidLength(String),
}

impl Color {
    pub const fn new(r: u8, g: u8, b: u8, a: u8) -> Self {
        Color { r, g, b, a }
    }

    pub fn from_hex(hex_string: &str) -> Result<Self, ColorParseError> {
        let s = hex_string.trim_start_matches('#');
        if!(s.len() == 6 |


| s.len() == 8) {return Err(ColorParseError::InvalidLength(hex_string.to_string()));}if!s.chars().all(|c| c.is_ascii_hexdigit()) {return Err(ColorParseError::InvalidFormat(hex_string.to_string()));}        let r = u8::from_str_radix(&s[0..2], 16).map_err(|_| ColorParseError::InvalidHexDigit{ input: hex_string.to_string(), component: "R".to_string()})?;
        let g = u8::from_str_radix(&s[2..4], 16).map_err(|_| ColorParseError::InvalidHexDigit{ input: hex_string.to_string(), component: "G".to_string()})?;
        let b = u8::from_str_radix(&s[4..6], 16).map_err(|_| ColorParseError::InvalidHexDigit{ input: hex_string.to_string(), component: "B".to_string()})?;
        let a = if s.len() == 8 {
            u8::from_str_radix(&s[6..8], 16).map_err(|_| ColorParseError::InvalidHexDigit{ input: hex_string.to_string(), component: "A".to_string()})?
        } else {
            255 // Default alpha to fully opaque
        };
        Ok(Color { r, g, b, a })
    }

    pub fn to_hex(&self, include_alpha: bool) -> String {
        if include_alpha {
            format!("#{:02X}{:02X}{:02X}{:02X}", self.r, self.g, self.b, self.a)
        } else {
            format!("#{:02X}{:02X}{:02X}", self.r, self.g, self.b)
        }
    }
}
```

Attribute: r, g, b, a: u8 - Sichtbarkeit: pub. Rot-, Grün-, Blau- und Alpha-Komponenten.
Methoden: Siehe Definition.
Invarianten: Keine.
Orientation
Datei: nova_de/core/src/types/orientation.rs
Definition:
Rust#
#
pub enum Orientation {
    Horizontal,
    Vertical,
}


Varianten: Horizontal, Vertical.
Re-exportierte Typen
Datei: nova_de/core/src/types/mod.rs
Rust//... imports für Point, Size, Rect, Color, Orientation...
pub use uuid::Uuid;
pub use chrono::{DateTime, Utc};

pub type NotificationId = Uuid;
// Weitere Typ-Aliase können hier definiert werden.

Die Verwendung von uuid::Uuid für NotificationId 5 und chrono::DateTime<Utc> für Zeitstempel 6 ist eine robuste Wahl, die Standardbibliotheken für diese Zwecke nutzt. Die Aktivierung der "serde" und "v4" Features für uuid ist wichtig für die Serialisierung und die Generierung von Typ-4-UUIDs.
Diese grundlegenden Typen bilden eine solide Basis für geometrische Berechnungen, Farbdarstellungen und eindeutige Identifikatoren im gesamten NovaDE-System. Ihre konsequente Verwendung über alle Schichten hinweg fördert die Interoperabilität und reduziert Konvertierungsaufwand.2. Schnittstelle: Domänenschicht (Domain Layer) zu Systemschicht und BenutzeroberflächenschichtDie Domänenschicht kapselt die Geschäftslogik und den Kernzustand der Desktop-Umgebung. Sie stellt ihre Funktionalität über klar definierte Service-APIs (oft als Rust-Traits), Datenstrukturen und Events bereit.2.1. Bereitgestellte Funktionalität
Service-APIs (Traits): Öffentliche Schnittstellen werden primär durch Rust-Traits definiert, die von Service-Strukturen innerhalb der Domänenmodule implementiert werden.

domain::theming::ThemingEngine: Methoden wie get_current_theme_state(), update_configuration().
domain::workspaces::WorkspaceManager: Methoden wie create_workspace(), set_active_workspace().
domain::user_centric_services::AIInteractionLogicService: Methoden wie initiate_interaction(), provide_consent().
domain::user_centric_services::NotificationService: Methoden wie post_notification(), get_active_notifications().
domain::global_settings_and_state_management::GlobalSettingsService: Methoden wie load_settings(), update_setting().


Datenstrukturen: Öffentliche Datenstrukturen, die Zustände oder Konfigurationen repräsentieren (z.B. AppliedThemeState, Workspace, Notification, GlobalDesktopSettings).
Events: Domänenspezifische Events, die Zustandsänderungen signalisieren.

Beispiele: ThemeChangedEvent, WorkspaceEvent (z.B. ActiveWorkspaceChanged), NotificationPostedEvent, SettingChangedEvent.


Fehlertypen: Modulspezifische Fehler-Enums (z.B. ThemingError, WorkspaceManagerError, AIInteractionError, GlobalSettingsError).
2.2. Nutzung durch die Systemschicht
Die Systemschicht konsumiert die Service-APIs der Domänenschicht, um Geschäftsregeln anzuwenden und Zustände abzufragen.

Der system::compositor nutzt domain::window_management_policy für Fensterplatzierungsrichtlinien.
Der system::mcp Client interagiert mit AIInteractionLogicService für Einwilligungsprüfungen und Kontextinformationen.
system::dbus (für Benachrichtigungen) interagiert mit NotificationService.


Die Systemschicht kann auf Domänen-Events reagieren, um ihr Verhalten anzupassen (z.B. Umschalten der sichtbaren Surfaces im Compositor bei ActiveWorkspaceChanged).
Fehler aus der Domänenschicht werden in der Systemschicht behandelt oder weitergeleitet.
2.3. Nutzung durch die Benutzeroberflächenschicht
Die UI-Schicht nutzt die Service-APIs der Domänenschicht, um Daten für die Darstellung abzurufen und Benutzeraktionen in Domänenlogik umzusetzen.

ui::control_center verwendet GlobalSettingsService zum Anzeigen und Ändern von Einstellungen.
ui::shell interagiert mit WorkspaceManager für die Workspace-Darstellung und -Navigation.
ui::theming_gtk reagiert auf ThemeChangedEvent und wendet Stile an.


Die UI-Schicht abonniert Domänen-Events, um ihre Ansichten dynamisch zu aktualisieren.
Fehler aus der Domänenschicht werden von der UI-Schicht behandelt und dem Benutzer ggf. in verständlicher Form präsentiert.
2.4. Ultra-Feinspezifikation: Modul domain::user_centric_services::notification_service_implDieses Modul enthält die konkrete Implementierung des NotificationService-Traits.2.4.1. Modulübersicht
Zweck: Verwaltung des Lebenszyklus von Benachrichtigungen, einschließlich Erstellung, Speicherung, Abruf aktiver Benachrichtigungen, Schließen und Auslösen von Aktionen. Veröffentlicht Domänenereignisse im Zusammenhang mit Benachrichtigungen.
Dateistruktur:

nova_de/domain/src/user_centric_services/notification_api.rs: Definiert das Trait NotificationService und zugehörige öffentliche Typen wie Notification, NotificationAction, NotificationUrgency, NotificationId, CloseReason und NotificationError.
nova_de/domain/src/user_centric_services/notification_service_impl.rs: Enthält die Struktur NotificationServiceImpl und deren Implementierung des NotificationService-Traits.
nova_de/domain/src/events.rs: Definiert das DomainEvent-Enum, das NotificationPosted und NotificationClosed enthält.


Abhängigkeiten:

Extern: uuid (für NotificationId), chrono (für Zeitstempel).
Intern: crate::core::types::{NotificationId,...} (falls dort definiert, sonst lokal), crate::core::errors::DomainError (oder spezifischer NotificationError), crate::event_bus::{EventPublisher, DomainEvent} (abstrahiert den Event-Bus).


2.4.2. Öffentliche Datentypen (definiert in notification_api.rs)

pub type NotificationId = uuid::Uuid; 5

Verwendet Uuid::new_v4() zur Generierung.



##pub struct NotificationAction {pub key: String,pub label: String,}

key: Eindeutiger Bezeichner für die Aktion innerhalb der Benachrichtigung.
label: Für den Benutzer sichtbarer Text der Aktion.



##pub enum NotificationUrgency { Low, Normal, Critical }


##pub struct Notification {pub id: NotificationId,pub app_name: String,pub app_icon: Option<String>,pub summary: String,pub body: Option<String>,pub actions: Vec<NotificationAction>,pub hints: std::collections::HashMap<String, serde_json::Value>, // Flexibel für diverse Hintspub expire_timeout: i32, // Millisekunden. -1: Server-Default, 0: Niepub urgency: NotificationUrgency,pub created_at: chrono::DateTime<chrono::Utc>,}

Attribute wie in der Freedesktop Notification Specification definiert.9
hints: Verwendet serde_json::Value für Flexibilität bei D-Bus-Varianten.



##pub enum CloseReason { Expired, DismissedByUser, ClosedByApp, Replaced }


#pub enum NotificationError {#NotFound(NotificationId),#[error("Invalid parameter for notification: {field}: {message}")]InvalidParameter { field: String, message: String },#ActionNotFound { notification_id: NotificationId, action_key: String },#[error("Internal storage error for notifications")]StorageError(#[source] Box<dyn std::error::Error + Send + Sync + 'static>),}

2.4.3. Interne Datenstrukturen (notification_service_impl.rs)

struct NotificationInternal {public_data: Notification,// Ggf. Felder für Timer-Handles für expire_timeout// Ggf. Persistenz-Status}


pub struct NotificationServiceImpl {active_notifications: std::sync::Mutex<std::collections::HashMap<NotificationId, NotificationInternal>>,event_publisher: std::sync::Arc<dyn crate::event_bus::EventPublisher<crate::events::DomainEvent> + Send + Sync>,// Ggf. ein Tokio Runtime Handle für Timer, falls expire_timeout serverseitig gehandhabt wird}

2.4.4. Implementierung des NotificationService-Traits (notification_service_impl.rs)Rustuse async_trait::async_trait;
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use uuid::Uuid;
use chrono::Utc;
use crate::event_bus::{EventPublisher, DomainEvent}; // Annahme: DomainEvent ist hier definiert
use super::notification_api::*; // Importiert Traits und öffentliche Typen

impl NotificationServiceImpl {
    pub fn new(event_publisher: Arc<dyn EventPublisher<DomainEvent> + Send + Sync>) -> Self {
        NotificationServiceImpl {
            active_notifications: Mutex::new(HashMap::new()),
            event_publisher,
        }
    }

    // Interne Hilfsfunktion zum Schließen und Benachrichtigen
    fn internal_close_notification(
        &self,
        id: NotificationId,
        reason: CloseReason,
        notifications_guard: &mut std::sync::MutexGuard<HashMap<NotificationId, NotificationInternal>>,
    ) -> Result<Notification, NotificationError> {
        if let Some(removed_notification_internal) = notifications_guard.remove(&id) {
            let event = DomainEvent::NotificationClosed {
                id,
                reason,
                app_name: removed_notification_internal.public_data.app_name.clone(), // Für Kontext im Event
            };
            if self.event_publisher.publish(&event).is_err() {
                // Fehler beim Publishen loggen, aber nicht unbedingt den Vorgang abbrechen
                tracing::error!("Failed to publish NotificationClosed event for ID: {}", id);
            }
            Ok(removed_notification_internal.public_data)
        } else {
            Err(NotificationError::NotFound(id))
        }
    }
}

#[async_trait]
impl NotificationService for NotificationServiceImpl {
    async fn post_notification(
        &self, // &self statt &mut self, da Mutex interne Mutabilität ermöglicht
        app_name: String,
        replaces_id: Option<NotificationId>, // Verwende direkt NotificationId
        app_icon: Option<String>,
        summary: String,
        body: Option<String>,
        actions: Vec<NotificationAction>,
        hints: HashMap<String, serde_json::Value>,
        expire_timeout: i32,
        urgency: NotificationUrgency,
    ) -> Result<NotificationId, NotificationError> {
        let mut notifications_guard = self.active_notifications.lock().map_err(|_| {
            NotificationError::StorageError(Box::new(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Mutex poisoned",
            )))
        })?;

        let new_id = if let Some(id_to_replace) = replaces_id {
            // Versuche, die alte Benachrichtigung zu entfernen und zu benachrichtigen
            let _ = self.internal_close_notification(id_to_replace, CloseReason::Replaced, &mut notifications_guard);
            id_to_replace // Verwende die ID der ersetzten Benachrichtigung
        } else {
            Uuid::new_v4() // Generiere eine neue ID [5]
        };

        let notification_data = Notification {
            id: new_id,
            app_name,
            app_icon,
            summary,
            body,
            actions,
            hints,
            expire_timeout,
            urgency,
            created_at: Utc::now(),
        };

        let internal_notification = NotificationInternal {
            public_data: notification_data.clone(),
        };

        notifications_guard.insert(new_id, internal_notification);
        
        // TODO: Wenn expire_timeout > 0, hier Timer-Logik implementieren,
        // die self.close_notification(new_id, CloseReason::Expired) aufruft.
        // Dies erfordert typischerweise einen Tokio-Task oder ähnliches.

        let event = DomainEvent::NotificationPosted(notification_data);
        if self.event_publisher.publish(&event).is_err() {
            tracing::error!("Failed to publish NotificationPosted event for ID: {}", new_id);
            // Hier könnte man entscheiden, ob der Fehler an den Aufrufer weitergegeben wird.
            // Fürs Erste wird der Fehler nur geloggt.
        }

        Ok(new_id)
    }

    async fn get_active_notifications(&self) -> Result<Vec<Notification>, NotificationError> {
        let notifications_guard = self.active_notifications.lock().map_err(|_| {
            NotificationError::StorageError(Box::new(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Mutex poisoned",
            )))
        })?;
        Ok(notifications_guard.values().map(|internal| internal.public_data.clone()).collect())
    }

    async fn close_notification(&self, id: NotificationId, reason: CloseReason) -> Result<(), NotificationError> {
        let mut notifications_guard = self.active_notifications.lock().map_err(|_| {
            NotificationError::StorageError(Box::new(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Mutex poisoned",
            )))
        })?;
        
        self.internal_close_notification(id, reason, &mut notifications_guard)?;
        Ok(())
    }

    async fn invoke_action(&self, id: NotificationId, action_key: String) -> Result<(), NotificationError> {
        let notifications_guard = self.active_notifications.lock().map_err(|_| {
            NotificationError::StorageError(Box::new(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Mutex poisoned",
            )))
        })?;

        match notifications_guard.get(&id) {
            Some(notification_internal) => {
                if notification_internal.public_data.actions.iter().any(|act| act.key == action_key) {
                    // Aktion existiert
                    let event = DomainEvent::NotificationActionInvoked {
                        id,
                        action_key: action_key.clone(),
                        app_name: notification_internal.public_data.app_name.clone(),
                    };
                    if self.event_publisher.publish(&event).is_err() {
                         tracing::error!("Failed to publish NotificationActionInvoked event for ID: {}", id);
                    }
                    // Die D-Bus Spezifikation sagt nicht explizit, dass eine Benachrichtigung nach ActionInvoked geschlossen werden muss.
                    // Das überlassen wir der UI-Schicht oder spezifischen Hints.
                    Ok(())
                } else {
                    Err(NotificationError::ActionNotFound { notification_id: id, action_key })
                }
            }
            None => Err(NotificationError::NotFound(id)),
        }
    }
}
2.4.5. Domänenereignisse (events.rs)
#
pub enum DomainEvent {
NotificationPosted(Notification),
NotificationClosed { id: NotificationId, reason: CloseReason, app_name: String },
NotificationActionInvoked { id: NotificationId, action_key: String, app_name: String },
//... andere Domänenereignisse
}
Publisher: NotificationServiceImpl.
Typische Subscriber:

system::dbus::notification_dbus_service: Um D-Bus Signale zu emittieren.
ui::notifications_frontend: Um die Benutzeroberfläche zu aktualisieren.


Die Implementierung des NotificationService stellt sicher, dass die Kernlogik der Benachrichtigungsverwaltung von externen Schnittstellendetails (wie D-Bus) entkoppelt ist. Die Verwendung eines internen Event-Bus ermöglicht es anderen Systemteilen, reaktiv auf Benachrichtigungsänderungen zu reagieren.3. Schnittstelle: Systemschicht (System Layer) zu Benutzeroberflächenschicht (UI Layer)Die Systemschicht stellt der UI-Schicht systemnahe Dienste und Ereignisse zur Verfügung und setzt deren Befehle technisch um.3.1. Bereitgestellte Funktionalität
Systemereignisse und -zustände:

Fensterinformationen: Geometrie, Titel, AppID, Fokusstatus von Fenstern (aus system::compositor und system::xdg_shell).
Eingabeereignisse: Verarbeitete Tastatur-, Maus-, Touch- und Gestenereignisse (aus system::input).
Output-Informationen: Verfügbare Monitore, Auflösungen, Skalierungsfaktoren (aus system::outputs).
Status von Systemdiensten: Netzwerkverbindungen (system::dbus::networkmanager_client), Energiestatus (system::dbus::upower_client), Audiostatus (system::audio).
Sitzungsereignisse: Sperren, Abmelden (von system::dbus::logind_client).


Ausführung von UI-Befehlen:

Fenstermanipulationen (Verschieben, Größe ändern, Fokus setzen), initiiert durch die UI, werden vom system::compositor und system::window_mechanics umgesetzt.
Workspace-Wechsel.
Anpassung von Systemeinstellungen (z.B. Bildschirmhelligkeit, Lautstärke), die von system::outputs bzw. system::audio ausgeführt werden.


Fehlertypen: Modulspezifische Fehler-Enums (z.B. CompositorCoreError, InputError).
3.2. Nutzung durch die Benutzeroberflächenschicht
Darstellung von Systeminformationen: Die UI visualisiert die von der Systemschicht bereitgestellten Zustände.

Fensterlisten, Titelleisten, Fokus-Hervorhebungen basieren auf Daten von system::compositor.
Netzwerk-, Batterie-, Audio-Indikatoren in ui::shell zeigen Daten von system::dbus und system::audio.


Reaktion auf Eingabeereignisse: UI-Elemente reagieren auf verarbeitete Eingabeereignisse, um Aktionen auszulösen.
Initiierung von Systemaktionen: Benutzerinteraktionen in der UI führen zu Befehlsaufrufen an die Systemschicht.

Klick auf "Lauter"-Button in ui::shell ruft eine Funktion in system::audio auf.
Auswahl eines anderen Monitorsetups in ui::control_center sendet Befehl an system::outputs.


Dialoge über XDG Portals: ui::shell oder ui::components interagieren mit system::portals für Datei-Auswahl- oder Screenshot-Dialoge.
Die UI-Schicht behandelt Fehler von der Systemschicht und informiert ggf. den Benutzer.
Die UI-Schicht reagiert auf Systemereignisse (z.B. ActiveWorkspaceChanged indirekt über Änderungen der sichtbaren Fenster, DeviceAdded für Eingabegeräte), um ihre Darstellung anzupassen.
3.3. Ultra-Feinspezifikation: Modul system::dbus::notification_dbus_serviceDieses Modul implementiert den org.freedesktop.Notifications D-Bus Standard und dient als Brücke zur Domänenschicht (NotificationService).3.3.1. Modulübersicht
Zweck: Bereitstellung der org.freedesktop.Notifications D-Bus-Schnittstelle. Nimmt D-Bus-Methodenaufrufe entgegen, leitet sie an den NotificationService der Domänenschicht weiter und emittiert D-Bus-Signale basierend auf Domänenereignissen.
Dateistruktur: nova_de/system/src/dbus/notification_dbus_service.rs
Abhängigkeiten:

Extern: zbus (für D-Bus-Interaktion) 10, async-trait.
Intern: Arc<dyn domain::user_centric_services::NotificationService>, domain::events::DomainEvent, crate::event_bus::{EventSubscriber, DomainEvent}.


3.3.2. Datenstrukturen

struct NotificationDBusService {notification_service: Arc<dyn NotificationService>,connection: Arc<zbus::Connection>,// Für die Konvertierung von NotificationId (UUID) zu u32 (D-Bus ID) und umgekehrt:id_map: Arc<Mutex<IdMapper>>,}


struct IdMapper {next_dbus_id: u32,uuid_to_dbus: HashMap<NotificationId, u32>,dbus_to_uuid: HashMap<u32, NotificationId>,}

IdMapper ist notwendig, da die D-Bus-Spezifikation UINT32 für Benachrichtigungs-IDs verwendet, während intern uuid::Uuid für NotificationId genutzt wird, um globale Eindeutigkeit zu gewährleisten.


3.3.3. D-Bus SchnittstellenimplementierungDie Implementierung erfolgt mittels des #[dbus_interface] Makros von zbus.12Rust// nova_de/system/src/dbus/notification_dbus_service.rs
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use zbus::{dbus_interface, fdo, zvariant::Value, SignalContext};
use crate::domain::user_centric_services::notification_api::{
    NotificationService, NotificationId, NotificationAction, NotificationUrgency, CloseReason, NotificationError
};
use crate::event_bus::{DomainEvent, EventSubscriber}; // Angenommen, EventSubscriber ist definiert

// Hilfsstruktur für die ID-Konvertierung
struct IdMapper {
    next_dbus_id: u32,
    uuid_to_dbus: HashMap<NotificationId, u32>,
    dbus_to_uuid: HashMap<u32, NotificationId>,
}

impl IdMapper {
    fn new() -> Self {
        IdMapper {
            next_dbus_id: 1, // D-Bus IDs sind > 0
            uuid_to_dbus: HashMap::new(),
            dbus_to_uuid: HashMap::new(),
        }
    }

    fn get_or_create_dbus_id(&mut self, uuid: NotificationId) -> u32 {
        if let Some(dbus_id) = self.uuid_to_dbus.get(&uuid) {
            *dbus_id
        } else {
            let dbus_id = self.next_dbus_id;
            self.next_dbus_id += 1;
            self.uuid_to_dbus.insert(uuid, dbus_id);
            self.dbus_to_uuid.insert(dbus_id, uuid);
            dbus_id
        }
    }

    fn get_uuid(&self, dbus_id: u32) -> Option<NotificationId> {
        self.dbus_to_uuid.get(&dbus_id).copied()
    }

    fn remove_mapping_by_uuid(&mut self, uuid: &NotificationId) {
        if let Some(dbus_id) = self.uuid_to_dbus.remove(uuid) {
            self.dbus_to_uuid.remove(&dbus_id);
        }
    }
    
    fn remove_mapping_by_dbus_id(&mut self, dbus_id: u32) {
        if let Some(uuid) = self.dbus_to_uuid.remove(&dbus_id) {
            self.uuid_to_dbus.remove(&uuid);
        }
    }
}

pub struct NotificationDBusService {
    notification_service: Arc<dyn NotificationService + Send + Sync>,
    connection: Arc<zbus::Connection>,
    id_map: Arc<Mutex<IdMapper>>,
}

impl NotificationDBusService {
    pub async fn new(
        notification_service: Arc<dyn NotificationService + Send + Sync>,
        connection: Arc<zbus::Connection>,
        event_subscriber: Arc<dyn EventSubscriber<DomainEvent> + Send + Sync>, // Für das Abonnieren von DomainEvents
    ) -> Result<Self, zbus::Error> {
        let service = Self {
            notification_service,
            connection: connection.clone(),
            id_map: Arc::new(Mutex::new(IdMapper::new())),
        };

        // Task zum Abonnieren von DomainEvents und Emittieren von D-Bus Signalen
        let id_map_clone = service.id_map.clone();
        let conn_clone = connection.clone();
        tokio::spawn(async move {
            let mut stream = event_subscriber.subscribe();
            while let Some(event_result) = stream.recv().await { // Angenommen, subscribe() gibt einen Stream/Channel
                if let Ok(event) = event_result {
                    match event {
                        DomainEvent::NotificationClosed { id, reason, app_name: _ } => {
                            let dbus_id = {
                                let mut map = id_map_clone.lock().unwrap();
                                let id_val = map.get_uuid_to_dbus_id(id); // Hilfsfunktion in IdMapper
                                if id_val.is_some() { map.remove_mapping_by_uuid(&id); }
                                id_val
                            };
                            if let Some(valid_dbus_id) = dbus_id {
                                let dbus_reason = match reason {
                                    CloseReason::Expired => 1,
                                    CloseReason::DismissedByUser => 2,
                                    CloseReason::ClosedByApp => 3,
                                    CloseReason::Replaced => 3, // Oder eine spezifische D-Bus Reason, falls vorhanden
                                };
                                if let Err(e) = NotificationDBusService::emit_notification_closed(&conn_clone, valid_dbus_id, dbus_reason).await {
                                    tracing::error!("Failed to emit NotificationClosed D-Bus signal: {}", e);
                                }
                            }
                        }
                        DomainEvent::NotificationActionInvoked { id, action_key, app_name: _ } => {
                             let dbus_id = {
                                let map = id_map_clone.lock().unwrap();
                                map.get_uuid_to_dbus_id(id) // Hilfsfunktion in IdMapper
                            };
                            if let Some(valid_dbus_id) = dbus_id {
                                if let Err(e) = NotificationDBusService::emit_action_invoked(&conn_clone, valid_dbus_id, &action_key).await {
                                    tracing::error!("Failed to emit ActionInvoked D-Bus signal: {}", e);
                                }
                            }
                        }
                        _ => {} // Andere DomainEvents ignorieren
                    }
                }
            }
        });
        
        Ok(service)
    }

    // Hilfsfunktionen zum Emittieren von Signalen
    async fn emit_notification_closed(connection: &Arc<zbus::Connection>, id: u32, reason: u32) -> zbus::Result<()> {
        let ctxt = SignalContext::new(connection, "/org/freedesktop/Notifications")?;
        NotificationDBusService::notification_closed(&ctxt, id, reason).await
    }

    async fn emit_action_invoked(connection: &Arc<zbus::Connection>, id: u32, action_key: &str) -> zbus::Result<()> {
        let ctxt = SignalContext::new(connection, "/org/freedesktop/Notifications")?;
        NotificationDBusService::action_invoked(&ctxt, id, action_key).await
    }
}


#[dbus_interface(name = "org.freedesktop.Notifications")]
impl NotificationDBusService {
    async fn Notify(
        &self,
        app_name: String,
        replaces_id_dbus: u32,
        app_icon: String,
        summary: String,
        body: String,
        actions_dbus: Vec<String>,
        hints: HashMap<String, Value<'_>>, // zbus::zvariant::Value
        expire_timeout: i32,
    ) -> fdo::Result<u32> {
        tracing::debug!(
            "D-Bus Notify called: app_name={}, replaces_id={}, summary={}",
            app_name, replaces_id_dbus, summary
        );

        let replaces_id_uuid: Option<NotificationId> = if replaces_id_dbus == 0 {
            None
        } else {
            self.id_map.lock().unwrap().get_uuid(replaces_id_dbus)
        };

        let mut parsed_actions = Vec::new();
        for i in (0..actions_dbus.len()).step_by(2) {
            if i + 1 < actions_dbus.len() {
                parsed_actions.push(NotificationAction {
                    key: actions_dbus[i].clone(),
                    label: actions_dbus[i + 1].clone(),
                });
            }
        }
        
        // Konvertiere hints von zbus::zvariant::Value zu serde_json::Value
        let mut converted_hints = HashMap::new();
        for (k, v_ref) in hints.iter() {
            // Direkte Konvertierung ist möglicherweise nicht trivial.
            // Eine einfache Variante ist, wenn die Value-Typen kompatibel sind oder eine Serialisierung/Deserialisierung erfolgt.
            // Hier wird angenommen, dass die Struktur von Value serialisierbar zu JSON ist.
            // In einer echten Implementierung wäre hier robustere Konvertierungslogik nötig.
            match serde_json::to_value(v_ref) {
                Ok(json_val) => { converted_hints.insert(k.clone(), json_val); },
                Err(e) => {
                    tracing::warn!("Could not convert hint '{}' to JSON: {}", k, e);
                    // Optional: Fehler zurückgeben oder Hint ignorieren
                    // return Err(fdo::Error::InvalidArgs("Invalid hint format".into()));
                }
            }
        }


        // TODO: Urgency aus hints extrahieren, falls vorhanden (z.B. "urgency" byte)
        let urgency = NotificationUrgency::Normal; // Default, oder aus Hints bestimmen

        match self.notification_service.post_notification(
            app_name,
            replaces_id_uuid,
            if app_icon.is_empty() { None } else { Some(app_icon) },
            summary,
            if body.is_empty() { None } else { Some(body) },
            parsed_actions,
            converted_hints,
            expire_timeout,
            urgency,
        ).await {
            Ok(new_uuid) => {
                let dbus_id = self.id_map.lock().unwrap().get_or_create_dbus_id(new_uuid);
                Ok(dbus_id)
            }
            Err(e) => {
                tracing::error!("Error posting notification via service: {:?}", e);
                Err(fdo::Error::Failed(format!("Internal error: {}", e)))
            }
        }
    }

    async fn CloseNotification(&self, id: u32) -> fdo::Result<()> {
        tracing::debug!("D-Bus CloseNotification called for ID: {}", id);
        let uuid_to_close = match self.id_map.lock().unwrap().get_uuid(id) {
            Some(uuid) => uuid,
            None => {
                // Gemäß Spezifikation: "If the notification no longer exists, an empty D-BUS Error message is sent back."
                // Ein leerer fdo::Error::Failed("") ist nicht ideal, aber zbus erfordert einen Error-Namen.
                // org.freedesktop.DBus.Error.UnknownMethod ist nicht passend.
                // Ein benutzerdefinierter Fehler oder ein stillschweigendes Ok(()) könnte hier besser sein,
                // aber die Spezifikation verlangt einen Fehler.
                // Wir verwenden hier Failed, da kein spezifischerer Fehlercode für "existiert nicht mehr" vorgesehen ist.
                return Err(fdo::Error::Failed("Notification not found.".into()));
            }
        };

        match self.notification_service.close_notification(uuid_to_close, CloseReason::ClosedByApp).await {
            Ok(()) => {
                self.id_map.lock().unwrap().remove_mapping_by_dbus_id(id); // Mapping entfernen
                Ok(())
            }
            Err(NotificationError::NotFound(_)) => {
                 self.id_map.lock().unwrap().remove_mapping_by_dbus_id(id); // Sicherstellen, dass das Mapping entfernt ist
                 Err(fdo::Error::Failed("Notification not found by service.".into())) // Gemäß Spezifikation
            }
            Err(e) => {
                tracing::error!("Error closing notification via service: {:?}", e);
                Err(fdo::Error::Failed(format!("Internal error: {}", e)))
            }
        }
    }

    async fn GetCapabilities(&self) -> fdo::Result<Vec<String>> {
        tracing::debug!("D-Bus GetCapabilities called");
        Ok(vec!)
    }

    async fn GetServerInformation(&self) -> fdo::Result<(String, String, String, String)> {
        tracing::debug!("D-Bus GetServerInformation called");
        Ok((
            "NovaDE".to_string(),
            "NovaDE Project".to_string(),
            env!("CARGO_PKG_VERSION").to_string(), // Version aus Cargo.toml
            "1.2".to_string(), // Implementierte Spezifikationsversion
        ))
    }

    // Definition der Signale
    #[dbus_interface(signal)]
    async fn NotificationClosed(ctxt: &SignalContext<'_>, id: u32, reason: u32) -> zbus::Result<()>;

    #[dbus_interface(signal)]
    async fn ActionInvoked(ctxt: &SignalContext<'_>, id: u32, action_key: &str) -> zbus::Result<()>;
}
Hinweise zur Implementierung:
ID Mapping: Eine IdMapper-Struktur (oder ein ähnlicher Mechanismus) ist entscheidend, um zwischen den internen uuid::Uuid-basierten NotificationIds und den u32-basierten IDs der D-Bus-Schnittstelle zu übersetzen. replaces_id = 0 bedeutet eine neue Benachrichtigung. Zurückgegebene IDs müssen eindeutig sein.
Action Parsing: Die actions-Parameterliste im Notify-Aufruf ist ein flaches Array von Strings (as), wobei gerade Indizes Aktionsschlüssel und ungerade Indizes die zugehörigen Labels sind.9 Dies muss in die interne Vec<NotificationAction>-Struktur geparst werden.
Hints: hints ist ein a{sv} (Dictionary String to Variant). zbus::zvariant::Value muss in den internen Typ für Hint-Werte konvertiert werden (hier serde_json::Value als Beispiel). Die urgency (Dringlichkeit) und expire_timeout können auch über Hints gesteuert werden.
Signal Emission: Die D-Bus-Signale NotificationClosed und ActionInvoked müssen emittiert werden, wenn die entsprechenden DomainEvents (NotificationClosed, NotificationActionInvoked) vom NotificationService empfangen werden. Dies erfordert, dass NotificationDBusService den internen Event-Bus abonniert und in einem separaten Task auf diese Events lauscht.
Fehlerbehandlung: Interne NotificationError-Typen müssen in zbus::fdo::Error umgewandelt werden. Die D-Bus-Spezifikation gibt vor, dass bei CloseNotification für eine nicht existierende ID ein leerer D-Bus-Fehler zurückgegeben wird.
Asynchronität: Alle D-Bus-Methoden sind async. Die Interaktion mit dem NotificationService (der ebenfalls async sein kann) erfolgt über await.
Diese Implementierung stellt sicher, dass NovaDE sich standardkonform über D-Bus für Benachrichtigungen verhält und gleichzeitig die interne Logik in der Domänenschicht sauber gekapselt bleibt.3.3.4. Tabelle: org.freedesktop.Notifications D-Bus API zu NotificationService MappingD-Bus MemberTyp (Methode/Signal)NovaDE NotificationService Methode/DomänenEventSchlüsselparameter-/Payload-Mapping (D-Bus -> Intern)AnmerkungenNotifyMethodeasync post_notification(...)app_name -> app_name, replaces_id_dbus (u32) -> replaces_id (Option<NotificationId>), app_icon -> app_icon, summary -> summary, body -> body, actions_dbus (Vec<String>) -> actions (Vec<NotificationAction>), hints (HashMap<String, zbus::zvariant::Value>) -> hints (HashMap<String, serde_json::Value>), expire_timeout -> expire_timeout, urgency (aus Hints oder Default) -> urgencyID-Mapping für replaces_id und Rückgabewert erforderlich. Parsing der Aktionsliste. Hint-Konvertierung.CloseNotificationMethodeasync close_notification(...)id (u32) -> id (NotificationId)ID-Mapping. reason wird intern als CloseReason::ClosedByApp gesetzt.GetCapabilitiesMethodeN/A (Direkt in D-Bus Modul implementiert)N/AGibt statische Liste der Server-Fähigkeiten zurück (z.B. "body", "actions").GetServerInformationMethodeN/A (Direkt in D-Bus Modul implementiert)N/AGibt statische Serverinformationen zurück (Name, Vendor, Version, Spec-Version).NotificationClosedSignalDomainEvent::NotificationClosedid (NotificationId) -> id (u32), reason (CloseReason) -> reason (u32)ID-Mapping. Enum-Mapping für reason. Emittiert, wenn internes Event empfangen wird.ActionInvokedSignalDomainEvent::NotificationActionInvoked (löst async invoke_action(...) aus, welches dieses Event publiziert)id (NotificationId) -> id (u32), action_key (String) -> action_key (String)ID-Mapping. Emittiert, wenn internes Event empfangen wird.Diese Tabelle verdeutlicht die Kopplungspunkte und notwendigen Transformationen zwischen der standardisierten D-Bus-Schnittstelle und der internen Implementierung des Benachrichtigungsdienstes in NovaDE.4. Schnittstelle: Benutzeroberflächenschicht (UI Layer) zu Domänenschicht und SystemschichtDie UI-Schicht initiiert Aktionen in den unteren Schichten basierend auf Benutzerinteraktionen und stellt Informationen aus diesen Schichten dar.4.1. Gesendete Befehle/Daten an die Domänenschicht
Theming: ThemingEngine::update_configuration(new_config: ThemingConfiguration) durch ui::control_center oder ui::theming_gtk.
Workspaces: WorkspaceManager::create_workspace(name: Option<String>), set_active_workspace(id: WorkspaceId), pin_application_to_space(space_id: WorkspaceId, app_id: ApplicationIdentifier) durch ui::shell (Workspace-Switcher, SmartTabBar) oder ui::window_manager_frontend (Übersichtsmodus).
AI: AIInteractionLogicService::initiate_interaction(context_data: AIInteractionContextData), provide_consent(consent: AIConsent) durch ui::command_palette oder spezifische KI-Widgets.
Notifications: NotificationService::dismiss_notification(id: NotificationId), invoke_action(id: NotificationId, action_key: String) durch ui::notifications_frontend oder ui::shell (NotificationCenter).
Settings: GlobalSettingsService::update_setting(path: SettingPath, value: SettingValue) durch ui::control_center oder Quick-Settings.
4.2. Gesendete Befehle/Daten an die Systemschicht
Fenstermanagement: An system::window_mechanics oder direkt an system::compositor (über eine Fassade):

request_focus(window_id: DomainWindowIdentifier)
request_close_window(window_id: DomainWindowIdentifier)
request_move_window(window_id: DomainWindowIdentifier, new_pos: Point<i32, Logical>) (oder Start eines interaktiven Moves)
request_resize_window(window_id: DomainWindowIdentifier, new_size: Size<i32, Logical>) (oder Start eines interaktiven Resizes)
request_set_window_state(window_id: DomainWindowIdentifier, state: WindowState (Maximized, Minimized, Fullscreen))


Output-Konfiguration: An system::outputs (via wlr-output-management oder eine interne API):

apply_output_configuration(config: Vec<OutputConfigChange>) durch ui::control_center.


Audio-Steuerung: An system::audio::PipeWireClientService:

set_sink_volume(device_id, volume_percent), set_sink_mute(device_id, mute) durch ui::shell (Quick-Settings) oder ui::control_center.


Systemaktionen: An system::dbus Clients:

logind_client.lock_current_session() durch ui::shell (Lock-Button).
network_manager_client.activate_connection(connection_path, device_path) durch ui::shell (Quick-Settings) oder ui::control_center.


MCP-Anfragen: An system::mcp::SystemMcpService:

call_tool(server_id, tool_name, params, interaction_id) durch ui::command_palette oder KI-Widgets.


4.3. Ultra-Feinspezifikation: Modul ui::portals::file_chooser_portal_clientDieses Modul in der UI-Schicht ist verantwortlich für die Interaktion mit dem XDG Desktop Portal für Dateiauswahldialoge. Es agiert als Client für die D-Bus-Schnittstelle org.freedesktop.portal.FileChooser.4.3.1. Modulübersicht
Zweck: Kapselt die Logik zur Kommunikation mit dem XDG FileChooser-Portal, um native Dateiauswahldialoge zu öffnen und die Ergebnisse zu verarbeiten.
Dateistruktur: nova_de/ui/src/portals/file_chooser_portal_client.rs
Abhängigkeiten:

Extern: zbus (für D-Bus-Client-Interaktion) 10, tokio (für asynchrone Operationen).
Intern: core::errors::UIError (oder spezifischer PortalError), core::types.


4.3.2. Interne Datenstrukturen und Typen

struct FileChooserPortalClient { connection: Arc<zbus::Connection> }

Hält die D-Bus-Verbindung.



pub struct OpenFileOptions {pub parent_window_id: Option<String>, // XDG Window Identifierpub title: String,pub accept_label: Option<String>,pub modal: bool,pub multiple: bool,pub directory: bool,pub filters: Vec<FileFilter>,pub current_filter: Option<FileFilter>,pub current_folder: Option<PathBuf>,}

Spiegelt die Optionen des OpenFile-D-Bus-Aufrufs.15



pub struct FileFilter {pub name: String,pub patterns: Vec<FilterPattern>, // (u32 type, String pattern)}

FilterPattern: pub enum FilterPattern { Glob(String), MimeType(String) }



pub struct SaveFileOptions {... } (analog zu OpenFileOptions)


pub enum FileChooserResponse {SelectedFiles(Vec<url::Url>),SelectedFolder(url::Url),Cancelled,Error(PortalError),}


#pub enum PortalError {#DBusConnection(#[from] zbus::Error),#DBusCall(#[from] zbus::fdo::Error),#[error("Portal request failed with code {code}: {message}")]RequestFailed { code: u32, message: String },#InvalidUri(String),#[error("Portal response malformed: {0}")]ResponseMalformed(String),}

4.3.3. D-Bus Proxy Definition (intern)Mittels zbus::proxy wird ein Proxy für org.freedesktop.portal.FileChooser erstellt.10Rust// Innerhalb von file_chooser_portal_client.rs oder einem Hilfsmodul
use zbus::{proxy, zvariant::{Value, ObjectPath, OwnedValue, Dict, Array}};
use std::collections::HashMap;

#
trait FileChooser {
    async fn OpenFile(
        &self,
        parent_window: &str, // Window identifier, "" if none
        title: &str,
        options: HashMap<&str, Value<'_>>,
    ) -> zbus::fdo::Result<ObjectPath<'static>>; // Request handle

    async fn SaveFile(
        &self,
        parent_window: &str,
        title: &str,
        options: HashMap<&str, Value<'_>>,
    ) -> zbus::fdo::Result<ObjectPath<'static>>;

    // SaveFiles nicht im Detail hier, aber analog
}

// Proxy für org.freedesktop.portal.Request, um die Antwort zu empfangen
#
trait PortalRequest {
    #[zbus(signal)]
    async fn Response(&self, response_code: u32, results: Dict<'_, String, OwnedValue>) -> zbus::Result<()>;
    // Methode zum Schließen des Requests, falls benötigt
    // async fn Close(&self) -> zbus::fdo::Result<()>;
}
4.3.4. Implementierung von FileChooserPortalClientRust// nova_de/ui/src/portals/file_chooser_portal_client.rs
use zbus::{Connection, zvariant::{Value, Dict, Array, ObjectPath, Str, Type}, fdo::Error as ZbusFdoError};
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::Arc;
use url::Url;
use futures_util::stream::StreamExt; // Für das Lauschen auf Signale

//... (Proxy-Definitionen von oben)...
//... (OpenFileOptions, FileFilter, FileChooserResponse, PortalError Definitionen)...

impl FileChooserPortalClient {
    pub fn new(connection: Arc<Connection>) -> Self {
        Self { connection }
    }

    fn build_open_file_options_dict<'a>(
        &self,
        options: &'a OpenFileOptions,
        handle_token: &'a str
    ) -> HashMap<&'a str, Value<'a>> {
        let mut dict = HashMap::<&str, Value<'_>>::new();
        dict.insert("handle_token", Value::from(handle_token));
        if let Some(label) = &options.accept_label {
            dict.insert("accept_label", Value::from(label.as_str()));
        }
        dict.insert("modal", Value::from(options.modal));
        dict.insert("multiple", Value::from(options.multiple));
        dict.insert("directory", Value::from(options.directory)); // Version 3+ [15]

        if!options.filters.is_empty() {
            let mut filters_array = Array::new(Type::Tuple(Arc::new())))])));
            for filter in &options.filters {
                let mut patterns_array = Array::new(Type::Tuple(Arc::new()));
                for pattern_enum in &filter.patterns {
                    match pattern_enum {
                        FilterPattern::Glob(p) => patterns_array.append(Value::from((0u32, p.as_str()))).unwrap(),
                        FilterPattern::MimeType(m) => patterns_array.append(Value::from((1u32, m.as_str()))).unwrap(),
                    }
                }
                filters_array.append(Value::from((Str::from(filter.name.as_str()), patterns_array))).unwrap();
            }
            dict.insert("filters", Value::from(filters_array));
        }
        
        if let Some(current_filter) = &options.current_filter {
            let mut patterns_array = Array::new(Type::Tuple(Arc::new()));
            for pattern_enum in &current_filter.patterns {
                 match pattern_enum {
                    FilterPattern::Glob(p) => patterns_array.append(Value::from((0u32, p.as_str()))).unwrap(),
                    FilterPattern::MimeType(m) => patterns_array.append(Value::from((1u32, m.as_str()))).unwrap(),
                }
            }
            dict.insert("current_filter", Value::from((Str::from(current_filter.name.as_str()), patterns_array)));
        }

        if let Some(folder) = &options.current_folder {
            if let Some(folder_str) = folder.to_str() {
                 // Pfad muss als Array von Bytes (ay) gesendet werden, null-terminiert
                 let mut path_bytes: Vec<u8> = folder_str.as_bytes().to_vec();
                 path_bytes.push(0); // Null-Terminierung
                 dict.insert("current_folder", Value::from(path_bytes));
            }
        }
        dict
    }

    pub async fn open_file_dialog(
        &self,
        options: OpenFileOptions,
    ) -> Result<FileChooserResponse, PortalError> {
        let portal_proxy = FileChooserProxy::new(&self.connection).await?;
        let handle_token = format!("novade_open_{}", uuid::Uuid::new_v4().to_simple()); // Eindeutiger Token [15]

        let options_dict = self.build_open_file_options_dict(&options, &handle_token);
        
        let parent_window_str = options.parent_window_id.as_deref().unwrap_or("");

        let request_path: ObjectPath<'_> = portal_proxy
           .OpenFile(parent_window_str, &options.title, options_dict)
           .await?;
        
        tracing::debug!("OpenFile request sent. Handle: {}", request_path.as_str());

        // Auf das Response-Signal warten
        let request_proxy = PortalRequestProxy::builder(&self.connection)
           .path(request_path.to_owned())? //.to_owned() um Lifetime-Probleme zu vermeiden
           .build()
           .await?;
            
        let mut response_stream = request_proxy.receive_Response().await?;

        if let Some(signal_args) = response_stream.next().await {
            let response_code = signal_args.args()?.response_code;
            let results_dict = signal_args.args()?.results;
            tracing::debug!("Portal Response received: code={}, results={:?}", response_code, results_dict);

            if response_code == 0 { // Erfolg
                if let Some(Value::Array(uris_array)) = results_dict.get("uris") {
                    let mut uris = Vec::new();
                    for val in uris_array.get() {
                        if let Value::Str(s) = val {
                            match Url::parse(s.as_str()) {
                                Ok(url) => uris.push(url),
                                Err(_) => return Err(PortalError::InvalidUri(s.as_str().to_string())),
                            }
                        }
                    }
                    if options.directory {
                        if let Some(first_uri) = uris.into_iter().next() {
                             return Ok(FileChooserResponse::SelectedFolder(first_uri));
                        } else {
                            return Err(PortalError::ResponseMalformed("No URI returned for directory selection".into()));
                        }
                    } else {
                        return Ok(FileChooserResponse::SelectedFiles(uris));
                    }
                } else {
                    return Err(PortalError::ResponseMalformed("Missing 'uris' in results".into()));
                }
            } else if response_code == 1 { // Abgebrochen durch Benutzer
                return Ok(FileChooserResponse::Cancelled);
            } else { // Anderer Fehler
                let message = results_dict.get("message")
                               .and_then(|v| if let Value::Str(s) = v { Some(s.to_string()) } else { None })
                               .unwrap_or_else(|| "Unknown portal error".to_string());
                return Err(PortalError::RequestFailed { code: response_code, message });
            }
        }
        // Timeout oder anderer Fehler beim Warten auf das Signal
        Err(PortalError::ResponseMalformed("No response signal received".into()))
    }

    // pub async fn save_file_dialog(...) -> Result<FileChooserResponse, PortalError> {... }
    // Ähnliche Implementierung wie open_file_dialog, aber mit SaveFile-Methode und Optionen.
}
Implementierungsdetails:
Window Identifier: Der parent_window-Parameter für Portalaufrufe ist ein String. Für Wayland-Oberflächen wird dies typischerweise als wayland:WAYLAND_SURFACE_HANDLE formatiert, wobei der Handle die Objekt-ID der Wayland-Oberfläche ist. Die UI-Schicht muss diesen Bezeichner bereitstellen.
Optionen-Dictionary: Die options für OpenFile und SaveFile werden als HashMap<&str, zbus::zvariant::Value<'_>> konstruiert. Die Schlüssel und Werttypen müssen der XDG Portal Spezifikation entsprechen.15

filters: a(sa(us)) - Array von Tupeln (String, Array von Tupeln (Uint32, String)).
current_folder: ay - Byte-Array (null-terminierter Pfad).


Antwortverarbeitung: Die Antwort des Portals kommt asynchron über das Response-Signal auf dem Request-Objekt. Der Client muss dieses Signal abonnieren und die Ergebnisse (uris, choices) parsen.
Fehlerbehandlung: PortalError kapselt D-Bus-Fehler und spezifische Portal-Fehlercodes.
Asynchronität: Alle D-Bus-Aufrufe und Signal-Listener sind async.
Die Verwendung von XDG Desktop Portals ermöglicht es NovaDE-Anwendungen, die in einer Sandbox laufen könnten, auf sichere Weise mit dem Host-System zu interagieren, z.B. um Dateien zu öffnen oder zu speichern, ohne direkten Dateisystemzugriff zu benötigen. Dies ist ein wichtiger Aspekt moderner Desktop-Sicherheit.5. Zusammenfassende Prinzipien der Schnittstellen
Klare Verantwortlichkeiten: Jede Schicht hat definierte Aufgaben, und die Schnittstellen spiegeln diese wider.
Lose Kopplung: Kommunikation erfolgt über APIs (Traits) und Events, um direkte Abhängigkeiten von Implementierungsdetails zu minimieren.
Hohe Kohäsion: Module innerhalb einer Schicht arbeiten eng zusammen, aber die Schicht als Ganzes hat eine klar definierte externe Schnittstelle.
Einheitliche Fehlerbehandlung: Die thiserror-basierte Strategie wird über alle Schichten hinweg verwendet, wobei Fehler weitergeleitet oder spezifisch behandelt werden. Die source()-Kette ist wichtig.1
Event-gesteuerte Updates: Viele Zustandsänderungen werden über Events kommuniziert, was eine reaktive und entkoppelte Architektur fördert. Die UI-Schicht ist ein primärer Konsument von Events aus der Domänen- und Systemschicht, um ihre Darstellung aktuell zu halten.
Asynchronität: Schnittstellen, die potenziell blockierende Operationen beinhalten (I/O, IPC), sind als async deklariert und nutzen Rusts async/await-Syntax.
6. SchlussfolgerungenDie detaillierte Spezifikation der internen Schnittstellen und die Ultra-Feinspezifikation ausgewählter Module bilden das Rückgrat für die Entwicklung der NovaDE. Durch die klare Definition von Verantwortlichkeiten, Datenstrukturen, Methoden, Events und Fehlerbehandlung wird eine solide Grundlage für parallele Entwicklung und zukünftige Erweiterbarkeit geschaffen.Die konsequente Anwendung von Rusts Typ- und Fehlersystem, kombiniert mit etablierten Mustern wie der Trennung von API (Traits) und Implementierung sowie einem zentralen Event-Bus, trägt maßgeblich zur Robustheit und Wartbarkeit des Systems bei. Die detaillierte Ausarbeitung der Schnittstellen zu Standard-Desktop-Diensten wie org.freedesktop.Notifications und XDG Desktop Portals gewährleistet eine gute Integration in das Linux-Ökosystem.Dieser Implementierungsleitfaden ist so konzipiert, dass Entwickler die einzelnen Module mit einem hohen Grad an Sicherheit und Klarheit implementieren können, wodurch Integrationsrisiken minimiert und die Gesamtqualität der NovaDE maximiert wird. Die durchgängige Verwendung von async/await für potenziell blockierende Operationen stellt sicher, dass die Desktop-Umgebung reaktionsschnell bleibt. Die sorgfältige Definition von Fehlerketten mittels thiserror wird die Fehlersuche und -behebung im gesamten System erheblich vereinfachen.


# NovaDE Interner Schnittstellen-Implementierungsleitfaden

Dieser Implementierungsleitfaden definiert die ultrafeinen Spezifikationen und hochdetaillierten Implementierungspläne für jede Schicht der Linux-Desktop-Umgebung "NovaDE". Er ist so detailliert konzipiert, dass Entwickler ihn direkt zur Implementierung verwenden können, ohne eigene Entscheidungen treffen oder Logiken/Algorithmen entwerfen zu müssen.

---

## 1. Schicht: Kernschicht (Core Layer)

Die Kernschicht (Core Layer) bildet das Fundament von NovaDE und stellt grundlegende, universell einsetzbare Bausteine und Dienste bereit, die von allen darüberliegenden Schichten – der Domänenschicht, der Systemschicht und der Benutzeroberflächenschicht (UI-Schicht) – genutzt werden. Die Kommunikation mit höheren Schichten erfolgt durch die direkte Verwendung der hier definierten Typen und Funktionen.

### 1.1. Modul: `core::types`

Dieses Modul definiert grundlegende Datentypen, die systemweit für geometrische Berechnungen, Farbdarstellungen und andere fundamentale Konzepte verwendet werden.

- **Verzeichnis:** `core/src/types/`

#### 1.1.1. `Point<T>` Struktur

Stellt einen Punkt im 2D-Raum dar.

- Datei: `core/src/types/point.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Point<T, U> {
        pub x: T,
        pub y: T,
        _unit: std::marker::PhantomData<U>,
    }
    
    impl<T: Default, U> Default for Point<T, U> {
        fn default() -> Self {
            Point { x: Default::default(), y: Default::default(), _unit: std::marker::PhantomData }
        }
    }
    
    // U kann z.B. Logical, Physical, BufferCoords sein
    pub struct Logical;
    pub struct Physical;
    pub struct BufferCoords;
    
    impl<T, U> Point<T, U> {
        pub const fn new(x: T, y: T) -> Self {
            Point { x, y, _unit: std::marker::PhantomData }
        }
    }
    
    // Weitere Methoden wie Add, Sub, etc. können implementiert werden.
    ```
    
- Verwendung: Positionierung von UI-Elementen, Fensterkoordinaten.

#### 1.1.2. `Size<T>` Struktur

Stellt die Dimensionen (Breite und Höhe) eines 2D-Objekts dar.

- Datei: `core/src/types/size.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Size<T, U> {
        pub w: T,
        pub h: T,
        _unit: std::marker::PhantomData<U>,
    }
    
    impl<T: Default, U> Default for Size<T, U> {
        fn default() -> Self {
            Size { w: Default::default(), h: Default::default(), _unit: std::marker::PhantomData }
        }
    }
    
    impl<T, U> Size<T, U> {
        pub const fn new(w: T, h: T) -> Self {
            Size { w, h, _unit: std.marker::PhantomData }
        }
    }
    ```
    
- Verwendung: Fenstergrößen, UI-Element-Dimensionen.

#### 1.1.3. `Rect<T>` und `RectInt` Strukturen

Stellt ein Rechteck im 2D-Raum dar, definiert durch Position und Größe.

- Datei: `core/src/types/rect.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Rect<T, U> {
        pub loc: Point<T, U>,
        pub size: Size<T, U>,
    }
    
    impl<T: Default, U> Default for Rect<T, U> {
        fn default() -> Self {
            Rect { loc: Default::default(), size: Default::default() }
        }
    }
    
    impl<T, U> Rect<T, U> {
        pub const fn new(loc: Point<T, U>, size: Size<T, U>) -> Self {
            Rect { loc, size }
        }
        // Methoden wie contains_point, intersection, etc.
    }
    
    pub type RectInt = Rect<i32, Logical>; // Beispiel für einen häufigen Typ
    ```
    
- Verwendung: Fenstergeometrien, Auswahlbereiche.

#### 1.1.4. `Color` Struktur

Repräsentiert eine Farbe im RGBA-Format.

- Datei: `core/src/types/color.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Color {
        pub r: f32, // Range 0.0 to 1.0
        pub g: f32, // Range 0.0 to 1.0
        pub b: f32, // Range 0.0 to 1.0
        pub a: f32, // Range 0.0 to 1.0 (alpha)
    }
    
    impl Color {
        pub const fn new(r: f32, g: f32, b: f32, a: f32) -> Self {
            Color { r, g, b, a }
        }
    
        pub fn to_hex_rgb(&self) -> String {
            format!(
                "#{:02x}{:02x}{:02x}",
                (self.r * 255.0) as u8,
                (self.g * 255.0) as u8,
                (self.b * 255.0) as u8
            )
        }
    
        pub fn to_hex_rgba(&self) -> String {
            format!(
                "#{:02x}{:02x}{:02x}{:02x}",
                (self.r * 255.0) as u8,
                (self.g * 255.0) as u8,
                (self.b * 255.0) as u8,
                (self.a * 255.0) as u8
            )
        }
        // Ggf. From-Implementierungen für gängige Formate (z.B. String "#RRGGBB")
    }
    ```
    
- Verwendung: Theming, UI-Elementfarben.

#### 1.1.5. `Orientation` Enum

Definiert die Ausrichtung von UI-Elementen oder Layouts.

- Datei: `core/src/types/orientation.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub enum Orientation {
        Horizontal,
        Vertical,
    }
    ```
    
- Verwendung: Layout-Manager, Ausrichtung von Bedienelementen.

#### 1.1.6. `uuid::Uuid` Integration

Universell eindeutige Identifikatoren.

- Datei: `core/src/types/mod.rs` (als Re-Export)
- Re-Export: `pub use uuid::Uuid;`
- Abhängigkeit in `core/Cargo.toml`: `uuid = { version = "1.0", features = ["v4", "serde"] }`
    - Die Features `v4` und `serde` sind essenziell. `v4` ermöglicht die Generierung zufälliger UUIDs, die für die eindeutige Identifizierung von Entitäten wie Fenstern, Workspaces oder Benachrichtigungen unerlässlich sind. `serde` wird benötigt, falls diese IDs in Konfigurationsdateien persistiert oder über IPC-Schnittstellen serialisiert werden müssen, was in einer Desktop-Umgebung sehr wahrscheinlich ist.1
- Verwendung: Eindeutige Identifizierung von Ressourcen systemweit.

#### 1.1.7. `chrono::DateTime<Utc>` Integration

Zeitstempel mit UTC-Zeitzone.

- Datei: `core/src/types/mod.rs` (als Re-Export)
- Re-Export: `pub use chrono::{DateTime, Utc};`
- Abhängigkeit in `core/Cargo.toml`: `chrono = { version = "0.4", features = ["serde"] }`
    - `chrono` ist der De-facto-Standard für Datums- und Zeitmanipulationen in Rust. Die Verwendung von `DateTime<Utc>` stellt zeitzonenagnostische Zeitstempel sicher, was für interne Repräsentationen als Best Practice gilt, um Komplexitäten bei der Zeitzonenbehandlung zu vermeiden. Das `serde`-Feature ist notwendig, wenn Zeitstempel persistiert (z.B. in Logdateien oder Konfigurationen) oder serialisiert werden sollen.3
- Verwendung: Zeitstempel für Logging, Events, "zuletzt geändert"-Informationen.

#### 1.1.8. Implementierungsschritte für `core::types`

1. Erstellen Sie das Verzeichnis `core/src/types/`.
2. Implementieren Sie `point.rs`, `size.rs`, `rect.rs`, `color.rs`, und `orientation.rs` gemäß den obigen Spezifikationen.
3. Fügen Sie `uuid` (mit Features "v4", "serde") und `chrono` (mit Feature "serde") zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
4. Fügen Sie die Re-Exports für `Uuid` und `DateTime<Utc>` in `core/src/types/mod.rs` hinzu. Alle lokalen Typen (Point, Size, etc.) sollten ebenfalls von `mod.rs` re-exportiert werden.
    
    Rust
    
    ```
    // core/src/types/mod.rs
    mod color;
    mod orientation;
    mod point;
    mod rect;
    mod size;
    
    pub use chrono::{DateTime, Utc};
    pub use color::Color;
    pub use orientation::Orientation;
    pub use point::{BufferCoords, Logical, Physical, Point};
    pub use rect::{Rect, RectInt};
    pub use size::Size;
    pub use uuid::Uuid;
    ```
    

### 1.2. Modul: `core::errors`

Dieses Modul stellt eine Basis-Fehlerbehandlungsstrategie und den `CoreError`-Typ bereit. Höhere Schichten können `CoreError` oder spezifischere Fehler aus Kernmodulen mittels `#[from]` oder `#[source]` in ihre eigenen Fehlertypen wrappen, wobei die Fehlerursachenkette (`source()`) beibehalten wird.

- **Verzeichnis:** `core/src/`
- Datei: `core/src/errors.rs`

#### 1.2.1. `CoreError` Enum

- Definition unter Verwendung von `thiserror`:
    
    Rust
    
    ```
    #
    pub enum CoreError {
        #[error("I/O error: {source}")]
        Io {
            #[from]
            source: std::io::Error,
            // Optional: context: String, // Um zusätzlichen Kontext zur IO-Operation zu geben
        },
    
        #[error("Configuration parsing error from '{path:?}': {message}")]
        ConfigParse {
            path: Option<std::path::PathBuf>,
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #
        Serialization {
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #
        Deserialization {
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #[error("Invalid path: {path:?}")]
        InvalidPath { path: std::path::PathBuf },
    
        #[error("Initialization failed for module: {module_name}")]
        InitializationFailed {
            module_name: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #[error("Feature not implemented: {feature_name}")]
        NotImplemented { feature_name: String },
    
        #[error("Internal error: {message}")]
        Internal { message: String },
    
        #[error("Operation timed out: {operation}")]
        Timeout { operation: String },
    
        #[error("Permission denied for operation: {operation}")]
        PermissionDenied { operation: String },
    }
    ```
    
    Die Verwendung von `thiserror` 5 ist entscheidend für die Erstellung ergonomischer und informativer Fehlertypen. Das Attribut `#[from]` ermöglicht eine einfache Konvertierung von Standardbibliotheksfehlern wie `std::io::Error`. Das Attribut `#[source]` (implizit von `thiserror` verwendet, wenn ein Feld `#[from]` oder explizit `#[source]` ist) ist entscheidend für die Beibehaltung der Fehlerursachenkette, wie in der Spezifikation hervorgehoben. Eine robuste Fehlerbehandlungsstrategie ist fundamental. `thiserror` vereinfacht die Erstellung benutzerdefinierter Fehlertypen, die gut mit dem `Error`-Trait von Rust integriert sind. Die Beibehaltung der `source()`-Kette ist für das Debugging unerlässlich, da sie es Entwicklern ermöglicht, einen Fehler bis zu seinem Ursprung zurückzuverfolgen, selbst wenn er von verschiedenen Schichten mehrfach umgebrochen wird.

#### 1.2.2. Fehlerpropagierungsstrategie

Alle Funktionen in der Kernschicht, die fehlschlagen können, MÜSSEN `Result<T, CoreError>` oder `Result<T, SpecificCoreSubError>` zurückgeben, wobei `SpecificCoreSubError` via `#[from]` in `CoreError` konvertierbar sein sollte. Höhere Schichten definieren ihre eigenen Fehler-Enums (z.B. `DomainError`, `SystemError`, `UIError`) und verwenden `#[from] CoreError` oder `#[source] CoreError`, um Fehler aus dem Kern zu wrappen.

#### 1.2.3. Implementierungsschritte für `core::errors`

1. Fügen Sie `thiserror = "1.0"` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Implementieren Sie `core/src/errors.rs` mit dem `CoreError`-Enum wie oben spezifiziert.
3. Stellen Sie sicher, dass alle Module der Kernschicht `CoreError` für ihre Fehlerberichterstattung verwenden.

### 1.3. Modul: `core::logging`

Dieses Modul definiert die Logging-Infrastruktur basierend auf dem `tracing`-Crate. Alle höheren Schichten verwenden die `tracing`-Makros für ihre Logging-Ausgaben.

- **Verzeichnis:** `core/src/`
- Datei: `core/src/logging.rs`

#### 1.3.1. `initialize_logging()` Funktion

- Signatur:
    
    Rust
    
    ```
    pub fn initialize_logging(
        level_filter: tracing::Level,
        use_json: bool,
        custom_writer: Option<Box<dyn Fn() -> Box<dyn std::io::Write + Send + Sync + 'static> + Send + Sync + 'static>>
    ) -> Result<(), CoreError>
    ```
    
    - `level_filter`: Der minimale Log-Level, der aufgezeichnet werden soll (z.B. `tracing::Level::INFO`, `tracing::Level::DEBUG`).
    - `use_json`: Wenn `true`, werden Logs im JSON-Format ausgegeben, andernfalls in einem menschenlesbaren Format.
    - `custom_writer`: Eine optionale Funktion, die einen Writer für die Log-Ausgabe zurückgibt (z.B. in eine Datei, einen Netzwerk-Socket oder `std::io::stderr`). Standardmäßig wird `std::io::stderr` verwendet. Die Funktion wird verwendet, um den Writer bei Bedarf neu erstellen zu können (z.B. bei Log-Rotation).
- Implementierung:
    1. Verwendet `tracing_subscriber::fmt()` für die formatierte Protokollierung.
    2. Ermöglicht die Konfiguration des Formats (JSON oder "pretty") und des Writers.
        - Für JSON: `tracing_subscriber::fmt().json().with_writer(writer_closure).init();`
        - Für Pretty: `tracing_subscriber::fmt().pretty().with_writer(writer_closure).init();`
    3. Konfiguriert den `EnvFilter` basierend auf `level_filter` oder einer Umgebungsvariable (z.B. `RUST_LOG`).
    4. Richtet einen globalen Standard-Subscriber ein mittels `tracing::subscriber::set_global_default`.
    5. Gibt `Result<(), CoreError>` zurück, um Initialisierungsfehler zu signalisieren (z.B. wenn das Setzen des globalen Subscribers fehlschlägt).
- Die Standardisierung auf `tracing` ermöglicht eine strukturierte Protokollierung über alle Schichten hinweg, was für das Debugging und die Überwachung eines komplexen Systems wie einer Desktop-Umgebung von unschätzbarem Wert ist. Die Möglichkeit, zwischen menschenlesbaren und JSON-Formaten zu wechseln, ist gut für Entwicklung versus Produktion/Log-Aggregation. `tracing` bietet ein leistungsfähigeres und flexibleres Logging-Framework als das ältere `log`-Crate, insbesondere durch sein Konzept von Spans für kontextbezogene Protokollierung. Dies ist in einem mehrschichtigen, ereignisgesteuerten System von großem Vorteil.

#### 1.3.2. Verwendung von `tracing`-Makros

Alle Schichten verwenden die Makros `trace!`, `debug!`, `info!`, `warn!`, `error!` aus dem `tracing`-Crate. Spans (`span!`, `info_span!`, etc.) sollten verwendet werden, um kontextuelle Informationen für zusammengehörige Log-Meldungen bereitzustellen.

- Beispiel: `info!(target: "core::config", path = %file_path.display(), "Lade Kernkonfiguration.");`
- Beispiel mit Span:
    
    Rust
    
    ```
    let workspace_span = info_span!("workspace_operation", id = %workspace_id);
    let _enter = workspace_span.enter();
    //... Operationen innerhalb des Spans...
    info!("Operation abgeschlossen");
    ```
    

#### 1.3.3. Implementierungsschritte für `core::logging`

1. Fügen Sie `tracing = "0.1"` und `tracing_subscriber = { version = "0.3", features = ["fmt", "json", "env-filter"] }` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Implementieren Sie `core/src/logging.rs` mit der Funktion `initialize_logging()` wie oben spezifiziert.

### 1.4. Modul: `core::config`

Dieses Modul stellt Primitive zum Laden, Parsen und Zugreifen auf Kernkonfigurationen bereit. Es definiert die Struktur `CoreConfig` und Funktionen für deren Verwaltung.

- **Verzeichnis:** `core/src/config/`

#### 1.4.1. `CoreConfig` Struktur

Definiert die Kernkonfigurationseinstellungen.

- Datei: `core/src/config/types.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct CoreConfig {
        pub log_level: String, // z.B. "info", "debug", "trace"
        pub log_format: LogFormat,
        pub default_theme_name: Option<String>,
        pub enable_xwayland: bool,
        // Weitere kernspezifische Konfigurationen, z.B. Pfade, Feature-Flags
    }
    
    #
    #[serde(rename_all = "lowercase")]
    pub enum LogFormat {
        Json,
        Pretty,
    }
    
    impl Default for CoreConfig {
        fn default() -> Self {
            CoreConfig {
                log_level: "info".to_string(),
                log_format: LogFormat::Pretty,
                default_theme_name: Some("NovaDark".to_string()),
                enable_xwayland: true,
            }
        }
    }
    ```
    

#### 1.4.2. `ConfigError` Enum

Spezifische Fehler für das Laden und Verarbeiten von Konfigurationen.

- Datei: `core/src/config/error.rs`
- Definition:
    
    Rust
    
    ```
    use crate::core::errors::CoreError; // Assuming CoreError is in crate::core
    
    #
    pub enum ConfigError {
        #[error("Failed to determine config directory: {0}")]
        DirectoryResolutionError(String),
    
        #[error("Config file not found at {path:?}")]
        FileNotFound { path: std::path::PathBuf },
    
        #[error("Failed to read config file {path:?}")]
        FileReadError {
            path: std::path::PathBuf,
            #[source]
            source: std::io::Error,
        },
    
        #
        TomlParseError {
            path: std::path::PathBuf,
            message: String,
            #[source]
            source: Option<toml::de::Error>,
        },
        // Ggf. JsonParseError, falls JSON auch unterstützt wird
    
        #[error("Configuration not loaded or initialization failed.")]
        NotLoaded,
    
        #[error("Invalid configuration value for key '{key}': {message}")]
        InvalidValue { key: String, message: String },
    
        #[error("Failed to write default config to {path:?}")]
        DefaultConfigWriteError {
            path: std::path::PathBuf,
            #[source]
            source: std::io::Error,
        },
    
        #
        DefaultConfigTomlError(#[from] toml::ser::Error),
    
        #[error(transparent)]
        Core(#[from] CoreError), // Um CoreError wrappen zu können
    }
    ```
    

#### 1.4.3. Globale Konfigurationsvariable

Verwendet `once_cell` für eine thread-sichere, einmalig initialisierte globale Konfiguration.

- Datei: `core/src/config/mod.rs` (oder `core/src/config/global.rs`)
    
    Rust
    
    ```
    use once_cell::sync::OnceCell;
    use std::sync::RwLock;
    use super::types::CoreConfig; // Pfad anpassen
    use super::error::ConfigError; // Pfad anpassen
    
    static CORE_CONFIG: OnceCell<RwLock<CoreConfig>> = OnceCell::new();
    ```
    

#### 1.4.4. `load_core_config()` Funktion

Lädt die Kernkonfiguration aus einer Datei.

- Datei: `core/src/config/loader.rs`
- Signatur: `pub fn load_core_config(custom_path: Option<std::path::PathBuf>) -> Result<(), ConfigError>`
- Implementierung:
    
    1. Bestimme den Konfigurationsdateipfad:
        - Verwende `custom_path`, falls angegeben.
        - Andernfalls suche im XDG-Standardverzeichnis (z.B. `$XDG_CONFIG_HOME/nova-de/core.toml`) mittels `directories_next::ProjectDirs`.
        - Falls kein XDG-Verzeichnis gefunden wird, verwende einen Fallback-Pfad (z.B. `~/.config/nova-de/core.toml`).
    2. Wenn die Datei nicht existiert, erstelle eine Standardkonfiguration (`CoreConfig::default()`) und speichere sie unter dem ermittelten Pfad. Logge diesen Vorgang.
    3. Lese den Dateiinhalt. Bei Fehler `ConfigError::FileReadError`.
    4. Parse den Inhalt (z.B. TOML) in eine `CoreConfig`-Instanz. Bei Fehler `ConfigError::TomlParseError`.
    5. Initialisiere die globale `CORE_CONFIG` Variable mit der geladenen Konfiguration: `CORE_CONFIG.set(RwLock::new(loaded_config)).map_err(|_| ConfigError::NotLoaded)` (Fehlerbehandlung für den Fall, dass `set` fehlschlägt, was nur passiert, wenn bereits initialisiert).
    6. Gibt `Ok(())` bei Erfolg zurück.
    
    - Eine globale, statisch zugängliche Konfiguration ist üblich, erfordert aber eine sorgfältige Verwaltung, insbesondere bei der Initialisierung. `once_cell` für die Lazy-Initialisierung und `RwLock` für den threadsicheren Zugriff sind ein gutes Muster. Die Konfiguration muss früh im Anwendungslebenszyklus verfügbar sein und von verschiedenen Teilen des Systems zugänglich sein. `once_cell` stellt sicher, dass das Laden nur einmal erfolgt.

#### 1.4.5. `get_core_config()` Funktion

Bietet globalen Lesezugriff auf die geladene `CoreConfig`.

- Datei: `core/src/config/access.rs`
- Signatur: `pub fn get_core_config() -> Result<std::sync::RwLockReadGuard<'static, CoreConfig>, ConfigError>`
- Implementierung:
    1. Versuche, einen Read-Lock auf `CORE_CONFIG` zu erhalten: `CORE_CONFIG.get().ok_or(ConfigError::NotLoaded)?.read().map_err(|_| ConfigError::NotLoaded)` (Fehlerbehandlung für Poisoned Lock).
    2. Gibt den `RwLockReadGuard` bei Erfolg zurück.

#### 1.4.6. `update_core_config()` Funktion (Optional)

Ermöglicht die dynamische Aktualisierung der Kernkonfiguration zur Laufzeit.

- Datei: `core/src/config/access.rs`
- Signatur: `pub fn update_core_config(new_config: CoreConfig) -> Result<(), ConfigError>`
- Implementierung:
    1. Versuche, einen Write-Lock auf `CORE_CONFIG` zu erhalten.
    2. Aktualisiere die Konfiguration.
    3. Persistiert die neue Konfiguration in die Datei.
    4. **Wichtig:** Benachrichtige relevante Systemteile über die Konfigurationsänderung (z.B. über ein Event). Dies erfordert sorgfältige Überlegungen zur Thread-Sicherheit und wie Komponenten auf dynamische Änderungen reagieren.

#### 1.4.7. Implementierungsschritte für `core::config`

1. Fügen Sie `serde = { version = "1.0", features = ["derive"] }`, `toml = "0.8"`, `once_cell = "1.19"`, `directories-next = "2.0"` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Erstellen Sie die Verzeichnisstruktur `core/src/config/`.
3. Definieren Sie `CoreConfig` und `LogFormat` in `core/src/config/types.rs`.
4. Definieren Sie `ConfigError` in `core/src/config/error.rs`.
5. Implementieren Sie `loader.rs` (mit `load_core_config`) und `access.rs` (mit `get_core_config` und optional `update_core_config`).
6. Fügen Sie die globale `CORE_CONFIG`-Variable in `core/src/config/mod.rs` oder einer dedizierten `global.rs` ein und exportieren Sie die öffentlichen Funktionen.

### 1.5. Modul: `core::utils`

Dieses Modul bietet allgemeine Hilfsfunktionen, die von allen höheren Schichten genutzt werden können.

- **Verzeichnis:** `core/src/utils/`
- **Struktur:** Das Modul sollte in thematische Untermodule aufgeteilt werden, um die Übersichtlichkeit zu wahren.

#### 1.5.1. Untermodul: `core::utils::file_utils`

- Datei: `core/src/utils/file_utils.rs`
- Funktionen:
    - `pub fn read_file_to_string(path: &std::path::Path) -> Result<String, CoreError>`
        - Implementierung: Verwendet `std::fs::read_to_string`. Mappt `std::io::Error` auf `CoreError::Io`.
    - `pub fn ensure_dir_exists(path: &std::path::Path) -> Result<(), CoreError>`
        - Implementierung: Verwendet `std::fs::create_dir_all`. Mappt `std::io::Error` auf `CoreError::Io`.
    - `pub fn write_string_to_file(path: &std::path::Path, content: &str) -> Result<(), CoreError>`
        - Implementierung: Verwendet `std::fs::write`. Mappt `std::io::Error` auf `CoreError::Io`.

#### 1.5.2. Untermodul: `core::utils::string_utils`

- Datei: `core/src/utils/string_utils.rs`
- Funktionen:
    - `pub fn sanitize_filename(name: &str) -> String`
        - Implementierung: Ersetzt ungültige Zeichen für Dateinamen (z.B. `/`, `\`, `:`, `*`, `?`, `"`, `<`, `>`, `|`) durch Unterstriche oder entfernt sie.
    - `pub fn truncate_string_with_ellipsis(s: &str, max_len: usize) -> String`
        - Implementierung: Kürzt den String auf `max_len` Zeichen und fügt "..." hinzu, falls er gekürzt wurde. Achtet auf Grapheme Cluster, um Unicode-Zeichen nicht zu zerschneiden.
            
            Rust
            
            ```
            use unicode_segmentation::UnicodeSegmentation;
            //...
            // if s.graphemes(true).count() > max_len {
            //     s.graphemes(true).take(max_len - 3).collect::<String>() + "..."
            // } else {
            //     s.to_string()
            // }
            ```
            
            - Abhängigkeit: `unicode-segmentation = "1.10"`

#### 1.5.3. Untermodul: `core::utils::async_utils` (falls benötigt)

- Datei: `core/src/utils/async_utils.rs`
- Mögliche Funktionen:
    - Wrapper für `tokio::spawn` mit standardisierter Fehlerbehandlung oder Logging.
    - Hilfsfunktionen für Timeout-Management bei asynchronen Operationen.

#### 1.5.4. Implementierungsschritte für `core::utils`

1. Erstellen Sie das Verzeichnis `core/src/utils/`.
2. Erstellen Sie `core/src/utils/mod.rs` und deklarieren Sie die Untermodule:
    
    Rust
    
    ```
    pub mod file_utils;
    pub mod string_utils;
    // pub mod async_utils;
    ```
    
3. Implementieren Sie die Funktionen in den jeweiligen Untermodul-Dateien.
4. Fügen Sie ggf. Abhängigkeiten wie `unicode-segmentation` zu `core/Cargo.toml` hinzu.
5. Das `utils`-Modul kann leicht zu einer Ansammlung unzusammenhängender Funktionen werden. Es ist wichtig, die Organisation beizubehalten und sicherzustellen, dass die Funktionen eine breite Anwendbarkeit haben. Wenn eine Hilfsfunktion sehr spezifisch für eine einzelne Domäne oder ein Systemanliegen ist, sollte sie stattdessen im Hilfsmodul dieser Schicht angesiedelt sein. Eine klare Abgrenzung ist notwendig, um die Kohäsion der Module zu wahren und unnötige Kopplungen zu vermeiden.

---

## 2. Schicht: Domänenschicht (Domain Layer)

Die Domänenschicht kapselt die Geschäftslogik und den Kernzustand der Desktop-Umgebung NovaDE. Sie definiert die zentralen Konzepte, Regeln und Verhaltensweisen des Systems, unabhängig von technischen Implementierungsdetails der System- oder UI-Schicht. Die Kommunikation mit höheren Schichten (System- und UI-Schicht) erfolgt primär über wohldefinierte Service-APIs (als Rust-Traits implementiert) und durch domänenspezifische Events, die Zustandsänderungen signalisieren.

Die Domänenschicht ist zentral für die Funktionalität von NovaDE. Die Verwendung von Rust-Traits für Service-APIs fördert lose Kopplung und Testbarkeit. Ereignisse sind der Schlüssel zur reaktiven Propagierung von Zustandsänderungen. Fehlertypen sollten für jedes Domänenmodul spezifisch sein, um klaren Kontext zu bieten.

### 2.1. Service APIs (Traits)

Öffentliche Schnittstellen der Domänenschicht werden primär durch Rust-Traits definiert. Diese Traits werden von Service-Strukturen innerhalb der Domänenmodule implementiert. Methoden sind typischerweise `async`, wenn sie I/O-Operationen oder potenziell langlaufende Prozesse beinhalten, und geben `Result<T, SpecificDomainError>` zurück.

#### 2.1.1. `domain::theming::ThemingEngine` Trait

Verantwortlich für die Verwaltung und Anwendung von Themes.

- **Datei:** `domain/src/theming/engine.rs`

##### Zugehörige Datenstrukturen und Typen:

- **`ThemingConfiguration` Struct (Wertobjekt):**
    
    - Definiert die vom Benutzer oder System gewählten Theme-Einstellungen.
    - **Datei:** `domain/src/theming/config.rs`
    - **Felder:**
        - `icon_theme_name: String` (z.B. "Adwaita", "Papirus")
        - `gtk_theme_name: String` (z.B. "Adwaita-dark")
        - `cursor_theme_name: String` (z.B. "Adwaita")
        - `font_name: String` (z.B. "Cantarell 11")
        - `wallpaper_path: Option<std::path::PathBuf>`
        - `color_scheme: ColorScheme` (Enum: `Light`, `Dark`, `SystemPreference`)
        - `accent_color: core::types::Color`
    - **Invarianten:** `font_name` darf nicht leer sein, wenn gesetzt.
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`ColorScheme` Enum (Wertobjekt):**
    
    - Definiert die möglichen Farbschemata.
    - **Datei:** `domain/src/theming/config.rs` (oder `types.rs` im Theming-Modul)
    - **Varianten:** `Light`, `Dark`, `SystemPreference`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`AppliedThemeState` Struct (Wertobjekt):**
    
    - Repräsentiert den aktuell angewandten Theme-Zustand, inklusive aufgelöster Werte.
    - **Datei:** `domain/src/theming/state.rs`
    - **Felder:**
        - `current_config: ThemingConfiguration`
        - `resolved_wallpaper_path: Option<std::path::PathBuf>` (absoluter Pfad zum tatsächlich genutzten Hintergrundbild)
        - `font_config_details: String` (z.B. eine Pango-Font-Beschreibung oder Fontconfig-Pattern)
        - `effective_color_scheme: EffectiveColorScheme` (Enum: `Light`, `Dark`)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`EffectiveColorScheme` Enum (Wertobjekt):**
    
    - Repräsentiert das tatsächlich aktive Farbschema (aufgelöst aus `SystemPreference`).
    - **Datei:** `domain/src/theming/state.rs`
    - **Varianten:** `Light`, `Dark`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`ThemingError` Enum (Fehlertyp):**
    
    - Spezifische Fehler für das Theming-Subsystem.
    - **Datei:** `domain/src/theming/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum ThemingError {
            #[error("Invalid theming configuration: {0}")]
            InvalidConfiguration(String),
        
            #[error("Wallpaper not found at path: {0:?}")]
            WallpaperNotFound(std::path::PathBuf),
        
            #[error("Failed to apply theme '{theme_name}': {details}")]
            ThemeApplyFailed {
                theme_name: String,
                details: String,
                #[source]
                source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
            },
        
            #[error("Persistence error during theming operation")]
            PersistenceError(#[from] crate::core::errors::CoreError), // Assuming CoreError is accessible
        
            #[error("Underlying system service error for theming: {0}")]
            SystemServiceError(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn get_current_theme_state(&self) -> Result<AppliedThemeState, ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den aktuell im System angewandten und zwischengespeicherten Theme-Zustand ab.
    - **Vorbedingungen:** Keine.
    - **Nachbedingungen:** Gibt den `AppliedThemeState` zurück oder einen `ThemingError`.
- `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Aktualisiert die Theme-Konfiguration, persistiert sie und stößt die Anwendung des neuen Themes an.
    - **Vorbedingungen:** `new_config` muss valide sein (ggf. interne Validierung).
    - **Nachbedingungen:** Bei Erfolg wird das `ThemeChangedEvent` publiziert. Die Konfiguration wird persistiert (z.B. über `GlobalSettingsService` oder ein dediziertes Persistenz-Interface). Das System-Theme wird (versucht) anzuwenden.
    - **Geschäftsregeln:** Validiert die `new_config`. Löst das Hintergrundbild auf.
- `async fn apply_theme_to_system(&self, theme_state: &AppliedThemeState) -> Result<(), ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** (Potenziell intern, aufgerufen von `update_configuration`, oder als separate Methode für fortgeschrittene Nutzung) Wendet den gegebenen `AppliedThemeState` auf die Systemkomponenten an (z.B. Setzen von GTK-Theme, Icons, Cursor über Systemmechanismen).
    - **Vorbedingungen:** `theme_state` ist valide.
    - **Nachbedingungen:** Theme-Änderungen sind im System (versucht) aktiv.

##### Publizierte Events:

- **`ThemeChangedEvent`:**
    - **Datei:** `domain/src/theming/events.rs`
    - **Struktur:**
        
        Rust
        
        ```
        #
        pub struct ThemeChangedEvent {
            pub new_state: AppliedThemeState,
            pub old_state: Option<AppliedThemeState>, // Optional, falls der vorherige Zustand bekannt ist
        }
        ```
        
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::theming::ThemeChangedEvent`
    - **Typische Publisher:** Die Implementierung von `ThemingEngine`.
    - **Typische Subscriber:** `ui::theming_gtk` (UI-Schicht), `system::compositor` (Systemschicht, falls relevant für Darstellung).

#### 2.1.2. `domain::workspaces::WorkspaceManager` Trait

Verwaltet Workspaces (virtuelle Desktops).

- **Datei:** `domain/src/workspaces/manager.rs`

##### Zugehörige Datenstrukturen und Typen:

- **`WorkspaceId` Typalias:**
    
    - **Datei:** `domain/src/workspaces/types.rs` (oder direkt in `manager.rs`)
    - **Definition:** `pub type WorkspaceId = core::types::Uuid;`
- **`ApplicationIdentifier` Struct (Wertobjekt):**
    
    - Identifiziert eine Anwendung eindeutig.
    - **Datei:** `domain/src/workspaces/app_id.rs`
    - **Felder:**
        - `id_type: ApplicationIdType` (Enum: `DesktopFile`, `WaylandAppId`, `X11WindowClass`)
        - `identifier_str: String` (z.B. "firefox.desktop", "org.gnome.Nautilus", "Firefox")
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `serde::Serialize`, `serde::Deserialize`.
- **`Workspace` Struct (Entität):**
    
    - Repräsentiert einen einzelnen Workspace.
    - **Datei:** `domain/src/workspaces/workspace.rs`
    - **Felder:**
        - `id: WorkspaceId` (Sichtbarkeit: `pub(crate)`, Zugriff über Getter)
        - `name: String` (Sichtbarkeit: `pub`)
        - `output_name: Option<String>` (Name des Monitors, dem der Workspace primär zugeordnet ist, Sichtbarkeit: `pub`)
        - `layout_policy: WorkspaceLayoutPolicy` (Enum: `Tiling`, `Floating`, `Hybrid`, Sichtbarkeit: `pub`)
        - `pinned_applications: std::collections::HashSet<ApplicationIdentifier>` (Sichtbarkeit: `pub(crate)`, Zugriff über Methoden)
        - `creation_timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
        - `last_accessed_timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
    - **Initialwerte:** `id` wird bei Erstellung generiert, `name` z.B. "Workspace 1", `output_name` ist `None`, `layout_policy` wird aus globalen Einstellungen übernommen oder ist Standard (`Floating`), `pinned_applications` ist leer, `creation_timestamp` und `last_accessed_timestamp` sind Zeitpunkte der Erstellung.
    - **Invarianten:** `name` darf nicht leer sein. `id` ist unveränderlich nach Erstellung.
    - **Methoden (Beispiele):**
        - `pub fn new(name: String, layout_policy: WorkspaceLayoutPolicy) -> Self`
        - `pub fn id(&self) -> WorkspaceId`
        - `pub fn add_pinned_app(&mut self, app_id: ApplicationIdentifier) -> bool`
        - `pub fn remove_pinned_app(&mut self, app_id: &ApplicationIdentifier) -> bool`
        - `pub fn is_app_pinned(&self, app_id: &ApplicationIdentifier) -> bool`
        - `pub(crate) fn set_last_accessed(&mut self)`
    - **Beziehungen:** Keine direkten Entitätsbeziehungen in dieser Struktur, aber `pinned_applications` verweist auf `ApplicationIdentifier`.
- **`WorkspaceLayoutPolicy` Enum (Wertobjekt):**
    
    - **Datei:** `domain/src/workspaces/types.rs`
    - **Varianten:** `Tiling`, `Floating`, `Hybrid`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`WorkspaceManagerError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/workspaces/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum WorkspaceManagerError {
            #
            WorkspaceNotFound(super::types::WorkspaceId), // super::types::WorkspaceId
        
            #[error("Workspace with name '{0}' already exists")]
            DuplicateWorkspaceName(String),
        
            #[error("Maximum number of workspaces reached ({0})")]
            MaxWorkspacesReached(usize),
        
            #[error("Cannot delete the last workspace")]
            CannotDeleteLastWorkspace,
        
            #[error("Cannot delete active workspace; switch to another first")]
            CannotDeleteActiveWorkspace,
        
            #[error("Persistence error during workspace operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #[error("Invalid application identifier: {0}")]
            InvalidApplicationId(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn create_workspace(&self, name: Option<String>) -> Result<Workspace, WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Erstellt einen neuen Workspace. Wenn `name` `None` ist, wird ein Standardname generiert (z.B. "Workspace N").
    - **Nachbedingungen:** Bei Erfolg wird `WorkspaceEvent::Created` publiziert. Der neue Workspace wird persistiert.
    - **Geschäftsregeln:** Prüft auf Namenskonflikte und maximale Anzahl von Workspaces.
- `async fn delete_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Löscht den Workspace mit der gegebenen ID.
    - **Vorbedingungen:** Workspace darf nicht der letzte verbleibende sein. Workspace darf nicht der aktive sein (oder es muss eine Logik zum Wechsel des aktiven Workspaces implementiert sein).
    - **Nachbedingungen:** Bei Erfolg wird `WorkspaceEvent::Deleted` publiziert. Änderungen werden persistiert.
- `async fn get_workspace_by_id(&self, id: WorkspaceId) -> Result<Option<Workspace>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn get_all_workspaces(&self) -> Result<Vec<Workspace>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Vorbedingungen:** Der Workspace mit `id` muss existieren.
    - **Nachbedingungen:** `WorkspaceEvent::ActiveChanged` wird publiziert. Der `last_accessed_timestamp` des neuen und ggf. des alten aktiven Workspaces wird aktualisiert.
- `async fn get_active_workspace_id(&self) -> Result<Option<WorkspaceId>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Vorbedingungen:** `new_name` darf nicht leer sein und nicht mit einem existierenden Workspace-Namen (außer dem eigenen) kollidieren.
    - **Nachbedingungen:** `WorkspaceEvent::Renamed` wird publiziert. Änderung wird persistiert.
- `async fn pin_application_to_space(&self, space_id: WorkspaceId, app_id: ApplicationIdentifier) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Nachbedingungen:** `WorkspaceEvent::AppPinned` wird publiziert. Änderung wird persistiert.
- `async fn unpin_application_from_space(&self, space_id: WorkspaceId, app_id: ApplicationIdentifier) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Nachbedingungen:** `WorkspaceEvent::AppUnpinned` wird publiziert. Änderung wird persistiert.
- `async fn move_window_to_workspace(&self, window_identifier: String /* Eindeutiger Fenster-Identifikator, z.B. Wayland Surface ID als String */, target_workspace_id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Fordert an, ein Fenster zum Ziel-Workspace zu verschieben. Die eigentliche Fensterverschiebung erfolgt in der Systemschicht.
    - **Nachbedingungen:** `WorkspaceEvent::WindowMoved` wird publiziert.

##### Publizierte Events:

- **`WorkspaceEvent` Enum:**
    - **Datei:** `domain/src/workspaces/events.rs`
    - **Varianten (Beispiele):**
        - `Created { workspace: Workspace }`
        - `Deleted { workspace_id: WorkspaceId, new_active_workspace_id: Option<WorkspaceId> }`
        - `ActiveChanged { old_id: Option<WorkspaceId>, new_id: WorkspaceId }`
        - `Renamed { workspace_id: WorkspaceId, new_name: String }`
        - `AppPinned { space_id: WorkspaceId, app_id: ApplicationIdentifier }`
        - `AppUnpinned { space_id: WorkspaceId, app_id: ApplicationIdentifier }`
        - `LayoutPolicyChanged { workspace_id: WorkspaceId, new_policy: WorkspaceLayoutPolicy }`
        - `WindowMoved { window_identifier: String, source_workspace_id: Option<WorkspaceId>, target_workspace_id: WorkspaceId }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::workspaces::WorkspaceEvent`
    - **Typische Publisher:** Die Implementierung von `WorkspaceManager`.
    - **Typische Subscriber:** `ui::shell` (UI-Schicht), `system::compositor` (Systemschicht).

#### 2.1.3. `domain::user_centric_services::AIInteractionLogicService` Trait

Steuert die Logik für Benutzerinteraktionen mit KI-Diensten, inklusive Einwilligungsmanagement.

- **Datei:** `domain/src/user_centric_services/ai_logic.rs`
- Diese Service-Schnittstelle ist entscheidend für die sichere und transparente Integration von KI-Funktionen. Die Trennung der Einwilligungslogik von der reinen MCP-Kommunikation (die in der Systemschicht angesiedelt ist) ist ein wichtiger Aspekt für Datenschutz und Benutzerkontrolle.

##### Zugehörige Datenstrukturen und Typen:

- **`AIInteractionContextData` Struct (Wertobjekt):**
    
    - Sammelt Kontextinformationen für eine KI-Anfrage.
    - **Datei:** `domain/src/user_centric_services/ai_context.rs`
    - **Felder:**
        - `active_window_title: Option<String>`
        - `active_app_id: Option<super::workspaces::app_id::ApplicationIdentifier>` // Pfad anpassen
        - `current_workspace_id: Option<super::workspaces::types::WorkspaceId>` // Pfad anpassen
        - `selected_text: Option<String>`
        - `clipboard_content_preview: Option<String>` (Vorschau, nicht der volle Inhalt)
        - `screenshot_data_uri: Option<String>` (Data-URI eines Screenshots, falls relevant)
        - `user_query: String` (Die eigentliche Anfrage des Benutzers)
        - `interaction_id: core::types::Uuid` (Eindeutige ID für diese Interaktion)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIConsent` Enum (Wertobjekt):**
    
    - Repräsentiert den Einwilligungsstatus des Benutzers für KI-Interaktionen.
    - **Datei:** `domain/src/user_centric_services/ai_consent.rs`
    - **Varianten:**
        - `Granted { for_session: bool, timestamp: core::types::DateTime<core::types::Utc> }` (Einwilligung für die aktuelle Sitzung oder dauerhaft)
        - `Denied { timestamp: core::types::DateTime<core::types::Utc> }`
        - `NotSet`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIInteractionResponse` Struct (Wertobjekt):**
    
    - Repräsentiert die Antwort von einem KI-Dienst.
    - **Datei:** `domain/src/user_centric_services/ai_response.rs`
    - **Felder:**
        - `interaction_id: core::types::Uuid`
        - `response_text: Option<String>`
        - `suggested_actions: Vec<String>`
        - `tool_call_id: Option<String>` (Falls ein Tool vom MCP-Server aufgerufen wurde)
        - `tool_call_result: Option<serde_json::Value>` (Ergebnis des Tool-Aufrufs)
        - `error_message: Option<String>`
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIInteractionError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/user_centric_services/ai_error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum AIInteractionError {
            #[error("User consent not given for AI interaction")]
            ConsentNotGiven,
        
            #[error("MCP client error: {0}")]
            MCPError(String), // Wird von SystemMcpService kommen
        
            #[error("Failed to prepare context for AI interaction: {0}")]
            ContextPreparationFailed(String),
        
            #[error("AI service returned an error: {0}")]
            AIServiceError(String),
        
            #[error("Persistence error during AI consent operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #
            InteractionNotFoundOrTimedOut(crate::core::types::Uuid),
        }
        ```
        

##### Methoden des Traits:

- `async fn initiate_interaction(&self, context_data: AIInteractionContextData) -> Result<core::types::Uuid /* interaction_id */, AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Startet eine neue KI-Interaktion. Prüft die Einwilligung und leitet die Anfrage ggf. an den `SystemMcpService` weiter. Gibt eine `interaction_id` zurück, um die Antwort später zu korrelieren.
    - **Vorbedingungen:** `get_consent_status()` darf nicht `Denied` sein. Wenn `NotSet`, wird die Interaktion ggf. pausiert und ein `AIConsentRequestEvent` ausgelöst.
    - **Nachbedingungen:** `AIInteractionStartedEvent` wird publiziert.
    - **Geschäftsregeln:** Die Logik hier muss entscheiden, ob basierend auf `context_data` und `AIConsent` die Interaktion fortgesetzt, abgelehnt oder eine erneute Einwilligung angefordert wird.
- `async fn provide_consent(&self, consent: AIConsent) -> Result<(), AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Speichert die Benutzereinwilligung.
    - **Nachbedingungen:** `AIConsentChangedEvent` wird publiziert. Der Einwilligungsstatus wird persistiert.
- `async fn get_consent_status(&self) -> Result<AIConsent, AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den aktuellen Einwilligungsstatus ab.
- `async fn process_mcp_response(&self, interaction_id: core::types::Uuid, response: Result<serde_json::Value, String> /* MCP Tool Call Result oder Fehler */) -> Result<(), AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Verarbeitet eine asynchrone Antwort vom `SystemMcpService` (typischerweise ein Tool-Aufruf-Ergebnis).
    - **Nachbedingungen:** `AIInteractionCompletedEvent` oder `AIInteractionFailedEvent` wird publiziert.

##### Publizierte Events:

- **`AIConsentChangedEvent`:**
    - **Datei:** `domain/src/user_centric_services/events.rs`
    - **Struktur:** `pub struct AIConsentChangedEvent { pub new_status: AIConsent; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIConsentChangedEvent`
- **`AIInteractionStartedEvent`:**
    - **Struktur:** `pub struct AIInteractionStartedEvent { pub interaction_id: core::types::Uuid, pub context: AIInteractionContextData; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionStartedEvent`
- **`AIInteractionCompletedEvent`:**
    - **Struktur:** `pub struct AIInteractionCompletedEvent { pub response: AIInteractionResponse; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionCompletedEvent`
- **`AIInteractionFailedEvent`:**
    - **Struktur:** `pub struct AIInteractionFailedEvent { pub interaction_id: core::types::Uuid, pub error: AIInteractionError; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionFailedEvent`
- **`AIConsentRequestEvent`:** (Falls die UI den Benutzer zur Einwilligung auffordern soll)
    - **Struktur:** `pub struct AIConsentRequestEvent { pub interaction_id: core::types::Uuid, pub for_context: AIInteractionContextData }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIConsentRequestEvent`
- **Typische Publisher:** Die Implementierung von `AIInteractionLogicService`.
- **Typische Subscriber:** `ui::command_palette` oder KI-Widgets (UI-Schicht), `system::mcp::SystemMcpService` (Systemschicht, für Antworten).

#### 2.1.4. `domain::user_centric_services::NotificationService` Trait

Verwaltet das Anzeigen und Interagieren mit Desktop-Benachrichtigungen.

- **Datei:** `domain/src/user_centric_services/notification_service.rs`
- Die Parameter für `post_notification` spiegeln eng die D-Bus-Methode `org.freedesktop.Notifications.Notify` wider.9 Dieser Dienst fungiert als Abstraktion über potenzielle D-Bus-Implementierungen in der Systemschicht. Die Domänenschicht definiert das _Konzept_ einer Benachrichtigung innerhalb von NovaDE. Die Systemschicht wäre dann dafür verantwortlich, diese Benachrichtigung tatsächlich über D-Bus zu senden, wenn NovaDE als Benachrichtigungsserver fungiert, oder auf D-Bus-Benachrichtigungen zu lauschen, wenn es diese konsumiert. Die Verwendung von `zvariant::OwnedValue` für `hints` deutet auf eine direkte Abbildung auf D-Bus-Varianten hin.

##### Zugehörige Datenstrukturen und Typen:

- **`NotificationId` Typalias:**
    
    - **Datei:** `domain/src/user_centric_services/types.rs` (oder direkt in `notification_service.rs`)
    - **Definition:** `pub type NotificationId = core::types::Uuid;`
- **`NotificationAction` Struct (Wertobjekt):**
    
    - Definiert eine Aktion, die mit einer Benachrichtigung verbunden ist.
    - **Datei:** `domain/src/user_centric_services/notification_action.rs`
    - **Felder:**
        - `key: String` (Eindeutiger Schlüssel für die Aktion, z.B. "default", "reply")
        - `label: String` (Anzeigetext für den Button)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `serde::Serialize`, `serde::Deserialize`.
- **`NotificationUrgency` Enum (Wertobjekt):**
    
    - Definiert die Dringlichkeitsstufe einer Benachrichtigung.
    - **Datei:** `domain/src/user_centric_services/types.rs`
    - **Varianten:** `Low`, `Normal`, `Critical`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`Notification` Struct (Entität):**
    
    - Repräsentiert eine einzelne Desktop-Benachrichtigung.
    - **Datei:** `domain/src/user_centric_services/notification.rs`
    - **Felder:**
        - `id: NotificationId` (Sichtbarkeit: `pub(crate)`, Zugriff über Getter)
        - `app_name: String` (Sichtbarkeit: `pub`)
        - `replaces_id: Option<NotificationId>` (Sichtbarkeit: `pub`)
        - `app_icon: Option<String>` (Pfad oder Name des Icons, Sichtbarkeit: `pub`)
        - `summary: String` (Kurze Zusammenfassung, Sichtbarkeit: `pub`)
        - `body: Option<String>` (Detaillierter Text, Sichtbarkeit: `pub`)
        - `actions: Vec<NotificationAction>` (Sichtbarkeit: `pub`)
        - `hints: std::collections::HashMap<String, zbus::zvariant::OwnedValue>` (Spezifische Hinweise für den Notification-Server, Sichtbarkeit: `pub`)
        - `expire_timeout_ms: i32` (-1 für Server-Default, 0 für nie, >0 für Millisekunden, Sichtbarkeit: `pub`)
        - `urgency: NotificationUrgency` (Sichtbarkeit: `pub`)
        - `timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
        - `is_displayed: std::sync::atomic::AtomicBool` (Interner Status, ob die Benachrichtigung aktuell angezeigt wird)
    - **Initialwerte:** `id` wird generiert, `timestamp` ist aktuell, `is_displayed` ist `false`.
    - **Invarianten:** `summary` darf nicht leer sein. `id` ist unveränderlich.
    - **Methoden (Beispiele):**
        - `pub fn id(&self) -> NotificationId`
        - `pub(crate) fn mark_as_displayed(&self)`
        - `pub(crate) fn mark_as_closed(&self)`
- **`CloseReason` Enum (Wertobjekt):**
    
    - Gibt den Grund an, warum eine Benachrichtigung geschlossen wurde.
    - **Datei:** `domain/src/user_centric_services/types.rs`
    - **Varianten:** `Expired`, `DismissedByUser`, `ClosedByApp`, `ServiceShutdown`, `Unknown`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`NotificationError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/user_centric_services/notification_error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum NotificationError {
            #
            NotificationNotFound(super::types::NotificationId), // Pfad anpassen
        
            #[error("Invalid notification format or content: {0}")]
            InvalidNotificationFormat(String),
        
            #[error("Failed to invoke action '{action_key}' for notification {notification_id}: {reason}")]
            ActionInvokeFailed {
                notification_id: super::types::NotificationId, // Pfad anpassen
                action_key: String,
                reason: String,
            },
        
            #[error("Notification service is unavailable or failed: {0}")]
            ServiceUnavailable(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn post_notification(&self, app_name: String, replaces_id: Option<NotificationId>, app_icon: Option<String>, summary: String, body: Option<String>, actions: Vec<NotificationAction>, hints: std::collections::HashMap<String, zbus::zvariant::OwnedValue>, expire_timeout_ms: i32, urgency: NotificationUrgency) -> Result<NotificationId, NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Sendet eine neue Benachrichtigung oder aktualisiert eine existierende.
    - **Nachbedingungen:** Bei Erfolg wird `NotificationPostedEvent` publiziert. Die Benachrichtigung wird (versucht) dem Benutzer angezeigt.
- `async fn get_active_notifications(&self) -> Result<Vec<Notification>, NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft eine Liste aller aktuell aktiven (angezeigten) Benachrichtigungen ab.
- `async fn close_notification(&self, id: NotificationId, reason: CloseReason) -> Result<(), NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Schließt eine spezifische Benachrichtigung.
    - **Vorbedingungen:** Benachrichtigung mit `id` muss existieren und aktiv sein.
    - **Nachbedingungen:** `NotificationClosedEvent` wird publiziert.
- `async fn invoke_action(&self, id: NotificationId, action_key: String) -> Result<(), NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Löst eine mit einer Benachrichtigung verbundene Aktion aus.
    - **Vorbedingungen:** Benachrichtigung mit `id` und Aktion mit `action_key` müssen existieren.
    - **Nachbedingungen:** `NotificationActionInvokedEvent` wird publiziert.

##### Publizierte Events:

- **`NotificationPostedEvent`:**
    - **Datei:** `domain/src/user_centric_services/events.rs`
    - **Struktur:** `pub struct NotificationPostedEvent { pub notification: Notification; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationPostedEvent`
- **`NotificationClosedEvent`:**
    - **Struktur:** `pub struct NotificationClosedEvent { pub id: NotificationId, pub reason: CloseReason; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationClosedEvent`
- **`NotificationActionInvokedEvent`:**
    - **Struktur:** `pub struct NotificationActionInvokedEvent { pub id: NotificationId, pub action_key: String; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationActionInvokedEvent`
- **Typische Publisher:** Die Implementierung von `NotificationService`.
- **Typische Subscriber:** `ui::notifications_frontend` oder `ui::shell` (UI-Schicht), `system::dbus::notification_server` (Systemschicht, falls NovaDE als Server agiert und die Events intern weiterleitet).

#### 2.1.5. `domain::global_settings_and_state_management::GlobalSettingsService` Trait

Verwaltet globale Desktop-Einstellungen und deren Persistenz.

- **Datei:** `domain/src/global_settings/service.rs`
- Dieser Dienst bietet eine strukturierte Methode zur Verwaltung einer Vielzahl von Desktop-Einstellungen. Der Persistenzmechanismus (z.B. eine Implementierung von `domain::settings_persistence_iface`, wie in der Kernschichtspezifikation erwähnt) ist hier von entscheidender Bedeutung.

##### Zugehörige Datenstrukturen und Typen:

- **`SettingPath` Typalias:**
    
    - **Datei:** `domain/src/global_settings/types.rs`
    - **Definition:** `pub type SettingPath = String;` (z.B. "desktop.background.color", "keyboard.layouts.0.name")
- **`SettingValue` Enum (Wertobjekt):**
    
    - Repräsentiert den Wert einer Einstellung. Kann verschiedene primitive Typen und verschachtelte Strukturen annehmen.
    - **Datei:** `domain/src/global_settings/value.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        #[serde(untagged)] // Für flexible (De-)Serialisierung
        pub enum SettingValue {
            String(String),
            Integer(i64),
            Float(f64),
            Boolean(bool),
            List(Vec<SettingValue>),
            Map(std::collections::HashMap<String, SettingValue>),
            Null, // Um das Fehlen eines Wertes explizit darzustellen
        }
        // Implement From<T> for SettingValue für gängige Typen
        ```
        
    - Die Verwendung von `serde_json::Value` wäre eine Alternative für maximale Flexibilität, aber ein eigenes Enum bietet mehr Typsicherheit innerhalb der Domäne.
- **`GlobalDesktopSettings` Struct (Entität):**
    
    - Repräsentiert die Gesamtheit aller verwalteten Einstellungen.
    - **Datei:** `domain/src/global_settings/settings_struct.rs`
    - **Felder:**
        - `settings: std::collections::BTreeMap<SettingPath, SettingValue>` (BTreeMap für geordnete Iteration/Serialisierung, falls gewünscht)
    - **Sichtbarkeit:** `pub(crate)` für `settings`, Zugriff über Methoden.
    - **Methoden (Beispiele):**
        - `pub fn get(&self, path: &SettingPath) -> Option<&SettingValue>`
        - `pub fn set(&mut self, path: SettingPath, value: SettingValue) -> Option<SettingValue>` (gibt alten Wert zurück)
        - `pub fn remove(&mut self, path: &SettingPath) -> Option<SettingValue>`
- **`GlobalSettingsError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/global_settings/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum GlobalSettingsError {
            #
            SettingNotFound(super::types::SettingPath), // Pfad anpassen
        
            #
            TypeMismatch {
                path: super::types::SettingPath, // Pfad anpassen
                expected_type: String,
                found_type: String,
            },
        
            #[error("Persistence error during settings operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #[error("Validation error for setting '{path}': {message}")]
            ValidationError {
                path: super::types::SettingPath, // Pfad anpassen
                message: String,
            },
        
            #[error("Invalid setting path format: {0}")]
            InvalidPathFormat(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn load_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Lädt alle Einstellungen aus der Persistenzschicht.
    - **Nachbedingungen:** Gibt die geladenen `GlobalDesktopSettings` zurück oder einen Fehler.
- `async fn save_settings(&self, settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Persistiert den gesamten Einstellungsbaum.
- `async fn get_setting(&self, path: &SettingPath) -> Result<Option<SettingValue>, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den Wert einer spezifischen Einstellung ab.
- `async fn update_setting(&self, path: SettingPath, value: SettingValue) -> Result<Option<SettingValue /* old_value */>, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Aktualisiert eine spezifische Einstellung und persistiert die Änderung. Gibt den alten Wert zurück, falls vorhanden.
    - **Vorbedingungen:** `path` und `value` müssen validen Formaten entsprechen. Ggf. Validierung gegen ein Schema.
    - **Nachbedingungen:** Bei Erfolg wird `SettingChangedEvent` publiziert. Die Einstellung wird persistiert.
- `async fn get_all_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft eine Kopie aller aktuellen Einstellungen ab.

##### Publizierte Events:

- **`SettingChangedEvent`:**
    - **Datei:** `domain/src/global_settings/events.rs`
    - **Struktur:**
        
        Rust
        
        ```
        #
        pub struct SettingChangedEvent {
            pub path: SettingPath,
            pub old_value: Option<SettingValue>,
            pub new_value: SettingValue,
        }
        ```
        
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::global_settings::SettingChangedEvent`
- **Typische Publisher:** Die Implementierung von `GlobalSettingsService`.
- **Typische Subscriber:** `ui::control_center` (UI-Schicht), verschiedene Systemkomponenten, die auf Einstellungsänderungen reagieren müssen.

### 2.2. Datenstrukturen (Öffentlich)

Zusätzlich zu den direkt mit Service-APIs assoziierten Strukturen können weitere öffentliche Datenstrukturen existieren, die Zustände oder Konfigurationen repräsentieren und von mehreren Modulen oder Schichten verwendet werden.

- **Beispiele:** Viele der oben bereits definierten Strukturen fallen in diese Kategorie, z.B. `AppliedThemeState`, `Workspace`, `Notification`, `GlobalDesktopSettings`, `ThemingConfiguration`, `ApplicationIdentifier`, `AIInteractionContextData`, `AIConsent`, `SettingValue`.
- **Implementierungsrichtlinien:**
    - Jede Struktur/Enum in einer eigenen Datei innerhalb des relevanten Domänenmoduls (z.B. `domain/src/theming/state.rs`).
    - Ableitung von `Debug`, `Clone`, `PartialEq` ist Standard.
    - Ableitung von `serde::Serialize`, `serde::Deserialize` falls Persistenz oder IPC-Übertragung erforderlich ist.
    - Felder sollten `pub` sein, wenn sie direkt von extern gelesen werden sollen, oder `pub(crate)` mit öffentlichen Gettern/Settern für kontrollierten Zugriff.
    - Invarianten sollten durch Konstruktoren und Methoden sichergestellt werden.
    - Beziehungen zu anderen Entitäten/Wertobjekten sollten klar definiert sein (z.B. durch Komposition oder IDs).

### 2.3. Events (Domänenspezifisch)

Domänenspezifische Events signalisieren wichtige Zustandsänderungen innerhalb der Domänenschicht. Sie sind entscheidend für eine reaktive Architektur und lose Kopplung.

- **Beispiele:** Die bereits bei den Services definierten Events (`ThemeChangedEvent`, `WorkspaceEvent`, `NotificationPostedEvent`, `SettingChangedEvent`, `AIConsentChangedEvent`, etc.).
- **Struktur:**
    - Jedes Event sollte als eigene Struktur oder als Variante eines umfassenderen Event-Enums (pro Modul) definiert werden.
    - Die Event-Struktur enthält alle relevanten Daten zur Zustandsänderung.
    - Beispiel: `pub struct ActiveWorkspaceChanged { pub old_id: Option<WorkspaceId>, pub new_id: WorkspaceId }`
- **Eindeutiger Event-Name/Typ:** Eine klare Namenskonvention ist wichtig, z.B. `nova_de::domain::module::EventName`.
- **Publisher:** Die jeweilige Service-Implementierung, die die Zustandsänderung verursacht.
- **Subscriber:** Komponenten in der System- und UI-Schicht, die auf diese Änderungen reagieren müssen.
    - Beispiel: `ui::theming_gtk` abonniert `ThemeChangedEvent`.
    - Beispiel: `system::compositor` abonniert `ActiveWorkspaceChanged`.
- **Datei-Struktur:** Events können in einer `events.rs`-Datei innerhalb jedes Domänenmoduls definiert werden (z.B. `domain/src/theming/events.rs`).
- **Serialisierung:** Wenn Events über IPC-Grenzen (z.B. D-Bus) gesendet werden sollen, müssen sie `serde::Serialize` und `serde::Deserialize` implementieren.

### 2.4. Fehlertypen (Modulspezifisch)

Jedes Hauptmodul innerhalb der Domänenschicht sollte seine eigenen spezifischen Fehler-Enums definieren, um präzise Fehlerinformationen zu liefern.

- **Beispiele:** Die bereits bei den Services definierten Fehler (`ThemingError`, `WorkspaceManagerError`, `AIInteractionError`, `NotificationError`, `GlobalSettingsError`).
- **Implementierungsrichtlinien:**
    - Verwendung des `thiserror`-Crates für eine ergonomische Definition.
    - Jeder Fehlertyp in einer eigenen Datei (z.B. `domain/src/theming/error.rs`).
    - Fehlervarianten sollten klare und spezifische Fehlerzustände des Moduls beschreiben.
    - Wo sinnvoll, sollten Quellfehler (`#[source]`) oder Konvertierungen (`#[from]`) für Fehler aus der Kernschicht oder anderen Abhängigkeiten bereitgestellt werden, um die Fehlerkette zu erhalten.
- **Verwendung:** Domänenservices geben diese spezifischen Fehler in ihren `Result`-Typen zurück. Die System- und UI-Schicht behandeln diese Fehler oder leiten sie ggf. weiter, eventuell gewrappt in ihre eigenen, allgemeineren Fehlertypen.

---

## 3. Schicht: Systemschicht (System Layer)

Die Systemschicht stellt der UI-Schicht systemnahe Dienste und Ereignisse zur Verfügung und setzt deren Befehle technisch um. Sie interagiert direkt mit dem Betriebssystem, der Hardware (über Abstraktionen wie DRM/GBM, libinput), Systemdiensten (via D-Bus, PipeWire) und dem Wayland-Compositor-Backend (Smithay). Sie konsumiert APIs der Domänenschicht, um Geschäftslogik anzuwenden und Zustände abzufragen.

Diese Schicht ist die Brücke zwischen der abstrakten Domänenlogik von NovaDE und den konkreten Realitäten des Betriebssystems und der Hardware. Hier finden viele der FFI-Aufrufe, IPC-Kommunikation und Interaktionen auf niedriger Ebene statt. Smithay wird intensiv für Wayland-bezogene Komponenten genutzt. Eine robuste Fehlerbehandlung ist entscheidend, um Fehler von niedriger Ebene in abstraktere `SystemError`-Typen oder spezifische Unterfehler zu übersetzen. Die asynchrone Natur vieler Operationen (IPC, Hardwareinteraktion) ist hier kritisch.

### 3.1. Modul: `system::compositor` (Smithay-basierter Wayland Compositor Kern)

Dieses Modul ist das Herzstück der grafischen Darstellung und Fensterverwaltung in NovaDE. Es basiert auf der Smithay-Bibliothek und implementiert die Kernfunktionalitäten eines Wayland-Compositors.

- **Abhängigkeiten:** `smithay`, `wayland-server`, `wayland-protocols`, `calloop`, `input` (libinput-rs), `drm-rs`, `gbm-rs`, `libloading` (für EGL).
- **Verzeichnis:** `system/src/compositor/`

#### 3.1.1. `NovaDeSystemState` Struktur (Hauptzustand für Smithay Handler)

Diese Struktur dient als zentraler Datenhalter für den Event-Loop und implementiert die verschiedenen Handler-Traits von Smithay.

- **Datei:** `system/src/state.rs` (oder `system/src/compositor/state.rs`, je nach Gesamtstruktur)
- **Felder (Beispiele, basierend auf typischer Smithay-Nutzung und NovaDE-Anforderungen):**
    
    Rust
    
    ```
    use smithay::{
        backend::{
            allocator::dmabuf::DmabufState, // [50]
            drm::DrmDeviceFd, // [19, 24, 56, 62, 69, 93, 305, 388]
            egl::{EGLContext, EGLDisplay}, // [16, 26, 62, 65, 94, 97]
            renderer::{
                gles::GlesRenderer, // [16, 40, 62, 94, 97]
                multigpu::{gbm::GbmGlesBackend, GpuManager}, // [24, 28, 40, 62, 97, 145, 222]
            },
            libinput::LibinputInputBackend, // [23, 75, 382]
            udev::{UdevBackend, UdevEvent}, // [37]
            session::{Session, Signal as SessionSignal, logind::LogindSession}, // [362, 391]
            input::Seat,
        },
        desktop::{Space, Window, PopupManager, layer_map_for_output, LayerSurface}, // [67]
        input::{SeatState, SeatHandler, pointer::PointerHandle, keyboard::KeyboardHandle, touch::TouchHandle, SeatName},
        output::Output,
        reexports::{
            calloop::{EventLoop, LoopHandle, LoopSignal},
            wayland_server::{Display, DisplayHandle, Client,backend::GlobalId},
            wayland_protocols::xdg::shell::server::xdg_wm_base,
        },
        utils::{Clock, Logical, Point, Rectangle, Serial, Transform, SERIAL_COUNTER},
        wayland::{
            buffer::BufferHandler, // [353]
            compositor::{CompositorState, CompositorHandler, CompositorClientState, SurfaceData}, // [17, 87, 99]
            dmabuf::DmabufHandler, // [50]
            output::{OutputHandler, OutputManagerState}, // [49, 147, 280, 370, 372, 392]
            presentation::PresentationState, // [274]
            seat::WaylandSeatData,
            shell::{
                xdg::{XdgShellState, XdgShellHandler, XdgShellSurfaceUserData, XdgWmBaseUserData, decoration::XdgDecorationState}, // [13, 31, 54, 81, 167, 176, 191, 195, 199, 204, 207, 208, 215, 223, 224, 225, 227, 317, 323, 336, 349, 350, 393, 394, 395, 396, 397, 398, 399, 400]
                wlr_layer::{WlrLayerShellState, LayerShellHandler, LayerSurfaceData}, // [11, 19, 20, 41, 48, 57, 66, 67, 71, 91, 92, 95, 160, 192, 254, 292, 307, 318, 347, 401, 402]
            },
            shm::{ShmState, ShmHandler}, // [141, 165]
            selection::{
                data_device::{DataDeviceState, DataDeviceHandler}, // [11, 12, 19, 35, 44, 45, 73, 80, 141, 216, 403, 404, 405, 406]
                primary_selection::{PrimarySelectionState, PrimarySelectionHandler}, // [30, 120]
            },
            input_method::{InputMethodManagerState, InputMethodHandler, InputMethodKeyboardUserData}, // [11, 34, 35, 117, 253, 264, 268, 407, 408, 409, 410, 411]
            text_input::{TextInputManagerState, TextInputHandler, TextInputUserData}, // [86, 112, 328, 412, 413, 414]
            viewporter::ViewporterState, // [371]
            xdg_activation::XdgActivationState, // [303]
            foreign_toplevel::ForeignToplevelState, // [335]
            idle_notify::IdleNotifierState, // [58]
            explicit_synchronization::ExplicitSyncState, // [415]
            drm_lease::DrmLeaseState, // [107]
            server_decoration::ServerDecorationManagerState, // [297]
        },
        xwayland::{XWayland, XWaylandEvent, XWaylandClientData, xwm::{X11Wm, XwmHandler, X11Surface}}, // [11, 14, 19, 21, 32, 35, 36, 41, 43, 52, 60, 76, 78, 85, 117, 141, 219, 270, 310, 329, 339, 361, 363, 377, 416, 417]
    };
    use std::{collections::HashMap, sync::{Arc, Mutex}};
    use crate::system::dbus::DBusConnectionManager; // Für D-Bus Interaktionen
    use crate::system::audio::PipeWireClientService; // Für PipeWire
    use crate::domain::services::DomainLayerServices; // Wrapper für Domain-Service-Handles
    
    pub struct NovaDeSystemState {
        pub display_handle: DisplayHandle,
        pub event_loop_handle: LoopHandle<'static, Self>,
        pub loop_signal: LoopSignal,
        pub clock: Clock, // Für Timings, Animationen
    
        // Core Wayland protocol states
        pub compositor_state: Arc<Mutex<CompositorState>>,
        pub shm_state: Arc<Mutex<ShmState>>,
        pub output_manager_state: Arc<Mutex<OutputManagerState>>,
        pub seat_state: Arc<Mutex<SeatState<Self>>>,
        pub data_device_state: Arc<Mutex<DataDeviceState>>,
        pub primary_selection_state: Arc<Mutex<PrimarySelectionState>>,
    
        // Shells
        pub xdg_shell_state: Arc<Mutex<XdgShellState>>,
        pub layer_shell_state: Arc<Mutex<WlrLayerShellState>>,
        pub xdg_decoration_state: Arc<Mutex<XdgDecorationState>>,
        // Optional: xwayland_shell_state if using Smithay's xwayland shell helpers
    
        // Input related
        pub text_input_manager_state: Arc<Mutex<TextInputManagerState>>,
        pub input_method_manager_state: Arc<Mutex<InputMethodManagerState>>,
    
        // Optional Wayland protocol states
        pub presentation_time_state: Option<Arc<Mutex<PresentationState>>>,
        pub viewporter_state: Option<Arc<Mutex<ViewporterState>>>,
        pub xdg_activation_state: Option<Arc<Mutex<XdgActivationState>>>,
        pub foreign_toplevel_state: Option<Arc<Mutex<ForeignToplevelState>>>,
        pub idle_notifier_state: Option<Arc<Mutex<IdleNotifierState<Self>>>>,
        pub explicit_sync_state: Option<Arc<Mutex<ExplicitSyncState>>>,
        pub drm_lease_state: Option<Arc<Mutex<DrmLeaseState>>>,
        pub server_decoration_manager_state: Option<Arc<Mutex<ServerDecorationManagerState>>>,
    
        // Backend specific states
        pub udev_backend_data: Option<UdevBackendData>, // If using udev backend
        pub winit_data: Option<WinitData>, // If using winit backend
        pub x11_data: Option<X11BackendData>, // If using X11 backend (as a client)
    
        // XWayland
        pub xwayland: Option<XWayland>,
        pub xwm: Option<Arc<Mutex<X11Wm>>>, // X11 Window Manager for XWayland
        pub xwayland_client_data_id: Option<u32>, // To identify XWayland's client
    
        // Desktop management
        pub space: Arc<Mutex<Space<WindowElement>>>, // Manages windows and outputs
        pub popup_manager: Arc<Mutex<PopupManager>>,
    
        // Input devices
        pub seat_name: String,
        pub seat: Seat<Self>,
        pub pointer: PointerHandle<Self>,
        pub keyboard: KeyboardHandle<Self>,
        pub touch: Option<TouchHandle<Self>>, // Touch ist optional
    
        // Domain Layer Access
        pub domain_services: Arc<DomainLayerServices>,
    
        // System Services Clients
        pub dbus_conn_manager: Arc<DBusConnectionManager>,
        pub pipewire_service: Arc<PipeWireClientService>,
    
        // Internal state
        pub running: std::sync::atomic::AtomicBool,
        pub active_workspace_id: Option<crate::domain::workspaces::WorkspaceId>,
        // Weitere anwendungsspezifische Zustände
    }
    
    // Hilfsstrukturen für Backend-spezifische Daten
    pub struct UdevBackendData {
        pub session: LogindSession, // Oder eine andere Session-Implementierung
        pub gpus: GpuManager<GbmGlesBackend<GlesRenderer, DrmDeviceFd>>,
        pub primary_gpu: DrmDeviceFd,
        pub udev_backend: UdevBackend,
        // Weitere DRM/GBM/EGL spezifische Zustände
    }
    pub struct WinitData { /*... relevante Winit-Felder... */ }
    pub struct X11BackendData { /*... relevante X11-Backend-Felder... */ }
    
    // WindowElement (Beispiel, muss an NovaDE angepasst werden)
    #
    pub enum WindowElement {
        Wayland(Window), // Smithay's Window für XDG Toplevels
        X11(X11Surface), // Smithay's X11Surface
        Layer(LayerSurface), // Smithay's LayerSurface
    }
    // Implementiere notwendige Traits für WindowElement (z.B. RenderElement, SpaceElement)
    ```
    
    - Der Compositor ist das komplexeste Element der Systemschicht. Smithay 8 stellt Bausteine bereit, aber die eigentliche Fensterverwaltungslogik (Tiling, Stacking, Fokusrichtlinien basierend auf Domänenregeln) muss hier implementiert werden. Die `AnvilState` aus Smithays Anvil-Compositor dient als gute Referenz für die Strukturierung von `NovaDeSystemState` und die Integration verschiedener Smithay-Handler.

#### 3.1.2. Initialisierung (`system::compositor::initialize_compositor`)

- **Datei:** `system/src/compositor/init.rs`
- **Signatur:** `pub async fn initialize_compositor(domain_services: Arc<DomainLayerServices>, event_loop_handle: LoopHandle<'static, NovaDeSystemState>, loop_signal: LoopSignal) -> Result<NovaDeSystemState, SystemError>`
- **Schritte:**
    1. Erstelle `DisplayHandle` aus dem globalen `Display` Objekt (Annahme: `Display` wird im `main` erstellt und `DisplayHandle` wird hierher übergeben oder `NovaDeSystemState` wird direkt im `main` erstellt).
    2. Initialisiere Smithay-Backends (z.B. `LibinputInputBackend` 23, `UdevBackend` 37, DRM/GBM/EGL 16). Die Wahl des Backends (DRM/libseat für Bare-Metal, Winit/X11 für verschachtelte Entwicklung) ist eine wichtige architektonische Entscheidung. Die Implementierung sollte dies abstrahieren.
    3. Initialisiere alle relevanten Wayland-Globale unter Verwendung ihrer

---

# NovaDE Interner Schnittstellen-Implementierungsleitfaden

Dieser Implementierungsleitfaden definiert die ultrafeinen Spezifikationen und hochdetaillierten Implementierungspläne für jede Schicht der Linux-Desktop-Umgebung "NovaDE". Er ist so detailliert konzipiert, dass Entwickler ihn direkt zur Implementierung verwenden können, ohne eigene Entscheidungen treffen oder Logiken/Algorithmen entwerfen zu müssen.

---

## 1. Schicht: Kernschicht (Core Layer)

Die Kernschicht (Core Layer) bildet das Fundament von NovaDE und stellt grundlegende, universell einsetzbare Bausteine und Dienste bereit, die von allen darüberliegenden Schichten – der Domänenschicht, der Systemschicht und der Benutzeroberflächenschicht (UI-Schicht) – genutzt werden. Die Kommunikation mit höheren Schichten erfolgt durch die direkte Verwendung der hier definierten Typen und Funktionen.

### 1.1. Modul: `core::types`

Dieses Modul definiert grundlegende Datentypen, die systemweit für geometrische Berechnungen, Farbdarstellungen und andere fundamentale Konzepte verwendet werden.

- **Verzeichnis:** `core/src/types/`

#### 1.1.1. `Point<T>` Struktur

Stellt einen Punkt im 2D-Raum dar.

- Datei: `core/src/types/point.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Point<T, U> {
        pub x: T,
        pub y: T,
        _unit: std::marker::PhantomData<U>,
    }
    
    impl<T: Default, U> Default for Point<T, U> {
        fn default() -> Self {
            Point { x: Default::default(), y: Default::default(), _unit: std::marker::PhantomData }
        }
    }
    
    // U kann z.B. Logical, Physical, BufferCoords sein
    pub struct Logical;
    pub struct Physical;
    pub struct BufferCoords;
    
    impl<T, U> Point<T, U> {
        pub const fn new(x: T, y: T) -> Self {
            Point { x, y, _unit: std::marker::PhantomData }
        }
    }
    
    // Weitere Methoden wie Add, Sub, etc. können implementiert werden.
    ```
    
- Verwendung: Positionierung von UI-Elementen, Fensterkoordinaten.

#### 1.1.2. `Size<T>` Struktur

Stellt die Dimensionen (Breite und Höhe) eines 2D-Objekts dar.

- Datei: `core/src/types/size.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Size<T, U> {
        pub w: T,
        pub h: T,
        _unit: std::marker::PhantomData<U>,
    }
    
    impl<T: Default, U> Default for Size<T, U> {
        fn default() -> Self {
            Size { w: Default::default(), h: Default::default(), _unit: std::marker::PhantomData }
        }
    }
    
    impl<T, U> Size<T, U> {
        pub const fn new(w: T, h: T) -> Self {
            Size { w, h, _unit: std.marker::PhantomData }
        }
    }
    ```
    
- Verwendung: Fenstergrößen, UI-Element-Dimensionen.

#### 1.1.3. `Rect<T>` und `RectInt` Strukturen

Stellt ein Rechteck im 2D-Raum dar, definiert durch Position und Größe.

- Datei: `core/src/types/rect.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Rect<T, U> {
        pub loc: Point<T, U>,
        pub size: Size<T, U>,
    }
    
    impl<T: Default, U> Default for Rect<T, U> {
        fn default() -> Self {
            Rect { loc: Default::default(), size: Default::default() }
        }
    }
    
    impl<T, U> Rect<T, U> {
        pub const fn new(loc: Point<T, U>, size: Size<T, U>) -> Self {
            Rect { loc, size }
        }
        // Methoden wie contains_point, intersection, etc.
    }
    
    pub type RectInt = Rect<i32, Logical>; // Beispiel für einen häufigen Typ
    ```
    
- Verwendung: Fenstergeometrien, Auswahlbereiche.

#### 1.1.4. `Color` Struktur

Repräsentiert eine Farbe im RGBA-Format.

- Datei: `core/src/types/color.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Color {
        pub r: f32, // Range 0.0 to 1.0
        pub g: f32, // Range 0.0 to 1.0
        pub b: f32, // Range 0.0 to 1.0
        pub a: f32, // Range 0.0 to 1.0 (alpha)
    }
    
    impl Color {
        pub const fn new(r: f32, g: f32, b: f32, a: f32) -> Self {
            Color { r, g, b, a }
        }
    
        pub fn to_hex_rgb(&self) -> String {
            format!(
                "#{:02x}{:02x}{:02x}",
                (self.r * 255.0) as u8,
                (self.g * 255.0) as u8,
                (self.b * 255.0) as u8
            )
        }
    
        pub fn to_hex_rgba(&self) -> String {
            format!(
                "#{:02x}{:02x}{:02x}{:02x}",
                (self.r * 255.0) as u8,
                (self.g * 255.0) as u8,
                (self.b * 255.0) as u8,
                (self.a * 255.0) as u8
            )
        }
        // Ggf. From-Implementierungen für gängige Formate (z.B. String "#RRGGBB")
    }
    ```
    
- Verwendung: Theming, UI-Elementfarben.

#### 1.1.5. `Orientation` Enum

Definiert die Ausrichtung von UI-Elementen oder Layouts.

- Datei: `core/src/types/orientation.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub enum Orientation {
        Horizontal,
        Vertical,
    }
    ```
    
- Verwendung: Layout-Manager, Ausrichtung von Bedienelementen.

#### 1.1.6. `uuid::Uuid` Integration

Universell eindeutige Identifikatoren.

- Datei: `core/src/types/mod.rs` (als Re-Export)
- Re-Export: `pub use uuid::Uuid;`
- Abhängigkeit in `core/Cargo.toml`: `uuid = { version = "1.0", features = ["v4", "serde"] }`
    - Die Features `v4` und `serde` sind essenziell. `v4` ermöglicht die Generierung zufälliger UUIDs, die für die eindeutige Identifizierung von Entitäten wie Fenstern, Workspaces oder Benachrichtigungen unerlässlich sind. `serde` wird benötigt, falls diese IDs in Konfigurationsdateien persistiert oder über IPC-Schnittstellen serialisiert werden müssen, was in einer Desktop-Umgebung sehr wahrscheinlich ist.1
- Verwendung: Eindeutige Identifizierung von Ressourcen systemweit.

#### 1.1.7. `chrono::DateTime<Utc>` Integration

Zeitstempel mit UTC-Zeitzone.

- Datei: `core/src/types/mod.rs` (als Re-Export)
- Re-Export: `pub use chrono::{DateTime, Utc};`
- Abhängigkeit in `core/Cargo.toml`: `chrono = { version = "0.4", features = ["serde"] }`
    - `chrono` ist der De-facto-Standard für Datums- und Zeitmanipulationen in Rust. Die Verwendung von `DateTime<Utc>` stellt zeitzonenagnostische Zeitstempel sicher, was für interne Repräsentationen als Best Practice gilt, um Komplexitäten bei der Zeitzonenbehandlung zu vermeiden. Das `serde`-Feature ist notwendig, wenn Zeitstempel persistiert (z.B. in Logdateien oder Konfigurationen) oder serialisiert werden sollen.3
- Verwendung: Zeitstempel für Logging, Events, "zuletzt geändert"-Informationen.

#### 1.1.8. Implementierungsschritte für `core::types`

1. Erstellen Sie das Verzeichnis `core/src/types/`.
2. Implementieren Sie `point.rs`, `size.rs`, `rect.rs`, `color.rs`, und `orientation.rs` gemäß den obigen Spezifikationen.
3. Fügen Sie `uuid` (mit Features "v4", "serde") und `chrono` (mit Feature "serde") zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
4. Fügen Sie die Re-Exports für `Uuid` und `DateTime<Utc>` in `core/src/types/mod.rs` hinzu. Alle lokalen Typen (Point, Size, etc.) sollten ebenfalls von `mod.rs` re-exportiert werden.
    
    Rust
    
    ```
    // core/src/types/mod.rs
    mod color;
    mod orientation;
    mod point;
    mod rect;
    mod size;
    
    pub use chrono::{DateTime, Utc};
    pub use color::Color;
    pub use orientation::Orientation;
    pub use point::{BufferCoords, Logical, Physical, Point};
    pub use rect::{Rect, RectInt};
    pub use size::Size;
    pub use uuid::Uuid;
    ```
    

### 1.2. Modul: `core::errors`

Dieses Modul stellt eine Basis-Fehlerbehandlungsstrategie und den `CoreError`-Typ bereit. Höhere Schichten können `CoreError` oder spezifischere Fehler aus Kernmodulen mittels `#[from]` oder `#[source]` in ihre eigenen Fehlertypen wrappen, wobei die Fehlerursachenkette (`source()`) beibehalten wird.

- **Verzeichnis:** `core/src/`
- Datei: `core/src/errors.rs`

#### 1.2.1. `CoreError` Enum

- Definition unter Verwendung von `thiserror`:
    
    Rust
    
    ```
    #
    pub enum CoreError {
        #[error("I/O error: {source}")]
        Io {
            #[from]
            source: std::io::Error,
            // Optional: context: String, // Um zusätzlichen Kontext zur IO-Operation zu geben
        },
    
        #[error("Configuration parsing error from '{path:?}': {message}")]
        ConfigParse {
            path: Option<std::path::PathBuf>,
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #
        Serialization {
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #
        Deserialization {
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #[error("Invalid path: {path:?}")]
        InvalidPath { path: std::path::PathBuf },
    
        #[error("Initialization failed for module: {module_name}")]
        InitializationFailed {
            module_name: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #[error("Feature not implemented: {feature_name}")]
        NotImplemented { feature_name: String },
    
        #[error("Internal error: {message}")]
        Internal { message: String },
    
        #[error("Operation timed out: {operation}")]
        Timeout { operation: String },
    
        #[error("Permission denied for operation: {operation}")]
        PermissionDenied { operation: String },
    }
    ```
    
    Die Verwendung von `thiserror` 5 ist entscheidend für die Erstellung ergonomischer und informativer Fehlertypen. Das Attribut `#[from]` ermöglicht eine einfache Konvertierung von Standardbibliotheksfehlern wie `std::io::Error`. Das Attribut `#[source]` (implizit von `thiserror` verwendet, wenn ein Feld `#[from]` oder explizit `#[source]` ist) ist entscheidend für die Beibehaltung der Fehlerursachenkette, wie in der Spezifikation hervorgehoben. Eine robuste Fehlerbehandlungsstrategie ist fundamental. `thiserror` vereinfacht die Erstellung benutzerdefinierter Fehlertypen, die gut mit dem `Error`-Trait von Rust integriert sind. Die Beibehaltung der `source()`-Kette ist für das Debugging unerlässlich, da sie es Entwicklern ermöglicht, einen Fehler bis zu seinem Ursprung zurückzuverfolgen, selbst wenn er von verschiedenen Schichten mehrfach umgebrochen wird.

#### 1.2.2. Fehlerpropagierungsstrategie

Alle Funktionen in der Kernschicht, die fehlschlagen können, MÜSSEN `Result<T, CoreError>` oder `Result<T, SpecificCoreSubError>` zurückgeben, wobei `SpecificCoreSubError` via `#[from]` in `CoreError` konvertierbar sein sollte. Höhere Schichten definieren ihre eigenen Fehler-Enums (z.B. `DomainError`, `SystemError`, `UIError`) und verwenden `#[from] CoreError` oder `#[source] CoreError`, um Fehler aus dem Kern zu wrappen.

#### 1.2.3. Implementierungsschritte für `core::errors`

1. Fügen Sie `thiserror = "1.0"` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Implementieren Sie `core/src/errors.rs` mit dem `CoreError`-Enum wie oben spezifiziert.
3. Stellen Sie sicher, dass alle Module der Kernschicht `CoreError` für ihre Fehlerberichterstattung verwenden.

### 1.3. Modul: `core::logging`

Dieses Modul definiert die Logging-Infrastruktur basierend auf dem `tracing`-Crate. Alle höheren Schichten verwenden die `tracing`-Makros für ihre Logging-Ausgaben.

- **Verzeichnis:** `core/src/`
- Datei: `core/src/logging.rs`

#### 1.3.1. `initialize_logging()` Funktion

- Signatur:
    
    Rust
    
    ```
    pub fn initialize_logging(
        level_filter: tracing::Level,
        use_json: bool,
        custom_writer: Option<Box<dyn Fn() -> Box<dyn std::io::Write + Send + Sync + 'static> + Send + Sync + 'static>>
    ) -> Result<(), CoreError>
    ```
    
    - `level_filter`: Der minimale Log-Level, der aufgezeichnet werden soll (z.B. `tracing::Level::INFO`, `tracing::Level::DEBUG`).
    - `use_json`: Wenn `true`, werden Logs im JSON-Format ausgegeben, andernfalls in einem menschenlesbaren Format.
    - `custom_writer`: Eine optionale Funktion, die einen Writer für die Log-Ausgabe zurückgibt (z.B. in eine Datei, einen Netzwerk-Socket oder `std::io::stderr`). Standardmäßig wird `std::io::stderr` verwendet. Die Funktion wird verwendet, um den Writer bei Bedarf neu erstellen zu können (z.B. bei Log-Rotation).
- Implementierung:
    1. Verwendet `tracing_subscriber::fmt()` für die formatierte Protokollierung.
    2. Ermöglicht die Konfiguration des Formats (JSON oder "pretty") und des Writers.
        - Für JSON: `tracing_subscriber::fmt().json().with_writer(writer_closure).init();`
        - Für Pretty: `tracing_subscriber::fmt().pretty().with_writer(writer_closure).init();`
    3. Konfiguriert den `EnvFilter` basierend auf `level_filter` oder einer Umgebungsvariable (z.B. `RUST_LOG`).
    4. Richtet einen globalen Standard-Subscriber ein mittels `tracing::subscriber::set_global_default`.
    5. Gibt `Result<(), CoreError>` zurück, um Initialisierungsfehler zu signalisieren (z.B. wenn das Setzen des globalen Subscribers fehlschlägt).
- Die Standardisierung auf `tracing` ermöglicht eine strukturierte Protokollierung über alle Schichten hinweg, was für das Debugging und die Überwachung eines komplexen Systems wie einer Desktop-Umgebung von unschätzbarem Wert ist. Die Möglichkeit, zwischen menschenlesbaren und JSON-Formaten zu wechseln, ist gut für Entwicklung versus Produktion/Log-Aggregation. `tracing` bietet ein leistungsfähigeres und flexibleres Logging-Framework als das ältere `log`-Crate, insbesondere durch sein Konzept von Spans für kontextbezogene Protokollierung. Dies ist in einem mehrschichtigen, ereignisgesteuerten System von großem Vorteil.

#### 1.3.2. Verwendung von `tracing`-Makros

Alle Schichten verwenden die Makros `trace!`, `debug!`, `info!`, `warn!`, `error!` aus dem `tracing`-Crate. Spans (`span!`, `info_span!`, etc.) sollten verwendet werden, um kontextuelle Informationen für zusammengehörige Log-Meldungen bereitzustellen.

- Beispiel: `info!(target: "core::config", path = %file_path.display(), "Lade Kernkonfiguration.");`
- Beispiel mit Span:
    
    Rust
    
    ```
    let workspace_span = info_span!("workspace_operation", id = %workspace_id);
    let _enter = workspace_span.enter();
    //... Operationen innerhalb des Spans...
    info!("Operation abgeschlossen");
    ```
    

#### 1.3.3. Implementierungsschritte für `core::logging`

1. Fügen Sie `tracing = "0.1"` und `tracing_subscriber = { version = "0.3", features = ["fmt", "json", "env-filter"] }` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Implementieren Sie `core/src/logging.rs` mit der Funktion `initialize_logging()` wie oben spezifiziert.

### 1.4. Modul: `core::config`

Dieses Modul stellt Primitive zum Laden, Parsen und Zugreifen auf Kernkonfigurationen bereit. Es definiert die Struktur `CoreConfig` und Funktionen für deren Verwaltung.

- **Verzeichnis:** `core/src/config/`

#### 1.4.1. `CoreConfig` Struktur

Definiert die Kernkonfigurationseinstellungen.

- Datei: `core/src/config/types.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct CoreConfig {
        pub log_level: String, // z.B. "info", "debug", "trace"
        pub log_format: LogFormat,
        pub default_theme_name: Option<String>,
        pub enable_xwayland: bool,
        // Weitere kernspezifische Konfigurationen, z.B. Pfade, Feature-Flags
    }
    
    #
    #[serde(rename_all = "lowercase")]
    pub enum LogFormat {
        Json,
        Pretty,
    }
    
    impl Default for CoreConfig {
        fn default() -> Self {
            CoreConfig {
                log_level: "info".to_string(),
                log_format: LogFormat::Pretty,
                default_theme_name: Some("NovaDark".to_string()),
                enable_xwayland: true,
            }
        }
    }
    ```
    

#### 1.4.2. `ConfigError` Enum

Spezifische Fehler für das Laden und Verarbeiten von Konfigurationen.

- Datei: `core/src/config/error.rs`
- Definition:
    
    Rust
    
    ```
    use crate::core::errors::CoreError; // Assuming CoreError is in crate::core
    
    #
    pub enum ConfigError {
        #[error("Failed to determine config directory: {0}")]
        DirectoryResolutionError(String),
    
        #[error("Config file not found at {path:?}")]
        FileNotFound { path: std::path::PathBuf },
    
        #[error("Failed to read config file {path:?}")]
        FileReadError {
            path: std::path::PathBuf,
            #[source]
            source: std::io::Error,
        },
    
        #
        TomlParseError {
            path: std::path::PathBuf,
            message: String,
            #[source]
            source: Option<toml::de::Error>,
        },
        // Ggf. JsonParseError, falls JSON auch unterstützt wird
    
        #[error("Configuration not loaded or initialization failed.")]
        NotLoaded,
    
        #[error("Invalid configuration value for key '{key}': {message}")]
        InvalidValue { key: String, message: String },
    
        #[error("Failed to write default config to {path:?}")]
        DefaultConfigWriteError {
            path: std::path::PathBuf,
            #[source]
            source: std::io::Error,
        },
    
        #
        DefaultConfigTomlError(#[from] toml::ser::Error),
    
        #[error(transparent)]
        Core(#[from] CoreError), // Um CoreError wrappen zu können
    }
    ```
    

#### 1.4.3. Globale Konfigurationsvariable

Verwendet `once_cell` für eine thread-sichere, einmalig initialisierte globale Konfiguration.

- Datei: `core/src/config/mod.rs` (oder `core/src/config/global.rs`)
    
    Rust
    
    ```
    use once_cell::sync::OnceCell;
    use std::sync::RwLock;
    use super::types::CoreConfig; // Pfad anpassen
    use super::error::ConfigError; // Pfad anpassen
    
    static CORE_CONFIG: OnceCell<RwLock<CoreConfig>> = OnceCell::new();
    ```
    

#### 1.4.4. `load_core_config()` Funktion

Lädt die Kernkonfiguration aus einer Datei.

- Datei: `core/src/config/loader.rs`
- Signatur: `pub fn load_core_config(custom_path: Option<std::path::PathBuf>) -> Result<(), ConfigError>`
- Implementierung:
    
    1. Bestimme den Konfigurationsdateipfad:
        - Verwende `custom_path`, falls angegeben.
        - Andernfalls suche im XDG-Standardverzeichnis (z.B. `$XDG_CONFIG_HOME/nova-de/core.toml`) mittels `directories_next::ProjectDirs`.
        - Falls kein XDG-Verzeichnis gefunden wird, verwende einen Fallback-Pfad (z.B. `~/.config/nova-de/core.toml`).
    2. Wenn die Datei nicht existiert, erstelle eine Standardkonfiguration (`CoreConfig::default()`) und speichere sie unter dem ermittelten Pfad. Logge diesen Vorgang.
    3. Lese den Dateiinhalt. Bei Fehler `ConfigError::FileReadError`.
    4. Parse den Inhalt (z.B. TOML) in eine `CoreConfig`-Instanz. Bei Fehler `ConfigError::TomlParseError`.
    5. Initialisiere die globale `CORE_CONFIG` Variable mit der geladenen Konfiguration: `CORE_CONFIG.set(RwLock::new(loaded_config)).map_err(|_| ConfigError::NotLoaded)` (Fehlerbehandlung für den Fall, dass `set` fehlschlägt, was nur passiert, wenn bereits initialisiert).
    6. Gibt `Ok(())` bei Erfolg zurück.
    
    - Eine globale, statisch zugängliche Konfiguration ist üblich, erfordert aber eine sorgfältige Verwaltung, insbesondere bei der Initialisierung. `once_cell` für die Lazy-Initialisierung und `RwLock` für den threadsicheren Zugriff sind ein gutes Muster. Die Konfiguration muss früh im Anwendungslebenszyklus verfügbar sein und von verschiedenen Teilen des Systems zugänglich sein. `once_cell` stellt sicher, dass das Laden nur einmal erfolgt.

#### 1.4.5. `get_core_config()` Funktion

Bietet globalen Lesezugriff auf die geladene `CoreConfig`.

- Datei: `core/src/config/access.rs`
- Signatur: `pub fn get_core_config() -> Result<std::sync::RwLockReadGuard<'static, CoreConfig>, ConfigError>`
- Implementierung:
    1. Versuche, einen Read-Lock auf `CORE_CONFIG` zu erhalten: `CORE_CONFIG.get().ok_or(ConfigError::NotLoaded)?.read().map_err(|_| ConfigError::NotLoaded)` (Fehlerbehandlung für Poisoned Lock).
    2. Gibt den `RwLockReadGuard` bei Erfolg zurück.

#### 1.4.6. `update_core_config()` Funktion (Optional)

Ermöglicht die dynamische Aktualisierung der Kernkonfiguration zur Laufzeit.

- Datei: `core/src/config/access.rs`
- Signatur: `pub fn update_core_config(new_config: CoreConfig) -> Result<(), ConfigError>`
- Implementierung:
    1. Versuche, einen Write-Lock auf `CORE_CONFIG` zu erhalten.
    2. Aktualisiere die Konfiguration.
    3. Persistiert die neue Konfiguration in die Datei.
    4. **Wichtig:** Benachrichtige relevante Systemteile über die Konfigurationsänderung (z.B. über ein Event). Dies erfordert sorgfältige Überlegungen zur Thread-Sicherheit und wie Komponenten auf dynamische Änderungen reagieren.

#### 1.4.7. Implementierungsschritte für `core::config`

1. Fügen Sie `serde = { version = "1.0", features = ["derive"] }`, `toml = "0.8"`, `once_cell = "1.19"`, `directories-next = "2.0"` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Erstellen Sie die Verzeichnisstruktur `core/src/config/`.
3. Definieren Sie `CoreConfig` und `LogFormat` in `core/src/config/types.rs`.
4. Definieren Sie `ConfigError` in `core/src/config/error.rs`.
5. Implementieren Sie `loader.rs` (mit `load_core_config`) und `access.rs` (mit `get_core_config` und optional `update_core_config`).
6. Fügen Sie die globale `CORE_CONFIG`-Variable in `core/src/config/mod.rs` oder einer dedizierten `global.rs` ein und exportieren Sie die öffentlichen Funktionen.

### 1.5. Modul: `core::utils`

Dieses Modul bietet allgemeine Hilfsfunktionen, die von allen höheren Schichten genutzt werden können.

- **Verzeichnis:** `core/src/utils/`
- **Struktur:** Das Modul sollte in thematische Untermodule aufgeteilt werden, um die Übersichtlichkeit zu wahren.

#### 1.5.1. Untermodul: `core::utils::file_utils`

- Datei: `core/src/utils/file_utils.rs`
- Funktionen:
    - `pub fn read_file_to_string(path: &std::path::Path) -> Result<String, CoreError>`
        - Implementierung: Verwendet `std::fs::read_to_string`. Mappt `std::io::Error` auf `CoreError::Io`.
    - `pub fn ensure_dir_exists(path: &std::path::Path) -> Result<(), CoreError>`
        - Implementierung: Verwendet `std::fs::create_dir_all`. Mappt `std::io::Error` auf `CoreError::Io`.
    - `pub fn write_string_to_file(path: &std::path::Path, content: &str) -> Result<(), CoreError>`
        - Implementierung: Verwendet `std::fs::write`. Mappt `std::io::Error` auf `CoreError::Io`.

#### 1.5.2. Untermodul: `core::utils::string_utils`

- Datei: `core/src/utils/string_utils.rs`
- Funktionen:
    - `pub fn sanitize_filename(name: &str) -> String`
        - Implementierung: Ersetzt ungültige Zeichen für Dateinamen (z.B. `/`, `\`, `:`, `*`, `?`, `"`, `<`, `>`, `|`) durch Unterstriche oder entfernt sie.
    - `pub fn truncate_string_with_ellipsis(s: &str, max_len: usize) -> String`
        - Implementierung: Kürzt den String auf `max_len` Zeichen und fügt "..." hinzu, falls er gekürzt wurde. Achtet auf Grapheme Cluster, um Unicode-Zeichen nicht zu zerschneiden.
            
            Rust
            
            ```
            use unicode_segmentation::UnicodeSegmentation;
            //...
            // if s.graphemes(true).count() > max_len {
            //     s.graphemes(true).take(max_len - 3).collect::<String>() + "..."
            // } else {
            //     s.to_string()
            // }
            ```
            
            - Abhängigkeit: `unicode-segmentation = "1.10"`

#### 1.5.3. Untermodul: `core::utils::async_utils` (falls benötigt)

- Datei: `core/src/utils/async_utils.rs`
- Mögliche Funktionen:
    - Wrapper für `tokio::spawn` mit standardisierter Fehlerbehandlung oder Logging.
    - Hilfsfunktionen für Timeout-Management bei asynchronen Operationen.

#### 1.5.4. Implementierungsschritte für `core::utils`

1. Erstellen Sie das Verzeichnis `core/src/utils/`.
2. Erstellen Sie `core/src/utils/mod.rs` und deklarieren Sie die Untermodule:
    
    Rust
    
    ```
    pub mod file_utils;
    pub mod string_utils;
    // pub mod async_utils;
    ```
    
3. Implementieren Sie die Funktionen in den jeweiligen Untermodul-Dateien.
4. Fügen Sie ggf. Abhängigkeiten wie `unicode-segmentation` zu `core/Cargo.toml` hinzu.
5. Das `utils`-Modul kann leicht zu einer Ansammlung unzusammenhängender Funktionen werden. Es ist wichtig, die Organisation beizubehalten und sicherzustellen, dass die Funktionen eine breite Anwendbarkeit haben. Wenn eine Hilfsfunktion sehr spezifisch für eine einzelne Domäne oder ein Systemanliegen ist, sollte sie stattdessen im Hilfsmodul dieser Schicht angesiedelt sein. Eine klare Abgrenzung ist notwendig, um die Kohäsion der Module zu wahren und unnötige Kopplungen zu vermeiden.

---

## 2. Schicht: Domänenschicht (Domain Layer)

Die Domänenschicht kapselt die Geschäftslogik und den Kernzustand der Desktop-Umgebung NovaDE. Sie definiert die zentralen Konzepte, Regeln und Verhaltensweisen des Systems, unabhängig von technischen Implementierungsdetails der System- oder UI-Schicht. Die Kommunikation mit höheren Schichten (System- und UI-Schicht) erfolgt primär über wohldefinierte Service-APIs (als Rust-Traits implementiert) und durch domänenspezifische Events, die Zustandsänderungen signalisieren.

Die Domänenschicht ist zentral für die Funktionalität von NovaDE. Die Verwendung von Rust-Traits für Service-APIs fördert lose Kopplung und Testbarkeit. Ereignisse sind der Schlüssel zur reaktiven Propagierung von Zustandsänderungen. Fehlertypen sollten für jedes Domänenmodul spezifisch sein, um klaren Kontext zu bieten.

### 2.1. Service APIs (Traits)

Öffentliche Schnittstellen der Domänenschicht werden primär durch Rust-Traits definiert. Diese Traits werden von Service-Strukturen innerhalb der Domänenmodule implementiert. Methoden sind typischerweise `async`, wenn sie I/O-Operationen oder potenziell langlaufende Prozesse beinhalten, und geben `Result<T, SpecificDomainError>` zurück.

#### 2.1.1. `domain::theming::ThemingEngine` Trait

Verantwortlich für die Verwaltung und Anwendung von Themes.

- **Datei:** `domain/src/theming/engine.rs`

##### Zugehörige Datenstrukturen und Typen:

- **`ThemingConfiguration` Struct (Wertobjekt):**
    
    - Definiert die vom Benutzer oder System gewählten Theme-Einstellungen.
    - **Datei:** `domain/src/theming/config.rs`
    - **Felder:**
        - `icon_theme_name: String` (z.B. "Adwaita", "Papirus")
        - `gtk_theme_name: String` (z.B. "Adwaita-dark")
        - `cursor_theme_name: String` (z.B. "Adwaita")
        - `font_name: String` (z.B. "Cantarell 11")
        - `wallpaper_path: Option<std::path::PathBuf>`
        - `color_scheme: ColorScheme` (Enum: `Light`, `Dark`, `SystemPreference`)
        - `accent_color: core::types::Color`
    - **Invarianten:** `font_name` darf nicht leer sein, wenn gesetzt.
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`ColorScheme` Enum (Wertobjekt):**
    
    - Definiert die möglichen Farbschemata.
    - **Datei:** `domain/src/theming/config.rs` (oder `types.rs` im Theming-Modul)
    - **Varianten:** `Light`, `Dark`, `SystemPreference`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`AppliedThemeState` Struct (Wertobjekt):**
    
    - Repräsentiert den aktuell angewandten Theme-Zustand, inklusive aufgelöster Werte.
    - **Datei:** `domain/src/theming/state.rs`
    - **Felder:**
        - `current_config: ThemingConfiguration`
        - `resolved_wallpaper_path: Option<std::path::PathBuf>` (absoluter Pfad zum tatsächlich genutzten Hintergrundbild)
        - `font_config_details: String` (z.B. eine Pango-Font-Beschreibung oder Fontconfig-Pattern)
        - `effective_color_scheme: EffectiveColorScheme` (Enum: `Light`, `Dark`)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`EffectiveColorScheme` Enum (Wertobjekt):**
    
    - Repräsentiert das tatsächlich aktive Farbschema (aufgelöst aus `SystemPreference`).
    - **Datei:** `domain/src/theming/state.rs`
    - **Varianten:** `Light`, `Dark`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`ThemingError` Enum (Fehlertyp):**
    
    - Spezifische Fehler für das Theming-Subsystem.
    - **Datei:** `domain/src/theming/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum ThemingError {
            #[error("Invalid theming configuration: {0}")]
            InvalidConfiguration(String),
        
            #[error("Wallpaper not found at path: {0:?}")]
            WallpaperNotFound(std::path::PathBuf),
        
            #[error("Failed to apply theme '{theme_name}': {details}")]
            ThemeApplyFailed {
                theme_name: String,
                details: String,
                #[source]
                source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
            },
        
            #[error("Persistence error during theming operation")]
            PersistenceError(#[from] crate::core::errors::CoreError), // Assuming CoreError is accessible
        
            #[error("Underlying system service error for theming: {0}")]
            SystemServiceError(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn get_current_theme_state(&self) -> Result<AppliedThemeState, ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den aktuell im System angewandten und zwischengespeicherten Theme-Zustand ab.
    - **Vorbedingungen:** Keine.
    - **Nachbedingungen:** Gibt den `AppliedThemeState` zurück oder einen `ThemingError`.
- `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Aktualisiert die Theme-Konfiguration, persistiert sie und stößt die Anwendung des neuen Themes an.
    - **Vorbedingungen:** `new_config` muss valide sein (ggf. interne Validierung).
    - **Nachbedingungen:** Bei Erfolg wird das `ThemeChangedEvent` publiziert. Die Konfiguration wird persistiert (z.B. über `GlobalSettingsService` oder ein dediziertes Persistenz-Interface). Das System-Theme wird (versucht) anzuwenden.
    - **Geschäftsregeln:** Validiert die `new_config`. Löst das Hintergrundbild auf.
- `async fn apply_theme_to_system(&self, theme_state: &AppliedThemeState) -> Result<(), ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** (Potenziell intern, aufgerufen von `update_configuration`, oder als separate Methode für fortgeschrittene Nutzung) Wendet den gegebenen `AppliedThemeState` auf die Systemkomponenten an (z.B. Setzen von GTK-Theme, Icons, Cursor über Systemmechanismen).
    - **Vorbedingungen:** `theme_state` ist valide.
    - **Nachbedingungen:** Theme-Änderungen sind im System (versucht) aktiv.

##### Publizierte Events:

- **`ThemeChangedEvent`:**
    - **Datei:** `domain/src/theming/events.rs`
    - **Struktur:**
        
        Rust
        
        ```
        #
        pub struct ThemeChangedEvent {
            pub new_state: AppliedThemeState,
            pub old_state: Option<AppliedThemeState>, // Optional, falls der vorherige Zustand bekannt ist
        }
        ```
        
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::theming::ThemeChangedEvent`
    - **Typische Publisher:** Die Implementierung von `ThemingEngine`.
    - **Typische Subscriber:** `ui::theming_gtk` (UI-Schicht), `system::compositor` (Systemschicht, falls relevant für Darstellung).

#### 2.1.2. `domain::workspaces::WorkspaceManager` Trait

Verwaltet Workspaces (virtuelle Desktops).

- **Datei:** `domain/src/workspaces/manager.rs`

##### Zugehörige Datenstrukturen und Typen:

- **`WorkspaceId` Typalias:**
    
    - **Datei:** `domain/src/workspaces/types.rs` (oder direkt in `manager.rs`)
    - **Definition:** `pub type WorkspaceId = core::types::Uuid;`
- **`ApplicationIdentifier` Struct (Wertobjekt):**
    
    - Identifiziert eine Anwendung eindeutig.
    - **Datei:** `domain/src/workspaces/app_id.rs`
    - **Felder:**
        - `id_type: ApplicationIdType` (Enum: `DesktopFile`, `WaylandAppId`, `X11WindowClass`)
        - `identifier_str: String` (z.B. "firefox.desktop", "org.gnome.Nautilus", "Firefox")
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `serde::Serialize`, `serde::Deserialize`.
- **`Workspace` Struct (Entität):**
    
    - Repräsentiert einen einzelnen Workspace.
    - **Datei:** `domain/src/workspaces/workspace.rs`
    - **Felder:**
        - `id: WorkspaceId` (Sichtbarkeit: `pub(crate)`, Zugriff über Getter)
        - `name: String` (Sichtbarkeit: `pub`)
        - `output_name: Option<String>` (Name des Monitors, dem der Workspace primär zugeordnet ist, Sichtbarkeit: `pub`)
        - `layout_policy: WorkspaceLayoutPolicy` (Enum: `Tiling`, `Floating`, `Hybrid`, Sichtbarkeit: `pub`)
        - `pinned_applications: std::collections::HashSet<ApplicationIdentifier>` (Sichtbarkeit: `pub(crate)`, Zugriff über Methoden)
        - `creation_timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
        - `last_accessed_timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
    - **Initialwerte:** `id` wird bei Erstellung generiert, `name` z.B. "Workspace 1", `output_name` ist `None`, `layout_policy` wird aus globalen Einstellungen übernommen oder ist Standard (`Floating`), `pinned_applications` ist leer, `creation_timestamp` und `last_accessed_timestamp` sind Zeitpunkte der Erstellung.
    - **Invarianten:** `name` darf nicht leer sein. `id` ist unveränderlich nach Erstellung.
    - **Methoden (Beispiele):**
        - `pub fn new(name: String, layout_policy: WorkspaceLayoutPolicy) -> Self`
        - `pub fn id(&self) -> WorkspaceId`
        - `pub fn add_pinned_app(&mut self, app_id: ApplicationIdentifier) -> bool`
        - `pub fn remove_pinned_app(&mut self, app_id: &ApplicationIdentifier) -> bool`
        - `pub fn is_app_pinned(&self, app_id: &ApplicationIdentifier) -> bool`
        - `pub(crate) fn set_last_accessed(&mut self)`
    - **Beziehungen:** Keine direkten Entitätsbeziehungen in dieser Struktur, aber `pinned_applications` verweist auf `ApplicationIdentifier`.
- **`WorkspaceLayoutPolicy` Enum (Wertobjekt):**
    
    - **Datei:** `domain/src/workspaces/types.rs`
    - **Varianten:** `Tiling`, `Floating`, `Hybrid`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`WorkspaceManagerError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/workspaces/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum WorkspaceManagerError {
            #
            WorkspaceNotFound(super::types::WorkspaceId), // super::types::WorkspaceId
        
            #[error("Workspace with name '{0}' already exists")]
            DuplicateWorkspaceName(String),
        
            #[error("Maximum number of workspaces reached ({0})")]
            MaxWorkspacesReached(usize),
        
            #[error("Cannot delete the last workspace")]
            CannotDeleteLastWorkspace,
        
            #[error("Cannot delete active workspace; switch to another first")]
            CannotDeleteActiveWorkspace,
        
            #[error("Persistence error during workspace operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #[error("Invalid application identifier: {0}")]
            InvalidApplicationId(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn create_workspace(&self, name: Option<String>) -> Result<Workspace, WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Erstellt einen neuen Workspace. Wenn `name` `None` ist, wird ein Standardname generiert (z.B. "Workspace N").
    - **Nachbedingungen:** Bei Erfolg wird `WorkspaceEvent::Created` publiziert. Der neue Workspace wird persistiert.
    - **Geschäftsregeln:** Prüft auf Namenskonflikte und maximale Anzahl von Workspaces.
- `async fn delete_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Löscht den Workspace mit der gegebenen ID.
    - **Vorbedingungen:** Workspace darf nicht der letzte verbleibende sein. Workspace darf nicht der aktive sein (oder es muss eine Logik zum Wechsel des aktiven Workspaces implementiert sein).
    - **Nachbedingungen:** Bei Erfolg wird `WorkspaceEvent::Deleted` publiziert. Änderungen werden persistiert.
- `async fn get_workspace_by_id(&self, id: WorkspaceId) -> Result<Option<Workspace>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn get_all_workspaces(&self) -> Result<Vec<Workspace>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Vorbedingungen:** Der Workspace mit `id` muss existieren.
    - **Nachbedingungen:** `WorkspaceEvent::ActiveChanged` wird publiziert. Der `last_accessed_timestamp` des neuen und ggf. des alten aktiven Workspaces wird aktualisiert.
- `async fn get_active_workspace_id(&self) -> Result<Option<WorkspaceId>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Vorbedingungen:** `new_name` darf nicht leer sein und nicht mit einem existierenden Workspace-Namen (außer dem eigenen) kollidieren.
    - **Nachbedingungen:** `WorkspaceEvent::Renamed` wird publiziert. Änderung wird persistiert.
- `async fn pin_application_to_space(&self, space_id: WorkspaceId, app_id: ApplicationIdentifier) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Nachbedingungen:** `WorkspaceEvent::AppPinned` wird publiziert. Änderung wird persistiert.
- `async fn unpin_application_from_space(&self, space_id: WorkspaceId, app_id: ApplicationIdentifier) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Nachbedingungen:** `WorkspaceEvent::AppUnpinned` wird publiziert. Änderung wird persistiert.
- `async fn move_window_to_workspace(&self, window_identifier: String /* Eindeutiger Fenster-Identifikator, z.B. Wayland Surface ID als String */, target_workspace_id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Fordert an, ein Fenster zum Ziel-Workspace zu verschieben. Die eigentliche Fensterverschiebung erfolgt in der Systemschicht.
    - **Nachbedingungen:** `WorkspaceEvent::WindowMoved` wird publiziert.

##### Publizierte Events:

- **`WorkspaceEvent` Enum:**
    - **Datei:** `domain/src/workspaces/events.rs`
    - **Varianten (Beispiele):**
        - `Created { workspace: Workspace }`
        - `Deleted { workspace_id: WorkspaceId, new_active_workspace_id: Option<WorkspaceId> }`
        - `ActiveChanged { old_id: Option<WorkspaceId>, new_id: WorkspaceId }`
        - `Renamed { workspace_id: WorkspaceId, new_name: String }`
        - `AppPinned { space_id: WorkspaceId, app_id: ApplicationIdentifier }`
        - `AppUnpinned { space_id: WorkspaceId, app_id: ApplicationIdentifier }`
        - `LayoutPolicyChanged { workspace_id: WorkspaceId, new_policy: WorkspaceLayoutPolicy }`
        - `WindowMoved { window_identifier: String, source_workspace_id: Option<WorkspaceId>, target_workspace_id: WorkspaceId }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::workspaces::WorkspaceEvent`
    - **Typische Publisher:** Die Implementierung von `WorkspaceManager`.
    - **Typische Subscriber:** `ui::shell` (UI-Schicht), `system::compositor` (Systemschicht).

#### 2.1.3. `domain::user_centric_services::AIInteractionLogicService` Trait

Steuert die Logik für Benutzerinteraktionen mit KI-Diensten, inklusive Einwilligungsmanagement.

- **Datei:** `domain/src/user_centric_services/ai_logic.rs`
- Diese Service-Schnittstelle ist entscheidend für die sichere und transparente Integration von KI-Funktionen. Die Trennung der Einwilligungslogik von der reinen MCP-Kommunikation (die in der Systemschicht angesiedelt ist) ist ein wichtiger Aspekt für Datenschutz und Benutzerkontrolle.

##### Zugehörige Datenstrukturen und Typen:

- **`AIInteractionContextData` Struct (Wertobjekt):**
    
    - Sammelt Kontextinformationen für eine KI-Anfrage.
    - **Datei:** `domain/src/user_centric_services/ai_context.rs`
    - **Felder:**
        - `active_window_title: Option<String>`
        - `active_app_id: Option<super::workspaces::app_id::ApplicationIdentifier>` // Pfad anpassen
        - `current_workspace_id: Option<super::workspaces::types::WorkspaceId>` // Pfad anpassen
        - `selected_text: Option<String>`
        - `clipboard_content_preview: Option<String>` (Vorschau, nicht der volle Inhalt)
        - `screenshot_data_uri: Option<String>` (Data-URI eines Screenshots, falls relevant)
        - `user_query: String` (Die eigentliche Anfrage des Benutzers)
        - `interaction_id: core::types::Uuid` (Eindeutige ID für diese Interaktion)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIConsent` Enum (Wertobjekt):**
    
    - Repräsentiert den Einwilligungsstatus des Benutzers für KI-Interaktionen.
    - **Datei:** `domain/src/user_centric_services/ai_consent.rs`
    - **Varianten:**
        - `Granted { for_session: bool, timestamp: core::types::DateTime<core::types::Utc> }` (Einwilligung für die aktuelle Sitzung oder dauerhaft)
        - `Denied { timestamp: core::types::DateTime<core::types::Utc> }`
        - `NotSet`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIInteractionResponse` Struct (Wertobjekt):**
    
    - Repräsentiert die Antwort von einem KI-Dienst.
    - **Datei:** `domain/src/user_centric_services/ai_response.rs`
    - **Felder:**
        - `interaction_id: core::types::Uuid`
        - `response_text: Option<String>`
        - `suggested_actions: Vec<String>`
        - `tool_call_id: Option<String>` (Falls ein Tool vom MCP-Server aufgerufen wurde)
        - `tool_call_result: Option<serde_json::Value>` (Ergebnis des Tool-Aufrufs)
        - `error_message: Option<String>`
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIInteractionError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/user_centric_services/ai_error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum AIInteractionError {
            #[error("User consent not given for AI interaction")]
            ConsentNotGiven,
        
            #[error("MCP client error: {0}")]
            MCPError(String), // Wird von SystemMcpService kommen
        
            #[error("Failed to prepare context for AI interaction: {0}")]
            ContextPreparationFailed(String),
        
            #[error("AI service returned an error: {0}")]
            AIServiceError(String),
        
            #[error("Persistence error during AI consent operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #
            InteractionNotFoundOrTimedOut(crate::core::types::Uuid),
        }
        ```
        

##### Methoden des Traits:

- `async fn initiate_interaction(&self, context_data: AIInteractionContextData) -> Result<core::types::Uuid /* interaction_id */, AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Startet eine neue KI-Interaktion. Prüft die Einwilligung und leitet die Anfrage ggf. an den `SystemMcpService` weiter. Gibt eine `interaction_id` zurück, um die Antwort später zu korrelieren.
    - **Vorbedingungen:** `get_consent_status()` darf nicht `Denied` sein. Wenn `NotSet`, wird die Interaktion ggf. pausiert und ein `AIConsentRequestEvent` ausgelöst.
    - **Nachbedingungen:** `AIInteractionStartedEvent` wird publiziert.
    - **Geschäftsregeln:** Die Logik hier muss entscheiden, ob basierend auf `context_data` und `AIConsent` die Interaktion fortgesetzt, abgelehnt oder eine erneute Einwilligung angefordert wird.
- `async fn provide_consent(&self, consent: AIConsent) -> Result<(), AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Speichert die Benutzereinwilligung.
    - **Nachbedingungen:** `AIConsentChangedEvent` wird publiziert. Der Einwilligungsstatus wird persistiert.
- `async fn get_consent_status(&self) -> Result<AIConsent, AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den aktuellen Einwilligungsstatus ab.
- `async fn process_mcp_response(&self, interaction_id: core::types::Uuid, response: Result<serde_json::Value, String> /* MCP Tool Call Result oder Fehler */) -> Result<(), AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Verarbeitet eine asynchrone Antwort vom `SystemMcpService` (typischerweise ein Tool-Aufruf-Ergebnis).
    - **Nachbedingungen:** `AIInteractionCompletedEvent` oder `AIInteractionFailedEvent` wird publiziert.

##### Publizierte Events:

- **`AIConsentChangedEvent`:**
    - **Datei:** `domain/src/user_centric_services/events.rs`
    - **Struktur:** `pub struct AIConsentChangedEvent { pub new_status: AIConsent; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIConsentChangedEvent`
- **`AIInteractionStartedEvent`:**
    - **Struktur:** `pub struct AIInteractionStartedEvent { pub interaction_id: core::types::Uuid, pub context: AIInteractionContextData; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionStartedEvent`
- **`AIInteractionCompletedEvent`:**
    - **Struktur:** `pub struct AIInteractionCompletedEvent { pub response: AIInteractionResponse; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionCompletedEvent`
- **`AIInteractionFailedEvent`:**
    - **Struktur:** `pub struct AIInteractionFailedEvent { pub interaction_id: core::types::Uuid, pub error: AIInteractionError; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionFailedEvent`
- **`AIConsentRequestEvent`:** (Falls die UI den Benutzer zur Einwilligung auffordern soll)
    - **Struktur:** `pub struct AIConsentRequestEvent { pub interaction_id: core::types::Uuid, pub for_context: AIInteractionContextData }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIConsentRequestEvent`
- **Typische Publisher:** Die Implementierung von `AIInteractionLogicService`.
- **Typische Subscriber:** `ui::command_palette` oder KI-Widgets (UI-Schicht), `system::mcp::SystemMcpService` (Systemschicht, für Antworten).

#### 2.1.4. `domain::user_centric_services::NotificationService` Trait

Verwaltet das Anzeigen und Interagieren mit Desktop-Benachrichtigungen.

- **Datei:** `domain/src/user_centric_services/notification_service.rs`
- Die Parameter für `post_notification` spiegeln eng die D-Bus-Methode `org.freedesktop.Notifications.Notify` wider.9 Dieser Dienst fungiert als Abstraktion über potenzielle D-Bus-Implementierungen in der Systemschicht. Die Domänenschicht definiert das _Konzept_ einer Benachrichtigung innerhalb von NovaDE. Die Systemschicht wäre dann dafür verantwortlich, diese Benachrichtigung tatsächlich über D-Bus zu senden, wenn NovaDE als Benachrichtigungsserver fungiert, oder auf D-Bus-Benachrichtigungen zu lauschen, wenn es diese konsumiert. Die Verwendung von `zvariant::OwnedValue` für `hints` deutet auf eine direkte Abbildung auf D-Bus-Varianten hin.

##### Zugehörige Datenstrukturen und Typen:

- **`NotificationId` Typalias:**
    
    - **Datei:** `domain/src/user_centric_services/types.rs` (oder direkt in `notification_service.rs`)
    - **Definition:** `pub type NotificationId = core::types::Uuid;`
- **`NotificationAction` Struct (Wertobjekt):**
    
    - Definiert eine Aktion, die mit einer Benachrichtigung verbunden ist.
    - **Datei:** `domain/src/user_centric_services/notification_action.rs`
    - **Felder:**
        - `key: String` (Eindeutiger Schlüssel für die Aktion, z.B. "default", "reply")
        - `label: String` (Anzeigetext für den Button)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `serde::Serialize`, `serde::Deserialize`.
- **`NotificationUrgency` Enum (Wertobjekt):**
    
    - Definiert die Dringlichkeitsstufe einer Benachrichtigung.
    - **Datei:** `domain/src/user_centric_services/types.rs`
    - **Varianten:** `Low`, `Normal`, `Critical`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`Notification` Struct (Entität):**
    
    - Repräsentiert eine einzelne Desktop-Benachrichtigung.
    - **Datei:** `domain/src/user_centric_services/notification.rs`
    - **Felder:**
        - `id: NotificationId` (Sichtbarkeit: `pub(crate)`, Zugriff über Getter)
        - `app_name: String` (Sichtbarkeit: `pub`)
        - `replaces_id: Option<NotificationId>` (Sichtbarkeit: `pub`)
        - `app_icon: Option<String>` (Pfad oder Name des Icons, Sichtbarkeit: `pub`)
        - `summary: String` (Kurze Zusammenfassung, Sichtbarkeit: `pub`)
        - `body: Option<String>` (Detaillierter Text, Sichtbarkeit: `pub`)
        - `actions: Vec<NotificationAction>` (Sichtbarkeit: `pub`)
        - `hints: std::collections::HashMap<String, zbus::zvariant::OwnedValue>` (Spezifische Hinweise für den Notification-Server, Sichtbarkeit: `pub`)
        - `expire_timeout_ms: i32` (-1 für Server-Default, 0 für nie, >0 für Millisekunden, Sichtbarkeit: `pub`)
        - `urgency: NotificationUrgency` (Sichtbarkeit: `pub`)
        - `timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
        - `is_displayed: std::sync::atomic::AtomicBool` (Interner Status, ob die Benachrichtigung aktuell angezeigt wird)
    - **Initialwerte:** `id` wird generiert, `timestamp` ist aktuell, `is_displayed` ist `false`.
    - **Invarianten:** `summary` darf nicht leer sein. `id` ist unveränderlich.
    - **Methoden (Beispiele):**
        - `pub fn id(&self) -> NotificationId`
        - `pub(crate) fn mark_as_displayed(&self)`
        - `pub(crate) fn mark_as_closed(&self)`
- **`CloseReason` Enum (Wertobjekt):**
    
    - Gibt den Grund an, warum eine Benachrichtigung geschlossen wurde.
    - **Datei:** `domain/src/user_centric_services/types.rs`
    - **Varianten:** `Expired`, `DismissedByUser`, `ClosedByApp`, `ServiceShutdown`, `Unknown`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`NotificationError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/user_centric_services/notification_error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum NotificationError {
            #
            NotificationNotFound(super::types::NotificationId), // Pfad anpassen
        
            #[error("Invalid notification format or content: {0}")]
            InvalidNotificationFormat(String),
        
            #[error("Failed to invoke action '{action_key}' for notification {notification_id}: {reason}")]
            ActionInvokeFailed {
                notification_id: super::types::NotificationId, // Pfad anpassen
                action_key: String,
                reason: String,
            },
        
            #[error("Notification service is unavailable or failed: {0}")]
            ServiceUnavailable(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn post_notification(&self, app_name: String, replaces_id: Option<NotificationId>, app_icon: Option<String>, summary: String, body: Option<String>, actions: Vec<NotificationAction>, hints: std::collections::HashMap<String, zbus::zvariant::OwnedValue>, expire_timeout_ms: i32, urgency: NotificationUrgency) -> Result<NotificationId, NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Sendet eine neue Benachrichtigung oder aktualisiert eine existierende.
    - **Nachbedingungen:** Bei Erfolg wird `NotificationPostedEvent` publiziert. Die Benachrichtigung wird (versucht) dem Benutzer angezeigt.
- `async fn get_active_notifications(&self) -> Result<Vec<Notification>, NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft eine Liste aller aktuell aktiven (angezeigten) Benachrichtigungen ab.
- `async fn close_notification(&self, id: NotificationId, reason: CloseReason) -> Result<(), NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Schließt eine spezifische Benachrichtigung.
    - **Vorbedingungen:** Benachrichtigung mit `id` muss existieren und aktiv sein.
    - **Nachbedingungen:** `NotificationClosedEvent` wird publiziert.
- `async fn invoke_action(&self, id: NotificationId, action_key: String) -> Result<(), NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Löst eine mit einer Benachrichtigung verbundene Aktion aus.
    - **Vorbedingungen:** Benachrichtigung mit `id` und Aktion mit `action_key` müssen existieren.
    - **Nachbedingungen:** `NotificationActionInvokedEvent` wird publiziert.

##### Publizierte Events:

- **`NotificationPostedEvent`:**
    - **Datei:** `domain/src/user_centric_services/events.rs`
    - **Struktur:** `pub struct NotificationPostedEvent { pub notification: Notification; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationPostedEvent`
- **`NotificationClosedEvent`:**
    - **Struktur:** `pub struct NotificationClosedEvent { pub id: NotificationId, pub reason: CloseReason; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationClosedEvent`
- **`NotificationActionInvokedEvent`:**
    - **Struktur:** `pub struct NotificationActionInvokedEvent { pub id: NotificationId, pub action_key: String; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationActionInvokedEvent`
- **Typische Publisher:** Die Implementierung von `NotificationService`.
- **Typische Subscriber:** `ui::notifications_frontend` oder `ui::shell` (UI-Schicht), `system::dbus::notification_server` (Systemschicht, falls NovaDE als Server agiert und die Events intern weiterleitet).

#### 2.1.5. `domain::global_settings_and_state_management::GlobalSettingsService` Trait

Verwaltet globale Desktop-Einstellungen und deren Persistenz.

- **Datei:** `domain/src/global_settings/service.rs`
- Dieser Dienst bietet eine strukturierte Methode zur Verwaltung einer Vielzahl von Desktop-Einstellungen. Der Persistenzmechanismus (z.B. eine Implementierung von `domain::settings_persistence_iface`, wie in der Kernschichtspezifikation erwähnt) ist hier von entscheidender Bedeutung.

##### Zugehörige Datenstrukturen und Typen:

- **`SettingPath` Typalias:**
    
    - **Datei:** `domain/src/global_settings/types.rs`
    - **Definition:** `pub type SettingPath = String;` (z.B. "desktop.background.color", "keyboard.layouts.0.name")
- **`SettingValue` Enum (Wertobjekt):**
    
    - Repräsentiert den Wert einer Einstellung. Kann verschiedene primitive Typen und verschachtelte Strukturen annehmen.
    - **Datei:** `domain/src/global_settings/value.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        #[serde(untagged)] // Für flexible (De-)Serialisierung
        pub enum SettingValue {
            String(String),
            Integer(i64),
            Float(f64),
            Boolean(bool),
            List(Vec<SettingValue>),
            Map(std::collections::HashMap<String, SettingValue>),
            Null, // Um das Fehlen eines Wertes explizit darzustellen
        }
        // Implement From<T> for SettingValue für gängige Typen
        ```
        
    - Die Verwendung von `serde_json::Value` wäre eine Alternative für maximale Flexibilität, aber ein eigenes Enum bietet mehr Typsicherheit innerhalb der Domäne.
- **`GlobalDesktopSettings` Struct (Entität):**
    
    - Repräsentiert die Gesamtheit aller verwalteten Einstellungen.
    - **Datei:** `domain/src/global_settings/settings_struct.rs`
    - **Felder:**
        - `settings: std::collections::BTreeMap<SettingPath, SettingValue>` (BTreeMap für geordnete Iteration/Serialisierung, falls gewünscht)
    - **Sichtbarkeit:** `pub(crate)` für `settings`, Zugriff über Methoden.
    - **Methoden (Beispiele):**
        - `pub fn get(&self, path: &SettingPath) -> Option<&SettingValue>`
        - `pub fn set(&mut self, path: SettingPath, value: SettingValue) -> Option<SettingValue>` (gibt alten Wert zurück)
        - `pub fn remove(&mut self, path: &SettingPath) -> Option<SettingValue>`
- **`GlobalSettingsError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/global_settings/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum GlobalSettingsError {
            #
            SettingNotFound(super::types::SettingPath), // Pfad anpassen
        
            #
            TypeMismatch {
                path: super::types::SettingPath, // Pfad anpassen
                expected_type: String,
                found_type: String,
            },
        
            #[error("Persistence error during settings operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #[error("Validation error for setting '{path}': {message}")]
            ValidationError {
                path: super::types::SettingPath, // Pfad anpassen
                message: String,
            },
        
            #[error("Invalid setting path format: {0}")]
            InvalidPathFormat(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn load_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Lädt alle Einstellungen aus der Persistenzschicht.
    - **Nachbedingungen:** Gibt die geladenen `GlobalDesktopSettings` zurück oder einen Fehler.
- `async fn save_settings(&self, settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Persistiert den gesamten Einstellungsbaum.
- `async fn get_setting(&self, path: &SettingPath) -> Result<Option<SettingValue>, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den Wert einer spezifischen Einstellung ab.
- `async fn update_setting(&self, path: SettingPath, value: SettingValue) -> Result<Option<SettingValue /* old_value */>, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Aktualisiert eine spezifische Einstellung und persistiert die Änderung. Gibt den alten Wert zurück, falls vorhanden.
    - **Vorbedingungen:** `path` und `value` müssen validen Formaten entsprechen. Ggf. Validierung gegen ein Schema.
    - **Nachbedingungen:** Bei Erfolg wird `SettingChangedEvent` publiziert. Die Einstellung wird persistiert.
- `async fn get_all_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft eine Kopie aller aktuellen Einstellungen ab.

##### Publizierte Events:

- **`SettingChangedEvent`:**
    - **Datei:** `domain/src/global_settings/events.rs`
    - **Struktur:**
        
        Rust
        
        ```
        #
        pub struct SettingChangedEvent {
            pub path: SettingPath,
            pub old_value: Option<SettingValue>,
            pub new_value: SettingValue,
        }
        ```
        
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::global_settings::SettingChangedEvent`
- **Typische Publisher:** Die Implementierung von `GlobalSettingsService`.
- **Typische Subscriber:** `ui::control_center` (UI-Schicht), verschiedene Systemkomponenten, die auf Einstellungsänderungen reagieren müssen.

### 2.2. Datenstrukturen (Öffentlich)

Zusätzlich zu den direkt mit Service-APIs assoziierten Strukturen können weitere öffentliche Datenstrukturen existieren, die Zustände oder Konfigurationen repräsentieren und von mehreren Modulen oder Schichten verwendet werden.

- **Beispiele:** Viele der oben bereits definierten Strukturen fallen in diese Kategorie, z.B. `AppliedThemeState`, `Workspace`, `Notification`, `GlobalDesktopSettings`, `ThemingConfiguration`, `ApplicationIdentifier`, `AIInteractionContextData`, `AIConsent`, `SettingValue`.
- **Implementierungsrichtlinien:**
    - Jede Struktur/Enum in einer eigenen Datei innerhalb des relevanten Domänenmoduls (z.B. `domain/src/theming/state.rs`).
    - Ableitung von `Debug`, `Clone`, `PartialEq` ist Standard.
    - Ableitung von `serde::Serialize`, `serde::Deserialize` falls Persistenz oder IPC-Übertragung erforderlich ist.
    - Felder sollten `pub` sein, wenn sie direkt von extern gelesen werden sollen, oder `pub(crate)` mit öffentlichen Gettern/Settern für kontrollierten Zugriff.
    - Invarianten sollten durch Konstruktoren und Methoden sichergestellt werden.
    - Beziehungen zu anderen Entitäten/Wertobjekten sollten klar definiert sein (z.B. durch Komposition oder IDs).

### 2.3. Events (Domänenspezifisch)

Domänenspezifische Events signalisieren wichtige Zustandsänderungen innerhalb der Domänenschicht. Sie sind entscheidend für eine reaktive Architektur und lose Kopplung.

- **Beispiele:** Die bereits bei den Services definierten Events (`ThemeChangedEvent`, `WorkspaceEvent`, `NotificationPostedEvent`, `SettingChangedEvent`, `AIConsentChangedEvent`, etc.).
- **Struktur:**
    - Jedes Event sollte als eigene Struktur oder als Variante eines umfassenderen Event-Enums (pro Modul) definiert werden.
    - Die Event-Struktur enthält alle relevanten Daten zur Zustandsänderung.
    - Beispiel: `pub struct ActiveWorkspaceChanged { pub old_id: Option<WorkspaceId>, pub new_id: WorkspaceId }`
- **Eindeutiger Event-Name/Typ:** Eine klare Namenskonvention ist wichtig, z.B. `nova_de::domain::module::EventName`.
- **Publisher:** Die jeweilige Service-Implementierung, die die Zustandsänderung verursacht.
- **Subscriber:** Komponenten in der System- und UI-Schicht, die auf diese Änderungen reagieren müssen.
    - Beispiel: `ui::theming_gtk` abonniert `ThemeChangedEvent`.
    - Beispiel: `system::compositor` abonniert `ActiveWorkspaceChanged`.
- **Datei-Struktur:** Events können in einer `events.rs`-Datei innerhalb jedes Domänenmoduls definiert werden (z.B. `domain/src/theming/events.rs`).
- **Serialisierung:** Wenn Events über IPC-Grenzen (z.B. D-Bus) gesendet werden sollen, müssen sie `serde::Serialize` und `serde::Deserialize` implementieren.

### 2.4. Fehlertypen (Modulspezifisch)

Jedes Hauptmodul innerhalb der Domänenschicht sollte seine eigenen spezifischen Fehler-Enums definieren, um präzise Fehlerinformationen zu liefern.

- **Beispiele:** Die bereits bei den Services definierten Fehler (`ThemingError`, `WorkspaceManagerError`, `AIInteractionError`, `NotificationError`, `GlobalSettingsError`).
- **Implementierungsrichtlinien:**
    - Verwendung des `thiserror`-Crates für eine ergonomische Definition.
    - Jeder Fehlertyp in einer eigenen Datei (z.B. `domain/src/theming/error.rs`).
    - Fehlervarianten sollten klare und spezifische Fehlerzustände des Moduls beschreiben.
    - Wo sinnvoll, sollten Quellfehler (`#[source]`) oder Konvertierungen (`#[from]`) für Fehler aus der Kernschicht oder anderen Abhängigkeiten bereitgestellt werden, um die Fehlerkette zu erhalten.
- **Verwendung:** Domänenservices geben diese spezifischen Fehler in ihren `Result`-Typen zurück. Die System- und UI-Schicht behandeln diese Fehler oder leiten sie ggf. weiter, eventuell gewrappt in ihre eigenen, allgemeineren Fehlertypen.

---

## 3. Schicht: Systemschicht (System Layer)

Die Systemschicht stellt der UI-Schicht systemnahe Dienste und Ereignisse zur Verfügung und setzt deren Befehle technisch um. Sie interagiert direkt mit dem Betriebssystem, der Hardware (über Abstraktionen wie DRM/GBM, libinput), Systemdiensten (via D-Bus, PipeWire) und dem Wayland-Compositor-Backend (Smithay). Sie konsumiert APIs der Domänenschicht, um Geschäftslogik anzuwenden und Zustände abzufragen.

Diese Schicht ist die Brücke zwischen der abstrakten Domänenlogik von NovaDE und den konkreten Realitäten des Betriebssystems und der Hardware. Hier finden viele der FFI-Aufrufe, IPC-Kommunikation und Interaktionen auf niedriger Ebene statt. Smithay wird intensiv für Wayland-bezogene Komponenten genutzt. Eine robuste Fehlerbehandlung ist entscheidend, um Fehler von niedriger Ebene in abstraktere `SystemError`-Typen oder spezifische Unterfehler zu übersetzen. Die asynchrone Natur vieler Operationen (IPC, Hardwareinteraktion) ist hier kritisch.

### 3.1. Modul: `system::compositor` (Smithay-basierter Wayland Compositor Kern)

Dieses Modul ist das Herzstück der grafischen Darstellung und Fensterverwaltung in NovaDE. Es basiert auf der Smithay-Bibliothek und implementiert die Kernfunktionalitäten eines Wayland-Compositors.

- **Abhängigkeiten:** `smithay`, `wayland-server`, `wayland-protocols`, `calloop`, `input` (libinput-rs), `drm-rs`, `gbm-rs`, `libloading` (für EGL).
- **Verzeichnis:** `system/src/compositor/`

#### 3.1.1. `NovaDeSystemState` Struktur (Hauptzustand für Smithay Handler)

Diese Struktur dient als zentraler Datenhalter für den Event-Loop und implementiert die verschiedenen Handler-Traits von Smithay.

- **Datei:** `system/src/state.rs` (oder `system/src/compositor/state.rs`, je nach Gesamtstruktur)
- **Felder (Beispiele, basierend auf typischer Smithay-Nutzung und NovaDE-Anforderungen):**
    
    Rust
    
    ```
    use smithay::{
        backend::{
            allocator::dmabuf::DmabufState, // [50]
            drm::DrmDeviceFd, // [19, 24, 56, 62, 69, 93, 305, 388]
            egl::{EGLContext, EGLDisplay}, // [16, 26, 62, 65, 94, 97]
            renderer::{
                gles::GlesRenderer, // [16, 40, 62, 94, 97]
                multigpu::{gbm::GbmGlesBackend, GpuManager}, // [24, 28, 40, 62, 97, 145, 222]
            },
            libinput::LibinputInputBackend, // [23, 75, 382]
            udev::{UdevBackend, UdevEvent}, // [37]
            session::{Session, Signal as SessionSignal, logind::LogindSession}, // [362, 391]
            input::Seat,
        },
        desktop::{Space, Window, PopupManager, layer_map_for_output, LayerSurface}, // [67]
        input::{SeatState, SeatHandler, pointer::PointerHandle, keyboard::KeyboardHandle, touch::TouchHandle, SeatName},
        output::Output,
        reexports::{
            calloop::{EventLoop, LoopHandle, LoopSignal},
            wayland_server::{Display, DisplayHandle, Client,backend::GlobalId},
            wayland_protocols::xdg::shell::server::xdg_wm_base,
        },
        utils::{Clock, Logical, Point, Rectangle, Serial, Transform, SERIAL_COUNTER},
        wayland::{
            buffer::BufferHandler, // [353]
            compositor::{CompositorState, CompositorHandler, CompositorClientState, SurfaceData}, // [17, 87, 99]
            dmabuf::DmabufHandler, // [50]
            output::{OutputHandler, OutputManagerState}, // [49, 147, 280, 370, 372, 392]
            presentation::PresentationState, // [274]
            seat::WaylandSeatData,
            shell::{
                xdg::{XdgShellState, XdgShellHandler, XdgShellSurfaceUserData, XdgWmBaseUserData, decoration::XdgDecorationState}, // [13, 31, 54, 81, 167, 176, 191, 195, 199, 204, 207, 208, 215, 223, 224, 225, 227, 317, 323, 336, 349, 350, 393, 394, 395, 396, 397, 398, 399, 400]
                wlr_layer::{WlrLayerShellState, LayerShellHandler, LayerSurfaceData}, // [11, 19, 20, 41, 48, 57, 66, 67, 71, 91, 92, 95, 160, 192, 254, 292, 307, 318, 347, 401, 402]
            },
            shm::{ShmState, ShmHandler}, // [141, 165]
            selection::{
                data_device::{DataDeviceState, DataDeviceHandler}, // [11, 12, 19, 35, 44, 45, 73, 80, 141, 216, 403, 404, 405, 406]
                primary_selection::{PrimarySelectionState, PrimarySelectionHandler}, // [30, 120]
            },
            input_method::{InputMethodManagerState, InputMethodHandler, InputMethodKeyboardUserData}, // [11, 34, 35, 117, 253, 264, 268, 407, 408, 409, 410, 411]
            text_input::{TextInputManagerState, TextInputHandler, TextInputUserData}, // [86, 112, 328, 412, 413, 414]
            viewporter::ViewporterState, // [371]
            xdg_activation::XdgActivationState, // [303]
            foreign_toplevel::ForeignToplevelState, // [335]
            idle_notify::IdleNotifierState, // [58]
            explicit_synchronization::ExplicitSyncState, // [415]
            drm_lease::DrmLeaseState, // [107]
            server_decoration::ServerDecorationManagerState, // [297]
        },
        xwayland::{XWayland, XWaylandEvent, XWaylandClientData, xwm::{X11Wm, XwmHandler, X11Surface}}, // [11, 14, 19, 21, 32, 35, 36, 41, 43, 52, 60, 76, 78, 85, 117, 141, 219, 270, 310, 329, 339, 361, 363, 377, 416, 417]
    };
    use std::{collections::HashMap, sync::{Arc, Mutex}};
    use crate::system::dbus::DBusConnectionManager; // Für D-Bus Interaktionen
    use crate::system::audio::PipeWireClientService; // Für PipeWire
    use crate::domain::services::DomainLayerServices; // Wrapper für Domain-Service-Handles
    
    pub struct NovaDeSystemState {
        pub display_handle: DisplayHandle,
        pub event_loop_handle: LoopHandle<'static, Self>,
        pub loop_signal: LoopSignal,
        pub clock: Clock, // Für Timings, Animationen
    
        // Core Wayland protocol states
        pub compositor_state: Arc<Mutex<CompositorState>>,
        pub shm_state: Arc<Mutex<ShmState>>,
        pub output_manager_state: Arc<Mutex<OutputManagerState>>,
        pub seat_state: Arc<Mutex<SeatState<Self>>>,
        pub data_device_state: Arc<Mutex<DataDeviceState>>,
        pub primary_selection_state: Arc<Mutex<PrimarySelectionState>>,
    
        // Shells
        pub xdg_shell_state: Arc<Mutex<XdgShellState>>,
        pub layer_shell_state: Arc<Mutex<WlrLayerShellState>>,
        pub xdg_decoration_state: Arc<Mutex<XdgDecorationState>>,
        // Optional: xwayland_shell_state if using Smithay's xwayland shell helpers
    
        // Input related
        pub text_input_manager_state: Arc<Mutex<TextInputManagerState>>,
        pub input_method_manager_state: Arc<Mutex<InputMethodManagerState>>,
    
        // Optional Wayland protocol states
        pub presentation_time_state: Option<Arc<Mutex<PresentationState>>>,
        pub viewporter_state: Option<Arc<Mutex<ViewporterState>>>,
        pub xdg_activation_state: Option<Arc<Mutex<XdgActivationState>>>,
        pub foreign_toplevel_state: Option<Arc<Mutex<ForeignToplevelState>>>,
        pub idle_notifier_state: Option<Arc<Mutex<IdleNotifierState<Self>>>>,
        pub explicit_sync_state: Option<Arc<Mutex<ExplicitSyncState>>>,
        pub drm_lease_state: Option<Arc<Mutex<DrmLeaseState>>>,
        pub server_decoration_manager_state: Option<Arc<Mutex<ServerDecorationManagerState>>>,
    
        // Backend specific states
        pub udev_backend_data: Option<UdevBackendData>, // If using udev backend
        pub winit_data: Option<WinitData>, // If using winit backend
        pub x11_data: Option<X11BackendData>, // If using X11 backend (as a client)
    
        // XWayland
        pub xwayland: Option<XWayland>,
        pub xwm: Option<Arc<Mutex<X11Wm>>>, // X11 Window Manager for XWayland
        pub xwayland_client_data_id: Option<u32>, // To identify XWayland's client
    
        // Desktop management
        pub space: Arc<Mutex<Space<WindowElement>>>, // Manages windows and outputs
        pub popup_manager: Arc<Mutex<PopupManager>>,
    
        // Input devices
        pub seat_name: String,
        pub seat: Seat<Self>,
        pub pointer: PointerHandle<Self>,
        pub keyboard: KeyboardHandle<Self>,
        pub touch: Option<TouchHandle<Self>>, // Touch ist optional
    
        // Domain Layer Access
        pub domain_services: Arc<DomainLayerServices>,
    
        // System Services Clients
        pub dbus_conn_manager: Arc<DBusConnectionManager>,
        pub pipewire_service: Arc<PipeWireClientService>,
    
        // Internal state
        pub running: std::sync::atomic::AtomicBool,
        pub active_workspace_id: Option<crate::domain::workspaces::WorkspaceId>,
        // Weitere anwendungsspezifische Zustände
    }
    
    // Hilfsstrukturen für Backend-spezifische Daten
    pub struct UdevBackendData {
        pub session: LogindSession, // Oder eine andere Session-Implementierung
        pub gpus: GpuManager<GbmGlesBackend<GlesRenderer, DrmDeviceFd>>,
        pub primary_gpu: DrmDeviceFd,
        pub udev_backend: UdevBackend,
        // Weitere DRM/GBM/EGL spezifische Zustände
    }
    pub struct WinitData { /*... relevante Winit-Felder... */ }
    pub struct X11BackendData { /*... relevante X11-Backend-Felder... */ }
    
    // WindowElement (Beispiel, muss an NovaDE angepasst werden)
    #
    pub enum WindowElement {
        Wayland(Window), // Smithay's Window für XDG Toplevels
        X11(X11Surface), // Smithay's X11Surface
        Layer(LayerSurface), // Smithay's LayerSurface
    }
    // Implementiere notwendige Traits für WindowElement (z.B. RenderElement, SpaceElement)
    ```
    
    - Der Compositor ist das komplexeste Element der Systemschicht. Smithay 8 stellt Bausteine bereit, aber die eigentliche Fensterverwaltungslogik (Tiling, Stacking, Fokusrichtlinien basierend auf Domänenregeln) muss hier implementiert werden. Die `AnvilState` aus Smithays Anvil-Compositor dient als gute Referenz für die Strukturierung von `NovaDeSystemState` und die Integration verschiedener Smithay-Handler.

#### 3.1.2. Initialisierung (`system::compositor::initialize_compositor`)

- **Datei:** `system/src/compositor/init.rs`
- **Signatur:** `pub async fn initialize_compositor(domain_services: Arc<DomainLayerServices>, event_loop_handle: LoopHandle<'static, NovaDeSystemState>, loop_signal: LoopSignal) -> Result<NovaDeSystemState, SystemError>`
- **Schritte:**
    1. Erstelle `DisplayHandle` aus dem globalen `Display` Objekt (Annahme: `Display` wird im `main` erstellt und `DisplayHandle` wird hierher übergeben oder `NovaDeSystemState` wird direkt im `main` erstellt).
    2. Initialisiere Smithay-Backends (z.B. `LibinputInputBackend` 23, `UdevBackend` 37, DRM/GBM/EGL 16). Die Wahl des Backends (DRM/libseat für Bare-Metal, Winit/X11 für verschachtelte Entwicklung) ist eine wichtige architektonische Entscheidung. Die Implementierung sollte dies abstrahieren.
    3. Initialisiere alle relevanten Wayland-Globale unter Verwendung ihrer

# **UI-Schicht: Ultra-Feinspezifikation und Implementierungsleitfaden**

## **Modul: ui::shell::PanelWidget (Haupt-Panel-Implementierung)**

### **1. Modul-Identifikation und Zweck**

- **Modul-ID:** `ui::shell::PanelWidget`
- **Abhängigkeiten:**
    - `novade-core` (insbesondere `core::types` für geometrische Primitive und Farben, `core::errors` als Basis)
    - `novade-domain` (insbesondere `domain::theming` für Design-Tokens, `domain::global_settings_and_state_management` für Konfigurationen)
    - `gtk4-rs` (GTK4 Rust Bindings)
    - `gtk4-layer-shell` (für Wayland Layer Shell Integration)
    - `cairo-rs` (für benutzerdefiniertes Zeichnen, falls CSS nicht ausreicht)
    - `zbus` (für D-Bus-Kommunikation, falls das Panel direkt mit Systemdiensten interagiert, was aber eher von Submodulen gehandhabt wird)
    - `once_cell` (für statische Initialisierungen)
    - `thiserror` (für Fehlerdefinitionen innerhalb dieses Moduls, falls spezifisch)
    - `tracing` (für Logging)
- **Zweck:** Das `PanelWidget` ist die zentrale Komponente der `ui::shell`, die als primäre(s) Kontroll- und Systemleiste(n) der NovaDE dient. Es ist verantwortlich für die Bereitstellung einer oder mehrerer horizontaler Leisten am Bildschirmrand, die Aufnahme, Anordnung und Verwaltung verschiedener modularer Panel-Elemente (Submodule), die Implementierung grundlegender Panel-Eigenschaften (Höhe, Transparenz, visueller "Leuchtakzent") und die korrekte Integration in Wayland-Compositors mittels des `gtk4-layer-shell`-Protokolls.

### **2. Visuelles Design und Theming (Spezifikation für Manus AI)**

- **Positionierung:**
    - Kann am oberen (`Top`) oder unteren (`Bottom`) Bildschirmrand verankert werden.
    - Die Positionierung wird durch die Eigenschaft `position` (Typ: `PanelPosition`, siehe unten) gesteuert.
    - Standardwert: `PanelPosition::Top`.
- **Abmessungen:**
    - **Höhe (`panel-height`):** Konfigurierbare Höhe in Pixeln.
        - Datentyp: `i32`.
        - Gültiger Bereich: Minimum 24px, Maximum 128px.
        - Standardwert: 36px.
        - Die Höhe wird über die GObject-Eigenschaft `panel-height` gesetzt und beeinflusst die `default-height` des zugrundeliegenden `gtk::ApplicationWindow` sowie die `height-request` der internen `main_box`.
    - **Breite:** Das Panel erstreckt sich standardmäßig über die gesamte Breite des zugewiesenen Monitors/Outputs. Dies wird durch die Ankerung über `gtk4-layer-shell` erreicht (`Edge::Left` und `Edge::Right` auf `true` setzen).
- **Erscheinungsbild:**
    - **Hintergrund:**
        - Farbe und Stil werden primär über CSS gesteuert.
        - Das Panel kann optional einen transluzenten Hintergrund haben.
        - Die Eigenschaft `transparency-enabled` (Typ: `bool`, Standard: `false`) steuert dies.
        - Implementierung der Transparenz:
            1. Das GDK Visual des `PanelWidget` (als `gtk::Window`) muss auf ein RGBA-Visual gesetzt werden, falls Transparenz aktiviert ist: `self.set_visual(self.display().rgba_visual().as_ref())`.
            2. Der CSS-Hintergrund muss eine RGBA-Farbe verwenden (z.B. `background-color: rgba(0, 0, 0, 0.5);`).
            3. Für Wayland-Compositors, die transparente Oberflächen unterstützen, muss die `gtk4-layer-shell`-Integration sicherstellen, dass der Compositor die Transparenz korrekt handhabt. Das Setzen von `surface.set_opaque_region(None)` kann notwendig sein.
    - **"Leuchtakzent"-Effekt:**
        - Ein subtiler Leuchteffekt entlang einer Kante des Panels (typischerweise die dem Bildschirmzentrum zugewandte Kante).
        - Gesteuert durch Eigenschaften:
            - `leuchtakzent-color` (Typ: `Option<gdk::RGBA>`, Standard: `None`). Farbe des Akzents.
            - `leuchtakzent-intensity` (Typ: `f64`, Bereich: 0.0 bis 1.0, Standard: 0.5). Intensität/Opazität des Akzents.
        - **Implementierung (priorisierte Reihenfolge):**
            1. **CSS `box-shadow`:** Versuche, den Effekt mit CSS `box-shadow` zu erzielen (z.B. `box-shadow: 0px 2px 5px 0px var(--leuchtakzent-color);` angepasst für die Kante). Die Farbe `--leuchtakzent-color` wird dynamisch über einen `CssProvider` basierend auf `leuchtakzent-color` und `leuchtakzent-intensity` gesetzt.
            2. **Benutzerdefiniertes Zeichnen (Cairo auf `gtk::DrawingArea`):** Falls CSS nicht ausreicht oder Performance-Probleme verursacht:
                - Eine `gtk::DrawingArea` wird als unterste Ebene im `PanelWidget` platziert (oder das `PanelWidget` zeichnet seinen Hintergrund selbst, was komplexer ist).
                - Im `draw`-Signal-Handler der `DrawingArea`:
                    - Hintergrund des Panels zeichnen (unter Berücksichtigung von `transparency-enabled`).
                    - Den Leuchtakzent-Pfad definieren (Linie oder schmales Rechteck entlang der relevanten Kante).
                    - Akzentfarbe und -intensität aus den GObject-Eigenschaften abrufen.
                    - `cr.set_source_rgba()` mit der `leuchtakzent-color` (modifiziert durch `leuchtakzent-intensity` für die Alpha-Komponente) verwenden.
                    - Für einen weichen Effekt: `cairo::LinearGradient` verwenden, der von der Akzentfarbe zu einer transparenten Version derselben Farbe oder zur Hintergrundfarbe übergeht.
                    - `self.queue_draw()` aufrufen, wenn sich `leuchtakzent-color` oder `leuchtakzent-intensity` ändern.
- **CSS-Styling:**
    - **CSS-Knotenname:** Das `PanelWidget` (als `GtkApplicationWindow`) hat standardmäßig den CSS-Knoten `window`. Das interne Haupt-Layout-Widget (z.B. `main_box` vom Typ `gtk::Box`) hat den Knoten `box`.
    - Dem `PanelWidget` wird der CSS-Name "panelwidget" zugewiesen (`klass.set_css_name("panelwidget");`).
    - **CSS-Klassen (dynamisch und statisch):**
        - `.nova-panel` (statisch): Allgemeine Klasse für das Panel.
        - `.panel-top` / `.panel-bottom` (dynamisch): Je nach Wert der `position`-Eigenschaft.
        - `.transparent-panel` (dynamisch): Wenn `transparency-enabled` `true` ist.
        - Diese Klassen werden dem `PanelWidget` über `gtk::Widget::add_css_class()` / `gtk::Widget::remove_css_class()` zugewiesen, wenn sich die entsprechenden Eigenschaften ändern.
    - **CSS-Provider:** Die Anwendung von CSS erfolgt über einen globalen `gtk::CssProvider`, der durch ein übergeordnetes Theming-Modul (z.B. `ui::theming_gtk`) verwaltet wird. Das `PanelWidget` reagiert auf `ThemeChangedEvents` (siehe Abschnitt 2.6 Signale), um Stiländerungen zu übernehmen.

### **3. Datenstrukturen, Eigenschaften und Zustand (Spezifikation für Manus AI)**

Das `PanelWidget` wird als benutzerdefiniertes GObject-Widget implementiert, das von `gtk::ApplicationWindow` erbt.

#### **3.1. Datei: `src/ui/shell/panel_widget/mod.rs` (Öffentliche API)**

Rust

```
use gtk::glib;
use gtk::subclass::prelude::*;
use gtk::{gio, ApplicationWindow, Widget}; // Hinzugefügt für @extends und @implements
use std::cell::{Cell, RefCell}; // Für interne Veränderlichkeit in imp.rs benötigt, hier nicht direkt

mod imp; // Private Implementierung

glib::wrapper! {
    pub struct PanelWidget(ObjectSubclass<imp::PanelWidget>)
        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}

impl PanelWidget {
    pub fn new(app: &gtk::Application) -> Self {
        glib::Object::builder::<Self>()
            .property("application", app)
            .build()
    }

    // ### Öffentliche Methoden zur Modulverwaltung ###

    /// Fügt ein Widget-Modul dem Panel hinzu.
    ///
    /// # Parameter
    /// * `module`: Das Widget, das als Modul hinzugefügt werden soll.
    /// * `position`: Die Position im Panel (Start, Center, End).
    /// * `order`: Die Reihenfolge des Moduls innerhalb seiner Position (kleinere Werte zuerst).
    ///
    /// `noexcept` (nicht direkt in Rust, aber Methode soll nicht paniken)
    pub fn add_module(&self, module: &impl glib::IsA<gtk::Widget>, position: imp::ModulePosition, order: i32) {
        self.imp().add_module_ordered(module, position, order);
    }

    /// Entfernt ein zuvor hinzugefügtes Modul aus dem Panel.
    ///
    /// # Parameter
    /// * `module`: Das zu entfernende Widget-Modul.
    ///
    /// `noexcept`
    pub fn remove_module(&self, module: &impl glib::IsA<gtk::Widget>) {
        self.imp().remove_module_internal(module);
    }

    // ### Öffentliche Methoden für Eigenschaften (optional, wenn GObject Properties bevorzugt) ###
    // Beispiel, falls direkte Methodenaufrufe gewünscht sind, ansonsten über Properties

    pub fn set_panel_position(&self, position: imp::PanelPosition) {
        self.set_property("position", position.to_value());
    }

    pub fn get_panel_position(&self) -> imp::PanelPosition {
        self.property("position")
    }

    pub fn set_panel_height(&self, height: i32) {
        self.set_property("panel-height", height);
    }

    pub fn get_panel_height(&self) -> i32 {
        self.property("panel-height")
    }

    pub fn set_transparency_enabled(&self, enabled: bool) {
        self.set_property("transparency-enabled", enabled);
    }

    pub fn is_transparency_enabled(&self) -> bool {
        self.property("transparency-enabled")
    }
}

// Enum Definitionen müssen hier oder in einem gemeinsamen Typmodul sein,
// damit sie in der öffentlichen API verwendet werden können.
// Für dieses Beispiel werden sie im imp-Modul deklariert und hier re-exportiert,
// oder sie sind in einem ui::shell::panel_widget::types Modul.
// pub use imp::{PanelPosition, ModulePosition}; // Falls sie in imp definiert sind

```

#### **3.2. Datei: `src/ui/shell/panel_widget/imp.rs` (Private GObject-Implementierung)**

Rust

```
use gtk::glib::{self, Properties, ParamSpec, Value, subclass::Signal};
use gtk::subclass::prelude::*;
use gtk::{CompositeTemplate, Align, Orientation as GtkOrientation, Box as GtkBox, ApplicationWindow, Widget}; // Widget hinzugefügt
use gdk::RGBA; // Für leuchtakzent-color
use std::cell::{Cell, RefCell};
use std::collections::{BTreeMap, HashMap}; // BTreeMap für geordnete Module
use once_cell::sync::Lazy;

// ### Enums für Panel-Konfiguration ###

#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, glib::Enum)]
#[enum_type(name = "NovaDEPanelPosition")]
pub enum PanelPosition {
    #[default]
    Top,
    Bottom,
}

// Benötigt `glib:: القيمه` für Properties
impl From<PanelPosition> for Value {
    fn from(position: PanelPosition) -> Self {
        position.to_value()
    }
}
impl From<Value> for PanelPosition {
    fn from(value: Value) -> Self {
        glib::EnumClass::new(PanelPosition::static_type())
            .expect("PanelPosition EnumClass not found")
            .value(value.get_enum().expect("Value is not an enum"))
            .expect("Invalid PanelPosition enum value")
            .downcast::<PanelPosition>()
            .expect("Failed to downcast to PanelPosition")
            .get()
    }
}


#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, glib::Enum)]
#[enum_type(name = "NovaDEModulePosition")]
pub enum ModulePosition {
    #[default]
    Start,
    Center,
    End,
}

// Hilfsstruktur für geordnete Module
#[derive(Debug, Clone)]
struct OrderedModule {
    widget: Widget,
    order: i32,
}

// ### GObject Properties Definition ###
static PANEL_PROPERTIES: Lazy<Vec<ParamSpec>> = Lazy::new(|| {
    vec![
        ParamSpec::new_enum(
            "position",
            "Position",
            "Bildschirmkante, an der das Panel verankert ist (Oben, Unten).",
            PanelPosition::static_type(),
            PanelPosition::default() as i32, // Standardwert
            glib::ParamFlags::READWRITE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_int(
            "panel-height",
            "Panel Height",
            "Höhe des Panels in Pixeln (Min: 24, Max: 128).",
            24, // Min
            128, // Max
            36, // Standardwert
            glib::ParamFlags::READWRITE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_boolean(
            "transparency-enabled",
            "Transparency Enabled",
            "Gibt an, ob Transparenzeffekte für das Panel aktiv sind.",
            false, // Standardwert
            glib::ParamFlags::READWRITE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_boxed(
            "leuchtakzent-color",
            "Leuchtakzent Color",
            "Farbe des Leuchtakzents (gdk::RGBA). Wird typischerweise vom Theming-System aktualisiert.",
            RGBA::static_type(), // Typ gdk::RGBA
            glib::ParamFlags::READWRITE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_double(
            "leuchtakzent-intensity",
            "Leuchtakzent Intensity",
            "Intensität/Opazität des Leuchtakzents (Bereich: 0.0 bis 1.0).",
            0.0, // Min
            1.0, // Max
            0.5, // Standardwert
            glib::ParamFlags::READWRITE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
    ]
});

// ### GObject Signale Definition ###
static PANEL_SIGNALS: Lazy<HashMap<String, Signal>> = Lazy::new(|| {
    let mut signals = HashMap::new();
    signals.insert(
        "module-layout-changed".to_string(),
        Signal::builder("module-layout-changed")
            .action() // Kein Rückgabewert, keine Parameter für dieses Signal
            .build(),
    );
    signals
});


#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/nova_de/ui/shell/panel_widget.ui")] // Pfad zur UI-Datei
pub struct PanelWidget {
    #[template_child]
    pub main_box: TemplateChild<GtkBox>,
    #[template_child]
    pub start_box: TemplateChild<GtkBox>,
    #[template_child]
    pub center_box: TemplateChild<GtkBox>,
    #[template_child]
    pub end_box: TemplateChild<GtkBox>,

    // GObject Properties (als Felder in der Imp-Struktur)
    #[property(get, set, explicit_notify)]
    position: RefCell<PanelPosition>,
    #[property(get, set, explicit_notify)]
    panel_height: Cell<i32>,
    #[property(get, set, explicit_notify)]
    transparency_enabled: Cell<bool>,
    #[property(get, set, explicit_notify)]
    leuchtakzent_color: RefCell<Option<RGBA>>,
    #[property(get, set, explicit_notify)]
    leuchtakzent_intensity: Cell<f64>,

    // Interner Zustand für Modulverwaltung
    // Verwendet BTreeMap, um Module nach `order` und dann nach Einfügezeit (als Fallback für gleiche Order)
    // sortiert zu halten. Der innere Vec ist für den Fall, dass mehrere Widgets exakt dieselbe Order haben.
    modules_start: RefCell<BTreeMap<i32, Vec<Widget>>>,
    modules_center: RefCell<BTreeMap<i32, Vec<Widget>>>,
    modules_end: RefCell<BTreeMap<i32, Vec<Widget>>>,

    // Für benutzerdefiniertes Zeichnen des Leuchtakzents, falls CSS nicht ausreicht.
    // Wird im `constructed` initialisiert, falls benötigt.
    drawing_area_for_accent: RefCell<Option<gtk::DrawingArea>>,
}

#[glib::object_subclass]
impl ObjectSubclass for PanelWidget {
    const NAME: &'static str = "NovaDEPanelWidget";
    type Type = super::PanelWidget; // Der öffentliche Wrapper-Typ
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &mut Self::Class) {
        klass.bind_template();
        klass.install_properties(&PANEL_PROPERTIES);
        klass.install_signals(&PANEL_SIGNALS);
        klass.set_css_name("panelwidget"); // CSS-Name für das Widget
    }

    fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
        obj.init_template();
    }
}

#[glib::derived_properties]
impl ObjectImpl for PanelWidget {
    fn constructed(&self) {
        self.parent_constructed();
        let obj = self.obj(); // Der öffentliche Wrapper `super::PanelWidget`

        // Standardwerte für Properties setzen, falls nicht explizit beim Bauen angegeben
        // Diese Werte werden von den ParamSpec Defaults überschrieben, falls `glib::Object::builder()` verwendet wird.
        // Wenn direkt `PanelWidget::new()` aufgerufen wird, sind die Zell-Defaults (z.B. 0 für i32) aktiv.
        // Die ParamSpec Defaults sollten hier bevorzugt werden.
        // Die Initialisierung der RefCell/Cell-Felder mit den Property-Standardwerten erfolgt
        // implizit durch das GObject-Property-System, wenn das Objekt gebaut wird.
        // Manuelle Defaults hier sind nur nötig, wenn kein Property-System genutzt würde.

        // gtk4-layer-shell initialisieren
        obj.setup_layer_shell_internal();
        obj.update_module_layout_internal(); // Erstes Layout anwenden

        // CSS-Klassen basierend auf initialen Properties setzen
        self.update_css_classes();

        // Eventuell DrawingArea für Leuchtakzent initialisieren und verbinden, falls nötig
        // self.setup_drawing_area_for_accent();
    }

    // Implementierung der Properties Getters und Setters (automatisch durch #[property] und #[glib::derived_properties])
    // Die Logik für Property-Änderungen (z.B. LayerShell neu konfigurieren) kommt in die `set_property` Methode.

    fn set_property(&self, _id: usize, value: &Value, pspec: &ParamSpec) {
        match pspec.name() {
            "position" => {
                let new_position = value.get::<PanelPosition>().expect("Value must be PanelPosition");
                self.position.replace(new_position);
                self.obj().setup_layer_shell_internal(); // Layer Shell neu konfigurieren
                self.update_css_classes();
                self.obj().notify_position(); // Benachrichtigung für diese Eigenschaft
            }
            "panel-height" => {
                let new_height = value.get::<i32>().expect("Value must be i32");
                // Validierung gegen Min/Max aus ParamSpec (automatisch durch GObject, aber man könnte hier zusätzlich prüfen)
                self.panel_height.set(new_height);
                self.obj().set_default_height(new_height); // Fensterhöhe anpassen
                self.main_box.set_height_request(new_height);
                // Ggf. DrawingArea Höhe anpassen
                self.obj().queue_draw(); // Neuzeichnen anfordern
                self.obj().notify_panel_height();
            }
            "transparency-enabled" => {
                let enabled = value.get::<bool>().expect("Value must be bool");
                self.transparency_enabled.set(enabled);
                self.update_transparency_visual_internal();
                self.update_css_classes();
                self.obj().notify_transparency_enabled();
            }
            "leuchtakzent-color" => {
                // Option<RGBA> muss vorsichtig gehandhabt werden
                let color_opt = value.get::<Option<RGBA>>().expect("Value must be Option<RGBA> or None");
                self.leuchtakzent_color.replace(color_opt);
                self.obj().queue_draw(); // Neuzeichnen für Akzent
                self.obj().notify_leuchtakzent_color();
            }
            "leuchtakzent-intensity" => {
                let intensity = value.get::<f64>().expect("Value must be f64");
                self.leuchtakzent_intensity.set(intensity.clamp(0.0, 1.0)); // Sicherstellen, dass im Bereich
                self.obj().queue_draw();
                self.obj().notify_leuchtakzent_intensity();
            }
            _ => unimplemented!(),
        }
    }
}

impl WidgetImpl for PanelWidget {
    fn map(&self) {
        self.parent_map();
        // Sicherstellen, dass Layer Shell korrekt initialisiert ist, bevor das Fenster angezeigt wird
        self.obj().setup_layer_shell_internal();
    }

    fn size_allocate(&self, width: i32, height: i32, baseline: i32) {
        self.parent_size_allocate(width, height, baseline);
        // Ggf. Layout der internen Boxen hier anpassen oder DrawingArea Größe
        // Dies ist wichtig, wenn sich die Panel-Breite ändert (z.B. Multi-Monitor-Setup Wechsel)
    }

    // Falls benutzerdefiniertes Zeichnen für Akzent via DrawingArea:
    // fn snapshot(&self, snapshot: &gtk::Snapshot) {
    //     self.parent_snapshot(snapshot);
    //     // Hier könnte man den Akzent zeichnen, wenn er nicht Teil eines Kind-Widgets ist.
    // }
}

impl WindowImpl for PanelWidget {
    // Fenster-spezifische Implementierungen, z.B. Schließen-Verhalten
}

impl ApplicationWindowImpl for PanelWidget {}

// ### Interne Implementierungsmethoden für PanelWidget ###
impl PanelWidget {
    fn update_css_classes(&self) {
        let obj = self.obj();
        if *self.position.borrow() == PanelPosition::Top {
            obj.remove_css_class("panel-bottom");
            obj.add_css_class("panel-top");
        } else {
            obj.remove_css_class("panel-top");
            obj.add_css_class("panel-bottom");
        }

        if self.transparency_enabled.get() {
            obj.add_css_class("transparent-panel");
        } else {
            obj.remove_css_class("transparent-panel");
        }
    }

    fn update_transparency_visual_internal(&self) {
        let obj = self.obj();
        let visual = if self.transparency_enabled.get() {
            obj.display().rgba_visual()
        } else {
            // Zurück zum System-Standard-Visual (oder None, wenn das Fenster sowieso opak sein soll)
            obj.display().default_visual(&obj.surface().unwrap_or_else(|| obj.create_surface(obj.width(), obj.height(), None)))
        };
        obj.set_visual(visual.as_ref());
        obj.queue_draw(); // Neuzeichnen anfordern, da sich das Visual geändert hat
    }

    // Wird vom öffentlichen add_module aufgerufen
    pub(super) fn add_module_ordered(&self, module: &impl glib::IsA<gtk::Widget>, position: ModulePosition, order: i32) {
        let module_widget = module.clone().upcast::<Widget>();
        let modules_map = match position {
            ModulePosition::Start => &self.modules_start,
            ModulePosition::Center => &self.modules_center,
            ModulePosition::End => &self.modules_end,
        };

        let mut map_guard = modules_map.borrow_mut();
        map_guard.entry(order).or_default().push(module_widget);

        self.obj().update_module_layout_internal();
        self.obj().emit_by_name::<()>("module-layout-changed", &[]);
    }

    // Wird vom öffentlichen remove_module aufgerufen
    pub(super) fn remove_module_internal(&self, module_to_remove: &impl glib::IsA<gtk::Widget>) {
        let widget_ptr_to_remove = module_to_remove.as_ref().to_glib_none().0;
        let mut changed = false;

        for modules_map_refcell in [&self.modules_start, &self.modules_center, &self.modules_end] {
            let mut map_guard = modules_map_refcell.borrow_mut();
            for (_order, widgets_in_order) in map_guard.iter_mut() {
                let initial_len = widgets_in_order.len();
                widgets_in_order.retain(|m| m.to_glib_none().0 != widget_ptr_to_remove);
                if widgets_in_order.len() < initial_len {
                    changed = true;
                    break; // Modul gefunden und entfernt
                }
            }
            if changed { break; }
        }

        if changed {
            // Physisches Entfernen aus den GtkBox-Containern
            if let Some(parent_box) = module_to_remove.as_ref().parent().and_then(|p| p.downcast::<GtkBox>().ok()){
                parent_box.remove(module_to_remove.as_ref());
            }
            self.obj().update_module_layout_internal();
            self.obj().emit_by_name::<()>("module-layout-changed", &[]);
        }
    }
}

// ### Öffentliche Methoden, die von der `imp`-Struktur für den Wrapper bereitgestellt werden ###
// Diese sind jetzt im `PanelWidget`-Block in `mod.rs` implementiert oder werden
// durch GObject-Properties gehandhabt. Die `setup_layer_shell_internal` und
// `update_module_layout_internal` sind die Kernmethoden, die der Wrapper aufruft.
impl super::PanelWidget { // Bezieht sich auf den öffentlichen Wrapper
    fn setup_layer_shell_internal(&self) {
        let imp = self.imp();
        gtk_layer_shell::init_for_window(self);
        gtk_layer_shell::set_layer(self, gtk_layer_shell::Layer::Top);
        // Panels benötigen i.d.R. keinen direkten Fokus, außer ihre Kindelemente
        gtk_layer_shell::set_keyboard_mode(self, gtk_layer_shell::KeyboardMode::OnDemand); // Oder None, wenn Module Fokus explizit anfordern
        gtk_layer_shell::auto_exclusive_zone_enable(self); // Platz reservieren
        gtk_layer_shell::set_namespace(self, "NovaDEPanel");

        let position_val = *imp.position.borrow();
        match position_val {
            PanelPosition::Top => {
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Top, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Left, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Right, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Bottom, false);
            }
            PanelPosition::Bottom => {
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Bottom, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Left, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Right, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Top, false);
            }
        }
        self.set_default_height(imp.panel_height.get());
        // Margins könnten hier auch gesetzt werden, falls gewünscht, z.B. um das Panel leicht vom Rand abzusetzen
        // gtk_layer_shell::set_margin(self, gtk_layer_shell::Edge::Top, 5);
        // gtk_layer_shell::set_margin(self, gtk_layer_shell::Edge::Left, 5);
        // gtk_layer_shell::set_margin(self, gtk_layer_shell::Edge::Right, 5);
    }

    fn update_module_layout_internal(&self) {
        let imp = self.imp();

        // Helferfunktion zum Leeren und Befüllen einer Box
        let repopulate_box = |target_box: &GtkBox, modules_map_refcell: &RefCell<BTreeMap<i32, Vec<Widget>>>| {
            while let Some(child) = target_box.first_child() {
                target_box.remove(&child);
            }
            let map_guard = modules_map_refcell.borrow();
            for (_order, widgets_in_order) in map_guard.iter() { // BTreeMap iteriert über Schlüssel (order) sortiert
                for widget in widgets_in_order {
                    target_box.append(widget);
                }
            }
        };

        repopulate_box(&imp.start_box, &imp.modules_start);
        repopulate_box(&imp.center_box, &imp.modules_center);
        repopulate_box(&imp.end_box, &imp.modules_end);
    }
}
```

#### **3.3. UI-Definitionsdatei: `resources/ui/shell/panel_widget.ui`**

XML

```
<?xml version="1.0" encoding="UTF-8"?>
<interface>
  <requires lib="gtk" version="4.0"/>
  <template class="NovaDEPanelWidget" parent="GtkApplicationWindow">
    <property name="title" translatable="yes">NovaDE Panel</property>
    <property name="decorated">false</property>
    <child>
      <object class="GtkBox" id="main_box">
        <property name="orientation">horizontal</property>
        <property name="halign">fill</property>
        <property name="valign">fill</property> <property name="spacing">6</property> <style>
          <class name="nova-panel-main-box"/>
        </style>
        <child>
          <object class="GtkBox" id="start_box">
            <property name="orientation">horizontal</property>
            <property name="halign">start</property>
            <property name="valign">center</property>
            <property name="spacing">6</property> <style>
              <class name="nova-panel-start-box"/>
            </style>
            </object>
        </child>
        <child>
          <object class="GtkBox" id="center_box">
            <property name="orientation">horizontal</property>
            <property name="halign">center</property>
            <property name="valign">center</property>
            <property name="hexpand">true</property> <property name="spacing">6</property>
            <style>
              <class name="nova-panel-center-box"/>
            </style>
            </object>
        </child>
        <child>
          <object class="GtkBox" id="end_box">
            <property name="orientation">horizontal</property>
            <property name="halign">end</property>
            <property name="valign">center</property>
            <property name="spacing">6</property>
            <style>
              <class name="nova-panel-end-box"/>
            </style>
            </object>
        </child>
      </object>
    </child>
  </template>
</interface>
```

#### **3.4. GObject-Eigenschaften (Zusammenfassung)**

|Eigenschaftsname|Rust-Feld (Imp)|Typ (Rust / GLib)|Zugriff|Standardwert|Beschreibung|
|:--|:--|:--|:--|:--|:--|
|`application`|(Parent-Eigenschaft)|`gtk::Application`|R/W/C|N/A|Die `gtk::Application`, zu der das Fenster gehört.|
|`position`|`position`|`PanelPosition` / Enum|R/W|`Top`|Bildschirmkante für das Panel (Oben, Unten).|
|`panel-height`|`panel_height`|`i32` / GINT|R/W|36|Höhe des Panels in Pixeln (Min: 24, Max: 128).|
|`transparency-enabled`|`transparency_enabled`|`bool` / GBOOLEAN|R/W|`false`|Aktiviert/Deaktiviert Transparenzeffekte.|
|`leuchtakzent-color`|`leuchtakzent_color`|`Option<gdk::RGBA>` / GBoxed|R/W|`None`|Farbe des Leuchtakzents.|
|`leuchtakzent-intensity`|`leuchtakzent_intensity`|`f64` / GDOUBLE|R/W|0.5|Intensität des Leuchtakzents (0.0-1.0).|

In Google Sheets exportieren

_R=Read, W=Write, C=Construct-Only_

#### **3.5. Interner Zustand (Felder in `PanelWidgetImp`)**

- `main_box: TemplateChild<GtkBox>`: Hauptcontainer für die drei Modulbereiche.
- `start_box: TemplateChild<GtkBox>`: Container für Module am Anfang (links bei LTR-Layout).
- `center_box: TemplateChild<GtkBox>`: Container für Module in der Mitte. `hexpand = true`.
- `end_box: TemplateChild<GtkBox>`: Container für Module am Ende (rechts bei LTR-Layout).
- `position: RefCell<PanelPosition>`: Speichert die aktuelle Panel-Position.
- `panel_height: Cell<i32>`: Speichert die aktuelle Panel-Höhe.
- `transparency_enabled: Cell<bool>`: Speichert den Transparenzstatus.
- `leuchtakzent_color: RefCell<Option<RGBA>>`: Speichert die Akzentfarbe.
- `leuchtakzent_intensity: Cell<f64>`: Speichert die Akzentintensität.
- `modules_start: RefCell<BTreeMap<i32, Vec<Widget>>>`: Geordnete Map von Modulen für den Startbereich. Schlüssel ist `order`.
- `modules_center: RefCell<BTreeMap<i32, Vec<Widget>>>`: Geordnete Map von Modulen für den Mittelbereich.
- `modules_end: RefCell<BTreeMap<i32, Vec<Widget>>>`: Geordnete Map von Modulen für den Endbereich.
- `drawing_area_for_accent: RefCell<Option<gtk::DrawingArea>>`: (Optional) Für benutzerdefiniertes Zeichnen des Akzents.

### **4. GTK-Widget-Implementierungsstrategie (Spezifikation für Manus AI)**

- **Basis-Widget:** Das `PanelWidget` erbt von `gtk::ApplicationWindow`. Diese Wahl ist entscheidend für die Integration mit `gtk4-layer-shell`, da dessen Funktionen (`init_for_window`, `set_layer`, `set_anchor`, `auto_exclusive_zone_enable` etc.) auf einem `gtk::Window` operieren.
- **Initialisierung von `gtk4-layer-shell`:**
    - `gtk_layer_shell::init_for_window(self_wrapper)`: Muss im `constructed`-Handler oder vor dem ersten `map`-Ereignis des Fensters aufgerufen werden.
    - `gtk_layer_shell::set_layer(self_wrapper, gtk_layer_shell::Layer::Top)`: Positioniert das Panel über normalen Anwendungsfenstern.
    - `gtk_layer_shell::set_keyboard_mode(self_wrapper, gtk_layer_shell::KeyboardMode::OnDemand)`: Erlaubt dem Panel oder seinen Kindern, Tastaturfokus zu erhalten, wenn sie ihn anfordern. `None` wäre auch eine Option, wenn Module den Fokus nicht benötigen oder ihn selbst über andere Mechanismen (wie Popovers) handhaben.
    - `gtk_layer_shell::auto_exclusive_zone_enable(self_wrapper)`: Sorgt dafür, dass das Panel Platz auf dem Bildschirm reserviert und andere maximierte Fenster nicht verdeckt.
    - `gtk_layer_shell::set_namespace(self_wrapper, "NovaDEPanel")`: Setzt einen eindeutigen Namespace für das Panel.
    - **Ankerpunkte (`set_anchor`):** Basierend auf der `position`-Eigenschaft werden die Anker gesetzt:
        - `PanelPosition::Top`: `Top=true, Left=true, Right=true, Bottom=false`.
        - `PanelPosition::Bottom`: `Bottom=true, Left=true, Right=true, Top=false`.
- **Internes Layout (Composite Template):**
    - Die interne Struktur des `PanelWidget` wird über eine UI-Datei (`panel_widget.ui`) definiert und als `CompositeTemplate` geladen.
    - **`main_box` (`GtkBox`, Orientation: Horizontal):** Dient als Hauptcontainer. Erstreckt sich über die gesamte Breite und Höhe des Panel-Fensters.
    - **`start_box` (`GtkBox`, Orientation: Horizontal):** Nimmt Module auf, die am Anfang (links) des Panels positioniert sind. `halign = GtkAlign::Start`.
    - **`center_box` (`GtkBox`, Orientation: Horizontal):** Nimmt Module auf, die in der Mitte des Panels positioniert sind. `halign = GtkAlign::Center`, `hexpand = true` (damit dieser Bereich den verfügbaren Platz ausfüllt).
    - **`end_box` (`GtkBox`, Orientation: Horizontal):** Nimmt Module auf, die am Ende (rechts) des Panels positioniert sind. `halign = GtkAlign::End`.
    - Alle drei Boxen (`start_box`, `center_box`, `end_box`) haben `valign = GtkAlign::Center`, um die Module vertikal zu zentrieren.
    - Ein Abstand (`spacing`) zwischen den Boxen und zwischen den Modulen innerhalb der Boxen kann in der `.ui`-Datei oder programmatisch gesetzt werden.
- **Benutzerdefiniertes Zeichnen:** Implementierung erfolgt wie unter Abschnitt 2 beschrieben, falls notwendig.

### **5. Methoden und Funktionssignaturen (Interne und Wrapper-Logik)**

#### **5.1. Interne Methoden (in `PanelWidgetImp`)**

- `fn update_css_classes(&self)`: Aktualisiert die CSS-Klassen des Wrapper-Widgets basierend auf den aktuellen Werten von `position` und `transparency_enabled`.
- `fn update_transparency_visual_internal(&self)`: Stellt das `GdkVisual` des Fensters um, um Transparenz zu aktivieren/deaktivieren.
- `pub(super) fn add_module_ordered(&self, module: &impl glib::IsA<gtk::Widget>, position: ModulePosition, order: i32)`:
    1. Fügt das `module` der entsprechenden internen `BTreeMap` (`modules_start`, `modules_center`, `modules_end`) unter dem Schlüssel `order` hinzu. Wenn bereits Module mit derselben `order` existieren, wird das neue Modul an die `Vec<Widget>` für diese `order` angehängt.
    2. Ruft `self.obj().update_module_layout_internal()` auf.
    3. Emittiert das `module-layout-changed`-Signal.
- `pub(super) fn remove_module_internal(&self, module_to_remove: &impl glib::IsA<gtk::Widget>)`:
    1. Durchsucht alle drei Modul-Maps (`modules_start`, `modules_center`, `modules_end`).
    2. Entfernt das `module_to_remove` (Vergleich über Widget-Zeiger oder eine eindeutige ID, falls Module IDs haben) aus der entsprechenden `BTreeMap` und der zugehörigen `Vec<Widget>`.
    3. Wenn das Modul entfernt wurde:
        - Entfernt das Widget physisch aus dem Eltern-`GtkBox`-Container (`start_box`, `center_box` oder `end_box`).
        - Ruft `self.obj().update_module_layout_internal()` auf.
        - Emittiert das `module-layout-changed`-Signal.

#### **5.2. Methoden des öffentlichen Wrappers (`super::PanelWidget`)**

- `fn setup_layer_shell_internal(&self)`: Führt die Konfiguration von `gtk4-layer-shell` durch, wie in Abschnitt 4 beschrieben. Wird bei der Initialisierung und bei Änderungen der `position`-Eigenschaft aufgerufen.
- `fn update_module_layout_internal(&self)`:
    1. Leert alle drei `GtkBox`-Container (`start_box`, `center_box`, `end_box`), indem alle existierenden Kinder entfernt werden.
    2. Iteriert über die sortierten Module in `imp.modules_start.borrow()` (BTreeMap iteriert Schlüssel sortiert). Für jede `order`, iteriere über die `Vec<Widget>` und füge jedes Widget der `imp.start_box` hinzu (`append`).
    3. Wiederholt Schritt 2 für `imp.modules_center` und `imp.center_box`.
    4. Wiederholt Schritt 2 für `imp.modules_end` und `imp.end_box`.

### **6. Signale (Spezifikation für Manus AI)**

#### **6.1. Emittierte Signale**

- **Signal: `module-layout-changed`**
    - **GObject Signal Name:** `module-layout-changed`
    - **Parameter:** Keine.
    - **Signal-Flags:** `glib::SignalFlags::ACTION` (oder `RUN_FIRST`/`RUN_LAST` je nach Bedarf).
    - **Beschreibung:** Wird emittiert, nachdem Module dem Panel hinzugefügt, daraus entfernt oder ihre Anordnung (durch `update_module_layout_internal`) geändert wurde.
    - **Zweck:** Ermöglicht anderen UI-Komponenten oder Logikmodulen, auf Änderungen im Panel-Layout zu reagieren, z.B. um Größen neu zu berechnen oder Fokus-Reihenfolgen anzupassen.
    - **Auslöser:** Aufruf von `add_module_ordered` oder `remove_module_internal` nach erfolgreicher Modifikation und Layout-Aktualisierung.

#### **6.2. Verbundene Signale (Reaktionen auf externe Events)**

- **Event:** `ThemeChangedEvent` (aus `domain::theming::ThemingEngine`)
    - **Handler-Aktion im `PanelWidget`:**
        1. Die neuen Design-Tokens aus dem `ThemeChangedEvent.new_state.resolved_tokens` extrahieren, die für das Panel relevant sind (insbesondere die Werte für `--leuchtakzent-color-rgba` und `--leuchtakzent-intensity-css`).
        2. Die GObject-Eigenschaften `leuchtakzent-color` und `leuchtakzent-intensity` des `PanelWidget` entsprechend aktualisieren (z.B. `self.set_leuchtakzent_color(Some(parsed_rgba_from_token))`).
        3. `self.queue_draw()` aufrufen, um ein Neuzeichnen des Panels (und des Akzents) zu erzwingen.
- **Signale von `gtk::Settings::default()`:**
    - `notify::gtk-theme-name`:
        - **Handler-Aktion:** Kann verwendet werden, um panel-spezifisches CSS neu zu laden oder Stile anzupassen, falls das Panel-Design stark vom System-GTK-Theme abhängt und nicht vollständig durch das NovaDE-Theming-System abgedeckt wird. Für NovaDE wird primär das eigene Theming-System verwendet, daher ist dies eher ein Fallback.
    - `notify::gtk-application-prefer-dark-theme`:
        - **Handler-Aktion:** Ähnlich wie bei `gtk-theme-name`. Wenn das NovaDE-Theming-System die Light/Dark-Modi nicht vollständig über `ThemeChangedEvent` steuert, kann hierauf reagiert werden, um z.B. CSS-Klassen für Dark Mode zu setzen/entfernen.

### **7. Ereignisbehandlung (Benutzerinteraktion)**

- Das `PanelWidget` selbst ist primär ein Container und reagiert nicht direkt auf komplexe Maus- oder Tastaturereignisse.
- Mausereignisse wie `enter-notify-event` und `leave-notify-event` könnten theoretisch für Tooltips auf dem Panel selbst verwendet werden, aber Tooltips sind eher für die einzelnen Module relevant.
- Der Tastaturfokus wird von den fokussierbaren Modulen innerhalb des Panels verwaltet, nicht vom Panel selbst.

### **8. Interaktionen mit anderen Komponenten/Modulen**

- **`domain::global_settings_and_state_management` (GlobalSettingsService):**
    - Das `PanelWidget` liest beim Start (oder bei Änderungen) seine Konfiguration (z.B. Standardposition, Standardhöhe, initiale Transparenz, welche Module standardmäßig geladen werden sollen) vom `GlobalSettingsService`.
    - Änderungen an diesen Einstellungen im `GlobalSettingsService` (z.B. durch `ui::control_center`) sollten ein `SettingChangedEvent` auslösen, auf das das `PanelWidget` reagiert, um seine GObject-Properties dynamisch anzupassen.
- **`system::compositor` (indirekt über `gtk4-layer-shell`):**
    - Die primäre Interaktion erfolgt über die `gtk4-layer-shell`-Bibliothek, um das Panel als Layer-Oberfläche im Wayland-Compositor zu positionieren und zu verwalten.
- **`domain::theming::ThemingEngine`:**
    - Das `PanelWidget` abonniert das `ThemeChangedEvent` der `ThemingEngine`, um Design-Tokens (insbesondere für `leuchtakzent-color` und Hintergrundstile) zu erhalten und anzuwenden.

### **9. Ausnahmebehandlung (Fehlerdefinitionen)**

Für das `PanelWidget`-Modul selbst werden spezifische Fehler mittels `thiserror` definiert, falls Operationen fehlschlagen können, die nicht durch GTK-interne Fehler abgedeckt sind.

- **Datei:** `src/ui/shell/panel_widget/error.rs`
    
- **Enum `PanelWidgetError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use gtk::glib; // Für glib::Error
    
    #[derive(Debug, Error)]
    pub enum PanelWidgetError {
        #[error("Fehler bei der Initialisierung der gtk-layer-shell: {0}")]
        LayerShellInitializationFailed(String), // Enthält Details des Fehlers
    
        #[error("Fehler beim Laden des UI-Templates für PanelWidget: {source}")]
        TemplateLoadError { #[from] source: glib::Error },
    
        #[error("Ungültige Modulposition angegeben: {position:?}")]
        InvalidModulePosition { position: super::imp::ModulePosition }, // super::imp verweist auf PanelWidgetImp
    
        #[error("Modul konnte nicht zum Panel hinzugefügt werden: {reason}")]
        ModuleAddFailed { reason: String },
    
        #[error("Modul konnte nicht vom Panel entfernt werden: {reason}")]
        ModuleRemoveFailed { reason: String },
    }
    ```
    
- **Verwendung:** Methoden wie `add_module_ordered` oder `remove_module_internal` könnten `Result<(), PanelWidgetError>` zurückgeben, obwohl in der GTK-Welt Fehler oft durch Signale oder Logging behandelt werden, anstatt Result-Typen in Widget-APIs zu verwenden. Für kritische Setup-Fehler ist `Result` jedoch angemessen. `gtk_layer_shell`-Funktionen geben keine direkten `Result`-Typen zurück, Fehler hier würden eher zu Panics oder visuellen Problemen führen; `LayerShellInitializationFailed` wäre also ein interner Fehler, der geloggt wird, falls die Initialisierung visuell fehlschlägt.
    

### **10. Auflösung "Untersuchungsbedarf" (aus dem Quelldokument)**

Der "Untersuchungsbedarf" bezüglich `gtk4-layer-shell`-Integration und Implementierung des "Leuchtakzents" wurde in den Abschnitten 2, 4 und 8 dieser Spezifikation adressiert.

- **Best Practices `gtk4-layer-shell`:** Initialisierung vor dem `map`-Ereignis, korrekte Wahl des `KeyboardMode`, Setzen eines Namespace, Ankerung für Positionierung und `auto_exclusive_zone_enable` sind spezifiziert. Multi-Monitor-Szenarien erfordern separate `PanelWidget`-Instanzen pro Monitor, die über Änderungen in der Monitorkonfiguration (`gdk::Display` Signale) verwaltet werden.
- **Implementierung "Leuchtakzent":** Präferenz für CSS `box-shadow`. Falls unzureichend, benutzerdefiniertes Zeichnen mit Cairo auf einer `gtk::DrawingArea` oder direkt im Panel-Fenster (unter Verwendung von `set_draw_func` für Widgets oder Snapshot-Funktion für komplexere Fälle). Details zur Verwendung von `gdk::RGBA`, `cairo::LinearGradient` und Transparenz sind spezifiziert.

### **11. Dateistruktur (Zusammenfassung)**

- `src/ui/shell/panel_widget/mod.rs` (Öffentliche API, GObject Wrapper)
- `src/ui/shell/panel_widget/imp.rs` (Private GObject Implementierung, Logik)
- `src/ui/shell/panel_widget/error.rs` (Spezifische Fehlerdefinitionen)
- `resources/ui/shell/panel_widget.ui` (XML-Definition für Composite Template)

Diese Struktur fördert Modularität und Trennung von Belangen.

**Nächster Schritt:** Detaillierte Spezifikation für `ui::shell::panel_widget::AppMenuButton`.

# **UI-Schicht: Ultra-Feinspezifikation und Implementierungsleitfaden**

## **Modul: ui::shell::panel_widget::AppMenuButton (Anwendungsmenü-Button)**

### **1. Modul-Identifikation und Zweck**

- **Modul-ID:** `ui::shell::panel_widget::AppMenuButton`
- **Übergeordnetes Modul:** `ui::shell::PanelWidget`
- **Abhängigkeiten:**
    - `novade-core`
    - `novade-domain` (potenziell für das Abrufen von Anwendungsmetadaten, falls nicht direkt über Systemschicht)
    - `novade-system` (insbesondere `system::compositor` für Informationen zum aktiven Fenster/AppID und `system::dbus` für die `org.gtk.Menus`-Schnittstelle)
    - `gtk4-rs` (GTK4 Rust Bindings)
    - `zbus` (für direkte D-Bus-Kommunikation, falls nicht vollständig von `novade-system` abstrahiert)
    - `once_cell`
    - `thiserror`
    - `tracing`
- **Zweck:** Das `AppMenuButton` ist ein spezialisiertes Panel-Modul, das als `gtk::MenuButton` (oder eine benutzerdefinierte Ableitung) implementiert wird. Seine Hauptverantwortung ist die Darstellung des globalen Anwendungsmenüs (typischerweise `GMenuModel`) der aktuell fokussierten Applikation. Es muss die aktive Anwendung identifizieren, deren Menümodell über D-Bus abrufen und dieses in einem `gtk::PopoverMenu` darstellen. Das Aussehen des Buttons (Icon, Name) wird dynamisch an die aktive Anwendung angepasst.

### **2. Visuelles Design und Theming (Spezifikation für Manus AI)**

- **Darstellung als Button:**
    - Standardmäßig wird das Icon der aktiven Anwendung angezeigt (`gtk::Image` im `gtk::MenuButton`).
    - **Fallback-Icon:** Wenn kein Anwendungsicon verfügbar ist oder keine Anwendung ein Menü bereitstellt, wird ein generisches "Anwendungsmenü"-Icon angezeigt (z.B. `application-menu-symbolic`).
    - **Beschriftung (Label):** Optional kann der Name der aktiven Anwendung (`gtk::Label`) neben dem Icon angezeigt werden. Dies ist konfigurierbar (z.B. über eine globale Einstellung) und hängt vom verfügbaren Platz im Panel ab. Standardmäßig wird nur das Icon angezeigt, um Platz zu sparen.
- **Tooltip:** Der Tooltip des `AppMenuButton` zeigt immer den Namen der aktiven Anwendung an, auch wenn dieser nicht als Label sichtbar ist (`gtk::Widget::set_tooltip_text()`).
- **PopoverMenu:** Beim Klick auf den Button wird ein `gtk::PopoverMenu` angezeigt, das die Menüeinträge des `GMenuModel` der aktiven Anwendung enthält. Das Styling dieses Popovers folgt dem globalen Theme.
- **Styling (CSS):**
    - **CSS-Knotenname:** `menubutton` (wenn von `gtk::MenuButton` geerbt) oder `button` (wenn eine benutzerdefinierte Schaltfläche mit manuellem Popover verwendet wird). Das Widget selbst bekommt den CSS-Namen `appmenubutton` (`klass.set_css_name("appmenubutton");`).
    - **CSS-Klassen (dynamisch):**
        - `.app-menu-button` (statisch): Allgemeine Klasse für spezifisches Styling.
        - `.active-app-menu` (dynamisch): Wird gesetzt, wenn ein Anwendungsmenü erfolgreich geladen und an den Button gebunden wurde.
        - `.no-app-menu` (dynamisch): Wird gesetzt, wenn kein Menü für die aktive Anwendung verfügbar ist, keine Anwendung fokussiert ist oder ein Fehler beim Laden des Menüs aufgetreten ist.
        - `.loading-app-menu` (dynamisch): Wird gesetzt, während das Menü aktiv geladen wird. Dies kann für ein visuelles Feedback (z.B. Spinner-ähnliche Zustandsänderung) genutzt werden.
- **Zustandsabhängiges Aussehen:**
    - **Kein Menü / Fehler:** Button könnte leicht ausgegraut oder mit einem speziellen Indikator versehen sein.
    - **Laden:** Ein subtiler Ladeindikator könnte angezeigt werden (z.B. pulsierendes Icon).

### **3. Datenstrukturen, Eigenschaften und Zustand (Spezifikation für Manus AI)**

Das `AppMenuButton` wird als benutzerdefiniertes GObject-Widget implementiert, das von `gtk::MenuButton` erbt.

#### **3.1. Datei: `src/ui/shell/panel_widget/app_menu_button/mod.rs` (Öffentliche API)**

Rust

```
use gtk::glib;
use gtk::subclass::prelude::*;
use gtk::{gio, MenuButton, Widget}; // Widget für IsA

mod imp;

glib::wrapper! {
    pub struct AppMenuButton(ObjectSubclass<imp::AppMenuButton>)
        @extends gtk::MenuButton, gtk::Button, gtk::Widget, // gtk::Button hinzugefügt
        @implements gtk::Accessible, gtk::Actionable, gtk::Buildable, gtk::ConstraintTarget;
}

impl AppMenuButton {
    pub fn new() -> Self {
        glib::Object::builder::<Self>().build()
    }

    /// Aktualisiert die Informationen über das aktive Fenster und löst ggf. eine Menüaktualisierung aus.
    /// Diese Methode wird typischerweise von einem übergeordneten Shell-Dienst aufgerufen,
    /// der Änderungen des Fensterfokus überwacht.
    ///
    /// # Parameter
    /// * `app_id`: Optionale ID der aktiven Anwendung (z.B. "org.gnome.TextEditor").
    /// * `app_name`: Optionaler Anzeigename der aktiven Anwendung.
    /// * `icon_name`: Optionaler Icon-Name der aktiven Anwendung.
    ///
    /// `noexcept`
    pub fn update_active_window_info(&self, app_id: Option<String>, app_name: Option<String>, icon_name: Option<String>) {
        self.imp().update_active_window_info_internal(app_id, app_name, icon_name);
    }

    // Methode, um das Menü explizit neu zu laden (z.B. bei manueller Aktion oder Fehlerwiederholung)
    pub fn refresh_menu(&self) {
        self.imp().trigger_menu_update_for_current_app_internal();
    }
}

impl Default for AppMenuButton {
    fn default() -> Self {
        Self::new()
    }
}
```

#### **3.2. Datei: `src/ui/shell/panel_widget/app_menu_button/imp.rs` (Private GObject-Implementierung)**

Rust

```
use gtk::glib::{self, Properties, ParamSpec, Value, subclass::Signal, Bytes};
use gtk::subclass::prelude::*;
use gtk::{gio, MenuButton, Button, Widget, Image, Label, Box as GtkBox, Orientation, PopoverMenu, Align};
use std::cell::{Cell, RefCell};
use std::sync::Arc; // Für zbus Connection
use once_cell::sync::Lazy;
use zbus::Connection; // Für D-Bus Kommunikation
use tracing;

use crate::ui::shell::panel_widget::app_menu_button::error::AppMenuButtonError; // Error-Typ

// ### Enums für internen Zustand ###
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
pub enum MenuFetchStatus {
    #[default]
    Idle, // Noch kein Versuch unternommen oder zurückgesetzt
    Loading, // Menü wird gerade über D-Bus geladen
    Success, // Menü erfolgreich geladen
    NoMenuAvailable, // Anwendung hat kein Menü oder D-Bus-Dienst nicht gefunden
    Error(AppMenuButtonError), // Ein spezifischer Fehler ist aufgetreten
}

// Notwendig für Speicherung in GObject Property, falls der Status als Property verfügbar gemacht wird
// impl ToValue for MenuFetchStatus { ... }
// impl FromValue for MenuFetchStatus { ... }

// ### GObject Properties Definition ###
static APP_MENU_BUTTON_PROPERTIES: Lazy<Vec<ParamSpec>> = Lazy::new(|| {
    vec![
        ParamSpec::new_string(
            "active-app-name",
            "Active Application Name",
            "Name der Anwendung, deren Menü angezeigt wird oder angezielt ist.",
            None, // Kein Default-Wert, da dynamisch
            glib::ParamFlags::READABLE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_string(
            "active-app-icon-name",
            "Active Application Icon Name",
            "Icon-Name der Anwendung, deren Menü angezielt ist.",
            None,
            glib::ParamFlags::READABLE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_boolean(
            "has-menu",
            "Has Menu",
            "true, wenn ein Menü für die aktive Anwendung verfügbar und geladen ist.",
            false, // Default
            glib::ParamFlags::READABLE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        // Potenziell eine Property für MenuFetchStatus, aber String oder Int Enum wäre einfacher für GObject
    ]
});

#[derive(Default)]
pub struct AppMenuButton {
    // UI-Elemente (falls nicht über CompositeTemplate)
    // Stattdessen als Teil des MenuButton-Parents oder im Popover
    button_content_box: RefCell<Option<GtkBox>>, // Box für Icon und Label
    app_icon_widget: RefCell<Option<Image>>,
    app_name_widget: RefCell<Option<Label>>,
    popover_menu: RefCell<Option<PopoverMenu>>,

    // GObject Properties
    #[property(get, explicit_notify)]
    active_app_name: RefCell<Option<String>>,
    #[property(get, explicit_notify)]
    active_app_icon_name: RefCell<Option<String>>,
    #[property(get, explicit_notify)]
    has_menu: Cell<bool>,

    // Interner Zustand
    active_app_id_internal: RefCell<Option<String>>, // Unterscheidung zum Property für interne Nutzung
    menu_fetch_status_internal: RefCell<MenuFetchStatus>,
    current_menu_model_internal: RefCell<Option<gio::MenuModel>>,
    dbus_connection: RefCell<Option<Arc<Connection>>>, // Arc für Teilen mit async Tasks

    // Service-Abhängigkeit (von ui::shell oder Systemschicht)
    // Annahme: Ein Dienst liefert aktive Fensterinformationen und D-Bus-Verbindung
    // active_window_monitor: RefCell<Option<Arc<dyn ActiveWindowMonitoringService>>>,
    // Wird hier vereinfacht durch direkte D-Bus-Nutzung und Aufruf von update_active_window_info
}

#[glib::object_subclass]
impl ObjectSubclass for AppMenuButton {
    const NAME: &'static str = "NovaDEAppMenuButton";
    type Type = super::AppMenuButton; // Der öffentliche Wrapper
    type ParentType = gtk::MenuButton;

    fn class_init(klass: &mut Self::Class) {
        klass.install_properties(&APP_MENU_BUTTON_PROPERTIES);
        klass.set_css_name("appmenubutton");
    }
}

#[glib::derived_properties]
impl ObjectImpl for AppMenuButton {
    fn constructed(&self) {
        self.parent_constructed();
        let obj = self.obj(); // Der öffentliche Wrapper `super::AppMenuButton`

        // Standard-Icon und Popover setzen
        let icon = Image::from_icon_name("application-menu-symbolic");
        let label = Label::new(None);
        label.set_visible(false); // Standardmäßig kein Label
        let content_box = GtkBox::new(GtkOrientation::Horizontal, 6);
        content_box.append(&icon);
        content_box.append(&label);
        obj.set_child(Some(&content_box));

        self.button_content_box.replace(Some(content_box));
        self.app_icon_widget.replace(Some(icon));
        self.app_name_widget.replace(Some(label));

        let popover = PopoverMenu::new_from_model(None::<&gio::MenuModel>); // Initial leer
        obj.set_popover(Some(&popover));
        self.popover_menu.replace(Some(popover));

        // Initialisiere D-Bus Verbindung asynchron
        let widget_clone = obj.clone();
        glib::MainContext::default().spawn_local(async move {
            match Connection::session().await {
                Ok(conn) => {
                    widget_clone.imp().dbus_connection.replace(Some(Arc::new(conn)));
                    tracing::info!("AppMenuButton: D-Bus Session-Verbindung hergestellt.");
                    // Initiales Update versuchen, falls schon eine App fokussiert ist (Info müsste von außen kommen)
                }
                Err(e) => {
                    tracing::error!("AppMenuButton: Fehler beim Verbinden zum D-Bus Session-Bus: {}", e);
                    widget_clone.imp().menu_fetch_status_internal.replace(MenuFetchStatus::Error(AppMenuButtonError::DBusConnectionError(e.to_string())));
                    widget_clone.imp().update_button_appearance_and_state_internal();
                }
            }
        });
        self.update_button_appearance_and_state_internal(); // Initiales Aussehen setzen
    }
}

impl WidgetImpl for AppMenuButton {}
impl ButtonImpl for AppMenuButton {} // Notwendig, da gtk::MenuButton von gtk::Button erbt
impl MenuButtonImpl for AppMenuButton {}

// ### Interne Implementierungsmethoden für AppMenuButtonImp ###
impl AppMenuButton {
    pub(super) fn update_active_window_info_internal(&self, app_id: Option<String>, app_name: Option<String>, icon_name: Option<String>) {
        tracing::debug!("AppMenuButton: update_active_window_info: app_id={:?}, name={:?}, icon={:?}", app_id, app_name, icon_name);
        let current_app_id = self.active_app_id_internal.borrow().clone();

        // Nur neu laden, wenn sich die app_id geändert hat oder vorher None war
        let needs_menu_update = current_app_id != app_id || (current_app_id.is_none() && app_id.is_some());

        self.active_app_id_internal.replace(app_id.clone());
        // Die Properties direkt über den Wrapper setzen, um Notify auszulösen
        self.obj().set_property("active-app-name", app_name.to_value());
        self.obj().set_property("active-app-icon-name", icon_name.to_value());
        // self.active_app_name.replace(app_name); // Direktes Setzen ohne Notify
        // self.active_app_icon_name.replace(icon_name); // Direktes Setzen ohne Notify

        if needs_menu_update {
            if app_id.is_some() {
                self.trigger_menu_update_for_current_app_internal();
            } else {
                // Keine aktive App, Menü zurücksetzen
                self.current_menu_model_internal.replace(None);
                self.obj().set_menu_model(None::<&gio::MenuModel>);
                self.menu_fetch_status_internal.replace(MenuFetchStatus::Idle);
                self.obj().set_property("has-menu", false);
            }
        }
        self.update_button_appearance_and_state_internal();
    }

    pub(super) fn trigger_menu_update_for_current_app_internal(&self) {
        let app_id_opt = self.active_app_id_internal.borrow().clone();
        let dbus_conn_opt = self.dbus_connection.borrow().clone();

        if let (Some(app_id), Some(dbus_conn)) = (app_id_opt, dbus_conn_opt) {
            if app_id.is_empty() {
                tracing::warn!("AppMenuButton: Leere AppID erhalten, Menü-Update übersprungen.");
                self.menu_fetch_status_internal.replace(MenuFetchStatus::Error(AppMenuButtonError::MenuNotFound("Leere AppID".to_string())));
                self.update_button_appearance_and_state_internal();
                return;
            }

            tracing::info!("AppMenuButton: Starte Menü-Update für AppID: {}", app_id);
            self.menu_fetch_status_internal.replace(MenuFetchStatus::Loading);
            self.update_button_appearance_and_state_internal(); // Ladezustand anzeigen

            let widget_clone = self.obj().clone(); // Klon des Wrappers
            glib::MainContext::default().spawn_local(async move {
                let result = Self::fetch_menu_for_app_async(dbus_conn, app_id.clone()).await;
                widget_clone.imp().handle_menu_fetch_result_internal(result, &app_id);
            });
        } else {
            tracing::debug!("AppMenuButton: Keine AppID oder D-Bus-Verbindung für Menü-Update vorhanden.");
            self.menu_fetch_status_internal.replace(MenuFetchStatus::Idle);
            if app_id_opt.is_none() { // Explizit kein Menü, wenn keine AppID
                 self.obj().set_menu_model(None::<&gio::MenuModel>);
                 self.obj().set_property("has-menu", false);
            }
            self.update_button_appearance_and_state_internal();
        }
    }

    async fn fetch_menu_for_app_async(dbus_conn: Arc<Connection>, app_id: String) -> Result<gio::MenuModel, AppMenuButtonError> {
        // Primärer Mechanismus: org.gtk.Menus auf dem Bus-Namen der Anwendung
        // Standardpfade sind /org/gtk/menus/menubar oder /org/gtk/menus/appmenu
        // oder ein von GApplication festgelegter Pfad.
        // Hier wird versucht, gängige Pfade zu prüfen.
        let common_paths = [
            "/org/gtk/menus/menubar",
            "/org/gtk/menus/appmenu",
            &format!("/{}", app_id.replace('.', "/")), // z.B. /org/gnome/TextEditor
            "/", // Manchmal exportieren Apps Menüs direkt am Root-Pfad ihres Bus-Namens
        ];

        for path_str in common_paths.iter() {
            // Zuerst versuchen, direkt ein DBusMenuModel zu erstellen,
            // was die org.gtk.Menus Schnittstelle verwendet.
            match gio::DBusMenuModel::new(&dbus_conn, Some(app_id.as_str()), path_str) {
                Ok(menu_model) => {
                    // Prüfen, ob das Menü tatsächlich Items hat, da ein leeres Modell nicht nützlich ist.
                    // DBusMenuModel ist ein Live-Objekt, Änderungen werden reflektiert.
                    // Ein einfacher Check hier ist schwierig, da n_items() nicht direkt auf MenuModel existiert.
                    // Wir vertrauen darauf, dass ein erfolgreich erstelltes Modell gültig ist.
                    tracing::info!("AppMenuButton: GMenuModel für '{}' an Pfad '{}' erfolgreich via org.gtk.Menus bezogen.", app_id, path_str);
                    return Ok(menu_model.upcast::<gio::MenuModel>());
                }
                Err(e) => {
                    tracing::debug!("AppMenuButton: Kein GMenuModel für '{}' an Pfad '{}' via org.gtk.Menus gefunden: {}", app_id, path_str, e);
                }
            }
        }
        
        // Fallback: com.canonical.AppMenu.Registrar (veraltet und X11-lastig, hier nur als Referenz)
        // Für eine reine Wayland-Umgebung ist dies weniger relevant, es sei denn, XWayland-Apps nutzen es.
        // Diese Logik wird hier nicht vollständig implementiert, da sie komplex ist und oft nicht funktioniert.
        // tracing::warn!("AppMenuButton: Fallback zu com.canonical.AppMenu.Registrar nicht implementiert.");

        tracing::warn!("AppMenuButton: Kein Menü für AppID '{}' auf bekannten Pfaden gefunden.", app_id);
        Err(AppMenuButtonError::MenuNotFound(app_id))
    }

    fn handle_menu_fetch_result_internal(&self, result: Result<gio::MenuModel, AppMenuButtonError>, app_id_for_result: &str) {
        // Sicherstellen, dass das Ergebnis noch für die aktuell aktive App relevant ist.
        // Wenn der Benutzer schnell die App gewechselt hat, könnte dieses Ergebnis veraltet sein.
        let current_app_id = self.active_app_id_internal.borrow();
        if current_app_id.as_deref() != Some(app_id_for_result) {
            tracing::info!("AppMenuButton: Menü-Ergebnis für '{}' ist veraltet, aktuelle App ist '{:?}'. Ignoriere.", app_id_for_result, current_app_id);
            // Status nicht ändern, da ein neuer Ladevorgang ggf. läuft
            return;
        }

        match result {
            Ok(menu_model) => {
                tracing::info!("AppMenuButton: Menü für '{}' erfolgreich geladen.", app_id_for_result);
                self.current_menu_model_internal.replace(Some(menu_model.clone()));
                self.obj().set_menu_model(Some(&menu_model));
                self.menu_fetch_status_internal.replace(MenuFetchStatus::Success);
                self.obj().set_property("has-menu", true);
            }
            Err(e) => {
                tracing::warn!("AppMenuButton: Fehler beim Laden des Menüs für '{}': {:?}", app_id_for_result, e);
                self.current_menu_model_internal.replace(None);
                self.obj().set_menu_model(None::<&gio::MenuModel>);
                self.menu_fetch_status_internal.replace(MenuFetchStatus::Error(e.clone())); // Klonen des Fehlers
                 if matches!(e, AppMenuButtonError::MenuNotFound(_)) {
                    self.menu_fetch_status_internal.replace(MenuFetchStatus::NoMenuAvailable);
                }
                self.obj().set_property("has-menu", false);
            }
        }
        self.update_button_appearance_and_state_internal();
    }

    fn update_button_appearance_and_state_internal(&self) {
        let obj = self.obj();
        let status = *self.menu_fetch_status_internal.borrow();
        let has_actual_menu = self.current_menu_model_internal.borrow().is_some() && status == MenuFetchStatus::Success;

        // CSS-Klassen aktualisieren
        obj.remove_css_class("no-app-menu");
        obj.remove_css_class("active-app-menu");
        obj.remove_css_class("loading-app-menu");

        if has_actual_menu {
            obj.add_css_class("active-app-menu");
        } else if status == MenuFetchStatus::NoMenuAvailable || matches!(status, MenuFetchStatus::Error(_)) || self.active_app_id_internal.borrow().is_none() {
            obj.add_css_class("no-app-menu");
        } else if status == MenuFetchStatus::Loading {
            obj.add_css_class("loading-app-menu");
        }

        // Sensitivität des Buttons
        obj.set_sensitive(has_actual_menu || status == MenuFetchStatus::Loading); // Aktiv während Laden, um Klick auf leeres Popover zu verhindern

        // Icon und Label (Label wird hier nicht primär verwendet)
        let icon_widget_opt = self.app_icon_widget.borrow();
        if let Some(icon_widget) = icon_widget_opt.as_ref() {
            let icon_name_prop = self.obj().property::<Option<String>>("active-app-icon-name");
            if let Some(icon_name_str) = icon_name_prop.as_ref().filter(|s| !s.is_empty()) {
                icon_widget.set_from_icon_name(Some(icon_name_str));
            } else {
                icon_widget.set_from_icon_name(Some("application-menu-symbolic")); // Fallback
            }
        }
        
        // Tooltip aktualisieren
        let app_name_prop = self.obj().property::<Option<String>>("active-app-name");
        if let Some(name_str) = app_name_prop.as_ref().filter(|s| !s.is_empty()) {
            obj.set_tooltip_text(Some(name_str));
        } else {
            obj.set_tooltip_text(Some("Anwendungsmenü")); // Fallback-Tooltip
        }
    }
}

```

#### **3.3. GObject-Eigenschaften (Zusammenfassung)**

|Eigenschaftsname|Rust-Feld (Imp)|Typ (Rust / GLib)|Zugriff|Standardwert|Beschreibung|
|:--|:--|:--|:--|:--|:--|
|`active-app-name`|`active_app_name`|`Option<String>` / G_TYPE_STRING|R|`None`|Name der Anwendung, deren Menü angezeigt wird oder angezielt ist.|
|`active-app-icon-name`|`active_app_icon_name`|`Option<String>` / G_TYPE_STRING|R|`None`|Icon-Name der Anwendung.|
|`has-menu`|`has_menu`|`bool` / G_TYPE_BOOLEAN|R|`false`|`true`, wenn ein Menü für die aktive Anwendung verfügbar und geladen ist.|
|(Parent `menu-model`)|N/A (Parent-Eigenschaft)|`Option<gio::MenuModel>` / G_TYPE_OBJECT|R/W|`None`|Das Menümodell, das im Popover angezeigt wird. Wird von dieser Logik gesetzt.|
|(Parent `icon-name`)|N/A (Parent-Eigenschaft)|`Option<String>`|R/W|`None`|Das Icon des MenuButtons selbst. Diese Logik setzt das Icon eines Kind-Widgets.|
|(Parent `label`)|N/A (Parent-Eigenschaft)|`Option<String>`|R/W|`None`|Das Label des MenuButtons selbst. Diese Logik setzt das Label eines Kind-Widgets.|

In Google Sheets exportieren

#### **3.4. Interner Zustand (Felder in `AppMenuButtonImp`)**

- `button_content_box: RefCell<Option<GtkBox>>`: Container für Icon und optionales Label im Button.
- `app_icon_widget: RefCell<Option<Image>>`: Das `gtk::Image`-Widget für das Anwendungsicon.
- `app_name_widget: RefCell<Option<Label>>`: Das `gtk::Label`-Widget für den Anwendungsnamen (standardmäßig unsichtbar).
- `popover_menu: RefCell<Option<PopoverMenu>>`: Das `gtk::PopoverMenu`, das an den `gtk::MenuButton` gebunden ist.
- `active_app_id_internal: RefCell<Option<String>>`: Speichert die ID der aktuell fokussierten Anwendung. Dient als Trigger für Menü-Updates.
- `menu_fetch_status_internal: RefCell<MenuFetchStatus>`: Verfolgt den Zustand des Menüabrufs (Idle, Loading, Success, Error, NoMenuAvailable).
- `current_menu_model_internal: RefCell<Option<gio::MenuModel>>`: Hält das aktuell geladene `GMenuModel`.
- `dbus_connection: RefCell<Option<Arc<Connection>>>`: Die D-Bus-Verbindung für Abfragen. `Arc` wird verwendet, um die Verbindung sicher mit asynchronen Tasks zu teilen, die das Menü laden.

### **4. GTK-Widget-Implementierungsstrategie (Spezifikation für Manus AI)**

- **Basis-Widget:** Das `AppMenuButton` erbt von `gtk::MenuButton`. Diese Klasse bietet bereits die Funktionalität, ein Popover beim Klick anzuzeigen.
- **Button-Inhalt:**
    - Das `AppMenuButton` verwendet intern ein `GtkBox` (horizontal orientiert) als Kind-Widget, um ein `gtk::Image` (für das Icon) und optional ein `gtk::Label` (für den Anwendungsnamen) aufzunehmen. Standardmäßig ist nur das Icon sichtbar.
    - Das Icon wird basierend auf `active_app_icon_name` aktualisiert.
- **Popover und Menümodell:**
    - Ein `gtk::PopoverMenu` wird erstellt und als Popover für den `gtk::MenuButton` gesetzt (`obj.set_popover(Some(&popover))`).
    - Die Eigenschaft `menu-model` des `gtk::MenuButton` (oder direkt des `gtk::PopoverMenu`) wird dynamisch mit dem über D-Bus abgerufenen `gio::MenuModel` aktualisiert: `obj.set_menu_model(Some(&menu_model))`.
    - Wenn kein Menü verfügbar ist oder ein Fehler auftritt, wird `obj.set_menu_model(None::<&gio::MenuModel>)` gesetzt.

### **5. Methoden und Funktionssignaturen (Interne und Wrapper-Logik)**

#### **5.1. Interne Methoden (in `AppMenuButtonImp`)**

- `fn update_active_window_info_internal(&self, app_id: Option<String>, app_name: Option<String>, icon_name: Option<String>)`:
    1. Aktualisiert die internen Felder `active_app_id_internal`.
    2. Setzt die GObject-Properties `active-app-name` und `active-app-icon-name` des Wrapper-Objekts, um `notify`-Signale auszulösen.
    3. Wenn sich die `app_id` geändert hat oder von `None` zu `Some` wurde:
        - Wenn `app_id` `Some` ist und nicht leer: Ruft `trigger_menu_update_for_current_app_internal()` auf.
        - Wenn `app_id` `None` ist: Setzt `current_menu_model_internal` auf `None`, ruft `obj.set_menu_model(None)` auf, setzt `menu_fetch_status_internal` auf `Idle` und `has-menu` Property auf `false`.
    4. Ruft `update_button_appearance_and_state_internal()` auf.
- `fn trigger_menu_update_for_current_app_internal(&self)`:
    1. Holt `active_app_id_internal` und `dbus_connection`.
    2. Wenn beide `Some` sind und `app_id` nicht leer ist:
        - Setzt `menu_fetch_status_internal` auf `Loading`.
        - Ruft `update_button_appearance_and_state_internal()` auf, um Ladezustand anzuzeigen.
        - Startet eine asynchrone Task (`glib::MainContext::default().spawn_local`) die `Self::fetch_menu_for_app_async(dbus_conn_arc, app_id_str).await` aufruft.
        - Der Callback dieser Task ruft `self.handle_menu_fetch_result_internal(result, &original_app_id_str)` auf.
    3. Wenn keine `app_id` oder keine D-Bus-Verbindung: Setzt Status auf `Idle`, `set_menu_model(None)`, `set_property("has-menu", false)` und aktualisiert Aussehen.
- `async fn fetch_menu_for_app_async(dbus_conn: Arc<Connection>, app_id: String) -> Result<gio::MenuModel, AppMenuButtonError>`:
    1. Versucht, ein `gio::DBusMenuModel` für die gegebene `app_id` und gängige D-Bus-Objektpfade (z.B. `/org/gtk/menus/menubar`, `/org/gtk/menus/appmenu`, `/{app_id_als_pfad}`, `/`) über die `org.gtk.Menus`-Schnittstelle zu erstellen.
        - Nutzt `gio::DBusMenuModel::new(&dbus_conn, Some(app_id.as_str()), path_str)`.
    2. Wenn erfolgreich für einen Pfad: Gibt `Ok(menu_model.upcast())` zurück.
    3. Wenn alle Versuche fehlschlagen: Gibt `Err(AppMenuButtonError::MenuNotFound(app_id))` zurück.
    4. D-Bus-Verbindungsfehler werden als `AppMenuButtonError::DBusError` behandelt.
- `fn handle_menu_fetch_result_internal(&self, result: Result<gio::MenuModel, AppMenuButtonError>, app_id_for_result: &str)`:
    1. Prüft, ob das Ergebnis noch für die aktuell in `active_app_id_internal` gespeicherte App relevant ist. Wenn nicht, ignoriere das Ergebnis (Logge Warnung).
    2. Bei `Ok(menu_model)`:
        - Setzt `current_menu_model_internal` auf `Some(menu_model.clone())`.
        - Ruft `self.obj().set_menu_model(Some(&menu_model))`.
        - Setzt `menu_fetch_status_internal` auf `Success`.
        - Setzt die `has-menu` Property auf `true`.
    3. Bei `Err(e)`:
        - Setzt `current_menu_model_internal` auf `None`.
        - Ruft `self.obj().set_menu_model(None)`.
        - Setzt `menu_fetch_status_internal` auf `Error(e.clone())` oder `NoMenuAvailable` (wenn `e` ein `MenuNotFound` Fehler ist).
        - Setzt die `has-menu` Property auf `false`.
    4. Ruft `update_button_appearance_and_state_internal()` auf.
- `fn update_button_appearance_and_state_internal(&self)`:
    1. Aktualisiert CSS-Klassen (`active-app-menu`, `no-app-menu`, `loading-app-menu`) basierend auf `menu_fetch_status_internal` und ob `current_menu_model_internal` `Some` ist.
    2. Setzt die Sensitivität des Buttons (`gtk::Widget::set_sensitive()`). Der Button ist sensitiv, wenn ein Menü erfolgreich geladen wurde oder gerade geladen wird (um das Popover zu öffnen, das dann ggf. leer ist oder eine Ladeanzeige hat – hier wird es sensitiv, wenn `has_actual_menu` oder `status == Loading`).
    3. Aktualisiert das Icon im `app_icon_widget` basierend auf der `active-app-icon-name` Property (oder Fallback-Icon).
    4. Aktualisiert das Label im `app_name_widget` (falls sichtbar) basierend auf der `active-app-name` Property.
    5. Aktualisiert den Tooltip des Wrapper-Buttons (`obj.set_tooltip_text()`) mit dem Wert der `active-app-name` Property oder einem Fallback-Text.

#### **5.2. Methoden des öffentlichen Wrappers (`super::AppMenuButton`)**

- `pub fn new() -> Self`: Erstellt die Instanz.
- `pub fn update_active_window_info(&self, app_id: Option<String>, app_name: Option<String>, icon_name: Option<String>)`: Ruft die interne `update_active_window_info_internal` auf.
- `pub fn refresh_menu(&self)`: Ruft die interne `trigger_menu_update_for_current_app_internal` auf.

### **6. Signale**

- **Emittierte Signale:** Keine spezifischen benutzerdefinierten Signale für diese Komponente vorgesehen. Erbt und nutzt Signale von `gtk::MenuButton` (z.B. `clicked`, `activate` für Aktionen im Menü) und GObject-Properties (`notify::property-name`).
- **Verbundene Signale:**
    - Keine direkten Verbindungen zu externen Signalen in dieser Komponente. Es wird erwartet, dass ein übergeordneter Dienst (z.B. in `ui::shell` oder der Systemschicht) Änderungen des aktiven Fensters überwacht (z.B. mittels Wayland-Protokollen wie `wlr-foreign-toplevel-management`) und dann `AppMenuButton::update_active_window_info()` aufruft.

### **7. Interaktionen mit anderen Komponenten/Modulen**

- **`ui::shell`-Dienst (oder äquivalenter Systemdienst):**
    - Verantwortlich für die Überwachung des globalen Fensterfokus.
    - Ruft `AppMenuButton::update_active_window_info()` auf, wenn sich das aktive Anwendungsfenster ändert, und übergibt `app_id` (z.B. aus `zwlr_foreign_toplevel_handle_v1.app_id`), `app_name` (aus Fenstertitel oder App-Metadaten) und `icon_name`.
- **D-Bus (direkt oder via `novade-system`):**
    - Das `AppMenuButton` (bzw. seine `imp`-Logik) stellt direkt D-Bus-Anfragen über `zbus`, um das `GMenuModel` von Anwendungen abzurufen, die die `org.gtk.Menus`-Schnittstelle auf ihrem Anwendungs-Bus-Namen bereitstellen.
- **`domain::global_settings_and_state_management`:**
    - Könnte verwendet werden, um Konfigurationsoptionen für das `AppMenuButton` zu speichern (z.B. ob der Anwendungsname neben dem Icon angezeigt werden soll).

### **8. Ausnahmebehandlung (Fehlerdefinitionen)**

- **Datei:** `src/ui/shell/panel_widget/app_menu_button/error.rs`
    
- **Enum `AppMenuButtonError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    
    #[derive(Debug, Clone, Error, PartialEq, Eq)] // Clone, PartialEq, Eq für MenuFetchStatus::Error
    pub enum AppMenuButtonError {
        #[error("D-Bus connection error: {0}")]
        DBusConnectionError(String), // Enthält zbus::Error::to_string()
    
        #[error("D-Bus call failed for app '{app_id}': {dbus_error_name} - {dbus_error_message}")]
        DBusCallFailed {
            app_id: String,
            dbus_error_name: String,
            dbus_error_message: String,
        },
    
        #[error("Menu model not found for application '{0}'.")]
        MenuNotFound(String), // app_id
    
        #[error("Failed to parse menu model for application '{app_id}': {details}")]
        MenuModelParseError { app_id: String, details: String },
    
        #[error("Active window information (app_id) is missing or invalid.")]
        MissingWindowInfo,
    
        #[error("An internal error occurred in AppMenuButton: {0}")]
        InternalError(String),
    }
    ```
    
- Fehler werden im `MenuFetchStatus::Error(AppMenuButtonError)` gespeichert und beeinflussen das Aussehen und die Sensitivität des Buttons. Fehlerdetails werden via `tracing` geloggt.
    

### **9. Auflösung "Untersuchungsbedarf" (aus dem Quelldokument)**

- **Zuverlässige Methode zur Ermittlung des aktiven Fensters/app_id unter Wayland:**
    - Dies ist _nicht_ die direkte Verantwortung des `AppMenuButton`. Ein übergeordneter Dienst (Teil von `ui::shell` oder `novade-system`) muss diese Information bereitstellen.
    - Dieser Dienst verwendet Protokolle wie `wlr-foreign-toplevel-management-unstable-v1` oder `ext-foreign-toplevel-list-v1`.
    - Das `activated`-Ereignis von `zwlr_foreign_toplevel_handle_v1` signalisiert das fokussierte Fenster. Dessen `app_id` wird dann an `AppMenuButton::update_active_window_info()` übergeben.
- **Ermittlung und Konsumierung von `GMenuModel` via D-Bus:**
    - Die Methode `Workspace_menu_for_app_async` implementiert dies.
    - **Primärer Pfad:** `gio::DBusMenuModel::new()` wird verwendet, um das Menü von `bus_name = app_id` und gängigen Objektpfaden (`/org/gtk/menus/menubar`, `/org/gtk/menus/appmenu`, anwendungsspezifischer Pfad) zu beziehen. Dies nutzt die `org.gtk.Menus`-Schnittstelle.
    - **Fallbacks (StatusNotifierItem, AppMenuRegistrar):** Sind für eine moderne Wayland-Umgebung weniger relevant. `StatusNotifierItem.Menu` (D-Bus-Pfad zu `com.canonical.dbusmenu`) könnte ein seltener Fall sein. `AppMenuRegistrar` ist X11-lastig und wird hier nicht priorisiert. Die Spezifikation fokussiert sich auf `org.gtk.Menus`.

### **10. Dateistruktur (Zusammenfassung)**

- `src/ui/shell/panel_widget/app_menu_button/mod.rs` (Öffentliche API, GObject Wrapper)
- `src/ui/shell/panel_widget/app_menu_button/imp.rs` (Private GObject Implementierung, Logik)
- `src/ui/shell/panel_widget/app_menu_button/error.rs` (Spezifische Fehlerdefinitionen)

Diese detaillierte Spezifikation für das `AppMenuButton`-Modul sollte eine klare Grundlage für die Implementierung bieten. Die Aspekte der Fensterfokus-Überwachung sind ausgelagert, was die Komplexität dieses Widgets reduziert und es auf seine Kernaufgabe – das Abrufen und Anzeigen des Anwendungsmenüs – fokussiert.

1. **Definierte APIs (Traits & öffentliche Funktionen):**
    
    - **Kernschicht:** Stellt ihre Funktionalität über `pub` Funktionen und direkt nutzbare `pub` Typen bereit.
    - **Domänenschicht:** Definiert ihre Service-Schnittstellen primär über `pub trait ...: Send + Sync {}` (oft mit `#[async_trait::async_trait]`). Diese Traits werden von konkreten Service-Strukturen implementiert, die typischerweise mit `Arc<tokio::sync::Mutex/RwLock<InternalState>>` arbeiten, um Zustand zu verwalten.
    - **Systemschicht:** Definiert ebenfalls Service-Schnittstellen über Traits für Funktionen, die von der UI-Schicht aufgerufen werden können (z.B. `SystemPowerControlTrait`). Für interne Operationen oder Callbacks von externen Bibliotheken (z.B. Smithay Handler) werden konkrete `impl` Blöcke für die zentralen Zustandsstrukturen (`DesktopState`) verwendet.
    - **UI-Schicht:** Nutzt die Traits der Domänen- und Systemschicht. Interne UI-Komponenten kommunizieren über GTK-Signale, Rust-Methodenaufrufe und ggf. interne Event-Bus-Mechanismen (z.B. `glib::Sender/Receiver` für thread-übergreifende Kommunikation innerhalb der UI).
2. **Event-System (Nachrichtenbasierte Kommunikation):**
    
    - **Domänenschicht-Events:** Werden über `tokio::sync::broadcast` Kanäle von Domänen-Services publiziert. Subscriber (in Domäne, System oder UI) erhalten Klone der Event-Datenstrukturen. Event-Strukturen sind `#[derive(Debug, Clone, Serialize, Deserialize)]` (Serialize/Deserialize für Logging oder potenzielle IPC).
    - **Systemschicht-Events (intern & extern):**
        - Intern: Der `system::event_bridge` (mit `tokio::sync::broadcast`) verteilt System-interne Ereignisse (z.B. `UPowerEvent`, `AudioEvent`, `InputDeviceHotplugEvent`).
        - Extern (für UI): Die Systemschicht übersetzt relevante Low-Level-Systemereignisse (z.B. Wayland-Events, D-Bus-Signale) in spezifische, UI-konsumierbare Events oder aktualisiert Zustände, die von der UI periodisch abgefragt oder über Callbacks (z.B. `glib::idle_add`) verarbeitet werden. Wayland-Events (wie `xdg_surface.configure`) sind ein primärer Kommunikationsweg vom Compositor zu den Anwendungsfenstern (Clients) und indirekt zur UI-Shell.
    - **UI-Schicht-Events:** GTK4-Signale (`button.connect_clicked(...)`), `glib::Property` Benachrichtigungen, benutzerdefinierte Signale auf Widgets.
3. **Direktionale Abhängigkeiten:**
    
    - Kern → (von Domäne, System, UI genutzt)
    - Domäne → (von System, UI genutzt)
    - System → (von UI genutzt)
    - Keine zyklischen Abhängigkeiten zwischen den Hauptschichten-Crates (`novade-core`, `novade-domain`, `novade-system`, `novade-ui`).
4. **Datenfluss und Transformation:**
    
    - Daten, die zwischen Schichten ausgetauscht werden, sind klar definierte Rust-Structs oder -Enums.
    - Wenn eine Schicht Daten von einer tieferen Schicht empfängt, kann sie diese in ihre eigenen internen Repräsentationen transformieren (z.B. D-Bus-`zvariant::Value` wird in der Systemschicht zu einer Rust-Struktur, die dann ggf. an die Domänenschicht als Domänenobjekt weitergegeben wird).

---

**Schnittstellen im Detail (Ultra-Feinspezifikation):**

---

**1. Schnittstelle: Kernschicht (`novade-core`) zu höheren Schichten**

Diese Schnittstelle ist unidirektional. Die Kernschicht stellt Funktionalität bereit und hat keine Kenntnis von den höheren Schichten.

**1.1. `core::types`**

- **Datentypen (Beispiele mit exakten Definitionen):**
    - `pub struct Point<T: Copy + Debug + PartialEq + Default + Send + Sync + 'static> { pub x: T, pub y: T }`
    - `pub struct Size<T: Copy + Debug + PartialEq + Default + Send + Sync + 'static> { pub width: T, pub height: T }`
    - `pub struct Rect<T: Copy + Debug + PartialEq + Default + Send + Sync + 'static> { pub origin: Point<T>, pub size: Size<T> }`
    - `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)] pub struct RectInt { pub x: i32, pub y: i32, pub width: u32, pub height: u32 }`
    - `#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)] pub struct Color { pub r: f32, pub g: f32, pub b: f32, pub a: f32 }` (Invarianten: 0.0-1.0, Durchsetzung in `new()` und `serde`-Implementierung).
    - `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)] pub enum Orientation { #[default] Horizontal, Vertical }`
    - `pub use uuid::Uuid;`
    - `pub use chrono::{DateTime, Utc};`
- **Nutzung (Ultra-Fein):**
    - **Domäne:**
        - `domain::theming::types::AccentColor::value: core::types::Color`
        - `domain::window_management_policy::types::GapSettings::screen_outer_horizontal: u16` (Primitiver Typ, aber Werte könnten von `core::types::Size<u16>` inspiriert sein).
    - **System:**
        - `system::compositor::core::state::DesktopState::pointer_location: core::types::Point<f64, smithay::utils::Logical>`
        - `system::compositor::surface_management::RenderableElement::WaylandSurface::position: core::types::Point<i32, smithay::utils::Logical>`
        - Wayland-Geometrien (z.B. `xdg_surface.configure(.., width: i32, height: i32, ..)`) verwenden primitive Typen, werden aber oft in `core::types::RectInt` für interne Logik umgewandelt.
    - **UI:**
        - `ui::widgets::PlacedWidgetWidget::position: core::types::Point<i32>` (Hypothetisch)
        - CSS-Farben aus `domain::theming::AppliedThemeState::resolved_tokens` werden von der UI-Schicht geparst (ggf. zurück in `core::types::Color`, wenn nötig).

**1.2. `core::errors`**

- **Fehlertypen (Beispiele mit exakten Definitionen):**
    - `#[derive(Debug, thiserror::Error)] pub enum CoreError { #[error("I/O error accessing path '{path}': {source}")] Io { path: PathBuf, #[source] source: std::io::Error }, ... }`
    - `#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)] pub enum ColorParseError { #[error("Invalid hex color string format for '{0}'")] InvalidHexFormat(String), ... }`
- **Nutzung (Ultra-Fein):**
    - **Domäne:**
        - `domain::theming::errors::ThemingError::TokenFileIoError { path: PathBuf, #[source] source: std::io::Error }` (Könnte `CoreError::Io` wrappen oder direkt `std::io::Error` verwenden und `From<std::io::Error>` implementieren).
        - Wenn `domain::theming::logic::load_raw_tokens_from_file` eine `core::config::ConfigError::FileReadError { path, source }` zurückgibt (falls Dateilesen in `core::config` gekapselt ist), könnte `ThemingError` dies direkt via `#[from]` übernehmen oder spezifischer mappen.
    - **System:**
        - `system::dbus_interfaces::common::errors::DBusInterfaceError::ConnectionFailed(#[from] zbus::Error)` (Wrappt externen Fehler). Wenn `zbus::Error` selbst `std::io::Error` wrappt, könnte die Kette bis `CoreError::Io` reichen.
        - Fehler beim Lesen einer Shader-Datei im `system::compositor::renderer` könnte `CoreError::Io` sein, das in einen `RendererError::ShaderLoadFailed` gewrappt wird.
    - **UI:**
        - Fehler aus der Domänen- oder Systemschicht werden an die UI weitergegeben. Z.B. ein `GlobalSettingsError::PersistenceError { source: CoreError::Io { ... } }` wird von der UI abgefangen. Die UI entscheidet dann, dem Benutzer eine generische "Speichern fehlgeschlagen" Meldung anzuzeigen und loggt den vollständigen Fehler (`error!(error = ?err, "...")`).

**1.3. `core::logging`**

- **Logging-API (Beispiele mit exakten Signaturen):**
    - `pub fn initialize_logging(level_filter: tracing::LevelFilter, format: core::logging::types::LogFormat, writer: impl std::io::Write + Send + Sync + 'static) -> Result<(), core::logging::errors::LoggingError>` (Writer für Flexibilität).
    - Konvention: Alle Module verwenden `tracing::{trace, debug, info, warn, error, instrument};`.
- **Nutzung (Ultra-Fein):**
    - **Anwendungs-Root (`main.rs` in `novade-ui` oder dem Haupt-Binary):**
        
        Rust
        
        ```
        // In main.rs
        fn main() -> Result<(), Box<dyn std::error::Error>> {
            // Konfig laden, um Log-Level und Format zu bestimmen
            // let core_config = novade_core::config::get_global_core_config(); // Annahme: Konfig wurde geladen
            // let log_level = core_config.log_level.into(); // Konvertierung zu tracing::LevelFilter
            // let log_format = core_config.log_format.into(); // Konvertierung zu core::logging::LogFormat
            // novade_core::logging::initialize_logging(log_level, log_format, std::io::stdout())?;
            // ... Rest der Anwendung ...
            Ok(())
        }
        ```
        
    - **Alle Schichten/Module:**
        
        Rust
        
        ```
        // In irgendeiner Funktion
        #[tracing::instrument(skip(sensitive_data))]
        fn process_data(data: &DataType, sensitive_data: &Secret) -> Result<(), MyModuleError> {
            tracing::debug!(input_data_len = data.len(), "Verarbeite Daten.");
            if data.is_empty() {
                tracing::warn!("Leere Daten empfangen.");
                return Err(MyModuleError::EmptyData);
            }
            // ... Logik ...
            tracing::info!(result = "Erfolgreich", "Daten verarbeitet.");
            Ok(())
        }
        ```
        

**1.4. `core::config`**

- **Konfigurations-API (Beispiele mit exakten Signaturen):**
    - **Trait `core::config::ConfigServiceAsync` (Neu, für asynchrones Laden):**
        
        Rust
        
        ```
        #[async_trait::async_trait]
        pub trait ConfigServiceAsync: Send + Sync {
            async fn read_config_file_string(&self, key_or_path: &str) -> Result<String, CoreError>; // CoreError::Io oder CoreError::NotFound
            async fn write_config_file_string(&self, key_or_path: &str, content: String) -> Result<(), CoreError>; // CoreError::Io
        }
        ```
        
        - Eine Implementierung (`FilesystemConfigServiceAsync`) würde `tokio::fs` verwenden.
    - `pub fn load_config_deserialize<T: for<'de> serde::Deserialize<'de>>(content_str: &str, source_description: &str) -> Result<T, CoreError>` (Generische Deserialisierungsfunktion).
    - Globale `CoreConfig` über `pub fn get_global_core_config() -> &'static CoreConfig`. Initialisierung über `pub fn initialize_global_core_config(paths: &[PathBuf], config_service: Arc<dyn ConfigServiceAsync>) -> Result<(), CoreError>`.
- **Nutzung (Ultra-Fein):**
    - **Domäne (`domain::theming::logic`):**
        
        Rust
        
        ```
        // ThemingEngine::internal_load_themes_and_tokens_locked
        async fn load_theme_definition_from_file(
            &self,
            path: &Path,
            config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>,
        ) -> Result<ThemeDefinition, ThemingError> {
            let content = config_service.read_config_file_string(path.to_str().unwrap())
                .await
                .map_err(|core_err| ThemingError::FilesystemError(core_err))?; // Wrapping
            let theme_def: ThemeDefinition = novade_core::config::load_config_deserialize(&content, path.to_string_lossy().as_ref())
                .map_err(|core_err| ThemingError::ThemeFileLoadError { /* ... source: core_err ... */})?;
            Ok(theme_def)
        }
        ```
        
    - **System (`system::mcp_client::connection_manager`):**
        - `McpConnectionManager` könnte `get_global_core_config()` verwenden, um Standardpfade oder Features für MCP-Server zu laden, falls diese in `CoreConfig` definiert sind.


# Kernschicht Implementierungsleitfaden: Modul 1 - Fundamentale Datentypen (core::types)

1. Modulübersicht: core::types
    1. 1.1. Zweck und Verantwortlichkeit Dieses Modul, `core::types`, bildet das Fundament der Kernschicht (core) und somit des gesamten Systems.
        
    2. Seine primäre Verantwortung liegt in der Definition grundlegender, universell einsetzbarer Datentypen, die von allen anderen Schichten und Modulen der Desktop-Umgebung benötigt werden.
        
    3. Dazu gehören geometrische Primitive (wie Punkte, Größen, Rechtecke), Farbdarstellungen und allgemeine Enumerationen (wie Orientierungen).
        
    4. Die in diesem Modul definierten Typen sind bewusst einfach gehalten und repräsentieren reine Datenstrukturen ohne komplexe Geschäftslogik oder Abhängigkeiten zu höheren Schichten oder externen Systemen.
        
    5. Sie dienen als Bausteine für komplexere Operationen und Zustandsrepräsentationen in den Domänen-, System- und Benutzeroberflächenschichten.
        
    6. 1.2. Designphilosophie Das Design von `core::types` folgt den Prinzipien der Modularität, Wiederverwendbarkeit und minimalen Kopplung.
        
    7. Die Typen sind generisch gehalten (wo sinnvoll, z.B. bei geometrischen Primitiven), um Flexibilität für verschiedene numerische Darstellungen (z.B. `i32` für Koordinaten, `f32` für Skalierungsfaktoren) zu ermöglichen.
        
    8. Ein wesentlicher Aspekt ist die klare Trennung von Datenrepräsentation (in `core::types`) und Fehlerbehandlung.
        
    9. Während dieses Modul die Datenstrukturen definiert, werden die spezifischen Fehler, die bei Operationen mit diesen Typen auftreten können (z.B. durch ungültige Werte), in den Modulen definiert, die diese Operationen durchführen (typischerweise in `core::errors` oder modulspezifischen Fehler-Enums höherer Schichten).
        
    10. 1.3. Zusammenspiel mit Fehlerbehandlung Obwohl `core::types` selbst keine Error-Typen definiert, ist das Design der hier enthaltenen Typen entscheidend für eine robuste und konsistente Fehlerbehandlungsstrategie im gesamten Projekt.
        
    11. Die übergeordnete Richtlinie sieht die Verwendung des `thiserror`-Crates vor, um spezifische Fehler-Enums pro Modul zu definieren.
        
    12. Dies ermöglicht eine granulare Fehlerbehandlung, ohne die Komplexität übermäßig zu erhöhen.
        
    13. Die Typen in `core::types` unterstützen diese Strategie, indem sie:
        
        - Standard-Traits implementieren: Alle Typen implementieren grundlegende Traits wie `Debug` und `Display`.
            
        - Dies ist essenziell, damit Instanzen dieser Typen effektiv in Fehlermeldungen und Log-Ausgaben eingebettet werden können, die von höheren Schichten unter Verwendung von `thiserror` generiert werden.
            
        - Eine gute Fehlerdarstellung ist entscheidend für die Fehlersuche und das Verständnis von Problemen im Laufzeitbetrieb.
            
        - Invarianten dokumentieren: Für Typen wie `Rect<T>` existieren logische Invarianten (z.B. nicht-negative Breite und Höhe). Diese Invarianten werden klar dokumentiert.
            
        - Validierung ermöglichen: Wo sinnvoll, werden Methoden zur Überprüfung der Gültigkeit bereitgestellt (z.B. `Rect::is_valid()`).
            
        - Diese Methoden erlauben es aufrufendem Code in höheren Schichten, Zustände zu überprüfen, bevor Operationen ausgeführt werden, die fehlschlagen könnten.
            
        - Keine Panics in Kernfunktionen: Konstruktoren und einfache Zugriffsmethoden in `core::types` lösen keine Panics aus und geben keine `Result`-Typen zurück, um die API auf dieser fundamentalen Ebene einfach und vorhersagbar zu halten.
            
        - Die Verantwortung für die Handhabung potenziell ungültiger Zustände (z.B. ein `Rect` mit negativer Breite, das an eine Rendering-Funktion übergeben wird) liegt bei den konsumierenden Funktionen, die dann die definierten Fehlerpfade (mittels `Result<T, E>` 3 und den `thiserror`-basierten E-Typen) nutzen.
            
    14. Diese Designentscheidungen stellen sicher, dass die fundamentalen Typen nahtlos in das übergeordnete Fehlerbehandlungskonzept integriert werden können, ohne selbst die Komplexität der Fehlerdefinition tragen zu müssen.
        
    15. Die gewählte Fehlerstrategie mit `thiserror` pro Modul wird als ausreichend für die Bedürfnisse der Kernschicht erachtet, auch wenn alternative Ansätze wie `snafu` für komplexere Szenarien existieren, in denen z.B. die Unterscheidung von Fehlern aus derselben Quelle kritisch ist. Für die Kernschicht wird die Einfachheit und Direktheit von `thiserror` bevorzugt.
        
    16. 1.4. Modulabhängigkeiten Dieses Modul ist darauf ausgelegt, minimale externe Abhängigkeiten zu haben, um seine grundlegende Natur und breite Anwendbarkeit zu gewährleisten.
        
    17. Erlaubte Abhängigkeiten:
        
        - `std` (Rust Standardbibliothek)
            
    18. Optionale Abhängigkeiten (derzeit nicht verwendet):
        
        - `num-traits`: Nur hinzufügen, falls generische numerische Operationen benötigt werden, die über `std::ops` hinausgehen.
        - `serde` (mit `derive`-Feature): Nur hinzufügen, wenn Serialisierung/Deserialisierung dieser Basistypen direkt auf dieser Ebene zwingend erforderlich ist (z.B. für Konfigurationsdateien, die diese Typen direkt verwenden).
            
        - Aktuell wird davon ausgegangen, dass Serialisierungslogik in höheren Schichten implementiert wird, um unnötige Abhängigkeiten zu vermeiden.
    19. 1.5. Ziel-Dateistruktur Die Implementierung dieses Moduls erfolgt innerhalb des core-Crates mit folgender Verzeichnisstruktur:
        
        ```
        core/
        └── src/
            ├── Cargo.toml        # (Definiert das 'core' Crate)
            └── src/
                ├── lib.rs          # (Deklariert Kernmodule: pub mod types; pub mod errors; ...)
                └── types/
                    ├── mod.rs       # (Deklariert und re-exportiert Typen: pub mod geometry; pub mod color; ...)
                    ├── geometry.rs # (Enthält Point<T>, Size<T>, Rect<T>)
                    ├── color.rs      # (Enthält Color)
                    └── enums.rs      # (Enthält Orientation, etc.)
        ```
        
2. 2. Spezifikation: Geometrische Primitive (geometry.rs) Diese Datei definiert grundlegende 2D-Geometrietypen, die für Layout, Positionierung und Rendering unerlässlich sind.
    3. 2.1. Struct: `Point<T>`
        1. 2.1.1. Definition und Zweck: Repräsentiert einen Punkt im 2D-Raum mit x- und y-Koordinaten.
            
        2. Generisch über den Typ T.
        3. 2.1.2. Felder:
            - `pub x: T`
            - `pub y: T`
        4. 2.1.3. Assoziierte Konstanten:
            - `pub const ZERO_I32: Point<i32> = Point { x: 0, y: 0 };`
                
            - `pub const ZERO_U32: Point<u32> = Point { x: 0, y: 0 };`
                
            - `pub const ZERO_F32: Point<f32> = Point { x: 0.0, y: 0.0 };`
                
            - `pub const ZERO_F64: Point<f64> = Point { x: 0.0, y: 0.0 };`
                
        5. 2.1.4. Methoden:
            - `pub const fn new(x: T, y: T) -> Self`
                - Erstellt einen neuen Punkt.
                    
            - `pub fn distance_squared(&self, other: &Point<T>) -> T`
                - Berechnet das Quadrat der euklidischen Distanz.
                    
                - Constraints: `T: Copy + std::ops::Add<Output=T> + std::ops::Sub<Output=T> + std::ops::Mul<Output=T>`
                    
            - `pub fn distance(&self, other: &Point<T>) -> T`
                - Berechnet die euklidische Distanz.
                    
                - Constraints: `T: Copy + std::ops::Add<Output=T> + std::ops::Sub<Output=T> + std::ops::Mul<Output=T> + num_traits::Float` (Implementierung nur für Float-Typen sinnvoll oder über sqrt-Funktion). Vorerst nur für f32,f64 implementieren.
            - `pub fn manhattan_distance(&self, other: &Point<T>) -> T`
                - Berechnet die Manhattan-Distanz (`|x1 - x2| + |y1 - y2|`).
                    
                - Constraints: `T: Copy + std::ops::Add<Output=T> + std::ops::Sub<Output=T> + num_traits::Signed` (Benötigt abs()).
        6. 2.1.5. Trait Implementierungen:
            - `impl<T: Copy + Debug + Default> Default for Point<T> { ... }`
                - Bedingung: T muss die jeweiligen Traits ebenfalls implementieren. Default setzt x und y auf T::default().
                    
            - `impl<T: Send + 'static> Send for Point<T> {}`
                
            - `impl<T: Sync + 'static> Sync for Point<T> {}`
                
            - `impl<T: std::ops::Add<Output = T>> std::ops::Add for Point<T>`
                
            - `impl<T: std::ops::Sub<Output = T>> std::ops::Sub for Point<T>`
                
        7. 2.1.6. Generische Constraints (Basis): `T: Copy + Debug + PartialEq + Default + Send + Sync + 'static`.
            
            - Weitere Constraints werden pro Methode spezifiziert.
    4. 2.2. Struct: `Size<T>`
        1. 2.2.1. Definition und Zweck: Repräsentiert eine 2D-Dimension (Breite und Höhe). Generisch über den Typ T.
            
        2. 2.2.2. Felder:
            - `pub width: T`
            - `pub height: T`
        3. 2.2.3. Assoziierte Konstanten:
            - `pub const ZERO_I32: Size<i32> = Size { width: 0, height: 0 };`
                
            - `pub const ZERO_U32: Size<u32> = Size { width: 0, height: 0 };`
                
            - `pub const ZERO_F32: Size<f32> = Size { width: 0.0, height: 0.0 };`
                
            - `pub const ZERO_F64: Size<f64> = Size { width: 0.0, height: 0.0 };`
                
        4. 2.2.4. Methoden:
            - `pub const fn new(width: T, height: T) -> Self`
                - Erstellt eine neue Größe.
                    
            - `pub fn area(&self) -> T`
                - Berechnet die Fläche (`width * height`).
                    
                - Constraints: `T: Copy + std::ops::Mul<Output=T>`
            - `pub fn is_empty(&self) -> bool`
                - Prüft, ob Breite oder Höhe null ist.
                    
                - Constraints: `T: PartialEq + num_traits::Zero`
            - `pub fn is_valid(&self) -> bool`
                - Prüft, ob Breite und Höhe nicht-negativ sind. Nützlich für Typen wie i32.
                    
                - Constraints: `T: PartialOrd + num_traits::Zero`
        5. 2.2.5. Trait Implementierungen:
            - `impl<T: Copy + Debug + Default> Default for Size<T> { ... }`
                - Bedingung: T muss die jeweiligen Traits ebenfalls implementieren. Default setzt width und height auf T::default().
                    
            - `impl<T: Send + 'static> Send for Size<T> {}`
                
            - `impl<T: Sync + 'static> Sync for Size<T> {}`
                
        6. 2.2.6. Generische Constraints (Basis): `T: Copy + Debug + PartialEq + Default + Send + Sync + 'static`.
            
            - Weitere Constraints werden pro Methode spezifiziert. Die Invariante nicht-negativer Dimensionen wird durch `is_valid` prüfbar gemacht, aber nicht durch den Typ erzwungen.
    5. 2.3. Struct: `Rect<T>`
        1. 2.3.1. Definition und Zweck: Repräsentiert ein 2D-Rechteck, definiert durch einen Ursprungspunkt (oben-links) und eine Größe.
            
        2. Generisch über den Typ T.
        3. 2.3.2. Felder:
            - `pub origin: Point<T>`
            - `pub size: Size<T>`
        4. 2.3.3. Assoziierte Konstanten:
            - `pub const ZERO_I32: Rect<i32> = Rect { origin: Point::ZERO_I32, size: Size::ZERO_I32 };`
                
            - `pub const ZERO_U32: Rect<u32> = Rect { origin: Point::ZERO_U32, size: Size::ZERO_U32 };`
                
            - `pub const ZERO_F32: Rect<f32> = Rect { origin: Point::ZERO_F32, size: Size::ZERO_F32 };`
                
            - `pub const ZERO_F64: Rect<f64> = Rect { origin: Point::ZERO_F64, size: Size::ZERO_F64 };`
                
        5. 2.3.4. Methoden:
            - `pub const fn new(origin: Point<T>, size: Size<T>) -> Self`
                
            - `pub fn from_coords(x: T, y: T, width: T, height: T) -> Self`
                - Constraints: T muss die Constraints von `Point::new` und `Size::new` erfüllen.
                    
            - `pub fn x(&self) -> T` (Constraints: `T: Copy`)
                
            - `pub fn y(&self) -> T` (Constraints: `T: Copy`)
                
            - `pub fn width(&self) -> T` (Constraints: `T: Copy`)
                
            - `pub fn height(&self) -> T` (Constraints: `T: Copy`)
                
            - `pub fn top(&self) -> T` (Alias für y, Constraints: `T: Copy`)
                
            - `pub fn left(&self) -> T` (Alias für x, Constraints: `T: Copy`)
                
            - `pub fn bottom(&self) -> T` (y + height, Constraints: `T: Copy + std::ops::Add<Output=T>`)
                
            - `pub fn right(&self) -> T` (x + width, Constraints: `T: Copy + std::ops::Add<Output=T>`)
                
            - `pub fn center(&self) -> Point<T>`
                - Berechnet den Mittelpunkt.
                    
                - Constraints: `T: Copy + std::ops::Add<Output=T> + std::ops::Div<Output=T> + num_traits::FromPrimitive` (Benötigt Division durch 2).
            - `pub fn contains_point(&self, point: &Point<T>) -> bool`
                - Prüft, ob der Punkt innerhalb des Rechtecks liegt (Grenzen inklusiv für top/left, exklusiv für bottom/right).
                    
                - Constraints: `T: Copy + PartialOrd + std::ops::Add<Output=T>`
            - `pub fn intersects(&self, other: &Rect<T>) -> bool`
                - Prüft, ob sich dieses Rechteck mit einem anderen überschneidet.
                    
                - Constraints: `T: Copy + PartialOrd + std::ops::Add<Output=T>`
            - `pub fn intersection(&self, other: &Rect<T>) -> Option<Rect<T>>`
                - Berechnet das Schnittrechteck. Gibt `None` zurück, wenn keine Überschneidung vorliegt.
                    
                - Constraints: `T: Copy + Ord + std::ops::Add<Output=T> + std::ops::Sub<Output=T> + num_traits::Zero`
            - `pub fn union(&self, other: &Rect<T>) -> Rect<T>`
                - Berechnet das umschließende Rechteck beider Rechtecke.
                    
                - Constraints: `T: Copy + Ord + std::ops::Add<Output=T> + std::ops::Sub<Output=T>`
            - `pub fn translated(&self, dx: T, dy: T) -> Rect<T>`
                - Verschiebt das Rechteck um (dx, dy).
                    
                - Constraints: `T: Copy + std::ops::Add<Output=T>`
            - `pub fn scaled(&self, sx: T, sy: T) -> Rect<T>`
                - Skaliert das Rechteck relativ zum Ursprung (0, 0).
                    
                - Beachtet, dass dies Ursprung und Größe skaliert.
                - Constraints: `T: Copy + std::ops::Mul<Output=T>`
            - `pub fn is_valid(&self) -> bool`
                - Prüft, ob `size.is_valid()` wahr ist.
                    
                - Constraints: `T: PartialOrd + num_traits::Zero`
        6. 2.3.5. Trait Implementierungen:
            - `impl<T: Copy + Debug + Default> Default for Rect<T> { ... }`
                - Bedingung: T muss die jeweiligen Traits ebenfalls implementieren. Default verwendet `Point::default()` und `Size::default()`.
                    
            - `impl<T: Send + 'static> Send for Rect<T> {}`
                
            - `impl<T: Sync + 'static> Sync for Rect<T> {}`
                
        7. 2.3.6. Generische Constraints (Basis): `T: Copy + Debug + PartialEq + Default + Send + Sync + 'static`.
            
            - Weitere Constraints werden pro Methode spezifiziert.
        8. 2.3.7. Invarianten und Validierung (Verbindung zur Fehlerbehandlung):
            - Invariante: Logisch sollten width und height der size-Komponente nicht-negativ sein.
                
            - Kontext: Die Verwendung von vorzeichenbehafteten Typen wie i32 für Koordinaten ist üblich, erlaubt aber technisch negative Dimensionen.
                
            - Eine Erzwingung nicht-negativer Dimensionen auf Typebene (z.B. durch u32) wäre zu restriktiv für Koordinatensysteme.
                
            - Konsequenz: Die Flexibilität, `Rect<i32>` zu verwenden, verlagert die Verantwortung für die Validierung auf die Nutzer des Rect-Typs.
                
            - Funktionen in höheren Schichten (z.B. Layout-Algorithmen, Rendering-Engines), die ein `Rect` konsumieren, müssen potenziell ungültige Rechtecke (mit negativer Breite oder Höhe) behandeln.
                
            - Solche Fälle stellen Laufzeitfehler dar, die über das etablierte Fehlerbehandlungssystem (basierend auf `Result<T, E>` und `thiserror`-definierten E-Typen) signalisiert werden müssen.
                
            - Implementierung in `core::types`: Das Modul erzwingt die Invariante nicht zur Compilezeit oder in Konstruktoren.
                
            - Stattdessen wird die Methode `pub fn is_valid(&self) -> bool` bereitgestellt.
                
            - Nutzer von `Rect<T>` (insbesondere mit `T=i32`) sollten diese Methode aufrufen, um die Gültigkeit sicherzustellen, bevor Operationen durchgeführt werden, die eine positive Breite und Höhe voraussetzen.
                
            - Die Dokumentation des Rect-Typs muss explizit auf diese Invariante und die Notwendigkeit der Validierung durch den Aufrufer hinweisen.
                
            - Die Verantwortung für das Melden eines Fehlers bei Verwendung eines ungültigen `Rect` liegt beim Aufrufer, der dafür die Fehlerinfrastruktur (z.B. `core::errors` oder modulspezifische Fehler) nutzt.
                
    6. 2.4. Struct: `RectInt`
        - (aus einer anderen Quelldatei, aber thematisch passend)
        - Repräsentiert ein achsenparalleles Rechteck mit ganzzahligen Koordinaten (`x: i32`, `y: i32`) und Dimensionen (`width: u32`, `height: u32`).
            
            - Methoden u.a. `new(...)`, `from_points(...)`, `top_left()`, `size()`, `right()`, `bottom()`, `contains_point(...)`, `intersects(...)`, `intersection(...)`, `union(...)`, `translate(...)`, `inflate(...)`, `is_empty()`
                
            - Verwendet `saturating_add` / `saturating_sub` um Überläufe zu vermeiden.
                
            - Traits: `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Default`
                
3. 3. Spezifikation: Farbdarstellung (color.rs) Diese Datei definiert einen Standard-Farbtyp für die Verwendung im gesamten System.
    4. 3.1. Struct: `Color` (RGBA)
        1. 3.1.1. Definition und Zweck: Repräsentiert eine Farbe mit Rot-, Grün-, Blau- und Alpha-Komponenten.
            
        2. Verwendet `f32`-Komponenten im Bereich `[0.0, 1.0]` für hohe Präzision und Flexibilität bei Farboperationen wie Mischen und Transformationen.
            
        3. 3.1.2. Felder:
            - `pub r: f32` (Rotkomponente, 0.0 bis 1.0)
                
            - `pub g: f32` (Grünkomponente, 0.0 bis 1.0)
                
            - `pub b: f32` (Blaukomponente, 0.0 bis 1.0)
                
            - `pub a: f32` (Alphakomponente, 0.0=transparent bis 1.0=opak)
                
        4. 3.1.3. Assoziierte Konstanten:
            - `pub const TRANSPARENT: Color = Color { r: 0.0, g: 0.0, b: 0.0, a: 0.0 };`
                
            - `pub const BLACK: Color = Color { r: 0.0, g: 0.0, b: 0.0, a: 1.0 };`
                
            - `pub const WHITE: Color = Color { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };`
                
            - `pub const RED: Color = Color { r: 1.0, g: 0.0, b: 0.0, a: 1.0 };`
                
            - `pub const GREEN: Color = Color { r: 0.0, g: 1.0, b: 0.0, a: 1.0 };`
                
            - `pub const BLUE: Color = Color { r: 0.0, g: 0.0, b: 1.0, a: 1.0 };`
                
            - (Weitere Standardfarben nach Bedarf hinzufügen)
                
        5. 3.1.4. Methoden:
            - `pub const fn new(r: f32, g: f32, b: f32, a: f32) -> Self`
                - Erstellt eine neue Farbe.
                    
                - Werte außerhalb `[0.0, 1.0]` werden nicht automatisch geklemmt, dies liegt in der Verantwortung des Aufrufers oder nachfolgender Operationen. `debug_assert!` kann zur Laufzeitprüfung in Debug-Builds verwendet werden.
                    
            - `pub fn from_rgba8(r: u8, g: u8, b: u8, a: u8) -> Self`
                - Konvertiert von 8-Bit-Ganzzahlkomponenten (0-255) zu f32 (0.0-1.0).
                    
                - `value / 255.0`.
            - `pub fn to_rgba8(&self) -> (u8, u8, u8, u8)`
                - Konvertiert von f32 zu 8-Bit-Ganzzahlkomponenten.
                    
                - Klemmt Werte auf `[0.0, 1.0]` und skaliert dann auf (value.clamp(0.0,1.0)∗255.0).round()asu8.
                    
            - `pub fn with_alpha(&self, alpha: f32) -> Self`
                - Erstellt eine neue Farbe mit dem angegebenen Alpha-Wert, wobei RGB beibehalten wird.
                    
                - Klemmt Alpha auf `[0.0, 1.0]`.
                    
            - `pub fn blend(&self, background: &Color) -> Color`
                - Führt Alpha-Blending ("source-over") dieser Farbe über einer Hintergrundfarbe durch.
                    
                - Formel: `C_out = C_fg * α_fg + C_bg * α_bg * (1 - α_fg)`. `α_out = α_fg + α_bg * (1 - α_fg)`. Annahme: Farben sind nicht vormultipliziert.
                    
            - `pub fn lighten(&self, amount: f32) -> Color`
                - Hellt die Farbe um einen Faktor amount auf (z.B. durch lineare Interpolation zu Weiß).
                    
                - Klemmt das Ergebnis auf gültige Farbwerte. amount im Bereich `[0.0, 1.0]`.
                    
            - `pub fn darken(&self, amount: f32) -> Color`
                - Dunkelt die Farbe um einen Faktor amount ab (z.B. durch lineare Interpolation zu Schwarz).
                    
                - Klemmt das Ergebnis. amount im Bereich `[0.0, 1.0]`.
                    
        6. 3.1.5. Trait Implementierungen:
            - `impl PartialEq for Color { ... }`
                - PartialEq: Verwendet den Standard-Float-Vergleich.
                    
                - Für präzisere Vergleiche könnten benutzerdefinierte Implementierungen mit Epsilon erforderlich sein, dies wird jedoch für die Kernschicht als unnötige Komplexität betrachtet.
                    
            - `impl Default for Color { ... }`
                - Default: Implementiert Default manuell, um `Color::TRANSPARENT` zurückzugeben.
                    
            - `impl Send for Color {}`
                
            - `impl Sync for Color {}`
                
4. 4. Spezifikation: Allgemeine Enumerationen (enums.rs) Diese Datei enthält häufig verwendete, einfache Enumerationen.
        
    5. 4.1. Enum: `Orientation`
        1. 4.1.1. Definition und Zweck: Repräsentiert eine horizontale oder vertikale Ausrichtung, häufig verwendet in UI-Layouts und Widgets.
            
        2. 4.1.2. Varianten:
            - `Horizontal`
                
            - `Vertical`
                
        3. 4.1.3. Methoden:
            - `pub fn toggle(&self) -> Self`
                - Gibt die jeweils andere Orientierung zurück (Horizontal -> Vertical, Vertical -> Horizontal).
                    
        4. 4.1.4. Trait Implementierungen:
            - `impl Default for Orientation { fn default() -> Self { Orientation::Horizontal } }` (Standard ist Horizontal).
                
            - `impl Send for Orientation {}`
                
            - `impl Sync for Orientation {}`
                
5. 5. Zusammenfassung: Standard Trait Implementierungen Die folgende Tabelle gibt einen Überblick über die Implementierung gängiger Standard-Traits für die in diesem Modul definierten Typen. Dies dient als
        

 Quellen
---

**2. Schnittstelle: Domänenschicht (`novade-domain`) zu Systemschicht und UI-Schicht**

**2.1. Service-APIs (Traits) – Ultra-Fein-Definitionen (Beispiele):**

- **`domain::theming::service::ThemingService`** (Umbenannt von `ThemingEngine` für Klarheit als Trait)
    
    Rust
    
    ```
    use crate::core::types::{Color as CoreColor}; // novade-core Typen
    use super::types::{AppliedThemeState, ThemeIdentifier, ColorSchemeType, ThemingConfiguration, ThemeDefinition};
    use super::errors::ThemingError;
    use tokio::sync::broadcast;
    use uuid::Uuid;
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)] // Für Event und Cache
    pub struct ThemeChangedEvent {
        pub event_id: Uuid,
        pub timestamp: DateTime<Utc>,
        pub new_state: AppliedThemeState,
    }
    
    #[async_trait::async_trait]
    pub trait ThemingService: Send + Sync {
        /// Gibt den aktuell angewendeten Theme-Zustand zurück.
        async fn get_current_theme_state(&self) -> Result<AppliedThemeState, ThemingError>;
    
        /// Gibt eine Liste aller verfügbaren (geladenen) Theme-Definitionen zurück.
        async fn get_available_themes(&self) -> Result<Vec<ThemeDefinition>, ThemingError>;
    
        /// Gibt die aktuell vom Benutzer gewählte Theming-Konfiguration zurück.
        async fn get_current_theming_configuration(&self) -> Result<ThemingConfiguration, ThemingError>;
    
        /// Aktualisiert die Theming-Konfiguration des Benutzers.
        /// Löst eine Neuberechnung des `AppliedThemeState` und ein `ThemeChangedEvent` aus, falls sich der Zustand ändert.
        async fn update_theming_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>;
    
        /// Lädt alle Theme- und Token-Definitionen von den konfigurierten Pfaden neu.
        /// Dies kann z.B. nützlich sein, wenn der Benutzer neue Themes installiert.
        /// Aktualisiert den `AppliedThemeState` basierend auf der aktuellen Konfiguration.
        async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>;
    
        /// Abonniert Änderungen am angewendeten Theme-Zustand.
        fn subscribe_to_theme_changes(&self) -> broadcast::Receiver<ThemeChangedEvent>;
    }
    ```
    
    - **Publisher von `ThemeChangedEvent`**: `DefaultThemingService` (die Implementierung).
    - **Subscriber von `ThemeChangedEvent`**:
        - `ui::theming_gtk::ThemeManagerGtk`: Aktualisiert GTK CSS Provider.
        - Andere UI-Komponenten, die direkt auf Theme-Änderungen reagieren müssen (z.B. benutzerdefinierte Widgets, die Farben nicht über CSS beziehen).
        - Ggf. `system::compositor` wenn serverseitige Dekorationen stark vom Theme abhängen.
- **`domain::global_settings_and_state_management::service::GlobalSettingsService`**
    
    Rust
    
    ```
    use super::types::GlobalDesktopSettings;
    use super::paths::SettingPath;
    use super::errors::GlobalSettingsError;
    use tokio::sync::broadcast;
    use uuid::Uuid;
    use serde_json::Value as JsonValue;
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct SettingChangedEvent {
        pub event_id: Uuid,
        pub timestamp: DateTime<Utc>,
        pub path: SettingPath,
        pub old_value: Option<JsonValue>, // Kann None sein, wenn der vorherige Wert nicht verfügbar war
        pub new_value: JsonValue,
    }
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct SettingsLoadedEvent { /* ... */ pub settings: GlobalDesktopSettings }
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct SettingsSavedEvent { /* ... */ }
    
    
    #[async_trait::async_trait]
    pub trait GlobalSettingsService: Send + Sync {
        /// Lädt die globalen Einstellungen vom Persistenz-Provider.
        /// Löst ein `SettingsLoadedEvent` aus.
        async fn load_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>;
    
        /// Speichert die aktuellen globalen Einstellungen über den Persistenz-Provider.
        /// Löst ein `SettingsSavedEvent` aus.
        async fn save_settings(&self) -> Result<(), GlobalSettingsError>;
    
        /// Gibt einen Klon der aktuell geladenen `GlobalDesktopSettings` zurück.
        async fn get_current_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>;
    
        /// Aktualisiert einen spezifischen Einstellungswert über seinen `SettingPath`.
        /// Validiert den neuen Wert.
        /// Löst ein `SettingChangedEvent` aus und persistiert die Änderungen.
        async fn update_setting(&self, path: SettingPath, new_value: JsonValue) -> Result<(), GlobalSettingsError>;
    
        /// Liest den Wert einer spezifischen Einstellung.
        async fn get_setting_value(&self, path: &SettingPath) -> Result<JsonValue, GlobalSettingsError>;
    
        /// Setzt alle Einstellungen auf ihre Standardwerte zurück.
        /// Löst mehrere `SettingChangedEvent`s aus und persistiert.
        async fn reset_all_settings_to_defaults(&self) -> Result<(), GlobalSettingsError>;
    
        /// Setzt eine spezifische Einstellung auf ihren Standardwert zurück.
        async fn reset_setting_to_default(&self, path: &SettingPath) -> Result<(), GlobalSettingsError>;
    
        /// Abonniert Änderungen an spezifischen Einstellungen oder allen Einstellungen.
        fn subscribe_to_setting_changes(&self) -> broadcast::Receiver<SettingChangedEvent>;
        // fn subscribe_to_settings_loaded_event(...) -> broadcast::Receiver<SettingsLoadedEvent>;
        // fn subscribe_to_settings_saved_event(...) -> broadcast::Receiver<SettingsSavedEvent>;
    }
    ```
    
    - **Publisher von Events**: `DefaultGlobalSettingsService`.
    - **Subscriber von `SettingChangedEvent`**:
        - **Domäne:** `ThemingService` (für Theme-relevante Einstellungen), `WorkspaceManagerService` (für Workspace-bezogene Einstellungen), `NotificationRulesEngine` (für `SettingIsTrue`-Bedingungen), `PowerManagementService` (für Energieeinstellungen).
        - **System:** `system::input` (für Tastatur-Layout, Maus-Sensitivität), `system::compositor::output_management` (für Standard-Auflösung/Skalierung), `system::audio_management` (für Standard-Lautstärke).
        - **UI:** `ui::control_center` (um sich selbst zu aktualisieren), diverse `ui::shell`-Widgets, die Einstellungen direkt darstellen oder verwenden.

**2.2. Nutzung durch die Systemschicht (Ultra-Fein):**

- **`system::compositor::core::state::DesktopState::new(...)`** nimmt `Arc<dyn WindowManagementPolicyService>` und `Arc<dyn WorkspaceManagerService>` als Parameter.
- **`system::compositor::xdg_shell::handlers::XdgShellHandler::new_toplevel()` (für `DesktopState`)**:
    1. Erhält `ToplevelSurface` von Smithay.
    2. Erzeugt eine `DomainWindowIdentifier`.
    3. Ruft `self.workspace_manager_service.get_active_workspace_id().await` (oder eine äquivalente synchrone Methode, wenn im Compositor-Thread).
    4. Ruft `self.window_policy_service.get_initial_window_geometry(domain_id, workspace_id, available_area, ...).await` um die initiale Geometrie und den Zustand zu bestimmen.
    5. Konfiguriert die `ToplevelSurface` entsprechend.
    6. Informiert `self.workspace_manager_service.assign_window_to_workspace(workspace_id, domain_id, ...).await`.
- **`system::dbus_interfaces::notifications_server::FreedesktopNotificationsServer::notify()`**:
    1. Empfängt D-Bus-Parameter.
    2. Konvertiert diese in eine `domain::user_centric_services::notifications_core::types::NotificationInput`-Struktur.
    3. Ruft `self.notification_service_domain_handle.lock().await.post_notification(input).await`.
    4. Konvertiert das Ergebnis (Domain `Uuid`) in eine D-Bus `u32` ID.
- **`system::input::event_dispatcher::process_input_event()` für `InputEvent::GestureSwipeUpdate`**:
    1. Ermittelt die Geste.
    2. Ruft `self.desktop_state.workspace_manager_service.switch_to_next_or_prev_workspace(direction).await`.

**2.3. Nutzung durch die UI-Schicht (Ultra-Fein):**

- **`ui::control_center::appearance_page::AppearancePageModel::new()`**:
    1. Nimmt `Arc<dyn GlobalSettingsService>` und `Arc<dyn ThemingService>` als Parameter.
    2. Abonniert `global_settings_service.subscribe_to_setting_changes()` und `theming_service.subscribe_to_theme_changes()`.
    3. Ruft `global_settings_service.get_current_settings().await` und `theming_service.get_current_theming_configuration().await` sowie `get_available_themes().await`, um den initialen Zustand der UI-Elemente (ComboBoxes für Themes, Switches für Dark Mode etc.) zu füllen.
- **Event-Handler in `AppearancePageModel` für `SettingChangedEvent`**:
    1. Prüft, ob `event.path` für die Appearance-Seite relevant ist.
    2. Aktualisiert das entsprechende UI-Element (z.B. einen `gtk::Switch` für `SettingPath::Appearance(AppearanceSettingPath::PreferDarkTheme)`) mit `event.new_value`.
- **Aktion in `AppearancePageModel` (z.B. Klick auf "Akzentfarbe ändern"):**
    1. Öffnet einen Farbauswahldialog.
    2. Nach Auswahl: `new_color: core::types::Color`.
    3. `current_theming_config = self.theming_service.get_current_theming_configuration().await?;`
    4. `updated_config = current_theming_config.with_new_accent(new_color);`
    5. `self.theming_service.update_theming_configuration(updated_config).await?;` (Löst `ThemeChangedEvent` aus).
- **`ui::shell::workspace_switcher::WorkspaceSwitcherWidget::on_active_workspace_changed_event(event: domain::workspaces::manager::events::ActiveWorkspaceChangedData)`**:
    1. Iteriert über seine `SpaceIconWidget`s.
    2. Setzt den visuellen "aktiv"-Zustand für das Widget, das `event.new_active_id` entspricht.

---

**3. Schnittstelle: Systemschicht (`novade-system`) zu UI-Schicht (`novade-ui`)**

Diese Schnittstelle ist oft ereignisbasiert oder durch von der UI-Schicht gehaltene Handles zu System-Services.

**3.1. Systemereignisse und -zustände (Ultra-Fein):**

- **Fensterinformationen (bereitgestellt durch einen `WindowManagerSystemFacade` Trait, implementiert von einer Struktur, die auf `DesktopState` zugreift):**
    - **Trait `WindowManagerSystemFacade`**:
        
        Rust
        
        ```
        use crate::core::types::RectInt;
        use crate::domain::workspaces::core::types::{WindowIdentifier as DomainWindowIdentifier, WorkspaceId};
        use crate::system::compositor::xdg_shell::types::ManagedWindowPublicState; // Neuer Typ
        
        #[derive(Debug, Clone, Serialize, Deserialize)] // Für UI-Nutzung
        pub struct ManagedWindowPublicState { // Daten, die UI benötigt
            pub domain_id: DomainWindowIdentifier,
            pub app_id: Option<String>,
            pub title: Option<String>,
            pub geometry: RectInt, // Relative Workspace-Koordinaten
            pub workspace_id: Option<WorkspaceId>,
            pub is_mapped: bool,
            pub is_focused: bool, // Bezogen auf den Seat der UI-Shell
            pub is_maximized: bool,
            pub is_fullscreen: bool,
            // Ggf. Icon-Daten oder Name
        }
        
        #[async_trait::async_trait]
        pub trait WindowManagerSystemFacade: Send + Sync {
            /// Gibt eine Liste aller aktuell verwalteten (gemappten) Fenster mit ihren relevanten Zuständen zurück.
            async fn get_all_managed_windows(&self) -> Result<Vec<ManagedWindowPublicState>, SystemFacadeError>;
        
            /// Gibt den Zustand eines spezifischen Fensters zurück.
            async fn get_window_state(&self, id: &DomainWindowIdentifier) -> Result<Option<ManagedWindowPublicState>, SystemFacadeError>;
        
            /// Fordert den Fokus für ein bestimmtes Fenster an.
            async fn request_focus(&self, id: &DomainWindowIdentifier) -> Result<(), SystemFacadeError>;
        
            /// Fordert das Schließen eines Fensters an (sendet Close-Request an Client).
            async fn request_close_window(&self, id: &DomainWindowIdentifier) -> Result<(), SystemFacadeError>;
        
            // Weitere Aktionen: request_minimize, request_maximize, request_move_to_workspace etc.
        
            /// Abonniert Änderungen an Fensterzuständen.
            fn subscribe_to_window_changes(&self) -> tokio::sync::broadcast::Receiver<WindowSystemEvent>;
        }
        
        #[derive(Debug, Clone)] // System-intern oder für UI, Serialize/Deserialize falls nötig
        pub enum WindowSystemEvent {
            WindowCreated(ManagedWindowPublicState),
            WindowClosed(DomainWindowIdentifier),
            WindowUpdated(ManagedWindowPublicState), // Geometrie, Titel, Fokus etc. geändert
            FocusChanged(Option<DomainWindowIdentifier> /* neues Fokusfenster */, Option<DomainWindowIdentifier> /* altes Fokusfenster */),
        }
        // SystemFacadeError definieren
        ```
        
    - **Implementierung:** Eine Struktur in `novade-system` implementiert diesen Trait. Sie greift auf `system::compositor::core::DesktopState` (via `Arc<Mutex<...>>` oder `LoopHandle::insert_idle`) zu, um die Daten der `ManagedWindow`s zu lesen und in `ManagedWindowPublicState` zu transformieren. Sie publiziert `WindowSystemEvent`s über den `SystemEventBridge`.
- **Eingabeereignisse:** Werden nicht direkt als Rust-Strukturen an die UI-Schicht gesendet. Stattdessen:
    - **Wayland-Protokoll:** Der `system::compositor` sendet `wl_keyboard.key`, `wl_pointer.motion`, `wl_touch.down` etc. an die Wayland-Oberflächen der UI-Elemente (GTK-Fenster). GTK4 (`gdk::Display`) empfängt diese Wayland-Events und übersetzt sie in GTK-Events (`GdkEvent`), die dann von Widgets verarbeitet werden.
    - **Spezielle Aktionen:** Globale Hotkeys oder Gesten, die nicht an ein spezifisches Fenster gebunden sind (z.B. `Super+Space` für Command Palette, Workspace-Switch-Gesten), werden vom `system::input` erkannt. Der `system::input` kann dann direkt eine Domänenaktion auslösen (z.B. `domain::command_palette_service::show()`) oder ein spezifisches `SystemLayerEvent` über den `SystemEventBridge` senden, das von der UI-Shell abonniert wird.
- **Status von Systemdiensten:**
    - `system::dbus_interfaces::upower_client::UPowerClientService` publiziert `UPowerEvent`s über den `SystemEventBridge`.
    - Die UI (z.B. `ui::shell::PowerIndicatorWidget`) abonniert `SystemLayerEvent::UPower` vom `SystemEventBridge`.
    - Bei Empfang: `match event { SystemLayerEvent::UPower(UPowerEvent::DeviceChanged(path)) => { let details = block_on(self.upower_client_facade.get_device_details_by_path(path)); /* UI aktualisieren */ } ... }`

**3.2. Ausführung von UI-Befehlen (Ultra-Fein):**

- **UI-Schicht (`ui::shell::window_title_bar::CloseButton::on_clicked`)**:
    1. Ruft `self.window_manager_facade.request_close_window(self.associated_window_id).await;`.
- **Systemschicht (`DefaultWindowManagerSystemFacade::request_close_window`)**:
    1. Sperrt `DesktopState`.
    2. Findet das `ManagedWindow` (als `Arc<smithay::desktop::Window>`) für die `DomainWindowIdentifier`.
    3. Wenn `WindowSurface::Toplevel(toplevel)`: `toplevel.send_close();`.
    4. (Der Client sollte dann unmappen; `XdgShellHandler::unmap_toplevel` wird ausgelöst).
- **UI-Schicht (`ui::control_center::display_page::ApplyButton::on_clicked`)**:
    1. Sammelt neue Monitorkonfiguration (`Vec<MonitorConfigUiData>`).
    2. Konvertiert zu `Vec<system::output_management::types::OutputConfigRequestData>`.
    3. Ruft `self.output_management_facade.apply_output_configuration(requests).await;`.
- **Systemschicht (`DefaultOutputManagementFacade::apply_output_configuration`)**:
    1. Interagiert mit `system::compositor::output_management` (oder `DesktopState`), um `wlr-output-management` Protokoll-Requests zu senden oder direkt DRM-Modi zu setzen.

---

**Zusammenfassende Prinzipien der Schnittstellen (Ultra-Fein):**

1. **Typsicherheit und explizite Datenstrukturen:** Alle über Schnittstellen ausgetauschten Daten (Parameter, Rückgabewerte, Event-Payloads) sind explizit definierte Rust-`struct`s oder `enum`s. Primitive Typen werden verwendet, wo angemessen, aber für komplexere Daten werden spezifische Typen bevorzugt.
2. **Trait-basierte Service-Abstraktion:** Domänen- und Systemdienste, die von höheren Schichten genutzt werden, implementieren `#[async_trait::async_trait]` Traits. Dies ermöglicht Mocking für Tests und Flexibilität bei Implementierungsänderungen. Handles zu diesen Services sind typischerweise `Arc<dyn ServiceTrait>`.
3. **Granulare Events:** Events sind spezifisch und enthalten alle notwendigen Daten, um Subscribern eine sinnvolle Reaktion zu ermöglichen, ohne zusätzliche Abfragen tätigen zu müssen (außer bei Bedarf für sehr große Datenmengen). Jedes Event hat eine eindeutige ID (`Uuid`) und einen Zeitstempel (`DateTime<Utc>`).
4. **Fehler-Wrapping und -Kontext:** Fehler werden über Schichten hinweg mit `#[from]` oder `#[source]` gewrappt, um die ursprüngliche Ursache nachvollziehbar zu halten. Fehlertypen enthalten kontextspezifische Informationen (z.B. Pfade, IDs).
5. **Asynchronität für potenziell blockierende Operationen:** Alle Operationen, die I/O beinhalten oder länger dauern könnten (insbesondere in Domänen- und Systemschicht-APIs), sind `async`. Die UI-Schicht verwendet `tokio::spawn` oder `glib::MainContext::spawn_local` um diese `async` Funktionen aufzurufen, ohne die UI zu blockieren.
6. **Threadsicherheit:** Geteilter Zustand in Service-Implementierungen wird mit `Arc<tokio::sync::Mutex<...>>` oder `Arc<tokio::sync::RwLock<...>>` geschützt.
7. **Kommunikation mit dem Compositor-Thread:** Operationen, die direkten Zugriff auf `DesktopState` (oder andere nicht-`Send` Smithay-Strukturen) benötigen und von `async` Kontexten außerhalb des Compositor-`calloop`-Threads ausgelöst werden, müssen sorgfältig gehandhabt werden:
    - **Option A (Bevorzugt für kurze Operationen):** `LoopHandle::insert_idle()` oder `LoopHandle::send_event()` um eine Funktion/einen Task im `calloop`-Thread auszuführen.
    - **Option B (Für komplexe Interaktionen):** Dedizierte `mpsc` oder `oneshot` Kanäle zwischen `async` Tasks und dem Compositor-Thread.
    - **Option C (Wenn Daten `Send` sind):** `Arc<Mutex<TeilVonDesktopState>>`, wobei der Mutex `parking_lot::Mutex` sein kann für blockierende Operationen aus dem Compositor-Thread und `tokio::sync::Mutex` für `async` Tasks.

Diese ultra-feingranulare Definition der Schnittstellen ist der Schlüssel zu einer disziplinierten Entwicklung. Jede Interaktion ist spezifiziert, was die Integration der Schichten erleichtert und die Testbarkeit verbessert.

**1. Schnittstelle: Kernschicht (Core Layer) zu höheren Schichten**

- **1.1.1. `core::types` Schnittstelle:**
    - **Exakte Typdefinitionen referenzieren:** Verlinken Sie oder wiederholen Sie die exakten Rust-Definitionen von `Point<T>`, `Size<T>`, `Rect<T>`, `RectInt`, `Color`, `Orientation` aus `A1 Kernschicht.md` / `1. Core-Details.md` / `Infrastruktur ( UI fehlt).md`. Inklusive aller abgeleiteten Traits (`Debug`, `Clone`, `Serialize`, etc.) und implementierten Methoden mit Signaturen.
    - **Nutzungsbeispiele präzisieren:** "Domänenschicht verwendet `Color` für `TokenValue::Color(String)` und `AccentColor.value: CoreColor`."
- **1.1.2. `core::errors` Schnittstelle:**
    - **Exakte Fehlerdefinition referenzieren:** Verlinken oder wiederholen Sie die Definition von `CoreError` und `ColorParseError` aus `A2 Kernschicht.md` / `A3 Kernschicht Fehlerbehandlung.md` / `A4 Kernschicht.md`. Inklusive aller Varianten, `#[error(...)]`-Attribute und `#[source]` / `#[from]`-Annotationen.
    - **Fehler-Wrapping-Regel:** "JEDE höhere Schicht, die eine Funktion aus der Kernschicht aufruft, die `Result<_, CoreError>` (oder einen spezifischeren Kernfehler wie `ConfigError`) zurückgibt, MUSS diesen Fehler entweder:
        - Explizit behandeln (match).
        - Oder in ihren eigenen Fehlertyp wrappen. Diese Wrapper-Variante in den höheren Schichten MUSS `#[from] CoreError` oder `#[source] source: CoreError` verwenden, um die Fehlerkette zu erhalten."
- **1.1.3. `core::logging` Schnittstelle:**
    - **Exakte Signatur:** `pub fn initialize_logging(level_filter: tracing::LevelFilter, format: LogFormat) -> Result<(), LoggingError>` (aus `A4 Kernschicht.md`). Die Enums `LogFormat` und `LoggingError` MÜSSEN hier ebenfalls exakt definiert werden.
    - **Verwendungsrichtlinie:** "Alle Module in allen Schichten MÜSSEN die Makros `tracing::{trace, debug, info, warn, error}` für Logging verwenden. Sensible Daten DÜRFEN NICHT geloggt werden."
- **1.1.4. `core::config` Schnittstelle:**
    - **Exakte Signaturen und Strukturen referenzieren:** `load_core_config(...) -> Result<CoreConfig, ConfigError>`, `get_global_core_config() -> &'static CoreConfig`, `initialize_global_core_config(config: CoreConfig) -> Result<(), ConfigError>` (aus `A4 Kernschicht.md`). Die Struktur `CoreConfig` (und alle ihre Unterstrukturen wie `LogLevelConfig`, `FeatureFlags`) und der `ConfigError`-Enum MÜSSEN hier exakt spezifiziert werden.
    - **Suchreihenfolge für `load_core_config`:** (Wie in meiner vorherigen Analyse vorgeschlagen) "1. `custom_path` (falls `Some`), 2. `$XDG_CONFIG_HOME/novade/core.toml`, 3. `/etc/novade/core.toml`. Wenn keine Datei gefunden wird, wird `ConfigError::NoConfigurationFileFound` zurückgegeben. Die aufrufende Schicht (typischerweise beim Anwendungsstart) MUSS dann `CoreConfig::default()` verwenden und dies loggen."
- **1.1.5. `core::utils` Schnittstelle:**
    - Für JEDE geplante Utility-Funktion: Exakte Signatur, Parameter, Rückgabetyp (`Result<_, UtilityXYError>`), Vor-/Nachbedingungen und eine kurze Beschreibung ihrer Logik. Jede `UtilityXYError` muss definiert sein.

**2. Schnittstelle: Domänenschicht (Domain Layer) zu System- und UI-Schicht**

Hier wird es komplexer, da die Domänenschicht viele Services bereitstellt.

- **Für jeden Domänen-Service-Trait (z.B. `ThemingEngine`, `WorkspaceManagerService`, `AIInteractionLogicService`, `NotificationService`, `GlobalSettingsService`, `WindowManagementPolicyService`):**
    
    - **Exakte Trait-Definition:** Alle Methoden mit exakten Signaturen (`async fn ...`), Parameter-Typen (die bereits in `core::types`, `domain::shared_types` oder den `types.rs` des jeweiligen Domänenmoduls definiert sein müssen) und Rückgabetypen (`Result<OkTyp, DomänenModulFehlerTyp>`).
    - **Datenstrukturen der API:** Alle Structs und Enums, die in den Methodensignaturen als Parameter oder Rückgabewerte verwendet werden (z.B. `AppliedThemeState`, `WorkspaceWindowLayout`, `AIInteractionContext`, `NotificationInput`), MÜSSEN exakt definiert werden (Felder, Typen, Ableitungen). Verweisen Sie auf die Moduldokumente (B1-B4, "2. Domain-Details.md").
    - **Events von diesem Service:**
        - Für jeden Event-Typ (z.B. `ThemeChangedEvent`, `WorkspaceEvent::WorkspaceCreated`, `NotificationEventEnum::NotificationPosted`): Die exakte Payload-Struktur muss definiert sein.
        - **Event-Bus-Spezifikation:** "Jeder Domänen-Service, der Events publiziert, hält einen `tokio::sync::broadcast::Sender<EventType>`. Die `subscribe_to_xxx_events()`-Methode des Services gibt einen `tokio::sync::broadcast::Receiver<EventType>` zurück. Die Kapazität des Broadcast-Kanals wird beim Erstellen des Service festgelegt (z.B. `new(..., broadcast_capacity: usize)`)."
    - **Fehlertypen dieses Services:** Der spezifische Fehler-Enum des Domänenmoduls (z.B. `ThemingError`, `WorkspaceManagerError`) MUSS hier als Teil der Schnittstelle explizit genannt werden.
    - **Beispielhafte Nutzung durch System-/UI-Schicht präzisieren:**
        - "Systemschicht: Der `system::mcp_client::service::DefaultSystemMcpService` ruft `ai_interaction_service.get_consent_status_for_interaction(...)` auf. Der zurückgegebene `AIInteractionError` wird in einen `SystemMcpError::DomainInteractionFailed` gewrappt."
        - "UI-Schicht: Das `ui::shell::PanelWidget` (oder dessen Submodule) abonniert `ThemingEngine::subscribe_to_theme_changes()` und erhält `ThemeChangedEvent`. Bei Empfang wird `ui::theming_gtk::apply_resolved_tokens(event.new_state.resolved_tokens)` aufgerufen."
- **Spezifische Ultra-Feinspezifikation für `domain::user_centric_services::notification_service_impl` und `core::config::loader` (aus Ihrem Plan):**
    
    - Diese Detailtiefe ist exzellent und genau das, was für _alle_ Module und deren öffentliche APIs (und internen, wenn für die Schnittstelle relevant) benötigt wird. Ihr Plan, dies für ausgewählte Module zu tun, ist gut. Dieser Detailgrad muss auf die _Schnittstellenbeschreibung zwischen den Schichten_ erweitert werden.
    - **Inkonsistenz-Beispiel und Lösung im Plan:**
        - `notification_api.rs` definiert `replaces_id: Option<NotificationId>` für `post_notification`.
        - Die D-Bus-Schnittstelle (`notification_dbus_service.rs`) nimmt `replaces_id_dbus: u32`.
        - Die Schnittstellendokumentation muss das **Mapping** spezifizieren: "Der `system::dbus::notification_dbus_service` MUSS `replaces_id_dbus: u32` in `Option<NotificationId>` für den Aufruf von `NotificationService::post_notification` umwandeln. Wenn `replaces_id_dbus == 0`, dann ist das Ergebnis `None`. Andernfalls MUSS der `IdMapper` konsultiert werden, um die `u32` in eine `NotificationId` (Uuid) zu konvertieren. Wenn keine Uuid für die `u32` existiert, ist dies ein `NotificationDBusError::InvalidReplacesId`."
        - Ähnlich für die Rückgabe der neuen `NotificationId` (Uuid) als `u32` D-Bus-ID.

**3. Schnittstelle: Systemschicht (System Layer) zu Benutzeroberflächenschicht (UI Layer)**

- **Für jede von der Systemschicht bereitgestellte Information/Funktion:**
    - **Exakter API-Aufruf (oft ein Trait, den die Systemschicht implementiert und die UI-Schicht nutzt) oder Event:**
        - **Fensterinformationen:** `system::compositor_facade::CompositorViewService::get_visible_windows_for_space(space_id: WorkspaceId) -> Result<Vec<WindowViewData>, SystemError>`. Die Struktur `WindowViewData { id: DomainWindowIdentifier, title: String, app_id: ApplicationId, rect: RectInt, has_focus: bool, decoration_mode: DecorationMode }` muss definiert sein.
        - **Eingabeereignisse:** "Die UI-Schicht registriert Callback-Handler bei `system::input::InputManager::register_keyboard_event_handler(Box<dyn Fn(KeyEventData) + Send>)`. Die Struktur `KeyEventData { keysym: u32, utf8: Option<String>, modifiers: ModifiersState, state: KeyState }` muss definiert sein." (Alternativ: Systemschicht sendet Events über den `SystemEventBridge`).
        - **Status von Systemdiensten:** Z.B. `system::dbus::upower_client_service::UPowerService::get_current_power_state() -> Result<PowerStateData, SystemError>`.
    - **Fehlertypen:** Jeder Service der Systemschicht, den die UI aufruft, gibt einen spezifischen Systemfehler zurück.
    - **Event-Strukturen und Event-Bus:** Wenn die Systemschicht Events an die UI sendet (z.B. `OutputConfigurationChangedEvent`), müssen diese Events und der Bus spezifiziert werden (wahrscheinlich der `SystemEventBridge`).

**4. Allgemeine Kommunikationsmuster (aus Ihrem Plan)**

Diese sind gut, aber müssen für die KI konkretisiert werden:

- **Synchrone Aufrufe:** Nur innerhalb eines Threads oder wenn der aufgerufene Code garantiert nicht blockiert. Für schichtübergreifende Aufrufe selten, außer für einfache Getter auf bereits gecachte/gehaltene Daten.
- **Asynchrone Operationen:** Alle schichtübergreifenden Aufrufe, die I/O oder potenziell längere Berechnungen beinhalten, MÜSSEN `async` sein und `Result<_, _>` zurückgeben.
- **Event-Broadcasting:** Der `SystemEventBridge` (für System-interne und System-zu-UI Events) und die `tokio::sync::broadcast`-Kanäle in Domänen-Services sind die festgelegten Mechanismen.
    - _Spezifizieren:_ Welche Events werden von welchem Modul über welchen Sender/Kanal gesendet? Wer sind die erwarteten Subscriber?
- **Fehlerpropagation:** Die Regel "Die `source()`-Kette MUSS erhalten bleiben" ist kritisch.

**Inkonsistenzen erkennen und beheben durch diesen detaillierten Plan:**

Indem Sie jede Schnittstelle so detailliert definieren, werden Inkonsistenzen aufgedeckt:

1. **Typ-Mismatch:** Wenn `domain::theming` eine `core::types::Color` erwartet, aber `ui::control_center` versucht, einen `String` zu senden, wird dies beim Definieren der `GlobalSettingsService::update_setting`-Signatur und der `SettingPath`-Logik klar.
2. **Fehlende Fehlerbehandlung:** Wenn eine Funktion `Result` zurückgibt, aber die aufrufende Schicht den `Err`-Fall nicht behandelt oder nicht in ihren eigenen Fehlertyp mapped, wird dies beim Definieren des Fehler-Mappings auffallen.
3. **Semantische Unterschiede:** (Wie beim `replaces_id`-Beispiel oben) Die D-Bus-Spezifikation verwendet `u32`, die Domäne `Option<Uuid>`. Die Schnittstellendefinition muss die Transformation explizit machen.
4. **Fehlende Daten:** Wenn die UI-Schicht eine bestimmte Information zum Darstellen eines Fensters benötigt (z.B. "minimiert"-Status), aber die von `system::compositor` bereitgestellte `WindowViewData`-Struktur dieses Feld nicht enthält, wird die Lücke offensichtlich.
5. **Unklare Verantwortlichkeiten für Zustandsänderungen:** Wenn sowohl die Domäne als auch die Systemschicht versuchen, denselben Zustand zu modifizieren, ohne klare Koordination, wird dies bei der Definition der API-Aufrufe und Event-Flüsse sichtbar.
# Detaillierte Analyse und Implementierungsstrategien für die Systemschicht von NovaDE

Dieser Bericht analysiert die Kernkomponenten der Systemschicht (novade-system) der Linux-Desktop-Umgebung NovaDE. Er fokussiert auf bewährte Verfahren, typische Fallstricke und Lösungen für potenzielle Implementierungsprobleme unter Verwendung der spezifizierten Technologien wie Smithay, libinput, zbus und PipeWire.

## 1. Smithay Compositor-Entwicklung (system::compositor)

Die Entwicklung eines Wayland-Compositors mit Smithay erfordert eine sorgfältige Planung des Zustandsmanagements, der Fensterrepräsentation und der Protokollimplementierungen.

### 1.1. Zustandsmanagement in `DesktopState`

Die `DesktopState`-Struktur ist das Herzstück des Compositors und implementiert eine Vielzahl von Smithay-Handler-Traits (z.B. `CompositorHandler`, `XdgShellHandler`, `ShmHandler`, `SeatHandler`). Dies birgt die Gefahr, dass `DesktopState` zu einem "God Object" mit übermäßiger Komplexität wird.1

**Best Practices zur Strukturierung:**

- **Modularisierung durch Komposition:** Anstatt alle Logik direkt in `DesktopState` zu implementieren, sollten spezialisierte Sub-Strukturen für zusammengehörige Funktionalitäten verwendet werden. Beispielsweise könnte eine `XdgShellState` die Logik für `xdg_shell` kapseln und von `DesktopState` referenziert werden. Smithay selbst fördert diesen Ansatz durch spezifische Zustandsstrukturen für viele Protokolle (z.B. `smithay::wayland::shell::xdg::XdgShellState`, `smithay::wayland::seat::SeatState`).2
- **Trait-basierte Abstraktion:** Für komplexe, wiederverwendbare Logik innerhalb der Handler können eigene Traits definiert und von `DesktopState` oder dessen Sub-Strukturen implementiert werden.
- **Klare Verantwortlichkeiten:** Jeder Handler-Trait sollte primär für die Interaktion mit dem entsprechenden Wayland-Protokoll zuständig sein. Anwendungslogik, die darüber hinausgeht (z.B. spezifische Fensterverwaltungsregeln), sollte in separate Module ausgelagert und von den Handlern aufgerufen werden.

**Strategien zur Verwaltung von `Arc<Mutex/RwLock<...>>`:**

Der Zugriff auf geteilte Zustände innerhalb der asynchronen Handler-Methoden erfordert Synchronisation. `Arc<Mutex<T>>` oder `Arc<RwLock<T>>` sind hierfür gängige Muster in Rust.4

- **Granularität der Locks:** Sperren sollten so feingranular wie möglich gehalten werden, um Contention zu minimieren. Anstatt den gesamten `DesktopState` zu sperren, sollten nur die tatsächlich benötigten Teile des Zustands gesperrt werden.
- **`RwLock` bevorzugen:** Für Zustände, die häufig gelesen und selten geschrieben werden, ist `RwLock` performanter als `Mutex`, da es mehrere gleichzeitige Leser erlaubt.
- **Vermeidung von Deadlocks:** Besondere Vorsicht ist bei verschachtelten Locks oder dem Aufruf von externem Code (z.B. Client-Callbacks) innerhalb eines Locks geboten. Die Reihenfolge der Lock-Akquirierung sollte konsistent sein.
- **Kurze Lock-Dauer:** Locks sollten nur so lange wie unbedingt nötig gehalten werden. Operationen, die außerhalb des kritischen Abschnitts durchgeführt werden können, sollten dies auch tun.

Smithay selbst empfiehlt, einen zentralen, mutablen Zustand über `calloop` an die Callbacks zu übergeben, was die Notwendigkeit von `Arc<Mutex<T>>` für den Hauptzustand reduzieren kann, da Callbacks sequenziell ausgeführt werden.6 Für Zustände, die von nebenläufigen Tasks (z.B. D-Bus-Handler in Tokio) modifiziert werden und vom Compositor-Thread gelesen werden müssen, bleiben `Arc<Mutex/RwLock<T>>` jedoch relevant.

**Beispiel (konzeptionell):**

Rust

```
pub struct DesktopState {
    pub compositor_state: smithay::wayland::compositor::CompositorState,
    pub xdg_shell_state: smithay::wayland::shell::xdg::XdgShellState,
    pub seat_state: smithay::wayland::seat::SeatState<Self>,
    pub space: Arc<Mutex<smithay::desktop::Space<smithay::desktop::Window>>>,
    //... weitere Zustands-Subkomponenten
}

// Implementierung der Handler-Traits für DesktopState,
// die oft auf die Sub-Zustände delegieren.
// smithay::delegate_compositor!(DesktopState);
// smithay::delegate_xdg_shell!(DesktopState);
//...
```

Die `delegate_*!` Makros von Smithay sind essentiell, um die Implementierung der Handler-Traits an die entsprechenden Zustandsstrukturen zu delegieren und Boilerplate-Code zu reduzieren.2

### 1.2. `ManagedWindow` und `smithay::desktop::Space`

`ManagedWindow` ist eine Abstraktion über Wayland-Fenster (XDG Toplevels, Popups) und XWayland-Fenster. Es implementiert das `smithay::desktop::Window`-Trait.

**Korrekte Implementierung des `Window`-Traits:**

Das `smithay::desktop::Window`-Trait 9 erfordert die Implementierung verschiedener Methoden, um die Eigenschaften und das Verhalten eines Fensters zu definieren:

- `bbox()`: Gibt die Bounding Box des Fensters inklusive aller Subsurfaces und Popups zurück.
- `is_wayland()` / `is_x11()`: Unterscheidet zwischen Wayland- und X11-Fenstern.
- `toplevel()`: Gibt eine Referenz auf die zugrundeliegende `ToplevelSurface` (für XDG-Fenster) zurück.
- `send_frame()`: Sendet Frame-Callbacks an die Oberflächen des Fensters.
- `surface_under()`: Findet die Oberfläche unter einem gegebenen Punkt.
- `set_activated()`: Setzt den Aktivierungszustand des Fensters.
- `geometry()`: Gibt die Kerngeometrie des Fensters zurück (ohne Dekorationen).
- `on_commit()`: Wird aufgerufen, wenn die zugrundeliegende Oberfläche einen Commit durchführt.

**Repräsentation von Fenstergeometrien und -zuständen:**

- **Geometrie:** Die Geometrie (`Rectangle<i32, Logical>`) wird typischerweise direkt in der `ManagedWindow`-Struktur gespeichert und bei `configure`-Events vom Client oder durch Aktionen des Compositors aktualisiert. Sie repräsentiert die von der Anwendung gewünschte Größe und Position des Fensterinhalts.
- **Zustände (maximiert, aktiv, etc.):** Diese Zustände sollten ebenfalls in `ManagedWindow` gespeichert werden (z.B. als Booleans oder Enums).
    - Der **maximierte Zustand** wird durch Anfragen des Clients (z.B. `xdg_toplevel::set_maximized`) oder Aktionen des Compositors gesetzt. Die tatsächliche Geometrie wird dann vom Compositor basierend auf dem verfügbaren Platz des Outputs angepasst.
    - Der **aktive Zustand** wird vom Compositor verwaltet (typischerweise im `SeatHandler` in Reaktion auf Benutzereingaben) und an das Fenster propagiert (z.B. über `Window::set_activated(true)`).
- **Dekorationen (CSD/SSD via `xdg-decoration`):**
    - Das `xdg-decoration-unstable-v1`-Protokoll ermöglicht die Aushandlung zwischen Client-Side Decorations (CSD) und Server-Side Decorations (SSD).12
    - `ManagedWindow` (oder eine assoziierte Struktur) muss den ausgehandelten Dekorationsmodus (`zxdg_toplevel_decoration_v1::mode`) speichern.
    - Wenn SSD aktiv ist, ist der Compositor für das Zeichnen der Dekorationen verantwortlich. `ManagedWindow` sollte Informationen bereitstellen, die für das Rendern der SSDs benötigt werden (z.B. Titel, aktive/inaktive Zustände).
    - Wenn CSD aktiv ist, zeichnet der Client die Dekorationen selbst. Der Compositor muss die Geometrie des Fensters entsprechend berücksichtigen.
    - Die `XdgDecorationState` und `XdgDecorationHandler` von Smithay helfen bei der Implementierung dieses Protokolls.15 Die `XdgDecorationHandler::request_mode` und `new_decoration` Methoden sind hierbei zentral. Der Server (Compositor) sendet `configure`-Events an den `zxdg_toplevel_decoration_v1`, um den Modus festzulegen. Der Client antwortet mit `set_mode` oder `unset_mode`.

**Synchronisation mit `XdgToplevelSurfaceData`:**

`XdgToplevelSurfaceData` 3 speichert den Zustand, der spezifisch für eine `xdg_toplevel`-Oberfläche ist (z.B. angeforderte Größe, Zustände wie maximiert, minimiert, fullscreen, App-ID, Titel).

- Wenn der Client Zustandsänderungen anfordert (z.B. `set_title`, `set_maximized`), werden diese im `XdgToplevelSurfaceData` (oft im `pending_state`) gespeichert.
- Bei einem `wl_surface.commit` werden diese Änderungen durch den `XdgShellHandler` verarbeitet.
- Die Logik im `XdgShellHandler` (oder in `ManagedWindow::on_commit`) muss dann den Zustand von `ManagedWindow` mit den Daten aus `XdgToplevelSurfaceData` synchronisieren. Beispielsweise wird ein `xdg_toplevel.set_maximized` im `XdgToplevelSurfaceData` vermerkt, und der Compositor entscheidet dann, ob und wie er das Fenster maximiert und sendet entsprechende `configure`-Events. Die `send_configure`-Methode auf `ToplevelSurface` ist hierbei zentral, um dem Client die neue Konfiguration mitzuteilen.20 Der Client muss diese Konfiguration mit `ack_configure` bestätigen.

**Interaktion mit `Space`:**

Der `smithay::desktop::Space` 9 verwaltet die Anordnung von Fenstern und anderen Elementen im 2D-Raum.

- `Space::map_window(window, location, activate)`: Fügt ein `ManagedWindow` zum `Space` an einer bestimmten `location` hinzu und legt die Stapelreihenfolge fest. `activate` gibt an, ob das Fenster aktiviert werden soll.
- `Space::unmap_window(window)`: Entfernt ein Fenster aus dem `Space`.
- `Space::raise_window(window, activate)`: Bringt ein Fenster in der Stapelreihenfolge nach vorne.
- **Schadensverfolgung (Damage Tracking):**
    - `Space::damage_window(window, new_damage, old_damage)`: Wird verwendet, um dem `Space` mitzuteilen, dass sich Bereiche eines Fensters geändert haben. `new_damage` sind die beschädigten Regionen in Fensterkoordinaten. `old_damage` kann verwendet werden, wenn sich die Position oder Größe des Fensters geändert hat.
    - `Space::damage_output(output, damage)`: Markiert einen Bereich auf einem bestimmten Output als beschädigt.
    - Wenn ein Client einen neuen Puffer committet (`wl_surface.commit`), wird die `SurfaceAttributes.damage`-Region aktualisiert.26 Der Compositor muss diese Information dann an den `Space` weiterleiten, typischerweise über `damage_window`.
    - `render_output` verwendet die akkumulierten Schadensinformationen, um nur die notwendigen Bereiche eines Outputs neu zu zeichnen und so die Performance zu optimieren.9

### 1.3. Wayland Protokoll-Implementierung (spezifisch)

**1.3.1. `wlr-output-management-unstable-v1`** 6

Dieses Protokoll ermöglicht Clients (z.B. Display-Konfigurationstools wie `kanshi` 34 oder `wdisplays` 33) das Abfragen und Ändern der Konfiguration von Ausgabegeräten (Heads).

- **`apply` und `test` Requests auf `zwlr_output_configuration_v1`:**
    - Ein Client erstellt ein `zwlr_output_configuration_v1`-Objekt mit einem bestimmten `serial` (erhalten vom `zwlr_output_manager_v1.done`-Event).
    - Auf diesem Konfigurationsobjekt kann der Client Änderungen für einzelne `zwlr_output_head_v1`-Objekte vornehmen (z.B. Modus, Position, Skalierung, Aktivierungsstatus setzen).
    - **`test` Request:** Der Client sendet einen `test`-Request, um die Konfiguration zu validieren, ohne sie anzuwenden. Der Compositor prüft, ob die Konfiguration prinzipiell möglich ist.
    - **`apply` Request:** Der Client sendet einen `apply`-Request, um die Konfiguration anzuwenden.
    - **Antworten des Compositors:** In beiden Fällen (`test` und `apply`) muss der Compositor mit einem der folgenden Events antworten:
        - `succeeded`: Die Konfiguration wurde erfolgreich getestet/angewendet. Der Client sollte das Konfigurationsobjekt zerstören. Wenn die Konfiguration angewendet wurde und sich der Zustand geändert hat, sendet der Manager `head`-Events und ein `done`-Event mit einem neuen Serial.
        - `failed`: Die Konfiguration konnte nicht getestet/angewendet werden (z.B. ungültiger Modus). Der Compositor sollte alle Änderungen, die durch einen `apply`-Request ausgelöst wurden, zurückrollen. Der Client sollte das Konfigurationsobjekt zerstören.
        - `cancelled`: Die Konfiguration wurde vom Compositor abgebrochen, weil sich der Zustand eines Outputs geändert hat und die Informationen des Clients veraltet sind (z.B. durch Hotplugging). Der Client kann eine neue Konfiguration mit einem neueren Serial erstellen und es erneut versuchen. Der Client sollte das Konfigurationsobjekt zerstören.
- **Atomarität und Serial-Nummern:**
    - Der `serial` spielt eine Schlüsselrolle für die Atomarität. Der `zwlr_output_manager_v1` sendet ein `done`-Event mit einem `serial`, nachdem alle aktuellen Zustandsinformationen gesendet wurden.29
    - Der Client muss diesen `serial` beim Erstellen eines `zwlr_output_configuration_v1`-Objekts verwenden. Dies stellt sicher, dass die Konfigurationsänderungen des Clients auf einem aktuellen Stand des Compositor-Zustands basieren.
    - Wenn der Compositor eine Konfiguration mit einem veralteten `serial` erhält, kann er diese mit `cancelled` ablehnen.
    - Die Änderungen innerhalb eines `apply`-Requests sollten atomar angewendet werden. Das bedeutet, entweder alle Änderungen werden erfolgreich übernommen, oder bei einem Fehler wird der Zustand vor dem `apply`-Request wiederhergestellt (Rollback).31
- **Smithay Integration:**
    - Smithays `Output` und `OutputManagerState` 34 verwalten die Eigenschaften von Outputs (Modi, Skalierung, Transformation, aktivierter Zustand) und können diese über `wl_output` und `xdg_output` an Clients bekannt machen.
    - Zur Implementierung von `wlr-output-management` muss ein `OutputHandler` (oder eine ähnliche Logik) die Anfragen des Clients verarbeiten, die Konfigurationen validieren und anwenden und die entsprechenden `succeeded`, `failed` oder `cancelled` Events senden. Der `OutputManagerState` würde die globalen Objekte bereitstellen und die `OutputHandler`-Implementierung würde die spezifischen Anfragen bearbeiten.
    - Die Atomarität erfordert sorgfältiges Zustandsmanagement im Compositor. Bevor eine Konfiguration angewendet wird, sollte der aktuelle Zustand zwischengespeichert werden, um im Fehlerfall ein Rollback durchführen zu können.

**1.3.2. `wlr-output-power-management-unstable-v1`** 30

Dieses Protokoll ermöglicht Clients (typischerweise Desktop-Shells) die Steuerung der Energieverwaltungsmodi (DPMS) von Ausgabegeräten, die Teil des Compositor-Raums sind.

- **Exklusive Kontrolle pro Output (`get_output_power`):**
    - Der Client fordert über `zwlr_output_power_manager_v1::get_output_power` ein `zwlr_output_power_v1`-Objekt für ein bestimmtes `wl_output` an.
    - Der Compositor kann diesen Request ablehnen (und ein `failed`-Event auf dem `zwlr_output_power_v1`-Objekt senden), wenn z.B. der Output kein Power-Management unterstützt oder ein anderer Client bereits exklusive Kontrolle hat.30 Dies impliziert, dass der Compositor den Besitz von Power-Management-Kontrollen pro Output verfolgen muss.
- **Reaktion auf vom Compositor initiierte DPMS-Änderungen:**
    - Das `zwlr_output_power_v1::mode`-Event wird gesendet, wenn sich der Power-Modus eines Outputs ändert. Dies kann durch einen `set_mode`-Request des Clients oder durch eine Entscheidung des Compositors selbst geschehen (z.B. durch Inaktivitäts-Timer).49
    - Wenn der Compositor den DPMS-Zustand eines Outputs ändert (z.B. über `system::power_management`), muss er das `mode`-Event an alle Clients senden, die ein `zwlr_output_power_v1`-Objekt für diesen Output halten.
- **Smithay Integration:**
    - Die `OutputHandler`-Implementierung 6 müsste erweitert werden, um die Anfragen dieses Protokolls zu verarbeiten.
    - Der `OutputManagerState` 36 würde das globale `zwlr_output_power_manager_v1`-Objekt verwalten.
    - Der Zustand (aktueller Power-Modus, exklusive Kontrolle) müsste pro Output im Compositor-Zustand (`DesktopState` oder einer Substruktur) gespeichert werden.

**1.3.3. `wlr-layer-shell-unstable-v1`** 53

Dieses Protokoll erlaubt es Clients, Oberflächen (Layer Surfaces) zu erstellen, die über, unter oder zwischen normalen Fenstern gerendert werden, typischerweise für Panels, Hintergrundbilder, Benachrichtigungen und Sperrbildschirme.

- **Management von `LayerSurface`-Daten:**
    - Für jede `LayerSurface` müssen Informationen wie die gewünschte Schicht (`zwlr_layer_shell_v1::layer`), Anker (`anchor`), exklusive Zone (`exclusive_zone`), Ränder (`margin`) und Interaktivitätseinstellungen (`keyboard_interactivity`) gespeichert werden. Diese Daten sind oft Teil einer `SurfaceData`-ähnlichen Struktur, die mit der `wl_surface` der `LayerSurface` assoziiert ist.
    - Smithays `WlrLayerShellState` und `WlrLayerShellHandler` 59 sind für die Verwaltung dieser Zustände und die Bearbeitung von Client-Anfragen zuständig.
- **Interaktion mit `PopupManager` für Layer-Popups:**
    - `LayerSurface`s können Popups haben (z.B. ein Kalender-Popup von einem Panel). Das `zwlr_layer_surface_v1::get_popup`-Request wird verwendet, um ein `xdg_popup` einer `LayerSurface` zuzuordnen.54
    - Der `smithay::desktop::PopupManager` 9 sollte so erweitert oder verwendet werden, dass er auch Popups von `LayerSurface`s korrekt verwalten und positionieren kann. Dies bedeutet, dass der `PopupManager` die Hierarchie von Popups relativ zu ihren Eltern-`LayerSurface`s verstehen muss.
- **Korrekte Berechnung von exklusiven Zonen:**
    - Eine `LayerSurface` kann eine exklusive Zone anfordern (`set_exclusive_zone`). Dies ist ein Bereich entlang eines oder mehrerer Ränder des Outputs, den andere Oberflächen (insbesondere maximierte Fenster) nicht verdecken sollten.55
    - Der Compositor muss die exklusiven Zonen aller `LayerSurface`s auf einem Output aggregieren. Dies ist besonders wichtig für das `system::window_mechanics`-Modul, um Fenster korrekt zu positionieren und zu maximieren, ohne über Panels oder andere Layer-Elemente zu ragen.
    - Die Berechnung muss die Schicht (`layer`), den Anker und die Ränder der `LayerSurface` berücksichtigen. Ein Wert von -1 für die exklusive Zone bedeutet, dass die Oberfläche nicht verschoben werden soll, auch wenn sie andere exklusive Zonen überlappt.56
    - Die `smithay::desktop::Space`-Logik muss diese exklusiven Zonen bei der Berechnung des verfügbaren Arbeitsbereichs für normale Fenster berücksichtigen.

### 1.4. Renderer-Abstraktion

Eine robuste Renderer-Abstraktion ist entscheidend für Flexibilität und Wartbarkeit. Die Traits `FrameRenderer` und `RenderableTexture` sind hierfür vorgesehen.

- **Robuste Trait-Definitionen:**
    - **`FrameRenderer`:**
        - Sollte Methoden zum Beginnen und Beenden eines Frames bereitstellen.
        - Methoden zum Rendern von `RenderableTexture`s an bestimmten Positionen mit Transformationen (Skalierung, Rotation), Alpha-Blending und Clipping-Regionen.
        - Methoden zum Löschen des Framebuffers oder Teilen davon.
        - Potenziell Methoden zur Verwaltung von Shader-Programmen oder anderen Renderer-spezifischen Ressourcen.
    - **`RenderableTexture`:**
        - Repräsentiert eine Textur, die vom `FrameRenderer` gezeichnet werden kann.
        - Sollte Methoden zum Abrufen der Dimensionen und des Formats der Textur bereitstellen.
        - Muss die zugrundeliegenden Pufferdaten (SHM oder DMABUF) kapseln.
- **Effiziente Pufferübergabe und Texturverwaltung:**
    - **SHM-Puffer:** Für SHM-Puffer (`wl_shm_buffer`) müssen die Pixeldaten in eine GPU-Textur hochgeladen werden. Dies kann bei jedem Frame oder nur bei Änderungen erfolgen.
    - **DMABUF-Puffer:** DMABUFs können oft direkt von der GPU importiert werden, was den Kopiervorgang CPU -> GPU vermeidet. Smithays `DmabufFeedback` und `ImportDma` 60 sind hier relevant.
    - **Textur-Caching:** Um das wiederholte Hochladen identischer Pufferinhalte zu vermeiden, kann ein Textur-Cache implementiert werden. Texturen können anhand eines Identifikators des Puffers (z.B. `wl_buffer`-Objekt-ID oder ein Hash des Inhalts für SHM) zwischengespeichert werden.
    - **Freigabe:** Wenn ein `wl_buffer` vom Client freigegeben wird (`wl_buffer.release`), sollten auch die zugehörigen Texturen im Cache freigegeben oder als wiederverwendbar markiert werden.
- **Kommunikation von Schadensverfolgung (Damage Tracking):**
    - Der Compositor (speziell `DesktopState` oder `Space`) verfolgt die beschädigten Regionen jeder Oberfläche (`wl_surface.damage_buffer` oder `wl_surface.damage_surface`) und des gesamten Outputs.9
    - Diese Schadensinformation (typischerweise eine Liste von Rechtecken) muss an den `FrameRenderer` übergeben werden.
    - Der `FrameRenderer` sollte diese Information nutzen, um nur die beschädigten Bereiche des Framebuffers neu zu zeichnen (z.B. durch Setzen einer Scissor-Region oder durch differenzielles Rendern).
    - Smithay bietet im Modul `smithay::backend::renderer::damage` Hilfsmittel für das Damage Tracking auf Output-Ebene.60 Die `Frame`-Implementierung des Renderers sollte die akkumulierten Schäden berücksichtigen.

**Beispiel (konzeptionelle Trait-Definitionen):**

Rust

```
use smithay::utils::{Point, Rectangle, Scale, Transform};
use smithay::backend::renderer::Renderer; // Basis-Renderer-Trait von Smithay

pub trait RenderableTexture {
    fn width(&self) -> u32;
    fn height(&self) -> u32;
    // Evtl. Methode, um den zugrundeliegenden Puffer-Typ zu identifizieren (SHM, DMABUF)
    // fn buffer_type(&self) -> BufferType;
    // Evtl. Methode, um die Textur-ID für den spezifischen Renderer zu erhalten
    // fn renderer_id(&self) -> RendererTextureId;
}

pub trait FrameRenderer<T: RenderableTexture, R: Renderer> { // R ist der Backend-Renderer von Smithay
    fn begin_frame(&mut self, output_damage: Option<&>) -> Result<(), R::Error>;
    fn render_texture(
        &mut self,
        texture: &T,
        src_rect: Rectangle<f64, smithay::utils::Buffer>, // Quellrechteck auf der Textur
        dst_rect: Rectangle<i32, smithay::utils::Physical>, // Zielrechteck auf dem Framebuffer
        transform: Transform,
        alpha: f32,
        damage: &, // Schaden relativ zur Textur im Ziel-Framebuffer
    ) -> Result<(), R::Error>;
    fn clear(&mut self, color: [f32; 4], region: &) -> Result<(), R::Error>;
    fn finish_frame(&mut self) -> Result<(), R::Error>; // Beinhaltet Swap-Buffers o.ä.
}
```

Die Integration mit Smithays eigenem `Renderer`-Trait und den `RenderElement`-Strukturen 60 ist hierbei zu beachten. Die `FrameRenderer`-Abstraktion könnte auf Smithays `Frame`-Trait aufbauen oder dieses wrappen.

### 1.5. XWayland-Integration

Die Integration von XWayland ermöglicht die Ausführung von X11-Anwendungen in der Wayland-Umgebung.

- **Herausforderungen und Lösungen:**
    - **Starten und Verwalten des XWayland-Prozesses:**
        - Smithays `smithay::xwayland::XWayland::new()` 61 startet den XWayland-Server als Kindprozess. Der Compositor muss die Wayland- und X11-Sockets bereitstellen, über die XWayland kommuniziert.
        - Die `XWayland`-Struktur muss im `DesktopState` gehalten und bei Beendigung des Compositors ordnungsgemäß beendet werden.
    - **X11 Window Manager (`X11Wm`):**
        - Der Compositor muss als X11 Window Manager für die von XWayland erzeugten X11-Fenster agieren. Smithay stellt das `XwmHandler`-Trait und die `X11Wm`-Struktur bereit.61
        - Der `XwmHandler` muss Callbacks implementieren, um auf X11-Ereignisse wie das Erstellen, Zerstören, Konfigurieren und Verschieben von Fenstern zu reagieren.
        - Die `X11Wm`-Instanz verwaltet die Verbindung zum XWayland-Server und die X11-Fenster.
    - **Darstellung von X11-Fenstern (`X11Surface`) im Wayland-Space:**
        - XWayland erstellt für jedes X11-Top-Level-Fenster eine `wl_surface`. Smithays `X11Surface` 61 repräsentiert ein solches Fenster und ist mit der zugrundeliegenden X11-Fenster-ID und der `wl_surface` verbunden.
        - Diese `X11Surface`-Objekte müssen in das `smithay::desktop::Window`-Trait gewrappt und im `smithay::desktop::Space` verwaltet werden, genau wie native Wayland-Fenster.
        - Die Geometrie, Stapelreihenfolge und der Aktivierungszustand von X11-Fenstern müssen zwischen dem X11-Protokoll (via `X11Wm`) und dem Wayland-Space synchronisiert werden. Beispielsweise muss ein `XConfigureWindow`-Request vom `X11Wm` verarbeitet und die Position des `X11Surface` im `Space` entsprechend angepasst werden.
    - **Input-Routing:** Eingabeereignisse (Tastatur, Maus) für X11-Fenster müssen korrekt an XWayland weitergeleitet werden. Dies geschieht, indem der Fokus auf die `wl_surface` des `X11Surface` gesetzt wird. Der `SeatHandler` spielt hier eine wichtige Rolle.
    - **Synchronisation von Fensterzuständen:** Zustände wie Maximierung oder Aktivierung müssen zwischen dem Wayland-Compositor und dem X11-Zustand des Fensters synchron gehalten werden. Der `X11Wm` ist dafür verantwortlich, entsprechende X11-Properties (z.B. `_NET_WM_STATE`) zu setzen oder zu interpretieren.
- **Referenzimplementierungen:** Die Anvil-Demo-Compositor von Smithay enthält eine XWayland-Integration, die als gutes Beispiel dienen kann.6

## 2. Eingabeverarbeitung (system::input)

Die Eingabeverarbeitung ist eine kritische Komponente für die Benutzerinteraktion. NovaDE setzt hier auf `libinput` und `xkbcommon`.

### 2.1. `libinput` und `calloop`

- **Best Practices für die Integration des `LibinputInputBackend` in die `calloop`-Ereignisschleife:**
    - Der `LibinputInputBackend` wird typischerweise als eine `calloop::EventSource` in die `calloop`-Schleife eingefügt.
    - Die `dispatch`-Methode des Backends verarbeitet die anstehenden `libinput`-Events.
    - Um die Schleife nicht zu blockieren, sollte die Verarbeitung der einzelnen Events (z.B. Übersetzung in Wayland-Events, Fokus-Logik) möglichst effizient sein. Langwierige Operationen sollten vermieden oder in separate Tasks ausgelagert werden (obwohl dies im Input-Pfad selten vorkommt).
    - Smithay bietet in `smithay::backend::input` und `smithay::input` Abstraktionen, die die Integration erleichtern.
- **Effiziente Verarbeitung von `libinput`-Events:**
    - Events sollten so früh wie möglich gefiltert werden, wenn sie nicht relevant sind.
    - Die Übersetzung von `libinput`-Events in Wayland-Protokoll-Events sollte direkt und ohne unnötige Allokationen erfolgen.
    - Zustandsänderungen (z.B. Tastatur-Modifier-Status) sollten effizient aktualisiert werden.

### 2.2. `xkbcommon`

`xkbcommon` ist für die Interpretation von Tastatur-Layouts und die Übersetzung von Keycodes in Keysyms und UTF-8-Strings zuständig.

- **Korrekte Initialisierung und Aktualisierung von `xkb::State` pro Tastatur/Seat:**
    - Für jede Tastatur (oder allgemeiner, für jeden `Seat` mit Tastatur-Capability) muss eine eigene `xkb::Context` und `xkb::Keymap` erstellt werden.
    - Aus der `Keymap` wird dann eine `xkb::State` abgeleitet. Diese `XkbKeyboardData` (mit `xkb::State`) wird im `SeatState` gehalten.
    - **Layout-Wechsel:** Bei einem Layout-Wechsel (z.B. durch den Benutzer oder eine Systemkonfiguration) muss die `xkb::Keymap` neu geladen und eine neue `xkb::State` daraus erstellt und aktualisiert werden. Dies erfordert typischerweise die Interaktion mit Systemdiensten, die Layout-Änderungen signalisieren (z.B. über D-Bus).
- **Zuverlässige Implementierung von Modifikatoren und Tastenwiederholung:**
    - **Modifikatoren:** `xkb::State::update_key()` aktualisiert den Zustand der Modifikatoren (Shift, Ctrl, Alt, etc.) basierend auf den gedrückten/losgelassenen Tasten. Der `SeatHandler` muss diesen Zustand verwenden, um korrekte Keysyms und Modifier-Masken an die Clients zu senden.
    - **Tastenwiederholung (Key Repeat):**
        - `libinput` selbst sendet keine Wiederholungsereignisse. Der Compositor muss dies implementieren.
        - Wenn eine Taste gedrückt wird, für die Wiederholung aktiviert ist (konfigurierbar über `xkb::Keymap::key_repeats()`), startet ein Timer.
        - Der Timer wird in `calloop` verwaltet (z.B. `calloop::timer::Timer`).
        - Nach einer initialen Verzögerung (`repeat_delay`) sendet der Timer periodisch (mit `repeat_rate`) Events, die der Compositor als erneute Tastendrücke interpretiert und an den fokussierten Client weiterleitet.
        - Der Timer muss gestoppt werden, wenn die Taste losgelassen wird oder der Fokus wechselt.
        - Die `XkbKeyboardData` in der Spezifikation deutet darauf hin, dass die Konfiguration für die Tastenwiederholung (Rate, Verzögerung) aus `xkbcommon` bezogen wird.

### 2.3. Fokusmanagement

Das Fokusmanagement ist komplex und erfordert eine enge Koordination zwischen `SeatHandler`, `system::input` und `system::window_mechanics`.

- **Detaillierte Logik für `SeatHandler::focus_changed`:**
    - Diese Methode wird vom `Seat` aufgerufen, wenn sich der Fokus ändert.
    - Sie muss den alten und neuen Fokus-Target (typischerweise eine `WlSurface`) an die entsprechenden Clients kommunizieren (z.B. `wl_keyboard::leave`/`enter`, `wl_pointer::leave`/`enter`).
    - Der `SeatHandler` sollte auch den internen Zustand des Compositors aktualisieren (z.B. welches Fenster gerade aktiv ist).
- **Konsistente Handhabung des Fokus zwischen Tastatur, Zeiger und Touch:**
    - **Tastaturfokus:** Folgt typischerweise dem "aktiven Fenster". Ein Klick auf ein Fenster oder eine explizite Aktivierungsanforderung setzt den Tastaturfokus.
    - **Zeigerfokus ("Pointer Focus"):** Folgt der Mausbewegung. Wenn der Zeiger eine neue Oberfläche betritt, erhält diese den Zeigerfokus. Dies löst `wl_pointer::enter` und `wl_pointer::leave` aus.
    - **Touchfokus:** Ist oft an einen bestimmten Touchpunkt (Slot) gebunden. Wenn ein Touchpunkt auf einer Oberfläche landet, erhält diese Oberfläche den Touchfokus für diesen Slot.
    - Die Konsistenz wird dadurch erreicht, dass der `Seat` den Zustand für alle Eingabemethoden hält und der `SeatHandler` die entsprechenden Wayland-Events basierend auf diesem Zustand sendet.
- **Interaktion mit `system::window_mechanics::set_application_focus`:**
    - `set_application_focus` in `system::window_mechanics` ist für die _technische Umsetzung_ des Fokuswechsels zuständig (z.B. Anfordern der Aktivierung eines XDG-Toplevels, Aktualisieren des internen Zustands im `DesktopState`).
    - Der `SeatHandler` (oder die Logik, die Fokusentscheidungen trifft) ruft `set_application_focus` auf, um einen Fokuswechsel zu initiieren.
    - Um Redundanz oder Konflikte zu vermeiden:
        - `SeatHandler::focus_changed` sollte primär für das Senden der Wayland-Protokoll-Events zuständig sein, nachdem der Fokuswechsel _entschieden und technisch umgesetzt_ wurde.
        - Die Entscheidung, welches Fenster den Fokus erhält (z.B. durch Klick), und die Aktivierung dieses Fensters (über `set_application_focus`) sollten vor dem Aufruf von `focus_changed` erfolgen.
- **Finden der korrekten Oberfläche unter dem Zeiger/Touchpunkt (`find_surface_and_coords_at_global_point`):**
    - Diese Funktion ist entscheidend für das korrekte Routing von Zeiger- und Touch-Events.
    - Sie muss die Fenster im `smithay::desktop::Space` in umgekehrter Stapelreihenfolge (von oben nach unten) durchlaufen.
    - Für jedes Fenster muss geprüft werden, ob der globale Punkt innerhalb seiner Bounding Box liegt.
    - Anschließend muss der Punkt in die Koordinaten der Fensteroberfläche transformiert werden.
    - `smithay::desktop::Window::surface_under()` kann verwendet werden, um die spezifische `WlSurface` (inkl. Subsurfaces und Popups) unter dem lokalen Punkt zu finden.
    - **Eingaberegionen (`wl_surface.set_input_region`):** Die Eingaberegion einer Oberfläche definiert, welche Teile der Oberfläche auf Eingaben reagieren. `surface_under` muss dies berücksichtigen. Nur wenn der Punkt innerhalb der Eingaberegion liegt, gilt die Oberfläche als getroffen.
    - **Stapelreihenfolge:** Die Iteration durch die Fenster im `Space` muss die korrekte z-Ordnung beachten, um sicherzustellen, dass die oberste sichtbare Oberfläche an diesem Punkt ausgewählt wird. `smithay::desktop::Space::elements_under()` kann hierfür nützlich sein.

### 2.4. Gesten

Die Implementierung robuster Gestenerkennung (Pinch, Swipe) auf Basis von `libinput`-Events ist eine fortgeschrittene Aufgabe.

- **Ansätze:**
    - **Direkte Verarbeitung von `libinput`-Gestenereignissen:** `libinput` selbst erkennt bereits einige grundlegende Gesten (z.B. `GesturePinchEvent`, `GestureSwipeEvent`). Diese Events enthalten Informationen wie Skalierungsfaktor, Winkeländerung (Pinch) oder Verschiebungsvektoren (Swipe).
        - Der `LibinputInputBackend` leitet diese Events an den Compositor weiter.
        - Der Compositor muss diese Events interpretieren und in höherwertige Aktionen oder Wayland-Protokoll-Events (z.B. über `zwp_pointer_gestures_v1`) umwandeln.
    - **Eigene Gestenerkennung:** Für komplexere oder benutzerdefinierte Gesten, die `libinput` nicht direkt bereitstellt, müsste der Compositor eine eigene Gestenerkennungslogik implementieren. Dies würde das Sammeln und Analysieren von Folgen von Touch- oder Zeigerereignissen über die Zeit erfordern. Dies ist deutlich aufwendiger.
- **Übersetzung in Domänenaktionen:**
    - Erkannte Gesten (z.B. ein "Pinch-to-Zoom" auf einem Fenster) müssen in Aktionen der Domänenschicht übersetzt werden (z.B. "ZoomFenster", "WechsleWorkspace").
    - Dies erfordert eine klare Schnittstelle zwischen `system::input` und der Domänenschicht, möglicherweise über den `SystemEventBridge`.
- **Smithay-Unterstützung:** Smithay bietet Unterstützung für das `zwp_pointer_gestures_v1`-Protokoll, was die Weiterleitung von Pinch- und Swipe-Gesten an Clients ermöglicht. Der Compositor muss die `libinput`-Events in die entsprechenden Wayland-Events dieses Protokolls übersetzen.
- **Herausforderungen:**
    - **Eindeutigkeit:** Sicherstellen, dass Gesten nicht mit normalen Zeiger- oder Touch-Interaktionen kollidieren.
    - **Konfigurierbarkeit:** Benutzer erwarten oft, Gesten konfigurieren zu können.
    - **Performance:** Die Gestenerkennung darf die Eingabeverarbeitung nicht verlangsamen.

## 3. D-Bus Interaktion (system::dbus_interfaces mit zbus)

Die Kommunikation mit Systemdiensten über D-Bus ist ein integraler Bestandteil moderner Desktop-Umgebungen. `zbus` wird für die asynchrone D-Bus-Kommunikation mit Tokio verwendet.

### 3.1. Proxy-Management

Die Erstellung und Verwaltung von `zbus::Proxy`-Instanzen, insbesondere für dynamische Objektpfade, erfordert sorgfältige Überlegungen zum Lebenszyklus.

- **Best Practices:**
    - **Caching von Proxies:** Für häufig verwendete Proxies zu bekannten Objektpfaden (z.B. `/org/freedesktop/UPower`, `/org/freedesktop/NetworkManager`) ist es sinnvoll, die Proxy-Instanzen nach der ersten Erstellung zwischenzuspeichern (z.B. in einem `OnceLock` oder einem `Arc<Mutex<...>>` Feld im jeweiligen `DBusClientService`). Dies vermeidet den Overhead wiederholter Proxy-Erstellung.
        - Die `DBusConnectionManager` mit `OnceLock` für Session/System-Bus ist ein guter Ansatz für die zugrundeliegende `zbus::Connection`.
    - **Dynamische Objektpfade:** Für Proxies zu dynamischen Objektpfaden (z.B. `UPowerDeviceProxy` für `/org/freedesktop/UPower/devices/display_device`, `LogindSessionProxy` für `/org/freedesktop/login1/session/self`):
        - Diese Proxies sollten bei Bedarf erstellt werden, wenn der spezifische Objektpfad bekannt wird (z.B. durch ein Signal vom Manager-Objekt oder eine Abfrage).
        - Eine Möglichkeit ist, sie nicht langfristig zu cachen, wenn ihre Lebensdauer stark an das zugrundeliegende D-Bus-Objekt gebunden ist und dieses häufig wechseln kann.
        - Alternativ kann ein Cache (z.B. `HashMap<OwnedObjectPath, Arc<MyDeviceProxy>>`) verwendet werden, aber es muss eine Strategie zur Invalidierung geben, falls das D-Bus-Objekt verschwindet. Signale wie `InterfacesRemoved` vom `org.freedesktop.DBus.ObjectManager` können hier helfen, sind aber nicht immer verfügbar.
    - **Lebenszyklusmanagement:**
        - Proxies sind an die Lebensdauer der `zbus::Connection` gebunden. Wenn die Verbindung getrennt wird, werden die Proxies ungültig.
        - Für Dienste, die neu gestartet werden können, muss der Client-Service in der Lage sein, die Verbindung und die Proxies neu zu initialisieren. Das Abonnieren von `NameOwnerChanged`-Signalen auf dem D-Bus kann helfen, Neustarts von Diensten zu erkennen.
- **Beispiel (Caching eines Manager-Proxys):**
    
    Rust
    
    ```
    use zbus::Proxy;
    use tokio::sync::OnceCell;
    use std::sync::Arc;
    
    static UPOWER_PROXY: OnceCell<Arc<UPowerProxy<'static>>> = OnceCell::const_new();
    
    async fn get_upower_proxy(connection: &Arc<zbus::Connection>) -> Result<Arc<UPowerProxy<'static>>, zbus::Error> {
        UPOWER_PROXY.get_or_try_init(|| async {
            let proxy = UPowerProxy::new(connection).await?;
            Ok(Arc::new(proxy))
        }).await.cloned()
    }
    ```
    
    Für dynamische Proxies wäre ein `HashMap` im Service-Struct, geschützt durch einen `Mutex` oder `RwLock`, ein gängiger Ansatz.

### 3.2. Asynchrone Signalbehandlung

Die Verarbeitung von D-Bus-Signalen erfolgt in `tokio::tasks`, die `zbus::SignalStream`s konsumieren.

- **Robuste Implementierung:**
    - Jeder `SignalStream` sollte in einem eigenen `tokio::task` verarbeitet werden, um Blockierungen zu vermeiden.
    - Der Task muss den Stream kontinuierlich pollen (z.B. mit `while let Some(signal) = stream.next().await`).
    - **Fehler im Stream:** `stream.next().await` kann `None` zurückgeben, wenn der Stream beendet wird (z.B. Verbindung verloren, Dienst beendet). Der Task sollte dies erkennen und sich sauber beenden oder versuchen, den Stream neu zu initialisieren (z.B. durch erneutes Abonnieren der Signale nach Wiederherstellung der Verbindung). Fehler während des Stream-Pollings (z.B. `zbus::Error`) sollten geloggt und behandelt werden.
    - **Parsen von Signaldaten:** Die Argumente eines Signals kommen als `zbus::zvariant::Value` oder spezifischere Typen an. Diese müssen sorgfältig in die internen Event-Typen der Systemschicht gemappt werden. Fehler beim Parsen (z.B. unerwarteter Typ) sollten abgefangen und geloggt werden.
    - **Umwandlung in interne Events:** Nach erfolgreichem Parsen werden die Signaldaten in anwendungsspezifische Events (z.B. `UPowerEvent`, `NetworkManagerEvent`) umgewandelt und typischerweise über den `SystemEventBridge` publiziert.
- **Beispiel (konzeptionell):**
    
    Rust
    
    ```
    // In UPowerClientService::initialize()
    // let upower_proxy = self.get_proxy().await?;
    // let mut device_added_stream = upower_proxy.receive_device_added().await?;
    // let event_bridge = global_system_event_bridge();
    
    // tokio::spawn(async move {
    //     while let Some(signal) = device_added_stream.next().await {
    //         match signal.args() {
    //             Ok(args) => {
    //                 let device_path = args.device_path; // Annahme basierend auf Spezifikation
    //                 // Hole Details für device_path, erstelle UPowerEvent::DeviceAdded
    //                 // event_bridge.publish(SystemLayerEvent::UPower(upower_event)).await;
    //             },
    //             Err(e) => {
    //                 // log_error!("Failed to parse UPower DeviceAdded signal args: {:?}", e);
    //             }
    //         }
    //     }
    //     // log_info!("UPower DeviceAdded signal stream ended.");
    // });
    ```
    
- **Referenz:** Die `zbus` Dokumentation zu `SignalStream` und asynchroner Verarbeitung ist hier relevant.

### 3.3. `org.freedesktop.Notifications` Server

Die Implementierung eines D-Bus-Servers für `org.freedesktop.Notifications` 75 erfordert ein Mapping zwischen D-Bus `u32` IDs und den internen `Uuid`s der Domänenschicht sowie das korrekte Emittieren von Signalen.

- **ID-Mapping (`D-Bus u32 <-> Domain Uuid`):**
    - Wenn der Server eine Benachrichtigung über `Notify` empfängt, generiert er eine neue, eindeutige `u32` ID und gibt diese an den Client zurück.
    - Diese `u32` ID muss intern mit der `Uuid` der Domänen-Benachrichtigung (die vom `domain::NotificationService` kommt oder dorthin gesendet wird) assoziiert werden. Ein `HashMap<u32, Uuid>` und ggf. ein `HashMap<Uuid, u32>` (für schnelle Rückwärts-Lookups) im Zustand des `FreedesktopNotificationsServer` sind hierfür geeignet. Diese Maps müssen durch einen `Mutex` oder `RwLock` geschützt werden, da D-Bus-Methodenaufrufe und Domain-Event-Handler potenziell nebenläufig sind.
- **Verwendung von `zbus::SignalContext` zum Emittieren von Signalen:**
    - Wenn ein Domänen-Event (z.B. `DomainNotificationEvent::Closed`) eintritt, das ein D-Bus-Signal auslösen soll (z.B. `NotificationClosed`), muss der Listener dieses Domänen-Events den `FreedesktopNotificationsServer` darüber informieren.
    - Der Server-Task, der die D-Bus-Schnittstelle implementiert, ist derjenige, der Signale emittieren kann.
    - Um ein Signal aus einem anderen Task (dem Domain-Event-Listener) zu emittieren, muss der `SignalContext` des entsprechenden Interfaces verwendet werden.
    - Eine Möglichkeit ist, dass der Domain-Event-Listener eine Nachricht (z.B. über einen `tokio::sync::mpsc::channel`) an den D-Bus-Server-Task sendet. Dieser Task ruft dann die Signal-Emissionsmethode auf seinem Interface-Objekt auf.
    - **Beispiel (konzeptionell für `NotificationClosed`):**
        
        Rust
        
        ```
        // In FreedesktopNotificationsServer (zbus::Interface Implementierung)
        // #[dbus_interface(name = "org.freedesktop.Notifications")]
        // struct NotificationsServerLogic {
        //     //... id_map: Arc<Mutex<HashMap<u32, Uuid>>>,...
        //     // signal_context: Option<SignalContext<'static>> // Wird von zbus bereitgestellt
        // }
        
        // impl NotificationsServerLogic {
        //     #[dbus_interface(signal)]
        //     async fn notification_closed(&self, ctxt: &SignalContext<'_>, id: u32, reason: u32) -> zbus::Result<()>;
        
        //     // Diese Methode wird vom Domain-Event-Listener aufgerufen (z.B. via MPSC-Kanal)
        //     async fn handle_domain_notification_closed(&self, dbus_id: u32, reason: u32) {
        //         if let Some(ctxt) = self.signal_context() { // Korrekten Weg zum SignalContext finden
        //             if let Err(e) = self.notification_closed(ctxt, dbus_id, reason).await {
        //                 // log_error!("Failed to emit NotificationClosed signal: {:?}", e);
        //             }
        //         }
        //     }
        // }
        ```
        
        Die `SwayNotificationCenter` 77 und `mako` 78 sind Beispiele für Notification Daemons, deren D-Bus Implementierung (falls in Rust/zbus oder C/GDBus) als Inspiration dienen kann. Die Freedesktop Notification Specification 75 ist die maßgebliche Quelle.

### 3.4. Fehlerbehandlung

- **Umgang mit `zbus::Error` und `zbus::fdo::Error`:**
    - `zbus::Error` ist der allgemeine Fehlertyp von `zbus`, der I/O-Fehler, Serialisierungsfehler, Verbindungsfehler etc. umfassen kann.79
    - `zbus::fdo::Error` ist ein spezifischer D-Bus-Fehlertyp, der von Methodenaufrufen zurückgegeben werden kann (z.B. `org.freedesktop.DBus.Error.ServiceUnknown`).
    - Diese Fehler müssen in den jeweiligen Client-Services (z.B. `UPowerClientService`) abgefangen werden.
- **Mapping in eigenes `DBusInterfaceError`-Schema unter Beibehaltung des Fehlerkontexts:**
    - Das `DBusInterfaceError`-Enum sollte Varianten für spezifische Fehlerfälle (z.B. `ServiceUnavailable`, `MethodCallFailed`, `SignalStreamError`, `InvalidResponse`) und eine generische Variante für unerwartete `zbus`-Fehler haben.
    - Die `thiserror`-Crate ist hierfür ideal.
    - Die ursprüngliche `zbus::Error` oder `zbus::fdo::Error` sollte als `source` im `DBusInterfaceError` gespeichert werden, um den Kontext nicht zu verlieren.
    - **Beispiel (konzeptionell):**
        
        Rust
        
        ```
        #
        pub enum DBusInterfaceError {
            #
            ServiceUnavailable { service: String, #[source] source: zbus::Error },
        
            #[error("Method call {method:?} on {interface:?} failed")]
            MethodCallFailed {
                interface: String,
                method: String,
                #[source]
                source: zbus::fdo::Error,
            },
        
            #
            MessageSendError(#[from] zbus::Error),
        
            #
            ResponseParseError{ method: String, #[source] source: zbus::zvariant::Error },
            //... weitere Varianten
        }
        
        // In einem Client-Service:
        // match some_proxy.some_method().await {
        //     Ok(reply) => Ok(reply),
        //     Err(zbus::Error::FDO(fdo_error)) => Err(DBusInterfaceError::MethodCallFailed {
        //         interface: P::INTERFACE.to_string(), // P ist der Proxy-Typ
        //         method: "some_method".to_string(),
        //         source: *fdo_error,
        //     }),
        //     Err(e) => Err(DBusInterfaceError::MessageSendError(e)),
        // }
        ```
        
        Die Granularität der Fehlertypen ist ein wichtiger Aspekt. Eine zu feine Aufteilung von `DBusInterfaceError` kann unhandlich werden. Eine gute Balance zwischen spezifischen, für die Domänenschicht relevanten Fehlern und generischen Catch-All-Varianten ist anzustreben. Die Domänenschicht interessiert sich beispielsweise eher dafür, _ob_ ein Dienst nicht verfügbar ist, um ein Feature zu deaktivieren, als für die genaue Art eines I/O-Fehlers auf dem D-Bus-Socket. Das `DBusInterfaceError` sollte diese Abstraktionsebene widerspiegeln. Bei bestimmten Fehlern, wie `ServiceUnavailable` oder temporären Netzwerkproblemen, könnte eine Retry-Logik in den Client-Services implementiert werden, bevor der Fehler an die Domänenschicht weitergegeben wird. Dies erhöht die Robustheit der Systemschicht gegenüber transienten Fehlern.

Tabelle für Sektion 3.1: Proxy-Management-Strategien

Eine durchdachte Strategie für das Management von D-Bus-Proxies ist entscheidend für Performance und Stabilität. Die naive Erstellung eines Proxys bei jedem Methodenaufruf ist ineffizient. Andererseits können langlebige Proxies veralten, wenn der zugrundeliegende Dienst neu startet oder Objekte verschwinden.

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|**Strategie**|**Beschreibung**|**Vorteile**|**Nachteile**|**zbus-Mechanismen**|**Eignung für NovaDE-Dienste (Beispiele)**|
|**On-Demand Creation**|Proxy wird bei jedem benötigten Aufruf neu erstellt.|Immer aktuell; einfach zu implementieren.|Hoher Overhead bei häufigen Aufrufen.|`Proxy::new(conn).await`|Selten genutzte Dienste oder einmalige Aufrufe.|
|**Cached Static Proxies**|Proxies für bekannte, statische Objektpfade werden einmal erstellt und wiederverwendet.|Geringer Overhead nach Initialisierung.|Proxy kann veralten, wenn Dienst neu startet (Neuerstellung erforderlich).|`OnceCell`, `Arc<Proxy>`|Manager-Proxies: `UPowerProxy`, `LogindManagerProxy`, `NetworkManagerProxy`, `SecretServiceProxy`, `PolicyKitAuthorityProxy`.|
|**Cached Dynamic Proxies**|Proxies für dynamische Objektpfade werden bei Bedarf erstellt und in einem Cache (z.B. `HashMap`) gehalten.|Reduzierter Overhead für häufig zugegriffene dynamische Objekte.|Cache-Invalidierung komplex; Proxy kann veralten.|`Arc<Mutex<HashMap<ObjectPath, Arc<Proxy>>>>`|`UPowerDeviceProxy`, `LogindSessionProxy`, `NMDeviceProxy`, `SecretCollectionProxy`, `SecretItemProxy`. Erfordert Überwachung von Signalen (z.B. `InterfacesRemoved`).|
|**Proxies via Manager Signals**|Proxies für dynamische Objekte werden nur erstellt, wenn ihre Existenz durch Signale des Managers bekannt wird.|Erstellt Proxies nur für tatsächlich existierende Objekte.|Abhängig von der Zuverlässigkeit und Semantik der Manager-Signale.|Signal-Handler, die Proxies erstellen/entfernen.|Wie "Cached Dynamic Proxies", aber die Erstellung/Entfernung wird durch Signale wie `DeviceAdded`/`DeviceRemoved` (UPower) oder `SessionNew`/`SessionRemoved` (Logind) gesteuert.|
|**Server-seitige Objekt-Ref.**|(Für den Notifications-Server) Referenzen auf exportierte Objekte werden von zbus verwaltet.|Lebenszyklus wird von zbus gehandhabt.|Weniger direkte Kontrolle.|`#[dbus_interface]`, `ObjectServer`|`FreedesktopNotificationsServer`.|

## 4. PipeWire Integration (system::audio_management mit `pipewire-rs`)

Die Integration von PipeWire 80 für Audio-Management in NovaDE erfolgt über die `pipewire-rs`-Bibliothek. Dies erfordert die Verwaltung des PipeWire-MainLoops und die Kommunikation zwischen dem asynchronen Service und dem PipeWire-Thread.

### 4.1. `MainLoop` Management

PipeWire benötigt einen laufenden MainLoop. Die `pipewire-rs`-Bibliothek abstrahiert dies.

- **Strategien zur Integration der `pipewire::MainLoop` in eine tokio-basierte Anwendung:**
    
    - **Option 1: Dedizierter Thread für PipeWire `MainLoop`:** Dies ist der gängigste und oft robusteste Ansatz. Ein separater Systemthread wird gestartet, der ausschließlich `pipewire::MainLoop::run()` ausführt.
        - _Vorteile:_ Klare Trennung der Audioverarbeitung vom Rest der Anwendung, blockiert nicht die Tokio-Runtime.
        - _Nachteile:_ Erfordert Inter-Thread-Kommunikation (IPC) für Befehle und Zustandsaktualisierungen.
    - **Option 2: Integration des PipeWire-FDs in eine tokio-kompatible Event-Loop:** Theoretisch könnte, falls `pipewire-rs` einen Dateideskriptor des PipeWire-Mainloops exponiert, dieser in den Tokio-Eventloop integriert werden (ähnlich wie `calloop` FDs integriert). Dies ist jedoch mit `pipewire-rs` **unwahrscheinlich**, da es oft auf GLib im Hintergrund setzt oder einen eigenen Loop managed. Die Dokumentation von `pipewire-rs` ist hier entscheidend.
        - _Vorteile (hypothetisch):_ Potenziell geringerer Threading-Overhead.
        - _Nachteile (hypothetisch):_ Deutlich komplexere Implementierung, falls nicht direkt von `pipewire-rs` unterstützt.
    - **Empfehlung für NovaDE:** Ein dedizierter Thread für den PipeWire `MainLoop` wird empfohlen, da dies ein etabliertes Muster ist und die Komplexität der direkten FD-Integration vermeidet, es sei denn, `pipewire-rs` bietet explizite Unterstützung für eine Tokio-Integration.
- **Sichere Kommunikation zwischen async-Service-Methoden und dem PipeWire-Thread:**
    
    - **Befehle (Tokio-Service -> PipeWire-Thread):** Ein `tokio::sync::mpsc::channel` ist hierfür ideal. Der `PipeWireClientService` (laufend im Tokio-Kontext) sendet Befehle (z.B. `SetVolumeCommand { device_id: String, volume: f32 }`) an den PipeWire-Thread. Der PipeWire-Thread besitzt den `Receiver`-Teil des Kanals und verarbeitet die eintreffenden Befehle synchron innerhalb seines `MainLoop`-Kontexts.
    - **Zustandsupdates und Events (PipeWire-Thread -> Tokio-Service):**
        - Für lesbare Zustände (z.B. aktuelle Geräteliste, Lautstärken): Ein `Arc<RwLock<AudioSystemState>>` kann verwendet werden. Der PipeWire-Thread hat Schreibzugriff und aktualisiert diesen Zustand, wenn sich etwas ändert (z.B. nach einem Befehl oder durch externe PipeWire-Events). Der Tokio-Service hat Lesezugriff.
        - Für Event-Benachrichtigungen (z.B. `DeviceListChanged`, `DefaultDeviceChanged`): Ein `tokio::sync::watch::channel` (für einzelne Werte, die sich ändern) oder ein `tokio::sync::broadcast::channel` (für Ereignisse, die von mehreren Stellen konsumiert werden könnten) kann vom PipeWire-Thread verwendet werden, um Updates an den Tokio-Service zu senden. Der `PipeWireClientService` abonniert diese Kanäle.
        - Alternativ kann der PipeWire-Thread Callbacks verwenden (siehe Abschnitt 4.2), die dann ihrerseits Nachrichten über einen weiteren `mpsc`-Kanal zurück an den Tokio-Thread senden. Dieser kann dann die `AudioEvent`s über den `SystemEventBridge` publizieren.
- **Code-Beispiel (konzeptionell für dedizierten Thread und MPSC):**
    
    Rust
    
    ```
    use pipewire::Loop; // Beispiel, tatsächliche Typen können variieren
    use std::sync::{Arc, RwLock};
    use tokio::sync::mpsc;
    
    enum PipeWireCommand {
        SetVolume(String, f32),
        // Weitere Befehle
    }
    
    struct InternalAudioState {
        //... z.B. Vec<AudioDevice>
    }
    
    pub struct PipeWireClientService {
        command_tx: mpsc::Sender<PipeWireCommand>,
        audio_state: Arc<RwLock<InternalAudioState>>,
        //... event_rx: broadcast::Receiver<AudioEvent>...
    }
    
    impl PipeWireClientService {
        pub fn new(/*... */) -> Self {
            let (command_tx, mut command_rx) = mpsc::channel(32);
            let audio_state = Arc::new(RwLock::new(InternalAudioState { /*... */ }));
            let audio_state_clone = audio_state.clone();
            // Hier fehlt der Event-Sender vom PipeWire-Thread zum SystemEventBridge
    
            std::thread::spawn(move |
    ```
    

| {

// Diese Initialisierung ist stark vereinfacht und dient nur dem Konzept

let main_loop = pipewire::MainLoop::new(None)

.expect("Failed to create PipeWire MainLoop");

let context = pipewire::Context::new(&main_loop)

.expect("Failed to create PipeWire Context");

let core = context.connect(None)

.expect("Failed to connect to PipeWire Core");

let registry = core.get_registry()

.expect("Failed to get PipeWire Registry");

````
            // Hier würden Listener für Core- und Registry-Events registriert (siehe 4.2)
            // Diese Listener würden audio_state_clone aktualisieren und/oder Events senden

            loop {
                // Verarbeite Befehle vom Tokio-Service
                // main_loop.iterate(false) blockiert nicht lange, erlaubt command_rx.try_recv()
                // oder man nutzt einen blocking_recv mit Timeout in einer Schleife,
                // die auch main_loop.iterate() aufruft.
                match command_rx.blocking_recv() { // In einem echten Szenario ggf. non-blocking oder mit Timeout
                    Some(command) => {
                        // PipeWire-Aktionen basierend auf dem Befehl ausführen
                        // z.B. core.set_volume(...)
                        // audio_state_clone.write().unwrap()... aktualisieren
                    }
                    None => break, // Kanal wurde geschlossen
                }

                // PipeWire-Events verarbeiten (non-blocking)
                if main_loop.iterate(false) < 0 {
                    // Fehler in der PipeWire-Schleife
                    break;
                }
            }
        });

        Self { command_tx, audio_state /*,... */ }
    }

    // Async Methoden, die command_tx verwenden
    pub async fn set_device_volume(&self, device_id: String, volume: f32) -> Result<(), AudioManagementError> {
        self.command_tx.send(PipeWireCommand::SetVolume(device_id, volume)).await
           .map_err(|_| AudioManagementError::InternalThreadCommunicationError)?;
        Ok(())
    }
}
```
Die Thread-Sicherheit der von `pipewire-rs` bereitgestellten Objekte ist fundamental. Objekte wie `pipewire::Core` oder `pipewire::Registry` sind oft nicht `Send` oder `Sync`. Das bedeutet, sie dürfen nicht direkt über `Arc<Mutex<T>>` zwischen Threads geteilt und von verschiedenen Threads modifiziert werden. Alle Operationen, die diese Objekte verändern, müssen im Kontext des PipeWire-MainLoops (also im dedizierten PipeWire-Thread) ausgeführt werden. Befehle vom Tokio-Service müssen daher über einen Kanal an diesen Thread gesendet werden.
````

### 4.2. Callback-Management

PipeWire verwendet ein Callback-basiertes System für Events (z.B. über `RegistryListener`, `CoreListener`, `NodeListener`, `StreamListener`).

- **Verwaltung von Listener-Strukturen, die `'static` sein müssen:**
    
    - Wenn `add_listener_local` verwendet wird, erwartet `pipewire-rs` oft, dass der Listener eine `'static` Lebensdauer hat, da der Listener potenziell länger existiert als der Scope, in dem er erstellt wurde.
    - **Problem mit `self`-Referenzen:** Wenn der Listener Methoden des `PipeWireClientService` oder dessen internen Zustands aufrufen muss, wird es schwierig, da `self` nicht einfach in einen `'static` Closure verschoben werden kann, wenn der Listener selbst Teil von `self` ist oder `self` eine kürzere Lebensdauer hat.
    - **Lösungen:**
        1. **`Arc` und schwache Referenzen (`Weak`):** Der Zustand, auf den der Listener zugreifen muss (z.B. der `mpsc::Sender` für Events zurück an Tokio oder der `Arc<RwLock<InternalAudioState>>`), kann in einen `Arc` gepackt werden. Der Listener-Closure erhält einen Klon dieses `Arc`. Wenn der Listener den `PipeWireClientService` selbst referenzieren muss (z.B. um Methoden aufzurufen), kann ein `Weak<PipeWireClientService>` verwendet werden, das vor der Verwendung zu einem `Arc` aufgewertet wird, um Zyklen zu vermeiden.
        2. **Kanalbasierte Kommunikation:** Der Listener-Callback sendet die empfangenen Daten/Events über einen `mpsc::Sender` (der in den Callback geklont wurde) an einen zentralen Verarbeitungspunkt im PipeWire-Thread oder direkt zurück an den Tokio-Thread.
        3. **Globale oder statische Handler (mit Vorsicht):** In seltenen Fällen könnten globale Handler verwendet werden, aber dies erschwert das Zustandsmanagement erheblich und ist meist nicht empfehlenswert.
- **Beenden von Listenern:**
    
    - Die von `add_listener_local` zurückgegebenen `Listener` structs implementieren `Drop`. Wenn der `Listener` aus dem Scope geht, wird der Listener automatisch von PipeWire entfernt.
    - Es ist wichtig, diese `Listener`-Objekte so lange im Speicher zu halten, wie die Callbacks aktiv sein sollen (z.B. als Felder im PipeWire-Thread-Zustand). Wenn sie vorzeitig gedroppt werden, werden keine Callbacks mehr empfangen.
- **Beispiel (konzeptionell für Registry-Listener):**
    
    Rust
    
    ```
    // Im PipeWire-Thread
    // let registry_listener = registry.add_listener_local()
    //    .global({
    //         let audio_state_clone = audio_state.clone(); // Arc<RwLock<InternalAudioState>>
    //         // let event_tx_clone = event_tx.clone(); // mpsc::Sender<AudioEvent>
    //         move |global_obj| {
    //             if let Some(props) = &global_obj.props {
    //                 if props.get(pipewire::keys::OBJECT_TYPE) == Some("PipeWire:Interface:Device") {
    //                     // Neues Audiogerät gefunden
    //                     // audio_state_clone.write().unwrap().add_device(...);
    //                     // event_tx_clone.send(AudioEvent::DeviceAdded(...)).unwrap();
    //                 }
    //             }
    //         }
    //     })
    //     //... weitere Callbacks...
    //    .register();
    // // registry_listener muss am Leben gehalten werden.
    ```
    

### 4.3. SPA Pod Erstellung und Anwendung

SPA (Simple Plugin API) Pods werden verwendet, um Parameter für PipeWire-Objekte (Nodes, Streams) zu setzen, z.B. für Lautstärkeregelung.

- **Detaillierte Beispiele für die Erstellung von `SpaPod`s:**
    - `pipewire-rs` bietet Builder-APIs oder direkte Konstruktionsmethoden für Pods.
    - **Lautstärkeregelung (`Props` mit `channelVolumes`, `mute`):**
        - Ein `Props`-Pod (oft ein `Object`-Pod mit `ParamProps`-Typ) wird erstellt.
        - Dieser enthält Eigenschaften wie `channelVolumes` (ein Array von Floats, z.B. `[0.5, 0.5]` für Stereo bei 50%) und `mute` (ein Boolean).
        - Die genauen Namen der Eigenschaften (`SpaId`) und deren Typen müssen der PipeWire-Spezifikation für Audio-Nodes entsprechen (z.B. `SpaId::from_str("channelVolumes")`).
    - **Routenparameter auf Devices:** Ähnlich können Pods für Routing-Parameter erstellt werden, um z.B. ein Default-Profil für ein Gerät zu setzen.
- **Korrekte Verwendung mit `node.set_param()`:**
    - Die `set_param`-Methode eines `Node`-Objekts (oder `Stream`-Objekts) erwartet die ID des Parameters, der gesetzt werden soll (z.B. `SpaId::EnumParamPortConfig` für Port-Konfiguration, `SpaId::EnumParamProps` für allgemeine Eigenschaften) und den `SpaPod` mit den neuen Werten.
    - **Beispiel (konzeptionell):**
        
        Rust
        
        ```
        // Annahme: node ist ein pipewire::Node
        // use pipewire::spa::pod::{Pod, PodObject, PodBuilder, Value};
        // use pipewire::spa::param::ParamType;
        // use pipewire::spa::utils::SpaTypes; // Für SpaId-Konstanten
        
        // // Lautstärke setzen (vereinfacht)
        // let mut props_builder = PodBuilder::new_object(
        //     SpaTypes::Props, // Builder-Typ
        //     ParamType::Props.as_raw() // Pod-Typ-ID
        // );
        // props_builder.add(
        //     SpaTypes::PropChannelVolumes, // Key-ID
        //     &Value::Array(vec![Value::Float(0.7), Value::Float(0.7)]) // Wert
        // ).unwrap();
        // props_builder.add(
        //     SpaTypes::PropMute,
        //     &Value::Bool(false)
        // ).unwrap();
        // let props_pod = props_builder.end();
        
        // node.set_param(ParamType::Props.as_raw(), 0, &props_pod).unwrap();
        ```
        
        Die genaue API für die Pod-Erstellung in `pipewire-rs` muss der Dokumentation entnommen werden. Die Verwendung von `spa_sys` oder höheren Abstraktionen in `pipewire-rs` ist möglich.

### 4.4. Metadaten-Interface

Das Metadaten-Interface in PipeWire wird verwendet, um systemweite Einstellungen wie Standard-Audio-Geräte zu verwalten.

- **Interaktion mit dem `Metadata`-Objekt:**
    - PipeWire exponiert ein globales `Metadata`-Objekt (oft mit der ID `PIPEWIRE_METADATA_OBJECT_ID_SETTINGS` oder über die Registry auffindbar).
    - Dieses Objekt hat Eigenschaften (Properties), die über `metadata.set_property()` und `metadata.property()` (oder äquivalente Methoden in `pipewire-rs`) gelesen und geschrieben werden können.
- **Setzen und Lesen von Standard-Audio-Geräten (`default.audio.sink/source`):**
    - Die Namen der Properties für Standardgeräte sind typischerweise `"default.audio.sink"` und `"default.audio.source"`.
    - Der Wert dieser Properties ist die ID (oft eine `u32`) des entsprechenden PipeWire-Node-Objekts, das als Standard-Sink oder -Source dienen soll.
    - Um das Standardgerät zu ändern, wird `metadata.set_property("default.audio.sink", "neue_node_id_als_string")` aufgerufen.
    - Um das aktuelle Standardgerät zu lesen, wird `metadata.property("default.audio.sink")` verwendet.
- **Events:** Änderungen an Metadaten (einschließlich Standardgeräten) lösen Events auf dem `Metadata`-Objekt oder der `Registry` aus, die der `PipeWireClientService` abonnieren muss, um `DefaultDeviceChanged`-Events zu generieren.

## 5. MCP Client (system::mcp_client mit `mcp_client_rs`)

Der Model Context Protocol (MCP) Client ermöglicht die Anbindung an KI-Dienste. NovaDE startet lokale MCP-Server-Prozesse und verwaltet die Kommunikation.

### 5.1. Prozessmanagement

Das Starten und Überwachen lokaler MCP-Server-Prozesse erfolgt mit `tokio::process::Command`.

- **Robuste Methoden:**
    
    - **Starten:** `tokio::process::Command::new("path/to/mcp_server_executable")` wird verwendet, um den Prozess zu konfigurieren (Argumente, Umgebungsvariablen). `Command::spawn()` startet den Prozess asynchron.
    - **Überwachen:**
        - Das von `spawn()` zurückgegebene `Child`-Objekt bietet eine `wait()`-Methode (als Future), um auf das Beenden des Prozesses zu warten und den Exit-Status zu erhalten.
        - Regelmäßige Health-Checks (falls vom MCP-Server unterstützt) oder das Überwachen der Stdio-Pipes können ebenfalls zur Überwachung dienen.
        - Bei unerwartetem Beenden des Prozesses sollte ein Fehler geloggt und ggf. ein Neustartversuch unternommen werden (mit Backoff-Strategie).
- **Handhabung von Stdio (`stdin`/`stdout`):**
    
    - `mcp_client_rs::McpClient` kommuniziert typischerweise über `stdin` und `stdout` mit dem Serverprozess.
    - `Command::stdin(Stdio::piped())` und `Command::stdout(Stdio::piped())` müssen gesetzt werden.
    - Die von `child.stdin.take().unwrap()` und `child.stdout.take().unwrap()` zurückgegebenen `ChildStdin` und `ChildStdout` (die `AsyncWrite` bzw. `AsyncRead` implementieren) werden dann an den `McpClient` übergeben (z.B. beim Konstruktor des Clients).
- **Beispiel (konzeptionell):**
    
    Rust
    
    ```
    use tokio::process::Command;
    use std::process::Stdio;
    
    // async fn start_local_mcp_server(config: &McpServerConfig::LocalExecutable) -> Result<mcp_client_rs::McpClient, McpSystemClientError> {
    //     let mut command = Command::new(&config.executable_path);
    //     command.args(&config.args);
    //     command.stdin(Stdio::piped());
    //     command.stdout(Stdio::piped());
    //     // command.stderr(Stdio::piped()); // Für Fehler-Logging
    
    //     let mut child = command.spawn().map_err(McpSystemClientError::ProcessSpawnFailed)?;
    
    //     let stdin = child.stdin.take().ok_or(McpSystemClientError::StdioUnavailable("stdin".into()))?;
    //     let stdout = child.stdout.take().ok_or(McpSystemClientError::StdioUnavailable("stdout".into()))?;
    
    //     let mcp_client = mcp_client_rs::McpClient::new(stdout, stdin); // Annahme einer solchen API
    
    //     // Optional: Task zur Überwachung des Kindprozesses
    //     tokio::spawn(async move {
    //         match child.wait().await {
    //             Ok(status) => { /* log_info!("MCP server exited with status: {}", status); */ },
    //             Err(e) => { /* log_error!("Failed to wait for MCP server: {}", e); */ }
    //         }
    //         // Hier ggf. ServerConnectionStateChanged-Event senden
    //     });
    
    //     Ok(mcp_client)
    // }
    ```
    

### 5.2. Notification Handling

Asynchrone `McpMessage::Notification`-Nachrichten vom Server müssen in einem Hintergrund-Task überwacht werden.

- **Effiziente Überwachung:**
    - Der `mcp_client_rs::McpClient` sollte eine Methode wie `receive_message()` oder `notifications_stream()` bereitstellen, die einen Stream von `McpMessage`s zurückgibt.
    - Dieser Stream wird in einem dedizierten `tokio::task` konsumiert.
    - `while let Some(message) = stream.next().await` wird verwendet, um Nachrichten zu empfangen.
    - Wenn `message` eine `McpMessage::Notification` ist, wird sie in ein `McpClientSystemEvent::NotificationReceived` umgewandelt und über den `SystemEventBridge` publiziert.
- **Beispiel (konzeptionell):**
    
    Rust
    
    ```
    // In McpConnection::new() oder einer ähnlichen Methode
    // let client_clone = self.mcp_client.clone(); // Annahme, McpClient ist Arc-wrapped oder hat eine clone-bare Listener-API
    // let event_bridge = global_system_event_bridge();
    // tokio::spawn(async move {
    //     // Annahme: client_clone.message_stream() liefert einen Stream<Result<McpMessage, _>>
    //     let mut stream = client_clone.message_stream();
    //     while let Some(result) = stream.next().await {
    //         match result {
    //             Ok(McpMessage::Notification(notification)) => {
    //                 event_bridge.publish(SystemLayerEvent::McpClient(
    //                     McpClientSystemEvent::NotificationReceived {
    //                         server_id: self.server_config.id, // Annahme: Server-ID ist verfügbar
    //                         notification,
    //                     }
    //                 )).await;
    //             }
    //             Ok(_) => { /* Andere Nachrichtentypen ignorieren oder behandeln */ }
    //             Err(e) => {
    //                 // log_error!("Error receiving MCP message: {:?}", e);
    //                 // event_bridge.publish(SystemLayerEvent::McpClient(
    //                 //     McpClientSystemEvent::CommunicationError { server_id: self.server_config.id, error: e.into() }
    //                 // )).await;
    //                 break; // Stream beenden bei Fehler
    //             }
    //         }
    //     }
    // });
    ```
    

### 5.3. Request Timeouts

Die Implementierung von Timeouts für `client.send_request_json()` ist wichtig, um auf nicht antwortende Server zu reagieren.

- **`tokio::time::timeout`:** Die `tokio::time::timeout(duration, future)`-Funktion ist hierfür ideal.
    - Sie wrappt den `Future` des `send_request_json()`-Aufrufs.
    - Wenn der `Future` innerhalb der `duration` nicht auflöst, gibt `timeout` ein `Err(Elapsed)` zurück.
    - Anderenfalls gibt es das `Result` des inneren `Future`s zurück.
- **Beispiel:**
    
    Rust
    
    ```
    use tokio::time::{timeout, Duration};
    
    // async fn send_request_with_timeout(
    //     client: &mcp_client_rs::McpClient,
    //     request: McpRequest, // Annahme: MCP-Request-Typ
    //     timeout_duration: Duration,
    // ) -> Result<McpResponse, McpSystemClientError> { // Annahme: MCP-Response-Typ
    //     match timeout(timeout_duration, client.send_request_json(&request)).await {
    //         Ok(Ok(response)) => Ok(response),
    //         Ok(Err(mcp_err)) => Err(McpSystemClientError::RequestFailed(mcp_err)), // Fehler vom McpClient
    //         Err(_elapsed) => Err(McpSystemClientError::Timeout), // Timeout-Fehler
    //     }
    // }
    ```
    
    Dieses Ergebnis wird dann ggf. als `McpClientSystemEvent::RequestFailed` publiziert.

### 5.4. API-Key Management

API-Keys für `RemoteHttp`-Verbindungen werden über den `SecretsServiceClientService` abgerufen und müssen sicher an den `McpClient` übergeben werden.

- **Sichere Übergabe:**
    - Der `McpConnectionManager` oder `DefaultSystemMcpService` fordert den API-Key vom `SecretsServiceClientService` an, wenn eine `RemoteHttp`-Verbindung konfiguriert wird.
    - Der abgerufene Key (typischerweise ein `String` oder `Vec<u8>`) wird dann an den `mcp_client_rs::McpClient` übergeben, wenn dieser für die Remote-Verbindung initialisiert wird.
    - `mcp_client_rs` sollte eine Methode oder Konfigurationsoption bieten, um den API-Key für HTTP-Header (z.B. `Authorization: Bearer <key>`) zu setzen.
    - Der API-Key sollte **niemals** hartcodiert oder unverschlüsselt in Konfigurationsdateien gespeichert werden. Die Verwendung des Secret Service ist hier die korrekte Vorgehensweise.
    - Es ist wichtig sicherzustellen, dass der API-Key nur im Speicher gehalten wird, solange er benötigt wird, und nicht unnötig geloggt oder anderweitig exponiert wird.

## 6. Schichtübergreifende Synchronisation und Fehlerbehandlung

Die Koordination zwischen verschiedenen Event-Loops und eine konsistente Fehlerbehandlung sind für die Stabilität des Gesamtsystems unerlässlich.

### 6.1. Event-Loops (calloop vs. tokio vs. GLib)

NovaDE verwendet `calloop` für Wayland/Compositor-Events und `tokio` für D-Bus, MCP und interne Timer. Eine potenzielle GLib-Main-Loop könnte von der UI-Schicht (nicht Teil der Systemschicht-Spezifikation, aber relevant für die Integration) verwendet werden.

- **Best Practices für Kommunikation und Datenübergabe:**
    - **`calloop` (Compositor-Thread) <-> `tokio` (Service-Threads):**
        - **Von `tokio` zu `calloop`:**
            - Wenn ein Tokio-Task (z.B. D-Bus-Signal-Handler) eine Aktion im Compositor auslösen muss (z.B. Fenster neu zeichnen lassen), kann dies über einen `calloop::channel` geschehen. Der Tokio-Task sendet eine Nachricht, der `calloop`-Eventloop empfängt sie und führt eine entsprechende Aktion im Compositor-Zustand aus.
            - Alternativ kann ein `Arc<Mutex<T>>` für geteilten Zustand verwendet werden, wobei der Tokio-Task den Zustand modifiziert und der Compositor-Thread ihn periodisch prüft oder durch ein Signal (z.B. `calloop::ping`) aufgeweckt wird.
        - **Von `calloop` zu `tokio`:**
            - Wenn eine Aktion im Compositor (z.B. Benutzerinteraktion) einen Tokio-basierten Service aufrufen muss, kann der Compositor-Code einen `tokio::task` spawnen (wenn der `DesktopState` Zugriff auf eine Tokio-Runtime hat) oder eine Nachricht über einen `std::sync::mpsc` (oder `crossbeam_channel`) an einen lauschenden Tokio-Task senden.
            - Der `SystemEventBridge` (basierend auf `tokio::sync::broadcast`) ist der primäre Mechanismus für Events vom Compositor (oder anderen Systemmodulen) zu Tokio-basierten Listenern.
    - **`tokio` (Systemschicht) <-> GLib (UI-Schicht, falls GTK4):**
        - GTK4 ist nicht threadsicher. Alle UI-Operationen müssen im GLib-Main-Thread ausgeführt werden.82
        - **Von `tokio` zu GLib/GTK4:**
            - `glib::MainContext::spawn_local()` oder `glib::idle_add_local()` sind die Standardmechanismen, um Code aus einem Tokio-Thread im GLib-Main-Thread auszuführen.
            - Ein Tokio-Task kann ein Ergebnis berechnen und dann `glib::MainContext::default().spawn_local(...)` verwenden, um einen Closure auszuführen, der die UI aktualisiert.
            - Die `SystemEventBridge`-Events (`tokio::sync::broadcast::Receiver`) müssen im GLib-Main-Thread konsumiert werden. Ein `glib::MainContext::spawn_local` kann einen `async` Block starten, der auf dem `broadcast::Receiver` lauscht und bei neuen Events UI-Updates durchführt.88
                
                Rust
                
                ```
                // In der UI-Schicht (GTK4)
                // let system_event_rx = global_system_event_bridge().subscribe();
                // glib::MainContext::default().spawn_local(async move {
                //     loop {
                //         match system_event_rx.recv().await {
                //             Ok(system_event) => {
                //                 // UI basierend auf system_event aktualisieren
                //             }
                //             Err(broadcast::error::RecvError::Lagged(_)) => { /*... */ }
                //             Err(broadcast::error::RecvError::Closed) => break,
                //         }
                //     }
                // });
                ```
                
        - **Von GLib/GTK4 zu `tokio`:**
            - Ein GTK-Signal-Handler (der im GLib-Main-Thread läuft) kann einen `tokio::task` auf einer globalen Tokio-Runtime spawnen, um eine langlaufende Operation auszuführen.
            - Das Ergebnis kann dann wieder über `glib::MainContext::spawn_local()` an die UI zurückgespielt werden.
- **Wichtige Überlegungen:**
    - **Blockierung vermeiden:** Kein Thread sollte den Event-Loop eines anderen Threads blockieren. Insbesondere dürfen `calloop`-Callbacks und GLib-Main-Loop-Handler keine langwierigen synchronen Operationen ausführen.
    - **Daten-Ownership und Thread-Safety:** `Send` und `Sync` müssen beachtet werden, wenn Daten zwischen Threads übergeben werden. `Arc<Mutex/RwLock<T>>` für geteilten Zustand oder Kanäle für Nachrichten sind üblich.

### 6.2. Fehler-Wrapping

Eine konsistente Strategie zum Wrappen von Fehlern aus unteren Schichten in die spezifischen Fehler-Enums der Systemschicht-Module ist entscheidend für Robustheit und Debugging.

- **Konsistente Strategien:**
    - **`thiserror` verwenden:** Jedes Modul der Systemschicht (`system::compositor`, `system::input`, etc.) sollte sein eigenes Fehler-Enum definieren (z.B. `CompositorCoreError`, `InputError`), das mit `#[derive(thiserror::Error)]` versehen ist.
    - **`#[from]`-Annotation:** Für Fehler, die direkt von einer Abhängigkeits-Crate stammen und 1:1 übernommen werden können oder eine klare Entsprechung haben, kann `#[from]` verwendet werden.
        
        Rust
        
        ```
        // #
        // pub enum McpSystemClientError {
        //     #[error("MCP client internal error: {0}")]
        //     ClientError(#[from] mcp_client_rs::Error),
        //     //...
        // }
        ```
        
    - **`#[source]`-Annotation:** Wenn ein Fehler aus einer unteren Schicht gewrappt und mit zusätzlichem Kontext versehen wird, sollte der ursprüngliche Fehler mit `#[source]` als Ursache beibehalten werden. Dies ist entscheidend für die `source()`-Kette.
        
        Rust
        
        ```
        // #
        // pub enum AudioManagementError {
        //     #[error("PipeWire connection failed")]
        //     ConnectionError(#[source] pipewire::Error), // Annahme: pipewire::Error ist der Fehlertyp
        //     //...
        // }
        ```
        
    - **Spezifische Fehlervarianten:** Erstellen Sie spezifische Fehlervarianten für häufige oder für die Domänenschicht relevante Fehlerfälle. Dies ermöglicht eine präzisere Fehlerbehandlung in höheren Schichten.
    - **Weitergabe an die Domänenschicht:** Die Domänenschicht sollte idealerweise nicht direkt mit den spezifischen Fehlertypen der Systemschicht-Module konfrontiert werden. Eine übergeordnete `SystemLayerError`-Enum, die alle modul-spezifischen Systemfehler wrappt, oder ein generischerer Ansatz (z.B. `anyhow::Error` mit Kontext) kann verwendet werden, um Fehler an die Domänenschicht zu propagieren. Die `source()`-Kette bleibt dabei erhalten und ermöglicht bei Bedarf eine detaillierte Fehleranalyse.
    - **Logging:** Fehler sollten auf der Systemschicht geloggt werden, bevor sie weitergegeben werden, insbesondere wenn sie nicht trivial sind oder wichtige Kontextinformationen enthalten.

## 7. Schlussfolgerungen und Empfehlungen

Die Entwicklung der Systemschicht für NovaDE stellt eine komplexe Aufgabe dar, die ein tiefes Verständnis der zugrundeliegenden Technologien und Protokolle erfordert. Die gewählte Architektur mit einer klaren Trennung in Module und der Verwendung etablierter Bibliotheken wie Smithay, libinput, zbus und pipewire-rs bildet eine solide Grundlage.

**Zentrale Herausforderungen und Lösungsansätze:**

- **Zustandsmanagement im Compositor:** Die Komplexität des `DesktopState` sollte durch Modularisierung und klare Verantwortlichkeiten reduziert werden. Die `delegate_*!`-Makros von Smithay sind hierbei wertvolle Werkzeuge. Geteilter Zustand erfordert sorgfältige Synchronisation mit `Arc<Mutex/RwLock<T>>`, wobei feingranulare Locks und die Vermeidung von Deadlocks essentiell sind.
- **Wayland-Protokollimplementierung:** Die korrekte Implementierung spezifischer Protokolle wie `wlr-output-management` (Atomarität, Serial-Handling), `wlr-output-power-management` (exklusive Kontrolle) und `wlr-layer-shell` (exklusive Zonen) ist entscheidend für die Funktionalität und Stabilität des Desktops. Die Protokoll-Spezifikationen und existierende Implementierungen (z.B. in wlroots-basierten Compositors) dienen als wichtige Referenzen.
- **Asynchronität und Event-Loop-Integration:** Die Koordination zwischen `calloop` (Compositor) und `tokio` (D-Bus, MCP, Timer) erfordert robuste IPC-Mechanismen wie Kanäle (`tokio::sync::mpsc`, `calloop::channel`) und geteilten Zustand (`Arc<Mutex<T>>`). Für die UI-Integration (GLib) sind `glib::MainContext::spawn_local` und `glib::idle_add_local` Schlüsselkomponenten.
- **Fehlerbehandlung:** Eine konsistente Fehler-Wrapping-Strategie mit `thiserror` unter Beibehaltung der `source()`-Kette ist für Diagnose und Robustheit unerlässlich.

**Empfehlungen für die weitere Entwicklung:**

1. **Priorisierung von Tests:** Angesichts der Komplexität, insbesondere bei der Interaktion verschiedener Protokolle und Event-Loops, sollten Unit- und Integrationstests frühzeitig und umfassend implementiert werden.
2. **Dokumentation und Code-Beispiele:** Die interne Dokumentation sollte detailliert sein. Das Studium von Open-Source-Compositors, die ähnliche Technologien verwenden (z.B. Anvil für Smithay, andere Compositors für wlroots-Protokolle), kann wertvolle Einblicke liefern.
3. **Performance-Analyse:** Regelmäßige Performance-Analysen, insbesondere in kritischen Pfaden wie Rendering und Eingabeverarbeitung, sind notwendig, um Engpässe frühzeitig zu erkennen.
4. **Sicherheitsaspekte:** Bei der Interaktion mit externen Diensten (D-Bus, MCP) und der Verarbeitung von Client-Eingaben müssen Sicherheitsaspekte (Input-Validierung, Berechtigungsmanagement via PolicyKit) berücksichtigt werden.
5. **Iterative Entwicklung:** Aufgrund der Komplexität ist ein iterativer Ansatz, bei dem einzelne Module und Protokolle schrittweise implementiert und getestet werden, empfehlenswert.

Durch die konsequente Anwendung von Best Practices und eine sorgfältige Implementierung der spezifizierten Komponenten kann die Systemschicht von NovaDE eine stabile und leistungsfähige Basis für die darüberliegenden Schichten bilden.

# NovaDE Ultra-Feinspezifikation: Domänenschicht & Wayland/Smithay-Integration

Dieses Dokument definiert die detaillierten technischen Spezifikationen für die Domänenschicht des NovaDE-Projekts und deren Integration mit dem Wayland-Compositor, der unter Verwendung des Smithay-Toolkits implementiert wird. Es dient als direkter Implementierungsleitfaden für Entwickler und beschreibt die Kernarchitektur, Datenstrukturen, APIs und Interaktionsmuster.

## 1. Domänenschicht-Spezifikationen

Die Domänenschicht kapselt die Kernlogik und den Zustand der NovaDE-Desktop-Umgebung. Sie ist bewusst unabhängig von UI-Details und systemspezifischen Implementierungen konzipiert, um eine klare Trennung der Verantwortlichkeiten zu gewährleisten und die Wartbarkeit sowie Testbarkeit des Systems zu verbessern. Diese Schicht bildet das Herzstück von NovaDE und definiert die grundlegenden Entitäten, Regeln und Prozesse, die das Verhalten der Desktop-Umgebung bestimmen.

### 1.1. Modul: `domain::theming`

Dieses Modul ist verantwortlich für die Logik des Erscheinungsbilds (Theming), die Verwaltung von Design-Tokens, die Interpretation von Theme-Definitionen und die Ermöglichung dynamischer Theme-Wechsel. Es stellt die Grundlage für ein konsistentes und anpassbares Benutzererlebnis dar.

Referenzierte Dokumente: B1 Domänenschicht.md

#### 1.1.1. Datenstrukturen (`domain::theming::types`)

Die folgenden Datenstrukturen definieren die Kernentitäten für das Theming-System:

- **`TokenIdentifier`**: Ein Wrapper für `String` zur eindeutigen Identifizierung von Design-Tokens (z.B. `"color.background.primary"`).
    
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `PartialOrd`, `Ord`, `Display`, `From<&str>`.
    - Invarianten: Darf nicht leer sein und darf nur ASCII-Alphanumerische Zeichen, Punkte (`.`) und Bindestriche (`-`) enthalten. Diese strikten Invarianten sind entscheidend, um Parsing-Fehler zu vermeiden und eine konsistente Referenzierung von Tokens im gesamten System sicherzustellen, was die Token-Verwaltung vereinfacht und potenzielle Laufzeitprobleme reduziert.
- **`TokenValue`**: Ein Enum zur Repräsentation der verschiedenen Typen von Token-Werten.
    
    - Varianten: `Color(String)`, `Dimension(String)`, `FontSize(String)`, `FontFamily(String)`, `FontWeight(String)`, `LineHeight(String)`, `LetterSpacing(String)`, `Border(String)`, `Shadow(String)`, `Radius(String)`, `Spacing(String)`, `ZIndex(i32)`, `Opacity(f64)` (Wertebereich 0.0-1.0), `Text(String)`, `Reference(TokenIdentifier)`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
    - Die `Opacity`-Werte werden bei der Zuweisung oder Verarbeitung automatisch auf den Bereich [0.0,1.0] geklemmt, um ungültige Zustände zu verhindern. Die `Reference` Variante ermöglicht es, Tokens aufeinander verweisen zu lassen, was eine flexible und wartbare Theme-Struktur unterstützt.
- **`RawToken`**: Eine Struktur zur Repräsentation eines Tokens, wie es typischerweise aus einer Konfigurationsdatei gelesen wird.
    
    - Felder: `id: TokenIdentifier`, `value: TokenValue`, `description: Option<String>`, `group: Option<String>`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
- **`TokenSet`**: Ein Typalias für `std::collections::BTreeMap<TokenIdentifier, RawToken>`.
    
    - Die Verwendung von `BTreeMap` stellt sicher, dass Tokens bei der Verarbeitung oder Anzeige konsistent sortiert sind, was die Fehlersuche und das Management erleichtert.
- **`ThemeIdentifier`**: Ein Wrapper für `String` zur eindeutigen Identifizierung von Themes.
    
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `PartialOrd`, `Ord`, `Display`, `From<&str>`.
    - Invarianten: Darf nicht leer sein. Empfohlene Zeichen sind `a-z`, `A-Z`, `0-9`, `.` und `-`, um Kompatibilität über verschiedene Dateisysteme und Kontexte hinweg zu gewährleisten.
- **`ColorSchemeType`**: Ein Enum zur Unterscheidung zwischen hellen und dunklen Farbschemata.
    
    - Varianten: `Light`, `Dark`.
    - Implementiert: `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `Default` (standardmäßig `Light`).
- **`AccentColor`**: Eine Struktur zur Repräsentation einer Akzentfarbe innerhalb eines Themes.
    
    - Felder: `name: Option<String>`, `value: novade_core::types::Color`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
    - Für `Eq` und `Hash` auf dem Feld `value` (vom Typ `novade_core::types::Color`) ist möglicherweise eine manuelle Implementierung oder eine Konvertierung in einen kanonischen Hex-String erforderlich, um konsistentes Verhalten in Hash-basierten Sammlungen sicherzustellen.
- **`ThemeVariantDefinition`**: Definiert spezifische Token-Werte für eine bestimmte Theme-Variante (z.B. helles oder dunkles Schema).
    
    - Felder: `applies_to_scheme: ColorSchemeType`, `tokens: TokenSet`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
- **`ThemeDefinition`**: Die vollständige Definition eines Themes, inklusive Basis-Tokens, Varianten und Akzentfarb-Informationen.
    
    - Felder: `id: ThemeIdentifier`, `name: String`, `description: Option<String>`, `author: Option<String>`, `version: Option<String>`, `base_tokens: TokenSet`, `variants: Vec<ThemeVariantDefinition>`, `supported_accent_colors: Option<Vec<AccentColor>>`, `accentable_tokens: Option<HashMap<TokenIdentifier, AccentModificationType>>`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
    - Das Feld `accentable_tokens` ermöglicht eine feingranulare Steuerung, wie Akzentfarben auf einzelne Tokens angewendet werden.
- **`AccentModificationType`**: Ein Enum, das beschreibt, wie ein Token durch eine Akzentfarbe modifiziert werden soll.
    
    - Varianten: `DirectReplace`, `Lighten(f32)`, `Darken(f32)`.
    - Die Parameter für `Lighten` und `Darken` (z.B. `f32`) geben den Grad der Aufhellung oder Abdunkelung an.
- **`AppliedThemeState`**: Repräsentiert den aktuell aktiven, vollständig aufgelösten Theme-Zustand, der an die UI-Schicht übergeben wird.
    
    - Felder: `theme_id: ThemeIdentifier`, `color_scheme: ColorSchemeType`, `active_accent_color: Option<AccentColor>`, `resolved_tokens: std::collections::BTreeMap<TokenIdentifier, String>`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
    - Invarianten: `resolved_tokens` darf keine `TokenValue::Reference` mehr enthalten; alle Werte müssen zu finalen Strings aufgelöst sein. Dies ist kritisch, da die UI-Schicht keine Token-Referenzen interpretieren soll.
- **`ThemingConfiguration`**: Benutzerspezifische Einstellungen für das Theming.
    
    - Felder: `selected_theme_id: ThemeIdentifier`, `preferred_color_scheme: ColorSchemeType`, `selected_accent_color: Option<novade_core::types::Color>`, `custom_user_token_overrides: Option<TokenSet>`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`, `Default`.
    - Die `Default`-Implementierung stellt sicher, dass das System auch ohne explizite Benutzerkonfiguration einen validen Ausgangszustand hat.

#### 1.1.2. Fehlerbehandlung (`domain::theming::errors`)

Das `ThemingError` Enum, definiert mit `thiserror`, kapselt alle potenziellen Fehler, die im Theming-Modul auftreten können. Dies ermöglicht eine präzise und kontextbezogene Fehlerbehandlung.

- **Varianten**:
    - `TokenFileParseError { path: PathBuf, source: serde_json::Error }`: Fehler beim Parsen einer Token-JSON-Datei.
    - `TokenFileIoError { path: PathBuf, source: std::io::Error }`: Fehler beim Lesen/Schreiben einer Token-Datei.
    - `InvalidTokenData { path: PathBuf, message: String }`: Ungültige Datenstruktur in einer Token-Datei.
    - `InvalidTokenValue { token_id: TokenIdentifier, value_string: String, reason: String }`: Ein Token-Wert entspricht nicht dem erwarteten Format oder Typ.
    - `CyclicTokenReference { token_id: TokenIdentifier, cycle_path: Vec<TokenIdentifier> }`: Zyklische Abhängigkeit bei der Token-Referenzierung entdeckt.
    - `ThemeFileLoadError { theme_id: ThemeIdentifier, path: PathBuf, source: serde_json::Error }`: Fehler beim Parsen einer Theme-JSON-Datei.
    - `ThemeFileIoError { theme_id: ThemeIdentifier, path: PathBuf, source: std::io::Error }`: Fehler beim Lesen/Schreiben einer Theme-Datei.
    - `InvalidThemeData { theme_id: ThemeIdentifier, path: PathBuf, message: String }`: Ungültige Datenstruktur in einer Theme-Datei.
    - `ThemeNotFound { theme_id: ThemeIdentifier }`: Das angeforderte Theme konnte nicht gefunden werden.
    - `MissingTokenReference { referencing_token_id: TokenIdentifier, target_token_id: TokenIdentifier }`: Ein referenziertes Token existiert nicht.
    - `MaxReferenceDepthExceeded { token_id: TokenIdentifier, depth: u8 }`: Die maximale Tiefe für Token-Referenzen wurde überschritten, um Endlosschleifen zu verhindern.
    - `ThemeApplicationError { message: String, source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`: Allgemeiner Fehler bei der Anwendung eines Themes.
    - `FallbackThemeLoadError { source: Box<dyn std::error::Error + Send + Sync + 'static>> }`: Fehler beim Laden des Fallback-Themes.
    - `InitialConfigurationError(String)`: Fehler bei der Initialisierung der Theming-Konfiguration.
    - `InternalStateError(String)`: Unerwarteter interner Fehler im Theming-Modul.
    - `EventSubscriptionError(String)`: Fehler bei der Registrierung für Theme-Änderungs-Events.
    - `AccentColorApplicationError { theme_id: ThemeIdentifier, accent_color: novade_core::types::Color, details: String }`: Fehler bei der Anwendung einer Akzentfarbe.
    - `TokenResolutionError { token_id: TokenIdentifier, message: String, source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`: Fehler während der Auflösung eines spezifischen Tokens.
    - `FilesystemError(#[from] novade_core::errors::CoreError)`: Fehler im Zusammenhang mit Dateisystemoperationen, die von `novade_core` stammen.

#### 1.1.3. Kernlogik (`domain::theming::logic`)

Die Kernlogik des Theming-Moduls umfasst das Laden, Validieren und Auflösen von Themes und Tokens.

- **Konstante**: `MAX_TOKEN_RESOLUTION_DEPTH: u8 = 16`. Dieser Wert begrenzt die Rekursionstiefe bei der Auflösung von Token-Referenzen, um Endlosschleifen und übermäßigen Ressourcenverbrauch zu verhindern. Der Wert 16 stellt einen pragmatischen Kompromiss zwischen Flexibilität und Sicherheit dar.
    
- **Token/Theme Laden & Validieren**:
    
    - `async fn load_raw_tokens_from_file(path: &Path, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`: Liest eine JSON-Datei vom angegebenen Pfad, parst deren Inhalt zu einem `TokenSet` und validiert auf Duplikate sowie das grundlegende Format der Tokens. Nutzt den `ConfigServiceAsync` für asynchrone Dateioperationen.
    - `async fn load_and_validate_token_files(paths: &, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`: Lädt Tokens von mehreren Pfaden, führt sie zusammen (wobei Benutzer-Tokens System-Tokens überschreiben) und validiert das Ergebnis auf Zyklen und andere Inkonsistenzen.
    - `async fn load_theme_definition_from_file(path: &Path, theme_id_override: Option<ThemeIdentifier>, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<ThemeDefinition, ThemingError>`: Liest eine JSON-Datei und parst sie zu einer `ThemeDefinition`. Ermöglicht das Überschreiben der Theme-ID, falls diese nicht im Dateinamen enthalten ist oder anders abgeleitet werden muss.
    - `async fn load_and_validate_theme_files(paths: &, available_tokens: &TokenSet, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<Vec<ThemeDefinition>, ThemingError>`: Lädt mehrere Theme-Definitionen von den angegebenen Pfaden und validiert die darin enthaltenen Token-Referenzen gegen den Satz der global verfügbaren Tokens (`available_tokens`).
    - `fn validate_tokenset_for_cycles(tokens: &TokenSet) -> Result<(), ThemingError>`: Verwendet eine Tiefensuche (Depth-First Search, DFS), um zyklische Referenzen innerhalb eines `TokenSet` zu erkennen.
- **Token Resolution Pipeline**:
    
    - `fn resolve_tokens_for_config(config: &ThemingConfiguration, theme_def: &ThemeDefinition, global_tokens: &TokenSet, accentable_tokens_map: &HashMap<TokenIdentifier, AccentModificationType>, max_depth: u8) -> Result<BTreeMap<TokenIdentifier, String>, ThemingError>`: Diese zentrale Funktion ist verantwortlich für die Auflösung aller Tokens zu ihren finalen String-Werten basierend auf der aktuellen Konfiguration.
        
        1. Startet mit einer Basis-Token-Menge, die aus globalen Tokens und den Basis-Tokens des ausgewählten Themes besteht.
        2. Wendet die Tokens der passenden Theme-Variante (hell/dunkel) an, die die Basis-Tokens überschreiben.
        3. Appliziert die ausgewählte Akzentfarbe. Dies geschieht durch Modifikation der Tokens, die im `accentable_tokens_map` des Themes definiert sind, gemäß dem `AccentModificationType`.
        4. Wendet benutzerspezifische Token-Overrides an, die die höchste Priorität haben.
        5. Führt eine rekursive Auflösung für alle Tokens vom Typ `TokenValue::Reference` durch. Dabei wird die Funktion `resolve_single_token_value` (nicht explizit in der API, aber impliziert durch die Logik) verwendet, die eine Zyklenerkennung und eine Begrenzung der Rekursionstiefe (`max_depth`) implementiert.
        6. Konvertiert alle aufgelösten `TokenValue`-Instanzen in ihre finalen String-Repräsentationen (z.B. Farbcodes, Dimensionsangaben).
        
        - Das Ergebnis ist ein `BTreeMap<TokenIdentifier, String>`, das keine Referenzen mehr enthält und direkt von der UI-Schicht verwendet werden kann.
- **Caching**:
    
    - Ein Cache für `AppliedThemeState` wird implementiert, um die wiederholte, potenziell aufwendige Auflösung von Tokens zu vermeiden.
    - Der Cache-Schlüssel (`CacheKey`) wird gebildet aus: `(ThemeIdentifier, ColorSchemeType, Option<String> /* hex von AccentColor */, u64 /* hash von Overrides */)`.
    - Diese Strategie stellt sicher, dass bei relevanten Änderungen der Konfiguration ein neuer Zustand generiert wird, während bei unveränderter Konfiguration auf den gecachten Zustand zurückgegriffen werden kann.
- **Fallback**:
    
    - `fn generate_fallback_applied_state() -> AppliedThemeState`: Generiert einen minimalen, aber funktionsfähigen `AppliedThemeState` aus einkompilierten JSON-Definitionen. Dies stellt sicher, dass das System auch dann ein grundlegendes Erscheinungsbild hat, wenn keine Theme-Dateien geladen werden können oder Konfigurationsfehler auftreten.

#### 1.1.4. API (`domain::theming::service::ThemingEngine`)

Die `ThemingEngine` ist die zentrale Schnittstelle für andere Teile des Systems, um auf Theming-Funktionalitäten zuzugreifen.

- **Struktur `ThemingEngineInternalState`**: Kapselt den internen, veränderlichen Zustand der Engine.
    
    - Felder: `current_config: ThemingConfiguration`, `available_themes: Vec<ThemeDefinition>`, `global_raw_tokens: TokenSet`, `applied_state: AppliedThemeState`, `theme_load_paths: Vec<PathBuf>`, `token_load_paths: Vec<PathBuf>`, `resolved_state_cache: HashMap<CacheKey, AppliedThemeState>`, `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>`.
    - Die Verwendung von `Arc` für `config_service` ermöglicht die gemeinsame Nutzung dieses Dienstes.
- **Struktur `ThemingEngine`**: Die öffentliche API-Struktur.
    
    - Felder: `internal_state: Arc<tokio::sync::Mutex<ThemingEngineInternalState>>`, `event_sender: tokio::sync::broadcast::Sender<ThemeChangedEvent>`.
    - Die Verwendung von `Arc<tokio::sync::Mutex<...>>` gewährleistet Thread-sicheren Zugriff auf den internen Zustand in einer asynchronen Umgebung.
    - `tokio::sync::broadcast::Sender` wird für die Veröffentlichung von Theme-Änderungs-Events verwendet.
- **Methoden**:
    
    - `async fn new(initial_config: ThemingConfiguration, theme_load_paths: Vec<PathBuf>, token_load_paths: Vec<PathBuf>, config_service: Arc<dyn novade_core::config::ConfigServiceAsync>, broadcast_capacity: usize) -> Result<Self, ThemingError>`: Konstruktor, der die Engine initialisiert, initiale Themes und Tokens lädt und den ersten `AppliedThemeState` generiert.
    - `async fn get_current_theme_state(&self) -> AppliedThemeState`: Gibt den aktuell angewendeten und aufgelösten Theme-Zustand zurück.
    - `async fn get_available_themes(&self) -> Vec<ThemeDefinition>`: Gibt eine Liste aller verfügbaren Theme-Definitionen zurück.
    - `async fn get_current_configuration(&self) -> ThemingConfiguration`: Gibt die aktuelle Benutzerkonfiguration für das Theming zurück.
    - `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`: Aktualisiert die Benutzerkonfiguration, löst die Tokens neu auf, aktualisiert den Cache und publiziert ein `ThemeChangedEvent`.
    - `async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`: Lädt alle Theme- und Token-Dateien von den konfigurierten Pfaden neu, validiert sie, aktualisiert den internen Zustand und den Cache und publiziert ggf. ein `ThemeChangedEvent`.
    - `fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeChangedEvent>`: Ermöglicht anderen Modulen, auf Änderungen des Themes zu reagieren.

#### 1.1.5. Events (`domain::theming::events`)

- **`ThemeChangedEvent`**: Wird publiziert, wenn sich der angewendete Theme-Zustand ändert.
    - Payload: `new_state: AppliedThemeState`.
    - Dieses Event ist entscheidend für die dynamische Aktualisierung der Benutzeroberfläche, ohne dass Komponenten den `ThemingEngine` ständig pollen müssen.

### 1.2. Modul: `domain::workspaces`

Dieses Modul ist für die Logik und Verwaltung von Arbeitsbereichen (auch "Spaces" oder "virtuelle Desktops" genannt) zuständig. Es definiert, wie Arbeitsbereiche erstellt, modifiziert, gelöscht und wie Fenster ihnen zugewiesen werden.

Referenzierte Dokumente: B2 Domänenschicht.md

#### 1.2.1. Untermodul: `domain::workspaces::core`

Das `core`-Untermodul definiert die grundlegenden Datenstrukturen, Entitäten und Kernfehler für Arbeitsbereiche.

- **Datenstrukturen (`domain::workspaces::core::types`)**:
    
    - `WorkspaceId`: Ein Typalias für `uuid::Uuid`, um Arbeitsbereiche eindeutig zu identifizieren. Die Verwendung von UUIDs stellt globale Eindeutigkeit sicher, was bei der Synchronisation oder bei verteilten Szenarien vorteilhaft sein kann.
    - `WindowIdentifier`: Ein Wrapper für `String` zur Identifizierung von Fenstern.
        - Implementiert `new(id: impl Into<String>) -> Result<Self, WorkspaceCoreError>`. Die Validierung (z.B. nicht leer) erfolgt hier. Dies stellt sicher, dass Fensterbezeichner immer in einem validen Zustand sind.
    - `WorkspaceLayoutType`: Ein Enum zur Definition der verschiedenen Layout-Modi eines Arbeitsbereichs.
        - Varianten: `Floating`, `TilingHorizontal`, `TilingVertical`, `Maximized`.
        - Implementiert `Default` (standardmäßig `Floating`).
- **Entität `Workspace` (`domain::workspaces::core::mod.rs`)**: Die zentrale Entität, die einen Arbeitsbereich repräsentiert.
    
    - Felder:
        - `id: WorkspaceId`: Eindeutiger Identifikator.
        - `name: String`: Vom Benutzer lesbarer Name des Arbeitsbereichs (z.B. "Arbeit", "Web").
        - `persistent_id: Option<String>`: Eine optionale, persistente ID, die über Sitzungen hinweg stabil bleiben kann (z.B. für das Wiederherstellen von Arbeitsbereichs-Setups).
        - `layout_type: WorkspaceLayoutType`: Der aktuelle Layout-Modus.
        - `window_ids: HashSet<WindowIdentifier>`: Eine Menge der IDs der Fenster, die diesem Arbeitsbereich zugeordnet sind.
        - `created_at: DateTime<Utc>`: Zeitstempel der Erstellung.
        - `icon_name: Option<String>`: Optionaler Name eines Icons zur visuellen Repräsentation.
        - `accent_color_hex: Option<String>`: Optionale Akzentfarbe im Hex-Format für den Arbeitsbereich.
    - Methoden:
        - `new(name: String, persistent_id: Option<String>, layout_type: WorkspaceLayoutType, icon_name: Option<String>, accent_color_hex: Option<String>) -> Result<Self, WorkspaceCoreError>`: Konstruktor für neue Arbeitsbereiche. Validiert Eingaben wie `name` und `accent_color_hex`.
        - `id() -> WorkspaceId`: Gibt die ID des Arbeitsbereichs zurück.
        - `name() -> &str`: Gibt den Namen des Arbeitsbereichs zurück.
        - `rename(&mut self, new_name: String) -> Result<(), WorkspaceCoreError>`: Ändert den Namen des Arbeitsbereichs. Validiert den neuen Namen.
        - `set_layout_type(&mut self, layout_type: WorkspaceLayoutType)`: Ändert den Layout-Typ.
        - `add_window_id(&mut self, window_id: WindowIdentifier)` (`crate`-intern): Fügt eine Fenster-ID hinzu. Die Sichtbarkeit ist auf `crate` beschränkt, da die Fensterzuweisung über den `assignment`-Service erfolgen soll.
        - `remove_window_id(&mut self, window_id: &WindowIdentifier) -> bool` (`crate`-intern): Entfernt eine Fenster-ID.
        - `set_icon_name(&mut self, icon_name: Option<String>)`: Setzt den Icon-Namen.
        - `set_accent_color_hex(&mut self, accent_color_hex: Option<String>) -> Result<(), WorkspaceCoreError>`: Setzt die Akzentfarbe und validiert das Format.
- **Event-Payloads (`domain::workspaces::core::event_data`)**: Strukturen, die als Daten für die verschiedenen Arbeitsbereichs-Events dienen.
    
    - `WorkspaceRenamedData { new_name: String }`
    - `WorkspaceLayoutChangedData { new_layout: WorkspaceLayoutType }`
    - `WindowAddedToWorkspaceData { window_id: WindowIdentifier }`
    - `WindowRemovedFromWorkspaceData { window_id: WindowIdentifier }`
    - `WorkspacePersistentIdChangedData { new_persistent_id: Option<String> }`
    - `WorkspaceIconChangedData { new_icon_name: Option<String> }`
    - `WorkspaceAccentChangedData { new_accent_color_hex: Option<String> }`
- **Fehlerbehandlung (`domain::workspaces::core::errors`)**:
    
    - `WorkspaceCoreError`: Enum für Fehler, die direkt bei der Manipulation einer `Workspace`-Entität auftreten können.
        - Varianten: `InvalidName`, `NameCannotBeEmpty`, `NameTooLong`, `InvalidPersistentId`, `WindowIdentifierEmpty`, `InvalidAccentColorFormat`.

#### 1.2.2. Untermodul: `domain::workspaces::assignment`

Dieses Untermodul stellt die API für die Zuordnung von Fenstern zu Arbeitsbereichen bereit. Es stellt sicher, dass die Regeln für Fensterzuweisungen eingehalten werden.

- **API (`domain::workspaces::assignment::mod.rs`)**: Funktionen, die auf einer veränderlichen `HashMap<WorkspaceId, Workspace>` operieren. Dieser Ansatz ermöglicht es, die Zuordnungslogik von der Hauptverwaltung der Arbeitsbereiche zu entkoppeln, macht aber eine sorgfältige Zustandsverwaltung erforderlich, um Konsistenz zu gewährleisten.
    
    - `assign_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier, ensure_unique_assignment: bool) -> Result<(), WindowAssignmentError>`: Weist ein Fenster einem spezifischen Arbeitsbereich zu. Der Parameter `ensure_unique_assignment` steuert, ob ein Fenster zuvor von allen anderen Arbeitsbereichen entfernt werden muss.
    - `remove_window_from_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<bool, WindowAssignmentError>`: Entfernt ein Fenster von einem spezifischen Arbeitsbereich. Gibt `true` zurück, wenn das Fenster entfernt wurde.
    - `move_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, window_id: &WindowIdentifier, source_workspace_id: WorkspaceId, target_workspace_id: WorkspaceId) -> Result<(), WindowAssignmentError>`: Verschiebt ein Fenster von einem Quell- zu einem Zielarbeitsbereich.
    - `find_workspace_for_window(workspaces: &HashMap<WorkspaceId, Workspace>, window_id: &WindowIdentifier) -> Option<WorkspaceId>`: Findet den Arbeitsbereich, dem ein bestimmtes Fenster zugewiesen ist.
- **Fehlerbehandlung (`domain::workspaces::assignment::errors`)**:
    
    - `WindowAssignmentError`: Enum für Fehler, die bei der Fensterzuweisung auftreten können.
        - Varianten: `WorkspaceNotFound`, `WindowAlreadyAssigned` (wenn `ensure_unique_assignment` true ist und das Fenster bereits auf dem Ziel-Workspace ist oder auf einem anderen und nicht entfernt werden konnte), `WindowNotAssignedToWorkspace`, `SourceWorkspaceNotFound`, `TargetWorkspaceNotFound`, `WindowNotOnSourceWorkspace`, `CannotMoveToSameWorkspace`, `RuleViolation` (für zukünftige, komplexere Zuweisungsregeln), `Internal`.

#### 1.2.3. Untermodul: `domain::workspaces::config`

Verantwortlich für die Persistenz und das Laden von Arbeitsbereichs-Konfigurationen.

- **Datenstrukturen (`domain::workspaces::config::mod.rs`)**:
    
    - `WorkspaceSnapshot`: Eine serialisierbare Repräsentation eines Arbeitsbereichs für die Speicherung. Enthält nur persistente Eigenschaften.
        - Felder: `persistent_id: String`, `name: String`, `layout_type: WorkspaceLayoutType`, `icon_name: Option<String>`, `accent_color_hex: Option<String>`.
    - `WorkspaceSetSnapshot`: Eine serialisierbare Repräsentation eines Sets von Arbeitsbereichen und des aktiven Arbeitsbereichs.
        - Felder: `workspaces: Vec<WorkspaceSnapshot>`, `active_workspace_persistent_id: Option<String>`.
- **API (`domain::workspaces::config::mod.rs`)**:
    
    - Trait `WorkspaceConfigProvider`: Definiert die Schnittstelle für das Laden und Speichern von Arbeitsbereichs-Konfigurationen.
        - `async fn load_workspace_config(&self) -> Result<WorkspaceSetSnapshot, WorkspaceConfigError>`
        - `async fn save_workspace_config(&self, snapshot: &WorkspaceSetSnapshot) -> Result<(), WorkspaceConfigError>`
    - Struktur `FilesystemConfigProvider`: Eine Implementierung von `WorkspaceConfigProvider`, die `novade_core::config::ConfigServiceAsync` für Dateioperationen verwendet. Dies entkoppelt die Workspace-Logik von den Details der Dateispeicherung.
- **Fehlerbehandlung (`domain::workspaces::config::errors`)**:
    
    - `WorkspaceConfigError`: Enum für Fehler im Zusammenhang mit der Konfigurationspersistenz.
        - Varianten: `LoadError { source: novade_core::errors::CoreError }`, `SaveError { source: novade_core::errors::CoreError }`, `InvalidData { message: String }`, `SerializationError { source: serde_json::Error }`, `DeserializationError { source: serde_json::Error }`, `PersistentIdNotFoundInLoadedSet { persistent_id: String }`, `DuplicatePersistentIdInLoadedSet { persistent_id: String }`.

#### 1.2.4. Untermodul: `domain::workspaces::manager`

Der `WorkspaceManagerService` ist die Hauptschnittstelle zur Verwaltung von Arbeitsbereichen. Er orchestriert die `core`-, `assignment`- und `config`-Logik.

- **API (`domain::workspaces::manager::mod.rs`)**:
    
    - Trait `WorkspaceManagerService`: Definiert die öffentliche API für die Arbeitsbereichsverwaltung.
        - Methoden: `async fn create_workspace(&self, name: String, persistent_id: Option<String>, layout_type: Option<WorkspaceLayoutType>, icon: Option<String>, accent_color: Option<String>) -> Result<Workspace, WorkspaceManagerError>`, `async fn delete_workspace(&self, id: WorkspaceId, fallback_workspace_id: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError>`, `async fn get_workspace(&self, id: WorkspaceId) -> Option<Workspace>`, `async fn all_workspaces_ordered(&self) -> Vec<Workspace>`, `async fn active_workspace_id(&self) -> Option<WorkspaceId>`, `async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`, `async fn assign_window_to_active_workspace(&self, window_id: WindowIdentifier) -> Result<(), WorkspaceManagerError>`, `async fn assign_window_to_specific_workspace(&self, workspace_id: WorkspaceId, window_id: WindowIdentifier) -> Result<(), WorkspaceManagerError>`, `async fn remove_window_from_its_workspace(&self, window_id: &WindowIdentifier) -> Result<bool, WorkspaceManagerError>`, `async fn move_window_to_specific_workspace(&self, window_id: &WindowIdentifier, target_workspace_id: WorkspaceId) -> Result<(), WorkspaceManagerError>`, `async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`, `async fn set_workspace_layout(&self, id: WorkspaceId, layout: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>`, `async fn set_workspace_icon(&self, id: WorkspaceId, icon_name: Option<String>) -> Result<(), WorkspaceManagerError>`, `async fn set_workspace_accent_color(&self, id: WorkspaceId, accent_color_hex: Option<String>) -> Result<(), WorkspaceManagerError>`, `async fn save_configuration(&self) -> Result<(), WorkspaceManagerError>`, `fn subscribe_to_workspace_events(&self) -> tokio::sync::broadcast::Receiver<WorkspaceEvent>`, `async fn reorder_workspace(&self, workspace_id: WorkspaceId, new_index: usize) -> Result<(), WorkspaceManagerError>`.
- **Implementierung `DefaultWorkspaceManager`**: Hält einen `Arc<tokio::sync::Mutex<WorkspaceManagerInternalState>>`.
    
    - `WorkspaceManagerInternalState`: Kapselt den internen Zustand.
        - Felder: `workspaces: HashMap<WorkspaceId, Workspace>`, `active_workspace_id: Option<WorkspaceId>`, `ordered_workspace_ids: Vec<WorkspaceId>`, `next_workspace_number: u32` (für Standardnamen neuer Workspaces), `config_provider: Arc<dyn WorkspaceConfigProvider>`, `event_publisher: tokio::sync::broadcast::Sender<WorkspaceEvent>`, `ensure_unique_window_assignment: bool`.
        - Die Option `ensure_unique_window_assignment` steuert, ob ein Fenster nur einem Arbeitsbereich gleichzeitig zugewiesen sein darf. Dies ist eine wichtige Policy-Entscheidung.
- **Events (`domain::workspaces::manager::events`)**:
    
    - `WorkspaceEvent`: Enum, das alle relevanten Änderungen an Arbeitsbereichen und Fensterzuweisungen repräsentiert.
        - Varianten: `WorkspaceCreated { workspace: Workspace }`, `WorkspaceDeleted { workspace_id: WorkspaceId, windows_moved_to: Option<WorkspaceId> }`, `ActiveWorkspaceChanged { old_id: Option<WorkspaceId>, new_id: WorkspaceId }`, `WorkspaceRenamed { workspace_id: WorkspaceId, data: WorkspaceRenamedData }`, `WorkspaceLayoutChanged { workspace_id: WorkspaceId, data: WorkspaceLayoutChangedData }`, `WindowAddedToWorkspace { workspace_id: WorkspaceId, data: WindowAddedToWorkspaceData }`, `WindowRemovedFromWorkspace { workspace_id: WorkspaceId, data: WindowRemovedFromWorkspaceData }`, `WorkspaceOrderChanged { ordered_ids: Vec<WorkspaceId> }`, `WorkspacesReloaded { new_workspaces: Vec<Workspace>, new_active_id: Option<WorkspaceId> }`, `WorkspacePersistentIdChanged { workspace_id: WorkspaceId, data: WorkspacePersistentIdChangedData }`, `WorkspaceIconChanged { workspace_id: WorkspaceId, data: WorkspaceIconChangedData }`, `WorkspaceAccentChanged { workspace_id: WorkspaceId, data: WorkspaceAccentChangedData }`.
- **Fehlerbehandlung (`domain::workspaces::manager::errors`)**:
    
    - `WorkspaceManagerError`: Enum für Fehler auf der Manager-Ebene.
        - Varianten: `WorkspaceNotFound { id: WorkspaceId }`, `CannotDeleteLastWorkspace`, `DeleteRequiresFallbackForWindows { num_windows: usize }`, `FallbackWorkspaceNotFound { id: WorkspaceId }`, `CoreError(#[from] WorkspaceCoreError)`, `AssignmentError(#[from] WindowAssignmentError)`, `ConfigError(#[from] WorkspaceConfigError)`, `SetActiveWorkspaceNotFound { id: WorkspaceId }`, `NoActiveWorkspace`, `DuplicatePersistentId { id: String }`, `Internal { message: String }`.

### 1.3. Modul: `domain::user_centric_services`

Dieses Modul bündelt Domänenlogik für Dienste, die direkt auf Benutzerinteraktionen und -bedürfnisse ausgerichtet sind, insbesondere KI-Interaktionen und Benachrichtigungen.

Referenzierte Dokumente: B3 Domänenschicht.md, B4 Domänenschicht.md

#### 1.3.1. Untermodul: `domain::user_centric_services::ai_interaction`

Verantwortlich für die Logik rund um KI-gestützte Interaktionen, Einwilligungsmanagement und die Verwaltung von KI-Modellprofilen.

- **Datenstrukturen (`domain::user_centric_services::ai_interaction::types`)**:
    
    - `AIDataCategory`: Enum zur Kategorisierung von Daten, die für KI-Interaktionen verwendet werden (z.B. `UserProfile`, `ApplicationUsage`, `FileSystemRead`).
    - `AIConsentStatus`: Enum für den Einwilligungsstatus (z.B. `Granted`, `Denied`, `PendingUserAction`). Die Variante `NotRequired` ist nützlich für Interaktionen, die keine explizite Einwilligung erfordern.
    - `AttachmentData`: Struktur für Anhänge an KI-Interaktionen (z.B. Dateien, Textauszüge). Die Felder `source_uri`, `content_base64`, `text_content` bieten Flexibilität für verschiedene Anhangstypen.
    - `InteractionParticipant`: Enum zur Kennzeichnung der Teilnehmer einer Interaktion (`User`, `Assistant`, `System`).
    - `InteractionHistoryEntry`: Repräsentiert einen einzelnen Eintrag im Interaktionsverlauf.
    - `AIInteractionContext`: Die zentrale Entität, die den gesamten Kontext einer KI-Interaktion kapselt, inklusive Verlauf, Anhängen und Einwilligungsstatus.
    - `AIConsentScope`: Enum zur Definition des Gültigkeitsbereichs einer Einwilligung (z.B. `SessionOnly`, `PersistentUntilRevoked`).
    - `AIConsent`: Struktur zur Speicherung detaillierter Einwilligungsinformationen.
    - `AIModelCapability`: Enum zur Beschreibung der Fähigkeiten eines KI-Modells (z.B. `TextGeneration`, `ImageAnalysis`).
    - `AIModelProfile`: Struktur zur Definition der Eigenschaften und Fähigkeiten eines KI-Modells. Das Feld `sort_order` ermöglicht eine benutzerdefinierte Sortierung der Modelle in der UI.
- **Fehlerbehandlung (`domain::user_centric_services::ai_interaction::errors`)**:
    
    - `AIInteractionError`: Enum für Fehler im KI-Interaktionsmodul (z.B. `ConsentCheckFailed`, `ApiKeyNotFoundInSecrets`, `ModelEndpointUnreachable`, `NoDefaultModelConfigured`, `CoreConfigError(#[from] novade_core::errors::CoreError)`).
- **Persistenz-Interfaces (`domain::user_centric_services::ai_interaction::persistence_iface`)**:
    
    - Traits `AIConsentProvider` und `AIModelProfileProvider`: Definieren Schnittstellen für das Laden und Speichern von Einwilligungen und Modellprofilen, was eine Entkopplung von der konkreten Speicherimplementierung ermöglicht.
- **API (`domain::user_centric_services::ai_interaction::service::AIInteractionLogicService`)**:
    
    - Trait mit Methoden wie `initiate_interaction`, `get_interaction_context`, `provide_consent`, `load_model_profiles`.
- **Implementierung `DefaultAIInteractionLogicService`**: Konkrete Implementierung des `AIInteractionLogicService`.
    
- **Events (`domain::user_centric_services::ai_interaction::events::AIInteractionEventEnum`)**:
    
    - Events wie `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`, `AIContextUpdatedEvent`, `AIModelProfilesReloadedEvent` zur Benachrichtigung anderer Systemteile über relevante Änderungen.

#### 1.3.2. Untermodul: `domain::user_centric_services::notifications_core`

Verantwortlich für die Kernlogik der Benachrichtigungsverwaltung, inklusive Erstellung, Speicherung, Filterung und Interaktion mit Benachrichtigungen.

- **Datenstrukturen (`domain::user_centric_services::notifications_core::types`)**:
    
    - `NotificationId`: Typalias für `uuid::Uuid`.
    - `NotificationUrgency`: Enum für die Dringlichkeit (`Low`, `Normal`, `Critical`).
    - `NotificationActionType`: Enum für Aktionstypen (`Callback`, `OpenLink`).
    - `NotificationAction`: Struktur für Aktionen, die einer Benachrichtigung zugeordnet sind.
    - `Notification`: Die Hauptentität, die eine Benachrichtigung repräsentiert. Enthält Felder wie `id`, `application_name`, `summary`, `body`, `actions`, `urgency`, `timestamp`, `is_read`, `is_dismissed`, `transient`, `category`, `hints`, `timeout_ms`.
    - `NotificationInput`: Eine Struktur zum Erstellen neuer Benachrichtigungen, ohne laufzeitgenerierte Felder wie `id` oder `timestamp`. Dies vereinfacht die API zum Posten von Benachrichtigungen.
    - `NotificationFilterCriteria`: Ein Enum für komplexe Filterkriterien, das logische UND/ODER/NICHT-Operationen sowie Filter auf Zeitbereiche unterstützt. Dies ermöglicht mächtige Abfragen des Benachrichtigungsverlaufs.
    - `NotificationSortOrder`: Enum für Sortierkriterien.
    - `NotificationStats`: Struktur zur Bereitstellung von Statistiken (z.B. `num_active`, `num_unread`), nützlich für UI-Anzeigen.
    - `DismissReason`: Enum zur Angabe des Grundes für das Schließen einer Benachrichtigung (z.B. `User`, `Timeout`), nützlich für Analysen und intelligente Benachrichtigungslogik.
- **Fehlerbehandlung (`domain::user_centric_services::notifications_core::errors`)**:
    
    - `NotificationError`: Enum für Fehler im Benachrichtigungssystem (z.B. `NotFound`, `InvalidData`, `HistoryFull`).
- **API (`domain::user_centric_services::notifications_core::service::NotificationService`)**:
    
    - Trait mit Methoden wie `post_notification(input: NotificationInput)`, `get_notification`, `mark_as_read`, `dismiss_notification`, `get_active_notifications`, `get_notification_history`, `set_do_not_disturb`, `invoke_action`, `get_stats`.
- **Implementierung `DefaultNotificationService`**: Konkrete Implementierung des `NotificationService`.
    
- **Events (`domain::user_centric_services::notifications_core::events::NotificationEventEnum`)**:
    
    - Events wie `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `DoNotDisturbModeChangedEvent` zur Benachrichtigung der UI und anderer Systemteile.

### 1.4. Modul: `domain::notifications_rules`

Ermöglicht eine regelbasierte Verarbeitung von eingehenden Benachrichtigungen, um deren Verhalten (z.B. Unterdrückung, Änderung der Dringlichkeit) basierend auf benutzerdefinierten Kriterien anzupassen.

Referenzierte Dokumente: B4 Domänenschicht.md

#### 1.4.1. Datenstrukturen (`domain::notifications_rules::types`)

- `RuleConditionValue`: Enum für die Werte in Regelbedingungen (z.B. `String(String)`, `Urgency(NotificationUrgency)`).
- `RuleConditionOperator`: Enum für Vergleichsoperatoren (z.B. `Is`, `Contains`, `MatchesRegex`).
- `RuleConditionField`: Enum zur Spezifizierung des Benachrichtigungsfeldes, auf das sich eine Bedingung bezieht (z.B. `ApplicationName`, `Summary`, `HintExists(String)`). Die Varianten `HintExists` und `HintValue` erlauben flexible Bedingungen basierend auf den `hints` einer Benachrichtigung.
- `SimpleRuleCondition`: Eine einfache Bedingung bestehend aus Feld, Operator und Wert.
- `RuleCondition`: Ein Enum, das komplexe, verschachtelte Bedingungen durch logische Operatoren (`And`, `Or`, `Not`) ermöglicht. Die Variante `SettingIsTrue(SettingPath)` erlaubt es, Regeln basierend auf globalen Einstellungen zu definieren, was eine starke Integration mit dem `GlobalSettingsService` ermöglicht.
- `RuleAction`: Enum für Aktionen, die ausgeführt werden, wenn eine Regel zutrifft (z.B. `SuppressNotification`, `SetUrgency`, `PlaySound`). Die Aktion `StopProcessingFurtherRules` bietet eine explizite Kontrolle über den Regelauswertungsfluss.
- `NotificationRule`: Repräsentiert eine einzelne Regel mit ID, Name, Bedingung, Aktionen, Aktivierungsstatus und Priorität. Die `Default`-Implementierung kann für das einfache Erstellen neuer Regeln in einer UI nützlich sein.
- `NotificationRuleSet`: Typalias für `Vec<NotificationRule>`. Die Reihenfolge in diesem Vektor ist relevant für die Regelauswertung, da Regeln typischerweise basierend auf ihrer Priorität und/oder Reihenfolge verarbeitet werden.

#### 1.4.2. Fehlerbehandlung (`domain::notifications_rules::errors`)

- `NotificationRulesError`: Enum für Fehler im Regelmodul (z.B. `InvalidRuleDefinition`, `ConditionEvaluationError`, `SettingsAccessError(#[from] GlobalSettingsError)`, `InvalidRegex`).

#### 1.4.3. API (`domain::notifications_rules::engine::NotificationRulesEngine`)

- Trait `NotificationRulesEngine`:
    - Methoden: `async fn reload_rules(&mut self)`, `async fn process_notification(&self, notification: Notification) -> Result<RuleProcessingResult, NotificationRulesError>`, `async fn get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`, `async fn update_rules(&mut self, new_rules: NotificationRuleSet) -> Result<(), NotificationRulesError>`.
- Implementierung `DefaultNotificationRulesEngine`: Hält einen `Arc<tokio::sync::RwLock<NotificationRuleSet>>`, einen `Arc<dyn NotificationRulesProvider>` und einen `Arc<dyn GlobalSettingsService>`. Die Verwendung von `RwLock` ermöglicht konkurrierenden Lesezugriff auf die Regeln, während Schreibzugriffe exklusiv sind.
- Enum `RuleProcessingResult`: Gibt das Ergebnis der Regelverarbeitung an.
    - Varianten: `Allow(Notification)` (die Benachrichtigung darf angezeigt werden, möglicherweise modifiziert), `Suppress { rule_id: Uuid }` (die Benachrichtigung soll unterdrückt werden).

#### 1.4.4. Persistenz (`domain::notifications_rules::persistence_iface`)

- Trait `NotificationRulesProvider`: Definiert die Schnittstelle zum Laden und Speichern von Regelwerken.
    - Methoden: `async fn load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`, `async fn save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`.
- Implementierung `FilesystemNotificationRulesProvider`: Speichert Regeln im Dateisystem, typischerweise als JSON.

### 1.5. Modul: `domain::global_settings_and_state_management`

Verwaltet globale Desktop-Einstellungen und deren Persistenz. Dieses Modul ist zentral für die Konfiguration vieler Aspekte der Desktop-Umgebung.

Referenzierte Dokumente: B3 Domänenschicht.md, B4 Domänenschicht.md

#### 1.5.1. Datenstrukturen (`domain::global_settings_and_state_management::types`)

- `GlobalDesktopSettings`: Die Hauptstruktur, die alle globalen Einstellungen enthält.
    - Felder: `appearance: AppearanceSettings`, `workspace_config: WorkspaceSettings`, `input_behavior: InputBehaviorSettings`, `power_management_policy: PowerManagementPolicySettings`, `default_applications: DefaultApplicationsSettings`.
    - Alle Felder sind mit `#[serde(default)]` annotiert. Dies ist eine wichtige Designentscheidung, die die Robustheit des Systems gegenüber unvollständigen oder fehlerhaften Konfigurationsdateien erhöht, da für fehlende Abschnitte Standardwerte verwendet werden.
- Detaillierte Unterstrukturen (z.B. `AppearanceSettings`, `FontSettings`) und Enums (z.B. `ColorScheme`, `MouseAccelerationProfile`) sind wie in den referenzierten Dokumenten B3 und B4 definiert.
- **Validierung**: Jede Einstellungs-Unterstruktur implementiert eine Methode `fn validate(&self) -> Result<(), String>`. Die `GlobalDesktopSettings`-Struktur verfügt über eine Methode `validate_recursive()`, die die Validierung für alle Unterstrukturen aufruft und so die Datenintegrität sicherstellt.

#### 1.5.2. Pfade (`domain::global_settings_and_state_management::paths`)

- `SettingPath`: Ein hierarchischer Enum zur typsicheren Adressierung einzelner Einstellungen innerhalb der `GlobalDesktopSettings`-Struktur.
    - Implementiert `Display` (zur Konvertierung in einen lesbaren String-Pfad, z.B. für UI oder Logging) und `TryFrom<&str>` (zum Parsen eines String-Pfades zurück in den Enum).
    - Die Verwendung eines typsicheren Pfad-Enums anstelle von reinen Strings reduziert das Risiko von Tippfehlern und Laufzeitfehlern beim Zugriff auf Einstellungen.

#### 1.5.3. Fehlerbehandlung (`domain::global_settings_and_state_management::errors`)

- `GlobalSettingsError`: Enum für Fehler im Einstellungsmodul.
    - Varianten: `PathNotFound { path: SettingPath }`, `InvalidValueType { path: SettingPath, expected: String, found: String }`, `ValidationError { path: SettingPath, reason: String }`, `SerializationError { source: serde_json::Error }`, `DeserializationError { source: serde_json::Error }`, `PersistenceError(#[from] GlobalSettingsPersistenceError)`.
    - Die Verwendung von `SettingPath` in den Fehlervarianten ermöglicht eine präzise Fehlerlokalisierung.

#### 1.5.4. Persistenz-Interface (`domain::global_settings_and_state_management::persistence_iface`)

- Trait `SettingsPersistenceProvider`: Definiert die Schnittstelle zum Laden und Speichern der globalen Einstellungen.
    - Methoden: `async fn load_global_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsPersistenceError>`, `async fn save_global_settings(&self, settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsPersistenceError>`.
    - Anmerkung: Die Verwendung eines spezifischen `GlobalSettingsPersistenceError` ermöglicht eine saubere `#[from]`-Konvertierung in `GlobalSettingsError::PersistenceError`.
- Implementierung `FilesystemSettingsProvider`: Nutzt `novade_core::config::ConfigServiceAsync` für Dateioperationen.

#### 1.5.5. API (`domain::global_settings_and_state_management::service::GlobalSettingsService`)

- Trait `GlobalSettingsService`: Die Hauptschnittstelle für den Zugriff auf und die Manipulation von globalen Einstellungen.
    - Methoden: `async fn load_settings(&self) -> Result<(), GlobalSettingsError>`, `async fn save_settings(&self) -> Result<(), GlobalSettingsError>`, `fn get_current_settings(&self) -> Arc<GlobalDesktopSettings>`, `async fn update_setting(&self, path: SettingPath, value: serde_json::Value) -> Result<(), GlobalSettingsError>`, `fn get_setting(&self, path: &SettingPath) -> Result<serde_json::Value, GlobalSettingsError>`, `async fn reset_to_defaults(&self) -> Result<(), GlobalSettingsError>`, `fn subscribe_to_setting_changes(&self) -> tokio::sync::broadcast::Receiver<SettingChangedEvent>`.
- Implementierung `DefaultGlobalSettingsService`: Hält die Einstellungen in einem `Arc<tokio::sync::RwLock<GlobalDesktopSettings>>`, einen `Arc<dyn SettingsPersistenceProvider>` und einen `tokio::sync::broadcast::Sender` für Events.

#### 1.5.6. Events (`domain::global_settings_and_state_management::events`)

- `SettingChangedEvent { path: SettingPath, new_value: serde_json::Value }`: Wird publiziert, wenn eine Einstellung geändert wird.
- `SettingsLoadedEvent { settings: Arc<GlobalDesktopSettings> }`: Wird publiziert, nachdem die Einstellungen erfolgreich geladen wurden.
- `SettingsSavedEvent`: Wird publiziert, nachdem die Einstellungen erfolgreich gespeichert wurden.

### 1.6. Modul: `domain::window_management_policy`

Dieses Modul definiert High-Level-Regeln und Richtlinien für die Fensterplatzierung, Tiling-Verhalten, Snapping und Fokusmanagement. Es entkoppelt die Policy-Entscheidungen von den Mechanismen der Fensterverwaltung, die im Compositor implementiert sind.

Referenzierte Dokumente: B3 Domänenschicht.md

#### 1.6.1. Datenstrukturen (`domain::window_management_policy::types`)

- `TilingMode`: Enum für verschiedene Tiling-Strategien (z.B. `Manual`, `Columns`, `Rows`, `Spiral`, `MaximizedFocused`).
- `GapSettings`: Definiert Abstände um Bildschirme und zwischen Fenstern.
    - Felder: `screen_outer_horizontal: u16`, `screen_outer_vertical: u16`, `window_inner: u16`.
- `WindowSnappingPolicy`: Konfiguriert das Snapping-Verhalten von Fenstern.
    - Felder: `snap_to_screen_edges: bool`, `snap_to_other_windows: bool`, `snap_to_workspace_gaps: bool`, `snap_distance_px: u16`.
- `WindowGroupingPolicy`: Einstellungen für manuelles Gruppieren von Fenstern.
    - Felder: `enable_manual_grouping: bool`.
- `NewWindowPlacementStrategy`: Enum für die Platzierungsstrategie neuer Fenster (z.B. `Smart`, `Center`, `Cascade`, `UnderMouse`).
- `FocusStealingPreventionLevel`: Enum zur Steuerung, wie aggressiv das System "Focus Stealing" verhindert (`None`, `Moderate`, `Strict`).
- `FocusPolicy`: Umfassende Einstellungen zum Fokusverhalten.
    - Felder: `focus_follows_mouse: bool`, `click_to_focus: bool`, `focus_new_windows_on_creation: bool`, `focus_new_windows_on_workspace_switch: bool`, `focus_stealing_prevention: FocusStealingPreventionLevel`.
- `WindowPolicyOverrides`: Optionale, fensterspezifische Überschreibungen globaler Policies (z.B. `preferred_tiling_mode`, `is_always_floating`).
- `WorkspaceWindowLayout`: Beschreibt das berechnete Layout aller Fenster auf einem Arbeitsbereich.
    - Felder: `window_geometries: HashMap<WindowIdentifier, novade_core::types::RectInt>`, `occupied_area: Option<novade_core::types::RectInt>`, `tiling_mode_applied: TilingMode`.
- `WindowLayoutInfo`: Enthält Informationen von einem Fenster, die für Layout-Berechnungen relevant sind.
    - Felder: `id: WindowIdentifier`, `requested_min_size: Option<novade_core::types::Size<u32>>`, `is_fullscreen_requested: bool`, `is_maximized_requested: bool`.

#### 1.6.2. Fehlerbehandlung (`domain::window_management_policy::errors`)

- `WindowPolicyError`: Enum für Fehler im Policy-Modul.
    - Varianten: `LayoutCalculationError { details: String }`, `InvalidPolicyConfiguration { setting_path: Option<String>, reason: String }`, `WindowNotFoundForPolicy { window_id: WindowIdentifier }`.

#### 1.6.3. API (`domain::window_management_policy::service::WindowManagementPolicyService`)

- Trait `WindowManagementPolicyService`: Definiert die Schnittstelle für Policy-Abfragen und Layout-Berechnungen.
    - Methoden: `async fn calculate_workspace_layout(&self, workspace_id: WorkspaceId, windows_info: Vec<WindowLayoutInfo>, available_area: novade_core::types::RectInt) -> Result<WorkspaceWindowLayout, WindowPolicyError>`, `async fn get_initial_window_geometry(&self, app_id: Option<ApplicationId>, title: Option<String>, requested_size: Option<novade_core::types::Size<u32>>, output_area: novade_core::types::RectInt) -> Result<novade_core::types::RectInt, WindowPolicyError>`, `async fn calculate_snap_target(&self, window_id: WindowIdentifier, current_geometry: novade_core::types::RectInt, workspace_layout: &WorkspaceWindowLayout, output_area: novade_core::types::RectInt) -> Option<novade_core::types::RectInt>`, `async fn get_effective_tiling_mode_for_workspace(&self, workspace_id: WorkspaceId) -> Result<TilingMode, WindowPolicyError>`, `async fn get_effective_gap_settings_for_workspace(&self, workspace_id: WorkspaceId) -> Result<GapSettings, WindowPolicyError>`, `async fn get_effective_snapping_policy(&self) -> Result<WindowSnappingPolicy, WindowPolicyError>`, `async fn get_effective_focus_policy(&self) -> Result<FocusPolicy, WindowPolicyError>`, `async fn get_effective_new_window_placement_strategy(&self) -> Result<NewWindowPlacementStrategy, WindowPolicyError>`.
- Implementierung `DefaultWindowManagementPolicyService`: Hält einen `Arc<dyn GlobalSettingsService>`, um auf die globalen Policy-Einstellungen zuzugreifen. Diese Abhängigkeit ermöglicht dynamische Policy-Änderungen. Die Komplexität der `calculate_workspace_layout`-Funktion erfordert sorgfältige Implementierung und gründliche Tests, insbesondere im Hinblick auf verschiedene Tiling-Modi und Fenster-Overrides.

### 1.7. Modul: `domain::common_events`

Definiert Domänen-übergreifende Events, die von verschiedenen Modulen publiziert oder abonniert werden können.

Referenzierte Dokumente: B3 Domänenschicht.md

#### 1.7.1. Datenstrukturen (`domain::common_events::events`)

- `UserActivityType`: Enum zur Klassifizierung von Benutzeraktivitäten.
    - Varianten: `MouseMoved`, `MouseClicked`, `MouseWheelScrolled`, `KeyPressed`, `TouchInteraction`, `WorkspaceSwitched`, `ApplicationFocused`, `WindowOpened`, `WindowClosed`. Die Granularität dieser Typen ist für die Implementierung von Features wie Inaktivitäts-Timer oder Nutzungsstatistiken relevant.
- `UserActivityDetectedEvent`: Event, das bei Erkennung einer Benutzeraktivität ausgelöst wird.
    - Felder: `event_id: Uuid`, `timestamp: DateTime<Utc>`, `activity_type: UserActivityType`, `current_session_state: UserSessionState`, `active_application_id: Option<ApplicationId>`, `active_workspace_id: Option<WorkspaceId>`.
- `ShutdownReason`: Enum, das den Grund für ein Herunterfahren des Systems angibt.
    - Varianten: `UserRequest`, `PowerButtonPress`, `LowBattery`, `SystemUpdate`, `ApplicationRequest`, `OsError`, `Unknown`.
- `SystemShutdownInitiatedEvent`: Event, das ausgelöst wird, wenn ein System-Shutdown initiiert wird.
    - Felder: `event_id: Uuid`, `timestamp: DateTime<Utc>`, `reason: ShutdownReason`, `is_reboot: bool`, `delay_seconds: Option<u32>`, `message: Option<String>`.

### 1.8. Modul: `domain::shared_types`

Stellt wiederverwendbare, domänenspezifische Typen bereit, die in mehreren Domänenmodulen verwendet werden, um Konsistenz zu fördern und Duplizierung zu vermeiden.

Referenzierte Dokumente: B3 Domänenschicht.md

#### 1.8.1. Datenstrukturen (`domain::shared_types::types`)

- `ApplicationId`: Wrapper für `String` zur eindeutigen Identifizierung von Anwendungen.
- `UserSessionState`: Enum zur Repräsentation des Zustands der Benutzersitzung.
    - Varianten: `Active`, `Locked`, `Idle`.
- `ResourceIdentifier`: Eine generische Struktur zur Identifizierung von Ressourcen innerhalb des Systems.
    - Felder: `r#type: String` (z.B. "window", "workspace"), `id: String`, `label: Option<String>`.

Die klare Definition dieser gemeinsam genutzten Typen ist grundlegend für die Interoperabilität und das korrekte Zusammenspiel der verschiedenen Domänenmodule.

**Tabelle 1: Domain Layer Modules Overview**

|   |   |   |
|---|---|---|
|**Modul-Pfad**|**Kernverantwortlichkeit**|**Wichtige Services/Entitäten**|
|`domain::theming`|Verwaltet alle Aspekte des visuellen Stylings, der Theme-Anwendung und der Token-Auflösung.|`ThemingEngine`, `ThemeDefinition`, `AppliedThemeState`, `TokenIdentifier`, `TokenValue`|
|`domain::workspaces`|Logik und Verwaltung von Arbeitsbereichen ("Spaces"), inklusive Fensterzuweisung und Persistenz.|`WorkspaceManagerService`, `Workspace`, `WorkspaceId`, `WindowIdentifier`|
|`domain::user_centric_services::ai_interaction`|Handhabt KI-gestützte Interaktionen, Einwilligungsmanagement und KI-Modellprofile.|`AIInteractionLogicService`, `AIInteractionContext`, `AIConsent`, `AIModelProfile`|
|`domain::user_centric_services::notifications_core`|Kernlogik für das Erstellen, Speichern, Filtern und Interagieren mit Benachrichtigungen.|`NotificationService`, `Notification`, `NotificationInput`, `NotificationFilterCriteria`|
|`domain::notifications_rules`|Ermöglicht regelbasierte Verarbeitung und Modifikation von Benachrichtigungen.|`NotificationRulesEngine`, `NotificationRule`, `RuleCondition`, `RuleAction`|
|`domain::global_settings_and_state_management`|Verwaltung globaler Desktop-Einstellungen, deren Persistenz und Validierung.|`GlobalSettingsService`, `GlobalDesktopSettings`, `SettingPath`|
|`domain::window_management_policy`|Definiert High-Level-Regeln für Fensterplatzierung, Tiling, Snapping und Fokus.|`WindowManagementPolicyService`, `TilingMode`, `FocusPolicy`, `WorkspaceWindowLayout`|
|`domain::common_events`|Definiert Domänen-übergreifende Events wie Benutzeraktivität oder System-Shutdown.|`UserActivityDetectedEvent`, `SystemShutdownInitiatedEvent`|
|`domain::shared_types`|Stellt wiederverwendbare domänenspezifische Typen bereit.|`ApplicationId`, `UserSessionState`, `ResourceIdentifier`|

## 2. Wayland/Smithay-Integration (Systemschicht-Perspektive)

Dieser Abschnitt beschreibt, wie die Systemschicht, insbesondere der Wayland-Compositor, der mit dem Smithay-Toolkit implementiert wird, mit Wayland-Protokollen umgeht und mit der oben definierten Domänenschicht interagiert. Die korrekte Integration ist entscheidend für die Funktionalität und Stabilität des Desktops.

Referenzierte Dokumente: C1 System Implementierungsplan.md bis C4 Systemschicht.md, 3. System-Details.md.

### 2.1. Kern-Compositor-Struktur (`system::compositor::core::state::DesktopState`)

`DesktopState` ist die zentrale Zustandsstruktur des Compositors. Sie implementiert die verschiedenen Handler-Traits von Smithay und hält sowohl Smithay-spezifische Zustände als auch Handles zu den Domänendiensten. Diese Struktur ist das Herzstück der Compositor-Implementierung und agiert als zentraler Dispatcher und State-Manager für Wayland-bezogene Operationen.1 Die Verwendung einer zentralen, veränderbaren Zustandsstruktur, die an Callbacks übergeben wird, ist ein von Smithay empfohlenes Muster, das durch `calloop` ermöglicht wird und die Notwendigkeit komplexer Synchronisationsmechanismen reduziert.2

- **Wichtige Felder** (Auswahl, basierend auf typischer Smithay-Architektur):
    - `display_handle: DisplayHandle`: Das zentrale Handle zur Wayland-Display-Instanz, notwendig für die Erstellung von Globals und die Client-Kommunikation.5
    - `loop_handle: LoopHandle<'static, Self>`: Handle zum `calloop`-Event-Loop, der den Compositor antreibt.
    - `clock: Clock<u64>`: Eine Zeitquelle für den Compositor.
    - `compositor_state: CompositorState`: Verwaltet `wl_compositor`- und `wl_subcompositor`-bezogene Zustände.6
    - `shm_state: ShmState`: Verwaltet `wl_shm`-bezogene Zustände für Shared Memory Buffer.8
    - `xdg_shell_state: XdgShellState`: Verwaltet Zustände für das `xdg_shell`-Protokoll (Fenster, Popups).9
    - `output_manager_state: OutputManagerState`: Verwaltet `wl_output`- und `zxdg_output_v1`-Zustände.16
    - `seat_state: SeatState<Self>`: Verwaltet `wl_seat`-Zustände und Eingabefähigkeiten.9
    - `seat: Seat<Self>`: Die konkrete Seat-Instanz.
    - `data_device_state: DataDeviceState`: Verwaltet Zustände für `wl_data_device` (Clipboard, Drag & Drop).8
    - `space: Space<WindowElement>`: Smithays 2D-Raum zur Verwaltung von Fenstern, deren Stapelreihenfolge und zum Rendern.1 `WindowElement` ist dabei ein Enum, das verschiedene Fenstertypen wie native Wayland-Fenster (`Window`), X11-Fenster (`X11Surface`) und Layer-Shell-Oberflächen (`LayerSurface`) kapselt.
    - `windows: HashMap<DomainWindowIdentifier, Arc<WindowElement>>`: Ein Mapping von den abstrakten `DomainWindowIdentifier` der Domänenschicht zu den konkreten `WindowElement`-Instanzen des Compositors. Dies ist eine entscheidende Brücke zwischen Domänen- und Systemschicht.
    - Domänen-Service-Handles: `Arc<dyn WindowManagementPolicyService>`, `Arc<dyn WorkspaceManagerService>`, `Arc<dyn GlobalSettingsService>`. Diese `Arc`-Handles ermöglichen den Zugriff auf die Domänenlogik aus den Wayland-Handlern heraus. Die Thread-Sicherheit dieser Interaktion muss gewährleistet sein, insbesondere da Domänendienste asynchron sind, während Wayland-Handler typischerweise synchron im `calloop`-Thread ausgeführt werden.33
    - `event_bridge: Arc<SystemEventBridge>`: Ein Mechanismus zur internen Event-Kommunikation innerhalb der Systemschicht und potenziell zur Weiterleitung von Systemereignissen an die Domänenschicht.

Obwohl `DesktopState` viele Verantwortlichkeiten bündelt, was Bedenken hinsichtlich eines "God Object" 29 aufwerfen könnte, ist dieses Muster im Kontext von Smithay und `calloop` üblich und wird durch die Verwendung von Delegate-Makros handhabbar gemacht. Diese Makros leiten die Protokollbehandlung an spezifische Zustands-Subobjekte und deren Handler weiter, anstatt die gesamte Logik in `DesktopState` selbst zu implementieren.1

### 2.2. Wayland-Protokoll-Implementierungen

Die `DesktopState`-Struktur implementiert verschiedene Handler-Traits von Smithay, um die Wayland-Protokolle zu bedienen.

- **`wl_compositor`, `wl_subcompositor`**:
    
    - Gehandhabt durch `CompositorState` und die Implementierung von `CompositorHandler` in `DesktopState`.4
    - `CompositorHandler::commit(surface: &WlSurface)`: Diese Methode wird bei jedem `wl_surface.commit` eines Clients aufgerufen. Sie ist verantwortlich für:
        - Aktualisierung von `SurfaceData` (Puffer, Schadensregionen (Damage)).
        - Benachrichtigung von `domain::window_management_policy` oder `domain::workspaces` bei relevanten Änderungen (z.B. könnte eine neue Puffergröße das Layout beeinflussen). Diese Interaktion ist ein Beispiel für die Kommunikation von der Systemschicht zur Domänenschicht für Policy-Entscheidungen.
        - Markierung der Oberfläche für eine Neuzeichnung durch den Renderer.
- **`wl_shm`**:
    
    - Gehandhabt durch `ShmState` und die Implementierung von `ShmHandler` in `DesktopState`.4
    - `BufferHandler::buffer_destroyed(buffer: &WlBuffer)`: Informiert den Renderer, dass die mit diesem Puffer verbundenen Ressourcen freigegeben werden können. Dies ist wichtig für das Speichermanagement.
- **`xdg_shell` (`xdg_wm_base`, `xdg_surface`, `xdg_toplevel`, `xdg_popup`)**:
    
    - Gehandhabt durch `XdgShellState` und die Implementierung von `XdgShellHandler` in `DesktopState`.4
    - `XdgShellHandler::new_toplevel(surface: ToplevelSurface)`: Ein kritischer Integrationspunkt.
        1. Erstellt ein `WindowElement::Wayland(Window::new(ToplevelKind::Xdg(surface)))`. Das `Window` hier ist eine Smithay-Abstraktion.29
        2. Generiert einen `DomainWindowIdentifier` für die Domänenschicht.
        3. Ruft `domain::window_management_policy::get_initial_window_geometry()` auf, um die initiale Position und Größe des Fensters gemäß den globalen und anwendungsspezifischen Richtlinien zu bestimmen.
        4. Ruft `domain::workspaces::assign_window_to_active_workspace()` auf, um das neue Fenster dem aktuell aktiven Arbeitsbereich zuzuordnen.
        5. Konfiguriert und mappt das Fenster im `Space`.
    - `XdgShellHandler::map_toplevel(surface: &ToplevelSurface)`: Informiert `domain::workspaces`, dass das Fenster nun sichtbar (gemappt) ist.
    - Client-Anfragen wie `set_title`, `set_app_id`, `set_maximized`, `move`, `resize` werden an `domain::window_management_policy` delegiert. Die Domänenschicht entscheidet über die Policy-konforme Reaktion. Das Ergebnis dieser Entscheidung (z.B. neue Geometrie, neuer Zustand) wird dann vom Compositor auf das `ToplevelSurface` angewendet, typischerweise durch Senden eines `configure`-Events an den Client (`toplevel_surface.send_configure(...)`).
    - **Domäne -> System für Layout**: `domain::window_management_policy` gibt eine `WorkspaceWindowLayout`-Struktur zurück. Ein systemseitiger Mechanismus (z.B. `system::window_mechanics::apply_workspace_layout`) iteriert über die `window_geometries` dieser Struktur und ruft `toplevel_surface.send_configure(...)` für jedes betroffene Fenster auf, um die vom Domänenmodul berechneten Größen und Positionen anzuwenden.
    - Die Synchronisation von Zuständen wie "maximiert" oder "aktiv" zwischen `XdgToplevelSurfaceData` und einer internen `ManagedWindow`-Repräsentation erfolgt über den Configure-Ack-Mechanismus.1 Der Compositor sendet einen `configure`-Event mit dem neuen Zustand, und der Client muss diesen mit `ack_configure` bestätigen, bevor der Zustand als angewendet gilt.
- **`wlr-layer-shell-unstable-v1`**:
    
    - Gehandhabt durch `WlrLayerShellState` und die Implementierung von `LayerShellHandler` in `DesktopState`.4
    - `LayerShellHandler::new_layer_surface(surface: LayerSurface,...)`: Erstellt ein `WindowElement::Layer(surface)`. Informiert die Domänenschicht (ggf. ein spezifischer Service für Shell-Elemente wie Panels oder Hintergrundbilder). Die Platzierung im `Space` erfolgt gemäß den Layer-Shell-Regeln (Layer, Anchor, Exclusive Zone). Die Interaktion mit `PopupManager` und die Handhabung von `exclusive_zone` sind hier relevant.53
- **`wl_output` / `xdg-output-unstable-v1`**:
    
    - Gehandhabt durch `OutputManagerState` und die Implementierung von `OutputHandler` in `DesktopState`.2
    - Änderungen an Outputs (Hotplug, Modusänderung) werden vom `OutputHandler` verarbeitet.
    - Diese Änderungen werden an `domain::global_settings_and_state_management` gemeldet (z.B. um Persistenz anzustoßen oder Display-Profile zu aktualisieren) und an `domain::workspaces` (da Änderungen der Output-Konfiguration das Fensterlayout beeinflussen können).
    - Die Implementierung von `zwlr_output_manager_v1` (Teil von `wlr-output-management-unstable-v1` 2) in `system::outputs::output_manager` (oder einer ähnlichen Struktur) würde die `apply`-Methode dieses Protokolls implementieren. Bei einem Aufruf von `apply` wird `Output::change_current_state()` aufgerufen. Die Domänenschicht wird über ein `OutputConfigurationChangedEvent` informiert. Die korrekte Handhabung von Serials ist hierbei entscheidend für die atomare Anwendung von Konfigurationen.61
- **`wl_seat` / Eingabeprotokolle (`wl_keyboard`, `wl_pointer`, `wl_touch`)**:
    
    - Gehandhabt durch `SeatState`, `SeatHandler`, `KeyboardHandle`, `PointerHandle`, `TouchHandle`.4
    - Eingabe-Events von `system::input` (typischerweise `libinput` 81) werden verarbeitet.
    - `SeatHandler::focus_changed(seat: &Seat<Self>, focused: Option<&WlSurface>)`: Identifiziert den `DomainWindowIdentifier` für die fokussierte Oberfläche. Informiert `domain::window_management_policy` oder `domain::workspaces` über die Fokusänderung. Dies ist ein kritischer Punkt für die Fokusverwaltung.84
    - `KeyboardHandle::input(keycode, state,...)`: Sendet `wl_keyboard.key`-Events an den fokussierten Client.
    - `PointerHandle::motion(...)`: Sendet `wl_pointer.motion`, `enter`, `leave`-Events.
    - **Domäne -> System für Fokus**: `domain::window_management_policy` kann einen Fokuswechsel anstoßen (z.B. als Reaktion auf eine Policy oder einen Benutzerbefehl). Ein systemseitiger Mechanismus (z.B. `system::window_mechanics::set_application_focus`) ruft dann `keyboard.set_focus(...)` auf, um den Fokus im Wayland-Seat zu setzen.

### 2.3. Smithay-Typen und ihre Verwendung

Die Integration mit Smithay erfordert die korrekte Verwendung und Erweiterung seiner Kern-Typen.

- **`DisplayHandle`**: Das zentrale Handle zur Wayland-Display-Instanz. Wird für die Erstellung von Globals, Client-Kommunikation etc. verwendet.5
    
- **`CompositorState`**: Verwaltet `wl_compositor` und `wl_subcompositor` Globals und Client-Zustände.6
    
- **`ShmState`**: Verwaltet das `wl_shm` Global und SHM-Puffer.
    
- **`XdgShellState`**: Verwaltet das `xdg_wm_base` Global und XDG-Oberflächen (Toplevels, Popups).9
    
- **`OutputManagerState`**: Verwaltet `wl_output` und `zxdg_output_manager_v1` Globals.16
    
- **`SeatState<DesktopState>` / `Seat<DesktopState>`**: Verwalten `wl_seat` und die Eingabefähigkeiten (Tastatur, Maus, Touch). `SeatHandler` wird von `DesktopState` implementiert.9
    
- **`KeyboardHandle`, `PointerHandle`, `TouchHandle`**: Abstraktionen für die Interaktion mit spezifischen Eingabegeräten des Seats.
    
- **`Space<WindowElement>`**: Smithays 2D-Raum zur Verwaltung von Fenstern, deren Stapelreihenfolge und zum Rendern.1 `WindowElement` muss den `smithay::desktop::Window` Trait implementieren.29
    
- **`SurfaceData`** (aus `smithay::wayland::compositor`): Wird an `WlSurface`-Instanzen angehängt und speichert Pufferinformationen, die zugewiesene Rolle, Schadensregionen (Damage) etc..7 NovaDE wird dies erweitern (z.B. über `UserDataMap` oder eine dedizierte Erweiterungsstruktur wie `SurfaceDataExt`), um anwendungsspezifische Daten wie `DomainWindowIdentifier` und Renderer-spezifische Textur-Handles zu speichern. Die Verwaltung von doppelt gepuffertem Zustand und Commit-Hooks (Pre/Post) ist ein Kernaspekt von `SurfaceData`.4
    
- **`ClientData`** (aus `smithay::reexports::wayland_server::backend`): Wird an `Client`-Instanzen angehängt und kann Client-spezifische Zustände speichern (z.B. `CompositorClientState`, `XdgWmBaseClientData`).
    
- **Änderungen an Smithay-Typen und deren Konsequenzen**:
    
    - Das direkte Ändern von Smithay-Typen ist in der Regel nicht vorgesehen, da sie Teil der Bibliothek sind. Die Erweiterung erfolgt primär durch die Verwendung von `UserDataMap` an Objekten wie `WlSurface` oder `Client` oder durch die Implementierung der von Smithay bereitgestellten Handler-Traits.
    - Wenn Smithay eine neue Version mit geänderten Typen oder Trait-Signaturen veröffentlicht, müssen die Handler-Implementierungen und die Nutzung dieser Typen in NovaDE entsprechend angepasst werden. Dies erfordert sorgfältige Migration und umfassende Tests, um die Kompatibilität und korrekte Funktionalität sicherzustellen.
    - Das `UserDataMap`-Muster ist der primäre Mechanismus, um anwendungsspezifische Daten mit Smithay-Objekten zu assoziieren, ohne die Typen selbst modifizieren zu müssen. Dies ist entscheidend für die Aufrechterhaltung einer sauberen Trennung zwischen der Bibliothekslogik und der anwendungsspezifischen Logik des Compositors.

### 2.4. Kommunikation Domäne <-> Compositor

Die Kommunikation zwischen der Domänenschicht und der Systemschicht (Compositor) ist bidirektional und erfolgt über definierte Schnittstellen, primär Events und Service-Aufrufe.

- **Compositor (System) -> Domäne**:
    
    - **Events**: Der Compositor generiert Systemereignisse, die für die Domänenschicht relevant sind. Diese werden typischerweise über einen `SystemEventBridge` oder einen ähnlichen Mechanismus an die Domänenschicht weitergeleitet.
        - Neues Fenster (z.B. in `XdgShellHandler::new_toplevel`): Sendet ein `WindowCreatedEvent { domain_id, initial_geometry, app_id, title }` an `domain::workspaces::manager` oder einen allgemeinen Event-Bus.
        - Fenster geschlossen (z.B. in `XdgShellHandler::toplevel_destroyed`): Sendet ein `WindowClosedEvent { domain_id }`.
        - Fokusänderung durch Benutzer (z.B. in `SeatHandler::focus_changed`): Sendet ein `FocusChangedEvent { new_focus_domain_id, old_focus_domain_id }`.
        - Benutzereingabe für spezielle Funktionen (z.B. Befehlspalette): Kann ein spezifisches Event senden oder direkt einen Domänendienst aufrufen.
        - Output-Änderung (z.B. in `OutputHandler`): Sendet ein `OutputConfigurationChangedEvent {... }`.
    - **Service-Aufrufe (indirekt)**: Bei bestimmten Aktionen kann der Compositor Domänenlogik benötigen, z.B. um die Standardplatzierung für ein neues Fenster zu erfragen (`domain::window_management_policy::get_initial_window_geometry`).
- **Domäne -> Compositor (System)**:
    
    - **Service-Aufrufe**: Die Domänenschicht kann Aktionen im Compositor auslösen, indem sie Methoden auf Schnittstellen aufruft, die von der Systemschicht bereitgestellt werden.
        - `domain::window_management_policy` gibt eine `WorkspaceWindowLayout`-Struktur an einen systemseitigen Mechanismus (z.B. `system::window_mechanics`).
        - `system::window_mechanics::apply_workspace_layout` ruft dann spezifische Smithay-Funktionen auf, z.B. `toplevel_surface.send_configure(...)` oder `space.map_window(...)`.
        - `domain::workspaces::manager` ruft z.B. `system::window_mechanics::set_application_focus` auf, was intern `keyboard.set_focus(...)` verwendet.
    - Die Systemschicht stellt hierfür klar definierte Traits bereit (z.B. eine `WindowManipulationApi`), die von Domänendiensten genutzt werden können. Diese API-Aufrufe werden dann in spezifische Smithay-Operationen übersetzt, um die gewünschten Aktionen im Compositor auszuführen.

Diese klare Trennung der Kommunikationspfade und -mechanismen ist entscheidend für die Entkopplung der Schichten und die Aufrechterhaltung einer sauberen Architektur.

## 3. Protokoll-Implementierungen (D-Bus, XDG Desktop Portals, MCP)

Die Systemschicht ist verantwortlich für die Implementierung von Clients und Servern für verschiedene externe Protokolle und deren Integration mit der Domänenschicht, um eine umfassende Desktop-Funktionalität zu gewährleisten.

### 3.1. D-Bus (`zbus`)

Die D-Bus-Integration erfolgt über die `zbus`-Bibliothek, die moderne asynchrone D-Bus-Kommunikation in Rust ermöglicht.87 Die Wahl von `zbus` gegenüber älteren Alternativen wie `dbus-rs` ist auf dessen asynchrone Natur und bessere Integration in moderne Rust-Ökosysteme zurückzuführen.

- **Module in `system::dbus_interfaces`**:
    
    - `connection_manager`: Stellt einen `DBusConnectionManager` bereit, der den Zugriff auf den Session-Bus (`session_bus()`) und den System-Bus (`system_bus()`) kapselt und vereinfacht.89
    - **Clients** (z.B. `upower_client`, `logind_client`, `network_manager_client`, `secrets_service_client`, `policykit_client`):
        - Definieren `zbus::proxy`-Strukturen für die jeweiligen D-Bus-Interfaces der externen Dienste (z.B. `org.freedesktop.UPower` 90, `org.freedesktop.NetworkManager` 91).
        - Implementieren einen Service-Wrapper (z.B. `UPowerClientService`), der den Proxy kapselt und eine saubere API für die Domänenschicht bereitstellt.
        - Abonnieren relevante D-Bus-Signale (z.B. `PropertiesChanged` von UPower) und konvertieren diese entweder in interne `SystemLayerEvents` (die über den `SystemEventBridge` publiziert werden) oder rufen direkt Methoden von Domänendiensten auf.
        - Bieten asynchrone Methoden für die Domänenschicht, um D-Bus-Methoden aufzurufen (z.B. `NetworkManager.ActivateConnection`) oder Eigenschaften abzufragen (z.B. `UPower.OnBattery`).
    - **Server** (z.B. `notifications_server`):
        - Implementiert das `org.freedesktop.Notifications`-Interface unter Verwendung des `#[dbus_interface]`-Makros von `zbus`.94
        - Ruft Methoden des `domain::user_centric_services::NotificationService` auf, um Aktionen wie das Anzeigen oder Schließen von Benachrichtigungen auszuführen.
        - Abonniert Domänen-Events (z.B. `NotificationDismissedEvent`, `NotificationActionInvokedEvent` aus `domain::user_centric_services::notifications_core::events`) und sendet entsprechende D-Bus-Signale (`NotificationClosed`, `ActionInvoked`) an D-Bus-Clients.
        - Verwaltet ein ID-Mapping zwischen den `u32`-basierten D-Bus-Benachrichtigungs-IDs und den `Uuid`-basierten internen `NotificationId`s der Domänenschicht.
- **Integration mit der Domäne**:
    
    - Domänendienste (z.B. `PowerManagementPolicy` in `domain::global_settings_and_state_management`) abonnieren die von den D-Bus-Client-Wrappern publizierten `SystemLayerEvents` oder halten direkte Handles zu den Client-Services, um auf Systemänderungen zu reagieren oder Aktionen auszulösen.
    - Domänendienste (z.B. `NotificationService`) werden von den D-Bus-Server-Implementierungen aufgerufen, um Anfragen von externen Anwendungen zu bedienen.

### 3.2. XDG Desktop Portals (`system::portals`)

Implementiert die Backend-Logik für ausgewählte XDG Desktop Portals, um sandboxed Anwendungen den Zugriff auf Systemressourcen auf eine kontrollierte Weise zu ermöglichen. Die `ashpd`-Bibliothek 96 dient hierbei als Referenz oder kann direkt genutzt werden, falls sie Backend-Logik für Portalserver bereitstellt; andernfalls erfolgt eine direkte `zbus`-Implementierung der Portal-D-Bus-Interfaces.

- Definiert einen Trait `SystemPortalInterface` (oder ähnlich benannt), den die D-Bus-Objekte der Portale (die in einem separaten Prozess oder Dienst laufen könnten) aufrufen.
- **`FileChooser` Portal (`org.freedesktop.portal.FileChooser`)** 96:
    - Empfängt `OpenFile`- oder `SaveFile`-Anfragen vom Portal-D-Bus-Objekt. Diese Anfragen enthalten typischerweise einen `WindowIdentifier`, um den Dialog korrekt dem anfragenden Anwendungsfenster zuzuordnen.97
    - Sendet einen Befehl an die UI-Schicht (über den `SystemEventBridge` oder eine dedizierte Schnittstelle), um einen nativen Dateidialog (z.B. mit GTK) anzuzeigen.
    - Empfängt das Ergebnis des Dateidialogs von der UI-Schicht und sendet es über D-Bus an den anfragenden Client zurück.
- **`Screenshot` Portal (`org.freedesktop.portal.Screenshot`)**:
    - Empfängt `Screenshot`- oder `PickColor`-Anfragen.
    - Interagiert mit `system::compositor::screencopy` (für Screenshots) oder einer spezifischen Compositor-Funktion (für die Farbpipette), um die angeforderte Aktion auszuführen.
    - Sendet das Ergebnis (Bilddaten oder Farbwert) über D-Bus zurück.

### 3.3. Model Context Protocol (MCP) (`system::mcp_client`)

Implementiert die Client-Seite des Model Context Protocol für die Interaktion mit KI-Modellen oder -Diensten, die dieses Protokoll verwenden. Die `mcp_client_rs`-Bibliothek 101 wird hierfür als Grundlage genutzt.

- Implementiert den Trait `SystemMcpService` aus der Domänenschicht.
- Nutzt `mcp_client_rs::McpClient` für die eigentliche Protokollkommunikation.
- **`connection_manager`**:
    - Verwaltet Verbindungen zu MCP-Servern, basierend auf `McpServerConfig`-Strukturen.
    - Kann lokale MCP-Server-Prozesse starten und deren `stdin`/`stdout` für die IPC verwalten, typischerweise unter Verwendung von `tokio::process::Command`.104
    - Holt API-Schlüssel für die Authentifizierung bei MCP-Servern über den `secrets_service_client` (siehe D-Bus-Integration).
- **`service::DefaultSystemMcpService`**:
    - Empfängt Anfragen (z.B. `CallToolParams`) vom `domain::user_centric_services::AIInteractionLogicService`.
    - Sendet diese Anfragen über `McpClient::send_request_json` an den entsprechenden MCP-Server.
    - Implementiert Timeout-Mechanismen für MCP-Anfragen.
    - Lauscht auf `McpClient::receive_message()` für Antworten und serverseitige Benachrichtigungen (Notifications).
    - Konvertiert MCP-Antworten und -Notifications in `McpClientSystemEvents` und publiziert diese über den `SystemEventBridge`. Der `AIInteractionLogicService` abonniert diese Events, um auf Ergebnisse oder serverseitige Updates zu reagieren. Die robuste Handhabung des Notification-Streams, inklusive Fehlerbehandlung und Deserialisierung, ist hierbei entscheidend.103

## 4. Implementierbare Lösungen

Dieser Abschnitt skizziert konkrete Implementierungsansätze für ausgewählte Komponenten und Interaktionen, um die Spezifikationen greifbarer zu machen.

### 4.1. Code-Skizzen (Englisch)

Die folgenden Code-Skizzen dienen zur Veranschaulichung der Struktur und Interaktion einiger Kernkomponenten. Sie sind nicht als vollständig kompilierbarer oder fehlerfreier Code gedacht, sondern sollen die in den Spezifikationen definierten Typen und Methoden im Kontext zeigen.

Hinweis zur Verwendung von Arc<Mutex<T>> und block_on in Handlern:

Die direkte Verwendung von Arc<Mutex<DesktopState>> und dessen Weitergabe an tokio::spawn muss sorgfältig auf Thread-Sicherheit und Deadlocks geprüft werden; oft sind spezifische Daten zu extrahieren oder Kanäle für die Kommunikation mit dem Haupt-Compositor-Thread zu verwenden.33 block_on in synchronen Smithay-Handlern zur Ausführung asynchroner Domänenlogik ist generell zu vermeiden. Stattdessen sollten Kommunikationsmuster wie Kanäle zwischen dem synchronen Handler-Thread und einem Tokio-Runtime-Thread verwendet werden, um Ergebnisse asynchroner Operationen zurück an den Handler zu leiten.107

Rust

```
// ==== Domain Layer: domain::workspaces::manager ====
// #[async_trait]
// pub trait WorkspaceManagerService: Send + Sync {
//     async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>;
//     //... other methods
// }

// pub struct DefaultWorkspaceManager {
//     internal: Arc<tokio::sync::Mutex<WorkspaceManagerInternalState>>,
// }

// impl WorkspaceManagerInternalState {
//     async fn set_active_workspace_impl(&mut self, id: WorkspaceId, current_active: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError> {
//         if!self.workspaces.contains_key(&id) {
//             return Err(WorkspaceManagerError::SetActiveWorkspaceNotFound(id));
//         }
//         if self.active_workspace_id == Some(id) {
//             return Ok(());
//         }
//         let old_id = self.active_workspace_id.take();
//         self.active_workspace_id = Some(id);
//         self.ordered_workspace_ids.retain(|ws_id| *ws_id!= id);
//         self.ordered_workspace_ids.insert(0, id); // Example: move to front
//         let event = WorkspaceEvent::ActiveWorkspaceChanged { old_id, new_id: id };
//         if self.event_publisher.send(event).is_err() {
//             tracing::warn!("No active subscribers for ActiveWorkspaceChanged event.");
//         }
//         // self.save_configuration_internal_locked().await?; // Persist change
//         Ok(())
//     }
// }

// ==== System Layer: system::compositor::core::state::DesktopState ====
// impl SeatHandler for DesktopState {
//     type KeyboardFocus = WlSurface;
//     type PointerFocus = WlSurface;
//     type TouchFocus = WlSurface;

//     fn seat_state(&mut self) -> &mut SeatState<Self> {
//         &mut self.seat_state
//     }

//     fn focus_changed(&mut self, seat: &Seat<Self>, focused: Option<&WlSurface>) {
//         let new_focus_domain_id = focused.and_then(|s| {
//             // Logic to get DomainWindowIdentifier from WlSurface UserData
//             // Example: s.data_map().get::<SurfaceDataExt>().map(|data_ext| data_ext.domain_id.clone())
//             None // Placeholder
//         });
//         tracing::debug!(seat = %seat.name(), new_focus =?new_focus_domain_id, "Keyboard focus changed (Wayland)");
//         // Notify domain layer (e.g., window_management_policy or workspace_manager)
//         // This might involve sending an event through the SystemEventBridge or calling a domain service
//         // let event = SystemLayerEvent::InputFocusChanged { new_focus_domain_id };
//         // self.event_bridge.publish(event);

//         // For XDG Shell activation (simplified)
//         if let Some(surface_to_activate) = focused {
//             if let Some(toplevel) = self.space.window_for_surface(surface_to_activate, WindowSurfaceType::TOPLEVEL)
//                .and_then(|win_elem| match win_elem.as_ref() { // Assuming WindowElement is Arc<ManagedWindow>
//                     WindowElement::Wayland(w) => w.toplevel().ok(),
//                     _ => None,
//                 }) {
//                 toplevel.send_configure(); // To signal state change (active)
//             }
//         }
//         // Deactivate previously focused window
//         //...
//     }

//     fn cursor_image(&mut self, _seat: &Seat<Self>, image: CursorImageStatus) {
//         // Update self.current_cursor_status for the renderer
//         // *self.current_cursor_status.lock().unwrap() = image;
//         // self.damage_cursor_area(); // Signal renderer to update cursor
//     }
// }

// ==== System Layer: system::dbus_interfaces::upower_client::service ====
// #[async_trait]
// pub trait SystemUPowerClient: Send + Sync {
//    async fn is_on_battery(&self) -> Result<bool, DBusInterfaceError>;
// }

// pub struct UPowerClientService {
//     proxy: UPowerProxy<'static>, // Generated by zbus
//     event_publisher: Arc<SystemEventBridge>,
// }

// impl UPowerClientService {
//     pub async fn new(conn: Arc<Connection>, event_publisher: Arc<SystemEventBridge>) -> Result<Self, DBusInterfaceError> {
//         let proxy = UPowerProxy::new(&conn).await?;
//         let client = Self { proxy, event_publisher };
//         client.start_signal_listeners().await?;
//         Ok(client)
//     }

//     async fn start_signal_listeners(&self) -> Result<(), DBusInterfaceError> {
//         let mut props_changed_stream = self.proxy.receive_properties_changed().await?;
//         let publisher_clone = self.event_publisher.clone();
//         let proxy_clone = self.proxy.clone(); // Proxy is Arc-like or cloneable for tasks

//         tokio::spawn(async move {
//             while let Some(signal) = props_changed_stream.next().await {
//                 if let Ok(args) = signal.args() {
//                     if args.interface_name() == "org.freedesktop.UPower" {
//                         if let Some(Value::Bool(is_on_battery)) = args.changed_properties().get("OnBattery") {
//                             publisher_clone.publish(SystemLayerEvent::UPower(UPowerEvent::OnBatteryChanged(*is_on_battery)));
//                         }
//                         // Handle LidIsClosed, etc.
//                     }
//                 }
//             }
//         });
//         Ok(())
//     }
// }

// #[async_trait]
// impl SystemUPowerClient for UPowerClientService {
//     async fn is_on_battery(&self) -> Result<bool, DBusInterfaceError> {
//         Ok(self.proxy.on_battery().await?)
//     }
// }
```

### 4.2. Algorithmen

- **Token Resolution Pipeline (`domain::theming::logic`)**:
    
    1. **Sammle Basis-Tokens**: Kombiniere globale Tokens (systemweit oder anwendungsweit definiert) mit den Basis-Tokens des aktuell ausgewählten Themes (`theme_def.base_tokens`).
    2. **Varianten-Tokens anwenden**: Basierend auf dem `preferred_color_scheme` (z.B. `Light` oder `Dark`) aus der `ThemingConfiguration`, wähle die entsprechende `ThemeVariantDefinition` aus `theme_def.variants`. Überschreibe die Basis-Tokens mit den Tokens aus dieser Variante.
    3. **Akzentfarbe anwenden**: Falls eine `selected_accent_color` in der `ThemingConfiguration` gesetzt ist und das Theme Akzentfarben unterstützt (`theme_def.accentable_tokens_map`), modifiziere die entsprechenden Tokens. Für jedes Token im `accentable_tokens_map`:
        - Bei `AccentModificationType::DirectReplace`: Ersetze den Token-Wert direkt durch die Akzentfarbe.
        - Bei `AccentModificationType::Lighten(factor)` oder `AccentModificationType::Darken(factor)`: Helle den bestehenden Farbwert des Tokens um den Faktor auf oder dunkle ihn ab, unter Verwendung der Akzentfarbe als Basis oder Modifikator.
    4. **Benutzer-Overrides anwenden**: Überschreibe die bisherigen Token-Werte mit Tokens aus `config.custom_user_token_overrides`, falls vorhanden. Diese haben die höchste Priorität.
    5. **Rekursive Referenzauflösung**: Iteriere durch alle Tokens. Für jedes Token, dessen `value` ein `TokenValue::Reference(target_id)` ist:
        - Rufe `resolve_single_token_value(target_id, &mut visited_path, current_depth + 1, max_depth,...)` auf.
        - `visited_path`: Eine Liste der bisher besuchten `TokenIdentifier` in der aktuellen Auflösungskette, um Zyklen zu erkennen. Wenn `target_id` bereits in `visited_path` enthalten ist, liegt ein Zyklus vor -> `ThemingError::CyclicTokenReference`.
        - `current_depth`: Die aktuelle Rekursionstiefe. Wenn `current_depth > max_depth` (`MAX_TOKEN_RESOLUTION_DEPTH`), dann -> `ThemingError::MaxReferenceDepthExceeded`.
        - Wenn das `target_id` nicht im kombinierten Token-Set gefunden wird -> `ThemingError::MissingTokenReference`.
        - Ersetze das `TokenValue::Reference` durch den aufgelösten Wert des `target_id`.
    6. **Finale Werte konvertieren**: Konvertiere alle `TokenValue`-Varianten (die jetzt keine Referenzen mehr sein sollten) in ihre finalen String-Repräsentationen (z.B. Hex-Farbcodes, Pixelwerte mit "px"-Suffix, Schriftartnamen). Das Ergebnis ist ein `BTreeMap<TokenIdentifier, String>`.
- **Fenster-Layout-Berechnung (Beispiel für `domain::window_management_policy` bei `TilingMode::Columns`)**:
    
    1. Ermittle die verfügbare Breite für Fenster: `available_width = available_area.width - (num_windows - 1) * gap_settings.window_inner - 2 * gap_settings.screen_outer_horizontal`. (Annahme: `num_windows > 0`).
    2. Berechne die Breite pro Fenster: `width_per_window = available_width / num_windows`.
    3. Iteriere über die zu kachelnden Fenster (basierend auf `windows_info`):
        - Setze `window_height = available_area.height - 2 * gap_settings.screen_outer_vertical`.
        - Setze `window_width = width_per_window`.
        - Berücksichtige `WindowLayoutInfo.requested_min_size` und `WindowPolicyOverrides` (z.B. `min_size_override`, `fixed_size`). Passe `window_width` und `window_height` entsprechend an, falls die berechneten Werte die Minima unterschreiten oder feste Größen vorgegeben sind.
        - Positioniere das Fenster: `x_position = gap_settings.screen_outer_horizontal + previous_window_x_plus_width + gap_settings.window_inner`. `y_position = gap_settings.screen_outer_vertical`.
        - Speichere die berechnete Geometrie (`RectInt`) in `WorkspaceWindowLayout.window_geometries`.
    4. Aktualisiere `WorkspaceWindowLayout.occupied_area`.
    5. Setze `WorkspaceWindowLayout.tiling_mode_applied = TilingMode::Columns`.
- **Wayland Event zu Domänen-Event (Beispiel `XdgShellHandler::new_toplevel`)**:
    
    1. Ein Wayland-Client sendet `xdg_wm_base.get_xdg_surface` und anschließend `xdg_surface.get_toplevel`.
    2. Smithay ruft die Methode `XdgShellHandler::new_toplevel(toplevel_surface)` in `DesktopState` auf.
    3. Innerhalb des Handlers in `DesktopState`:
        - Generiere einen neuen, eindeutigen `DomainWindowIdentifier` (z.B. mittels `Uuid::new_v4()`).
        - Extrahiere initiale Client-Hinweise (z.B. `app_id`, `title` vom `toplevel_surface`).
        - Rufe asynchron (ggf. über einen Task und Channel-Kommunikation, um den synchronen Handler nicht zu blockieren) `domain_service.get_initial_window_geometry(domain_id, client_hints)` auf, um die empfohlene Startgeometrie zu erhalten.
        - Rufe asynchron `domain_service.assign_window_to_active_workspace(domain_id)` (oder eine spezifischere Zuweisungsmethode) auf.
        - Erstelle ein `WindowElement` (z.B. `WindowElement::Wayland(Window::new(toplevel_surface))`).
        - Füge das `WindowElement` zu `DesktopState.space` hinzu (z.B. `space.map_window(window_element, initial_position, activate)`).
        - Speichere das Mapping `DomainWindowIdentifier -> Arc<WindowElement>` in `DesktopState.windows`.
        - Sende einen `configure`-Event an das `toplevel_surface` mit der von der Domäne bestimmten Geometrie und Zuständen (z.B. aktiviert/maximiert).
        - Publiziere ein `SystemLayerEvent::WindowCreated { domain_id,... }` über den `SystemEventBridge`, damit die Domänenschicht (z.B. `WorkspaceManagerService`) darauf reagieren kann.

### 4.3. Relevante Rust-Bibliotheken

- **Domänenschicht**:
    - `uuid`: Für eindeutige Identifikatoren (`WorkspaceId`, `NotificationId`, etc.).
    - `chrono`: Für Zeitstempel (`DateTime<Utc>`).
    - `serde`, `serde_json`: Für Serialisierung und Deserialisierung von Datenstrukturen (z.B. Konfigurationen, Events).
    - `thiserror`: Zur einfachen Erstellung von Fehler-Enums.
    - `async-trait`: Für asynchrone Traits in Services.
    - `tokio` (speziell `tokio::sync`): Für Synchronisationsprimitive wie `Mutex`, `RwLock` und `broadcast` Channels für die Event-Verteilung.
- **Systemschicht**:
    - **Compositor**:
        - `smithay`: Das Kern-Toolkit für den Wayland-Compositor.2
        - `wayland-server`, `wayland-protocols`: Für die Wayland-Protokoll-Implementierung.122
        - `calloop`: Der Event-Loop, der von Smithay verwendet wird.36
        - `tracing`, `tracing-subscriber`: Für Logging.
    - **Input**:
        - `libinput` (C-Bibliothek) und `input-rs` (Rust-Bindings, von Smithay genutzt) 81: Für die Verarbeitung von Eingabeereignissen von Geräten.
        - `xkbcommon` (C-Bibliothek) und `xkbcommon-rs` (Rust-Bindings) 126: Für Tastatur-Layout-Management.
    - **D-Bus**:
        - `zbus`: Für die asynchrone D-Bus-Kommunikation.87
    - **Audio**:
        - `pipewire` (C-Bibliothek) und `pipewire-rs` (Rust-Bindings) 137: Für Audio-Management und Interaktion mit dem PipeWire-Server.
    - **MCP**:
        - `mcp_client_rs`: Für die Implementierung des Model Context Protocol Clients.101
    - **XDG Desktop Portals**:
        - `ashpd`: Als Referenz oder zur direkten Nutzung für die Implementierung von Portal-Backends, falls es die serverseitige Logik unterstützt. Andernfalls direkte `zbus`-Implementierung der Portal-D-Bus-Interfaces.96
- **Kernschicht (`novade_core`)**:
    - `thiserror`: Für Fehlerdefinitionen.
    - `tracing`, `serde`, `toml`, `once_cell`, `uuid`, `chrono`: Allgemeine Hilfsbibliotheken.

### 4.4. Annahmen, Einschränkungen, Alternativen

- **Annahme**: Die `novade_core`-Schicht stellt alle in der Domänenschicht referenzierten Typen (z.B. `novade_core::types::RectInt`, `novade_core::types::Color`, `novade_core::errors::CoreError`, `novade_core::config::ConfigServiceAsync`, Logging-Initialisierung) bereit.
- **Annahme**: Ein `SystemEventBridge` (basierend auf `tokio::sync::broadcast`) existiert für die interne Event-Kommunikation in der Systemschicht und als Adapter zur Domänenschicht. Dies ermöglicht eine entkoppelte Kommunikation zwischen Systemkomponenten und der Domäne.
- **Annahme**: Die Domänenschicht-Services sind asynchron implementiert und werden über `Arc<dyn TraitName>`-Handles zugänglich gemacht, um Thread-Sicherheit und flexible Injektion zu ermöglichen.
- **Einschränkung**: Detaillierte Spezifikationen zur GPU-Interaktion und die konkrete Implementierung des Renderers (z.B. spezifische OpenGL/Vulkan-Nutzung) sind in diesem Dokument nicht enthalten und müssen separat definiert werden.4
- **Einschränkung**: Die Komplexität des XWayland-Managements ist nur angedeutet. Eine vollständige XWayland-Integration erfordert eine detaillierte Implementierung eines X11 Window Managers (`X11Wm`) innerhalb des Compositors.4
- **Alternative (D-Bus)**: `dbus-rs` (älter, primär synchron) wurde zugunsten von `zbus` (modern, asynchron-fokussiert) nicht gewählt, um eine bessere Integration in das `tokio`-basierte asynchrone Ökosystem von NovaDE zu gewährleisten.87
- **Alternative (Compositor-Toolkit)**: Die direkte Nutzung von `libweston` (C-Bibliothek) wäre in Rust komplexer zu integrieren und würde weniger idiomatische Rust-APIs bieten als das Smithay-Toolkit. Smithay wurde aufgrund seiner Rust-Nativität und modularen Architektur gewählt.2

## 5. Maximale Detailtiefe

Die vorliegenden Spezifikationen versuchen, für jedes Modul und jede wesentliche Interaktion die folgenden Detailebenen abzudecken, um eine klare und direkte Implementierungsgrundlage zu schaffen:

- **Datenstrukturen**: Alle Felder werden mit exakten Rust-Typen spezifiziert. Sichtbarkeitsmodifikatoren (wo relevant für die Kapselung), abgeleitete Traits (wie `Debug`, `Clone`, `Serialize`, `Deserialize`, `PartialEq`, `Eq`, `Hash`, `Ord`, `Display`, `From`, `Default`) und wichtige Invarianten werden explizit genannt.
- **APIs (Traits und Funktionen)**: Signaturen werden präzise definiert, inklusive Parameternamen, Parametertypen, Rückgabetypen und relevanten Trait-Bounds wie `async`, `Send`, `Sync`. Vor- und Nachbedingungen für kritische Funktionen werden, wo nötig, beschrieben.
- **Events**: Die Struktur des Event-Payloads (alle Felder und deren Typen) wird definiert. Es wird angegeben, welche Komponenten typischerweise Events publizieren und welche sie abonnieren, sowie die Bedingungen, unter denen Events ausgelöst werden.
- **Fehlerbehandlung**: Spezifische Fehler-Enums werden pro Modul unter Verwendung von `thiserror` definiert. Jede Fehlervariante wird mit ihrer Bedeutung erläutert, und gegebenenfalls werden `#[source]`- oder `#[from]`-Attribute zur Fehlerverkettung spezifiziert.
- **Logik/Algorithmen**: Kritische Abläufe und Algorithmen (z.B. Token-Auflösung, Fenster-Layout-Berechnung) werden schrittweise beschrieben, um die Implementierungslogik zu verdeutlichen.
- **Interaktionen**: Die Kommunikation zwischen Modulen und Schichten über APIs und Events wird klar definiert, um das Zusammenspiel der Systemkomponenten nachvollziehbar zu machen.

Diese Detailtiefe zielt darauf ab, Interpretationsspielraum während der Entwicklung zu minimieren und eine konsistente, qualitativ hochwertige Implementierung zu ermöglichen.

## Schlussfolgerungen

Dieses Spezifikationsdokument legt eine solide Grundlage für die Entwicklung der Domänenschicht und deren Integration mit dem Wayland/Smithay-basierten Compositor für das NovaDE-Projekt. Die klare Trennung zwischen Domänenlogik und Systemimplementierungsdetails, die detaillierte Definition von Datenstrukturen, APIs und Fehlerzuständen sowie die Skizzierung von Kernalgorithmen und Interaktionsmustern bieten einen umfassenden Leitfaden für Entwickler.

Die Modularität der Domänenschicht, beispielsweise durch die Aufteilung in `domain::theming`, `domain::workspaces` und `domain::user_centric_services`, fördert die Kapselung und Wiederverwendbarkeit von Code. Die Verwendung von Rusts Typsystem und Features wie `async/await`, `thiserror` und `serde` unterstützt die Entwicklung eines robusten und wartbaren Systems.

Die Integration mit Smithay nutzt dessen Stärken im Bereich der Wayland-Protokollbehandlung und des Zustandsmanagements. Die `DesktopState`-Struktur als zentraler Punkt im Compositor, die verschiedene Handler-Traits implementiert und Smithay-Zustandsobjekte verwaltet, ist ein etabliertes Muster. Die Kommunikation zwischen Dom

## NovaDE Ultra-Feinspezifikation: Domänenschicht & Wayland/Smithay-Integration

Dieses Dokument definiert die detaillierten technischen Spezifikationen für die Domänenschicht des NovaDE-Projekts und deren Integration mit dem Wayland-Compositor, der unter Verwendung des Smithay-Toolkits implementiert wird. Es dient als direkter Implementierungsleitfaden für Entwickler.

### 1. Domänenschicht-Spezifikationen

Die Domänenschicht kapselt die Kernlogik und den Zustand der NovaDE-Desktop-Umgebung. Sie ist unabhängig von UI- und Systemdetails konzipiert.

#### 1.1. Modul: `domain::theming`

Dieses Modul ist verantwortlich für die Logik des Erscheinungsbilds (Theming), die Verwaltung von Design-Tokens, die Interpretation von Theme-Definitionen und die Ermöglichung dynamischer Theme-Wechsel.

- **Referenzierte Dokumente:** `B1 Domänenschicht.md`

##### 1.1.1. Datenstrukturen (`domain::theming::types`)

- **`TokenIdentifier`**: Wrapper für `String` zur Identifizierung von Design-Tokens (z.B. "color.background.primary").
    - Implementiert: `Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord, Display, From<&str>`.
    - **Invarianten**: Nicht leer, enthält nur ASCII-Alphanumerisch, Punkte, Bindestriche.
- **`TokenValue`**: Enum zur Repräsentation von Token-Werten.
    - Varianten: `Color(String)`, `Dimension(String)`, `FontSize(String)`, `FontFamily(String)`, `FontWeight(String)`, `LineHeight(String)`, `LetterSpacing(String)`, `Border(String)`, `Shadow(String)`, `Radius(String)`, `Spacing(String)`, `ZIndex(i32)`, `Opacity(f64)` (0.0-1.0), `Text(String)`, `Reference(TokenIdentifier)`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`.
    - `Opacity`-Werte werden auf 0.0-1.0 geklemmt.
- **`RawToken`**: Struktur zur Repräsentation eines Tokens aus einer Konfigurationsdatei.
    - Felder: `id: TokenIdentifier`, `value: TokenValue`, `description: Option<String>`, `group: Option<String>`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`.
- **`TokenSet`**: Typalias für `std::collections::BTreeMap<TokenIdentifier, RawToken>`.
- **`ThemeIdentifier`**: Wrapper für `String` zur Identifizierung von Themes.
    - Implementiert: `Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord, Display, From<&str>`.
    - **Invarianten**: Nicht leer, empfohlene Zeichen: `a-zA-Z0-9-`.
- **`ColorSchemeType`**: Enum (`Light`, `Dark`).
    - Implementiert: `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default`.
- **`AccentColor`**: Struktur zur Repräsentation einer Akzentfarbe.
    - Felder: `name: Option<String>`, `value: novade_core::types::Color`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`. (Eq/Hash für `value` ggf. manuell oder über Hex-String).
- **`ThemeVariantDefinition`**: Definition spezifischer Token-Werte für eine Theme-Variante.
    - Felder: `applies_to_scheme: ColorSchemeType`, `tokens: TokenSet`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`.
- **`ThemeDefinition`**: Vollständige Definition eines Themes.
    - Felder: `id: ThemeIdentifier`, `name: String`, `description: Option<String>`, `author: Option<String>`, `version: Option<String>`, `base_tokens: TokenSet`, `variants: Vec<ThemeVariantDefinition>`, `supported_accent_colors: Option<Vec<AccentColor>>`, `accentable_tokens: Option<HashMap<TokenIdentifier, AccentModificationType>>`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`.
- **`AccentModificationType`**: Enum (`DirectReplace`, `Lighten(f32)`, `Darken(f32)`).
- **`AppliedThemeState`**: Repräsentiert den aktuell aktiven, aufgelösten Theme-Zustand.
    - Felder: `theme_id: ThemeIdentifier`, `color_scheme: ColorSchemeType`, `active_accent_color: Option<AccentColor>`, `resolved_tokens: std::collections::BTreeMap<TokenIdentifier, String>`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`.
    - **Invarianten**: `resolved_tokens` enthält keine Referenzen mehr.
- **`ThemingConfiguration`**: Benutzerspezifische Theming-Einstellungen.
    - Felder: `selected_theme_id: ThemeIdentifier`, `preferred_color_scheme: ColorSchemeType`, `selected_accent_color: Option<novade_core::types::Color>`, `custom_user_token_overrides: Option<TokenSet>`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize, Default`.

##### 1.1.2. Fehlerbehandlung (`domain::theming::errors`)

- **`ThemingError`**: Enum (definiert mit `thiserror`).
    - Varianten: `TokenFileParseError { path: PathBuf, source: serde_json::Error }`, `TokenFileIoError { path: PathBuf, source: std::io::Error }`, `InvalidTokenData { path: PathBuf, message: String }`, `InvalidTokenValue { token_id: TokenIdentifier, value_string: String, reason: String }`, `CyclicTokenReference { token_id: TokenIdentifier, cycle_path: Vec<TokenIdentifier> }`, `ThemeFileLoadError { theme_id: ThemeIdentifier, path: PathBuf, source: serde_json::Error }`, `ThemeFileIoError { theme_id: ThemeIdentifier, path: PathBuf, source: std::io::Error }`, `InvalidThemeData { theme_id: ThemeIdentifier, path: PathBuf, message: String }`, `ThemeNotFound { theme_id: ThemeIdentifier }`, `MissingTokenReference { referencing_token_id: TokenIdentifier, target_token_id: TokenIdentifier }`, `MaxReferenceDepthExceeded { token_id: TokenIdentifier, depth: u8 }`, `ThemeApplicationError { message: String, source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`, `FallbackThemeLoadError { source: Box<dyn std::error::Error + Send + Sync + 'static> }`, `InitialConfigurationError(String)`, `InternalStateError(String)`, `EventSubscriptionError(String)`, `AccentColorApplicationError { theme_id: ThemeIdentifier, accent_color: novade_core::types::Color, details: String }`, `TokenResolutionError { token_id: TokenIdentifier, message: String, source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`, `FilesystemError(#[from] novade_core::errors::CoreError)`.

##### 1.1.3. Kernlogik (`domain::theming::logic`)

- **Konstante**: `MAX_TOKEN_RESOLUTION_DEPTH: u8 = 16;`
- **Token/Theme Laden & Validieren**:
    - `async fn load_raw_tokens_from_file(path: &Path, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`: Liest JSON, parst zu `TokenSet`, validiert Duplikate/Basisformat.
    - `async fn load_and_validate_token_files(paths: &[PathBuf], config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`: Lädt von Pfaden, mergt (Benutzer überschreibt System), validiert Zyklen.
    - `async fn load_theme_definition_from_file(...) -> Result<ThemeDefinition, ThemingError>`: Liest JSON, parst zu `ThemeDefinition`.
    - `async fn load_and_validate_theme_files(...) -> Result<Vec<ThemeDefinition>, ThemingError>`: Lädt Themes, validiert Token-Referenzen.
    - `fn validate_tokenset_for_cycles(tokens: &TokenSet) -> Result<(), ThemingError>`: Tiefensuche zur Zyklenerkennung.
- **Token Resolution Pipeline**:
    - `fn resolve_tokens_for_config(config: &ThemingConfiguration, theme_def: &ThemeDefinition, global_tokens: &TokenSet, accentable_tokens_map: &HashMap<TokenIdentifier, AccentModificationType>, max_depth: u8) -> Result<BTreeMap<TokenIdentifier, String>, ThemingError>`:
        1. Start mit globalen Tokens + Theme-Basis-Tokens.
        2. Varianten-Tokens anwenden.
        3. Akzentfarben anwenden (basierend auf `accentable_tokens_map` und `config.selected_accent_color`).
        4. Benutzer-Overrides anwenden.
        5. Rekursive Referenzauflösung (`resolve_single_token_value`) mit Zyklenerkennung und Tiefenbegrenzung.
        6. Finale Werte in Strings konvertieren.
- **Caching**: Cache-Schlüssel `(ThemeIdentifier, ColorSchemeType, Option<String> /* hex von AccentColor */, u64 /* hash von Overrides */)` für `AppliedThemeState`.
- **Fallback**: `fn generate_fallback_applied_state() -> AppliedThemeState` aus einkompilierten JSONs.

##### 1.1.4. API (`domain::theming::service::ThemingEngine`)

- **Struktur `ThemingEngineInternalState`**:
    - Felder: `current_config: ThemingConfiguration`, `available_themes: Vec<ThemeDefinition>`, `global_raw_tokens: TokenSet`, `applied_state: AppliedThemeState`, `theme_load_paths: Vec<PathBuf>`, `token_load_paths: Vec<PathBuf>`, `resolved_state_cache: HashMap<CacheKey, AppliedThemeState>`, `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>`.
- **Struktur `ThemingEngine`**:
    - Felder: `internal_state: Arc<tokio::sync::Mutex<ThemingEngineInternalState>>`, `event_sender: tokio::sync::broadcast::Sender<ThemeChangedEvent>`.
- **Methoden**:
    - `async fn new(initial_config: ThemingConfiguration, theme_load_paths: Vec<PathBuf>, token_load_paths: Vec<PathBuf>, config_service: Arc<dyn novade_core::config::ConfigServiceAsync>, broadcast_capacity: usize) -> Result<Self, ThemingError>`
    - `async fn get_current_theme_state(&self) -> AppliedThemeState`
    - `async fn get_available_themes(&self) -> Vec<ThemeDefinition>`
    - `async fn get_current_configuration(&self) -> ThemingConfiguration`
    - `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
    - `async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`
    - `fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeChangedEvent>`

##### 1.1.5. Events (`domain::theming::events`)

- **`ThemeChangedEvent`**:
    - Payload: `new_state: AppliedThemeState`.

#### 1.2. Modul: `domain::workspaces`

Verantwortlich für die Logik und Verwaltung von Arbeitsbereichen ("Spaces").

- **Referenzierte Dokumente:** `B2 Domänenschicht.md`

##### 1.2.1. Untermodul: `domain::workspaces::core`

- **Datenstrukturen (`domain::workspaces::core::types`)**:
    - `WorkspaceId`: Typalias für `uuid::Uuid`.
    - `WindowIdentifier`: Wrapper für `String`. Implementiert `new(id: impl Into<String>) -> Result<Self, WorkspaceCoreError>`.
    - `WorkspaceLayoutType`: Enum (`Floating`, `TilingHorizontal`, `TilingVertical`, `Maximized`). Implementiert `Default`.
- **Entität `Workspace` (`domain::workspaces::core::mod.rs`)**:
    - Felder: `id: WorkspaceId`, `name: String`, `persistent_id: Option<String>`, `layout_type: WorkspaceLayoutType`, `window_ids: HashSet<WindowIdentifier>`, `created_at: DateTime<Utc>`, `icon_name: Option<String>`, `accent_color_hex: Option<String>`.
    - Methoden: `new(...) -> Result<Self, WorkspaceCoreError>`, `id()`, `name()`, `rename(...)`, `set_layout_type(...)`, `add_window_id(...)` (crate-intern), `remove_window_id(...)` (crate-intern), `set_icon_name(...)`, `set_accent_color_hex(...) -> Result<...>`.
- **Event-Payloads (`domain::workspaces::core::event_data`)**: `WorkspaceRenamedData`, `WorkspaceLayoutChangedData`, `WindowAddedToWorkspaceData`, `WindowRemovedFromWorkspaceData`, `WorkspacePersistentIdChangedData`, `WorkspaceIconChangedData`, `WorkspaceAccentChangedData`.
- **Fehlerbehandlung (`domain::workspaces::core::errors`)**:
    - `WorkspaceCoreError`: `InvalidName`, `NameCannotBeEmpty`, `NameTooLong`, `InvalidPersistentId`, `WindowIdentifierEmpty`, `InvalidAccentColorFormat`.

##### 1.2.2. Untermodul: `domain::workspaces::assignment`

- **API (`domain::workspaces::assignment::mod.rs`)**: Funktionen operieren auf `&mut HashMap<WorkspaceId, Workspace>`.
    - `assign_window_to_workspace(...) -> Result<(), WindowAssignmentError>`
    - `remove_window_from_workspace(...) -> Result<bool, WindowAssignmentError>`
    - `move_window_to_workspace(...) -> Result<(), WindowAssignmentError>`
    - `find_workspace_for_window(...) -> Option<WorkspaceId>`
- **Fehlerbehandlung (`domain::workspaces::assignment::errors`)**:
    - `WindowAssignmentError`: `WorkspaceNotFound`, `WindowAlreadyAssigned`, `WindowNotAssignedToWorkspace`, `SourceWorkspaceNotFound`, `TargetWorkspaceNotFound`, `WindowNotOnSourceWorkspace`, `CannotMoveToSameWorkspace`, `RuleViolation`, `Internal`.

##### 1.2.3. Untermodul: `domain::workspaces::config`

- **Datenstrukturen (`domain::workspaces::config::mod.rs`)**:
    - `WorkspaceSnapshot`: `persistent_id: String`, `name: String`, `layout_type: WorkspaceLayoutType`, `icon_name: Option<String>`, `accent_color_hex: Option<String>`.
    - `WorkspaceSetSnapshot`: `workspaces: Vec<WorkspaceSnapshot>`, `active_workspace_persistent_id: Option<String>`.
- **API (`domain::workspaces::config::mod.rs`)**:
    - Trait `WorkspaceConfigProvider`: `async fn load_workspace_config() -> Result<WorkspaceSetSnapshot, WorkspaceConfigError>`, `async fn save_workspace_config(snapshot: &WorkspaceSetSnapshot) -> Result<(), WorkspaceConfigError>`.
    - Struktur `FilesystemConfigProvider`: Implementiert `WorkspaceConfigProvider`, nutzt `core::config::ConfigServiceAsync`.
- **Fehlerbehandlung (`domain::workspaces::config::errors`)**:
    - `WorkspaceConfigError`: `LoadError`, `SaveError`, `InvalidData`, `SerializationError`, `DeserializationError`, `PersistentIdNotFoundInLoadedSet`, `DuplicatePersistentIdInLoadedSet`.

##### 1.2.4. Untermodul: `domain::workspaces::manager`

- **API (`domain::workspaces::manager::mod.rs`)**: Trait `WorkspaceManagerService`.
    - Methoden: `async create_workspace(...)`, `async delete_workspace(...)`, `get_workspace(...) -> Option<Workspace>`, `all_workspaces_ordered() -> Vec<Workspace>`, `active_workspace_id()`, `async set_active_workspace(...)`, `async assign_window_to_active_workspace(...)`, `async assign_window_to_specific_workspace(...)`, `async remove_window_from_its_workspace(...)`, `async move_window_to_specific_workspace(...)`, `async rename_workspace(...)`, `async set_workspace_layout(...)`, `async set_workspace_icon(...)`, `async set_workspace_accent_color(...)`, `async save_configuration()`, `subscribe_to_workspace_events() -> tokio::sync::broadcast::Receiver<WorkspaceEvent>`, `async reorder_workspace(...)`.
- **Implementierung `DefaultWorkspaceManager`**: Hält `Arc<tokio::sync::Mutex<WorkspaceManagerInternalState>>`.
    - `WorkspaceManagerInternalState`: `workspaces: HashMap<WorkspaceId, Workspace>`, `active_workspace_id: Option<WorkspaceId>`, `ordered_workspace_ids: Vec<WorkspaceId>`, `next_workspace_number: u32`, `config_provider: Arc<dyn WorkspaceConfigProvider>`, `event_publisher: tokio::sync::broadcast::Sender<WorkspaceEvent>`, `ensure_unique_window_assignment: bool`.
- **Events (`domain::workspaces::manager::events`)**:
    - `WorkspaceEvent`: `WorkspaceCreated`, `WorkspaceDeleted`, `ActiveWorkspaceChanged`, `WorkspaceRenamed`, `WorkspaceLayoutChanged`, `WindowAddedToWorkspace`, `WindowRemovedFromWorkspace`, `WorkspaceOrderChanged`, `WorkspacesReloaded`, `WorkspacePersistentIdChanged`, `WorkspaceIconChanged`, `WorkspaceAccentChanged`.
- **Fehlerbehandlung (`domain::workspaces::manager::errors`)**:
    - `WorkspaceManagerError`: `WorkspaceNotFound`, `CannotDeleteLastWorkspace`, `DeleteRequiresFallbackForWindows`, `FallbackWorkspaceNotFound`, `CoreError(#[from] WorkspaceCoreError)`, `AssignmentError(#[from] WindowAssignmentError)`, `ConfigError(#[from] WorkspaceConfigError)`, `SetActiveWorkspaceNotFound`, `NoActiveWorkspace`, `DuplicatePersistentId`, `Internal`.

#### 1.3. Modul: `domain::user_centric_services`

Bündelt Logik für KI-Interaktionen und Benachrichtigungen.

- **Referenzierte Dokumente:** `B3 Domänenschicht.md`, `B4 Domänenschicht.md`

##### 1.3.1. Untermodul: `domain::user_centric_services::ai_interaction`

- **Datenstrukturen (`...::types`)**:
    - `AIDataCategory`: Enum (`UserProfile`, `ApplicationUsage`, `FileSystemRead`, `ClipboardAccess`, `LocationData`, `GenericText`, `GenericImage`).
    - `AIConsentStatus`: Enum (`Granted`, `Denied`, `PendingUserAction`, `NotRequired`).
    - `AttachmentData`: Felder `id: Uuid`, `mime_type: String`, `source_uri: Option<String>`, `content_base64: Option<String>`, `text_content: Option<String>`, `description: Option<String>`.
    - `InteractionParticipant`: Enum (`User`, `Assistant`, `System`).
    - `InteractionHistoryEntry`: Felder `entry_id: Uuid`, `timestamp: DateTime<Utc>`, `participant: InteractionParticipant`, `content: String`, `related_attachment_ids: Vec<Uuid>`.
    - `AIInteractionContext`: Felder `id: Uuid`, `creation_timestamp: DateTime<Utc>`, `active_model_id: Option<String>`, `consent_status: AIConsentStatus`, `associated_data_categories: Vec<AIDataCategory>`, `history_entries: Vec<InteractionHistoryEntry>`, `attachments: Vec<AttachmentData>`, `user_prompt_template: Option<String>`, `is_active: bool`.
    - `AIConsentScope`: Enum (`SessionOnly`, `PersistentUntilRevoked`, `SpecificDuration`).
    - `AIConsent`: Felder `id: Uuid`, `user_id: String`, `model_id: String`, `data_category: AIDataCategory`, `granted_timestamp: DateTime<Utc>`, `expiry_timestamp: Option<DateTime<Utc>>`, `is_revoked: bool`, `last_used_timestamp: Option<DateTime<Utc>>`, `consent_scope: AIConsentScope`.
    - `AIModelCapability`: Enum (`TextGeneration`, `CodeGeneration`, `Summarization`, `Translation`, `ImageAnalysis`, `FunctionCalling`).
    - `AIModelProfile`: Felder `model_id: String`, `display_name: String`, `description: String`, `provider: String`, `required_consent_categories: Vec<AIDataCategory>`, `capabilities: Vec<AIModelCapability>`, `supports_streaming: bool`, `endpoint_url: Option<String>`, `api_key_secret_name: Option<String>`, `is_default_model: bool`, `sort_order: i32`.
- **Fehlerbehandlung (`...::errors`)**: `AIInteractionError` (`ConsentCheckFailed`, `ApiKeyNotFoundInSecrets`, `ModelEndpointUnreachable`, `NoDefaultModelConfigured`, `CoreConfigError`).
- **Persistenz-Interfaces (`...::persistence_iface`)**: Traits `AIConsentProvider`, `AIModelProfileProvider`.
- **API (`...::service::AIInteractionLogicService`)**: Trait mit Methoden `initiate_interaction`, `get_interaction_context`, `provide_consent`, `get_consent_status_for_interaction`, `get_default_model`, `update_interaction_history`, `store_consent`, `get_all_user_consents`, `load_model_profiles`.
- **Implementierung `DefaultAIInteractionLogicService`**.
- **Events (`...::events::AIInteractionEventEnum`)**: `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`, `AIContextUpdatedEvent`, `AIModelProfilesReloadedEvent`.

##### 1.3.2. Untermodul: `domain::user_centric_services::notifications_core`

- **Datenstrukturen (`...::types`)**:
    - `NotificationId`: Typalias für `uuid::Uuid`.
    - `NotificationUrgency`: Enum (`Low`, `Normal`, `Critical`).
    - `NotificationActionType`: Enum (`Callback`, `OpenLink`).
    - `NotificationAction`: Felder `key: String`, `label: String`, `action_type: NotificationActionType`.
    - `Notification`: Felder `id: Uuid`, `application_name: String`, `application_icon: Option<String>`, `summary: String`, `body: Option<String>`, `actions: Vec<NotificationAction>`, `urgency: NotificationUrgency`, `timestamp: DateTime<Utc>`, `is_read: bool`, `is_dismissed: bool`, `transient: bool`, `category: Option<String>`, `hints: HashMap<String, serde_json::Value>`, `timeout_ms: Option<u32>`.
    - `NotificationInput`: Struktur für das Erstellen von Notifications (ohne `id`, `timestamp`, `is_read`, `is_dismissed`).
    - `NotificationFilterCriteria`: Enum (mit Varianten `Unread`, `Application`, `Urgency`, `Category`, `HasAction`, `BodyContains`, `SummaryContains`, `IsTransient`, `AndTimeRange`, `And`, `Or`, `Not`).
    - `NotificationSortOrder`: Enum (`TimestampAscending`, `TimestampDescending`, `Urgency`, `ApplicationNameAscending`, `SummaryAscending`).
    - `NotificationStats`: `num_active: usize`, `num_history: usize`, `num_unread: usize`.
    - `DismissReason`: Enum (`User`, `Timeout`, `Replaced`, `AppClosed`, `SystemRequest`).
- **Fehlerbehandlung (`...::errors`)**: `NotificationError` (`NotFound`, `InvalidData`, `HistoryFull`, `ActionNotFound`, `InvalidFilterCriteria`, `ActionInvocationFailed`).
- **API (`...::service::NotificationService`)**: Trait mit Methoden `post_notification(input: NotificationInput)`, `get_notification`, `mark_as_read`, `dismiss_notification`, `get_active_notifications`, `get_notification_history`, `clear_history`, `set_do_not_disturb`, `is_do_not_disturb_enabled`, `invoke_action`, `get_stats`, `clear_all_for_app`.
- **Implementierung `DefaultNotificationService`**.
- **Events (`...::events::NotificationEventEnum`)**: `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `NotificationActionInvokedEvent`, `DoNotDisturbModeChangedEvent`, `NotificationHistoryClearedEvent`, `NotificationPopupExpiredEvent`.

#### 1.4. Modul: `domain::notifications_rules`

Regelbasierte Verarbeitung von Benachrichtigungen.

- **Referenzierte Dokumente:** `B4 Domänenschicht.md`

##### 1.4.1. Datenstrukturen (`domain::notifications_rules::types`)

- `RuleConditionValue`: Enum (`String(String)`, `Integer(i64)`, `Boolean(bool)`, `Urgency(NotificationUrgency)`, `Regex(String)`).
- `RuleConditionOperator`: Enum (`Is`, `IsNot`, `Contains`, `NotContains`, `StartsWith`, `EndsWith`, `MatchesRegex`, `NotMatchesRegex`, `GreaterThan`, `LessThan`, `GreaterThanOrEqual`, `LessThanOrEqual`).
- `RuleConditionField`: Enum (`ApplicationName`, `Summary`, `Body`, `Urgency`, `Category`, `HintExists(String)`, `HintValue(String)`).
- `SimpleRuleCondition`: Felder `field: RuleConditionField`, `operator: RuleConditionOperator`, `value: RuleConditionValue`.
- `RuleCondition`: Enum (`Simple(SimpleRuleCondition)`, `SettingIsTrue(SettingPath)`, `And(Vec<RuleCondition>)`, `Or(Vec<RuleCondition>)`, `Not(Box<RuleCondition>`).
- `RuleAction`: Enum (`SuppressNotification`, `SetUrgency`, `AddActionToNotification`, `SetHint`, `PlaySound`, `MarkAsPersistent`, `SetTimeoutMs`, `SetCategory`, `SetSummary`, `SetBody`, `SetIcon`, `SetAccentColor`, `StopProcessingFurtherRules`, `LogMessage`).
- `NotificationRule`: Felder `id: Uuid`, `name: String`, `condition: RuleCondition`, `actions: Vec<RuleAction>`, `is_enabled: bool`, `priority: i32`. Implementiert `Default`.
- `NotificationRuleSet`: Typalias für `Vec<NotificationRule>`.

##### 1.4.2. Fehlerbehandlung (`domain::notifications_rules::errors`)

- `NotificationRulesError`: `InvalidRuleDefinition`, `ConditionEvaluationError`, `ActionApplicationError`, `SettingsAccessError(#[from] GlobalSettingsError)`, `RulePersistenceError(#[from] novade_core::errors::CoreError)`, `InvalidRegex`.

##### 1.4.3. API (`domain::notifications_rules::engine::NotificationRulesEngine`)

- **Trait `NotificationRulesEngine`**:
    - Methoden: `async reload_rules()`, `async process_notification(notification: Notification) -> Result<RuleProcessingResult, NotificationRulesError>`, `async get_rules() -> Result<NotificationRuleSet, _>`, `async update_rules(new_rules: NotificationRuleSet) -> Result<_,_>`.
- **Implementierung `DefaultNotificationRulesEngine`**: Hält `Arc<tokio::sync::RwLock<NotificationRuleSet>>`, `Arc<dyn NotificationRulesProvider>`, `Arc<dyn GlobalSettingsService>`.
- **Enum `RuleProcessingResult`**: `Allow(Notification)`, `Suppress { rule_id: Uuid }`.

##### 1.4.4. Persistenz (`domain::notifications_rules::persistence_iface`)

- **Trait `NotificationRulesProvider`**: `async fn load_rules() -> Result<NotificationRuleSet, _>`, `async fn save_rules(rules: &NotificationRuleSet) -> Result<_,_>`.
- **Implementierung `FilesystemNotificationRulesProvider`**.

#### 1.5. Modul: `domain::global_settings_and_state_management`

Verwaltung globaler Desktop-Einstellungen.

- **Referenzierte Dokumente:** `B3 Domänenschicht.md`, `B4 Domänenschicht.md`

##### 1.5.1. Datenstrukturen (`...::types`)

- `GlobalDesktopSettings`: Hauptstruktur mit Feldern wie `appearance: AppearanceSettings`, `workspace_config: WorkspaceSettings`, `input_behavior: InputBehaviorSettings`, `power_management_policy: PowerManagementPolicySettings`, `default_applications: DefaultApplicationsSettings`. Alle Felder mit `#[serde(default)]`.
- Detaillierte Unterstrukturen (`AppearanceSettings`, `FontSettings`, etc.) und Enums (`ColorScheme`, `MouseAccelerationProfile`, etc.) wie in `B3 Domänenschicht.md` und `B4 Domänenschicht.md` definiert.
- **Validierung**: Jede Einstellungs-Unterstruktur implementiert `fn validate(&self) -> Result<(), String>`. `GlobalDesktopSettings` hat `validate_recursive()`.

##### 1.5.2. Pfade (`...::paths`)

- `SettingPath`: Hierarchischer Enum zur typsicheren Adressierung aller Einstellungen. Implementiert `Display` und `TryFrom<&str>`.

##### 1.5.3. Fehlerbehandlung (`...::errors`)

- `GlobalSettingsError`: `PathNotFound { path: SettingPath }`, `InvalidValueType { path: SettingPath, ... }`, `ValidationError { path: SettingPath, reason: String }`, `SerializationError`, `DeserializationError`, `PersistenceError(#[from] GlobalSettingsPersistenceError)`.

##### 1.5.4. Persistenz-Interface (`...::persistence_iface`)

- **Trait `SettingsPersistenceProvider`**: `async fn load_global_settings() -> Result<GlobalDesktopSettings, GlobalSettingsError>`, `async fn save_global_settings(settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`.
    - **Anmerkung:** Die Fehlerart hier sollte ggf. ein spezifischerer `GlobalSettingsPersistenceError` sein, um `#[from]` in `GlobalSettingsError::PersistenceError` zu ermöglichen.
- **Implementierung `FilesystemSettingsProvider`**.

##### 1.5.5. API (`...::service::GlobalSettingsService`)

- **Trait `GlobalSettingsService`**:
    - Methoden: `async load_settings()`, `async save_settings()`, `get_current_settings() -> GlobalDesktopSettings`, `async update_setting(path: SettingPath, value: serde_json::Value) -> Result<(),_>`, `get_setting(path: &SettingPath) -> Result<serde_json::Value, _>`, `async reset_to_defaults()`, `subscribe_to_setting_changes() -> tokio::sync::broadcast::Receiver<SettingChangedEvent>`.
- **Implementierung `DefaultGlobalSettingsService`**: Hält `settings: Arc<tokio::sync::RwLock<GlobalDesktopSettings>>`, `persistence_provider: Arc<dyn SettingsPersistenceProvider>`, `event_sender`.

##### 1.5.6. Events (`...::events`)

- `SettingChangedEvent { path: SettingPath, new_value: serde_json::Value }`
- `SettingsLoadedEvent { settings: GlobalDesktopSettings }`
- `SettingsSavedEvent`

#### 1.6. Modul: `domain::window_management_policy`

High-Level-Regeln und Richtlinien für Fensterplatzierung, Tiling, etc.

- **Referenzierte Dokumente:** `B3 Domänenschicht.md`

##### 1.6.1. Datenstrukturen (`...::types`)

- `TilingMode`: Enum (`Manual`, `Columns`, `Rows`, `Spiral`, `MaximizedFocused`).
- `GapSettings`: `screen_outer_horizontal: u16`, `screen_outer_vertical: u16`, `window_inner: u16`.
- `WindowSnappingPolicy`: `snap_to_screen_edges: bool`, `snap_to_other_windows: bool`, `snap_to_workspace_gaps: bool`, `snap_distance_px: u16`.
- `WindowGroupingPolicy`: `enable_manual_grouping: bool`.
- `NewWindowPlacementStrategy`: Enum (`Smart`, `Center`, `Cascade`, `UnderMouse`).
- `FocusStealingPreventionLevel`: Enum (`None`, `Moderate`, `Strict`).
- `FocusPolicy`: `focus_follows_mouse: bool`, `click_to_focus: bool`, `focus_new_windows_on_creation: bool`, `focus_new_windows_on_workspace_switch: bool`, `focus_stealing_prevention: FocusStealingPreventionLevel`.
- `WindowPolicyOverrides`: Optionale, fensterspezifische Overrides (`preferred_tiling_mode`, `is_always_floating`, `fixed_size`, `fixed_position`, `prevent_focus_stealing`, `min_size_override`, `max_size_override`).
- `WorkspaceWindowLayout`: `window_geometries: HashMap<WindowIdentifier, novade_core::types::RectInt>`, `occupied_area: Option<RectInt>`, `tiling_mode_applied: TilingMode`.
- `WindowLayoutInfo`: `id: WindowIdentifier`, `requested_min_size: Option<novade_core::types::Size<u32>>`, `is_fullscreen_requested: bool`, `is_maximized_requested: bool`.

##### 1.6.2. Fehlerbehandlung (`...::errors`)

- `WindowPolicyError`: `LayoutCalculationError`, `InvalidPolicyConfiguration`, `WindowNotFoundForPolicy`.

##### 1.6.3. API (`...::service::WindowManagementPolicyService`)

- **Trait `WindowManagementPolicyService`**:
    - Methoden: `async calculate_workspace_layout(...) -> Result<WorkspaceWindowLayout, _>`, `async get_initial_window_geometry(...) -> Result<RectInt, _>`, `async calculate_snap_target(...) -> Option<RectInt>`, `async get_effective_tiling_mode_for_workspace(...) -> Result<TilingMode, _>`, `async get_effective_gap_settings_for_workspace(...) -> Result<GapSettings, _>`, `async get_effective_snapping_policy() -> Result<WindowSnappingPolicy, _>`, `async get_effective_focus_policy() -> Result<FocusPolicy, _>`, `async get_effective_new_window_placement_strategy() -> Result<NewWindowPlacementStrategy, _>`.
- **Implementierung `DefaultWindowManagementPolicyService`**: Hält `Arc<dyn GlobalSettingsService>`.

#### 1.7. Modul: `domain::common_events`

Definition von Domänen-übergreifenden Events.

- **Referenzierte Dokumente:** `B3 Domänenschicht.md`

##### 1.7.1. Datenstrukturen (`domain::common_events::events`)

- `UserActivityType`: Enum (`MouseMoved`, `MouseClicked`, `MouseWheelScrolled`, `KeyPressed`, `TouchInteraction`, `WorkspaceSwitched`, `ApplicationFocused`, `WindowOpened`, `WindowClosed`).
- `UserActivityDetectedEvent`: Felder `event_id: Uuid`, `timestamp: DateTime<Utc>`, `activity_type: UserActivityType`, `current_session_state: UserSessionState`, `active_application_id: Option<ApplicationId>`, `active_workspace_id: Option<WorkspaceId>`.
- `ShutdownReason`: Enum (`UserRequest`, `PowerButtonPress`, `LowBattery`, `SystemUpdate`, `ApplicationRequest`, `OsError`, `Unknown`).
- `SystemShutdownInitiatedEvent`: Felder `event_id: Uuid`, `timestamp: DateTime<Utc>`, `reason: ShutdownReason`, `is_reboot: bool`, `delay_seconds: Option<u32>`, `message: Option<String>`.

#### 1.8. Modul: `domain::shared_types`

Wiederverwendbare domänenspezifische Typen.

- **Referenzierte Dokumente:** `B3 Domänenschicht.md`

##### 1.8.1. Datenstrukturen (`domain::shared_types::types`)

- `ApplicationId`: Wrapper für `String`.
- `UserSessionState`: Enum (`Active`, `Locked`, `Idle`).
- `ResourceIdentifier`: Felder `r#type: String`, `id: String`, `label: Option<String>`.

### 2. Wayland/Smithay-Integration (Systemschicht-Perspektive)

Dieser Abschnitt beschreibt, wie die Systemschicht, insbesondere der Compositor, mit Wayland-Protokollen unter Verwendung von Smithay umgeht und mit der Domänenschicht interagiert.

- **Referenzierte Dokumente:** `C1 System Implementierungsplan.md` bis `C4 Systemschicht.md`, `3. System-Details.md`.

#### 2.1. Kern-Compositor-Struktur (`system::compositor::core::state::DesktopState`)

- `DesktopState` ist die zentrale Zustandsstruktur, die Smithay-Handler-Traits implementiert.
- **Wichtige Felder (Auswahl, basierend auf Smithay-Architektur):**
    - `display_handle: DisplayHandle`
    - `loop_handle: LoopHandle<'static, Self>`
    - `clock: Clock<u64>`
    - `compositor_state: CompositorState`
    - `shm_state: ShmState`
    - `xdg_shell_state: XdgShellState`
    - `output_manager_state: OutputManagerState`
    - `seat_state: SeatState<Self>`
    - `seat: Seat<Self>`
    - `data_device_state: DataDeviceState`
    - `space: Space<WindowElement>` (wobei `WindowElement` ein Enum ist, das `Wayland(Window)`, `X11(X11Surface)`, `Layer(LayerSurface)` wrappt)
    - `windows: HashMap<DomainWindowIdentifier, Arc<WindowElement>>` (Mapping von Domänen-IDs zu Compositor-Fenstern)
    - Domänen-Service-Handles: `Arc<dyn WindowManagementPolicyService>`, `Arc<dyn WorkspaceManagerService>`, `Arc<dyn GlobalSettingsService>`.
    - `event_bridge: Arc<SystemEventBridge>`

#### 2.2. Wayland-Protokoll-Implementierungen

- **`wl_compositor`, `wl_subcompositor`**: Gehandhabt durch `CompositorState` und `CompositorHandler` in `DesktopState`.
    - `CompositorHandler::commit(surface: &WlSurface)`:
        1. Aktualisiert `SurfaceData` (Puffer, Schaden).
        2. Informiert `domain::window_management_policy` oder `domain::workspaces` bei relevanten Änderungen (z.B. neue Puffergröße könnte Layout beeinflussen).
        3. Markiert Oberfläche für Neuzeichnung.
- **`wl_shm`**: Gehandhabt durch `ShmState` und `ShmHandler` in `DesktopState`.
    - `BufferHandler::buffer_destroyed(buffer: &WlBuffer)`: Informiert Renderer, Ressourcen freizugeben.
- **`xdg_shell` (`xdg_wm_base`, `xdg_surface`, `xdg_toplevel`, `xdg_popup`)**: Gehandhabt durch `XdgShellState` und `XdgShellHandler` in `DesktopState`.
    - `XdgShellHandler::new_toplevel(surface: ToplevelSurface)`:
        1. Erstellt `WindowElement::Wayland(Window::new(ToplevelKind::Xdg(surface))))`.
        2. Generiert `DomainWindowIdentifier`.
        3. Ruft `domain::window_management_policy::get_initial_window_geometry()` auf, um Position/Größe zu bestimmen.
        4. Ruft `domain::workspaces::assign_window_to_active_workspace()` auf.
        5. Konfiguriert und mappt das Fenster im `Space`.
    - `XdgShellHandler::map_toplevel(surface: &ToplevelSurface)`: Informiert `domain::workspaces`, Fenster als gemappt zu markieren.
    - Anfragen (`set_title`, `set_app_id`, `set_maximized`, `move`, `resize`) werden an `domain::window_management_policy` delegiert, um die Policy-konforme Reaktion zu bestimmen. Das Ergebnis wird dann auf das `ToplevelSurface` angewendet (`send_configure`).
    - **Domäne -> System**: `domain::window_management_policy` gibt `WorkspaceWindowLayout` zurück. `system::window_mechanics::apply_workspace_layout` iteriert über `window_geometries` und ruft `toplevel.send_configure(...)` für jedes Fenster auf.
- **`wlr-layer-shell-unstable-v1`**: Gehandhabt durch `WlrLayerShellState` und `LayerShellHandler`.
    - `LayerShellHandler::new_layer_surface(surface: LayerSurface, ...)`: Erstellt `WindowElement::Layer(surface)`. Informiert Domäne (ggf. spezifischer Service für Shell-Elemente), platziert im `Space` gemäß Layer-Regeln.
- **`wl_output` / `xdg-output-unstable-v1`**: Gehandhabt durch `OutputManagerState`.
    - Änderungen an Outputs (Hotplug, Modusänderung) werden von `OutputHandler` verarbeitet.
    - Meldet Änderungen an `domain::global_settings_and_state_management` (um z.B. Persistenz anzustoßen) und `domain::workspaces` (kann Layout beeinflussen).
    - `system::outputs::output_manager` implementiert `wlr-output-management-unstable-v1`.
        - `apply()`: Ruft `Output::change_current_state()`. Domäne wird über `OutputConfigurationChangedEvent` informiert.
- **`wl_seat` / Eingabeprotokolle**: Gehandhabt durch `SeatState`, `SeatHandler`, `KeyboardHandle`, `PointerHandle`, `TouchHandle`.
    - Eingabe-Events von `system::input` (Libinput) werden verarbeitet.
    - `SeatHandler::focus_changed(seat: &Seat<Self>, focused: Option<&WlSurface>)`:
        1. Identifiziert `DomainWindowIdentifier` für `focused_surface`.
        2. Informiert `domain::window_management_policy` oder `domain::workspaces` über Fokusänderung.
    - `KeyboardHandle::input(keycode, state, ...)`: Sendet `wl_keyboard.key`.
    - `PointerHandle::motion(...)`: Sendet `wl_pointer.motion`, `enter`, `leave`.
    - **Domäne -> System**: `domain::window_management_policy` kann Fokuswechsel anstoßen. `system::window_mechanics::set_application_focus` ruft `keyboard.set_focus(...)`.

#### 2.3. Smithay-Typen und ihre Verwendung

- **`DisplayHandle`**: Zentrales Handle zur Wayland-Display-Instanz. Wird für die Erstellung von Globals, Client-Kommunikation etc. verwendet.
- **`CompositorState`**: Verwaltet `wl_compositor` und `wl_subcompositor` Globals und Client-Zustände.
- **`ShmState`**: Verwaltet `wl_shm` Global und SHM-Puffer.
- **`XdgShellState`**: Verwaltet `xdg_wm_base` Global und XDG-Oberflächen.
- **`OutputManagerState`**: Verwaltet `wl_output` und `zxdg_output_v1` Globals.
- **`SeatState<DesktopState>` / `Seat<DesktopState>`**: Verwalten `wl_seat` und Eingabefähigkeiten. `SeatHandler` wird von `DesktopState` implementiert.
- **`KeyboardHandle`, `PointerHandle`, `TouchHandle`**: Abstraktionen für die Interaktion mit spezifischen Eingabegeräten des Seats.
- **`Space<WindowElement>`**: Smithay's 2D-Raum zur Verwaltung von Fenstern, deren Stapelreihenfolge und zum Rendern. `WindowElement` muss das `smithay::desktop::Window` Trait implementieren.
- **`SurfaceData` (aus `smithay::wayland::compositor`)**: Hängt an `WlSurface` und speichert Puffer, Rolle, Schaden etc. NovaDE wird dies um `novade_system::compositor::surface_management::SurfaceDataExt` (oder ähnliches in `UserDataMap`) erweitern, um anwendungsspezifische Daten wie `DomainWindowIdentifier` und Renderer-Textur-Handles zu speichern.
- **`ClientData` (aus `smithay::reexports::wayland_server::backend`)**: Hängt an `Client` und kann Client-spezifische Zustände speichern (z.B. `CompositorClientState`, `XdgWmBaseClientData`).

**Änderungen an Smithay-Typen und deren Konsequenzen:**

- Das Ändern von Smithay-Typen ist in der Regel nicht vorgesehen, da sie Teil der Bibliothek sind. Man erweitert sie durch UserData oder implementiert Handler-Traits.
- Wenn Smithay eine neue Version mit geänderten Typen veröffentlicht, müssen die Handler-Implementierungen und die Nutzung dieser Typen in NovaDE angepasst werden. Dies erfordert sorgfältige Migration und Tests.
- Das UserData-Muster (`UserDataMap` an `WlSurface`, `Client` etc.) ist der primäre Mechanismus, um anwendungsspezifische Daten mit Smithay-Objekten zu assoziieren, ohne die Typen selbst zu ändern.

#### 2.4. Kommunikation Domäne &lt;-> Compositor

- **Compositor (System) -> Domäne:**
    - **Events**:
        - Neues Fenster (`XdgShellHandler::new_toplevel`): Sendet `WindowCreatedEvent { domain_id, initial_geometry, app_id, title }` an `domain::workspaces::manager` oder einen allgemeinen Event-Bus.
        - Fenster geschlossen (`XdgShellHandler::toplevel_destroyed`): Sendet `WindowClosedEvent { domain_id }`.
        - Fokusänderung durch Benutzer (`SeatHandler::focus_changed`): Sendet `FocusChangedEvent { new_focus_domain_id, old_focus_domain_id }`.
        - Benutzereingabe für Befehlspalette: Sendet spezifisches Event oder ruft Domänen-Service direkt.
        - Output-Änderung (`OutputHandler`): Sendet `OutputConfigurationChangedEvent { ... }`.
    - **Service-Aufrufe (indirekt):** Bei bestimmten Aktionen kann der Compositor Domänenlogik benötigen, z.B. um Standardplatzierung für ein neues Fenster zu erfragen.
- **Domäne -> Compositor (System):**
    - **Service-Aufrufe**:
        - `domain::window_management_policy` gibt `WorkspaceWindowLayout` an `system::window_mechanics`.
        - `system::window_mechanics::apply_workspace_layout` ruft dann z.B. `toplevel_surface.send_configure(...)` oder `space.map_window(...)`.
        - `domain::workspaces::manager` ruft `system::window_mechanics::set_application_focus` auf.
    - Die Systemschicht stellt Traits bereit (z.B. `WindowManipulationApi`), die von Domänendiensten aufgerufen werden können, um Aktionen im Compositor auszulösen. Diese API-Aufrufe werden dann in spezifische Smithay-Operationen übersetzt.

### 3. Protokoll-Implementierungen (D-Bus, XDG Desktop Portals, MCP)

Die Systemschicht implementiert Clients und Server für diese Protokolle und integriert sie mit der Domänenschicht.

#### 3.1. D-Bus (`zbus`)

- **Module in `system::dbus_interfaces`**:
    - **`connection_manager`**: Stellt `DBusConnectionManager` bereit (`session_bus()`, `system_bus()`).
    - **Clients (`upower_client`, `logind_client`, `network_manager_client`, `secrets_service_client`, `policykit_client`)**:
        - Definieren `zbus::proxy` für die D-Bus-Interfaces.
        - Implementieren einen Service (z.B. `UPowerClientService`), der den Proxy nutzt.
        - Abonnieren D-Bus-Signale und konvertieren sie in interne `SystemLayerEvent`s (publiziert über `SystemEventBridge`) oder rufen direkt Domänen-Services auf.
        - Bieten `async` Methoden für die Domänenschicht, um D-Bus-Methoden aufzurufen oder Eigenschaften abzufragen.
    - **Server (`notifications_server`)**:
        - Implementiert das `org.freedesktop.Notifications` Interface mit `#[dbus_interface]`.
        - Ruft Methoden des `domain::user_centric_services::NotificationService`.
        - Abonniert Domänen-Events (`NotificationDismissedEvent`, `NotificationActionInvokedEvent`) und sendet entsprechende D-Bus-Signale (`NotificationClosed`, `ActionInvoked`).
        - Verwaltet ID-Mapping zwischen D-Bus `u32` und Domänen `Uuid`.
- **Integration Domäne**:
    - Domänendienste (z.B. `PowerManagementPolicy`) abonnieren die von D-Bus-Clients publizierten `SystemLayerEvent`s oder haben direkte Handles zu den Client-Services.
    - Domänendienste (z.B. `NotificationService`) werden von D-Bus-Server-Implementierungen aufgerufen.

#### 3.2. XDG Desktop Portals (`system::portals`)

- Implementiert Backend-Logik für ausgewählte Portale (FileChooser, Screenshot).
- Definiert einen Trait `SystemPortalInterface` (o.ä.), den die D-Bus-Objekte der Portale (die in einem separaten Prozess oder Dienst laufen könnten) aufrufen.
- **`FileChooser`**:
    - Empfängt `OpenFile` / `SaveFile` Anfrage von Portal D-Bus Objekt.
    - Sendet Befehl an UI-Schicht (via `SystemEventBridge` oder dedizierter Schnittstelle) zur Anzeige eines GTK-Dateidialogs.
    - Empfängt Ergebnis von UI und sendet es via D-Bus zurück.
- **`Screenshot`**:
    - Empfängt `Screenshot` / `PickColor` Anfrage.
    - Interagiert mit `system::compositor::screencopy` (für Screenshots) oder einer spezifischen Compositor-Funktion (für Farbpipette).
    - Sendet Ergebnis zurück.

#### 3.3. Model Context Protocol (MCP) (`system::mcp_client`)

- Implementiert den `SystemMcpService`-Trait.
- Nutzt `mcp_client_rs::McpClient`.
- **`connection_manager`**: Verwaltet Verbindungen zu MCP-Servern (`McpServerConfig`), startet lokale Prozesse, holt API-Keys via `secrets_service_client`.
- **`service::DefaultSystemMcpService`**:
    - Empfängt Anfragen von `domain::user_centric_services::AIInteractionLogicService` (z.B. `CallToolParams`).
    - Sendet Anfragen via `McpClient::send_request_json`.
    - Handhabt Timeouts.
    - Lauscht auf `McpClient::receive_message()` für Antworten und Notifications.
    - Konvertiert MCP-Antworten/Notifications in `McpClientSystemEvent`s und publiziert sie. `AIInteractionLogicService` abonniert diese Events.

### 4. Implementierbare Lösungen

#### 4.1. Code-Skizzen (Englisch)

Rust

```
// ==== Domain Layer: domain::workspaces::manager ====
// #[async_trait]
// pub trait WorkspaceManagerService: Send + Sync {
//     async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>;
//     // ... other methods
// }

// pub struct DefaultWorkspaceManager {
//     internal: Arc<tokio::sync::Mutex<WorkspaceManagerInternalState>>,
// }

// impl WorkspaceManagerInternalState {
//     async fn set_active_workspace_impl(&mut self, id: WorkspaceId, current_active: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError> {
//         if !self.workspaces.contains_key(&id) {
//             return Err(WorkspaceManagerError::SetActiveWorkspaceNotFound(id));
//         }
//         if self.active_workspace_id == Some(id) {
//             return Ok(());
//         }
//         let old_id = self.active_workspace_id.take();
//         self.active_workspace_id = Some(id);
//         self.ordered_workspace_ids.retain(|ws_id| *ws_id != id);
//         self.ordered_workspace_ids.insert(0, id); // Example: move to front

//         let event = WorkspaceEvent::ActiveWorkspaceChanged { old_id, new_id: id };
//         if self.event_publisher.send(event).is_err() {
//             tracing::warn!("No active subscribers for ActiveWorkspaceChanged event.");
//         }
//         // self.save_configuration_internal_locked().await?; // Persist change
//         Ok(())
//     }
// }

// ==== System Layer: system::compositor::core::state::DesktopState ====
// impl SeatHandler for DesktopState {
//     type KeyboardFocus = WlSurface;
//     type PointerFocus = WlSurface;
//     type TouchFocus = WlSurface;

//     fn seat_state(&mut self) -> &mut SeatState<Self> {
//         &mut self.seat_state
//     }

//     fn focus_changed(&mut self, seat: &Seat<Self>, focused: Option<&WlSurface>) {
//         let new_focus_domain_id = focused.and_then(|s| {
//             // Logic to get DomainWindowIdentifier from WlSurface UserData
//             // Example: s.data_map().get::<SurfaceDataExt>().map(|data_ext| data_ext.domain_id.clone())
//             None // Placeholder
//         });
//         tracing::debug!(seat = %seat.name(), new_focus = ?new_focus_domain_id, "Keyboard focus changed (Wayland)");

//         // Notify domain layer (e.g., window_management_policy or workspace_manager)
//         // This might involve sending an event through the SystemEventBridge or calling a domain service
//         // let event = SystemLayerEvent::InputFocusChanged { new_focus_domain_id };
//         // self.event_bridge.publish(event);

//         // For XDG Shell activation (simplified)
//         if let Some(surface_to_activate) = focused {
//             if let Some(toplevel) = self.space.window_for_surface(surface_to_activate, WindowSurfaceType::TOPLEVEL)
//                 .and_then(|win_elem| match win_elem.as_ref() { // Assuming WindowElement is Arc<ManagedWindow>
//                     WindowElement::Wayland(w) => w.toplevel().ok(),
//                     _ => None,
//                 }) {
//                 toplevel.send_configure(); // To signal state change (active)
//             }
//         }
//         // Deactivate previously focused window
//         // ...
//     }

//     fn cursor_image(&mut self, _seat: &Seat<Self>, image: CursorImageStatus) {
//         // Update self.current_cursor_status for the renderer
//         // *self.current_cursor_status.lock().unwrap() = image;
//         // self.damage_cursor_area(); // Signal renderer to update cursor
//     }
// }

// ==== System Layer: system::dbus_interfaces::upower_client::service ====
// #[async_trait]
// pub trait SystemUPowerClient: Send + Sync {
//    async fn is_on_battery(&self) -> Result<bool, DBusInterfaceError>;
// }

// pub struct UPowerClientService {
//     proxy: UPowerProxy<'static>, // Generated by zbus
//     event_publisher: Arc<SystemEventBridge>,
// }

// impl UPowerClientService {
//     pub async fn new(conn: Arc<Connection>, event_publisher: Arc<SystemEventBridge>) -> Result<Self, DBusInterfaceError> {
//         let proxy = UPowerProxy::new(&conn).await?;
//         let client = Self { proxy, event_publisher };
//         client.start_signal_listeners().await?;
//         Ok(client)
//     }

//     async fn start_signal_listeners(&self) -> Result<(), DBusInterfaceError> {
//         let mut props_changed_stream = self.proxy.receive_properties_changed().await?;
//         let publisher_clone = self.event_publisher.clone();
//         let proxy_clone = self.proxy.clone(); // Proxy is Arc-like or cloneable for tasks

//         tokio::spawn(async move {
//             while let Some(signal) = props_changed_stream.next().await {
//                 if let Ok(args) = signal.args() {
//                     if args.interface_name() == "org.freedesktop.UPower" {
//                         if let Some(Value::Bool(is_on_battery)) = args.changed_properties().get("OnBattery") {
//                             publisher_clone.publish(SystemLayerEvent::UPower(UPowerEvent::OnBatteryChanged(*is_on_battery)));
//                         }
//                         // Handle LidIsClosed, etc.
//                     }
//                 }
//             }
//         });
//         Ok(())
//     }
// }

// #[async_trait]
// impl SystemUPowerClient for UPowerClientService {
//     async fn is_on_battery(&self) -> Result<bool, DBusInterfaceError> {
//         Ok(self.proxy.on_battery().await?)
//     }
// }
```

#### 4.2. Algorithmen

- **Token Resolution Pipeline (`domain::theming::logic`)**:
    1. Sammle Basis-Tokens (globale + Theme-Basis).
    2. Überschreibe mit Varianten-Tokens (Hell/Dunkel).
    3. Wende Akzentfarbe an (ersetze definierte Akzent-Token-IDs).
    4. Überschreibe mit Benutzer-Overrides.
    5. Löse rekursiv `TokenValue::Reference` auf:
        - Verfolge besuchten Pfad zur Zyklenerkennung.
        - Prüfe maximale Rekursionstiefe.
        - Bei fehlender Referenz: Fehler.
    6. Konvertiere alle Werte in finale CSS-Strings.
- **Fenster-Layout-Berechnung (`domain::window_management_policy`)**:
    - Für `TilingMode::Columns`:
        1. Ermittle verfügbare Breite (`available_area.width` - Summe der `gap_settings.window_inner` - `2 * gap_settings.screen_outer_horizontal`).
        2. Teile verfügbare Breite durch Anzahl der zu kachelnden Fenster (`width_per_window`).
        3. Iteriere über Fenster, setze `width = width_per_window`, `height = available_area.height - 2 * gap_settings.screen_outer_vertical`. Positioniere sequentiell mit `gap_settings.window_inner`.
        4. Berücksichtige `WindowLayoutInfo.requested_min_size` und `WindowPolicyOverrides`.
- **Wayland Event zu Domänen-Event (`system::compositor` Handler)**:
    - Beispiel `XdgShellHandler::new_toplevel`:
        1. Wayland-Client sendet `xdg_wm_base.get_xdg_surface` und `xdg_surface.get_toplevel`.
        2. Smithay ruft `XdgShellHandler::new_toplevel(toplevel_surface)`.
        3. Handler in `DesktopState`:
            - Generiert `DomainWindowIdentifier`.
            - Ruft `domain_service.get_initial_window_geometry(domain_id, client_hints)`.
            - Ruft `domain_service.assign_window_to_active_workspace(domain_id)`.
            - Erstellt `WindowElement`, fügt zu `DesktopState.space` und `DesktopState.windows` hinzu.
            - Sendet `configure` Event an `toplevel_surface` mit der von der Domäne bestimmten Geometrie.
            - Publiziert `SystemLayerEvent::WindowCreated` über `SystemEventBridge`.

#### 4.3. Relevante Rust-Bibliotheken

- **Domänenschicht**: `uuid`, `chrono`, `serde`, `serde_json`, `thiserror`, `async-trait`, `tokio` (für `sync`-Primitive wie `Mutex`, `RwLock`, `broadcast`).
- **Systemschicht**:
    - Compositor: `smithay`, `wayland-server`, `wayland-protocols`, `calloop`, `tracing`.
    - Input: `libinput` (C-Lib), `input-rs` (Rust-Bindings für libinput, wird von Smithay genutzt), `xkbcommon` (C-Lib), `xkbcommon-rs` (Rust-Bindings).
    - D-Bus: `zbus`.
    - Audio: `pipewire` (C-Lib), `pipewire-rs` (Rust-Bindings).
    - MCP: `mcp_client_rs`.
    - XDG Portals: `ashpd` (als Referenz oder Nutzung, wenn es Backend-Logik für Portalserver bereitstellt, sonst direkte `zbus`-Implementierung der Portal-D-Bus-Interfaces).
- **Kernschicht**: `thiserror`, `tracing`, `tracing-subscriber`, `serde`, `toml`, `once_cell`, `uuid`, `chrono`.

#### 4.4. Annahmen, Einschränkungen, Alternativen

- **Annahme**: Die `novade-core` Schicht stellt alle spezifizierten Typen (`RectInt`, `Color`, `CoreError`, `ConfigError`, Logging-Init) bereit.
- **Annahme**: Ein `SystemEventBridge` (basierend auf `tokio::sync::broadcast`) existiert für die interne Event-Kommunikation in der Systemschicht und als Adapter zur Domänenschicht.
- **Annahme**: Die Domänenschicht-Services sind `async` und hinter `Arc<dyn TraitName>` zugänglich.
- **Einschränkung**: Detaillierte GPU-Interaktion und Renderer-Implementierung sind noch nicht spezifiziert.
- **Einschränkung**: Komplexität des XWayland-Managements ist nur angedeutet.
- **Alternative (D-Bus)**: `dbus-rs` (älter, synchron) vs. `zbus` (modern, async). `zbus` wird bevorzugt.
- **Alternative (Compositor)**: Direkte Nutzung von `libweston` (C) wäre komplexer in Rust zu integrieren als Smithay.

### 5. Maximale Detailtiefe

Die Spezifikationen versuchen, für jedes Modul und jede Interaktion die folgenden Details abzudecken:

- **Datenstrukturen**: Alle Felder mit exakten Rust-Typen, Sichtbarkeitsmodifikatoren, abgeleitete Traits (`Debug`, `Clone`, `Serialize`, etc.), Invarianten.
- **APIs (Traits/Funktionen)**: Exakte Signaturen (Parameter mit Name und Typ, Rückgabetyp, `async`, `Send`, `Sync`). Vor- und Nachbedingungen.
- **Events**: Struktur des Event-Payloads (alle Felder und Typen). Wer publiziert, wer abonniert (typischerweise). Auslösebedingungen.
- **Fehler**: Spezifische Fehler-Enums pro Modul (`thiserror`), jede Variante mit Bedeutung und ggf. `#[source]` oder `#[from]`.
- **Logik/Algorithmen**: Schritt-für-Schritt-Beschreibung kritischer Abläufe.
- **Interaktionen**: Klare Definition, wie Module und Schichten über APIs und Events kommunizieren.

Diese Detailtiefe zielt darauf ab, Interpretationsspielraum zu minimieren und eine direkte, konsistente Implementierung zu ermöglichen.

---

**Anmerkung zu den bereitgestellten Code-Skizzen:** Die Code-Skizzen sind zur Veranschaulichung und nicht als vollständig kompilierbarer oder fehlerfreier Code gedacht. Sie dienen dazu, die Struktur, Typen und Interaktionen gemäß der Spezifikation aufzuzeigen. Die tatsächliche Implementierung erfordert weitere Details, Fehlerbehandlung und Tests. `block_on` in Smithay-Handlern ist zu vermeiden; stattdessen sollten synchrone Domänenaufrufe oder eine Umstrukturierung für `async` erfolgen. Die Verwendung von `Arc<Mutex<DesktopState>>` und dessen Weitergabe an `tokio::spawn` muss sorgfältig auf Thread-Sicherheit und Deadlocks geprüft werden; oft sind spezifische Daten zu extrahieren oder Kanäle für die Kommunikation mit dem Haupt-Compositor-Thread zu verwenden.


## Technische Spezifikation der Domänenschicht

Basierend auf den bereitgestellten Dokumenten ("Domänenschicht: Theming-Engine – Ultra-Feinspezifikation (Teil 1/4)", "Domänenschicht: Implementierungsleitfaden Teil 2/4 – Workspaces (domain::workspaces)", "Domänenschicht: Detaillierte Spezifikation – Teil 3/4: Benutzerzentrierte Dienste und Globale Einstellungsverwaltung" und "Domänenschicht (Domain Layer) – Teil 4/4: Einstellungs- und Benachrichtigungs-Subsysteme" ) wird hiermit eine eigenständige, konkrete und ausführliche technische Spezifikation für die Entwicklung der Domänenschicht erstellt. Diese Spezifikation beinhaltet allgemeine Entwicklungsrichtlinien sowie spezifische Details zu den einzelnen Modulen der Domänenschicht.

### 1. Allgemeine Prinzipien und Entwicklungsrichtlinien der Domänenschicht

Die Domänenschicht ist das Herzstück der Anwendungslogik und repräsentiert die Geschäftsregeln und -konzepte der Desktop-Umgebung. Sie ist UI-unabhängig und entkoppelt von spezifischen Systemdetails oder Infrastrukturbelangen.

**Entwicklungsrichtlinien:**

- **Sprache und Tooling:** Rust wird als primäre Programmiersprache verwendet.
    - **Fehlerbehandlung:** `thiserror` wird für die Definition spezifischer, benutzerdefinierter Fehler-Enums pro Modul verwendet. Dies ermöglicht eine klare Kommunikation von Fehlerzuständen. Fehler werden über `Result<T, E>` zurückgegeben; `unwrap()` und `expect()` sind zu vermeiden, außer in absoluten Ausnahmefällen. Die `source()`-Kette von Fehlern soll durch korrekte Verwendung von `#[source]` und `#[from]` erhalten bleiben.
        
    - **Serialisierung/Deserialisierung:** `serde` (mit `serde_json` für JSON) wird für das Laden und Speichern von Konfigurationen und Datenstrukturen verwendet. Attribute wie `#[serde(rename_all = "kebab-case")]`, `#[serde(default)]` und `#[serde(skip_serializing_if = "Option::is_none")]` sollen konsistent genutzt werden.
        
    - **Asynchronität:** Wo Operationen potenziell blockierend sind (z.B. I/O beim Laden von Konfigurationen, Kommunikation mit externen Diensten), werden `async/await` und `async_trait` verwendet. Für nebenläufigen Zugriff auf geteilte Zustände sind `tokio::sync` Mechanismen wie `RwLock` und `Mutex` einzusetzen.
        
    - **Eindeutige IDs:** `uuid` (Version 4) wird zur Generierung eindeutiger Identifikatoren für Entitäten verwendet.
        
    - **Zeitstempel:** `chrono::DateTime<Utc>` wird für Zeitstempel verwendet, um Konsistenz zu gewährleisten.
        
    - **Event-Handling:** `tokio::sync::broadcast` wird für ein entkoppeltes, internes Event-System genutzt, um Änderungen an andere Systemteile zu kommunizieren.
        
- **Modularität und Kohäsion:** Die Domänenschicht ist in klar abgegrenzte Module unterteilt, die jeweils spezifische Verantwortlichkeiten haben (z.B. `domain::theming`, `domain::workspaces`, `domain::user_centric_services`, `domain::global_settings_and_state_management`, `domain::notifications_core`, `domain::notifications_rules`). Jedes Modul sollte eine hohe Kohäsion aufweisen und lose mit anderen Modulen gekoppelt sein.
    
- **Typsicherheit:** Newtypes und spezifische Enums werden verwendet, um die Typsicherheit zu erhöhen und die Semantik von Daten klarer zu gestalten (z.B. `TokenIdentifier`, `WorkspaceId`, `SettingKey` ).
    
- **Abstraktion und Schnittstellen:** Öffentliche APIs von Modulen werden oft durch Traits definiert, um Implementierungsdetails zu kapseln und Testbarkeit durch Mocking zu ermöglichen (z.B. `AIInteractionLogicService`, `NotificationService`, `GlobalSettingsService`, `SettingsProvider` ).
    
- **Zustandsverwaltung:** Veränderliche Zustände innerhalb von Services werden typischerweise mit `Arc<Mutex<...>>` oder `Arc<RwLock<...>>` gekapselt, um Thread-Sicherheit zu gewährleisten.
    
- **Validierung:** Eingabedaten und Einstellungsänderungen werden aktiv validiert, um die Konsistenz und Integrität der Domänendaten sicherzustellen.
    
- **Logging:** Das `tracing`-Framework soll für strukturiertes Logging und Debugging verwendet werden.
    
- **Dokumentation:** Öffentliche Typen, Methoden und Felder müssen umfassend mit `rustdoc`-Kommentaren dokumentiert werden, inklusive Vor- und Nachbedingungen, Fehler und Beispiele.
    
- **Testbarkeit:** Unit-Tests sind parallel zur Implementierung zu erstellen und sollen eine hohe Codeabdeckung anstreben. Mocking von Abhängigkeiten (insbesondere von Schnittstellen zur Kern- oder Systemschicht) ist entscheidend.
    

### 2. Struktur und Kernkomponenten der Domänenschicht

Die Domänenschicht besteht aus mehreren Kernmodulen, die spezifische Aufgabenbereiche abdecken:

#### 2.1. Modul: `domain::theming`

- **Verantwortlichkeit:** Logik des Erscheinungsbilds (Theming), Verwaltung von Design-Tokens, Interpretation von Theme-Definitionen, dynamische Theme-Wechsel (Farbschema, Akzentfarben).
    
- **Datenstrukturen:**
    - `TokenIdentifier` (String-Wrapper für hierarchische Token-IDs wie "color.background.primary").
        
    - `TokenValue` (Enum für Token-Wertetypen: Color, Dimension, FontSize, FontFamily, FontWeight, LineHeight, LetterSpacing, Border, Shadow, Radius, Spacing, ZIndex, Opacity, Text, Reference zu anderem Token).
        
    - `RawToken` (Struct: id, value, optionale description, group).
        
    - `TokenSet` (Typalias für `HashMap<TokenIdentifier, RawToken>`).
        
    - `ThemeIdentifier` (String-Wrapper für Theme-IDs).
        
    - `ColorSchemeType` (Enum: Light, Dark).
        
    - `AccentColor` (Struct: optionaler name, value als CSS-Farbwert).
        
    - `ThemeVariantDefinition` (Struct: applies_to_scheme, tokens als TokenSet für Überschreibungen).
        
    - `ThemeDefinition` (Struct: id, name, description, author, version, base_tokens, variants, supported_accent_colors).
        
    - `AppliedThemeState` (Struct: theme_id, color_scheme, active_accent_color, resolved_tokens als `HashMap<TokenIdentifier, String>`).
        
    - `ThemingConfiguration` (Struct: selected_theme_id, preferred_color_scheme, selected_accent_color, custom_user_token_overrides).
        
- **Kernlogik (`ThemingEngine` Service):**
    
    - Laden, Parsen und Validieren von Token- (_.tokens.json) und Theme-Definitionen (_.theme.json) von standardisierten Pfaden (System- und Benutzer-spezifisch). Validierung beinhaltet Eindeutigkeit von Token-IDs und Erkennung zyklischer Referenzen.
        
    - Token Resolution Pipeline: Auflösung von Token-Referenzen und Anwendung von Überschreibungen (Theme-Basis, Variante, Akzentfarbe, Benutzer-Overrides) in definierter Reihenfolge. Ergebnis ist der `AppliedThemeState`.
        
    - Dynamische Theme-Wechsel basierend auf Änderungen in `ThemingConfiguration`.
        
    - Caching von aufgelösten `AppliedThemeState`s.
        
- **Öffentliche API (`ThemingEngine`):**
    - `new(initial_config, theme_load_paths, token_load_paths)`: Konstruktor.
        
    - `get_current_theme_state()`: Gibt aktuellen `AppliedThemeState` zurück.
        
    - `get_available_themes()`: Gibt `Vec<ThemeDefinition>` zurück.
        
    - `get_current_configuration()`: Gibt aktuelle `ThemingConfiguration` zurück.
        
    - `update_configuration(new_config)`: Aktualisiert Konfiguration und löst Neuberechnung aus.
        
    - `reload_themes_and_tokens()`: Lädt alle Definitionen neu.
        
    - `subscribe_to_theme_changes()`: Gibt einen `mpsc::Receiver<ThemeChangedEvent>` zurück.
        
- **Events:** `ThemeChangedEvent { new_state: AppliedThemeState }`.
    
- **Fehlerbehandlung:** `ThemingError` Enum (z.B. `TokenFileParseError`, `CyclicTokenReference`, `ThemeNotFound`, `MissingTokenReference`).
    
- **Dateistruktur:** `domain/theming/{mod.rs, types.rs, errors.rs, logic.rs, default_themes/}`.
    

#### 2.2. Modul: `domain::workspaces`

Verantwortlich für die Logik und Verwaltung von Arbeitsbereichen ("Spaces" oder virtuelle Desktops). Unterteilt in `core`, `assignment`, `manager`, und `config`.

- **`workspaces::core`**: Fundamentale Workspace-Definition.
    
    - **Datenstrukturen:**
        - `WorkspaceId` (Typalias für `uuid::Uuid`).
            
        - `WindowIdentifier` (Newtype für `String`, repräsentiert Fenster-IDs).
            
        - `WorkspaceLayoutType` (Enum: Floating, TilingHorizontal, TilingVertical, Maximized; Default: Floating).
            
        - `Workspace` (Struct: id, name, persistent_id, layout_type, window_ids: `HashSet<WindowIdentifier>`, created_at). Validierungen für `name` (nicht leer, Maximallänge) und `persistent_id`.
            
    - **API (`impl Workspace`):** `new()`, `id()`, `name()`, `rename()`, `layout_type()`, `set_layout_type()`, `add_window_id()` (crate-intern), `remove_window_id()` (crate-intern), `window_ids()`, `persistent_id()`, `set_persistent_id()`, `created_at()`.
        
    - **Event-Payloads (Definiert in `core::event_data`):** `WorkspaceRenamedData`, `WorkspaceLayoutChangedData`, `WindowAddedToWorkspaceData`, `WindowRemovedFromWorkspaceData`, `WorkspacePersistentIdChangedData`.
        
    - **Fehlerbehandlung:** `WorkspaceCoreError` (z.B. `InvalidName`, `NameCannotBeEmpty`, `NameTooLong`, `InvalidPersistentId`).
        
- **`workspaces::assignment`**: Logik zur Fensterzuweisung.
    
    - **API (Freistehende Funktionen):**
        - `assign_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, target_workspace_id, window_id, ensure_unique_assignment: bool)`
            
        - `remove_window_from_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, source_workspace_id, window_id)`
            
        - `move_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, source_workspace_id, target_workspace_id, window_id)`
            
        - `find_workspace_for_window(workspaces: &HashMap<WorkspaceId, Workspace>, window_id) -> Option<WorkspaceId>`
            
    - **Fehlerbehandlung:** `WindowAssignmentError` (z.B. `WorkspaceNotFound`, `WindowAlreadyAssigned`, `WindowNotOnSourceWorkspace`, `CannotMoveToSameWorkspace`, `RuleViolation`).
        
- **`workspaces::manager`**: Orchestrierung und übergeordnete Verwaltung.
    
    - **Zustand (`WorkspaceManager` Struct):** `workspaces: HashMap<WorkspaceId, Workspace>`, `active_workspace_id: Option<WorkspaceId>`, `ordered_workspace_ids: Vec<WorkspaceId>`, `next_workspace_number`, `config_provider: Arc<dyn WorkspaceConfigProvider>`, `event_publisher: Arc<dyn EventPublisher<WorkspaceEvent>>`, `ensure_unique_window_assignment: bool`.
        
    - **API (`impl WorkspaceManager`):** `new()`, `create_workspace()`, `delete_workspace()`, `get_workspace()`, `get_workspace_mut()`, `all_workspaces_ordered()`, `active_workspace_id()`, `set_active_workspace()`, `assign_window_to_active_workspace()`, `assign_window_to_specific_workspace()`, `remove_window_from_its_workspace()`, `move_window_to_specific_workspace()`, `rename_workspace()`, `set_workspace_layout()`, `save_configuration()`.
        
    - **Events (`WorkspaceEvent` Enum):** `WorkspaceCreated`, `WorkspaceDeleted`, `ActiveWorkspaceChanged`, `WorkspaceRenamed`, `WorkspaceLayoutChanged`, `WindowAddedToWorkspace`, `WindowRemovedFromWorkspace`, `WorkspaceOrderChanged`, `WorkspacesReloaded`, `WorkspacePersistentIdChanged`.
        
    - **Fehlerbehandlung:** `WorkspaceManagerError` (z.B. `WorkspaceNotFound`, `CannotDeleteLastWorkspace`, `NoActiveWorkspace`, Wraps: `WorkspaceCoreError`, `WindowAssignmentError`, `WorkspaceConfigError`).
        
- **`workspaces::config`**: Konfigurations- und Persistenzlogik.
    
    - **Datenstrukturen (Snapshots für Persistenz):**
        - `WorkspaceSnapshot` (Struct: persistent_id, name, layout_type).
            
        - `WorkspaceSetSnapshot` (Struct: workspaces: `Vec<WorkspaceSnapshot>`, active_workspace_persistent_id).
            
    - **Schnittstelle (`WorkspaceConfigProvider` Trait):**
        - `load_workspace_config() -> Result<WorkspaceSetSnapshot, WorkspaceConfigError>`
            
        - `save_workspace_config(config_snapshot: &WorkspaceSetSnapshot) -> Result<(), WorkspaceConfigError>`
            
    - **Beispielimplementierung:** `FilesystemConfigProvider` (nutzt `core::config::ConfigService`).
        
    - **Fehlerbehandlung:** `WorkspaceConfigError` (z.B. `LoadError`, `SaveError`, `InvalidData`, `SerializationError`, `DeserializationError`, `PersistentIdNotFound`, `DuplicatePersistentId`).
        

#### 2.3. Modul: `domain::user_centric_services`

Bündelt Logik für KI-Interaktionen (inkl. Einwilligungsmanagement) und ein umfassendes Benachrichtigungssystem.

- **KI-Interaktionsmanagement:**
    - **Datenstrukturen:**
        - `AIInteractionContext` (Struct: id: Uuid, creation_timestamp, active_model_id, consent_status: `AIConsentStatus`, associated_data_categories: `Vec<AIDataCategory>`, interaction_history, attachments: `Vec<AttachmentData>`).
            
        - `AIConsent` (Struct: id: Uuid, user_id, model_id, data_categories: `Vec<AIDataCategory>`, granted_timestamp, expiry_timestamp, is_revoked).
            
        - `AIModelProfile` (Struct: model_id, display_name, description, provider, required_consent_categories: `Vec<AIDataCategory>`, capabilities).
            
        - `AttachmentData` (Struct: id: Uuid, mime_type, source_uri, content, description).
            
        - `AIConsentStatus` (Enum: Granted, Denied, PendingUserAction, NotRequired).
            
        - `AIDataCategory` (Enum: UserProfile, ApplicationUsage, FileSystemRead, ClipboardAccess, LocationData, GenericText, GenericImage).
            
    - **API (`AIInteractionLogicService` Trait):** `initiate_interaction()`, `get_interaction_context()`, `provide_consent()`, `get_consent_for_model()`, `add_attachment_to_context()`, `list_available_models()`, `store_consent()`, `get_all_user_consents()`, `load_model_profiles()`.
        
    - **Events:** `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`.
        
    - **Fehlerbehandlung:** `AIInteractionError` (z.B. `ContextNotFound`, `ConsentRequired`, `ModelNotFound`, `ConsentStorageError`, `ModelProfileLoadError`).
        
- **Benachrichtigungsmanagement:**
    - **Datenstrukturen:**
        - `Notification` (Struct: id: Uuid, application_name, application_icon, summary, body, actions: `Vec<NotificationAction>`, urgency: `NotificationUrgency`, timestamp, is_read, is_dismissed, transient).
            
        - `NotificationAction` (Struct: key, label, action_type: `NotificationActionType`).
            
        - `NotificationUrgency` (Enum: Low, Normal, Critical).
            
        - `NotificationActionType` (Enum: Callback, OpenLink).
            
        - `NotificationFilterCriteria` (Enum: Unread, Application(String), Urgency(NotificationUrgency)).
            
        - `NotificationSortOrder` (Enum: TimestampAscending, TimestampDescending, Urgency).
            
    - **API (`NotificationService` Trait):** `post_notification()`, `get_notification()`, `mark_as_read()`, `dismiss_notification()`, `get_active_notifications()`, `get_notification_history()`, `clear_history()`, `set_do_not_disturb()`, `is_do_not_disturb_enabled()`, `invoke_action()`.
        
    - **Events:** `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `DoNotDisturbModeChangedEvent`.
        
    - **Fehlerbehandlung:** `NotificationError` (z.B. `NotFound`, `InvalidData`, `HistoryFull`, `ActionNotFound`).
        
- **Dateistruktur:** `domain/user_centric_services/{mod.rs, ai_interaction_service.rs, notification_service.rs, types.rs, errors.rs}`.
    

#### 2.4. Modul: `domain::global_settings_and_state_management` (auch `domain::settings_core` + `domain::settings_persistence_iface`)

Verantwortlich für die Repräsentation, Verwaltung und Konsistenz globaler Desktop-Einstellungen.

- **`domain::settings_core`**: Kernlogik der Einstellungsverwaltung.
    
    - **Datenstrukturen:**
        - `SettingKey` (Newtype für `String`, für Einstellungsschlüssel wie "appearance.theme.name").
            
        - `SettingValue` (Enum: Boolean, Integer, Float, String, Color, FilePath, List, Map).
            
        - `SettingMetadata` (Struct: description, default_value, value_type_hint, possible_values, validation_regex, min_value, max_value, is_sensitive, requires_restart).
            
        - `Setting` (Struct: id: Uuid, key, current_value, metadata, last_modified, is_dirty).
            
        - `GlobalDesktopSettings` (Hauptstruktur, die alle globalen Einstellungen kategorisiert, z.B. `AppearanceSettings`, `WorkspaceSettings`, `InputBehaviorSettings`, `PowerManagementPolicySettings`, `DefaultApplicationsSettings`). Jede Unterstruktur enthält spezifische Einstellungsfelder.
            
        - `SettingPath` (Enum-Hierarchie zur typsicheren Adressierung von Einstellungen, z.B. `SettingPath::Appearance(AppearanceSettingPath::FontSettings(FontSettingPath::DefaultFontSize))`).
            
    - **API (`SettingsCoreManager` oder `GlobalSettingsService` Trait):**
        - `new(provider, initial_metadata, event_channel_capacity)` / `load_settings()`
            
        - `save_settings()`
            
        - `get_current_settings()` / `get_setting_value(key)` / `get_setting(path)`
            
        - `set_setting_value(key, value)` / `update_setting(path, value: JsonValue)`
            
        - `reset_setting_to_default(key)` / `reset_to_defaults()`
            
        - `register_setting_metadata(key, metadata)`
            
        - `get_all_settings_with_metadata()`
            
        - `subscribe_to_changes()` / `subscribe_to_setting_changes()`
            
    - **Events:** `SettingChangedEvent { key/path, new_value }`, `SettingsLoadedEvent { settings }`, `SettingsSavedEvent`.
        
    - **Fehlerbehandlung:** `SettingsCoreError` / `GlobalSettingsError` (z.B. `SettingNotFound`, `ValidationError`, `PersistenceError`, `PathNotFound`, `InvalidValueType`).
        
- **`domain::settings_persistence_iface`**: Persistenzabstraktion.
    
    - **Schnittstelle (`SettingsProvider` Trait):**
        - `load_setting(key) -> Result<Option<SettingValue>, SettingsPersistenceError>`
            
        - `save_setting(key, value) -> Result<(), SettingsPersistenceError>`
            
        - `load_all_settings() -> Result<Vec<(SettingKey, SettingValue)>, SettingsPersistenceError>`
            
        - `delete_setting(key) -> Result<(), SettingsPersistenceError>`
            
        - `setting_exists(key) -> Result<bool, SettingsPersistenceError>`
            
    - **Fehlerbehandlung:** `SettingsPersistenceError` (z.B. `BackendUnavailable`, `StorageAccessError`, `SerializationError`, `DeserializationError`, `IoError`).
        
- **Dateistruktur (Global Settings):** `domain/global_settings_management/{mod.rs, service.rs, types.rs, paths.rs, errors.rs}`.
    
- **Dateistruktur (Settings Core & Persistence Interface):** `domain/src/settings_core/{mod.rs, types.rs, error.rs}`, `domain/src/settings_persistence_iface/{mod.rs, error.rs}`.
    

#### 2.5. Modul: `domain::notifications_rules`

Implementiert die Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf konfigurierbaren Regeln.

- **Verantwortlichkeit:** Definition von Benachrichtigungsregeln (`NotificationRule`), deren Bedingungen (`RuleCondition`) und Aktionen (`RuleAction`); Bereitstellung einer Engine (`NotificationRulesEngine`) zur Regelauswertung und -anwendung.
    
- **Datenstrukturen:**
    - `RuleCondition` (Enum: AppNameIs, AppNameMatches (Regex), SummaryContains, UrgencyIs, CategoryIs, HintExists, HintValueIs, SettingIsTrue, LogicalAnd, LogicalOr, LogicalNot etc.).
        
    - `RuleAction` (Enum: SuppressNotification, SetUrgency, AddAction, SetHint, PlaySound, MarkAsPersistent, SetExpiration, LogMessage etc.).
        
    - `NotificationRule` (Struct: id, description, conditions: `RuleCondition`, actions: `Vec<RuleAction>`, is_enabled, priority, stop_after).
        
- **Kernlogik (`NotificationRulesEngine` Service):**
    - Lädt und verwaltet Regeldefinitionen (sortiert nach Priorität).
        
    - `process_notification(notification)`: Wertet Regeln gegen eine eingehende Benachrichtigung aus.
        
        - Gibt `RuleProcessingResult` zurück: `Allow(modified_notification)` oder `Suppress(rule_id)`.
            
    - `evaluate_condition(condition, notification, rule)`: Rekursive Auswertung von Regelbedingungen. Interagiert mit `SettingsCoreManager` für `Setting*`-Bedingungen.
        
    - `apply_action(action, notification, rule)`: Anwendung von Regelaktionen auf eine Benachrichtigung.
        
    - Reagiert auf `SettingChangedEvent` (optional, zur Cache-Invalidierung oder Neubewertung).
        
- **Öffentliche API (`NotificationRulesEngine`):**
    - `new(settings_manager, initial_rules, settings_event_receiver)`
        
    - `load_rules(new_rules)`
        
    - `process_notification(notification) -> Result<RuleProcessingResult, NotificationRulesError>`
        
    - `handle_setting_changed(event)` (intern aufgerufen).
        
- **Fehlerbehandlung:** `NotificationRulesError` (z.B. `InvalidRuleDefinition`, `ConditionEvaluationError`, `ActionApplicationError`, `SettingsAccessError`).
    
- **Dateistruktur:** `domain/src/notifications_rules/{mod.rs, types.rs, error.rs}`.

### 3. Interaktionen und Abhängigkeiten

- **Domänenmodule untereinander:**
    - `NotificationCoreManager` nutzt `NotificationRulesEngine` zur Verarbeitung von Benachrichtigungen.
        
    - `NotificationRulesEngine` nutzt `SettingsCoreManager` (oder `GlobalSettingsService`), um regelbedingte Einstellungen abzufragen.
        
    - `ThemingEngine` reagiert auf `SettingChangedEvent` von `SettingsCoreManager` für themenrelevante Einstellungen.
        
    - Services aus `domain::user_centric_services` und `domain::workspaces` können globale Einstellungen von `GlobalSettingsService` lesen.
        
- **Abhängigkeiten zur Kernschicht (`core::*`):**
    - `core::config`: Wird von `domain::settings_persistence_iface`-Implementierungen und `domain::workspaces::config` für das Lesen/Schreiben von Konfigurationsdateien genutzt.
        
    - `core::errors`: Basisfehlertypen können in Domänenfehler gewrappt werden.
        
    - `core::types`: Fundamentale Typen wie `Uuid`, `DateTime<Utc>`.
        
    - `core::logging` (`tracing`): Wird für Logging verwendet.
        
- **Schnittstellen zu höheren Schichten (System- und UI-Schicht):**
    - Die Domänenschicht stellt ihre Funktionalität über öffentliche APIs (oft Traits) ihrer Service-Komponenten bereit.
        
    - Die UI-Schicht (z.B. `ui::control_center`, `ui::shell` ) konsumiert diese APIs und reagiert auf Events aus der Domänenschicht.
        
    - Die Systemschicht (z.B. MCP-Client, D-Bus Handler, Compositor ) interagiert ebenfalls mit den Domänendiensten und leitet Systemereignisse an diese weiter oder setzt deren Anweisungen um.
        

### 4. Zusammenfassende Betrachtungen

Die Domänenschicht ist als eine Sammlung modularer, voneinander entkoppelter Komponenten konzipiert, die jeweils klar definierte Verantwortlichkeiten besitzen. Durch die konsequente Anwendung von Prinzipien wie Typsicherheit, expliziter Fehlerbehandlung, Event-basierter Kommunikation und der Abstraktion von Persistenz- und UI-Belangen wird eine robuste, wartbare und erweiterbare Grundlage für die Desktop-Umgebung geschaffen. Die detaillierten Spezifikationen der einzelnen Module, ihrer Datenstrukturen, APIs und Fehlerfälle dienen als direkter Leitfaden für die Implementierung.

## Technische Spezifikation und Entwicklungsrichtlinien: Systemschicht

Die Systemschicht bildet das Fundament der Desktop-Umgebung und ist verantwortlich für die Kernfunktionalitäten, die Interaktion mit der Hardware und die Bereitstellung grundlegender Dienste für höhere Schichten. Sie implementiert die "Mechanik" der Desktop-Umgebung, indem sie übergeordnete Richtlinien und Benutzerinteraktionen in konkrete Systemaktionen übersetzt. Dies erfordert eine präzise und robuste Interaktion mit Wayland-Protokollen, D-Bus-Systemdiensten und potenziell direkter Hardware-Interaktion (z.B. DRM). Die Stabilität und Reaktionsfähigkeit der gesamten Umgebung hängt maßgeblich von der Zuverlässigkeit dieser Schicht ab. Daher sind Resilienz, asynchrone Operationen, umfassendes Fehlermanagement und sorgfältige Zustandssynchronisation zentrale Entwurfsprinzipien.

### 1. Entwicklungsrichtlinien

Die Entwicklung aller Komponenten der Systemschicht muss strengen Richtlinien folgen, um Konsistenz, Qualität und Wartbarkeit zu gewährleisten.

- **Programmiersprache:** Rust ist die primäre Programmiersprache.
    
- **Coding Style & Formatierung:** Verbindliche Nutzung von `rustfmt` mit Standardkonfiguration. Einhaltung der Rust API Guidelines ist erforderlich.
    
- **API-Design:** Befolgung der Rust API Guidelines Checklist für konsistente und idiomatische Schnittstellen.
    
- **Fehlerbehandlung:** Konsequente Verwendung des `thiserror`-Crates zur Definition spezifischer Fehler-Enums pro Modul (z.B. `CompositorCoreError`, `ShmError`, `XdgShellError`, `DBusError`, `OutputError`, `AudioError`, `McpError`, `PortalsError`). Alle öffentlichen Funktionen in den Modulen sollten `Result<T, SpecificError>` zurückgeben.
    
- **Logging & Tracing:** Einsatz des `tracing`-Crate-Frameworks (`tracing::{info, debug, error}`) für strukturiertes, kontextbezogenes Logging und Tracing von Operationen.
    
- **Dokumentkonventionen:** Eine Tabelle mit definierten Begriffen und Konventionen (z.B. `DesktopState`, `WlFoo`, `XdgFoo`) wird verwendet, um Klarheit und Konsistenz in der Terminologie sicherzustellen.
    
- **Asynchronität:** Asynchrone Operationen sind für alle potenziell blockierenden E/A-Vorgänge zu verwenden, insbesondere bei D-Bus-Aufrufen (mittels `zbus`) und Wayland-Ereignisverarbeitung.
    
- **Strikte Einhaltung der Gesamtspezifikation:** Die hier beschriebenen Spezifikationen sind eine detaillierte Erweiterung der "Technischen Gesamtspezifikation und Entwicklungsrichtlinien". Deren Einhaltung ist bindend.
    

### 2. Modul: `system::compositor` (Smithay-basierter Wayland Compositor)

Dieses Modul implementiert die Kernlogik des Wayland-Compositors unter Verwendung des Smithay-Toolkits. Es ist verantwortlich für die Verwaltung von Wayland-Client-Verbindungen, Oberflächen, Pufferbehandlung und die Integration mit Shell-Protokollen. Die Designphilosophie von Smithay erfordert ein signifikantes Zustandsmanagement innerhalb der zentralen `DesktopState`-Struktur.

#### 2.1. Submodul: `system::compositor::core`

Dieses Submodul etabliert die grundlegenden Elemente für die Verwaltung von Wayland-Oberflächen und die Kernoperationen des Compositors.

**Dateien:**

- `compositor_state.rs`:
    - **Zweck:** Definiert und verwaltet den primären Zustand für die Globals `wl_compositor` und `wl_subcompositor` und handhabt den Client-spezifischen Compositor-Zustand.
        
    - **Struktur `CompositorCoreError`:** Definiert Fehler spezifisch für Kernoperationen des Compositors mittels `thiserror`. Varianten umfassen `GlobalCreationFailed`, `RoleError`, `ClientDataMissing`, `SurfaceDataMissing`, `InvalidSurfaceState`.
        
    - **Struktur `DesktopState` (teilweise):** Kapselt den zentralen Zustand. Enthält `compositor_state: CompositorState`, `display_handle: DisplayHandle`, `loop_handle: LoopHandle<Self>`. Ein Konstruktor `new(display_handle, loop_handle)` initialisiert diese Felder.
        
    - **Struktur `ClientCompositorData`:** Speichert `CompositorClientState` pro Client.
        
    - **Implementierung `CompositorHandler` für `DesktopState`:** Delegiert Compositor-Ereignisse an die Anwendungslogik.
        
        - `compositor_state()`: Gibt `&mut self.compositor_state` zurück.
            
        - `client_compositor_state()`: Ruft `ClientCompositorData` aus `Client::get_data()` ab und gibt `&compositor_state` daraus zurück. Loggt Fehler und panicked bei fehlenden Daten.
            
        - `commit()`: Greift auf `SurfaceData` zu, prüft auf neue Puffer, aktualisiert Schadensverfolgung, löst rollenspezifische Logik aus und markiert die Oberfläche für Neuzeichnung. Verwendet `smithay::wayland::compositor::with_states`.
            
        - `new_surface()`: Initialisiert `SurfaceData` für die neue `WlSurface` und speichert sie in deren `data_map`. Fügt einen Zerstörungs-Hook hinzu.
            
        - `new_subsurface()`: Aktualisiert `SurfaceData` der neuen und der Eltern-Oberfläche, um die Eltern-Kind-Beziehung herzustellen.
            
        - `destroyed()`: Die primäre Bereinigung wird von Smithay gehandhabt. Externe Referenzen müssen hier oder über Zerstörungs-Hooks bereinigt werden.
            
    - **Implementierung `GlobalDispatch<WlCompositor, ()>` für `DesktopState`:**
        - `bind()`: Protokolliert die Bind-Anfrage, initialisiert bei Bedarf `ClientCompositorData` für den Client und initialisiert die Ressource mit `data_init.init()`. `CompositorState::new()` erstellt das Global.
            
    - **Implementierung `GlobalDispatch<WlSubcompositor, ()>` für `DesktopState`:**
        - `bind()`: Protokolliert die Bind-Anfrage und initialisiert die Ressource. `CompositorState::new()` erstellt das Global.
            
- `surface_management.rs`:
    - **Zweck:** Definiert `SurfaceData` und zugehörige Hilfsfunktionen.
        
    - **Struktur `SurfaceData`:** Gespeichert in der `UserDataMap` jeder `WlSurface`. Enthält Felder wie `id: uuid::Uuid`, `role: Option<String>`, `client_id`, `current_buffer`, `pending_buffer`, `texture_id` (als `Option<Box<dyn RenderableTexture>>`), `last_commit_serial`, `damage_regions_buffer_coords`, `opaque_region`, `input_region`, `user_data_ext`, `parent`, `children`, `pre_commit_hooks`, `post_commit_hooks`, `destruction_hooks`. `RenderableTexture` muss `Send + Sync` sein.
        
    - **Methoden für `SurfaceData`:** `new()`, `set_role()`, `get_role()`, `attach_buffer()`, `commit_buffer()`, `add_damage_buffer_coords()`, `take_damage_buffer_coords()`.
        
    - **Enum `SurfaceRoleError`:** Variante `RoleAlreadySet`.
        
    - **Funktionen:** `get_surface_data()`, `with_surface_data()` (kapselt Mutex-Locking), `give_surface_role()` (verwendet `smithay::wayland::compositor::give_role`), `get_surface_role()` (verwendet `smithay::wayland::compositor::get_role`).
        
- `global_objects.rs`:
    - **Zweck:** Zentralisiert die Erstellung der Kern-Wayland-Globals.
        
    - **Funktion `create_core_compositor_globals()`:** Erstellt `CompositorState` und speichert es in `DesktopState`. Dies registriert intern `wl_compositor` (Version 6) und `wl_subcompositor` (Version 1).
        

#### 2.2. Submodul: `system::compositor::shm` (SHM-Pufferbehandlung)

Dieses Submodul implementiert die Unterstützung für `wl_shm`, wodurch Clients Shared-Memory-Puffer mit dem Compositor teilen können.

**Dateien:**

- `shm_state.rs`:
    - **Zweck:** Verwaltet das `wl_shm`-Global und handhabt die Erstellung und den Zugriff auf SHM-Puffer.
        
    - **Struktur `ShmError`:** Definiert Fehler für SHM-Operationen (z.B. `PoolCreationFailed`, `BufferCreationFailed`, `InvalidFormat`, `AccessError`).
        
    - **`DesktopState` (teilweise):** Enthält `shm_state: ShmState` und `shm_global: GlobalId`.
        
    - **Implementierung `ShmHandler` für `DesktopState`:**
        - `shm_state()`: Gibt `&self.shm_state` zurück.
            
    - **Implementierung `BufferHandler` für `DesktopState`:** (Gilt für alle `wl_buffer`, nicht nur SHM)
        
        - `buffer_destroyed()`: Protokolliert, benachrichtigt das Rendering-Backend zur Ressourcenfreigabe und entfernt Puffer-Referenzen aus `SurfaceData`-Instanzen.
            
    - **Implementierung `GlobalDispatch<WlShm, ()>` für `DesktopState`:**
        - `bind()`: Protokolliert die Bindung und initialisiert die Ressource. `ShmState` sendet `format`-Ereignisse.
            
    - **Funktion `create_shm_global()`:** Definiert unterstützte SHM-Formate (Standard: ARGB8888, XRGB8888), erstellt `ShmState`, speichert `shm_state` und `shm_global` (zurückgegeben von `shm_state.global().clone()`) in `DesktopState`.
        
- `shm_buffer_access.rs`:
    - **Zweck:** Bietet sicheren Zugriff auf Inhalte von SHM-Puffern.
        
    - **Funktion `with_shm_buffer_contents()`:** Verwendet intern `smithay::wayland::shm::with_buffer_contents`, um einen Callback mit Zeiger und Länge der Pufferdaten aufzurufen. Kapselt die Unsicherheit der Zeiger-Dereferenzierung.
        

#### 2.3. Submodul: `system::compositor::xdg_shell` (XDG-Shell-Integration)

Implementiert das `xdg_shell`-Protokoll zur Verwaltung moderner Desktop-Fenster (Toplevels und Popups). Das Protokoll ist komplex und erfordert signifikante Logik in den Handler-Methoden, um Oberflächenzustände, Interaktionen mit der Fenstermanagement-Richtlinie und das Senden korrekter Wayland-Ereignisse zu verwalten. Eine robuste Fehlerbehandlung und Zustandsvalidierung sind entscheidend.

**Dateien:**

- `xdg_shell_state.rs`:
    - **Zweck:** Verwaltet das `xdg_wm_base`-Global und die zugehörigen XDG-Oberflächenzustände.
        
    - **Struktur `XdgShellError`:** Definiert Fehler wie `InvalidSurfaceRole`, `WindowHandlingError`, `PopupPositioningError`, `InvalidAckConfigureSerial`, `ToplevelNotFound`, `PopupNotFound`.
        
    - **`DesktopState` (teilweise):** Enthält `xdg_shell_state: XdgShellState`, `xdg_shell_global: GlobalId`, `toplevels: HashMap<WlSurface, Arc<Mutex<ManagedToplevel>>>`, `popups: HashMap<WlSurface, Arc<Mutex<ManagedPopup>>>`.
        
    - **Implementierung `XdgShellHandler` für `DesktopState`:** Die Implementierung der Methoden wird in `xdg_handlers.rs` detailliert. `xdg_shell_state()` gibt `&mut self.xdg_shell_state` zurück.
        
    - **Implementierung `GlobalDispatch<XdgWmBase, GlobalId>` für `DesktopState`:**
        - `bind()`: Protokolliert, ruft `state.xdg_shell_state.new_client()` auf, um `ShellClientUserData` zu erhalten, und initialisiert die Ressource damit. `XdgShellState` handhabt das Ping/Pong-Verhalten.
            
    - **Funktion `create_xdg_shell_global()`:** Erstellt `XdgShellState`, ruft dessen `global()`-Methode auf und speichert beides in `DesktopState`.
        
- `toplevel_management.rs`:
    - **Zweck:** Definiert Datenstrukturen und Logik spezifisch für XDG-Toplevel-Fenster.
        
    - **Struktur `ManagedToplevel`:** Kapselt `ToplevelSurface` von Smithay und fügt anwendungsspezifische Zustände hinzu. Felder umfassen `id: uuid::Uuid`, `surface_handle: ToplevelSurface`, `wl_surface: WlSurface`, `app_id`, `title`, `current_state: ToplevelWindowState`, `pending_state: ToplevelWindowState`, `window_geometry`, `min_size`, `max_size`, `parent` (für transiente Fenster), `client_provides_decorations`, `last_configure_serial`, `acked_configure_serial`. Methoden: `new()`, `send_configure()` (sendet `xdg_toplevel.configure` und `xdg_surface.configure`), `ack_configure()`.
        
    - **Struktur `ToplevelWindowState`:** Felder: `size`, `maximized`, `fullscreen`, `resizing`, `activated`, `suspended`, `decorations`.
        
    - **Struktur `ToplevelSurfaceUserData`:** In `WlSurface::data_map()` gespeichert, enthält `managed_toplevel_id`.
        
- `popup_management.rs`:
    - **Zweck:** Definiert Datenstrukturen und Logik spezifisch für XDG-Popup-Fenster.
        
    - **Struktur `ManagedPopup`:** Kapselt `PopupSurface` von Smithay. Felder: `id: uuid::Uuid`, `surface_handle: PopupSurface`, `wl_surface: WlSurface`, `parent_wl_surface`, `positioner_state: PositionerState`, `current_geometry`, `last_configure_serial`, `acked_configure_serial`. Methoden: `new()`, `send_configure()`, `ack_configure()`, `calculate_geometry()`.
        
    - **Struktur `PopupSurfaceUserData`:** In `WlSurface::data_map()` gespeichert, enthält `managed_popup_id`.
        
- `xdg_handlers.rs`:
    - **Zweck:** Detaillierte Implementierung der `XdgShellHandler`-Methoden für `DesktopState`.
        
    - `new_toplevel()`: Erstellt `ManagedToplevel`, speichert es in `state.toplevels` und dessen ID in `ToplevelSurfaceUserData` der `WlSurface`. Sendet initiale Konfiguration.
        
    - `new_popup()`: Erstellt `ManagedPopup`, speichert es in `state.popups` und dessen ID in `PopupSurfaceUserData`. Sendet initiale Konfiguration.
        
    - `map_toplevel()`: Führt Logik für das Mapping des Toplevels aus (Sichtbarkeit, initiale Position/Größe), ruft ggf. `send_configure()` auf.
        
    - `ack_configure()`: Verarbeitet `ack_configure` vom Client für Toplevels oder Popups, ruft `ack_configure()` auf der `ManagedEntity` auf.
        
    - `toplevel_request_set_title()`: Aktualisiert `title` im `ManagedToplevel` und benachrichtigt die UI-Schicht.
        
    - Weitere Handler (z.B. für `set_app_id`, `set_maximized`, `move`, `resize`) werden analog implementiert, aktualisieren den Zustand von `ManagedToplevel`/`ManagedPopup` und lösen ggf. neue `configure`-Zyklen aus oder interagieren mit dem Input-System.
        

#### 2.4. Submodul: `system::compositor::display_loop` (Display und Ereignisschleife)

Verantwortlich für die Einrichtung des Wayland-Display-Kernobjekts und dessen Integration in die `calloop`-Ereignisschleife. Die `calloop`-Ereignisschleife ist zentral für Smithay. Langlaufende Operationen in Callbacks müssen vermieden werden.

**Dateien:**

- `display_setup.rs`:
    - **Zweck:** Initialisiert das Wayland Display und `DisplayHandle`.
        
    - **Struktur `ClientData`:** Assoziiert mit `wayland_server::Client`. Enthält `id: uuid::Uuid`, `client_name: Option<String>`, `user_data: UserDataMap`.
        
    - **Funktion `init_wayland_display_and_loop()` (konzeptionell):** Erstellt `EventLoop<DesktopState>` und `Display<DesktopState>`. `DisplayHandle` und `LoopHandle` werden in `DesktopState` gespeichert.
        
    - **Enum `InitError`:** Varianten `WaylandDisplayCreationFailed`, `EventLoopCreationFailed`.
        
- `event_loop_integration.rs`:
    - **Zweck:** Integriert die Wayland-Anzeige in die `calloop`-Ereignisschleife.
        
    - **Funktion `register_wayland_source()`:** Ruft den Dateideskriptor der Wayland-Anzeige ab. Erstellt eine `calloop::generic::Generic<FileDescriptor>`-Ereignisquelle. Fügt die Quelle in die Ereignisschleife ein (`loop_handle.insert_source()`). Der Callback ruft `shared_data.display_handle.dispatch_clients(shared_data)` auf und bei Erfolg `shared_data.display_handle.flush_clients()`. `display_handle.flush_clients()` muss regelmäßig aufgerufen werden.
        

#### 2.5. Submodul: `system::compositor::renderer_interface` (Renderer-Schnittstelle)

Definiert abstrakte Schnittstellen für Rendering-Operationen, um die Kernlogik des Compositors von spezifischen Rendering-Backends zu entkoppeln (z.B. DRM/GBM, Winit/EGL). Schadensverfolgung ist für effizientes Rendering unerlässlich und muss integriert werden.

**Dateien:**

- `abstraction.rs`:
    - **Zweck:** Definiert Traits für Rendering-Operationen.
        
    - **Trait `FrameRenderer`:**
        - Methoden: `new()`, `render_frame()` (nimmt `RenderElement`), `present_frame()`, `create_texture_from_shm()`, `create_texture_from_dmabuf()` (für spätere Teile), `screen_size()`.
            
    - **Trait `RenderableTexture` (`Send + Sync + Debug`):**
        - Methoden: `id() -> uuid::Uuid`, `bind()`, `width_px()`, `height_px()`, `format()`.
            
    - **Enum `RenderElement` (konzeptionell, analog zu Smithays `Element`):** Varianten `Surface` (mit `texture: Arc<dyn RenderableTexture>`), `SolidColor`, `Cursor`.
        
    - **Struktur `Color`:** Felder `r, g, b, a` als `f32`.
        
    - **Enum `RendererError`:** Varianten `ContextCreationFailed`, `ShaderCompilationFailed`, `TextureUploadFailed`, `BufferSwapFailed`, `InvalidBufferType`, `DrmError`, `EglError`, `Generic`.
        

### 3. Modul: `system::input` (Libinput-basierte Eingabeverarbeitung)

Verantwortlich für die gesamte Verarbeitung von Benutzereingaben von Geräten wie Tastaturen, Mäusen und Touchpads. Nutzt `libinput` für Rohdaten und Smithay-Abstraktionen (`LibinputInputBackend`, `SeatState`, `SeatHandler`) für Seat- und Fokusmanagement. Latenz oder fehlerhafte Verarbeitung hier beeinträchtigen die UX erheblich. Die Transformation von `libinput`-Ereignissen in Wayland-Ereignisse, inklusive Koordinatentransformationen und Fokuslogik, muss präzise sein. Erweiterte Eingabefunktionen wie Gesten müssen berücksichtigt werden. `xkbcommon` ist fundamental für die korrekte Interpretation von Tastatureingaben.

#### 3.1. Submodul: `system::input::seat_manager`

Definiert und verwaltet `SeatState` und `SeatHandler` für Eingabefokus und die Bekanntmachung von Fähigkeiten.

**Dateien:**

- `seat_state.rs`:
    - **Struktur `InputError`:** Definiert Fehler wie `SeatCreationFailed`, `CapabilityAdditionFailed`, `XkbConfigError`, `LibinputError`, `SeatNotFound`, `KeyboardHandleNotFound`, etc..
        
    - **`DesktopState` (teilweise):** Enthält `seat_state: SeatState<Self>`, `seats: HashMap<String, Seat<Self>>`, `active_seat_name: Option<String>`, `keyboards: HashMap<String, XkbKeyboardData>`.
        
    - **Implementierung `SeatHandler` für `DesktopState`:**
        - `KeyboardFocus = WlSurface`, `PointerFocus = WlSurface`, `TouchFocus = WlSurface`.
            
        - `seat_state()`: Gibt `&mut self.seat_state` zurück.
            
        - `focus_changed()`: Protokolliert Fokusänderung. Ruft `KeyboardHandle::leave()` für alten Fokus und `KeyboardHandle::enter()` für neuen Fokus auf (mit aktuellen Tasten und Modifikatoren). Aktualisiert interne Fenstermanagement-Zustände.
            
        - `cursor_image()`: Handhabt `CursorImageStatus::Hidden`, `CursorImageStatus::Surface` (prüft Rolle "cursor", ruft Puffer/Hotspot ab) und `CursorImageStatus::Named` (verwendet Cursor-Theming-Bibliothek). Weist Renderer an, den Cursor zu zeichnen/aktualisieren.
            
    - **Funktion `create_seat()`:** Ruft `state.seat_state.new_wl_seat()` auf. Fügt Fähigkeiten hinzu (`seat.add_keyboard()`, `seat.add_pointer()`, `seat.add_touch()`). Speichert `Seat`-Objekt und `XkbKeyboardData`. Setzt ggf. `active_seat_name`.
        

#### 3.2. Submodul: `system::input::libinput_handler`

Initialisiert und konfiguriert das `LibinputInputBackend` und verarbeitet dessen Ereignisse.

**Dateien:**

- `backend_config.rs`:
    - **Struktur `LibinputSessionInterface`:** Wrapper für `input::LibinputInterface` zum Öffnen/Schließen von Geräten über ein Session-Objekt (z.B. `DirectSession`, `LogindSession`).
        
    - **Funktion `init_libinput_backend()`:** Erstellt `libinput::Libinput`-Kontext mit `Libinput::new_from_path(session_interface)`. Weist dem Kontext einen Seat zu (`udev_assign_seat("seat0")`). Erstellt und gibt `LibinputInputBackend` zurück.
        
- `event_dispatcher.rs`:
    - **Zweck:** Verarbeitet `InputEvent<LibinputInputBackend>` und leitet an spezifische Handler weiter.
        
    - **Funktion `process_input_event()`:** Wird vom `calloop`-Callback aufgerufen. Ruft den aktiven Seat ab. Verarbeitet verschiedene `InputEvent`-Varianten (`Keyboard`, `PointerMotion`, `PointerButton`, `PointerAxis`, `TouchDown`, `TouchUp`, `TouchMotion`, `TouchFrame`, `TouchCancel`, `Gesture*`, `DeviceAdded`, `DeviceRemoved`) durch Aufruf entsprechender Handler-Funktionen in den jeweiligen Submodulen (`keyboard::key_event_translator`, `pointer::pointer_event_translator`, `touch::touch_event_translator`). Gestenereignisse werden initial nur protokolliert. Bei `DeviceAdded`/`DeviceRemoved` werden Seat-Fähigkeiten ggf. aktualisiert.
        

#### 3.3. Submodul: `system::input::keyboard`

Verwaltet XKB-Keymap und -Status für Tastaturen, übersetzt `KeyboardKeyEvent` und handhabt Tastaturfokus.

**Dateien:**

- `xkb_config.rs`:
    - **Struktur `XkbKeyboardData`:** Enthält `context: xkbcommon::xkb::Context`, `keymap: xkbcommon::xkb::Keymap`, `state: xkbcommon::xkb::State`, `repeat_timer: Option<calloop::TimerHandle>`, `repeat_info`, `focused_surface_on_seat`, `repeat_key_serial`.
        
    - **Funktion `new_xkb_keyboard_data()`:** Erstellt `xkbcommon::xkb::Context`, `xkbcommon::xkb::RuleNames` (aus `XkbConfig`), `xkbcommon::xkb::Keymap` und `xkbcommon::xkb::State`.
        
    - **Funktion `update_xkb_state_from_modifiers()`:** Ruft `xkb_state.update_mask()` auf.
        
- `key_event_translator.rs`:
    - **Funktion `handle_keyboard_key_event()`:** Ruft Keyboard-Handle und `XkbKeyboardData` ab. Aktualisiert `xkb_data.state` mit `update_key()`. Ruft `ModifiersState` von `xkb_data.state` ab und informiert `KeyboardHandle`. Sendet `keyboard_handle.input()` mit Keysym und UTF-8 (für `KeyState::Pressed`). Richtet Tastenwiederholung mittels `calloop::Timer` ein/bricht sie ab, basierend auf `keyboard_handle.repeat_info()`.
        
- `focus_handler_keyboard.rs`:
    - **Funktion `set_keyboard_focus()`:** Ruft Seat und Keyboard-Handle ab. Ermittelt alten Fokus. Sendet `keyboard_handle.leave()` für alten Fokus und `keyboard_handle.enter()` (mit gedrückten Tasten/Modifikatoren) für neuen Fokus. Aktualisiert `xkb_data.focused_surface_on_seat`. Ruft `keyboard_handle.set_focus()` auf.
        

#### 3.4. Submodul: `system::input::pointer`

Verarbeitet Zeigerereignisse, handhabt Zeigerfokus und Cursor-Aktualisierungen.

**Dateien:**

- `pointer_event_translator.rs`:
    - **Funktion `handle_pointer_motion_event()`:** Ruft Pointer-Handle ab. Aktualisiert globale Cursorposition. Bestimmt neuen Zeigerfokus basierend auf globaler Position und sichtbaren Toplevel-Oberflächen/Eingaberegionen (`find_surface_at_global_coords()`). Ruft `update_pointer_focus_and_send_motion()` auf. Aktualisiert Renderer-Cursorposition.
        
    - **Funktion `handle_pointer_motion_absolute_event()`:** Ähnlich wie Motion, aber verwendet absolute Koordinaten (`event.x_transformed()`, `event.y_transformed()`).
        
    - **Funktion `handle_pointer_button_event()`:** Ruft Pointer-Handle ab. Sendet `pointer_handle.button()`. Ändert ggf. Tastaturfokus (Click-to-Focus) und behandelt Fenstermanagement-Interaktionen (z.B. Start von Move/Resize-Grab).
        
    - **Funktion `handle_pointer_axis_event()`:** Ruft Pointer-Handle ab. Bestimmt Achsenquelle. Sendet `pointer_handle.axis()` für vertikales/horizontales Scrollen mit diskreten und kontinuierlichen Werten.
        
- `focus_handler_pointer.rs`:
    - **Funktion `update_pointer_focus_and_send_motion()`:** Ruft aktuellen Fokus vom Pointer-Handle ab. Sendet `pointer_handle.leave()` für alten Fokus und `pointer_handle.enter()` für neuen Fokus. Sendet `pointer_handle.motion()`, wenn neuer Fokus existiert.
        
- `cursor_updater.rs`:
    - **Zweck:** Enthält Logik von `SeatHandler::cursor_image`, ggf. Hilfsfunktionen für Cursor-Themen.
        

#### 3.5. Submodul: `system::input::touch`

Verarbeitet Touch-Ereignisse und handhabt Touch-Fokus. Fokus ist implizit im Oberflächenargument für `down`/`motion`. Zustand, welche Oberfläche von welchem Slot berührt wird, muss in `DesktopState` oder assoziierten Strukturen verwaltet werden.

**Dateien:**

- `touch_event_translator.rs`:
    - **Funktion `handle_touch_down_event()`:** Ruft Touch-Handle ab. Bestimmt fokussierte Oberfläche unter dem Touchpunkt. Sendet `touch_handle.down()`.
        
    - **Funktion `handle_touch_up_event()`:** Ruft Touch-Handle ab. Sendet `touch_handle.up()`.
        
    - **Funktion `handle_touch_motion_event()`:** Ruft Touch-Handle ab. Ruft fokussierte Oberfläche für den Touch-Slot ab. Transformiert Koordinaten. Sendet `touch_handle.motion()`.
        
    - **Funktion `handle_touch_frame_event()`:** Ruft Touch-Handle ab. Sendet `touch_handle.frame()`.
        
    - **Funktion `handle_touch_cancel_event()`:** Ruft Touch-Handle ab. Sendet `touch_handle.cancel()`.
        
- `focus_handler_touch.rs`:
    - **Zweck:** Verwaltet Touch-Fokus, ähnlich wie Zeigerfokus, aber pro Touchpunkt/Slot.
        

### 4. Modul: `system::dbus` (Interaktion mit System-D-Bus-Diensten)

Verantwortlich für die Kommunikation mit Standard-D-Bus-Diensten wie UPower, systemd-logind, NetworkManager, Freedesktop Secret Service und PolicyKit unter Verwendung der `zbus`-Bibliothek.

#### 4.1. Submodul: `system::dbus::error`

Definiert spezifische Fehlertypen für D-Bus-Interaktionen mittels `thiserror`.

**Datei:** `system/dbus/error.rs`

- **Enum `DBusError`:** Varianten wie `ConnectionFailed`, `MethodCallFailed`, `ProxyCreationFailed`, `SignalSubscriptionFailed`, `InvalidResponse`, `DataDeserializationError`, `PropertyAccessFailed`, `NameTaken`, `Timeout`.
    
- **Enum `BusType`:** `Session`, `System`.
    

#### 4.2. Submodul: `system::dbus::connection`

Stellt einen zentralen Manager für D-Bus-Verbindungen bereit.

**Datei:** `system/dbus/connection.rs`

- **Struktur `DBusConnectionManager`:**
    - Felder: `session_bus: tokio::sync::OnceCell<Arc<zbus::Connection>>`, `system_bus: tokio::sync::OnceCell<Arc<zbus::Connection>>` für verzögerte Initialisierung und Wiederverwendung.
        
    - Methoden: `new()`, `get_session_bus()` (verwendet `zbus::Connection::session().await`), `get_system_bus()` (verwendet `zbus::Connection::system().await`).
        

#### 4.3. Submodul: `system::dbus::upower_client` (oder `upower_interface`)

Interagiert mit `org.freedesktop.UPower` für Energieinformationen.

**Dateien:** `system/dbus/upower_client.rs` (oder `upower_interface/client.rs`), `system/dbus/upower_types.rs` (oder `upower_interface/types.rs`)

- **`upower_types.rs`:**
    - Enums: `PowerDeviceType`, `PowerState`, `PowerWarningLevel`, `PowerDeviceTechnology`. `TryFrom<u32>` für Enums implementieren.
        
    - Strukturen: `PowerDeviceDetails` (enthält Felder wie `object_path`, `vendor`, `model`, `device_type`, `state`, `percentage`, `time_to_empty`, `time_to_full`, etc.), `UPowerProperties` (oder `UPowerManagerProperties`) (`on_battery`, `lid_is_closed`, `lid_is_present`, `daemon_version`).
        
    - Internes Enum `UPowerEvent`: `DeviceAdded`, `DeviceRemoved`, `DeviceUpdated`, `ManagerPropertiesChanged`.
        
- **`upower_client.rs`:**
    - **Proxy-Definitionen (`#[zbus::proxy]`)**:
        - `UPowerManagerProxy` für `org.freedesktop.UPower`: Methoden `enumerate_devices`, `get_display_device`, `get_critical_action`; Properties `on_battery`, `lid_is_closed`, `lid_is_present`, `daemon_version`; Signale `device_added`, `device_removed`, `properties_changed`.
            
        - `UPowerDeviceProxy` für `org.freedesktop.UPower.Device`: Properties wie `type_`, `state`, `percentage`, `time_to_empty`, `time_to_full`, `is_present`, `icon_name`, etc.; Signal `properties_changed`.
            
    - **Struktur `UPowerClient`:**
        - Felder: `connection_manager: Arc<DBusConnectionManager>` (oder `connection: zbus::Connection`), `manager_proxy: Arc<UPowerManagerProxy>`, `devices: Arc<Mutex<HashMap<ObjectPath<'static>, PowerDeviceDetails>>>`, `display_device_path: Arc<Mutex<Option<ObjectPath<'static>>>>`, `manager_properties: Arc<Mutex<UPowerManagerProperties>>`, `internal_event_sender: tokio::sync::broadcast::Sender<UPowerEvent>`.
            
        - Methoden: `new()` (oder `connect_and_initialize()`), `get_manager_proxy()`, `get_device_proxy()`, `get_properties()` (für Manager), `enumerate_devices()`, `get_display_device_path()`, `get_device_details()`, `on_battery()`, `subscribe_device_added()`, `subscribe_device_removed()`, `subscribe_upower_properties_changed()` (Manager), `subscribe_device_properties_changed()`.
            
    - **Signalbehandlung:** Asynchrone Tasks (`tokio::spawn`) für Manager-Signale (`DeviceAdded`, `DeviceRemoved`, `PropertiesChanged`) und Geräte-Signale (`PropertiesChanged`). Aktualisiert interne Zustände (`devices`, `manager_properties`) und sendet `UPowerEvent` über den Broadcast-Kanal. PropertiesChanged-Signale sollten detailliert ausgewertet werden, um nur betroffene Felder zu aktualisieren.
        

#### 4.4. Submodul: `system::dbus::logind_client` (oder `logind_interface`)

Interagiert mit `org.freedesktop.login1` für Sitzungsmanagement und Systemereignisse.

**Dateien:** `system/dbus/logind_client.rs` (oder `logind_interface/client.rs`), `system/dbus/logind_types.rs` (oder `logind_interface/types.rs`)

- **`logind_types.rs`:**
    - Strukturen: `SessionInfo` (`id`, `user_id`, `user_name`, `seat_id`, `object_path`, `is_active`, `is_locked_hint`), `UserInfo`.
        
    - Enums: `SessionState`, `LogindEvent` (`PrepareForSleep { starting: bool }`, `ActiveSessionLocked`, `ActiveSessionUnlocked`, `ActiveSessionChanged`, `SessionListChanged`).
        
- **`logind_client.rs`:**
    - **Proxy-Definitionen (`#[zbus::proxy]`)**:
        - `LogindManagerProxy` für `org.freedesktop.login1.Manager`: Methoden `get_session`, `get_session_by_pid`, `get_user`, `list_sessions`, `lock_session`, `unlock_session`, `lock_sessions`, `unlock_sessions`, `inhibit`; Signale `session_new`, `session_removed`, `prepare_for_sleep`.
            
        - `LogindSessionProxy` für `org.freedesktop.login1.Session`: Properties `active`, `locked_hint`, `id`, `user`, `seat`; Signale `Lock`, `Unlock`, `PropertyChanged`.
            
    - **Struktur `LogindClient`:**
        - Felder: `connection: zbus::Connection`, `manager_proxy: Arc<LogindManagerProxy>`, `active_session_id: Arc<Mutex<Option<String>>>`, `active_session_path`, `active_session_proxy`, `sleep_inhibitor_lock: Arc<Mutex<Option<zbus::zvariant::OwnedFd>>>`, `internal_event_sender: tokio::sync::broadcast::Sender<LogindEvent>`.
            
        - Methoden: `new()` (oder `connect_and_initialize()`), `get_manager_proxy()`, `get_session_proxy()`, `list_sessions()` (konvertiert zu `Vec<SessionInfo>`), `get_session_details()`, `lock_session()`, `unlock_session()`, `lock_all_sessions()`, `unlock_all_sessions()`, `subscribe_session_new()`, `subscribe_session_removed()`, `subscribe_prepare_for_sleep()`, `subscribe_session_lock()`, `subscribe_session_unlock()`, `request_lock_active_session()`, `request_unlock_active_session()`, `subscribe_events()`, `release_sleep_inhibitor()`.
            
    - **Initialisierung:** Identifiziert die aktive Sitzung durch `ListSessions` und Prüfung der `Active`-Eigenschaft jeder Session.
        
    - **Signalbehandlung (`PrepareForSleep`):** Bei `start == true`, `inhibit()` aufrufen und FD speichern. `LogindEvent::PrepareForSleep { starting: true }` senden. Bei `start == false`, Inhibit-Lock freigeben (`drop(fd)`) und `LogindEvent::PrepareForSleep { starting: false }` senden. Die korrekte Freigabe des Inhibit-Locks ist kritisch.
        
    - **Signalbehandlung (`SessionNew`/`SessionRemoved`):** Aktualisiert interne Sitzungsliste, prüft auf Änderung der aktiven Sitzung und sendet `LogindEvent`.
        
    - **Signalbehandlung (`Lock`/`Unlock` oder `LockedHint` der aktiven Session):** Sendet `LogindEvent::ActiveSessionLocked/Unlocked`. Die DE ist i.d.R. selbst für den Sperrbildschirm zuständig; dieses Modul kann `LockedHint` überwachen.
        

#### 4.5. Submodul: `system::dbus::networkmanager_client`

Interagiert mit `org.freedesktop.NetworkManager` für Netzwerkinformationen.

**Dateien:** `system/dbus/networkmanager_client.rs`, `system/dbus/networkmanager_types.rs`

- **`networkmanager_types.rs`:**
    - Enums: `NetworkManagerState`, `NetworkDeviceType`, `NetworkConnectivityState`.
        
    - Strukturen: `NetworkDevice`, `ActiveConnection`, `NetworkManagerProperties`.
        
- **`networkmanager_client.rs`:**
    - **Proxy-Definitionen (`#[zbus::proxy]`)**: `NetworkManagerProxy`, `NMDeviceProxy`, `NMActiveConnectionProxy` mit relevanten Methoden, Properties und Signalen (z.B. `GetDevices`, `GetActiveConnections`, `StateChanged`, `DeviceAdded`, `DeviceRemoved`).
        
    - **Struktur `NetworkManagerClient`:** Enthält `connection_manager`, `manager_proxy_path`. Methoden `new()`, `get_manager_proxy()`, `get_device_proxy()`, `get_active_connection_proxy()`, `get_properties()`, `get_devices()` (ruft Details für jeden Pfad ab), `get_active_connections()`, `subscribe_state_changed()`, `subscribe_device_added()` (ruft Details für neuen Pfad ab), `subscribe_device_removed()`.
        
    - Reaktive Aktualisierung bei Signalempfang ist wichtig.
        

#### 4.6. Submodul: `system::dbus::secrets_client`

Interagiert mit `org.freedesktop.secrets` zum Speichern/Abrufen sensibler Daten (z.B. API-Schlüssel).

**Dateien:** `system/dbus/secrets_client.rs`, `system/dbus/secrets_types.rs`

- **`secrets_types.rs`:**
    - Strukturen: `Secret`, `SecretItemInfo`, `SecretCollectionInfo`.
        
    - Enum: `PromptCompletedResult`.
        
- **`secrets_client.rs`:**
    - **Proxy-Definitionen (`#[zbus::proxy]`)**: `SecretServiceProxy`, `SecretCollectionProxy`, `SecretItemProxy`, `SecretPromptProxy` mit relevanten Methoden, Properties und Signalen (z.B. `OpenSession`, `CreateCollection`, `SearchItems`, `Unlock`, `GetSecrets`, `CreateItem`, `GetSecret`, `Prompt`, `Completed`).
        
    - **Struktur `SecretsClient`:** Enthält `connection_manager`, `service_proxy_path`. Methoden `new()`, Proxies abrufen, `open_session()`, `get_default_collection()`, `store_secret()` (behandelt Prompt), `retrieve_secret()` (behandelt Unlock/Prompt), `search_items()`, `handle_prompt_if_needed()` (ruft `PromptProxy::Prompt()` mit `window_id` von UI-Schicht und wartet auf `Completed`-Signal).
        

#### 4.7. Submodul: `system::dbus::policykit_client`

Interagiert mit `org.freedesktop.PolicyKit1.Authority` zur Berechtigungsprüfung.

**Dateien:** `system/dbus/policykit_client.rs`, `system/dbus/policykit_types.rs`

- **`policykit_types.rs`:**
    - Bitflags-Struktur `PolicyKitCheckAuthFlags` (`AllowUserInteraction`, etc.).
        
    - Strukturen: `PolicyKitSubject` (`kind`, `details`), `PolicyKitAuthorizationResult` (`is_authorized`, `is_challenge`, `details`).
        
- **`policykit_client.rs`:**
    - **Proxy-Definition (`#[zbus::proxy]`)**: `PolicyKitAuthorityProxy` für `org.freedesktop.PolicyKit1.Authority`. Methode `CheckAuthorization`.
        
    - **Struktur `PolicyKitClient`:** Enthält `connection_manager`, `authority_proxy_path`. Methoden `new()`, `get_authority_proxy()`, `check_authorization()` (erstellt `PolicyKitSubject` mit PID des aktuellen Prozesses oder übergebenem PID, setzt Flags, ruft Proxy-Methode auf). Die korrekte Definition des `subject` ist sicherheitskritisch.
        

### 5. Modul: `system::outputs` (Verwaltung der Anzeigeausgänge)

Verantwortlich für Erkennung, Konfiguration und Verwaltung von Anzeigeausgängen (Monitoren). Implementiert serverseitige Logik für Wayland-Protokolle (`wl_output`, `xdg-output-unstable-v1`, `wlr-output-management-unstable-v1`, `wlr-output-power-management-unstable-v1`) unter Verwendung von Smithay-Abstraktionen.

#### 5.1. Submodul: `system::outputs::error`

Definiert spezifische Fehlertypen für Output-Operationen.

**Datei:** `system/outputs/error.rs`

- **Enum `OutputError`:** Varianten `DeviceAccessFailed`, `ProtocolError`, `ConfigurationConflict`, `ResourceCreationFailed`, `SmithayOutputError`, `OutputNotFound`, `ModeNotSupported`.
    

#### 5.2. Submodul: `system::outputs::output_device`

Kapselt Zustand und Logik eines einzelnen physischen Anzeigeausgangs.

**Datei:** `system/outputs/output_device.rs`

- **Struktur `OutputDevice`:**
    - Felder: `name: String`, `smithay_output: smithay::output::Output`, `wl_output_global: Option<GlobalId>`, `xdg_output_global: Option<GlobalId>`, `wlr_head_global: Option<GlobalId>`, `wlr_power_global: Option<GlobalId>`, `enabled: bool`, `current_dpms_state: DpmsState`, `pending_config_serial: Option<u32>` (für wlr-output-management).
        
    - Methoden: `new()` (initialisiert `smithay::output::Output`, fügt Modi hinzu, setzt initialen Zustand), `name()`, `smithay_output()`, `current_mode()`, `current_transform()`, `current_scale()`, `current_position()`, `is_enabled()`, `apply_state()` (ruft `smithay_output.change_current_state()`), `set_dpms_state()` (interagiert mit DRM, aktualisiert `current_dpms_state`), `supported_modes()`, `physical_properties()`, `add_mode()`, `set_preferred_mode()`, Methoden zum Setzen/Abrufen von Global-IDs, `destroy_globals()`.
        
- **Struktur `OutputDevicePendingState` (für wlr-output-management):** Felder `mode`, `position`, `transform`, `scale`, `enabled`, `adaptive_sync_enabled`.
    
- **Enum `DpmsState`:** `On`, `Standby`, `Suspend`, `Off`.
    

#### 5.3. Submodul: `system::outputs::manager` (oder `output_manager` für wlr-output-management)

Verwaltet eine Liste aller `OutputDevice`-Instanzen und behandelt Hotplug-Events.

**Datei:** `system/outputs/manager.rs` (oder `output_manager/manager_global.rs` und andere für wlr-output-management)

- **Struktur `OutputManager` (oder `OutputManagerModuleState` / `WlrOutputManagementState`):**
    - Felder: `outputs: HashMap<String, Arc<Mutex<OutputDevice>>>`, `udev_event_source_token: Option<RegistrationToken>`, `output_manager_global` (für wlr), `active_configurations` (für wlr), `compositor_output_serial` (für wlr) / `global_serial`.
        
    - Methoden: `new()`, `add_output()`, `remove_output()` (zerstört Globals), `find_output_by_name()`, `all_outputs()`, `handle_hotplug_event()` (erstellt/entfernt `OutputDevice`, ruft `output_device_created/removed_notifications` auf).
        
    - Hilfsmethoden `output_device_created_notifications()` und `output_device_removed_notifications()`: Erstellen/Zerstören Globals (`wl_output`, `zxdg_output_v1`, `zwlr_output_head_v1`) und benachrichtigen relevante Handler (WlrOutputManagementState, WlrOutputPowerManagementState).
        
- **Enum `HotplugEvent`:** `DeviceAdded` (mit Name, Pfad, Eigenschaften, Modi, etc.), `DeviceRemoved`.
    
- **Struktur `OutputConfigurationRequest` (für wlr-output-management):** `serial`, `client`, `pending_changes: HashMap<String, HeadChangeRequest>`, `config_resource`.
    
- **Struktur `HeadChangeRequest` (für wlr-output-management):** `mode`, `position`, `transform`, `scale`, `enabled`, `adaptive_sync_enabled`.
    
- **`wlr-output-management` spezifische UserData-Strukturen:** `WlrOutputManagerGlobalData`, `WlrOutputHeadGlobalData`, `WlrOutputModeGlobalData`, `WlrOutputConfigurationUserData`, `WlrOutputConfigurationHeadUserData`.
    

#### 5.4. Submodul: `system::outputs::wl_output_handler`

Handhabung des `wl_output`-Protokolls, meist durch Smithay's `Output`-Typ und `OutputHandler`-Trait.

**Datei:** Integration in globalen Compositor-Zustand und `system::outputs::manager.rs`.

- **Smithay Integration:** Globaler Compositor-Zustand implementiert `smithay::wayland::output::OutputHandler`. `smithay::delegate_output!` wird deklariert. Beim Hinzufügen eines Outputs wird `output_dev.smithay_output().create_global()` aufgerufen; `GlobalId` wird in `OutputDevice::wl_output_global` gespeichert.
    
- **Implementierung `OutputHandler`:**
    - `output_state()`: Gibt Referenz zum `OutputManagerState` des Compositors zurück.
        
    - `new_output()`: Kann Client-spezifischen Zustand initialisieren.
        
    - `output_destroyed()`: Wird bei Zerstörung eines `wl_output`-Globals aufgerufen.
        
    - Smithay sendet `geometry`, `mode`, `scale`, `done` Events automatisch bei `Output::change_current_state()`.
        

#### 5.5. Submodul: `system::outputs::wlr_output_management_handler` (oder in `system::outputs::output_manager`)

Implementiert `wlr-output-management-unstable-v1`.

**Dateien:** `system/outputs/wlr_output_management/*` oder integriert.

- **Zustandsstrukturen:** `WlrOutputManagementState` (enthält `OutputManager`-Referenz, `configurations`, `global_serial`). `OutputConfigurationRequest` (enthält `serial`, `client`, `pending_changes`, `config_resource`). `HeadChangeRequest` (enthält `mode`, `position`, etc.).
    
- **Smithay Integration:** Globaler Compositor-Zustand implementiert `GlobalDispatch` und `Dispatch` für `ZwlrOutputManagerV1`, `ZwlrOutputHeadV1`, `ZwlrOutputModeV1`, `ZwlrOutputConfigurationV1`, `ZwlrOutputConfigurationHeadV1`.
    
- **Initialisierung:** `WlrOutputManagementState` erstellen, `zwlr_output_manager_v1`-Global registrieren.
    
- **Anfragebehandlung `zwlr_output_manager_v1`:**
    - `bind`: Sendet aktuellen Zustand aller Outputs (Heads, Modi) und `done(serial)`.
        
    - `create_configuration()`: Erstellt `OutputConfigurationRequest`, speichert es. Sendet aktuellen Output-Zustand an das neue `config_resource`.
        
    - `stop()`: Zerstört das Manager-Global, sendet `finished`.
        
- **Anfragebehandlung `zwlr_output_configuration_head_v1`:** `enable()`, `disable()`, `set_mode()`, `set_custom_mode()`, `set_position()`, `set_transform()`, `set_scale()`, `set_adaptive_sync()` aktualisieren `HeadChangeRequest` im `OutputConfigurationRequest`. Prüfen auf `is_applied_or_tested`.
    
- **Anfragebehandlung `zwlr_output_configuration_v1`:**
    - `destroy()`: Verwirft Anfrage.
        
    - `apply()`: Prüft `serial` gegen `compositor_output_serial` (bei Mismatch -> `cancelled`). Validiert Änderungen. Versucht, Konfiguration auf `OutputDevice` anzuwenden (via `OutputManager` und `output.change_current_state()`). Bei Erfolg: `succeeded`, `compositor_output_serial` inkrementieren, alle Manager-Clients benachrichtigen. Bei Fehler: `failed`, ggf. Rollback.
        
    - `test()`: Validiert Konfiguration. Sendet `succeeded` oder `failed`.
        
- **Event-Generierung:** Bei Änderungen des Output-Zustands (Hotplug, erfolgreiches `apply`) müssen `head`, `mode`, `done(new_serial)` an alle Manager gesendet werden.
    
- **Fehlerbehandlung (`OutputManagerError`):** Varianten wie `InvalidWlOutput`, `AlreadyProcessed`, `SerialMismatch`, `UnknownOutput`, `TestFailed`, `ApplyFailed`, `Cancelled`, `ProtocolError`.
    

#### 5.6. Submodul: `system::outputs::wlr_output_power_management_handler` (oder `system::outputs::power_manager`)

Implementiert `wlr-output-power-management-unstable-v1` für Energiezustand von Monitoren.

**Dateien:** `system/outputs/wlr_output_power_management/*` oder integriert.

- **Zustandsstrukturen:** `WlrOutputPowerManagementState` (enthält `OutputManager`-Referenz, `active_controllers: HashMap<String, Resource<ZwlrOutputPowerV1>>`). `OutputPowerControlState` (enthält `wl_output_resource`, `compositor_output_name`, `current_mode: InternalPowerMode`).
    
- **Enum `InternalPowerMode`**: `On`, `Off`.
    
- **UserData-Strukturen:** `WlrOutputPowerManagerGlobalData`, `WlrOutputPowerControlUserData`.
    
- **Smithay Integration:** Globaler Compositor-Zustand implementiert `GlobalDispatch` und `Dispatch` für `ZwlrOutputPowerManagerV1`, `ZwlrOutputPowerV1`.
    
- **Initialisierung:** `WlrOutputPowerManagementState` erstellen, `zwlr_output_power_manager_v1`-Global registrieren.
    
- **Anfragebehandlung `zwlr_output_power_manager_v1`:**
    - `get_output_power()`: Ermittelt `OutputDevice`. Prüft auf exklusive Kontrolle (nur ein Controller pro Output). Speichert `ZwlrOutputPowerV1`-Ressource in `active_controllers`. Sendet initiales `mode`-Event an Ressource.
        
    - `destroy()`: Zerstört Manager-Global.
        
- **Anfragebehandlung `zwlr_output_power_v1`:**
    - `destroy()`: Entfernt Controller aus `active_controllers`.
        
    - `set_mode()`: Ermittelt `OutputDevice`. Konvertiert `mode` in `DpmsState`. Ruft `output_device.set_dpms_state()`. Sendet `mode(mode)` oder `failed`.
        
- **Event-Generierung:** Bei externer Änderung des DPMS-Zustands oder Entfernung eines Outputs, `mode` oder `failed` an aktive Controller senden.
    
- **Fehlerbehandlung (`OutputPowerError`):** Varianten `OutputDoesNotSupportPowerManagement`, `BackendSetModeFailed`, `OutputVanished`, `ExclusiveControlConflict`, `InvalidWlOutput`, `ProtocolError`.
    

#### 5.7. Submodul: `system::outputs::xdg_output_handler`

Implementiert `xdg-output-unstable-v1` für detaillierte logische Geometrieinformationen.

**Datei:** `system/outputs/xdg_output_handler.rs` oder integriert.

- **Smithay Integration:** Globaler Compositor-Zustand implementiert `GlobalDispatch` und `Dispatch` für `ZxdgOutputManagerV1`, `ZxdgOutputV1`. `XdgOutputManagerGlobalData`, `XdgOutputGlobalData` als UserData. Erstellung von Globals kann über `OutputManagerState::new_with_xdg_output()` oder manuell erfolgen.
    
- **Anfragebehandlung `zxdg_output_manager_v1`:**
    - `get_xdg_output()`: Ermittelt `OutputDevice`. Initialisiert `ZxdgOutputV1`-Ressource mit logischen Daten (`logical_position`, `logical_size`, `name`, `description`), sendet diese und `done`.
        
- **Event-Generierung:** Bei Änderungen an logischer Position, Größe, Name, Beschreibung eines `OutputDevice` müssen entsprechende Events an gebundene `zxdg_output_v1`-Instanzen gesendet werden, gefolgt von `done`. Dies wird i.d.R. von Smithay bei `Output::change_current_state()` gehandhabt.
    

### 6. Modul: `system::audio` (PipeWire Client-Integration)

Verantwortlich für alle audiobezogenen Operationen mittels PipeWire und `pipewire-rs`. Zentralisiert PipeWire-Interaktionslogik, ereignisgesteuerte Architektur. Eigene PipeWire MainLoop in dediziertem Thread, Kommunikation über asynchrone Kanäle (`tokio::sync::mpsc`, `tokio::sync::broadcast`). Unterscheidet Master-Lautstärke (Device-Routen) und Anwendungs-Stream-Lautstärke (Node-Props).

#### 6.1. Submodul: `system::audio::client`

Verwaltet Low-Level-Verbindung zu PipeWire, startet und unterhält PipeWire-MainLoop-Thread, leitet Befehle weiter und verteilt Ereignisse.

**Datei:** `system/audio/client.rs`

- **Struktur `PipeWireClient`:**
    - Felder: `core: Arc<pipewire::Core>`, `mainloop_thread_handle: Option<std::thread::JoinHandle<()>>`, `command_sender: tokio::sync::mpsc::Sender<AudioCommand>`, `internal_event_sender: tokio::sync::mpsc::Sender<InternalAudioEvent>`.
        
    - Methode `new()`: Initialisiert PipeWire (`pipewire::init()`), erstellt MPSC-Kanäle, startet `run_pipewire_loop` in neuem OS-Thread, wartet auf Initialisierungssignal vom Thread, speichert Handles und Sender.
        
    - Methode `get_command_sender()`: Gibt Klon des `command_sender` zurück.
        
- **Struktur `PipeWireLoopData` (für internen Thread-Zustand):** `core`, `registry: Arc<pipewire::Registry>`, `audio_event_broadcaster: tokio::sync::broadcast::Sender<AudioEvent>`, `command_receiver`, `internal_event_receiver`, `active_devices: HashMap<u32, MonitoredDevice>`, `active_streams: HashMap<u32, MonitoredStream>`, `default_sink_id`, `default_source_id`, `pipewire_mainloop`, `pipewire_context`, `metadata_proxy`, `metadata_listener_hook`.
    
- **Struktur `MonitoredDevice`:** `proxy: Arc<dyn ProxyT>`, `proxy_id`, `global_id`, `properties`, `param_listener_hook`, `info: AudioDevice`.
    
- **Struktur `MonitoredStream`:** `proxy: Arc<pipewire::node::Node>`, `proxy_id`, `global_id`, `properties`, `param_listener_hook`, `info: StreamInfo`.
    
- **Enum `InternalAudioEvent`:** `PwGlobalAdded`, `PwGlobalRemoved`, `PwNodeParamChanged`, `PwDeviceParamChanged`, `PwMetadataPropsChanged`.
    
- **Private Funktion `run_pipewire_loop()`:** Initialisiert `MainLoop`, `Context`, `Core`, `Registry`. Registriert Listener auf Registry (`global`, `global_remove` Callbacks senden `InternalAudioEvent`). Startet Timer, der `process_external_messages` aufruft. Ruft `mainloop.run()`.
    
    - `process_external_messages()`: Verarbeitet `AudioCommand` (ruft Control-Funktionen) und `InternalAudioEvent` (ruft Manager-Funktionen).
        

#### 6.2. Submodul: `system::audio::manager`

Verarbeitet PipeWire-Registry-Ereignisse, verwaltet `AudioDevice`/`StreamInfo`, behandelt Eigenschaftsänderungen.

**Datei:** `system/audio/manager.rs`

- **Funktion `handle_pipewire_global_added()`:** Loggt. Abhängig von `global.type_`:
    - `ObjectType::Node`: Extrahiert Properties. Unterscheidet Gerät (Sink/Source) von Anwendungsstream. Bindet `pipewire::node::Node`-Proxy. Ruft initiale Parameter ab (Lautstärke/Mute aus `SPA_PARAM_Props`). Erstellt `AudioDevice` oder `StreamInfo`. Registriert `param_changed`-Listener (sendet `InternalAudioEvent::PwNodeParamChanged`). Speichert in `active_devices` oder `active_streams`. Sendet `AudioEvent::DeviceAdded` oder `StreamAdded`.
        
    - `ObjectType::Device`: Extrahiert Properties. Bindet `pipewire::device::Device`-Proxy. Ruft initiale `SPA_PARAM_Route`-Parameter ab. Erstellt `AudioDevice`. Registriert `param_changed`-Listener (sendet `InternalAudioEvent::PwDeviceParamChanged`). Speichert in `active_devices`. Sendet `AudioEvent::DeviceAdded`.
        
    - `ObjectType::Metadata`: Wenn `metadata.name == "default"`. Bindet `pipewire::metadata::Metadata`-Proxy. Speichert Proxy. Parst Standardgeräte-IDs aus Properties. Registriert `props`-Listener (sendet `InternalAudioEvent::PwMetadataPropsChanged`). Sendet `AudioEvent::DefaultSink/SourceChanged`.
        
- **Funktion `handle_pipewire_global_removed()`:** Loggt. Entfernt `MonitoredDevice` oder `MonitoredStream` aus `active_devices`/`active_streams`. Listener werden automatisch entfernt. Sendet `AudioEvent::DeviceRemoved` oder `StreamRemoved`. Behandelt Entfernung des Metadata-Proxy.
    
- **Funktion `handle_node_param_changed()`:** Loggt. Sucht `MonitoredDevice`/`Stream`. Wenn `SPA_PARAM_Props` geändert: Parst Lautstärke/Mute aus Pod. Aktualisiert `AudioDevice`/`StreamInfo`. Sendet `AudioEvent::Device/StreamVolumeChanged/MuteChanged`.
    
- **Funktion `handle_device_param_changed()`:** Loggt. Sucht `MonitoredDevice`. Wenn `SPA_PARAM_Route` geändert: Parst Lautstärke/Mute der aktiven Route. Aktualisiert `AudioDevice`. Sendet `AudioEvent::DeviceVolumeChanged/MuteChanged`.
    
- **Funktion `handle_metadata_props_changed()`:** Loggt. Extrahiert neue Standard-Sink/Source-IDs aus Properties. Aktualisiert `is_default`-Flags der betroffenen `AudioDevice`-Instanzen und sendet `AudioEvent::DeviceUpdated`. Aktualisiert `default_sink_id`/`default_source_id`. Sendet `AudioEvent::DefaultSink/SourceChanged`.
    

#### 6.3. Submodul: `system::audio::control`

Implementiert Logik zum Senden von Steuerbefehlen an PipeWire.

**Datei:** `system/audio/control.rs`

- **Funktion `set_node_volume()`:** Sucht `MonitoredDevice`/`Stream`. Passt `volume.channel_volumes` gemäß `VolumeCurve` an. Erstellt `SPA_PARAM_Props`-Pod mit `channelVolumes` (via `spa_pod_utils`). Ruft `node_proxy.set_param()`.
    
- **Funktion `set_node_mute()`:** Sucht `MonitoredDevice`/`Stream`. Erstellt `SPA_PARAM_Props`-Pod mit `mute`. Ruft `node_proxy.set_param()`.
    
- **Funktion `set_device_volume()`:** Sucht `MonitoredDevice` (Device-Proxy). Passt `volume.channel_volumes` an. Ermittelt aktive Route. Erstellt `SPA_PARAM_Route`-Pod mit `channelVolumes` für die Route. Ruft `device_proxy.set_param()`.
    
- **Funktion `set_device_mute()`:** Sucht `MonitoredDevice`. Ermittelt aktive Route. Erstellt `SPA_PARAM_Route`-Pod mit `mute` für die Route. Ruft `device_proxy.set_param()`.
    
- **Funktion `set_default_device()`:** Prüft `metadata_proxy`. Bestimmt Property-Namen (`default.audio.sink/source`). Ruft `metadata_proxy.set_property()` mit globaler ID als String.
    

#### 6.4. Submodul: `system::audio::types`

Definiert primäre Datenstrukturen für das Audio-Modul.

**Datei:** `system/audio/types.rs`

- **Enums:** `AudioDeviceType` (`Sink`, `Source`, `Unknown`), `VolumeCurve` (`Linear`, `Cubic`), `AudioCommand` (siehe Tabelle), `AudioEvent` (siehe Tabelle).
    
- **Strukturen:**
    - `Volume`: Enthält `channel_volumes: Vec<f32>` (0.0-1.0).
        
    - `AudioDevice`: Enthält `id` (globale PW ID), `proxy_id`, `name`, `description`, `device_type`, `volume`, `is_muted`, `is_default`, `ports` (optional), `properties_spa` (optional), `is_hardware_device`, `api_name`.
        
    - `StreamInfo`: Enthält `id` (globale PW ID), `name`, `application_name`, `process_id`, `volume`, `is_muted`, `media_class`, `node_id_pw` (interne PW Node ID).
        

#### 6.5. Submodul: `system::audio::spa_pod_utils`

Hilfsfunktionen zur Erstellung von `pipewire::spa::Pod`-Objekten.

**Datei:** `system/audio/spa_pod_utils.rs`

- `build_volume_props_pod()`: Erstellt Pod für `SPA_PARAM_Props` mit `SPA_PROP_channelVolumes`.
    
- `build_mute_props_pod()`: Erstellt Pod für `SPA_PARAM_Props` mit `SPA_PROP_mute`.
    
- `build_route_volume_pod()`: Erstellt Pod für `SPA_PARAM_Route` mit `SPA_PARAM_ROUTE_index`, `SPA_PARAM_ROUTE_device` und verschachtelten `SPA_PARAM_ROUTE_props` (mit `SPA_PROP_channelVolumes`).
    
- `build_route_mute_pod()`: Analog für `SPA_PROP_mute` in Route-Props.
    
- `parse_props_volume_mute()`: Extrahiert `Volume` und `mute` aus `SPA_PARAM_Props`-Pod.
    
- `parse_route_props_volume_mute()`: Extrahiert `Volume` und `mute` aus `SPA_PARAM_ROUTE`-Pod (via dessen `SPA_PARAM_ROUTE_props`).
    

#### 6.6. Submodul: `system::audio::error`

Definiert `AudioError` mittels `thiserror`.

**Datei:** `system/audio/error.rs`

- **Enum `AudioError`:** Varianten wie `PipeWireInitFailed`, `MainLoopCreationFailed`, `ContextCreationFailed`, `CoreConnectionFailed`, `RegistryCreationFailed`, `PipeWireThreadPanicked`, `ProxyBindFailed`, `ParameterEnumerationFailed`, `SpaPodParseFailed`, `SpaPodBuildFailed`, `PipeWireCommandFailed`, `DeviceOrStreamNotFound`, `NoActiveRouteFound`, `MetadataProxyNotAvailable`, `InternalChannelSendError`, `InternalBroadcastSendError`.
    

### 7. Modul: `system::mcp` (Model Context Protocol Client)

Implementiert einen Client für das Model Context Protocol (MCP) zur Kommunikation mit lokalen oder Cloud-basierten MCP-Servern für KI-gestützte Funktionen. Kommunikation typischerweise über Stdio mit JSON-RPC. Verwendet `mcp_client_rs` Crate.

#### 7.1. Submodul: `system::mcp::client`

Kernlogik für Interaktion mit MCP-Server: Starten des Serverprozesses, Senden von Anfragen, Verarbeiten von Antworten/Benachrichtigungen.

**Datei:** `system/mcp/client.rs`

- **Struktur `McpClient`:**
    - Felder: `client_handle: Option<mcp_client_rs::client::Client>`, `server_process: Option<tokio::process::Child>`, `command_sender: tokio::sync::mpsc::Sender<McpCommand>`, `notification_broadcaster: tokio::sync::broadcast::Sender<McpNotification>`, `status_broadcaster: tokio::sync::broadcast::Sender<McpClientStatus>`, `request_id_counter: Arc<AtomicU64>`, `pending_requests: Arc<Mutex<HashMap<String, tokio::sync::oneshot::Sender<Result<serde_json::Value, McpError>>>>>`, `listen_task_handle: Option<tokio::task::JoinHandle<()>>`.
        
    - Methode `new()`: Erstellt MPSC-Kanal für `McpCommand`. Startet MCP-Serverprozess (`tokio::process::Command`) mit Pipes für Stdin/Stdout/Stderr. Erstellt `mcp_client_rs::transport::stdio::StdioTransport` und `mcp_client_rs::client::Client`. Startet `listen_task`. Sendet `Initialize`-Befehl und wartet auf Antwort. Sendet `McpClientStatus`-Updates.
        
    - Private Methode `listen_task()`: Lauscht auf `StdioTransportReceiver`. Deserialisiert Nachrichten. Bei Antwort: Sendet an passenden `oneshot::Sender` aus `pending_requests`. Bei Benachrichtigung: Sendet an `notification_broadcaster`. Behandelt Fehler und Verbindungsabbruch, sendet `McpClientStatus`.
        
    - Private Methode `send_request_generic()`: Generiert `request_id`. Speichert `oneshot::Sender` in `pending_requests`. Sendet JSON-RPC-Anfrage über `client_handle` (intern via `mcp_client_rs`). Wartet auf Antwort.
        
    - Öffentliche Methoden für MCP-Requests (`list_resources`, `read_resource`, `call_tool`): Rufen `send_request_generic` auf.
        
    - Methode `shutdown()`: Sendet Shutdown-Anfrage (falls unterstützt). Bricht `listen_task` ab. Beendet Serverprozess (`child.kill()`). Sendet `McpClientStatus::Disconnected`.
        
    - Methode `get_command_sender()`: Gibt Klon des `command_sender` zurück.
        
- **Struktur `McpServerConfig`:** `command`, `args`, `working_directory`.
    
- **Enums:** `McpClientStatus` (`Disconnected`, `Connecting`, `Connected`, `Error`), `McpCommand` (z.B. `Initialize`, `ListResources`, `ReadResource`, `CallTool`, `Shutdown`).
    

#### 7.2. Submodul: `system::mcp::transport`

Abstraktionsebene für Kommunikationstransport. Meist durch `mcp_client_rs::transport::stdio::StdioTransport` abgedeckt.

#### 7.3. Submodul: `system::mcp::types`

Definitionen für MCP-Anfragen, -Antworten, -Benachrichtigungen. Meist Re-Exporte oder dünne Wrapper um `mcp_client_rs::protocol` und `mcp_client_rs::types`.

**Datei:** `system/mcp/types.rs`

- **Struktur `McpNotification`:** `method: String`, `params: Option<serde_json::Value>`.
    

#### 7.4. Submodul: `system::mcp::error`

Definiert `McpError` mittels `thiserror`.

**Datei:** `system/mcp/error.rs`

- **Enum `McpError`:** Varianten `ServerSpawnFailed`, `TransportError` (aus `mcp_client_rs::Error`), `NotConnected`, `InitializationFailed`, `SerializationFailed` (aus `serde_json::Error`), `RequestTimeout`, `ServerReturnedError` (mit `code`, `message`, `data`), `UnexpectedResponse`, `ResponseChannelDropped`, `CommandSendError`.
    

### 8. Modul: `system::portals` (XDG Desktop Portals Backend)

Implementiert Backend-Logik für XDG Desktop Portals (`org.freedesktop.portal.FileChooser`, `org.freedesktop.portal.Screenshot`). Agiert als D-Bus-Dienst, der Anfragen von Client-Anwendungen bearbeitet. Nutzt `zbus` für D-Bus-Implementierung.

#### 8.1. Submodul: `system::portals::file_chooser`

Implementiert `org.freedesktop.portal.FileChooser` D-Bus-Interface.

**Datei:** `system/portals/file_chooser.rs`

- **Struktur `FileChooserPortal`:** Enthält `connection: Arc<zbus::Connection>`, `ui_event_sender: tokio::sync::mpsc::Sender<UiPortalCommand>` (zur Kommunikation mit UI-Schicht für Dialoganzeige).
    
- **D-Bus Interface Implementierung (`#[zbus::interface(name = "org.freedesktop.portal.FileChooser")]`)**:
    - `OpenFile()`: Extrahiert Optionen. Sendet Befehl an UI-Schicht, um Dateiauswahldialog anzuzeigen. Wartet auf Antwort (ausgewählte URIs). Gibt `Ok((0, {"uris": Value::from(vec!["file:///..."])})` oder Fehlercode/D-Bus-Fehler zurück.
        
    - `SaveFile()`: Ähnlich `OpenFile`, UI zeigt "Speichern"-Dialog. Gibt einzelnen URI zurück.
        
    - `SaveFiles()`: UI zeigt Ordnerauswahldialog. Backend konstruiert vollständige URIs aus ausgewähltem Ordner und übergebenen Dateinamen (`options["files"]`).
        
    - Antworten erfolgen direkt, nicht über separates Request-Objekt für einfache Fälle.
        

#### 8.2. Submodul: `system::portals::screenshot`

Implementiert `org.freedesktop.portal.Screenshot` D-Bus-Interface.

**Datei:** `system/portals/screenshot.rs`

- **Struktur `ScreenshotPortal`:** Enthält `connection: Arc<zbus::Connection>`, `compositor_command_sender: tokio::sync::mpsc::Sender<CompositorScreenshotCommand>` (zur Kommunikation mit Compositor).
    
- **D-Bus Interface Implementierung (`#[zbus::interface(name = "org.freedesktop.portal.Screenshot")]`)**:
    - `Screenshot()`: Extrahiert `interactive`. Sendet Befehl an Compositor, Screenshot zu erstellen (interaktiv oder gesamter Bildschirm). Compositor speichert temporär, gibt Pfad zurück. Konvertiert Pfad zu URI. Gibt `Ok((0, {"uri": Value::from(screenshot_uri)}))` zurück.
        
    - `PickColor()`: Sendet Befehl an Compositor, Farbauswahlmodus zu starten. Compositor meldet RGB-Werte. Gibt `Ok((0, {"color": Value::from((r,g,b))}))` zurück.
        
    - Property `version()`: Gibt implementierte Portal-Version zurück (z.B. 2).
        

#### 8.3. Submodul: `system::portals::common`

Gemeinsame Hilfsmittel und D-Bus-Handhabung.

**Datei:** `system/portals/common.rs`

- **Funktion `run_portal_service()`:**
    - Erstellt D-Bus-Verbindung zum Session-Bus. Registriert Dienstnamen `org.freedesktop.portal.Desktop`.
        
    - Erstellt Instanzen der Portal-Implementierungen (z.B. `FileChooserPortal`, `ScreenshotPortal`).
        
    - Registriert eine einzelne `DesktopPortal`-Struktur (die alle Portal-Interfaces implementiert oder delegiert) unter Pfad `/org/freedesktop/portal/desktop` beim `ObjectServer`.
        
    - Hält Dienst am Laufen.
        
- **Funktion `generate_request_handle()`:** Erzeugt eindeutigen Handle-String für Portal-Anfragen.
    
- **Hilfsstrukturen/Enums für UI/Compositor-Kommunikation:** `UiPortalCommand` (mit `OpenFileOptions`, `SaveFileOptions`), `PortalUiError`, `CompositorScreenshotCommand`.
    

#### 8.4. Submodul: `system::portals::error`

Definiert `PortalsError` mittels `thiserror`.

**Datei:** `system/portals/error.rs`

- **Enum `PortalsError`:** Varianten `DBusConnectionFailed` (aus `zbus::Error`), `DBusNameAcquisitionFailed`, `DBusInterfaceRegistrationFailed`, `UiCommandSendError`, `CompositorCommandSendError`, `UiInteractionFailed`, `CompositorInteractionFailed`, `InvalidOptions`.
    

### Schlussfolgerung

Diese detaillierte technische Spezifikation für die Systemschicht, basierend auf den bereitgestellten Dokumenten, deckt die Kernmodule Compositor, Input, D-Bus-Interaktion, Output-Management, Audio-Integration, MCP-Client und XDG-Desktop-Portal-Backends ab. Die konsequente Anwendung der Entwicklungsrichtlinien und die Nutzung moderner Technologien wie Rust, Smithay, PipeWire und D-Bus sollen eine robuste, performante und wartbare Systemschicht gewährleisten, die als solide Grundlage für die gesamte Desktop-Umgebung dient.

## Technische Spezifikation und Entwicklungsrichtlinien: Kernschicht

Diese Spezifikation beschreibt die fundamentalen Komponenten und Richtlinien für die Entwicklung der Kernschicht der Desktop-Umgebung. Die Kernschicht bildet das Fundament für alle darüberliegenden Schichten und umfasst Module für grundlegende Datentypen (`core::types`), Fehlerbehandlung (`core::errors`), Logging (`core::logging`), Konfigurationsmanagement (`core::config`) und allgemeine Hilfsfunktionen (`core::utils`).

### 1. Modul: `core::types` (Fundamentale Datentypen)

**1.1. Zweck und Verantwortlichkeit** Das Modul `core::types` definiert grundlegende, universell einsetzbare Datentypen, die von allen anderen Schichten und Modulen benötigt werden. Dazu gehören geometrische Primitive, Farbdarstellungen und allgemeine Enumerationen. Diese Typen sind reine Datenstrukturen ohne komplexe Geschäftslogik oder Abhängigkeiten zu höheren Schichten.

**1.2. Designphilosophie** Das Design folgt den Prinzipien der Modularität, Wiederverwendbarkeit und minimalen Kopplung. Typen sind generisch gehalten, wo sinnvoll (z.B. `Point<T>`, `Size<T>`, `Rect<T>`), um Flexibilität für verschiedene numerische Darstellungen zu ermöglichen (z.B. `i32` für Koordinaten, `f32` für Skalierungsfaktoren). Es besteht eine klare Trennung von Datenrepräsentation und Fehlerbehandlung.

**1.3. Ziel-Dateistruktur**

```
core/
└── src/
    ├── lib.rs         # Deklariert Kernmodule: pub mod types; pub mod errors; ...
    └── types/
        ├── mod.rs     # Deklariert und re-exportiert Typen aus geometry.rs, color.rs, etc.
        ├── geometry.rs # Enthält Point<T>, Size<T>, Rect<T>
        ├── color.rs    # Enthält Color
        └── enums.rs    # Enthält Orientation, etc.
```

**1.4. Spezifikation: Geometrische Primitive (`geometry.rs`)**

- **`Point<T>`**: Repräsentiert einen Punkt im 2D-Raum mit `x: T` und `y: T`.
    
    - Konstanten wie `ZERO_I32`, `ZERO_F32` etc..
        
    - Methoden: `new(x: T, y: T)`, `distance_squared(...)`, `distance(...)` (für Float-Typen), `manhattan_distance(...)`.
        
    - Basis-Constraints für `T`: `Copy + Debug + PartialEq + Default + Send + Sync + 'static`.
        
- **`Size<T>`**: Repräsentiert eine 2D-Dimension mit `width: T` und `height: T`.
    
    - Konstanten wie `ZERO_I32`, `ZERO_F32` etc..
        
    - Methoden: `new(width: T, height: T)`, `area()`, `is_empty()`, `is_valid()` (für nicht-negative Dimensionen).
        
    - Basis-Constraints für `T`: `Copy + Debug + PartialEq + Default + Send + Sync + 'static`. Die Invariante nicht-negativer Dimensionen wird durch `is_valid()` prüfbar gemacht, aber nicht durch den Typ erzwungen.
        
- **`Rect<T>`**: Repräsentiert ein 2D-Rechteck, definiert durch `origin: Point<T>` und `size: Size<T>`.
    
    - Konstanten wie `ZERO_I32`, `ZERO_F32` etc..
        
    - Methoden: `new(origin, size)`, `from_coords(x,y,width,height)`, Zugriffsmethoden (`x()`, `y()`, `width()`, `height()`, `top()`, `left()`, `bottom()`, `right()`), `center()`, `contains_point(...)`, `intersects(...)`, `intersection(...)`, `union(...)`, `translated(...)`, `scaled(...)`, `is_valid()`.
        
    - Basis-Constraints für `T`: `Copy + Debug + PartialEq + Default + Send + Sync + 'static`.
        
    - **Invariante**: Logisch sollten `width` und `height` nicht-negativ sein. Die Methode `is_valid()` wird bereitgestellt; Nutzer (besonders mit `T=i32`) sollten diese aufrufen. Die Verantwortung für das Melden eines Fehlers bei Verwendung eines ungültigen `Rect` liegt beim Aufrufer.
        
- **`RectInt`**: (aus einer anderen Quelldatei, aber thematisch passend) Repräsentiert ein achsenparalleles Rechteck mit ganzzahligen Koordinaten (`x: i32`, `y: i32`) und Dimensionen (`width: u32`, `height: u32`).
    
    - Methoden u.a. `new(...)`, `from_points(...)`, `top_left()`, `size()`, `right()`, `bottom()`, `contains_point(...)`, `intersects(...)`, `intersection(...)`, `union(...)`, `translate(...)`, `inflate(...)`, `is_empty()`.
        
    - Verwendet `saturating_add` / `saturating_sub` um Überläufe zu vermeiden.
        
    - Traits: `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Default`.
        

**1.5. Spezifikation: Farbdarstellung (`color.rs`)**

- **`Color` (RGBA)**: Repräsentiert eine Farbe mit `r: f32`, `g: f32`, `b: f32`, `a: f32` Komponenten im Bereich `[0.0, 1.0]`.
    
    - Konstanten: `TRANSPARENT`, `BLACK`, `WHITE`, `RED`, `GREEN`, `BLUE` etc..
        
    - Methoden: `new(r,g,b,a)` (klemmt Werte nicht automatisch, Aufruferverantwortung), `from_rgba8(r,g,b,a)`, `to_rgba8()`, `with_alpha(alpha)` (klemmt Alpha), `blend(background)`, `lighten(amount)`, `darken(amount)`.
        
    - `Default` wird manuell implementiert, um `Color::TRANSPARENT` zurückzugeben.
        
    - Soll `Serialize` und `Deserialize` implementieren, um als Hex-String (z.B. "#RRGGBBAA") in Konfigurationsdateien dargestellt zu werden. Dies erfordert eine `ColorParseError`-Behandlung.
        

**1.6. Spezifikation: Allgemeine Enumerationen (`enums.rs`)**

- **`Orientation`**: Repräsentiert eine horizontale oder vertikale Ausrichtung.
    
    - Varianten: `Horizontal`, `Vertical`.
        
    - Methoden: `toggle()`.
        
    - `Default` ist `Orientation::Horizontal`.
        

**1.7. Standard Trait Implementierungen** Alle Typen sollen grundlegende Traits wie `Debug`, `Clone`, `Copy` (wo anwendbar und `T` es unterstützt), `PartialEq`, `Default` (sinnvoll definiert), `Send` und `Sync` implementieren. `Eq` und `Hash` sind für Fließkommazahlen generell nicht geeignet.

**1.8. Modulabhängigkeiten** Minimale externe Abhängigkeiten: `std`. Optional `num-traits` (für erweiterte numerische Operationen) und `serde` (mit `derive`-Feature, falls Serialisierung direkt hier benötigt wird, aktuell aber eher in höheren Schichten vorgesehen).

### 2. Modul: `core::errors` (Fehlerbehandlung)

**2.1. Zweck und Geltungsbereich** Spezifiziert die verbindliche Strategie und Implementierung der Fehlerbehandlung innerhalb der Kernschicht. Ziel ist eine lückenlose, präzise Spezifikation für Entwickler.

**2.2. Grundlagen und Prinzipien**

- **Verwendung von `thiserror`**: Obligatorisch für die Definition von benutzerdefinierten Fehlertypen. `thiserror` reduziert Boilerplate-Code für `std::error::Error` und `std::fmt::Display`. Alle benutzerdefinierten Fehler-Enums in der Kernschicht müssen `thiserror::Error` ableiten.
    
- **`Result<T, E>` vs. `panic!`**: Strikte Trennung.
    
    - `Result<T, E>`: Standard für erwartete, potenziell behebbare Fehlerzustände (z.B. I/O-Fehler, ungültige Eingaben). Funktionen müssen `Result<T, E>` zurückgeben, wobei `E` typischerweise `CoreError` oder ein spezifischerer Modul-Fehler ist.
        
    - `panic!`: Ausschließlich für nicht behebbare Programmierfehler (Bugs), Verletzung von Vorbedingungen oder logisch unmögliche interne Zustände.
        
- **Umgang mit `.unwrap()` und `.expect()`**: In produktivem Code der Kernschicht strengstens zu vermeiden, da sie die strukturierte Fehlerbehandlung umgehen.
    
    - Ausnahme für `expect()`: Nur wenn ein `Err`- oder `None`-Zustand nachweislich einen Bug darstellt (interne Invariante verletzt). Die Nachricht muss dem "expect as precondition"-Stil folgen und erklären, _warum_ ein `Ok`- oder `Some`-Wert erwartet wurde.
        
- **Anforderungen an Fehlermeldungen (`#[error("...")]`)**:
    - Klarheit und Präzision, eindeutige Problembeschreibung.
        
    - Kontextinformationen durch eingebettete Feldwerte (`{field_name}`).
        
    - Zielgruppe: Entwickler (für Logging/Debugging).
        
    - Format: Knappe, klein geschriebene Sätze ohne abschließende Satzzeichen (Rust API Guidelines).
        
- **Keine sensiblen Daten in Fehlermeldungen**: Niemals Passwörter, API-Schlüssel, private Benutzerdaten etc. in Fehlermeldungen oder Kontextfeldern. Daten müssen maskiert, entfernt oder durch Platzhalter ersetzt werden.
    

**2.3. Strategie: Ein Fehler-Enum pro Modul** Jedes signifikante Modul innerhalb der Kernschicht (und höheren Schichten) definiert sein eigenes, spezifisches Fehler-Enum mit `thiserror`. Dies vermeidet Überladung des zentralen `CoreError` und adressiert `thiserror`-Einschränkungen bezüglich mehrdeutiger `#[from]`-Konvertierungen desselben Quelltyps.

**2.4. Definition des Basis-Fehlertyps: `CoreError`** Ein zentrales, öffentliches Enum `CoreError` in `core::errors` dient als primäre Schnittstelle für Fehler, die von öffentlichen Funktionen der Kernschicht propagiert werden. Es aggregiert allgemeine Fehlerarten und spezifischere Fehler aus Untermodulen (via `#[from]`).

- **Spezifikation `CoreError`** (Beispielvarianten):
    
    - `Io { path: PathBuf, #[source] source: std::io::Error }`
        
    - `Configuration(#[from] ConfigError)`
        
    - `Serialization { description: String }`
        
    - `InvalidId { invalid_id: String }`
        
    - `NotFound { resource_description: String }`
        
    - `Internal(String)` (sollte vermieden und durch spezifischere Varianten ersetzt werden)
        
    - `InitializationFailed { component: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
        
- **Ableitungen**: Mindestens `Debug` und `thiserror::Error`.
    
- **Fehlerverkettung (`source()`)**: Wird von `thiserror` automatisch für `#[source]` und `#[from]` annotierte Felder implementiert, um die Ursache zurückzuverfolgen.
    

**2.5. Modul-spezifische Fehler und Integration** Module definieren eigene Fehler-Enums (z.B. `ConfigError`, `UtilsError`) die `thiserror::Error` ableiten.

- **Integrationsmechanismus**: Eine dedizierte Variante in `CoreError`, die den Modul-Fehler kapselt und `#[from]` verwendet, ist der bevorzugte Weg. Beispiel: `Configuration(#[from] ConfigError)` in `CoreError`.
    
- Dies etabliert eine zweistufige Fehlerhierarchie.
    

**2.6. Fehlerkontext und Diagnose** Fehlervarianten sollen relevante Kontextinformationen als Felder enthalten (Dateipfade, ungültige Werte etc.).

**2.7. Implementierungsleitfaden für Entwickler (Fehlerdefinition und -behandlung)**

- **Neue Variante zu `CoreError` hinzufügen**: Prüfen, ob der Fehlerfall allgemeine Bedeutung hat oder besser in einem Modul-Fehler aufgehoben ist. Variante, `#[error]`-Meldung und Kontextfelder definieren. `#[source]` oder `#[from]` für Kapselung verwenden.
    
- **Neuen Modul-Fehler erstellen**: `errors.rs` im Modulverzeichnis anlegen. Enum definieren, `thiserror::Error` ableiten, Varianten und Meldungen spezifizieren. In `CoreError` über eine `#[from]`-Variante integrieren.
    
- **Verwendung des `?`-Operators**: Standard für Fehlerpropagation. Funktioniert nahtlos bei identischen Fehlertypen oder existierender `From`-Implementierung.
    
- **Fehler-Matching (`match`)**: Für spezifische Behandlung (Standardwerte, alternative Pfade, Anreicherung).
    
- **Umgang mit externen Crates**: Fehler von externen Bibliotheken müssen in einen Kernschicht-Fehlertyp (`CoreError` oder Modul-Fehler) gekapselt werden. Bevorzugt mit `#[from]` oder `#[source]` (manuelle Erzeugung via `.map_err()`).
    

### 3. Modul: `core::logging` (Logging-Infrastruktur)

**3.1. Grundlagen und Wahl von `tracing`** Die Desktop-Umgebung verwendet das `tracing`-Crate für strukturiertes Logging. `core::logging` stellt Initialisierungsroutinen bereit.

**3.2. `tracing` Framework Integrationsdetails**

- **Initialisierung**: Eine Funktion `initialize_logging(level_filter: tracing::LevelFilter, format: LogFormatEnum) -> Result<(), LoggingError>` wird früh im Anwendungsstart aufgerufen. `LogFormatEnum` könnte `PlainTextDevelopment`, `JsonProduction` definieren. `LoggingError` ist ein `thiserror`-Enum in `core::logging`.
    
- **Subscriber-Konfiguration**:
    - Entwicklung: `tracing_subscriber::fmt()` mit menschenlesbarer Ausgabe (`with_ansi(true)`, `with_target(true)`, `with_file(true)`, `with_line_number(true)`).
        
    - Release: Strukturiertes JSON-Format für Log-Aggregation und maschinelle Analyse (`tracing_subscriber::fmt::json()` oder `tracing-bunyan-formatter`).
        
- **Dynamische Log-Level-Änderungen**: Für zukünftige Erweiterungen berücksichtigen (z.B. via `tracing_subscriber::filter::EnvFilter` oder `RUST_LOG`).
    

**3.3. Standardisierte Log-Makros und `tracing::instrument` Verwendung**

- **Standard-Makros**: Direkte Verwendung von `trace!`, `debug!`, `info!`, `warn!`, `error!` ist verbindlich.
    
- **Log-Nachrichtenstruktur**: Prägnant und beschreibend. Schlüssel-Wert-Paare für strukturierte Daten: `tracing::info!(user_id = %user.id, " Nachricht")` (% für Display, ? für Debug). Fehler mit `error = ?err` loggen, um die Debug-Repräsentation (inkl. `source`-Kette) zu erfassen.
    
- **`#[tracing::instrument]` Verwendung**: Erzeugt Spans für Funktionen/Codeblöcke, gruppiert Log-Ereignisse.
    
    - Anwendung auf öffentliche API-Funktionen, I/O-Operationen, komplexe Berechnungen, abgeschlossene operative Einheiten.
        
    - `skip(...)` / `skip_all` für sensible/ausführliche Argumente.
        
    - `fields(...)` für spezifischen Kontext im Span.
        
    - `err` zur automatischen Fehlerprotokollierung bei `Result::Err`.
        
    - `level` zur Steuerung des Span-Levels.
        

**3.4. Logging von Fehlern** Jeder Fehler (`Result::Err`) sollte an seiner Ursprungsstelle oder einer geeigneten übergeordneten Stelle mit ausreichend Kontext geloggt werden, mindestens auf `ERROR`-Level (`tracing::error!`). Dies sollte typischerweise _vor_ der Propagation geschehen. Den Fehler selbst als strukturiertes Feld mitgeben: `error!(error = %core_err, "Nachricht")`.

**3.5. Log-Daten Sensibilität** Absolutes Verbot, sensible Daten (Passwörter, API-Schlüssel, PII etc.) im Klartext zu loggen. Daten redigieren oder auslassen. Vorsicht bei `Debug`-Implementierungen für Strukturen mit sensiblen Daten; ggf. manuelle Redaktion in `Debug` oder `skip_all` in `#[tracing::instrument]` verwenden.

### 4. Modul: `core::config` (Konfigurationsprimitive)

**4.1. Zweck** Definiert, wie grundlegende Konfigurationseinstellungen geladen, geparst und zugegriffen werden. Fokus auf Einfachheit, Robustheit.

**4.2. Konfigurationsdateiformat und Parsing-Logik**

- **Format**: TOML (Tom's Obvious, Minimal Language) wegen Lesbarkeit und einfacher Verarbeitung.
    
- **Parsing-Bibliothek**: `serde` in Verbindung mit `toml`-Crate (`serde_toml`).
    
- **Ladelogik**:
    - Definition von Standard-Konfigurationspfaden (z.B. systemweit, Entwicklungstests). XDG-Pfade für benutzerspezifische Konfigurationen in höheren Schichten berücksichtigen.
        
    - Eine Funktion wie `load_core_config(custom_path: Option<PathBuf>) -> Result<CoreConfig, ConfigError>` implementiert eine Suchreihenfolge, liest und deserialisiert die TOML-Datei.
        
    - Fehlerbehandlung mit `core::config::ConfigError` (definiert mit `thiserror`), Varianten wie `FileReadError`, `DeserializationError`, `NoConfigurationFileFound`.
        

**4.3. Konfigurationsdatenstrukturen (Ultra-Fein)**

- **`CoreConfig`-Struktur**: Eine primäre Struktur (z.B. `CoreConfig`) hält alle spezifischen Konfigurationen der Kernschicht.
    
    - Felder mit explizit definierten Typen.
        
    - Muss `serde::Deserialize` ableiten.
        
    - `#[serde(default = "path")]` oder `#[serde(default)]` umfassend verwenden für Standardwerte bei fehlenden Feldern.
        
    - `#[serde(deny_unknown_fields)]` erzwingen, um Tippfehler oder unbekannte Felder in Konfigurationsdateien zu verhindern.
        
- **Validierung**: Grundlegende Validierung durch Typen. Komplexere Validierungen nach Deserialisierung (z.B. via `TryFrom` Muster oder `validate()`-Methode). Für Kernschicht kann initiale Validierung auf `serde`-Fähigkeiten beschränkt sein.
    

**4.4. Konfigurationszugriffs-API**

- **Globaler Zugriff**: Geladene `CoreConfig`-Instanz threadsicher speichern, typischerweise mittels `once_cell::sync::OnceCell`.
    
    - `initialize_core_config(config: CoreConfig) -> Result<(), CoreConfig>` zum einmaligen Setzen.
        
    - `get_core_config() -> &'static CoreConfig` für den Zugriff; paniert, wenn nicht initialisiert (Programmierfehler).
        
- **Immutabilität**: Global zugängliche Konfiguration sollte nach Initialisierung unveränderlich sein. `CoreConfig` sollte `Clone` ableiten für Momentaufnahmen oder Tests.
    

### 5. Modul: `core::utils` (Allgemeine Hilfsfunktionen)

**5.1. Zweck** Beherbergt allgemeine Hilfsfunktionen und kleine, in sich geschlossene Utilities, die nicht in spezifischere Module passen, aber breit verwendet werden.

**5.2. Allgemeine Richtlinien**

- **Geltungsbereich**: Nur wirklich allgemeine Utilities.
- **Einfachheit**: Einfache Funktionen bevorzugen.
- **Reinheit**: Reine Funktionen (Ausgabe hängt nur von Eingabe ab, keine Seiteneffekte) bevorzugen.
- **Fehlerbehandlung**: Jede fehleranfällige Utility-Funktion gibt `Result<T, YourUtilError>` zurück, wobei `YourUtilError` mit `thiserror` im Utility-Submodul definiert wird.
- **Dokumentation**: Umfassende `rustdoc`-Kommentare mit Beispielen.
- **Tests**: Gründliche Unit-Tests.

### 6. Allgemeine Entwicklungsrichtlinien (Kernschicht)

**6.1. Dokumentation (`rustdoc`)** Alle öffentlichen Elemente (Module, Structs, Enums, Felder, Konstanten, Methoden) müssen `///`-Dokumentationskommentare haben.

- Modul-Level: Zweck des Moduls.
- Typ-Level: Zweck und Invarianten.
- Feld-Level: Bedeutung des Feldes.
- Methoden-Level: Was die Methode tut, Parameter, Rückgabewerte, mögliche Panics (idealerweise keine außer in Tests), Vor-/Nachbedingungen, Algorithmen.
- `# Examples`-Abschnitte verwenden.
- Strikte Einhaltung der Rust API Guidelines.
- `cargo doc --open` zur Überprüfung.

**6.2. Unit-Testing**

- Ein `#[cfg(test)]`-Modul innerhalb jeder Implementierungsdatei.
- Tests für Konstruktoren, Konstanten, Methodenlogik, Grenzfälle, Trait-Implementierungen, Invariantenprüfungen.
- Anstreben einer hohen Testabdeckung.

**6.3. Immutabilität und Stabilität** Die API der Kernschicht sollte nach Stabilisierung als äußerst stabil behandelt werden. Änderungen haben weitreichende Auswirkungen. Komponenten sind so konzipiert, dass sie `Send + Sync` sind, wo sinnvoll, für Multithreading.

**6.4. Schichtübergreifende Integrationsrichtlinien**

- **Fehlerbehandlung**: Höhere Schichten definieren eigene `thiserror`-Enums. Fehler aus der Kernschicht werden behandelt oder via `?` propagiert (ggf. mit `#[from]` in eigene Fehlertypen konvertiert), Fehlerkette (`source()`) muss erhalten bleiben.
- **Logging**: Alle Schichten nutzen `tracing`-Makros. `core::logging::initialize_logging()` wird vom Hauptbinary aufgerufen. Einhaltung von Log-Leveln und Datensensibilität ist zwingend.
- **Konfiguration**: Höhere Schichten können eigene Konfigs definieren. Zugriff auf Kern-Konfig via `core::config::get_core_config()`. Kern-Konfig nicht zur Laufzeit modifizieren.
- **Typen und Utilities**: Kerndatentypen und -utilities direkt verwenden. Bei Spezialisierung Komposition oder Newtype-Wrapper um Kerntypen in Betracht ziehen.

Diese Spezifikation legt den Grundstein für eine robuste, wartbare und performante Kernschicht. Die disziplinierte Einhaltung dieser Richtlinien ist für den Erfolg des Projekts entscheidend.

# Ultra-Detaillierter Implementierungsplan: Linux-Desktop-Umgebung

## 1. Einleitung

### 1.1. Zweck und Umfang

Dieses Dokument stellt einen detaillierten, schichtweisen Implementierungsplan für das Linux-Desktop-Umgebungsprojekt dar. Es dient als technischer Leitfaden für das Entwicklungsteam und beschreibt die Schritte, Komponenten und Überlegungen, die für die erfolgreiche Umsetzung des Projekts gemäß den (angenommenen) technischen Gesamtspezifikationen und Entwicklungsrichtlinien erforderlich sind. Der Plan deckt alle architektonischen Schichten ab – Core, Domain, System und UI – und geht detailliert auf Aspekte wie API-Definitionen, Fehlerbehandlung, Logging, Tests und Dokumentation ein. Der Umfang dieses Plans umfasst den gesamten Lebenszyklus der Desktop-Umgebungssoftware, von der Initialisierung bis zur Benutzerinteraktion und Systemintegration.

### 1.2. Angenommene Technische Grundlage

Dieser Implementierungsplan basiert auf der Annahme, dass moderne, robuste Technologien als Fundament dienen. Konkret wird davon ausgegangen, dass **Wayland** als Display-Server-Protokoll und **Rust** als primäre Implementierungssprache verwendet werden. Diese Wahl wird durch die Notwendigkeit von Sicherheit, Performance und moderner Architektur getrieben. Rust bietet Speichersicherheit ohne Garbage Collection, was für Systemsoftware wie eine Desktop-Umgebung von entscheidender Bedeutung ist. Wayland bietet gegenüber älteren Systemen wie X11 Vorteile in Bezug auf Sicherheit, Performance und Einfachheit des Protokolls.

Zentral für die Implementierung ist die Nutzung der **Smithay-Bibliothek**.1 Smithay stellt modulare Bausteine für die Erstellung von Wayland-Kompositoren in Rust bereit. Seine Designziele – gut dokumentiert, sicherheitsorientiert, modular und abstrahierend – passen gut zu den Qualitätsanforderungen dieses Projekts.2 Smithay ist explizit keine einschränkende Framework-Lösung, sondern bietet Werkzeuge, die eine flexible Architektur ermöglichen. Dies erfordert jedoch eine sorgfältige Planung der Architektur und der Komponenteninteraktion, wie sie in diesem Dokument dargelegt wird. Die Verwendung von Smithay beschleunigt die Entwicklung, indem sie grundlegende Wayland-Interaktionen und Zustandsverwaltung abstrahiert.1

### 1.3. Architektonische Übersicht

Die Architektur der Desktop-Umgebung ist in vier logische Schichten unterteilt, um eine klare Trennung der Verantwortlichkeiten und eine hohe Modularität zu gewährleisten:

- **Core:** Die unterste Schicht, verantwortlich für den grundlegenden Prozessstart, die Ereignisschleife, die Initialisierung der Wayland-Verbindung und grundlegende Dienstprogramme wie Logging und Fehlerdefinitionen.
- **Domain:** Enthält die Kernlogik und die Zustandsrepräsentation der Desktop-Umgebung. Sie verwaltet abstrakte Konzepte wie Fenster, Arbeitsbereiche, Ausgaben und Eingabegeräte unabhängig von spezifischen Protokollen oder Rendering-Details.
- **System:** Vermittelt zwischen der Domain-Schicht und der Außenwelt. Implementiert Wayland-Protokollschnittstellen, interagiert mit Grafik-Backends und Systemdiensten (z. B. `logind`).
- **UI:** Verantwortlich für die visuelle Darstellung der Desktop-Elemente (Shell-Komponenten, Fensterinhalte) und die Verarbeitung von Benutzerinteraktionen, die die Präsentation direkt beeinflussen.

Die folgenden Abschnitte detaillieren den Implementierungsplan für jede dieser Schichten sowie übergreifende Aspekte wie Fehlerbehandlung, Logging und Tests.

## 2. Gesamtarchitektur

### 2.1. Schichtverantwortlichkeiten

Eine klare Definition der Verantwortlichkeiten jeder Schicht ist entscheidend für eine saubere Architektur und Wartbarkeit:

- **Core:**
    - Initialisierung und Verwaltung der Haupt-Ereignisschleife (`calloop`).
    - Herstellen und Verwalten der Wayland-Display-Verbindung.
    - Grundlegendes Ressourcenmanagement (z. B. Speicher, Dateideskriptoren).
    - Bereitstellung fundamentaler Hilfsprogramme (zentrale Fehler-Typen, Logging-Initialisierung).
- **Domain:**
    - Definition und Verwaltung der internen Zustandsrepräsentation (z. B. Fensterhierarchien, Fokus, Arbeitsbereichszuordnungen, Ausgabekonfigurationen).
    - Implementierung der "Geschäftslogik" der Desktop-Umgebung (z. B. Fensterplatzierungsregeln, Fokuswechsel-Logik, Workspace-Management).
    - Abstraktion über rohe Wayland-Objekte (z. B. ein "Fenster"-Konzept, das eine `wl_surface` mit einer Rolle kapselt).
    - Zustandsverwaltung für Oberflächen (`wl_surface`) unter Verwendung von Smithay-Primitiven.1
- **System:**
    - Implementierung spezifischer Wayland-Protokoll-Handler (z. B. `xdg-shell`, `wlr-layer-shell`, `wl_seat`).
    - Interaktion mit dem Grafik-Subsystem (z. B. EGL, WGPU, DRM/KMS) für Buffer-Management und Rendering-Kontext.
    - Kommunikation mit Systemdiensten (z. B. `logind` für Sitzungsverwaltung und Geräteberechtigungen).2
    - Verarbeitung von Eingabeereignissen vom Backend (z. B. `libinput`) und Weiterleitung an Clients über Wayland-Protokolle.
- **UI:**
    - Implementierung der Rendering-Pipeline (Zeichnen von Fenstern, Shell-Elementen).
    - Implementierung von Damage Tracking zur Optimierung des Renderings.3
    - Entwicklung und Darstellung von Desktop-Shell-Komponenten (Panel, Launcher, Benachrichtigungen) unter Verwendung von Protokollen wie `wlr-layer-shell`.4
    - Verarbeitung direkter UI-Interaktionen (z. B. Klicks auf Buttons im Panel).
    - Anwendung von Theming und visuellen Stilen.

### 2.2. Komponenteninteraktion

Die Schichten interagieren auf klar definierten Wegen. Ein typischer Ablauf könnte wie folgt aussehen:

1. Ein Hardware-Ereignis (z. B. Tastendruck) wird vom System-Backend (z. B. `libinput`) erfasst.
2. Die Core-Ereignisschleife nimmt das Ereignis entgegen und leitet es an den entsprechenden Handler in der System-Schicht weiter.
3. Die System-Schicht (z. B. `wl_seat`-Handler) interpretiert das Ereignis im Kontext des Wayland-Protokolls.
4. Die System-Schicht interagiert mit der Domain-Schicht, um den relevanten Zustand zu ermitteln (z. B. welches Fenster hat den Fokus?).
5. Basierend auf dem Zustand entscheidet die System-Schicht, das Ereignis an einen Wayland-Client zu senden oder eine Aktion in der Domain-Schicht auszulösen (z. B. Fokuswechsel anfordern).
6. Wenn eine Zustandsänderung in der Domain-Schicht erfolgt (z. B. Fokus wechselt), wird dies registriert.
7. Die UI-Schicht wird über die Zustandsänderung informiert (direkt oder indirekt durch die Notwendigkeit eines Neuzeichnens).
8. Die UI-Schicht rendert die betroffenen Bereiche neu, möglicherweise unter Verwendung von Damage Tracking, um nur die geänderten Teile zu aktualisieren.3 Sie greift dabei auf Zustandsinformationen aus der Domain-Schicht (z. B. Fensterpositionen, Inhalte) und System-Schicht (z. B. Buffer von Clients) zu.

### 2.3. Wichtige Architekturprinzipien

Die Entwicklung folgt diesen Leitprinzipien:

- **Modularität:** Aufbauend auf Smithays Philosophie 2, werden Komponenten so entworfen, dass sie möglichst unabhängig und austauschbar sind.
- **Trennung der Verantwortlichkeiten (Separation of Concerns):** Strikte Einhaltung der Schichtgrenzen, um Abhängigkeiten zu minimieren und die Testbarkeit zu erhöhen.
- **Testbarkeit:** Design für Testbarkeit auf allen Ebenen (Unit, Integration, E2E).
- **Robustheit:** Umfassende Fehlerbehandlung, sicheres Ressourcenmanagement (unterstützt durch Rust) und graceful degradation bei Fehlern.
- **Performance:** Effiziente Algorithmen, insbesondere im Rendering-Pfad (z. B. Damage Tracking 3) und bei der Ereignisverarbeitung.

### 2.4. _Wertvolle Tabelle:_ Matrix der Schichtverantwortlichkeiten

Die folgende Matrix bietet eine Übersicht, welche Schicht primär (P) oder unterstützend (S) für wichtige Funktionalitäten verantwortlich ist.

|   |   |   |   |   |
|---|---|---|---|---|
|**Funktionalität**|**Core**|**Domain**|**System**|**UI**|
|Ereignisverarbeitung (Loop)|P||S||
|Wayland-Verbindung|P||S||
|Zustandsverwaltung (intern)||P|S|S|
|Fenstergeometrie/-logik||P|S|S|
|Workspace-Management||P|S|S|
|Wayland-Protokoll-Impl.|S|S|P||
|Grafik-Backend-Interaktion|S||P|S|
|Rendering||S|S|P|
|Damage Tracking||S|S|P|
|Eingabeverarbeitung (System)|S|S|P||
|Eingabeverarbeitung (Client)||S|P||
|Shell-Komponenten (Logik)||S|S|P|
|Shell-Komponenten (Darst.)|||S|P|
|Konfiguration (Speicher)|S|P|S||
|Konfiguration (Anwendung)||P|S|P|
|Logging|P|S|S|S|
|Fehlerbehandlung (Kern)|P|S|S|S|
|Fehlerbehandlung (Protokoll)||S|P||

Diese Matrix dient als Referenz, um sicherzustellen, dass die Logik in der korrekten Schicht implementiert wird und die Prinzipien der Modularität und Trennung der Verantwortlichkeiten eingehalten werden.

## 3. Core Layer Implementierung

### 3.1. Event Loop Integration (`calloop`)

Die zentrale Ereignisverarbeitung wird mittels der `calloop`-Bibliothek implementiert.5 `calloop` ist eine auf Rückrufen basierende Ereignisschleife, die sich gut für I/O-gebundene Anwendungen wie einen Wayland-Kompositor eignet, der die meiste Zeit auf Ereignisse wartet.

Die Initialisierung erfolgt typischerweise durch `EventLoop::try_new()`. Ein `handle` wird verwendet, um neue Ereignisquellen hinzuzufügen (`handle.insert_source()`). Jede Quelle wird mit einem Callback assoziiert, der bei Eintreten von Ereignissen ausgeführt wird. Die `event_loop.run()`-Methode startet die Schleife und verarbeitet Ereignisse. Sie ermöglicht die Übergabe gemeinsamer Daten (`shared_data`), auf die Callbacks zugreifen können, beispielsweise ein `LoopSignal` zum Beenden der Schleife.5

Eine besondere Herausforderung stellt die Integration von Wayland-Ereignisquellen dar. Der Dateideskriptor der Wayland-Display-Verbindung muss in die `calloop`-Schleife integriert werden. Es ist jedoch entscheidend, die Verwaltung der Wayland-Ereigniswarteschlangen korrekt zu handhaben, insbesondere wenn mehrere Komponenten oder Threads mit der Wayland-Verbindung interagieren könnten (z. B. durch Bibliotheken wie `winit` oder separate Threads für Aufgaben wie die Zwischenablage).6 Die Wayland-Client-Bibliothek erfordert, dass `wl_display_prepare_read_queue` aufgerufen wird, _bevor_ die Ereignisschleife blockiert (z. B. mittels `epoll_wait`), um Race Conditions zu vermeiden und sicherzustellen, dass keine Ereignisse verloren gehen oder falsch verarbeitet werden.6 Ein einfaches Hinzufügen des Wayland-FDs zu `calloop` ist möglicherweise nicht ausreichend, wenn die Warteschlange auch von anderer Stelle beeinflusst werden kann.

Daher muss eine klare Strategie für die Verwaltung der Wayland-Warteschlange definiert werden. Mögliche Ansätze sind:

a) Sicherstellen, dass alle Wayland-Interaktionen ausschließlich über den Haupt-Thread der calloop-Schleife und die von ihr verwalteten Quellen erfolgen.

b) Sorgfältige manuelle Verwendung von wl_display_prepare_read_queue, falls eine tiefere Integration notwendig ist.

c) Isolation von Komponenten mit komplexen Wayland-Interaktionen (wie der in 6 erwähnten Zwischenablage) in separate Threads mit eigenen, sorgfältig verwalteten Verbindungen/Warteschlangen, die über in calloop integrierte Kanäle (z. B. MPSC-Kanäle 5) mit der Hauptschleife kommunizieren.

Diese architektonische Entscheidung hat erhebliche Auswirkungen auf die Komplexität, Performance und das Potenzial für Deadlocks und muss frühzeitig getroffen werden.

### 3.2. Wayland Display & Core Initialisierung

Der Prozess beginnt mit dem Aufbau der Verbindung zum Wayland-Display. Dies kann entweder als verschachtelter Client innerhalb einer bestehenden Wayland- oder X11-Sitzung geschehen (nützlich für Entwicklung und Tests 2) oder direkt auf der Hardware über ein TTY mit DRM/KMS und `udev`-Unterstützung.2

Nach erfolgreicher Verbindung werden die globalen Wayland-Objekte initialisiert. Eine zentrale `State`-Struktur wird definiert, die alle kompositorweiten Ressourcen und Zustände enthält. Hierzu gehört auch die Initialisierung von Smithays `CompositorState`, wie im Beispiel in 1 gezeigt, um die Basis für die Verwaltung von Oberflächen zu legen.

### 3.3. Fundamentales Logging

Ein robustes Logging-System ist von Anfang an unerlässlich. Es wird empfohlen, die `tracing`-Bibliothek oder die `log`-Fassade mit einem geeigneten Backend wie `env_logger` 7 zu verwenden.

Zu Beginn werden grundlegende Logging-Levels (z. B. ERROR, WARN, INFO, DEBUG, TRACE) definiert. Log-Nachrichten sollten standardmäßig Zeitstempel, Modulpfad und Schweregrad enthalten. Wo immer sinnvoll, sollte strukturiertes Logging (z. B. Key-Value-Paare) verwendet werden, um die spätere Analyse und Filterung von Logs zu erleichtern. Die Konfiguration der Log-Levels sollte zur Laufzeit möglich sein (z. B. über Umgebungsvariablen).

### 3.4. Grundlegende Fehlerbehandlung

Ein konsistentes Fehlerbehandlungssystem wird etabliert. Es wird empfohlen, `thiserror` oder eine benutzerdefinierte `enum`-Struktur zu verwenden, um spezifische Fehlertypen für die Core-Schicht (`CoreError`) und potenziell andere Schichten zu definieren. Die Konvention für die Fehlerweitergabe ist `Result<T, ErrorType>`.

Ein grundlegender Panic-Handler wird implementiert, um bei unerwarteten Fehlern aussagekräftige Informationen zu loggen oder anzuzeigen, anstatt stillschweigend abzustürzen. Rusts Ownership- und Borrowing-System hilft, viele Fehlerklassen zur Kompilierzeit zu vermeiden, aber Laufzeitfehler (z. B. I/O-Fehler, Protokollverletzungen durch Clients) müssen explizit behandelt werden.

## 4. Domain Layer Implementierung

### 4.1. Compositor State Management

Die Verwaltung des Zustands von Wayland-Oberflächen (`wl_surface`) ist eine Kernaufgabe des Kompositors. Smithays `CompositorState` und das zugehörige `CompositorHandler`-Trait werden hierfür zentral genutzt.1 Diese Komponenten übernehmen die automatische Verwaltung von Oberflächen, Unteroberflächen (`subsurfaces`) und Regionen, speichern den Zustand kohärent und behandeln die Anwendung von doppelt gepufferten Zuständen.

Der Zugriff auf den Zustand einer Oberfläche erfolgt über die Funktion `with_states`, die Zugriff auf die `SurfaceData`-Instanz der Oberfläche gewährt. `SurfaceData` dient als allgemeiner Container, um anwendungsspezifische Daten (gepuffert oder nicht) mit einer Oberfläche zu assoziieren.1

Der Commit-Lebenszyklus einer Oberfläche wird durch Hooks gesteuert:

- `add_pre_commit_hook`: Wird vor der Anwendung des neuen Zustands aufgerufen. Nützlich für Protokollerweiterungen, um ungültige Zustandsanfragen von Clients zu validieren, bevor sie angewendet werden.
- `add_post_commit_hook`: Wird nach der Anwendung des neuen Zustands aufgerufen. Nützlich für Abstraktionen, die den neuen Zustand weiterverarbeiten müssen.
- `add_destruction_hook`: Wird aufgerufen, wenn die Oberfläche zerstört wird, um zugeordnete Zustände aufzuräumen.1

Die Implementierung von `CompositorHandler::commit` ist der zentrale Punkt, an dem die Domain-Logik auf den neuen, aktuellen Zustand einer Oberfläche reagieren kann, nachdem dieser (und der Zustand synchronisierter Kind-Unteroberflächen) angewendet wurde.1

Wayland verlangt, dass jede darstellbare Oberfläche eine "Rolle" zugewiesen bekommt (z. B. `toplevel`, `popup`, `subsurface`, `layer-surface`). Smithay repräsentiert dies durch einen statischen String-Identifier, der nur einmal pro Oberfläche gesetzt werden kann (`give_role`, `get_role`).1 Die Domain-Schicht ist verantwortlich für die Verwaltung dieser Rollen und die Sicherstellung, dass sie korrekt und konsistent verwendet werden.

### 4.2. Window Management Abstraction

Während Smithay die Mechanismen zur Verwaltung von `wl_surface`-Zuständen bereitstellt 1, benötigt die Desktop-Umgebung höherstufige Konzepte wie "Fenster", "Fokus" und "Stapelanordnung".3 Es ist daher notwendig, innerhalb der Domain-Schicht eine explizite Abstraktionsebene für das Fenstermanagement zu implementieren. Diese Abstraktion kapselt typischerweise eine Wurzel-`wl_surface` mit einer bestimmten Rolle (z. B. `xdg_toplevel`) und verwaltet die damit verbundenen Metadaten und Verhaltensweisen.

Diese Abstraktion ist verantwortlich für:

- **Geometrieverwaltung:** Verfolgung und Verwaltung der Position und Größe von Fenstern im logischen Koordinatensystem des Desktops.3 Dies beinhaltet auch die Handhabung von Geometrie-Constraints, wie z. B. minimale/maximale Größen oder spezielle Begrenzungsrahmen für Popups (möglicherweise pro Ausgabe, wie in 3 vorgeschlagen, um Popups auf einem Monitor zu halten).
- **Stapelanordnung (Z-Order):** Implementierung der Logik zur Verwaltung der Sichtbarkeitsreihenfolge von Fenstern. Dies ist entscheidend für das korrekte Rendering, bei dem Fenster (und ihre Unteroberflächen und Popups) in der richtigen Z-Reihenfolge durchlaufen werden müssen. Optimierungen wie das Überspringen von Oberflächen, die vollständig von anderen opaken Oberflächen verdeckt werden, sollten hier berücksichtigt werden.3
- **Fokusmanagement:** Verfolgung des aktiven Fensters (das Eingabeereignisse empfängt) und Implementierung der Logik für Fokuswechsel (z. B. durch Benutzeraktion oder programmatisch).

Die Schaffung dieser internen Abstraktion ist kritisch. Sie entkoppelt die höhere Fensterverwaltungslogik von den Details der `wl_surface`-Commit-Hooks und der Baumstruktur von Unteroberflächen.1 Ohne diese Abstraktion besteht die Gefahr, dass sich Low-Level-Oberflächenbehandlung und High-Level-Fensterlogik vermischen, was zu schwer wartbarem Code führt. Die API dieser Abstraktion muss klar definiert sein, um eine saubere Interaktion mit der System- und UI-Schicht zu ermöglichen.

### 4.3. Input Abstraction

Die Domain-Schicht verwaltet den _Zustand_ der Eingabegeräte, während die System-Schicht die _Protokoll_-Interaktion übernimmt. Hier werden interne Repräsentationen für Tastaturen, Zeigergeräte (Mäuse, Touchpads) und Touchscreens definiert.

Diese Schicht ist verantwortlich für die Verwaltung von:

- Gerätefähigkeiten (z. B. Anzahl der Maustasten, Touchscreen-Funktionen).
- Gerätezuständen (z. B. aktuell aktives Tastaturlayout, Zeigerbeschleunigungseinstellungen, Tastenzustände wie Caps Lock).
- Zuordnung von Geräten zu "Seats" (logische Gruppierungen von Eingabe- und Ausgabegeräten für einen Benutzer).

### 4.4. Output Configuration

Analog zur Eingabeabstraktion verwaltet die Domain-Schicht den internen Zustand der angeschlossenen Ausgabegeräte (Monitore).

Verantwortlichkeiten umfassen:

- Definition interner Repräsentationen für Ausgaben.
- Verwaltung von Ausgabeeigenschaften: Auflösung (Mode), Position im globalen Koordinatenraum, Skalierungsfaktor, Aktivierungszustand (enabled/disabled), Orientierung.
- Logik zur Anordnung mehrerer Monitore.

Diese Zustandsinformationen werden von der System-Schicht verwendet, um das `wl_output`-Protokoll zu implementieren und von der UI-Schicht für das Rendering.

### 4.5. Workspace/Virtual Desktop Logic

Falls das Desktop-Paradigma virtuelle Desktops oder Workspaces vorsieht, wird die entsprechende Logik in der Domain-Schicht implementiert.

Dies beinhaltet:

- Datenstrukturen zur Darstellung von Workspaces und deren Zuordnung zu Ausgaben.
- Logik zur Verwaltung der Zugehörigkeit von Fenstern zu Workspaces.
- Implementierung von Workspace-Wechsel-Aktionen und deren Auswirkungen auf Fenster-Sichtbarkeit und Fokus.

## 5. System Layer Implementierung

### 5.1. Wayland Protocol Implementation

Diese Schicht ist maßgeblich für die Implementierung der verschiedenen Wayland-Protokolle verantwortlich, die die Kommunikation zwischen dem Kompositor und den Client-Anwendungen ermöglichen. Smithay bietet hierfür zahlreiche Handler und Hilfsprogramme.

- **`wl_compositor` / `wl_subcompositor`:** Die grundlegende Funktionalität wird weitgehend durch Smithays `CompositorState` bereitgestellt.1 Die Integration in die Haupt-`State`-Struktur und die Ereignisschleife ist jedoch erforderlich.
- **Shell Protocols (`xdg-shell`):** Dies ist eines der wichtigsten Protokolle für Desktop-Anwendungen. Es müssen Handler für `xdg_wm_base` (das globale Objekt), `xdg_surface` (bindet eine `wl_surface` an `xdg-shell`), `xdg_toplevel` (für Hauptfenster) und `xdg_popup` (für Menüs, Tooltips etc.) implementiert werden. Anfragen von Clients (z. B. `move`, `resize`, `set_title`, `set_maximized`, `set_fullscreen`) müssen empfangen und in Aktionen auf der Fenstermanagement-Abstraktion der Domain-Schicht übersetzt werden. Ebenso müssen Konfigurationsereignisse (`configure`) an die Clients gesendet und deren Bestätigungen (`ack_configure`) verarbeitet werden.
- **Decoration Protocol (`xdg-decoration`):** Dieses Protokoll dient der Aushandlung zwischen Client und Kompositor, ob Fensterdekorationen vom Client (Client-Side Decorations, CSD) oder vom Kompositor (Server-Side Decorations, SSD) gezeichnet werden sollen.
    - Die Implementierung erfolgt durch Bereitstellung des `zxdg_decoration_manager_v1`-Globals mithilfe von `XdgDecorationState`.8
    - Handler für `zxdg_toplevel_decoration_v1`-Anfragen wie `set_mode` und `unset_mode` müssen implementiert werden.
    - Es ist von entscheidender Bedeutung, die _Semantik_ des Protokolls korrekt umzusetzen. Wie in 9 am Beispiel von SDL dargelegt, dient das Protokoll der _Aushandlung_, nicht ausschließlich der Signalisierung von SSD. Clients könnten fälschlicherweise annehmen, dass SSD verfügbar ist, nur weil der Manager existiert. Der Kompositor muss klar seine bevorzugte Dekorationsart (oder die Fähigkeit zum Wechsel) signalisieren und auf Client-Anfragen entsprechend reagieren. Es muss entschieden werden, ob der Kompositor nur CSD, nur SSD oder beides (ggf. dynamisch umschaltbar) unterstützt, und die Protokoll-Implementierung muss dies widerspiegeln. Die Implementierung muss robust gegenüber potenziell missverständlichen Client-Anfragen sein und die Teststrategie (Abschnitt 7.4) muss die Korrektheit dieser Aushandlung mit verschiedenen Clients überprüfen.
- **Layer Shell Protocol (`wlr-layer-shell-unstable-v1`):** Dieses Protokoll ermöglicht es Clients, Oberflächen zu erstellen, die als Teil der Desktop-Shell fungieren (z. B. Panels, Hintergrundbilder, Benachrichtigungs-Popups, Lock Screens).4
    - Das `zwlr_layer_shell_v1`-Global und die `zwlr_layer_surface_v1`-Schnittstelle müssen implementiert werden.
    - Anfragen wie `get_layer_surface`, `set_layer` (Hintergrund, Unten, Oben, Überlagerung), `set_anchor` (Anheften an Bildschirmkanten), `set_exclusive_zone` (Reservieren von Platz, der von normalen Fenstern freigehalten wird) und `set_keyboard_interactivity` müssen verarbeitet werden.4
    - Der Konfigurationszyklus (initialer Commit ohne Buffer, `configure`-Ereignis vom Kompositor, `ack_configure` vom Client, dann Buffer anhängen) muss korrekt implementiert werden.4
    - Die Eigenschaften dieser Layer-Oberflächen müssen in der Domain-Schicht repräsentiert und in die Rendering-Pipeline der UI-Schicht integriert werden. Die Möglichkeit, `xdg_popup`s relativ zu Layer-Oberflächen zu positionieren (`get_popup`), muss ebenfalls berücksichtigt werden.4
- **Seat & Input Protocols (`wl_seat`, `wl_keyboard`, `wl_pointer`, `wl_touch`):** Das `wl_seat`-Global repräsentiert eine Gruppe von Ein- und Ausgabegeräten für einen Benutzer. Zugehörige Schnittstellen (`wl_keyboard`, `wl_pointer`, etc.) dienen der Übermittlung von Eingabeereignissen an fokussierte Clients. Die System-Schicht empfängt rohe Eingabeereignisse vom Backend (z. B. `libinput`), verarbeitet sie gemäß dem Zustand in der Domain-Schicht (z. B. Fokus, Tastaturlayout) und sendet die entsprechenden Wayland-Ereignisse an die Clients. Die Verwaltung von Tastatur-Keymaps erfordert typischerweise die `libxkbcommon`-Bibliothek.7
- **Output Protocol (`wl_output`):** Das `wl_output`-Global repräsentiert einen Monitor. Die System-Schicht implementiert dieses Global und sendet Ereignisse über Geometrie (`geometry`), verfügbare Modi (`mode`), Skalierungsfaktor (`scale`) und Abschluss der Konfiguration (`done`) an die Clients, basierend auf dem Zustand, der in der Domain-Schicht verwaltet wird.
- **Andere Protokolle:** Je nach Anforderung müssen weitere Protokolle implementiert werden, z. B.:
    - Datenübertragung (`wl_data_device_manager` für Drag-and-Drop und Copy-Paste).
    - Primäre Auswahl (`gtk_primary_selection_device_manager`).
    - Präsentationszeit (`wp_presentation` für Frame-Callbacks und Timing).
    - Bildschirmaufnahme (`xdg-desktop-portal` oder spezifische Protokolle wie `wlr-screencopy-unstable-v1`).

### 5.2. _Wertvolle Tabelle:_ Wayland-Protokoll-Implementierungsplan

Diese Tabelle dient der Nachverfolgung des Implementierungsstatus und wichtiger Aspekte der einzelnen Protokolle.

|   |   |   |   |
|---|---|---|---|
|**Protokoll/Interface**|**Status**|**Smithay Handler/Util**|**Wichtige Überlegungen**|
|`wl_compositor`|Benötigt|`CompositorState`, `CompositorHandler`|Basis für Oberflächenverwaltung, von Smithay weitgehend abgedeckt.1|
|`wl_subcompositor`|Benötigt|`CompositorState`|Verwaltung von Unteroberflächen, Teil von `CompositorState`.1|
|`xdg_wm_base`|Benötigt|`XdgShellState`, `XdgShellHandler`|Zentral für Desktop-Anwendungen; komplexe Zustandsverwaltung (Konfiguration, Rollen).|
|`xdg_surface`, `xdg_toplevel`|Benötigt|`XdgShellState`, `ToplevelSurface`|Handling von Fenster-Requests (move, resize, maximize etc.), Konfigurationszyklus.|
|`xdg_popup`|Benötigt|`XdgShellState`, `PopupSurface`|Positionierung relativ zu Eltern, Greifen von Eingaben.|
|`zxdg_decoration_manager_v1`|Benötigt|`XdgDecorationState` 8|Korrekte Implementierung der CSD/SSD-Aushandlung ist kritisch, Client-Verhalten beachten.9|
|`zwlr_layer_shell_v1`|Benötigt|`LayerShellState` (oder Äquivalent)|Für Shell-UI-Elemente; Konfigurationszyklus, `exclusive_zone`, `anchor` beachten.4|
|`wl_seat`|Benötigt|`SeatState`, `SeatHandler`|Verwaltung von Fähigkeiten (Tastatur, Zeiger, Touch) und Fokus.|
|`wl_keyboard`|Benötigt|`KeyboardHandle`|Keymap-Handling (via `libxkbcommon` 7), Senden von Tastenereignissen.|
|`wl_pointer`|Benötigt|`PointerHandle`|Senden von Bewegungs-, Tasten-, Achsenereignissen; Cursor-Management.|
|`wl_touch`|Optional|`TouchHandle`|Senden von Touch-Ereignissen (down, up, motion).|
|`wl_output`|Benötigt|`OutputManagerState` (oder Äquiv.)|Senden von Geometrie, Modus, Skalierung an Clients.|
|`wl_data_device_manager`|Empfohlen|`DataDeviceState`|Für Copy-Paste und Drag-and-Drop.|
|`wp_presentation`|Empfohlen|`PresentationState` (oder Äquiv.)|Für präzise Frame-Callbacks und Timing-Informationen.|
|`wlr-screencopy-unstable-v1`|Optional|Eigene Implementierung|Für Bildschirmaufnahmen/Screenshots.|

_Status: Benötigt, Empfohlen, Optional, In Arbeit, Implementiert, Getestet_

### 5.3. Graphics Backend Abstraction

Die System-Schicht muss mit dem Grafik-Subsystem des Hosts interagieren, um Fensterinhalte darzustellen. Eine Abstraktionsschicht ist hier sinnvoll, um die Kopplung an eine spezifische Grafik-API zu minimieren.

Mögliche Backends sind:

- **EGL + OpenGL ES:** Der traditionelle Ansatz für viele Wayland-Kompositoren.
- **WGPU:** Eine moderne Grafikabstraktion in Rust, die über verschiedene native Backends (Vulkan, Metal, DirectX 12, OpenGL ES) laufen kann. Die Verwendung von `wgpu` wird in der Wayland/Smithay-Community untersucht und eingesetzt.7

Die Abstraktion muss folgende Aufgaben übernehmen:

- **Backend-Initialisierung:** Laden der Grafiktreiber, Erstellen von Kontexten (EGL-Kontext, WGPU-Instanz/Device).
- **Buffer-Management:** Handhabung von Client-bereitgestellten Buffern über `wl_buffer`. Dies umfasst Shared Memory Buffers (SHM) und idealerweise DMA-BUFs für effiziente, kopierfreie Übergabe von Grafikdaten von Clients (insbesondere GPUs) an den Kompositor.
- **Rendering-Synchronisation:** Sicherstellen, dass Frames zum richtigen Zeitpunkt (z. B. VSync) auf dem Bildschirm angezeigt werden.
- **Integration mit DRM/KMS:** Bei Ausführung direkt auf der Hardware (`--tty-udev`-Backend 2) ist eine direkte Interaktion mit dem Direct Rendering Manager (DRM) und Kernel Mode Setting (KMS) zur Ansteuerung der Monitore erforderlich. Smithay bietet hierfür Hilfsmittel.

Die Wahl des Backends hat Auswirkungen auf die Systemanforderungen und die Komplexität der Implementierung. WGPU bietet potenziell breitere Kompatibilität und modernere Features, kann aber auch komplexer in der Handhabung sein.

### 5.4. Session & Permissions Integration

Wenn der Kompositor direkt auf der Hardware läuft (nicht verschachtelt), benötigt er spezielle Berechtigungen für den Zugriff auf Eingabe- und Ausgabegeräte (DRM/KMS, `libinput`). Diese Berechtigungen werden typischerweise über einen Session Manager wie `logind` (Teil von `systemd`) oder `seatd` (eine leichtere Alternative) verwaltet.

Die System-Schicht muss:

- Mit dem aktiven Session Manager über dessen D-Bus-Schnittstelle oder Client-Bibliothek kommunizieren.
- Geräte-Dateideskriptoren sicher öffnen und Berechtigungen wieder freigeben, wenn der Kompositor beendet wird oder die Sitzung wechselt.
- Auf Ereignisse wie Geräte-Hotplugging (An-/Abstecken von Monitoren, Mäusen etc.) und Sitzungswechsel reagieren.

Smithay bietet Unterstützung für die Integration mit `libinput` und DRM/KMS, oft in Verbindung mit `logind` oder `seatd`. Die korrekte Handhabung von Berechtigungen ist entscheidend für die Sicherheit und Stabilität des Systems.2

## 6. UI Layer Implementierung

### 6.1. Rendering Pipeline

Die UI-Schicht ist verantwortlich für das tatsächliche Zeichnen jedes Frames auf dem Bildschirm. Die Rendering-Pipeline umfasst typischerweise folgende Schritte:

1. **Szenenbeschreibung erstellen:** Basierend auf dem Zustand in der Domain-Schicht (Fensterpositionen, Z-Order, Sichtbarkeit, Workspace) und System-Schicht (verfügbare Client-Buffer) wird eine Liste der darzustellenden Elemente erstellt.
2. **Oberflächen durchlaufen:** Iteration durch die sichtbaren Oberflächen (Fenster, Layer-Shell-Elemente, Popups, Unteroberflächen) in der korrekten Z-Reihenfolge (von hinten nach vorne).3
3. **Oberflächeninhalte abrufen:** Zugriff auf die Texturen oder Pixeldaten der Oberflächen. Dies können SHM-Buffer sein, die auf die GPU hochgeladen werden müssen, oder direkt verwendbare DMA-BUF-Texturen.
4. **Komposition:** Zeichnen der Oberflächeninhalte auf den Ziel-Framebuffer (des Bildschirms). Dies beinhaltet Transformationen (Positionierung, Skalierung), Clipping und Blending (für Transparenz). Opake Regionen von Oberflächen können genutzt werden, um das Zeichnen dahinterliegender Oberflächen zu überspringen.3
5. **Shell-Elemente zeichnen:** Rendern von UI-Komponenten wie Panels, Cursor usw.
6. **Frame einreichen:** Übergabe des fertigen Frames an das Grafik-Backend zur Anzeige.

**Damage Tracking:** Ein entscheidender Aspekt für die Performance ist das Damage Tracking. Anstatt jeden Frame komplett neu zu zeichnen, sollten nur die Bereiche des Bildschirms aktualisiert werden, die sich seit dem letzten Frame geändert haben.3 Dies reduziert die GPU-Last und den Energieverbrauch erheblich.

Die Implementierung von Damage Tracking ist jedoch komplex:

- Es muss nicht nur der Inhalt von Oberflächen verfolgt werden (was Smithay teilweise für SHM-Buffer unterstützt), sondern auch Änderungen an der Szene selbst: Fensterbewegungen, Größenänderungen, das Erscheinen oder Verschwinden von Fenstern/Oberflächen.3
- Ein möglicher Algorithmus (angelehnt an 3):
    1. Sammle alle "beschädigten" Rechtecke auf dem Bildschirm: die Bounding Box von neuen Fenstern, die _alte_ Bounding Box von entfernten Fenstern, die _alte und neue_ Bounding Box von bewegten/skalierten Fenstern, und die von Clients gemeldeten Schadensregionen auf Oberflächen (übersetzt in globale Koordinaten).
    2. Optimiere optional die Liste der Schadensrechtecke (z. B. durch Zusammenfassen überlappender Rechtecke).
    3. Für jedes Schadensrechteck: Ermittle alle Oberflächen, die dieses Rechteck überlappen. Zeichne die relevanten Teile dieser Oberflächen (unter Berücksichtigung der Z-Order und opaker Regionen) innerhalb des Schadensrechtecks neu.

Die Implementierung von effektivem Damage Tracking erfordert sorgfältige Zustandsverwaltung (Speichern des vorherigen Frame-Zustands) und geometrische Berechnungen. Es ist keine triviale Optimierung, sondern ein Kernmerkmal für eine performante Desktop-Umgebung. Es sollte als eigenständiges, komplexes Teilprojekt betrachtet werden, das iterative Entwicklung, Tests und Performance-Profiling erfordert.

### 6.2. Desktop Shell Components

Die UI-Schicht implementiert die sichtbaren Komponenten der Desktop-Shell. Dazu gehören typischerweise:

- **Panel/Taskleiste:** Anzeige von laufenden Anwendungen, System-Tray, Uhrzeit, Menüs.
- **Application Launcher:** Menü oder Übersicht zum Starten von Anwendungen.
- **Notification System:** Anzeige von Benachrichtigungen von Anwendungen.
- **Background Manager:** Anzeige und Verwaltung des Desktophintergrunds.
- **Lock Screen:** Bildschirmsperre bei Inaktivität oder auf Anforderung.
- **Cursor:** Darstellung des Mauszeigers.

Diese Komponenten werden oft als spezielle Wayland-Clients implementiert, die das `wlr-layer-shell-unstable-v1`-Protokoll verwenden, um sich korrekt auf dem Bildschirm zu positionieren (z. B. Panel am oberen Rand), Platz zu reservieren (`exclusive_zone`) und Eingabeverhalten zu steuern.4 Alternativ könnten einige Komponenten direkt im Kompositor-Prozess gerendert werden, was jedoch die Modularität verringern kann. Die Wahl hängt von der gewünschten Architektur ab. Bestehende Werkzeuge oder Bibliotheken aus dem Ökosystem (z. B. Konzepte aus `wlr-screen-fade` 7 für Übergänge) könnten als Inspiration dienen oder wiederverwendet werden.

### 6.3. Client Toolkit Integration (Optional)

Wenn die Shell-Komponenten selbst mit einem UI-Toolkit (wie GTK, Qt oder einem Rust-basierten Toolkit) erstellt werden, muss die Integration dieses Toolkits mit Wayland berücksichtigt werden. Wenn diese Komponenten als separate Prozesse laufen, agieren sie als normale Wayland-Clients. Das `smithay-client-toolkit` 7 könnte relevant sein, wenn UI-Komponenten ebenfalls in Rust geschrieben werden und Wayland-Client-Funktionalität benötigen.

### 6.4. Theming and Configuration API

Die UI-Schicht muss Mechanismen zur Anpassung des Erscheinungsbilds und Verhaltens bereitstellen:

- **Theming:** Laden und Anwenden von visuellen Themen (Icons, Cursor-Themes, Stile für Shell-Komponenten). Dies erfordert definierte Schnittstellen und Konventionen für Theme-Dateien.
- **Konfiguration:** Eine API oder ein Mechanismus (z. B. D-Bus-Schnittstelle, Konfigurationsdateien), über den Benutzer oder Einstellungs-Tools das Verhalten der Desktop-Umgebung anpassen können (z. B. Tastenkürzel, Erscheinungsbild, Ausgabeeinstellungen, Panel-Konfiguration). Der Zustand dieser Konfiguration wird typischerweise in der Domain-Schicht gehalten, während die UI-Schicht ihn anwendet und ggf. Einstellungsdialoge bereitstellt.

## 7. Cross-Cutting Concerns Implementation Strategy

Diese Aspekte betreffen alle Schichten und erfordern eine konsistente Strategie.

### 7.1. API Design & Documentation

- **Interne APIs:** Es werden strenge Richtlinien für das Design interner Rust-APIs festgelegt (Modulstruktur, Namenskonventionen, Nutzung des Typsystems zur Sicherstellung von Invarianten, Sichtbarkeitsregeln).
- **Dokumentation:** Umfassende Dokumentation aller öffentlichen APIs, Module und komplexen Funktionen mittels `rustdoc` ist obligatorisch. Besonderes Augenmerk liegt auf der Dokumentation der Zustandsverwaltung, der erwarteten Invarianten, der Thread-Sicherheit (falls zutreffend) und potenzieller Fehlerbedingungen. Das Ziel ist eine Dokumentationsqualität ähnlich der von Smithay selbst.2

### 7.2. Error Handling Strategy

Aufbauend auf den grundlegenden Fehlertypen der Core-Schicht wird eine detaillierte Strategie definiert:

- **Fehler-Typen:** Spezifische Fehlertypen für jede Schicht oder Hauptkomponente können definiert werden, um den Ursprung von Fehlern besser zu lokalisieren.
- **Fehlerweitergabe:** Klare Regeln für die Weitergabe von Fehlern über Schichtgrenzen hinweg. Interne Fehler sollten geloggt werden, während Protokollfehler (durch fehlerhaftes Client-Verhalten) ggf. zum Schließen der Client-Verbindung führen (`wl_display.error`).
- **Graceful Degradation:** Wo möglich, sollte das System versuchen, bei Fehlern in nicht-kritischen Komponenten weiterzuarbeiten.
- **Ressourcenbereinigung:** Robuste Mechanismen (unterstützt durch Rusts RAII) zur Freigabe von Ressourcen (Speicher, Dateideskriptoren, Wayland-Objekte) im Fehlerfall sind essenziell.

### 7.3. Structured Logging Implementation

Das grundlegende Logging wird erweitert:

- **Strukturiertes Logging:** Konsequente Verwendung von strukturiertem Logging (z. B. mit `tracing` und Feldern), um Logs maschinenlesbar und leichter analysierbar zu machen. Wichtige Identifikatoren (z. B. Client-ID, Surface-ID) sollten in den Logs enthalten sein.
- **Log-Punkte:** Definierte Log-Punkte für kritische Ereignisse (z. B. Start/Ende von Rendering-Phasen, Fokuswechsel, Fenstererstellung/-zerstörung, wichtige Protokollanfragen, Fehler).
- **Dynamische Konfiguration:** Die Log-Levels sollten zur Laufzeit anpassbar sein, um die Fehlersuche im Betrieb zu erleichtern.

### 7.4. Testing Strategy

Ein mehrschichtiger Testansatz ist erforderlich:

- **Unit Tests:** Testen isolierter Funktionen und Module, insbesondere für die reine Logik in der Domain-Schicht (z. B. Fensterplatzierungsalgorithmen, Zustandsübergänge). Rusts integriertes Test-Framework (`#[test]`) wird hierfür genutzt.
- **Integration Tests:** Testen das Zusammenspiel von Komponenten innerhalb einer Schicht oder über Schichtgrenzen hinweg. Beispiel: Überprüfen, ob eine `xdg-toplevel.set_maximized`-Anfrage (System-Schicht) korrekt den Zustand des entsprechenden Fensters in der Domain-Schicht ändert.
- **End-to-End (E2E) Tests:** Testen vollständiger Benutzerszenarien aus der Sicht eines Clients oder Benutzers. Dies ist die komplexeste Testebene.
    - **Testumgebungen:** Ähnlich wie bei Smithays Beispielkompositor Anvil 2 sollten Tests in verschiedenen Umgebungen laufen können:
        - **Verschachtelt (Nested):** Ausführung des Kompositors als Client innerhalb einer bestehenden X11- oder Wayland-Sitzung (mittels `--winit` oder `--x11` Backends). Dies ist ideal für automatisierte Tests in CI/CD-Pipelines, da keine spezielle Hardware benötigt wird.
        - **TTY/DRM:** Ausführung direkt auf der Hardware (`--tty-udev` Backend). Notwendig, um die Interaktion mit DRM/KMS, `libinput` und die Sitzungsverwaltung zu testen.
    - **Test-Clients:** Verwendung von Standard-Wayland-Clients (`weston-terminal`, `gedit`, etc.), spezialisierten Test-Clients oder Frameworks (z. B. Wayland-Konformitätstestsuiten) zur Simulation von Client-Verhalten und Überprüfung der Protokollimplementierung. Spezifische Tests sind erforderlich, um die korrekte Handhabung von Protokoll-Nuancen wie der `xdg-decoration`-Aushandlung mit verschiedenen Clients (z. B. SDL-basierten 9) sicherzustellen.

Die Einrichtung und Wartung zuverlässiger Testumgebungen, insbesondere für E2E- und Hardware-Tests, stellt eine erhebliche Herausforderung dar. Die Komplexität ergibt sich aus der Abhängigkeit von spezifischer Hardware (GPUs), Kernel-Modulen (DRM), Systembibliotheken (`libinput`, EGL/WGPU, `libxkbcommon` 7) und dem Verhalten externer Clients.10 Daher müssen explizit Ressourcen für den Aufbau und die Pflege der Testinfrastruktur eingeplant werden. Dies umfasst CI-Pipelines, die verschachtelte Tests ausführen können, und potenziell dedizierte Test-Hardware für den TTY/DRM-Backend. Manuelle Testverfahren bleiben für Aspekte wie subjektive Benutzererfahrung oder schwer automatisierbare Szenarien (z. B. komplexe Multi-Monitor-Setups 10) notwendig.

### 7.5. _Wertvolle Tabelle:_ Komponenten-Teststrategie

|   |   |   |   |   |
|---|---|---|---|---|
|**Komponente/Modul**|**Unit Test Coverage**|**Integration Test Scenarios**|**E2E Test Scenarios**|**Spezifische Tools/Backends**|
|Event Loop (`calloop`)|Mittel|Hinzufügen/Entfernen von Quellen, Timer-Auslösung|Start/Stopp des Kompositors, Reaktion auf Signale|`calloop`-API, MPSC-Kanäle|
|Window Manager (Domain)|Hoch|Fenster erstellen/zerstören, Fokuswechsel, Geometrieänderung|Fenster überlappen, maximieren, minimieren, Workspace wechseln|Interne APIs, Mock-Oberflächen|
|XDG-Shell Handler (System)|Mittel|Client verbindet sich, erstellt Toplevel/Popup, sendet Requests|Starten/Bedienen einer XDG-Client-Anwendung (z. B. `gedit`)|Wayland Test Clients, `xdg-shell`-Protokolltests|
|Layer-Shell Handler (System)|Mittel|Client erstellt Layer Surface, setzt Anchor/Layer/Zone|Starten eines Panels/Docks (als Layer-Client), Interaktion mit normalen Fenstern|Wayland Test Clients (Layer Shell), `wlr-layer-shell`-Tests|
|Renderer (UI)|Niedrig|-|Fenster anzeigen, bewegen, Transparenz, Vollbild|Verschachtelte Backends (`--winit`, `--x11`), Visueller Vergleich|
|Damage Tracker (UI)|Mittel|Berechnung von Schadensregionen für Bewegung/Resize/Inhalt|Fenster bewegen/verändern, nur beschädigte Bereiche neu zeichnen (Profiling)|Verschachtelte Backends, Frame-Analyse-Tools, Profiler|
|Panel UI (UI/System)|Mittel|Interaktion mit Layer Shell, Klick-Handler|Panel anzeigen, Fensterliste aktualisieren, auf Klicks reagieren|Layer Shell Client, Verschachtelte Backends|
|Input Handling (System)|Mittel|Verarbeitung von `libinput`-Events, Weiterleitung an Domain|Tippen in fokussiertem Fenster, Mausbewegung, Klicks|Mock `libinput`, Wayland Test Clients|

_Coverage: Ziel-Codeabdeckung (%), Schlüsselbereiche_

### 7.6. Dependency Management

- **Rust Crates:** Abhängigkeiten werden über `Cargo.toml` verwaltet. Es wird eine Strategie für regelmäßige Updates (`cargo update`) und die Überprüfung auf bekannte Sicherheitslücken benötigt. Tools wie `cargo-deny` oder externe Dienste (wie der in 2 erwähnte) können zur Überwachung eingesetzt werden. Die Auswahl der Abhängigkeiten sollte deren Wartungszustand und Popularität berücksichtigen.2
- **System Dependencies:** Externe Bibliotheken wie `libwayland-client`, `libwayland-server`, `libxkbcommon`, `pkg-config`, `libinput`, EGL/OpenGL/Vulkan-Loader und Treiber müssen auf dem Zielsystem vorhanden sein.7 Der Build-Prozess muss diese Abhängigkeiten überprüfen (z. B. mittels `pkg-config`). Dokumentation und ggf. Build-Skripte müssen die Installation dieser Abhängigkeiten erleichtern.

### 7.7. Build System & CI/CD

- **Build System:** Der Standard `cargo build`-Prozess wird verwendet. Build-Profile (Debug, Release) werden konfiguriert.
- **Continuous Integration (CI):** Eine CI-Pipeline (z. B. GitHub Actions, GitLab CI) wird eingerichtet. Diese sollte bei jedem Commit/Pull Request automatisch:
    - Den Code kompilieren (`cargo build`).
    - Linting-Checks durchführen (`cargo clippy`).
    - Code formatieren (`cargo fmt --check`).
    - Unit- und Integrationstests ausführen (`cargo test`).
    - Idealerweise E2E-Tests in einer verschachtelten Umgebung durchführen.
- **Continuous Deployment (CD):** Optional kann eine CD-Pipeline eingerichtet werden, um z. B. Nightly Builds oder Releases automatisch zu erstellen und zu veröffentlichen.

## 8. Implementation Phasing & High-Level Roadmap

### 8.1. Logical Sequencing

Eine phasierte Implementierung wird vorgeschlagen, um schrittweise Funktionalität aufzubauen und frühes Feedback zu ermöglichen:

- **Phase 1 (Core Setup & Grundstruktur):**
    - Projekt-Setup (Repository, Lizenz, Readme).
    - Implementierung der Core-Schicht: `calloop`-Ereignisschleife, grundlegende Wayland-Verbindung, Logging, Fehlerbehandlung.
    - Einrichtung des Build-Systems und der CI-Pipeline.
    - _Ziel:_ Kompositor startet, verbindet sich mit Wayland (als Client), loggt Nachrichten und kann beendet werden.
- **Phase 2 (System Basics & Rendering-Grundlagen):**
    - Implementierung der System-Schicht-Grundlagen: Grafik-Backend-Initialisierung (z. B. EGL/WGPU), grundlegende DRM/KMS-Integration (falls TTY-Backend benötigt wird).
    - Implementierung wesentlicher Wayland-Protokolle: `wl_compositor`, `wl_output`, `wl_seat`.
    - Minimales Rendering: Fähigkeit, einen einfarbigen Hintergrund oder einen einfachen Client-Buffer anzuzeigen.
    - _Ziel:_ Ein minimaler Wayland-Client (z. B. `weston-simple-shm`) kann sich verbinden und seine Oberfläche wird angezeigt.
- **Phase 3 (Domain & Windowing):**
    - Implementierung der Domain-Schicht: `CompositorState` 1, Fenstermanagement-Abstraktion (Geometrie, Fokus).
    - Implementierung von `xdg-shell` (Toplevels).
    - Grundlegende Fensterinteraktion: Fenster verschieben, Größe ändern (initial ohne Client-Feedback), Fokus per Klick setzen.
    - _Ziel:_ Mehrere `xdg-shell`-Clients können gestartet, angezeigt und rudimentär manipuliert werden.
- **Phase 4 (UI & Shell-Grundlagen):**
    - Implementierung der Rendering-Pipeline mit Komposition mehrerer Oberflächen.
    - Implementierung von grundlegendem Damage Tracking.3
    - Implementierung von `wlr-layer-shell`.4
    - Entwicklung erster Shell-Komponenten (z. B. Hintergrundmanager, einfaches Panel als Layer-Shell-Client).
    - Implementierung von `xdg-popup` und `xdg-decoration` (mit korrekter Aushandlung 9).
    - _Ziel:_ Eine grundlegende Desktop-Shell ist sichtbar, Fenster haben Dekorationen (CSD/SSD), Popups funktionieren.
- **Phase 5 (Advanced Features & Polish):**
    - Implementierung weiterer Wayland-Protokolle (Datenübertragung, etc.).
    - Verbessertes Damage Tracking und Performance-Optimierungen.
    - Vollständige Implementierung aller geplanten Shell-Features (Launcher, Notifications, etc.).
    - Implementierung von Theming und Konfigurationsmechanismen.
    - Umfassende Tests (insbesondere E2E und auf Hardware).
    - Dokumentation vervollständigen.
    - _Ziel:_ Eine funktionsreiche, performante und stabile Desktop-Umgebung.

### 8.2. Key Milestones

Messbare Meilensteine für jede Phase:

- **M1 (Ende Phase 1):** Kompositor läuft stabil in verschachtelter Umgebung, grundlegendes Logging funktioniert, CI ist grün.
- **M2 (Ende Phase 2):** Ein einfacher SHM-Client wird korrekt angezeigt (verschachtelt und/oder TTY). `wl_output` und `wl_seat` sind funktional.
- **M3 (Ende Phase 3):** Mehrere `xdg-toplevel`-Fenster können angezeigt, verschoben und fokussiert werden.
- **M4 (Ende Phase 4):** Grundlegendes Damage Tracking ist aktiv. Ein Panel (Layer Shell) ist sichtbar. Fensterdekorationen (CSD/SSD) funktionieren gemäß Aushandlung. Popups werden korrekt angezeigt.
- **M5 (Ende Phase 5):** Alle Kernfunktionen sind implementiert und getestet. Die Performance ist akzeptabel. Theming und Konfiguration sind möglich.

## 9. Schlussfolgerung

### 9.1. Zusammenfassung

Dieser Plan skizziert einen detaillierten, schichtweisen Ansatz zur Implementierung einer modernen Linux-Desktop-Umgebung. Er basiert auf der Verwendung von Wayland als Protokoll, Rust als Sprache und der Smithay-Bibliothek als Fundament.1 Der Fokus liegt auf Modularität, klarer Trennung der Verantwortlichkeiten zwischen den Schichten (Core, Domain, System, UI), Robustheit durch sorgfältige Fehlerbehandlung und umfassende Tests sowie Performance durch Techniken wie Damage Tracking.3 Besondere Aufmerksamkeit gilt der korrekten Implementierung von Wayland-Protokollen unter Berücksichtigung ihrer Semantik und potenzieller Client-Verhaltensweisen 9, der Notwendigkeit klar definierter interner Abstraktionen (z. B. Fenstermanagement) 1 und der Komplexität der Integration verschiedener Systemkomponenten wie der Ereignisschleife 5 und Testumgebungen.2

### 9.2. Nächste Schritte

Die unmittelbaren nächsten Schritte zur Umsetzung dieses Plans sind:

1. **Projekt-Setup:** Erstellung des Code-Repositorys, Wahl einer Lizenz, Einrichtung der grundlegenden Projektstruktur und der CI/CD-Pipeline gemäß Phase 1.
2. **Team-Briefing:** Vorstellung und Diskussion dieses Implementierungsplans mit dem Entwicklungsteam, um ein gemeinsames Verständnis der Architektur und der Vorgehensweise sicherzustellen.
3. **Beginn Phase 1:** Start der Implementierung der Core-Schicht-Komponenten (Ereignisschleife, Logging, Fehlerbehandlung).
4. **Spezifikationsverfeinerung:** Ggf. Verfeinerung der technischen Gesamtspezifikation basierend auf ersten Erkenntnissen aus der Prototypenentwicklung und der detaillierten Planung in diesem Dokument.
5. **Technologie-Evaluation (falls nötig):** Finale Entscheidung über spezifische Technologien (z. B. Grafik-Backend WGPU vs. EGL/GLES), falls noch nicht festgelegt.

Die konsequente Verfolgung dieses Plans, kombiniert mit agilen Praktiken zur Anpassung an neue Erkenntnisse, legt den Grundstein für die erfolgreiche Entwicklung einer robusten und performanten Linux-Desktop-Umgebung.

**Grundlegende Kommunikationsprinzipien**

Die Architektur von NovaDE basiert auf fundamentalen Kommunikations- und Strukturprinzipien, die ein robustes, modulares und wartbares System gewährleisten sollen.

1. **API-basierte Interaktion:** Die Kommunikation zwischen den Schichten – Kern (Core), Domäne (Domain), System und Benutzeroberfläche (UI) – erfolgt primär über klar definierte öffentliche Programmierschnittstellen (APIs). Diese APIs werden in der Regel als Rust-Traits spezifiziert und von Service-Strukturen innerhalb der jeweiligen Schicht implementiert. Dies fördert ein vertragsbasiertes Interaktionsmodell.
2. **Ereignisgesteuertes System:** Ein robustes, ereignisgesteuertes System dient der Benachrichtigung über Zustandsänderungen und ermöglicht entkoppelte Interaktionen. Komponenten können auf relevante Ereignisse reagieren, ohne direkte Abhängigkeiten zu den Ereigniserzeugern aufzubauen. Dies ist besonders für die UI-Schicht wichtig, um reaktive Updates zu ermöglichen. Für die Event-Kommunikation wird `tokio::sync::broadcast` als bevorzugter Mechanismus für die Verteilung von Events spezifiziert.
3. **Strikte Schichtenhierarchie:** Höhere Schichten dürfen typischerweise nur von unmittelbar tieferliegenden Schichten abhängen, um zirkuläre Abhängigkeiten und unkontrollierte Interaktionen zu verhindern.
4. **Fehlerbehandlung:** Eine konsistente Fehlerbehandlungsstrategie wird über alle Schichten hinweg angewendet. Die `thiserror`-Bibliothek wird für die Definition von spezifischen, benutzerdefinierten Fehlertypen genutzt. `core::errors::CoreError` dient als fundamentaler Basistyp. Fehlerketten (`source()`) müssen bei der Weitergabe oder beim Wrappen von Fehlern erhalten bleiben. Panics sind strikt zu vermeiden.

## 1. Schnittstelle: Kernschicht (Core Layer) zu höheren Schichten (Domäne, System, UI)

Die Kernschicht stellt fundamentale Bausteine und Dienste bereit, die von allen darüberliegenden Schichten genutzt werden.

### 1.1. Bereitgestellte Funktionalität durch die Kernschicht

Die Kernschicht exportiert die folgenden Module und deren öffentliche APIs:

#### 1.1.1. `core::types`

- **Schnittstelle**: Direkte Verwendung von Typen durch die höheren Schichten.
- **Definierte Typen (Ultra-Fein)**:
    - `Point<T>`: Repräsentiert einen Punkt im 2D-Raum.
        - Felder: `pub x: T`, `pub y: T`.
        - Methoden: `new(x: T, y: T) -> Self`, `distance_squared(...)`, `distance(...)` (für Float-Typen), `manhattan_distance(...)`.
        - Assoziierte Konstanten: `ZERO_I32`, `ZERO_F32`, etc..
        - Generische Parameter: `T` (Basis-Constraints: `Copy + Debug + PartialEq + Default + Send + Sync + 'static`).
    - `Size<T>`: Repräsentiert eine 2D-Dimension.
        - Felder: `pub width: T`, `pub height: T`.
        - Methoden: `new(width: T, height: T) -> Self`, `area()`, `is_empty()`, `is_valid()`.
        - Assoziierte Konstanten: `ZERO_I32`, `ZERO_F32`, etc..
    - `Rect<T>`: Repräsentiert ein 2D-Rechteck.
        - Felder: `pub origin: Point<T>`, `pub size: Size<T>`.
        - Methoden: `new(...)`, `from_coords(...)`, Getter (`x`, `y`, `width`, `height`, `top`, `left`, `bottom`, `right`), `center()`, `contains_point(...)`, `intersects(...)`, `intersection(...)`, `union(...)`, `translated(...)`, `scaled(...)`, `is_valid()`.
    - `RectInt`: Typalias für `Rect<i32>` oder spezifische Struktur mit `x: i32, y: i32, width: u32, height: u32`. Bietet Methoden wie `inflate`, `translate`. Verwendet `saturating_add/sub` für Robustheit.
    - `Color`: Repräsentiert eine RGBA-Farbe.
        - Felder: `pub r: f32`, `pub g: f32`, `pub b: f32`, `pub a: f32` (Wertebereich `[0.0, 1.0]`).
        - Methoden: `new(r,g,b,a)` (klemmt Werte), `from_rgba8(...)`, `to_rgba8()`, `with_alpha(...)`, `blend(...)`, `lighten(...)`, `darken(...)`, `interpolate(...)`, `from_hex(...) -> Result<Self, ColorParseError>`, `to_hex_string(...)`.
        - Implementiert `Default` (z.B. `Color::TRANSPARENT`) und `Serialize`/`Deserialize` als Hex-String.
    - `Orientation`: Enum (`Horizontal`, `Vertical`) mit `toggle()` Methode und `Default` (Horizontal).
    - `uuid::Uuid`: Re-exportiert für eindeutige Identifikatoren.
    - `chrono::DateTime<Utc>`: Re-exportiert für Zeitstempel.
- **Nutzung**: Diese Typen werden direkt in den öffentlichen APIs und internen Logiken der höheren Schichten verwendet.

#### 1.1.2. `core::errors`

- **Schnittstelle**: Höhere Schichten wrappen Fehler aus der Kernschicht (z.B. `CoreError` oder spezifischere Modul-Fehler wie `ColorParseError`) mittels `#[from]` oder `#[source]` in ihre eigenen Fehlertypen. Die Fehlerkette (`source()`) wird beibehalten.
- **Definierte Typen (Ultra-Fein)**:
    - `CoreError`: Basis-Fehlertyp der Kernschicht.
        - Varianten: `InitializationFailed { component: String, source: Option<Box<dyn std::error::Error>> }`, `Io { path: PathBuf, source: std::io::Error }`, `Serialization { description: String, source: Option<Box<dyn std::error::Error>> }`, `Deserialization { ... }`, `InvalidId { invalid_id: String }`, `NotFound { resource_description: String }`, `CoreConfigError { message: String, source: Option<Box<dyn std::error::Error>> }`, `InternalError(String)`.
    - `ColorParseError`: Fehler beim Parsen von Hex-Farbcodes.
        - Varianten: `InvalidHexFormat(String)`, `InvalidHexDigit(String, source: std::num::ParseIntError)`, `InvalidHexLength(String)`.
- **Nutzung**: Jedes Modul, auch in höheren Schichten, definiert sein eigenes Fehler-Enum mit `thiserror` und integriert Fehler aus tieferen Schichten oder Bibliotheken.

#### 1.1.3. `core::logging`

- **Schnittstelle**:
    - `pub fn initialize_logging(level_filter: tracing::LevelFilter, format: LogFormat) -> Result<(), LoggingError>`: Einmaliger Aufruf beim Anwendungsstart.
        - `LogFormat`: Enum (`PlainTextDevelopment`, `JsonProduction`).
        - `LoggingError`: Enum (`SetGlobalDefaultError(String)`, `InitializationError(String)`).
    - Verwendung der `tracing`-Makros (`trace!`, `info!`, `warn!`, `error!`, `#[tracing::instrument]`) durch alle höheren Schichten.
- **Nutzung**: Alle Schichten nutzen `tracing`-Makros. Sensible Daten dürfen nicht geloggt werden.

#### 1.1.4. `core::config`

- **Schnittstelle**:
    - `pub fn load_core_config(config_paths: &[PathBuf]) -> Result<CoreConfig, ConfigError>`: Lädt Konfiguration aus TOML-Dateien in der angegebenen Reihenfolge.
    - `pub fn initialize_global_core_config(config: CoreConfig) -> Result<(), ConfigError>`: Initialisiert die globale Konfiguration einmalig.
    - `pub fn get_global_core_config() -> &'static CoreConfig`: Globaler, schreibgeschützter Zugriff auf die geladene `CoreConfig` (via `once_cell`).
- **Definierte Typen (Ultra-Fein)**:
    - `CoreConfig`: Struktur, die alle Kernschicht-spezifischen Einstellungen hält (z.B. `log_level: LogLevelConfig`, `feature_flags: FeatureFlags`). Implementiert `Deserialize`, `Default`. Verwendet `#[serde(default = "path")]` und `#[serde(deny_unknown_fields)]`.
    - `ConfigError`: Fehler beim Laden/Parsen der Konfiguration.
        - Varianten: `FileReadError { path: PathBuf, source: std::io::Error }`, `DeserializationError { path: PathBuf, source: toml::de::Error }`, `NoConfigurationFileFound { checked_paths: Vec<PathBuf> }`, `AlreadyInitializedError`, `NotInitializedError`.
- **Nutzung**: Domänenschicht (z.B. `domain::settings_persistence_iface`) kann Kernschicht-Dienste zum Lesen/Schreiben von Konfigurationsdateien nutzen, aber die `CoreConfig` selbst wird nach Initialisierung als unveränderlich betrachtet.

#### 1.1.5. `core::utils`

- **Schnittstelle**: Direkte Nutzung der öffentlichen, zustandslosen Hilfsfunktionen durch alle höheren Schichten.
- **Beispielhafte Utilities**:
    - `path_utils::normalize_path_robustly(...)`
    - `string_utils::sanitize_filename(...)`, `truncate_string_with_ellipsis(...)`
    - Fehlerbehandlung: Jede fehleranfällige Utility-Funktion gibt `Result<T, YourUtilError>` zurück.

## 2. Schnittstelle: Domänenschicht (Domain Layer) zu Systemschicht und Benutzeroberflächenschicht

Die Domänenschicht kapselt die Geschäftslogik und den Kernzustand von NovaDE. Sie interagiert nicht direkt mit Hardware oder OS-Details.

### 2.1. Bereitgestellte Funktionalität durch die Domänenschicht

Die Domänenschicht stellt ihre Logik und Zustandsinformationen über öffentliche APIs ihrer Service-Komponenten (Rust-Traits) und durch domänenspezifische Events bereit.

#### 2.1.1. Traits für Service-APIs (asynchron via `async_trait`)

- **`domain::theming::ThemingEngine` Trait**
    - Methoden:
        - `async fn get_current_theme_state(&self) -> Result<AppliedThemeState, ThemingError>`
        - `async fn get_available_themes(&self) -> Result<Vec<ThemeDefinition>, ThemingError>`
        - `async fn get_current_configuration(&self) -> Result<ThemingConfiguration, ThemingError>`
        - `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
        - `async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`
        - `fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeChangedEvent>`
- **`domain::workspaces::WorkspaceManagerService` Trait**
    - Methoden:
        - `async fn create_workspace(&self, name: Option<String>, persistent_id: Option<String>, icon_name: Option<String>, accent_color_hex: Option<String>) -> Result<WorkspaceId, WorkspaceManagerError>`
        - `async fn delete_workspace(&self, id: WorkspaceId, fallback_id_for_windows: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError>`
        - `fn get_workspace(&self, id: WorkspaceId) -> Option<Workspace>` (gibt Klon)
        - `fn all_workspaces_ordered(&self) -> Vec<Workspace>` (gibt Klone)
        - `fn active_workspace_id(&self) -> Option<WorkspaceId>`
        - `async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
        - `async fn assign_window_to_active_workspace(&self, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
        - `async fn assign_window_to_specific_workspace(&self, workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
        - `async fn remove_window_from_its_workspace(&self, window_id: &WindowIdentifier) -> Result<Option<WorkspaceId>, WorkspaceManagerError>`
        - `async fn move_window_to_specific_workspace(&self, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
        - `async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`
        - `async fn set_workspace_layout(&self, id: WorkspaceId, layout_type: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>`
        - `async fn set_workspace_icon(&self, id: WorkspaceId, icon_name: Option<String>) -> Result<(), WorkspaceManagerError>`
        - `async fn set_workspace_accent_color(&self, id: WorkspaceId, color_hex: Option<String>) -> Result<(), WorkspaceManagerError>`
        - `async fn save_configuration(&self) -> Result<(), WorkspaceManagerError>`
        - `fn subscribe_to_workspace_events(&self) -> tokio::sync::broadcast::Receiver<WorkspaceEvent>`
        - `async fn reorder_workspace(&self, workspace_id: WorkspaceId, new_index: usize) -> Result<(), WorkspaceManagerError>`
- **`domain::user_centric_services::ai_interaction::AIInteractionLogicService` Trait**
    - Methoden:
        - `async fn initiate_interaction(&mut self, relevant_categories: Vec<AIDataCategory>, initial_attachments: Option<Vec<AttachmentData>>) -> Result<Uuid, AIInteractionError>`
        - `async fn get_interaction_context(&self, context_id: Uuid) -> Result<AIInteractionContext, AIInteractionError>`
        - `async fn provide_consent(&mut self, context_id: Uuid, model_id: String, granted_categories: Vec<AIDataCategory>, consent_decision: bool) -> Result<(), AIInteractionError>`
        - `async fn get_consent_status_for_interaction(&self, context_id: Uuid, model_id: &str, required_categories: &[AIDataCategory]) -> Result<AIConsentStatus, AIInteractionError>`
        - `async fn add_attachment_to_context(&mut self, context_id: Uuid, attachment: AttachmentData) -> Result<(), AIInteractionError>`
        - `async fn list_available_models(&self) -> Result<Vec<AIModelProfile>, AIInteractionError>`
        - `async fn get_default_model(&self) -> Result<Option<AIModelProfile>, AIInteractionError>`
        - `async fn update_interaction_history(&mut self, context_id: Uuid, entry: InteractionHistoryEntry) -> Result<(), AIInteractionError>`
        - (Persistenz-bezogene Methoden wie `store_consent`, `get_all_user_consents`, `load_model_profiles` werden über separate Provider-Traits abgewickelt: `AIConsentProvider`, `AIModelProfileProvider`)
- **`domain::user_centric_services::notifications_core::NotificationService` Trait**
    - Methoden:
        - `async fn post_notification(&mut self, notification_data: NotificationInput) -> Result<Uuid, NotificationError>`
        - `async fn get_active_notification(&self, notification_id: Uuid) -> Result<Option<Notification>, NotificationError>`
        - `async fn mark_as_read(&mut self, notification_id: Uuid) -> Result<(), NotificationError>`
        - `async fn dismiss_notification(&mut self, notification_id: Uuid, reason: DismissReason) -> Result<(), NotificationError>`
        - `async fn get_active_notifications(&self, filter: Option<NotificationFilterCriteria>, sort_order: Option<NotificationSortOrder>) -> Result<Vec<Notification>, NotificationError>`
        - `async fn get_notification_history(&self, limit: Option<usize>, filter: Option<NotificationFilterCriteria>, sort_order: Option<NotificationSortOrder>) -> Result<Vec<Notification>, NotificationError>`
        - `async fn clear_history(&mut self) -> Result<(), NotificationError>`
        - `async fn clear_all_for_app(&mut self, app_id: &ApplicationId) -> Result<usize, NotificationError>`
        - `async fn set_do_not_disturb(&mut self, enabled: bool) -> Result<(), NotificationError>`
        - `async fn is_do_not_disturb_enabled(&self) -> Result<bool, NotificationError>`
        - `async fn invoke_action(&mut self, notification_id: Uuid, action_key: &str) -> Result<(), NotificationError>`
        - `async fn get_stats(&self) -> Result<NotificationStats, NotificationError>`
- **`domain::global_settings_and_state_management::GlobalSettingsService` Trait**
    - Methoden:
        - `async fn load_settings(&mut self) -> Result<(), GlobalSettingsError>`
        - `async fn save_settings(&self) -> Result<(), GlobalSettingsError>`
        - `fn get_current_settings(&self) -> GlobalDesktopSettings`
        - `async fn update_setting(&mut self, path: SettingPath, value: serde_json::Value) -> Result<(), GlobalSettingsError>`
        - `fn get_setting(&self, path: &SettingPath) -> Result<serde_json::Value, GlobalSettingsError>`
        - `async fn reset_to_defaults(&mut self) -> Result<(), GlobalSettingsError>`
        - `fn subscribe_to_setting_changes(&self) -> tokio::sync::broadcast::Receiver<SettingChangedEvent>`
- **`domain::notifications_rules::NotificationRulesEngine` Trait**
    - Methoden:
        - `async fn reload_rules(&self) -> Result<(), NotificationRulesError>`
        - `async fn process_notification(&self, notification: Notification) -> Result<RuleProcessingResult, NotificationRulesError>`
        - `async fn get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`
        - `async fn update_rules(&self, new_rules: NotificationRuleSet) -> Result<(), NotificationRulesError>`
- **`domain::window_management_policy::WindowManagementPolicyService` Trait**
    - Methoden:
        - `async fn calculate_workspace_layout(&self, workspace_id: WorkspaceId, windows_to_layout: &[WindowLayoutInfo], available_area: RectInt, workspace_current_tiling_mode: TilingMode, focused_window_id: Option<&WindowIdentifier>, window_specific_overrides: &HashMap<WindowIdentifier, WindowPolicyOverrides>) -> Result<WorkspaceWindowLayout, WindowPolicyError>`
        - `async fn get_initial_window_geometry(&self, window_info: &WindowLayoutInfo, is_transient_for: Option<&WindowIdentifier>, parent_geometry: Option<RectInt>, workspace_id: WorkspaceId, active_layout_on_workspace: &WorkspaceWindowLayout, available_area: RectInt, window_specific_overrides: &Option<WindowPolicyOverrides>) -> Result<RectInt, WindowPolicyError>`
        - `async fn calculate_snap_target(&self, moving_window_id: &WindowIdentifier, current_geometry: RectInt, other_windows_on_workspace: &[(&WindowIdentifier, &RectInt)], workspace_area: RectInt, snapping_policy: &WindowSnappingPolicy, gap_settings: &GapSettings) -> Option<RectInt>`
        - `async fn get_effective_tiling_mode_for_workspace(&self, workspace_id: WorkspaceId) -> Result<TilingMode, WindowPolicyError>`
        - `async fn get_effective_gap_settings_for_workspace(&self, workspace_id: WorkspaceId) -> Result<GapSettings, WindowPolicyError>`
        - (Weitere Methoden zum Abruf von Teil-Policies)

#### 2.1.2. Datenstrukturen (Öffentlich exportierte Typen aus der Domänenschicht)

- **`domain::theming::types`**: `AppliedThemeState`, `ThemeDefinition`, `ThemingConfiguration`, `TokenIdentifier`, `ThemeIdentifier`, `ColorSchemeType`, `AccentColor` (mit `novade_core::types::Color`).
- **`domain::workspaces::core::types`**: `WorkspaceId`, `WindowIdentifier`, `WorkspaceLayoutType`.
- **`domain::workspaces::core`**: `Workspace` (mit `icon_name`, `accent_color_hex`).
- **`domain::user_centric_services::ai_interaction::types`**: `AIInteractionContext` (mit `InteractionHistoryEntry`), `AIConsent` (mit `AIConsentScope`), `AIModelProfile` (mit `AIModelCapability`), `AttachmentData`, `AIConsentStatus`, `AIDataCategory`.
- **`domain::user_centric_services::notifications_core::types`**: `Notification` (mit `category`, `hints`, `timeout_ms`), `NotificationAction`, `NotificationUrgency`, `NotificationActionType`, `NotificationInput`, `NotificationFilterCriteria`, `NotificationSortOrder`, `DismissReason`.
- **`domain::global_settings_and_state_management::types`**: `GlobalDesktopSettings` (und alle untergeordneten Einstellungs-Structs wie `AppearanceSettings`, `InputBehaviorSettings`), `SettingPath`-Enum-Hierarchie.
- **`domain::notifications_rules::types`**: `RuleConditionValue`, `RuleConditionOperator`, `RuleConditionField`, `SimpleRuleCondition`, `RuleCondition`, `RuleAction`, `NotificationRule`, `NotificationRuleSet`, `RuleProcessingResult`.
- **`domain::window_management_policy::types`**: `TilingMode`, `GapSettings`, `WindowSnappingPolicy`, `WindowGroupingPolicy`, `NewWindowPlacementStrategy`, `FocusStealingPreventionLevel`, `FocusPolicy`, `WindowPolicyOverrides`, `WorkspaceWindowLayout`, `WindowLayoutInfo`.
- **`domain::shared_types`**: `ApplicationId`, `UserSessionState`, `ResourceIdentifier`.

#### 2.1.3. Events (Domänenspezifisch, via `tokio::sync::broadcast`)

- **`domain::theming`**: `ThemeChangedEvent { new_state: AppliedThemeState }`.
- **`domain::workspaces::manager::events`**: `WorkspaceEvent` Enum (z.B. `WorkspaceCreated { descriptor }`, `ActiveWorkspaceChanged { old_id, new_id, new_descriptor }`, `WindowAssignedToWorkspace { ... }`, `WorkspaceIconChanged`, `WorkspaceAccentChanged`, `WorkspaceOrderChanged`).
- **`domain::user_centric_services::events`**: Wrapper-Enums `AIInteractionEventEnum` und `NotificationEventEnum`.
    - `AIInteractionEventEnum`: `AIInteractionInitiatedEvent { context }`, `AIConsentUpdatedEvent { ... }`, `AIContextUpdatedEvent { ... }`, `AIModelProfilesReloadedEvent { ... }`.
    - `NotificationEventEnum`: `NotificationPostedEvent { notification, suppressed_by_dnd }`, `NotificationDismissedEvent { notification_id, reason }`, `NotificationReadEvent { ... }`, `DoNotDisturbModeChangedEvent { ... }`, `NotificationActionInvokedEvent { ... }`, `NotificationHistoryClearedEvent`, `NotificationPopupExpiredEvent { ... }`.
- **`domain::global_settings_and_state_management`**: `SettingChangedEvent { path: SettingPath, new_value: serde_json::Value }`, `SettingsLoadedEvent { settings: GlobalDesktopSettings }`, `SettingsSavedEvent`.
- **`domain::common_events`**: `UserActivityDetectedEvent { timestamp, activity_type, ... }`, `SystemShutdownInitiatedEvent { reason, is_reboot, ... }`.

#### 2.1.4. Fehlertypen (Modulspezifisch via `thiserror`)

- `domain::theming::errors::ThemingError`.
- `domain::workspaces::core::errors::WorkspaceCoreError`, `assignment::errors::WindowAssignmentError`, `manager::errors::WorkspaceManagerError`, `config::errors::WorkspaceConfigError`.
- `domain::user_centric_services::ai_interaction::errors::AIInteractionError`, `notifications_core::errors::NotificationError`.
- `domain::global_settings_and_state_management::errors::GlobalSettingsError`.
- `domain::notifications_rules::errors::NotificationRulesError`.
- `domain::window_management_policy::errors::WindowPolicyError`.

### 2.2. Nutzung durch die Systemschicht

- **Anwendung von Domänenregeln**: Die Systemschicht setzt Domänenrichtlinien technisch um.
    - `system::window_mechanics` nutzt `WindowManagementPolicyService::calculate_workspace_layout()` und andere Methoden, um Fenstergeometrien und -verhalten zu bestimmen und anzuwenden.
    - Der `system::compositor` und seine Submodule (z.B. für XDG-Shell, Layer-Shell) interagieren mit `WindowManagementPolicyService` und `WorkspaceManagerService` für Platzierung, Stapelreihenfolge und Sichtbarkeit von Fenstern/Surfaces.
- **Abfrage von Zuständen und Konfigurationen**:
    - `system::mcp_client` interagiert mit `AIInteractionLogicService` für Einwilligungsprüfungen, Modellprofile und Kontextmanagement.
    - `system::dbus::notifications_server` (D-Bus Implementierung von `org.freedesktop.Notifications`) leitet Anfragen an den `NotificationService` weiter und reagiert auf dessen Events, um D-Bus Signale zu senden.
    - Systemkomponenten wie `system::power_management` oder `system::audio_management` können relevante Einstellungen vom `GlobalSettingsService` beziehen.
- **Event-Konsum und -Weiterleitung**: Die Systemschicht kann auf Domänen-Events reagieren (z.B. `ActiveWorkspaceChanged`, `SettingChangedEvent` für themenrelevante Einstellungen) und diese ggf. in systemnahe Aktionen übersetzen oder an die UI-Schicht weiterleiten, wenn sie systemweite Auswirkungen haben (z.B. über den `SystemEventBridge`).
- **Fehlerbehandlung**: Fehler aus der Domänenschicht werden von der Systemschicht gefangen, ggf. in systemspezifische Fehler gewrappt und an die UI-Schicht oder interne Logging-Mechanismen weitergeleitet.

### 2.3. Nutzung durch die Benutzeroberflächenschicht (UI Layer)

- **Zustandsdarstellung**: Die UI-Schicht visualisiert Zustände und Daten aus der Domänenschicht.
    - `ui::theming_gtk` verwendet `ThemingEngine::get_current_theme_state()` und abonniert `ThemeChangedEvent`, um CSS-Stile anzuwenden.
    - `ui::shell` (z.B. Workspace-Switcher, Panel-Elemente) und `ui::control_center` nutzen `WorkspaceManagerService` und `GlobalSettingsService` intensiv zur Anzeige und Modifikation.
    - UI-Elemente für KI-Interaktionen (Befehlspalette, Assistenz-Widgets) nutzen `AIInteractionLogicService`.
    - Das `ui::notifications_frontend` (Popups, Notification-Center) nutzt `NotificationService` und reagiert auf dessen Events.
- **Auslösen von Geschäftslogik**: Benutzerinteraktionen in der UI werden in Aufrufe an Domänen-Service-Methoden übersetzt.
- **Event-Konsum**: Die UI-Schicht ist ein primärer Konsument von Domänen-Events, um sich dynamisch zu aktualisieren.
- **Fehlerbehandlung**: Fehler von Domänendiensten werden von der UI gefangen und in benutzerfreundliche Nachrichten oder Aktionen übersetzt.

## 3. Schnittstelle: Systemschicht (System Layer) zu Benutzeroberflächenschicht (UI Layer)

Die Systemschicht stellt der UI-Schicht systemnahe Dienste und Ereignisse zur Verfügung und setzt deren UI-initiierte Befehle technisch um.

### 3.1. Bereitgestellte Funktionalität durch die Systemschicht

#### 3.1.1. Traits für Service-APIs (asynchron via `async_trait`)

- **`system::compositor::CompositorInterface` (Beispielhafter Trait-Name)**
    - Methoden (Beispiele):
        - `fn request_focus(&self, window_id: novade_core::types::WindowId) -> Result<(), CompositorError>`
        - `fn configure_window(&self, window_id: novade_core::types::WindowId, config: WindowConfigurationRequest) -> Result<(), CompositorError>`
        - `fn get_window_info(&self, window_id: novade_core::types::WindowId) -> Result<Option<WindowInfo>, CompositorError>`
        - `fn list_managed_windows(&self) -> Result<Vec<WindowInfo>, CompositorError>`
        - `fn list_outputs(&self) -> Result<Vec<OutputInfo>, CompositorError>`
        - `fn subscribe_to_compositor_events(&self) -> tokio::sync::broadcast::Receiver<CompositorEvent>`
- **`system::input::InputInterface` (Beispielhafter Trait-Name)**
    - Methoden (Beispiele):
        - `fn set_cursor_theme(&self, theme_name: String, size: u32) -> Result<(), InputError>`
        - `fn get_current_keyboard_layout(&self) -> Result<String, InputError>`
        - `fn subscribe_to_input_events(&self) -> tokio::sync::broadcast::Receiver<InputEventEnum>`
- **`system::dbus` (Wrapper für spezifische D-Bus Clients wie UPower, Logind, NetworkManager)**: Exponiert vereinfachte Methoden und Events.
    - Beispiel `UPowerClientInterface`: `async fn get_display_device_details() -> Result<PowerDeviceDetails, DBusInterfaceError>`, `fn subscribe() -> Receiver<UPowerEvent>`.
- **`system::audio_management::AudioServiceInterface` (Beispielhafter Trait-Name)**
    - Methoden: `async fn list_audio_devices(...)`, `async fn set_device_volume(...)`, `fn subscribe() -> Receiver<AudioEvent>`.
- **`system::mcp_client::SystemMcpService` Trait**
    - Methoden: `async fn configure_servers(...)`, `async fn initialize_server(...)`, `async fn list_resources(...)`, `async fn call_tool(...)`, `fn subscribe_to_mcp_events() -> Receiver<McpClientSystemEvent>`.
- **`system::portals::PortalsInterface` (Beispielhafter Trait-Name für XDG Portal Interaktionen)**
    - Methoden: `async fn open_file_dialog(...) -> Result<Vec<PathBuf>, PortalError>`, `async fn save_file_dialog(...)`, `async fn take_screenshot(...)`.

#### 3.1.2. Datenstrukturen (Öffentlich exportierte Typen aus der Systemschicht für die UI)

- **`system::compositor`**: `WindowInfo` (mit `id`, `title`, `app_id`, `geometry`, Fokus-Status, Workspace-Zuordnung etc.), `OutputInfo` (mit ID, Name, Geometrie, Auflösungen, Skalierung), `CompositorWindowState` (Enum).
- **`system::input`**: `KeyboardEvent`, `PointerEvent` (Button, Motion, Axis), `TouchEvent`, `GestureEvent`, `InputEventEnum` (Wrapper).
- **`system::dbus` Clients**: Spezifische Structs für Gerätedetails, Verbindungsstatus etc. (z.B. `UPowerDeviceDetails` [aus `upower_client::types` aber ggf. hier vereinfacht für UI], `NetworkDeviceDetails`, `AccessPointInfo` [aus `network_manager_client::types`]).
- **`system::audio_management::types`**: `AudioDevice` (vereinfacht für UI), `AudioStream` (vereinfacht für UI).
- **`system::mcp_client::types`**: `McpClientSystemEvent` (für Benachrichtigungen an UI), `AICompletionResponse` (oder vereinfachte Version).
- **`system::portals`**: `OpenFileOptions`, `SaveFileOptions`, `FileFilter` für Dialoge. `WindowIdentifier` für Portal-Fenster-Handles.

#### 3.1.3. Events (System-Level Events, via `system::event_bridge` oder spezifische `broadcast::Sender`)

- **`system::compositor`**: `CompositorEvent` Enum (z.B. `WindowCreated { info }`, `WindowFocused { window_id }`, `OutputConfigurationChanged { info }`).
- **`system::input`**: `InputEventEnum` (Wrapper für spezifische Eingabe-Events).
- **`system::dbus` Clients**: Events wie `UPowerSystemEvent::DeviceChanged`, `LogindSystemEvent::SessionLocked`, `NetworkManagerSystemEvent::ConnectivityChanged`.
- **`system::audio_management`**: `AudioSystemEvent::DeviceVolumeChanged`, `AudioSystemEvent::DefaultDeviceChanged`.
- **`system::mcp_client`**: `McpClientSystemEvent::McpNotificationReceived`, `McpClientSystemEvent::McpToolCallSuccessful`.
- **`system::event_bridge::SystemLayerEvent`**: Ein übergreifendes Enum, das spezifische Events aus den Systemmodulen wrappen kann, um ein zentrales Abonnement zu ermöglichen.

#### 3.1.4. Fehlertypen (Modulspezifisch via `thiserror`)

- `system::compositor::errors::CompositorError` (z.B. `WindowNotFound`, `WaylandError`).
- `system::input::errors::InputError` (z.B. `SeatError`, `LibinputError`).
- `system::dbus_interfaces::common::errors::DBusInterfaceError` (z.B. `ConnectionFailed`, `MethodCallFailed`).
- `system::audio_management::errors::AudioManagementError` (z.B. `ConnectionFailed`, `ObjectNotFound`).
- `system::mcp_client::errors::McpSystemClientError` (z.B. `ServerConfigNotFound`, `RequestTimeout`).
- `system::portals` (z.B. `PortalError` mit `UserCancelled`, `PortalNotAvailable`).
- `system::window_mechanics::errors::WindowMechanicsError`.
- `system::power_management::errors::PowerManagementError`.

### 3.2. Nutzung durch die Benutzeroberflächenschicht (UI Layer)

- **Darstellung von Systeminformationen**: Die UI visualisiert die von der Systemschicht bereitgestellten Zustände (Fensterlisten, Fokus, Netzwerk-/Batterie-/Audio-Indikatoren etc.).
- **Reaktion auf Eingabeereignisse**: UI-Elemente (Buttons, Textfelder) reagieren auf verarbeitete Eingabeereignisse von `system::input`.
- **Initiierung von Systemaktionen**: Benutzerinteraktionen in der UI führen zu Befehlsaufrufen an die Systemschicht-APIs (Fenster schließen, Lautstärke ändern, Netzwerk verbinden, Datei öffnen via Portal).
- **Dialogmanagement**: UI-Komponenten (z.B. `ui::shell` oder spezifische Einstellungsdialoge) rufen Methoden von `system::portals::PortalsInterface` auf, um native Dialoge anzuzeigen. Die UI stellt dabei einen `WindowIdentifier` für das Elternfenster bereit.
- **Fehlerbehandlung**: Die UI fängt Fehler von der Systemschicht ab und präsentiert dem Benutzer verständliche Meldungen oder Wiederherstellungsoptionen.
- **Event-Konsum**: Die UI abonniert System-Events (z.B. `CompositorEvent::WindowCreated`, `InputEventEnum`, `UPowerSystemEvent`, etc.), um ihre Ansichten reaktiv zu aktualisieren.

## 4. Allgemeine Kommunikationsmuster (Wiederholung und Verfeinerung)

- **Synchrone vs. Asynchrone Aufrufe**:
    - Methoden, die schnell antworten und keine blockierenden Operationen ausführen (z.B. Abfrage eines bereits im Speicher befindlichen Zustands), können synchron sein.
    - Methoden, die I/O, IPC oder potenziell langlaufende Operationen beinhalten, **müssen** `async` sein (z.B. `save_settings()`, `call_tool()`, die meisten D-Bus-Aufrufe).
- **Event-Broadcasting**:
    - `tokio::sync::broadcast` wird als primärer Mechanismus für Events innerhalb einer Schicht und zwischen Schichten verwendet.
    - Services, die Events publizieren, halten einen `broadcast::Sender<EventType>`.
    - Services oder UI-Komponenten, die Events konsumieren, erhalten einen `broadcast::Receiver<EventType>` über eine `subscribe_to_..._events()` Methode.
- **Fehlerpropagation**:
    - Die konsequente Nutzung von `Result<T, E>` und dem `?`-Operator ist verbindlich.
    - Fehler werden mit `thiserror` definiert und sollten die `source()`-Kette erhalten, um die Ursachenanalyse zu ermöglichen.
    - Schichten wrappen Fehler aus tieferen Schichten in ihre eigenen, kontextspezifischeren Fehlertypen unter Beibehaltung der `source`.
- **Thread-Sicherheit für geteilten Zustand**:
    - Zustand, der von mehreren `async` Tasks oder über Thread-Grenzen hinweg geteilt wird, muss mit `Arc<tokio::sync::Mutex<...>>` oder `Arc<tokio::sync::RwLock<...>>` geschützt werden.
    - Der UI-Thread (GTK-Hauptschleife) erfordert spezielle Behandlung: Daten von Worker-Threads müssen über `glib::MainContext::spawn_local` oder geeignete Kanäle sicher an den UI-Thread übergeben werden, um UI-Aktualisierungen durchzuführen.

Diese detaillierte Schnittstellenspezifikation dient als Grundlage für die Implementierung der einzelnen Module und die Sicherstellung einer kohärenten und robusten Kommunikation zwischen den Architekturschichten von NovaDE.

**Grundlegende Kommunikationsprinzipien**

Die Architektur von NovaDE basiert auf fundamentalen Kommunikations- und Strukturprinzipien, die ein robustes, modulares und wartbares System gewährleisten sollen.

1. **API-basierte Interaktion:** Die Kommunikation zwischen den Schichten – Kern (Core), Domäne (Domain), System und Benutzeroberfläche (UI) – erfolgt primär über klar definierte öffentliche Programmierschnittstellen (APIs). Diese APIs werden in der Regel als Rust-Traits spezifiziert und von Service-Strukturen innerhalb der jeweiligen Schicht implementiert. Dies fördert ein vertragsbasiertes Interaktionsmodell.
2. **Ereignisgesteuertes System:** Ein robustes, ereignisgesteuertes System dient der Benachrichtigung über Zustandsänderungen und ermöglicht entkoppelte Interaktionen. Komponenten können auf relevante Ereignisse reagieren, ohne direkte Abhängigkeiten zu den Ereigniserzeugern aufzubauen. Dies ist besonders für die UI-Schicht wichtig, um reaktive Updates zu ermöglichen. Für die Event-Kommunikation wird `tokio::sync::broadcast` als bevorzugter Mechanismus für die Verteilung von Events spezifiziert.
3. **Strikte Schichtenhierarchie:** Höhere Schichten dürfen typischerweise nur von unmittelbar tieferliegenden Schichten abhängen, um zirkuläre Abhängigkeiten und unkontrollierte Interaktionen zu verhindern.
4. **Fehlerbehandlung:** Eine konsistente Fehlerbehandlungsstrategie wird über alle Schichten hinweg angewendet. Die `thiserror`-Bibliothek wird für die Definition von spezifischen, benutzerdefinierten Fehlertypen genutzt. `core::errors::CoreError` dient als fundamentaler Basistyp. Fehlerketten (`source()`) müssen bei der Weitergabe oder beim Wrappen von Fehlern erhalten bleiben. Panics sind strikt zu vermeiden.

## 1. Schnittstelle: Kernschicht (Core Layer) zu höheren Schichten (Domäne, System, UI)

Die Kernschicht stellt fundamentale Bausteine und Dienste bereit, die von allen darüberliegenden Schichten genutzt werden.

### 1.1. Bereitgestellte Funktionalität durch die Kernschicht

Die Kernschicht exportiert die folgenden Module und deren öffentliche APIs:

#### 1.1.1. `core::types`

- **Schnittstelle**: Direkte Verwendung von Typen durch die höheren Schichten.
- **Definierte Typen (Ultra-Fein)**:
    - `Point<T>`: Repräsentiert einen Punkt im 2D-Raum.
        - Felder: `pub x: T`, `pub y: T`.
        - Methoden: `new(x: T, y: T) -> Self`, `distance_squared(...)`, `distance(...)` (für Float-Typen), `manhattan_distance(...)`.
        - Assoziierte Konstanten: `ZERO_I32`, `ZERO_F32`, etc..
        - Generische Parameter: `T` (Basis-Constraints: `Copy + Debug + PartialEq + Default + Send + Sync + 'static`).
    - `Size<T>`: Repräsentiert eine 2D-Dimension.
        - Felder: `pub width: T`, `pub height: T`.
        - Methoden: `new(width: T, height: T) -> Self`, `area()`, `is_empty()`, `is_valid()`.
        - Assoziierte Konstanten: `ZERO_I32`, `ZERO_F32`, etc..
    - `Rect<T>`: Repräsentiert ein 2D-Rechteck.
        - Felder: `pub origin: Point<T>`, `pub size: Size<T>`.
        - Methoden: `new(...)`, `from_coords(...)`, Getter (`x`, `y`, `width`, `height`, `top`, `left`, `bottom`, `right`), `center()`, `contains_point(...)`, `intersects(...)`, `intersection(...)`, `union(...)`, `translated(...)`, `scaled(...)`, `is_valid()`.
    - `RectInt`: Typalias für `Rect<i32>` oder spezifische Struktur mit `x: i32, y: i32, width: u32, height: u32`. Bietet Methoden wie `inflate`, `translate`. Verwendet `saturating_add/sub` für Robustheit.
    - `Color`: Repräsentiert eine RGBA-Farbe.
        - Felder: `pub r: f32`, `pub g: f32`, `pub b: f32`, `pub a: f32` (Wertebereich `[0.0, 1.0]`).
        - Methoden: `new(r,g,b,a)` (klemmt Werte), `from_rgba8(...)`, `to_rgba8()`, `with_alpha(...)`, `blend(...)`, `lighten(...)`, `darken(...)`, `interpolate(...)`, `from_hex(...) -> Result<Self, ColorParseError>`, `to_hex_string(...)`.
        - Implementiert `Default` (z.B. `Color::TRANSPARENT`) und `Serialize`/`Deserialize` als Hex-String.
    - `Orientation`: Enum (`Horizontal`, `Vertical`) mit `toggle()` Methode und `Default` (Horizontal).
    - `uuid::Uuid`: Re-exportiert für eindeutige Identifikatoren.
    - `chrono::DateTime<Utc>`: Re-exportiert für Zeitstempel.
- **Nutzung**: Diese Typen werden direkt in den öffentlichen APIs und internen Logiken der höheren Schichten verwendet.

#### 1.1.2. `core::errors`

- **Schnittstelle**: Höhere Schichten wrappen Fehler aus der Kernschicht (z.B. `CoreError` oder spezifischere Modul-Fehler wie `ColorParseError`) mittels `#[from]` oder `#[source]` in ihre eigenen Fehlertypen. Die Fehlerkette (`source()`) wird beibehalten.
- **Definierte Typen (Ultra-Fein)**:
    - `CoreError`: Basis-Fehlertyp der Kernschicht.
        - Varianten: `InitializationFailed { component: String, source: Option<Box<dyn std::error::Error>> }`, `Io { path: PathBuf, source: std::io::Error }`, `Serialization { description: String, source: Option<Box<dyn std::error::Error>> }`, `Deserialization { ... }`, `InvalidId { invalid_id: String }`, `NotFound { resource_description: String }`, `CoreConfigError { message: String, source: Option<Box<dyn std::error::Error>> }`, `InternalError(String)`.
    - `ColorParseError`: Fehler beim Parsen von Hex-Farbcodes.
        - Varianten: `InvalidHexFormat(String)`, `InvalidHexDigit(String, source: std::num::ParseIntError)`, `InvalidHexLength(String)`.
- **Nutzung**: Jedes Modul, auch in höheren Schichten, definiert sein eigenes Fehler-Enum mit `thiserror` und integriert Fehler aus tieferen Schichten oder Bibliotheken.

#### 1.1.3. `core::logging`

- **Schnittstelle**:
    - `pub fn initialize_logging(level_filter: tracing::LevelFilter, format: LogFormat) -> Result<(), LoggingError>`: Einmaliger Aufruf beim Anwendungsstart.
        - `LogFormat`: Enum (`PlainTextDevelopment`, `JsonProduction`).
        - `LoggingError`: Enum (`SetGlobalDefaultError(String)`, `InitializationError(String)`).
    - Verwendung der `tracing`-Makros (`trace!`, `info!`, `warn!`, `error!`, `#[tracing::instrument]`) durch alle höheren Schichten.
- **Nutzung**: Alle Schichten nutzen `tracing`-Makros. Sensible Daten dürfen nicht geloggt werden.

#### 1.1.4. `core::config`

- **Schnittstelle**:
    - `pub fn load_core_config(config_paths: &[PathBuf]) -> Result<CoreConfig, ConfigError>`: Lädt Konfiguration aus TOML-Dateien in der angegebenen Reihenfolge.
    - `pub fn initialize_global_core_config(config: CoreConfig) -> Result<(), ConfigError>`: Initialisiert die globale Konfiguration einmalig.
    - `pub fn get_global_core_config() -> &'static CoreConfig`: Globaler, schreibgeschützter Zugriff auf die geladene `CoreConfig` (via `once_cell`).
- **Definierte Typen (Ultra-Fein)**:
    - `CoreConfig`: Struktur, die alle Kernschicht-spezifischen Einstellungen hält (z.B. `log_level: LogLevelConfig`, `feature_flags: FeatureFlags`). Implementiert `Deserialize`, `Default`. Verwendet `#[serde(default = "path")]` und `#[serde(deny_unknown_fields)]`.
    - `ConfigError`: Fehler beim Laden/Parsen der Konfiguration.
        - Varianten: `FileReadError { path: PathBuf, source: std::io::Error }`, `DeserializationError { path: PathBuf, source: toml::de::Error }`, `NoConfigurationFileFound { checked_paths: Vec<PathBuf> }`, `AlreadyInitializedError`, `NotInitializedError`.
- **Nutzung**: Domänenschicht (z.B. `domain::settings_persistence_iface`) kann Kernschicht-Dienste zum Lesen/Schreiben von Konfigurationsdateien nutzen, aber die `CoreConfig` selbst wird nach Initialisierung als unveränderlich betrachtet.

#### 1.1.5. `core::utils`

- **Schnittstelle**: Direkte Nutzung der öffentlichen, zustandslosen Hilfsfunktionen durch alle höheren Schichten.
- **Beispielhafte Utilities**:
    - `path_utils::normalize_path_robustly(...)`
    - `string_utils::sanitize_filename(...)`, `truncate_string_with_ellipsis(...)`
    - Fehlerbehandlung: Jede fehleranfällige Utility-Funktion gibt `Result<T, YourUtilError>` zurück.

## 2. Schnittstelle: Domänenschicht (Domain Layer) zu Systemschicht und Benutzeroberflächenschicht

Die Domänenschicht kapselt die Geschäftslogik und den Kernzustand von NovaDE. Sie interagiert nicht direkt mit Hardware oder OS-Details.

### 2.1. Bereitgestellte Funktionalität durch die Domänenschicht

Die Domänenschicht stellt ihre Logik und Zustandsinformationen über öffentliche APIs ihrer Service-Komponenten (Rust-Traits) und durch domänenspezifische Events bereit.

#### 2.1.1. Traits für Service-APIs (asynchron via `async_trait`)

- **`domain::theming::ThemingEngine` Trait**
    - Methoden:
        - `async fn get_current_theme_state(&self) -> Result<AppliedThemeState, ThemingError>`
        - `async fn get_available_themes(&self) -> Result<Vec<ThemeDefinition>, ThemingError>`
        - `async fn get_current_configuration(&self) -> Result<ThemingConfiguration, ThemingError>`
        - `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
        - `async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`
        - `fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeChangedEvent>`
- **`domain::workspaces::WorkspaceManagerService` Trait**
    - Methoden:
        - `async fn create_workspace(&self, name: Option<String>, persistent_id: Option<String>, icon_name: Option<String>, accent_color_hex: Option<String>) -> Result<WorkspaceId, WorkspaceManagerError>`
        - `async fn delete_workspace(&self, id: WorkspaceId, fallback_id_for_windows: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError>`
        - `fn get_workspace(&self, id: WorkspaceId) -> Option<Workspace>` (gibt Klon)
        - `fn all_workspaces_ordered(&self) -> Vec<Workspace>` (gibt Klone)
        - `fn active_workspace_id(&self) -> Option<WorkspaceId>`
        - `async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
        - `async fn assign_window_to_active_workspace(&self, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
        - `async fn assign_window_to_specific_workspace(&self, workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
        - `async fn remove_window_from_its_workspace(&self, window_id: &WindowIdentifier) -> Result<Option<WorkspaceId>, WorkspaceManagerError>`
        - `async fn move_window_to_specific_workspace(&self, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
        - `async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`
        - `async fn set_workspace_layout(&self, id: WorkspaceId, layout_type: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>`
        - `async fn set_workspace_icon(&self, id: WorkspaceId, icon_name: Option<String>) -> Result<(), WorkspaceManagerError>`
        - `async fn set_workspace_accent_color(&self, id: WorkspaceId, color_hex: Option<String>) -> Result<(), WorkspaceManagerError>`
        - `async fn save_configuration(&self) -> Result<(), WorkspaceManagerError>`
        - `fn subscribe_to_workspace_events(&self) -> tokio::sync::broadcast::Receiver<WorkspaceEvent>`
        - `async fn reorder_workspace(&self, workspace_id: WorkspaceId, new_index: usize) -> Result<(), WorkspaceManagerError>`
- **`domain::user_centric_services::ai_interaction::AIInteractionLogicService` Trait**
    - Methoden:
        - `async fn initiate_interaction(&mut self, relevant_categories: Vec<AIDataCategory>, initial_attachments: Option<Vec<AttachmentData>>) -> Result<Uuid, AIInteractionError>`
        - `async fn get_interaction_context(&self, context_id: Uuid) -> Result<AIInteractionContext, AIInteractionError>`
        - `async fn provide_consent(&mut self, context_id: Uuid, model_id: String, granted_categories: Vec<AIDataCategory>, consent_decision: bool) -> Result<(), AIInteractionError>`
        - `async fn get_consent_status_for_interaction(&self, context_id: Uuid, model_id: &str, required_categories: &[AIDataCategory]) -> Result<AIConsentStatus, AIInteractionError>`
        - `async fn add_attachment_to_context(&mut self, context_id: Uuid, attachment: AttachmentData) -> Result<(), AIInteractionError>`
        - `async fn list_available_models(&self) -> Result<Vec<AIModelProfile>, AIInteractionError>`
        - `async fn get_default_model(&self) -> Result<Option<AIModelProfile>, AIInteractionError>`
        - `async fn update_interaction_history(&mut self, context_id: Uuid, entry: InteractionHistoryEntry) -> Result<(), AIInteractionError>`
        - (Persistenz-bezogene Methoden wie `store_consent`, `get_all_user_consents`, `load_model_profiles` werden über separate Provider-Traits abgewickelt: `AIConsentProvider`, `AIModelProfileProvider`)
- **`domain::user_centric_services::notifications_core::NotificationService` Trait**
    - Methoden:
        - `async fn post_notification(&mut self, notification_data: NotificationInput) -> Result<Uuid, NotificationError>`
        - `async fn get_active_notification(&self, notification_id: Uuid) -> Result<Option<Notification>, NotificationError>`
        - `async fn mark_as_read(&mut self, notification_id: Uuid) -> Result<(), NotificationError>`
        - `async fn dismiss_notification(&mut self, notification_id: Uuid, reason: DismissReason) -> Result<(), NotificationError>`
        - `async fn get_active_notifications(&self, filter: Option<NotificationFilterCriteria>, sort_order: Option<NotificationSortOrder>) -> Result<Vec<Notification>, NotificationError>`
        - `async fn get_notification_history(&self, limit: Option<usize>, filter: Option<NotificationFilterCriteria>, sort_order: Option<NotificationSortOrder>) -> Result<Vec<Notification>, NotificationError>`
        - `async fn clear_history(&mut self) -> Result<(), NotificationError>`
        - `async fn clear_all_for_app(&mut self, app_id: &ApplicationId) -> Result<usize, NotificationError>`
        - `async fn set_do_not_disturb(&mut self, enabled: bool) -> Result<(), NotificationError>`
        - `async fn is_do_not_disturb_enabled(&self) -> Result<bool, NotificationError>`
        - `async fn invoke_action(&mut self, notification_id: Uuid, action_key: &str) -> Result<(), NotificationError>`
        - `async fn get_stats(&self) -> Result<NotificationStats, NotificationError>`
- **`domain::global_settings_and_state_management::GlobalSettingsService` Trait**
    - Methoden:
        - `async fn load_settings(&mut self) -> Result<(), GlobalSettingsError>`
        - `async fn save_settings(&self) -> Result<(), GlobalSettingsError>`
        - `fn get_current_settings(&self) -> GlobalDesktopSettings`
        - `async fn update_setting(&mut self, path: SettingPath, value: serde_json::Value) -> Result<(), GlobalSettingsError>`
        - `fn get_setting(&self, path: &SettingPath) -> Result<serde_json::Value, GlobalSettingsError>`
        - `async fn reset_to_defaults(&mut self) -> Result<(), GlobalSettingsError>`
        - `fn subscribe_to_setting_changes(&self) -> tokio::sync::broadcast::Receiver<SettingChangedEvent>`
- **`domain::notifications_rules::NotificationRulesEngine` Trait**
    - Methoden:
        - `async fn reload_rules(&self) -> Result<(), NotificationRulesError>`
        - `async fn process_notification(&self, notification: Notification) -> Result<RuleProcessingResult, NotificationRulesError>`
        - `async fn get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`
        - `async fn update_rules(&self, new_rules: NotificationRuleSet) -> Result<(), NotificationRulesError>`
- **`domain::window_management_policy::WindowManagementPolicyService` Trait**
    - Methoden:
        - `async fn calculate_workspace_layout(&self, workspace_id: WorkspaceId, windows_to_layout: &[WindowLayoutInfo], available_area: RectInt, workspace_current_tiling_mode: TilingMode, focused_window_id: Option<&WindowIdentifier>, window_specific_overrides: &HashMap<WindowIdentifier, WindowPolicyOverrides>) -> Result<WorkspaceWindowLayout, WindowPolicyError>`
        - `async fn get_initial_window_geometry(&self, window_info: &WindowLayoutInfo, is_transient_for: Option<&WindowIdentifier>, parent_geometry: Option<RectInt>, workspace_id: WorkspaceId, active_layout_on_workspace: &WorkspaceWindowLayout, available_area: RectInt, window_specific_overrides: &Option<WindowPolicyOverrides>) -> Result<RectInt, WindowPolicyError>`
        - `async fn calculate_snap_target(&self, moving_window_id: &WindowIdentifier, current_geometry: RectInt, other_windows_on_workspace: &[(&WindowIdentifier, &RectInt)], workspace_area: RectInt, snapping_policy: &WindowSnappingPolicy, gap_settings: &GapSettings) -> Option<RectInt>`
        - `async fn get_effective_tiling_mode_for_workspace(&self, workspace_id: WorkspaceId) -> Result<TilingMode, WindowPolicyError>`
        - `async fn get_effective_gap_settings_for_workspace(&self, workspace_id: WorkspaceId) -> Result<GapSettings, WindowPolicyError>`
        - (Weitere Methoden zum Abruf von Teil-Policies)

#### 2.1.2. Datenstrukturen (Öffentlich exportierte Typen aus der Domänenschicht)

- **`domain::theming::types`**: `AppliedThemeState`, `ThemeDefinition`, `ThemingConfiguration`, `TokenIdentifier`, `ThemeIdentifier`, `ColorSchemeType`, `AccentColor` (mit `novade_core::types::Color`).
- **`domain::workspaces::core::types`**: `WorkspaceId`, `WindowIdentifier`, `WorkspaceLayoutType`.
- **`domain::workspaces::core`**: `Workspace` (mit `icon_name`, `accent_color_hex`).
- **`domain::user_centric_services::ai_interaction::types`**: `AIInteractionContext` (mit `InteractionHistoryEntry`), `AIConsent` (mit `AIConsentScope`), `AIModelProfile` (mit `AIModelCapability`), `AttachmentData`, `AIConsentStatus`, `AIDataCategory`.
- **`domain::user_centric_services::notifications_core::types`**: `Notification` (mit `category`, `hints`, `timeout_ms`), `NotificationAction`, `NotificationUrgency`, `NotificationActionType`, `NotificationInput`, `NotificationFilterCriteria`, `NotificationSortOrder`, `DismissReason`.
- **`domain::global_settings_and_state_management::types`**: `GlobalDesktopSettings` (und alle untergeordneten Einstellungs-Structs wie `AppearanceSettings`, `InputBehaviorSettings`), `SettingPath`-Enum-Hierarchie.
- **`domain::notifications_rules::types`**: `RuleConditionValue`, `RuleConditionOperator`, `RuleConditionField`, `SimpleRuleCondition`, `RuleCondition`, `RuleAction`, `NotificationRule`, `NotificationRuleSet`, `RuleProcessingResult`.
- **`domain::window_management_policy::types`**: `TilingMode`, `GapSettings`, `WindowSnappingPolicy`, `WindowGroupingPolicy`, `NewWindowPlacementStrategy`, `FocusStealingPreventionLevel`, `FocusPolicy`, `WindowPolicyOverrides`, `WorkspaceWindowLayout`, `WindowLayoutInfo`.
- **`domain::shared_types`**: `ApplicationId`, `UserSessionState`, `ResourceIdentifier`.

#### 2.1.3. Events (Domänenspezifisch, via `tokio::sync::broadcast`)

- **`domain::theming`**: `ThemeChangedEvent { new_state: AppliedThemeState }`.
- **`domain::workspaces::manager::events`**: `WorkspaceEvent` Enum (z.B. `WorkspaceCreated { descriptor }`, `ActiveWorkspaceChanged { old_id, new_id, new_descriptor }`, `WindowAssignedToWorkspace { ... }`, `WorkspaceIconChanged`, `WorkspaceAccentChanged`, `WorkspaceOrderChanged`).
- **`domain::user_centric_services::events`**: Wrapper-Enums `AIInteractionEventEnum` und `NotificationEventEnum`.
    - `AIInteractionEventEnum`: `AIInteractionInitiatedEvent { context }`, `AIConsentUpdatedEvent { ... }`, `AIContextUpdatedEvent { ... }`, `AIModelProfilesReloadedEvent { ... }`.
    - `NotificationEventEnum`: `NotificationPostedEvent { notification, suppressed_by_dnd }`, `NotificationDismissedEvent { notification_id, reason }`, `NotificationReadEvent { ... }`, `DoNotDisturbModeChangedEvent { ... }`, `NotificationActionInvokedEvent { ... }`, `NotificationHistoryClearedEvent`, `NotificationPopupExpiredEvent { ... }`.
- **`domain::global_settings_and_state_management`**: `SettingChangedEvent { path: SettingPath, new_value: serde_json::Value }`, `SettingsLoadedEvent { settings: GlobalDesktopSettings }`, `SettingsSavedEvent`.
- **`domain::common_events`**: `UserActivityDetectedEvent { timestamp, activity_type, ... }`, `SystemShutdownInitiatedEvent { reason, is_reboot, ... }`.

#### 2.1.4. Fehlertypen (Modulspezifisch via `thiserror`)

- `domain::theming::errors::ThemingError`.
- `domain::workspaces::core::errors::WorkspaceCoreError`, `assignment::errors::WindowAssignmentError`, `manager::errors::WorkspaceManagerError`, `config::errors::WorkspaceConfigError`.
- `domain::user_centric_services::ai_interaction::errors::AIInteractionError`, `notifications_core::errors::NotificationError`.
- `domain::global_settings_and_state_management::errors::GlobalSettingsError`.
- `domain::notifications_rules::errors::NotificationRulesError`.
- `domain::window_management_policy::errors::WindowPolicyError`.

### 2.2. Nutzung durch die Systemschicht

- **Anwendung von Domänenregeln**: Die Systemschicht setzt Domänenrichtlinien technisch um.
    - `system::window_mechanics` nutzt `WindowManagementPolicyService::calculate_workspace_layout()` und andere Methoden, um Fenstergeometrien und -verhalten zu bestimmen und anzuwenden.
    - Der `system::compositor` und seine Submodule (z.B. für XDG-Shell, Layer-Shell) interagieren mit `WindowManagementPolicyService` und `WorkspaceManagerService` für Platzierung, Stapelreihenfolge und Sichtbarkeit von Fenstern/Surfaces.
- **Abfrage von Zuständen und Konfigurationen**:
    - `system::mcp_client` interagiert mit `AIInteractionLogicService` für Einwilligungsprüfungen, Modellprofile und Kontextmanagement.
    - `system::dbus::notifications_server` (D-Bus Implementierung von `org.freedesktop.Notifications`) leitet Anfragen an den `NotificationService` weiter und reagiert auf dessen Events, um D-Bus Signale zu senden.
    - Systemkomponenten wie `system::power_management` oder `system::audio_management` können relevante Einstellungen vom `GlobalSettingsService` beziehen.
- **Event-Konsum und -Weiterleitung**: Die Systemschicht kann auf Domänen-Events reagieren (z.B. `ActiveWorkspaceChanged`, `SettingChangedEvent` für themenrelevante Einstellungen) und diese ggf. in systemnahe Aktionen übersetzen oder an die UI-Schicht weiterleiten, wenn sie systemweite Auswirkungen haben (z.B. über den `SystemEventBridge`).
- **Fehlerbehandlung**: Fehler aus der Domänenschicht werden von der Systemschicht gefangen, ggf. in systemspezifische Fehler gewrappt und an die UI-Schicht oder interne Logging-Mechanismen weitergeleitet.

### 2.3. Nutzung durch die Benutzeroberflächenschicht (UI Layer)

- **Zustandsdarstellung**: Die UI-Schicht visualisiert Zustände und Daten aus der Domänenschicht.
    - `ui::theming_gtk` verwendet `ThemingEngine::get_current_theme_state()` und abonniert `ThemeChangedEvent`, um CSS-Stile anzuwenden.
    - `ui::shell` (z.B. Workspace-Switcher, Panel-Elemente) und `ui::control_center` nutzen `WorkspaceManagerService` und `GlobalSettingsService` intensiv zur Anzeige und Modifikation.
    - UI-Elemente für KI-Interaktionen (Befehlspalette, Assistenz-Widgets) nutzen `AIInteractionLogicService`.
    - Das `ui::notifications_frontend` (Popups, Notification-Center) nutzt `NotificationService` und reagiert auf dessen Events.
- **Auslösen von Geschäftslogik**: Benutzerinteraktionen in der UI werden in Aufrufe an Domänen-Service-Methoden übersetzt.
- **Event-Konsum**: Die UI-Schicht ist ein primärer Konsument von Domänen-Events, um sich dynamisch zu aktualisieren.
- **Fehlerbehandlung**: Fehler von Domänendiensten werden von der UI gefangen und in benutzerfreundliche Nachrichten oder Aktionen übersetzt.

## 3. Schnittstelle: Systemschicht (System Layer) zu Benutzeroberflächenschicht (UI Layer)

Die Systemschicht stellt der UI-Schicht systemnahe Dienste und Ereignisse zur Verfügung und setzt deren UI-initiierte Befehle technisch um.

### 3.1. Bereitgestellte Funktionalität durch die Systemschicht

#### 3.1.1. Traits für Service-APIs (asynchron via `async_trait`)

- **`system::compositor::CompositorInterface` (Beispielhafter Trait-Name)**
    - Methoden (Beispiele):
        - `fn request_focus(&self, window_id: novade_core::types::WindowId) -> Result<(), CompositorError>`
        - `fn configure_window(&self, window_id: novade_core::types::WindowId, config: WindowConfigurationRequest) -> Result<(), CompositorError>`
        - `fn get_window_info(&self, window_id: novade_core::types::WindowId) -> Result<Option<WindowInfo>, CompositorError>`
        - `fn list_managed_windows(&self) -> Result<Vec<WindowInfo>, CompositorError>`
        - `fn list_outputs(&self) -> Result<Vec<OutputInfo>, CompositorError>`
        - `fn subscribe_to_compositor_events(&self) -> tokio::sync::broadcast::Receiver<CompositorEvent>`
- **`system::input::InputInterface` (Beispielhafter Trait-Name)**
    - Methoden (Beispiele):
        - `fn set_cursor_theme(&self, theme_name: String, size: u32) -> Result<(), InputError>`
        - `fn get_current_keyboard_layout(&self) -> Result<String, InputError>`
        - `fn subscribe_to_input_events(&self) -> tokio::sync::broadcast::Receiver<InputEventEnum>`
- **`system::dbus` (Wrapper für spezifische D-Bus Clients wie UPower, Logind, NetworkManager)**: Exponiert vereinfachte Methoden und Events.
    - Beispiel `UPowerClientInterface`: `async fn get_display_device_details() -> Result<PowerDeviceDetails, DBusInterfaceError>`, `fn subscribe() -> Receiver<UPowerEvent>`.
- **`system::audio_management::AudioServiceInterface` (Beispielhafter Trait-Name)**
    - Methoden: `async fn list_audio_devices(...)`, `async fn set_device_volume(...)`, `fn subscribe() -> Receiver<AudioEvent>`.
- **`system::mcp_client::SystemMcpService` Trait**
    - Methoden: `async fn configure_servers(...)`, `async fn initialize_server(...)`, `async fn list_resources(...)`, `async fn call_tool(...)`, `fn subscribe_to_mcp_events() -> Receiver<McpClientSystemEvent>`.
- **`system::portals::PortalsInterface` (Beispielhafter Trait-Name für XDG Portal Interaktionen)**
    - Methoden: `async fn open_file_dialog(...) -> Result<Vec<PathBuf>, PortalError>`, `async fn save_file_dialog(...)`, `async fn take_screenshot(...)`.

#### 3.1.2. Datenstrukturen (Öffentlich exportierte Typen aus der Systemschicht für die UI)

- **`system::compositor`**: `WindowInfo` (mit `id`, `title`, `app_id`, `geometry`, Fokus-Status, Workspace-Zuordnung etc.), `OutputInfo` (mit ID, Name, Geometrie, Auflösungen, Skalierung), `CompositorWindowState` (Enum).
- **`system::input`**: `KeyboardEvent`, `PointerEvent` (Button, Motion, Axis), `TouchEvent`, `GestureEvent`, `InputEventEnum` (Wrapper).
- **`system::dbus` Clients**: Spezifische Structs für Gerätedetails, Verbindungsstatus etc. (z.B. `UPowerDeviceDetails` [aus `upower_client::types` aber ggf. hier vereinfacht für UI], `NetworkDeviceDetails`, `AccessPointInfo` [aus `network_manager_client::types`]).
- **`system::audio_management::types`**: `AudioDevice` (vereinfacht für UI), `AudioStream` (vereinfacht für UI).
- **`system::mcp_client::types`**: `McpClientSystemEvent` (für Benachrichtigungen an UI), `AICompletionResponse` (oder vereinfachte Version).
- **`system::portals`**: `OpenFileOptions`, `SaveFileOptions`, `FileFilter` für Dialoge. `WindowIdentifier` für Portal-Fenster-Handles.

#### 3.1.3. Events (System-Level Events, via `system::event_bridge` oder spezifische `broadcast::Sender`)

- **`system::compositor`**: `CompositorEvent` Enum (z.B. `WindowCreated { info }`, `WindowFocused { window_id }`, `OutputConfigurationChanged { info }`).
- **`system::input`**: `InputEventEnum` (Wrapper für spezifische Eingabe-Events).
- **`system::dbus` Clients**: Events wie `UPowerSystemEvent::DeviceChanged`, `LogindSystemEvent::SessionLocked`, `NetworkManagerSystemEvent::ConnectivityChanged`.
- **`system::audio_management`**: `AudioSystemEvent::DeviceVolumeChanged`, `AudioSystemEvent::DefaultDeviceChanged`.
- **`system::mcp_client`**: `McpClientSystemEvent::McpNotificationReceived`, `McpClientSystemEvent::McpToolCallSuccessful`.
- **`system::event_bridge::SystemLayerEvent`**: Ein übergreifendes Enum, das spezifische Events aus den Systemmodulen wrappen kann, um ein zentrales Abonnement zu ermöglichen.

#### 3.1.4. Fehlertypen (Modulspezifisch via `thiserror`)

- `system::compositor::errors::CompositorError` (z.B. `WindowNotFound`, `WaylandError`).
- `system::input::errors::InputError` (z.B. `SeatError`, `LibinputError`).
- `system::dbus_interfaces::common::errors::DBusInterfaceError` (z.B. `ConnectionFailed`, `MethodCallFailed`).
- `system::audio_management::errors::AudioManagementError` (z.B. `ConnectionFailed`, `ObjectNotFound`).
- `system::mcp_client::errors::McpSystemClientError` (z.B. `ServerConfigNotFound`, `RequestTimeout`).
- `system::portals` (z.B. `PortalError` mit `UserCancelled`, `PortalNotAvailable`).
- `system::window_mechanics::errors::WindowMechanicsError`.
- `system::power_management::errors::PowerManagementError`.

### 3.2. Nutzung durch die Benutzeroberflächenschicht (UI Layer)

- **Darstellung von Systeminformationen**: Die UI visualisiert die von der Systemschicht bereitgestellten Zustände (Fensterlisten, Fokus, Netzwerk-/Batterie-/Audio-Indikatoren etc.).
- **Reaktion auf Eingabeereignisse**: UI-Elemente (Buttons, Textfelder) reagieren auf verarbeitete Eingabeereignisse von `system::input`.
- **Initiierung von Systemaktionen**: Benutzerinteraktionen in der UI führen zu Befehlsaufrufen an die Systemschicht-APIs (Fenster schließen, Lautstärke ändern, Netzwerk verbinden, Datei öffnen via Portal).
- **Dialogmanagement**: UI-Komponenten (z.B. `ui::shell` oder spezifische Einstellungsdialoge) rufen Methoden von `system::portals::PortalsInterface` auf, um native Dialoge anzuzeigen. Die UI stellt dabei einen `WindowIdentifier` für das Elternfenster bereit.
- **Fehlerbehandlung**: Die UI fängt Fehler von der Systemschicht ab und präsentiert dem Benutzer verständliche Meldungen oder Wiederherstellungsoptionen.
- **Event-Konsum**: Die UI abonniert System-Events (z.B. `CompositorEvent::WindowCreated`, `InputEventEnum`, `UPowerSystemEvent`, etc.), um ihre Ansichten reaktiv zu aktualisieren.

## 4. Allgemeine Kommunikationsmuster (Wiederholung und Verfeinerung)

- **Synchrone vs. Asynchrone Aufrufe**:
    - Methoden, die schnell antworten und keine blockierenden Operationen ausführen (z.B. Abfrage eines bereits im Speicher befindlichen Zustands), können synchron sein.
    - Methoden, die I/O, IPC oder potenziell langlaufende Operationen beinhalten, **müssen** `async` sein (z.B. `save_settings()`, `call_tool()`, die meisten D-Bus-Aufrufe).
- **Event-Broadcasting**:
    - `tokio::sync::broadcast` wird als primärer Mechanismus für Events innerhalb einer Schicht und zwischen Schichten verwendet.
    - Services, die Events publizieren, halten einen `broadcast::Sender<EventType>`.
    - Services oder UI-Komponenten, die Events konsumieren, erhalten einen `broadcast::Receiver<EventType>` über eine `subscribe_to_..._events()` Methode.
- **Fehlerpropagation**:
    - Die konsequente Nutzung von `Result<T, E>` und dem `?`-Operator ist verbindlich.
    - Fehler werden mit `thiserror` definiert und sollten die `source()`-Kette erhalten, um die Ursachenanalyse zu ermöglichen.
    - Schichten wrappen Fehler aus tieferen Schichten in ihre eigenen, kontextspezifischeren Fehlertypen unter Beibehaltung der `source`.
- **Thread-Sicherheit für geteilten Zustand**:
    - Zustand, der von mehreren `async` Tasks oder über Thread-Grenzen hinweg geteilt wird, muss mit `Arc<tokio::sync::Mutex<...>>` oder `Arc<tokio::sync::RwLock<...>>` geschützt werden.
    - Der UI-Thread (GTK-Hauptschleife) erfordert spezielle Behandlung: Daten von Worker-Threads müssen über `glib::MainContext::spawn_local` oder geeignete Kanäle sicher an den UI-Thread übergeben werden, um UI-Aktualisierungen durchzuführen.

Diese detaillierte Schnittstellenspezifikation dient als Grundlage für die Implementierung der einzelnen Module und die Sicherstellung einer kohärenten und robusten Kommunikation zwischen den Architekturschichten von NovaDE.


# **Nova A1 Kernschicht Implementierungsleitfaden: Modul 1 \- Fundamentale Datentypen (core::types)**

## **1\. Modulübersicht: core::types**

### **1.1. Zweck und Verantwortlichkeit**

Dieses Modul, core::types, bildet das Fundament der Kernschicht (core) und somit des gesamten Systems. Seine primäre Verantwortung liegt in der Definition grundlegender, universell einsetzbarer Datentypen, die von allen anderen Schichten und Modulen der Desktop-Umgebung benötigt werden. Dazu gehören geometrische Primitive (wie Punkte, Größen, Rechtecke), Farbdarstellungen und allgemeine Enumerationen (wie Orientierungen).  
Die in diesem Modul definierten Typen sind bewusst einfach gehalten und repräsentieren reine Datenstrukturen ohne komplexe Geschäftslogik oder Abhängigkeiten zu höheren Schichten oder externen Systemen. Sie dienen als Bausteine für komplexere Operationen und Zustandsrepräsentationen in den Domänen-, System- und Benutzeroberflächenschichten.

### **1.2. Designphilosophie**

Das Design von core::types folgt den Prinzipien der Modularität, Wiederverwendbarkeit und minimalen Kopplung. Die Typen sind generisch gehalten (wo sinnvoll, z.B. bei geometrischen Primitiven), um Flexibilität für verschiedene numerische Darstellungen (z.B. i32 für Koordinaten, f32 für Skalierungsfaktoren) zu ermöglichen.  
Ein wesentlicher Aspekt ist die klare Trennung von Datenrepräsentation (in core::types) und Fehlerbehandlung. Während dieses Modul die Datenstrukturen definiert, werden die spezifischen Fehler, die bei Operationen mit diesen Typen auftreten können (z.B. durch ungültige Werte), in den Modulen definiert, die diese Operationen durchführen (typischerweise in core::errors oder modulspezifischen Fehler-Enums höherer Schichten).

### **1.3. Zusammenspiel mit Fehlerbehandlung**

Obwohl core::types selbst keine Error-Typen definiert, ist das Design der hier enthaltenen Typen entscheidend für eine robuste und konsistente Fehlerbehandlungsstrategie im gesamten Projekt. Die übergeordnete Richtlinie sieht die Verwendung des thiserror-Crates vor, um spezifische Fehler-Enums pro Modul zu definieren. Dies ermöglicht eine granulare Fehlerbehandlung, ohne die Komplexität übermäßig zu erhöhen.  
Die Typen in core::types unterstützen diese Strategie, indem sie:

1. **Standard-Traits implementieren:** Alle Typen implementieren grundlegende Traits wie Debug und Display. Dies ist essenziell, damit Instanzen dieser Typen effektiv in Fehlermeldungen und Log-Ausgaben eingebettet werden können, die von höheren Schichten unter Verwendung von thiserror generiert werden. Eine gute Fehlerdarstellung ist entscheidend für die Fehlersuche und das Verständnis von Problemen im Laufzeitbetrieb.  
2. **Invarianten dokumentieren:** Für Typen wie Rect\<T\> existieren logische Invarianten (z.B. nicht-negative Breite und Höhe). Diese Invarianten werden klar dokumentiert.  
3. **Validierung ermöglichen:** Wo sinnvoll, werden Methoden zur Überprüfung der Gültigkeit bereitgestellt (z.B. Rect::is\_valid()). Diese Methoden erlauben es aufrufendem Code in höheren Schichten, Zustände zu überprüfen, *bevor* Operationen ausgeführt werden, die fehlschlagen könnten.  
4. **Keine Panics in Kernfunktionen:** Konstruktoren und einfache Zugriffsmethoden in core::types lösen keine Panics aus und geben keine Result-Typen zurück, um die API auf dieser fundamentalen Ebene einfach und vorhersagbar zu halten. Die Verantwortung für die Handhabung potenziell ungültiger Zustände (z.B. ein Rect mit negativer Breite, das an eine Rendering-Funktion übergeben wird) liegt bei den konsumierenden Funktionen, die dann die definierten Fehlerpfade (mittels Result\<T, E\> 3 und den thiserror-basierten E-Typen) nutzen.

Diese Designentscheidungen stellen sicher, dass die fundamentalen Typen nahtlos in das übergeordnete Fehlerbehandlungskonzept integriert werden können, ohne selbst die Komplexität der Fehlerdefinition tragen zu müssen. Die gewählte Fehlerstrategie mit thiserror pro Modul wird als ausreichend für die Bedürfnisse der Kernschicht erachtet, auch wenn alternative Ansätze wie snafu für komplexere Szenarien existieren, in denen z.B. die Unterscheidung von Fehlern aus derselben Quelle kritisch ist. Für die Kernschicht wird die Einfachheit und Direktheit von thiserror bevorzugt.

### **1.4. Modulabhängigkeiten**

Dieses Modul ist darauf ausgelegt, minimale externe Abhängigkeiten zu haben, um seine grundlegende Natur und breite Anwendbarkeit zu gewährleisten.

* **Erlaubte Abhängigkeiten:**  
  * std (Rust Standardbibliothek)  
* **Optionale Abhängigkeiten (derzeit nicht verwendet):**  
  * num-traits: Nur hinzufügen, falls generische numerische Operationen benötigt werden, die über std::ops hinausgehen.  
  * serde (mit derive-Feature): Nur hinzufügen, wenn Serialisierung/Deserialisierung dieser Basistypen *direkt auf dieser Ebene* zwingend erforderlich ist (z.B. für Konfigurationsdateien, die diese Typen direkt verwenden). Aktuell wird davon ausgegangen, dass Serialisierungslogik in höheren Schichten implementiert wird, um unnötige Abhängigkeiten zu vermeiden.

### **1.5. Ziel-Dateistruktur**

Die Implementierung dieses Moduls erfolgt innerhalb des core-Crates mit folgender Verzeichnisstruktur:

src/  
└── core/  
    ├── Cargo.toml         \# (Definiert das 'core' Crate)  
    └── src/  
        ├── lib.rs             \# (Deklariert Kernmodule: pub mod types; pub mod errors;...)  
        └── types/  
            ├── mod.rs         \# (Deklariert und re-exportiert Typen: pub mod geometry; pub mod color;...)  
            ├── geometry.rs    \# (Enthält Point\<T\>, Size\<T\>, Rect\<T\>)  
            ├── color.rs       \# (Enthält Color)  
            └── enums.rs       \# (Enthält Orientation, etc.)

## **2\. Spezifikation: Geometrische Primitive (geometry.rs)**

Diese Datei definiert grundlegende 2D-Geometrietypen, die für Layout, Positionierung und Rendering unerlässlich sind.

### **2.1. Struct: Point\<T\>**

* **2.1.1. Definition und Zweck:** Repräsentiert einen Punkt im 2D-Raum mit x- und y-Koordinaten. Generisch über den Typ T.  
* **2.1.2. Felder:**  
  * pub x: T  
  * pub y: T  
* **2.1.3. Assoziierte Konstanten:**  
  * pub const ZERO\_I32: Point\<i32\> \= Point { x: 0, y: 0 };  
  * pub const ZERO\_U32: Point\<u32\> \= Point { x: 0, y: 0 };  
  * pub const ZERO\_F32: Point\<f32\> \= Point { x: 0.0, y: 0.0 };  
  * pub const ZERO\_F64: Point\<f64\> \= Point { x: 0.0, y: 0.0 };  
* **2.1.4. Methoden:**  
  * pub const fn new(x: T, y: T) \-\> Self  
    * Erstellt einen neuen Punkt.  
  * pub fn distance\_squared(\&self, other: \&Point\<T\>) \-\> T  
    * Berechnet das Quadrat der euklidischen Distanz.  
    * *Constraints:* T:Copy+std::ops::Add\<Output=T\>+std::ops::Sub\<Output=T\>+std::ops::Mul\<Output=T\>  
  * pub fn distance(\&self, other: \&Point\<T\>) \-\> T  
    * Berechnet die euklidische Distanz.  
    * *Constraints:* T:Copy+std::ops::Add\<Output=T\>+std::ops::Sub\<Output=T\>+std::ops::Mul\<Output=T\>+numt​raits::Float (Implementierung nur für Float-Typen sinnvoll oder über sqrt-Funktion). Vorerst nur für f32,f64 implementieren.  
  * pub fn manhattan\_distance(\&self, other: \&Point\<T\>) \-\> T  
    * Berechnet die Manhattan-Distanz (∣x1​−x2​∣+∣y1​−y2​∣).  
    * *Constraints:* T:Copy+std::ops::Add\<Output=T\>+std::ops::Sub\<Output=T\>+numt​raits::Signed (Benötigt abs()).  
* **2.1.5. Trait Implementierungen:**  
  * \#  
    * *Bedingung:* T muss die jeweiligen Traits ebenfalls implementieren. Default setzt x und y auf T::default().  
  * impl\<T: Send \+ 'static\> Send for Point\<T\> {}  
  * impl\<T: Sync \+ 'static\> Sync for Point\<T\> {}  
  * impl\<T: std::ops::Add\<Output \= T\>\> std::ops::Add for Point\<T\>  
  * impl\<T: std::ops::Sub\<Output \= T\>\> std::ops::Sub for Point\<T\>  
* **2.1.6. Generische Constraints (Basis):** T:Copy+Debug+PartialEq+Default+Send+Sync+′static. Weitere Constraints werden pro Methode spezifiziert.

### **2.2. Struct: Size\<T\>**

* **2.2.1. Definition und Zweck:** Repräsentiert eine 2D-Dimension (Breite und Höhe). Generisch über den Typ T.  
* **2.2.2. Felder:**  
  * pub width: T  
  * pub height: T  
* **2.2.3. Assoziierte Konstanten:**  
  * pub const ZERO\_I32: Size\<i32\> \= Size { width: 0, height: 0 };  
  * pub const ZERO\_U32: Size\<u32\> \= Size { width: 0, height: 0 };  
  * pub const ZERO\_F32: Size\<f32\> \= Size { width: 0.0, height: 0.0 };  
  * pub const ZERO\_F64: Size\<f64\> \= Size { width: 0.0, height: 0.0 };  
* **2.2.4. Methoden:**  
  * pub const fn new(width: T, height: T) \-\> Self  
    * Erstellt eine neue Größe.  
  * pub fn area(\&self) \-\> T  
    * Berechnet die Fläche (width×height).  
    * *Constraints:* T:Copy+std::ops::Mul\<Output=T\>  
  * pub fn is\_empty(\&self) \-\> bool  
    * Prüft, ob Breite oder Höhe null ist.  
    * *Constraints:* T:PartialEq+numt​raits::Zero  
  * pub fn is\_valid(\&self) \-\> bool  
    * Prüft, ob Breite und Höhe nicht-negativ sind. Nützlich für Typen wie i32.  
    * *Constraints:* T:PartialOrd+numt​raits::Zero  
* **2.2.5. Trait Implementierungen:**  
  * \#  
    * *Bedingung:* T muss die jeweiligen Traits ebenfalls implementieren. Default setzt width und height auf T::default().  
  * impl\<T: Send \+ 'static\> Send for Size\<T\> {}  
  * impl\<T: Sync \+ 'static\> Sync for Size\<T\> {}  
* **2.2.6. Generische Constraints (Basis):** T:Copy+Debug+PartialEq+Default+Send+Sync+′static. Weitere Constraints werden pro Methode spezifiziert. Die Invariante nicht-negativer Dimensionen wird durch is\_valid prüfbar gemacht, aber nicht durch den Typ erzwungen.

### **2.3. Struct: Rect\<T\>**

* **2.3.1. Definition und Zweck:** Repräsentiert ein 2D-Rechteck, definiert durch einen Ursprungspunkt (oben-links) und eine Größe. Generisch über den Typ T.  
* **2.3.2. Felder:**  
  * pub origin: Point\<T\>  
  * pub size: Size\<T\>  
* **2.3.3. Assoziierte Konstanten:**  
  * pub const ZERO\_I32: Rect\<i32\> \= Rect { origin: Point::ZERO\_I32, size: Size::ZERO\_I32 };  
  * pub const ZERO\_U32: Rect\<u32\> \= Rect { origin: Point::ZERO\_U32, size: Size::ZERO\_U32 };  
  * pub const ZERO\_F32: Rect\<f32\> \= Rect { origin: Point::ZERO\_F32, size: Size::ZERO\_F32 };  
  * pub const ZERO\_F64: Rect\<f64\> \= Rect { origin: Point::ZERO\_F64, size: Size::ZERO\_F64 };  
* **2.3.4. Methoden:**  
  * pub const fn new(origin: Point\<T\>, size: Size\<T\>) \-\> Self  
  * pub fn from\_coords(x: T, y: T, width: T, height: T) \-\> Self  
    * *Constraints:* T muss die Constraints von Point::new und Size::new erfüllen.  
  * pub fn x(\&self) \-\> T (*Constraints:* T:Copy)  
  * pub fn y(\&self) \-\> T (*Constraints:* T:Copy)  
  * pub fn width(\&self) \-\> T (*Constraints:* T:Copy)  
  * pub fn height(\&self) \-\> T (*Constraints:* T:Copy)  
  * pub fn top(\&self) \-\> T (Alias für y, *Constraints:* T:Copy)  
  * pub fn left(\&self) \-\> T (Alias für x, *Constraints:* T:Copy)  
  * pub fn bottom(\&self) \-\> T (y+height, *Constraints:* T:Copy+std::ops::Add\<Output=T\>)  
  * pub fn right(\&self) \-\> T (x+width, *Constraints:* T:Copy+std::ops::Add\<Output=T\>)  
  * pub fn center(\&self) \-\> Point\<T\>  
    * Berechnet den Mittelpunkt.  
    * *Constraints:* T:Copy+std::ops::Add\<Output=T\>+std::ops::Div\<Output=T\>+numt​raits::FromPrimitive (Benötigt Division durch 2).  
  * pub fn contains\_point(\&self, point: \&Point\<T\>) \-\> bool  
    * Prüft, ob der Punkt innerhalb des Rechtecks liegt (Grenzen inklusiv für top/left, exklusiv für bottom/right).  
    * *Constraints:* T:Copy+PartialOrd+std::ops::Add\<Output=T\>  
  * pub fn intersects(\&self, other: \&Rect\<T\>) \-\> bool  
    * Prüft, ob sich dieses Rechteck mit einem anderen überschneidet.  
    * *Constraints:* T:Copy+PartialOrd+std::ops::Add\<Output=T\>  
  * pub fn intersection(\&self, other: \&Rect\<T\>) \-\> Option\<Rect\<T\>\>  
    * Berechnet das Schnittrechteck. Gibt None zurück, wenn keine Überschneidung vorliegt.  
    * *Constraints:* T:Copy+Ord+std::ops::Add\<Output=T\>+std::ops::Sub\<Output=T\>+numt​raits::Zero  
  * pub fn union(\&self, other: \&Rect\<T\>) \-\> Rect\<T\>  
    * Berechnet das umschließende Rechteck beider Rechtecke.  
    * *Constraints:* T:Copy+Ord+std::ops::Add\<Output=T\>+std::ops::Sub\<Output=T\>  
  * pub fn translated(\&self, dx: T, dy: T) \-\> Rect\<T\>  
    * Verschiebt das Rechteck um (dx,dy).  
    * *Constraints:* T:Copy+std::ops::Add\<Output=T\>  
  * pub fn scaled(\&self, sx: T, sy: T) \-\> Rect\<T\>  
    * Skaliert das Rechteck relativ zum Ursprung (0,0). Beachtet, dass dies Ursprung und Größe skaliert.  
    * *Constraints:* T:Copy+std::ops::Mul\<Output=T\>  
  * pub fn is\_valid(\&self) \-\> bool  
    * Prüft, ob size.is\_valid() wahr ist.  
    * *Constraints:* T:PartialOrd+numt​raits::Zero  
* **2.3.5. Trait Implementierungen:**  
  * \#  
    * *Bedingung:* T muss die jeweiligen Traits ebenfalls implementieren. Default verwendet Point::default() und Size::default().  
  * impl\<T: Send \+ 'static\> Send for Rect\<T\> {}  
  * impl\<T: Sync \+ 'static\> Sync for Rect\<T\> {}  
* **2.3.6. Generische Constraints (Basis):** T:Copy+Debug+PartialEq+Default+Send+Sync+′static. Weitere Constraints werden pro Methode spezifiziert.  
* **2.3.7. Invarianten und Validierung (Verbindung zur Fehlerbehandlung):**  
  * **Invariante:** Logisch sollten width und height der size-Komponente nicht-negativ sein.  
  * **Kontext:** Die Verwendung von vorzeichenbehafteten Typen wie i32 für Koordinaten ist üblich, erlaubt aber technisch negative Dimensionen. Eine Erzwingung nicht-negativer Dimensionen auf Typebene (z.B. durch u32) wäre zu restriktiv für Koordinatensysteme.  
  * **Konsequenz:** Die Flexibilität, Rect\<i32\> zu verwenden, verlagert die Verantwortung für die Validierung auf die Nutzer des Rect-Typs. Funktionen in höheren Schichten (z.B. Layout-Algorithmen, Rendering-Engines), die ein Rect konsumieren, müssen potenziell ungültige Rechtecke (mit negativer Breite oder Höhe) behandeln. Solche Fälle stellen Laufzeitfehler dar, die über das etablierte Fehlerbehandlungssystem (basierend auf Result\<T, E\> und thiserror-definierten E-Typen) signalisiert werden müssen.  
  * **Implementierung in core::types:** Das Modul erzwingt die Invariante nicht zur Compilezeit oder in Konstruktoren. Stattdessen wird die Methode pub fn is\_valid(\&self) \-\> bool bereitgestellt. Nutzer von Rect\<T\> (insbesondere mit T=i32) *sollten* diese Methode aufrufen, um die Gültigkeit sicherzustellen, bevor Operationen durchgeführt werden, die eine positive Breite und Höhe voraussetzen. Die Dokumentation des Rect-Typs muss explizit auf diese Invariante und die Notwendigkeit der Validierung durch den Aufrufer hinweisen. Die Verantwortung für das *Melden* eines Fehlers bei Verwendung eines ungültigen Rect liegt beim Aufrufer, der dafür die Fehlerinfrastruktur (z.B. core::errors oder modulspezifische Fehler) nutzt.

## **3\. Spezifikation: Farbdarstellung (color.rs)**

Diese Datei definiert einen Standard-Farbtyp für die Verwendung im gesamten System.

### **3.1. Struct: Color (RGBA)**

* **3.1.1. Definition und Zweck:** Repräsentiert eine Farbe mit Rot-, Grün-, Blau- und Alpha-Komponenten. Verwendet f32-Komponenten im Bereich \[0.0,1.0\] für hohe Präzision und Flexibilität bei Farboperationen wie Mischen und Transformationen.  
* **3.1.2. Felder:**  
  * pub r: f32 (Rotkomponente, 0.0 bis 1.0)  
  * pub g: f32 (Grünkomponente, 0.0 bis 1.0)  
  * pub b: f32 (Blaukomponente, 0.0 bis 1.0)  
  * pub a: f32 (Alphakomponente, 0.0=transparent bis 1.0=opak)  
* **3.1.3. Assoziierte Konstanten:**  
  * pub const TRANSPARENT: Color \= Color { r: 0.0, g: 0.0, b: 0.0, a: 0.0 };  
  * pub const BLACK: Color \= Color { r: 0.0, g: 0.0, b: 0.0, a: 1.0 };  
  * pub const WHITE: Color \= Color { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };  
  * pub const RED: Color \= Color { r: 1.0, g: 0.0, b: 0.0, a: 1.0 };  
  * pub const GREEN: Color \= Color { r: 0.0, g: 1.0, b: 0.0, a: 1.0 };  
  * pub const BLUE: Color \= Color { r: 0.0, g: 0.0, b: 1.0, a: 1.0 };  
  * *(Weitere Standardfarben nach Bedarf hinzufügen)*  
* **3.1.4. Methoden:**  
  * pub const fn new(r: f32, g: f32, b: f32, a: f32) \-\> Self  
    * Erstellt eine neue Farbe. Werte außerhalb \[0.0,1.0\] werden nicht automatisch geklemmt, dies liegt in der Verantwortung des Aufrufers oder nachfolgender Operationen. debug\_assert\! kann zur Laufzeitprüfung in Debug-Builds verwendet werden.  
  * pub fn from\_rgba8(r: u8, g: u8, b: u8, a: u8) \-\> Self  
    * Konvertiert von 8-Bit-Ganzzahlkomponenten (0−255) zu f32 (0.0−1.0). value/255.0.  
  * pub fn to\_rgba8(\&self) \-\> (u8, u8, u8, u8)  
    * Konvertiert von f32 zu 8-Bit-Ganzzahlkomponenten. Klemmt Werte auf \[0.0,1.0\] und skaliert dann auf $$. (value.clamp(0.0,1.0)∗255.0).round()asu8.  
  * pub fn with\_alpha(\&self, alpha: f32) \-\> Self  
    * Erstellt eine neue Farbe mit dem angegebenen Alpha-Wert, wobei RGB beibehalten wird. Klemmt Alpha auf \[0.0,1.0\].  
  * pub fn blend(\&self, background: \&Color) \-\> Color  
    * Führt Alpha-Blending ("source-over") dieser Farbe über einer Hintergrundfarbe durch. Formel: Cout​=Cfg​×αfg​+Cbg​×αbg​×(1−αfg​). αout​=αfg​+αbg​×(1−αfg​). Annahme: Farben sind nicht vormultipliziert.  
  * pub fn lighten(\&self, amount: f32) \-\> Color  
    * Hellt die Farbe um einen Faktor amount auf (z.B. durch lineare Interpolation zu Weiß). Klemmt das Ergebnis auf gültige Farbwerte. amount im Bereich \[0.0,1.0\].  
  * pub fn darken(\&self, amount: f32) \-\> Color  
    * Dunkelt die Farbe um einen Faktor amount ab (z.B. durch lineare Interpolation zu Schwarz). Klemmt das Ergebnis. amount im Bereich \[0.0,1.0\].  
* **3.1.5. Trait Implementierungen:**  
  * \#  
    * PartialEq: Verwendet den Standard-Float-Vergleich. Für präzisere Vergleiche könnten benutzerdefinierte Implementierungen mit Epsilon erforderlich sein, dies wird jedoch für die Kernschicht als unnötige Komplexität betrachtet.  
    * Default: Implementiert Default manuell, um Color::TRANSPARENT zurückzugeben.  
  * impl Send for Color {}  
  * impl Sync for Color {}

## **4\. Spezifikation: Allgemeine Enumerationen (enums.rs)**

Diese Datei enthält häufig verwendete, einfache Enumerationen.

### **4.1. Enum: Orientation**

* **4.1.1. Definition und Zweck:** Repräsentiert eine horizontale oder vertikale Ausrichtung, häufig verwendet in UI-Layouts und Widgets.  
* **4.1.2. Varianten:**  
  * Horizontal  
  * Vertical  
* **4.1.3. Methoden:**  
  * pub fn toggle(\&self) \-\> Self  
    * Gibt die jeweils andere Orientierung zurück (Horizontal \-\> Vertical, Vertical \-\> Horizontal).  
* **4.1.4. Trait Implementierungen:**  
  * \#  
  * impl Default for Orientation { fn default() \-\> Self { Orientation::Horizontal } } (Standard ist Horizontal).  
  * impl Send for Orientation {}  
  * impl Sync for Orientation {}

## **5\. Zusammenfassung: Standard Trait Implementierungen**

Die folgende Tabelle gibt einen Überblick über die Implementierung gängiger Standard-Traits für die in diesem Modul definierten Typen. Dies dient als schnelle Referenz für Entwickler.

| Typ | Debug | Clone | Copy | PartialEq | Eq | Default | Hash | Send | Sync |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| Point\<T\> | Ja | Ja | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) |
| Size\<T\> | Ja | Ja | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) |
| Rect\<T\> | Ja | Ja | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) |
| Color | Ja | Ja | Ja | Ja | Nein | Ja | Nein | Ja | Ja |
| Orientation | Ja | Ja | Ja | Ja | Ja | Ja | Ja | Ja | Ja |

Anmerkungen:  
Eq und Hash sind aufgrund von Präzisionsproblemen generell nicht für Fließkommazahlen geeignet.  
Default::default() ergibt Color::TRANSPARENT.  
Default::default() ergibt Orientation::Horizontal.

## **6\. Schritt-für-Schritt Implementierungsplan**

Die Implementierung des core::types-Moduls folgt diesen Schritten:

* **6.1. Setup: Verzeichnis- und Dateierstellung:**  
  * Sicherstellen, dass das core-Crate existiert (ggf. cargo new core \--lib ausführen).  
  * Erstellen des Verzeichnisses src/core/src/types.  
  * Erstellen der Dateien:  
    * src/core/src/types/mod.rs  
    * src/core/src/types/geometry.rs  
    * src/core/src/types/color.rs  
    * src/core/src/types/enums.rs  
* **6.2. Implementierung geometry.rs: Point\<T\>, Size\<T\>, Rect\<T\>:**  
  * Definieren der Point\<T\>-Struktur mit Feldern x, y. Hinzufügen der spezifizierten generischen Basis-Constraints (T:Copy+Debug+PartialEq+Default+Send+Sync+′static). Implementieren von new, Konstanten (ZERO\_I32 etc.), Methoden (distance\_squared, distance (für Floats), manhattan\_distance) mit ihren spezifischen Constraints und Ableiten/Implementieren der spezifizierten Traits (Add, Sub).  
  * Definieren der Size\<T\>-Struktur mit Feldern width, height. Hinzufügen der Basis-Constraints. Implementieren von new, Konstanten (ZERO\_I32 etc.), Methoden (area, is\_empty, is\_valid) mit ihren Constraints und Ableiten/Implementieren der Traits.  
  * Definieren der Rect\<T\>-Struktur mit Feldern origin, size. Hinzufügen der Basis-Constraints. Implementieren von new, from\_coords, Konstanten (ZERO\_I32 etc.), Zugriffsmethoden (x, y, width, height, top, left, bottom, right), geometrischen Methoden (center, contains\_point, intersects, intersection, union, translated, scaled), Validierungsmethode (is\_valid) mit ihren Constraints und Ableiten/Implementieren der Traits.  
  * Hinzufügen notwendiger use-Anweisungen (z.B. std::ops, num\_traits).  
* **6.3. Implementierung color.rs: Color:**  
  * Definieren der Color-Struktur mit Feldern r, g, b, a (alle f32).  
  * Implementieren von new, Konstanten (TRANSPARENT, BLACK, WHITE, etc.), Konvertierungsmethoden (from\_rgba8, to\_rgba8), Hilfsmethoden (with\_alpha, blend, lighten, darken) und Ableiten/Implementieren der Traits (Default manuell).  
* **6.4. Implementierung enums.rs: Orientation:**  
  * Definieren des Orientation-Enums mit Varianten Horizontal, Vertical.  
  * Implementieren der toggle-Methode.  
  * Ableiten/Implementieren der spezifizierten Traits (Default manuell).  
* **6.5. Implementierung Moduldeklaration (mod.rs):**  
  * In src/core/src/types/mod.rs:  
    Rust  
    // src/core/src/types/mod.rs  
    pub mod color;  
    pub mod enums;  
    pub mod geometry;

    // Re-exportiere die primären Typen für einfacheren Zugriff  
    pub use color::Color;  
    pub use enums::Orientation;  
    pub use geometry::{Point, Rect, Size};

  * In src/core/src/lib.rs:  
    Rust  
    // src/core/src/lib.rs  
    // Deklariere das types-Modul  
    pub mod types;

    // Deklariere andere Kernmodule (werden später hinzugefügt)  
    // pub mod errors;  
    // pub mod logging;  
    // pub mod config;  
    // pub mod utils;

* **6.6. Unit-Testing Anforderungen:**  
  * Erstellen eines \#\[cfg(test)\]-Moduls innerhalb jeder Implementierungsdatei (geometry.rs, color.rs, enums.rs).  
  * Schreiben von Unit-Tests, die Folgendes abdecken:  
    * Konstruktorfunktionen (new, from\_coords, from\_rgba8).  
    * Konstantenwerte (deren Eigenschaften überprüfen).  
    * Methodenlogik (z.B. distance\_squared, area, is\_empty, bottom, right, contains\_point, intersects, intersection, union, toggle, blend). Testen von Grenzfällen (Nullwerte, überlappende/nicht überlappende Rechtecke, identische Punkte, Farbblending mit transparent/opak).  
    * Trait-Implementierungen (insbesondere Default, PartialEq, Add/Sub, wo zutreffend).  
    * Invariantenprüfungen (z.B. is\_valid für Rect und Size testen).  
  * Anstreben einer hohen Testabdeckung für diesen fundamentalen Code.  
* **6.7. Dokumentationsanforderungen (rustdoc):**  
  * Hinzufügen von ///-Dokumentationskommentaren zu *allen* öffentlichen Elementen: Module (mod.rs-Dateien), Structs, Enums, Felder, Konstanten, Methoden, Typ-Aliase.  
  * Modul-Level-Kommentare sollen den Zweck des Moduls erklären (geometry.rs, color.rs, etc.).  
  * Typ-Level-Kommentare sollen den Zweck und die Invarianten der Struktur/des Enums erklären (besonders wichtig für Rect-Invarianten).  
  * Feld-Level-Kommentare sollen die Bedeutung des Feldes erklären (z.B. Wertebereich für Color-Komponenten).  
  * Methoden-Level-Kommentare sollen erklären, was die Methode tut, ihre Parameter, Rückgabewerte, mögliche Panics (sollten hier idealerweise keine auftreten, außer bei unwrap/expect in Tests), relevante Vor-/Nachbedingungen oder verwendete Algorithmen (z.B. Alpha-Blending-Formel). \# Examples-Abschnitte verwenden, wo sinnvoll.  
  * Strikte Einhaltung der Rust API Guidelines für Dokumentation.  
  * Ausführen von cargo doc \--open zur Überprüfung der generierten Dokumentation.

## **7\. Schlussfolgerung**

Dieses Dokument spezifiziert das Modul core::types, welches die grundlegendsten Datentypen für die neue Linux-Desktop-Umgebung bereitstellt. Die definierten Typen (Point\<T\>, Size\<T\>, Rect\<T\>, Color, Orientation) sind mit Fokus auf Einfachheit, Wiederverwendbarkeit und minimalen Abhängigkeiten entworfen. Besonderes Augenmerk wurde auf die klare Trennung zwischen Datenrepräsentation und Fehlerbehandlung gelegt, wobei die Typen so gestaltet sind, dass sie die übergeordnete, auf thiserror basierende Fehlerstrategie des Projekts unterstützen, ohne selbst Fehlerdefinitionen zu enthalten. Die Bereitstellung von Validierungsfunktionen wie Rect::is\_valid und die klare Dokumentation von Invarianten sind entscheidend, um Robustheit in den konsumierenden Schichten zu ermöglichen. Der detaillierte Implementierungsplan inklusive Test- und Dokumentationsanforderungen stellt sicher, dass dieses fundamentale Modul mit hoher Qualität und Konsistenz entwickelt werden kann.

# **A2 Implementierungsleitfaden: Kernschicht – Teil 2: Fehlerbehandlung (core::errors)**

## **1\. Einleitung**

### **1.1. Zweck und Geltungsbereich**

Dieser Abschnitt des Implementierungsleitfadens spezifiziert die verbindliche Strategie und Implementierung der Fehlerbehandlung innerhalb der Kernschicht (Core Layer) des Projekts. Er stellt Teil 2 der Spezifikation für die Kernschicht dar und baut direkt auf der technischen Gesamtspezifikation auf, insbesondere auf Abschnitt III (Technologie-Stack) und IV (Entwicklungsrichtlinien). Die hier dargelegten Definitionen und Richtlinien konkretisieren die Anforderungen für das Modul core::errors. Das Ziel ist die Bereitstellung einer lückenlosen, präzisen Spezifikation, die Entwicklern die direkte Implementierung der Fehlerbehandlungsmechanismen ermöglicht, ohne eigene architektonische Entscheidungen treffen oder grundlegende Logiken entwerfen zu müssen.

### **1.2. Bezug zur Gesamtspezifikation**

Wie in Abschnitt IV. 4.3 der technischen Gesamtspezifikation festgelegt, ist die Verwendung des thiserror Crates für die Definition von benutzerdefinierten Fehlertypen obligatorisch. Diese Entscheidung basiert auf der Notwendigkeit, idiomatisches, wartbares und kontextreiches Fehlerhandling für Code zu implementieren, der als Bibliothek für andere Schichten dient – eine primäre Funktion der Kernschicht.1 thiserror erleichtert die Erstellung von Fehlertypen, die das std::error::Error Trait implementieren, erheblich.1

### **1.3. Anforderungen an die Spezifikation**

Die folgenden Anforderungen gelten für diesen Implementierungsleitfaden:

* **Höchste Präzision:** Alle Typen, Enums, Traits und Methoden im Zusammenhang mit der Fehlerbehandlung müssen exakt definiert werden, einschließlich ihrer Signaturen, Felder und abgeleiteten Traits.  
* **Eindeutigkeit:** Benennung und Semantik aller Fehlerarten müssen klar und unmissverständlich sein.  
* **Vollständigkeit:** Alle relevanten Aspekte der Fehlerbehandlungsstrategie und \-implementierung müssen abgedeckt sein.  
* **Detaillierte Anleitungen:** Schritt-für-Schritt-Anleitungen für typische Implementierungsaufgaben im Zusammenhang mit Fehlern müssen bereitgestellt werden.

## **2\. Kernschicht Fehlerbehandlungsstrategie (core::errors)**

### **2.1. Grundlagen und Prinzipien**

#### **Verwendung von thiserror**

Die Entscheidung für das thiserror Crate, wie in der Gesamtspezifikation (IV. 4.3) festgelegt, wird hier bekräftigt und als verbindlich erklärt. thiserror stellt ein deklaratives Makro (\#\[derive(Error)\]) bereit, das den Boilerplate-Code für die Implementierung des std::error::Error Traits und verwandter Traits (wie std::fmt::Display) signifikant reduziert.1 Alle benutzerdefinierten Fehler-Enums, die innerhalb der Kernschicht definiert werden, *müssen* thiserror::Error ableiten.

#### **$Result\<T, E\>$ vs. $panic\!$**

Eine strikte und konsequente Trennung zwischen der Verwendung von $Result\<T, E\>$ und $panic\!$ ist für die Stabilität und Vorhersagbarkeit des Systems unerlässlich.3 Die folgenden Regeln sind einzuhalten:

* **$Result\<T, E\>$:** Dieses Konstrukt, wobei E das std::error::Error Trait implementiert, ist der Standardmechanismus zur Signalisierung von *erwarteten*, potenziell behebbaren Fehlerzuständen zur Laufzeit. Beispiele hierfür sind fehlgeschlagene I/O-Operationen (Datei nicht gefunden), ungültige Benutzereingaben, Fehler bei der Netzwerkkommunikation oder Probleme beim Parsen von Daten. Funktionen in der Kernschicht, die solche Fehlerzustände antizipieren, *müssen* einen $Result\<T, E\>$ zurückgeben, wobei E typischerweise CoreError oder ein spezifischerer Modul-Fehler ist (siehe Abschnitt 2.2 und 2.3).  
* **$panic\!$:** Der $panic\!-Mechanismus ist ausschließlich für die Signalisierung von *nicht behebbaren Programmierfehlern* (Bugs) reserviert.3 Ein Panic tritt ein, wenn eine Funktion in einem Zustand aufgerufen wird, der gegen ihre dokumentierten Vorbedingungen (Invariants) verstößt, oder wenn ein interner Systemzustand erreicht wird, der logisch unmöglich sein sollte und auf einen Fehler in der Programmlogik hindeutet. Panics signalisieren, dass das Programm in einem inkonsistenten Zustand ist, von dem es sich nicht sicher erholen kann.

#### **Umgang mit $unwrap()$ und $expect()$**

Die Methoden $unwrap()$ und $expect()$ auf $Result$ oder $Option$ führen bei einem Err- bzw. None-Wert zu einem $panic\!$. Ihre Verwendung in produktivem Code der Kernschicht ist daher **strengstens zu vermeiden**, da sie die strukturierte Fehlerbehandlung umgehen und die Kontrolle über den Fehlerfluss dem Aufrufer entziehen.1  
Es gibt nur eine seltene Ausnahme: Wenn ein Err- oder None-Zustand an einer bestimmten Stelle *nachweislich* und *unwiderlegbar* einen Bug darstellt (d.h., eine interne Invariante wurde verletzt, die unter normalen Umständen niemals verletzt sein dürfte), *darf* $expect()$ verwendet werden. In diesem Fall *muss* die übergebene Nachricht dem "expect as precondition"-Stil folgen.3 Diese Nachricht sollte klar artikulieren, *warum* der Entwickler an dieser Stelle einen Ok- oder Some-Wert erwartet hat und welche Bedingung verletzt wurde. Beispiel:

Rust

// FALSCH (unzureichende Begründung):  
// let config\_value \= config\_map.get("required\_key").expect("Config key missing\!");

// RICHTIG (Begründung der Erwartung):  
let config\_value \= config\_map.get("required\_key")  
   .expect("Internal invariant violated: Configuration map should always contain 'required\_key' after initialization phase.");

Die Verwendung von $unwrap()$ ist generell zu unterlassen, da es keine Begründung für die Erwartung liefert.

#### **Anforderungen an Fehlermeldungen**

Fehlermeldungen, die durch das \#\[error("...")\] Attribut von thiserror für die Display-Implementierung generiert werden, müssen folgende Kriterien erfüllen:

* **Klarheit und Präzision:** Die Meldung muss das aufgetretene Problem eindeutig beschreiben.  
* **Kontext:** Sie sollte genügend Kontextinformationen enthalten (oft durch eingebettete Feldwerte wie {field\_name} im Formatstring), um Entwicklern die Diagnose des Problems zu ermöglichen, idealerweise ohne sofortigen Blick in den Quellcode.1  
* **Zielgruppe:** Die primäre Zielgruppe dieser Meldungen sind Entwickler (für Logging und Debugging). Sie können jedoch als Grundlage für benutzerfreundlichere Fehlermeldungen dienen, die in höheren Schichten (insbesondere der UI-Schicht) generiert werden.  
* **Format:** Fehlermeldungen sollten typischerweise knappe, klein geschriebene Sätze ohne abschließende Satzzeichen sein, wie in der std::error::Error Dokumentation empfohlen.4

#### **Akzeptierte Einschränkungen bei thiserror**

Die Wahl von thiserror bietet Einfachheit und reduziert Boilerplate für den häufigen Anwendungsfall der Fehlerdefinition in Bibliotheken.1 Es ist jedoch wichtig, eine spezifische Einschränkung zu verstehen, die sich aus der Funktionsweise von thiserror ergibt, insbesondere bei der Verwendung des \#\[from\]-Attributs zur automatischen Konvertierung von Quellfehlern. thiserror implementiert das std::convert::From-Trait, um die nahtlose Verwendung des ?-Operators zu ermöglichen.1 Eine Konsequenz daraus ist, dass ein bestimmter Quellfehlertyp (z.B. std::io::Error) nicht ohne Weiteres über \#\[from\] in *mehrere verschiedene Varianten* desselben Ziel-Enums (z.B. CoreError) konvertiert werden kann, da die From-Implementierung eindeutig sein muss.1  
Wenn beispielsweise ein std::io::Error sowohl beim Lesen einer Konfigurationsdatei als auch beim Schreiben in eine Log-Datei auftreten kann, können nicht einfach zwei Varianten wie ConfigReadIo(\#\[from\] std::io::Error) und LogWriteIo(\#\[from\] std::io::Error) innerhalb von CoreError definiert werden. Diese Einschränkung unterscheidet thiserror von flexibleren, aber potenziell komplexeren Fehlerbehandlungs-Frameworks wie snafu, die explizit darauf ausgelegt sind, Kontext aus dem Fehlerpfad abzuleiten.1  
Diese systembedingte Eigenschaft von thiserror erfordert eine bewusste Gestaltung der Fehlerhierarchie. Um dennoch semantisch unterschiedliche Fehlerfälle zu behandeln, die auf denselben zugrunde liegenden Fehlertyp zurückzuführen sind, wird die Strategie der Modul-spezifischen Fehler verfolgt (siehe Abschnitt 2.3). Diese spezifischen Fehler können dann eindeutig in eine dedizierte Variante des übergeordneten Fehlers (CoreError) gekapselt werden, wobei der notwendige Kontext entweder im Modul-Fehler selbst oder in der Kapselungsvariante hinzugefügt wird. Dieser Ansatz stellt sicher, dass der semantische Kontext des Fehlers erhalten bleibt, auch wenn der unmittelbare Quelltyp mehrdeutig sein könnte.

### **2.2. Definition des Basis-Fehlertyps: $CoreError$**

#### **Spezifikation**

Im Modul core::errors wird ein zentrales, öffentliches Enum namens CoreError definiert. Dieses Enum stellt die primäre Schnittstelle für Fehler dar, die von öffentlichen Funktionen der Kernschicht nach außen propagiert werden. Es aggregiert sowohl allgemeine Fehlerarten als auch spezifischere Fehler aus den Untermodulen der Kernschicht.

Rust

// In core/src/errors.rs  
use thiserror::Error;  
use std::path::PathBuf; // Beispiel für einen benötigten Typ

// Import von Modul-spezifischen Fehlern (Beispiel)  
use crate::config::errors::ConfigError;  
// use crate::utils::errors::UtilsError; // Falls vorhanden

\#  
pub enum CoreError {  
    /// Fehler bei Ein-/Ausgabeoperationen. Enthält den ursprünglichen I/O-Fehler.  
    \#\[error("I/O error accessing '{path}': {source}")\]  
    Io {  
        path: PathBuf, // Pfad zur Ressource, bei der der Fehler auftrat  
        \#\[source\] // \#\[source\] statt \#\[from\], um Kontext (path) hinzuzufügen  
        source: std::io::Error,  
    },

    /// Fehler im Zusammenhang mit der Konfigurationsverwaltung. Kapselt spezifischere ConfigError-Typen.  
    \#\[error("Configuration error: {0}")\]  
    Configuration(\#\[from\] ConfigError), // Nutzt \#\[from\] für nahtlose Konvertierung

    /// Fehler bei der Serialisierung oder Deserialisierung von Daten (z.B. JSON, TOML).  
    /// Enthält eine Beschreibung des Fehlers. Ggf. spezifischere Varianten für Serde etc. hinzufügen.  
    \#  
    Serialization { description: String },

    /// Eine ungültige ID oder ein ungültiger Bezeichner wurde verwendet.  
    \#\[error("Invalid identifier provided: '{invalid\_id}'")\]  
    InvalidId { invalid\_id: String },

    /// Ein angeforderter Wert oder eine Ressource wurde nicht gefunden.  
    \#  
    NotFound { resource\_description: String },

    /// Ein allgemeiner Fehler in einem Hilfsmodul (Beispiel für Kapselung).  
    // \#\[error("Utility error: {0}")\]  
    // Utility(\#\[from\] UtilsError), // Beispiel für Integration eines weiteren Modul-Fehlers

    /// Platzhalter für einen unerwarteten oder nicht näher spezifizierten internen Fehler.  
    /// Sollte möglichst vermieden und durch spezifischere Varianten ersetzt werden.  
    \#\[error("Internal error: {0}")\]  
    Internal(String),  
}

// Manuelle Implementierung von From\<std::io::Error\>, falls \#\[source\] verwendet wird  
// und man dennoch eine einfache Konvertierung für bestimmte Fälle braucht,  
// aber hier wollen wir Kontext (den Pfad) hinzufügen, daher ist eine manuelle  
// Erzeugung von CoreError::Io an der Fehlerquelle notwendig.  
// Beispiel:  
// std::fs::read("some/path").map\_err(|e| CoreError::Io { path: "some/path".into(), source: e })?;

#### **Ableitungen**

Das CoreError-Enum *muss* mindestens die folgenden Traits ableiten oder implementieren:

* \#: Unerlässlich für Debugging und Diagnosezwecke.  
* \#\[derive(thiserror::Error)\]: Implementiert automatisch std::error::Error und std::fmt::Display basierend auf den \#\[error(...)\]-Attributen und \#\[source\]-/\#\[from\]-Annotationen.1

#### **Fehlerverkettung (source())**

Varianten, die andere Fehler kapseln (entweder durch \#\[from\] oder \#\[source\] annotierte Felder), stellen den ursprünglichen, zugrunde liegenden Fehler über die source()-Methode des std::error::Error-Traits zur Verfügung.4 Dies ist ein fundamentaler Mechanismus für die Fehleranalyse über Schicht- und Modulgrenzen hinweg, da er es ermöglicht, die Kette der verursachenden Fehler bis zur Wurzel zurückzuverfolgen. thiserror implementiert die source()-Methode automatisch korrekt für annotierte Felder.

#### **Tabelle 1: CoreError Varianten (Initial)**

Die folgende Tabelle dient als Referenz für Entwickler und definiert den initialen "Fehlervertrag" der Kernschicht-API. Sie listet die Varianten des CoreError-Enums auf und beschreibt deren Semantik und Struktur.

| Variantenname | \#\[error("...")\] Formatstring | Enthaltene Felder | Beschreibung / Typischer Auslöser | Kapselung (\#\[from\] / \#\[source\]) |
| :---- | :---- | :---- | :---- | :---- |
| Io | I/O error accessing '{path}': {source} | path: PathBuf, source: std::io::Error | Fehler beim Lesen/Schreiben von Dateien oder anderen I/O-Ressourcen. | \#\[source\] (std::io::Error) |
| Configuration | Configuration error: {0} | ConfigError (intern) | Fehler beim Laden, Parsen oder Validieren von Konfigurationen. Kapselt ConfigError. | \#\[from\] (ConfigError) |
| Serialization | Serialization/Deserialization error: {description} | description: String | Fehler beim Umwandeln von Datenstrukturen in/aus Formaten wie JSON, TOML, etc. | \- |
| InvalidId | Invalid identifier provided: '{invalid\_id}' | invalid\_id: String | Eine verwendete ID (z.B. für eine Ressource) ist syntaktisch oder semantisch ungültig. | \- |
| NotFound | Resource not found: {resource\_description} | resource\_description: String | Eine angeforderte Ressource oder ein Wert konnte nicht gefunden werden (z.B. Schlüssel in Map). | \- |
| Internal | Internal error: {0} | String | Allgemeiner interner Fehler, der nicht spezifischer kategorisiert werden konnte. | \- |

Diese Tabelle stellt eine klare Referenz dar, welche Fehlerarten von der Kernschicht erwartet werden können und wie sie strukturiert sind. Sie ist ein wesentlicher Bestandteil der "Ultra-Feinspezifikation", da sie Entwicklern die genaue Struktur der Fehler mitteilt, die sie behandeln oder erzeugen müssen.

### **2.3. Modul-spezifische Fehler und Integration**

#### **Richtlinie**

Während CoreError den zentralen, nach außen sichtbaren Fehlertyp der Kernschicht darstellt, *dürfen* und *sollen* komplexere Module innerhalb der Kernschicht (z.B. core::config, core::utils, core::types falls dort komplexe Validierungen stattfinden) ihre eigenen, spezifischeren Fehler-Enums definieren. Diese Modul-Fehler *müssen* ebenfalls thiserror::Error ableiten.

#### **Begründung**

Diese Vorgehensweise verfolgt einen hybriden Ansatz, der die Vorteile spezifischer Fehler 2 mit der Notwendigkeit einer zentralen Fehlerschnittstelle verbindet. Sie adressiert auch direkt die zuvor beschriebene Einschränkung von thiserror bezüglich mehrdeutiger \#\[from\]-Konvertierungen. Die Definition von Modul-Fehlern bietet folgende Vorteile:

* **Feinere Granularität:** Ermöglicht eine detailliertere Darstellung von Fehlerzuständen, die spezifisch für die Logik eines Moduls sind.  
* **Bessere Kapselung:** Hält die Fehlerdefinitionen und die zugehörige Logik nahe am Code, der die Fehler erzeugt.  
* **Vermeidung von Überladung:** Verhindert, dass das zentrale CoreError-Enum mit einer übermäßigen Anzahl sehr spezifischer Varianten überladen wird, was dessen Übersichtlichkeit und Wartbarkeit beeinträchtigen würde.2

#### **Integrationsmechanismus**

Modul-spezifische Fehler müssen nahtlos in CoreError integrierbar sein, um die Fehlerpropagation mittels des ?-Operators zu gewährleisten. Der **bevorzugte Mechanismus** hierfür ist die Definition einer dedizierten Variante in CoreError, die den Modul-Fehler als einziges Feld enthält und das \#\[from\]-Attribut verwendet.

Rust

// Beispiel in core/src/config/errors.rs  
use thiserror::Error;  
use std::path::PathBuf;

\#  
pub enum ConfigError {  
    \#\[error("Failed to parse configuration file '{file\_path}': {source}")\]  
    ParseError {  
        file\_path: PathBuf,  
        // Box\<dyn Error\> für Flexibilität bei verschiedenen Parser-Fehlern (z.B. TOML, JSON)  
        \#\[source\] source: Box\<dyn std::error::Error \+ Send \+ Sync \+ 'static\>,  
    },

    \#\[error("Missing required configuration key: '{key}' in section '{section}'")\]  
    MissingKey { key: String, section: String },

    \#\[error("Invalid value for key '{key}': {reason}")\]  
    InvalidValue { key: String, reason: String },

    // Spezifischer I/O-Fehler im Kontext der Konfiguration  
    \#\[error("I/O error while accessing config '{path}': {source}")\]  
    Io {  
        path: PathBuf,  
        \#\[source\] source: std::io::Error, // Hier \#\[source\], da Kontext (path) hinzugefügt wird  
    },  
}

// Integration in core/src/errors.rs (Erweiterung von CoreError)  
// (bereits oben im CoreError Beispiel gezeigt)  
// \#\[error("Configuration error: {0}")\]  
// Configuration(\#\[from\] ConfigError),

Die Verwendung von \#\[from\] auf der CoreError::Configuration-Variante ermöglicht die automatische Konvertierung eines Result\<\_, ConfigError\> in ein Result\<\_, CoreError\> durch den ?-Operator.1

#### **Etablierung einer strukturierten Fehlerhierarchie**

Der Ansatz, einen zentralen CoreError mit integrierten, Modul-spezifischen Fehlern über \#\[from\] zu kombinieren, etabliert eine klare, zweistufige Fehlerhierarchie innerhalb der Kernschicht. Diese Struktur bietet eine gute Balance:

1. **Zentrale Schnittstelle:** Höhere Schichten interagieren primär mit dem wohldefinierten CoreError, was die Komplexität für die Nutzer der Kernschicht reduziert.  
2. **Lokale Spezifität:** Entwickler, die innerhalb eines Kernschicht-Moduls arbeiten, können mit spezifischeren, kontextbezogenen Fehlertypen (ConfigError, UtilsError, etc.) arbeiten, was die interne Logik klarer und wartbarer macht.  
3. **Nahtlose Propagation:** Die \#\[from\]-Integration stellt sicher, dass die Vorteile des ?-Operators für die Fehlerpropagation über Modulgrenzen hinweg erhalten bleiben.

Diese bewusste Strukturierung ist entscheidend für die Skalierbarkeit und Wartbarkeit der Fehlerbehandlung in einem größeren Projekt. Sie verhindert sowohl eine unübersichtliche Flut von Fehlertypen auf der obersten Ebene als auch den Verlust von spezifischem Fehlerkontext.

### **2.4. Fehlerkontext und Diagnose**

#### **Anreicherung mit Kontext**

Fehlervarianten *sollen* über die reine Fehlermeldung hinaus relevante Kontextinformationen als Felder enthalten. Diese Informationen sind entscheidend für eine effektive Diagnose und Fehlersuche.1 Beispiele für nützliche Kontextfelder sind:

* Dateipfade oder Ressourcennamen (path: PathBuf)  
* Ungültige Werte oder Eingaben (invalid\_value: String)  
* Betroffene Schlüssel oder Bezeichner (key: String, item\_id: Uuid)  
* Zustandsinformationen zum Zeitpunkt des Fehlers (z.B. index: usize, state: String)  
* Zeitstempel (falls relevant)

Rust

// Beispiel für eine Variante mit Kontextfeldern  
\#  
pub enum ProcessingError {  
    \#\[error("Failed to process item '{item\_id}' at index {index} due to: {reason}")\]  
    ItemFailure {  
        item\_id: String,  
        index: usize,  
        reason: String, // Könnte auch ein \#\[source\] Fehler sein  
    },  
    //...  
}

Die Auswahl der Kontextfelder sollte darauf abzielen, die Frage "Was ist passiert und unter welchen Umständen?" möglichst präzise zu beantworten.

#### **Backtraces**

Das thiserror-Crate bettet standardmäßig keine Backtraces in die erzeugten Fehlertypen ein, wie es bei anyhow oder eyre der Fall ist. Backtraces sind primär mit dem $panic\!-Mechanismus assoziiert und können durch Setzen der Umgebungsvariable RUST\_BACKTRACE=1 (oder full) aktiviert werden, um den Call Stack zum Zeitpunkt des Panics anzuzeigen.1  
Für die Diagnose von Fehlern, die über $Result::Err$ zurückgegeben werden, sind die primären Werkzeuge:

1. **Fehlerverkettung (source()):** Verfolgung der Ursache über die source()-Methode.4  
2. **Kontextfelder:** Analyse der in den Fehlervarianten gespeicherten Daten.  
3. **Logging:** Korrelation mit Log-Einträgen, die zum Zeitpunkt des Fehlers erstellt wurden (siehe Abschnitt 4).

Es ist nicht vorgesehen, Backtraces manuell in CoreError oder Modul-Fehler einzubetten, um die Komplexität gering zu halten und sich auf die strukturierte Fehlerinformation zu konzentrieren.

#### **Keine sensiblen Daten**

Es ist absolut entscheidend, dass Fehlermeldungen (\#\[error("...")\]) und die Werte von Kontextfeldern in Fehlervarianten **niemals** sensible Informationen enthalten. Dazu gehören insbesondere:

* Passwörter  
* API-Schlüssel oder Tokens  
* Private Benutzerdaten (Namen, Adressen, etc.)  
* Andere vertrauliche Informationen

Diese Daten dürfen unter keinen Umständen in Logs oder Diagnosedateien gelangen. Wenn solche Daten Teil des Kontexts sind, der zum Fehler führt, müssen sie vor der Aufnahme in den Fehlertyp maskiert, entfernt oder durch Platzhalter ersetzt werden.

## **3\. Implementierungsleitfaden für Entwickler**

### **3.1. Fehlerdefinition**

#### **Neue Variante zu $CoreError$ hinzufügen**

1. **Bedarf prüfen:** Stellen Sie sicher, dass der neue Fehlerfall eine allgemeine Bedeutung für die Kernschicht hat und nicht besser durch einen bestehenden oder einen neuen Modul-Fehler abgedeckt wird.  
2. **Variante definieren:** Fügen Sie eine neue Variante zum CoreError-Enum in core/src/errors.rs hinzu.  
3. **Attribute hinzufügen:** Versehen Sie das CoreError-Enum (falls noch nicht geschehen) mit \#.  
4. **Fehlermeldung (\#\[error\])**: Definieren Sie einen klaren und informativen \#\[error("...")\]-Formatstring für die neue Variante. Nutzen Sie {field\_name}-Platzhalter für Kontextfelder.  
5. **Kontextfelder:** Fügen Sie der Variante die notwendigen Felder hinzu, um den Fehlerkontext zu speichern. Definieren Sie deren Typen.  
6. **Kapselung (\#\[source\] / \#\[from\]):** Falls die Variante einen anderen Fehler kapselt:  
   * Verwenden Sie \#\[source\] auf dem Feld, wenn Sie zusätzlichen Kontext hinzufügen möchten oder der Quelltyp nicht direkt konvertiert werden soll. Die Erzeugung des Fehlers erfolgt dann manuell (z.B. via .map\_err(|e| CoreError::SomeVariant {..., source: e })).  
   * Verwenden Sie \#\[from\] auf dem Feld, wenn eine direkte, automatische Konvertierung vom Quelltyp zur Variante gewünscht ist (nur möglich, wenn der Quelltyp eindeutig dieser Variante zugeordnet werden kann).  
7. **Dokumentation:** Fügen Sie die neue Variante zur Tabelle 1 (oder einer Folgetabelle in der Dokumentation) hinzu und beschreiben Sie ihre Bedeutung und Verwendung. Aktualisieren Sie ggf. Doc-Kommentare.

#### **Neuen Modul-Fehler erstellen und integrieren**

1. **Datei erstellen:** Legen Sie eine neue Datei für die Fehler des Moduls an, typischerweise errors.rs im Modulverzeichnis (z.B. core/src/neues\_modul/errors.rs).  
2. **Enum definieren:** Definieren Sie ein neues, öffentliches Enum (z.B. pub enum NeuesModulError) und leiten Sie \# ab.  
3. **Varianten definieren:** Fügen Sie spezifische Fehlervarianten für das Modul hinzu, wie im vorherigen Abschnitt beschrieben (inkl. \#\[error\], Kontextfeldern, \#\[source\]/\#\[from\] falls interne Fehler gekapselt werden).  
4. **Integration in CoreError:**  
   * Importieren Sie den neuen Modul-Fehler in core/src/errors.rs (z.B. use crate::neues\_modul::errors::NeuesModulError;).  
   * Fügen Sie eine neue Variante zu CoreError hinzu, die den Modul-Fehler kapselt. Der bevorzugte Weg ist:  
     Rust  
     \#\[error("Neues Modul error: {0}")\] // Display delegiert an Modul-Fehler  
     NeuesModul(\#\[from\] NeuesModulError),

5. **Dokumentation:** Dokumentieren Sie den neuen Modul-Fehler (in seiner eigenen Datei) und die Integrationsvariante in CoreError (in core/src/errors.rs und der Tabelle).

### **3.2. Fehlerbehandlung im Code**

#### **Verwendung des ?-Operators**

Der ?-Operator ist das idiomatisches Mittel zur Fehlerpropagation in Rust und *sollte* standardmäßig verwendet werden, wenn eine Funktion, die $Result$ zurückgibt, eine andere Funktion aufruft, die ebenfalls $Result$ zurückgibt.

Rust

use crate::errors::CoreError;  
use crate::config::errors::ConfigError; // Beispiel Modul-Fehler

// Funktion, die einen Modul-Fehler zurückgibt  
fn load\_setting\_internal() \-\> Result\<String, ConfigError\> {  
    //... Logik...  
    if condition {  
        Ok("value".to\_string())  
    } else {  
        Err(ConfigError::MissingKey { key: "foo".to\_string(), section: "bar".to\_string() })  
    }  
}

// Funktion, die CoreError zurückgibt und intern load\_setting\_internal aufruft  
pub fn get\_setting() \-\> Result\<String, CoreError\> {  
    // Das '?' hier konvertiert ConfigError automatisch zu CoreError::Configuration  
    // dank der \#\[from\]-Annotation auf der CoreError::Configuration Variante.  
    let setting \= load\_setting\_internal()?;  
    //... weitere Logik...  
    Ok(setting)  
}

Der ?-Operator funktioniert nahtlos, solange die Fehlertypen entweder identisch sind oder eine From-Implementierung existiert (was thiserror mit \#\[from\] bereitstellt).

#### **Fehler-Matching (match)**

Wenn ein Fehler nicht nur propagiert, sondern spezifisch behandelt werden muss (z.B. um einen Standardwert zu verwenden, einen alternativen Pfad zu wählen oder den Fehler anzureichern), verwenden Sie eine match-Anweisung auf das $Result$.

Rust

use crate::errors::CoreError;  
use crate::config::errors::ConfigError;  
use tracing::warn; // Beispiel für Logging

fn handle\_config\_loading() {  
    match get\_setting() {  
        Ok(setting) \=\> {  
            println\!("Einstellung erfolgreich geladen: {}", setting);  
            //... mit der Einstellung arbeiten...  
        }  
        Err(CoreError::Configuration(ConfigError::MissingKey { ref key, ref section })) \=\> {  
            warn\!(key \= %key, section \= %section, "Konfigurationsschlüssel fehlt, verwende Standardwert.");  
            //... Standardwert verwenden...  
        }  
        Err(CoreError::Io { ref path, ref source }) \=\> {  
            // Kritischer Fehler, kann oft nicht sinnvoll behandelt werden  
            eprintln\!("FATAL: I/O Fehler beim Zugriff auf {:?}: {}", path, source);  
            // Ggf. Programm beenden oder Fehler weiter nach oben geben  
            // return Err(CoreError::Io { path: path.clone(), source: \*source }); // Beispiel für Weitergabe  
        }  
        Err(ref other\_error) \=\> {  
            // Alle anderen CoreError-Varianten behandeln  
            eprintln\!("Ein unerwarteter Kernschicht-Fehler ist aufgetreten: {}", other\_error);  
            // Allgemeine Fehlerbehandlung, ggf. weiter propagieren  
            // return Err(other\_error.clone()); // Klonen nur wenn Fehler Clone implementiert  
        }  
    }  
}

Behandeln Sie nur die Fehlerfälle, für die eine spezifische Logik sinnvoll ist. Für alle anderen Fälle sollte der Fehler entweder weiter propagiert oder in einen allgemeineren Fehler umgewandelt werden.

#### **Umgang mit externen Crates**

Fehler, die von externen Bibliotheken (Crates) zurückgegeben werden (z.B. serde\_json::Error, toml::de::Error, std::io::Error), *müssen* in einen geeigneten Fehlertyp der Kernschicht (CoreError oder einen Modul-Fehler) gekapselt werden, bevor sie die Grenzen der Kernschicht verlassen.

* **Bevorzugt mit \#\[from\]:** Wenn eine eindeutige Zuordnung des externen Fehlers zu einer Variante sinnvoll ist und keine zusätzliche Kontextinformation benötigt wird, verwenden Sie \#\[from\] auf einem Feld dieser Variante. Dies ist oft bei std::io::Error der Fall, wobei hier entschieden wurde, Kontext (path) hinzuzufügen, was \#\[source\] erfordert (siehe CoreError::Io).  
* **Mit \#\[source\]:** Wenn zusätzlicher Kontext hinzugefügt werden soll oder der externe Fehler nicht direkt einer Variante zugeordnet werden kann, verwenden Sie \#\[source\] auf einem Feld und erzeugen Sie die Fehlervariante manuell im Code mittels .map\_err().  
  Rust  
  use serde\_json;  
  use crate::errors::CoreError;

  fn parse\_json\_data(data: \&str) \-\> Result\<serde\_json::Value, CoreError\> {  
      serde\_json::from\_str(data).map\_err(|e| CoreError::Serialization {  
          description: format\!("Failed to parse JSON: {}", e),  
          // Hier wird der Fehler in einen String umgewandelt.  
          // Alternativ könnte man den Fehler boxen: source: Box::new(e)  
          // und die Variante anpassen, wenn der Originalfehler benötigt wird.  
      })  
  }

* **Manuelle Konvertierung:** In komplexeren Fällen kann eine explizite match-Anweisung auf den externen Fehler notwendig sein, um ihn auf verschiedene Varianten des Kernschicht-Fehlers abzubilden.

## **4\. Zusammenspiel mit Logging (core::logging)**

### **4.1. Verweis**

Die detaillierte Spezifikation des Logging-Frameworks (tracing) und dessen Initialisierung ist Gegenstand eines separaten Abschnitts des Kernschicht-Implementierungsleitfadens (Teil 3 oder 4, basierend auf Gesamtspezifikation IV. 4.4). Die hier beschriebenen Richtlinien beziehen sich auf die *Verwendung* des Logging-Frameworks im Kontext der Fehlerbehandlung.

### **4.2. Vorgabe: Logging von Fehlern**

Jeder Fehler, der mittels $Result::Err$ zurückgegeben wird, *sollte* an der Stelle seines Ursprungs oder an einer geeigneten übergeordneten Stelle, die über ausreichend Kontext verfügt, geloggt werden. Das Logging *muss* mindestens auf dem ERROR-Level erfolgen. Das Makro tracing::error\! ist hierfür zu verwenden.  
Das Logging sollte typischerweise *vor* der Propagation des Fehlers mittels ? oder return Err(...) geschehen, um sicherzustellen, dass der Fehler erfasst wird, auch wenn er in höheren Schichten möglicherweise abgefangen oder ignoriert wird.

### **4.3. Strukturiertes Logging**

Das tracing-Framework ermöglicht strukturiertes Logging, bei dem Schlüssel-Wert-Paare an Log-Ereignisse angehängt werden können. Es ist **dringend empfohlen**, den aufgetretenen Fehler selbst als strukturiertes Feld im Log-Eintrag mitzugeben. Dies erleichtert die automatisierte Analyse und Filterung von Logs erheblich.

Rust

use tracing::{error, instrument};  
use crate::errors::CoreError;

\#\[instrument\] // Instrumentiert die Funktion für Tracing (Span)  
fn perform\_critical\_operation(config\_path: \&std::path::Path) \-\> Result\<(), CoreError\> {  
    match std::fs::read\_to\_string(config\_path) {  
        Ok(content) \=\> {  
            //... Operation mit content...  
            Ok(())  
        }  
        Err(io\_error) \=\> {  
            // Fehler loggen, bevor er gekapselt und zurückgegeben wird  
            let core\_err \= CoreError::Io {  
                path: config\_path.to\_path\_buf(),  
                source: io\_error, // Beachten: io::Error implementiert nicht Copy/Clone  
            };

            // Strukturiertes Logging mit dem Fehler als Feld  
            // %core\_err nutzt die Display-Implementierung  
            //?core\_err würde die Debug-Implementierung nutzen  
            error\!(  
                error \= %core\_err, // Fehlerobjekt als Feld 'error'  
                file\_path \= %config\_path.display(), // Zusätzlicher Kontext  
                "Failed during critical operation while reading config" // Log-Nachricht  
            );

            Err(core\_err) // Fehler zurückgeben  
        }  
    }  
}

Die Verwendung von error \= %e (wobei e der Fehler ist) nutzt die Display-Implementierung des Fehlers für die Log-Ausgabe, während error \=?e die Debug-Implementierung verwenden würde. Die Display-Implementierung ist oft für die primäre Log-Nachricht vorzuziehen, während die Debug-Darstellung bei Bedarf für detailliertere Analysen herangezogen werden kann.

### **4.4. Fehler als integraler Bestandteil der Observability**

Die konsequente Verknüpfung von $Result::Err$-Rückgaben mit strukturiertem tracing::error\!-Logging hebt die Fehlerbehandlung über reines Debugging hinaus. Sie macht Fehler zu einem integralen Bestandteil der System-Observability. Die Kombination aus wohldefinierten, typisierten Fehlern (thiserror) und einem strukturierten Logging-Framework (tracing) schafft einen Datenstrom von Fehlerereignissen, der für Monitoring und Alerting genutzt werden kann.  
Systeme zur Log-Aggregation und \-Analyse (wie z.B. Elasticsearch/Kibana, Loki/Grafana oder spezialisierte Tracing-Backends) können diesen strukturierten Datenstrom verarbeiten. Dies ermöglicht:

* **Visualisierung:** Erstellung von Dashboards, die Fehlerraten über Zeit anzeigen, aufgeschlüsselt nach Fehlertyp (z.B. CoreError::Io vs. CoreError::Configuration).  
* **Filterung und Suche:** Gezielte Suche nach spezifischen Fehlervarianten oder Fehlern, die bestimmte Kontextdaten enthalten (z.B. alle Fehler im Zusammenhang mit einer bestimmten Datei).  
* **Alerting:** Konfiguration von Alarmen, die ausgelöst werden, wenn die Häufigkeit bestimmter Fehler einen Schwellenwert überschreitet.

Diese systematische Erfassung und Analyse von Fehlern ist entscheidend für die Aufrechterhaltung der Stabilität und Zuverlässigkeit des Systems im Betrieb und verbessert die Reaktionsfähigkeit auf Probleme erheblich.

## **5\. Ausblick**

Dieser Implementierungsleitfaden für core::errors legt das Fundament für eine robuste und konsistente Fehlerbehandlung in der gesamten Desktop-Umgebung. Die hier definierten Prinzipien, der CoreError-Typ und die Mechanismen zur Integration von Modul-Fehlern sind verbindlich für alle weiteren Entwicklungen innerhalb der Kernschicht und dienen als Vorbild für die Fehlerbehandlung in den darüberliegenden Schichten (Domäne, System, UI).  
Die nachfolgenden Teile der Kernschicht-Spezifikation, beginnend mit core::logging (Implementierung der tracing-Integration), core::config (Laden und Parsen von Konfigurationen unter Verwendung von CoreError::Configuration und ConfigError) und core::types (Definition fundamentaler Datenstrukturen mit entsprechender Fehlerbehandlung bei Validierungen), werden die hier etablierten Fehlerkonventionen konsequent anwenden und darauf aufbauen. Die disziplinierte Einhaltung dieser Fehlerstrategie ist von zentraler Bedeutung für die Entwicklung einer qualitativ hochwertigen, stabilen und wartbaren Software.


## **A3 Kernschicht Fehlerbehandlung** **1\. Fehlerbehandlung (core::errors)**

Die Fehlerbehandlung ist ein kritischer Aspekt der Systemstabilität und Wartbarkeit. Dieses Kapitel definiert die Strategien und Mechanismen für die Fehlerbehandlung innerhalb der Kernschicht (Core Layer). Ziel ist es, eine konsistente, informative und robuste Fehlerpropagierung und \-behandlung im gesamten System sicherzustellen. Die hier festgelegten Richtlinien basieren auf den allgemeinen Entwicklungsrichtlinien (Abschnitt IV.3. Fehlerbehandlung) und spezifizieren deren Anwendung innerhalb der Kernschicht.

### **1.1. Definition des Basis-Fehlertyps (CoreError)**

Zweck:  
Ein grundlegender, allgemeiner Fehlertyp für die Kernschicht, CoreError, wird definiert. Dieser dient dazu, Fehler zu repräsentieren, die direkt von generischen Kern-Dienstprogrammen stammen oder als gemeinsame Basis für Fehler innerhalb des core::errors-Moduls selbst dienen. Die Existenz von CoreError verhindert die Ad-hoc-Verwendung von unspezifischen Fehlertypen wie Box\<dyn std::error::Error\> für nicht klassifizierte Kernprobleme und stellt ein kanonisches Beispiel für die Verwendung von thiserror dar. Es ist jedoch entscheidend, dass CoreError nicht zu einem Sammelbecken für alle Arten von Fehlern wird, da die primäre Strategie auf modul-spezifischen Fehlertypen beruht (siehe Abschnitt 1.3), um Präzision und Klarheit in der Fehlerbehandlung zu gewährleisten.1  
Spezifikation:  
Der CoreError-Enum wird wie folgt definiert:

Rust

\#  
pub enum CoreError {  
    \#\[error("Core component '{component}' failed to initialize")\]  
    InitializationFailed {  
        component: String,  
        \#\[source\]  
        source: Option\<Box\<dyn std::error::Error \+ Send \+ Sync \+ 'static\>\>,  
    },

    \#\[error("Core configuration error: {message}")\]  
    ConfigurationError {  
        message: String,  
        \#\[source\]  
        source: Option\<Box\<dyn std::error::Error \+ Send \+ Sync \+ 'static\>\>,  
    },

    \#\[error("An I/O operation failed at the core level")\]  
    Io {  
        \#\[from\] // Beispiel für direkte Konvertierung eines häufigen, eindeutigen Fehlers  
        source: std::io::Error,  
    },

    \#\[error("Core internal assertion failed: {context}")\]  
    InternalAssertionFailed {  
        context: String,  
        // Diese Variante hat typischerweise keine \`source\`, da sie einen internen Logikfehler darstellt.  
    },

    // Weitere wirklich generische Core Layer Fehlervarianten können hier bei Bedarf ergänzt werden.  
    // Es ist zu vermeiden, Varianten hinzuzufügen, die spezifischen Submodulen wie config, utils etc. zugeordnet werden sollten.  
}

* **Display (\#\[error(...)\]) Nachrichten:**  
  * Die Fehlermeldungen, die durch das \#\[error(...)\]-Attribut generiert werden, *müssen* den Rust API Guidelines entsprechen: prägnant, in Kleinbuchstaben und ohne abschließende Satzzeichen (z.B. "invalid digit found in string" 3).  
  * Die Nachrichten *müssen* klar artikulieren, welches spezifische Problem aus der Perspektive des Betriebs der Kernschicht aufgetreten ist.  
  * Platzhalter (z.B. {component}, {message}) *müssen* verwendet werden, um dynamische kontextuelle Informationen in die Nachricht zu integrieren.  
  * Die Sprache *muss* so gewählt werden, dass sie für einen Entwickler, der das System debuggt, verständlich ist.  
* **Debug Format:**  
  * Die abgeleitete Debug-Implementierung ist Standard. Sie wird für detailliertes Logging und Debugging-Sitzungen verwendet, bei denen die vollständige Struktur des Fehlers, einschließlich aller Felder und der Debug-Repräsentation jeglicher \#\[source\]-Fehler, erforderlich ist.  
* **std::error::Error Trait Implementierung:**  
  * Diese wird automatisch durch \#\[derive(thiserror::Error)\] bereitgestellt. Die source()-Methode ist verfügbar, wenn eine Variante ein Feld enthält, das mit \#\[source\] oder \#\[from\] annotiert ist.

Die Varianten von CoreError *müssen* strikt auf wirklich generische Situationen beschränkt bleiben. Dieser Enum darf nicht zu einem "Catch-all"-Typ werden, da dies die Vorteile spezifischer, modulbezogener Fehlertypen untergraben würde, die eine präzise Fehlerbehandlung durch Aufrufer ermöglichen.1 Eine übermäßige Ansammlung diverser Varianten, die eigentlich zu Submodulen gehören (z.B. ConfigParseError, UtilsStringFormatError), würde CoreError zu einem monolithischen Fehlertyp machen. Die Behandlung eines solchen Fehlers würde dann umfangreiches Pattern-Matching und möglicherweise die Inspektion von Zeichenketten erfordern, was die Vorteile spezifischer Enums zunichtemacht. Daher wird sichergestellt, dass CoreError schlank bleibt und sich auf genuinely schichtweite oder spezifische Probleme des core::errors-Moduls konzentriert.  
**Tabelle 1: CoreError Enum Spezifikation**  
Die folgende Tabelle dient als eindeutige Referenz für Entwickler und als Vertrag für den CoreError-Typ, um Konsistenz über das gesamte Projekt hinweg sicherzustellen und die Anforderung einer "Ultra-Feinspezifikation" zu erfüllen.

| Variantenname | Felder | \#\[error(...)\] Format-String | Beschreibung / Verwendungszweck |
| :---- | :---- | :---- | :---- |
| InitializationFailed | component: String, source: Option\<Box\<dyn std::error::Error \+ Send \+ Sync \+ 'static\>\> (\#\[source\]) | Core component '{component}' failed to initialize | Wird verwendet, wenn eine Kernkomponente nicht initialisiert werden konnte. Enthält optional den zugrundeliegenden Fehler. |
| ConfigurationError | message: String, source: Option\<Box\<dyn std::error::Error \+ Send \+ Sync \+ 'static\>\> (\#\[source\]) | Core configuration error: {message} | Repräsentiert einen allgemeinen Konfigurationsfehler auf Kernschichtebene. |
| Io | source: std::io::Error (\#\[from\]) | An I/O operation failed at the core level | Für generische E/A-Fehler, die direkt auf der Kernschichtebene auftreten und von std::io::Error konvertiert werden können. |
| InternalAssertionFailed | context: String | Core internal assertion failed: {context} | Zeigt einen internen Logikfehler oder eine verletzte Invariante innerhalb der Kernschicht an. |

Diese tabellarische Darstellung ermöglicht es Entwicklern, alle kritischen Attribute jeder Fehlervariante – Name, enthaltene Daten, Display-Format und Zweck – sofort zu erfassen. Diese Präzision minimiert Mehrdeutigkeiten und stellt sicher, dass alle Entwickler CoreError identisch implementieren und verwenden.

### **1.2. Fehlerquellenverkettung und Kontext (Error Source Chaining and Context)**

Zweck:  
Es werden verbindliche Praktiken zur Bewahrung und Offenlegung der zugrundeliegenden Ursachen von Fehlern etabliert. Dies stellt sicher, dass ein vollständiger Diagnosepfad verfügbar ist, was das Debugging erleichtert, indem Entwickler einen Fehler bis zu seiner ursprünglichen Ursache zurückverfolgen können.1 Ein Fehlerbericht sollte die grundlegende Ursache und den vollständigen Kontext-Stack für das Debugging enthalten.  
**Spezifikationen:**

* **Verbindliche Verwendung von \#\[from\] für eindeutige direkte Konvertierungen:**  
  * Wenn eine Funktion der Kernschicht eine andere Funktion aufruft (intern, aus std oder aus einer externen Crate), die ein Result zurückgibt, und der Fehlertyp des Aufgerufenen *eindeutig und direkt* einer spezifischen Variante des thiserror-Enums des Aufrufers zugeordnet werden kann, *muss* das \#\[from\]-Attribut auf einem Feld dieser Variante verwendet werden, um eine automatische Konvertierung über den ?-Operator zu ermöglichen.  
  * Beispiel:  
    Rust  
    // In core/src/some\_module/errors.rs  
    \#  
    pub enum SomeModuleError {  
        \#\[error("A core I/O operation failed")\]  
        CoreIo(\#\[from\] std::io::Error), // Eindeutige Konvertierung von std::io::Error

        \#\[error("Failed to parse item data")\]  
        Parsing(\#\[from\] serde\_json::Error), // Eindeutige Konvertierung von serde\_json::Error  
    }

* **Manuelles Wrappen zur Hinzufügung von Kontext oder zur Auflösung von Mehrdeutigkeiten:**  
  * **Hinzufügen von Kontext:** Wenn ein Fehler eines Aufgerufenen gewrappt werden muss, um *zusätzliche kontextuelle Informationen* bereitzustellen, die für das Verständnis des Fehlers im Kontext des Aufrufers entscheidend sind (z.B. die spezifische Datei, die verarbeitet wird, der gesuchte Schlüssel), *muss* eine dedizierte Fehlervariante definiert werden. Diese Variante *muss* Felder für den zusätzlichen Kontext und ein Feld, das mit \#\[source\] annotiert ist, zur Speicherung des ursprünglichen Fehlers enthalten.  
    Rust  
    // In core/src/config/errors.rs  
    use std::path::PathBuf; // Hinzugefügt für Vollständigkeit

    \#  
    pub enum ConfigError {  
        \#\[error("Failed to load configuration from '{path}'")\]  
        LoadFailed {  
            path: PathBuf,  
            \#\[source\]  
            source: std::io::Error, // Manuell gewrappt, um 'path'-Kontext hinzuzufügen  
        },  
        //... andere Varianten  
    }

  * **Auflösung von \#\[from\]-Mehrdeutigkeiten:** Die thiserror-Crate erlaubt nicht mehrere \#\[from\]-Annotationen für den *gleichen Quellfehlertyp* innerhalb eines einzelnen Enums.1 Wenn die Operationen eines Moduls denselben zugrundeliegenden Fehlertyp (z.B. std::io::Error) aus logisch unterschiedlichen Operationen (z.B. Lesen einer Datei vs. Schreiben einer Datei) ergeben können, kann \#\[from\] nicht für beide verwendet werden. In diesem Szenario:  
    1. Es *müssen* unterschiedliche Fehlervarianten für jede logische Operation erstellt werden.  
    2. Jede solche Variante *muss* den gemeinsamen zugrundeliegenden Fehlertyp manuell unter Verwendung eines mit \#\[source\] annotierten Feldes wrappen.  
    3. Die \#\[error("...")\]-Nachricht und alle zusätzlichen kontextuellen Felder dieser Varianten *müssen* die logischen Operationen klar unterscheiden.

Rust  
// In core/src/some\_module/errors.rs  
use std::path::PathBuf; // Hinzugefügt für Vollständigkeit

\#  
pub enum FileOperationError {  
    \#\[error("Failed to read data from file '{path}'")\]  
    ReadError {  
        path: PathBuf,  
        \#\[source\]  
        source: std::io::Error, // std::io::Error aus einer Leseoperation  
    },

    \#\[error("Failed to write data to file '{path}'")\]  
    WriteError {  
        path: PathBuf,  
        \#\[source\]  
        source: std::io::Error, // std::io::Error aus einer Schreiboperation  
    },  
}  
Diese Vorgehensweise erhält die semantische Spezifität des Fehlers und ermöglicht es Aufrufern, Fehlermodi zu unterscheiden, was für eine robuste Fehlerbehandlungslogik entscheidend ist. Es wandelt eine potenzielle Einschränkung von thiserror (bei unsachgemäßer Verwendung) in ein Muster um, das zu aussagekräftigeren Fehlervarianten anregt.

* **Nutzung der source()-Methode:**  
  * Die Methode std::error::Error::source() (verfügbar bei thiserror-abgeleiteten Enums) ist der Standardmechanismus für den Zugriff auf die zugrundeliegende Ursache eines Fehlers.3  
  * Entwickler, die Fehler der Kernschicht (oder Fehler anderer Schichten) konsumieren, *müssen* sich dieser Methode bewusst sein und *sollten* sie in Logging- und Debugging-Routinen verwenden, um die Fehlerkette zu durchlaufen und die vollständige Abfolge der Ursachen zu melden.  
  * Der experimentelle sources()-Iterator 3 wäre, falls stabilisiert, der bevorzugte Weg, um die gesamte Kette zu iterieren. Bis dahin ist eine manuelle Schleife erforderlich:  
    Rust  
    // fn log\_full\_error\_chain(err: &(dyn std::error::Error \+ 'static)) {  
    //     tracing::error\!("Error: {}", err);  
    //     let mut current\_source \= err.source();  
    //     while let Some(source) \= current\_source {  
    //         tracing::error\!("  Caused by: {}", source);  
    //         current\_source \= source.source();  
    //     }  
    // }

Die Bequemlichkeit von \#\[from\] ist verlockend, aber die Einschränkung, dass nicht zwei Fehlervarianten vom selben Quelltyp abgeleitet werden können 1, kann zu einem Verlust an semantischer Unterscheidung führen, wenn sie nicht sorgfältig gehandhabt wird. Die Spezifikation begegnet dem direkt, indem sie manuelles Wrappen mit unterschiedlichen Varianten vorschreibt, wenn eine solche Mehrdeutigkeit auftritt. Dies erhält die Klarheit und nutzt thiserror dennoch effektiv. Effektives Debugging hängt von ausreichendem Kontext ab. Die \#\[source\]-Kette liefert das "Warum" ein Fehler auf einer niedrigeren Ebene aufgetreten ist, während benutzerdefinierte Felder in Fehlervarianten das "Was" und "Wo" spezifisch für die aktuelle Operation liefern.1 Durch die Vorschrift, solche Kontextfelder einzuschließen und \#\[source\] zu verwenden, wird sichergestellt, dass Fehlertypen reich an Informationen sind, was die Debugfähigkeit direkt verbessert.

### **1.3. Modul-spezifische Fehler innerhalb der Kernschicht**

Zweck:  
Durchsetzung eines modularen und spezifischen Ansatzes zur Fehlerbehandlung gemäß Richtlinie 4.3 ("spezifischen Fehler-Enums pro Modul"). Jedes logische Submodul innerhalb der Kernschicht (z.B. core::config, core::utils::string\_processing, core::types\_validation) muss seinen eigenen, distinkten Fehler-Enum definieren. Dies verbessert die Kapselung, erhöht die Klarheit für die Konsumenten des Moduls und steht im Einklang mit bewährten Praktiken.2  
**Spezifikationen:**

* **Verbindliche modul-level Fehler-Enums:**  
  * Jedes nicht-triviale öffentliche Submodul innerhalb der Kernschicht, das behebbare Fehler erzeugen kann, *muss* seinen eigenen öffentlichen Fehler-Enum definieren (z.B. pub enum ConfigError {... } in core::config::errors, pub enum ValidationRuleError {... } in core::types::validation::errors).  
  * Diese Enums *müssen* mittels \# definiert werden.  
  * Sie *müssen* allen Spezifikationen bezüglich Display-Nachrichten (Abschnitt 1.1) und Fehlerquellenverkettung/Kontext (Abschnitt 1.2) entsprechen.  
* **Granularität und Kohäsion:**  
  * Die Granularität der Fehler-Enums sollte sich an Modulgrenzen und logischen Funktionsbereichen orientieren. Ein einzelnes, großes Modul könnte einen umfassenden Fehler-Enum für seine Operationen definieren. Wenn ein Modul übermäßig groß wird oder seine Fehlerzustände zu vielfältig werden, *sollte* eine Refaktorierung in kleinere Submodule in Betracht gezogen werden, von denen jedes einen fokussierteren Fehler-Enum besitzt. Dies folgt dem Geist der Diskussion in 2 über das Gleichgewicht zwischen der Verbreitung von Fehlertypen und der Spezifität.  
  * Die Erstellung von Fehlertypen für einzelne Funktionen ist zu vermeiden, es sei denn, diese Funktion stellt eine signifikante, distinkte Einheit fehlbarer Arbeit dar.  
* **Keine direkte Propagierung von CoreError aus Submodulen:**  
  * Submodule der Kernschicht (z.B. core::config) *dürfen typischerweise nicht* den generischen CoreError (definiert in Abschnitt 1.1) zurückgeben. Sie *müssen* ihre eigenen spezifischen Fehlertypen zurückgeben (z.B. ConfigError).  
  * CoreError ist für Fehler reserviert, die innerhalb von core::errors selbst entstehen, oder für wirklich schichtweite, nicht klassifizierbare Probleme, die keinem spezifischen Submodul zugeordnet werden können.  
* **Intermodul-Fehlerkonvertierung/-wrapping (innerhalb der Kernschicht):**  
  * Wenn ein Kernschichtmodul Alpha eine Funktion eines anderen Kernschichtmoduls Beta aufruft und die Funktion von Beta Result\<T, BetaError\> zurückgibt, dann *muss* der Fehler-Enum von Alpha (AlphaError) eine Variante definieren, um BetaError zu wrappen, falls dieser Fehler propagiert werden soll.  
  * Dieses Wrapping *sollte* typischerweise \#\[from\] für die Kürze verwenden, wenn die Zuordnung innerhalb von AlphaError eindeutig ist.  
    Rust  
    // In core/src/module\_alpha/errors.rs  
    use crate::module\_beta::errors::BetaError; // Annahme: BetaError ist korrekt importiert

    \#  
    pub enum AlphaError {  
        \#\[error("An error occurred in the beta subsystem")\]  
        BetaSystemFailure(\#\[from\] BetaError),  
        //... andere AlphaError Varianten  
    }

  * Dies stellt sicher, dass Konsumenten von module\_alpha nur direkt auf AlphaError-Varianten matchen müssen, aber immer noch über AlphaError::BetaSystemFailure(...).source() auf den zugrundeliegenden BetaError zugreifen können.  
* **Handhabung von \#\[from\]-Konflikten (Wiederholung für Modulfehler):**  
  * Die Regel aus Abschnitt 1.2 bezüglich des manuellen Wrappings für mehrdeutige \#\[from\]-Quellen gilt gleichermaßen für modul-spezifische Fehler-Enums. Wenn core::config::ConfigError std::io::Error sowohl von einer Lese- als auch einer Schreiboperation repräsentieren muss, *muss* es distinkte Varianten wie ReadIoError { \#\[source\] source: std::io::Error,... } und WriteIoError { \#\[source\] source: std::io::Error,... } haben.

Modul-spezifische Fehler sind ein Eckpfeiler der Kapselung. Konsumenten eines Moduls (z.B. core::config) müssen nur ConfigError kennen, nicht die internen Fehlertypen (wie serde\_json::Error oder std::io::Error), die core::config möglicherweise handhabt und wrappt.2 Dies reduziert die Kopplung zwischen Modulen und Schichten erheblich. Würde core::config die Fehler seiner internen Abhängigkeiten direkt exponieren, wären alle Nutzer von core::config auch an diese Abhängigkeiten gekoppelt. Eine spätere Änderung der JSON-Parsing-Bibliothek in core::config würde dann alle seine Konsumenten brechen. Durch die Definition von ConfigError mit Varianten wie ParseFailure(\#\[from\] serde\_json::Error) schirmt core::config seine Konsumenten ab.  
Indem jedes Modul nur seinen eigenen Fehler-Enum definiert und exponiert, stellt die Kernschicht den höheren Schichten (Domäne, System, UI) eine abstraktere und handhabbare Menge von Fehlertypen zur Verfügung. Diese höheren Schichten wrappen dann Fehler der Kernschicht in ihre eigenen, abstrakteren Fehlertypen. Dies erzeugt eine saubere Hierarchie der Fehlerabstraktion und verhindert eine überwältigende Verbreitung spezifischer Fehlertypen auf höheren Ebenen.2 Die detaillierten Regeln für die Verwendung von thiserror, insbesondere bezüglich \#\[from\]-Mehrdeutigkeiten und manuellem Wrappen für Kontext, stellen sicher, dass die gewählte Bibliothek ihr volles Potenzial entfaltet und Fehlertypen erzeugt werden, die sowohl ergonomisch für Entwickler als auch reich an diagnostischen Informationen sind. Dies begegnet potenziellen Fallstricken, die in 1 erwähnt werden, durch die Bereitstellung konkreter, handlungsorientierter Muster.

### **1.4. Durchsetzung der Strategie für Panic vs. Error**

Zweck:  
Es wird eine strikte, unzweideutige Unterscheidung zwischen behebbaren Laufzeitfehlern (die zwingend mittels Result\<T, E\> und den oben definierten Fehlertypen behandelt werden müssen) und nicht behebbaren Programmierfehlern oder kritischen Invariantenverletzungen (die zu einem panic führen sollten) etabliert und durchgesetzt. Dies entspricht der fundamentalen Fehlerbehandlungsphilosophie von Rust.4  
**Spezifikationen:**

* **Striktes Verbot von .unwrap() und .expect() in Bibliotheks-Code der Kernschicht:**  
  * Die Verwendung der Methoden .unwrap() oder .expect() auf Result\<T, E\>- oder Option\<T\>-Typen ist in jeglichem Bibliotheks-Code der Kernschicht *strikt verboten*. Bibliotheks-Code ist definiert als jeder Code innerhalb der core-Crate, der für die Verwendung durch andere Schichten (Domäne, System, UI) oder andere Module innerhalb der Kernschicht vorgesehen ist.  
  * Alle Operationen, die auf einen behebbaren Fehler stoßen können, *müssen* explizit Result\<T, E\> zurückgeben, wobei E ein geeigneter Fehlertyp gemäß den Spezifikationen in den Abschnitten 1.1-1.3 ist. Diese strikte Regel ist der primäre Mechanismus, um sicherzustellen, dass alle potenziellen behebbaren Fehlerpfade explizit berücksichtigt und durch Rückgabe von Result behandelt werden, was fundamental für die Entwicklung robuster Software in Rust ist.4 Jeder Aufruf von .unwrap() oder .expect() in Bibliotheks-Code ist ein versteckter panic, der die gesamte Desktop-Umgebung zum Absturz bringen kann.  
* **Zulässige, wohlüberlegte Verwendung von .expect() (Nicht-Bibliotheks-Kontexte):**  
  * .expect() *darf nur* in den folgenden, gut begründeten Nicht-Bibliotheks-Kontexten verwendet werden:  
    * **Tests:** Innerhalb von Unit-Tests (\#\[test\]) und Integrationstests (in tests/), wo ein Fehlschlag einen Fehler im Test-Setup, ein Missverständnis der getesteten Komponente oder einen echten, durch den Test aufgedeckten Bug anzeigt. Der Test selbst ist die Grenze der Wiederherstellbarkeit.  
    * **Interne Werkzeuge/Binaries:** In main.rs oder Hilfsfunktionen von internen Kommandozeilenwerkzeugen, Build-Skripten oder Dienstprogrammen, die *nicht* Teil der Kernschicht-Bibliothek selbst sind und bei denen ein Fehlerzustand für die Ausführung *dieses spezifischen Werkzeugs* tatsächlich nicht behebbar ist.  
    * **Kritische Invarianten (selten):** In äußerst seltenen Situationen innerhalb des Bibliotheks-Codes, in denen eine Bedingung aufgrund vorheriger validierter Logik *garantiert* wahr ist (z.B. Zugriff auf ein Array-Element nach einer Grenzenprüfung). Wenn diese Invariante verletzt wird, signalisiert dies einen kritischen, nicht behebbaren internen Logikfehler (einen Bug). Eine solche Verwendung *muss* ausführlich kommentiert und begründet werden. Dies ist eine Ausnahme, nicht die Regel.  
* **Verbindlicher Stil für .expect()-Nachrichten:**  
  * Wenn .expect() zulässigerweise verwendet wird (wie oben definiert), *muss* die bereitgestellte Nachrichtenzeichenkette dem Stil "expect as precondition" entsprechen, wie in 4 befürwortet.  
  * Die Nachricht *darf nicht* lediglich den aufgetretenen Fehler beschreiben (was oft redundant mit der Display-Nachricht des zugrundeliegenden Fehlers ist, falls das Result ein Err enthielt).  
  * Stattdessen *muss* die Nachricht die *Vorbedingung* oder *Invariante* beschreiben, von der erwartet wurde, dass sie zutrifft, und erklären, *warum* erwartet wurde, dass die Operation erfolgreich ist.  
  * **Korrektes Beispiel (Precondition Style):**  
    Rust  
    // In einem Test oder internen Werkzeug:  
    // let config \= get\_config\_somehow(); // Platzhalter für Konfigurationsbeschaffung  
    // let user\_count: u32 \= config.get\_max\_users()  
    //    .expect("System configuration 'max\_users' should be present and valid at this point");

  * **Falsches Beispiel (Error Message Style \- NICHT VERWENDEN):**  
    Rust  
    // let user\_count \= config.get\_max\_users().expect("Failed to get max\_users"); // SCHLECHTER STIL

Die Übernahme des "expect as precondition"-Stils für Panic-Nachrichten 4 verwandelt Panics von einfachen Absturzberichten in wertvolle Diagnosewerkzeuge. Diese Nachrichten erklären die verletzten Annahmen des Programmierers und lenken die Debugging-Bemühungen direkt auf den logischen Fehler. Eine Nachricht wie "env variable 'IMPORTANT\_PATH' should be set by 'wrapper\_script.sh'" 4 ist weitaus informativer als "env variable 'IMPORTANT\_PATH' is not set".

* **Direkte Verwendung des panic\!-Makros:**  
  * Direkte Aufrufe von panic\!("message") *sollten* Situationen vorbehalten bleiben, in denen das Programm einen nicht wiederherstellbaren Zustand, eine verletzte kritische Invariante oder eine logische Unmöglichkeit feststellt, die eindeutig auf einen Bug im eigenen Code der Kernschicht hinweist.  
  * Die Panic-Nachricht *sollte* klar und informativ sein und Entwicklern bei der Diagnose des Bugs helfen.  
  * Panicking ist angebracht, wenn eine Fortsetzung der Ausführung zu weiteren Fehlern, Datenkorruption oder undefiniertem Verhalten führen würde.

# **A4 Kernschicht: Kerninfrastruktur (Teil 4/4)**

## **1\. Einleitung**

Dieses Dokument ist Teil 4 der Spezifikation für die Kernschicht (Core Layer) und konzentriert sich auf die Definition der fundamentalen Infrastrukturkomponenten. Diese Komponenten bilden das Rückgrat für alle darüberliegenden Schichten der Desktop-Umgebung und umfassen die Fehlerbehandlung, das Logging-System, Mechanismen zur Konfigurationsverwaltung sowie grundlegende Datentypen und Hilfsfunktionen.  
Ziel dieses Dokuments ist es, eine ultra-feingranulare Spezifikation bereitzustellen, die es Entwicklern ermöglicht, diese Kerninfrastrukturelemente direkt zu implementieren. Jede Komponente, Methode, Datenstruktur und Richtlinie wird detailliert beschrieben, um Klarheit zu gewährleisten und Designentscheidungen vorwegzunehmen. Die hier definierten Systeme sind entscheidend für die Stabilität, Wartbarkeit, Diagnosefähigkeit und Konsistenz der gesamten Desktop-Umgebung.  
Die folgenden Abschnitte behandeln:

* **Fehlerbehandlungsinfrastruktur (core::errors)**: Definition eines robusten und konsistenten Ansatzes zur Fehlerbehandlung unter Verwendung der thiserror-Crate.  
* **Core Logging Infrastruktur (core::logging)**: Spezifikation eines strukturierten Logging-Systems basierend auf der tracing-Crate.  
* **Core Konfigurationsprimitive (core::config)**: Festlegung von Mechanismen zum Laden, Parsen und Zugreifen auf Basiskonfigurationen.  
* **Core Utilities (core::utils)**: Richtlinien für allgemeine Hilfsfunktionen.  
* **Core Datentypen (core::types)**: Definition fundamentaler, systemweit genutzter Datentypen.

Die sorgfältige Implementierung dieser Infrastrukturkomponenten ist unerlässlich, da sie die Qualität und Zuverlässigkeit aller anderen Teile des Systems maßgeblich beeinflussen.

## **2\. Fehlerbehandlungsinfrastruktur (core::errors)**

Eine robuste und aussagekräftige Fehlerbehandlung ist das Fundament stabiler Software. Für die Kernschicht, die von allen anderen Schichten genutzt wird, ist dies von besonderer Bedeutung. Die hier definierte Infrastruktur zielt auf Klarheit, Konsistenz und einfache Nutzung für Entwickler ab.

### **2.1. Grundlagen und Wahl von thiserror**

Die Fehlerbehandlung in Rust basiert auf dem Result\<T, E\>-Enum, wobei E typischerweise den std::error::Error-Trait implementiert.1 Für die Definition benutzerdefinierter Fehlertypen wird die Crate thiserror eingesetzt. Diese Wahl begründet sich dadurch, dass thiserror speziell für Bibliotheken konzipiert ist, im Gegensatz zu anyhow, das eher für Applikationen (Binaries) gedacht ist.1 Die Kernschicht und viele Teile der Domänen- und Systemschicht fungieren als Bibliotheken für andere Teile der Desktop-Umgebung.  
thiserror bietet folgende Vorteile:

* Es generiert Boilerplate-Code für die Implementierung des std::error::Error-Traits.  
* Es ermöglicht die einfache Definition von Fehlermeldungen über das \#\[error(...)\]-Attribut.  
* Es unterstützt die Konvertierung von zugrundeliegenden Fehlern mittels des \#\[from\]-Attributs, was die Verwendung des ?-Operators erleichtert.1

### **2.2. Granularität: Ein Fehler-Enum pro Modul**

Um eine klare Struktur und gute Verwaltbarkeit der Fehlertypen zu gewährleisten, wird festgelegt, dass jedes signifikante Modul innerhalb der Kernschicht (und konsequenterweise auch in den höheren Schichten) sein eigenes, spezifisches Fehler-Enum definiert.2 Dies stellt einen guten Kompromiss zwischen der Notwendigkeit spezifischer Fehlerbehandlung und der Vermeidung einer übermäßigen Anzahl globaler oder unspezifischer Fehlertypen dar.  
Eine potenzielle Einschränkung von thiserror ist, dass man nicht zwei Fehlervarianten vom selben Ursprungstyp (source type) definieren kann, wenn man \#\[from\] direkt verwendet, was dazu führen könnte, dass der Kontext verloren geht (z.B. ob ein std::io::Error beim Lesen oder Schreiben auftrat).1 Die Strategie, pro Modul ein eigenes Fehler-Enum zu definieren, mildert dieses Problem erheblich. Selbst wenn sowohl ModuleAError als auch ModuleBError einen std::io::Error wrappen, liefert bereits der Typ des Fehler-Enums (ModuleAError vs. ModuleBError) wichtigen Kontext. Innerhalb eines Modul-Enums können zudem spezifische Varianten erstellt werden, die denselben zugrundeliegenden Fehlertyp wrappen, aber unterschiedliche Operationen oder Kontexte repräsentieren. Zum Beispiel könnte ein ConfigError-Enum Varianten wie ReadError { path: PathBuf, \#\[source\] source: std::io::Error } und ParseError { path: PathBuf, \#\[source\] source: serde\_toml::Error } haben. Dies stellt sicher, dass der Kontext nicht "verwischt" wird, wie in 1 als potenzielle Herausforderung beschrieben. Die Kombination aus modul-spezifischen Enums und sorgfältig benannten Varianten mit kontextuellen Feldern sorgt für die notwendige Klarheit.

### **2.3. thiserror Implementierungsrichtlinien und Pro-Modul Fehler-Enums**

Für jedes Modul, das Fehler erzeugen kann, muss ein Fehler-Enum mit thiserror definiert werden.  
Strukturbeispiel:  
Angenommen, es gibt ein Modul core::some\_module:

Rust

// In core::some\_module::error.rs (oder direkt im Modul)  
use std::path::PathBuf;  
use thiserror::Error;

\#  
pub enum SomeModuleError {  
    \#\[error("Fehler bei der Initialisierung der Komponente: {reason}")\]  
    InitializationFailure { reason: String },

    \#\[error("Ungültiger Parameter '{parameter\_name}': {details}")\]  
    InvalidParameter { parameter\_name: String, details: String },

    \#  
    IoError {  
        operation: String,  
        path: PathBuf,  
        \#\[source\]  
        source: std::io::Error,  
    },

    \#  
    DeserializationError {  
        path: PathBuf,  
        \#\[source\]  
        source: serde\_json::Error, // Beispiel für einen spezifischen Deserialisierungsfehler  
    },

    \#\[error("Feature '{feature\_name}' ist nicht verfügbar.")\]  
    FeatureUnavailable { feature\_name: String },

    \#  
    DependentServiceError {  
        service\_name: String,  
        \#\[source\]  
        source: Box\<dyn std::error::Error \+ Send \+ Sync \+ 'static\>, // Für generische Fehler von Abhängigkeiten  
    },  
}

**\#\[error(...)\]-Annotationen:**

* Die Fehlermeldungen müssen primär entwicklerorientiert sein: präzise, informativ und klar verständlich.  
* Sie müssen den Grund des Fehlers erläutern und wichtige kontextuelle Parameter (z.B. Dateipfade, Parameternamen, fehlerhafte Werte) über die Felder der Enum-Variante einbinden (z.B. {parameter\_name}).  
* Der Stil der Meldungen soll konsistent sein: typischerweise in Kleinschreibung, prägnant und ohne abschließende Satzzeichen, es sei denn, diese sind Teil eines zitierten Literals.3  
* Die Meldungen sollen dazu beitragen, die "Grundursache" des Fehlers zu verstehen.1 Obwohl die "Benutzerperspektive" in 1 erwähnt wird, ist der "Benutzer" eines Core-Layer-Fehlers typischerweise ein anderer Entwickler, der diese Schicht verwendet.

**\#\[from\]-Annotationen:**

* Das \#\[from\]-Attribut wird verwendet, um Fehler von anderen Typen (z.B. std::io::Error, Fehler aus anderen Kernschichtmodulen oder externen Crates) transparent in eine Variante des aktuellen Modul-Fehler-Enums zu konvertieren.  
* Dies ist entscheidend für die ergonomische Fehlerweitergabe mittels des ?-Operators.  
* **Spezifikation**: \#\[from\] ist dann angemessen, wenn ein externer Fehlertyp direkt einer *semantisch eindeutigen* Fehlerbedingung innerhalb des Moduls zugeordnet werden kann. Falls ein externer Fehlertyp aus mehreren unterschiedlichen Operationen innerhalb des Moduls resultieren kann, sind spezifische Varianten zu erstellen, die den Ursprungsfehler mit zusätzlichem Kontext umhüllen (wie im IoError-Beispiel oben, das ein operation-Feld und path-Feld enthält). Dies vermeidet Ambiguität und stellt sicher, dass der Fehlertyp selbst bereits maximalen Kontext liefert.

**Kontextuelle Informationen:**

* Fehlervarianten müssen Felder enthalten, die relevante kontextuelle Informationen zum Zeitpunkt der Fehlererzeugung erfassen (z.B. Dateipfade, betroffene Werte, Operationsnamen). Dies unterstützt die Forderung nach einem "vollständigen Kontext-Stack" für Debugging-Zwecke.1

**Tabelle: Übersicht der Kernmodul-Fehler-Enums (Auszug)**

| Modulpfad | Fehler-Enum-Name | Schlüssekvarianten (illustrativ) | Primäre \#\[from\] Quellen (Beispiele) |
| :---- | :---- | :---- | :---- |
| core::config | ConfigError | FileReadError, DeserializationError, MissingKeyError | std::io::Error, serde\_toml::de::Error |
| core::utils::json | JsonUtilError | SerializationError, DeserializationError | serde\_json::Error |
| core::ipc | IpcError | ConnectionFailed, MessageSendError, ResponseTimeout | zbus::Error (falls zbus verwendet wird) |
| core::types::color | ColorParseError | InvalidHexFormat, InvalidHexDigit | std::num::ParseIntError |

*Begründung für den Wert der Tabelle*:

1. **Auffindbarkeit**: Bietet Entwicklern einen schnellen Überblick über alle benutzerdefinierten Fehlertypen innerhalb der Kernschicht.  
2. **Konsistenz**: Fördert einen standardisierten Ansatz für die Benennung und Strukturierung von Fehler-Enums über Module hinweg.  
3. **Modulübergreifendes Verständnis**: Hilft Entwicklern zu verstehen, welche Arten von Fehlern beim Aufruf von Funktionen aus verschiedenen Kernmodulen zu erwarten sind, was eine bessere Fehlerbehandlung im aufrufenden Code ermöglicht.  
4. **Wartung**: Dient als Checkliste bei Code-Reviews, um sicherzustellen, dass neue Module ihre Fehlertypen gemäß den Projektspezifikationen korrekt definiert haben.

### **2.4. Fehlerweitergabe, \-konvertierung und \-verkettung**

* **?-Operator**: Die Verwendung des ?-Operators ist für die Weitergabe von Result-Fehlern den Aufrufstack hinauf verbindlich vorgeschrieben. Dies ist idiomatisches Rust und verbessert die Lesbarkeit des Codes erheblich.  
* **\#\[from\] zur Konvertierung**: Wie oben detailliert, ist \#\[from\] (bereitgestellt durch thiserror) der primäre Mechanismus zur Konvertierung eines Fehlertyps in einen anderen, was die Nutzung von ? erleichtert.  
* **source()-Verkettung**: Es ist sicherzustellen, dass das \#\[source\]-Attribut von thiserror auf dem Feld verwendet wird, das den zugrundeliegenden Fehler enthält. Dies ermöglicht es Konsumenten, die vollständige Fehlerkette über std::error::Error::source() zu inspizieren, was für das Debugging komplexer Probleme, die sich über mehrere Module oder Operationen erstrecken, unerlässlich ist.3 Die source()-Kette ist das programmatische Äquivalent des in 1 erwähnten "virtuellen Benutzer-Stacks". Jede Ebene der source()-Aufrufe enthüllt eine tiefere Ursache des Fehlers. Wenn ein Fehler E1 einen Ursprungsfehler E2 (der wiederum E3 usw. wrappen könnte) umschließt, rekonstruiert die Iteration durch e1.source(), dann e1.source().unwrap().source() usw. effektiv die kausale Fehlerkette. Diese Kette liefert den "vollständigen Kontext-Stack", indem sie zeigt, wie sich ein Low-Level-Fehler durch verschiedene Abstraktionsschichten fortgepflanzt und transformiert hat. Daher ist die konsistente und korrekte Verwendung von \#\[source\] für die Erreichung der Debugging-Ziele von entscheidender Bedeutung.

### **2.5. Fehlerkontext und entwicklerorientiertes Reporting**

* **Hinzufügen von Kontext**: Über die \#\[error(...)\]-Nachricht hinaus müssen Funktionen, die Result zurückgeben, sicherstellen, dass die von ihnen konstruierten Fehlerwerte genügend Informationen enthalten, damit ein Entwickler den Zustand verstehen kann, der zum Fehler geführt hat. Dies bedeutet oft, Fehlervarianten mit spezifischen Feldern zu erstellen, die diesen Zustand erfassen.  
* **Integration mit core::logging**: Wenn ein Fehler behandelt wird (d.h. nicht weiter mit ? propagiert wird), sollte er typischerweise mit der core::logging-Infrastruktur (siehe Abschnitt 3\) protokolliert werden. Der Log-Eintrag sollte die vollständigen Fehlerinformationen enthalten, oft durch Protokollierung der Debug-Repräsentation des Fehlers, die die source-Kette einschließt.  
  * Beispiel: tracing::error\!(error \=?e, "Kritische Operation X fehlgeschlagen");  
* **Keine sensiblen Daten**: Es wird die strikte Richtlinie wiederholt: Fehlermeldungen und protokollierte Fehlerdetails dürfen *niemals* Passwörter, API-Schlüssel, personenbezogene Daten (PII) oder andere sensible Informationen enthalten. Redaktion oder Auslassung ist erforderlich, wenn solche Daten peripher an einer Fehlerbedingung beteiligt sind.

### **2.6. Panic-Strategie (Core Layer Spezifika)**

Panics signalisieren nicht behebbare Fehler, die typischerweise auf Programmierfehler hinweisen.4 Ihre Verwendung in der Kernschicht muss streng kontrolliert werden.

* **Verbot in Bibliothekscode**: Panics (unwrap(), expect(), panic\!) sind in Code der Kernschicht, der für die allgemeine Nutzung durch andere Schichten vorgesehen ist, strikt verboten. Funktionen und Methoden müssen für alle fehleranfälligen Operationen Result zurückgeben.  
* **Zulässige Verwendungen**:  
  * **Nicht behebbare Initialisierung**: In den frühesten Phasen des Anwendungsstarts, wenn eine fundamentale Ressource nicht initialisiert werden kann und die Anwendung unmöglich fortfahren kann (z.B. eine kritische Konfigurationsdatei ist fehlerhaft und es gibt keine Standardwerte), kann ein Panic als letztes Mittel akzeptabel sein.  
  * **Tests**: unwrap() und expect() sind in Testcode zulässig und oft idiomatisch, um Bedingungen zu assertieren, die *unbedingt* gelten müssen.  
  * **Interne Invarianten**: In seltenen Fällen kann expect() verwendet werden, um eine interne Invariante zu assertieren, die logischerweise *niemals* verletzt werden sollte. Wenn sie es doch wird, deutet dies auf einen Fehler in der Kernschicht selbst hin.  
* **expect()-Nachrichtenstil**: Wenn expect() in den zulässigen Szenarien verwendet wird, *muss* die Nachricht dem Stil "expect as precondition" (Erwartung als Vorbedingung) folgen.4 Die Nachricht sollte beschreiben, *warum* erwartet wurde, dass die Operation erfolgreich ist, und nicht nur den Fehler wiederholen.  
  * Beispiel: let config\_value \= map.get("critical\_key").expect("critical\_key sollte in der beim Start geladenen Standardkonfiguration vorhanden sein"); Der Stil "expect as precondition" ist dem Stil "expect as error message" überlegen, da er dem Entwickler, der den Panic debuggt, neue Informationen hinzufügt.4 Er erklärt die verletzte Annahme, während "expect as error message" oft nur wiederholt, was der zugrundeliegende Fehler bereits aussagt (z.B. Panic-Nachricht: "...ist nicht gesetzt: Nicht vorhanden"). Durch die Fokussierung auf das, was hätte wahr sein *sollen*, wird der Kontext über den beabsichtigten Zustand und die Annahmen des Programms verdeutlicht. Dies erleichtert das Debugging, da es unmittelbar auf eine fehlerhafte Annahme oder einen Fehler in einem vorangegangenen Schritt hinweist, der diese Vorbedingung hätte herstellen sollen. Für die Kernschicht, wo Robustheit und Klarheit an erster Stelle stehen, verbessert die Durchsetzung dieses Stils für die seltenen Fälle von expect() die Wartbarkeit und Fehlerdiagnose.

## **3\. Core Logging Infrastruktur Spezifikation (core::logging)**

Diese Sektion definiert die standardisierte Logging-Infrastruktur für die gesamte Desktop-Umgebung, basierend auf der tracing-Crate, wie in der Gesamtarchitektur (Abschnitt 4.4) festgelegt. Das Modul core::logging wird Initialisierungsroutinen und potenziell gemeinsame Logging-Makros oder Hilfsfunktionen bereitstellen, obwohl die Makros von tracing selbst in der Regel ausreichend sind.

### **3.1. tracing Framework Integrationsdetails**

* **Initialisierung**:  
  * Eine dedizierte Funktion, z.B. pub fn initialize\_logging(level\_filter: tracing::LevelFilter, format: LogFormatEnum) \-\> Result\<(), LoggingError\>, muss bereitgestellt werden. Diese Funktion wird sehr früh im Anwendungslebenszyklus aufgerufen (z.B. in main.rs).  
  * Sie konfiguriert einen globalen Standard tracing\_subscriber.  
  * LogFormatEnum könnte Varianten wie PlainTextDevelopment, JsonProduction definieren.  
  * LoggingError wäre ein Enum, das mit thiserror im Modul core::logging definiert wird (z.B. für Fehler beim Setzen des globalen Subscribers).  
* **Subscriber-Konfiguration**:  
  * Für Entwicklungs-Builds (LogFormatEnum::PlainTextDevelopment): tracing\_subscriber::fmt() mit with\_ansi(true) (falls Terminal es unterstützt), with\_target(true) (zeigt Modulpfad), with\_file(true), with\_line\_number(true) und dem übergebenen level\_filter. Dies liefert eine reichhaltige, menschenlesbare Ausgabe.  
  * Für Release-Builds (LogFormatEnum::JsonProduction): Es wird ein strukturiertes Format wie JSON empfohlen, um die Log-Aggregation und maschinelle Analyse zu erleichtern.2 Dies kann über tracing\_subscriber::fmt::json() oder spezialisierte Formatter wie tracing-bunyan-formatter erreicht werden. Die Wahl des Formats kann ein Argument für initialize\_logging sein.  
* **Dynamische Log-Level-Änderungen**: Obwohl keine V1-Anforderung für core::logging selbst, sollte das Subscriber-Setup im Hinblick auf mögliche zukünftige Anforderungen an dynamische Log-Level-Anpassungen (z.B. über ein D-Bus-Signal oder Neuladen einer Konfigurationsdatei) gestaltet sein. tracing\_subscriber::filter::EnvFilter oder benutzerdefinierte Filter-Implementierungen können dies unterstützen. EnvFilter erlaubt es, den Log-Level über eine Umgebungsvariable (z.B. RUST\_LOG) zu steuern.

### **3.2. Standardisierte Log-Makros und tracing::instrument Verwendung**

* **Standard-Makros**: Die direkte Verwendung der tracing-Makros (trace\!, debug\!, info\!, warn\!, error\!) ist verbindlich vorgeschrieben.  
* **Log-Nachrichtenstruktur**:  
  * Nachrichten sollten prägnant und beschreibend sein.  
  * Für strukturierte Daten sind Schlüssel-Wert-Paare zu verwenden: tracing::info\!(user\_id \= %user.id, action \= "login", "Benutzer hat sich angemeldet"); (Verwendung von % für Display-Implementierungen, ? für Debug).  
  * Fehler sollten mit dem Feld error protokolliert werden: tracing::error\!(error \=?err, "Anfrage konnte nicht verarbeitet werden");. Das ?-Zeichen stellt sicher, dass die Debug-Repräsentation des Fehlers (einschließlich der source-Kette) erfasst wird.  
* **\#\[tracing::instrument\] Verwendung**:  
  * **Zweck**: Erzeugt Spans für Funktionen oder Codeblöcke, die kontextuelle Informationen (einschließlich Timing) liefern und nachfolgende Log-Ereignisse innerhalb dieses Spans gruppieren.  
  * **Richtlinien**:  
    * Anwendung auf öffentliche API-Funktionen signifikanter Module, insbesondere solche, die I/O oder komplexe Berechnungen beinhalten.  
    * Anwendung auf Funktionen, die abgeschlossene operative Einheiten oder Phasen in einem Prozess darstellen.  
    * Verwendung von skip(...) oder skip\_all, um die Protokollierung sensibler oder übermäßig ausführlicher Argumente zu vermeiden.  
    * Verwendung von fields(...), um dem Span spezifischen Kontext hinzuzufügen, z.B. \#\[tracing::instrument(fields(entity.id \= %entity.id))\].  
    * Die Option err kann verwendet werden, um Fehler automatisch auf dem ERROR-Level zu erfassen, wenn die instrumentierte Funktion ein Result::Err zurückgibt: \#\[tracing::instrument(err)\].  
    * Das level Attribut kann verwendet werden, um das Level des Spans selbst zu steuern (z.B. \#\[tracing::instrument(level \= "debug")\]).

**Tabelle: tracing::instrument Verwendungsmuster**

| Szenario | \#\[tracing::instrument\] Attribute | Begründung |
| :---- | :---- | :---- |
| Öffentlicher API-Einstiegspunkt | level \= "debug" (oder info für sehr wichtige APIs) | Nachverfolgung aller Aufrufe öffentlicher APIs für Audit- und Debugging-Zwecke. |
| I/O-Operation (z.B. Datei lesen) | fields(path \= %file\_path.display()), err | Kontextualisierung der Operation mit relevanten Daten (Dateipfad) und automatische Fehlerprotokollierung. |
| Komplexe Berechnung | skip\_all (falls Argumente groß/komplex), fields(param\_count \= args.len()) | Vermeidung der Protokollierung großer Datenstrukturen, aber Erfassung von Metadaten über die Eingabe. |
| Ereignisbehandlung | fields(event.type \= %event.kind()) | Verknüpfung von Log-Einträgen mit spezifischen Ereignistypen für eine einfachere Analyse. |
| Funktion mit sensiblen Argumenten | skip(password, api\_key) oder skip\_all | Sicherstellung, dass keine sensiblen Daten versehentlich protokolliert werden. |

*Begründung für den Wert der Tabelle*:

1. **Konsistenz**: Stellt sicher, dass \#\[tracing::instrument\] einheitlich und effektiv im gesamten Code verwendet wird.  
2. **Performance-Bewusstsein**: Leitet Entwickler an, wann und wie skip verwendet werden sollte, um Performance-Overhead durch übermäßige Protokollierung von Argumenten zu vermeiden.  
3. **Debuggabilität**: Fördert die Erstellung gut definierter Spans, die das Verständnis des Kontrollflusses und die Diagnose von Problemen in verteilten oder asynchronen Operationen erheblich erleichtern.  
4. **Best Practices**: Kodifiziert bewährte Verfahren für die Instrumentierung verschiedener Arten von Funktionen und reduziert das Rätselraten für Entwickler.

### **3.3. Log-Daten Sensibilität und Redaktionsrichtlinie**

* **Striktes Verbot**: Absolut keine sensiblen Daten (Passwörter, API-Schlüssel, PII, Finanzdetails, Gesundheitsinformationen usw.) dürfen im Klartext protokolliert werden.  
* **Redaktion/Auslassung**: Wenn auf eine Variable, die sensible Daten enthält, Bezug genommen werden *muss* (z.B. wegen ihrer Existenz oder ihres Typs), sollte sie redigiert (z.B. password: "\*\*\*") oder vollständig aus den Log-Feldern entfernt werden.  
* **Debug-Trait-Bewusstsein**: Vorsicht ist geboten beim Ableiten von Debug für Strukturen, die sensible Informationen enthalten. Wenn solche Strukturen über ? protokolliert werden (z.B. error \=?sensitive\_struct), muss ihre Debug-Implementierung eine Redaktion durchführen. Benutzerdefinierte Debug-Implementierungen oder Wrapper-Typen, die die Redaktion handhaben, sind in Betracht zu ziehen.  
* **\#\[tracing::instrument(skip\_all)\]**: Ein primäres Werkzeug, um die versehentliche Protokollierung aller Funktionsargumente zu verhindern. Selektive fields können dann wieder hinzugefügt werden.

Die Verantwortung für die Datensensibilität in Logs ist verteilt. Während core::logging den Mechanismus bereitstellt, muss jedes Modul und jeder Entwickler, der Logging-Anweisungen schreibt oder Debug ableitet, wachsam sein. Das tracing-Framework protokolliert Daten basierend auf dem, was Entwickler in Makros bereitstellen oder was Debug-Implementierungen ausgeben. \#\[tracing::instrument\] kann Funktionsargumente automatisch protokollieren, wenn sie nicht übersprungen werden. Eine zentrale Logging-Richtlinie (wie "keine sensiblen Daten") ist unerlässlich. Das Modul core::logging selbst kann diese Richtlinie jedoch nicht für den *Inhalt* der Logs erzwingen; es stellt nur die Infrastruktur bereit. Daher muss die Richtlinie von den Entwicklern im gesamten Code durch sorgfältige Logging-Praktiken, skip-Attribute und gegebenenfalls benutzerdefinierte Debug-Implementierungen aktiv umgesetzt werden. Dies impliziert die Notwendigkeit von Entwicklerschulungen und Code-Review-Checklisten, die sich auf die Sensibilität von Log-Daten konzentrieren.

## **4\. Core Konfigurationsprimitive Spezifikation (core::config)**

Dieser Abschnitt definiert, wie die Kernschicht und nachfolgend andere Schichten grundlegende Konfigurationseinstellungen laden, parsen und darauf zugreifen. Der Fokus liegt auf Einfachheit, Robustheit und der Einhaltung von XDG-Standards, wo dies für benutzerspezifische Überschreibungen relevant ist (obwohl Konfigurationen der Kernschicht wahrscheinlich systemweit oder Standardeinstellungen sind).

### **4.1. Konfigurationsdateiformat(e) und Parsing-Logik**

* **Format**: TOML (Tom's Obvious, Minimal Language) wird aufgrund seiner guten Lesbarkeit für Menschen und der einfachen Verarbeitung durch Maschinen ausgewählt.  
* **Parsing-Bibliothek**: Das serde-Framework in Verbindung mit der toml-Crate (serde\_toml) wird für die Deserialisierung verwendet.  
* **Ladelogik**:  
  1. Definition von Standard-Konfigurationspfaden (z.B. /usr/share/YOUR\_DESKTOP\_ENV\_NAME/core.toml für Systemstandards, /etc/YOUR\_DESKTOP\_ENV\_NAME/core.toml für systemweite Überschreibungen, und potenziell ein Pfad für Entwicklungstests, z.B. relativ zum Projekt-Root). Die XDG Base Directory Specification ($XDG\_CONFIG\_DIRS, $XDG\_CONFIG\_HOME) sollte für benutzerspezifische Konfigurationen in höheren Schichten berücksichtigt werden, ist aber für core.toml (als Basiskonfiguration) möglicherweise weniger relevant, wenn es sich um reine Systemstandards handelt.  
  2. Eine Funktion wie pub fn load\_core\_config(custom\_path: Option\<PathBuf\>) \-\> Result\<CoreConfig, ConfigError\> wird verantwortlich sein. Sie würde eine definierte Suchreihenfolge für Konfigurationsdateien implementieren (z.B. custom\_path falls gegeben, dann Entwicklungspfad, dann Systempfade).  
  3. Sie versucht, den Inhalt der TOML-Datei vom ersten gefundenen Pfad zu lesen.  
  4. Verwendet serde\_toml::from\_str() zur Deserialisierung des Inhalts in die CoreConfig-Struktur.  
  5. Behandelt I/O-Fehler (Datei nicht gefunden, Zugriff verweigert) und Parsing-Fehler (fehlerhaftes TOML, Typ-Inkonsistenzen) und konvertiert sie in entsprechende Varianten von core::config::ConfigError.  
* **Fehlerbehandlung**: Ein core::config::ConfigError-Enum (unter Verwendung von thiserror) wird definiert, mit Varianten wie:  
  Rust  
  use std::path::PathBuf;  
  use thiserror::Error;

  \#  
  pub enum ConfigError {  
      \#\[error("Fehler beim Lesen der Konfigurationsdatei '{path:?}': {source}")\]  
      FileReadError {  
          path: PathBuf,  
          \#\[source\]  
          source: std::io::Error,  
      },  
      \#\[error("Fehler beim Parsen der Konfigurationsdatei '{path:?}': {source}")\]  
      DeserializationError {  
          path: PathBuf,  
          \#\[source\]  
          source: serde\_toml::de::Error,  
      },  
      \#\[error("Keine Konfigurationsdatei gefunden an den geprüften Pfaden: {checked\_paths:?}")\]  
      NoConfigurationFileFound { checked\_paths: Vec\<PathBuf\> },  
      // Ggf. weitere Varianten für Validierungsfehler, falls nicht in Deserialisierung abgedeckt  
  }

### **4.2. Konfigurationsdatenstrukturen (Ultra-Fein)**

* **CoreConfig-Struktur**: Eine primäre Struktur, z.B. CoreConfig, wird in core::config definiert, um alle spezifischen Konfigurationen der Kernschicht zu halten.  
  Rust  
  use serde::Deserialize;  
  use std::path::PathBuf; // Beispiel für einen komplexeren Typ

  // Beispiel für ein Enum, das in der Konfiguration verwendet wird  
  \#  
  \#\[serde(rename\_all \= "lowercase")\] // Erlaubt "info", "debug" etc. in TOML  
  pub enum LogLevelConfig {  
      Trace,  
      Debug,  
      Info,  
      Warn,  
      Error,  
  }

  impl Default for LogLevelConfig {  
      fn default() \-\> Self { LogLevelConfig::Info }  
  }

  \#  
  \#\[serde(deny\_unknown\_fields)\] // Strikte Prüfung auf unbekannte Felder  
  pub struct CoreConfig {  
      \#\[serde(default \= "default\_log\_level")\]  
      pub log\_level: LogLevelConfig,

      \#\[serde(default \= "default\_feature\_flags")\]  
      pub feature\_flags: FeatureFlags,

      \#\[serde(default)\] // Verwendet FeatureXConfig::default()  
      pub feature\_x\_config: FeatureXConfig,

      \#\[serde(default \= "default\_some\_path")\]  
      pub some\_critical\_path: PathBuf,  
  }

  fn default\_log\_level() \-\> LogLevelConfig { LogLevelConfig::default() }  
  fn default\_feature\_flags() \-\> FeatureFlags { FeatureFlags::default() }  
  fn default\_some\_path() \-\> PathBuf { PathBuf::from("/usr/share/YOUR\_DESKTOP\_ENV\_NAME/default\_resource") }

  impl Default for CoreConfig {  
      fn default() \-\> Self {  
          Self {  
              log\_level: default\_log\_level(),  
              feature\_flags: default\_feature\_flags(),  
              feature\_x\_config: FeatureXConfig::default(),  
              some\_critical\_path: default\_some\_path(),  
          }  
      }  
  }

  \#  
  \#\[serde(deny\_unknown\_fields)\]  
  pub struct FeatureFlags {  
      \#\[serde(default)\] // bool-Felder standardmäßig auf false  
      pub enable\_alpha\_feature: bool,  
      \#\[serde(default \= "default\_beta\_timeout\_ms")\]  
      pub beta\_feature\_timeout\_ms: u64,  
  }

  fn default\_beta\_timeout\_ms() \-\> u64 { 1000 }

  \#  
  \#\[serde(deny\_unknown\_fields)\]  
  pub struct FeatureXConfig {  
      \#\[serde(default \= "default\_retries")\]  
      pub retries: u32,  
      \#\[serde(default)\]  
      pub some\_string\_option: Option\<String\>,  
  }

  fn default\_retries() \-\> u32 { 3 }

  impl Default for FeatureXConfig {  
      fn default() \-\> Self {  
          Self {  
              retries: default\_retries(),  
              some\_string\_option: None,  
          }  
      }  
  }

* **Felder**: Alle Felder müssen explizit definierte Typen haben.  
* **serde::Deserialize**: Die Struktur und ihre verschachtelten Strukturen müssen Deserialize ableiten.  
* **\#\[serde(default \= "path")\]**: Wird umfassend verwendet, um Standardwerte für fehlende Felder in der TOML-Datei bereitzustellen, was die Robustheit erhöht. Die referenzierte Funktion muss den Typ des Feldes zurückgeben. Für Felder, deren Typ Default implementiert, kann auch \#\[serde(default)\] verwendet werden.  
* **\#\[serde(deny\_unknown\_fields)\]**: Wird erzwungen, um zu verhindern, dass Tippfehler oder nicht erkannte Felder in Konfigurationsdateien stillschweigend ignoriert werden.  
* **Validierung**:  
  * Grundlegende Validierung kann durch Typen erfolgen (z.B. u32 für eine Anzahl).  
  * Komplexere Validierungen (z.B. log\_level muss ein gültiger Wert sein, was hier durch das LogLevelConfig-Enum und serde(rename\_all \= "lowercase") bereits gut gehandhabt wird) sollten *nach* der Deserialisierung durchgeführt werden. Dies kann entweder in einem TryFrom\<CoreConfigRaw\>-Muster geschehen, bei dem CoreConfigRaw die deserialisierte Struktur ohne komplexe Validierung ist und CoreConfig die validierte Version, oder durch eine dedizierte validate()-Methode auf CoreConfig, die ein Result\<(), ConfigError\> zurückgibt. Für die Kernschicht kann die initiale Validierung auf die Fähigkeiten von serde und Typbeschränkungen beschränkt sein. Komplexere, semantische Validierungen können bei Bedarf in höheren Schichten oder durch benutzerdefinierte Deserialisierungsfunktionen mit \#\[serde(deserialize\_with \= "...")\] hinzugefügt werden.  
* **Invarianten**: Als Kommentare dokumentiert oder durch Validierungslogik erzwungen (z.B. timeout\_ms \> 0).

**Tabelle: Definitionen der Core-Konfigurationsparameter (Auszug)**

| Parameterpfad | Typ | serde Default-Funktion/Wert | Validierungsregeln (Beispiele) | Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| log\_level | LogLevelConfig | default\_log\_level() | Muss einer der Enum-Werte sein (implizit durch Deserialize) | Globaler Standard-Log-Level für die Anwendung. |
| feature\_flags.enable\_alpha\_feature | bool | false (implizit) | \- | Schaltet ein experimentelles Alpha-Feature ein oder aus. |
| feature\_flags.beta\_feature\_timeout\_ms | u64 | default\_beta\_timeout\_ms() | Muss \>= 0 sein (implizit durch u64) | Timeout-Wert in Millisekunden für ein Beta-Feature. |
| feature\_x\_config.retries | u32 | default\_retries() | Muss \>= 0 sein (implizit durch u32) | Anzahl der Wiederholungsversuche für eine bestimmte Operation in Feature X. |
| some\_critical\_path | PathBuf | default\_some\_path() | Pfad sollte idealerweise existieren (Laufzeitprüfung nötig) | Pfad zu einer kritischen Ressource. |

*Begründung für den Wert der Tabelle*:

1. **Klarheit**: Bietet eine einzige, maßgebliche Referenz für alle verfügbaren Kernkonfigurationen, ihre Typen und Standardwerte.  
2. **Dokumentation**: Unerlässlich für Benutzer/Administratoren, die diese Kerneinstellungen möglicherweise anpassen müssen.  
3. **Entwicklungshilfe**: Hilft Entwicklern, die verfügbaren Konfigurationen zu verstehen und neue konsistent hinzuzufügen.  
4. **Validierungsreferenz**: Zentralisiert die Definition gültiger Werte und Bereiche und unterstützt sowohl die automatisierte Validierung als auch die manuelle Konfiguration.

### **4.3. Konfigurationszugriffs-API**

* **Globaler Zugriff**: Die geladene CoreConfig-Instanz sollte so gespeichert werden, dass sie im gesamten Anwendungskontext effizient zugänglich ist. Hierfür wird eine threadsichere statische Variable verwendet, typischerweise mittels once\_cell::sync::OnceCell.  
  Rust  
  // In core::config  
  use once\_cell::sync::OnceCell;  
  //... CoreConfig Strukturendefinition und andere...

  static CORE\_CONFIG: OnceCell\<CoreConfig\> \= OnceCell::new();

  /// Initialisiert die globale Core-Konfiguration.  
  /// Darf nur einmal während des Anwendungsstarts aufgerufen werden.  
  ///  
  /// \# Errors  
  ///  
  /// Gibt einen Fehler zurück, wenn die Konfiguration bereits initialisiert wurde.  
  pub fn initialize\_core\_config(config: CoreConfig) \-\> Result\<(), CoreConfig\> {  
      CORE\_CONFIG.set(config)  
  }

  /// Gibt eine Referenz auf die global initialisierte Core-Konfiguration zurück.  
  ///  
  /// \# Panics  
  ///  
  /// Paniert, wenn \`initialize\_core\_config()\` nicht zuvor erfolgreich aufgerufen wurde.  
  /// Dies signalisiert einen schwerwiegenden Programmierfehler in der Anwendungsinitialisierung.  
  pub fn get\_core\_config() \-\> &'static CoreConfig {  
      CORE\_CONFIG.get().expect("CoreConfig wurde nicht initialisiert. initialize\_core\_config() muss zuerst aufgerufen werden.")  
  }  
  Das expect im get\_core\_config() ist hier vertretbar, da es einen Programmierfehler darstellt: der Versuch, auf die Konfiguration zuzugreifen, bevor sie geladen wurde, was ein fatales Setup-Problem ist und nicht zur Laufzeit normal behandelt werden kann.  
* **Zugriffsmethoden**: Einfache Getter-Funktionen oder direkter Feldzugriff auf die abgerufene &'static CoreConfig-Instanz.  
* **Thread-Sicherheit**: Der gewählte statische Speichermechanismus (OnceCell) gewährleistet eine threadsichere Initialisierung und einen threadsicheren Zugriff. Die CoreConfig-Struktur selbst sollte Send \+ Sync sein (was sie typischerweise ist, wenn ihre Felder dies sind). Clone wird abgeleitet für Fälle, in denen Teile der Konfiguration herumgereicht oder in einem lokalen Kontext modifiziert werden müssen, ohne den globalen Zustand zu beeinflussen.  
* **Immutabilität**: Die global zugängliche Konfiguration sollte nach der Initialisierung unveränderlich sein, um Laufzeitinkonsistenzen zu vermeiden. Wenn dynamische Konfigurationsaktualisierungen erforderlich sind, würde dies einen komplexeren Mechanismus erfordern (z.B. mit RwLock und einem dedizierten Aktualisierungsprozess), der außerhalb des Rahmens dieser initialen Kernschichtspezifikation liegt, aber architektonisch für zukünftige Erweiterbarkeit berücksichtigt werden sollte.

Die Ableitung von Clone für CoreConfig ermöglicht es Komponenten, bei Bedarf eine Momentaufnahme der Konfiguration zu einem bestimmten Zeitpunkt zu erstellen oder für Testzwecke. Der primäre Zugriff sollte jedoch über die statische Referenz erfolgen, um sicherzustellen, dass alle Teile des Systems denselben konsistenten Konfigurationszustand verwenden. Beispielsweise könnte eine langlaufende Aufgabe den relevanten Teil der Konfiguration bei ihrem Start klonen, um sicherzustellen, dass sie während ihrer gesamten Lebensdauer mit konsistenten Einstellungen arbeitet, selbst wenn später ein globaler Mechanismus zum Neuladen der Konfiguration eingeführt würde.

## **5\. Core Utilities Spezifikation (core::utils) (Ausgewählte kritische Utilities)**

Das Modul core::utils wird allgemeine Hilfsfunktionen und kleine, in sich geschlossene Utilities beherbergen, die nicht in spezifischere Module wie types oder config passen, aber über mehrere Teile der Kernschicht oder von anderen Schichten verwendet werden. Nur Utilities mit nicht-trivialer Logik oder spezifischen Designentscheidungen rechtfertigen hier eine detaillierte Spezifikation. Einfache Einzeiler-Helfer tun dies nicht.  
Für die initiale Kernschicht wird davon ausgegangen, dass keine hochkomplexen, neuartigen Utilities identifiziert wurden, die eine tiefergehende Spezifikation erfordern. Sollte sich dies ändern (z.B. ein benutzerdefinierter ID-Generator, ein spezialisierter String-Interner oder eine komplexe Pfad-Normalisierungsroutine), würde die Spezifikation dem untenstehenden Muster folgen.

* **5.X.1. Utility:**  
  * **Zweck, Begründung und Designentscheidungen**: (z.B. "Stellt ein robustes, plattformübergreifendes Dienstprogramm zur Pfadnormalisierung bereit, das Symlinks und relative Pfade konsistenter behandelt als Standardbibliotheksfunktionen in spezifischen Grenzfällen, die für die Desktop-Umgebung relevant sind.")  
  * **API**:  
    * **Strukturen/Enums**:  
      Rust  
      // pub struct NormalizedPath { /\*... \*/ }  
      // pub enum NormalizationError { /\*... \*/ } // Verwendet thiserror

    * **Methoden**:  
      Rust  
      // impl ComplexPathNormalizer {  
      //     pub fn new(/\*... \*/) \-\> Self;  
      //     pub fn normalize(base: \&Path, input: \&Path) \-\> Result\<NormalizedPath, NormalizationError\>;  
      // }  
      Vollständige Signaturen: fn normalize(base: \&std::path::Path, input: \&std::path::Path) \-\> Result\<NormalizedPath, NormalizationError\>; (Rusts noexcept ist implizit für Funktionen, die nicht unsafe deklariert sind und nicht paniken; die explizite Erwähnung der Panic-Vermeidung ist jedoch entscheidend).  
  * **Interne Algorithmen**: (Schritt-für-Schritt-Logik für komplexe Teile, z.B. Symlink-Auflösungsschleife, Behandlung von ..).  
  * **Fehlerbedingungen**: Abbildung auf NormalizationError-Varianten (z.B. PathNotFound, MaxSymlinkDepthExceeded).  
  * **Invarianten, Vorbedingungen, Nachbedingungen**: (z.B. "Eingabepfad muss für bestimmte Operationen existieren", "Zurückgegebener Pfad ist absolut und frei von . oder .. Komponenten").  
* **Allgemeine Richtlinien für core::utils:**  
  * **Geltungsbereich**: Utilities müssen wirklich allgemeiner Natur sein. Wenn ein Utility nur von einem anderen Modul verwendet wird, sollte es wahrscheinlich innerhalb dieses Moduls angesiedelt sein.  
  * **Einfachheit**: Einfache Funktionen sind komplexen Strukturen vorzuziehen, es sei denn, Zustand ist wirklich erforderlich.  
  * **Reinheit**: Reine Funktionen sind wo möglich zu bevorzugen (Ausgabe hängt nur von der Eingabe ab, keine Seiteneffekte).  
  * **Fehlerbehandlung**: Jede fehleranfällige Utility-Funktion muss Result\<T, YourUtilError\> zurückgeben, wobei YourUtilError unter Verwendung von thiserror innerhalb des Submoduls des Utilities definiert wird (z.B. core::utils::path\_utils::Error).  
  * **Dokumentation**: Alle öffentlichen Utilities müssen umfassende rustdoc-Kommentare haben, einschließlich Beispielen.  
  * **Tests**: Gründliche Unit-Tests sind für alle Utilities zwingend erforderlich.

## **6\. Core Datentypen Spezifikation (core::types) (Ausgewählte kritische Datentypen)**

Das Modul core::types definiert fundamentale Datenstrukturen und Enums, die in der gesamten Desktop-Umgebung verwendet werden. Diese unterscheiden sich von Konfigurationsstrukturen und sind eher primitive Bausteine für die Anwendungslogik. Beispiele hierfür sind Point, Size, Rect, Color, ResourceId usw.

### **6.1. Datentyp: RectInt (Integer-basiertes Rechteck)**

* **Zweck und Begründung**: Repräsentiert ein achsenparalleles Rechteck, das durch ganzzahlige Koordinaten und Dimensionen definiert ist. Unerlässlich für Fenstergeometrie, Positionierung von UI-Elementen und pixelbasierte Berechnungen. Die Verwendung von i32 für Koordinaten und u32 für Größen ist üblich für Bildschirmkoordinaten.  
* **Definition**:  
  Rust  
  use serde::{Serialize, Deserialize};

  \#  
  pub struct PointInt {  
      pub x: i32,  
      pub y: i32,  
  }

  impl PointInt {  
      pub const ZERO: Self \= Self { x: 0, y: 0 };

      \#\[must\_use\]  
      pub fn new(x: i32, y: i32) \-\> Self {  
          Self { x, y }  
      }

      // Weitere Methoden wie add, sub, etc. können hier hinzugefügt werden.  
      // pub fn add(self, other: Self) \-\> Self { Self { x: self.x \+ other.x, y: self.y \+ other.y } }  
  }

  \#  
  pub struct SizeInt {  
      pub width: u32,  
      pub height: u32,  
  }

  impl SizeInt {  
      pub const ZERO: Self \= Self { width: 0, height: 0 };

      \#\[must\_use\]  
      pub fn new(width: u32, height: u32) \-\> Self {  
          Self { width, height }  
      }

      \#\[must\_use\]  
      pub fn is\_empty(\&self) \-\> bool {  
          self.width \== 0 |

| self.height \== 0  
}  
}

\#  
pub struct RectInt {  
    pub x: i32,  
    pub y: i32,  
    pub width: u32,  
    pub height: u32,  
}  
\`\`\`

* **Methoden für RectInt**:  
  * pub const fn new(x: i32, y: i32, width: u32, height: u32) \-\> Self: Konstruktor.  
  * \#\[must\_use\] pub fn from\_points(p1: PointInt, p2: PointInt) \-\> Self: Erstellt ein Rechteck, das zwei Punkte umschließt.  
    * Vorbedingung: Keine.  
    * Nachbedingung: x ist min(p1.x, p2.x), y ist min(p1.y, p2.y), width ist abs(p1.x \- p2.x) as u32, height ist abs(p1.y \- p2.y) as u32. Die Umwandlung in u32 ist sicher, da die Differenz absolut ist.  
  * \#\[must\_use\] pub fn top\_left(\&self) \-\> PointInt: Gibt PointInt { x: self.x, y: self.y } zurück.  
  * \#\[must\_use\] pub fn size(\&self) \-\> SizeInt: Gibt SizeInt { width: self.width, height: self.height } zurück.  
  * \#\[must\_use\] pub fn right(\&self) \-\> i32: Gibt self.x.saturating\_add(self.width as i32) zurück. Verwendet saturating\_add um Überlauf zu vermeiden, obwohl dies bei typischen Bildschirmkoordinaten unwahrscheinlich ist.  
  * \#\[must\_use\] pub fn bottom(\&self) \-\> i32: Gibt self.y.saturating\_add(self.height as i32) zurück.  
  * \#\[must\_use\] pub fn contains\_point(\&self, p: PointInt) \-\> bool: Prüft, ob ein Punkt innerhalb des Rechtecks liegt (einschließlich der Ränder).  
    * Logik: p.x \>= self.x && p.x \< self.right() && p.y \>= self.y && p.y \< self.bottom(). Beachten Sie, dass right() und bottom() exklusiv sind.  
  * \#\[must\_use\] pub fn intersects(\&self, other: RectInt) \-\> bool: Prüft, ob dieses Rechteck ein anderes schneidet.  
    * Logik: self.x \< other.right() && self.right() \> other.x && self.y \< other.bottom() && self.bottom() \> other.y.  
  * \#\[must\_use\] pub fn intersection(\&self, other: RectInt) \-\> Option\<RectInt\>: Gibt das Schnittrechteck zurück oder None, wenn sie sich nicht schneiden.  
    * Logik: Berechne x\_intersect \= max(self.x, other.x), y\_intersect \= max(self.y, other.y). Berechne right\_intersect \= min(self.right(), other.right()), bottom\_intersect \= min(self.bottom(), other.bottom()). Wenn right\_intersect \> x\_intersect und bottom\_intersect \> y\_intersect, dann ist das Ergebnis RectInt::new(x\_intersect, y\_intersect, (right\_intersect \- x\_intersect) as u32, (bottom\_intersect \- y\_intersect) as u32). Sonst None.  
  * \#\[must\_use\] pub fn union(\&self, other: RectInt) \-\> RectInt: Gibt das kleinste Rechteck zurück, das beide umschließt.  
    * Logik: x\_union \= min(self.x, other.x), y\_union \= min(self.y, other.y). right\_union \= max(self.right(), other.right()), bottom\_union \= max(self.bottom(), other.bottom()). Ergebnis ist RectInt::new(x\_union, y\_union, (right\_union \- x\_union) as u32, (bottom\_union \- y\_union) as u32).  
  * \#\[must\_use\] pub fn translate(\&self, dx: i32, dy: i32) \-\> RectInt: Gibt ein neues, um (dx, dy) verschobenes Rechteck zurück.  
    * Logik: RectInt::new(self.x.saturating\_add(dx), self.y.saturating\_add(dy), self.width, self.height).  
  * \#\[must\_use\] pub fn inflate(\&self, dw: i32, dh: i32) \-\> RectInt: Gibt ein neues Rechteck zurück, das auf jeder Seite um dw (links/rechts) bzw. dh (oben/unten) erweitert (oder verkleinert, wenn dw, dh negativ sind) wird. Die resultierende Breite/Höhe darf nicht negativ werden.  
    * Logik: new\_x \= self.x.saturating\_sub(dw), new\_y \= self.y.saturating\_sub(dh). new\_width \= (self.width as i64).saturating\_add(2 \* dw as i64), new\_height \= (self.height as i64).saturating\_add(2 \* dh as i64). RectInt::new(new\_x, new\_y, max(0, new\_width) as u32, max(0, new\_height) as u32).  
  * \#\[must\_use\] pub fn is\_empty(\&self) \-\> bool: Gibt self.width \== 0 | | self.height \== 0 zurück.  
* **Invarianten**: width \>= 0, height \>= 0\. (Durch den u32-Typ erzwungen).  
* **Serialisierung**: Leitet Serialize, Deserialize für einfache Verwendung in Konfigurationen oder IPC ab.  
* **Traits**: Debug, Clone, Copy, PartialEq, Eq, Hash, Default.

### **6.2. Datentyp: Color (RGBA Farbrepräsentation)**

* **Zweck und Begründung**: Repräsentiert eine Farbe mit Rot-, Grün-, Blau- und Alpha-Komponenten. Fundamental für Theming, UI-Rendering und Grafik. Die Verwendung von f32 für Komponenten im Bereich \[0.0, 1.0\] ist üblich für Grafikpipelines. GTK4 verwendet intern oft f64, aber f32 bietet einen guten Kompromiss zwischen Präzision und Speicherbedarf und ist weit verbreitet.  
* **Definition**:  
  Rust  
  use serde::{Serialize, Deserialize, Deserializer, Serializer};  
  use thiserror::Error;  
  use std::num::ParseIntError;

  \#  
  pub struct Color {  
      pub r: f32, // Bereich \[0.0, 1.0\]  
      pub g: f32, // Bereich \[0.0, 1.0\]  
      pub b: f32, // Bereich \[0.0, 1.0\]  
      pub a: f32, // Bereich \[0.0, 1.0\]  
  }

  \#  
  pub enum ColorParseError {  
      \#  
      InvalidHexFormat(String),  
      \#\[error("Ungültige Hex-Ziffer in '{0}'")\]  
      InvalidHexDigit(String, \#\[source\] ParseIntError),  
      \#  
      InvalidHexLength(String),  
  }

* **Methoden für Color**:  
  * \#\[must\_use\] pub fn new(r: f32, g: f32, b: f32, a: f32) \-\> Self: Konstruktor. Klemmt Werte auf den Bereich \[0.0, 1.0\].  
    * Implementierung: Self { r: r.clamp(0.0, 1.0), g: g.clamp(0.0, 1.0), b: b.clamp(0.0, 1.0), a: a.clamp(0.0, 1.0) }.  
    * Nachbedingung: 0.0 \<= self.r \<= 1.0, usw.  
  * pub const OPAQUE\_BLACK: Color \= Color { r: 0.0, g: 0.0, b: 0.0, a: 1.0 };  
  * pub const OPAQUE\_WHITE: Color \= Color { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };  
  * pub const TRANSPARENT: Color \= Color { r: 0.0, g: 0.0, b: 0.0, a: 0.0 };  
  * pub fn from\_hex(hex\_string: \&str) \-\> Result\<Self, ColorParseError\>: Parst aus den Formaten "\#RRGGBB", "\#RGB", "\#RRGGBBAA" oder "\#RGBA".  
    * Logik: String validieren (Präfix \#, Länge), dann entsprechende Paare von Hex-Ziffern parsen, zu u8 konvertieren und dann zu f32 normalisieren (/ 255.0). Für Kurzformate (\#RGB, \#RGBA) Ziffern verdoppeln (z.B. "F" wird zu "FF").  
  * \#\[must\_use\] pub fn to\_hex\_string(\&self, include\_alpha: bool) \-\> String: Konvertiert in einen Hex-String ("\#RRGGBB" oder "\#RRGGBBAA").  
    * Logik: Komponenten mit 255.0 multiplizieren, zu u8 runden/casten, dann als Hex formatieren.  
  * \#\[must\_use\] pub fn with\_alpha(\&self, alpha: f32) \-\> Self: Gibt eine neue Farbe mit dem angegebenen Alpha-Wert zurück (geklemmt).  
  * \#\[must\_use\] pub fn lighten(\&self, amount: f32) \-\> Self: Hellt die Farbe auf. Eine einfache Methode ist, amount zu R, G und B zu addieren und dann zu klemmen. Komplexere Methoden würden im HSL/HSV-Raum arbeiten. Für die Kernschicht ist eine einfache RGB-Aufhellung zunächst ausreichend.  
  * \#\[must\_use\] pub fn darken(\&self, amount: f32) \-\> Self: Dunkelt die Farbe ab (analog zu lighten).  
  * \#\[must\_use\] pub fn interpolate(\&self, other: Color, t: f32) \-\> Self: Lineare Interpolation zwischen dieser Farbe und other. t wird auf \[0.0, 1.0\] geklemmt.  
    * Logik: r \= self.r \* (1.0 \- t) \+ other.r \* t, analog für g, b, a.  
* **Serialisierung**: Color soll Serialize und Deserialize implementieren, um als Hex-String in Konfigurationsdateien (z.B. TOML, JSON) dargestellt zu werden. Dies macht Konfigurationen (z.B. für Theming) wesentlich benutzerfreundlicher.  
  Rust  
  impl Serialize for Color {  
      fn serialize\<S\>(\&self, serializer: S) \-\> Result\<S::Ok, S::Error\>  
      where  
          S: Serializer,  
      {  
          serializer.serialize\_str(\&self.to\_hex\_string(true)) // Immer mit Alpha serialisieren für Konsistenz  
      }  
  }

  impl\<'de\> Deserialize\<'de\> for Color {  
      fn deserialize\<D\>(deserializer: D) \-\> Result\<Self, D::Error\>  
      where  
          D: Deserializer\<'de\>,  
      {  
          let s \= String::deserialize(deserializer)?;  
          Color::from\_hex(\&s).map\_err(serde::de::Error::custom)  
      }  
  }  
  Die Verwendung von serde(try\_from \= "String", into \= "String") ist eine Alternative, erfordert aber die Implementierung von TryFrom\<String\> for Color und From\<Color\> for String. Der oben gezeigte Weg mit manueller Implementierung von Serialize und Deserialize gibt volle Kontrolle. Die Möglichkeit, Farben als Hex-Codes ("\#CC331A") anstelle von Arrays von Fließkommazahlen (\[0.8, 0.2, 0.1, 1.0\]) in Konfigurationsdateien anzugeben, ist ein erheblicher Gewinn für die Benutzerfreundlichkeit, sowohl für Entwickler (bei der Erstellung von Standardkonfigurationen) als auch für Endbenutzer (bei der Anpassung von Themes). Dies erfordert eine robuste ColorParseError-Behandlung, um ungültige Hex-Strings abzufangen.  
* **Traits**: Debug, Clone, Copy, PartialEq, Default (kann auf OPAQUE\_BLACK oder TRANSPARENT gesetzt werden, OPAQUE\_BLACK ist eine gängige Wahl).

## **7\. Schlussfolgerung und Schichtübergreifende Integrationsrichtlinien (Fokus Kerninfrastruktur)**

* **Zusammenfassung der Kerninfrastruktur**: Dieser Teil der Spezifikation hat die fundamentalen Elemente der Kernschicht detailliert beschrieben: ein robustes Fehlerbehandlungsframework (core::errors) basierend auf thiserror und modul-spezifischen Enums; ein strukturiertes Logging-System (core::logging) unter Verwendung von tracing; Primitive für das Laden und den Zugriff auf Konfigurationen (core::config) über TOML und serde; sowie Definitionen für essentielle gemeinsame Datentypen (core::types) wie RectInt und Color. Diese Komponenten sind darauf ausgelegt, eine solide, wartbare und performante Basis für die gesamte Desktop-Umgebung zu schaffen.  
* **Richtlinien für die Nutzung durch andere Schichten**:  
  * **Fehlerbehandlung**: Alle Module in der Domänen-, System- und UI-Schicht *müssen* ihre eigenen thiserror-basierten Fehler-Enums definieren. Fehler, die von Funktionen der Kernschicht stammen, müssen entweder behandelt oder mittels ? weitergegeben werden, wobei sie potenziell unter Verwendung von \#\[from\] in die eigenen Fehlertypen der aufrufenden Schicht umgewandelt werden. Die Fehlerkette (source()) muss dabei erhalten bleiben.  
  * **Logging**: Alle Schichten *müssen* die tracing-Makros (trace\!, info\!, etc.) für sämtliche Logging-Aktivitäten verwenden. Die Funktion core::logging::initialize\_logging() muss vom Hauptanwendungsbinary beim Start aufgerufen werden. Die Einhaltung der Log-Level und der Richtlinien zur Datensensibilität ist zwingend erforderlich.  
  * **Konfiguration**: Höhere Schichten können ihre eigenen Konfigurationsstrukturen definieren, die als Teil eines größeren Anwendungskonfigurationsobjekts geladen werden können. Sie greifen auf Konfigurationen der Kernschicht über core::config::get\_core\_config() zu. Sie sollten nicht versuchen, die Konfiguration der Kernschicht zur Laufzeit zu modifizieren, da diese als statisch und nach der Initialisierung unveränderlich betrachtet wird.  
  * **Typen und Utilities**: Kerndatentypen (RectInt, Color usw.) und Utilities (core::utils) sollten direkt verwendet werden, wo dies angemessen ist, um Konsistenz zu gewährleisten und Neuimplementierungen zu vermeiden. Wenn eine höhere Schicht eine spezialisierte Version eines Kerntyps benötigt, sollte sie Komposition oder Newtype-Wrapper um den Kerntyp in Betracht ziehen, anstatt den Typ neu zu definieren.  
* **Immutabilität und Stabilität**: Die API der Kernschicht sollte nach ihrer Stabilisierung als äußerst stabil behandelt werden. Änderungen hier haben weitreichende Auswirkungen auf das gesamte System. Alle spezifizierten Komponenten sind so konzipiert, dass sie Send \+ Sync sind, wo dies sinnvoll ist, was ihre Verwendung in einer multithreaded Umgebung ermöglicht – ein Schlüsselmerkmal von Rust und wichtig für eine reaktionsschnelle Desktop-Umgebung. Die strikte Einhaltung der hier definierten Schnittstellen und Richtlinien ist entscheidend für den langfristigen Erfolg und die Wartbarkeit des Projekts.

#### **Referenzen**

1. Error Handling for Large Rust Projects \- Best Practice in GreptimeDB, Zugriff am Mai 13, 2025, [https://greptime.com/blogs/2024-05-07-error-rust](https://greptime.com/blogs/2024-05-07-error-rust)  
2. Error handling \- good/best practices : r/rust \- Reddit, Zugriff am Mai 13, 2025, [https://www.reddit.com/r/rust/comments/1bb7dco/error\_handling\_goodbest\_practices/](https://www.reddit.com/r/rust/comments/1bb7dco/error_handling_goodbest_practices/)  
3. Error in std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/trait.Error.html](https://doc.rust-lang.org/std/error/trait.Error.html)  
4. std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/index.html](https://doc.rust-lang.org/std/error/index.html)


# **Domänenschicht: Theming-Engine – Ultra-Feinspezifikation (Teil 1/4)**

## **1\. Einleitung zum Modul domain::theming**

Das Modul domain::theming ist eine Kernkomponente der Domänenschicht und trägt die Verantwortung für die gesamte Logik des Erscheinungsbilds (Theming) der Desktop-Umgebung. Seine Hauptaufgabe besteht darin, Design-Tokens zu verwalten, Theme-Definitionen zu interpretieren, Benutzereinstellungen für das Theming zu berücksichtigen und den finalen, aufgelösten Theme-Zustand für die Benutzeroberflächenschicht bereitzustellen. Dieses Modul ermöglicht dynamische Theme-Wechsel zur Laufzeit, einschließlich Änderungen des Farbschemas (Hell/Dunkel) und der Akzentfarben, basierend auf einem robusten, Token-basierten System. Es ist so konzipiert, dass es unabhängig von spezifischen UI-Toolkits oder Systemdetails agiert und eine klare Trennung zwischen der Logik des Erscheinungsbilds und dessen Darstellung gewährleistet. Diese Spezifikation dient als direkter Implementierungsleitfaden für Entwickler.

## **2\. Datenstrukturen (domain::theming::types)**

Die folgenden Datenstrukturen definieren die Entitäten und Wertobjekte, die für die Verwaltung und Anwendung von Themes und Design-Tokens notwendig sind. Sie sind für die Serialisierung und Deserialisierung mittels serde vorbereitet, um das Laden von Konfigurationen und Definitionen aus Dateien (z.B. JSON) zu ermöglichen.

### **2.1. Token-bezogene Datenstrukturen**

Diese Strukturen repräsentieren einzelne Design-Tokens und deren Werte.

* TokenIdentifier (Wertobjekt):  
  Ein eindeutiger, hierarchischer Bezeichner für ein Design-Token (z.B. "color.background.primary", "font.size.default"). Die hierarchische Struktur erleichtert die Organisation und das Verständnis der Tokens.  
  Rust  
  \#  
  pub struct TokenIdentifier(String);

  impl TokenIdentifier {  
      pub fn new(id: impl Into\<String\>) \-\> Self {  
          Self(id.into())  
      }  
      pub fn as\_str(\&self) \-\> \&str {  
          \&self.0  
      }  
  }

  impl std::fmt::Display for TokenIdentifier {  
      fn fmt(\&self, f: \&mut std::fmt::Formatter\<'\_\>) \-\> std::fmt::Result {  
          write\!(f, "{}", self.0)  
      }  
  }

* TokenValue (Enum):  
  Repräsentiert die möglichen Wertetypen eines Design-Tokens. Die String-Werte für Farben, Dimensionen etc. sind so gestaltet, dass sie direkt CSS-kompatibel sind. Die Variante Reference ermöglicht die Erstellung von Alias-Tokens, die auf andere Tokens verweisen, was die Wiederverwendbarkeit und Konsistenz fördert.  
  Rust  
  \#  
  \#\[serde(rename\_all \= "kebab-case")\]  
  pub enum TokenValue {  
      Color(String),      // z.B., "\#FF0000", "rgba(255,0,0,0.5)", "transparent"  
      Dimension(String),  // z.B., "16px", "2rem", "100%"  
      FontSize(String),   // z.B., "12pt", "1.5em"  
      FontFamily(String), // z.B., "Inter, sans-serif"  
      FontWeight(String), // z.B., "normal", "bold", "700"  
      LineHeight(String), // z.B., "1.5", "150%"  
      LetterSpacing(String),// z.B., "0.5px", "0.05em"  
      Border(String),     // z.B., "1px solid \#CCCCCC"  
      Shadow(String),     // z.B., "2px 2px 5px rgba(0,0,0,0.3)"  
      Radius(String),     // z.B., "4px", "50%"  
      Spacing(String),    // z.B., "8px" (generische Abstände für padding, margin)  
      ZIndex(i32),  
      Opacity(f64),       // 0.0 bis 1.0  
      Text(String),       // Für beliebige String-Werte  
      Reference(TokenIdentifier), // Alias zu einem anderen Token  
  }

* RawToken (Struct):  
  Repräsentiert ein einzelnes Design-Token, wie es typischerweise aus einer Konfigurationsdatei (z.B. JSON) geladen wird. Enthält den Identifikator, den Wert und optionale Metadaten wie Beschreibung und Gruppierung.  
  Rust  
  \#  
  pub struct RawToken {  
      pub id: TokenIdentifier,  
      pub value: TokenValue,  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub description: Option\<String\>,  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub group: Option\<String\>, // z.B., "colors", "spacing", "typography"  
  }

* TokenSet (Typalias):  
  Eine Sammlung von RawTokens, die für eine effiziente Suche und Verwaltung als HashMap implementiert ist, wobei der TokenIdentifier als Schlüssel dient.  
  Rust  
  pub type TokenSet \= std::collections::HashMap\<TokenIdentifier, RawToken\>;

### **2.2. Theme-Definitionsstrukturen**

Diese Strukturen definieren ein vollständiges Theme, seine Varianten (z.B. Hell/Dunkel) und unterstützte Anpassungen.

* ThemeIdentifier (Wertobjekt):  
  Ein eindeutiger Bezeichner für ein Theme (z.B. "adwaita-ng", "material-you-like").  
  Rust  
  \#  
  pub struct ThemeIdentifier(String);

  impl ThemeIdentifier {  
      pub fn new(id: impl Into\<String\>) \-\> Self {  
          Self(id.into())  
      }  
      pub fn as\_str(\&self) \-\> \&str {  
          \&self.0  
      }  
  }  
  impl std::fmt::Display for ThemeIdentifier {  
      fn fmt(\&self, f: \&mut std::fmt::Formatter\<'\_\>) \-\> std::fmt::Result {  
          write\!(f, "{}", self.0)  
      }  
  }

* ColorSchemeType (Enum):  
  Definiert die grundlegenden Farbschemata, die ein Theme unterstützen kann.  
  Rust  
  \#  
  pub enum ColorSchemeType {  
      Light,  
      Dark,  
  }

* AccentColor (Struct / Wertobjekt):  
  Repräsentiert eine Akzentfarbe, die entweder einen vordefinierten Namen oder einen direkten Farbwert haben kann.  
  Rust  
  \#  
  pub struct AccentColor {  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub name: Option\<String\>, // z.B., "Blue", "ForestGreen"  
      pub value: String,        // z.B., "\#3498db" (tatsächlicher CSS-Farbwert)  
  }

* ThemeVariantDefinition (Struct):  
  Definiert die spezifischen Token-Werte oder Überschreibungen für eine bestimmte Variante eines Themes (z.B. das Dunkel-Schema). Der TokenSet hier enthält nur die Tokens, die sich von den base\_tokens des Themes unterscheiden oder spezifisch für diese Variante sind.  
  Rust  
  \#  
  pub struct ThemeVariantDefinition {  
      pub applies\_to\_scheme: ColorSchemeType,  
      pub tokens: TokenSet, // Token-Überschreibungen oder spezifische Definitionen für diese Variante  
  }

* ThemeDefinition (Struct):  
  Die vollständige Definition eines Themes, inklusive Metadaten, Basis-Tokens, Varianten und unterstützten Akzentfarben.  
  Rust  
  \#  
  pub struct ThemeDefinition {  
      pub id: ThemeIdentifier,  
      pub name: String, // Anzeigename, z.B. "Adwaita Next Generation"  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub description: Option\<String\>,  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub author: Option\<String\>,  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub version: Option\<String\>,  
      pub base\_tokens: TokenSet, // Grundlegende Tokens, die für alle Varianten gelten  
      \#\[serde(default, skip\_serializing\_if \= "Vec::is\_empty")\]  
      pub variants: Vec\<ThemeVariantDefinition\>, // Definitionen für Hell, Dunkel etc.  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub supported\_accent\_colors: Option\<Vec\<AccentColor\>\>, // Vordefinierte Akzentfarben  
  }

### **2.3. Konfigurations- und Zustandsstrukturen**

Diese Strukturen repräsentieren die vom Benutzer gewählten Theming-Einstellungen und den daraus resultierenden, angewendeten Theme-Zustand.

* AppliedThemeState (Struct):  
  Repräsentiert den aktuell im System aktiven Theme-Zustand. Entscheidend ist hier das Feld resolved\_tokens, welches alle Design-Tokens auf ihre endgültigen, CSS-kompatiblen String-Werte abbildet. Diese Struktur ist das primäre Ergebnis der Theming-Logik und wird von der UI-Schicht konsumiert.  
  Eine wichtige Invariante ist, dass resolved\_tokens keine TokenValue::Reference mehr enthalten darf; alle Werte müssen endgültig aufgelöst sein.  
  Rust  
  \# // Deserialize ist hier nicht zwingend nötig  
  pub struct AppliedThemeState {  
      pub theme\_id: ThemeIdentifier,  
      pub color\_scheme: ColorSchemeType,  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub active\_accent\_color: Option\<AccentColor\>,  
      // Schlüssel: TokenIdentifier (z.B., "color.background.default")  
      // Wert: Final aufgelöster CSS-String (z.B., "\#FFFFFF")  
      pub resolved\_tokens: std::collections::HashMap\<TokenIdentifier, String\>,  
  }

* ThemingConfiguration (Struct):  
  Speichert die benutzerspezifischen Einstellungen für das Theming. Diese Konfiguration wird typischerweise von einer übergeordneten Einstellungsverwaltung (domain::settings) bereitgestellt und dient als Eingabe für die ThemingEngine. Sie ermöglicht es Benutzern, ihr bevorzugtes Theme, Farbschema, Akzentfarbe und sogar einzelne Tokens global zu überschreiben.  
  Rust  
  \#  
  pub struct ThemingConfiguration {  
      pub selected\_theme\_id: ThemeIdentifier,  
      pub preferred\_color\_scheme: ColorSchemeType, // Präferenz des Benutzers  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub selected\_accent\_color: Option\<AccentColor\>,  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      // Ermöglicht Power-Usern, spezifische Tokens für jedes Theme zu überschreiben  
      pub custom\_user\_token\_overrides: Option\<TokenSet\>,  
  }

### **2.4. Tabellen für Datenstrukturen**

Die folgenden Tabellen fassen die Schlüsseleigenschaften der wichtigsten Datenstrukturen zusammen und dienen als schnelle Referenz für Entwickler. Sie verdeutlichen die Struktur und die Bedeutung der einzelnen Felder, was für die korrekte Implementierung und Nutzung dieser Typen unerlässlich ist. Die explizite Angabe von serde-Attributen und abgeleiteten Traits stellt sicher, dass die Strukturen direkt für die Datenpersistenz und den internen Gebrauch geeignet sind.

* **Tabelle 2.1: RawToken Felder**

| Feldname | Rust-Typ | Sichtbarkeit | Initialwert (JSON Default) | Invarianten/Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| id | TokenIdentifier | pub | N/A (erforderlich) | Eindeutiger, hierarchischer Bezeichner des Tokens. |
| value | TokenValue | pub | N/A (erforderlich) | Der Wert des Tokens, kann ein primitiver Typ oder eine Referenz auf ein anderes Token sein. |
| description | Option\<String\> | pub | None | Optionale Beschreibung des Tokens und seines Verwendungszwecks. |
| group | Option\<String\> | pub | None | Optionale Gruppierung (z.B. "Farben", "Typografie") zur besseren Organisation. |

* **Tabelle 2.2: ThemeDefinition Felder**

| Feldname | Rust-Typ | Sichtbarkeit | Initialwert (JSON Default) | Invarianten/Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| id | ThemeIdentifier | pub | N/A (erforderlich) | Eindeutiger Bezeichner des Themes. |
| name | String | pub | N/A (erforderlich) | Menschenlesbarer Name des Themes. |
| description | Option\<String\> | pub | None | Optionale Beschreibung des Themes. |
| author | Option\<String\> | pub | None | Optionaler Autor des Themes. |
| version | Option\<String\> | pub | None | Optionale Version des Themes. |
| base\_tokens | TokenSet | pub | N/A (erforderlich, kann leer sein) | Set von Basis-Tokens, die für alle Varianten gelten, falls nicht spezifisch überschrieben. |
| variants | Vec\<ThemeVariantDefinition\> | pub | \`\` (leerer Vektor) | Definitionen für spezifische Varianten (z.B. Hell, Dunkel). |
| supported\_accent\_colors | Option\<Vec\<AccentColor\>\> | pub | None | Optionale Liste vordefinierter Akzentfarben, die gut mit diesem Theme harmonieren. |

* **Tabelle 2.3: AppliedThemeState Felder**

| Feldname | Rust-Typ | Sichtbarkeit | Beschreibung |
| :---- | :---- | :---- | :---- |
| theme\_id | ThemeIdentifier | pub | ID des aktuell angewendeten Themes. |
| color\_scheme | ColorSchemeType | pub | Das aktuell angewendete Farbschema (Hell/Dunkel). |
| active\_accent\_color | Option\<AccentColor\> | pub | Die aktuell angewendete Akzentfarbe, falls eine ausgewählt wurde. |
| resolved\_tokens | std::collections::HashMap\<TokenIdentifier, String\> | pub | Eine Map aller Design-Tokens, aufgelöst zu ihren finalen, CSS-kompatiblen String-Werten. Enthält keine Referenzen. |

## **3\. Kernlogik und Geschäftsregeln (domain::theming::logic)**

Dieser Abschnitt beschreibt die internen Algorithmen und Regeln, die das Verhalten der Theming-Engine steuern. Diese Logik wird in privaten (priv) oder modul-internen (pub(crate)) Funktionen und Untermodulen innerhalb von domain::theming implementiert und von der in Abschnitt 4 definierten öffentlichen API genutzt.

### **3.1. Laden, Parsen und Validieren von Token- und Theme-Definitionen**

Die Theming-Engine muss in der Lage sein, Token- und Theme-Definitionen aus externen Quellen, typischerweise JSON-Dateien, zu laden, zu parsen und auf ihre Gültigkeit zu überprüfen.

* **Token-Dateien (\*.tokens.json):**  
  * **Ladepfade:** Token-Definitionen werden von standardisierten Pfaden geladen. Systemweite Tokens befinden sich beispielsweise unter /usr/share/desktop-environment/themes/tokens/, während benutzerspezifische Tokens unter $XDG\_CONFIG\_HOME/desktop-environment/themes/tokens/ (gemäß XDG Base Directory Specification) abgelegt werden können. Benutzerspezifische Dateien haben Vorrang und können systemweite Tokens überschreiben oder ergänzen.  
  * **Einlesen und Parsen:** Es wird eine Logik implementiert, die JSON-Dateien einliest, welche entweder ein Vec\<RawToken\> oder direkt ein TokenSet (als JSON-Objekt, bei dem Schlüssel Token-IDs sind) enthalten. Für das Parsen wird die serde\_json-Bibliothek verwendet.  
  * **Validierung:**  
    * **Eindeutigkeit der TokenIdentifier:** Beim Laden mehrerer Token-Dateien muss sichergestellt werden, dass Token-Identifier eindeutig sind. Bei Konflikten (gleiche ID aus verschiedenen Quellen) wird eine klare Strategie verfolgt: Benutzerspezifische Tokens haben Vorrang vor systemweiten Tokens. Bei gleichrangigen Konflikten wird eine Warnung geloggt, und das zuletzt geladene Token überschreibt das vorherige.  
    * **Zyklische Referenzen:** Es muss geprüft werden, ob TokenValue::Reference-Abhängigkeiten Zyklen bilden (z.B. Token A verweist auf B, B verweist auf A). Dies erfordert einen Graphenalgorithmus, wie z.B. eine Tiefensuche (DFS), um solche Zyklen zu erkennen. Ein erkannter Zyklus führt zu einem ThemingError::CyclicTokenReference.  
    * **Fehlerbehandlung:** Parse-Fehler (ungültiges JSON) oder ungültige Werte innerhalb der Tokens (z.B. ein fehlerhaftes Farbformat, das nicht CSS-kompatibel ist) führen zu einem ThemingError::TokenFileParseError bzw. ThemingError::InvalidTokenData.  
* **Theme-Definitionsdateien (\*.theme.json):**  
  * **Ladepfade:** Analog zu Token-Dateien, z.B. /usr/share/desktop-environment/themes/\[theme\_id\]/\[theme\_id\].theme.json für systemweite Themes und $XDG\_CONFIG\_HOME/desktop-environment/themes/\[theme\_id\]/\[theme\_id\].theme.json für benutzerspezifische Themes.  
  * **Einlesen und Parsen:** Es wird eine Logik implementiert, die JSON-Dateien einliest, die eine ThemeDefinition-Struktur repräsentieren. Auch hier kommt serde\_json zum Einsatz.  
  * **Validierung:**  
    * **Referenzierte Tokens:** Es muss sichergestellt werden, dass Tokens, die in base\_tokens oder variants\[\*\].tokens als TokenValue::Reference definiert sind, entweder auf bekannte globale Tokens (aus den geladenen \*.tokens.json-Dateien) verweisen oder innerhalb derselben ThemeDefinition (z.B. in base\_tokens) definiert sind. Fehlende Referenzen führen zu einem Fehler.  
    * **Vollständigkeit der Varianten:** Es sollte geprüft werden, ob für gängige ColorSchemeType-Werte (insbesondere Light und Dark) entsprechende ThemeVariantDefinitions existieren oder ob die base\_tokens als ausreichend für alle Schemata betrachtet werden können. Fehlende, aber erwartete Varianten könnten zu Warnungen führen.  
    * **Fehlerbehandlung:** Fehler beim Parsen oder ungültige Datenstrukturen führen zu ThemingError::ThemeFileLoadError oder ThemingError::InvalidThemeData.  
* **Logging:** Während des Lade-, Parse- und Validierungsprozesses wird das tracing-Framework intensiv genutzt:  
  * tracing::debug\!: Für Informationen über geladene Dateien und erfolgreich geparste Definitionen.  
  * tracing::warn\!: Für nicht-kritische Probleme, wie das Überschreiben von Tokens durch benutzerspezifische Definitionen oder kleinere Validierungsfehler, die nicht das Laden des gesamten Themes verhindern.  
  * tracing::error\!: Für kritische Fehler, die das Laden oder die Verwendung eines Tokensets oder einer Theme-Definition unmöglich machen (z.B. Parse-Fehler, zyklische Referenzen).

### **3.2. Mechanismus zur Auflösung und Vererbung von Tokens (Token Resolution Pipeline)**

Dies ist die zentrale Logikkomponente der Theming-Engine. Sie ist dafür verantwortlich, aus den rohen RawTokens, der ausgewählten ThemeDefinition und der aktuellen ThemingConfiguration die endgültigen, anwendbaren Token-Werte zu berechnen, die im AppliedThemeState.resolved\_tokens gespeichert werden. Dieser Prozess stellt sicher, dass alle Referenzen aufgelöst, Überschreibungen korrekt angewendet und spezifische Anpassungen (wie Akzentfarben) berücksichtigt werden.  
Die Auflösung erfolgt in einer klar definierten Reihenfolge von Schritten für eine gegebene ThemingConfiguration:

1. **Basissatz globaler Tokens bestimmen:**  
   * Lade alle RawTokens aus den systemweiten und benutzerspezifischen Token-Dateien (\*.tokens.json).  
   * Diese Sammlung bildet den "Foundation Layer" oder den globalen Token-Pool, auf den sich Themes beziehen können. Bei Namenskonflikten haben benutzerspezifische Tokens Vorrang.  
2. **Theme-spezifische Tokens laden und anwenden:**  
   * Identifiziere und lade die ThemeDefinition für die in ThemingConfiguration.selected\_theme\_id angegebene ID.  
   * Beginne mit einer Kopie der base\_tokens aus dieser ThemeDefinition. Diese Tokens können entweder eigenständige Werte definieren oder Referenzen auf Tokens im globalen Pool (aus Schritt 1\) sein.  
3. **Varianten-spezifische Tokens anwenden:**  
   * Ermittle die preferred\_color\_scheme (z.B. Light oder Dark) aus der ThemingConfiguration.  
   * Suche in der ThemeDefinition.variants nach einer ThemeVariantDefinition, deren applies\_to\_scheme mit der bevorzugten Einstellung übereinstimmt.  
   * Wenn eine passende Variante gefunden wird, merge deren tokens über das bisherige Set (aus Schritt 2). "Merging" bedeutet hier, dass Tokens aus der Variante gleichnamige Tokens aus den base\_tokens (oder dem globalen Pool, falls die Basis-Tokens Referenzen waren) überschreiben.  
4. **Akzentfarben-Logik anwenden (falls ThemingConfiguration.selected\_accent\_color vorhanden ist):**  
   * Dieser Schritt ist komplex und hängt stark davon ab, wie ein Theme die Integration von Akzentfarben definiert.  
   * **Ansatz 1: Direkte Ersetzung über spezielle Token-IDs:** Das Theme definiert Tokens mit speziellen, reservierten IDs (z.B. color.accent.primary.value, color.accent.secondary.value). Die Werte dieser Tokens werden direkt durch den value-Teil der selected\_accent\_color (z.B. "\#3498db") ersetzt. Das Theme kann auch Tokens definieren, die auf diese Akzent-Tokens verweisen (z.B. button.background.active verweist auf color.accent.primary.value).  
   * **Ansatz 2: Farbmanipulation (fortgeschritten):** Basierend auf der selected\_accent\_color.value könnten andere verwandte Farben dynamisch generiert werden (z.B. hellere/dunklere Schattierungen für Hover/Active-Zustände, kontrastierende Textfarben). Dies würde eine Farbmanipulationsbibliothek erfordern. Für die Erstimplementierung wird die direkte Ersetzung (Ansatz 1\) bevorzugt, da sie einfacher umzusetzen ist und weniger Abhängigkeiten erfordert.  
   * Die ThemeDefinition könnte ein Feld enthalten, das auflistet, welche ihrer Tokens als "akzentfähig" gelten und wie sie von der selected\_accent\_color beeinflusst werden.  
5. **Benutzerdefinierte globale Token-Overrides anwenden:**  
   * Wenn in der ThemingConfiguration ein custom\_user\_token\_overrides-Set vorhanden ist, merge diese Tokens über das bisherige, aus den vorherigen Schritten resultierende Set. Diese benutzerdefinierten Überschreibungen haben die höchste Priorität und überschreiben jeden zuvor festgelegten Wert für ein Token mit derselben ID.  
6. **Referenzen auflösen (rekursiv):**  
   * Nachdem alle Überschreibungen angewendet wurden, iteriere durch alle Tokens im aktuellen Set.  
   * Wenn ein Token den Wert TokenValue::Reference(target\_id) hat:  
     * Suche das Token mit der target\_id im aktuellen Set.  
     * **Erfolgreiche Auflösung:** Wenn target\_id gefunden wird und dessen Wert *kein* weiterer Reference ist (d.h., es ist ein konkreter Wert wie Color, Dimension etc.), ersetze den Wert des ursprünglichen Tokens (das die Referenz enthielt) durch den aufgelösten Wert des Ziel-Tokens.  
     * **Kaskadierte Referenz:** Wenn target\_id gefunden wird, aber dessen Wert ebenfalls ein Reference ist, muss diese Referenz ebenfalls aufgelöst werden. Dieser Prozess wird rekursiv fortgesetzt.  
     * **Fehlende Referenz:** Wenn target\_id nicht im aktuellen Set gefunden wird, ist dies ein Fehler, der als ThemingError::MissingTokenReference behandelt wird. Das referencing Token kann nicht aufgelöst werden.  
     * **Zyklenerkennung:** Während der rekursiven Auflösung muss ein Mechanismus zur Erkennung von Zyklen aktiv sein (z.B. durch Verfolgung des Auflösungspfads). Ein Zyklus (z.B. A → B → C → A) würde zu einer Endlosschleife führen und muss als ThemingError::CyclicTokenReference abgefangen werden. Die Validierung in Schritt 3.1 sollte Zyklen bereits erkennen, aber eine zusätzliche Prüfung hier dient als Sicherheitsnetz.  
     * **Maximale Rekursionstiefe:** Eine maximale Tiefe für die Auflösung von Referenzen (z.B. 10-20 Ebenen) sollte festgelegt werden, um bei unentdeckten Fehlern oder extrem verschachtelten (aber gültigen) Strukturen eine Endlosschleife zu verhindern und einen ThemingError::MaxReferenceDepthExceeded auszulösen.  
7. **Finale Wertkonvertierung und Erstellung des AppliedThemeState:**  
   * Nachdem alle Referenzen erfolgreich aufgelöst wurden, enthält das Token-Set nur noch konkrete TokenValue-Varianten (außer Reference).  
   * Konvertiere alle diese TokenValues in ihre finalen String-Repräsentationen, die direkt von der UI-Schicht (z.B. als CSS-Werte) verwendet werden können. Beispielsweise wird TokenValue::Color("\#aabbcc".to\_string()) zu String::from("\#aabbcc").  
   * Das Ergebnis dieser Konvertierung ist eine HashMap\<TokenIdentifier, String\>, die zusammen mit der theme\_id, color\_scheme und active\_accent\_color aus der ThemingConfiguration den neuen AppliedThemeState bildet.  
* **Caching:** Da die Token-Auflösung potenziell rechenintensiv sein kann (insbesondere bei vielen Tokens, komplexen Referenzen und häufigen Theme-Wechseln), sollte ein Caching-Mechanismus in Betracht gezogen werden.  
  * Ein aufgelöstes AppliedThemeState (oder zumindest das resolved\_tokens-Set) kann für eine gegebene Kombination aus (ThemeIdentifier, ColorSchemeType, Option\<AccentColor\>, HashOfUserOverrides) gecacht werden.  
  * Der Cache muss invalidiert werden, wenn sich zugrundeliegende Token-Dateien (\*.tokens.json) oder Theme-Definitionen (\*.theme.json) ändern (z.B. durch Aufruf von reload\_themes\_and\_tokens() in der ThemingEngine) oder wenn sich die custom\_user\_token\_overrides ändern.

### **3.3. Regeln für dynamische Theme-Wechsel und Aktualisierung des Theme-Zustands**

Die Theming-Engine muss in der Lage sein, auf Änderungen der ThemingConfiguration (z.B. durch Benutzereingaben in den Einstellungen) dynamisch zur Laufzeit zu reagieren.

1. **Benachrichtigung über Konfigurationsänderung:** Die ThemingEngine wird über eine Änderung der ThemingConfiguration informiert, typischerweise durch einen Methodenaufruf ihrer öffentlichen API (z.B. update\_configuration(new\_config)).  
2. **Neuberechnung des Theme-Zustands:** Nach Erhalt der neuen Konfiguration führt die ThemingEngine die vollständige Token Resolution Pipeline (wie in Abschnitt 3.2 beschrieben) erneut aus, unter Verwendung der new\_config.  
3. **Aktualisierung des internen Zustands:** Der resultierende AppliedThemeState wird zum neuen internen aktuellen Zustand der ThemingEngine.  
4. **Event-Benachrichtigung:** Wenn sich der neu berechnete AppliedThemeState vom vorherigen Zustand unterscheidet, emittiert die ThemingEngine ein ThemeChangedEvent. Dieses Event enthält den neuen AppliedThemeState und ermöglicht es anderen Teilen des Systems (insbesondere der UI-Schicht), auf die Änderung zu reagieren und ihr Erscheinungsbild entsprechend zu aktualisieren.

### **3.4. Invarianten und Konsistenzprüfungen**

Um die Stabilität und Korrektheit des Theming-Systems zu gewährleisten, müssen bestimmte Invarianten jederzeit gelten:

* **Keine Referenzen im AppliedThemeState:** Das Feld resolved\_tokens eines AppliedThemeState-Objekts darf unter keinen Umständen TokenValue::Reference-Typen (oder deren String-Äquivalente, falls die Auflösung fehlschlägt) enthalten. Alle Werte müssen endgültig und direkt verwendbar sein.  
* **Gültiger Fallback-Zustand:** Die ThemingEngine muss auch dann einen gültigen (wenn auch möglicherweise minimalen) AppliedThemeState bereitstellen können, wenn Konfigurationsdateien fehlerhaft, unvollständig oder nicht vorhanden sind. Hierfür ist ein Default-Fallback-Theme erforderlich. Dieses Fallback-Theme sollte entweder fest im Code einkompiliert sein (z.B. über include\_str\! aus eingebetteten JSON-Ressourcen) oder aus einer garantierten, immer verfügbaren Quelle geladen werden können. Ein Fehlschlagen beim Laden des Fallback-Themes ist ein kritischer Fehler (ThemingError::FallbackThemeLoadError).  
* **Zuverlässige Zyklenerkennung:** Zyklische Abhängigkeiten in Token-Referenzen müssen bei der Validierung (3.1) und spätestens bei der Auflösung (3.2) zuverlässig erkannt und als Fehler (ThemingError::CyclicTokenReference) behandelt werden, um Endlosschleifen und Systeminstabilität zu verhindern.  
* **Konsistenz der ThemeIdentifier:** Alle in ThemingConfiguration oder intern verwendeten ThemeIdentifier müssen auf tatsächlich geladene und validierte ThemeDefinitions verweisen, es sei denn, es handelt sich um den expliziten Fallback-Zustand.

## **4\. Öffentliche API-Spezifikation (domain::theming::api)**

Dieser Abschnitt definiert die öffentliche Schnittstelle des domain::theming-Moduls. Die Interaktion mit der Theming-Logik erfolgt primär über den ThemingEngine-Service. Diese API ist so gestaltet, dass sie klar, robust und einfach von anderen Modulen, insbesondere der UI-Schicht und der Einstellungsverwaltung, genutzt werden kann.

### **4.1. Haupt-Service: ThemingEngine**

Der ThemingEngine-Service ist die zentrale Struktur, die die gesamte Theming-Logik kapselt, den aktuellen Theme-Zustand verwaltet und als Schnittstelle für andere Systemteile dient. Er wird typischerweise als eine gemeinsam genutzte, langlebige Instanz im System existieren (z.B. als Singleton oder über Dependency Injection bereitgestellt).  
Die Implementierung muss Thread-Sicherheit gewährleisten (Send \+ Sync), da von verschiedenen Threads (z.B. UI-Thread, Hintergrund-Threads für Konfigurationsaktualisierungen) darauf zugegriffen werden könnte. Dies wird üblicherweise durch die Verwendung von Arc\<Mutex\<ThemingEngineInternalState\>\> für den internen, veränderlichen Zustand erreicht.

Rust

// Angenommen in domain::theming::mod.rs oder domain::theming::api.rs

use crate::core::errors::CoreError; // Basis-Fehlertyp, falls benötigt  
use super::types::\*;  
use super::errors::ThemingError;  
use std::sync::{Arc, Mutex};  
use std::path::PathBuf;  
// Für Eventing wird eine robuste Multi-Producer, Multi-Consumer (MPMC) Broadcast-Lösung  
// oder eine sorgfältig verwaltete Liste von mpsc-Sendern empfohlen.  
// Hier als Beispiel mit einer Liste von mpsc::Sendern für Einfachheit,  
// aber tokio::sync::broadcast oder crossbeam\_channel::Sender (cloneable) wären bessere Optionen.  
use std::sync::mpsc;

pub struct ThemingEngine {  
    internal\_state: Arc\<Mutex\<ThemingEngineInternalState\>\>,  
    // Hält Sender-Enden für alle Subscriber.  
    event\_subscribers: Arc\<Mutex\<Vec\<mpsc::Sender\<ThemeChangedEvent\>\>\>\>,  
}

struct ThemingEngineInternalState {  
    current\_config: ThemingConfiguration,  
    available\_themes: Vec\<ThemeDefinition\>, // Geladen beim Start/Refresh  
    global\_raw\_tokens: TokenSet, // Globale Tokens, nicht Teil eines Themes  
    applied\_state: AppliedThemeState,  
    // Pfade, von denen Tokens und Themes geladen wurden, für \`reload\_themes\_and\_tokens\`  
    theme\_load\_paths: Vec\<PathBuf\>,  
    token\_load\_paths: Vec\<PathBuf\>,  
    // Optional: Cache für aufgelöste Token-Sets  
    // resolved\_state\_cache: HashMap\<CacheKey, AppliedThemeState\>,  
}

impl ThemingEngine {  
    // Konstruktor und Methoden werden unten definiert  
}

#### **4.1.1. Deklarierte Eigenschaften (Properties)**

Diese Eigenschaften repräsentieren den Kernzustand der ThemingEngine. Der Zugriff erfolgt ausschließlich über die unten definierten Methoden, um Kapselung und kontrollierte Zustandsänderungen zu gewährleisten.

* **Aktueller AppliedThemeState:** Der vollständig aufgelöste und angewendete Theme-Zustand. Zugänglich über get\_current\_theme\_state().  
* **Liste der verfügbaren Themes (Vec\<ThemeDefinition\>):** Eine Liste aller erfolgreich geladenen und validierten Theme-Definitionen. Zugänglich über get\_available\_themes().  
* **Aktuelle ThemingConfiguration:** Die derzeit von der Engine verwendete Benutzerkonfiguration. Zugänglich über get\_current\_configuration().

#### **4.1.2. Methoden**

Die Methoden der ThemingEngine ermöglichen die Initialisierung, Abfrage des Zustands, Aktualisierung der Konfiguration und die Registrierung für Benachrichtigungen über Zustandsänderungen.

* **Konstruktoren/Builder:**  
  * pub fn new(initial\_config: ThemingConfiguration, theme\_load\_paths: Vec\<PathBuf\>, token\_load\_paths: Vec\<PathBuf\>) \-\> Result\<Self, ThemingError\>  
    * **Beschreibung:** Initialisiert die ThemingEngine. Lädt alle verfügbaren Themes und Tokens von den angegebenen theme\_load\_paths und token\_load\_paths. Wendet die initial\_config an, um den ersten AppliedThemeState zu berechnen. Wenn dieser Prozess fehlschlägt, wird versucht, ein Fallback-Theme zu laden.  
    * **Parameter:**  
      * initial\_config: ThemingConfiguration: Die anfängliche Benutzerkonfiguration für das Theming.  
      * theme\_load\_paths: Vec\<PathBuf\>: Eine Liste von Verzeichnispfaden, in denen nach Theme-Definitionen (\*.theme.json) gesucht wird.  
      * token\_load\_paths: Vec\<PathBuf\>: Eine Liste von Verzeichnispfaden, in denen nach globalen Token-Dateien (\*.tokens.json) gesucht wird.  
    * **Rückgabe:** Result\<Self, ThemingError\>. Gibt die initialisierte ThemingEngine oder einen Fehler zurück.  
    * **Vorbedingungen:** initial\_config sollte semantisch valide sein (obwohl die Engine dies prüft). Die angegebenen Pfade müssen für das Programm lesbar sein.  
    * **Nachbedingungen:** Bei Erfolg ist die Engine initialisiert, verfügt über einen gültigen applied\_state (entweder basierend auf initial\_config oder einem Fallback) und hat alle verfügbaren Themes/Tokens geladen. event\_subscribers ist initialisiert (leer).  
    * **Mögliche Fehler:** ThemingError::TokenFileParseError, ThemingError::ThemeFileLoadError, ThemingError::CyclicTokenReference, ThemingError::InitialConfigurationError (wenn initial\_config zu einem unauflösbaren Zustand führt), ThemingError::FallbackThemeLoadError (wenn selbst das Laden des Fallback-Themes fehlschlägt).  
* **Zustandsabfrage:**  
  * pub fn get\_current\_theme\_state(\&self) \-\> Result\<AppliedThemeState, ThemingError\>  
    * **Beschreibung:** Gibt eine Kopie (Clone) des aktuellen AppliedThemeState zurück. Dies ist der primäre Weg für die UI-Schicht, die aktuellen Theme-Werte abzurufen.  
    * **Rückgabe:** Result\<AppliedThemeState, ThemingError\>. Ein Fehler ist hier unwahrscheinlich, könnte aber bei schwerwiegenden internen Inkonsistenzen auftreten (z.B. ThemingError::InternalStateError).  
    * **Thread-Sicherheit:** Diese Methode ist lesend und greift auf den internen Zustand über einen Mutex zu.  
  * pub fn get\_available\_themes(\&self) \-\> Result\<Vec\<ThemeDefinition\>, ThemingError\>  
    * **Beschreibung:** Gibt eine Kopie (Clone) der Liste aller geladenen und validierten ThemeDefinitions zurück. Nützlich für UI-Elemente, die eine Theme-Auswahl anbieten.  
    * **Rückgabe:** Result\<Vec\<ThemeDefinition\>, ThemingError\>. Fehler wie bei get\_current\_theme\_state().  
  * pub fn get\_current\_configuration(\&self) \-\> Result\<ThemingConfiguration, ThemingError\>  
    * **Beschreibung:** Gibt eine Kopie (Clone) der aktuell von der Engine verwendeten ThemingConfiguration zurück.  
    * **Rückgabe:** Result\<ThemingConfiguration, ThemingError\>. Fehler wie bei get\_current\_theme\_state().  
* **Zustandsänderung:**  
  * pub fn update\_configuration(\&self, new\_config: ThemingConfiguration) \-\> Result\<(), ThemingError\>  
    * **Beschreibung:** Aktualisiert die Konfiguration der ThemingEngine mit der new\_config. Dies löst die Token Resolution Pipeline (Abschnitt 3.2) neu aus. Der interne applied\_state wird aktualisiert. Wenn sich der applied\_state dadurch tatsächlich ändert, wird ein ThemeChangedEvent an alle registrierten Subscriber gesendet.  
    * **Parameter:**  
      * new\_config: ThemingConfiguration: Die neue anzuwendende Benutzerkonfiguration.  
    * **Rückgabe:** Result\<(), ThemingError\>.  
    * **Vorbedingungen:** new\_config sollte semantisch valide sein.  
    * **Nachbedingungen:** Der interne Zustand (current\_config, applied\_state) ist aktualisiert. Bei einer relevanten Änderung wurde ein ThemeChangedEvent gesendet.  
    * **Mögliche Fehler:** ThemingError::ThemeNotFound (wenn new\_config.selected\_theme\_id ungültig ist), ThemingError::TokenResolutionError (z.B. MissingTokenReference, CyclicTokenReference während der Anwendung der neuen Konfiguration), ThemingError::ThemeApplicationError für allgemeinere Probleme.  
  * pub fn reload\_themes\_and\_tokens(\&self) \-\> Result\<(), ThemingError\>  
    * **Beschreibung:** Veranlasst die ThemingEngine, alle Theme-Definitionen und Token-Dateien von den beim Konstruktor angegebenen Pfaden neu zu laden. Dies ist nützlich, wenn der Benutzer z.B. neue Themes manuell installiert oder bestehende Token-Dateien extern bearbeitet hat. Nach dem Neuladen wird die *aktuell gespeicherte* ThemingConfiguration auf die neu geladenen Daten angewendet. Wenn sich der applied\_state dadurch ändert, wird ein ThemeChangedEvent gesendet.  
    * **Rückgabe:** Result\<(), ThemingError\>.  
    * **Nachbedingungen:** Der interne Bestand an available\_themes und global\_raw\_tokens ist aktualisiert. Der applied\_state ist basierend auf der aktuellen Konfiguration und den neuen Daten neu berechnet. Ein Event wurde ggf. gesendet.  
    * **Mögliche Fehler:** ThemingError::TokenFileIoError, ThemingError::TokenFileParseError, ThemingError::ThemeFileIoError, ThemingError::ThemeFileLoadError (beim Neuladen), sowie Fehler, die auch bei update\_configuration auftreten können, da der Zustand neu angewendet wird.  
* **Event-Handling (Subscription):**  
  * pub fn subscribe\_to\_theme\_changes(\&self) \-\> Result\<mpsc::Receiver\<ThemeChangedEvent\>, ThemingError\>  
    * **Beschreibung:** Ermöglicht anderen Teilen des Systems (Subscriber), sich für Benachrichtigungen über Änderungen am AppliedThemeState zu registrieren. Jeder Aufruf dieser Methode erstellt einen neuen Kommunikationskanal.  
    * **Rückgabe:** Result\<mpsc::Receiver\<ThemeChangedEvent\>, ThemingError\>. Der zurückgegebene Receiver kann verwendet werden, um ThemeChangedEvents asynchron zu empfangen.  
    * **Implementierungsdetails:** Die ThemingEngine hält eine Liste von mpsc::Sender\<ThemeChangedEvent\>-Enden (in event\_subscribers). Diese Methode erstellt ein neues mpsc::channel(), fügt den Sender-Teil zur Liste hinzu und gibt den Receiver-Teil zurück. Beim Senden eines Events iteriert die Engine über alle gespeicherten Sender und versucht, das Event zu senden. Sender, deren korrespondierender Receiver nicht mehr existiert (Kanal geschlossen), werden aus der Liste entfernt.  
    * **Mögliche Fehler:** ThemingError::EventSubscriptionError (z.B. bei Problemen mit der internen Verwaltung der Subscriber-Liste, obwohl dies bei korrekter Implementierung selten sein sollte).

#### **4.1.3. Signale/Events**

Die ThemingEngine verwendet Events, um andere Systemkomponenten über relevante Zustandsänderungen zu informieren, ohne eine enge Kopplung zu erfordern.

* **ThemeChangedEvent (Struct):**  
  * **Beschreibung:** Dieses Event wird von der ThemingEngine immer dann gesendet, wenn sich der AppliedThemeState erfolgreich geändert hat, sei es durch eine neue Benutzerkonfiguration oder durch das Neuladen von Theme-Daten.  
  * **Payload:**  
    Rust  
    \# // Clone ist wichtig, damit das Event an mehrere Subscriber gesendet werden kann.  
                            // Serialize ist nicht unbedingt nötig für interne Events.  
    pub struct ThemeChangedEvent {  
        pub new\_state: AppliedThemeState,  
        // Optional könnte hier auch der alte Zustand für Vergleiche mitgesendet werden:  
        // pub old\_state: Option\<AppliedThemeState\>,  
    }

  * **Typischer Publisher:** Die ThemingEngine selbst, innerhalb der Methoden update\_configuration und reload\_themes\_and\_tokens.  
  * **Typische Subscriber:**  
    * ui::theming\_gtk (oder ein äquivalentes Modul in der UI-Schicht): Um die GTK4-CSS-Provider mit den neuen, in new\_state.resolved\_tokens enthaltenen Werten zu aktualisieren.  
    * Andere UI-Komponenten oder Widgets, die direkt auf spezifische Token-Werte reagieren müssen, ohne den Umweg über CSS (obwohl dies seltener sein sollte).  
    * Potenziell andere Domänen- oder Systemdienste, die ihr Verhalten an das aktuelle Theme anpassen müssen.

### **4.2. Tabellen für API-Spezifikation**

Diese Tabellen bieten eine kompakte Übersicht über die Methoden der ThemingEngine und die von ihr emittierten Events. Sie sind entscheidend für Entwickler, die die Engine nutzen, da sie klare Erwartungen an Signaturen, Verhalten und Fehlerfälle setzen.

* **Tabelle 4.1: ThemingEngine-Methoden**

| Name | Signatur | Zugriff | Kurzbeschreibung | Vorbedingungen | Nachbedingungen | ThemingError-Varianten (Beispiele) |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| new | (initial\_config: ThemingConfiguration, theme\_load\_paths: Vec\<PathBuf\>, token\_load\_paths: Vec\<PathBuf\>) \-\> Result\<Self, ThemingError\> | pub | Konstruktor. Initialisiert Engine, lädt Themes/Tokens, wendet Erstkonfiguration an, richtet Fallback ein. | initial\_config valide, Pfade lesbar. | Engine initialisiert, applied\_state gültig. | ThemeLoadError, TokenParseError, InitialConfigurationError, FallbackThemeLoadError |
| get\_current\_theme\_state | (\&self) \-\> Result\<AppliedThemeState, ThemingError\> | pub | Gibt den aktuell angewendeten AppliedThemeState zurück. | Engine muss initialisiert sein. | Eine Kopie des Zustands wird zurückgegeben. | InternalStateError (selten) |
| get\_available\_themes | (\&self) \-\> Result\<Vec\<ThemeDefinition\>, ThemingError\> | pub | Gibt eine Liste aller verfügbaren, geladenen Theme-Definitionen zurück. | Engine muss initialisiert sein. | Eine Kopie der Liste wird zurückgegeben. | InternalStateError (selten) |
| get\_current\_configuration | (\&self) \-\> Result\<ThemingConfiguration, ThemingError\> | pub | Gibt die aktuell verwendete ThemingConfiguration zurück. | Engine muss initialisiert sein. | Eine Kopie der Konfiguration wird zurückgegeben. | InternalStateError (selten) |
| update\_configuration | (\&self, new\_config: ThemingConfiguration) \-\> Result\<(), ThemingError\> | pub | Aktualisiert Konfiguration, berechnet neuen Zustand und sendet ggf. ThemeChangedEvent. | new\_config valide. | Interner Zustand aktualisiert, ThemeChangedEvent ggf. gesendet. | ThemeApplicationError, TokenResolutionError, ThemeNotFound |
| reload\_themes\_and\_tokens | (\&self) \-\> Result\<(), ThemingError\> | pub | Lädt alle Theme- und Token-Dateien neu und wendet aktuelle Konfiguration an. Sendet ggf. ThemeChangedEvent. | Konfigurierte Pfade müssen weiterhin zugänglich sein. | Interner Datenbestand aktualisiert, ThemeChangedEvent ggf. gesendet. | ThemeLoadError, TokenParseError, ThemeApplicationError |
| subscribe\_to\_theme\_changes | (\&self) \-\> Result\<mpsc::Receiver\<ThemeChangedEvent\>, ThemingError\> | pub | Registriert einen Listener für ThemeChangedEvent und gibt einen Receiver zurück. | Engine muss initialisiert sein. | Ein mpsc::Receiver wird zurückgegeben, Sender intern registriert. | EventSubscriptionError |

* **Tabelle 4.2: ThemeChangedEvent**

| Event-Name/Typ | Payload-Struktur (pub fields: Type) | Typische Publisher | Typische Subscriber | Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| ThemeChangedEvent | new\_state: AppliedThemeState | ThemingEngine | ui::theming\_gtk (und Äquivalente), UI-Komponenten, die direkt auf Tokens reagieren | Wird ausgelöst, nachdem der AppliedThemeState der ThemingEngine erfolgreich aktualisiert und geändert wurde. |

## **5\. Fehlerbehandlung (domain::theming::errors)**

Eine robuste und aussagekräftige Fehlerbehandlung ist entscheidend für die Stabilität und Wartbarkeit des domain::theming-Moduls. Gemäß den übergeordneten Entwicklungsrichtlinien (Abschnitt 4.3 der Gesamtspezifikation) wird das thiserror-Crate verwendet, um spezifische, benutzerdefinierte Fehler-Enums pro Modul zu definieren. Dies ermöglicht eine klare Kommunikation von Fehlerzuständen sowohl innerhalb des Moduls als auch an dessen Aufrufer.  
Die Fehlerbehandlung in Rust, die sich um das Result\<T, E\>-Enum dreht 1, erfordert eine sorgfältige Definition der Fehlertypen E. Während std::error::Error eine Basistrait ist 2, bieten Crates wie thiserror erhebliche Erleichterungen bei der Erstellung benutzerdefinierter Fehlertypen, die diesen Trait implementieren.1

### **5.1. Definition des ThemingError Enums**

Das ThemingError-Enum fasst alle spezifischen Fehler zusammen, die innerhalb des domain::theming-Moduls auftreten können. Jede Variante des Enums repräsentiert einen distinkten Fehlerfall und ist mit einer aussagekräftigen Fehlermeldung versehen, die Kontextinformationen für Entwickler bereitstellt. Die Verwendung von \#\[from\] für Fehler aus tieferliegenden Bibliotheken (wie std::io::Error oder serde\_json::Error) ermöglicht eine einfache Fehlerkonvertierung und erhält die Kausalkette (source()).

Rust

// In domain::theming::errors.rs  
use thiserror::Error;  
use super::types::{TokenIdentifier, ThemeIdentifier}; // Annahme: types.rs ist im selben Modul  
use std::path::PathBuf;

\#  
pub enum ThemingError {  
    \#\[error("Failed to parse token file '{path}': {source}")\]  
    TokenFileParseError {  
        path: PathBuf,  
        \#\[source\]  
        source: serde\_json::Error,  
    },

    \#\[error("I/O error while processing token file '{path}': {source}")\]  
    TokenFileIoError {  
        path: PathBuf,  
        \#\[source\]  
        source: std::io::Error,  
    },

    \#\[error("Invalid token data in file '{path}': {message}")\]  
    InvalidTokenData {  
        path: PathBuf,  
        message: String,  
    },

    \#\[error("Cyclic dependency detected involving token '{token\_id}' during token validation or resolution")\]  
    CyclicTokenReference {  
        token\_id: TokenIdentifier,  
        // Optional: path\_to\_cycle: Vec\<TokenIdentifier\> // Zur besseren Diagnose  
    },

    \#\[error("Failed to load theme definition '{theme\_id}' from file '{path}': {source}")\]  
    ThemeFileLoadError {  
        theme\_id: ThemeIdentifier,  
        path: PathBuf,  
        \#\[source\]  
        source: serde\_json::Error,  
    },

    \#\[error("I/O error while loading theme definition '{theme\_id}' from file '{path}': {source}")\]  
    ThemeFileIoError {  
        theme\_id: ThemeIdentifier,  
        path: PathBuf,  
        \#\[source\]  
        source: std::io::Error,  
    },

    \#\[error("Invalid theme data for theme '{theme\_id}' in file '{path}': {message}")\]  
    InvalidThemeData {  
        theme\_id: ThemeIdentifier,  
        path: PathBuf,  
        message: String,  
    },

    \#  
    ThemeNotFound {  
        theme\_id: ThemeIdentifier,  
    },

    \#  
    MissingTokenReference {  
        referencing\_token\_id: TokenIdentifier,  
        target\_token\_id: TokenIdentifier,  
    },

    \#  
    MaxReferenceDepthExceeded {  
        token\_id: TokenIdentifier,  
    },

    \#\[error("Failed to apply theming configuration: {message}")\]  
    ThemeApplicationError {  
        message: String,  
        // Optional: \#\[source\] source: Option\<Box\<dyn std::error::Error \+ Send \+ Sync \+ 'static\>\>,  
    },

    \#\[error("Critical error: Failed to initialize theming engine because no suitable fallback theme could be loaded.")\]  
    FallbackThemeLoadError,

    \#  
    InitialConfigurationError(String),  
      
    \#  
    InternalStateError(String),

    \#\[error("Failed to subscribe to theme change events: {0}")\]  
    EventSubscriptionError(String),

    // Beispiel für einen Wrapper für Core-Fehler, falls das Projekt einen zentralen CoreError hat.  
    // Dies ist oft weniger spezifisch als dedizierte Fehler, kann aber für die Integration nützlich sein.  
    // \#\[error("Core system error: {source}")\]  
    // CoreError(\#\[from\] crate::core::errors::CoreError),  
}

Die gewählte Granularität – ein Fehler-Enum pro Modul (ThemingError) mit spezifischen Varianten – stellt einen guten Kompromiss dar. Es vermeidet eine übermäßige Anzahl von Fehlertypen über das gesamte Projekt hinweg, bietet aber dennoch genügend Spezifität, um Fehlerquellen innerhalb des Moduls klar zu identifizieren und darauf reagieren zu können.4 Die Fehlermeldungen sind so gestaltet, dass sie möglichst viel Kontext liefern (z.B. Dateipfade, Token-IDs), was die Fehlersuche erheblich erleichtert und der Anforderung nach aussagekräftigen Fehlerberichten entspricht.1  
Die \#\[from\]-Annotation von thiserror wird genutzt, um Fehler von Abhängigkeiten wie serde\_json::Error und std::io::Error nahtlos in spezifische ThemingError-Varianten zu überführen. Dies vereinfacht den Code, da der ?-Operator direkt verwendet werden kann, und stellt sicher, dass die ursprüngliche Fehlerquelle (source) erhalten bleibt.1 Die Unterscheidung zwischen TokenFileIoError und ThemeFileIoError, obwohl beide potenziell von std::io::Error stammen, ist hier gerechtfertigt, da sie unterschiedliche logische Operationen (Lesen einer Token-Datei vs. Lesen einer Theme-Datei) und unterschiedliche Kontextinformationen (nur path vs. theme\_id und path) repräsentieren. Dies vermeidet die in 1 erwähnte Problematik, dass der Kontext bei der reinen Verwendung von \#\[from\] für denselben Quelltyp verschwimmen kann, wenn nicht genügend differenzierende Felder vorhanden sind.

### **5.2. Richtlinien zur Fehlerbehandlung und \-weitergabe innerhalb des Moduls**

* **Fehlerkonvertierung:** Innerhalb der privaten Logikfunktionen des domain::theming-Moduls (Abschnitt 3\) werden auftretende Fehler (z.B. I/O-Fehler beim Dateizugriff, Parsing-Fehler von serde\_json) systematisch in die entsprechenden Varianten von ThemingError umgewandelt. Dies geschieht häufig automatisch durch die Verwendung des ?-Operators in Verbindung mit den \#\[from\]-Annotationen im ThemingError-Enum oder, falls notwendig, manuell durch Aufrufe von .map\_err().  
* **Vermeidung von Panics:** Panics, ausgelöst durch unwrap() oder expect(), sind im Code des domain::theming-Moduls strikt zu vermeiden. Die einzige Ausnahme bilden potenziell Situationen, in denen ein absolut inkonsistenter Zustand eine sichere Fortführung des Programms unmöglich macht (z.B. ein kritischer, nicht behebbarer Fehler beim Laden des essentiellen Fallback-Themes während der Initialisierung der ThemingEngine). Solche Fälle müssen extrem selten sein, sorgfältig dokumentiert und begründet werden. Falls ein expect() in einer solchen Ausnahmesituation verwendet wird, sollte die Nachricht dem "expect as precondition"-Stil folgen, der beschreibt, warum der Entwickler erwartet hat, dass die Operation erfolgreich sein würde.2  
* **Fehlerweitergabe durch die API:** Alle öffentlichen Methoden der ThemingEngine (Abschnitt 4), die fehlschlagen können, geben Result\<T, ThemingError\> zurück. Dies zwingt den aufrufenden Code, Fehler explizit zu behandeln und ermöglicht eine differenzierte Reaktion auf verschiedene Fehlerzustände.  
* **Nutzung der source()-Kette:** Durch die korrekte Verwendung von \#\[source\] in den thiserror-Definitionen wird die Kausalkette von Fehlern bewahrt. Dies ist besonders nützlich für das Debugging, da es ermöglicht, einen Fehler bis zu seiner ursprünglichen Ursache zurückzuverfolgen, auch über Modul- oder Bibliotheksgrenzen hinweg.3

### **5.3. Tabelle für Fehlerbehandlung**

Die folgende Tabelle listet eine Auswahl der wichtigsten ThemingError-Varianten auf, beschreibt ihre Bedeutung und die typischen Umstände ihres Auftretens. Dies dient Entwicklern als Referenz für die Implementierung der Fehlerbehandlung im aufrufenden Code und für das Debugging.

* **Tabelle 5.1: ThemingError-Varianten (Auswahl)**

| Variante | \#\[error("...")\] String (Beispiel) | Gekapselter Quellfehler (via \#\[from\] oder Feld) | Beschreibung des Fehlerfalls |
| :---- | :---- | :---- | :---- |
| TokenFileParseError | "Failed to parse token file '{path}': {source}" | path: PathBuf, source: serde\_json::Error | Fehler beim Parsen einer JSON-Datei, die Tokens enthält (z.B. Syntaxfehler im JSON). |
| TokenFileIoError | "I/O error while processing token file '{path}': {source}" | path: PathBuf, source: std::io::Error | Ein-/Ausgabefehler beim Lesen oder Schreiben einer Token-Datei (z.B. Datei nicht gefunden, keine Leserechte). |
| CyclicTokenReference | "Cyclic dependency detected involving token '{token\_id}'..." | token\_id: TokenIdentifier | Eine zirkuläre Referenz zwischen Tokens wurde gefunden (z.B. Token A verweist auf B, und B verweist zurück auf A). |
| ThemeNotFound | "Theme with ID '{theme\_id}' not found among available themes" | theme\_id: ThemeIdentifier | Ein angefordertes Theme (z.B. in ThemingConfiguration) konnte nicht in den geladenen Definitionen gefunden werden. |
| MissingTokenReference | "Token resolution failed: Referenced token '{target\_token\_id}' not found (referenced by '{referencing\_token\_id}')" | referencing\_token\_id: TokenIdentifier, target\_token\_id: TokenIdentifier | Ein Token verweist auf ein anderes Token (target\_token\_id), das jedoch nicht im aktuellen Auflösungskontext existiert. |
| ThemeApplicationError | "Failed to apply theming configuration: {message}" | message: String | Allgemeiner Fehler während des Prozesses, eine neue ThemingConfiguration anzuwenden und den AppliedThemeState zu generieren. |
| FallbackThemeLoadError | "Critical error: Failed to initialize theming engine because no suitable fallback theme could be loaded." | \- | Kritischer Initialisierungsfehler: Das essentielle Fallback-Theme konnte nicht geladen oder verarbeitet werden. |
| InternalStateError | "An internal, unrecoverable error occurred in the ThemingEngine: {0}" | String (Fehlermeldung) | Ein unerwarteter, interner Fehler in der Engine, der auf einen Programmierfehler oder eine Datenkorruption hindeutet. |

## **6\. Vorgeschlagene Dateistruktur für das Modul domain::theming**

Eine klare und logische Dateistruktur ist entscheidend für die Wartbarkeit und Verständlichkeit eines Moduls. Für domain::theming wird folgende Struktur vorgeschlagen:

domain/  
└── theming/  
    ├── mod.rs           // Hauptmoduldatei (public API: ThemingEngine, Re-Exports)  
    ├── types.rs         // Definition aller Datenstrukturen (Token\*, Theme\*, Config\*, Event\*)  
    ├── errors.rs        // Definition des ThemingError Enums und zugehöriger Typen  
    ├── logic.rs         // Interne Implementierung der Kernlogik (Token-Laden, \-Auflösung etc.)  
    │                    // Kann bei Bedarf in Untermodule aufgeteilt werden:  
    │                    //   logic/token\_parser.rs  
    │                    //   logic/theme\_loader.rs  
    │                    //   logic/token\_resolver.rs  
    │                    //   logic/accent\_color\_processor.rs  
    ├── default\_themes/  // Verzeichnis für eingebettete Fallback-Theme-Dateien (JSON)  
    │   └── fallback.theme.json  
    │   └── base.tokens.json // Minimale Basis-Tokens für das Fallback-Theme  
    └──Cargo.toml        // Falls domain::theming als eigenes Crate innerhalb eines Workspace konzipiert ist

* **Begründung der Struktur:**  
  * mod.rs: Dient als Fassade des Moduls. Es deklariert die ThemingEngine-Struktur und re-exportiert die öffentlich zugänglichen Typen aus types.rs und errors.rs. Hier wird die öffentliche API des Moduls definiert und zugänglich gemacht.  
  * types.rs: Zentralisiert alle theming-spezifischen Datenstrukturen (wie RawToken, ThemeDefinition, AppliedThemeState etc.). Dies verbessert die Übersichtlichkeit und hilft, zyklische Abhängigkeiten zu vermeiden, da diese Typen sowohl von der API (mod.rs) als auch von der internen Logik (logic.rs) benötigt werden.  
  * errors.rs: Enthält ausschließlich die Definition des ThemingError-Enums und eventuell zugehöriger Hilfstypen für Fehler. Dies entspricht der Richtlinie, Fehlerdefinitionen pro Modul zu gruppieren.  
  * logic.rs: Kapselt die gesamte interne Implementierungslogik der Theming-Engine. Dazu gehören das Laden, Parsen und Validieren von Token- und Theme-Dateien, die komplexe Token Resolution Pipeline und die Handhabung von dynamischen Theme-Wechseln. Um die Komplexität zu bewältigen, kann logic.rs selbst wiederum in spezialisierte Untermodule (z.B. token\_parser.rs, token\_resolver.rs) aufgeteilt werden, die jeweils einen spezifischen Teilaspekt der Logik behandeln. Diese internen Module und Funktionen sind nicht Teil der öffentlichen API (pub(crate)).  
  * default\_themes/: Dieses Verzeichnis enthält die JSON-Dateien für das Fallback-Theme und die dafür notwendigen Basis-Tokens. Diese Dateien können zur Kompilierzeit mittels include\_str\! direkt in die Binärdatei eingebettet werden, um sicherzustellen, dass das Fallback-Theme immer verfügbar ist, selbst wenn externe Konfigurationsdateien fehlen oder beschädigt sind.  
  * Cargo.toml: Wäre vorhanden, wenn domain::theming als separates Crate innerhalb eines Rust-Workspace verwaltet wird. In diesem Fall würde es die Abhängigkeiten (wie serde, serde\_json, thiserror, tracing) und Metadaten spezifisch für dieses Crate deklarieren.

Diese Struktur fördert eine klare Trennung der Belange ("Separation of Concerns"): Die API-Definition ist von der Implementierungslogik getrennt, Datentypen sind zentralisiert, und Fehlerbehandlung sowie Ressourcen sind ebenfalls in eigenen Bereichen organisiert. Dies erleichtert neuen Entwicklern den Einstieg und vereinfacht die Wartung und Weiterentwicklung des Moduls.

## **7\. Detaillierter Implementierungsleitfaden (Schritt-für-Schritt)**

Dieser Leitfaden beschreibt die empfohlene Reihenfolge und die Details für die Implementierung des domain::theming-Moduls. Jeder Schritt sollte von umfassenden Unit-Tests begleitet werden, um die Korrektheit der Implementierung sicherzustellen.

### **7.1. Schrittweise Implementierung der Datenstrukturen (Abschnitt 2\)**

1. **Datei erstellen:** domain/theming/types.rs.  
2. **TokenIdentifier implementieren:**  
   * Struct-Definition mit String-Feld.  
   * new()-Methode, as\_str()-Methode.  
   * Ableitungen: Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize.  
   * Implementierung von std::fmt::Display.  
3. **TokenValue implementieren:**  
   * Enum-Definition mit allen Varianten (Color, Dimension,..., Reference(TokenIdentifier)).  
   * Ableitungen: Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize.  
   * \#\[serde(rename\_all \= "kebab-case")\] Attribut für konsistente JSON-Serialisierung.  
4. **RawToken implementieren:**  
   * Struct-Definition mit Feldern id: TokenIdentifier, value: TokenValue, description: Option\<String\>, group: Option\<String\>.  
   * Ableitungen: Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize.  
   * \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\] für optionale Felder.  
5. **TokenSet Typalias definieren:**  
   * pub type TokenSet \= std::collections::HashMap\<TokenIdentifier, RawToken\>;  
6. **ThemeIdentifier implementieren:** Analog zu TokenIdentifier.  
7. **ColorSchemeType implementieren:**  
   * Enum-Definition mit Varianten Light, Dark.  
   * Ableitungen: Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize.  
8. **AccentColor implementieren:**  
   * Struct-Definition mit Feldern name: Option\<String\>, value: String.  
   * Ableitungen: Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize.  
9. **ThemeVariantDefinition implementieren:**  
   * Struct-Definition mit Feldern applies\_to\_scheme: ColorSchemeType, tokens: TokenSet.  
   * Ableitungen: Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize.  
10. **ThemeDefinition implementieren:**  
    * Struct-Definition mit allen Feldern (id, name, description, author, version, base\_tokens, variants, supported\_accent\_colors).  
    * Ableitungen: Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize.  
    * \#\[serde(default,...)\] für optionale Felder und Vektoren.  
11. **AppliedThemeState implementieren:**  
    * Struct-Definition mit Feldern theme\_id, color\_scheme, active\_accent\_color, resolved\_tokens: std::collections::HashMap\<TokenIdentifier, String\>.  
    * Ableitungen: Debug, Clone, PartialEq, serde::Serialize. Deserialize ist hier optional, da dieser Zustand typischerweise von der Engine konstruiert wird.  
12. **ThemingConfiguration implementieren:**  
    * Struct-Definition mit Feldern selected\_theme\_id, preferred\_color\_scheme, selected\_accent\_color, custom\_user\_token\_overrides.  
    * Ableitungen: Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize.  
13. **Unit-Tests für Datenstrukturen:**  
    * Für jede serialisierbare Struktur Tests schreiben, die die korrekte Serialisierung zu JSON und Deserialisierung von JSON überprüfen.  
    * Beispieldaten für JSON-Strings verwenden, die alle Felder und Varianten abdecken.  
    * Korrektheit der serde-Attribute (rename\_all, default, skip\_serializing\_if) verifizieren.  
    * Die Display-Implementierung für TokenIdentifier und ThemeIdentifier testen.

### **7.2. Implementierung des ThemingError Enums (Abschnitt 5\)**

1. **Datei erstellen:** domain/theming/errors.rs.  
2. **Abhängigkeit hinzufügen:** thiserror zur Cargo.toml des domain-Crates (oder des Workspace-Root, falls domain::theming ein eigenes Crate wird, bzw. zum Projekt-Crate).  
   Ini, TOML  
   \[dependencies\]  
   thiserror \= "1.0"  
   serde\_json \= "1.0" // Bereits für Typen benötigt, aber auch für Fehlerquellen relevant  
   \# weitere Abhängigkeiten

3. **ThemingError Enum definieren:**  
   * Das Enum wie in Abschnitt 5.1 spezifiziert implementieren.  
   * Alle Varianten mit den entsprechenden Feldern für Kontextinformationen (Pfade, IDs etc.) definieren.  
   * \#\[error("...")\] Attribute für jede Variante mit aussagekräftigen Fehlermeldungen versehen.  
   * \#\[source\] für gekapselte Fehler und \#\[from\] für automatische Konvertierung von std::io::Error und serde\_json::Error verwenden, wo passend.  
4. **Unit-Tests für ThemingError:**  
   * Tests schreiben, die sicherstellen, dass die Display-Implementierung (generiert durch \#\[error("...")\]) die erwarteten, formatierten Fehlermeldungen erzeugt.  
   * Für Fehler-Varianten, die einen \#\[source\]-Fehler kapseln, testen, ob die source()-Methode den korrekten zugrundeliegenden Fehler zurückgibt.  
   * Testen der From-Implementierungen (generiert durch \#\[from\]), indem Quellfehler manuell erzeugt und in ThemingError konvertiert werden.

### **7.3. Implementierung der Kernlogik-Funktionen und Geschäftsregeln (Abschnitt 3\)**

Diese Funktionen werden typischerweise in domain/theming/logic.rs oder dessen Untermodulen implementiert und als pub(crate) deklariert.

* **7.3.1. Token- und Theme-Definitionen laden, parsen und validieren:**  
  1. **Funktion pub(crate) fn load\_raw\_tokens\_from\_file(path: \&std::path::Path) \-\> Result\<TokenSet, ThemingError\>:**  
     * Datei öffnen und Inhalt lesen (std::fs::read\_to\_string). Fehlerbehandlung für I/O (ThemingError::TokenFileIoError).  
     * JSON-Inhalt parsen (serde\_json::from\_str) zu Vec\<RawToken\>. Fehlerbehandlung für Parsing (ThemingError::TokenFileParseError).  
     * Vec\<RawToken\> in TokenSet (HashMap) konvertieren. Dabei auf doppelte TokenIdentifier prüfen. Bei Duplikaten eine Warnung loggen (tracing::warn\!) und das zuletzt gelesene Token verwenden oder einen Fehler (ThemingError::InvalidTokenData) auslösen, je nach definierter Strategie (z.B. Duplikate innerhalb einer Datei sind ein Fehler).  
     * tracing::debug\! für erfolgreiches Laden verwenden.  
  2. **Funktion pub(crate) fn load\_theme\_definition\_from\_file(path: \&std::path::Path, theme\_id\_from\_path: ThemeIdentifier) \-\> Result\<ThemeDefinition, ThemingError\>:**  
     * Datei öffnen und Inhalt lesen. Fehlerbehandlung (ThemingError::ThemeFileIoError mit theme\_id und path).  
     * JSON-Inhalt parsen zu ThemeDefinition. Fehlerbehandlung (ThemingError::ThemeFileLoadError mit theme\_id und path).  
     * Validieren, ob theme\_def.id mit theme\_id\_from\_path (abgeleitet vom Dateinamen/Pfad) übereinstimmt. Bei Diskrepanz ThemingError::InvalidThemeData.  
  3. **Funktion pub(crate) fn validate\_tokenset\_for\_cycles(tokens: \&TokenSet) \-\> Result\<(), ThemingError\>:**  
     * Implementiert einen Algorithmus zur Zyklenerkennung (z.B. Tiefensuche) für TokenValue::Reference-Beziehungen.  
     * Hält eine Liste der besuchten Tokens während eines Auflösungspfads, um Zyklen zu erkennen.  
     * Gibt bei Zykluserkennung ThemingError::CyclicTokenReference { token\_id } zurück (wobei token\_id das erste im Zyklus erkannte Token ist oder ein Token, das Teil des Zyklus ist).  
  4. **Funktion pub(crate) fn validate\_theme\_definition\_references(theme\_def: \&ThemeDefinition, global\_tokens: \&TokenSet) \-\> Result\<(), ThemingError\>:**  
     * Iteriert durch alle Tokens in theme\_def.base\_tokens und in allen theme\_def.variants\[\*\].tokens.  
     * Für jedes Token, das ein TokenValue::Reference(target\_id) ist, prüfen, ob target\_id entweder in global\_tokens oder in theme\_def.base\_tokens (falls das aktuelle Token aus einer Variante stammt und sich auf ein Basistoken des Themes bezieht) existiert.  
     * Gibt bei einer fehlenden Referenz ThemingError::InvalidThemeData (oder einen spezifischeren Fehler wie MissingThemeTokenReference) zurück.  
  5. **Unit-Tests für Lade- und Validierungsfunktionen:**  
     * Tests mit gültigen JSON-Dateien für Tokens und Themes.  
     * Tests mit fehlerhaften JSON-Dateien (Syntaxfehler, falsche Typen).  
     * Tests mit semantisch ungültigen Daten (z.B. doppelte Token-IDs in einer Datei, zyklische Referenzen in einem TokenSet, fehlende Referenzen in einer ThemeDefinition).  
     * Sicherstellen, dass die korrekten ThemingError-Varianten zurückgegeben werden.  
* **7.3.2. Token Resolution Pipeline implementieren:**  
  1. **Hauptfunktion pub(crate) fn resolve\_applied\_state(config: \&ThemingConfiguration, available\_themes: &, global\_tokens: \&TokenSet) \-\> Result\<AppliedThemeState, ThemingError\>:**  
     * Implementiere die in Abschnitt 3.2 detailliert beschriebenen Schritte:  
       * **Theme auswählen:** Finde die ThemeDefinition für config.selected\_theme\_id in available\_themes. Bei Nichtauffinden ThemingError::ThemeNotFound.  
       * **Initiales Token-Set:** Beginne mit einer Kopie von global\_tokens. Merge (überschreibe) mit selected\_theme.base\_tokens.  
       * **Variante anwenden:** Finde die passende ThemeVariantDefinition für config.preferred\_color\_scheme. Merge deren tokens.  
       * **Akzentfarbe anwenden:** Implementiere die Logik zur Verarbeitung von config.selected\_accent\_color. Für die Erstimplementierung: Ersetze spezielle Token-IDs (z.B. {{ACCENT\_COLOR\_VALUE}} oder token.system.accent) durch accent\_color.value.  
       * **Benutzer-Overrides anwenden:** Merge config.custom\_user\_token\_overrides.  
       * **Referenzen auflösen:** Implementiere eine rekursive Funktion resolve\_references(current\_tokens: \&mut TokenSet, max\_depth: u8) \-\> Result\<(), ThemingError\>. Diese Funktion iteriert, bis keine TokenValue::Reference mehr vorhanden sind oder max\_depth erreicht ist. Sie muss Zyklenerkennung beinhalten (kann validate\_tokenset\_for\_cycles nutzen oder eine eigene Implementierung haben) und Fehler wie ThemingError::MissingTokenReference und ThemingError::MaxReferenceDepthExceeded behandeln.  
       * **Finale Werte konvertieren:** Konvertiere die nun aufgelösten TokenValues in String-Werte für das resolved\_tokens-Feld des AppliedThemeState.  
     * Konstruiere und gib den AppliedThemeState zurück.  
  2. **Hilfsfunktionen:**  
     * merge\_token\_sets(base: \&mut TokenSet, overrides: \&TokenSet): Fügt Tokens aus overrides zu base hinzu, wobei bestehende Tokens in base überschrieben werden.  
  3. **Unit-Tests für die Resolution Pipeline:**  
     * Szenarien mit einfachen Themes ohne Varianten oder Overrides.  
     * Szenarien mit Hell/Dunkel-Varianten.  
     * Szenarien mit Akzentfarben (einfache Ersetzung testen).  
     * Szenarien mit Benutzer-Overrides.  
     * Tests für mehrstufige Token-Referenzen (Aliase).  
     * Explizite Tests für Fehlerfälle: fehlende Referenzen, zyklische Referenzen während der Auflösung, Überschreitung der maximalen Tiefe.  
* **7.3.3. Fallback-Theme Logik:**  
  1. **Fallback-Ressourcen erstellen:** Erstelle domain/theming/default\_themes/fallback.theme.json und domain/theming/default\_themes/base.tokens.json mit minimalen, aber funktionsfähigen Werten. Diese sollten keine externen Referenzen enthalten und in sich geschlossen sein.  
  2. **Funktion pub(crate) fn load\_fallback\_applied\_state() \-\> Result\<AppliedThemeState, ThemingError\>:**  
     * Verwende include\_str\! Makros, um den Inhalt der JSON-Dateien zur Kompilierzeit einzubetten.  
     * Parse die eingebetteten Strings zu ThemeDefinition und TokenSet.  
     * Erzeuge einen AppliedThemeState direkt aus diesen Fallback-Daten (die Auflösung sollte hier trivial sein, da keine komplexen Referenzen erwartet werden).  
     * Diese Funktion sollte robust sein und nur im äußersten Notfall fehlschlagen (z.B. wenn die eingebetteten JSONs fehlerhaft sind, was ein Build-Problem wäre). Ein Fehler hier wäre ThemingError::FallbackThemeLoadError.

### **7.4. Implementierung des ThemingEngine-Service und seiner API (Abschnitt 4\)**

1. **Datei anpassen/erstellen:** domain/theming/mod.rs.  
2. **Strukturen definieren:**  
   * pub struct ThemingEngine { internal\_state: Arc\<Mutex\<ThemingEngineInternalState\>\>, event\_subscribers: Arc\<Mutex\<Vec\<mpsc::Sender\<ThemeChangedEvent\>\>\>\> }  
   * struct ThemingEngineInternalState {... } (Felder wie in 4.1 definiert, inklusive theme\_load\_paths, token\_load\_paths für reload).  
3. **Event-Struktur ThemeChangedEvent in types.rs definieren** (bereits in 7.1, hier nur zur Erinnerung).  
4. **Konstruktor ThemingEngine::new(...) implementieren:**  
   * Initialisiere event\_subscribers mit Arc::new(Mutex::new(Vec::new())).  
   * Initialisiere internal\_state.theme\_load\_paths und internal\_state.token\_load\_paths mit den übergebenen Pfaden.  
   * **Laden der globalen Tokens:** Iteriere über token\_load\_paths, rufe logic::load\_raw\_tokens\_from\_file für jede Datei auf und merge die Ergebnisse in internal\_state.global\_raw\_tokens. Führe logic::validate\_tokenset\_for\_cycles für das finale Set aus.  
   * **Laden der verfügbaren Themes:** Iteriere über theme\_load\_paths, finde \*.theme.json-Dateien, lade sie mit logic::load\_theme\_definition\_from\_file. Validiere jede ThemeDefinition mit logic::validate\_theme\_definition\_references gegen die global\_raw\_tokens. Sammle gültige Themes in internal\_state.available\_themes.  
   * **Anfänglichen Zustand anwenden:**  
     * Versuche, logic::resolve\_applied\_state mit initial\_config, internal\_state.available\_themes und internal\_state.global\_raw\_tokens aufzurufen.  
     * Bei Erfolg: Speichere initial\_config als internal\_state.current\_config und das Ergebnis als internal\_state.applied\_state.  
     * Bei Fehler: Logge den Fehler (tracing::warn\!). Versuche, logic::load\_fallback\_applied\_state() aufzurufen.  
       * Wenn Fallback erfolgreich: Speichere eine entsprechende Fallback-ThemingConfiguration (z.B. mit der ID des Fallback-Themes) und den Fallback-AppliedThemeState.  
       * Wenn Fallback fehlschlägt: Gib ThemingError::FallbackThemeLoadError zurück.  
   * Konstruiere und gib Ok(Self) zurück.  
5. **Implementiere get\_current\_theme\_state():** Sperre internal\_state-Mutex, klone internal\_state.applied\_state, gib Ok(cloned\_state) zurück.  
6. **Implementiere get\_available\_themes():** Sperre Mutex, klone internal\_state.available\_themes, gib Ok(cloned\_list) zurück.  
7. **Implementiere get\_current\_configuration():** Sperre Mutex, klone internal\_state.current\_config, gib Ok(cloned\_config) zurück.  
8. **Implementiere update\_configuration(new\_config: ThemingConfiguration):**  
   * Sperre internal\_state-Mutex.  
   * Speichere den alten applied\_state (für späteren Vergleich).  
   * Rufe logic::resolve\_applied\_state mit new\_config, \&self.internal\_state.available\_themes und \&self.internal\_state.global\_raw\_tokens auf.  
   * Bei Erfolg (Ok(new\_applied\_state)):  
     * Aktualisiere self.internal\_state.current\_config \= new\_config.  
     * Aktualisiere self.internal\_state.applied\_state \= new\_applied\_state.  
     * Wenn self.internal\_state.applied\_state sich vom alten applied\_state unterscheidet:  
       * Erzeuge ThemeChangedEvent { new\_state: self.internal\_state.applied\_state.clone() }.  
       * Sperre event\_subscribers-Mutex. Iteriere über die Sender und sende das geklonte Event. Entferne Sender, bei denen send() fehlschlägt (Kanal geschlossen).  
     * Gib Ok(()) zurück.  
   * Bei Fehler (Err(e)): Gib Err(e) zurück.  
9. **Implementiere reload\_themes\_and\_tokens():**  
   * Sperre internal\_state-Mutex.  
   * Lade globale Tokens und verfügbare Themes neu (wie im Konstruktor, unter Verwendung der gespeicherten theme\_load\_paths und token\_load\_paths). Aktualisiere internal\_state.global\_raw\_tokens und internal\_state.available\_themes. Fehler hierbei sollten geloggt und ggf. zurückgegeben werden.  
   * Speichere den alten applied\_state.  
   * Rufe logic::resolve\_applied\_state mit der *aktuellen* self.internal\_state.current\_config (die nicht geändert wurde) und den neu geladenen Daten auf.  
   * Aktualisiere self.internal\_state.applied\_state und sende Event wie bei update\_configuration, falls eine Änderung vorliegt.  
   * Gib Ok(()) oder den entsprechenden Lade-/Anwendungsfehler zurück.  
10. **Implementiere subscribe\_to\_theme\_changes():**  
    * Erzeuge ein neues mpsc::channel().  
    * Sperre event\_subscribers-Mutex. Füge den sender-Teil des Kanals zur Liste self.event\_subscribers hinzu.  
    * Gib Ok(receiver) zurück.  
11. **Unit-Tests für ThemingEngine:**  
    * **new():** Teste erfolgreiche Initialisierung mit gültigen Konfigurationen und Pfaden. Teste das Fallback-Verhalten, wenn initiale Konfigurationen fehlerhaft sind oder Pfade ungültig. Teste kritischen Fehler, wenn selbst Fallback fehlschlägt.  
    * **get\_\*() Methoden:** Teste, ob die korrekten Daten (Klone des internen Zustands) zurückgegeben werden.  
    * **update\_configuration():** Teste erfolgreiche Zustandsänderungen. Verifiziere, dass der applied\_state korrekt aktualisiert wird. Teste, dass ThemeChangedEvent nur gesendet wird, wenn sich der applied\_state tatsächlich ändert. Teste Fehlerfälle (z.B. ungültige ThemeIdentifier in new\_config).  
    * **reload\_themes\_and\_tokens():** Erstelle temporäre Theme-/Token-Dateien, modifiziere sie und teste, ob reload die Änderungen korrekt aufnimmt und den Zustand aktualisiert. Teste Event-Auslösung.  
    * **Event-System (subscribe\_to\_theme\_changes und Senden):** Registriere mehrere Subscriber. Löse eine Zustandsänderung aus und verifiziere, dass alle aktiven Subscriber das Event empfangen. Teste, dass Subscriber, deren Receiver fallengelassen wurde, korrekt aus der internen Liste entfernt werden und keine Fehler verursachen.  
    * **Thread-Sicherheit (konzeptionell):** Obwohl direkte Unit-Tests für Thread-Sicherheit komplex sind, stelle sicher, dass alle Zugriffe auf internal\_state und event\_subscribers korrekt durch Mutexe geschützt sind. Integrationstests könnten parallele Aufrufe simulieren.

### **7.5. Richtlinien für Unit-Tests (Zusammenfassung)**

* **Hohe Codeabdeckung:** Strebe eine hohe Testabdeckung für alle Logik-Komponenten in logic.rs und alle öffentlichen API-Methoden der ThemingEngine in mod.rs an.  
* **Fokus der Testfälle:**  
  * **Parsing und Validierung:** Korrekte Verarbeitung gültiger und ungültiger Eingabedaten (JSON-Dateien, Token-Strukturen).  
  * **Token-Auflösung:** Korrekte Auflösung von einfachen und komplexen Token-Referenzen (Aliase, Vererbung). Explizite Tests für Fehlerfälle wie fehlende Referenzen und zyklische Abhängigkeiten.  
  * **Theme-Anwendung:** Korrekte Anwendung von Basis-Themes, Varianten (Hell/Dunkel), Akzentfarben und Benutzer-Overrides.  
  * **ThemingEngine-Verhalten:** Korrekte Zustandsübergänge, Event-Auslösung und Fehlerbehandlung für alle API-Methoden.  
  * **Grenzwertanalyse:** Teste Randbedingungen (z.B. leere Token-Sets, Themes ohne Varianten, maximale Rekursionstiefe bei Referenzen).  
* **Testdaten und Fixtures:** Verwende kleine, fokussierte JSON-Beispieldateien für Tokens und Themes als Test-Fixtures. Diese können als Strings direkt in die Testfunktionen eingebettet oder aus einem Test-Ressourcenverzeichnis geladen werden.  
* **Mocking:** Für dieses Modul der Domänenschicht ist Mocking von externen Abhängigkeiten (hauptsächlich das Dateisystem) in der Regel nicht notwendig für Unit-Tests der Kernlogik. Die Ladefunktionen können mit temporären Dateien oder In-Memory-Daten getestet werden. Der Fokus liegt auf der internen Verarbeitungslogik.  
* **Testorganisation:** Unit-Tests sollten direkt neben dem zu testenden Code in Untermodulen tests liegen (\#\[cfg(test)\] mod tests {... }).

Durch die konsequente Befolgung dieses Implementierungsleitfadens und die sorgfältige Erstellung von Unit-Tests kann ein robustes, korrekt funktionierendes und wartbares domain::theming-Modul entwickelt werden.

#### **Referenzen**

1. Error Handling for Large Rust Projects \- Best Practice in GreptimeDB, Zugriff am Mai 13, 2025, [https://greptime.com/blogs/2024-05-07-error-rust](https://greptime.com/blogs/2024-05-07-error-rust)  
2. std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/index.html](https://doc.rust-lang.org/std/error/index.html)  
3. Error in std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/trait.Error.html](https://doc.rust-lang.org/std/error/trait.Error.html)  
4. Error handling \- good/best practices : r/rust \- Reddit, Zugriff am Mai 13, 2025, [https://www.reddit.com/r/rust/comments/1bb7dco/error\_handling\_goodbest\_practices/](https://www.reddit.com/r/rust/comments/1bb7dco/error_handling_goodbest_practices/)

# **Domänenschicht: Implementierungsleitfaden Teil 2/4 – Workspaces (domain::workspaces)**

## **1\. Einleitung zur Komponente domain::workspaces**

Die Komponente domain::workspaces ist ein zentraler Bestandteil der Domänenschicht und verantwortlich für die gesamte Logik und Verwaltung von Arbeitsbereichen, oft als "Spaces" oder virtuelle Desktops bezeichnet. Sie definiert die Struktur eines einzelnen Workspace, die Regeln für die Zuweisung von Fenstern zu Workspaces, die Orchestrierung aller Workspaces inklusive des aktiven Workspace und die Persistenz der Workspace-Konfiguration. Diese Komponente ist UI-unabhängig und stellt ihre Funktionalität über klar definierte Schnittstellen bereit, die von der System- und Benutzeroberflächenschicht genutzt werden können.  
Die Implementierung ist in vier primäre Module unterteilt, um eine hohe Kohäsion und lose Kopplung zu gewährleisten:

* workspaces::core: Definiert die grundlegende Entität eines Workspace und zugehörige Typen.  
* workspaces::assignment: Beinhaltet die Logik für die Zuweisung von Fenstern zu Workspaces.  
* workspaces::manager: Orchestriert die Verwaltung aller Workspaces und publiziert relevante Events.  
* workspaces::config: Verantwortlich für das Laden und Speichern der Workspace-Konfiguration.

Dieser Implementierungsleitfaden spezifiziert jedes dieser Module im Detail, einschließlich Datenstrukturen, APIs, Fehlerbehandlung und Implementierungsschritten, um eine direkte Umsetzung durch das Entwicklungsteam zu ermöglichen.

## **2\. Entwicklungsmodul 1: workspaces::core – Fundamentale Workspace-Definition**

Das Modul workspaces::core legt das Fundament für das Workspace-System, indem es die Kernentität Workspace sowie die damit verbundenen grundlegenden Datentypen und Fehlerdefinitionen bereitstellt.

### **2.1. Verantwortlichkeiten und Design-Rationale**

Dieses Modul ist ausschließlich dafür zuständig, die intrinsischen Eigenschaften und das Verhalten eines einzelnen, isolierten Workspace zu definieren. Es kapselt Attribute wie Name, ID, Layout-Typ und die Menge der zugeordneten Fensteridentifikatoren. Die Design-Entscheidung, diese Kernfunktionalität zu isolieren, stellt sicher, dass die grundlegende Definition eines Workspace unabhängig von komplexerer Verwaltungs- oder Zuweisungslogik bleibt, was die Wartbarkeit und Testbarkeit des Moduls verbessert. Es hat keine Kenntnis von anderen Workspaces oder dem Konzept eines "aktiven" Workspace.

### **2.2. Datentypen und Entitäten**

Die folgenden Rust-Datentypen sind für die Definition eines Workspace und seiner Attribute spezifiziert.

#### **2.2.1. Struct: Workspace**

Das Workspace-Struct repräsentiert einen einzelnen Arbeitsbereich.

* **Rust-Definition:**  
  Rust  
  // src/domain/workspaces/core/mod.rs  
  use std::collections::HashSet;  
  use uuid::Uuid;  
  use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType};  
  use crate::domain::workspaces::core::errors::WorkspaceCoreError;

  \#  
  pub struct Workspace {  
      id: WorkspaceId,  
      name: String,  
      persistent\_id: Option\<String\>, // Für Persistenz über Sitzungen hinweg  
      layout\_type: WorkspaceLayoutType,  
      window\_ids: HashSet\<WindowIdentifier\>, // IDs der Fenster auf diesem Workspace  
      created\_at: chrono::DateTime\<chrono::Utc\>, // Zeitstempel der Erstellung  
  }

* **Attribute und deren Bedeutung:**  
  * id: WorkspaceId: Ein eindeutiger Laufzeit-Identifikator für den Workspace, generiert bei der Erstellung (z.B. mittels uuid::Uuid::new\_v4()).  
  * name: String: Der vom Benutzer definierbare oder automatisch generierte Name des Workspace (z.B. "Arbeit", "Workspace 1").  
    * Invarianten: Darf nicht leer sein. Muss eine maximale Länge (z.B. 255 Zeichen) einhalten. Validierung erfolgt bei Erstellung und Umbenennung.  
  * persistent\_id: Option\<String\>: Eine optionale, eindeutige ID, die über Sitzungen hinweg stabil bleibt und zum Wiederherstellen von Workspaces verwendet wird. Kann vom Benutzer festgelegt oder automatisch generiert werden.  
    * Invarianten: Falls Some, darf der String nicht leer sein und sollte bestimmten Formatierungsregeln folgen (z.B. keine Sonderzeichen, um Dateisystem- oder Konfigurationsprobleme zu vermeiden).  
  * layout\_type: WorkspaceLayoutType: Definiert das aktuelle Layout-Verhalten für Fenster auf diesem Workspace (z.B. Floating, TilingHorizontal).  
  * window\_ids: HashSet\<WindowIdentifier\>: Eine Menge von eindeutigen Identifikatoren für Fenster, die aktuell diesem Workspace zugeordnet sind. Die Reihenfolge der Fenster ist hier nicht relevant; diese wird ggf. von der Systemschicht (Compositor) oder domain::window\_management verwaltet.  
  * created\_at: chrono::DateTime\<chrono::Utc\>: Der Zeitstempel der Erstellung des Workspace-Objekts.

#### **2.2.2. Struct: WindowIdentifier**

Ein Newtype für Fensteridentifikatoren zur Verbesserung der Typsicherheit.

* **Rust-Definition:**  
  Rust  
  // src/domain/workspaces/core/types.rs  
  \#  
  pub struct WindowIdentifier(String);

  impl WindowIdentifier {  
      pub fn new(id: String) \-\> Result\<Self, &'static str\> {  
          if id.is\_empty() {  
              Err("WindowIdentifier cannot be empty")  
          } else {  
              Ok(Self(id))  
          }  
      }

      pub fn as\_str(\&self) \-\> \&str {  
          \&self.0  
      }  
  }

  impl From\<String\> for WindowIdentifier {  
      fn from(s: String) \-\> Self {  
          // In einem realen Szenario könnte hier eine Validierung stattfinden oder  
          // es wird davon ausgegangen, dass der String bereits validiert ist.  
          // Für die einfache Konvertierung wird hier keine Validierung erzwungen,  
          // die \`new\` Methode ist für explizite Validierung vorgesehen.  
          Self(s)  
      }  
  }

  impl std::fmt::Display for WindowIdentifier {  
      fn fmt(\&self, f: \&mut std::fmt::Formatter\<'\_\>) \-\> std::fmt::Result {  
          write\!(f, "{}", self.0)  
      }  
  }

* **Verwendung:** Repräsentiert einen eindeutigen Identifikator für ein Fenster. Dieser Identifikator wird typischerweise von der Systemschicht (z.B. als Wayland Surface ID oder eine interne Anwendungs-ID) vergeben. Die Domänenschicht behandelt diesen Identifikator als einen opaken Wert, dessen genaues Format und Ursprung für die Logik innerhalb von domain::workspaces nicht von primärer Bedeutung sind, solange er Eindeutigkeit gewährleistet.  
* **Invarianten:** Der interne String darf nicht leer sein. Diese Invariante wird durch die new-Methode sichergestellt.

#### **2.2.3. Enum: WorkspaceLayoutType**

Definiert die möglichen Layout-Modi eines Workspace.

* **Rust-Definition:**  
  Rust  
  // src/domain/workspaces/core/types.rs  
  \#  
  pub enum WorkspaceLayoutType {  
      Floating,  
      TilingHorizontal,  
      TilingVertical,  
      Maximized, // Ein einzelnes Fenster ist maximiert, andere sind ggf. verborgen oder minimiert  
  }

  impl Default for WorkspaceLayoutType {  
      fn default() \-\> Self {  
          WorkspaceLayoutType::Floating  
      }  
  }

* **Verwendung:** Steuert, wie Fenster innerhalb des Workspace standardmäßig angeordnet oder verwaltet werden. Die konkrete Implementierung der Layout-Logik erfolgt in domain::window\_management und der Systemschicht, basierend auf diesem Typ.  
* **Standardwert:** Floating.

#### **2.2.4. Typalias: WorkspaceId**

Ein Typalias für die ID eines Workspace zur Verbesserung der Lesbarkeit und Konsistenz.

* **Rust-Definition:**  
  Rust  
  // src/domain/workspaces/core/types.rs  
  pub type WorkspaceId \= uuid::Uuid;

### **2.3. Öffentliche API: Methoden und Funktionen**

Alle hier definierten Methoden sind Teil der impl Workspace {... }.  
**Tabelle: API-Methoden für workspaces::core::Workspace**

| Methode (Rust-Signatur) | Kurzbeschreibung | Vorbedingungen | Nachbedingungen | Ausgelöste Events (indirekt) | Mögliche Fehler (WorkspaceCoreError) |
| :---- | :---- | :---- | :---- | :---- | :---- |
| pub fn new(name: String, persistent\_id: Option\<String\>) \-\> Result\<Self, WorkspaceCoreError\> | Erstellt einen neuen Workspace. | name darf nicht leer sein und muss die Längenbeschränkung einhalten. persistent\_id (falls Some) muss gültig sein. | Ein neues Workspace-Objekt wird mit einer eindeutigen id und created\_at Zeitstempel initialisiert. | \- | InvalidName, NameCannotBeEmpty, NameTooLong, InvalidPersistentId |
| pub fn id(\&self) \-\> WorkspaceId | Gibt die eindeutige Laufzeit-ID des Workspace zurück. | \- | \- | \- | \- |
| pub fn name(\&self) \-\> \&str | Gibt den aktuellen Namen des Workspace zurück. | \- | \- | \- | \- |
| pub fn rename(\&mut self, new\_name: String) \-\> Result\<(), WorkspaceCoreError\> | Benennt den Workspace um. | new\_name darf nicht leer sein und muss die Längenbeschränkung einhalten. | Der name des Workspace ist auf new\_name gesetzt. | WorkspaceRenamed (via manager) | InvalidName, NameCannotBeEmpty, NameTooLong |
| pub fn layout\_type(\&self) \-\> WorkspaceLayoutType | Gibt den aktuellen Layout-Typ des Workspace zurück. | \- | \- | \- | \- |
| pub fn set\_layout\_type(\&mut self, layout\_type: WorkspaceLayoutType) \-\> () | Setzt den Layout-Typ des Workspace. | \- | Der layout\_type des Workspace ist auf den übergebenen Wert gesetzt. | WorkspaceLayoutChanged (via manager) | \- |
| pub(crate) fn add\_window\_id(\&mut self, window\_id: WindowIdentifier) \-\> bool | Fügt eine Fenster-ID zur Menge der Fenster auf diesem Workspace hinzu. Intern verwendet vom assignment-Modul. | \- | window\_id ist in window\_ids enthalten. Gibt true zurück, wenn die ID neu hinzugefügt wurde, sonst false. | WindowAddedToWorkspace (via manager) | \- |
| pub(crate) fn remove\_window\_id(\&mut self, window\_id: \&WindowIdentifier) \-\> bool | Entfernt eine Fenster-ID aus der Menge der Fenster auf diesem Workspace. Intern verwendet vom assignment-Modul. | \- | window\_id ist nicht mehr in window\_ids enthalten. Gibt true zurück, wenn die ID entfernt wurde, sonst false. | WindowRemovedFromWorkspace (via manager) | \- |
| pub fn window\_ids(\&self) \-\> \&HashSet\<WindowIdentifier\> | Gibt eine unveränderliche Referenz auf die Menge der Fenster-IDs zurück. | \- | \- | \- | \- |
| pub fn persistent\_id(\&self) \-\> Option\<\&str\> | Gibt die optionale persistente ID des Workspace zurück. | \- | \- | \- | \- |
| pub fn set\_persistent\_id(\&mut self, pid: Option\<String\>) \-\> Result\<(), WorkspaceCoreError\> | Setzt oder entfernt die persistente ID des Workspace. | pid (falls Some) muss gültig sein. | Die persistent\_id des Workspace ist entsprechend gesetzt. | \- | InvalidPersistentId |
| pub fn created\_at(\&self) \-\> chrono::DateTime\<chrono::Utc\> | Gibt den Erstellungszeitstempel des Workspace zurück. | \- | \- | \- | \- |

Diese Tabelle definiert die exakte Schnittstelle für die Interaktion mit einem Workspace-Objekt. Die präzise Spezifikation von Signaturen, Vor- und Nachbedingungen sowie potenziellen Fehlern ist entscheidend für eine korrekte Implementierung und Nutzung durch andere Systemkomponenten.

### **2.4. Interner Zustand und Lebenszyklusmanagement**

Ein Workspace-Objekt wird typischerweise vom workspaces::manager-Modul erstellt und dessen Lebensdauer von diesem verwaltet. Es besitzt keinen komplexen internen Zustandsautomaten; sein Zustand wird vollständig durch seine Attribute (Felder des Structs) definiert. Änderungen am Zustand erfolgen durch Aufruf der in Abschnitt 2.3 definierten Methoden.

### **2.5. Events: Definition und Semantik (Event-Datenstrukturen)**

Das Modul workspaces::core definiert selbst keine Event-Enums und ist auch nicht für das Publizieren von Events zuständig. Es stellt jedoch die Datenstrukturen (Payloads) bereit, die von höherliegenden Modulen (insbesondere workspaces::manager) verwendet werden, um den Inhalt von Events zu definieren, die sich auf Änderungen an Workspace-Objekten beziehen.

* Beispielhafte Event-Datenstrukturen (Payloads):  
  Diese Strukturen werden im Untermodul event\_data definiert (src/domain/workspaces/core/event\_data.rs).  
  Rust  
  // src/domain/workspaces/core/event\_data.rs  
  use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType};

  \#  
  pub struct WorkspaceRenamedData {  
      pub id: WorkspaceId,  
      pub old\_name: String,  
      pub new\_name: String,  
  }

  \#  
  pub struct WorkspaceLayoutChangedData {  
      pub id: WorkspaceId,  
      pub old\_layout: WorkspaceLayoutType,  
      pub new\_layout: WorkspaceLayoutType,  
  }

  \#  
  pub struct WindowAddedToWorkspaceData {  
      pub workspace\_id: WorkspaceId,  
      pub window\_id: WindowIdentifier,  
  }

  \#  
  pub struct WindowRemovedFromWorkspaceData {  
      pub workspace\_id: WorkspaceId,  
      pub window\_id: WindowIdentifier,  
  }

  \#  
  pub struct WorkspacePersistentIdChangedData {  
      pub id: WorkspaceId,  
      pub old\_persistent\_id: Option\<String\>,  
      pub new\_persistent\_id: Option\<String\>,  
  }

  Die eigentlichen Event-Enums (z.B. WorkspaceEvent), die diese Datenstrukturen verwenden, werden im workspaces::manager-Modul definiert.

### **2.6. Fehlerbehandlung: WorkspaceCoreError**

Für die Fehlerbehandlung innerhalb des workspaces::core-Moduls wird ein spezifisches Error-Enum WorkspaceCoreError definiert. Dieses Enum nutzt das thiserror-Crate, um die Erstellung idiomatischer Fehlertypen zu vereinfachen, wie in Richtlinie 4.3 der Gesamtspezifikation und basierend auf etablierten Praktiken 1 empfohlen.

* **Definition:**  
  Rust  
  // src/domain/workspaces/core/errors.rs  
  use thiserror::Error;  
  use crate::core::errors::ValidationError; // Annahme: Ein allgemeiner Validierungsfehler aus der Kernschicht

  pub const MAX\_WORKSPACE\_NAME\_LENGTH: usize \= 64; // Beispielhafte Maximallänge

  \#  
  pub enum WorkspaceCoreError {  
      \#  
      InvalidName(String), // Enthält den ungültigen Namen

      \#\[error("Workspace name cannot be empty.")\]  
      NameCannotBeEmpty,

      \#\[error("Workspace name exceeds maximum length of {max\_len} characters: '{name}' is {actual\_len} characters long.")\]  
      NameTooLong { name: String, max\_len: usize, actual\_len: usize },

      \#  
      InvalidPersistentId(String), // Enthält die ungültige ID

      \#\[error("A core validation rule was violated: {0}")\]  
      ValidationError(\#\[from\] ValidationError), // Ermöglicht das Wrapping von Fehlern aus der Kernschicht

      \#\[error("An internal error occurred in workspace core logic: {context}")\]  
      Internal { context: String }, // Für unerwartete interne Fehlerzustände  
  }

* Erläuterung und Anwendung von Fehlerbehandlungsprinzipien:  
  Die Gestaltung von WorkspaceCoreError folgt mehreren wichtigen Prinzipien der Fehlerbehandlung in Rust:  
  1. **Spezifität und Kontext:** Jede Variante des Enums repräsentiert einen klar definierten Fehlerfall, der innerhalb des workspaces::core-Moduls auftreten kann. Varianten wie InvalidName(String) und NameTooLong { name, max\_len, actual\_len } enthalten die problematischen Werte oder relevanten Kontextinformationen direkt im Fehlertyp. Dies ist entscheidend, um das Problem des "Context Blurring" zu vermeiden, bei dem ein generischer Fehlertyp nicht genügend Informationen über die Fehlerursache liefert.1 Durch die Aufnahme dieser Daten kann der aufrufende Code nicht nur den Fehlertyp programmatisch behandeln, sondern auch detaillierte Fehlermeldungen für Benutzer oder Entwickler generieren.  
  2. **thiserror für Ergonomie:** Die Verwendung von \#\[derive(Error)\] und dem \#\[error("...")\]-Attribut von thiserror reduziert Boilerplate-Code erheblich und stellt sicher, dass das std::error::Error-Trait korrekt implementiert wird, inklusive einer sinnvollen Display-Implementierung.1  
  3. **Fehler-Wrapping mit \#\[from\]:** Die Variante ValidationError(\#\[from\] ValidationError) demonstriert die Nutzung von \#\[from\]. Dies ermöglicht die automatische Konvertierung eines ValidationError (aus crate::core::errors) in einen WorkspaceCoreError mittels des ?-Operators. Entscheidend ist hierbei, dass die source()-Methode des Error-Traits automatisch so implementiert wird, dass der ursprüngliche ValidationError als Ursache des WorkspaceCoreError zugänglich bleibt.3 Dies ist für die Fehlerdiagnose über Modulgrenzen hinweg unerlässlich.  
  4. **Vermeidung von Panics:** Die API-Methoden von Workspace geben Result\<\_, WorkspaceCoreError\> zurück. Dies stellt sicher, dass vorhersehbare Fehlerzustände (z.B. ungültige Eingaben) explizit behandelt und nicht durch panic\! abgebrochen werden, was für Bibliotheks- und Domänencode als Best Practice gilt.4  
  5. **Klare Fehlernachrichten:** Die \#\[error("...")\]-Nachrichten sind primär für Entwickler konzipiert (z.B. für Logging und Debugging). Sie sind präzise und beschreiben das technische Problem. Die Benutzeroberflächenschicht ist dafür verantwortlich, diese technischen Fehler gegebenenfalls in benutzerfreundlichere Meldungen zu übersetzen.

Ein wichtiger Aspekt bei der Fehlerdefinition ist die Balance zwischen der Anzahl der Fehlervarianten und der Notwendigkeit, spezifische Informationen für die Fehlerbehandlung bereitzustellen. Wenn ein generischer Fehler wie ValidationError aus einer tieferen Schicht stammt, ist es oft nicht ausreichend, ihn einfach nur zu wrappen. Wenn der Kontext, *welche* spezifische Validierung innerhalb von workspaces::core fehlgeschlagen ist, für den Aufrufer relevant ist, sollte eine spezifischere Variante in WorkspaceCoreError in Betracht gezogen werden. Alternativ kann die Internal { context: String }-Variante genutzt werden, wobei context die fehlgeschlagene Operation detailliert beschreibt. Entwickler müssen beim Mappen von Fehlern (z.B. mittels map\_err) darauf achten, präzise Kontextinformationen hinzuzufügen, falls \#\[from\] allein nicht genügend semantische Information transportiert.  
**Tabelle: WorkspaceCoreError Varianten**

| Variante | \#\[error("...")\]-Meldung (Auszug) | Semantische Bedeutung/Ursache | Enthaltene Datenfelder | Mögliche Quellfehler (source()) |
| :---- | :---- | :---- | :---- | :---- |
| InvalidName(String) | "Invalid workspace name: {0}..." | Der angegebene Workspace-Name ist ungültig (z.B. aufgrund von Formatierungsregeln, die über Leerstring/Länge hinausgehen). | Der ungültige Name (String). | \- |
| NameCannotBeEmpty | "Workspace name cannot be empty." | Es wurde versucht, einen Workspace mit einem leeren Namen zu erstellen oder einen bestehenden Workspace in einen leeren Namen umzubenennen. | \- | \- |
| NameTooLong | "Workspace name exceeds maximum length..." | Der angegebene Name überschreitet die definierte Maximallänge. | name: String, max\_len: usize, actual\_len: usize. | \- |
| InvalidPersistentId(String) | "Persistent ID is invalid: {0}..." | Die angegebene persistente ID ist ungültig (z.B. leer oder falsches Format). | Die ungültige ID (String). | \- |
| ValidationError(\#\[from\] ValidationError) | "A core validation rule was violated: {0}" | Eine allgemeine Validierungsregel aus der Kernschicht wurde verletzt. | Der ursprüngliche ValidationError. | ValidationError |
| Internal { context: String } | "An internal error occurred..." | Ein unerwarteter Fehler oder eine nicht behandelte Bedingung innerhalb der Modullogik. | context: String (Beschreibung des internen Fehlers). | Variiert |

Diese Tabelle dient Entwicklern als Referenz, um die möglichen Fehlerursachen im workspaces::core-Modul zu verstehen und eine robuste Fehlerbehandlung in aufrufenden Modulen zu implementieren.

### **2.7. Detaillierte Implementierungsschritte und Dateistruktur**

* **Dateistruktur innerhalb von src/domain/workspaces/core/:**  
  * mod.rs: Enthält die Definition des Workspace-Structs und die Implementierung seiner Methoden (impl Workspace). Exportiert öffentliche Typen und Module.  
  * types.rs: Beinhaltet die Definitionen von WorkspaceId, WindowIdentifier und WorkspaceLayoutType.  
  * errors.rs: Enthält die Definition des WorkspaceCoreError-Enums und zugehörige Konstanten wie MAX\_WORKSPACE\_NAME\_LENGTH.  
  * event\_data.rs: Enthält die Definitionen der Event-Payload-Strukturen (z.B. WorkspaceRenamedData).  
* **Implementierungsschritte:**  
  1. Definiere die Typen WorkspaceId, WindowIdentifier (inkl. new, as\_str, From\<String\>, Display) und WorkspaceLayoutType (inkl. Default) in types.rs.  
  2. Definiere das WorkspaceCoreError-Enum in errors.rs gemäß der Spezifikation in Abschnitt 2.6. Implementiere die Konstante MAX\_WORKSPACE\_NAME\_LENGTH.  
  3. Definiere die Event-Payload-Strukturen (z.B. WorkspaceRenamedData, WorkspaceLayoutChangedData, etc.) in event\_data.rs.  
  4. Implementiere das Workspace-Struct in mod.rs mit allen Attributen wie in Abschnitt 2.2.1 spezifiziert.  
  5. Implementiere die Methode pub fn new(name: String, persistent\_id: Option\<String\>) \-\> Result\<Self, WorkspaceCoreError\>:  
     * Validiere name: Prüfe auf Leerstring (Fehler: NameCannotBeEmpty) und Überschreitung von MAX\_WORKSPACE\_NAME\_LENGTH (Fehler: NameTooLong). Ggf. weitere Validierungen für InvalidName.  
     * Validiere persistent\_id (falls Some): Prüfe auf Leerstring und ggf. Format (Fehler: InvalidPersistentId).  
     * Initialisiere id mit Uuid::new\_v4().  
     * Initialisiere created\_at mit chrono::Utc::now().  
     * Initialisiere window\_ids als leeres HashSet.  
     * Initialisiere layout\_type mit WorkspaceLayoutType::default().  
     * Gib bei Erfolg Ok(Self {... }) zurück.  
  6. Implementiere alle Getter-Methoden (id(), name(), layout\_type(), window\_ids(), persistent\_id(), created\_at()) als einfache Rückgaben der entsprechenden Felder.  
  7. Implementiere pub fn rename(\&mut self, new\_name: String) \-\> Result\<(), WorkspaceCoreError\>:  
     * Validiere new\_name analog zur new()-Methode.  
     * Bei Erfolg: self.name \= new\_name; Ok(()).  
  8. Implementiere pub fn set\_layout\_type(\&mut self, layout\_type: WorkspaceLayoutType) \-\> (): self.layout\_type \= layout\_type;.  
  9. Implementiere pub fn set\_persistent\_id(\&mut self, pid: Option\<String\>) \-\> Result\<(), WorkspaceCoreError\>:  
     * Validiere pid (falls Some) analog zur new()-Methode.  
     * Bei Erfolg: self.persistent\_id \= pid; Ok(()).  
  10. Implementiere die pub(crate) Methoden add\_window\_id(\&mut self, window\_id: WindowIdentifier) \-\> bool und remove\_window\_id(\&mut self, window\_id: \&WindowIdentifier) \-\> bool unter Verwendung der entsprechenden HashSet-Methoden (insert bzw. remove) und gib deren booleschen Rückgabewert zurück.  
  11. Stelle sicher, dass alle öffentlichen Typen, Methoden und Felder (falls öffentlich) umfassend mit rustdoc-Kommentaren dokumentiert sind. Die Kommentare müssen Vor- und Nachbedingungen, ausgelöste Fehler (mit Verweis auf die WorkspaceCoreError-Varianten) und ggf. Code-Beispiele enthalten, gemäß Richtlinie 4.7 der Gesamtspezifikation.  
  12. Erstelle Unit-Tests im Untermodul tests (d.h. \#\[cfg(test)\] mod tests {... }) innerhalb von mod.rs. Teste jede Methode gründlich, insbesondere:  
      * Erfolgreiche Erstellung von Workspace-Objekten.  
      * Fehlerfälle bei der Erstellung (ungültige Namen, ungültige persistente IDs).  
      * Erfolgreiche Umbenennung und Fehlerfälle dabei.  
      * Setzen und Abrufen des Layout-Typs.  
      * Setzen und Abrufen der persistenten ID und Fehlerfälle dabei.  
      * Hinzufügen und Entfernen von Fenster-IDs, inklusive Überprüfung der Rückgabewerte und des Zustands von window\_ids.  
      * Überprüfung der Invarianten (z.B. dass id und created\_at korrekt initialisiert werden).

## **3\. Entwicklungsmodul 2: workspaces::assignment – Logik zur Fensterzuweisung**

Das Modul workspaces::assignment ist für die spezifische Geschäftslogik zuständig, die das Zuweisen von Fenstern zu Workspaces und das Entfernen von Fenstern aus Workspaces regelt.

### **3.1. Verantwortlichkeiten und Design-Rationale**

Die Hauptverantwortung dieses Moduls liegt in der Implementierung der Regeln und Operationen, die steuern, wie Fenster (repräsentiert durch WindowIdentifier) Workspaces zugeordnet werden. Dies beinhaltet die Durchsetzung von Regeln wie "ein Fenster darf nur einem Workspace gleichzeitig zugewiesen sein" (falls diese Regel gilt). Das Modul agiert als Dienstleister für den workspaces::manager, der die übergeordnete Workspace-Sammlung hält.  
Die Auslagerung dieser Logik in ein eigenes Modul dient mehreren Zwecken:

* **Trennung der Belange (Separation of Concerns):** Das workspaces::core-Modul bleibt fokussiert auf die Definition eines einzelnen Workspace, während workspaces::manager sich um die Verwaltung der Sammlung und Lebenszyklen kümmert. workspaces::assignment spezialisiert sich auf die Interaktionslogik zwischen Fenstern und Workspaces.  
* **Komplexitätsmanagement:** Regeln für Fensterzuweisungen können komplex werden (z.B. automatische Zuweisung basierend auf Fenstertyp, Anwendungsregeln). Ein dediziertes Modul erleichtert die Handhabung dieser Komplexität.  
* **Testbarkeit:** Die Zuweisungslogik kann isoliert getestet werden.

Dieses Modul interagiert eng mit workspaces::core (um Fenster-IDs in einem Workspace-Objekt zu modifizieren) und wird typischerweise vom workspaces::manager aufgerufen.

### **3.2. Datenstrukturen und Interaktionen**

Dieses Modul operiert primär mit Workspace-Instanzen (aus workspaces::core) und WindowIdentifier-Typen. Es führt selbst keine persistenten Datenstrukturen ein, sondern modifiziert die ihm übergebenen Workspace-Objekte. Für seine Operationen benötigt es Zugriff auf die Sammlung aller relevanten Workspaces, die typischerweise vom workspaces::manager als HashMap\<WorkspaceId, Workspace\> bereitgestellt wird.  
Spezifische temporäre Datenstrukturen könnten hier definiert werden, falls komplexe Zuweisungsalgorithmen (z.B. für automatische Platzierung in Tiling-Layouts) implementiert werden müssten. Für die grundlegende Zuweisung eines Fensters zu einem bestimmten Workspace sind solche Strukturen jedoch in der Regel nicht erforderlich. Die Logik für Layout-spezifische Platzierung ist eher im Modul domain::window\_management angesiedelt.

### **3.3. Öffentliche API: Methoden und Funktionen**

Die Funktionalität dieses Moduls wird durch freistehende Funktionen bereitgestellt, die auf einer veränderbaren Sammlung von Workspaces operieren. Diese Funktionen befinden sich im Modul domain::workspaces::assignment.  
**Tabelle: API-Funktionen für workspaces::assignment**

| Funktion (Rust-Signatur) | Kurzbeschreibung | Vorbedingungen | Nachbedingungen | Ausgelöste Events (indirekt) | Mögliche Fehler (WindowAssignmentError) |
| :---- | :---- | :---- | :---- | :---- | :---- |
| pub fn assign\_window\_to\_workspace(workspaces: \&mut std::collections::HashMap\<WorkspaceId, Workspace\>, target\_workspace\_id: WorkspaceId, window\_id: \&WindowIdentifier, ensure\_unique\_assignment: bool) \-\> Result\<(), WindowAssignmentError\> | Weist ein Fenster einem spezifischen Workspace zu. | target\_workspace\_id muss als Schlüssel in workspaces existieren. | Das Fenster window\_id ist dem Workspace target\_workspace\_id zugeordnet. Falls ensure\_unique\_assignment true ist, wird das Fenster von allen anderen Workspaces in der workspaces-Sammlung entfernt. | WindowAddedToWorkspace, WindowRemovedFromWorkspace (via manager) | WorkspaceNotFound (für target\_workspace\_id), WindowAlreadyAssigned (falls bereits auf Ziel-WS und ensure\_unique\_assignment ist false oder irrelevant), RuleViolation |
| pub fn remove\_window\_from\_workspace(workspaces: \&mut std::collections::HashMap\<WorkspaceId, Workspace\>, source\_workspace\_id: WorkspaceId, window\_id: \&WindowIdentifier) \-\> Result\<bool, WindowAssignmentError\> | Entfernt ein Fenster von einem spezifischen Workspace. | source\_workspace\_id muss als Schlüssel in workspaces existieren. | Das Fenster window\_id ist nicht mehr dem Workspace source\_workspace\_id zugeordnet. Gibt true zurück, wenn das Fenster entfernt wurde, false wenn es nicht auf dem Workspace war. | WindowRemovedFromWorkspace (via manager) | WorkspaceNotFound (für source\_workspace\_id) |
| pub fn move\_window\_to\_workspace(workspaces: \&mut std::collections::HashMap\<WorkspaceId, Workspace\>, source\_workspace\_id: WorkspaceId, target\_workspace\_id: WorkspaceId, window\_id: \&WindowIdentifier) \-\> Result\<(), WindowAssignmentError\> | Verschiebt ein Fenster von einem Quell-Workspace zu einem Ziel-Workspace. | source\_workspace\_id und target\_workspace\_id müssen in workspaces existieren. window\_id muss dem source\_workspace\_id zugeordnet sein. source\_workspace\_id und target\_workspace\_id dürfen nicht identisch sein. | Das Fenster window\_id ist vom source\_workspace\_id entfernt und dem target\_workspace\_id hinzugefügt. Andere Workspaces bleiben unberührt (d.h. es wird nicht implizit von einem dritten Workspace entfernt, falls es dort auch war, es sei denn, die interne Logik von assign\_window\_to\_workspace mit ensure\_unique\_assignment=true wird genutzt). | WindowRemovedFromWorkspace, WindowAddedToWorkspace (via manager) | SourceWorkspaceNotFound, TargetWorkspaceNotFound, WindowNotOnSourceWorkspace, CannotMoveToSameWorkspace, RuleViolation |
| pub fn find\_workspace\_for\_window(workspaces: \&std::collections::HashMap\<WorkspaceId, Workspace\>, window\_id: \&WindowIdentifier) \-\> Option\<WorkspaceId\> | Findet die ID des Workspace, dem ein bestimmtes Fenster aktuell zugeordnet ist. | \- | Gibt Some(WorkspaceId) zurück, wenn das Fenster einem Workspace in der Sammlung zugeordnet ist, sonst None. | \- | \- |

Die explizite Übergabe der workspaces-Sammlung an jede Funktion unterstreicht die Rolle dieses Moduls als Dienstleister, der auf Daten operiert, die vom workspaces::manager gehalten und verwaltet werden. Der Parameter ensure\_unique\_assignment in assign\_window\_to\_workspace ermöglicht es dem Aufrufer (typischerweise dem manager), die globale Regel "ein Fenster nur auf einem Workspace" durchzusetzen.

### **3.4. Events: Definition und Semantik**

Das Modul workspaces::assignment löst selbst keine Events aus. Änderungen an den Workspace-Objekten (Hinzufügen oder Entfernen von window\_ids) werden direkt auf diesen Objekten vorgenommen. Der workspaces::manager, der die Funktionen dieses Moduls aufruft, ist dafür verantwortlich, die entsprechenden Events zu publizieren (z.B. WindowAddedToWorkspace oder WindowRemovedFromWorkspace, unter Verwendung der in workspaces::core::event\_data definierten Payload-Strukturen). Diese Entkopplung hält das assignment-Modul fokussiert auf seine Kernlogik.

### **3.5. Fehlerbehandlung: WindowAssignmentError**

Für Fehler, die spezifisch bei Fensterzuweisungsoperationen auftreten, wird das WindowAssignmentError-Enum definiert.

* **Definition:**  
  Rust  
  // src/domain/workspaces/assignment/errors.rs  
  use thiserror::Error;  
  use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier};

  \#  
  pub enum WindowAssignmentError {  
      \#  
      WorkspaceNotFound(WorkspaceId), // Gilt für Ziel- oder Quell-Workspaces, je nach Kontext

      \#\[error("Window '{window\_id}' is already assigned to workspace '{workspace\_id}'. No action taken.")\]  
      WindowAlreadyAssigned { workspace\_id: WorkspaceId, window\_id: WindowIdentifier },

      \#\[error("Window '{window\_id}' is not assigned to workspace '{workspace\_id}', so it cannot be removed from it.")\]  
      WindowNotAssigned { workspace\_id: WorkspaceId, window\_id: WindowIdentifier }, // Spezifischer für Entfernungsoperationen

      \#  
      SourceWorkspaceNotFound(WorkspaceId),

      \#  
      TargetWorkspaceNotFound(WorkspaceId),

      \#\[error("Window '{window\_id}' not found on source workspace '{workspace\_id}' and thus cannot be moved.")\]  
      WindowNotOnSourceWorkspace { workspace\_id: WorkspaceId, window\_id: WindowIdentifier },

      \#\[error("Cannot move window '{window\_id}' from workspace '{workspace\_id}' to itself.")\]  
      CannotMoveToSameWorkspace { workspace\_id: WorkspaceId, window\_id: WindowIdentifier },

      \#  
      RuleViolation {  
          reason: String,  
          window\_id: Option\<WindowIdentifier\>,  
          target\_workspace\_id: Option\<WorkspaceId\>,  
      }, // Für spezifische, nicht abgedeckte Regeln

      \#\[error("An internal error occurred in window assignment logic: {context}")\]  
      Internal { context: String },  
  }

* Erläuterung und Anwendung von Fehlerbehandlungsprinzipien:  
  Die Definition von WindowAssignmentError folgt denselben Prinzipien wie WorkspaceCoreError unter Verwendung von thiserror.1 Die Varianten sind spezifisch für Zuweisungsoperationen und beinhalten relevante Identifikatoren, um den Kontext des Fehlers klar zu machen.1  
  Ein wichtiger Aspekt ist die Behandlung von Geschäftsregeln. Die Variante RuleViolation { reason,... } dient als flexibler Mechanismus, um Verletzungen von Zuweisungsregeln zu signalisieren, die nicht durch spezifischere Fehlervarianten abgedeckt sind. Es ist jedoch zu bedenken, dass eine programmatische Reaktion auf einen Fehler, der nur einen allgemeinen reason: String enthält, schwierig ist. Daher gilt: Für klar definierte, häufig auftretende oder kritische Geschäftsregeln der Fensterzuweisung *sollten* spezifische Fehlervarianten erstellt werden. Beispielsweise, wenn eine Regel besagt, dass bestimmte Fenstertypen nicht auf bestimmten Workspaces platziert werden dürfen, wäre ein Fehler wie DisallowedWindowTypeForWorkspace { window\_type: String, workspace\_id: WorkspaceId } aussagekräftiger als eine generische RuleViolation. Die RuleViolation-Variante dient dann als Fallback für dynamischere oder weniger häufige Regeln. Die Spezifikation sollte die wichtigsten Zuweisungsregeln identifizieren und dafür sorgen, dass dedizierte Fehler definiert werden, falls eine spezifische programmatische Behandlung durch den Aufrufer erforderlich ist. Dies steht im Einklang mit der Diskussion über die Granularität von Fehlertypen.2

**Tabelle: WindowAssignmentError Varianten**

| Variante | \#\[error("...")\]-Meldung (Auszug) | Semantische Bedeutung/Ursache | Enthaltene Datenfelder |
| :---- | :---- | :---- | :---- |
| WorkspaceNotFound(WorkspaceId) | "Workspace with ID '{0}' not found." | Ein angegebener Workspace (Quelle oder Ziel) existiert nicht in der übergebenen Sammlung. | Die ID des nicht gefundenen Workspace (WorkspaceId). |
| WindowAlreadyAssigned | "Window '{window\_id}' is already assigned..." | Es wurde versucht, ein Fenster einem Workspace zuzuweisen, dem es bereits zugeordnet ist (und keine weitere Aktion ist nötig/erwünscht). | workspace\_id: WorkspaceId, window\_id: WindowIdentifier. |
| WindowNotAssigned | "Window '{window\_id}' is not assigned..." | Es wurde versucht, ein Fenster von einem Workspace zu entfernen, dem es nicht zugeordnet ist. | workspace\_id: WorkspaceId, window\_id: WindowIdentifier. |
| SourceWorkspaceNotFound(WorkspaceId) | "Source workspace with ID '{0}' not found..." | Der Quell-Workspace für eine Verschiebungsoperation wurde nicht gefunden. | Die ID des Quell-Workspace (WorkspaceId). |
| TargetWorkspaceNotFound(WorkspaceId) | "Target workspace with ID '{0}' not found..." | Der Ziel-Workspace für eine Verschiebungsoperation wurde nicht gefunden. | Die ID des Ziel-Workspace (WorkspaceId). |
| WindowNotOnSourceWorkspace | "Window '{window\_id}' not found on source..." | Das zu verschiebende Fenster befindet sich nicht auf dem angegebenen Quell-Workspace. | workspace\_id: WorkspaceId, window\_id: WindowIdentifier. |
| CannotMoveToSameWorkspace | "Cannot move window... to itself." | Es wurde versucht, ein Fenster auf denselben Workspace zu verschieben, auf dem es sich bereits befindet. | workspace\_id: WorkspaceId, window\_id: WindowIdentifier. |
| RuleViolation | "A window assignment rule was violated: {reason}..." | Eine spezifische Geschäftsregel der Fensterzuweisung wurde verletzt. | reason: String, window\_id: Option\<WindowIdentifier\>, target\_workspace\_id: Option\<WorkspaceId\>. |
| Internal { context: String } | "An internal error occurred..." | Ein unerwarteter Fehler in der Zuweisungslogik. | context: String. |

### **3.6. Detaillierte Implementierungsschritte und Dateistruktur**

* **Dateistruktur innerhalb von src/domain/workspaces/assignment/:**  
  * mod.rs: Enthält die Implementierung der öffentlichen Zuweisungsfunktionen (assign\_window\_to\_workspace, remove\_window\_from\_workspace, move\_window\_to\_workspace, find\_workspace\_for\_window).  
  * errors.rs: Enthält die Definition des WindowAssignmentError-Enums.  
  * rules.rs (optional): Dieses Modul könnte interne Hilfsfunktionen oder Datenstrukturen enthalten, die spezifische Zuweisungsregeln kapseln (z.B. Überprüfung der "Fenster-Exklusivität"). Diese würden dann von den Hauptfunktionen in mod.rs genutzt.  
* **Implementierungsschritte:**  
  1. Definiere das WindowAssignmentError-Enum in errors.rs gemäß der Spezifikation in Abschnitt 3.5.  
  2. Implementiere pub fn assign\_window\_to\_workspace(...) in mod.rs:  
     * Überprüfe, ob target\_workspace\_id in workspaces existiert. Falls nicht, gib Err(WindowAssignmentError::WorkspaceNotFound(target\_workspace\_id)) zurück.  
     * Hole eine veränderbare Referenz auf den target\_workspace.  
     * Falls ensure\_unique\_assignment true ist:  
       * Iteriere über alle Workspaces in der workspaces-Sammlung (außer dem target\_workspace).  
       * Wenn ein anderer Workspace das window\_id enthält, rufe dessen remove\_window\_id(window\_id) Methode auf.  
     * Rufe target\_workspace.add\_window\_id(window\_id.clone()) auf. Wenn diese false zurückgibt (Fenster war bereits vorhanden), und dies als Fehlerfall betrachtet wird (abhängig von der genauen Semantik/Regeln), gib Err(WindowAssignmentError::WindowAlreadyAssigned {... }) zurück.  
     * Gib Ok(()) zurück.  
  3. Implementiere pub fn remove\_window\_from\_workspace(...) in mod.rs:  
     * Überprüfe, ob source\_workspace\_id in workspaces existiert. Falls nicht, gib Err(WindowAssignmentError::WorkspaceNotFound(source\_workspace\_id)) zurück.  
     * Hole eine veränderbare Referenz auf den source\_workspace.  
     * Rufe source\_workspace.remove\_window\_id(window\_id) auf und gib Ok(result) zurück. (Der Fehlerfall WindowNotAssigned wird hier nicht direkt von dieser Funktion erzeugt, da Workspace::remove\_window\_id nur bool zurückgibt. Der manager könnte dies interpretieren oder es wird angenommen, dass ein Aufruf zum Entfernen eines nicht vorhandenen Fensters kein Fehler ist, sondern einfach keine Aktion bewirkt und false zurückgibt). Alternativ könnte hier geprüft werden, ob das Fenster vorher drin war und bei false ein WindowNotAssigned Fehler erzeugt werden, falls das die gewünschte Semantik ist. Gemäß der Tabelle soll remove\_window\_from\_workspace Result\<bool,...\> zurückgeben, also ist die aktuelle Signatur von Workspace::remove\_window\_id ausreichend.  
  4. Implementiere pub fn move\_window\_to\_workspace(...) in mod.rs:  
     * Überprüfe, ob source\_workspace\_id und target\_workspace\_id identisch sind. Falls ja, gib Err(WindowAssignmentError::CannotMoveToSameWorkspace {... }) zurück.  
     * Überprüfe Existenz von source\_workspace (Fehler: SourceWorkspaceNotFound) und target\_workspace (Fehler: TargetWorkspaceNotFound).  
     * Hole Referenzen zu beiden Workspaces.  
     * Versuche, window\_id vom source\_workspace zu entfernen. Rufe source\_workspace.remove\_window\_id(window\_id) auf. Wenn dies false zurückgibt (Fenster war nicht auf Quelle), gib Err(WindowAssignmentError::WindowNotOnSourceWorkspace {... }) zurück.  
     * Füge window\_id zum target\_workspace hinzu. Rufe target\_workspace.add\_window\_id(window\_id.clone()) auf. (Die ensure\_unique\_assignment-Logik ist hier nicht direkt anwendbar, da wir explizit von einer Quelle zu einem Ziel verschieben. Es wird angenommen, dass das Fenster nach dem Entfernen von der Quelle nur noch dem Ziel hinzugefügt werden muss.)  
     * Gib Ok(()) zurück.  
  5. Implementiere pub fn find\_workspace\_for\_window(...) in mod.rs:  
     * Iteriere über die workspaces-Sammlung.  
     * Für jeden Workspace, prüfe, ob dessen window\_ids das gesuchte window\_id enthält.  
     * Wenn gefunden, gib Some(workspace.id()) zurück.  
     * Wenn die Iteration ohne Fund endet, gib None zurück.  
  6. Füge umfassende rustdoc-Kommentare für alle öffentlichen Funktionen hinzu.  
  7. Erstelle Unit-Tests im Untermodul tests in mod.rs. Teste alle Funktionen gründlich, einschließlich:  
     * Erfolgreiche Zuweisung, Entfernung und Verschiebung von Fenstern.  
     * Korrekte Handhabung der ensure\_unique\_assignment-Logik.  
     * Alle Fehlerfälle (nicht gefundene Workspaces, Fenster nicht auf Quell-Workspace, etc.).  
     * Randbedingungen (z.B. leere workspaces-Sammlung).  
     * Funktionalität von find\_workspace\_for\_window.

## **4\. Entwicklungsmodul 3: workspaces::manager – Orchestrierung und übergeordnete Verwaltung**

Das Modul workspaces::manager agiert als zentraler Orchestrator für alle Workspace-bezogenen Operationen. Es verwaltet die Gesamtheit der Workspaces, den Zustand des aktiven Workspace und dient als primäre Schnittstelle für andere Systemteile.

### **4.1. Verantwortlichkeiten und Design-Rationale**

Die Kernverantwortlichkeiten des WorkspaceManager sind:

* **Verwaltung der Workspace-Sammlung:** Halten und Pflegen einer Liste aller existierenden Workspace-Instanzen.  
* **Lebenszyklusmanagement:** Erstellung, Löschung und Modifikation von Workspaces.  
* **Zustandsmanagement des aktiven Workspace:** Verfolgen, welcher Workspace aktuell aktiv ist, und Ermöglichen des Wechsels.  
* **Orchestrierung von Operationen:** Koordination von Aktionen, die mehrere Workspaces betreffen oder globale Auswirkungen haben.  
* **Event-Publikation:** Benachrichtigung anderer Systemteile über signifikante Änderungen im Workspace-System (z.B. Erstellung, Löschung, Aktivierung eines Workspace, Fensterzuweisungen).  
* **Schnittstelle:** Bereitstellung einer kohärenten API für die System- und UI-Schicht zur Interaktion mit dem Workspace-System.

Das Design zielt darauf ab, die Komplexität der Workspace-Verwaltung an einem zentralen Ort zu bündeln. Dies fördert die Konsistenz des Gesamtzustands und vereinfacht die Interaktion für andere Komponenten, da sie nur mit dem WorkspaceManager und nicht mit einzelnen Workspace-Objekten oder dem assignment-Modul direkt kommunizieren müssen.

### **4.2. Interaktion mit anderen Modulen und externen Schnittstellen**

Der WorkspaceManager interagiert mit mehreren anderen Modulen:

* **workspaces::core:** Erstellt und hält Instanzen von Workspace-Objekten. Ruft Methoden auf diesen Objekten auf (z.B. rename, set\_layout\_type).  
* **workspaces::assignment:** Nutzt die Funktionen dieses Moduls (z.B. assign\_window\_to\_workspace) zur Durchführung der Logik für Fensterzuweisungen.  
* **workspaces::config:** Interagiert mit einem WorkspaceConfigProvider (aus workspaces::config), um die Workspace-Konfiguration beim Start zu laden und Änderungen zu persistieren.  
* **Event-System (nicht spezifiziert, aber implizit):** Benötigt einen Mechanismus zum Publizieren von WorkspaceEvents. Dies könnte ein interner Event-Bus, ein tokio::sync::broadcast Channel oder eine ähnliche Struktur sein. Für diese Spezifikation wird angenommen, dass ein solcher Mechanismus existiert und vom WorkspaceManager genutzt werden kann.  
* **Systemschicht:** Wird vom WorkspaceManager über Änderungen informiert (z.B. welcher Workspace aktiv ist, welche Fenster wo sind) und informiert den WorkspaceManager über Systemereignisse (z.B. neue Fenster).  
* **UI-Schicht:** Nutzt die API des WorkspaceManager zur Darstellung und Manipulation von Workspaces und reagiert auf WorkspaceEvents.

### **4.3. Öffentliche API: Methoden und Funktionen**

Die öffentliche API wird durch das WorkspaceManager-Struct und dessen Methoden bereitgestellt.

* **Struct-Definition:**  
  Rust  
  // src/domain/workspaces/manager/mod.rs  
  use std::collections::HashMap;  
  use std::sync::Arc;  
  use uuid::Uuid;  
  use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType};  
  use crate::domain::workspaces::core::Workspace;  
  use crate::domain::workspaces::core::event\_data::\*;  
  use crate::domain::workspaces::assignment;  
  use crate::domain::workspaces::config::{WorkspaceConfigProvider, WorkspaceSetSnapshot, WorkspaceSnapshot};  
  use crate::domain::workspaces::manager::errors::WorkspaceManagerError;  
  use crate::domain::workspaces::manager::events::WorkspaceEvent; // Und Event-Publisher

  // Annahme: Ein Event-Publisher Trait oder eine konkrete Implementierung  
  pub trait EventPublisher\<E\>: Send \+ Sync {  
      fn publish(\&self, event: E);  
  }

  pub struct WorkspaceManager {  
      workspaces: HashMap\<WorkspaceId, Workspace\>,  
      active\_workspace\_id: Option\<WorkspaceId\>,  
      // Hält die Reihenfolge der Workspaces für UI-Darstellung oder Wechsel-Logik  
      ordered\_workspace\_ids: Vec\<WorkspaceId\>,  
      next\_workspace\_number: u32, // Für Standardnamen wie "Workspace 1"  
      config\_provider: Arc\<dyn WorkspaceConfigProvider\>,  
      event\_publisher: Arc\<dyn EventPublisher\<WorkspaceEvent\>\>, // Zum Publizieren von Events  
      ensure\_unique\_window\_assignment: bool, // Konfigurierbare Regel  
  }

  Die ordered\_workspace\_ids sind wichtig, um eine konsistente Reihenfolge für UI-Elemente wie Pager oder für "Nächster/Vorheriger Workspace"-Aktionen zu gewährleisten. ensure\_unique\_window\_assignment macht die wichtige Regel der Fensterzuweisung explizit konfigurierbar.  
* **Methoden der impl WorkspaceManager:**

**Tabelle: API-Methoden für workspaces::manager::WorkspaceManager**

| Methode (Rust-Signatur) | Kurzbeschreibung | Vor-/Nachbedingungen | Ausgelöste Events | Mögliche Fehler (WorkspaceManagerError) |
| :---- | :---- | :---- | :---- | :---- |
| pub fn new(config\_provider: Arc\<dyn WorkspaceConfigProvider\>, event\_publisher: Arc\<dyn EventPublisher\<WorkspaceEvent\>\>, ensure\_unique\_window\_assignment: bool) \-\> Result\<Self, WorkspaceManagerError\> | Initialisiert den Manager. Lädt Konfiguration, setzt Standard-Workspaces falls keine Konfig vorhanden. | \- | Manager ist initialisiert. Workspaces sind geladen oder Standard-Workspaces erstellt. active\_workspace\_id ist gesetzt. | WorkspaceCreated (falls Standard-WS erstellt), ActiveWorkspaceChanged |
| pub fn create\_workspace(\&mut self, name: Option\<String\>, persistent\_id: Option\<String\>) \-\> Result\<WorkspaceId, WorkspaceManagerError\> | Erstellt einen neuen Workspace, fügt ihn zur Sammlung hinzu. | Name (falls Some) und persistent\_id (falls Some) müssen gültig sein. | Neuer Workspace ist erstellt, zur Sammlung und ordered\_workspace\_ids hinzugefügt. | WorkspaceCreated |
| pub fn delete\_workspace(\&mut self, id: WorkspaceId, fallback\_id\_for\_windows: Option\<WorkspaceId\>) \-\> Result\<(), WorkspaceManagerError\> | Löscht einen Workspace. Fenster werden ggf. auf einen Fallback-Workspace verschoben. | Darf nicht der letzte Workspace sein. fallback\_id\_for\_windows muss existieren, falls Fenster verschoben werden müssen und der Workspace nicht leer ist. | Workspace ist gelöscht. Fenster sind verschoben. Ggf. neuer aktiver Workspace. | WorkspaceDeleted, ActiveWorkspaceChanged, WindowRemovedFromWorkspace, WindowAddedToWorkspace |
| pub fn get\_workspace(\&self, id: WorkspaceId) \-\> Option\<\&Workspace\> | Gibt eine Referenz auf einen Workspace anhand seiner ID zurück. | \- | \- | \- |
| pub fn get\_workspace\_mut(\&mut self, id: WorkspaceId) \-\> Option\<\&mut Workspace\> | Gibt eine veränderbare Referenz auf einen Workspace anhand seiner ID zurück. | \- | \- | \- |
| pub fn all\_workspaces\_ordered(\&self) \-\> Vec\<\&Workspace\> | Gibt eine geordnete Liste aller Workspaces zurück. | \- | \- | \- |
| pub fn active\_workspace\_id(\&self) \-\> Option\<WorkspaceId\> | Gibt die ID des aktuell aktiven Workspace zurück. | \- | \- | \- |
| pub fn set\_active\_workspace(\&mut self, id: WorkspaceId) \-\> Result\<(), WorkspaceManagerError\> | Setzt den aktiven Workspace. | id muss ein existierender Workspace sein. | active\_workspace\_id ist auf id gesetzt. | ActiveWorkspaceChanged |
| pub fn assign\_window\_to\_active\_workspace(\&mut self, window\_id: \&WindowIdentifier) \-\> Result\<(), WorkspaceManagerError\> | Weist ein Fenster dem aktiven Workspace zu. | Ein aktiver Workspace muss existieren. | Fenster ist dem aktiven Workspace zugeordnet. | WindowAddedToWorkspace, WindowRemovedFromWorkspace (falls ensure\_unique\_window\_assignment) |
| pub fn assign\_window\_to\_specific\_workspace(\&mut self, workspace\_id: WorkspaceId, window\_id: \&WindowIdentifier) \-\> Result\<(), WorkspaceManagerError\> | Weist ein Fenster einem spezifischen Workspace zu. | workspace\_id muss existieren. | Fenster ist dem workspace\_id zugeordnet. | WindowAddedToWorkspace, WindowRemovedFromWorkspace (falls ensure\_unique\_window\_assignment) |
| pub fn remove\_window\_from\_its\_workspace(\&mut self, window\_id: \&WindowIdentifier) \-\> Result\<Option\<WorkspaceId\>, WorkspaceManagerError\> | Entfernt ein Fenster von dem Workspace, dem es aktuell zugeordnet ist. Gibt die ID des Workspace zurück, von dem es entfernt wurde. | \- | Fenster ist keinem Workspace mehr zugeordnet (oder dem, dem es explizit zugewiesen war). | WindowRemovedFromWorkspace |
| pub fn move\_window\_to\_specific\_workspace(\&mut self, target\_workspace\_id: WorkspaceId, window\_id: \&WindowIdentifier) \-\> Result\<(), WorkspaceManagerError\> | Verschiebt ein Fenster von seinem aktuellen Workspace zu einem spezifischen Ziel-Workspace. | target\_workspace\_id muss existieren. Fenster muss einem Workspace zugeordnet sein. | Fenster ist dem target\_workspace\_id zugeordnet und vom vorherigen entfernt. | WindowRemovedFromWorkspace, WindowAddedToWorkspace |
| pub fn rename\_workspace(\&mut self, id: WorkspaceId, new\_name: String) \-\> Result\<(), WorkspaceManagerError\> | Benennt einen Workspace um. | id muss existieren. new\_name muss gültig sein. | Workspace ist umbenannt. | WorkspaceRenamed |
| pub fn set\_workspace\_layout(\&mut self, id: WorkspaceId, layout\_type: WorkspaceLayoutType) \-\> Result\<(), WorkspaceManagerError\> | Ändert den Layout-Typ eines Workspace. | id muss existieren. | Layout-Typ ist geändert. | WorkspaceLayoutChanged |
| pub fn save\_configuration(\&self) \-\> Result\<(), WorkspaceManagerError\> | Speichert die aktuelle Workspace-Konfiguration (Namen, persistente IDs, Reihenfolge, aktiver Workspace). | \- | Konfiguration ist gespeichert. | \- |

### **4.4. Events: Definition und Semantik**

Der WorkspaceManager ist der primäre Publisher für alle Workspace-bezogenen Events. Diese Events informieren andere Teile des Systems über Zustandsänderungen.

* **Event-Enum: WorkspaceEvent**  
  Rust  
  // src/domain/workspaces/manager/events.rs  
  use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType};  
  use crate::domain::workspaces::core::event\_data::\*; // Importiert Payloads wie WorkspaceRenamedData

  \#  
  pub enum WorkspaceEvent {  
      WorkspaceCreated {  
          id: WorkspaceId,  
          name: String,  
          persistent\_id: Option\<String\>,  
          position: usize, // Position in der geordneten Liste  
      },  
      WorkspaceDeleted {  
          id: WorkspaceId,  
          // ID des Workspace, auf den Fenster verschoben wurden, falls zutreffend  
          windows\_moved\_to\_workspace\_id: Option\<WorkspaceId\>,  
      },  
      ActiveWorkspaceChanged {  
          old\_id: Option\<WorkspaceId\>,  
          new\_id: WorkspaceId,  
      },  
      WorkspaceRenamed(WorkspaceRenamedData), // Nutzt Payload aus core::event\_data  
      WorkspaceLayoutChanged(WorkspaceLayoutChangedData), // Nutzt Payload aus core::event\_data  
      WindowAddedToWorkspace(WindowAddedToWorkspaceData), // Nutzt Payload aus core::event\_data  
      WindowRemovedFromWorkspace(WindowRemovedFromWorkspaceData), // Nutzt Payload aus core::event\_data  
      WorkspaceOrderChanged(Vec\<WorkspaceId\>), // Die neue, vollständige Reihenfolge der Workspace-IDs  
      WorkspacesReloaded(Vec\<WorkspaceId\>), // Signalisiert, dass Workspaces neu geladen wurden (z.B. aus Konfig)  
      WorkspacePersistentIdChanged(WorkspacePersistentIdChangedData), // Nutzt Payload aus core::event\_data  
  }

* **Publisher:** WorkspaceManager (über den injizierten event\_publisher).  
* **Typische Subscriber:**  
  * **UI-Schicht:** Aktualisiert die Darstellung von Workspaces, Panels, Fensterlisten etc.  
  * **domain::window\_management:** Reagiert auf Layout-Änderungen oder Änderungen des aktiven Workspace, um Fenster entsprechend anzuordnen oder Fokus zu setzen.  
  * **Systemschicht (Compositor):** Passt die Sichtbarkeit von Fenstern/Surfaces an, wenn sich der aktive Workspace ändert.  
  * **Logging/Tracing-Systeme:** Protokollieren Workspace-bezogene Aktivitäten.

**Tabelle: WorkspaceEvent Varianten**

| Event-Variante | Payload-Struktur/Daten | Semantische Bedeutung | Typische Auslöser (Manager-Methode) |
| :---- | :---- | :---- | :---- |
| WorkspaceCreated | id, name, persistent\_id, position | Ein neuer Workspace wurde erstellt und der Sammlung hinzugefügt. | create\_workspace, Initialisierung |
| WorkspaceDeleted | id, windows\_moved\_to\_workspace\_id | Ein Workspace wurde gelöscht. | delete\_workspace |
| ActiveWorkspaceChanged | old\_id, new\_id | Der aktive Workspace hat sich geändert. | set\_active\_workspace, delete\_workspace (falls aktiver gelöscht) |
| WorkspaceRenamed | WorkspaceRenamedData | Ein Workspace wurde umbenannt. | rename\_workspace |
| WorkspaceLayoutChanged | WorkspaceLayoutChangedData | Der Layout-Typ eines Workspace wurde geändert. | set\_workspace\_layout |
| WindowAddedToWorkspace | WindowAddedToWorkspaceData | Ein Fenster wurde einem Workspace hinzugefügt. | assign\_window\_to\_active\_workspace, assign\_window\_to\_specific\_workspace, move\_window\_to\_specific\_workspace |
| WindowRemovedFromWorkspace | WindowRemovedFromWorkspaceData | Ein Fenster wurde von einem Workspace entfernt. | remove\_window\_from\_its\_workspace, move\_window\_to\_specific\_workspace, delete\_workspace |
| WorkspaceOrderChanged | Vec\<WorkspaceId\> | Die Reihenfolge der Workspaces hat sich geändert. | (Noch nicht spezifizierte Methoden wie move\_workspace\_left/right) |
| WorkspacesReloaded | Vec\<WorkspaceId\> | Die Workspace-Konfiguration wurde neu geladen. | new (bei Initialisierung aus Konfig) |
| WorkspacePersistentIdChanged | WorkspacePersistentIdChangedData | Die persistente ID eines Workspace wurde geändert. | (Indirekt durch Workspace::set\_persistent\_id via Manager) |

### **4.5. Fehlerbehandlung: WorkspaceManagerError**

Das WorkspaceManagerError-Enum fasst Fehler zusammen, die auf der Ebene des Managers auftreten können, einschließlich Fehlern aus den unterlagerten Modulen.

* **Definition:**  
  Rust  
  // src/domain/workspaces/manager/errors.rs  
  use thiserror::Error;  
  use crate::domain::workspaces::core::types::WorkspaceId;  
  use crate::domain::workspaces::core::errors::WorkspaceCoreError;  
  use crate::domain::workspaces::assignment::errors::WindowAssignmentError;  
  use crate::domain::workspaces::config::errors::WorkspaceConfigError;

  \#  
  pub enum WorkspaceManagerError {  
      \#  
      WorkspaceNotFound(WorkspaceId),

      \#\[error("Cannot delete the last workspace. At least one workspace must remain.")\]  
      CannotDeleteLastWorkspace,

      \#  
      DeleteRequiresFallbackForWindows(WorkspaceId),

      \#  
      FallbackWorkspaceNotFound(WorkspaceId),

      \#\[error("A workspace core operation failed: {source}")\]  
      CoreError { \#\[from\] source: WorkspaceCoreError },

      \#\[error("A window assignment operation failed: {source}")\]  
      AssignmentError { \#\[from\] source: WindowAssignmentError },

      \#\[error("A workspace configuration operation failed: {source}")\]  
      ConfigError { \#\[from\] source: WorkspaceConfigError },

      \#\[error("Attempted to set a non-existent workspace '{0}' as active.")\]  
      SetActiveWorkspaceNotFound(WorkspaceId),

      \#\[error("No active workspace is set, but the operation requires one.")\]  
      NoActiveWorkspace,

      \#  
      DuplicatePersistentId(String),

      \#\[error("An internal error occurred in the workspace manager: {context}")\]  
      Internal { context: String },  
  }

* Erläuterung und Anwendung von Fehlerbehandlungsprinzipien:  
  WorkspaceManagerError verwendet thiserror und das \#\[from\]-Attribut, um Fehler aus den Modulen core, assignment und config elegant zu wrappen.1 Dies ist ein zentrales Muster für die Fehleraggregation in übergeordneten Komponenten. Die source()-Kette bleibt dabei erhalten, was für die Fehlerdiagnose kritisch ist.3 Wenn beispielsweise WorkspaceManager::rename\_workspace aufgerufen wird und intern Workspace::rename einen WorkspaceCoreError::NameTooLong zurückgibt, wird dieser Fehler in einen WorkspaceManagerError::CoreError { source: WorkspaceCoreError::NameTooLong } umgewandelt. Der Aufrufer des WorkspaceManager kann dann error.source() verwenden, um an den ursprünglichen WorkspaceCoreError zu gelangen und dessen spezifische Details zu untersuchen. Diese Fähigkeit, die Fehlerursache über mehrere Abstraktionsebenen hinweg zurückzuverfolgen, ist für die Entwicklung robuster Software unerlässlich und wird durch die konsequente Anwendung von \#\[from\] und dem std::error::Error-Trait ermöglicht.1  
  Zusätzlich definiert das Enum spezifische Fehler, die nur in der Logik des Managers auftreten können, wie CannotDeleteLastWorkspace oder NoActiveWorkspace.

**Tabelle: WorkspaceManagerError Varianten**

| Variante | \#\[error("...")\]-Meldung (Auszug) | Semantische Bedeutung/Ursache | Enthaltene Daten/Quellfehler |
| :---- | :---- | :---- | :---- |
| WorkspaceNotFound(WorkspaceId) | "Workspace with ID '{0}' not found." | Ein referenzierter Workspace existiert nicht. | WorkspaceId des nicht gefundenen Workspace. |
| CannotDeleteLastWorkspace | "Cannot delete the last workspace..." | Es wurde versucht, den einzigen verbleibenden Workspace zu löschen. | \- |
| DeleteRequiresFallbackForWindows(WorkspaceId) | "Cannot delete workspace '{0}' because it contains windows..." | Ein Workspace mit Fenstern soll gelöscht werden, ohne einen Fallback anzugeben. | WorkspaceId des zu löschenden Workspace. |
| FallbackWorkspaceNotFound(WorkspaceId) | "The specified fallback workspace with ID '{0}' was not found..." | Der angegebene Fallback-Workspace existiert nicht. | WorkspaceId des nicht gefundenen Fallback-Workspace. |
| CoreError | "A workspace core operation failed..." | Fehler aus workspaces::core. | source: WorkspaceCoreError. |
| AssignmentError | "A window assignment operation failed..." | Fehler aus workspaces::assignment. | source: WindowAssignmentError. |
| ConfigError | "A workspace configuration operation failed..." | Fehler aus workspaces::config. | source: WorkspaceConfigError. |
| SetActiveWorkspaceNotFound(WorkspaceId) | "Attempted to set a non-existent workspace '{0}' as active." | Ein nicht existierender Workspace sollte als aktiv gesetzt werden. | WorkspaceId des nicht gefundenen Workspace. |
| NoActiveWorkspace | "No active workspace is set..." | Eine Operation wurde aufgerufen, die einen aktiven Workspace erfordert, aber keiner ist gesetzt. | \- |
| DuplicatePersistentId(String) | "Attempted to create a workspace with a persistent ID ('{0}') that already exists." | Eine persistente ID, die bereits verwendet wird, wurde für einen neuen Workspace angegeben. | Die duplizierte String ID. |
| Internal { context: String } | "An internal error occurred..." | Ein unerwarteter interner Fehler im Manager. | context: String. |

### **4.6. Detaillierte Implementierungsschritte und Dateistruktur**

* **Dateistruktur innerhalb von src/domain/workspaces/manager/:**  
  * mod.rs: Enthält die Definition des WorkspaceManager-Structs und die Implementierung seiner Methoden.  
  * errors.rs: Enthält die Definition des WorkspaceManagerError-Enums.  
  * events.rs: Enthält die Definition des WorkspaceEvent-Enums und ggf. des EventPublisher-Traits.  
* **Implementierungsschritte:**  
  1. Definiere WorkspaceEvent (und EventPublisher-Trait, falls nicht global vorhanden) in events.rs.  
  2. Definiere WorkspaceManagerError in errors.rs.  
  3. Implementiere das WorkspaceManager-Struct in mod.rs.  
  4. Implementiere pub fn new(...) \-\> Result\<Self, WorkspaceManagerError\>:  
     * Initialisiere workspaces als leere HashMap, ordered\_workspace\_ids als leeren Vec.  
     * Setze next\_workspace\_number auf 1\.  
     * Speichere config\_provider, event\_publisher, ensure\_unique\_window\_assignment.  
     * Versuche, die Konfiguration mittels self.config\_provider.load\_workspace\_config() zu laden.  
       * Bei Erfolg (Ok(snapshot)): Rekonstruiere Workspace-Objekte aus snapshot.workspaces. Füge sie zu self.workspaces und self.ordered\_workspace\_ids hinzu (Reihenfolge aus Snapshot beachten). Setze self.active\_workspace\_id basierend auf snapshot.active\_workspace\_persistent\_id (Suche nach Workspace mit passender persistent\_id). Aktualisiere next\_workspace\_number ggf. basierend auf den Namen der geladenen Workspaces. Publiziere WorkspacesReloaded und ActiveWorkspaceChanged.  
       * Bei Fehler (Err(config\_err)):  
         * Wenn der Fehler anzeigt, dass keine Konfiguration vorhanden ist (z.B. CoreConfigError::NotFound), erstelle einen Standard-Workspace (z.B. "Workspace 1"). Füge ihn hinzu, setze ihn als aktiv. Publiziere WorkspaceCreated, ActiveWorkspaceChanged.  
         * Andernfalls mappe den config\_err zu WorkspaceManagerError::ConfigError und gib ihn zurück.  
  5. Implementiere pub fn create\_workspace(...) \-\> Result\<WorkspaceId, WorkspaceManagerError\>:  
     * Falls persistent\_id Some ist, prüfe, ob bereits ein Workspace mit dieser persistent\_id existiert. Falls ja, Fehler DuplicatePersistentId.  
     * Bestimme den Namen: Falls name None ist, generiere einen Standardnamen (z.B. "Workspace {next\_workspace\_number}").  
     * Erstelle ein neues Workspace-Objekt via Workspace::new(final\_name, persistent\_id). Mappe WorkspaceCoreError zu CoreError.  
     * Füge den neuen Workspace zu self.workspaces und self.ordered\_workspace\_ids hinzu (z.B. am Ende).  
     * Inkrementiere next\_workspace\_number falls ein Standardname verwendet wurde.  
     * Publiziere WorkspaceEvent::WorkspaceCreated mit ID, Name, persistent\_id und Position.  
     * Rufe self.save\_configuration() auf.  
     * Gib Ok(new\_workspace.id()) zurück.  
  6. Implementiere pub fn delete\_workspace(...) \-\> Result\<(), WorkspaceManagerError\>:  
     * Prüfe, ob id existiert (Fehler: WorkspaceNotFound).  
     * Prüfe, ob es der letzte Workspace ist (Fehler: CannotDeleteLastWorkspace).  
     * Hole den zu löschenden Workspace. Wenn er Fenster enthält und fallback\_id\_for\_windows None ist, Fehler DeleteRequiresFallbackForWindows.  
     * Falls Fenster verschoben werden müssen:  
       * Prüfe, ob fallback\_id\_for\_windows existiert (Fehler: FallbackWorkspaceNotFound).  
       * Nutze assignment::move\_window\_to\_workspace (oder eine ähnliche Logik) für jedes Fenster, um es vom zu löschenden Workspace zum Fallback-Workspace zu verschieben. Mappe WindowAssignmentError zu AssignmentError. Publiziere WindowRemovedFromWorkspace und WindowAddedToWorkspace für jedes verschobene Fenster.  
     * Entferne den Workspace aus self.workspaces und self.ordered\_workspace\_ids.  
     * Falls der gelöschte Workspace der aktive war: Setze einen anderen Workspace als aktiv (z.B. den ersten in ordered\_workspace\_ids). Publiziere ActiveWorkspaceChanged.  
     * Publiziere WorkspaceEvent::WorkspaceDeleted.  
     * Rufe self.save\_configuration() auf.  
     * Gib Ok(()) zurück.  
  7. Implementiere die Getter-Methoden (get\_workspace, get\_workspace\_mut, all\_workspaces\_ordered, active\_workspace\_id). Für all\_workspaces\_ordered iteriere über ordered\_workspace\_ids und hole die entsprechenden Workspace-Referenzen aus workspaces.  
  8. Implementiere pub fn set\_active\_workspace(...) \-\> Result\<(), WorkspaceManagerError\>:  
     * Prüfe, ob id existiert (Fehler: SetActiveWorkspaceNotFound).  
     * Wenn id bereits aktiv ist, keine Aktion.  
     * Setze self.active\_workspace\_id \= Some(id).  
     * Publiziere WorkspaceEvent::ActiveWorkspaceChanged mit alter und neuer ID.  
     * Rufe self.save\_configuration() auf (optional, je nachdem ob der aktive Workspace persistiert werden soll).  
     * Gib Ok(()) zurück.  
  9. Implementiere Fensterzuweisungsmethoden (assign\_window\_to\_active\_workspace, assign\_window\_to\_specific\_workspace, remove\_window\_from\_its\_workspace, move\_window\_to\_specific\_workspace):  
     * Nutze die entsprechenden Funktionen aus dem workspaces::assignment-Modul.  
     * Übergebe \&mut self.workspaces und self.ensure\_unique\_window\_assignment (wo relevant).  
     * Mappe WindowAssignmentError zu WorkspaceManagerError::AssignmentError.  
     * Publiziere die relevanten Events (WindowAddedToWorkspace, WindowRemovedFromWorkspace) nach erfolgreicher Operation.  
  10. Implementiere rename\_workspace und set\_workspace\_layout:  
      * Hole \&mut Workspace (Fehler: WorkspaceNotFound).  
      * Rufe die entsprechende Methode auf dem Workspace-Objekt auf (rename oder set\_layout\_type). Mappe WorkspaceCoreError zu CoreError.  
      * Publiziere das entsprechende Event (WorkspaceRenamed oder WorkspaceLayoutChanged).  
      * Rufe self.save\_configuration() auf.  
  11. Implementiere pub fn save\_configuration(\&self) \-\> Result\<(), WorkspaceManagerError\>:  
      * Erstelle ein WorkspaceSetSnapshot. Fülle workspaces durch Iteration über self.ordered\_workspace\_ids und Erstellung von WorkspaceSnapshots für jeden Workspace (Name, persistente ID, Layout).  
      * Setze active\_workspace\_persistent\_id im Snapshot basierend auf der persistent\_id des aktuellen active\_workspace\_id.  
      * Rufe self.config\_provider.save\_workspace\_config(\&snapshot) auf. Mappe WorkspaceConfigError zu ConfigError.  
  12. Stelle sicher, dass alle Methoden umfassend mit rustdoc dokumentiert sind.  
  13. Erstelle Unit- und Integrationstests, die das Zusammenspiel der Module core, assignment, config und des Event-Publishings testen. Mocke WorkspaceConfigProvider und EventPublisher für die Tests.

## **5\. Entwicklungsmodul 4: workspaces::config – Konfigurations- und Persistenzlogik**

Das Modul workspaces::config ist dediziert für das Laden und Speichern der Konfiguration des Workspace-Systems zuständig.

### **5.1. Verantwortlichkeiten und Design-Rationale**

Die Hauptverantwortung dieses Moduls besteht darin, eine Abstraktion für die Persistenz von Workspace-bezogenen Daten bereitzustellen. Dies umfasst typischerweise:

* Namen und persistente IDs der Workspaces.  
* Standard-Layout-Typen pro Workspace.  
* Die Reihenfolge der Workspaces.  
* Die ID des zuletzt aktiven Workspace.

Es interagiert mit der core::config-Komponente der Kernschicht, um die tatsächlichen Lese- und Schreiboperationen aus bzw. in Konfigurationsdateien (oder andere Persistenzmechanismen) durchzuführen.  
Das Design-Rationale für dieses separate Modul ist die Entkopplung der Workspace-Verwaltungslogik (workspaces::manager) von den spezifischen Details der Konfigurationsspeicherung. Dies ermöglicht es, das Speicherformat (z.B. JSON, TOML, SQLite) oder den Speicherort zu ändern, ohne den WorkspaceManager modifizieren zu müssen, solange die WorkspaceConfigProvider-Schnittstelle eingehalten wird.

### **5.2. Datenstrukturen für Konfiguration und Interaktion mit core::config**

Für die Serialisierung und Deserialisierung der Workspace-Konfiguration werden spezielle Snapshot-Strukturen verwendet. Diese Strukturen sind so gestaltet, dass sie nur die Daten enthalten, die tatsächlich persistiert werden sollen.

* Struct: WorkspaceSnapshot  
  Eine serialisierbare Repräsentation der zu persistierenden Daten eines einzelnen Workspace.  
  Rust  
  // src/domain/workspaces/config/mod.rs  
  use serde::{Serialize, Deserialize};  
  use crate::domain::workspaces::core::types::{WorkspaceLayoutType, WorkspaceId}; // WorkspaceId nur für Referenz, nicht persistiert

  \#  
  pub struct WorkspaceSnapshot {  
      // Die \`persistent\_id\` ist der Schlüssel zur Wiedererkennung eines Workspace über Sitzungen.  
      // Die Laufzeit-\`WorkspaceId\` (uuid) wird bei jedem Start neu generiert und ist nicht Teil des Snapshots.  
      pub persistent\_id: String,  
      pub name: String,  
      pub layout\_type: WorkspaceLayoutType,  
      // \`window\_ids\` werden nicht persistiert, da sie von laufenden Anwendungen abhängen und transient sind.  
      // \`created\_at\` wird ebenfalls nicht standardmäßig persistiert, es sei denn, es gibt eine Anforderung dafür.  
  }

* Struct: WorkspaceSetSnapshot  
  Eine serialisierbare Repräsentation der gesamten Workspace-Konfiguration, die eine Liste von WorkspaceSnapshot-Instanzen und die persistente ID des aktiven Workspace enthält.  
  Rust  
  // src/domain/workspaces/config/mod.rs  
  \#  
  pub struct WorkspaceSetSnapshot {  
      pub workspaces: Vec\<WorkspaceSnapshot\>,  
      // Speichert die \`persistent\_id\` des Workspace, der beim letzten Speichern aktiv war.  
      pub active\_workspace\_persistent\_id: Option\<String\>,  
      // Die Reihenfolge der \`workspaces\` in diesem Vec definiert die persistierte Reihenfolge.  
  }

* Trait: WorkspaceConfigProvider  
  Definiert die Schnittstelle, die dieses Modul dem WorkspaceManager zur Verfügung stellt. Dies ermöglicht die Entkopplung von der konkreten Implementierung der Persistenzlogik.  
  Rust  
  // src/domain/workspaces/config/mod.rs  
  use crate::domain::workspaces::config::errors::WorkspaceConfigError;

  pub trait WorkspaceConfigProvider: Send \+ Sync {  
      fn load\_workspace\_config(\&self) \-\> Result\<WorkspaceSetSnapshot, WorkspaceConfigError\>;  
      fn save\_workspace\_config(\&self, config\_snapshot: \&WorkspaceSetSnapshot) \-\> Result\<(), WorkspaceConfigError\>;  
  }

* Struct: FilesystemConfigProvider (Beispielimplementierung)  
  Eine konkrete Implementierung von WorkspaceConfigProvider, die core::config (oder eine ähnliche Abstraktion der Kernschicht für Dateizugriffe) nutzt, um die Konfiguration als Datei (z.B. JSON oder TOML) zu speichern und zu laden.  
  Rust  
  // src/domain/workspaces/config/mod.rs  
  use std::sync::Arc;  
  use crate::core::config::ConfigService; // Annahme: Ein Service aus der Kernschicht

  pub struct FilesystemConfigProvider {  
      config\_service: Arc\<dyn ConfigService\>, // Service aus der Kernschicht  
      config\_file\_name: String, // z.B. "workspaces\_v1.json"  
  }

  impl FilesystemConfigProvider {  
      pub fn new(config\_service: Arc\<dyn ConfigService\>, config\_file\_name: String) \-\> Self {  
          Self { config\_service, config\_file\_name }  
      }  
  }

  // Die Implementierung von \`WorkspaceConfigProvider\` für \`FilesystemConfigProvider\` folgt in Abschnitt 5.6

### **5.3. Öffentliche API: Methoden und Funktionen**

Die öffentliche API dieses Moduls wird durch das WorkspaceConfigProvider-Trait definiert. Konkrete Implementierungen wie FilesystemConfigProvider setzen dieses Trait um.  
**Tabelle: API-Methoden für WorkspaceConfigProvider**

| Methode (Rust-Signatur) | Kurzbeschreibung | Mögliche Fehler (WorkspaceConfigError) |
| :---- | :---- | :---- |
| fn load\_workspace\_config(\&self) \-\> Result\<WorkspaceSetSnapshot, WorkspaceConfigError\> | Lädt die Workspace-Konfiguration aus dem persistenten Speicher. | LoadError, InvalidData, DeserializationError, PersistentIdNotFound (falls Konsistenzchecks fehlschlagen) |
| fn save\_workspace\_config(\&self, config\_snapshot: \&WorkspaceSetSnapshot) \-\> Result\<(), WorkspaceConfigError\> | Speichert die übergebene Workspace-Konfiguration in den persistenten Speicher. | SaveError, SerializationError |

Diese Schnittstelle ermöglicht es dem WorkspaceManager, die Konfiguration zu laden und zu speichern, ohne Details über den Speicherort oder das Format kennen zu müssen. Dies verbessert die Testbarkeit, da der WorkspaceConfigProvider im WorkspaceManager leicht durch eine Mock-Implementierung ersetzt werden kann.

### **5.4. Events: Definition und Semantik**

Das Modul workspaces::config ist typischerweise nicht dafür verantwortlich, eigene Events zu publizieren. Ein erfolgreicher Lade- oder Speichervorgang wird durch Result::Ok(()) signalisiert, während Fehler über das WorkspaceConfigError-Enum zurückgegeben werden. Der WorkspaceManager kann nach einem erfolgreichen Ladevorgang (z.B. bei der Initialisierung) ein WorkspacesReloaded-Event auslösen, um andere Systemteile über die Verfügbarkeit der geladenen Konfiguration zu informieren.

### **5.5. Fehlerbehandlung: WorkspaceConfigError**

Für Fehler, die spezifisch bei Konfigurations- und Persistenzoperationen auftreten, wird das WorkspaceConfigError-Enum definiert.

* **Definition:**  
  Rust  
  // src/domain/workspaces/config/errors.rs  
  use thiserror::Error;  
  // Annahme: Ein allgemeiner Konfigurationsfehler aus der Kernschicht,  
  // der I/O-Fehler, Berechtigungsfehler etc. kapseln kann.  
  use crate::core::config::ConfigError as CoreConfigError;

  \#  
  pub enum WorkspaceConfigError {  
      \#\[error("Failed to load workspace configuration from '{path}': {source}")\]  
      LoadError {  
          path: String,  
          \#\[source\]  
          source: CoreConfigError,  
      },

      \#\[error("Failed to save workspace configuration to '{path}': {source}")\]  
      SaveError {  
          path: String,  
          \#\[source\]  
          source: CoreConfigError,  
      },

      \#\[error("Workspace configuration data is invalid or corrupt: {reason}. Path: '{path:?}'")\]  
      InvalidData { reason: String, path: Option\<String\> },

      \#  
      SerializationError {  
          message: String,  
          \#\[source\]  
          source: Option\<serde\_json::Error\>, // Beispiel für serde\_json  
      },

      \#  
      DeserializationError {  
          message: String,  
          snippet: Option\<String\>, // Ein kleiner Teil des fehlerhaften Inhalts  
          \#\[source\]  
          source: Option\<serde\_json::Error\>, // Beispiel für serde\_json  
      },

      \#  
      PersistentIdNotFound { persistent\_id: String },

      \#  
      DuplicatePersistentId { persistent\_id: String },

      \#  
      VersionMismatch { expected: Option\<String\>, found: Option\<String\> },

      \#\[error("An internal error occurred in workspace configuration logic: {context}")\]  
      Internal { context: String },  
  }

* Erläuterung und Anwendung von Fehlerbehandlungsprinzipien:  
  Auch WorkspaceConfigError nutzt thiserror. Die Varianten LoadError und SaveError verwenden \#\[source\], um den zugrundeliegenden CoreConfigError (aus core::config) als Ursache einzubetten.3 Dies ist wichtig, um die Fehlerkette bis zum ursprünglichen I/O- oder Berechtigungsfehler zurückverfolgen zu können.  
  Ein besonderer Aspekt ist der Umgang mit Fehlern aus externen Bibliotheken, wie z.B. serde\_json::Error für die (De-)Serialisierung. Die Varianten SerializationError und DeserializationError sind so gestaltet, dass sie den ursprünglichen serde-Fehler als source aufnehmen können. Dies ist der direkten Konvertierung des Fehlers in einen String vorzuziehen, da so mehr Informationen für die Diagnose erhalten bleiben.  
  * Wenn serde\_json::Error direkt als source verwendet wird (z.B. \#\[source\] source: serde\_json::Error), kann der Aufrufer den Fehler heruntercasten und spezifische Details des serde-Fehlers untersuchen.  
  * Die message-Felder in diesen Varianten können entweder die Display-Ausgabe des serde-Fehlers oder eine benutzerdefinierte, kontextreichere Nachricht enthalten.  
  * Das Feld snippet in DeserializationError kann einen kleinen Ausschnitt der fehlerhaften Daten enthalten, was die Fehlersuche erheblich erleichtert.

Die Varianten PersistentIdNotFound und DuplicatePersistentId dienen der Validierung der semantischen Korrektheit der geladenen Konfigurationsdaten. VersionMismatch ist vorgesehen, um zukünftige Änderungen am Konfigurationsformat handhaben zu können.  
**Tabelle: WorkspaceConfigError Varianten**

| Variante | \#\[error("...")\]-Meldung (Auszug) | Semantische Bedeutung/Ursache | Enthaltene Daten/Quellfehler |
| :---- | :---- | :---- | :---- |
| LoadError | "Failed to load workspace configuration from '{path}'..." | Fehler beim Lesen der Konfigurationsdatei (I/O, Berechtigungen). | path: String, source: CoreConfigError. |
| SaveError | "Failed to save workspace configuration to '{path}'..." | Fehler beim Schreiben der Konfigurationsdatei (I/O, Berechtigungen, Speicherplatz). | path: String, source: CoreConfigError. |
| InvalidData | "Workspace configuration data is invalid or corrupt: {reason}..." | Die gelesenen Daten sind nicht im erwarteten Format oder semantisch inkonsistent (über (De-)Serialisierungsfehler hinaus). | reason: String, path: Option\<String\>. |
| SerializationError | "Serialization error for workspace configuration: {message}" | Fehler bei der Umwandlung der WorkspaceSetSnapshot-Struktur in ein serialisiertes Format (z.B. JSON). | message: String, source: Option\<serde\_json::Error\>. |
| DeserializationError | "Deserialization error for workspace configuration: {message}..." | Fehler bei der Umwandlung von serialisierten Daten (z.B. JSON-String) in die WorkspaceSetSnapshot-Struktur. | message: String, snippet: Option\<String\>, source: Option\<serde\_json::Error\>. |
| PersistentIdNotFound | "Persistent ID '{persistent\_id}' referenced in configuration..." | Eine in der Konfiguration referenzierte persistente ID (z.B. für den aktiven Workspace) existiert nicht in der Liste der geladenen Workspaces. | persistent\_id: String. |
| DuplicatePersistentId | "Duplicate persistent ID '{persistent\_id}' found..." | Mindestens zwei Workspaces in der Konfiguration haben dieselbe persistente ID. | persistent\_id: String. |
| VersionMismatch | "The configuration version is incompatible..." | Die Version der geladenen Konfigurationsdatei stimmt nicht mit der erwarteten Version überein. | expected: Option\<String\>, found: Option\<String\>. |
| Internal { context: String } | "An internal error occurred..." | Ein unerwarteter interner Fehler in der Konfigurationslogik. | context: String. |

### **5.6. Detaillierte Implementierungsschritte und Dateistruktur**

* **Dateistruktur innerhalb von src/domain/workspaces/config/:**  
  * mod.rs: Enthält die Definitionen der Snapshot-Strukturen (WorkspaceSnapshot, WorkspaceSetSnapshot), des WorkspaceConfigProvider-Traits und der konkreten Implementierung(en) wie FilesystemConfigProvider.  
  * errors.rs: Enthält die Definition des WorkspaceConfigError-Enums.  
* **Implementierungsschritte für FilesystemConfigProvider (Beispiel):**  
  1. Definiere das WorkspaceConfigError-Enum in errors.rs.  
  2. Definiere die Structs WorkspaceSnapshot und WorkspaceSetSnapshot in mod.rs und leite serde::Serialize sowie serde::Deserialize für sie ab.  
  3. Definiere das WorkspaceConfigProvider-Trait in mod.rs.  
  4. Implementiere das FilesystemConfigProvider-Struct (wie in 5.2 gezeigt) in mod.rs.  
  5. Implementiere das WorkspaceConfigProvider-Trait für FilesystemConfigProvider:  
     * **load\_workspace\_config():**  
       1. Rufe self.config\_service.read\_config\_file(\&self.config\_file\_name) auf, um den Inhalt der Konfigurationsdatei als String zu lesen.  
       2. Bei einem Fehler vom config\_service (z.B. Datei nicht gefunden, keine Leseberechtigung), mappe diesen CoreConfigError zu WorkspaceConfigError::LoadError { path: self.config\_file\_name.clone(), source: core\_err } und gib ihn zurück.  
          * Speziell der Fall "Datei nicht gefunden" (CoreConfigError::NotFound oder ähnlich) sollte vom Aufrufer (dem WorkspaceManager) ggf. als nicht-kritischer Fehler behandelt werden (z.B. um Standard-Workspaces zu erstellen). Diese Methode sollte den Fehler jedoch korrekt signalisieren.  
       3. Versuche, den gelesenen String-Inhalt mittels serde\_json::from\_str::\<WorkspaceSetSnapshot\>(content\_str) (oder dem entsprechenden Parser für das gewählte Format) zu deserialisieren.  
       4. Bei einem Deserialisierungsfehler, mappe den serde\_json::Error zu WorkspaceConfigError::DeserializationError { message: serde\_err.to\_string(), snippet: Some(...), source: Some(serde\_err) } und gib ihn zurück. Der snippet sollte einen kleinen Teil des problematischen Inhalts enthalten.  
       5. Führe nach erfolgreicher Deserialisierung Validierungen auf dem WorkspaceSetSnapshot durch:  
          * Prüfe auf doppelte persistent\_ids in snapshot.workspaces. Falls Duplikate gefunden werden, gib Err(WorkspaceConfigError::DuplicatePersistentId {... }) zurück.  
          * Wenn snapshot.active\_workspace\_persistent\_id Some(active\_pid) ist, prüfe, ob ein Workspace mit dieser persistent\_id auch in snapshot.workspaces existiert. Falls nicht, gib Err(WorkspaceConfigError::PersistentIdNotFound {... }) zurück.  
       6. Gib bei Erfolg Ok(snapshot) zurück.  
     * **save\_workspace\_config(config\_snapshot: \&WorkspaceSetSnapshot):**  
       1. Serialisiere das config\_snapshot-Objekt mittels serde\_json::to\_string\_pretty(config\_snapshot) (oder dem entsprechenden Serialisierer) in einen String. to\_string\_pretty wird für bessere Lesbarkeit der Konfigurationsdatei empfohlen.  
       2. Bei einem Serialisierungsfehler, mappe den serde\_json::Error zu WorkspaceConfigError::SerializationError { message: serde\_err.to\_string(), source: Some(serde\_err) } und gib ihn zurück.  
       3. Rufe self.config\_service.write\_config\_file(\&self.config\_file\_name, serialized\_content) auf, um den serialisierten String in die Konfigurationsdatei zu schreiben.  
       4. Bei einem Fehler vom config\_service (z.B. keine Schreibberechtigung, kein Speicherplatz), mappe diesen CoreConfigError zu WorkspaceConfigError::SaveError { path: self.config\_file\_name.clone(), source: core\_err } und gib ihn zurück.  
       5. Gib bei Erfolg Ok(()) zurück.  
  6. Stelle sicher, dass alle öffentlichen Elemente (Traits, Structs, Methoden) umfassend mit rustdoc dokumentiert sind.  
  7. Erstelle Unit-Tests für FilesystemConfigProvider. Diese Tests sollten:  
     * Einen gemockten ConfigService verwenden, um Lese- und Schreiboperationen zu simulieren, ohne auf das tatsächliche Dateisystem zuzugreifen.  
     * Erfolgreiches Laden und Speichern von gültigen WorkspaceSetSnapshot-Daten testen.  
     * Alle Fehlerfälle testen: I/O-Fehler (simuliert durch den Mock), (De-)Serialisierungsfehler mit ungültigen Daten, Validierungsfehler (doppelte IDs, nicht gefundene aktive ID).  
     * Testen des Verhaltens, wenn die Konfigurationsdatei nicht existiert (simulierter CoreConfigError::NotFound).

## **6\. Integrationsleitfaden für die Komponente domain::workspaces**

Dieser Abschnitt beschreibt das Zusammenspiel der vier Module innerhalb der domain::workspaces-Komponente und deren Interaktion mit anderen Teilen des Systems.

### **6.1. Zusammenwirken der Module**

Die vier Module (core, assignment, manager, config) der domain::workspaces-Komponente sind so konzipiert, dass sie eng zusammenarbeiten, wobei jedes Modul klar definierte Verantwortlichkeiten hat:

1. **workspaces::manager als zentraler Koordinator:**  
   * Der WorkspaceManager ist die Hauptschnittstelle und der Orchestrator für alle Workspace-Operationen.  
   * Er initialisiert sich selbst, indem er über einen WorkspaceConfigProvider (aus workspaces::config) die gespeicherte Workspace-Konfiguration lädt.  
   * Er hält eine interne Sammlung (HashMap und Vec) von Workspace-Instanzen (definiert in workspaces::core).  
   * Für Operationen, die die Zuweisung von Fenstern zu Workspaces betreffen (z.B. assign\_window\_to\_active\_workspace), delegiert der WorkspaceManager die Logik an die Funktionen des workspaces::assignment-Moduls und übergibt dabei seine interne Workspace-Sammlung.  
   * Bei Änderungen, die persistiert werden müssen (z.B. Erstellung eines neuen Workspace, Umbenennung, Änderung der Reihenfolge, Änderung des aktiven Workspace), erstellt der WorkspaceManager einen WorkspaceSetSnapshot und nutzt den WorkspaceConfigProvider aus workspaces::config, um diesen zu speichern.  
   * Der WorkspaceManager ist verantwortlich für das Publizieren von WorkspaceEvents, um andere Systemteile über relevante Änderungen zu informieren.  
2. **workspaces::core als Fundament:**  
   * Stellt die Definition des Workspace-Structs und zugehöriger Typen (WindowIdentifier, WorkspaceLayoutType) sowie der Event-Payload-Datenstrukturen bereit.  
   * Workspace-Instanzen werden vom WorkspaceManager gehalten und modifiziert (z.B. durch Aufruf von Workspace::rename()).  
3. **workspaces::assignment als Dienstleister für Zuweisungslogik:**  
   * Stellt zustandslose Funktionen bereit, die auf der vom WorkspaceManager übergebenen Sammlung von Workspace-Objekten operieren, um Fenster zuzuweisen, zu entfernen oder zu verschieben.  
   * Modifiziert die window\_ids-Mengen innerhalb der Workspace-Objekte.  
4. **workspaces::config als Persistenzabstraktion:**  
   * Definiert die Schnittstelle (WorkspaceConfigProvider) und die Datenstrukturen (WorkspaceSnapshot, WorkspaceSetSnapshot) für das Laden und Speichern der Workspace-Konfiguration.  
   * Konkrete Implementierungen (z.B. FilesystemConfigProvider) nutzen Dienste der Kernschicht (core::config) für den eigentlichen Dateizugriff.

Dieses Design fördert Modularität und Testbarkeit. Der WorkspaceManager kann beispielsweise mit gemockten WorkspaceConfigProvider- und EventPublisher-Implementierungen getestet werden.

### **6.2. Abhängigkeiten und Schnittstellen zu anderen Domänenkomponenten und Schichten**

Die domain::workspaces-Komponente interagiert mit und hat Abhängigkeiten zu folgenden anderen Teilen des Systems:

* **Kernschicht (Core Layer):**  
  * **core::config:** Wird von workspaces::config (konkret von FilesystemConfigProvider) genutzt, um auf das Dateisystem zuzugreifen und Konfigurationsdateien zu lesen/schreiben.  
  * **core::errors:** Basisfehlertypen (z.B. ValidationError, ConfigError aus core::config) können von den spezifischen Fehler-Enums der Workspace-Module (WorkspaceCoreError, WorkspaceConfigError) via \#\[from\] referenziert und gewrappt werden.  
  * **core::types:** Fundamentale Typen wie uuid::Uuid (für WorkspaceId) werden direkt genutzt. Andere Typen (z.B. chrono::DateTime) für Zeitstempel.  
  * **core::logging (implizit):** Alle Module der domain::workspaces-Komponente sollten das tracing-Framework der Kernschicht für Logging und Tracing verwenden, wie in Richtlinie 4.4 spezifiziert.  
* **Andere Domänenkomponenten (Domain Layer):**  
  * **domain::window\_management (Policy):**  
    * Diese Komponente definiert die übergeordneten Regeln für Fensterplatzierung und \-verhalten. Sie könnte auf WorkspaceEvents (z.B. ActiveWorkspaceChanged, WindowAddedToWorkspace, WorkspaceLayoutChanged) vom workspaces::manager lauschen, um ihre Layout-Algorithmen oder Fensteranordnungen anzupassen.  
    * Umgekehrt könnte domain::window\_management Regeln bereitstellen (z.B. "Anwendung X immer auf Workspace Y öffnen"), die der workspaces::manager oder workspaces::assignment bei der initialen Zuweisung eines neuen Fensters berücksichtigen muss. Dies könnte über eine direkte Abfrage oder eine Konfigurationsschnittstelle erfolgen.  
  * **domain::settings:**  
    * Globale Desktop-Einstellungen (z.B. "Standardanzahl der Workspaces beim ersten Start", "Verhalten beim Schließen des letzten Fensters auf einem Workspace") könnten das Initialisierungs- oder Betriebsverhalten des workspaces::manager beeinflussen. Der WorkspaceManager könnte diese Einstellungen beim Start abfragen.  
  * **domain::ai (indirekt):**  
    * KI-Funktionen könnten kontextabhängig von Workspaces agieren (z.B. "fasse die Fenster auf dem aktuellen Workspace zusammen"). In diesem Fall würde domain::ai Informationen über den aktiven Workspace und dessen Fenster vom workspaces::manager abfragen.  
* **Systemschicht (System Layer):**  
  * **Compositor (system::compositor):**  
    * Informiert den workspaces::manager (oder eine übergeordnete Fassade in der Systemschicht, die mit dem Manager kommuniziert), wenn neue Fenster (Wayland Surfaces) erstellt oder zerstört werden. Diese Information ist notwendig, damit der WorkspaceManager die Fenster den Workspaces zuordnen kann.  
    * Wird vom workspaces::manager (oft indirekt über domain::window\_management) angewiesen, welche Fenster auf dem aktuell aktiven Workspace sichtbar gemacht und welche verborgen werden sollen.  
    * Setzt Fokusregeln basierend auf dem aktiven Workspace und den Anweisungen aus der Domänenschicht um.  
  * **D-Bus-Schnittstellen (system::dbus):**  
    * Der WorkspaceManager könnte seine API (oder Teile davon) über D-Bus exponieren, um externen Werkzeugen oder Skripten die Steuerung von Workspaces zu ermöglichen.  
    * Umgekehrt könnte der WorkspaceManager auf D-Bus-Signale von Systemdiensten lauschen, falls diese für die Workspace-Logik relevant sind.  
* **Benutzeroberflächenschicht (User Interface Layer):**  
  * **Shell-UI (ui::shell), Pager, Fensterwechsler (ui::window\_manager\_frontend):**  
    * Nutzt die API des workspaces::manager intensiv, um die Liste der Workspaces abzurufen und darzustellen, den aktiven Workspace hervorzuheben, das Wechseln zwischen Workspaces zu ermöglichen und die Erstellung/Löschung/Umbenennung von Workspaces durch Benutzeraktionen anzustoßen.  
    * Reagiert auf WorkspaceEvents vom WorkspaceManager, um die Benutzeroberfläche dynamisch zu aktualisieren, wenn sich der Workspace-Zustand ändert (z.B. neuer Workspace erscheint im Pager, Fensterliste für aktiven Workspace wird aktualisiert).

### **6.3. Sequenzdiagramme für typische Anwendungsfälle**

Die folgenden Beschreibungen skizzieren die Interaktionen für typische Anwendungsfälle. In einer vollständigen grafischen Dokumentation würden hier UML-Sequenzdiagramme stehen.

1. **Erstellung eines neuen Workspace durch Benutzeraktion:**  
   * User interagiert mit der UI-Schicht (z.B. Klick auf "Neuer Workspace"-Button).  
   * UI-Schicht ruft WorkspaceManager::create\_workspace(name, persistent\_id) auf.  
   * WorkspaceManager validiert Eingaben, generiert ggf. Standardnamen.  
   * WorkspaceManager ruft Workspace::new(final\_name, persistent\_id) (aus workspaces::core) auf, um eine neue Workspace-Instanz zu erstellen.  
     * Workspace::new gibt Ok(new\_workspace) oder Err(WorkspaceCoreError) zurück.  
   * WorkspaceManager fügt new\_workspace seiner internen Sammlung hinzu.  
   * WorkspaceManager publiziert ein WorkspaceEvent::WorkspaceCreated über seinen EventPublisher.  
   * WorkspaceManager ruft self.save\_configuration() auf, was intern den WorkspaceConfigProvider::save\_workspace\_config() (aus workspaces::config) aufruft.  
     * WorkspaceConfigProvider serialisiert den Zustand und nutzt core::config::ConfigService zum Schreiben.  
   * WorkspaceManager gibt Ok(new\_workspace\_id) an die UI-Schicht zurück.  
   * UI-Schicht (als Subscriber des WorkspaceEvent::WorkspaceCreated) aktualisiert die Darstellung (z.B. fügt neuen Workspace-Tab hinzu).  
2. **Ein neues Fenster wird erstellt und dem aktiven Workspace zugewiesen:**  
   * Systemschicht (Compositor) erkennt ein neues Fenster (z.B. neues Wayland Surface) und generiert eine WindowIdentifier.  
   * Systemschicht benachrichtigt den WorkspaceManager (ggf. über eine Fassade oder einen System-Event) über das neue Fenster: handle\_new\_window(window\_id).  
   * WorkspaceManager::handle\_new\_window (oder eine ähnliche Methode) ruft intern WorkspaceManager::assign\_window\_to\_active\_workspace(\&window\_id) auf.  
   * WorkspaceManager::assign\_window\_to\_active\_workspace prüft, ob ein aktiver Workspace existiert.  
   * WorkspaceManager ruft workspaces::assignment::assign\_window\_to\_workspace(\&mut self.workspaces, active\_ws\_id, \&window\_id, self.ensure\_unique\_window\_assignment) auf.  
     * assignment::assign\_window\_to\_workspace modifiziert das Workspace-Objekt des aktiven Workspace (fügt window\_id zu dessen window\_ids-Set hinzu) und entfernt es ggf. von anderen Workspaces.  
     * Gibt Ok(()) oder Err(WindowAssignmentError) zurück.  
   * WorkspaceManager publiziert WorkspaceEvent::WindowAddedToWorkspace (und ggf. WindowRemovedFromWorkspace falls von einem anderen WS entfernt) über seinen EventPublisher.  
   * WorkspaceManager gibt Erfolg/Fehler an den Aufrufer (Systemschicht) zurück.  
   * UI-Schicht (als Subscriber) aktualisiert ggf. die Fensterliste für den aktiven Workspace.  
   * domain::window\_management (als Subscriber) könnte auf das Event reagieren, um das neue Fenster gemäß den Layout-Regeln des aktiven Workspace zu positionieren.  
3. **Laden der Workspace-Konfiguration beim Start des WorkspaceManager:**  
   * Eine übergeordnete Komponente (z.B. Desktop-Initialisierungsdienst) ruft WorkspaceManager::new(config\_provider, event\_publisher,...) auf.  
   * WorkspaceManager::new ruft config\_provider.load\_workspace\_config() (aus workspaces::config) auf.  
   * FilesystemConfigProvider::load\_workspace\_config (Implementierung von WorkspaceConfigProvider):  
     * Ruft core::config::ConfigService::read\_config\_file(...) auf, um Rohdaten zu laden.  
     * Deserialisiert die Rohdaten in ein WorkspaceSetSnapshot.  
     * Validiert den Snapshot (z.B. auf doppelte persistente IDs).  
     * Gibt Ok(snapshot) oder Err(WorkspaceConfigError) zurück.  
   * WorkspaceManager::new verarbeitet das Result:  
     * Bei Ok(snapshot): Erstellt Workspace-Instanzen aus den WorkspaceSnapshots, füllt self.workspaces und self.ordered\_workspace\_ids. Setzt self.active\_workspace\_id basierend auf snapshot.active\_workspace\_persistent\_id. Publiziere WorkspacesReloaded und ActiveWorkspaceChanged.  
     * Bei Err(WorkspaceConfigError::LoadError { source: CoreConfigError::NotFound,.. }) (oder ähnlicher Fehler, der "Datei nicht gefunden" anzeigt): Erstellt einen oder mehrere Standard-Workspaces, fügt sie hinzu, setzt einen als aktiv. Publiziere WorkspaceCreated und ActiveWorkspaceChanged.  
     * Bei anderen Err(config\_err): Gibt Err(WorkspaceManagerError::ConfigError(config\_err)) zurück.  
   * WorkspaceManager::new gibt Ok(self) oder Err(WorkspaceManagerError) an den Aufrufer zurück.

## **7\. Anhang: Referenzierte Richtlinien zur Fehlerbehandlung**

Dieser Anhang fasst die zentralen Prinzipien und Entscheidungen zur Fehlerbehandlung zusammen, die für die Implementierung der domain::workspaces-Komponente und darüber hinaus im gesamten Projekt gelten. Diese basieren auf Richtlinie 4.3 der Gesamtspezifikation und den Erkenntnissen aus der Analyse etablierter Rust-Fehlerbehandlungspraktiken.1

* **Verwendung von thiserror pro Modul:** Jedes Modul (z.B. workspaces::core, workspaces::assignment) definiert sein eigenes spezifisches Fehler-Enum unter Verwendung des thiserror-Crates. Dies reduziert Boilerplate und fördert klar definierte Fehlergrenzen zwischen Modulen.1  
* **Klare und kontextreiche Fehlernachrichten:** Jede Variante eines Fehler-Enums muss eine präzise, entwicklerorientierte Fehlermeldung über das \#\[error("...")\]-Attribut bereitstellen. Diese Nachricht sollte den Fehler eindeutig beschreiben.  
* **Fehlervarianten mit Datenanreicherung:** Wo immer es für die Fehlerdiagnose oder die programmatische Fehlerbehandlung durch den Aufrufer nützlich ist, sollen Fehlervarianten relevante Daten als Felder enthalten. Dies können ungültige Eingabewerte, Zustandsinformationen zum Zeitpunkt des Fehlers oder andere kontextrelevante Details sein. Dies hilft, das "Context Blurring"-Problem zu vermeiden, bei dem generische Fehler nicht genügend Informationen liefern.1  
* **Nutzung von \#\[from\] für Fehlerkonvertierung:** Das \#\[from\]-Attribut von thiserror soll verwendet werden, um Fehler aus abhängigen Modulen oder Bibliotheken einfach in den Fehlertyp des aktuellen Moduls zu konvertieren. Dies erleichtert die Fehlerpropagierung mit dem ?-Operator und stellt sicher, dass die std::error::Error::source()-Kette erhalten bleibt, sodass die ursprüngliche Fehlerursache zurückverfolgt werden kann.3  
* **Spezifische Varianten bei unzureichendem Kontext durch \#\[from\]:** Wenn ein via \#\[from\] gewrappter Fehler zu generisch ist und der spezifische Kontext der fehlgeschlagenen Operation im aktuellen Modul verloren ginge, soll eine spezifischere Fehlervariante im aktuellen Modul-Error-Enum erstellt werden. Diese spezifischere Variante sollte den ursprünglichen Fehler explizit über das \#\[source\]-Attribut einbetten und zusätzliche Felder für den Kontext der aktuellen Operation enthalten.  
* **Vermeidung von unwrap() und expect():** In Bibliotheks-, Kern- und Domänencode ist die Verwendung von unwrap() und expect() zur Fehlerbehandlung strikt zu vermeiden. Alle vorhersehbaren Fehler müssen über das Result\<T, E\>-Typsystem explizit behandelt und propagiert werden. Panics sind nur für nicht behebbare Fehler oder in Tests und Beispielen akzeptabel.1  
* **Semantik der Display-Implementierung:** Die durch \#\[error("...")\] generierte Display-Implementierung von Fehlern ist primär für Entwickler (Logging, Debugging) gedacht. Die Benutzeroberflächenschicht ist dafür verantwortlich, diese technischen Fehler – basierend auf der semantischen Bedeutung der jeweiligen Fehlervariante – in benutzerfreundliche und ggf. lokalisierte Nachrichten zu übersetzen.  
* **Umgang mit Fehlern aus externen Bibliotheken:** Fehler aus externen Bibliotheken (z.B. serde\_json::Error) sollten ebenfalls in die modul-spezifischen Fehler-Enums integriert werden, idealerweise unter Beibehaltung des Originalfehlers als source. Dies kann durch \#\[from\] oder durch eine Variante mit einem \#\[source\]-Feld geschehen. Die direkte Konvertierung des externen Fehlers in einen String sollte vermieden werden, wenn dadurch wertvolle Diagnoseinformationen verloren gehen.

Die konsequente Anwendung dieser Richtlinien ist entscheidend für die Entwicklung einer robusten, wartbaren und gut diagnostizierbaren Desktop-Umgebung. Sie stellt sicher, dass Fehler nicht verschleiert werden, sondern klar und mit ausreichend Kontext an die entsprechenden Stellen im System weitergeleitet werden können.

#### **Referenzen**

1. Error Handling for Large Rust Projects \- Best Practice in GreptimeDB, Zugriff am Mai 13, 2025, [https://greptime.com/blogs/2024-05-07-error-rust](https://greptime.com/blogs/2024-05-07-error-rust)  
2. Error handling \- good/best practices : r/rust \- Reddit, Zugriff am Mai 13, 2025, [https://www.reddit.com/r/rust/comments/1bb7dco/error\_handling\_goodbest\_practices/](https://www.reddit.com/r/rust/comments/1bb7dco/error_handling_goodbest_practices/)  
3. Error in std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/trait.Error.html](https://doc.rust-lang.org/std/error/trait.Error.html)  
4. std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/index.html](https://doc.rust-lang.org/std/error/index.html)

# **B3 Domänenschicht: Detaillierte Spezifikation – Teil 3/4: Benutzerzentrierte Dienste und Globale Einstellungsverwaltung**

Dieser Abschnitt des Dokuments setzt die detaillierte Spezifikation der Domänenschicht fort und konzentriert sich auf zwei Entwicklungsmodule: domain::user\_centric\_services und domain::global\_settings\_and\_state\_management. Diese Module sind entscheidend für die Implementierung intelligenter Benutzerinteraktionen, die Verwaltung von Benachrichtigungen und die Konfiguration des Desktops.  
---

**Entwicklungsmodul C: domain::user\_centric\_services**  
Dieses Modul bündelt die Logik für Dienste, die direkt auf die Bedürfnisse und Interaktionen des Benutzers ausgerichtet sind. Es umfasst die Verwaltung von KI-Interaktionen, einschließlich des Einwilligungsmanagements, sowie ein umfassendes Benachrichtigungssystem.  
**1\. Modulübersicht und Verantwortlichkeiten (domain::user\_centric\_services)**

* **Zweck:** Das Modul domain::user\_centric\_services dient als zentrale Komponente für die Orchestrierung von Benutzerinteraktionen, die über Standard-Desktop-Funktionen hinausgehen. Es stellt die Domänenlogik für KI-gestützte Assistenzfunktionen und ein robustes System zur Verwaltung von Benachrichtigungen bereit.  
* **Kernaufgaben:**  
  * **KI-Interaktionsmanagement:**  
    * Verwaltung des Lebenszyklus von KI-Interaktionskontexten.  
    * Implementierung der Logik für das Einholen, Speichern und Überprüfen von Benutzereinwilligungen (AIConsent) für die Nutzung von KI-Modellen und den Zugriff auf spezifische Datenkategorien (AIDataCategory).  
    * Verwaltung von Profilen verfügbarer KI-Modelle (AIModelProfile).  
    * Bereitstellung einer Schnittstelle zur Initiierung von KI-Aktionen und zur Verarbeitung von deren Ergebnissen, unabhängig vom spezifischen KI-Modell oder dem MCP-Protokoll (welches in der Systemschicht implementiert wird).  
  * **Benachrichtigungsmanagement:**  
    * Entgegennahme, Verarbeitung und Speicherung von Benachrichtigungen (Notification).  
    * Verwaltung des Zustands von Benachrichtigungen (aktiv, gelesen, abgewiesen).  
    * Implementierung einer Benachrichtigungshistorie mit konfigurierbarer Größe.  
    * Unterstützung für verschiedene Dringlichkeitsstufen (NotificationUrgency) und Aktionen (NotificationAction).  
    * Bereitstellung einer "Bitte nicht stören" (DND) Funktionalität.  
    * Ermöglichung des Filterns und Sortierens von Benachrichtigungen.  
* **Abgrenzung:**  
  * Dieses Modul implementiert *nicht* die UI-Elemente zur Darstellung von KI-Interaktionen oder Benachrichtigungen (dies ist Aufgabe der User Interface Layer).  
  * Es implementiert *nicht* die direkte Kommunikation mit KI-Modellen oder Systemdiensten wie dem D-Bus Notification Daemon (dies ist Aufgabe der System Layer). Es definiert die Logik und den Zustand, die von diesen Schichten genutzt werden.  
  * Die Persistenz von Einwilligungen oder Modellprofilen wird an die Core Layer (z.B. core::config) delegiert.  
* **Zugehörige Komponenten aus der Gesamtübersicht:** domain::ai, domain::notifications.

**2\. Datenstrukturen und Typdefinitionen (Rust) für domain::user\_centric\_services**  
Die folgenden Datenstrukturen definieren die Kernentitäten und Wertobjekte des Moduls. Sie sind so konzipiert, dass sie die notwendigen Informationen für die KI-Interaktions- und Benachrichtigungslogik kapseln.

* **2.1. Entitäten und Wertobjekte:**  
  * **AIInteractionContext (Entität):** Repräsentiert eine spezifische Interaktion oder einen Dialog mit einer KI.  
    * Attribute:  
      * id: Uuid (öffentlich): Eindeutiger Identifikator für den Kontext.  
      * creation\_timestamp: DateTime\<Utc\> (öffentlich): Zeitpunkt der Erstellung.  
      * active\_model\_id: Option\<String\> (öffentlich): ID des aktuell für diesen Kontext relevanten KI-Modells.  
      * consent\_status: AIConsentStatus (öffentlich): Aktueller Einwilligungsstatus für diesen Kontext.  
      * associated\_data\_categories: Vec\<AIDataCategory\> (öffentlich): Kategorien von Daten, die für diese Interaktion relevant sein könnten.  
      * interaction\_history: Vec\<String\> (privat, modifizierbar über Methoden): Eine einfache Historie der Konversation (z.B. Benutzeranfragen, KI-Antworten).  
      * attachments: Vec\<AttachmentData\> (öffentlich): Angehängte Daten (z.B. Dateipfade, Text-Snippets).  
    * Invarianten: id ist unveränderlich nach Erstellung. creation\_timestamp ist unveränderlich.  
    * Methoden (konzeptionell):  
      * new(relevant\_categories: Vec\<AIDataCategory\>) \-\> Self: Erstellt einen neuen Kontext.  
      * update\_consent\_status(\&mut self, status: AIConsentStatus): Aktualisiert den Einwilligungsstatus.  
      * set\_active\_model(\&mut self, model\_id: String): Legt das aktive Modell fest.  
      * add\_history\_entry(\&mut self, entry: String): Fügt einen Eintrag zur Historie hinzu.  
      * add\_attachment(\&mut self, attachment: AttachmentData): Fügt einen Anhang hinzu.  
  * **AIConsent (Entität):** Repräsentiert die Einwilligung eines Benutzers für eine spezifische Kombination aus KI-Modell und Datenkategorien.  
    * Attribute:  
      * id: Uuid (öffentlich): Eindeutiger Identifikator für die Einwilligung.  
      * user\_id: String (öffentlich, vereinfacht): Identifikator des Benutzers.  
      * model\_id: String (öffentlich): ID des KI-Modells, für das die Einwilligung gilt.  
      * data\_categories: Vec\<AIDataCategory\> (öffentlich): Datenkategorien, für die die Einwilligung erteilt wurde.  
      * granted\_timestamp: DateTime\<Utc\> (öffentlich): Zeitpunkt der Erteilung.  
      * expiry\_timestamp: Option\<DateTime\<Utc\>\> (öffentlich): Optionaler Ablaufzeitpunkt der Einwilligung.  
      * is\_revoked: bool (öffentlich, initial false): Gibt an, ob die Einwilligung widerrufen wurde.  
    * Invarianten: id, user\_id, model\_id, granted\_timestamp sind nach Erstellung unveränderlich. data\_categories sollten nach Erteilung nicht ohne Weiteres modifizierbar sein (neue Einwilligung erforderlich).  
    * Methoden (konzeptionell):  
      * new(user\_id: String, model\_id: String, categories: Vec\<AIDataCategory\>, expiry: Option\<DateTime\<Utc\>\>) \-\> Self.  
      * revoke(\&mut self): Markiert die Einwilligung als widerrufen.  
  * **AIModelProfile (Entität):** Beschreibt ein verfügbares KI-Modell.  
    * Attribute:  
      * model\_id: String (öffentlich): Eindeutiger Identifikator des Modells.  
      * display\_name: String (öffentlich): Anzeigename des Modells.  
      * description: String (öffentlich): Kurze Beschreibung des Modells.  
      * provider: String (öffentlich): Anbieter des Modells (z.B. "Local", "OpenAI").  
      * required\_consent\_categories: Vec\<AIDataCategory\> (öffentlich): Datenkategorien, für die dieses Modell typischerweise eine Einwilligung benötigt.  
      * capabilities: Vec\<String\> (öffentlich): Liste der Fähigkeiten des Modells (z.B. "text\_generation", "summarization").  
    * Invarianten: model\_id ist eindeutig und unveränderlich.  
    * Methoden (konzeptionell):  
      * new(...) \-\> Self.  
      * requires\_consent\_for(\&self, categories: &) \-\> bool: Prüft, ob für die gegebenen Kategorien eine Einwilligung erforderlich ist.  
  * **Notification (Entität):** Repräsentiert eine einzelne Benachrichtigung.  
    * Attribute:  
      * id: Uuid (öffentlich): Eindeutiger Identifikator.  
      * application\_name: String (öffentlich): Name der Anwendung, die die Benachrichtigung gesendet hat.  
      * application\_icon: Option\<String\> (öffentlich): Optionaler Pfad oder Name des Icons der Anwendung.  
      * summary: String (öffentlich): Kurze Zusammenfassung der Benachrichtigung.  
      * body: Option\<String\> (öffentlich): Detaillierterer Text der Benachrichtigung.  
      * actions: Vec\<NotificationAction\> (öffentlich): Verfügbare Aktionen für die Benachrichtigung.  
      * urgency: NotificationUrgency (öffentlich): Dringlichkeitsstufe.  
      * timestamp: DateTime\<Utc\> (öffentlich): Zeitpunkt des Eintreffens.  
      * is\_read: bool (privat, initial false): Status, ob gelesen.  
      * is\_dismissed: bool (privat, initial false): Status, ob vom Benutzer aktiv geschlossen.  
      * transient: bool (öffentlich, default false): Ob die Benachrichtigung flüchtig ist und nicht in der Historie verbleiben soll.  
    * Invarianten: id, timestamp sind unveränderlich. summary darf nicht leer sein.  
    * Methoden (konzeptionell):  
      * new(app\_name: String, summary: String, urgency: NotificationUrgency) \-\> Self.  
      * mark\_as\_read(\&mut self).  
      * dismiss(\&mut self).  
      * add\_action(\&mut self, action: NotificationAction).  
  * **NotificationAction (Wertobjekt):** Definiert eine Aktion, die im Kontext einer Benachrichtigung ausgeführt werden kann.  
    * Attribute:  
      * key: String (öffentlich): Eindeutiger Schlüssel für die Aktion (z.B. "reply", "archive").  
      * label: String (öffentlich): Anzeigename der Aktion.  
      * action\_type: NotificationActionType (öffentlich): Typ der Aktion (z.B. Callback, Link).  
  * **AttachmentData (Wertobjekt):** Repräsentiert angehängte Daten an einen AIInteractionContext.  
    * Attribute:  
      * id: Uuid (öffentlich): Eindeutiger Identifikator des Anhangs.  
      * mime\_type: String (öffentlich): MIME-Typ der Daten (z.B. "text/plain", "image/png").  
      * source\_uri: Option\<String\> (öffentlich): URI zur Quelle der Daten (z.B. file:///path/to/file).  
      * content: Option\<Vec\<u8\>\> (öffentlich): Direkter Inhalt der Daten, falls klein.  
      * description: Option\<String\> (öffentlich): Optionale Beschreibung des Anhangs.  
* **2.2. Modulspezifische Enums, Konstanten und Konfigurationsstrukturen:**  
  * **Enums:**  
    * AIConsentStatus: Enum (Granted, Denied, PendingUserAction, NotRequired).  
    * AIDataCategory: Enum (UserProfile, ApplicationUsage, FileSystemRead, ClipboardAccess, LocationData, GenericText, GenericImage).  
    * NotificationUrgency: Enum (Low, Normal, Critical).  
    * NotificationActionType: Enum (Callback, OpenLink).  
    * NotificationFilterCriteria: Enum (Unread, Application(String), Urgency(NotificationUrgency)).  
    * NotificationSortOrder: Enum (TimestampAscending, TimestampDescending, Urgency).  
  * **Konstanten:**  
    * const DEFAULT\_NOTIFICATION\_TIMEOUT\_SECS: u64 \= 5;  
    * const MAX\_NOTIFICATION\_HISTORY: usize \= 100;  
    * const MAX\_AI\_INTERACTION\_HISTORY: usize \= 50;  
* **2.3. Definition aller deklarierten Eigenschaften (Properties):**  
  * Für AIInteractionLogicService (als Trait implementiert):  
    * Keine direkten öffentlichen Eigenschaften, Zustand wird intern in der implementierenden Struktur gehalten (z.B. active\_contexts: HashMap\<Uuid, AIInteractionContext\>, consents: Vec\<AIConsent\>, model\_profiles: Vec\<AIModelProfile\>).  
  * Für NotificationService (als Trait implementiert):  
    * Keine direkten öffentlichen Eigenschaften, Zustand wird intern gehalten (z.B. active\_notifications: Vec\<Notification\>, history: VecDeque\<Notification\>, dnd\_enabled: bool).  
* **Wichtige Tabelle: Entitäten und Wertobjekte für domain::user\_centric\_services**

| Entität/Wertobjekt | Wichtige Attribute (Typ) | Kurzbeschreibung | Methoden (Beispiele) | Invarianten (Beispiele) |
| :---- | :---- | :---- | :---- | :---- |
| AIInteractionContext | id: Uuid, consent\_status: AIConsentStatus, associated\_data\_categories: Vec\<AIDataCategory\>, attachments: Vec\<AttachmentData\> | Repräsentiert eine laufende KI-Interaktion. | update\_consent\_status(), add\_attachment() | id ist unveränderlich. |
| AIConsent | model\_id: String, data\_categories: Vec\<AIDataCategory\>, granted\_timestamp: DateTime\<Utc\>, is\_revoked: bool | Speichert die Benutzereinwilligung für KI-Modell und Daten. | revoke() | model\_id, granted\_timestamp sind unveränderlich. |
| AIModelProfile | model\_id: String, display\_name: String, required\_consent\_categories: Vec\<AIDataCategory\>, capabilities: Vec\<String\> | Beschreibt ein verfügbares KI-Modell und dessen Anforderungen. | requires\_consent\_for() | model\_id ist eindeutig. |
| Notification | id: Uuid, summary: String, body: Option\<String\>, urgency: NotificationUrgency, is\_read: bool, actions: Vec\<NotificationAction\> | Repräsentiert eine System- oder Anwendungsbenachrichtigung. | mark\_as\_read(), dismiss(), add\_action() | id, timestamp sind unveränderlich. summary nicht leer. |
| NotificationAction | key: String, label: String, action\_type: NotificationActionType | Definiert eine ausführbare Aktion innerhalb einer Benachrichtigung. | \- | key ist eindeutig im Kontext der Benachrichtigung. |
| AttachmentData | id: Uuid, mime\_type: String, source\_uri: Option\<String\>, content: Option\<Vec\<u8\>\> | Repräsentiert angehängte Daten an einen AIInteractionContext. | \- | id ist eindeutig. Entweder source\_uri oder content sollte vorhanden sein. |

Diese tabellarische Übersicht fasst die zentralen Datenstrukturen zusammen. Die genaue Ausgestaltung der Attribute und Methoden ist für die korrekte Implementierung der Geschäftslogik entscheidend. Beispielsweise stellt die AIModelProfile-Struktur sicher, dass die Anforderungen eines Modells bezüglich der Dateneinwilligung klar definiert sind, was eine Kernanforderung für die KI-Integration darstellt.  
**3\. Öffentliche API und Interne Schnittstellen (Rust) für domain::user\_centric\_services**  
Die öffentliche API dieses Moduls wird durch Traits definiert, die von konkreten Service-Implementierungen erfüllt werden.

* **3.1. Exakte Signaturen aller öffentlichen Funktionen/Methoden:**  
  * **AIInteractionLogicService Trait:**  
    Rust  
    use crate::core::types::Uuid; // Standard Uuid Typ aus der Kernschicht  
    use crate::core::errors::CoreError; // Fehler aus der Kernschicht  
    use super::types::{AIInteractionContext, AIConsent, AIModelProfile, AIDataCategory, AttachmentData};  
    use super::errors::AIInteractionError;  
    use async\_trait::async\_trait;

    \#\[async\_trait\]  
    pub trait AIInteractionLogicService: Send \+ Sync {  
        /// Initiates a new AI interaction context.  
        /// Returns the ID of the newly created context.  
        async fn initiate\_interaction(  
            \&mut self,  
            relevant\_categories: Vec\<AIDataCategory\>,  
            initial\_attachments: Option\<Vec\<AttachmentData\>\>  
        ) \-\> Result\<Uuid, AIInteractionError\>;

        /// Retrieves an existing AI interaction context.  
        async fn get\_interaction\_context(\&self, context\_id: Uuid) \-\> Result\<AIInteractionContext, AIInteractionError\>;

        /// Provides or updates consent for a given interaction context and model.  
        async fn provide\_consent(  
            \&mut self,  
            context\_id: Uuid,  
            model\_id: String,  
            granted\_categories: Vec\<AIDataCategory\>,  
            consent\_decision: bool // true for granted, false for denied  
        ) \-\> Result\<(), AIInteractionError\>;

        /// Retrieves the consent status for a specific model and data categories,  
        /// potentially within an interaction context.  
        async fn get\_consent\_for\_model(  
            \&self,  
            model\_id: \&str,  
            data\_categories: &,  
            context\_id: Option\<Uuid\>  
        ) \-\> Result\<super::types::AIConsentStatus, AIInteractionError\>;

        /// Adds an attachment to an existing interaction context.  
        async fn add\_attachment\_to\_context(  
            \&mut self,  
            context\_id: Uuid,  
            attachment: AttachmentData  
        ) \-\> Result\<(), AIInteractionError\>;

        /// Lists all available and configured AI model profiles.  
        async fn list\_available\_models(\&self) \-\> Result\<Vec\<AIModelProfile\>, AIInteractionError\>;

        /// Stores a user's consent decision persistently.  
        /// This might be called after \`provide\_consent\` if the consent is to be remembered globally.  
        async fn store\_consent(\&self, consent: AIConsent) \-\> Result\<(), AIInteractionError\>;

        /// Retrieves all stored consents for a given user (simplified).  
        async fn get\_all\_user\_consents(\&self, user\_id: \&str) \-\> Result\<Vec\<AIConsent\>, AIInteractionError\>;

        /// Loads AI model profiles, e.g., from a configuration managed by core::config.  
        async fn load\_model\_profiles(\&mut self) \-\> Result\<(), AIInteractionError\>;  
    }

  * **NotificationService Trait:**  
    Rust  
    use crate::core::types::Uuid;  
    use crate::core::errors::CoreError;  
    use super::types::{Notification, NotificationUrgency, NotificationFilterCriteria, NotificationSortOrder};  
    use super::errors::NotificationError;  
    use async\_trait::async\_trait;

    \#\[async\_trait\]  
    pub trait NotificationService: Send \+ Sync {  
        /// Posts a new notification to the system.  
        /// Returns the ID of the newly created notification.  
        async fn post\_notification(\&mut self, notification\_data: Notification) \-\> Result\<Uuid, NotificationError\>;

        /// Retrieves a specific notification by its ID.  
        async fn get\_notification(\&self, notification\_id: Uuid) \-\> Result\<Notification, NotificationError\>;

        /// Marks a notification as read.  
        async fn mark\_as\_read(\&mut self, notification\_id: Uuid) \-\> Result\<(), NotificationError\>;

        /// Dismisses a notification, removing it from active view but possibly keeping it in history.  
        async fn dismiss\_notification(\&mut self, notification\_id: Uuid) \-\> Result\<(), NotificationError\>;

        /// Retrieves a list of currently active (not dismissed, potentially unread) notifications.  
        /// Allows filtering and sorting.  
        async fn get\_active\_notifications(  
            \&self,  
            filter: Option\<NotificationFilterCriteria\>,  
            sort\_order: Option\<NotificationSortOrder\>  
        ) \-\> Result\<Vec\<Notification\>, NotificationError\>;

        /// Retrieves the notification history.  
        /// Allows filtering and sorting.  
        async fn get\_notification\_history(  
            \&self,  
            limit: Option\<usize\>,  
            filter: Option\<NotificationFilterCriteria\>,  
            sort\_order: Option\<NotificationSortOrder\>  
        ) \-\> Result\<Vec\<Notification\>, NotificationError\>;

        /// Clears all notifications from history.  
        async fn clear\_history(\&mut self) \-\> Result\<(), NotificationError\>;

        /// Sets the "Do Not Disturb" mode.  
        async fn set\_do\_not\_disturb(\&mut self, enabled: bool) \-\> Result\<(), NotificationError\>;

        /// Checks if "Do Not Disturb" mode is currently enabled.  
        async fn is\_do\_not\_disturb\_enabled(\&self) \-\> Result\<bool, NotificationError\>;

        /// Invokes a specific action associated with a notification.  
        async fn invoke\_action(\&mut self, notification\_id: Uuid, action\_key: \&str) \-\> Result\<(), NotificationError\>;  
    }

* **3.2. Vor- und Nachbedingungen, Beschreibung der Logik/Algorithmen:**  
  * AIInteractionLogicService::provide\_consent:  
    * Vorbedingung: context\_id muss einen existierenden AIInteractionContext referenzieren. model\_id muss einem bekannten AIModelProfile entsprechen.  
    * Logik:  
      1. Kontext und Modellprofil laden.  
      2. Prüfen, ob die granted\_categories eine Untermenge der vom Modell potenziell benötigten Kategorien sind.  
      3. Einen neuen AIConsent-Eintrag erstellen oder einen bestehenden aktualisieren.  
      4. Den consent\_status im AIInteractionContext entsprechend anpassen.  
      5. Falls consent\_decision true ist und die Einwilligung global gespeichert werden soll, store\_consent() aufrufen.  
      6. AIConsentUpdatedEvent auslösen.  
    * Nachbedingung: Der Einwilligungsstatus des Kontexts ist aktualisiert. Ein AIConsent-Objekt wurde potenziell erstellt/modifiziert. Ein Event wurde ausgelöst.  
  * NotificationService::post\_notification:  
    * Vorbedingung: notification\_data.summary darf nicht leer sein.  
    * Logik:  
      1. Validieren der notification\_data.  
      2. Der Notification eine neue Uuid und einen timestamp zuweisen.  
      3. Wenn DND-Modus aktiv ist und die NotificationUrgency nicht Critical ist, die Benachrichtigung ggf. unterdrücken oder nur zur Historie hinzufügen, ohne sie aktiv anzuzeigen.  
      4. Die Benachrichtigung zur Liste der active\_notifications hinzufügen.  
      5. Wenn die Benachrichtigung nicht transient ist, sie zur history hinzufügen (unter Beachtung von MAX\_NOTIFICATION\_HISTORY).  
      6. NotificationPostedEvent auslösen (ggf. mit Information, ob sie aufgrund von DND unterdrückt wurde).  
    * Nachbedingung: Die Benachrichtigung ist im System registriert und ein Event wurde ausgelöst.  
* **3.3. Modulspezifische Trait-Definitionen und relevante Implementierungen:**  
  * AIInteractionLogicService und NotificationService sind die primären Traits.  
  * Implementierende Strukturen (z.B. DefaultAIInteractionLogicService, DefaultNotificationService) werden den Zustand halten (z.B. in HashMaps oder Vecs) und die Logik implementieren. Diese Strukturen sind nicht Teil der öffentlichen API, sondern interne Implementierungsdetails des Moduls.  
* **3.4. Exakte Definition aller Methoden für Komponenten mit komplexem internen Zustand oder Lebenszyklus:**  
  * DefaultAIInteractionLogicService:  
    * Hält intern Zustände wie active\_contexts: HashMap\<Uuid, AIInteractionContext\>, consents: Vec\<AIConsent\> (oder eine persistentere Speicherung über core::config), model\_profiles: Vec\<AIModelProfile\>.  
    * Die Methode load\_model\_profiles wäre typischerweise beim Start des Service aufgerufen, um die Profile aus einer Konfigurationsquelle zu laden.  
    * Die Methode store\_consent würde mit der Kernschicht interagieren, um Einwilligungen persistent zu machen.  
  * DefaultNotificationService:  
    * Hält intern Zustände wie active\_notifications: Vec\<Notification\>, history: VecDeque\<Notification\> (eine VecDeque ist hier passend für eine FIFO-artige Historie mit Limit), dnd\_enabled: bool, subscribers: Vec\<Weak\<dyn NotificationEventSubscriber\>\> (für den Event-Mechanismus, falls nicht über einen globalen Event-Bus gelöst).  
    * Methoden wie post\_notification und dismiss\_notification modifizieren diese Listen und müssen die Logik für die Historienbegrenzung und DND-Modus berücksichtigen.

**4\. Event-Spezifikationen für domain::user\_centric\_services**  
Events signalisieren Zustandsänderungen oder wichtige Ereignisse innerhalb des Moduls, die für andere Teile des Systems relevant sein können.

* **Event: AIInteractionInitiatedEvent**  
  * Event-Typ (Rust-Typ): pub struct AIInteractionInitiatedEvent { pub context\_id: Uuid, pub relevant\_categories: Vec\<AIDataCategory\> }  
  * Payload-Struktur: Enthält die ID des neuen Kontexts und die initial relevanten Datenkategorien.  
  * Typische Publisher: AIInteractionLogicService Implementierung.  
  * Typische Subscriber: UI-Komponenten, die eine KI-Interaktionsoberfläche öffnen oder vorbereiten; Logging-Systeme.  
  * Auslösebedingungen: Ein neuer AIInteractionContext wurde erfolgreich erstellt via initiate\_interaction.  
* **Event: AIConsentUpdatedEvent**  
  * Event-Typ (Rust-Typ): pub struct AIConsentUpdatedEvent { pub context\_id: Option\<Uuid\>, pub model\_id: String, pub granted\_categories: Vec\<AIDataCategory\>, pub consent\_status: AIConsentStatus }  
  * Payload-Struktur: Enthält die Kontext-ID (falls zutreffend), Modell-ID, die betroffenen Datenkategorien und den neuen Einwilligungsstatus.  
  * Typische Publisher: AIInteractionLogicService Implementierung.  
  * Typische Subscriber: UI-Komponenten, die den Einwilligungsstatus anzeigen oder Aktionen basierend darauf freischalten/sperren; die Komponente, die die eigentliche KI-Anfrage durchführt.  
  * Auslösebedingungen: Eine Einwilligung wurde erteilt, verweigert oder widerrufen (provide\_consent, store\_consent mit Widerruf).  
* **Event: NotificationPostedEvent**  
  * Event-Typ (Rust-Typ): pub struct NotificationPostedEvent { pub notification: Notification, pub suppressed\_by\_dnd: bool }  
  * Payload-Struktur: Enthält die vollständige Notification-Datenstruktur und ein Flag, ob sie aufgrund des DND-Modus unterdrückt wurde.  
  * Typische Publisher: NotificationService Implementierung.  
  * Typische Subscriber: UI-Schicht (zur Anzeige der Benachrichtigung), Systemschicht (z.B. um einen Ton abzuspielen, falls nicht unterdrückt).  
  * Auslösebedingungen: Eine neue Benachrichtigung wurde erfolgreich via post\_notification verarbeitet.  
* **Event: NotificationDismissedEvent**  
  * Event-Typ (Rust-Typ): pub struct NotificationDismissedEvent { pub notification\_id: Uuid }  
  * Payload-Struktur: Enthält die ID der entfernten Benachrichtigung.  
  * Typische Publisher: NotificationService Implementierung.  
  * Typische Subscriber: UI-Schicht (um die Benachrichtigung aus der aktiven Ansicht zu entfernen).  
  * Auslösebedingungen: Eine Benachrichtigung wurde erfolgreich via dismiss\_notification geschlossen.  
* **Event: NotificationReadEvent**  
  * Event-Typ (Rust-Typ): pub struct NotificationReadEvent { pub notification\_id: Uuid }  
  * Payload-Struktur: Enthält die ID der als gelesen markierten Benachrichtigung.  
  * Typische Publisher: NotificationService Implementierung.  
  * Typische Subscriber: UI-Schicht (um den "gelesen"-Status zu aktualisieren).  
  * Auslösebedingungen: Eine Benachrichtigung wurde erfolgreich via mark\_as\_read als gelesen markiert.  
* **Event: DoNotDisturbModeChangedEvent**  
  * Event-Typ (Rust-Typ): pub struct DoNotDisturbModeChangedEvent { pub dnd\_enabled: bool }  
  * Payload-Struktur: Enthält den neuen Status des DND-Modus.  
  * Typische Publisher: NotificationService Implementierung.  
  * Typische Subscriber: UI-Schicht (um ein Icon anzuzeigen), NotificationService selbst (um zukünftige Benachrichtigungen entsprechend zu behandeln).  
  * Auslösebedingungen: Der DND-Modus wurde via set\_do\_not\_disturb geändert.  
* **Wichtige Tabelle: Event-Spezifikationen für domain::user\_centric\_services**

| Event-Name/Typ (Rust) | Payload-Struktur (Felder, Typen) | Typische Publisher | Typische Subscriber | Auslösebedingungen |
| :---- | :---- | :---- | :---- | :---- |
| AIInteractionInitiatedEvent | context\_id: Uuid, relevant\_categories: Vec\<AIDataCategory\> | AIInteractionLogicService | UI für KI-Interaktion, Logging | Neuer AIInteractionContext erstellt. |
| AIConsentUpdatedEvent | context\_id: Option\<Uuid\>, model\_id: String, granted\_categories: Vec\<AIDataCategory\>, consent\_status: AIConsentStatus | AIInteractionLogicService | UI für Einwilligungsstatus, KI-Anfragekomponente | Einwilligung geändert (erteilt, verweigert, widerrufen). |
| NotificationPostedEvent | notification: Notification, suppressed\_by\_dnd: bool | NotificationService | UI zur Benachrichtigungsanzeige, System-Sound-Service | Neue Benachrichtigung verarbeitet. |
| NotificationDismissedEvent | notification\_id: Uuid | NotificationService | UI zur Benachrichtigungsanzeige | Benachrichtigung geschlossen. |
| NotificationReadEvent | notification\_id: Uuid | NotificationService | UI zur Benachrichtigungsanzeige | Benachrichtigung als gelesen markiert. |
| DoNotDisturbModeChangedEvent | dnd\_enabled: bool | NotificationService | UI (DND-Statusanzeige), NotificationService | DND-Modus geändert. |

Diese Event-Definitionen sind fundamental, um eine lose Kopplung zwischen diesem Domänenmodul und anderen Teilen des Systems, insbesondere der UI-Schicht, zu erreichen. Die UI kann auf diese Events reagieren, um sich dynamisch an Zustandsänderungen anzupassen, ohne die Interna dieses Moduls kennen zu müssen.  
**5\. Fehlerbehandlung (Rust mit thiserror) für domain::user\_centric\_services**  
Gemäß den Entwicklungsrichtlinien (Abschnitt 4.3) wird thiserror zur Definition spezifischer Fehler-Enums pro Sub-Modul verwendet. Dies ermöglicht eine klare und kontextbezogene Fehlerbehandlung.1

* **Definition der modulspezifischen Error-Enums:**  
  * AIInteractionError  
  * NotificationError  
* **Detaillierte Varianten, Nutzung von \#\[error(...)\] und \#\[from\]:**  
  * **AIInteractionError:**  
    Rust  
    use thiserror::Error;  
    use crate::core::types::Uuid; // Standard Uuid Typ aus der Kernschicht

    \#  
    pub enum AIInteractionError {  
        \#  
        ContextNotFound(Uuid),

        \#  
        ConsentAlreadyProvided(Uuid), // Spezifischer Fall, wenn ein erneutes explizites provide\_consent für bereits erteilte Zustimmung erfolgt

        \#\[error("Consent required for model '{model\_id}' but not granted for data categories: {missing\_categories:?}")\]  
        ConsentRequired { model\_id: String, missing\_categories: Vec\<String\> }, // String für AIDataCategory hier vereinfacht

        \#\[error("No suitable AI model available or configured.")\]  
        NoModelAvailable,

        \#\[error("AI Model '{model\_id}' not found or not configured.")\]  
        ModelNotFound(String),

        \#\[error("Invalid attachment data provided: {0}")\]  
        InvalidAttachment(String), // z.B. ungültiger Pfad, nicht unterstützter MIME-Typ

        \#\[error("Failed to store or retrieve consent: {0}")\]  
        ConsentStorageError(String), // Generisch für Fehler beim Speichern/Laden von AIConsent

        \#\[error("Failed to load AI model profiles: {0}")\]  
        ModelProfileLoadError(String),

        \#\[error("An underlying core error occurred: {source}")\]  
        CoreError { \#\[from\] source: crate::core::errors::CoreError }, // Annahme: Es gibt einen CoreError in der Kernschicht

        \#\[error("An unexpected internal error occurred: {0}")\]  
        InternalError(String),  
    }

  * **NotificationError:**  
    Rust  
    use thiserror::Error;  
    use crate::core::types::Uuid;

    \#  
    pub enum NotificationError {  
        \#  
        NotFound(Uuid),

        \# // z.B. leerer Summary  
        InvalidData{ summary: String, details: String },

        \#\[error("Maximum notification history of {max\_history} reached. Cannot add new notification: {summary}")\]  
        HistoryFull { max\_history: usize, summary: String },

        \#  
        ActionNotFound { notification\_id: Uuid, action\_id: String },

        \#\[error("An underlying core error occurred: {source}")\]  
        CoreError { \#\[from\] source: crate::core::errors::CoreError },

        \#\[error("An unexpected internal error occurred: {0}")\]  
        InternalError(String),  
    }

* **Spezifikation der Verwendung:**  
  * Diese Fehler werden als Err-Variante in Result\<T, E\>-Typen der öffentlichen API-Methoden der jeweiligen Services zurückgegeben.2  
  * Die \#\[from\]-Direktive wird genutzt, um Fehler aus der Kernschicht (z.B. CoreError beim Speichern/Laden von Konfigurationen für Einwilligungen oder Modellprofile) transparent in AIInteractionError oder NotificationError umzuwandeln. Dies erleichtert die Fehlerweitergabe (?-Operator) und erhält gleichzeitig die Fehlerquelle über die source()-Methode des std::error::Error-Traits.3  
  * Die \#\[error("...")\]-Nachrichten sind prägnant formuliert, um den Fehlerzustand klar zu beschreiben, wie in den Rust API Guidelines und 3 empfohlen (kleingeschrieben, ohne abschließende Interpunktion).  
  * Die Definition spezifischer Fehler-Enums pro logischem Service (AIInteractionError, NotificationError) folgt der Projektrichtlinie (4.3) und der Empfehlung aus 1, um Klarheit in der Fehlerbehandlung zu schaffen und es dem aufrufenden Code zu ermöglichen, spezifisch auf Fehlerfälle zu reagieren.  
  * Ein wichtiger Aspekt, der bei der Verwendung von thiserror mit \#\[from\] zu beachten ist, wurde in 2 hervorgehoben: Wenn mehrere Operationen innerhalb eines Services potenziell denselben *Basistyp* eines Fehlers aus einer unteren Schicht (z.B. std::io::Error, gekapselt in CoreError) für *unterschiedliche logische Fehlerfälle* im aktuellen Service erzeugen könnten, kann die alleinige Verwendung von \#\[from\] für eine generische CoreError-Variante den spezifischen Kontext verwischen.  
    * Beispiel: Sowohl das Speichern einer AIConsent als auch das Laden von AIModelProfile könnten intern eine CoreError::IoError verursachen. Wenn AIInteractionError nur CoreError { \#\[from\] source: CoreError } hätte, wäre aus dem Fehlertyp allein nicht ersichtlich, welche der beiden Operationen fehlgeschlagen ist.  
    * **Lösung und Spezifikation:** Für solche Fälle werden spezifischere Fehlervarianten ohne \#\[from\] für CoreError definiert, die stattdessen die CoreError (oder die relevante Information daraus) als Feld halten. Die \#\[error("...")\]-Nachricht dieser spezifischen Variante muss dann den Kontext klarstellen.  
      * Im obigen AIInteractionError sind ConsentStorageError(String) und ModelProfileLoadError(String) Beispiele dafür. Sie würden manuell in der Service-Logik konstruiert, z.B. indem ein von core::config zurückgegebener CoreError abgefangen und in diese spezifischeren Varianten umgewandelt wird, wobei die String-Payload die Details des Fehlers enthält.  
      * Die generische AIInteractionError::CoreError { \#\[from\] source: CoreError } Variante dient dann als Catch-All für andere, nicht spezifisch behandelte CoreError-Fälle aus diesem Service. Dies stellt sicher, dass der semantische Kontext des Domänenfehlers erhalten bleibt, während die Fehlerquelle (source()) weiterhin zugänglich ist, was für Debugging und Fehleranalyse von großer Bedeutung ist.2  
* **Wichtige Tabelle: Fehler-Enums für domain::user\_centric\_services**

| Fehler-Enum | Variante | \#\[error(...)\] Nachricht (Beispiel) | Felder (Typen) | Beschreibung / Auslösekontext |
| :---- | :---- | :---- | :---- | :---- |
| AIInteractionError | ContextNotFound | "AI interaction context not found for ID: {0}" | Uuid | Eine angeforderte AIInteractionContext ID existiert nicht. |
|  | ConsentRequired | "Consent required for model '{model\_id}' but not granted for data categories: {missing\_categories:?}" | model\_id: String, missing\_categories: Vec\<String\> | Für die geplante Aktion/Modell fehlt die notwendige Einwilligung. |
|  | ModelNotFound | "AI Model '{0}' not found or not configured." | String | Ein spezifisches KI-Modell wurde nicht gefunden oder ist nicht konfiguriert. |
|  | ConsentStorageError | "Failed to store or retrieve consent: {0}" | String | Fehler beim persistenten Speichern oder Laden einer AIConsent. |
|  | ModelProfileLoadError | "Failed to load AI model profiles: {0}" | String | Fehler beim Laden der AIModelProfile Konfigurationen. |
|  | CoreError | "An underlying core error occurred: {source}" | \#\[from\] source: crate::core::errors::CoreError | Ein nicht spezifisch behandelter Fehler aus der Kernschicht ist aufgetreten und wurde weitergeleitet. |
| NotificationError | NotFound | "Notification not found for ID: {0}" | Uuid | Eine angeforderte Benachrichtigungs-ID existiert nicht. |
|  | InvalidData | "Invalid notification data: {summary} (Details: {details})" | summary: String, details: String | Die übergebenen Daten zur Erstellung einer Benachrichtigung sind ungültig (z.B. leerer Summary). |
|  | HistoryFull | "Maximum notification history of {max\_history} reached. Cannot add new notification: {summary}" | max\_history: usize, summary: String | Das konfigurierte Benachrichtigungslimit in der Historie wurde erreicht. |
|  | ActionNotFound | "Action '{action\_id}' not found for notification ID: {notification\_id}" | notification\_id: Uuid, action\_id: String | Eine angeforderte Aktion für eine Benachrichtigung existiert nicht. |
|  | CoreError | "An underlying core error occurred: {source}" | \#\[from\] source: crate::core::errors::CoreError | Ein nicht spezifisch behandelter Fehler aus der Kernschicht ist aufgetreten und wurde weitergeleitet. |

Diese strukturierte Fehlerbehandlung ist für die Entwicklung robuster Software unerlässlich. Sie ermöglicht nicht nur eine präzise Fehlerdiagnose während der Entwicklung, sondern auch die Implementierung einer differenzierten Fehlerbehandlung im aufrufenden Code, bis hin zur Anzeige benutzerfreundlicher Fehlermeldungen in der UI.  
**6\. Detaillierte Implementierungsschritte und Dateistruktur für domain::user\_centric\_services**

* **6.1. Vorgeschlagene Dateistruktur:**  
  src/domain/user\_centric\_services/  
  ├── mod.rs               // Deklariert Submodule, exportiert öffentliche Typen/Traits  
  ├── ai\_interaction\_service.rs // Implementierung von AIInteractionLogicService (z.B. DefaultAIInteractionLogicService)  
  ├── notification\_service.rs   // Implementierung von NotificationService (z.B. DefaultNotificationService)  
  ├── types.rs             // Gemeinsame Enums (AIConsentStatus, AIDataCategory etc.) und Wertobjekte, Entitätsdefinitionen  
  └── errors.rs            // Definition von AIInteractionError und NotificationError

* **6.2. Nummerierte, schrittweise Anleitung zur Implementierung:**  
  1. **errors.rs erstellen:** Definieren Sie die AIInteractionError und NotificationError Enums mithilfe von thiserror wie im vorherigen Abschnitt spezifiziert. Stellen Sie sicher, dass sie Debug, Clone, PartialEq, Eq (falls für Testzwecke oder spezifische Logik benötigt) implementieren.  
  2. **types.rs erstellen:**  
     * Definieren Sie alle modulspezifischen Enums: AIConsentStatus, AIDataCategory, NotificationUrgency, NotificationActionType, NotificationFilterCriteria, NotificationSortOrder.  
     * Definieren Sie die Wertobjekte: NotificationAction, AttachmentData.  
     * Definieren Sie die Entitätsstrukturen: AIInteractionContext, AIConsent, AIModelProfile, Notification. Implementieren Sie für diese Debug, Clone, PartialEq und ggf. Serialize/Deserialize (von serde), falls sie direkt persistiert oder über IPC-Grenzen gesendet werden sollen. Fügen Sie Konstruktor-Methoden (new()) und andere relevante Logik direkt zu diesen Strukturen hinzu.  
  3. **ai\_interaction\_service.rs Basis:**  
     * Definieren Sie den Trait AIInteractionLogicService (wie in Abschnitt 3.1).  
     * Erstellen Sie eine Struktur DefaultAIInteractionLogicService. Diese Struktur wird Felder für den internen Zustand enthalten, z.B. active\_contexts: std::collections::HashMap\<Uuid, AIInteractionContext\>, consents: Vec\<AIConsent\> (oder eine Abstraktion für die Persistenz), model\_profiles: Vec\<AIModelProfile\>. Sie benötigt möglicherweise eine Abhängigkeit zu einer Komponente der Kernschicht für Persistenz.  
     * Beginnen Sie mit der Implementierung von \#\[async\_trait\] impl AIInteractionLogicService for DefaultAIInteractionLogicService {... }.  
  4. **notification\_service.rs Basis:**  
     * Definieren Sie den Trait NotificationService (wie in Abschnitt 3.1).  
     * Erstellen Sie eine Struktur DefaultNotificationService. Diese Struktur wird Felder für den internen Zustand enthalten, z.B. active\_notifications: Vec\<Notification\>, history: std::collections::VecDeque\<Notification\>, dnd\_enabled: bool.  
     * Beginnen Sie mit der Implementierung von \#\[async\_trait\] impl NotificationService for DefaultNotificationService {... }.  
  5. **Implementierung der AIInteractionLogicService-Methoden in DefaultAIInteractionLogicService:**  
     * Implementieren Sie jede Methode des Traits schrittweise. Achten Sie auf die korrekte Fehlerbehandlung und Rückgabe der definierten AIInteractionError-Varianten.  
     * Für Methoden, die Persistenz erfordern (z.B. store\_consent, load\_model\_profiles), definieren Sie die Interaktion mit der (noch abstrakten) Kernschichtkomponente.  
     * Stellen Sie sicher, dass die entsprechenden Events (z.B. AIInteractionInitiatedEvent, AIConsentUpdatedEvent) an den dafür vorgesehenen Stellen ausgelöst werden. Der genaue Mechanismus zur Event-Veröffentlichung (z.B. ein globaler Event-Bus, direkte Callbacks) muss projektweit definiert sein; hier wird nur das logische Auslösen spezifiziert.  
  6. **Implementierung der NotificationService-Methoden in DefaultNotificationService:**  
     * Implementieren Sie jede Methode des Traits. Achten Sie auf die Logik für DND, Historienbegrenzung (MAX\_NOTIFICATION\_HISTORY), Filterung und Sortierung.  
     * Verwenden Sie NotificationError-Varianten für Fehlerfälle.  
     * Lösen Sie die spezifizierten Notification-Events aus.  
  7. **mod.rs erstellen:**  
     * Deklarieren Sie die Submodule: pub mod errors;, pub mod types;, pub mod ai\_interaction\_service;, pub mod notification\_service;.  
     * Exportieren Sie die öffentlichen Typen, Traits und Fehler-Enums, die von außerhalb dieses Moduls verwendet werden sollen:  
       Rust  
       pub use errors::{AIInteractionError, NotificationError};  
       pub use types::{  
           AIInteractionContext, AIConsent, AIModelProfile, Notification, NotificationAction, AttachmentData,  
           AIConsentStatus, AIDataCategory, NotificationUrgency, NotificationActionType,  
           NotificationFilterCriteria, NotificationSortOrder  
       };  
       pub use ai\_interaction\_service::AIInteractionLogicService;  
       pub use notification\_service::NotificationService;

       // Optional: Konkrete Service-Typen exportieren, wenn sie direkt instanziiert werden sollen  
       // pub use ai\_interaction\_service::DefaultAIInteractionLogicService;  
       // pub use notification\_service::DefaultNotificationService;

  8. **Unit-Tests:** Schreiben Sie parallel zur Implementierung jeder Methode und jeder komplexen Logikeinheit Unit-Tests in den jeweiligen Service-Dateien (z.B. in einem \#\[cfg(test)\] mod tests {... } Block).

**7\. Interaktionen und Abhängigkeiten (domain::user\_centric\_services)**

* **Nutzung von Funktionalitäten der Kernschicht:**  
  * core::types: Verwendung von Uuid für eindeutige Identifikatoren und chrono::DateTime\<Utc\> für Zeitstempel.  
  * core::errors: Die CoreError-Typen der Kernschicht werden über \#\[from\] in die modulspezifischen Fehler AIInteractionError und NotificationError überführt, um Fehlerursachen aus der Kernschicht weiterzuleiten.  
  * core::config: Für das Laden von AIModelProfile-Konfigurationen und das persistente Speichern/Laden von AIConsent-Daten. Die Services in diesem Domänenmodul delegieren die eigentlichen Lese-/Schreiboperationen an die Kernschicht.  
  * core::logging: Das tracing-Framework wird innerhalb der Service-Implementierungen für strukturiertes Logging verwendet, um den Ablauf und mögliche Fehler nachvollziehen zu können.  
* **Schnittstellen zu System- und UI-Schicht:**  
  * Die definierten Traits AIInteractionLogicService und NotificationService stellen die primären Schnittstellen für höhere Schichten dar.  
  * Die **Systemschicht** wird diese Services nutzen:  
    * Der MCP-Client (in system::mcp) wird mit dem AIInteractionLogicService interagieren, um Einwilligungen zu prüfen und Interaktionskontexte zu verwalten.  
    * D-Bus Handler (in system::dbus), die z.B. den org.freedesktop.Notifications-Standard implementieren, werden den NotificationService verwenden, um Benachrichtigungen zu empfangen und Aktionen weiterzuleiten.  
  * Die **Benutzeroberflächenschicht (UI Layer)** wird ebenfalls mit diesen Services interagieren:  
    * UI-Komponenten für KI-Interaktionen (z.B. eine Befehlspalette oder ein Chat-Fenster) rufen Methoden des AIInteractionLogicService auf.  
    * Das ui::control\_center könnte Einstellungen für KI-Modelle oder Einwilligungen über den AIInteractionLogicService verwalten.  
    * Die Benachrichtigungsanzeige (ui::notifications) abonniert Events wie NotificationPostedEvent und ruft Methoden wie get\_active\_notifications oder mark\_as\_read des NotificationService auf.  
  * Events, die in diesem Domänenmodul ausgelöst werden (z.B. NotificationPostedEvent, AIConsentUpdatedEvent), werden primär von der UI-Schicht abonniert, um die Benutzeroberfläche entsprechend zu aktualisieren.  
* **Interaktionen mit anderen Modulen der Domänenschicht:**  
  * domain::global\_settings\_and\_state\_management: Globale Einstellungen, die das Verhalten der KI oder der Benachrichtigungen beeinflussen (z.B. Standard-KI-Modell, globale Einwilligungs-Standardeinstellungen, Standard-DND-Verhalten, maximale Historienlänge für Benachrichtigungen), könnten aus dem GlobalSettingsService gelesen werden. Änderungen an diesen Einstellungen könnten wiederum das Verhalten der Services in diesem Modul beeinflussen.  
  * domain::workspaces: Der AIInteractionContext könnte Informationen über den aktuellen Workspace (z.B. aktive Anwendung, Fenstertitel) enthalten, um den KI-Modellen besseren Kontext zu liefern. Diese Informationen würden vom AIInteractionLogicService aus dem domain::workspaces Modul bezogen.

**8\. Testaspekte für Unit-Tests (domain::user\_centric\_services)**  
Umfassende Unit-Tests sind entscheidend, um die Korrektheit der komplexen Logik in diesem Modul sicherzustellen.

* **Identifikation testkritischer Logik:**  
  * **AIInteractionLogicService:**  
    * Korrekte Erstellung, Aktualisierung und Abruf von AIInteractionContext.  
    * Logik der Einwilligungsprüfung (get\_consent\_for\_model), insbesondere die korrekte Auswertung von required\_consent\_categories der AIModelProfile gegen angefragte und erteilte AIDataCategory.  
    * Korrekte Erstellung und Speicherung (Mock) von AIConsent-Objekten.  
    * Laden und Filtern von AIModelProfile.  
    * Fehlerbehandlung für alle definierten AIInteractionError-Fälle.  
    * Korrekte Auslösung von Events.  
  * **NotificationService:**  
    * Korrekte Erstellung von Notification-Objekten und Zuweisung von IDs/Timestamps.  
    * Verwaltung der active\_notifications-Liste und der history-Deque, insbesondere die Einhaltung von MAX\_NOTIFICATION\_HISTORY.  
    * Logik des DND-Modus (Unterdrückung von Benachrichtigungen, Ausnahmen für Critical).  
    * Filter- und Sortierlogik für get\_active\_notifications und get\_notification\_history.  
    * Zustandsübergänge von Benachrichtigungen (is\_read, is\_dismissed).  
    * Korrekte Auslösung von Events.  
    * Fehlerbehandlung für alle definierten NotificationError-Fälle.  
* **Beispiele für Testfälle:**  
  * **AIInteractionLogicService Tests:**  
    * test\_initiate\_interaction\_creates\_context\_with\_unique\_id\_and\_fires\_event  
    * test\_provide\_consent\_granted\_updates\_context\_status\_and\_stores\_consent\_fires\_event  
    * test\_provide\_consent\_denied\_updates\_context\_status\_fires\_event  
    * test\_get\_consent\_for\_model\_no\_consent\_needed\_returns\_not\_required  
    * test\_get\_consent\_for\_model\_consent\_pending\_returns\_pending  
    * test\_get\_consent\_for\_model\_consent\_granted\_returns\_granted  
    * test\_get\_consent\_for\_model\_missing\_categories\_returns\_pending\_or\_error  
    * test\_list\_available\_models\_returns\_correctly\_loaded\_profiles  
    * test\_add\_attachment\_to\_context\_succeeds  
    * test\_get\_interaction\_context\_not\_found\_returns\_error  
    * test\_load\_model\_profiles\_error\_from\_core\_propagates\_as\_model\_profile\_load\_error  
  * **NotificationService Tests:**  
    * test\_post\_notification\_adds\_to\_active\_and\_history\_fires\_event  
    * test\_post\_notification\_when\_history\_full\_evicts\_oldest  
    * test\_post\_notification\_transient\_not\_added\_to\_history  
    * test\_post\_notification\_dnd\_active\_normal\_urgency\_suppressed\_fires\_event\_with\_suppressed\_flag  
    * test\_post\_notification\_dnd\_active\_critical\_urgency\_not\_suppressed  
    * test\_dismiss\_notification\_removes\_from\_active\_sets\_flag\_fires\_event  
    * test\_mark\_as\_read\_sets\_flag\_fires\_event  
    * test\_get\_active\_notifications\_filters\_unread\_correctly  
    * test\_get\_notification\_history\_sorted\_by\_timestamp\_descending  
    * test\_clear\_history\_empties\_history\_list  
    * test\_set\_do\_not\_disturb\_updates\_state\_and\_fires\_event  
    * test\_invoke\_action\_unknown\_notification\_id\_returns\_not\_found\_error  
    * test\_invoke\_action\_unknown\_action\_key\_returns\_action\_not\_found\_error  
* **Mocking:**  
  * Für Tests, die von der Kernschicht abhängen (z.B. core::config für das Laden/Speichern von AIConsent oder AIModelProfile), müssen Mocks dieser Kernschichtkomponenten erstellt werden. Dies kann durch Definition von Traits in der Kernschicht geschehen, die dann im Test durch Mock-Implementierungen ersetzt werden (z.B. mit dem mockall-Crate).  
  * Der Event-Mechanismus sollte ebenfalls mockbar sein, um zu überprüfen, ob Events korrekt ausgelöst werden.

---

**Entwicklungsmodul D: domain::global\_settings\_and\_state\_management**  
Dieses Modul ist für die Repräsentation, die Logik zur Verwaltung und die Konsistenz des globalen Zustands und der Einstellungen der Desktop-Umgebung zuständig, die nicht spezifisch einem anderen Domänenmodul zugeordnet sind oder von mehreren Modulen gemeinsam genutzt werden. Es fungiert als zentrale Anlaufstelle innerhalb der Domänenschicht für den Zugriff auf Konfigurationen und deren Modifikation.  
**1\. Modulübersicht und Verantwortlichkeiten (domain::global\_settings\_and\_state\_management)**

* **Zweck:** Bereitstellung einer kohärenten, typsicheren und validierten Abstraktion über die vielfältigen globalen Einstellungen und Zustände der Desktop-Umgebung. Dieses Modul definiert die "Quelle der Wahrheit" für diese Einstellungen innerhalb der Domänenschicht und stellt sicher, dass Änderungen konsistent angewendet und kommuniziert werden.  
* **Kernaufgaben:**  
  * Definition einer oder mehrerer umfassender Datenstrukturen (z.B. GlobalDesktopSettings), die alle globalen Desktop-Einstellungen kategorisiert repräsentieren (z.B. Erscheinungsbild, Verhalten, Eingabeoptionen, Energieverwaltungsrichtlinien, Standardanwendungen).  
  * Bereitstellung von Logik zur Validierung von Einstellungsänderungen anhand vordefinierter Regeln (z.B. Wertebereiche, gültige Optionen).  
  * Verwaltung des Lebenszyklus dieser Einstellungen: Laden von Standardwerten, Initialisierung aus persistenten Speichern (Delegation an die Kernschicht) und Persistierung von Änderungen.  
  * Benachrichtigung anderer Systemteile (innerhalb der Domänenschicht sowie höhere Schichten) über erfolgte Einstellungsänderungen mittels eines Event-Mechanismus.  
  * Verwaltung von globalen, nicht-persistenten Zuständen, die für die Dauer einer Benutzersitzung relevant sind und nicht direkt durch Systemdienste wie logind abgedeckt werden (z.B. ein anwendungsdefinierter "Desktop gesperrt"-Zustand, falls komplexere Logik als reine Sitzungssperrung benötigt wird).  
* **Abgrenzung:**  
  * Dieses Modul implementiert **nicht** die grafische Benutzeroberfläche zur Darstellung oder Änderung der Einstellungen. Diese Aufgabe obliegt der Komponente ui::control\_center in der Benutzeroberflächenschicht.  
  * Es implementiert **nicht** die tatsächliche Speicherung und das Laden von Konfigurationsdateien vom Dateisystem. Diese Low-Level-Operationen werden an eine Komponente der Kernschicht (z.B. core::config) delegiert. Das domain::global\_settings\_and\_state\_management-Modul definiert *was* gespeichert wird, die Struktur der Daten und die Regeln für deren Gültigkeit.  
  * Es verwaltet **keine** anwendungsspezifischen Einstellungen einzelner Drittanwendungen. Der Fokus liegt auf den globalen Einstellungen der Desktop-Umgebung selbst.  
* **Zugehörige Komponenten aus der Gesamtübersicht:** domain::settings.

**2\. Datenstrukturen und Typdefinitionen (Rust) für domain::global\_settings\_and\_state\_management**  
Die Datenstrukturen sind darauf ausgelegt, eine breite Palette von Einstellungen hierarchisch und typsicher abzubilden. Alle Einstellungsstrukturen müssen serde::Serialize und serde::Deserialize implementieren, um die Interaktion mit der Persistenzschicht (core::config) und die Verarbeitung von Einstellungsänderungen über serde\_json::Value zu ermöglichen.

* **2.1. Entitäten und Wertobjekte (primär Konfigurationsstrukturen):**  
  * **GlobalDesktopSettings (Hauptstruktur):**  
    Rust  
    use serde::{Serialize, Deserialize};  
    // Annahme: Pfade zu untergeordneten Typen sind korrekt  
    // use super::types::{AppearanceSettings, WorkspaceSettings,...};

    \#  
    pub struct GlobalDesktopSettings {  
        \#\[serde(default)\]  
        pub appearance: AppearanceSettings,  
        \#\[serde(default)\]  
        pub workspace\_config: WorkspaceSettings, // Umbenannt von workspace\_settings zur Klarheit (Konfiguration vs. Laufzeit)  
        \#\[serde(default)\]  
        pub input\_behavior: InputBehaviorSettings,  
        \#\[serde(default)\]  
        pub power\_management\_policy: PowerManagementPolicySettings,  
        \#\[serde(default)\]  
        pub default\_applications: DefaultApplicationsSettings,  
        // Weitere Kategorien können hier hinzugefügt werden, z.B.:  
        // \#\[serde(default)\]  
        // pub accessibility: AccessibilitySettings,  
        // \#\[serde(default)\]  
        // pub privacy: PrivacySettings,  
    }

    Die Verwendung von \#\[serde(default)\] stellt sicher, dass beim Deserialisieren einer unvollständigen Konfiguration die Standardwerte für fehlende Felder verwendet werden, was die Robustheit gegenüber Konfigurationsänderungen über Versionen hinweg erhöht.  
  * **AppearanceSettings:**  
    * Attribute:  
      * active\_theme\_name: String (z.B. "Adwaita-dark", "Nordic")  
      * color\_scheme: ColorScheme (Enum: Light, Dark, AutoSystem)  
      * accent\_color\_token: String (CSS-Token-Name, z.B. "--accent-blue", "--accent-custom-hexFFA07A")  
      * font\_settings: FontSettings  
      * icon\_theme\_name: String (z.B. "Papirus", "Numix")  
      * cursor\_theme\_name: String (z.B. "Adwaita", "Bibata-Modern-Ice")  
      * enable\_animations: bool  
      * interface\_scaling\_factor: f64 (z.B. 1.0, 1.25, 2.0; Validierung: \> 0.0)  
    * Methoden (konzeptionell): validate() prüft die Gültigkeit der Werte (z.B. Skalierungsfaktor \> 0).  
  * **WorkspaceSettings (Domänenlogik für Einstellungen, nicht der Workspace-Manager selbst):**  
    * Attribute:  
      * dynamic\_workspaces: bool (Workspaces werden bei Bedarf erstellt/entfernt)  
      * default\_workspace\_count: u8 (Nur relevant, wenn dynamic\_workspaces false ist; Validierung: \> 0\)  
      * workspace\_switching\_behavior: WorkspaceSwitchingBehavior (Enum: WrapAround, StopAtEdges)  
      * show\_workspace\_indicator: bool (Ob ein Indikator (z.B. im Panel) angezeigt wird)  
  * **FontSettings:**  
    * Attribute:  
      * default\_font\_family: String (z.B. "Noto Sans", "Cantarell")  
      * default\_font\_size: u8 (in Punkten, z.B. 10, 11; Validierung: z.B. 6-72)  
      * monospace\_font\_family: String (z.B. "Fira Code", "DejaVu Sans Mono")  
      * document\_font\_family: String (z.B. "Liberation Serif")  
      * hinting: FontHinting (Enum: None, Slight, Medium, Full)  
      * antialiasing: FontAntialiasing (Enum: None, Grayscale, Rgba)  
  * **InputBehaviorSettings:**  
    * Attribute:  
      * mouse\_acceleration\_profile: MouseAccelerationProfile (Enum: Flat, Adaptive, Custom(f32))  
      * mouse\_sensitivity: f32 (Validierung: z.B. 0.1 \- 10.0)  
      * natural\_scrolling\_mouse: bool  
      * natural\_scrolling\_touchpad: bool  
      * tap\_to\_click\_touchpad: bool  
      * touchpad\_pointer\_speed: f32 (Validierung: z.B. 0.1 \- 10.0)  
      * keyboard\_repeat\_delay\_ms: u32 (Validierung: z.B. 100-2000)  
      * keyboard\_repeat\_rate\_cps: u32 (Zeichen pro Sekunde; Validierung: z.B. 10-100)  
  * **PowerManagementPolicySettings (High-Level Richtlinien, die systemnahe Implementierung erfolgt in der Systemschicht):**  
    * Attribute:  
      * screen\_blank\_timeout\_ac\_secs: u32 (0 für nie; Validierung: z.B. 0 oder \>= 60\)  
      * screen\_blank\_timeout\_battery\_secs: u32 (0 für nie; Validierung: z.B. 0 oder \>= 30\)  
      * suspend\_action\_on\_lid\_close\_ac: LidCloseAction (Enum: Suspend, Hibernate, Shutdown, DoNothing, LockScreen)  
      * suspend\_action\_on\_lid\_close\_battery: LidCloseAction  
      * automatic\_suspend\_delay\_ac\_secs: u32 (0 für nie)  
      * automatic\_suspend\_delay\_battery\_secs: u32 (0 für nie)  
      * show\_battery\_percentage: bool  
  * **DefaultApplicationsSettings:**  
    * Attribute:  
      * web\_browser\_desktop\_file: String (Name der.desktop-Datei, z.B. "firefox.desktop")  
      * email\_client\_desktop\_file: String (z.B. "thunderbird.desktop")  
      * terminal\_emulator\_desktop\_file: String (z.B. "org.gnome.Console.desktop")  
      * file\_manager\_desktop\_file: String (z.B. "org.gnome.Nautilus.desktop")  
      * music\_player\_desktop\_file: String  
      * video\_player\_desktop\_file: String  
      * image\_viewer\_desktop\_file: String  
      * text\_editor\_desktop\_file: String  
* **2.2. Modulspezifische Enums, Konstanten und Konfigurationsstrukturen:**  
  * **Enums (alle mit Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Default):**  
    * ColorScheme: \#\[default\] Light, Dark, AutoSystem.  
    * FontHinting: None, Slight, \#\[default\] Medium, Full.  
    * FontAntialiasing: None, Grayscale, \#\[default\] Rgba.  
    * MouseAccelerationProfile: \#\[default\] Adaptive, Flat, Custom(SerdeF32) (Wrapper für f32 für Default).  
    * LidCloseAction: \#\[default\] Suspend, Hibernate, Shutdown, LockScreen, DoNothing.  
    * WorkspaceSwitchingBehavior: \#\[default\] WrapAround, StopAtEdges.  
    * **Hilfsstruktur für f32 Default in Enums (da f32 nicht Eq ist):**  
      Rust  
      \#  
      pub struct SerdeF32(pub f32);  
      impl Default for SerdeF32 { fn default() \-\> Self { SerdeF32(1.0) } } // Beispiel-Default

  * **SettingPath (Strukturierter Enum für typsicheren Zugriff):**  
    Rust  
    \#  
    pub enum SettingPath {  
        Appearance(AppearanceSettingPath),  
        WorkspaceConfig(WorkspaceSettingPath),  
        InputBehavior(InputBehaviorSettingPath),  
        PowerManagementPolicy(PowerManagementPolicySettingPath),  
        DefaultApplications(DefaultApplicationsSettingPath),  
        // Weitere Top-Level Kategorien  
    }

    \#  
    pub enum AppearanceSettingPath {  
        ActiveThemeName, ColorScheme, AccentColorToken,  
        FontSettings(FontSettingPath), // Verschachtelt  
        IconThemeName, CursorThemeName, EnableAnimations, InterfaceScalingFactor,  
    }

    \#  
    pub enum FontSettingPath { // Beispiel für weitere Verschachtelung  
        DefaultFontFamily, DefaultFontSize, MonospaceFontFamily, DocumentFontFamily, Hinting, Antialiasing,  
    }  
    // Ähnliche Enums für WorkspaceSettingPath, InputBehaviorSettingPath etc. definieren.  
    // Diese Struktur ermöglicht eine präzise Adressierung einzelner Einstellungen.  
    // Für die Implementierung von \`get\_setting\` und \`update\_setting\` ist eine  
    // Konvertierung von/zu String-basierten Pfaden (z.B. "appearance.font\_settings.default\_font\_size")  
    // oder eine direkte Verarbeitung dieser Enum-Pfade erforderlich.

    Die SettingPath-Struktur ist entscheidend für die update\_setting-Methode, da sie eine typsichere und explizite Weise bietet, auf spezifische Einstellungen zuzugreifen, anstatt fehleranfällige String-Pfade zu verwenden.  
* **2.3. Definition aller deklarierten Eigenschaften (Properties):**  
  * Für GlobalSettingsService (als Trait implementiert):  
    * current\_settings: GlobalDesktopSettings (logisch): Der aktuelle Satz aller globalen Einstellungen. Der Zugriff erfolgt über Methoden wie get\_current\_settings() oder get\_setting(\&SettingPath). Modifikationen erfolgen über update\_setting(...).  
* **Wichtige Tabelle: Ausgewählte globale Einstellungen und ihre Eigenschaften**

| Struktur/Kategorie | Attribut/Einstellung | Rust-Typ | Standardwert (Beispiel) | Beschreibung / Gültigkeitsbereich / Validierungsregeln (Beispiele) |
| :---- | :---- | :---- | :---- | :---- |
| AppearanceSettings | active\_theme\_name | String | "default\_light\_theme" | Name des aktuell aktiven GTK-Themes. Muss ein installierter Theme-Name sein. |
|  | color\_scheme | ColorScheme | AutoSystem | Bevorzugtes Farbschema (Hell, Dunkel, Systemeinstellung folgen). |
|  | accent\_color\_token | String | "--accent-blue" | CSS-Token-Name der Akzentfarbe (z.B. "--accent-color-1"). |
|  | enable\_animations | bool | true | Ob Desktop-Animationen (Fenster, Übergänge etc.) aktiviert sind. |
|  | interface\_scaling\_factor | f64 | 1.0 | Globaler Skalierungsfaktor für die UI. Validierung: 0.5 \<= x \<= 3.0. |
| FontSettings | default\_font\_family | String | "Cantarell" | Standard-Schriftart für UI-Elemente. Muss eine installierte Schriftart sein. |
|  | default\_font\_size | u8 | 11 | Standard-Schriftgröße in Punkten. Validierung: 6 \<= size \<= 72\. |
| InputBehaviorSettings | natural\_scrolling\_touchpad | bool | true | Ob natürliches Scrollen (Inhaltsbewegung mit Fingerbewegung) für Touchpads aktiviert ist. |
|  | tap\_to\_click\_touchpad | bool | true | Ob Tippen zum Klicken für Touchpads aktiviert ist. |
|  | keyboard\_repeat\_delay\_ms | u32 | 500 | Verzögerung in ms bis Tastenwiederholung einsetzt. Validierung: 100 \<= delay \<= 2000\. |
| PowerManagementPolicySettings | screen\_blank\_timeout\_ac\_secs | u32 | 600 (10 Min.) | Timeout in Sekunden bis Bildschirmabschaltung im Netzbetrieb. 0 für nie. Validierung: 0 oder 30 \<= secs \<= 7200\. |
|  | suspend\_action\_on\_lid\_close\_battery | LidCloseAction | Suspend | Aktion beim Schließen des Laptop-Deckels im Akkubetrieb. |
| DefaultApplicationsSettings | web\_browser\_desktop\_file | String | "firefox.desktop" | Name der.desktop-Datei des Standard-Webbrowsers. Muss eine gültige, installierte.desktop-Datei sein. |

Diese Tabelle hebt einige der wichtigsten konfigurierbaren Aspekte des Desktops hervor. Die Definition von Standardwerten und Validierungsregeln ist entscheidend für die Robustheit des Systems und eine gute Benutzererfahrung, da sie ungültige Konfigurationen verhindert.  
**3\. Öffentliche API und Interne Schnittstellen (Rust) für domain::global\_settings\_and\_state\_management**  
Die öffentliche API wird durch den GlobalSettingsService-Trait definiert.

* **3.1. Exakte Signaturen aller öffentlichen Funktionen/Methoden:**  
  * **GlobalSettingsService Trait:**  
    Rust  
    use crate::core::errors::CoreError;  
    use super::types::{GlobalDesktopSettings, SettingPath}; // SettingPath wie oben definiert  
    use super::errors::GlobalSettingsError;  
    use async\_trait::async\_trait;  
    use serde\_json::Value as JsonValue; // Alias für Klarheit

    // SubscriptionId für das Abbestellen von Änderungen  
    // pub type SubscriptionId \= Uuid; // Beispiel

    \#\[async\_trait\]  
    pub trait GlobalSettingsService: Send \+ Sync {  
        /// Lädt die Einstellungen aus der persistenten Speicherung (via Kernschicht).  
        /// Falls keine Konfiguration vorhanden ist oder Fehler auftreten, werden Standardwerte verwendet  
        /// und ggf. eine Fehlermeldung geloggt oder ein spezifischer Fehler zurückgegeben.  
        async fn load\_settings(\&mut self) \-\> Result\<(), GlobalSettingsError\>;

        /// Speichert die aktuellen Einstellungen persistent (via Kernschicht).  
        async fn save\_settings(\&self) \-\> Result\<(), GlobalSettingsError\>;

        /// Gibt eine (tiefe) Kopie der aktuellen \`GlobalDesktopSettings\` zurück.  
        fn get\_current\_settings(\&self) \-\> GlobalDesktopSettings;

        /// Aktualisiert eine spezifische Einstellung unter dem gegebenen \`SettingPath\`.  
        /// Der \`value\`-Parameter ist ein \`serde\_json::Value\`, um Flexibilität zu gewährleisten.  
        /// Interne Logik muss diesen Wert in den korrekten Rust-Typ der Zieleinstellung  
        /// deserialisieren und validieren.  
        async fn update\_setting(  
            \&mut self,  
            path: SettingPath,  
            value: JsonValue  
        ) \-\> Result\<(), GlobalSettingsError\>;

        /// Gibt den Wert einer spezifischen Einstellung unter dem gegebenen \`SettingPath\`  
        /// als \`serde\_json::Value\` zurück.  
        fn get\_setting(\&self, path: \&SettingPath) \-\> Result\<JsonValue, GlobalSettingsError\>;

        /// Setzt alle Einstellungen auf ihre definierten Standardwerte zurück.  
        /// Die Änderungen werden anschließend persistent gespeichert.  
        async fn reset\_to\_defaults(\&mut self) \-\> Result\<(), GlobalSettingsError\>;

        // Die Implementierung von \`subscribe\_to\_setting\_changes\` und \`unsubscribe\`  
        // ist komplex und hängt stark vom gewählten Event-Mechanismus des Projekts ab.  
        // Für eine erste Iteration könnte ein globales \`SettingChangedEvent\` ausreichen,  
        // das den Pfad und den neuen Wert enthält.  
        //  
        // async fn subscribe\_to\_setting\_changes(  
        //     \&self,  
        //     path\_filter: Option\<SettingPath\>, // None für alle Änderungen  
        //     // Der Callback erhält den Pfad und den neuen Wert  
        //     callback: Box\<dyn Fn(SettingPath, JsonValue) \+ Send \+ Sync \+ 'static\>  
        // ) \-\> Result\<SubscriptionId, GlobalSettingsError\>;  
        //  
        // async fn unsubscribe(\&self, id: SubscriptionId) \-\> Result\<(), GlobalSettingsError\>;  
    }

* **3.2. Vor- und Nachbedingungen, Beschreibung der Logik/Algorithmen:**  
  * GlobalSettingsService::update\_setting(path: SettingPath, value: JsonValue):  
    * Vorbedingung:  
      * path muss auf eine gültige, existierende Einstellung innerhalb der GlobalDesktopSettings-Struktur verweisen.  
      * value (JsonValue) muss in den Ziel-Rust-Typ der durch path adressierten Einstellung deserialisierbar sein.  
      * Der deserialisierte Wert muss alle anwendungsspezifischen Validierungsregeln für diese Einstellung erfüllen (z.B. Wertebereich, gültige Enum-Variante).  
    * Logik:  
      1. **Pfad-Navigation:** Navigiere innerhalb der intern gehaltenen GlobalDesktopSettings-Instanz zum durch path spezifizierten Feld. Dies erfordert eine Mapping-Logik vom SettingPath-Enum zu den tatsächlichen Struct-Feldern.  
      2. **Typ-Prüfung und Deserialisierung:** Ermittle den erwarteten Rust-Typ des Zielfeldes. Versuche, das JsonValue in diesen Typ zu deserialisieren (z.B. serde\_json::from\_value::\<TargetType\>(value)).  
         * Bei Fehlschlag: Rückgabe von GlobalSettingsError::InvalidValueType mit Details zum erwarteten und erhaltenen Typ.  
      3. **Validierung:** Führe spezifische Validierungsregeln für die Einstellung durch. Diese Regeln sind Teil der Domänenlogik (z.B. appearance.interface\_scaling\_factor muss zwischen 0.5 und 3.0 liegen).  
         * Bei Fehlschlag: Rückgabe von GlobalSettingsError::ValidationError mit einer beschreibenden Nachricht.  
      4. **Aktualisierung:** Wenn Deserialisierung und Validierung erfolgreich waren, aktualisiere den Wert des Zielfeldes in der internen GlobalDesktopSettings-Instanz.  
      5. **Event-Auslösung:** Löse ein SettingChangedEvent aus, das den path und das (ggf. serialisierte) new\_value enthält, um andere Systemteile zu informieren.  
      6. **Persistenz (optional, konfigurierbar):** Rufe intern save\_settings() auf, um die Änderung sofort persistent zu machen. Alternativ könnten Änderungen gesammelt und später oder auf explizite Anforderung gespeichert werden, um die I/O-Last zu reduzieren. Für eine Desktop-Umgebung ist eine zeitnahe Persistenz meist erwünscht.  
    * Nachbedingung:  
      * Entweder wurde die Einstellung erfolgreich aktualisiert, ein SettingChangedEvent wurde ausgelöst und die Änderung wurde (ggf.) persistiert.  
      * Oder es wurde ein GlobalSettingsError (z.B. PathNotFound, InvalidValueType, ValidationError) zurückgegeben, und der Zustand der Einstellungen bleibt unverändert.  
  * GlobalSettingsService::load\_settings():  
    * Vorbedingung: Keine spezifischen, außer dass der Service initialisiert ist.  
    * Logik:  
      1. Interagiere mit der Kernschicht-Komponente (z.B. core::config), um die GlobalDesktopSettings-Struktur aus einem persistenten Speicher (z.B. Konfigurationsdatei) zu laden.  
      2. Die Kernschicht-Komponente ist für die Deserialisierung der Daten verantwortlich.  
      3. **Fehlerbehandlung beim Laden:**  
         * Wenn die Konfigurationsdatei nicht existiert oder nicht lesbar ist: Verwende die Default::default()-Implementierung von GlobalDesktopSettings (oder eine explizite Methode zur Erzeugung von Standardwerten). Logge eine Warnung.  
         * Wenn die Konfigurationsdatei korrupt ist oder nicht deserialisiert werden kann: Verwende Standardwerte. Logge einen Fehler. GlobalSettingsError::PersistenceError könnte zurückgegeben werden, oder der Service initialisiert sich mit Defaults und loggt den Fehler. Für eine robuste Nutzererfahrung ist das Laden von Defaults oft besser als ein harter Fehler.  
         * Wenn die geladene Konfiguration veraltet ist (z.B. Felder fehlen): serde füllt dank \#\[serde(default)\] fehlende Felder mit ihren Standardwerten auf.  
      4. Speichere die geladenen (oder Standard-) Einstellungen in der internen Instanz von GlobalDesktopSettings.  
      5. Löse ein SettingsLoadedEvent mit den initialisierten Einstellungen aus.  
    * Nachbedingung: Die interne GlobalDesktopSettings-Instanz des Service ist mit den geladenen oder Standardeinstellungen initialisiert. Ein SettingsLoadedEvent wurde ausgelöst.  
* **3.3. Modulspezifische Trait-Definitionen und relevante Implementierungen:**  
  * Der GlobalSettingsService-Trait ist die zentrale öffentliche Schnittstelle.  
  * Alle Einstellungsstrukturen (GlobalDesktopSettings, AppearanceSettings, etc.) müssen std::fmt::Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize und Default implementieren.  
    * Serialize und Deserialize sind fundamental für die Interaktion mit core::config (Persistenz) und für die update\_setting/get\_setting-API, die serde\_json::Value verwendet.  
    * Default ist wichtig für die Erzeugung von Standardkonfigurationen und für \#\[serde(default)\].  
    * PartialEq ist nützlich für Tests und um festzustellen, ob sich ein Wert tatsächlich geändert hat.  
* **3.4. Exakte Definition aller Methoden für Komponenten mit komplexem internen Zustand oder Lebenszyklus:**  
  * Die Hauptkomponente mit komplexem Zustand ist die Implementierung von GlobalSettingsService (z.B. DefaultGlobalSettingsService). Diese Struktur hält die current\_settings: GlobalDesktopSettings als ihren primären Zustand.  
  * Die Komplexität in den Methoden update\_setting und get\_setting liegt in der robusten und korrekten Handhabung des SettingPath:  
    * **Pfad-Auflösung:** Eine effiziente Methode, um von einem SettingPath-Enum-Wert auf das entsprechende Feld in der verschachtelten GlobalDesktopSettings-Struktur zuzugreifen und dessen Typ zu kennen. Dies könnte über match-Anweisungen oder eine komplexere Makro-basierte Lösung erfolgen, um Boilerplate-Code zu reduzieren.  
    * **Dynamische Typkonvertierung:** Die Konvertierung zwischen serde\_json::Value und den stark typisierten Rust-Feldern erfordert sorgfältige Fehlerbehandlung bei der Deserialisierung.  
    * **Validierungslogik:** Die Implementierung der spezifischen Validierungsregeln für jede Einstellung.

**4\. Event-Spezifikationen für domain::global\_settings\_and\_state\_management**  
Events dienen der Benachrichtigung anderer Systemkomponenten über Änderungen an den globalen Einstellungen.

* **Event: SettingChangedEvent**  
  * Event-Typ (Rust-Typ): pub struct SettingChangedEvent { pub path: SettingPath, pub new\_value: JsonValue }  
  * Payload-Struktur: Enthält den SettingPath der geänderten Einstellung und deren neuen Wert als JsonValue. Die Verwendung von JsonValue hier bietet Flexibilität, da der Subscriber den Wert bei Bedarf in den spezifischen Typ deserialisieren kann.  
  * Typische Publisher: Die Implementierung von GlobalSettingsService (nach einem erfolgreichen Aufruf von update\_setting oder reset\_to\_defaults).  
  * Typische Subscriber:  
    * ui::control\_center: Um die Anzeige der Einstellungen in der UI zu aktualisieren.  
    * domain::theming\_engine: Um auf Änderungen in AppearanceSettings (z.B. active\_theme\_name, accent\_color\_token) zu reagieren und das Theme dynamisch neu zu laden/anzuwenden.  
    * system::compositor: Könnte auf Änderungen wie appearance.enable\_animations oder appearance.interface\_scaling\_factor reagieren.  
    * Andere Domänenmodule oder Systemdienste, deren Verhalten von globalen Einstellungen abhängt (z.B. system::input für Mausempfindlichkeit, system::outputs für Standard-Bildschirmhelligkeit basierend auf Energieeinstellungen).  
  * Auslösebedingungen: Eine einzelne Einstellung wurde erfolgreich geändert und validiert. Bei reset\_to\_defaults wird für jede geänderte Einstellung ein separates Event ausgelöst oder ein übergreifendes "Reset"-Event.  
* **Event: SettingsLoadedEvent**  
  * Event-Typ (Rust-Typ): pub struct SettingsLoadedEvent { pub settings: GlobalDesktopSettings }  
  * Payload-Struktur: Enthält eine Kopie der vollständig geladenen GlobalDesktopSettings.  
  * Typische Publisher: Die Implementierung von GlobalSettingsService (nach einem erfolgreichen Aufruf von load\_settings während der Initialisierung).  
  * Typische Subscriber: Initialisierungscode anderer Module, die auf die ersten geladenen Einstellungen warten, um sich zu konfigurieren. UI-Komponenten, um ihren initialen Zustand zu setzen.  
  * Auslösebedingungen: Die globalen Einstellungen wurden erfolgreich initial aus dem persistenten Speicher geladen oder mit Standardwerten initialisiert.  
* **Event: SettingsSavedEvent**  
  * Event-Typ (Rust-Typ): pub struct SettingsSavedEvent; (Kann leer sein, da der reine Akt des Speicherns signalisiert wird. Optional könnten Details wie der Zeitpunkt oder Erfolg/Misserfolg von Teiloperationen enthalten sein, falls relevant.)  
  * Payload-Struktur: In der Regel keine, dient als reines Signal.  
  * Typische Publisher: Die Implementierung von GlobalSettingsService (nach einem erfolgreichen Aufruf von save\_settings).  
  * Typische Subscriber: Logging-Systeme; UI-Komponenten, die dem Benutzer eine kurze Bestätigung anzeigen könnten (z.B. "Einstellungen gespeichert").  
  * Auslösebedingungen: Die aktuellen globalen Einstellungen wurden erfolgreich in den persistenten Speicher geschrieben.  
* **Wichtige Tabelle: Event-Spezifikationen für domain::global\_settings\_and\_state\_management**

| Event-Name/Typ (Rust) | Payload-Struktur (Felder, Typen) | Typische Publisher | Typische Subscriber | Auslösebedingungen |
| :---- | :---- | :---- | :---- | :---- |
| SettingChangedEvent | path: SettingPath, new\_value: JsonValue | GlobalSettingsService | ui::control\_center, domain::theming\_engine, system::compositor, andere Module, die von Einstellungen abhängen | Eine spezifische Einstellung wurde erfolgreich geändert und validiert. |
| SettingsLoadedEvent | settings: GlobalDesktopSettings | GlobalSettingsService | Initialisierungscode von Modulen, UI-Komponenten für initialen Zustand | Globale Einstellungen wurden beim Start erfolgreich geladen oder mit Standardwerten initialisiert. |
| SettingsSavedEvent | (Normalerweise keine, oder Details zum Speichervorgang) | GlobalSettingsService | Logging-Systeme, UI für Feedback | Aktuelle globale Einstellungen wurden erfolgreich persistent gespeichert. |

Diese Event-Struktur ist entscheidend für die Reaktionsfähigkeit und Konsistenz der Desktop-Umgebung. Sie ermöglicht es verschiedenen Teilen des Systems, auf Änderungen der globalen Konfiguration zu reagieren, ohne direkt an den GlobalSettingsService gekoppelt zu sein.  
**5\. Fehlerbehandlung (Rust mit thiserror) für domain::global\_settings\_and\_state\_management**  
Die Fehlerbehandlung folgt den etablierten Projektrichtlinien unter Verwendung von thiserror.

* **Definition des modulspezifischen Error-Enums:**  
  * GlobalSettingsError  
* **Detaillierte Varianten, Nutzung von \#\[error(...)\] und \#\[from\]:**  
  Rust  
  use thiserror::Error;  
  use crate::core::errors::CoreError; // Fehler aus der Kernschicht  
  use super::types::SettingPath; // Annahme: SettingPath implementiert Display oder wird hier formatiert  
  use serde\_json::Error as SerdeJsonError; // Für die Kapselung von serde\_json Fehlern

  // Wrapper für serde\_json::Error, um es Cloneable etc. zu machen, falls GlobalSettingsError das sein muss.  
  // Alternativ kann man auch nur die String-Repräsentation des Fehlers speichern.  
  \#  
  \#  
  pub struct WrappedSerdeJsonError(\#\[from\] SerdeJsonError);

  // Um Clone, PartialEq, Eq für WrappedSerdeJsonError zu ermöglichen, wenn benötigt:  
  // impl Clone for WrappedSerdeJsonError { fn clone(\&self) \-\> Self { WrappedSerdeJsonError(self.0.to\_string()) } } // Vereinfacht  
  // impl PartialEq for WrappedSerdeJsonError { fn eq(\&self, other: \&Self) \-\> bool { self.0.to\_string() \== other.0.to\_string() } }  
  // impl Eq for WrappedSerdeJsonError {}

  \# // Clone, PartialEq, Eq können hinzugefügt werden, wenn die Fehler verglichen werden müssen.  
                         // Dies erfordert, dass alle \#\[source\] Fehler dies ebenfalls unterstützen oder gewrapped werden.  
  pub enum GlobalSettingsError {  
      \#  
      PathNotFound { path\_description: String }, // String-Repräsentation des SettingPath

      \#\[error("Invalid value type provided for setting '{path\_description}'. Expected '{expected\_type}', but got value '{actual\_value\_preview}'.")\]  
      InvalidValueType {  
          path\_description: String,  
          expected\_type: String,  
          actual\_value\_preview: String, // Eine kurze Vorschau des fehlerhaften JSON-Wertes  
      },

      \#\[error("Validation failed for setting '{path\_description}': {message}")\]  
      ValidationError { path\_description: String, message: String },

      \#  
      SerializationError {  
          path\_description: String,  
          \#\[source\] source: WrappedSerdeJsonError,  
      },

      \#  
      DeserializationError {  
          path\_description: String,  
          \#\[source\] source: WrappedSerdeJsonError,  
      },

      // Spezifischer Fehler für Persistenzprobleme, der die CoreError kapselt  
      \#\[error("Persistence error ({operation}) for settings: {message}")\]  
      PersistenceError {  
          operation: String, // "load" oder "save"  
          message: String,  
          \#\[source\] source: Option\<CoreError\>, // CoreError ist hier optional, da der Fehler auch direkt hier entstehen kann  
      },

      // Generischer Fallback für andere CoreErrors, die nicht durch PersistenceError abgedeckt sind  
      \#\[error("An underlying core error occurred: {source}")\]  
      CoreError { \#\[from\] source: CoreError },

      \#\[error("An unexpected internal error occurred in settings management: {0}")\]  
      InternalError(String),  
  }

  // Implementierung, um aus einem serde\_json::Error und Kontext einen GlobalSettingsError zu machen  
  impl GlobalSettingsError {  
      pub fn from\_serde\_deserialize(err: SerdeJsonError, path: \&SettingPath) \-\> Self {  
          GlobalSettingsError::DeserializationError {  
              path\_description: format\!("{:?}", path), // Bessere Formatierung für SettingPath wäre hier gut  
              source: WrappedSerdeJsonError(err),  
          }  
      }  
      pub fn from\_serde\_serialize(err: SerdeJsonError, path: \&SettingPath) \-\> Self {  
          GlobalSettingsError::SerializationError {  
              path\_description: format\!("{:?}", path),  
              source: WrappedSerdeJsonError(err),  
          }  
      }  
  }

  Die WrappedSerdeJsonError-Struktur dient dazu, serde\_json::Error zu kapseln, da dieser Typ selbst nicht unbedingt alle Traits implementiert (wie Clone oder Eq), die für GlobalSettingsError gewünscht sein könnten. Die from\_serde\_deserialize und from\_serde\_serialize Hilfsmethoden erleichtern die Konvertierung.  
* **Spezifikation der Verwendung:**  
  * GlobalSettingsError wird als Err-Variante in den Result-Typen der Methoden des GlobalSettingsService zurückgegeben.  
  * \#\[from\] für CoreError wird für die generische CoreError-Variante verwendet, um nicht anderweitig behandelte Fehler von der Kernschicht (z.B. beim tatsächlichen Lesen/Schreiben von Dateien durch core::config) zu konvertieren.  
  * Die spezifische Variante PersistenceError wird für Fehler verwendet, die direkt beim Laden oder Speichern der Einstellungen auftreten und eine CoreError als Ursache haben können. Dies gibt mehr Kontext als ein generischer CoreError.  
  * SerializationError und DeserializationError kapseln Fehler von serde\_json, die bei der Konvertierung von/zu JsonValue oder beim Speichern/Laden auftreten können.  
  * Die Fehler-Enums und ihre Varianten sind so gestaltet, dass sie den Empfehlungen aus 2 und 1 folgen: spezifische Fehler pro Modul, klare \#\[error(...)\]-Nachrichten und die Möglichkeit des Fehler-Chainings mittels \#\[source\].  
  * Die Granularität der Fehlervarianten wie InvalidValueType und ValidationError ist besonders hervorzuheben. Sie sind nicht nur für das Logging und Debugging durch Entwickler von Bedeutung, sondern können auch dazu dienen, der Benutzeroberflächenschicht (ui::control\_center) präzise Informationen zu liefern, warum eine Einstellungsänderung fehlgeschlagen ist. Beispielsweise kann die UI die path\_description verwenden, um das fehlerhafte Eingabefeld hervorzuheben, und die message aus ValidationError direkt dem Benutzer anzeigen. Dies verbessert die Benutzererfahrung erheblich im Vergleich zu generischen Fehlermeldungen und ist ein direktes Ergebnis der Überlegung, Fehler so zu gestalten, dass sie die Perspektive des Benutzers berücksichtigen, wie in 2 angedeutet ("What happens from the user's perspective.").  
* **Wichtige Tabelle: Fehler-Enum GlobalSettingsError**

| Fehler-Enum | Variante | \#\[error(...)\] Nachricht (Beispiel) | Felder (Typen) | Beschreibung / Auslösekontext |
| :---- | :---- | :---- | :---- | :---- |
| GlobalSettingsError | PathNotFound | "Setting path not found: {path\_description}" | path\_description: String | Der angegebene SettingPath zu einer Einstellung existiert nicht in der GlobalDesktopSettings-Struktur. |
|  | InvalidValueType | "Invalid value type provided for setting '{path\_description}'. Expected '{expected\_type}', got '{actual\_value\_preview}'." | path\_description: String, expected\_type: String, actual\_value\_preview: String | Der für eine Einstellung übergebene JsonValue konnte nicht in den erwarteten Rust-Typ deserialisiert werden. |
|  | ValidationError | "Validation failed for setting '{path\_description}': {message}" | path\_description: String, message: String | Der Wert für eine Einstellung ist zwar vom korrekten Typ, aber ungültig gemäß den Domänenregeln (z.B. außerhalb des erlaubten Wertebereichs). |
|  | SerializationError | "Serialization error for setting '{path\_description}': {source}" | path\_description: String, source: WrappedSerdeJsonError | Fehler bei der Serialisierung eines Einstellungs-Wertes nach JsonValue (z.B. für die get\_setting-Methode oder Event-Payloads). |
|  | DeserializationError | "Deserialization error for setting '{path\_description}': {source}" | path\_description: String, source: WrappedSerdeJsonError | Fehler bei der Deserialisierung eines JsonValue in einen Rust-Typ (z.B. in update\_setting oder beim Laden aus der Kernschicht). |
|  | PersistenceError | "Persistence error ({operation}) for settings: {message}" | operation: String, message: String, source: Option\<CoreError\> | Ein Fehler ist beim Laden ("load") oder Speichern ("save") der Einstellungen durch die Kernschicht aufgetreten. |
|  | CoreError | "An underlying core error occurred: {source}" | \#\[from\] source: CoreError | Ein allgemeiner, nicht spezifisch durch PersistenceError abgedeckter Fehler aus der Kernschicht ist aufgetreten und wurde weitergeleitet. |

Diese detaillierte Fehlerklassifizierung ist für ein robustes Einstellungsmanagement unerlässlich. Sie ermöglicht es aufrufendem Code, differenziert auf Probleme zu reagieren und dem Benutzer kontextsensitive Rückmeldungen zu geben.  
**6\. Detaillierte Implementierungsschritte und Dateistruktur für domain::global\_settings\_and\_state\_management**

* **6.1. Vorgeschlagene Dateistruktur:**  
  src/domain/global\_settings\_management/ // Alternativ: src/domain/settings/  
  ├── mod.rs               // Deklariert Submodule, exportiert öffentliche Typen/Traits  
  ├── service.rs           // Implementierung des GlobalSettingsService (z.B. DefaultGlobalSettingsService)  
  ├── types.rs             // Definition von GlobalDesktopSettings und allen untergeordneten Einstellungs-Structs und \-Enums  
  ├── paths.rs             // Definition von SettingPath und ggf. Hilfsfunktionen zur Pfad-Konvertierung/Navigation  
  └── errors.rs            // Definition von GlobalSettingsError und WrappedSerdeJsonError

* **6.2. Nummerierte, schrittweise Anleitung zur Implementierung:**  
  1. **errors.rs erstellen:** Definieren Sie GlobalSettingsError und die Hilfsstruktur WrappedSerdeJsonError wie im vorherigen Abschnitt spezifiziert.  
  2. **types.rs erstellen:**  
     * Definieren Sie die Hauptstruktur GlobalDesktopSettings.  
     * Definieren Sie alle untergeordneten Einstellungs-Structs (AppearanceSettings, FontSettings, WorkspaceSettings, etc.).  
     * Definieren Sie alle zugehörigen Enums (ColorScheme, FontHinting, LidCloseAction, etc.).  
     * Implementieren Sie für alle diese Strukturen und Enums die notwendigen Traits: Debug, Clone, PartialEq, Serialize, Deserialize und Default. Achten Sie auf die korrekte Verwendung von \#\[serde(default)\] für Felder in Strukturen und \#\[default\] für Enum-Varianten.  
     * Implementieren Sie Default für GlobalDesktopSettings und alle ihre Felder, um einen vollständigen Satz von Standardeinstellungen zu definieren.  
  3. **paths.rs erstellen:**  
     * Definieren Sie die SettingPath-Enum-Hierarchie (z.B. SettingPath, AppearanceSettingPath, FontSettingPath, etc.) wie skizziert.  
     * Implementieren Sie Serialize und Deserialize für SettingPath, falls es über Events oder APIs in serialisierter Form verwendet wird.  
     * Optional: Entwickeln Sie Hilfsfunktionen oder Makros, die das Navigieren in einer GlobalDesktopSettings-Instanz basierend auf einem SettingPath erleichtern oder die Konvertierung zu/von einem String-basierten Pfad (z.B. "appearance.font\_settings.default\_font\_size") ermöglichen.  
  4. **service.rs Basis:**  
     * Definieren Sie den Trait GlobalSettingsService (wie in Abschnitt 3.1).  
     * Erstellen Sie eine Struktur DefaultGlobalSettingsService. Diese wird eine Instanz von GlobalDesktopSettings als internen Zustand halten: settings: GlobalDesktopSettings.  
     * Diese Struktur benötigt eine Abhängigkeit zu einer Komponente der Kernschicht (z.B. einem ConfigManager Trait), um Einstellungen zu laden und zu speichern. Diese Abhängigkeit sollte über den Konstruktor injiziert werden.  
     * Beginnen Sie mit der Implementierung von \#\[async\_trait\] impl GlobalSettingsService for DefaultGlobalSettingsService {... }.  
  5. **Implementierung der GlobalSettingsService-Methoden in DefaultGlobalSettingsService:**  
     * load\_settings: Implementieren Sie die Logik zum Laden der GlobalDesktopSettings von der Kernschicht-Abhängigkeit. Behandeln Sie Fehler beim Laden (Datei nicht vorhanden, korrupt) durch Rückgriff auf GlobalDesktopSettings::default(). Lösen Sie das SettingsLoadedEvent aus.  
     * save\_settings: Implementieren Sie die Logik zum Speichern der aktuellen internen settings über die Kernschicht-Abhängigkeit. Lösen Sie das SettingsSavedEvent aus.  
     * get\_current\_settings: Gibt einen Klon der internen settings-Instanz zurück.  
     * update\_setting: Dies ist die komplexeste Methode.  
       * Implementieren Sie die Pfad-Navigationslogik, um das spezifische Feld innerhalb von self.settings basierend auf dem SettingPath zu identifizieren.  
       * Deserialisieren Sie das JsonValue in den Zieltyp.  
       * Führen Sie die Validierung durch.  
       * Bei Erfolg: Aktualisieren Sie das Feld, lösen Sie das SettingChangedEvent aus und rufen Sie self.save\_settings().await auf.  
       * Geben Sie bei Fehlern die entsprechenden GlobalSettingsError-Varianten zurück.  
     * get\_setting: Implementieren Sie die Pfad-Navigation und serialisieren Sie den gefundenen Wert nach JsonValue.  
     * reset\_to\_defaults: Setzen Sie self.settings \= GlobalDesktopSettings::default();. Lösen Sie für jede (geänderte) Einstellung ein SettingChangedEvent aus (oder ein globales Reset-Event). Rufen Sie self.save\_settings().await auf.  
  6. **mod.rs erstellen:** Deklarieren Sie die Submodule (errors, types, paths, service) und exportieren Sie alle öffentlichen Typen, Traits und Fehler, die von anderen Teilen des Systems verwendet werden sollen.  
  7. **Unit-Tests:** Schreiben Sie umfassende Unit-Tests parallel zur Implementierung jeder Methode. Testen Sie insbesondere die Pfad-Navigation, (De-)Serialisierung, Validierungslogik und Fehlerfälle in update\_setting und get\_setting. Mocken Sie die Kernschicht-Abhängigkeit für Lade-/Speicheroperationen.

**7\. Interaktionen und Abhängigkeiten (domain::global\_settings\_and\_state\_management)**

* **Nutzung von Funktionalitäten der Kernschicht:**  
  * core::config (oder eine äquivalente Komponente/Trait): Dies ist die Hauptabhängigkeit für die Persistenz. Der GlobalSettingsService delegiert das tatsächliche Lesen von und Schreiben in Konfigurationsdateien (oder andere Speicherorte) an diese Kernschichtkomponente. Der Service stellt die Logik und die Datenstruktur (GlobalDesktopSettings) bereit, während core::config die I/O-Operationen und die (De-)Serialisierung von/zu einem bestimmten Dateiformat (z.B. TOML, JSON) übernimmt.  
  * core::errors: CoreError-Typen, die von core::config zurückgegeben werden (z.B. I/O-Fehler, Formatierungsfehler), werden in spezifischere GlobalSettingsError::PersistenceError oder die generische GlobalSettingsError::CoreError Variante umgewandelt.  
  * core::logging: Das tracing-Framework wird für internes Logging verwendet, z.B. um das Laden von Einstellungen, aufgetretene Fehler oder erfolgreiche Speicheroperationen zu protokollieren.  
* **Schnittstellen zu System- und UI-Schicht:**  
  * ui::control\_center: Dies ist der primäre Konsument des GlobalSettingsService in der UI-Schicht. Das Control Center wird:  
    * get\_current\_settings() oder multiple get\_setting() Aufrufe verwenden, um die aktuellen Werte für die Anzeige zu laden.  
    * update\_setting() aufrufen, wenn der Benutzer eine Einstellung ändert.  
    * Das SettingChangedEvent abonnieren, um die UI dynamisch zu aktualisieren, falls Einstellungen anderweitig (z.B. durch reset\_to\_defaults oder programmatisch) geändert werden.  
  * **Systemschicht-Komponenten:** Verschiedene Komponenten der Systemschicht können Einstellungen aus dem GlobalSettingsService lesen, um ihr Verhalten anzupassen:  
    * system::compositor: Könnte AppearanceSettings.enable\_animations, AppearanceSettings.interface\_scaling\_factor oder InputBehaviorSettings.mouse\_acceleration\_profile lesen.  
    * system::input: Könnte Einstellungen für Tastaturwiederholrate, Mausempfindlichkeit oder Touchpad-Verhalten (InputBehaviorSettings) anwenden.  
    * system::outputs (Display-Management): Könnte Standardwerte für Bildschirmhelligkeit oder Timeouts bis zum Blanking des Bildschirms aus PowerManagementPolicySettings beziehen.  
    * system::audio: Könnte eine globale Lautstärkeeinstellung oder Standardausgabegeräte hierüber beziehen, falls solche Einstellungen als global definiert werden.  
* **Interaktionen mit anderen Modulen der Domänenschicht:**  
  * domain::theming\_engine: Ein sehr enger Konsument. Liest alle relevanten AppearanceSettings (Theme-Name, Akzentfarbe, Schriftarten, Icons, Cursor) und muss auf SettingChangedEvent für diese Pfade reagieren, um das Desktop-Theme dynamisch neu zu generieren und anzuwenden.  
  * domain::workspace\_and\_window\_policy (oder domain::workspaces und domain::window\_management): Liest WorkspaceSettings (z.B. dynamische Workspaces) und relevante InputBehaviorSettings (z.B. Mausverhalten für Fensterinteraktionen).  
  * domain::user\_centric\_services: Könnte globale Standardeinstellungen für KI-Interaktionen (z.B. default\_ai\_model\_id, falls als globale Einstellung definiert) oder Benachrichtigungen (z.B. global\_do\_not\_disturb\_default\_state, max\_notification\_history\_override) aus dem GlobalSettingsService beziehen.

**8\. Testaspekte für Unit-Tests (domain::global\_settings\_and\_state\_management)**  
Die Testbarkeit dieses Moduls ist entscheidend für die Stabilität der gesamten Desktop-Umgebung.

* **Identifikation testkritischer Logik:**  
  * Die korrekte Deserialisierung von JsonValue in den spezifischen Rust-Typ der Zieleinstellung und die anschließende Validierung dieses Wertes in update\_setting. Dies umfasst die Behandlung von Typ-Mismatch und Wertebereichsverletzungen.  
  * Die korrekte Navigation zu verschachtelten Feldern innerhalb der GlobalDesktopSettings-Struktur mittels SettingPath in update\_setting und get\_setting.  
  * Die Fehlerbehandlung für ungültige Pfade (PathNotFound), falsche Wertetypen (InvalidValueType) und ungültige Werte (ValidationError).  
  * Die Logik zum Laden von Standardwerten (Default::default()) und das korrekte Mergen mit einer möglicherweise unvollständigen, aber gültigen Konfiguration aus dem persistenten Speicher (Sicherstellung, dass \#\[serde(default)\] wie erwartet funktioniert).  
  * Die korrekte Auslösung von SettingChangedEvent mit dem korrekten SettingPath und JsonValue als Payload nach einer erfolgreichen Aktualisierung.  
  * Die Interaktion mit der (gemockten) core::config-Schicht für Lade- und Speicheroperationen, einschließlich der korrekten Fehlerweitergabe.  
  * Die Funktionalität von reset\_to\_defaults.  
* **Beispiele für Testfälle:**  
  * test\_load\_settings\_new\_system\_uses\_defaults\_and\_fires\_loaded\_event  
  * test\_load\_settings\_existing\_config\_loads\_correctly\_and\_fires\_loaded\_event  
  * test\_load\_settings\_partial\_config\_fills\_missing\_with\_defaults  
  * test\_load\_settings\_corrupted\_config\_falls\_back\_to\_defaults\_logs\_error (benötigt Mock für core::config, der Fehler simuliert)  
  * test\_update\_setting\_valid\_value\_updates\_internal\_state\_fires\_changed\_event\_and\_saves  
  * test\_update\_setting\_valid\_value\_for\_nested\_path  
  * test\_update\_setting\_invalid\_json\_type\_returns\_invalid\_value\_type\_error (z.B. String für boolesches Feld)  
  * test\_update\_setting\_value\_violates\_validation\_rule\_returns\_validation\_error (z.B. Schriftgröße 200, wenn max 72\)  
  * test\_update\_setting\_nonexistent\_path\_returns\_path\_not\_found\_error  
  * test\_get\_setting\_existing\_path\_returns\_correct\_value\_as\_json  
  * test\_get\_setting\_nonexistent\_path\_returns\_path\_not\_found\_error  
  * test\_reset\_to\_defaults\_restores\_all\_settings\_fires\_changed\_events\_and\_saves  
  * Für jede Einstellungsstruktur (AppearanceSettings, etc.): Testen der (De-)Serialisierungslogik (serde) und der Default-Implementierung.  
  * Testen der SettingPath-Navigation: Sicherstellen, dass jeder definierte Pfad korrekt auf ein Feld zugreift.  
* **Mocking:**  
  * Eine Mock-Implementierung für die von core::config bereitgestellte Schnittstelle (z.B. ein trait ConfigPersistence) ist unerlässlich. Diese Mock-Implementierung muss es ermöglichen, erfolgreiche Lade-/Speicheroperationen sowie verschiedene Fehlerszenarien (Datei nicht gefunden, Lesefehler, Schreibfehler, korrupte Daten) zu simulieren. Crates wie mockall können hierfür verwendet werden.  
  * Der Event-Auslösemechanismus sollte ebenfalls mockbar sein, um zu verifizieren, dass Events korrekt und mit den richtigen Payloads gesendet werden.

---

**Zusammenfassende Betrachtungen zur Domänenschicht (für Teil 3/4)**  
Die in diesem Dokument detailliert spezifizierten Module domain::user\_centric\_services und domain::global\_settings\_and\_state\_management bilden zwei zentrale Säulen der Domänenschicht. Sie sind maßgeblich dafür verantwortlich, die Kernlogik für eine intelligente, personalisierte und anpassbare Benutzererfahrung bereitzustellen.  
Das Modul domain::user\_centric\_services kapselt die komplexe Logik für KI-gestützte Funktionen und das Benachrichtigungssystem. Die sorgfältige Definition von Entitäten wie AIInteractionContext und AIConsent, gepaart mit robusten Prozessen für das Einwilligungsmanagement, stellt sicher, dass KI-Funktionen verantwortungsvoll und unter Wahrung der Benutzerkontrolle integriert werden können. Das NotificationService bietet eine flexible und erweiterbare Grundlage für die Verwaltung aller System- und Anwendungsbenachrichtigungen.  
Das Modul domain::global\_settings\_and\_state\_management schafft die Voraussetzung für eine hochgradig konfigurierbare Desktop-Umgebung. Durch die zentrale, typsichere und validierte Verwaltung aller globalen Einstellungen in der GlobalDesktopSettings-Struktur und dem zugehörigen GlobalSettingsService wird Konsistenz über das gesamte System hinweg gewährleistet. Die Verwendung von serde für die (De-)Serialisierung und die klare Definition von SettingPath ermöglichen eine flexible und dennoch robuste Handhabung von Konfigurationsänderungen.  
Für beide Module ist die detaillierte Spezifikation der Fehlerbehandlung mittels thiserror von entscheidender Bedeutung. Die bewusste Entscheidung für spezifische Fehlervarianten und kontextreiche Fehlermeldungen, wie sie auch durch die Analyse der Referenzmaterialien 1 gestützt wird, erhöht nicht nur die Wartbarkeit und Debugfähigkeit des Codes, sondern ermöglicht es auch, dem Benutzer über die UI präzisere und hilfreichere Rückmeldungen bei Problemen zu geben. Die konsequente Auslösung von Events bei relevanten Zustandsänderungen ist fundamental für die Entkopplung der Module und die dynamische Reaktion der Benutzeroberfläche.  
Die hier vorgelegten Ultrafeinspezifikationen bieten eine solide Grundlage für die Implementierung dieser Domänenkomponenten. Die Entwickler können diese Pläne nutzen, um Module zu erstellen, die nicht nur funktional korrekt sind, sondern auch den hohen Anforderungen an Stabilität, Erweiterbarkeit und Benutzerfreundlichkeit der geplanten Desktop-Umgebung gerecht werden.

#### **Referenzen**

1. Error handling \- good/best practices : r/rust \- Reddit, Zugriff am Mai 13, 2025, [https://www.reddit.com/r/rust/comments/1bb7dco/error\_handling\_goodbest\_practices/](https://www.reddit.com/r/rust/comments/1bb7dco/error_handling_goodbest_practices/)  
2. Error Handling for Large Rust Projects \- Best Practice in GreptimeDB, Zugriff am Mai 13, 2025, [https://greptime.com/blogs/2024-05-07-error-rust](https://greptime.com/blogs/2024-05-07-error-rust)  
3. Error in std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/trait.Error.html](https://doc.rust-lang.org/std/error/trait.Error.html)

# **B4 Domänenschicht (Domain Layer) – Teil 4/4: Einstellungs- und Benachrichtigungs-Subsysteme**

Dieser Teil der Spezifikation widmet sich den verbleibenden Kernkomponenten der Domänenschicht: dem Subsystem für die Verwaltung von Einstellungen (domain::settings\_core und domain::settings\_persistence\_iface) sowie dem Subsystem für die Verarbeitung und Regelung von Benachrichtigungen (domain::notifications\_core und domain::notifications\_rules). Diese Module sind entscheidend für die Konfigurierbarkeit und das reaktive Verhalten der Desktop-Umgebung.

## **4.1. Entwicklungsmodul: Kernlogik für Einstellungen (domain::settings\_core)**

Dieses Modul bildet das Herzstück der Einstellungsverwaltung innerhalb der Domänenschicht. Es ist verantwortlich für die Definition, Validierung, Speicherung (über eine Abstraktionsschicht) und den Zugriff auf alle Konfigurationseinstellungen der Desktop-Umgebung.

### **4.1.1. Detaillierte Verantwortlichkeiten und Ziele**

* **Verantwortlichkeiten:**  
  * Definition der Struktur und Typen von Einstellungen (SettingKey, SettingValue, SettingMetadata, Setting).  
  * Bereitstellung einer zentralen Logik (SettingsCoreManager) zur Verwaltung dieser Einstellungen.  
  * Validierung von Einstellungswerten gegen definierte Metadaten (Typ, Bereich, erlaubte Werte).  
  * Koordination des Ladens und Speicherns von Einstellungen über eine abstrakte Persistenzschnittstelle (SettingsProvider).  
  * Benachrichtigung anderer Systemteile über Einstellungsänderungen mittels interner Events (SettingChangedEvent).  
* **Ziele:**  
  * Schaffung einer typsicheren und validierten Verwaltung von Einstellungen.  
  * Entkopplung der Einstellungslogik von der konkreten Speicherung und der Benutzeroberfläche.  
  * Ermöglichung einer reaktiven Anpassung des Systemverhaltens basierend auf Konfigurationsänderungen.  
  * Sicherstellung der Konsistenz und Integrität der Einstellungen.

### **4.1.2. Entitäten und Wertobjekte**

Die folgenden Datenstrukturen sind in domain/src/settings\_core/types.rs zu definieren. Sie müssen Debug, Clone und PartialEq implementieren. Für die Persistenz und den Datenaustausch ist zudem die Implementierung von serde::Serialize und serde::Deserialize für SettingValue und die darin enthaltenen Typen essenziell. Die uuid Crate wird für eindeutige IDs verwendet, wobei die Features v4 (zur Generierung) und serde (zur Serialisierung) aktiviert sein müssen.1 Für Zeitstempel wird chrono mit dem aktivierten serde-Feature eingesetzt.3

* **SettingKey (Newtype für String)**  
  * **Zweck:** Ein typsicherer Wrapper für den Schlüssel einer Einstellung (z.B. "appearance.theme.name", "notifications.do\_not\_disturb.enabled").  
  * **Warum wertvoll:** Erhöht die Typsicherheit und verhindert die versehentliche Verwendung beliebiger Strings als Einstellungsschlüssel. Fördert Klarheit im Code.  
  * **Implementierungsdetails:**  
    * Interner Typ: String.  
    * Sollte Display, Hash, Eq, PartialEq, Ord, PartialOrd, From\<String\>, AsRef\<str\> implementieren.  
    * Konstruktion z.B. über SettingKey::new("my.setting.key") oder From::from("my.setting.key").  
* **SettingValue (Enum)**  
  * **Zweck:** Ein Enum, das alle möglichen Typen von Einstellungswerten repräsentiert.  
  * **Warum wertvoll:** Ermöglicht eine flexible, aber dennoch typsichere Behandlung unterschiedlicher Einstellungsdatentypen an einer zentralen Stelle.  
  * **Varianten:**  
    * Boolean(bool)  
    * Integer(i64)  
    * Float(f64)  
    * String(String)  
    * Color(String): Hex-Farbcode (z.B. "\#RRGGBBAA").  
    * FilePath(String): Ein Pfad zu einer Datei oder einem Verzeichnis.  
    * List(Vec\<SettingValue\>): Eine geordnete Liste von SettingValue.  
    * Map(std::collections::HashMap\<String, SettingValue\>): Eine Schlüssel-Wert-Map.  
  * **Methoden (Beispiele):**  
    * pub fn as\_bool(\&self) \-\> Option\<bool\>  
    * pub fn as\_str(\&self) \-\> Option\<\&str\>  
    * Weitere as\_TYPE und try\_into\_TYPE Methoden für bequemen Zugriff und Konvertierung.  
* **SettingMetadata Struktur**  
  * **Zweck:** Enthält Metadaten zu einer Einstellung, wie Beschreibung, Standardwert, mögliche Werte (für Enums), Validierungsregeln.  
  * **Warum wertvoll:** Ermöglicht eine deklarative Definition von Einstellungen und deren Eigenschaften. Dies ist fundamental, um die Verwaltung, die automatische Generierung von Benutzeroberflächen für Einstellungen und die Validierung zu vereinfachen. Ohne Metadaten wäre jede Einstellungslogik ad-hoc und schwer zu warten.

| Attribut | Typ | Sichtbarkeit | Beschreibung |
| :---- | :---- | :---- | :---- |
| description | Option\<String\> | pub | Menschenlesbare Beschreibung der Einstellung. |
| default\_value | SettingValue | pub | Der Standardwert, der verwendet wird, wenn kein Wert gesetzt ist. |
| value\_type\_hint | String | pub | Hinweis auf den erwarteten SettingValue-Typ (z.B. "Boolean", "Integer"). |
| possible\_values | Option\<Vec\<SettingValue\>\> | pub | Für Enum-Typen: eine Liste der erlaubten Werte. |
| validation\_regex | Option\<String\> | pub | Für String-Typen: ein regulärer Ausdruck zur Validierung. |
| min\_value | Option\<SettingValue\> | pub | Für numerische Typen: der minimale erlaubte Wert. |
| max\_value | Option\<SettingValue\> | pub | Für numerische Typen: der maximale erlaubte Wert. |
| is\_sensitive | bool | pub | Gibt an, ob der Wert sensibel ist (z.B. Passwort, nicht loggen). Default: false. |
| requires\_restart | Option\<String\> | pub | Wenn Some(app\_id\_or\_service\_name), deutet an, dass eine Änderung einen Neustart der genannten Komponente erfordert. None bedeutet keinen Neustart. |

* **Setting Struktur (Entität)**  
  * **Zweck:** Repräsentiert eine einzelne, konkrete Einstellung mit ihrem aktuellen Wert und Metadaten.  
  * **Warum wertvoll:** Das zentrale Objekt, das eine Einstellung im System darstellt und deren Zustand und Verhalten kapselt.

| Attribut | Typ | Sichtbarkeit | Beschreibung | Invarianten |
| :---- | :---- | :---- | :---- | :---- |
| id | uuid::Uuid | pub | Eindeutige ID der Einstellung (intern verwendet). | Muss eindeutig sein. Generiert via Uuid::new\_v4(). |
| key | SettingKey | pub | Der eindeutige Schlüssel der Einstellung. | Muss eindeutig sein. |
| current\_value | SettingValue | pub(crate) | Der aktuell gesetzte Wert der Einstellung. | Muss den Validierungsregeln in metadata entsprechen, falls gesetzt. |
| metadata | SettingMetadata | pub | Metadaten, die diese Einstellung beschreiben. |  |
| last\_modified | chrono::DateTime\<Utc\> | pub(crate) | Zeitstempel der letzten Änderung. | Wird bei jeder erfolgreichen Wertänderung aktualisiert. |
| is\_dirty | bool | pub(crate) | true, wenn current\_value geändert wurde, aber noch nicht persistiert ist. |  |

\*   \*\*Methoden:\*\*  
    \*   \`pub fn new(key: SettingKey, metadata: SettingMetadata) \-\> Self\`: Erstellt eine neue Einstellung. Der \`current\_value\` wird initial auf \`metadata.default\_value\` gesetzt. \`id\` wird generiert. \`last\_modified\` wird auf \`Utc::now()\` gesetzt.  
    \*   \`pub fn value(\&self) \-\> \&SettingValue\`: Gibt eine Referenz auf den aktuellen Wert zurück.  
    \*   \`pub(crate) fn set\_value(\&mut self, new\_value: SettingValue, timestamp: chrono::DateTime\<Utc\>) \-\> Result\<(), SettingsCoreError\>\`: Setzt einen neuen Wert, nachdem dieser erfolgreich gegen \`self.metadata\` validiert wurde (interner Aufruf von \`validate\_value\`). Aktualisiert \`current\_value\` und \`last\_modified\`.  
    \*   \`pub fn validate\_value(value: \&SettingValue, metadata: \&SettingMetadata) \-\> Result\<(), SettingsCoreError\>\`: Statische Methode zur Validierung eines Wertes gegen die gegebenen Metadaten. Diese Methode ist separat, um auch externe Validierung zu ermöglichen, bevor \`set\_value\` aufgerufen wird.  
    \*   \`pub fn reset\_to\_default(\&mut self, timestamp: chrono::DateTime\<Utc\>)\`: Setzt den \`current\_value\` auf \`self.metadata.default\_value\` zurück und aktualisiert \`last\_modified\`.

### **4.1.3. Öffentliche API des Moduls (SettingsCoreManager)**

Der SettingsCoreManager, definiert in domain/src/settings\_core/mod.rs, ist die zentrale Schnittstelle zur Einstellungslogik. Er kapselt die Verwaltung der Setting-Objekte und die Interaktion mit dem Persistenz-Provider.  
Die Operationen zum Laden und Speichern von Einstellungen können I/O-intensiv sein. Um die Domänenschicht nicht zu blockieren, werden diese Methoden als async deklariert. Dies erfordert, dass der SettingsProvider ebenfalls asynchrone Methoden anbietet und als Arc\<dyn SettingsProvider \+ Send \+ Sync\> übergeben wird, um Thread-Sicherheit in asynchronen Kontexten zu gewährleisten.5  
Wenn Einstellungen geändert werden, müssen andere Teile der Domänenschicht (z.B. die NotificationRulesEngine oder das Theming-System) potenziell darüber informiert werden. Um eine lose Kopplung zu erreichen, sendet der SettingsCoreManager interne Events (SettingChangedEvent) über einen tokio::sync::broadcast::Sender.6 Interessierte Module können einen broadcast::Receiver abonnieren und auf diese Events reagieren, ohne dass der SettingsCoreManager explizite Kenntnis von ihnen haben muss. Dieser Mechanismus ist entscheidend für eine reaktive Architektur.

Rust

// domain/src/settings\_core/mod.rs  
use crate::settings\_persistence\_iface::{SettingsProvider, SettingsPersistenceError};  
use crate::settings\_core::types::{Setting, SettingKey, SettingValue, SettingMetadata};  
use crate::settings\_core::error::SettingsCoreError;  
use std::collections::HashMap;  
use std::sync::Arc;  
use tokio::sync::{RwLock, broadcast};  
use chrono::Utc;

\# // Clone ist wichtig für den broadcast::Sender  
pub struct SettingChangedEvent {  
    pub key: SettingKey,  
    pub new\_value: SettingValue,  
    pub old\_value: Option\<SettingValue\>,  
}

pub struct SettingsCoreManager {  
    settings: RwLock\<HashMap\<SettingKey, Setting\>\>,  
    provider: Arc\<dyn SettingsProvider \+ Send \+ Sync\>,  
    event\_sender: broadcast::Sender\<SettingChangedEvent\>,  
    registered\_metadata: RwLock\<HashMap\<SettingKey, SettingMetadata\>\>, // RwLock auch hier für dynamische Registrierung  
}

impl SettingsCoreManager {  
    pub fn new(  
        provider: Arc\<dyn SettingsProvider \+ Send \+ Sync\>,  
        initial\_metadata: Vec\<(SettingKey, SettingMetadata)\>,  
        event\_channel\_capacity: usize  
    ) \-\> Self {  
        let (event\_sender, \_) \= broadcast::channel(event\_channel\_capacity);  
        let mut metadata\_map \= HashMap::new();  
        for (key, meta) in initial\_metadata {  
            metadata\_map.insert(key, meta);  
        }

        SettingsCoreManager {  
            settings: RwLock::new(HashMap::new()),  
            provider,  
            event\_sender,  
            registered\_metadata: RwLock::new(metadata\_map),  
        }  
    }

    // Weitere Methoden folgen  
}

* **Tabelle: Methoden des SettingsCoreManager**

| Methode | Signatur | Kurzbeschreibung | Vorbedingungen | Nachbedingungen (Erfolg) | Nachbedingungen (Fehler) |
| :---- | :---- | :---- | :---- | :---- | :---- |
| new | pub fn new(provider: Arc\<dyn SettingsProvider \+ Send \+ Sync\>, initial\_metadata: Vec\<(SettingKey, SettingMetadata)\>, event\_channel\_capacity: usize) \-\> Self | Konstruktor. Initialisiert den Manager mit Provider, Metadaten und Event-Kanal-Kapazität. | provider ist valide. event\_channel\_capacity \> 0\. | SettingsCoreManager ist initialisiert. event\_sender ist erstellt. settings ist leer. registered\_metadata ist gefüllt. | \- |
| register\_setting\_metadata | pub async fn register\_setting\_metadata(\&self, key: SettingKey, metadata: SettingMetadata) \-\> Result\<(), SettingsCoreError\> | Registriert Metadaten für eine neue Einstellung zur Laufzeit. | key ist noch nicht registriert. | Metadaten für key sind in registered\_metadata gespeichert. | SettingsCoreError::SettingKeyAlreadyExists |
| load\_all\_settings | pub async fn load\_all\_settings(\&self) \-\> Result\<(), SettingsCoreError\> | Lädt alle Einstellungen, für die Metadaten registriert sind, vom SettingsProvider. | provider ist erreichbar. | Interne settings-Map ist mit geladenen Werten (oder Defaults aus Metadaten) gefüllt. | SettingsCoreError::PersistenceError, SettingsCoreError::ValidationError |
| get\_setting\_value | pub async fn get\_setting\_value(\&self, key: \&SettingKey) \-\> Result\<SettingValue, SettingsCoreError\> | Ruft den aktuellen Wert einer Einstellung ab. Lädt ggf. nach, falls nicht im Speicher. | key muss registriert sein. | SettingValue des Schlüssels wird zurückgegeben. | SettingsCoreError::SettingNotFound, SettingsCoreError::UnregisteredKey, SettingsCoreError::PersistenceError |
| set\_setting\_value | pub async fn set\_setting\_value(\&self, key: \&SettingKey, value: SettingValue) \-\> Result\<(), SettingsCoreError\> | Setzt den Wert einer Einstellung. Validiert und persistiert den Wert. Sendet ein Event. | key muss registriert sein. value muss valide sein gemäß Metadaten. | Wert ist intern gesetzt, persistiert via provider. SettingChangedEvent wird gesendet. last\_modified im Setting aktualisiert. | SettingsCoreError::SettingNotFound, SettingsCoreError::UnregisteredKey, SettingsCoreError::ValidationError, SettingsCoreError::PersistenceError |
| reset\_setting\_to\_default | pub async fn reset\_setting\_to\_default(\&self, key: \&SettingKey) \-\> Result\<(), SettingsCoreError\> | Setzt eine Einstellung auf ihren Standardwert (aus Metadaten) zurück. Persistiert und sendet Event. | key muss registriert sein. | Wert ist intern auf Default gesetzt, persistiert. SettingChangedEvent wird gesendet. last\_modified aktualisiert. | SettingsCoreError::SettingNotFound, SettingsCoreError::UnregisteredKey, SettingsCoreError::PersistenceError |
| get\_all\_settings\_with\_metadata | pub async fn get\_all\_settings\_with\_metadata(\&self) \-\> Result\<Vec\<Setting\>, SettingsCoreError\> | Gibt eine Liste aller aktuell verwalteten Einstellungen (inkl. ihrer Werte und Metadaten) zurück. | \- | Eine Vec\<Setting\> mit Klonen aller Einstellungen. | SettingsCoreError::PersistenceError (falls Nachladen nötig und fehlschlägt) |
| subscribe\_to\_changes | pub fn subscribe\_to\_changes(\&self) \-\> broadcast::Receiver\<SettingChangedEvent\> | Gibt einen Receiver für SettingChangedEvents zurück, um auf Einstellungsänderungen zu reagieren. | \- | Ein neuer broadcast::Receiver\<SettingChangedEvent\>. | \- |

### **4.1.4. Interne Events (SettingChangedEvent)**

Definiert in domain/src/settings\_core/mod.rs (siehe oben).

* **Zweck:** Entkoppelte Benachrichtigung anderer Domänenkomponenten über Einstellungsänderungen.  
* **Warum wertvoll:** Ermöglicht eine reaktive Architektur innerhalb der Domänenschicht. Module können auf Änderungen reagieren, ohne dass der SettingsCoreManager sie kennen muss. Dies reduziert die Kopplung und erhöht die Wartbarkeit und Erweiterbarkeit des Systems. Beispielsweise kann das Theming-Modul auf Änderungen der Akzentfarbe reagieren, ohne dass der SettingsCoreManager das Theming-Modul explizit aufrufen muss.  
* **Struktur SettingChangedEvent:**

| Feld | Typ | Beschreibung |
| :---- | :---- | :---- |
| key | SettingKey | Der Schlüssel der geänderten Einstellung. |
| new\_value | SettingValue | Der neue Wert der Einstellung. |
| old\_value | Option\<SettingValue\> | Der vorherige Wert der Einstellung (falls vorhanden oder nicht Standardwert). |

* **Typische Publisher:** SettingsCoreManager (nach erfolgreichem set\_setting\_value oder reset\_setting\_to\_default).  
* **Typische Subscriber (intern in Domänenschicht):** NotificationRulesEngine (um z.B. auf "Nicht stören"-Modus zu reagieren), ThemingEngine (um auf Theme- oder Akzentfarbänderungen zu reagieren), potenziell andere Domänenmodule, die einstellungsabhängige Logik haben.

### **4.1.5. Fehlerbehandlung (SettingsCoreError)**

Definiert in domain/src/settings\_core/error.rs unter Verwendung der thiserror-Crate, gemäß Richtlinie 4.3 der Gesamtspezifikation. Die Verwendung von thiserror für Bibliotheks-Code ist vorteilhaft, da sie spezifische, typisierte Fehler ermöglicht, die von Aufrufern explizit behandelt werden können, im Gegensatz zu generischen Fehlertypen wie anyhow::Error oder Box\<dyn std::error::Error\>.8 Die \#\[from\]-Annotation erleichtert die Konvertierung von Fehlern aus anderen Modulen (z.B. SettingsPersistenceError) in Varianten von SettingsCoreError.10

Rust

// domain/src/settings\_core/error.rs  
use thiserror::Error;  
use crate::settings\_core::types::SettingKey;  
use crate::settings\_persistence\_iface::SettingsPersistenceError;

\#  
pub enum SettingsCoreError {  
    \#  
    SettingNotFound { key: SettingKey },

    \#  
    SettingKeyAlreadyExists { key: SettingKey },

    \#\[error("Validation failed for setting '{key}': {message}")\]  
    ValidationError { key: SettingKey, message: String },

    \#\[error("Persistence operation failed for setting '{key\_str}': {source}")\]  
    PersistenceError {  
        key\_str: String, // String, da SettingKey nicht immer verfügbar oder relevant für globalen Fehler  
        \#\[source\]  
        source: SettingsPersistenceError,  
    },

    \#\[error("Attempted to operate on an unregistered setting key: '{key}'")\]  
    UnregisteredKey { key: SettingKey },

    \#\[error("An underlying I/O error occurred: {0}")\]  
    IoError(\#\[from\] std::io::Error), // Für den Fall, dass das Modul selbst I/O machen würde (selten)

    \#\[error("Event channel error while processing key '{key\_str}': {message}")\]  
    EventChannelError{ key\_str: String, message: String },  
}

// Konvertierung von SettingsPersistenceError zu SettingsCoreError  
// Dies ist nützlich, wenn ein Persistenzfehler auftritt, der nicht direkt einem Schlüssel zugeordnet ist.  
impl From\<SettingsPersistenceError\> for SettingsCoreError {  
    fn from(err: SettingsPersistenceError) \-\> Self {  
        SettingsCoreError::PersistenceError {  
            key\_str: err.get\_key().map\_or\_else(|| "global".to\_string(), |k| k.as\_str().to\_string()),  
            source: err,  
        }  
    }  
}

(Hinweis: SettingsPersistenceError müsste eine Methode get\_key() \-\> Option\<\&SettingKey\> haben, um dies sauber zu implementieren.)

* **Tabelle: SettingsCoreError Varianten**

| Variante | Beschreibung | Kontext/Ursache |
| :---- | :---- | :---- |
| SettingNotFound | Eine angeforderte Einstellung existiert nicht in der internen settings-Map. | get\_setting\_value, set\_setting\_value für einen Schlüssel, der zwar registriert, aber nicht geladen ist. |
| SettingKeyAlreadyExists | Versuch, Metadaten für einen bereits existierenden Schlüssel zu registrieren. | register\_setting\_metadata. |
| ValidationError | Ein neuer Wert für eine Einstellung entspricht nicht den Validierungsregeln. | set\_setting\_value, interne Validierung durch Setting::validate\_value. |
| PersistenceError | Fehler bei der Interaktion mit dem SettingsProvider. | Wrappt Fehler vom SettingsProvider (z.B. SettingsPersistenceError::StorageError). Verwendet \#\[source\]. |
| UnregisteredKey | Operation auf einem Schlüssel ohne registrierte Metadaten. | Wenn eine Operation Metadaten erfordert (z.B. set\_setting\_value), diese aber für den Schlüssel fehlen. |
| IoError | Generischer I/O-Fehler (eher selten direkt hier, mehr für SettingsProvider). | Beispiel für \#\[from\] std::io::Error. |
| EventChannelError | Fehler beim Senden eines SettingChangedEvent über den broadcast::Sender. | Wenn der broadcast::Sender::send() einen Fehler zurückgibt (z.B. keine aktiven Receiver und Puffer voll). |

### **4.1.6. Detaillierte Implementierungsschritte und Algorithmen**

1. **Initialisierung (SettingsCoreManager::new):**  
   * Speichere den übergebenen provider und die initial\_metadata (in RwLock\<HashMap\<...\>\>).  
   * Erstelle den broadcast::channel für SettingChangedEvent mit der spezifizierten Kapazität.  
   * Die settings-Map (RwLock\<HashMap\<SettingKey, Setting\>\>) bleibt initial leer. Einstellungen werden lazy oder durch load\_all\_settings geladen.  
2. **SettingsCoreManager::register\_setting\_metadata:**  
   * Erwirb Schreibsperre für registered\_metadata.  
   * Prüfe, ob key bereits existiert. Wenn ja, Err(SettingsCoreError::SettingKeyAlreadyExists).  
   * Füge (key, metadata) zu registered\_metadata hinzu. Ok(()).  
3. **SettingsCoreManager::load\_all\_settings:**  
   * Erwirb Lesesperre für registered\_metadata und Schreibsperre für settings.  
   * Iteriere über alle (key, metadata) in registered\_metadata.  
   * Für jeden key:  
     * Rufe self.provider.load\_setting(\&key).await auf.  
     * Bei Ok(Some(loaded\_value)):  
       * Validiere loaded\_value gegen metadata mittels Setting::validate\_value(\&loaded\_value, \&metadata). Bei Fehler: Err(SettingsCoreError::ValidationError).  
       * Erstelle ein Setting-Objekt: let setting \= Setting { id: uuid::Uuid::new\_v4(), key: key.clone(), current\_value: loaded\_value, metadata: metadata.clone(), last\_modified: Utc::now(), is\_dirty: false };  
       * Füge (key.clone(), setting) zur settings-Map hinzu.  
     * Bei Ok(None) (kein Wert persistiert):  
       * Verwende metadata.default\_value. Erstelle Setting-Objekt wie oben, aber mit metadata.default\_value.clone().  
       * Füge zur settings-Map hinzu.  
     * Bei Err(persistence\_error): Konvertiere zu SettingsCoreError::PersistenceError und gib Fehler zurück. Breche den Ladevorgang ab.  
   * Ok(()) bei Erfolg.  
4. **SettingsCoreManager::get\_setting\_value:**  
   * Erwirb Lesesperre für registered\_metadata. Prüfe, ob key registriert ist. Wenn nein, Err(SettingsCoreError::UnregisteredKey).  
   * Erwirb Lesesperre für settings.  
   * Wenn key in settings vorhanden ist, gib settings.get(key).unwrap().value().clone() zurück.  
   * Wenn key nicht in settings vorhanden (nicht geladen):  
     * Gib Lesesperre für settings frei.  
     * Rufe self.provider.load\_setting(key).await auf.  
     * Erwirb Schreibsperre für settings.  
     * Bei Ok(Some(loaded\_value)):  
       * Hole metadata aus registered\_metadata.  
       * Validiere loaded\_value. Bei Fehler: Err(SettingsCoreError::ValidationError).  
       * Erstelle Setting-Objekt, füge zu settings hinzu. Gib loaded\_value.clone() zurück.  
     * Bei Ok(None):  
       * Hole metadata aus registered\_metadata.  
       * Erstelle Setting-Objekt mit metadata.default\_value. Füge zu settings hinzu. Gib metadata.default\_value.clone() zurück.  
     * Bei Err(persistence\_error): Err(SettingsCoreError::from(persistence\_error)).  
   * Stelle sicher, dass Sperren korrekt freigegeben werden, besonders bei frühen Returns.  
5. **SettingsCoreManager::set\_setting\_value:**  
   * Erwirb Lesesperre für registered\_metadata. Hole metadata für key. Wenn nicht gefunden: Err(SettingsCoreError::UnregisteredKey).  
   * Validiere value gegen metadata mittels Setting::validate\_value(\&value, \&retrieved\_metadata). Bei Fehler: Err(SettingsCoreError::ValidationError).  
   * Erwirb Schreibsperre für settings.  
   * Hole das (mutable) Setting-Objekt für key. Wenn nicht gefunden (sollte nach get\_setting\_value-Logik oder load\_all\_settings existieren, aber zur Sicherheit prüfen oder entry() API verwenden): Err(SettingsCoreError::SettingNotFound).  
   * Speichere old\_value \= current\_setting.value().clone().  
   * Rufe current\_setting.set\_value(value.clone(), Utc::now()) auf (dies validiert intern nicht erneut, da bereits geschehen).  
   * Setze current\_setting.is\_dirty \= true.  
   * Rufe self.provider.save\_setting(key, \&value).await auf.  
     * Bei Err(persistence\_error):  
       * Setze current\_setting.set\_value(old\_value, Utc::now()) (Rollback der In-Memory-Änderung).  
       * Setze current\_setting.is\_dirty \= false.  
       * Err(SettingsCoreError::from(persistence\_error)).  
   * Setze current\_setting.is\_dirty \= false.  
   * Erstelle SettingChangedEvent { key: key.clone(), new\_value: value, old\_value: Some(old\_value) }.  
   * Sende das Event via self.event\_sender.send(). Bei Fehler (z.B. wenn keine Subscriber da sind und der Kanal voll ist, was bei broadcast selten zu einem harten Fehler führt, aber Err zurückgeben kann): Err(SettingsCoreError::EventChannelError).  
   * Ok(()).  
6. **Validierungslogik (Setting::validate\_value):**  
   * Prüfe Typkompatibilität von value mit metadata.value\_type\_hint (z.B. SettingValue::Integer mit "Integer").  
   * Wenn metadata.possible\_values Some(list) ist, prüfe, ob value in list enthalten ist.  
   * Wenn metadata.validation\_regex Some(regex\_str) ist und value ein SettingValue::String(s) ist, kompiliere Regex und prüfe s dagegen.  
   * Prüfe metadata.min\_value / metadata.max\_value für numerische Typen (Integer, Float).  
   * Bei Verletzung: Err(SettingsCoreError::ValidationError) mit passender Nachricht.

### **4.1.7. Überlegungen zur Nebenläufigkeit und Zustandssynchronisierung**

* Die internen Zustände settings und registered\_metadata werden mit tokio::sync::RwLock geschützt. Dies erlaubt parallele Lesezugriffe, während Schreibzugriffe exklusiv sind, was für typische Einstellungs-Workloads (viele Lesezugriffe, wenige Schreibzugriffe) performant ist.  
* Der SettingsProvider wird als Arc\<dyn SettingsProvider \+ Send \+ Sync\> gehalten. Send und Sync sind notwendig, da die async-Methoden des SettingsCoreManager potenziell auf verschiedenen Threads durch den Tokio-Executor ausgeführt werden können und der Provider über Thread-Grenzen hinweg sicher geteilt werden muss.5  
* Der broadcast::Sender für SettingChangedEvent ist Thread-sicher und für die Verwendung in asynchronen Kontexten konzipiert.6

## **4.2. Entwicklungsmodul: Persistenzabstraktion und Schema für Einstellungen (domain::settings\_persistence\_iface)**

Dieses Modul definiert die Schnittstelle, über die der SettingsCoreManager Einstellungen lädt und speichert, ohne die konkrete Implementierung der Persistenz zu kennen.

### **4.2.1. Detaillierte Verantwortlichkeiten und Ziele**

* **Verantwortlichkeiten:**  
  * Definition eines abstrakten Traits (SettingsProvider), der die Operationen zum Laden und Speichern von Einstellungen vorschreibt.  
  * Definition der Fehlertypen (SettingsPersistenceError), die bei Persistenzoperationen auftreten können.  
* **Ziele:**  
  * Vollständige Entkopplung der Domänenlogik (domain::settings\_core) von spezifischen Speichertechnologien (z.B. GSettings, Konfigurationsdateien im TOML/JSON-Format, Datenbank).  
  * Ermöglichung der Testbarkeit des SettingsCoreManager durch Mocking des SettingsProvider.  
  * Flexibilität bei der Auswahl oder dem Wechsel der Speichertechnologie, ohne dass Änderungen an der Domänenschicht erforderlich sind.

Die Verwendung eines Trait-Objekts (Arc\<dyn SettingsProvider \+ Send \+ Sync\>) ist hier entscheidend. Die Send \+ Sync-Bounds sind unerlässlich, da der Provider in async-Funktionen verwendet wird, die von einem Multi-Threaded-Executor wie Tokio ausgeführt werden können. Ohne diese Bounds könnte der Compiler die Thread-Sicherheit nicht garantieren.5

### **4.2.2. Trait-Definitionen (SettingsProvider)**

Definiert in domain/src/settings\_persistence\_iface/mod.rs. Die Verwendung von async\_trait ist notwendig, um async fn in Traits zu deklarieren, solange dies nicht nativ in stabilem Rust unterstützt wird.

Rust

// domain/src/settings\_persistence\_iface/mod.rs  
use async\_trait::async\_trait;  
use crate::settings\_core::types::{SettingKey, SettingValue};  
use crate::settings\_persistence\_iface::error::SettingsPersistenceError; // Eigener Fehlertyp

\#\[async\_trait\]  
pub trait SettingsProvider {  
    async fn load\_setting(\&self, key: \&SettingKey) \-\> Result\<Option\<SettingValue\>, SettingsPersistenceError\>;  
    async fn save\_setting(\&self, key: \&SettingKey, value: \&SettingValue) \-\> Result\<(), SettingsPersistenceError\>;  
    async fn load\_all\_settings(\&self) \-\> Result\<Vec\<(SettingKey, SettingValue)\>, SettingsPersistenceError\>;  
    async fn delete\_setting(\&self, key: \&SettingKey) \-\> Result\<(), SettingsPersistenceError\>;  
    async fn setting\_exists(\&self, key: \&SettingKey) \-\> Result\<bool, SettingsPersistenceError\>;  
}

* **Tabelle: Methoden des SettingsProvider Traits**

| Methode | Signatur | Kurzbeschreibung |
| :---- | :---- | :---- |
| load\_setting | async fn load\_setting(\&self, key: \&SettingKey) \-\> Result\<Option\<SettingValue\>, SettingsPersistenceError\> | Lädt den Wert für einen Schlüssel. Ok(None) wenn nicht vorhanden. |
| save\_setting | async fn save\_setting(\&self, key: \&SettingKey, value: \&SettingValue) \-\> Result\<(), SettingsPersistenceError\> | Speichert einen Wert für einen Schlüssel. Überschreibt, falls existent. |
| load\_all\_settings | async fn load\_all\_settings(\&self) \-\> Result\<Vec\<(SettingKey, SettingValue)\>, SettingsPersistenceError\> | Lädt alle Einstellungen, die dieser Provider verwaltet (z.B. unter einem Schema). |
| delete\_setting | async fn delete\_setting(\&self, key: \&SettingKey) \-\> Result\<(), SettingsPersistenceError\> | Löscht eine Einstellung aus dem persistenten Speicher. |
| setting\_exists | async fn setting\_exists(\&self, key: \&SettingKey) \-\> Result\<bool, SettingsPersistenceError\> | Prüft, ob eine Einstellung im persistenten Speicher existiert. |

### **4.2.3. Datenstrukturen für die Persistenzschnittstelle**

Die primären Datenstrukturen, die über diese Schnittstelle ausgetauscht werden, sind SettingKey und SettingValue aus dem Modul domain::settings\_core::types. Es wird implizit erwartet, dass Implementierungen des SettingsProvider-Traits mit serialisierbaren Formen von SettingValue arbeiten können. Daher müssen SettingValue und die darin enthaltenen Typen serde::Serialize und serde::Deserialize implementieren. Die konkrete Serialisierungslogik (z.B. zu JSON, GVariant für GSettings, etc.) ist Aufgabe der jeweiligen Provider-Implementierung in der Systemschicht, nicht der Domänenschicht.

### **4.2.4. Fehlerbehandlung (SettingsPersistenceError)**

Definiert in domain/src/settings\_persistence\_iface/error.rs unter Verwendung von thiserror. Diese Fehler sind spezifisch für Persistenzoperationen und werden vom SettingsCoreManager in SettingsCoreError::PersistenceError gewrappt.

Rust

// domain/src/settings\_persistence\_iface/error.rs  
use thiserror::Error;  
use crate::settings\_core::types::SettingKey;

\#  
pub enum SettingsPersistenceError {  
    \#  
    BackendUnavailable { message: String },

    \#\[error("Failed to access storage for key '{key}': {message}")\]  
    StorageAccessError { key: SettingKey, message: String },

    \#\[error("Failed to serialize setting '{key}': {message}")\]  
    SerializationError { key: SettingKey, message: String },

    \#\[error("Failed to deserialize setting '{key}': {message}")\]  
    DeserializationError { key: SettingKey, message: String },

    \#  
    SettingNotFoundInStorage { key: SettingKey }, // Eindeutiger als der allgemeine SettingNotFound

    \#\[error("An I/O error occurred while accessing storage for key '{key\_opt:?}': {source}")\]  
    IoError {  
        key\_opt: Option\<SettingKey\>,  
        \#\[source\]  
        source: std::io::Error,  
    },

    \#\[error("An unknown persistence error occurred for key '{key\_opt:?}': {message}")\]  
    UnknownError { key\_opt: Option\<SettingKey\>, message: String },  
}

impl SettingsPersistenceError {  
    /// Hilfsmethode, um den Schlüssel aus dem Fehler zu extrahieren, falls vorhanden.  
    pub fn get\_key(\&self) \-\> Option\<\&SettingKey\> {  
        match self {  
            SettingsPersistenceError::StorageAccessError { key,.. } \=\> Some(key),  
            SettingsPersistenceError::SerializationError { key,.. } \=\> Some(key),  
            SettingsPersistenceError::DeserializationError { key,.. } \=\> Some(key),  
            SettingsPersistenceError::SettingNotFoundInStorage { key,.. } \=\> Some(key),  
            SettingsPersistenceError::IoError { key\_opt,.. } \=\> key\_opt.as\_ref(),  
            SettingsPersistenceError::UnknownError { key\_opt,.. } \=\> key\_opt.as\_ref(),  
            \_ \=\> None,  
        }  
    }  
}

* **Tabelle: SettingsPersistenceError Varianten**

| Variante | Beschreibung |
| :---- | :---- |
| BackendUnavailable | Das Speichersystem (z.B. D-Bus Dienst, Datenbankverbindung) ist nicht erreichbar. |
| StorageAccessError | Allgemeiner Fehler beim Zugriff auf den Speicher für einen bestimmten Schlüssel. |
| SerializationError | Fehler beim Serialisieren eines SettingValue für die Speicherung. |
| DeserializationError | Fehler beim Deserialisieren eines Wertes aus dem Speicher in ein SettingValue. |
| SettingNotFoundInStorage | Spezifischer Fehler, wenn ein Schlüssel im Persistenzlayer nicht existiert. |
| IoError | Wrappt std::io::Error für dateibasierte Provider. Enthält optional den Schlüssel. |
| UnknownError | Ein anderer, nicht spezifisch klassifizierter Fehler. Enthält optional den Schlüssel. |

### **4.2.5. Detaillierte Implementierungsschritte für die Interaktion mit der Schnittstelle**

Die konkreten Implementierungen des SettingsProvider-Traits (z.B. GSettingsProvider, FileConfigProvider) befinden sich typischerweise in der Systemschicht oder einer dedizierten Infrastrukturschicht, da sie systemspezifische Details oder externe Bibliotheken involvieren.  
Der SettingsCoreManager interagiert wie folgt mit dem Provider:

1. Der SettingsCoreManager hält eine Instanz von Arc\<dyn SettingsProvider \+ Send \+ Sync\>.  
2. Bei Operationen wie set\_setting\_value ruft der SettingsCoreManager die entsprechende Methode des Providers auf, z.B. provider.save\_setting(\&key, \&value).await.  
3. Gibt die Provider-Methode Ok(...) zurück, fährt der SettingsCoreManager mit seiner Logik fort (internen Zustand aktualisieren, Event senden).  
4. Gibt die Provider-Methode Err(SettingsPersistenceError) zurück, konvertiert der SettingsCoreManager diesen Fehler in eine SettingsCoreError::PersistenceError-Variante (unter Beibehaltung des ursprünglichen Fehlers als source mittels \#\[from\] oder manueller Implementierung) und gibt diesen an seinen Aufrufer weiter. Der interne Zustand des SettingsCoreManager wird gegebenenfalls auf den Stand vor dem fehlgeschlagenen Persistenzversuch zurückgesetzt (Rollback).

Diese klare Trennung stellt sicher, dass die Domänenlogik agnostisch gegenüber der Persistenztechnologie bleibt und erleichtert das Testen erheblich, da der Provider durch einen Mock ersetzt werden kann.

## **4.3. Entwicklungsmodul: Kernlogik der Benachrichtigungsverwaltung (domain::notifications\_core)**

Dieses Modul ist für die zentrale Logik der Verwaltung von Desktop-Benachrichtigungen zuständig. Es definiert, was eine Benachrichtigung ist, wie sie verarbeitet, gespeichert und ihr Lebenszyklus verwaltet wird.

### **4.3.1. Detaillierte Verantwortlichkeiten und Ziele**

* **Verantwortlichkeiten:**  
  * Definition der Datenstruktur einer Benachrichtigung (Notification) und zugehöriger Typen (NotificationId, NotificationAction, NotificationUrgency).  
  * Verwaltung des Lebenszyklus von Benachrichtigungen: Erstellung, Anzeige (konzeptionell, die Darstellung erfolgt in der UI-Schicht), Aktualisierung, Schließen.  
  * Bereitstellung einer API (NotificationCoreManager) zum programmatischen Hinzufügen und Verwalten von Benachrichtigungen.  
  * Führung einer Liste aktiver Benachrichtigungen.  
  * Verwaltung einer Benachrichtigungshistorie mit konfigurierbarer Größe und Persistenzlogik (FIFO).  
  * Unterstützung für interaktive Benachrichtigungen durch NotificationAction.  
  * Implementierung von Logik zur Deduplizierung oder zum Ersetzen von Benachrichtigungen (z.B. basierend auf replaces\_id).  
  * Interaktion mit der NotificationRulesEngine (domain::notifications\_rules) zur Anwendung von Filter-, Priorisierungs- und Modifikationsregeln.  
  * Versenden interner Events (NotificationEvent) über Zustandsänderungen von Benachrichtigungen.  
* **Ziele:**  
  * Schaffung einer zentralen, konsistenten und robusten Logik für das gesamte Benachrichtigungssystem.  
  * Strikte Trennung der Benachrichtigungslogik von der UI-Darstellung und den Transportmechanismen (wie D-Bus). Die Domänenschicht definiert *was* eine Benachrichtigung ist und *wie* sie verwaltet wird, nicht wie sie konkret aussieht oder über welche Kanäle sie empfangen/gesendet wird.  
  * Ermöglichung eines flexiblen und durch Regeln steuerbaren Benachrichtigungsflusses.

### **4.3.2. Entitäten und Wertobjekte**

Alle Typen sind in domain/src/notifications\_core/types.rs zu definieren. Sie benötigen standardmäßig Debug, Clone, PartialEq. Für die Persistenz der Historie und die Verwendung in Events ist auch serde::Serialize und serde::Deserialize für die Hauptstrukturen (Notification, NotificationAction etc.) erforderlich. uuid::Uuid (mit Features v4, serde) 1 und chrono::DateTime\<Utc\> (mit Feature serde) 3 werden für IDs bzw. Zeitstempel verwendet.

* **NotificationId (Newtype für uuid::Uuid)**  
  * **Zweck:** Eine typsichere ID für Benachrichtigungen.  
  * **Warum wertvoll:** Verhindert Verwechslungen mit anderen Uuid-basierten IDs im System und macht die API expliziter.  
  * **Implementierungsdetails:**  
    * Interner Typ: uuid::Uuid.  
    * Sollte Display, Hash, Eq, PartialEq, Ord, PartialOrd, serde::Serialize, serde::Deserialize, Copy (da Uuid Copy ist) implementieren.  
    * Methoden: pub fn new() \-\> Self { Self(uuid::Uuid::new\_v4()) }, pub fn as\_uuid(\&self) \-\> \&uuid::Uuid { \&self.0 }, From\<uuid::Uuid\>, Into\<uuid\_Uuid\>.  
* **NotificationUrgency (Enum)**  
  * **Zweck:** Definiert die Dringlichkeitsstufe einer Benachrichtigung.  
  * **Warum wertvoll:** Standardisiert die Dringlichkeit und ermöglicht darauf basierende Logik in Regeln und UI (z.B. Sortierung, Hervorhebung, unterschiedliche Töne).

| Variante | Wert (intern, z.B. u8) | Beschreibung |
| :---- | :---- | :---- |
| Low | 0 | Niedrige Dringlichkeit (z.B. informative Updates). |
| Normal | 1 | Normale Dringlichkeit (Standard). |
| Critical | 2 | Hohe Dringlichkeit (z.B. Fehler, wichtige Alarme). |

\*   Sollte \`serde::Serialize\`, \`serde::Deserialize\`, \`Copy\` implementieren.

* **NotificationAction (Struktur, Wertobjekt)**  
  * **Zweck:** Repräsentiert eine Aktion, die der Benutzer im Kontext einer Benachrichtigung ausführen kann.  
  * **Warum wertvoll:** Ermöglicht interaktive Benachrichtigungen, die über reine Informationsanzeige hinausgehen.

| Attribut | Typ | Sichtbarkeit | Beschreibung |
| :---- | :---- | :---- | :---- |
| key | String | pub | Eindeutiger Schlüssel der Aktion innerhalb der Benachrichtigung (z.B. "reply", "archive"). |
| label | String | pub | Menschenlesbare Beschriftung für den Button/Menüeintrag (z.B. "Antworten"). |
| icon\_name | Option\<String\> | pub | Optionaler Name eines Icons für die Aktion (gemäß Freedesktop Icon Naming Spec). |

\*   Sollte \`serde::Serialize\`, \`serde::Deserialize\` implementieren.

* **Notification (Struktur, Entität)**  
  * **Zweck:** Das zentrale Objekt, das eine einzelne Benachrichtigung mit all ihren Attributen darstellt.  
  * **Warum wertvoll:** Kapselt alle Informationen einer Benachrichtigung und dient als Hauptdatentyp für die Benachrichtigungslogik.

| Attribut | Typ | Sichtbarkeit | Beschreibung | Invarianten |
| :---- | :---- | :---- | :---- | :---- |
| id | NotificationId | pub | Eindeutige ID der Benachrichtigung. | Muss eindeutig sein. Wird bei Erstellung generiert. |
| app\_name | String | pub | Name der Anwendung, die die Benachrichtigung gesendet hat (z.B. "Thunderbird", "System Update"). | Nicht leer. |
| app\_icon | Option\<String\> | pub | Pfad oder Name des Icons der Anwendung (gemäß Freedesktop Icon Naming Spec). |  |
| summary | String | pub | Kurze Zusammenfassung/Titel der Benachrichtigung. | Nicht leer. |
| body | Option\<String\> | pub | Ausführlicherer Text der Benachrichtigung. Kann Markup enthalten (abhängig von UI-Interpretation). |  |
| actions | Vec\<NotificationAction\> | pub | Liste von Aktionen, die mit der Benachrichtigung verbunden sind. | Schlüssel (key) jeder Aktion müssen innerhalb dieser Liste eindeutig sein. |
| hints | HashMap\<String, SettingValue\> | pub | Zusätzliche, anwendungsspezifische Daten oder UI-Hinweise (z.B. "image-path", "progress", "resident"). |  |
| urgency | NotificationUrgency | pub | Dringlichkeitsstufe. Default: Normal. |  |
| timestamp\_created | chrono::DateTime\<Utc\> | pub | Zeitstempel der Erstellung der Benachrichtigung *in der Domänenschicht*. | Wird bei Instanziierung gesetzt. |
| timestamp\_displayed | Option\<chrono::DateTime\<Utc\>\> | pub(crate) | Zeitstempel, wann die Benachrichtigung (potenziell) dem Benutzer angezeigt wurde (von NotificationCoreManager gesetzt). |  |
| expires\_at | Option\<chrono::DateTime\<Utc\>\> | pub | Zeitstempel, wann die Benachrichtigung automatisch geschlossen werden soll (None \= kein Timeout). |  |
| is\_persistent | bool | pub | true, wenn die Benachrichtigung nach dem Schließen in der Historie verbleiben soll. Default: false. |  |
| replaces\_id | Option\<NotificationId\> | pub | ID der Benachrichtigung, die durch diese ersetzt werden soll. |  |
| category | Option\<String\> | pub | Kategorie der Benachrichtigung (z.B. "email.new", "download.complete", "chat.incoming\_message"). Standardisierte Kategorien können für Regeln nützlich sein. |  |

\*   Sollte \`serde::Serialize\`, \`serde::Deserialize\` implementieren.

* **NotificationHistory (Struktur, Aggregatwurzel)**  
  * **Zweck:** Verwaltet die Sammlung der vergangenen (geschlossenen, persistenten) Benachrichtigungen.  
  * **Warum wertvoll:** Stellt die Logik für die Historie bereit, insbesondere die Begrenzung der Größe und den Zugriff.  
  * **Implementierungsdetails:**  
    * notifications: VecDeque\<Notification\>: Eine VecDeque ist geeignet, da sie effizientes Hinzufügen am einen Ende und Entfernen am anderen Ende (für die Größenbeschränkung) ermöglicht.  
    * max\_size: usize: Maximale Anzahl an Benachrichtigungen in der Historie.  
    * Methoden:  
      * pub fn new(max\_size: usize) \-\> Self  
      * pub fn add(\&mut self, notification: Notification): Fügt eine Benachrichtigung hinzu. Wenn max\_size überschritten wird, wird die älteste entfernt (pop\_front).  
      * pub fn get\_all(\&self) \-\> Vec\<Notification\>: Gibt eine Kopie aller historischen Benachrichtigungen zurück (neueste zuerst oder älteste zuerst, je nach Anforderung).  
      * pub fn get\_paged(\&self, limit: usize, offset: usize) \-\> Vec\<Notification\>: Gibt eine Seite der Historie zurück.  
      * pub fn clear(\&mut self): Leert die Historie.  
      * pub fn current\_size(\&self) \-\> usize.  
  * Sollte serde::Serialize, serde::Deserialize implementieren, um die gesamte Historie persistieren zu können (optional, aber nützlich).

### **4.3.3. Öffentliche API des Moduls (NotificationCoreManager)**

Definiert in domain/src/notifications\_core/mod.rs. Der NotificationCoreManager ist die Fassade für die Benachrichtigungslogik. Er verwaltet intern Listen für aktive Benachrichtigungen und eine Instanz von NotificationHistory. Er interagiert eng mit der NotificationRulesEngine.

Rust

// domain/src/notifications\_core/mod.rs  
use crate::notifications\_core::types::{Notification, NotificationId, NotificationAction, NotificationHistory, NotificationUrgency}; // NotificationUrgency für Defaults  
use crate::notifications\_core::error::NotificationCoreError;  
use crate::notifications\_core::events::{NotificationEvent, CloseReason};  
use crate::notifications\_rules::{NotificationRulesEngine, RuleProcessingResult}; // Abhängigkeit  
use std::collections::{HashMap, VecDeque};  
use std::sync::Arc;  
use tokio::sync::{RwLock, broadcast};  
use chrono::Utc;

pub struct NotificationCoreManager {  
    active\_notifications: RwLock\<HashMap\<NotificationId, Notification\>\>,  
    history: RwLock\<NotificationHistory\>,  
    rules\_engine: Arc\<NotificationRulesEngine\>,  
    event\_sender: broadcast::Sender\<NotificationEvent\>,  
    // next\_internal\_id: RwLock\<u32\>, // Für Freedesktop Notification Spec Server ID, falls benötigt  
}

impl NotificationCoreManager {  
    pub fn new(  
        rules\_engine: Arc\<NotificationRulesEngine\>,  
        history\_max\_size: usize,  
        event\_channel\_capacity: usize  
    ) \-\> Self {  
        let (event\_sender, \_) \= broadcast::channel(event\_channel\_capacity);  
        NotificationCoreManager {  
            active\_notifications: RwLock::new(HashMap::new()),  
            history: RwLock::new(NotificationHistory::new(history\_max\_size)),  
            rules\_engine,  
            event\_sender,  
        }  
    }

    // Weitere Methoden folgen  
}

* **Tabelle: Methoden des NotificationCoreManager**

| Methode | Signatur | Kurzbeschreibung |
| :---- | :---- | :---- |
| new | pub fn new(rules\_engine: Arc\<NotificationRulesEngine\>, history\_max\_size: usize, event\_channel\_capacity: usize) \-\> Self | Konstruktor. Initialisiert den Manager mit der Regel-Engine, maximaler Historiengröße und Event-Kanal-Kapazität. |
| add\_notification | pub async fn add\_notification(\&self, mut new\_notification: Notification) \-\> Result\<NotificationId, NotificationCoreError\> | Fügt eine neue Benachrichtigung hinzu. Wendet Regeln an, prüft auf Ersetzung. Sendet NotificationAdded oder NotificationSuppressedByRule Event. Gibt die ID der (ggf. modifizierten) Benachrichtigung zurück. |
| get\_active\_notification | pub async fn get\_active\_notification(\&self, id: \&NotificationId) \-\> Result\<Option\<Notification\>, NotificationCoreError\> | Ruft eine aktive Benachrichtigung anhand ihrer ID ab (als Klon). |
| get\_all\_active\_notifications | pub async fn get\_all\_active\_notifications(\&self) \-\> Result\<Vec\<Notification\>, NotificationCoreError\> | Ruft eine Liste aller derzeit aktiven Benachrichtigungen ab (als Klone). |
| close\_notification | pub async fn close\_notification(\&self, id: \&NotificationId, reason: CloseReason) \-\> Result\<(), NotificationCoreError\> | Schließt eine aktive Benachrichtigung. Verschiebt sie ggf. in die Historie (basierend auf is\_persistent und reason). Sendet NotificationClosed Event. |
| invoke\_action | pub async fn invoke\_action(\&self, notification\_id: \&NotificationId, action\_key: \&str) \-\> Result\<(), NotificationCoreError\> | Löst eine Aktion für eine Benachrichtigung aus. Sendet NotificationActionInvoked Event. Die eigentliche Ausführung der Aktion ist nicht Teil dieser Domänenlogik. |
| get\_history | pub async fn get\_history(\&self, limit: Option\<usize\>, offset: Option\<usize\>) \-\> Result\<Vec\<Notification\>, NotificationCoreError\> | Ruft Benachrichtigungen aus der Historie ab (paginiert). |
| clear\_history | pub async fn clear\_history(\&self) \-\> Result\<(), NotificationCoreError\> | Leert die Benachrichtigungshistorie. Sendet NotificationHistoryCleared Event. |
| clear\_app\_notifications | pub async fn clear\_app\_notifications(\&self, app\_name: \&str, reason: CloseReason) \-\> Result\<usize, NotificationCoreError\> | Schließt alle aktiven Benachrichtigungen einer bestimmten App. Gibt Anzahl geschlossener Benachrichtigungen zurück. |
| subscribe\_to\_events | pub fn subscribe\_to\_events(\&self) \-\> broadcast::Receiver\<NotificationEvent\> | Gibt einen Receiver für NotificationEvents zurück, um auf Benachrichtigungs-Events zu reagieren. |

### **4.3.4. Interne Events (NotificationEvent)**

Definiert in domain/src/notifications\_core/events.rs. Diese Events werden über tokio::sync::broadcast 6 verteilt, was eine entkoppelte Kommunikation innerhalb des Systems ermöglicht.

* **Zweck:** Andere Teile des Systems (primär die UI-Schicht über Adaptoren in der Systemschicht, aber auch andere Domänenmodule oder Logging-Dienste) über signifikante Änderungen im Benachrichtigungssystem zu informieren.  
* **Warum wertvoll:** Entkoppelte Kommunikation ist ein Schlüsselprinzip für modulare und wartbare Systeme. Die UI muss nicht direkt vom NotificationCoreManager aufgerufen werden; sie reagiert stattdessen auf Events.

Rust

// domain/src/notifications\_core/events.rs  
use crate::notifications\_core::types::{Notification, NotificationId};  
use chrono::{DateTime, Utc}; // Für Zeitstempel in Events

\# // Clone für Sender, PartialEq für Tests, Serde für ggf. externe Weiterleitung  
pub enum CloseReason {  
    DismissedByUser,  
    Expired,  
    Replaced,  
    AppClosed,      // App hat explizit CloseNotification gerufen  
    SystemShutdown,  
    AppScopeClear,  // Durch clear\_app\_notifications  
    Other(String),  
}

\# // Clone für Sender, Serde für ggf. externe Weiterleitung  
pub enum NotificationEvent {  
    NotificationAdded {  
        notification: Notification, // Die tatsächlich hinzugefügte (ggf. modifizierte) Notification  
        timestamp: DateTime\<Utc\>,  
    },  
    NotificationUpdated { // Falls Benachrichtigungen aktualisiert werden können (z.B. Fortschritt)  
        notification: Notification, // Die aktualisierte Notification  
        timestamp: DateTime\<Utc\>,  
    },  
    NotificationClosed {  
        notification\_id: NotificationId,  
        app\_name: String, // Nützlich für UI, um schnell zuordnen zu können  
        summary: String,  // Nützlich für UI  
        reason: CloseReason,  
        timestamp: DateTime\<Utc\>,  
    },  
    NotificationActionInvoked {  
        notification\_id: NotificationId,  
        action\_key: String,  
        timestamp: DateTime\<Utc\>,  
    },  
    NotificationHistoryCleared {  
        timestamp: DateTime\<Utc\>,  
    },  
    NotificationSuppressedByRule {  
        original\_summary: String, // Nur einige Infos, nicht die ganze Notification  
        app\_name: String,  
        rule\_id: String, // ID der verantwortlichen Regel  
        timestamp: DateTime\<Utc\>,  
    }  
}

* **Tabelle: NotificationEvent Varianten**

| Variante | Payload-Felder | Beschreibung |
| :---- | :---- | :---- |
| NotificationAdded | notification: Notification, timestamp | Eine neue Benachrichtigung wurde dem System hinzugefügt und ist (nach Regelprüfung) aktiv. |
| NotificationUpdated | notification: Notification, timestamp | Eine bestehende aktive Benachrichtigung wurde aktualisiert (z.B. Fortschrittsbalken). |
| NotificationClosed | notification\_id: NotificationId, app\_name, summary, reason: CloseReason, timestamp | Eine aktive Benachrichtigung wurde geschlossen. app\_name und summary für leichtere UI-Verarbeitung. |
| NotificationActionInvoked | notification\_id: NotificationId, action\_key: String, timestamp | Eine Aktion einer Benachrichtigung wurde ausgelöst. |
| NotificationHistoryCleared | timestamp | Die Benachrichtigungshistorie wurde geleert. |
| NotificationSuppressedByRule | original\_summary: String, app\_name: String, rule\_id: String, timestamp | Eine eingehende Benachrichtigung wurde aufgrund einer Regel unterdrückt und nicht aktiv angezeigt. |

* **Typische Publisher:** NotificationCoreManager.  
* **Typische Subscriber:** Die UI-Schicht (über einen Adapter in der Systemschicht, der D-Bus-Signale oder Wayland-Events generiert), Logging-Dienste, potenziell andere Domänenmodule, die auf Benachrichtigungsstatus reagieren müssen.

### **4.3.5. Fehlerbehandlung (NotificationCoreError)**

Definiert in domain/src/notifications\_core/error.rs mit thiserror.9

Rust

// domain/src/notifications\_core/error.rs  
use thiserror::Error;  
use crate::notifications\_core::types::NotificationId;  
use crate::notifications\_rules::error::NotificationRulesError;

\#  
pub enum NotificationCoreError {  
    \#  
    NotificationNotFound(NotificationId),

    \#\[error("Action '{action\_key}' not found for notification '{notification\_id}'.")\]  
    ActionNotFound {  
        notification\_id: NotificationId,  
        action\_key: String,  
    },

    \#\[error("Failed to apply notification rules: {source}")\]  
    RuleApplicationError {  
        \#\[from\] // Direkte Konvertierung von NotificationRulesError  
        source: NotificationRulesError  
    },

    \#\[error("Notification history is full (max size: {max\_size}). Cannot add notification '{summary}'.")\]  
    HistoryFull { max\_size: usize, summary: String },

    \#\[error("Invalid notification data: {message}")\]  
    InvalidNotificationData { message: String },

    \#\[error("Event channel error: {message}")\]  
    EventChannelError { message: String },

    \#  
    DuplicateNotificationId(NotificationId),

    \#  
    ReplacedNotificationNotFound(NotificationId),  
}

* **Tabelle: NotificationCoreError Varianten**

| Variante | Beschreibung |
| :---- | :---- |
| NotificationNotFound | Eine angeforderte Benachrichtigung (aktiv) wurde nicht gefunden. |
| ActionNotFound | Eine angeforderte Aktion für eine Benachrichtigung existiert nicht. |
| RuleApplicationError | Fehler bei der Anwendung von Regeln aus NotificationRulesEngine. Nutzt \#\[from\] für direkte Konvertierung. |
| HistoryFull | Die Benachrichtigungshistorie hat ihre maximale Kapazität erreicht und eine weitere kann nicht hinzugefügt werden. |
| InvalidNotificationData | Die Daten der hinzuzufügenden Benachrichtigung sind ungültig (z.B. fehlender summary). |
| EventChannelError | Fehler beim Senden eines NotificationEvent über den broadcast::Sender. |
| DuplicateNotificationId | Versuch, eine Benachrichtigung mit einer bereits existierenden ID zu den aktiven Benachrichtigungen hinzuzufügen. |
| ReplacedNotificationNotFound | Die in replaces\_id angegebene Benachrichtigung wurde nicht gefunden. |

### **4.3.6. Detaillierte Implementierungsschritte und Algorithmen**

1. **NotificationCoreManager::add\_notification:**  
   * Validiere new\_notification (z.B. app\_name, summary nicht leer, id muss gesetzt sein). Bei Fehler: Err(NotificationCoreError::InvalidNotificationData).  
   * Erwirb Schreibsperre für active\_notifications.  
   * Wenn new\_notification.id bereits in active\_notifications existiert: Err(NotificationCoreError::DuplicateNotificationId).  
   * **Regelanwendung:** Rufe self.rules\_engine.process\_notification(\&new\_notification).await auf.  
     * Bei Err(rules\_error): Err(NotificationCoreError::from(rules\_error)).  
     * Bei Ok(RuleProcessingResult::Suppress(rule\_id)):  
       * Sende NotificationSuppressedByRule Event.  
       * Die Benachrichtigung wird nicht aktiv. Ggf. zur Historie hinzufügen, falls die Regel dies impliziert oder new\_notification.is\_persistent ist (abhängig von Designentscheidung).  
       * Ok(new\_notification.id) zurückgeben (die ID der ursprünglichen, nun unterdrückten Benachrichtigung).  
     * Bei Ok(RuleProcessingResult::Allow(mut processed\_notification)):  
       * processed\_notification.timestamp\_displayed \= Some(Utc::now()).  
       * **Ersetzungslogik:** Wenn processed\_notification.replaces\_id ein Some(id\_to\_replace) ist:  
         * Versuche, die Benachrichtigung mit id\_to\_replace aus active\_notifications zu entfernen.  
         * Wenn erfolgreich entfernt, sende NotificationClosed Event für id\_to\_replace mit CloseReason::Replaced.  
         * Wenn nicht gefunden: Err(NotificationCoreError::ReplacedNotificationNotFound(id\_to\_replace)).  
       * Füge processed\_notification.clone() zu active\_notifications hinzu (mit ihrer eigenen id).  
       * Sende NotificationAdded { notification: processed\_notification.clone(),... } Event.  
       * Ok(processed\_notification.id).  
2. **NotificationCoreManager::close\_notification:**  
   * Erwirb Schreibsperren für active\_notifications und history.  
   * Entferne Benachrichtigung mit id aus active\_notifications. Wenn nicht gefunden: Err(NotificationCoreError::NotificationNotFound(id)).  
   * Sei closed\_notification die entfernte Benachrichtigung.  
   * Wenn closed\_notification.is\_persistent oder reason dies nahelegt (z.B. DismissedByUser, aber nicht Expired wenn nicht persistent):  
     * Rufe history.write().await.add(closed\_notification.clone()) auf. Handle HistoryFull Fehler, falls add diesen zurückgeben kann (oder logge es).  
   * Sende NotificationClosed { notification\_id: id, app\_name: closed\_notification.app\_name, summary: closed\_notification.summary, reason,... } Event.  
   * Ok(()).  
3. **NotificationHistory::add (interne Methode von NotificationHistory):**  
   * Wenn self.notifications.len() \>= self.max\_size und self.max\_size \> 0:  
     * self.notifications.pop\_front() (entferne die älteste).  
   * self.notifications.push\_back(notification).  
4. **NotificationCoreManager::invoke\_action:**  
   * Erwirb Lesesperre für active\_notifications.  
   * Hole Benachrichtigung mit notification\_id. Wenn nicht gefunden: Err(NotificationCoreError::NotificationNotFound).  
   * Prüfe, ob die Aktion mit action\_key in notification.actions existiert. Wenn nicht: Err(NotificationCoreError::ActionNotFound).  
   * Sende NotificationActionInvoked { notification\_id, action\_key: action\_key.to\_string(),... } Event.  
   * Ok(()). (Die Domänenschicht löst nur das Event aus; die tatsächliche Aktionsausführung erfolgt in höheren Schichten oder der Anwendung selbst).

### **4.3.7. Überlegungen zur Nebenläufigkeit und Zustandssynchronisierung**

* active\_notifications und history (bzw. dessen interne VecDeque) benötigen tokio::sync::RwLock für Thread-sicheren Lese- und Schreibzugriff, da mehrere Tasks (z.B. durch D-Bus-Aufrufe oder interne Timer) gleichzeitig auf Benachrichtigungen zugreifen könnten.  
* Die rules\_engine wird als Arc\<NotificationRulesEngine\> übergeben, da sie von mehreren Aufrufen (z.B. für jede neue Benachrichtigung) nebenläufig genutzt werden kann und ihr Zustand (die Regeln) ebenfalls Thread-sicher sein muss.  
* Der broadcast::Sender für NotificationEvent ist inhärent Thread-sicher.13

## **4.4. Entwicklungsmodul: Priorisierung und Regel-Engine für Benachrichtigungen (domain::notifications\_rules)**

Dieses Modul implementiert die Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf einem Satz von konfigurierbaren Regeln.

### **4.4.1. Detaillierte Verantwortlichkeiten und Ziele**

* **Verantwortlichkeiten:**  
  * Definition der Struktur von Benachrichtigungsregeln (NotificationRule), deren Bedingungen (RuleCondition) und Aktionen (RuleAction).  
  * Bereitstellung einer Engine (NotificationRulesEngine), die eingehende Benachrichtigungen anhand dieser Regeln bewertet.  
  * Ermöglichung von Modifikationen an Benachrichtigungen durch Regeln (z.B. Dringlichkeit ändern, Ton festlegen, Aktionen hinzufügen).  
  * Ermöglichung der Unterdrückung von Benachrichtigungen basierend auf Regelbedingungen.  
  * Interaktion mit domain::settings\_core (durch Empfang von SettingChangedEvents und Abfrage von Einstellungswerten), um kontextsensitive Regeln zu ermöglichen (z.B. "Nicht stören"-Modus, anwendungsspezifische Stummschaltungen).  
  * Laden und Verwalten von Regeldefinitionen. Diese können initial fest kodiert sein, sollten aber idealerweise aus einer externen Konfiguration (z.B. via SettingsProvider) geladen werden können, um Flexibilität zu gewährleisten.  
* **Ziele:**  
  * Schaffung einer flexiblen und erweiterbaren Logik zur dynamischen Anpassung des Benachrichtigungsverhaltens.  
  * Ermöglichung einer feingranularen Steuerung des Benachrichtigungsflusses durch den Benutzer (implizit über Systemeinstellungen) oder durch Systemadministratoren.  
  * Reduzierung von "Notification Fatigue" durch intelligente Filterung und Priorisierung.

Ein wichtiger Aspekt beim Design der Regel-Engine ist die Frage, ob Regeln fest im Code verankert oder datengetrieben (z.B. aus einer Konfigurationsdatei) sind. Ein datengetriebener Ansatz erhöht die Flexibilität und Wartbarkeit erheblich, da Regeln ohne Neukompilierung des Systems geändert oder hinzugefügt werden können. Dies erfordert, dass die Regelstrukturen (NotificationRule, RuleCondition, RuleAction) serde::Serialize und serde::Deserialize implementieren. Selbst wenn die erste Version mit fest kodierten Regeln startet, sollte das Design eine spätere Umstellung ermöglichen.

### **4.4.2. Entitäten und Wertobjekte**

Alle Typen sind in domain/src/notifications\_rules/types.rs zu definieren. Sie benötigen Debug, Clone, PartialEq und, für datengetriebene Regeln, serde::Serialize und serde::Deserialize.

* **RuleCondition (Enum, Wertobjekt)**  
  * **Zweck:** Definiert die Bedingungen, die erfüllt sein müssen, damit eine Regel ausgelöst wird.  
  * **Warum wertvoll:** Ermöglicht die flexible und kompositorische Definition von Kriterien für Regeln, von einfachen Vergleichen bis zu komplexen logischen Verknüpfungen.

| Variante | Assoziierte Daten | Beschreibung |
| :---- | :---- | :---- |
| AppNameIs | String | Der app\_name der Benachrichtigung entspricht exakt dem Wert (case-sensitive). |
| AppNameMatches | String (als Regex-Pattern zu interpretieren) | Der app\_name der Benachrichtigung entspricht dem regulären Ausdruck. |
| SummaryContains | String | Der summary der Benachrichtigung enthält den Text (case-insensitive). |
| SummaryMatches | String (Regex-Pattern) | Der summary der Benachrichtigung entspricht dem regulären Ausdruck. |
| BodyContains | String | Der body der Benachrichtigung (falls vorhanden) enthält den Text (case-insensitive). |
| UrgencyIs | NotificationUrgency | Die urgency der Benachrichtigung entspricht dem Wert. |
| CategoryIs | String | Die category der Benachrichtigung (falls vorhanden) entspricht exakt dem Wert. |
| HintExists | String (Schlüssel des Hints) | Ein bestimmter Schlüssel existiert in den hints der Benachrichtigung. |
| HintValueIs | (String (Hint-Schlüssel), SettingValue (erwarteter Wert)) | Ein bestimmter Hint-Schlüssel existiert und sein Wert entspricht dem SettingValue. |
| SettingIsTrue | SettingKey (Schlüssel zu einer Boolean-Einstellung) | Eine globale Systemeinstellung (aus SettingsCoreManager) ist auf true gesetzt. |
| SettingIsFalse | SettingKey (Schlüssel zu einer Boolean-Einstellung) | Eine globale Systemeinstellung ist auf false gesetzt. |
| SettingValueEquals | (SettingKey, SettingValue) | Eine globale Systemeinstellung hat exakt den spezifizierten Wert. |
| LogicalAnd | Vec\<RuleCondition\> | Alle Unterbedingungen in der Liste müssen wahr sein. |
| LogicalOr | Vec\<RuleCondition\> | Mindestens eine der Unterbedingungen in der Liste muss wahr sein. |
| LogicalNot | Box\<RuleCondition\> | Die umschlossene Unterbedingung muss falsch sein. |

* **RuleAction (Enum, Wertobjekt)**  
  * **Zweck:** Definiert die Aktionen, die ausgeführt werden, wenn die Bedingungen einer Regel erfüllt sind.  
  * **Warum wertvoll:** Beschreibt, wie eine Benachrichtigung als Reaktion auf eine Regel modifiziert oder behandelt wird.

| Variante | Assoziierte Daten | Beschreibung |
| :---- | :---- | :---- |
| SuppressNotification | \- | Unterdrückt die Benachrichtigung vollständig. Sie wird nicht aktiv und typischerweise auch nicht in der Historie gespeichert. |
| SetUrgency | NotificationUrgency | Ändert die urgency der Benachrichtigung auf den neuen Wert. |
| AddAction | NotificationAction | Fügt eine zusätzliche NotificationAction zur Liste der Aktionen der Benachrichtigung hinzu. |
| SetHint | (String (Hint-Schlüssel), SettingValue (Wert)) | Setzt oder überschreibt einen Wert in den hints der Benachrichtigung. |
| PlaySound | Option\<String\> (Sound-Datei/Name oder Event-Name) | Signalisiert, dass ein Ton abgespielt werden soll. None für einen Standard-Benachrichtigungston, Some(name) für einen spezifischen Ton. Die Implementierung des Abspielens erfolgt in der System- oder UI-Schicht. |
| MarkAsPersistent | bool | Setzt das is\_persistent-Flag der Benachrichtigung. |
| SetExpiration | Option\<i64\> (Millisekunden relativ zu jetzt) | Setzt oder ändert die Ablaufzeit der Benachrichtigung. None entfernt eine existierende Ablaufzeit. Ein positiver Wert gibt die Dauer in ms an. |
| LogMessage | (String (Level: "info", "warn", "debug"), String (Nachricht)) | Schreibt eine Nachricht ins System-Log (über das tracing-Framework). Nützlich für das Debugging von Regeln. |

* **NotificationRule (Struktur, Entität)**  
  * **Zweck:** Repräsentiert eine einzelne, vollständige Regel mit Bedingungen und Aktionen.  
  * **Warum wertvoll:** Die atomaren Bausteine der Regel-Engine. Eine Sammlung dieser Regeln definiert das Verhalten des Benachrichtigungssystems.

| Attribut | Typ | Sichtbarkeit | Beschreibung |
| :---- | :---- | :---- | :---- |
| id | String | pub | Eindeutige, menschenlesbare ID der Regel (z.B. "suppress-low-priority-chat", "urgentify-calendar-reminders"). |
| description | Option\<String\> | pub | Optionale, menschenlesbare Beschreibung des Zwecks der Regel. |
| conditions | RuleCondition | pub | Die Bedingung(en), die erfüllt sein müssen, damit die Regel angewendet wird. Oft eine LogicalAnd oder LogicalOr. |
| actions | Vec\<RuleAction\> | pub | Die Liste der Aktionen, die ausgeführt werden, wenn die conditions zutreffen. Die Reihenfolge kann relevant sein. |
| is\_enabled | bool | pub | Gibt an, ob die Regel aktiv ist und ausgewertet werden soll. Default: true. |
| priority | i32 | pub | Priorität der Regel. Regeln mit höherem Wert werden typischerweise früher ausgewertet. Default: 0\. |
| stop\_after | bool | pub | Wenn true und diese Regel zutrifft und Aktionen ausführt, werden keine weiteren (niedriger priorisierten) Regeln für diese Benachrichtigung mehr ausgewertet. Default: false. |

### **4.4.3. Öffentliche API des Moduls (NotificationRulesEngine)**

Definiert in domain/src/notifications\_rules/mod.rs.

Rust

// domain/src/notifications\_rules/mod.rs  
use crate::notifications\_core::types::{Notification, NotificationUrgency, SettingValue as NotificationSettingValue}; // SettingValue hier umbenannt zur Klarheit  
use crate::notifications\_rules::types::{NotificationRule, RuleCondition, RuleAction, NotificationAction as RuleNotificationAction};  
use crate::notifications\_rules::error::NotificationRulesError;  
use crate::settings\_core::{SettingsCoreManager, SettingChangedEvent, SettingKey, SettingValue};  
use std::sync::Arc;  
use tokio::sync::{RwLock, broadcast::Receiver as BroadcastReceiver}; // Receiver explizit benannt  
use tracing; // Für LogMessage Aktion

\#  
pub enum RuleProcessingResult {  
    Allow(Notification),  
    Suppress(String), // Enthält die ID der Regel, die zur Unterdrückung geführt hat  
}

pub struct NotificationRulesEngine {  
    rules: RwLock\<Vec\<NotificationRule\>\>,  
    settings\_manager: Arc\<SettingsCoreManager\>,  
    // settings\_update\_receiver: RwLock\<Option\<BroadcastReceiver\<SettingChangedEvent\>\>\>, // Für das Lauschen auf Einstellungsänderungen  
}

impl NotificationRulesEngine {  
    pub fn new(  
        settings\_manager: Arc\<SettingsCoreManager\>,  
        initial\_rules: Vec\<NotificationRule\>,  
        // mut settings\_event\_receiver: BroadcastReceiver\<SettingChangedEvent\> // Wird übergeben  
    ) \-\> Arc\<Self\> { // Gibt Arc\<Self\> zurück, um das Klonen für den Listener-Task zu erleichtern  
        let mut sorted\_rules \= initial\_rules;  
        sorted\_rules.sort\_by\_key(|r| \-r.priority); // Höchste Priorität zuerst

        let engine \= Arc::new(NotificationRulesEngine {  
            rules: RwLock::new(sorted\_rules),  
            settings\_manager,  
            // settings\_update\_receiver: RwLock::new(Some(settings\_event\_receiver)),  
        });

        // Hier könnte ein Task gestartet werden, der auf settings\_event\_receiver lauscht  
        // und self.handle\_setting\_changed aufruft.  
        // let engine\_clone \= Arc::clone(\&engine);  
        // tokio::spawn(async move {  
        //     if let Some(mut rx) \= engine\_clone.settings\_update\_receiver.write().await.take() {  
        //         while let Ok(event) \= rx.recv().await {  
        //             engine\_clone.handle\_setting\_changed(\&event).await;  
        //         }  
        //     }  
        // });

        engine  
    }

    pub async fn load\_rules(\&self, new\_rules: Vec\<NotificationRule\>) {  
        let mut rules\_guard \= self.rules.write().await;  
        \*rules\_guard \= new\_rules;  
        rules\_guard.sort\_by\_key(|r| \-r.priority); // Höchste Priorität zuerst  
        tracing::info\!("Notification rules reloaded. {} rules active.", rules\_guard.len());  
    }

    pub async fn process\_notification(  
        \&self,  
        notification: \&Notification,  
    ) \-\> Result\<RuleProcessingResult, NotificationRulesError\> {  
        let rules\_guard \= self.rules.read().await;  
        let mut current\_notification \= notification.clone();  
        let mut suppressed\_by\_rule\_id: Option\<String\> \= None;

        for rule in rules\_guard.iter().filter(|r| r.is\_enabled) {  
            if self.evaluate\_condition(\&rule.conditions, \&current\_notification, rule).await? {  
                tracing::debug\!("Rule '{}' matched for notification '{}'", rule.id, notification.summary);  
                for action in \&rule.actions {  
                    match self.apply\_action(action, \&mut current\_notification, rule).await? {  
                        RuleProcessingResult::Suppress(\_) \=\> {  
                            suppressed\_by\_rule\_id \= Some(rule.id.clone());  
                            break; // Aktion "Suppress" beendet Aktionsschleife für diese Regel  
                        }  
                        RuleProcessingResult::Allow(modified\_notification) \=\> {  
                            current\_notification \= modified\_notification;  
                        }  
                    }  
                }  
                if suppressed\_by\_rule\_id.is\_some() |  
| rule.stop\_after {  
                    break; // Regelverarbeitung für diese Benachrichtigung beenden  
                }  
            }  
        }

        if let Some(rule\_id) \= suppressed\_by\_rule\_id {  
            Ok(RuleProcessingResult::Suppress(rule\_id))  
        } else {  
            Ok(RuleProcessingResult::Allow(current\_notification))  
        }  
    }

    async fn evaluate\_condition(  
        \&self,  
        condition: \&RuleCondition,  
        notification: \&Notification,  
        rule: \&NotificationRule, // Für Kontext in Fehlermeldungen  
    ) \-\> Result\<bool, NotificationRulesError\> {  
        match condition {  
            RuleCondition::AppNameIs(name) \=\> Ok(\&notification.app\_name \== name),  
            RuleCondition::AppNameMatches(pattern) \=\> {  
                // Hier Regex-Implementierung, z.B. mit \`regex\` Crate  
                // Für dieses Beispiel: einfache Prüfung  
                match regex::Regex::new(pattern) {  
                    Ok(re) \=\> Ok(re.is\_match(\&notification.app\_name)),  
                    Err(e) \=\> Err(NotificationRulesError::ConditionEvaluationError{ rule\_id: Some(rule.id.clone()), message: format\!("Invalid regex pattern '{}': {}", pattern, e) })  
                }  
            }  
            RuleCondition::SummaryContains(text) \=\> Ok(notification.summary.to\_lowercase().contains(\&text.to\_lowercase())),  
            //... Implementierung für alle RuleCondition-Varianten...  
            RuleCondition::SettingIsTrue(key) \=\> {  
                match self.settings\_manager.get\_setting\_value(key).await {  
                    Ok(SettingValue::Boolean(b)) \=\> Ok(b),  
                    Ok(other\_type) \=\> {  
                        tracing::warn\!("Rule '{}' expected boolean for setting '{}', got {:?}", rule.id, key.as\_str(), other\_type);  
                        Ok(false) // Falscher Typ, als false bewerten  
                    }  
                    Err(SettingsCoreError::SettingNotFound{..}) | Err(SettingsCoreError::UnregisteredKey{..}) \=\> {  
                        tracing::debug\!("Rule '{}': Setting '{}' not found or unregistered, condition evaluates to false.", rule.id, key.as\_str());  
                        Ok(false) // Einstellung nicht gefunden, als false bewerten  
                    }  
                    Err(e) \=\> Err(NotificationRulesError::SettingsAccessError(e)) // Anderer Fehler beim Holen  
                }  
            }  
            RuleCondition::LogicalAnd(sub\_conditions) \=\> {  
                for sub\_cond in sub\_conditions {  
                    if\!self.evaluate\_condition(sub\_cond, notification, rule).await? {  
                        return Ok(false);  
                    }  
                }  
                Ok(true)  
            }  
            RuleCondition::LogicalOr(sub\_conditions) \=\> {  
                for sub\_cond in sub\_conditions {  
                    if self.evaluate\_condition(sub\_cond, notification, rule).await? {  
                        return Ok(true);  
                    }  
                }  
                Ok(false)  
            }  
            RuleCondition::LogicalNot(sub\_condition) \=\> {  
                Ok(\!self.evaluate\_condition(sub\_condition, notification, rule).await?)  
            }  
            // Standard-Fallback für nicht implementierte Bedingungen (sollte nicht passieren bei vollständiger Impl.)  
            \_ \=\> {  
                tracing::warn\!("Unimplemented condition met in rule '{}': {:?}", rule.id, condition);  
                Ok(false)  
            }  
        }  
    }

    async fn apply\_action(  
        \&self,  
        action: \&RuleAction,  
        notification: \&mut Notification,  
        rule: \&NotificationRule, // Für Kontext  
    ) \-\> Result\<RuleProcessingResult, NotificationRulesError\> {  
        tracing::debug\!("Applying action {:?} from rule '{}' to notification '{}'", action, rule.id, notification.summary);  
        match action {  
            RuleAction::SuppressNotification \=\> return Ok(RuleProcessingResult::Suppress(rule.id.clone())),  
            RuleAction::SetUrgency(new\_urgency) \=\> notification.urgency \= \*new\_urgency,  
            RuleAction::AddAction(new\_action) \=\> {  
                // Prüfen, ob Aktion mit gleichem Key schon existiert, um Duplikate zu vermeiden  
                if\!notification.actions.iter().any(|a| a.key \== new\_action.key) {  
                    notification.actions.push(new\_action.clone());  
                }  
            }  
            RuleAction::SetHint((key, value)) \=\> {  
                notification.hints.insert(key.clone(), value.clone().into\_setting\_value()); // Annahme: value ist hier ein Domänen-SettingValue  
            }  
            RuleAction::PlaySound(sound\_name\_opt) \=\> {  
                // Diese Aktion setzt typischerweise einen Hint, den die UI/Systemschicht interpretiert  
                let hint\_key \= "sound-name".to\_string();  
                if let Some(sound\_name) \= sound\_name\_opt {  
                    notification.hints.insert(hint\_key, NotificationSettingValue::String(sound\_name.clone()));  
                } else {  
                    // Signal für Standardton, z.B. spezieller Wert oder Entfernen des Hints  
                    notification.hints.remove(\&hint\_key);  
                }  
            }  
            RuleAction::MarkAsPersistent(is\_persistent) \=\> notification.is\_persistent \= \*is\_persistent,  
            RuleAction::SetExpiration(duration\_ms\_opt) \=\> {  
                if let Some(duration\_ms) \= duration\_ms\_opt {  
                    if \*duration\_ms \> 0 {  
                        notification.expires\_at \= Some(Utc::now() \+ chrono::Duration::milliseconds(\*duration\_ms));  
                    } else {  
                        notification.expires\_at \= None; // Negative oder Null-Dauer entfernt Expiration  
                    }  
                } else {  
                    notification.expires\_at \= None;  
                }  
            }  
            RuleAction::LogMessage((level, message)) \=\> {  
                let full\_message \= format\!(" {}", rule.id, message);  
                match level.as\_str() {  
                    "info" \=\> tracing::info\!("{}", full\_message),  
                    "warn" \=\> tracing::warn\!("{}", full\_message),  
                    "debug" \=\> tracing::debug\!("{}", full\_message),  
                    \_ \=\> tracing::trace\!("{}", full\_message), // Default zu trace  
                }  
            }  
        }  
        Ok(RuleProcessingResult::Allow(notification.clone()))  
    }

    // Diese Methode wird aufgerufen, wenn ein SettingChangedEvent empfangen wird.  
    // Sie könnte z.B. einen internen Cache für Settings aktualisieren, falls verwendet,  
    // oder Regeln neu bewerten, die von dieser Einstellung abhängen (komplexer).  
    // Für eine einfache Implementierung ohne Cache ist diese Methode ggf. leer  
    // oder löst nur einen Log-Eintrag aus.  
    pub async fn handle\_setting\_changed(\&self, event: \&SettingChangedEvent) {  
        tracing::debug\!("NotificationRulesEngine received SettingChangedEvent for key: {}", event.key.as\_str());  
        // Hier könnte Logik stehen, um z.B. interne Caches zu invalidieren,  
        // falls die Performance der direkten Abfrage des SettingsCoreManager ein Problem darstellt.  
        // Für die meisten Fälle sollte die direkte Abfrage bei Bedarf ausreichend sein.  
    }  
}

// Hilfskonvertierung für RuleAction::SetHint, falls SettingValue aus notifications\_rules::types  
// und settings\_core::types nicht identisch sind (sollten sie aber sein).  
// Hier wird angenommen, dass SettingValue aus settings\_core verwendet wird.  
trait IntoSettingValue {  
    fn into\_setting\_value(self) \-\> SettingValue;  
}  
impl IntoSettingValue for NotificationSettingValue { // Hier NotificationSettingValue ist Alias für settings\_core::SettingValue  
    fn into\_setting\_value(self) \-\> SettingValue {  
        self // Direkte Konvertierung, da Typen identisch sein sollten  
    }  
}

(Hinweis: Die regex-Crate müsste als Abhängigkeit hinzugefügt werden. Der Listener-Task für Einstellungsänderungen ist auskommentiert, da seine Implementierung von der genauen Architektur des Event-Handlings abhängt und den Rahmen sprengen könnte, aber das Prinzip ist wichtig.)

* **Tabelle: Methoden der NotificationRulesEngine**

| Methode | Signatur | Kurzbeschreibung |
| :---- | :---- | :---- |
| new | pub fn new(settings\_manager: Arc\<SettingsCoreManager\>, initial\_rules: Vec\<NotificationRule\>/\*, settings\_event\_receiver: BroadcastReceiver\<SettingChangedEvent\>\*/) \-\> Arc\<Self\> | Konstruktor. Lädt initiale Regeln, sortiert sie nach Priorität. Speichert Referenz auf SettingsCoreManager. Startet optional einen Task, um auf SettingChangedEvents zu lauschen. Gibt Arc\<Self\> zurück. |
| load\_rules | pub async fn load\_rules(\&self, new\_rules: Vec\<NotificationRule\>) | Lädt einen neuen Satz von Regeln, ersetzt die alten und sortiert sie neu nach Priorität. |
| process\_notification | pub async fn process\_notification(\&self, notification: \&Notification) \-\> Result\<RuleProcessingResult, NotificationRulesError\> | Verarbeitet eine eingehende Benachrichtigung anhand der geladenen, aktivierten Regeln. Gibt entweder eine (potenziell modifizierte) Benachrichtigung (Allow) oder ein Signal zur Unterdrückung (Suppress) mit der verantwortlichen Regel-ID zurück. |
| handle\_setting\_changed | pub async fn handle\_setting\_changed(\&self, event: \&SettingChangedEvent) | Wird (intern, z.B. durch einen dedizierten Task) aufgerufen, wenn sich eine für Regeln relevante Systemeinstellung ändert. Ermöglicht der Engine, ihren Zustand oder ihr Verhalten anzupassen (z.B. Cache-Invalidierung). |

Die Entscheidung, SettingValue aus settings\_core auch in den RuleCondition und RuleAction zu verwenden, vereinfacht die Typisierung und vermeidet unnötige Konvertierungen.

### **4.4.4. Fehlerbehandlung (NotificationRulesError)**

Definiert in domain/src/notifications\_rules/error.rs mit thiserror.

Rust

// domain/src/notifications\_rules/error.rs  
use thiserror::Error;  
use crate::settings\_core::error::SettingsCoreError; // Für Fehler beim Zugriff auf Settings

\#  
pub enum NotificationRulesError {  
    \#  
    InvalidRuleDefinition {  
        rule\_id: Option\<String\>,  
        message: String,  
    },

    \#\[error("Failed to evaluate condition for rule '{rule\_id:?}': {message}")\]  
    ConditionEvaluationError {  
        rule\_id: Option\<String\>,  
        message: String,  
    },

    \#\[error("Failed to apply action for rule '{rule\_id:?}': {message}")\]  
    ActionApplicationError {  
        rule\_id: Option\<String\>,  
        message: String,  
    },

    \#\[error("Error accessing settings for rule evaluation: {source}")\]  
    SettingsAccessError{  
        \#\[from\] // Direkte Konvertierung von SettingsCoreError  
        source: SettingsCoreError  
    },

    \# // Wird intern verwendet, falls Regeln auf andere verweisen  
    RuleNotFound(String),  
}

* **Tabelle: NotificationRulesError Varianten**

| Variante | Beschreibung |
| :---- | :---- |
| InvalidRuleDefinition | Eine geladene Regel ist ungültig (z.B. fehlerhaftes Regex-Pattern in AppNameMatches, widersprüchliche Bedingungen, unbekannte Aktionstypen). |
| ConditionEvaluationError | Ein Fehler trat während der Auswertung einer Bedingung auf (z.B. Regex-Kompilierungsfehler, interner Logikfehler). |
| ActionApplicationError | Ein Fehler trat während der Anwendung einer Aktion auf (z.B. ungültige Parameter für eine Aktion). |
| SettingsAccessError | Fehler beim Zugriff auf SettingsCoreManager für die Auswertung von Bedingungen, die auf Systemeinstellungen basieren. Nutzt \#\[from\]. |
| RuleNotFound | Eine referenzierte Regel-ID (z.B. in einer komplexen Regelstruktur) existiert nicht. |

### **4.4.5. Detaillierte Implementierungsschritte und Algorithmen**

1. **Initialisierung (NotificationRulesEngine::new):**  
   * Speichere den Arc\<SettingsCoreManager\>.  
   * Lade die initial\_rules.  
   * Sortiere die Regeln nach priority (absteigend, d.h. höhere numerische Werte zuerst) und dann ggf. nach id für deterministische Reihenfolge bei gleicher Priorität.  
   * **Abonnement von Einstellungsänderungen:** Es ist entscheidend, dass die Regel-Engine auf Änderungen von Systemeinstellungen reagieren kann, die in RuleConditions verwendet werden (z.B. "Nicht stören"-Modus).  
     * Der NotificationRulesEngine sollte beim Erstellen einen broadcast::Receiver\<SettingChangedEvent\> vom SettingsCoreManager erhalten (oder der SettingsCoreManager registriert die Engine als Listener).  
     * Ein dedizierter tokio::task sollte gestartet werden, der diesen Receiver konsumiert. Bei Empfang eines SettingChangedEvent ruft dieser Task engine.handle\_setting\_changed(\&event).await auf.  
     * handle\_setting\_changed kann dann z.B. einen internen Cache von oft benötigten Einstellungswerten invalidieren oder aktualisieren, um zu vermeiden, dass für jede Regelauswertung der SettingsCoreManager abgefragt werden muss (Performance-Optimierung, falls nötig). Für den Anfang kann es ausreichen, dass evaluate\_condition immer live den SettingsCoreManager abfragt.  
2. **NotificationRulesEngine::process\_notification:**  
   * Erwirb eine Lesesperre auf self.rules.  
   * Klone die eingehende notification, um Modifikationen zu ermöglichen (current\_notification).  
   * Iteriere durch die sortierten, aktivierten (rule.is\_enabled) Regeln.  
   * Für jede Regel:  
     * Evaluiere rule.conditions rekursiv mittels self.evaluate\_condition(\&rule.conditions, \&current\_notification, \&rule).await.  
     * Wenn die Bedingungen erfüllt sind (true):  
       * Iteriere durch rule.actions.  
       * Wende jede Aktion auf current\_notification an mittels self.apply\_action(action, \&mut current\_notification, \&rule).await.  
       * Wenn eine Aktion RuleProcessingResult::Suppress zurückgibt (z.B. RuleAction::SuppressNotification), speichere die rule.id und brich die Verarbeitung der Aktionen *dieser Regel* ab.  
       * Wenn RuleProcessingResult::Allow(modified\_notification) zurückgegeben wird, aktualisiere current\_notification \= modified\_notification.  
       * Wenn suppressed\_by\_rule\_id gesetzt wurde oder rule.stop\_after \== true ist, brich die Iteration über *weitere Regeln* ab.  
   * Wenn am Ende suppressed\_by\_rule\_id gesetzt ist, gib Ok(RuleProcessingResult::Suppress(rule\_id)) zurück.  
   * Andernfalls gib Ok(RuleProcessingResult::Allow(current\_notification)) zurück.  
3. **NotificationRulesEngine::evaluate\_condition (rekursiv):**  
   * Implementiere die Logik für jede RuleCondition-Variante:  
     * Einfache Vergleiche (AppNameIs, SummaryContains, UrgencyIs, etc.) sind direkte Vergleiche der Felder der notification.  
     * Regex-basierte Vergleiche (AppNameMatches, SummaryMatches) verwenden die regex-Crate. Fehler bei der Regex-Kompilierung (sollten idealerweise beim Laden der Regeln abgefangen werden) führen zu Err(NotificationRulesError::ConditionEvaluationError).  
     * HintExists, HintValueIs: Zugriff auf notification.hints.  
     * SettingIsTrue, SettingIsFalse, SettingValueEquals: Asynchroner Aufruf von self.settings\_manager.get\_setting\_value(\&key).await.  
       * Fehler wie SettingsCoreError::SettingNotFound oder UnregisteredKey sollten die Bedingung typischerweise als false bewerten lassen, anstatt einen harten Fehler in der Regel-Engine auszulösen, um die Robustheit zu erhöhen. Ein Log-Eintrag (Warnung oder Debug) ist hier angebracht. Andere SettingsCoreError (z.B. PersistenceError) sollten als Err(NotificationRulesError::SettingsAccessError) propagiert werden.  
     * LogicalAnd: Gibt true zurück, wenn alle Unterbedingungen true sind (Kurzschlussauswertung).  
     * LogicalOr: Gibt true zurück, wenn mindestens eine Unterbedingung true ist (Kurzschlussauswertung).  
     * LogicalNot: Negiert das Ergebnis der Unterbedingung.  
   * Alle Pfade müssen Result\<bool, NotificationRulesError\> zurückgeben.  
4. **NotificationRulesEngine::apply\_action:**  
   * Implementiere die Logik für jede RuleAction-Variante.  
   * Die meisten Aktionen modifizieren die übergebene \&mut Notification direkt (z.B. SetUrgency, AddAction, SetHint, MarkAsPersistent, SetExpiration).  
   * SuppressNotification gibt Ok(RuleProcessingResult::Suppress(...)) zurück.  
   * PlaySound könnte einen speziellen Hint setzen (z.B. sound-event: "message-new-instant"), den die UI-Schicht interpretiert.  
   * LogMessage verwendet das tracing-Makro (z.B. tracing::info\!).  
   * Alle Pfade geben Result\<RuleProcessingResult, NotificationRulesError\> zurück (meist Ok(RuleProcessingResult::Allow(notification.clone())) nach Modifikation).

### **4.4.6. Erweiterbarkeit und Konfiguration der Regeln**

* Um Regeln dynamisch (z.B. aus Konfigurationsdateien) laden zu können, müssen NotificationRule und alle eingebetteten Typen (RuleCondition, RuleAction) serde::Serialize und serde::Deserialize implementieren.  
* Die NotificationRulesEngine könnte eine Methode async fn load\_rules\_from\_provider(\&self, settings\_provider: Arc\<dyn SettingsProvider\>, config\_key: \&SettingKey) anbieten. Diese Methode würde:  
  1. Den settings\_provider verwenden, um eine serialisierte Regelmenge (z.B. als JSON-String oder eine Liste von serialisierten Regelobjekten) unter config\_key zu laden.  
  2. Die geladenen Daten deserialisieren in Vec\<NotificationRule\>.  
  3. Diese neuen Regeln über self.load\_rules(...) aktivieren.  
* Das Format der Serialisierung (z.B. JSON, YAML, TOML) muss sorgfältig entworfen werden, um sowohl menschenlesbar als auch maschinell verarbeitbar zu sein. Validierungsschemata (z.B. JSON Schema) können helfen, die Korrektheit der Regeldefinitionen sicherzustellen, bevor sie geladen werden.  
* Die Fehlerbehandlung beim Laden und Deserialisieren von Regeln muss robust sein (InvalidRuleDefinition).

Diese detaillierte Ausarbeitung der Einstellungs- und Benachrichtigungs-Subsysteme vervollständigt die Spezifikation der Domänenschicht und legt eine solide Grundlage für deren Implementierung. Die Betonung von klar definierten Schnittstellen, Typsicherheit, Fehlerbehandlung und Entkopplung durch Events und Abstraktionen ist entscheidend für die Entwicklung einer modernen, wartbaren und erweiterbaren Desktop-Umgebung.

# **Ultra-Feinspezifikation und Implementierungsplan: Systemschicht \- Teil 1/4**

## **I. Einleitung**

### **A. Zweck und Geltungsbereich dieses Dokuments (Teil 1/4 der Systemschicht)**

Dieses Dokument stellt den ersten von vier Teilen der Ultra-Feinspezifikation und des Implementierungsplans für die Systemschicht der neuartigen Linux-Desktop-Umgebung dar. Sein primäres Ziel ist es, Entwicklern eine erschöpfende und unzweideutige Anleitung für die direkte Implementierung der Kernkomponenten des Compositors und der Eingabeverarbeitung zu liefern. Der Detaillierungsgrad zielt darauf ab, jegliche Interpretationsspielräume während der Entwicklung auszuschließen; alle algorithmischen Entscheidungen, Datenstrukturen und API-Signaturen sind hierin vordefiniert.  
Der Geltungsbereich dieses ersten Teils ist strikt auf die Module system::compositor und system::input beschränkt, wie sie in der "Technischen Gesamtspezifikation und Entwicklungsrichtlinien" (im Folgenden als "Gesamtspezifikation" bezeichnet) definiert sind. Diese Module bilden das Fundament für die visuelle Darstellung und Benutzerinteraktion und sind somit grundlegend für alle nachfolgenden Komponenten der Systemschicht sowie für die darüberliegenden Schichten der Desktop-Umgebung.

### **B. Bezug zur "Technischen Gesamtspezifikation und Entwicklungsrichtlinien"**

Dieses Dokument ist eine direkte und detaillierte Erweiterung der Gesamtspezifikation. Es übersetzt die dort getroffenen übergeordneten Architekturentscheidungen, die Auswahl des Technologie-Stacks (Rust, Smithay, libinput usw.) und die Entwicklungsrichtlinien (Programmierstil, Fehlerbehandlung mittels thiserror, API-Designprinzipien, tracing für Logging) \[Gesamtspezifikation: Abschnitte II, III, IV\] in konkrete, implementierbare Spezifikationen. Insbesondere werden die in Abschnitt V.3 der Gesamtspezifikation skizzierten Komponenten der Systemschicht – hier der Compositor und die Eingabesubsysteme – detailliert ausgeführt.  
Die strikte Einhaltung der Gesamtspezifikation ist bindend. Sollten während der detaillierten Spezifikationsphase Konflikte oder Unklarheiten auftreten, die nicht durch dieses Dokument aufgelöst werden können, so sind die Prinzipien und Entscheidungen der Gesamtspezifikation maßgeblich. Dies unterstreicht die Notwendigkeit eines Prozesses zur Klärung solcher Fälle, um die Integrität der Gesamtarchitektur zu wahren. Die Qualität und Voraussicht der Gesamtspezifikation sind entscheidend für den Erfolg der Spezifikationen der einzelnen Schichten, da Lücken oder Inkonsistenzen in der Gesamtspezifikation sich in den detaillierten Implementierungsplänen potenzieren würden.

### **C. Überblick über die behandelten Module: system::compositor und system::input**

Dieser erste Teil der Systemspezifikation konzentriert sich auf zwei grundlegende Module:

1. **system::compositor**: Dieses Modul implementiert die Kernlogik des Wayland-Compositors unter Verwendung des Smithay-Toolkits. Zu seinen Verantwortlichkeiten gehören die Verwaltung von Wayland-Client-Verbindungen, der Lebenszyklus von Oberflächen (Erstellung, Mapping, Rendering, Zerstörung), die Pufferbehandlung (Shared Memory, SHM) und die Integration mit Shell-Protokollen, insbesondere xdg\_shell für modernes Desktop-Fenstermanagement. Es orchestriert das Rendering, delegiert jedoch die eigentlichen Zeichenbefehle an eine Renderer-Schnittstelle, die in späteren Teilen dieser Spezifikation detailliert wird.  
2. **system::input**: Dieses Modul ist für die gesamte Verarbeitung von Benutzereingaben zuständig, die von Geräten wie Tastaturen, Mäusen und Touchpads stammen. Es nutzt primär libinput für die Erfassung von Rohdaten-Ereignissen und die Eingabeabstraktionen von Smithay für das Seat- und Fokusmanagement.

Die Auswahl dieser beiden Module für den ersten Teil der Spezifikation ist strategisch, da sie das absolute Fundament für die Benutzerinteraktion und die visuelle Präsentation der Desktop-Umgebung bilden. Ohne einen funktionierenden Compositor und ein zuverlässiges Eingabesystem können keine übergeordneten Systemfunktionen oder Benutzeroberflächen realisiert werden. Fehler oder Ineffizienzen in diesen grundlegenden Modulen hätten kaskadierende negative Auswirkungen auf die gesamte Benutzererfahrung, einschließlich Leistung, Reaktionsfähigkeit und Stabilität. Daher müssen die von diesen Modulen für andere Schichten (Domänen- und UI-Schicht) bereitgestellten APIs von Anfang an außergewöhnlich stabil und wohldefiniert sein, da Änderungen hier zu einem späteren Zeitpunkt sehr kostspielig wären.  
Die enge Verzahnung dieser beiden Module ist offensichtlich: Vom system::input-Modul verarbeitete Eingabeereignisse bestimmen oft Fokusänderungen (verwaltet durch den SeatHandler), die wiederum beeinflussen, wie der system::compositor Ereignisse an Client-Oberflächen (WlSurface) weiterleitet. Das Verständnis des Compositors für Oberflächenlayout und \-zustand (verwaltet durch XdgShellHandler, CompositorHandler) ist für das Eingabesystem unerlässlich, um Ereignisziele korrekt zu identifizieren. Die DesktopState-Struktur, die den Gesamtzustand des Compositors kapselt, wird der zentrale Punkt sein, der all diese Smithay-Zustandsstrukturen hält und die notwendigen Handler implementiert.

#### **Tabelle: Dokumentkonventionen**

Zur Gewährleistung von Klarheit und Konsistenz in der Terminologie und den Referenzen in diesem und den nachfolgenden Teilen der Systemschichtspezifikation werden folgende Konventionen verwendet:

| Begriff/Konvention | Beschreibung | Beispiel |
| :---- | :---- | :---- |
| DesktopState | Die zentrale Compositor-Zustandsstruktur, die alle Smithay-Handler-Traits implementieren wird. | impl CompositorHandler for DesktopState |
| Gesamtspezifikation | Bezieht sich auf das Dokument "Technische Gesamtspezifikation und Entwicklungsrichtlinien". | Gemäß Gesamtspezifikation Abschnitt III. |
| WlFoo | Bezieht sich auf Wayland-Protokollobjekte (z.B. WlSurface, WlSeat). | fn commit(surface: \&WlSurface) |
| XdgFoo | Bezieht sich auf XDG-Shell-Protokollobjekte (z.B. XdgSurface, XdgToplevel). | let toplevel: ToplevelSurface \=... |
| Snippet-ID | Verweise auf Recherchematerial, z.B..1 | Smithay verwendet calloop.2 |
| system::foo::bar | Bezieht sich auf Module innerhalb der aktuellen Projektstruktur. | system::compositor::core |
| \# | Standardattribut für Fehlerdefinitionen gemäß Entwicklungsrichtlinien. | Siehe CompositorCoreError Definition. |
| tracing::{info, debug, error} | Standardmakros für Logging gemäß Entwicklungsrichtlinien. | tracing::info\!("Neue Oberfläche erstellt"); |

*Begründung für den Wert dieser Tabelle:* Diese Tabelle etabliert ein klares, gemeinsames Vokabular und Referenzierungssystem, das für ein Dokument dieser technischen Tiefe und für ein Projekt mit mehreren Entwicklern unerlässlich ist. Sie minimiert Mehrdeutigkeiten und stellt sicher, dass alle Beteiligten Verweise auf externe Dokumente, interne Komponenten und Wayland/Smithay-Entitäten verstehen.

## **II. Entwicklungsmodul: system::compositor (Smithay-basierter Wayland Compositor)**

### **A. Modulübersicht**

Dieses Modul implementiert die Kernlogik des Wayland-Compositors unter Verwendung des Smithay-Toolkits.1 Seine Hauptverantwortlichkeiten umfassen:

* Verwaltung von Wayland-Client-Verbindungen und deren Lebenszyklus.  
* Handhabung von Wayland-Protokollobjekten: wl\_display, wl\_compositor, wl\_subcompositor, wl\_shm, wl\_surface und XDG-Shell-Objekte (xdg\_wm\_base, xdg\_surface, xdg\_toplevel, xdg\_popup).  
* Integration mit der calloop-Ereignisschleife für die Ereignisverteilung.1  
* Koordination mit dem Rendering-Backend (hier werden Abstraktionen definiert, die konkrete Implementierung erfolgt in späteren Teilen).  
* Verwaltung von Oberflächenhierarchien, Rollen und Zuständen (z.B. Pufferanhänge, Schadensverfolgung).

Die Designphilosophie von Smithay, modular zu sein und kein einschränkendes Framework darzustellen 5, bedeutet, dass das system::compositor-Modul zwar Bausteine erhält, aber für deren korrekte Assemblierung und Verwaltung selbst verantwortlich ist. Dies schließt ein signifikantes Zustandsmanagement und Logik innerhalb der zentralen DesktopState-Struktur ein. Smithay fördert die Verwendung einer zentralen, mutierbaren Zustandsstruktur, die an Callbacks übergeben wird, um exzessive Nutzung von Rc\<RefCell\<T\>\> oder Arc\<Mutex\<T\>\> zu vermeiden.2 Verschiedene Smithay-Komponenten wie CompositorState, XdgShellState und ShmState sind so konzipiert, dass sie Teil der Hauptzustandsstruktur des Entwicklers werden. Handler-Traits (CompositorHandler, XdgShellHandler etc.) werden von dieser Hauptzustandsstruktur implementiert.6 Folglich wird DesktopState zu einer zentralen Drehscheibe für Wayland-Protokollinteraktionen. Während Smithay Low-Level-Protokolldetails handhabt, müssen die einzigartigen Richtlinien des Compositors (Fensterplatzierung, Fokusregeln jenseits des Basisprotokolls usw.) oft innerhalb der Handler-Trait-Methoden implementiert werden. Dies erfordert ein sorgfältiges Design von DesktopState, um seine Verantwortlichkeiten zu verwalten, ohne zu einem "God-Objekt" zu werden.  
Die Wahl von Smithay, das nativ in Rust geschrieben ist, passt perfekt zur primären Sprachwahl des Projekts (Rust) \[Gesamtspezifikation: Abschn. 3.1, 3.4\]. Dies minimiert die FFI-Komplexität im Kern des Compositors und nutzt die Sicherheitsgarantien von Rust. Die Verwendung eines Rust-nativen Toolkits für ein Rust-basiertes Projekt reduziert die Risiken und den Overhead, die mit der Sprachinteroperabilität (FFI) verbunden sind, wie z.B. unsichere C-Bindungen, Nichtübereinstimmungen bei der Speicherverwaltung und komplexe Build-System-Integration. Dies sollte zu einem robusteren und wartbareren Compositor-Kern führen als die direkte Integration von C-basierten Bibliotheken. Die Leistungscharakteristik des Compositors wird sowohl von der Effizienz von Smithay als auch von der Qualität des eigenen Rust-Codes innerhalb der Handler stark beeinflusst.

### **B. Submodul 1: Compositor-Kern (system::compositor::core)**

Dieses Submodul etabliert die grundlegenden Elemente für die Verwaltung von Wayland-Oberflächen und die Kernoperationen des Compositors.

#### **1\. Datei: compositor\_state.rs**

* **Zweck**: Definiert und verwaltet den primären Zustand für die Globals wl\_compositor und wl\_subcompositor und handhabt den Client-spezifischen Compositor-Zustand.  
* **Struktur: CompositorCoreError**  
  * Definiert Fehler, die spezifisch für Kernoperationen des Compositors sind.  
  * Verwendet thiserror gemäß den Entwicklungsrichtlinien.8  
  * **Tabelle: CompositorCoreError-Varianten**

| Variantenname | Felder | \#\[error("...")\] Nachricht (Beispiel) |
| :---- | :---- | :---- |
| GlobalCreationFailed | (String) | "Erstellung des globalen Objekts {0} fehlgeschlagen" |
| RoleError | (\#\[from\] SurfaceRoleError) | "Fehler bei der Oberflächenrolle: {0}" |
| ClientDataMissing | (wayland\_server::backend::ClientId) | "Client-Daten für Client-ID {0:?} nicht gefunden" |
| SurfaceDataMissing | (wayland\_server::protocol::wl\_surface::WlSurface) | "SurfaceData für WlSurface {0:?} nicht gefunden oder falscher Typ" |
| InvalidSurfaceState | (String) | "Ungültiger Oberflächenzustand: {0}" |

\*Begründung für den Wert dieser Tabelle:\* Klare, spezifische Fehlertypen sind entscheidend für die Fehlersuche und eine robuste Fehlerbehandlung und stehen im Einklang mit den Qualitätszielen des Projekts. \`thiserror\` vereinfacht deren Definition erheblich.

* **Struktur: DesktopState (Teilweise Definition \- Fokus auf Compositor-Aspekte)**  
  * Diese Struktur wird den zentralen Zustand für den gesamten Desktop kapseln. Hier konzentrieren wir uns auf Felder, die für den CompositorHandler relevant sind.  
  * Felder:  
    * compositor\_state: CompositorState (aus smithay::wayland::compositor) 6  
    * display\_handle: DisplayHandle (aus smithay::wayland::display::DisplayHandle, ermöglicht Interaktion mit der Wayland-Anzeige) 11  
    * loop\_handle: LoopHandle\<Self\> (aus calloop::LoopHandle\<Self\>, zur Interaktion mit der Ereignisschleife) 2  
    * (Weitere Zustände wie ShmState, XdgShellState, SeatState etc. werden in ihren jeweiligen Abschnitten detailliert.)  
  * Konstruktor:  
    Rust  
    // system/src/compositor/core/compositor\_state.rs  
    use smithay::wayland::compositor::{CompositorState, CompositorClientState, CompositorHandler};  
    use smithay::reexports::wayland\_server::{Client, DisplayHandle, protocol::wl\_surface::WlSurface};  
    use smithay::reexports::calloop::LoopHandle;  
    use std::sync::Arc;  
    use parking\_lot::Mutex; // Gemäß Vorgabe: Rust-Standard-Mutex oder crossbeam/parking\_lot  
                            // Hier parking\_lot für potenziell bessere Performance in umkämpften Szenarien.  
    use super::surface\_management::SurfaceData; // Pfad anpassen  
    use super::error::CompositorCoreError; // Pfad anpassen

    pub struct ClientCompositorData {  
        // Wird benötigt, um CompositorClientState pro Client zu speichern  
        pub compositor\_state: CompositorClientState,  
    }

    pub struct DesktopState {  
        pub display\_handle: DisplayHandle,  
        pub loop\_handle: LoopHandle\<Self\>,  
        pub compositor\_state: CompositorState,  
        // Weitere Zustände hier einfügen  
    }

    impl DesktopState {  
        pub fn new(display\_handle: DisplayHandle, loop\_handle: LoopHandle\<Self\>) \-\> Self {  
            let compositor\_state \= CompositorState::new::\<Self\>(\&display\_handle);  
            Self {  
                display\_handle,  
                loop\_handle,  
                compositor\_state,  
                // Initialisierung weiterer Zustände  
            }  
        }  
    }

* **Implementierung: CompositorHandler für DesktopState** 6  
  * Dieses Trait ist zentral dafür, wie Smithay Compositor-Ereignisse an unsere Anwendungslogik delegiert.  
  * Die Implementierung von ClientData (oft eine UserDataMap) in Smithay ist entscheidend für die Zuordnung beliebiger, typsicherer Daten zu Wayland-Client-Objekten.1 Wenn ein neuer Client eine Verbindung herstellt oder zum ersten Mal mit dem Compositor-Global interagiert, muss CompositorClientState korrekt initialisiert und in ClientData eingefügt werden. Die Bereinigung dieses Client-spezifischen Zustands wird implizit von Smithay gehandhabt, wenn ein Client die Verbindung trennt, da ClientData und dessen Inhalt dann verworfen werden.  
  * Methodenimplementierungen werden in der folgenden Tabelle detailliert.  
* **Tabelle: CompositorHandler-Methodenimplementierungsdetails für DesktopState**

| Methodenname | Signatur | Detaillierte Schritt-für-Schritt-Logik | Wichtige Smithay Funktionen/Daten | Fehlerbehandlung |
| :---- | :---- | :---- | :---- | :---- |
| compositor\_state | fn compositor\_state(\&mut self) \-\> \&mut CompositorState | 1\. \&mut self.compositor\_state zurückgeben. | self.compositor\_state | N/A |
| client\_compositor\_state | fn client\_compositor\_state\<'a\>(\&self, client: &'a Client) \-\> &'a CompositorClientState | 1\. tracing::debug\!(client\_id \=?client.id(), "Anfrage für ClientCompositorState"); 2\. match client.get\_data::\<Arc\<Mutex\<ClientCompositorData\>\>\>() (Annahme: ClientCompositorData wird in einem Arc\<Mutex\<\>\> in ClientData gespeichert). 3\. Wenn Some(data), let guard \= data.lock(); \&guard.compositor\_state zurückgeben (Achtung: Lebensdauer des Guards beachten; Smithay erwartet einen direkten Verweis. Ggf. Box::leak oder unsicheren Code vermeiden, indem CompositorClientState direkt in ClientData ist, falls Smithay dies unterstützt, oder die Datenstruktur anpassen). Smithay erwartet, dass dieser Zustand existiert. Wenn nicht, ist das ein schwerwiegender Fehler. 4\. Wenn None, tracing::error\!("ClientCompositorData nicht für Client {:?} gefunden.", client.id()); panic\!("ClientCompositorData nicht gefunden"); (oder CompositorCoreError::ClientDataMissing zurückgeben, falls die Trait-Signatur dies erlaubt, was sie hier nicht tut). | Client::get\_data(), UserDataMap, ClientCompositorData | CompositorCoreError::ClientDataMissing (intern geloggt, Panic, da Trait Rückgabe erzwingt). |
| commit | fn commit(\&mut self, surface: \&WlSurface) | 1\. tracing::debug\!(surface\_id \=?surface.id(), "Commit für Oberfläche empfangen"); 2\. Mittels \`smithay::wayland::compositor::with\_states(surface, | states | ...)aufSurfaceDatazugreifen, das mit der Oberfläche assoziiert ist. 3.let data\_map \= states.data\_map.get::\<Arc\<Mutex\<SurfaceData\>\>\>().ok\_or(CompositorCoreError::SurfaceDataMissing(surface.clone()))?;(Fehlerbehandlung anpassen). 4.let mut surface\_data \= data\_map.lock();5. Prüfen, ob ein neuer Puffer angehängt wurde (surface\_data.pending\_buffer.is\_some()). Ggf. Validierung des Puffertyps (SHM, DMABUF \- letzteres später). 6\. Schadensverfolgungsinformationen für die Oberfläche aktualisieren basierend aufstates.cached\_state.current::\<smithay::wayland::compositor::SurfaceAttributes\>().damage..6 7\. Wenn die Oberfläche eine Rolle hat (z.B. Toplevel, Popup, Cursor), rollenspezifische Commit-Logik auslösen (z.B. Fenstermanager benachrichtigen, Cursor aktualisieren). Dies beinhaltet die Prüfung vonsurface\_data.role\_data. 8\. Wenn die Oberfläche eine synchronisierte Subsurface ist, wird ihr Zustand möglicherweise nicht sofort angewendet.surface.is\_sync\_subsurface()prüfen.10 9\. Ggf. synchronisierte Kind-Subsurfaces mittelswith\_surface\_tree\_upwardoderwith\_surface\_tree\_downward\` iterieren, um deren ausstehende Zustände anzuwenden.10 10\. Oberfläche für Neuzeichnung/Rekompilierung durch die Rendering-Pipeline markieren. |
| new\_surface | fn new\_surface(\&mut self, surface: \&WlSurface) | 1\. tracing::info\!(surface\_id \=?surface.id(), "Neue WlSurface erstellt"); 2\. let client\_id \= surface.client().expect("Oberfläche muss einen Client haben").id(); 3\. SurfaceData für diese WlSurface initialisieren und mittels \`surface.data\_map().insert\_if\_missing\_threadsafe( | Arc::new(Mutex::new(SurfaceData::new(client\_id))));speichern. 4\. Zerstörungshook mittelssmithay::wayland::compositor::add\_destruction\_hook(surface, | data\_map |
| new\_subsurface | fn new\_subsurface(\&mut self, surface: \&WlSurface, parent: \&WlSurface) | 1\. tracing::info\!(surface\_id \=?surface.id(), parent\_id \=?parent.id(), "Neue WlSubsurface erstellt"); 2\. Der Handler new\_surface wird bereits für surface aufgerufen worden sein. 3\. SurfaceData von surface aktualisieren, um auf parent zu verlinken (z.B. surface\_data.parent \= Some(parent.downgrade())). 4\. SurfaceData von parent aktualisieren, um surface in einer Liste von Kindern hinzuzufügen (z.B. parent\_surface\_data.children.push(surface.downgrade())). 5\. Die Rolle "subsurface" wird typischerweise von Smithays Compositor-Modul verwaltet, wenn wl\_subcompositor.get\_subsurface gehandhabt wird.10 | WlSurface::data\_map(), SurfaceData, Object::downgrade() | Fehler beim Zugriff auf SurfaceData. |
| destroyed | fn destroyed(\&mut self, surface: \&WlSurface) | 1\. tracing::info\!(surface\_id \=?surface.id(), "WlSurface zerstört"); 2\. Die primäre Bereinigung von SurfaceData (und anderen Benutzerdaten) wird von Smithay gehandhabt, wenn das WlSurface-Objekt zerstört und seine UserDataMap verworfen wird. 3\. Alle externen Referenzen oder Zustände (z.B. in Fenstermanagementlisten), die starke Referenzen oder IDs zu dieser Oberfläche halten, müssen hier oder über Zerstörungshooks bereinigt werden. | UserDataMap::drop (implizit) | Sicherstellen, dass alle Referenzen auf die Oberfläche bereinigt werden, um Use-after-Free zu verhindern, falls nicht durch Weak-Zeiger oder Ähnliches verwaltet. |

\*Begründung für den Wert dieser Tabelle:\* Diese Tabelle ist entscheidend, da sie die abstrakten Anforderungen des \`CompositorHandler\`-Traits in konkrete Implementierungsschritte für Entwickler übersetzt und somit direkt die Anforderung der "Ultra-Feinspezifikation" erfüllt. Sie detailliert, \*wie\* mit Smithays \`CompositorState\` und \`SurfaceData\` zu interagieren ist.

* **Implementierung: GlobalDispatch\<WlCompositor, ()\> für DesktopState** 10  
  * fn bind(state: \&mut Self, handle: \&DisplayHandle, client: \&Client, resource: New\<WlCompositor\>, global\_data: &(), data\_init: \&mut DataInit\<'\_, Self\>): Wird aufgerufen, wenn ein Client an wl\_compositor bindet.  
    * **Schritt 1**: Protokollieren der Bind-Anfrage: tracing::info\!(client\_id \=?client.id(), resource\_id \=?resource.id(), "Client bindet an wl\_compositor");  
    * **Schritt 2**: Initialisieren der Client-spezifischen Compositor-Daten, falls noch nicht geschehen. client.get\_data::\<Arc\<Mutex\<ClientCompositorData\>\>\>() prüfen und ggf. client.insert\_user\_data(|| Arc::new(Mutex::new(ClientCompositorData { compositor\_state: CompositorClientState::new() })), | | {}); (Syntax für insert\_user\_data prüfen).  
    * **Schritt 3**: data\_init.init(resource, ()); (Das () ist der UserData-Typ für das WlCompositor-Global selbst, nicht für den Client).  
    * Die Erstellung des globalen wl\_compositor-Objekts wird von CompositorState::new() gehandhabt.10  
* **Implementierung: GlobalDispatch\<WlSubcompositor, ()\> für DesktopState** 10  
  * fn bind(state: \&mut Self, handle: \&DisplayHandle, client: \&Client, resource: New\<WlSubcompositor\>, global\_data: &(), data\_init: \&mut DataInit\<'\_, Self\>): Wird aufgerufen, wenn ein Client an wl\_subcompositor bindet.  
    * **Schritt 1**: Protokollieren: tracing::info\!(client\_id \=?client.id(), resource\_id \=?resource.id(), "Client bindet an wl\_subcompositor");  
    * **Schritt 2**: data\_init.init(resource, ());  
    * Smithays CompositorState handhabt auch das globale wl\_subcompositor-Objekt intern, wenn CompositorState::new() aufgerufen wird.10

#### **2\. Datei: surface\_management.rs**

* **Zweck**: Definiert SurfaceData und zugehörige Hilfsfunktionen für die Verwaltung von Wayland-Oberflächen.  
* **Struktur: SurfaceData**  
  * Diese Struktur wird in der UserDataMap jeder WlSurface gespeichert.1  
  * Felder:  
    * pub id: uuid::Uuid (Generiert bei Erstellung, für internes Tracking, benötigt uuid-Crate mit v4- und serde-Features 14).  
    * pub role: Option\<String\> (Speichert die via give\_role zugewiesene Rolle 10).  
    * pub client\_id: wayland\_server::backend::ClientId (ID des Clients, dem die Oberfläche gehört).  
    * pub current\_buffer: Option\<wl\_buffer::WlBuffer\> (Der aktuell angehängte und committete Puffer).  
    * pub pending\_buffer: Option\<wl\_buffer::WlBuffer\> (Puffer angehängt, aber noch nicht committet).  
    * pub texture\_id: Option\<Box\<dyn RenderableTexture\>\> (Handle zur gerenderten Textur; Typ abhängig von Renderer-Abstraktion, Box\<dyn...\> für dynamische Dispatch). Muss Send \+ Sync sein, wenn SurfaceData in Arc\<Mutex\<\>\> ist.  
    * pub last\_commit\_serial: smithay::utils::Serial (Serial des letzten Commits).  
    * pub damage\_regions\_buffer\_coords: Vec\<smithay::utils::Rectangle\<i32, smithay::utils::Buffer\>\> (Akkumulierter Schaden seit dem letzten Frame, in Pufferkoordinaten).  
    * pub opaque\_region: Option\<smithay::utils::Region\<smithay::utils::Logical\>\> (Wie vom Client gesetzt).  
    * pub input\_region: Option\<smithay::utils::Region\<smithay::utils::Logical\>\> (Wie vom Client gesetzt).  
    * pub user\_data\_ext: UserDataMap (Für weitere Erweiterbarkeit durch andere Module, z.B. XDG-Shell-Daten).  
    * pub parent: Option\<wayland\_server::Weak\<wl\_surface::WlSurface\>\>  
    * pub children: Vec\<wayland\_server::Weak\<wl\_surface::WlSurface\>\>  
    * pub pre\_commit\_hooks: Vec\<Box\<dyn FnMut(\&mut DesktopState, \&wl\_surface::WlSurface) \+ Send \+ Sync\>\>  
    * pub post\_commit\_hooks: Vec\<Box\<dyn FnMut(\&mut DesktopState, \&wl\_surface::WlSurface) \+ Send \+ Sync\>\>  
    * pub destruction\_hooks: Vec\<Box\<dyn FnOnce(\&mut DesktopState, \&wl\_surface::WlSurface) \+ Send \+ Sync\>\>  
  * Methoden:  
    * pub fn new(client\_id: wayland\_server::backend::ClientId) \-\> Self  
    * pub fn set\_role(\&mut self, role: \&str) \-\> Result\<(), SurfaceRoleError\> (Fehler, wenn Rolle bereits gesetzt).  
    * pub fn get\_role(\&self) \-\> Option\<\&String\>  
    * pub fn attach\_buffer(\&mut self, buffer: Option\<wl\_buffer::WlBuffer\>, serial: smithay::utils::Serial)  
    * pub fn commit\_buffer(\&mut self) (Verschiebt pending\_buffer zu current\_buffer, löscht pending\_buffer).  
    * pub fn add\_damage\_buffer\_coords(\&mut self, damage: smithay::utils::Rectangle\<i32, smithay::utils::Buffer\>)  
    * pub fn take\_damage\_buffer\_coords(\&mut self) \-\> Vec\<smithay::utils::Rectangle\<i32, smithay::utils::Buffer\>\>  
  * **Tabelle: SurfaceData-Felder**

| Feldname | Rust-Typ | Initialwert (Beispiel) | Mutabilität | Beschreibung | Invarianten |
| :---- | :---- | :---- | :---- | :---- | :---- |
| id | uuid::Uuid | Uuid::new\_v4() | immutable (nach Init) | Eindeutiger interner Identifikator. | Muss eindeutig sein. |
| role | Option\<String\> | None | mutable (einmalig setzbar) | Zugewiesene Rolle der Oberfläche (z.B. "toplevel"). | Kann nur einmal gesetzt werden. |
| client\_id | wayland\_server::backend::ClientId | Parameter des Konstruktors | immutable | ID des besitzenden Clients. | \- |
| current\_buffer | Option\<wl\_buffer::WlBuffer\> | None | mutable | Aktuell dargestellter Puffer. | \- |
| pending\_buffer | Option\<wl\_buffer::WlBuffer\> | None | mutable | Für den nächsten Commit angehängter Puffer. | \- |
| texture\_id | Option\<Box\<dyn RenderableTexture\>\> | None | mutable | Handle zur gerenderten Textur im Renderer. | Muss mit current\_buffer synchron sein. |
| last\_commit\_serial | smithay::utils::Serial | Serial::INITIAL | mutable | Serial des letzten erfolgreichen Commits. | \- |
| damage\_regions\_buffer\_coords | Vec\<Rectangle\<i32, Buffer\>\> | vec\! | mutable | Regionen des Puffers, die sich seit dem letzten Frame geändert haben. | Koordinaten relativ zum Puffer. |
| opaque\_region | Option\<Region\<Logical\>\> | None | mutable | Vom Client definierte undurchsichtige Region. | Koordinaten in logischen Einheiten. |
| input\_region | Option\<Region\<Logical\>\> | None | mutable | Vom Client definierte Eingaberegion. | Koordinaten in logischen Einheiten. |
| user\_data\_ext | UserDataMap | UserDataMap::new() | mutable | Zusätzliche benutzerspezifische Daten. | \- |
| parent | Option\<Weak\<WlSurface\>\> | None | mutable | Schwache Referenz auf die Elternoberfläche (für Subsurfaces). | \- |
| children | Vec\<Weak\<WlSurface\>\> | vec\! | mutable | Schwache Referenzen auf Kindoberflächen. | \- |
| pre\_commit\_hooks | Vec\<Box\<dyn FnMut(\&mut DesktopState, \&WlSurface) \+ Send \+ Sync\>\> | vec\! | mutable | Callbacks vor dem Commit. | \- |
| post\_commit\_hooks | Vec\<Box\<dyn FnMut(\&mut DesktopState, \&WlSurface) \+ Send \+ Sync\>\> | vec\! | mutable | Callbacks nach dem Commit. | \- |
| destruction\_hooks | Vec\<Box\<dyn FnOnce(\&mut DesktopState, \&WlSurface) \+ Send \+ Sync\>\> | vec\! | mutable | Callbacks bei Zerstörung. | \- |

\*Begründung für den Wert dieser Tabelle:\* Diese Tabelle bietet eine klare, strukturierte Definition aller Zustände, die mit einer Wayland-Oberfläche verbunden sind. Dies ist für Entwickler unerlässlich, um deren Lebenszyklus und Eigenschaften zu verstehen. Die Unterscheidung zwischen Puffer- und Logikkoordinaten sowie die explizite Auflistung von Hooks und Regionen sind für eine präzise Implementierung entscheidend.

* **Fehler-Enum: SurfaceRoleError** (in compositor\_state.rs oder einer gemeinsamen error.rs definiert)  
  * \#  
  * Varianten:  
    * \# RoleAlreadySet { existing\_role: String, new\_role: String }  
* **Funktionen:**  
  * pub fn get\_surface\_data(surface: \&WlSurface) \-\> Option\<Arc\<Mutex\<SurfaceData\>\>\>: Ruft SurfaceData über surface.data\_map().get::\<Arc\<Mutex\<SurfaceData\>\>\>().cloned() ab.  
  * pub fn with\_surface\_data\<F, R\>(surface: \&WlSurface, f: F) \-\> Result\<R, CompositorCoreError\> where F: FnOnce(\&mut SurfaceData) \-\> R: Kapselt das Locken und Entsperren des Mutex für SurfaceData.  
    Rust  
    // Beispielimplementierung  
    pub fn with\_surface\_data\<F, R\>(  
        surface: \&WlSurface,  
        callback: F,  
    ) \-\> Result\<R, CompositorCoreError\>  
    where  
        F: FnOnce(\&mut SurfaceData) \-\> R,  
    {  
        let data\_map\_guard \= surface  
           .data\_map()  
           .get::\<Arc\<Mutex\<SurfaceData\>\>\>()  
           .ok\_or\_else(|| CompositorCoreError::SurfaceDataMissing(surface.clone()))?  
           .clone(); // Klonen des Arc, um den Borrow von data\_map() freizugeben

        let mut surface\_data\_guard \= data\_map\_guard.lock();  
        Ok(callback(\&mut \*surface\_data\_guard))  
    }

  * pub fn give\_surface\_role(surface: \&WlSurface, role: &'static str) \-\> Result\<(), SurfaceRoleError\>: Verwendet intern smithay::wayland::compositor::give\_role(surface, role). 10  
  * pub fn get\_surface\_role(surface: \&WlSurface) \-\> Option\<String\>: Verwendet intern smithay::wayland::compositor::get\_role(surface).map(String::from). 10

#### **3\. Datei: global\_objects.rs**

* **Zweck**: Zentralisiert die Erstellung der Kern-Wayland-Globals, die vom system::compositor::core-Modul verwaltet werden.  
* **Funktion: pub fn create\_core\_compositor\_globals(display\_handle: \&DisplayHandle, state: \&mut DesktopState)**  
  * **Schritt 1**: Erstellen von CompositorState: let compositor\_state \= CompositorState::new::\<DesktopState\>(display\_handle);.10  
  * Speichern von compositor\_state in state.compositor\_state.  
  * Dies registriert intern die Globals wl\_compositor (Version 6\) und wl\_subcompositor (Version 1).10  
  * Protokollieren der Erstellung dieser Globals: tracing::info\!("wl\_compositor (v6) und wl\_subcompositor (v1) Globals erstellt.");

### **C. Submodul 2: SHM-Pufferbehandlung (system::compositor::shm)**

Dieses Submodul implementiert die Unterstützung für wl\_shm, wodurch Clients Shared-Memory-Puffer mit dem Compositor teilen können.

#### **1\. Datei: shm\_state.rs**

* **Zweck**: Verwaltet das wl\_shm-Global und handhabt die Erstellung und den Zugriff auf SHM-Puffer.  
* **Struktur: ShmError**  
  * \#  
  * Varianten:  
    * \# PoolCreationFailed(String)  
    * \# BufferCreationFailed(String)  
    * \# InvalidFormat(wl\_shm::Format)  
    * \# AccessError(\#\[from\] smithay::wayland::shm::BufferAccessError)  
  * **Tabelle: ShmError-Varianten**

| Variantenname | Felder | \#\[error("...")\] Nachricht |
| :---- | :---- | :---- |
| PoolCreationFailed | (String) | "Erstellung des SHM-Pools fehlgeschlagen: {0}" |
| BufferCreationFailed | (String) | "Erstellung des SHM-Puffers fehlgeschlagen: {0}" |
| InvalidFormat | (wl\_shm::Format) | "Ungültiges SHM-Format: {0:?}" |
| AccessError | (\#\[from\] smithay::wayland::shm::BufferAccessError) | "Fehler beim Zugriff auf SHM-Puffer: {0}" |

\*Begründung für den Wert dieser Tabelle:\* Spezifische Fehler für SHM-Operationen helfen bei der Diagnose von Client-Problemen oder internen Compositor-Problemen im Zusammenhang mit Shared Memory.

* **Struktur: DesktopState (Teilweise \- Fokus auf SHM-Aspekte)**  
  * Felder:  
    * shm\_state: ShmState (aus smithay::wayland::shm) 17  
    * shm\_global: GlobalId (um das Global am Leben zu erhalten)  
* **Implementierung: ShmHandler für DesktopState** 17  
  * fn shm\_state(\&self) \-\> \&ShmState: Gibt \&self.shm\_state zurück.  
* **Implementierung: BufferHandler für DesktopState** 17  
  * fn buffer\_destroyed(\&mut self, buffer: \&wl\_buffer::WlBuffer):  
    * **Schritt 1**: Protokollieren der Pufferzerstörung: tracing::debug\!(buffer\_id \=?buffer.id(), "SHM WlBuffer zerstört");  
    * **Schritt 2**: Das Rendering-Backend benachrichtigen, dass dieser Puffer nicht mehr gültig ist und alle zugehörigen GPU-Ressourcen freigegeben werden können. Dies erfordert eine Schnittstelle zum Renderer (Details später).  
    * **Schritt 3**: Wenn ein interner Zustand diesen Puffer direkt verfolgt (z.B. in einem Cache oder einer Liste aktiver Puffer für eine Oberfläche), entfernen Sie ihn. Dies geschieht oft durch Iterieren über alle SurfaceData-Instanzen und Setzen von current\_buffer/pending\_buffer auf None, wenn sie mit dem zerstörten Puffer übereinstimmen.  
  * Die Trait BufferHandler ist nicht spezifisch für SHM-Puffer, sondern gilt für alle wl\_buffer-Instanzen. Das bedeutet, dass die Logik in buffer\_destroyed robust genug sein muss, um Puffer aus verschiedenen Quellen (SHM, zukünftig DMABUF) zu handhaben. Wenn ein Client einen wl\_buffer erstellt (z.B. über wl\_shm\_pool.create\_buffer) und diesen an eine WlSurface anhängt und committet, könnte der CompositorHandler::commit diesen WlBuffer in SurfaceData speichern und seinen Inhalt möglicherweise auf die GPU hochladen, wodurch eine Textur-ID erhalten wird. Wenn der Client später den wl\_buffer freigibt, erkennt Smithay dies und ruft BufferHandler::buffer\_destroyed auf. Die Implementierung muss dann herausfinden, wo dieser WlBuffer verwendet wurde (z.B. in SurfaceData für eine beliebige Oberfläche) und zugehörige Ressourcen (wie die GPU-Textur) bereinigen. SurfaceData muss daher WlBuffer korrekt verfolgen, und die Renderer-Abstraktion muss eine Möglichkeit bieten, Texturen freizugeben, die mit einem WlBuffer oder seiner abgeleiteten Textur-ID verbunden sind.  
* **Implementierung: GlobalDispatch\<WlShm, ()\> für DesktopState** 13  
  * fn bind(state: \&mut Self, handle: \&DisplayHandle, client: \&Client, resource: New\<WlShm\>, global\_data: &(), data\_init: \&mut DataInit\<'\_, Self\>):  
    * **Schritt 1**: Protokollieren der wl\_shm-Bindung: tracing::info\!(client\_id \=?client.id(), resource\_id \=?resource.id(), "Client bindet an wl\_shm");  
    * **Schritt 2**: data\_init.init(resource, ());  
    * Smithays ShmState handhabt das Senden der format-Ereignisse beim Binden.16 Die unterstützten Formate werden bei der Initialisierung von ShmState festgelegt.  
* **Funktion: pub fn create\_shm\_global(display\_handle: \&DisplayHandle, state: \&mut DesktopState)**  
  * **Schritt 1**: Definieren der unterstützten SHM-Formate (zusätzlich zu den standardmäßigen ARGB8888, XRGB8888). Gemäß Gesamtspezifikation sind vorerst keine weiteren spezifischen Formate erforderlich. let additional\_formats: Vec\<wl\_shm::Format\> \= vec\!;  
  * **Schritt 2**: let shm\_state \= ShmState::new::\<DesktopState\>(display\_handle, additional\_formats.clone()); (Smithays ShmState::new erwartet \&DisplayHandle und Vec\<Format\>. Die Logger-Parameter sind in neueren Smithay-Versionen oft implizit durch tracing.).17  
  * **Schritt 3**: let shm\_global \= shm\_state.global().clone(); (Die global()-Methode gibt eine GlobalId zurück, die geklont werden kann, um das Global am Leben zu erhalten).  
  * Speichern von shm\_state und shm\_global in state.  
  * Protokollieren der Erstellung des SHM-Globals und der unterstützten Formate (einschließlich der Standardformate): tracing::info\!("wl\_shm Global erstellt. Unterstützte zusätzliche Formate: {:?}. Standardformate ARGB8888 und XRGB8888 sind immer verfügbar.", additional\_formats);

#### **2\. Datei: shm\_buffer\_access.rs**

* **Zweck**: Bietet sicheren Zugriff auf Inhalte von SHM-Puffern.  
* **Funktion: pub fn with\_shm\_buffer\_contents\<F, T, E\>(buffer: \&wl\_buffer::WlBuffer, callback: F) \-\> Result\<T, ShmError\>** wobei F: FnOnce(\*const u8, usize, \&smithay::wayland::shm::BufferData) \-\> Result\<T, E\>, E: Into\<ShmError\>. (Angepasst an Smithays with\_buffer\_contents, das möglicherweise einen anderen Fehlertyp oder eine andere Callback-Signatur hat). 17  
  * **Schritt 1**: Intern smithay::wayland::shm::with\_buffer\_contents(buffer, |ptr, len, data| {... }) verwenden.  
  * **Schritt 2**: Innerhalb des Smithay-Callbacks den bereitgestellten callback(ptr, len, data) aufrufen.  
  * **Schritt 3**: BufferAccessError von Smithay in ShmError::AccessError umwandeln oder den Fehler von callback mittels .map\_err(Into::into) propagieren.  
  * **Sicherheitshinweis**: Der ptr ist nur für die Dauer des Callbacks gültig. Auf die Daten darf außerhalb dieses Bereichs nicht zugegriffen werden. Diese Funktion kapselt die Unsicherheit der Zeiger-Dereferenzierung.  
* **Wertobjekt: ShmBufferView** (optional, falls direkter, langlebiger Zugriff benötigt wird, obwohl dies aus Sicherheitsgründen im Allgemeinen nicht empfohlen wird; Callback-basierter Zugriff ist vorzuziehen)  
  * pub id: uuid::Uuid  
  * pub data: Arc\<Vec\<u8\>\> (erfordert das Kopieren des Puffers, um die Lebensdauer zu verwalten).  
  * pub metadata: smithay::wayland::shm::BufferData (aus smithay::wayland::shm).  
  * Methoden: pub fn width(\&self) \-\> i32, pub fn height(\&self) \-\> i32, pub fn stride(\&self) \-\> i32, pub fn format(\&self) \-\> wl\_shm::Format.

### **D. Submodul 3: XDG-Shell-Integration (system::compositor::xdg\_shell)**

Dieses Submodul implementiert das xdg\_shell-Protokoll zur Verwaltung moderner Desktop-Fenster (Toplevels und Popups). Das xdg\_shell-Protokoll ist komplex und umfasst mehrere interagierende Objekte (xdg\_wm\_base, xdg\_surface, xdg\_toplevel, xdg\_popup, xdg\_positioner). Smithays XdgShellState und XdgShellHandler abstrahieren einen Großteil dieser Komplexität, aber die Handler-Methoden erfordern dennoch eine signifikante Logik.7 Das Protokoll beinhaltet eine Zustandsmaschine für Oberflächen (z.B. initiale Konfiguration, ack\_configure, nachfolgende Konfigurationen).19 Anfragen wie set\_title, set\_app\_id, set\_maximized, move, resize müssen verarbeitet werden und führen oft zu neuen configure-Ereignissen, die an den Client gesendet werden.19 Popups haben eine komplizierte Positionierungslogik basierend auf xdg\_positioner.7 Daher werden die XdgShellHandler-Methoden in DesktopState umfangreich sein. Sie müssen Oberflächenzustände korrekt verwalten, mit der Fensterverwaltungsrichtlinie der Domänenschicht interagieren (hier nicht detailliert, aber ein Schnittstellenpunkt) und korrekte Wayland-Ereignisse an Clients senden. Eine robuste Fehlerbehandlung und Zustandsvalidierung sind bei der Implementierung von xdg\_shell von größter Bedeutung, um Abstürze des Compositors oder fehlverhaltende Client-Fenster zu verhindern. Smithays Zustandsverfolgung (z.B. SurfaceCachedState, ToplevelSurfaceData) hilft dabei, aber die Logik muss sie korrekt verwenden.7

#### **1\. Datei: xdg\_shell\_state.rs**

* **Zweck**: Verwaltet das xdg\_wm\_base-Global und die zugehörigen XDG-Oberflächenzustände.  
* **Struktur: XdgShellError**  
  * \#  
  * Varianten:  
    * \# InvalidSurfaceRole  
    * \# WindowHandlingError(uuid::Uuid)  
    * \#\[error("Fehler bei der Popup-Positionierung.")\] PopupPositioningError  
    * \# InvalidAckConfigureSerial(smithay::utils::Serial)  
    * \# ToplevelNotFound(uuid::Uuid)  
    * \# PopupNotFound(uuid::Uuid)  
  * **Tabelle: XdgShellError-Varianten** (Analog zu vorherigen Fehlertabellen)  
* **Struktur: DesktopState (Teilweise \- Fokus auf XDG-Shell-Aspekte)**  
  * Felder:  
    * xdg\_shell\_state: XdgShellState (aus smithay::wayland::shell::xdg) 7  
    * xdg\_shell\_global: GlobalId  
    * toplevels: std::collections::HashMap\<WlSurface, Arc\<Mutex\<ManagedToplevel\>\>\> (oder eine andere geeignete Struktur zur Verwaltung von ManagedToplevel-Instanzen, indiziert durch WlSurface oder eine interne ID).  
    * popups: std::collections::HashMap\<WlSurface, Arc\<Mutex\<ManagedPopup\>\>\>  
* **Implementierung: XdgShellHandler für DesktopState** 7  
  * fn xdg\_shell\_state(\&mut self) \-\> \&mut XdgShellState: Gibt \&mut self.xdg\_shell\_state zurück.  
  * Die Implementierung der einzelnen XdgShellHandler-Methoden wird in xdg\_handlers.rs detailliert.  
* **Implementierung: GlobalDispatch\<XdgWmBase, GlobalId\> für DesktopState** 7  
  * fn bind(state: \&mut Self, handle: \&DisplayHandle, client: \&Client, resource: New\<XdgWmBase\>, global\_data: \&GlobalId, data\_init: \&mut DataInit\<'\_, Self\>):  
    * **Schritt 1**: Protokollieren der xdg\_wm\_base-Bindung: tracing::info\!(client\_id \=?client.id(), resource\_id \=?resource.id(), "Client bindet an xdg\_wm\_base");  
    * **Schritt 2**: let shell\_client\_user\_data \= state.xdg\_shell\_state.new\_client(client); (Smithay's new\_client gibt ShellClientUserData zurück, das für die Initialisierung des XdgWmBase-Ressourcen-Userdatas verwendet werden kann). 7  
    * **Schritt 3**: data\_init.init(resource, shell\_client\_user\_data); (Assoziieren der ShellClientUserData mit der xdg\_wm\_base-Ressource).  
    * Das XdgWmBase-Global selbst sendet ein ping-Ereignis, wenn der Client nicht rechtzeitig mit pong antwortet; Smithays XdgShellState handhabt dies.7  
* **Funktion: pub fn create\_xdg\_shell\_global(display\_handle: \&DisplayHandle, state: \&mut DesktopState)**  
  * **Schritt 1**: let xdg\_shell\_state \= XdgShellState::new::\<DesktopState\>(display\_handle);.7  
  * **Schritt 2**: let xdg\_shell\_global \= xdg\_shell\_state.global().clone(); (Die global()-Methode von XdgShellState gibt die GlobalId des xdg\_wm\_base-Globals zurück).  
  * Speichern von xdg\_shell\_state und xdg\_shell\_global in state.  
  * Protokollieren der Erstellung des XDG-Shell-Globals: tracing::info\!("xdg\_wm\_base Global erstellt.");

#### **2\. Datei: toplevel\_management.rs**

* **Zweck**: Definiert Datenstrukturen und Logik, die spezifisch für XDG-Toplevel-Fenster sind.  
* **Struktur: ManagedToplevel**  
  * Diese Struktur kapselt eine smithay::wayland::shell::xdg::ToplevelSurface und fügt anwendungsspezifische Zustände und Logik hinzu.  
  * Felder:  
    * pub id: uuid::Uuid (Eindeutiger interner Identifikator).  
    * pub surface\_handle: ToplevelSurface (Das Smithay-Handle zur XDG-Toplevel-Oberfläche).7  
    * pub wl\_surface: WlSurface (Die zugrundeliegende WlSurface).  
    * pub app\_id: Option\<String\>  
    * pub title: Option\<String\>  
    * pub current\_state: ToplevelWindowState (z.B. maximiert, Vollbild, aktiv, Größe).  
    * pub pending\_state: ToplevelWindowState (Für den nächsten Configure-Zyklus).  
    * pub window\_geometry: smithay::utils::Rectangle\<i32, smithay::utils::Logical\> (Aktuelle Fenstergeometrie).  
    * pub min\_size: Option\<smithay::utils::Size\<i32, smithay::utils::Logical\>\>  
    * pub max\_size: Option\<smithay::utils::Size\<i32, smithay::utils::Logical\>\>  
    * pub parent: Option\<wayland\_server::Weak\<WlSurface\>\> (Für transiente Fenster).  
    * pub client\_provides\_decorations: bool (Abgeleitet aus Interaktion mit xdg-decoration).  
    * pub last\_configure\_serial: Option\<smithay::utils::Serial\>  
    * pub acked\_configure\_serial: Option\<smithay::utils::Serial\>  
  * Methoden:  
    * pub fn new(surface\_handle: ToplevelSurface, wl\_surface: WlSurface) \-\> Self  
    * pub fn send\_configure(\&mut self): Bereitet einen xdg\_toplevel.configure und xdg\_surface.configure vor und sendet ihn basierend auf dem pending\_state. Aktualisiert last\_configure\_serial.  
    * pub fn ack\_configure(\&mut self, serial: smithay::utils::Serial): Verarbeitet ein ack\_configure vom Client.  
    * Methoden zum Setzen von Zuständen im pending\_state (z.B. set\_maximized\_pending(bool)).  
* **Struktur: ToplevelWindowState**  
  * Felder:  
    * pub size: Option\<smithay::utils::Size\<i32, smithay::utils::Logical\>\>  
    * pub maximized: bool  
    * pub fullscreen: bool  
    * pub resizing: bool  
    * pub activated: bool  
    * pub suspended: bool (z.B. wenn minimiert oder nicht sichtbar)  
    * pub decorations: smithay::wayland::shell::xdg::decoration::XdgToplevelDecorationMode (Standard: ClientSide)  
* **Struktur: ToplevelSurfaceUserData** (Wird in WlSurface::data\_map() gespeichert, um auf ManagedToplevel zu verlinken)  
  * pub managed\_toplevel\_id: uuid::Uuid  
* **Tabelle: ManagedToplevel-Felder** (Analog zu SurfaceData-Felder-Tabelle)  
* **Tabelle: ToplevelWindowState-Felder** (Analog zu SurfaceData-Felder-Tabelle)

#### **3\. Datei: popup\_management.rs**

* **Zweck**: Definiert Datenstrukturen und Logik, die spezifisch für XDG-Popup-Fenster sind.  
* **Struktur: ManagedPopup**  
  * Kapselt eine smithay::wayland::shell::xdg::PopupSurface.  
  * Felder:  
    * pub id: uuid::Uuid  
    * pub surface\_handle: PopupSurface 7  
    * pub wl\_surface: WlSurface  
    * pub parent\_wl\_surface: wayland\_server::Weak\<WlSurface\> (Eltern-WlSurface, nicht unbedingt ein Toplevel).  
    * pub positioner\_state: smithay::wayland::shell::xdg::PositionerState 7  
    * pub current\_geometry: smithay::utils::Rectangle\<i32, smithay::utils::Logical\> (Berechnet aus Positioner und Elterngröße).  
    * pub last\_configure\_serial: Option\<smithay::utils::Serial\>  
    * pub acked\_configure\_serial: Option\<smithay::utils::Serial\>  
  * Methoden:  
    * pub fn new(surface\_handle: PopupSurface, wl\_surface: WlSurface, parent\_wl\_surface: WlSurface, positioner: PositionerState) \-\> Self  
    * pub fn send\_configure(\&mut self): Sendet xdg\_popup.configure und xdg\_surface.configure.  
    * pub fn ack\_configure(\&mut self, serial: smithay::utils::Serial)  
    * pub fn calculate\_geometry(\&self) \-\> smithay::utils::Rectangle\<i32, smithay::utils::Logical\>: Berechnet die Popup-Geometrie basierend auf positioner\_state und der Geometrie der Elternoberfläche.  
* **Struktur: PopupSurfaceUserData** (Wird in WlSurface::data\_map() gespeichert)  
  * pub managed\_popup\_id: uuid::Uuid  
* **Tabelle: ManagedPopup-Felder** (Analog zu SurfaceData-Felder-Tabelle)

#### **4\. Datei: xdg\_handlers.rs**

* **Zweck**: Detaillierte Implementierung der XdgShellHandler-Methoden für DesktopState.  
* **Implementierung XdgShellHandler für DesktopState:**  
  * fn new\_toplevel(\&mut self, surface: ToplevelSurface) 7:  
    * **Schritt 1**: Protokollieren: tracing::info\!(surface \=?surface.wl\_surface().id(), "Neues XDG Toplevel erstellt.");  
    * **Schritt 2**: let wl\_surface \= surface.wl\_surface().clone();  
    * **Schritt 3**: Erstellen einer neuen ManagedToplevel-Instanz: let managed\_toplevel \= ManagedToplevel::new(surface, wl\_surface.clone());  
    * **Schritt 4**: Speichern der managed\_toplevel.id in ToplevelSurfaceUserData und Einfügen in wl\_surface.data\_map().  
    * **Schritt 5**: self.toplevels.insert(wl\_surface.clone(), Arc::new(Mutex::new(managed\_toplevel)));  
    * **Schritt 6**: Initiale Konfiguration senden. let mut guard \= self.toplevels.get(\&wl\_surface).unwrap().lock(); guard.send\_configure();  
  * fn new\_popup(\&mut self, surface: PopupSurface, positioner: PositionerState) 7:  
    * **Schritt 1**: Protokollieren.  
    * **Schritt 2**: let wl\_surface \= surface.wl\_surface().clone();  
    * **Schritt 3**: let parent\_wl\_surface \= surface.get\_parent\_surface().expect("Popup muss eine Elternoberfläche haben.");  
    * **Schritt 4**: Erstellen ManagedPopup: let managed\_popup \= ManagedPopup::new(surface, wl\_surface.clone(), parent\_wl\_surface, positioner);  
    * **Schritt 5**: PopupSurfaceUserData in wl\_surface.data\_map() speichern.  
    * **Schritt 6**: self.popups.insert(wl\_surface.clone(), Arc::new(Mutex::new(managed\_popup)));  
    * **Schritt 7**: Initiale Konfiguration senden. let mut guard \= self.popups.get(\&wl\_surface).unwrap().lock(); guard.send\_configure();  
  * fn map\_toplevel(\&mut self, surface: \&ToplevelSurface):  
    * **Schritt 1**: Protokollieren.  
    * **Schritt 2**: let wl\_surface \= surface.wl\_surface();  
    * **Schritt 3**: let managed\_toplevel\_arc \= self.toplevels.get(wl\_surface).ok\_or\_else(|| XdgShellError::WindowHandlingError(Default::default()))?;  
    * **Schritt 4**: let mut managed\_toplevel \= managed\_toplevel\_arc.lock();  
    * **Schritt 5**: Logik für das Mapping des Toplevels ausführen (z.B. Sichtbarkeit im Fenstermanager aktualisieren, initiale Position/Größe gemäß Richtlinien festlegen, falls nicht vom Client spezifiziert).  
    * **Schritt 6**: Ggf. send\_configure aufrufen, wenn sich der Zustand durch das Mapping ändert (z.B. Aktivierung).  
  * fn ack\_configure(\&mut self, surface: WlSurface, configure: smithay::wayland::shell::xdg::XdgSurfaceConfigure) 7:  
    * **Schritt 1**: Protokollieren: tracing::debug\!(surface \=?surface.id(), serial \=?configure.serial, "XDG Surface ack\_configure empfangen.");  
    * **Schritt 2**: Herausfinden, ob es sich um ein Toplevel oder Popup handelt, basierend auf get\_role(\&surface).  
    * **Schritt 3**: Entsprechendes ManagedToplevel oder ManagedPopup aus self.toplevels oder self.popups abrufen.  
    * **Schritt 4**: managed\_entity.lock().ack\_configure(configure.serial);  
    * **Schritt 5**: Wenn dies ein ack auf eine Größenänderung war, muss der Fenstermanager ggf. Layoutanpassungen vornehmen.  
  * fn toplevel\_request\_set\_title(\&mut self, surface: \&ToplevelSurface, title: String):  
    * **Schritt 1**: let wl\_surface \= surface.wl\_surface();  
    * **Schritt 2**: let managed\_toplevel\_arc \= self.toplevels.get(wl\_surface).ok\_or\_else(...)?;  
    * **Schritt 3**: let mut managed\_toplevel \= managed\_toplevel\_arc.lock();  
    * **Schritt 4**: managed\_toplevel.title \= Some(title);  
    * **Schritt 5**: UI-Schicht benachrichtigen (z.B. über Event-Bus), um Titelleisten zu aktualisieren.  
  * (Weitere Handler für set\_app\_id, set\_maximized, unset\_maximized, set\_fullscreen, unset\_fullscreen, set\_minimized, move, resize, show\_window\_menu, destroy\_toplevel, destroy\_popup, grab\_popup, reposition\_popup usw. müssen analog implementiert werden, wobei jeweils der Zustand des entsprechenden ManagedToplevel oder ManagedPopup aktualisiert und ggf. ein neuer configure-Zyklus ausgelöst oder mit dem Input-System interagiert wird.)  
  * **Tabelle: XdgShellHandler-Kernmethodenimplementierungsdetails** (Auszug)

| Methodenname | Protokoll-Anfrage/-Ereignis | Detaillierte Schritt-für-Schritt-Logik | Wichtige Smithay-Strukturen/-Funktionen | Interaktion mit Fenstermanagement-Richtlinie | Wayland-Ereignisse an Client gesendet |
| :---- | :---- | :---- | :---- | :---- | :---- |
| new\_toplevel | xdg\_wm\_base.get\_xdg\_surface, xdg\_surface.get\_toplevel | Siehe oben. | ToplevelSurface, WlSurface::data\_map(), ManagedToplevel::new(), send\_configure() | Initiale Platzierung/Größe könnte von Richtlinie beeinflusst werden. | xdg\_toplevel.configure, xdg\_surface.configure |
| ack\_configure | xdg\_surface.ack\_configure | Siehe oben. | XdgSurfaceConfigure, ManagedToplevel/Popup::ack\_configure() | Richtlinie könnte auf Zustandsänderung reagieren (z.B. nach Größenänderung). | Keine direkt, aber Voraussetzung für weitere configure. |
| toplevel\_request\_set\_maximized | xdg\_toplevel.set\_maximized | 1\. ManagedToplevel finden. 2\. pending\_state.maximized \= true;. 3\. pending\_state.size ggf. anpassen. 4\. send\_configure() aufrufen. | ToplevelSurface, ManagedToplevel, send\_configure() | Richtlinie entscheidet, ob Maximierung erlaubt ist und wie sie umgesetzt wird (z.B. Größe des Outputs). | xdg\_toplevel.configure (mit Maximierungsstatus und neuer Größe), xdg\_surface.configure. |
| move\_request | xdg\_toplevel.move | 1\. ManagedToplevel finden. 2\. Input-System benachrichtigen, einen interaktiven Move-Grab zu starten. 3\. Seat::start\_pointer\_grab mit speziellem Grab-Handler. | ToplevelSurface, WlSeat, Serial, Seat::start\_pointer\_grab | Richtlinie kann interaktiven Move beeinflussen (z.B. Snapping). | Keine direkt während des Moves, aber Fokus-Events. |

\*Begründung für den Wert dieser Tabelle:\* Dies ist das Kernstück der XDG-Shell-Funktionalität. Detaillierte Schritte stellen sicher, dass Entwickler die Protokolllogik korrekt implementieren, einschließlich Zustandsübergängen und Interaktionen mit anderen Systemteilen.

### **E. Submodul 4: Display und Ereignisschleife (system::compositor::display\_loop)**

Dieses Submodul ist verantwortlich für die Einrichtung des Wayland-Display-Kernobjekts und dessen Integration in die calloop-Ereignisschleife. Die calloop-Ereignisschleife ist zentral für die Architektur von Smithay. Alle Ereignisquellen (Wayland-Client-FDs, libinput-FDs, Timer, ggf. D-Bus-FDs) werden bei ihr registriert, und ihre Callbacks treiben die Logik des Compositors an.1 Das Display-Objekt von Smithay stellt einen Dateideskriptor bereit, den calloop auf Lesbarkeit überwachen kann.11 Wenn der Wayland-Display-FD lesbar wird, wird Display::dispatch\_clients aufgerufen, was wiederum die entsprechenden Dispatch-Trait-Implementierungen aufruft (oft an Handler wie CompositorHandler, XdgShellHandler delegiert).1 Dies bedeutet, dass der gesamte Compositor ereignisgesteuert und größtenteils single-threaded ist (innerhalb des Haupt-calloop-Dispatches). Asynchrone Operationen, die nicht zum calloop-Modell passen (z.B. könnten einige D-Bus-Bibliotheken tokio bevorzugen), müssten sorgfältig integriert werden, möglicherweise indem sie in einem separaten Thread ausgeführt werden und über Kanäle oder benutzerdefinierte Ereignisquellen mit calloop kommunizieren. Die Leistung der Ereignisschleife (Dispatch-Latenz, Callback-Ausführungszeit) ist entscheidend für die Reaktionsfähigkeit der Benutzeroberfläche. Langlaufende Operationen in Callbacks müssen vermieden werden.

#### **1\. Datei: display\_setup.rs**

* **Zweck**: Initialisiert das Wayland Display und DisplayHandle.  
* **Struktur: ClientData** (Assoziiert mit wayland\_server::Client)  
  * pub id: uuid::Uuid (Generiert mit Uuid::new\_v4()).  
  * pub client\_name: Option\<String\> (Kann über wl\_display.sync und wl\_callback.done gesetzt werden, falls der Client es bereitstellt, oder über andere Mittel).  
  * pub user\_data: UserDataMap (aus wayland\_server::backend::UserDataMap) zum Speichern von Client-spezifischen Zuständen wie ClientCompositorData, XdgShellClientData usw..1  
  * **Tabelle: ClientData-Felder** (Analog zu SurfaceData-Felder-Tabelle).  
* **Funktion (konzeptionell, da die Initialisierung Teil von DesktopState::new ist): fn init\_wayland\_display\_and\_loop() \-\> Result\<(Display\<DesktopState\>, EventLoop\<DesktopState\>), InitError\>**  
  * **Schritt 1**: let event\_loop: EventLoop\<DesktopState\> \= EventLoop::try\_new().map\_err(|e| InitError::EventLoopCreationFailed(e.to\_string()))?;.2  
  * **Schritt 2**: let display \= Display::\<DesktopState\>::new().map\_err(|e| InitError::WaylandDisplayCreationFailed(e.to\_string()))?;.11  
  * Der DisplayHandle und LoopHandle werden in DesktopState gespeichert.  
* **Fehler-Enum: InitError**  
  * \#  
  * Varianten:  
    * \#\[error("Erstellung der Wayland-Anzeige fehlgeschlagen: {0}")\] WaylandDisplayCreationFailed(String)  
    * \#\[error("Erstellung der Ereignisschleife fehlgeschlagen: {0}")\] EventLoopCreationFailed(String)

#### **2\. Datei: event\_loop\_integration.rs**

* **Zweck**: Integriert die Wayland-Anzeige in die calloop-Ereignisschleife.  
* **Funktion: pub fn register\_wayland\_source(loop\_handle: \&LoopHandle\<DesktopState\>, display\_handle: \&DisplayHandle, desktop\_state\_accessor: impl FnMut() \-\> Arc\<Mutex\<DesktopState\>\> \+ 'static) \-\> Result\<calloop::RegistrationToken, std::io::Error\>**  
  * Die Verwaltung des mutierbaren Zugriffs auf Display innerhalb des calloop-Callbacks, während DesktopState ebenfalls mutierbar ist, erfordert sorgfältige Überlegungen zu Ownership/Borrowing. Smithay-Beispiele strukturieren dies oft, indem Display und EventLoop als Top-Level-Variablen vorhanden sind und DesktopState mutierbar an dispatch und Callbacks übergeben wird. Wenn Display Teil von DesktopState ist, könnte dies eine temporäre Entnahme oder RefCell beinhalten, falls geteilt. Für diese Spezifikation wird angenommen, dass desktop\_state.wayland\_display zugänglich und mutierbar ist. Eine gängige Methode ist die Verwendung eines Arc\<Mutex\<DesktopState\>\>, das im Callback geklont und gelockt wird, um Zugriff auf den Zustand einschließlich des DisplayHandle zu erhalten, und dann display\_handle.dispatch\_clients() aufzurufen.  
  * **Schritt 1**: Dateideskriptor der Wayland-Anzeige abrufen: let fd \= display\_handle.get\_fd(); (Die genaue Methode zum Abrufen des FD kann von der wayland-backend-Version abhängen; display.backend().poll\_fd() ist eine gängige Methode, wenn man Zugriff auf das Display-Objekt hat, nicht nur den DisplayHandle. Für calloop wird ein AsFd-kompatibler Typ benötigt.)  
  * **Schritt 2**: Erstellen einer Generic\<FileDescriptor\>-Ereignisquelle für calloop. let source \= calloop::generic::Generic::from\_fd(fd, calloop::Interest::READ, calloop::Mode::Level);  
  * **Schritt 3**: Einfügen der Quelle in die Ereignisschleife:  
    Rust  
    loop\_handle.insert\_source(source, move |event, \_metadata, shared\_data: \&mut DesktopState| {  
        // shared\_data ist hier \&mut DesktopState  
        // Zugriff auf display\_handle erfolgt über shared\_data.display\_handle  
        match shared\_data.display\_handle.dispatch\_clients(shared\_data) {  
            Ok(dispatched\_count) \=\> {  
                if dispatched\_count \> 0 {  
                    if let Err(e) \= shared\_data.display\_handle.flush\_clients() {  
                        tracing::error\!("Fehler beim Flushen der Wayland-Clients: {}", e);  
                    }  
                }  
            },  
            Err(e) \=\> {  
                tracing::error\!("Fehler beim Dispatch der Wayland-Clients: {}", e);  
            }  
        }  
        Ok(calloop::PostAction::Continue)  
    })

  .2

  * **Schritt 4**: Regelmäßiger Aufruf von display\_handle.flush\_clients() in der Ereignisschleife (z.B. nachdem alle Ereignisquellen verarbeitet wurden oder auf einem Timer), um sicherzustellen, dass alle gepufferten Wayland-Nachrichten gesendet werden.11 Dies ist entscheidend für die Reaktionsfähigkeit.

### **F. Submodul 5: Renderer-Schnittstelle (system::compositor::renderer\_interface)**

Dieses Submodul definiert abstrakte Schnittstellen für Rendering-Operationen und entkoppelt so die Kernlogik des Compositors von spezifischen Rendering-Backends (DRM/GBM, Winit/EGL). Diese Abstraktion ist entscheidend für die Unterstützung mehrerer Rendering-Backends (z.B. für den Betrieb in einem verschachtelten Fenster während der Entwicklung vs. direkter Hardwarezugriff auf einem TTY) und für die Testbarkeit. Smithays Renderer-Trait und verwandte Konzepte (z.B. Frame, Texture, Import\*-Traits) bilden eine Grundlage für diese Abstraktion.23 Durch die Definition eigener, übergeordneter Traits hier kann die Schnittstelle auf die spezifischen Bedürfnisse der Rendering-Pipeline des Compositors zugeschnitten werden (z.B. Umgang mit Ebenen, Effekten, Cursorn). Die konkreten Implementierungen dieser Traits (in system::compositor::drm\_gbm\_renderer und system::compositor::winit\_renderer – Details in späteren Teilen) werden komplex und stark von den gewählten Grafik-APIs (EGL, OpenGL ES) abhängen. Die Schadensverfolgung (Damage Tracking) ist für effizientes Rendering unerlässlich und muss in diese Renderer-Schnittstellen integriert werden; der Renderer sollte nur beschädigte Bereiche von Oberflächen neu zeichnen.

#### **1\. Datei: abstraction.rs**

* **Zweck**: Definiert Traits für Rendering-Operationen.  
* **Trait: FrameRenderer**  
  * fn new(???) \-\> Result\<Self, RendererError\> (Parameter abhängig vom Backend: z.B. DRM-Gerät, EGL-Kontext).  
  * fn render\_frame\<'a, E: RenderElement\<'a\> \+ 'a\>(\&mut self, elements: impl IntoIterator\<Item \= &'a E\>, output\_geometry: smithay::utils::Rectangle\<i32, smithay::utils::Physical\>, output\_scale: f64) \-\> Result\<(), RendererError\>.  
  * fn present\_frame(\&mut self) \-\> Result\<(), RendererError\> (Handhabt Puffertausch/Page-Flipping).  
  * fn create\_texture\_from\_shm(\&mut self, buffer: \&wl\_buffer::WlBuffer) \-\> Result\<Box\<dyn RenderableTexture\>, RendererError\>.  
  * fn create\_texture\_from\_dmabuf(\&mut self, dmabuf\_attributes: \&smithay::backend::allocator::dmabuf::Dmabuf) \-\> Result\<Box\<dyn RenderableTexture\>, RendererError\> (DMABUF-Unterstützung für spätere Teile).  
  * fn screen\_size(\&self) \-\> smithay::utils::Size\<i32, smithay::utils::Physical\>.  
* **Trait: RenderableTexture** (pub trait RenderableTexture: Send \+ Sync \+ std::fmt::Debug)  
  * fn id(\&self) \-\> uuid::Uuid (Eindeutige ID für diese Texturressource).  
  * fn bind(\&self, slot: u32) \-\> Result\<(), RendererError\> (Für Shader-Nutzung).  
  * fn width\_px(\&self) \-\> u32.  
  * fn height\_px(\&self) \-\> u32.  
  * fn format(\&self) \-\> Option\<smithay::backend::renderer::utils::Format\>. (FourCC or similar)  
* **Enum: RenderElement\<'a\>** (Konzeptionell, Smithay hat smithay::backend::renderer::element::Element)  
  * Surface { surface\_id: uuid::Uuid, texture: Arc\<dyn RenderableTexture\>, geometry: smithay::utils::Rectangle\<i32, smithay::utils::Logical\>, damage\_surface\_coords: &'a }  
  * SolidColor { color: Color, geometry: smithay::utils::Rectangle\<i32, smithay::utils::Logical\> }  
  * Cursor { texture: Arc\<dyn RenderableTexture\>, position\_logical: smithay::utils::Point\<i32, smithay::utils::Logical\>, hotspot\_logical: smithay::utils::Point\<i32, smithay::utils::Logical\> }  
* **Struktur: Color**  
  * pub r: f32 (0.0 bis 1.0)  
  * pub g: f32 (0.0 bis 1.0)  
  * pub b: f32 (0.0 bis 1.0)  
  * pub a: f32 (0.0 bis 1.0)  
* **Fehler-Enum: RendererError**  
  * \#  
  * Varianten:  
    * \# ContextCreationFailed(String)  
    * \# ShaderCompilationFailed(String)  
    * \# TextureUploadFailed(String)  
    * \#\[error("Fehler beim Puffertausch/Present: {0}")\] BufferSwapFailed(String)  
    * \# InvalidBufferType(String)  
    * \# DrmError(String) (Platzhalter für spezifischere DRM-Fehler)  
    * \#\[error("EGL-Fehler: {0}")\] EglError(String) (Platzhalter für spezifischere EGL-Fehler)  
    * \# Generic(String)  
* **Tabelle: RendererError-Varianten** (Analog zu vorherigen Fehlertabellen)  
* **Tabelle: FrameRenderer-Trait-Methoden**

| Methodenname | Signatur | Beschreibung | Hauptverantwortlichkeiten |
| :---- | :---- | :---- | :---- |
| new | fn new(???) \-\> Result\<Self, RendererError\> | Konstruktor für den Renderer. Parameter sind backend-spezifisch. | Initialisierung des Rendering-Kontexts, Laden von Shadern, etc. |
| render\_frame | fn render\_frame\<'a, E: RenderElement\<'a\> \+ 'a\>(\&mut self, elements: impl IntoIterator\<Item \= &'a E\>, output\_geometry: Rectangle\<i32, Physical\>, output\_scale: f64) \-\> Result\<(), RendererError\> | Rendert einen einzelnen Frame, bestehend aus mehreren RenderElement-Instanzen. | Iterieren über Elemente, Setzen von Transformationsmatrizen, Ausführen von Zeichenbefehlen, Schadensoptimierung. |
| present\_frame | fn present\_frame(\&mut self) \-\> Result\<(), RendererError\> | Präsentiert den gerenderten Frame auf dem Bildschirm. | Puffertausch (z.B. eglSwapBuffers), Page-Flip bei DRM. |
| create\_texture\_from\_shm | fn create\_texture\_from\_shm(\&mut self, buffer: \&wl\_buffer::WlBuffer) \-\> Result\<Box\<dyn RenderableTexture\>, RendererError\> | Erstellt eine renderbare Textur aus einem SHM-Puffer. | Zugriff auf SHM-Daten, Hochladen auf GPU, Erstellung eines RenderableTexture-Objekts. |
| create\_texture\_from\_dmabuf | fn create\_texture\_from\_dmabuf(\&mut self, dmabuf: \&Dmabuf) \-\> Result\<Box\<dyn RenderableTexture\>, RendererError\> | Erstellt eine renderbare Textur aus einem DMABUF. | Importieren von DMABUF in den Grafikstack (EGL/OpenGL), Erstellung eines RenderableTexture-Objekts. |
| screen\_size | fn screen\_size(\&self) \-\> Size\<i32, Physical\> | Gibt die aktuelle Größe des Renderziels in physischen Pixeln zurück. | Abrufen der aktuellen Ausgabegröße. |

\*Begründung für den Wert dieser Tabelle:\* Diese Tabelle definiert den Vertrag für jedes Rendering-Backend und stellt sicher, dass der Kern-Compositor konsistent mit verschiedenen Renderern (z.B. DRM/GBM, Winit) interagieren kann.

* **Tabelle: RenderableTexture-Trait-Methoden**

| Methodenname | Signatur | Beschreibung |
| :---- | :---- | :---- |
| id | fn id(\&self) \-\> uuid::Uuid | Gibt eine eindeutige ID für die Texturressource zurück. |
| bind | fn bind(\&self, slot: u32) \-\> Result\<(), RendererError\> | Bindet die Textur an einen bestimmten Texturslot für die Verwendung in Shadern. |
| width\_px | fn width\_px(\&self) \-\> u32 | Gibt die Breite der Textur in Pixeln zurück. |
| height\_px | fn height\_px(\&self) \-\> u32 | Gibt die Höhe der Textur in Pixeln zurück. |
| format | fn format(\&self) \-\> Option\<smithay::backend::renderer::utils::Format\> | Gibt das Pixelformat der Textur zurück. |

\*Begründung für den Wert dieser Tabelle:\* Abstrahiert die Texturbehandlung, was für die Verwaltung von GPU-Ressourcen, die mit Client-Puffern verbunden sind, unerlässlich ist.

## **III. Entwicklungsmodul: system::input (Libinput-basierte Eingabeverarbeitung)**

### **A. Modulübersicht**

Dieses Modul ist für die gesamte Verarbeitung von Benutzereingaben zuständig. Es initialisiert und verwaltet Eingabegeräte mittels libinput, übersetzt rohe Eingabeereignisse in ein für den Compositor und Wayland-Clients verwendbares Format und handhabt das Seat-Management, den Eingabefokus sowie die Darstellung von Zeigern/Cursorn. Die Integration von libinput erfolgt über Smithays LibinputInputBackend, das libinput in die calloop-Ereignisschleife einbindet. Smithays SeatState und SeatHandler bieten übergeordnete Abstraktionen für das Seat- und Fokusmanagement.23  
Das Eingabesystem bildet einen kritischen Pfad für die Benutzerinteraktion. Latenz oder fehlerhafte Ereignisverarbeitung hier würden die Benutzererfahrung erheblich beeinträchtigen. Die Transformation von libinput-Ereignissen in Wayland-Ereignisse, einschließlich Koordinatentransformationen und Fokuslogik, muss präzise sein. libinput liefert Low-Level-Ereignisse 25, die vom Eingabe-Stack von Smithay (LibinputInputBackend, Seat, KeyboardHandle, PointerHandle) verarbeitet und Wayland-Konzepten zugeordnet werden.26 Der Fokus bestimmt, welcher Client Eingaben empfängt; eine fehlerhafte Fokuslogik führt dazu, dass Eingaben an das falsche Fenster gehen.26 Koordinatentransformationen sind erforderlich, wenn Oberflächen skaliert oder gedreht werden. Eine gründliche Prüfung der Eingabebehandlung über verschiedene Geräte, Layouts und Fokusszenarien hinweg ist unerlässlich. Das Design muss erweiterte Eingabefunktionen wie Gesten berücksichtigen (libinput unterstützt sie 27), was möglicherweise eine komplexere Ereignisinterpretation im SeatHandler oder dedizierte Gestenmodule erfordert.  
xkbcommon ist grundlegend für die korrekte Interpretation von Tastatureingaben (Keymaps, Layouts, Modifikatoren). Sein Zustand muss pro Tastaturgerät oder pro Seat verwaltet werden.30 Rohe Keycodes von libinput sind für Anwendungen nicht direkt verwendbar. xkbcommon übersetzt Keycodes basierend auf der aktiven Keymap und dem Modifikatorstatus in Keysyms (z.B. 'A', 'Enter', 'Shift\_L') und UTF-8-Zeichen.30 Die Methode KeyboardHandle::input von Smithay verwendet typischerweise xkbcommon::State::key\_get\_syms. Der Compositor muss die korrekte XKB-Keymap laden (oft aus der Systemkonfiguration oder den Benutzereinstellungen, anfänglich ggf. Standardwerte) und einen xkbcommon::State für jede Tastatur pflegen. Änderungen des Tastaturlayouts (z.B. Sprachwechsel) erfordern eine Aktualisierung des xkbcommon::State und eine Benachrichtigung der Clients (z.B. über wl\_keyboard.keymap und wl\_keyboard.modifiers).

### **B. Submodul 1: Seat-Management (system::input::seat\_manager)**

#### **1\. Datei: seat\_state.rs**

* **Zweck**: Definiert und verwaltet SeatState und SeatHandler für Eingabefokus und die Bekanntmachung von Fähigkeiten (Capabilities).  
* **Struktur: InputError**  
  * \#  
  * Varianten:  
    * \# SeatCreationFailed(String)  
    * \# CapabilityAdditionFailed { seat\_name: String, capability: String, source: Box\<dyn std::error::Error \+ Send \+ Sync\> }  
    * \# XkbConfigError(String) (Sollte spezifischer sein, z.B. KeymapCompilationFailed)  
    * \#\[error("Libinput-Fehler: {0}")\] LibinputError(String)  
    * \# SeatNotFound(String)  
    * \# KeyboardHandleNotFound(String)  
    * \# PointerHandleNotFound(String)  
    * \# TouchHandleNotFound(String)  
  * **Tabelle: InputError-Varianten** (Analog zu vorherigen Fehlertabellen)  
* **Struktur: DesktopState (Teilweise \- Fokus auf Seat-Aspekte)**  
  * Felder:  
    * seat\_state: SeatState\<Self\> (aus smithay::input::SeatState) 26  
    * seats: std::collections::HashMap\<String, Seat\<Self\>\> (Speichert aktive Seats, indiziert nach Namen, z.B. "seat0")  
    * active\_seat\_name: Option\<String\> (Name des aktuell primären Seats)  
    * keyboards: std::collections::HashMap\<String, keyboard::xkb\_config::XkbKeyboardData\> (XKB-Daten pro Tastatur, Schlüssel könnte Gerätename oder Seat-Name sein)  
* **Implementierung: SeatHandler für DesktopState** 26  
  * type KeyboardFocus \= WlSurface;  
  * type PointerFocus \= WlSurface;  
  * type TouchFocus \= WlSurface;  
  * fn seat\_state(\&mut self) \-\> \&mut SeatState\<Self\>: Gibt \&mut self.seat\_state zurück.  
  * fn focus\_changed(\&mut self, seat: \&Seat\<Self\>, focused: Option\<\&Self::KeyboardFocus\>): (Smithays focus\_changed ist generisch; hier wird angenommen, es wird für Tastaturfokus aufgerufen oder als allgemeine Benachrichtigung, dass sich *ein* Fokus geändert hat. Für Zeiger- und Touch-Fokus werden separate Logiken in den jeweiligen Event-Handlern oder durch PointerHandle::enter/leave benötigt.)  
    * **Schritt 1**: Protokollieren der Fokusänderung: tracing::debug\!(seat\_name \= %seat.name(), new\_focus \=?focused.map(|s| s.id()), "Tastaturfokus geändert.");  
    * **Schritt 2**: Tastatur-Handle abrufen: let keyboard \= seat.get\_keyboard().ok\_or\_else(|| InputError::KeyboardHandleNotFound(seat.name().to\_string()))?; (Fehlerbehandlung anpassen).  
    * **Schritt 3**: Alten Fokus ermitteln (z.B. aus self.keyboards.get\_mut(seat.name()).unwrap().focused\_surface).  
    * **Schritt 4**: Wenn focused Some(new\_surface\_ref) ist:  
      * Wenn sich der Fokus geändert hat, keyboard.leave() an die alte fokussierte Oberfläche senden.  
      * keyboard.enter(new\_surface\_ref, &, Serial::now(), seat.get\_keyboard\_modifiers\_state()); (Aktuelle gedrückte Tasten und Modifikatoren senden).  
      * self.keyboards.get\_mut(seat.name()).unwrap().focused\_surface \= Some(new\_surface\_ref.downgrade());  
      * Interne Fenstermanagement-Zustände aktualisieren.  
    * **Schritt 5**: Wenn focused None ist:  
      * keyboard.leave() an die alte fokussierte Oberfläche senden.  
      * self.keyboards.get\_mut(seat.name()).unwrap().focused\_surface \= None;  
      * Interne Fenstermanagement-Zustände löschen/aktualisieren.  
  * fn cursor\_image(\&mut self, seat: \&Seat\<Self\>, image: smithay::input::pointer::CursorImageStatus):  
    * **Schritt 1**: Protokollieren der Cursor-Bild-Anfrage: tracing::trace\!(seat\_name \= %seat.name(), image\_status \=?image, "Cursor-Bild-Anfrage.");  
    * **Schritt 2**: Basierend auf image:  
      * CursorImageStatus::Hidden: Cursor ausblenden. Renderer anweisen, ihn nicht zu zeichnen.  
      * CursorImageStatus::Surface(cursor\_surface): Ein Client hat einen benutzerdefinierten Cursor mittels wl\_pointer.set\_cursor gesetzt.  
        * SurfaceData für cursor\_surface abrufen.  
        * Prüfen, ob cursor\_surface die Rolle "cursor" hat (mittels get\_surface\_role(\&cursor\_surface) \== Some("cursor")). 10  
        * Wenn gültig, Puffer und Hotspot aus SurfaceData oder den SurfaceAttributes der cursor\_surface abrufen.  
        * Renderer anweisen, diese Oberfläche als Cursor zu zeichnen.  
      * CursorImageStatus::Named(name): Ein Client fordert einen thematisierten Cursor an (z.B. "left\_ptr").  
        * Eine Cursor-Theming-Bibliothek (z.B. wayland-cursor oder eine benutzerdefinierte Lösung) verwenden, um die passende Cursor-Textur basierend auf name und dem aktuellen Thema zu laden.  
        * Renderer anweisen, diesen thematisierten Cursor zu zeichnen.  
    * **Schritt 3**: Renderer mit der neuen Cursor-Textur/Sichtbarkeit und dem Hotspot aktualisieren.  
* **Tabelle: SeatHandler-Methodenimplementierungsdetails für DesktopState**

| Methodenname | Signatur | Detaillierte Schritt-für-Schritt-Logik | Wichtige Smithay-Strukturen/-Funktionen | Wayland-Ereignisse gesendet |
| :---- | :---- | :---- | :---- | :---- |
| seat\_state | fn seat\_state(\&mut self) \-\> \&mut SeatState\<Self\> | \&mut self.seat\_state zurückgeben. | SeatState | Keine |
| focus\_changed | fn focus\_changed(\&mut self, seat: \&Seat\<Self\>, focused: Option\<\&WlSurface\>) | Siehe oben. | Seat, WlSurface, KeyboardHandle::enter(), KeyboardHandle::leave() | wl\_keyboard.enter, wl\_keyboard.leave, wl\_keyboard.modifiers |
| cursor\_image | fn cursor\_image(\&mut self, seat: \&Seat\<Self\>, image: CursorImageStatus) | Siehe oben. | Seat, CursorImageStatus, WlSurface (für Cursor), Renderer-API | Keine direkt, aber beeinflusst Cursor-Darstellung. |

\*Begründung für den Wert dieser Tabelle:\* Definiert, wie der Compositor auf zentrale Seat-Ereignisse wie Fokusänderungen und Cursor-Aktualisierungen reagiert, was für die grundlegende Interaktivität unerlässlich ist.

* **Funktion: pub fn create\_seat(state: \&mut DesktopState, display\_handle: \&DisplayHandle, seat\_name: String) \-\> Result\<(), InputError\>**  
  * **Schritt 1**: let seat \= state.seat\_state.new\_wl\_seat(display\_handle, seat\_name.clone());.29  
  * **Schritt 2**: Hinzufügen von Fähigkeiten (normalerweise nachdem das libinput-Backend aktiv ist und Geräte bekannt sind):  
    * Tastatur:  
      * let xkb\_config \= keyboard::xkb\_config::XkbConfig { rules: None, model: None, layout: Some("us".into()), variant: None, options: None }; (Standardkonfiguration, anpassbar).  
      * let keyboard\_handle \= seat.add\_keyboard(xkb\_config, 200, 25).map\_err(|e| InputError::CapabilityAdditionFailed { seat\_name: seat\_name.clone(), capability: "keyboard".to\_string(), source: Box::new(e) })?;.26  
      * Erstellen und Speichern von XkbKeyboardData für diese Tastatur/diesen Seat in state.keyboards.  
    * Zeiger: let \_pointer\_handle \= seat.add\_pointer().map\_err(|e| InputError::CapabilityAdditionFailed { seat\_name: seat\_name.clone(), capability: "pointer".to\_string(), source: Box::new(e) })?;.26  
    * Touch: let \_touch\_handle \= seat.add\_touch().map\_err(|e| InputError::CapabilityAdditionFailed { seat\_name: seat\_name.clone(), capability: "touch".to\_string(), source: Box::new(e) })?;.26  
  * **Schritt 3**: Speichern des Seat-Objekts: state.seats.insert(seat\_name.clone(), seat);.  
  * **Schritt 4**: Wenn dies der erste/primäre Seat ist, state.active\_seat\_name \= Some(seat\_name);.  
  * Protokollieren der Seat-Erstellung und Fähigkeitserweiterung.  
  * Ok(()) zurückgeben.

### **C. Submodul 2: Libinput-Backend (system::input::libinput\_handler)**

#### **1\. Datei: backend\_config.rs**

* **Zweck**: Initialisiert und konfiguriert das LibinputInputBackend.  
* **Struktur: LibinputSessionInterface** (Wrapper für Session-Trait zur Bereitstellung von input::LibinputInterface) 25  
  * Felder: session\_signal: calloop::LoopSignal (oder ähnlicher Mechanismus, um Sitzungsänderungen an die Ereignisschleife zu signalisieren).  
  * Implementiert input::LibinputInterface zum Öffnen/Schließen eingeschränkter Geräte über ein Session-Objekt (z.B. smithay::backend::session::direct::DirectSession oder smithay::backend::session::logind::LogindSession – Details zum Sitzungsmanagement folgen in späteren Teilen, aber diese Schnittstelle wird jetzt benötigt).23  
* **Funktion: pub fn init\_libinput\_backend(event\_loop\_handle: \&LoopHandle\<DesktopState\>, session\_interface: LibinputSessionInterface) \-\> Result\<LibinputInputBackend, InputError\>**  
  * **Schritt 1**: Erstellen eines libinput::Libinput-Kontexts: let mut libinput\_context \= Libinput::new\_from\_path(session\_interface);.25 Die session\_interface wird von libinput zum Öffnen/Schließen von Gerätedateien verwendet.  
  * **Schritt 2**: Zuweisen eines Seats zum Kontext: libinput\_context.udev\_assign\_seat("seat0").map\_err(|e| InputError::LibinputError(format\!("Zuweisung zu udev seat0 fehlgeschlagen: {:?}", e)))?;.32  
  * **Schritt 3**: let libinput\_backend \= LibinputInputBackend::new(libinput\_context.into()); (Die into() Konvertierung ist möglicherweise nicht direkt, ggf. LibinputInputBackend::new(libinput\_context, logger\_oder\_tracing\_span))..25  
  * Rückgabe des libinput\_backend. Die Registrierung als Ereignisquelle erfolgt separat.

#### **2\. Datei: event\_dispatcher.rs**

* **Zweck**: Verarbeitet InputEvent\<LibinputInputBackend\> und leitet an spezifische Handler weiter.  
* **Funktion: pub fn process\_input\_event(desktop\_state: \&mut DesktopState, event: InputEvent\<LibinputInputBackend\>, seat\_name: \&str)** (Aufgerufen vom calloop-Callback)  
  * **Schritt 1**: Aktiven Seat abrufen: let seat \= desktop\_state.seats.get(seat\_name).ok\_or\_else(|| InputError::SeatNotFound(seat\_name.to\_string()))?; (Fehlerbehandlung anpassen).  
  * **Schritt 2**: match event {... } 27  
    * InputEvent::Keyboard { event }: keyboard::key\_event\_translator::handle\_keyboard\_key\_event(desktop\_state, seat, event, seat\_name);  
    * InputEvent::PointerMotion { event }: pointer::pointer\_event\_translator::handle\_pointer\_motion\_event(desktop\_state, seat, event);  
    * InputEvent::PointerMotionAbsolute { event }: pointer::pointer\_event\_translator::handle\_pointer\_motion\_absolute\_event(desktop\_state, seat, event);  
    * InputEvent::PointerButton { event }: pointer::pointer\_event\_translator::handle\_pointer\_button\_event(desktop\_state, seat, event);  
    * InputEvent::PointerAxis { event }: pointer::pointer\_event\_translator::handle\_pointer\_axis\_event(desktop\_state, seat, event);  
    * InputEvent::TouchDown { event }: touch::touch\_event\_translator::handle\_touch\_down\_event(desktop\_state, seat, event);  
    * InputEvent::TouchUp { event }: touch::touch\_event\_translator::handle\_touch\_up\_event(desktop\_state, seat, event);  
    * InputEvent::TouchMotion { event }: touch::touch\_event\_translator::handle\_touch\_motion\_event(desktop\_state, seat, event);  
    * InputEvent::TouchFrame { event }: touch::touch\_event\_translator::handle\_touch\_frame\_event(desktop\_state, seat);  
    * InputEvent::TouchCancel { event }: touch::touch\_event\_translator::handle\_touch\_cancel\_event(desktop\_state, seat);  
    * InputEvent::GesturePinchBegin/Update/End, InputEvent::GestureSwipeBegin/Update/End usw. 27: Anfänglich diese Ereignisse protokollieren: tracing::debug\!("Gestenereignis empfangen: {:?}", event);. Vollständige Gestenbehandlung ist komplex und könnte Teil einer späteren Spezifikationsphase sein.  
    * InputEvent::DeviceAdded { device }:  
      * Protokollieren der Gerätehinzufügung: tracing::info\!("Eingabegerät hinzugefügt: {} ({:?})", device.name(), device.id());  
      * Seat-Fähigkeiten aktualisieren, falls erforderlich (z.B. wenn eine Tastatur angeschlossen wurde und der Seat noch keine hatte). device.has\_capability(DeviceCapability::Keyboard) usw. prüfen.28  
    * InputEvent::DeviceRemoved { device }:  
      * Protokollieren der Geräteentfernung: tracing::info\!("Eingabegerät entfernt: {} ({:?})", device.name(), device.id());  
      * Seat-Fähigkeiten aktualisieren.  
    * Andere Ereignisse (ToolAxis, ToolTip, TabletPadButton usw.): Protokollieren. Vollständige Tablet-Unterstützung ist umfangreich.  
* **Tabelle: InputEvent-Variantenverarbeitung**

| InputEvent-Variante | Zugehörige Handler-Funktion in event\_dispatcher.rs | Kurze Logikbeschreibung |
| :---- | :---- | :---- |
| Keyboard { event } | keyboard::key\_event\_translator::handle\_keyboard\_key\_event | Übersetzt Keycode in Keysym/UTF-8, aktualisiert Modifikatoren, sendet an Client. |
| PointerMotion { event } | pointer::pointer\_event\_translator::handle\_pointer\_motion\_event | Aktualisiert Cursorposition, sendet Motion-Ereignis an fokussierte Oberfläche. |
| PointerMotionAbsolute { event } | pointer::pointer\_event\_translator::handle\_pointer\_motion\_absolute\_event | Wie PointerMotion, aber mit absoluten Koordinaten. |
| PointerButton { event } | pointer::pointer\_event\_translator::handle\_pointer\_button\_event | Sendet Button-Ereignis, löst ggf. Fokusänderung oder Fenstermanagement-Aktionen aus. |
| PointerAxis { event } | pointer::pointer\_event\_translator::handle\_pointer\_axis\_event | Sendet Scroll-Ereignis (vertikal/horizontal). |
| TouchDown { event } | touch::touch\_event\_translator::handle\_touch\_down\_event | Startet einen Touchpunkt, sendet Down-Ereignis an Oberfläche unter dem Punkt. |
| TouchUp { event } | touch::touch\_event\_translator::handle\_touch\_up\_event | Beendet einen Touchpunkt, sendet Up-Ereignis. |
| TouchMotion { event } | touch::touch\_event\_translator::handle\_touch\_motion\_event | Aktualisiert Position eines Touchpunkts, sendet Motion-Ereignis. |
| TouchFrame { event } | touch::touch\_event\_translator::handle\_touch\_frame\_event | Signalisiert Ende eines Satzes von Touch-Ereignissen. |
| TouchCancel { event } | touch::touch\_event\_translator::handle\_touch\_cancel\_event | Signalisiert Abbruch der Touch-Interaktion. |
| DeviceAdded { device } | Direkt in process\_input\_event | Protokolliert neues Gerät, aktualisiert ggf. Seat-Fähigkeiten. |
| DeviceRemoved { device } | Direkt in process\_input\_event | Protokolliert entferntes Gerät, aktualisiert ggf. Seat-Fähigkeiten. |
| Gesture\* | Direkt in process\_input\_event | Protokolliert Gestenereignisse für spätere Implementierung. |

\*Begründung für den Wert dieser Tabelle:\* Bietet eine klare Zuordnung von rohen Smithay-Eingabeereignissen zu den spezifischen Verarbeitungsfunktionen innerhalb des Eingabesystems.

### **D. Submodul 3: Tastaturverarbeitung (system::input::keyboard)**

#### **1\. Datei: xkb\_config.rs**

* **Zweck**: Verwaltet XKB-Keymap und \-Status für Tastaturen.  
* **Struktur: XkbKeyboardData**  
  * pub context: xkbcommon::xkb::Context  
  * pub keymap: xkbcommon::xkb::Keymap  
  * pub state: xkbcommon::xkb::State  
  * pub repeat\_timer: Option\<calloop::TimerHandle\> (Für Tastenwiederholung)  
  * pub repeat\_info: Option\<(u32, KeyState, std::time::Duration, std::time::Duration)\> (Keycode, Zustand, anfängliche Verzögerung, Wiederholungsintervall)  
  * focused\_surface\_on\_seat: Option\<wayland\_server::Weak\<WlSurface\>\> (Cache des aktuellen Fokus für diesen Seat/diese Tastatur)  
  * repeat\_key\_serial: Option\<Serial\> (Serial des Tastenereignisses, das die Wiederholung ausgelöst hat)  
* **Tabelle: XkbKeyboardData-Felder** (Analog zu SurfaceData-Felder-Tabelle)  
* **Funktion: pub fn new\_xkb\_keyboard\_data(config: \&smithay::input::keyboard::XkbConfig\<'\_\>) \-\> Result\<XkbKeyboardData, InputError\>**  
  * **Schritt 1**: let context \= xkbcommon::xkb::Context::new(xkbcommon::xkb::CONTEXT\_NO\_FLAGS);  
  * **Schritt 2**: Erstellen von xkbcommon::xkb::RuleNames aus config.rules, config.model, config.layout, config.variant (oder Standardwerte wie "evdev", "pc105", "us", "").  
  * **Schritt 3**: let keymap \= xkbcommon::xkb::Keymap::new\_from\_names(\&context, \&rules, xkbcommon::xkb::KEYMAP\_COMPILE\_NO\_FLAGS).map\_err(|\_| InputError::XkbConfigError("Keymap-Kompilierung fehlgeschlagen".to\_string()))?;.30  
  * **Schritt 4**: let state \= xkbcommon::xkb::State::new(\&keymap);.30  
  * Gibt XkbKeyboardData zurück.  
* **Funktion: pub fn update\_xkb\_state\_from\_modifiers(xkb\_state: \&mut xkbcommon::xkb::State, modifiers\_state: \&smithay::input::keyboard::ModifiersState) \-\> bool**  
  * Ruft xkb\_state.update\_mask(modifiers\_state.depressed, modifiers\_state.latched, modifiers\_state.locked, modifiers\_state.layout\_depressed, modifiers\_state.layout\_latched, modifiers\_state.layout\_locked) auf.30  
  * Gibt true zurück, wenn sich der Zustand geändert hat, andernfalls false.

#### **2\. Datei: key\_event\_translator.rs**

* **Zweck**: Übersetzt KeyboardKeyEvent in Keysyms/UTF-8 und leitet an den Client weiter.  
* **Funktion: pub fn handle\_keyboard\_key\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: KeyboardKeyEvent\<LibinputInputBackend\>, seat\_name: \&str)**  
  * **Schritt 1**: Tastatur-Handle abrufen: let keyboard\_handle \= seat.get\_keyboard().ok\_or\_else(|| { tracing::warn\!("Kein Keyboard-Handle für Seat {} bei Key-Event.", seat\_name); InputError::KeyboardHandleNotFound(seat\_name.to\_string()) })?;  
  * **Schritt 2**: XkbKeyboardData für diesen Seat/diese Tastatur abrufen: let xkb\_data \= desktop\_state.keyboards.get\_mut(seat\_name).ok\_or\_else(|| { tracing::warn\!("Keine XKB-Daten für Seat {} bei Key-Event.", seat\_name); InputError::XkbConfigError("XKB-Daten nicht gefunden".to\_string()) })?;  
  * **Schritt 3**: xkbcommon::State aktualisieren: let key\_direction \= match event.state() { KeyState::Pressed \=\> xkbcommon::xkb::KeyDirection::Down, KeyState::Released \=\> xkbcommon::xkb::KeyDirection::Up, }; xkb\_data.state.update\_key(event.key\_code(), key\_direction);.30  
  * **Schritt 4**: ModifiersState von xkb\_data.state abrufen: let smithay\_mods\_state \= smithay::input::keyboard::ModifiersState { depressed: xkb\_data.state.serialize\_mods(xkbcommon::xkb::STATE\_MODS\_DEPRESSED), latched: xkb\_data.state.serialize\_mods(xkbcommon::xkb::STATE\_MODS\_LATCHED), locked: xkb\_data.state.serialize\_mods(xkbcommon::xkb::STATE\_MODS\_LOCKED), layout\_effective: xkb\_data.state.serialize\_layout(xkbcommon::xkb::STATE\_LAYOUT\_EFFECTIVE),..Default::default() };  
  * **Schritt 5**: KeyboardHandle über Modifikatoränderungen informieren: keyboard\_handle.modifiers(\&smithay\_mods\_state, event.serial());  
  * **Schritt 6**: Wenn event.state() \== KeyState::Pressed:  
    * let keysym \= xkb\_data.state.key\_get\_one\_sym(event.key\_code());  
    * let utf8 \= xkb\_data.state.key\_get\_utf8(event.key\_code());  
    * Protokollieren von Keysym und UTF-8: tracing::trace\!(keycode \= event.key\_code(), keysym \=?keysym, utf8 \= %utf8, "Taste gedrückt");  
    * keyboard\_handle.input(event.key\_code(), KeyState::Pressed, Some(keysym), if utf8.is\_empty() { None } else { Some(utf8) }, event.time(), event.serial());  
    * Tastenwiederholung einrichten/abbrechen unter Verwendung von xkb\_data.repeat\_timer und calloop::Timer. Die Wiederholungsrate und \-verzögerung kommen von keyboard\_handle.repeat\_info().  
      * Wenn eine Taste gedrückt wird, die Wiederholung unterstützt:  
        * Vorhandenen repeat\_timer abbrechen.  
        * Neuen Timer mit anfänglicher Verzögerung starten. Callback des Timers sendet das Key-Event erneut und plant sich selbst mit dem Wiederholungsintervall neu, bis die Taste losgelassen wird oder der Fokus wechselt.  
        * xkb\_data.repeat\_info und xkb\_data.repeat\_key\_serial speichern.  
  * **Schritt 7**: Wenn event.state() \== KeyState::Released:  
    * keyboard\_handle.input(event.key\_code(), KeyState::Released, None, None, event.time(), event.serial());  
    * Tastenwiederholung abbrechen, falls diese Taste die Wiederholung ausgelöst hat. xkb\_data.repeat\_timer.take().map(|t| t.cancel()); xkb\_data.repeat\_info \= None;

#### **3\. Datei: focus\_handler\_keyboard.rs**

* **Zweck**: Verwaltet den Tastaturfokus für WlSurface.  
* **Funktion: pub fn set\_keyboard\_focus(desktop\_state: \&mut DesktopState, seat\_name: \&str, surface: Option\<\&WlSurface\>, serial: Serial)**  
  * **Schritt 1**: Seat und KeyboardHandle abrufen. let seat \= desktop\_state.seats.get(seat\_name).ok\_or\_else(...)?.clone(); (Klonen des Seat-Handles). let keyboard\_handle \= seat.get\_keyboard().ok\_or\_else(...)?.clone(); (Klonen des KeyboardHandle).  
  * **Schritt 2**: XkbKeyboardData für den Seat abrufen. let xkb\_data \= desktop\_state.keyboards.get\_mut(seat\_name).ok\_or\_else(...)?;  
  * **Schritt 3**: Alten Fokus ermitteln: let old\_focus\_weak \= xkb\_data.focused\_surface\_on\_seat.clone();  
  * **Schritt 4**: Wenn surface Some(new\_focus\_ref) ist:  
    * Wenn old\_focus\_weak.as\_ref().and\_then(|w| w.upgrade()).as\_ref()\!= Some(\&new\_focus\_ref), dann hat sich der Fokus geändert.  
      * Wenn alter Fokus existierte und noch gültig ist (old\_focus.upgrade()), keyboard\_handle.leave(old\_focus.upgrade().unwrap(), serial); senden.  
      * keyboard\_handle.enter(new\_focus\_ref, \&xkb\_data.state.keycodes\_pressed().collect::\<Vec\<\_\>\>(), serial, seat.get\_keyboard\_modifiers\_state()); (Aktuell gedrückte Tasten und Modifikatoren senden).  
      * xkb\_data.focused\_surface\_on\_seat \= Some(new\_focus\_ref.downgrade());  
  * **Schritt 5**: Wenn surface None ist:  
    * Wenn old\_focus\_weak.as\_ref().and\_then(|w| w.upgrade()).is\_some(), keyboard\_handle.leave(old\_focus\_weak.unwrap().upgrade().unwrap(), serial); senden.  
    * xkb\_data.focused\_surface\_on\_seat \= None;  
  * **Schritt 6**: keyboard\_handle.set\_focus(surface, serial);.31

### **E. Submodul 4: Zeigerverarbeitung (system::input::pointer)**

#### **1\. Datei: pointer\_event\_translator.rs**

* **Zweck**: Verarbeitet Zeigerereignisse und leitet sie weiter.  
* **Funktion: pub fn handle\_pointer\_motion\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: PointerMotionEvent\<LibinputInputBackend\>)**  
  * **Schritt 1**: PointerHandle abrufen: let pointer\_handle \= seat.get\_pointer().ok\_or\_else(...)?.clone();  
  * **Schritt 2**: Globale Cursorposition aktualisieren (z.B. in DesktopState speichern, wenn nicht von PointerHandle verwaltet). Die event.delta() oder event.delta\_unaccel() können verwendet werden, um die neue globale Position zu berechnen.  
  * **Schritt 3**: Neuen Zeigerfokus bestimmen basierend auf der neuen globalen Cursorposition. Dies erfordert eine Iteration über sichtbare Toplevel-Oberflächen und deren Eingaberegionen unter Berücksichtigung der Stapelreihenfolge. let (new\_focus\_surface, surface\_local\_coords) \= find\_surface\_at\_global\_coords(\&desktop\_state.toplevels, global\_cursor\_pos);  
  * **Schritt 4**: Fokus- und Enter/Leave-Ereignisse senden: update\_pointer\_focus\_and\_send\_motion(desktop\_state, seat, \&pointer\_handle, new\_focus\_surface, surface\_local\_coords, event.time(), event.serial());  
  * **Schritt 5**: Renderer-Cursorposition aktualisieren.  
* **Funktion: pub fn handle\_pointer\_motion\_absolute\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: PointerMotionAbsoluteEvent\<LibinputInputBackend\>)**  
  * Ähnlich wie handle\_pointer\_motion\_event, aber verwendet absolute Koordinaten. event.x\_transformed(output\_width), event.y\_transformed(output\_height) können verwendet werden, um globale Bildschirmkoordinaten zu erhalten.27 (Benötigt die Größe des Outputs, auf dem sich das Gerät befindet).  
* **Funktion: pub fn handle\_pointer\_button\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: PointerButtonEvent\<LibinputInputBackend\>)**  
  * **Schritt 1**: PointerHandle abrufen.  
  * **Schritt 2**: let wl\_button\_state \= match event.button\_state() { ButtonState::Pressed \=\> wl\_pointer::ButtonState::Pressed, ButtonState::Released \=\> wl\_pointer::ButtonState::Released, }; pointer\_handle.button(event.button(), wl\_button\_state, event.serial(), event.time());  
  * **Schritt 3**: Wenn Taste gedrückt (Pressed):  
    * Tastaturfokus gemäß Fenstermanagement-Richtlinie ändern (z.B. Click-to-Focus). focus\_handler\_keyboard::set\_keyboard\_focus(...) aufrufen mit der Oberfläche unter dem Cursor.  
    * Fenstermanagement-Interaktionen behandeln (z.B. Move/Resize starten, wenn auf Dekoration geklickt wird). Dies kann das Starten eines Grabs beinhalten (seat.start\_pointer\_grab(...)).  
* **Funktion: pub fn handle\_pointer\_axis\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: PointerAxisEvent\<LibinputInputBackend\>)**  
  * **Schritt 1**: PointerHandle abrufen.  
  * **Schritt 2**: Achsenquelle bestimmen: let source \= match event.axis\_source() { Some(libinput::event::pointer::AxisSource::Wheel) \=\> wl\_pointer::AxisSource::Wheel, Some(libinput::event::pointer::AxisSource::Finger) \=\> wl\_pointer::AxisSource::Finger, Some(libinput::event::pointer::AxisSource::Continuous) \=\> wl\_pointer::AxisSource::Continuous, \_ \=\> wl\_pointer::AxisSource::Wheel, // Fallback };  
  * **Schritt 3**: Diskrete Scroll-Schritte: let v\_discrete \= event.axis\_value\_discrete(PointerAxis::Vertical); let h\_discrete \= event.axis\_value\_discrete(PointerAxis::Horizontal);  
  * **Schritt 4**: Kontinuierlicher Scroll-Wert: let v\_continuous \= event.axis\_value(PointerAxis::Vertical); let h\_continuous \= event.axis\_value(PointerAxis::Horizontal);  
  * **Schritt 5**: Wenn vertikales Scrollen (v\_discrete.is\_some() | | v\_continuous\!= 0.0): pointer\_handle.axis(wl\_pointer::Axis::VerticalScroll, source, v\_discrete, v\_continuous, event.serial(), event.time());  
  * **Schritt 6**: Wenn horizontales Scrollen (h\_discrete.is\_some() | | h\_continuous\!= 0.0): pointer\_handle.axis(wl\_pointer::Axis::HorizontalScroll, source, h\_discrete, h\_continuous, event.serial(), event.time());

#### **2\. Datei: focus\_handler\_pointer.rs**

* **Zweck**: Verwaltet Zeigerfokus, Enter/Leave-Ereignisse.  
* **Funktion: pub fn update\_pointer\_focus\_and\_send\_motion(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, pointer\_handle: \&PointerHandle\<DesktopState\>, new\_focus\_surface: Option\<WlSurface\>, surface\_local\_coords: Point\<f64, Logical\>, time: u32, serial: Serial)**  
  * **Schritt 1**: Aktuellen Fokus vom pointer\_handle abrufen: let old\_focus\_surface \= pointer\_handle.current\_focus();  
  * **Schritt 2**: Wenn new\_focus\_surface\!= old\_focus\_surface.as\_ref():  
    * Wenn old\_focus\_surface existierte, pointer\_handle.leave(old\_focus\_surface.as\_ref().unwrap(), serial, time); senden.  
    * Wenn new\_focus\_surface existiert, pointer\_handle.enter(new\_focus\_surface.as\_ref().unwrap(), serial, time, surface\_local\_coords); senden.  
    * Internen Fokus des PointerHandle aktualisieren (Smithay macht dies oft implizit bei enter).  
  * **Schritt 3**: Wenn new\_focus\_surface existiert (auch wenn es dasselbe wie der alte Fokus ist), pointer\_handle.motion(new\_focus\_surface.as\_ref().unwrap(), time, serial, surface\_local\_coords); senden.

#### **3\. Datei: cursor\_updater.rs**

* **Zweck**: Behandelt die Logik von SeatHandler::cursor\_image.  
* Die Logik ist bereits oben in der Implementierung von SeatHandler::cursor\_image detailliert. Diese Datei würde Hilfsfunktionen enthalten, falls diese Logik zu komplex wird, z.B. für das Laden von Cursor-Themen.

### **F. Submodul 5: Touch-Verarbeitung (system::input::touch)**

#### **1\. Datei: touch\_event\_translator.rs**

* **Zweck**: Verarbeitet Touch-Ereignisse und leitet sie weiter.  
* **Funktion: pub fn handle\_touch\_down\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: TouchDownEvent\<LibinputInputBackend\>)**  
  * **Schritt 1**: TouchHandle abrufen: let touch\_handle \= seat.get\_touch().ok\_or\_else(...)?.clone();  
  * **Schritt 2**: Fokussierte Oberfläche für diesen Touchpunkt bestimmen. Dies kann die Oberfläche unter dem Touchpunkt sein. let (focused\_surface, surface\_local\_coords) \= find\_surface\_at\_global\_coords(\&desktop\_state.toplevels, event.position\_transformed(output\_size)); (Benötigt Output-Größe für Transformation).  
  * **Schritt 3**: Wenn eine Oberfläche anvisiert wird:  
    * touch\_handle.down(focused\_surface.as\_ref().unwrap(), event.serial(), event.time(), event.slot().unwrap(), surface\_local\_coords); (Smithay's slot() gibt Option\<TouchSlot\>).  
* **Funktion: pub fn handle\_touch\_up\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: TouchUpEvent\<LibinputInputBackend\>)**  
  * **Schritt 1**: TouchHandle abrufen.  
  * touch\_handle.up(event.serial(), event.time(), event.slot().unwrap());  
* **Funktion: pub fn handle\_touch\_motion\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: TouchMotionEvent\<LibinputInputBackend\>)**  
  * **Schritt 1**: TouchHandle abrufen.  
  * **Schritt 2**: Oberfläche abrufen, die aktuell von diesem Touch-Slot (event.slot().unwrap()) anvisiert wird (muss im TouchHandle oder DesktopState pro Slot gespeichert werden).  
  * **Schritt 3**: Koordinaten transformieren.  
  * touch\_handle.motion(focused\_surface\_for\_slot.as\_ref().unwrap(), event.serial(), event.time(), event.slot().unwrap(), surface\_local\_coords\_for\_slot);  
* **Funktion: pub fn handle\_touch\_frame\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>)**  
  * TouchHandle abrufen.  
  * touch\_handle.frame();  
* **Funktion: pub fn handle\_touch\_cancel\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>)**  
  * TouchHandle abrufen.  
  * touch\_handle.cancel();

#### **2\. Datei: focus\_handler\_touch.rs**

* **Zweck**: Verwaltet den Touch-Fokus.  
* Die Logik zur Bestimmung des Touch-Fokus ist ähnlich der des Zeigerfokus, aber pro Touchpunkt/Slot. TouchHandle selbst hat keine expliziten enter/leave-Methoden wie PointerHandle; der Fokus ist implizit in dem Oberflächenargument für down/motion. Der Zustand, welche Oberfläche von welchem Slot berührt wird, muss im DesktopState oder einer benutzerdefinierten Struktur, die mit dem TouchHandle assoziiert ist, verwaltet werden.

## **IV. Schlussfolgerungen**

Dieser erste Teil der Ultra-Feinspezifikation für die Systemschicht legt ein detailliertes Fundament für die Kernkomponenten des Wayland-Compositors und der Eingabeverarbeitung. Durch die systematische Zerlegung in Module und Submodule, die präzise Definition von Datenstrukturen, Schnittstellen und Fehlerfällen sowie die schrittweise Detaillierung der Implementierungslogik wird eine solide Basis für die nachfolgende Entwicklung geschaffen.  
Die enge Integration mit dem Smithay-Toolkit und dessen Designprinzipien, insbesondere das Handler-Trait-Muster und die zentrale Zustandsverwaltung in DesktopState, prägen die Struktur der Implementierung maßgeblich. Die Spezifikation berücksichtigt die Notwendigkeit einer klaren Abstraktion der Renderer-Schnittstelle und einer robusten Fehlerbehandlung mittels thiserror. Die detaillierte Ausarbeitung der XDG-Shell-Handler und der Input-Event-Übersetzer adressiert die Komplexität dieser Protokolle und Interaktionen.  
Die hier spezifizierten Module system::compositor und system::input sind grundlegend für jede weitere Funktionalität der Desktop-Umgebung. Ihre korrekte und performante Implementierung gemäß dieser Spezifikation ist entscheidend für die Stabilität, Reaktionsfähigkeit und das Gesamterlebnis des Systems. Die identifizierten Abhängigkeiten und Interaktionen zwischen diesen Modulen sowie die Notwendigkeit einer sorgfältigen Zustandsverwaltung wurden hervorgehoben, um potenziellen Herausforderungen proaktiv zu begegnen.  
Mit dieser Spezifikation sind Entwickler in der Lage, die Implementierung von Teil 1/4 der Systemschicht mit einem hohen Grad an Klarheit und Präzision zu beginnen. Die nachfolgenden Teile werden auf dieser Grundlage aufbauen und weitere systemnahe Dienste und Protokolle detaillieren.

# **Implementierungsleitfaden Systemschicht: D-Bus-Interaktion und Output-Management (Teil 2/4)**

Dieser Teil des Implementierungsleitfadens für die Systemschicht befasst sich mit zwei zentralen Aspekten der neuen Linux-Desktop-Umgebung: der Interaktion mit systemweiten D-Bus-Diensten und der umfassenden Verwaltung von Anzeigeausgängen. Diese Komponenten sind entscheidend für die Integration der Desktop-Umgebung in das Basissystem und für die Bereitstellung einer kohärenten Benutzererfahrung über verschiedene Hardwarekonfigurationen hinweg.

## **A. Modul: system::dbus – Interaktion mit System-D-Bus-Diensten**

Das Modul system::dbus ist verantwortlich für die Kommunikation mit verschiedenen Standard-D-Bus-Diensten, die für den Betrieb einer Desktop-Umgebung unerlässlich sind. Hierzu zählen Dienste für Energieverwaltung (UPower), Sitzungsmanagement (systemd-logind), Netzwerkmanagement (NetworkManager), Geheimnisverwaltung (Freedesktop Secret Service) und Rechteverwaltung (PolicyKit). Die Implementierung erfolgt unter Verwendung der zbus-Bibliothek.1

### **1\. Submodul: system::dbus::error – Fehlerbehandlung für D-Bus-Operationen**

Dieses Submodul definiert die spezifischen Fehlertypen für alle D-Bus-Interaktionen innerhalb der Systemschicht. Gemäß den Entwicklungsrichtlinien wird hierfür das thiserror-Crate genutzt, um pro Modul ein dediziertes Error-Enum zu erstellen \[User Query IV.4.3\]. Dies ermöglicht eine präzise Fehlerbehandlung und klare Fehlermeldungen.

* **Datei**: system/dbus/error.rs  
* **Spezifikation**:  
  * Es wird ein öffentliches Enum DBusError definiert, das die Traits thiserror::Error und std::fmt::Debug implementiert. Die Verwendung von thiserror vereinfacht die Erstellung idiomatischer Fehler.2  
  * Die \#\[from\]-Direktive von thiserror wird verwendet, um Fehler aus der zbus-Bibliothek (insbesondere zbus::Error 4 und zbus::zvariant::Error) transparent in spezifische Varianten von DBusError zu konvertieren. Dies ist entscheidend, da zbus-Operationen wie Verbindungsaufbau, Methodenaufrufe oder Signalabonnements fehlschlagen können.1  
  * **Varianten der DBusError Enum**:  
    * \# ConnectionFailed { service\_name: Option\<String\>, bus: BusType, \#\[source\] source: zbus::Error } Fehler beim Aufbau einer D-Bus-Verbindung. BusType ist ein Enum (Session, System).  
    * \# MethodCallFailed { service: String, path: String, interface: String, method: String, \#\[source\] source: zbus::Error } Fehler beim Aufruf einer D-Bus-Methode.  
    * \# ProxyCreationFailed { service: String, interface: String, \#\[source\] source: zbus::Error } Fehler bei der Erstellung eines D-Bus-Proxys.  
    * \# SignalSubscriptionFailed { interface: String, signal\_name: String, \#\[source\] source: zbus::Error } Fehler beim Abonnieren eines D-Bus-Signals.  
    * \# InvalidResponse { service: String, method: String, details: String } Unerwartete oder ungültige Antwort von einem D-Bus-Dienst.  
    * \# DataDeserializationError { context: String, \#\[source\] source: zbus::zvariant::Error } Fehler bei der Deserialisierung von D-Bus-Daten.  
    * \# PropertyAccessFailed { service: String, interface: String, property: String, \#\[source\] source: zbus::Error } Fehler beim Zugriff auf eine D-Bus-Eigenschaft.  
    * \# NameTaken { name: String, \#\[source\] source: zbus::Error } Tritt auf, wenn versucht wird, einen D-Bus-Namen zu beanspruchen, der bereits belegt ist (relevant für das Anbieten eigener D-Bus-Dienste, hier primär für Clients).  
    * \#\[error("Operation timed out: {operation}")\] Timeout { operation: String } Zeitüberschreitung bei einer D-Bus-Operation.  
* **Implementierungsschritte**:  
  1. Definition des BusType Enums: pub enum BusType { Session, System }.  
  2. Definition des DBusError Enums mit den oben genannten Varianten und den \#\[error(...)\]-Attributen für menschenlesbare Fehlermeldungen.  
  3. Sicherstellung, dass alle öffentlichen Funktionen im system::dbus-Modul und seinen Submodulen Result\<T, DBusError\> zurückgeben, um eine konsistente Fehlerbehandlung zu gewährleisten.

### **2\. Submodul: system::dbus::connection – D-Bus Verbindungsmanagement**

Dieses Submodul stellt einen zentralen Manager für D-Bus-Verbindungen bereit, um die Wiederverwendung von Verbindungen zu ermöglichen und deren Aufbau zu optimieren.

* **Datei**: system/dbus/connection.rs  
* **Spezifikation**:  
  * **Struktur**: DBusConnectionManager  
    * Felder:  
      * session\_bus: tokio::sync::OnceCell\<Arc\<zbus::Connection\>\>  
      * system\_bus: tokio::sync::OnceCell\<Arc\<zbus::Connection\>\> Die Verwendung von tokio::sync::OnceCell ermöglicht eine verzögerte Initialisierung der D-Bus-Verbindungen. Eine Verbindung wird erst beim ersten tatsächlichen Bedarf aufgebaut. Anschließend wird die Arc\<zbus::Connection\> für die zukünftige Wiederverwendung gespeichert.5 Dies ist effizient, da nicht bei jedem Start des Desktops sofort alle potenziellen D-Bus-Verbindungen etabliert werden müssen, und Arc stellt sicher, dass die einmal aufgebaute Verbindung sicher zwischen verschiedenen asynchronen Tasks geteilt werden kann, die möglicherweise parallel auf denselben Bus zugreifen (z.B. UPower-Client und Logind-Client auf dem Systembus).  
  * **Methoden** für DBusConnectionManager:  
    * pub fn new() \-\> Self: Konstruktor, initialisiert die leeren OnceCells.  
    * pub async fn get\_session\_bus(\&self) \-\> Result\<Arc\<zbus::Connection\>, DBusError\>: Gibt eine Arc-gekapselte zbus::Connection zum Session-Bus zurück. Nutzt self.session\_bus.get\_or\_try\_init() in Kombination mit zbus::Connection::session().await.1 Fehler beim Verbindungsaufbau werden in DBusError::ConnectionFailed gemappt.  
    * pub async fn get\_system\_bus(\&self) \-\> Result\<Arc\<zbus::Connection\>, DBusError\>: Analog zu get\_session\_bus, jedoch für den System-Bus unter Verwendung von zbus::Connection::system().await.1  
* **Implementierungsschritte**:  
  1. Definiere die DBusConnectionManager-Struktur.  
  2. Implementiere die new()-Methode.  
  3. Implementiere get\_session\_bus():  
     Rust  
     pub async fn get\_session\_bus(\&self) \-\> Result\<Arc\<zbus::Connection\>, DBusError\> {  
         self.session\_bus  
            .get\_or\_try\_init(|| async {  
                 zbus::Connection::session()  
                    .await  
                    .map(Arc::new)  
                    .map\_err(|e| DBusError::ConnectionFailed {  
                         service\_name: None, // Generic session bus connection  
                         bus: BusType::Session,  
                         source: e,  
                     })  
             })  
            .await  
            .cloned() // Clone the Arc for the caller  
     }

  4. Implementiere get\_system\_bus() analog.

### **3\. Submodul: system::dbus::upower\_client – UPower D-Bus Client**

Dieser Client interagiert mit dem org.freedesktop.UPower-Dienst, um Informationen über den Energiezustand des Systems und angeschlossene Geräte zu erhalten.6

* **Dateien**: system/dbus/upower\_client.rs, system/dbus/upower\_types.rs  
* **Spezifikation (upower\_types.rs)**:  
  * pub enum PowerDeviceType { Unknown \= 0, LinePower \= 1, Battery \= 2, Ups \= 3, Monitor \= 4, Mouse \= 5, Keyboard \= 6, Pda \= 7, Phone \= 8, /\* Display \= 9 (aus UPower.Device, nicht standardisiert in udev?) \*/ } (Werte basierend auf UPowerDeviceType in der UPower-Dokumentation).  
  * pub enum PowerState { Unknown \= 0, Charging \= 1, Discharging \= 2, Empty \= 3, FullyCharged \= 4, PendingCharge \= 5, PendingDischarge \= 6 }.8  
  * pub enum PowerWarningLevel { Unknown \= 0, None \= 1, Discharging \= 2, Low \= 3, Critical \= 4, Action \= 5 }.  
  * pub struct PowerDeviceDetails { pub object\_path: zbus::zvariant::OwnedObjectPath, pub vendor: String, pub model: String, pub serial: String, pub native\_path: String, pub device\_type: PowerDeviceType, pub state: PowerState, pub percentage: f64, pub temperature: f64, pub voltage: f64, pub energy: f64, pub energy\_empty: f64, pub energy\_full: f64, pub energy\_full\_design: f64, pub energy\_rate: f64, pub time\_to\_empty: i64, pub time\_to\_full: i64, pub is\_rechargeable: bool, pub is\_present: bool, pub warning\_level: PowerWarningLevel, pub icon\_name: String, pub capacity: f64, pub technology: String }.7  
    * Felder werden aus den Properties des org.freedesktop.UPower.Device-Interfaces abgeleitet.  
  * pub struct UPowerProperties { pub on\_battery: bool, pub lid\_is\_closed: bool, pub lid\_is\_present: bool, pub daemon\_version: String }.7  
  * Implementiere TryFrom\<u32\> für PowerDeviceType, PowerState, PowerWarningLevel zur Konvertierung von D-Bus-Werten.  
* **Spezifikation (upower\_client.rs)**:  
  * **Proxy-Definitionen** (mittels \#\[zbus::proxy(...)\] 1):  
    * UPowerManagerProxy (Name angepasst zur Klarheit) für org.freedesktop.UPower auf /org/freedesktop/UPower.  
      * Methoden:  
        * \# async fn enumerate\_devices(\&self) \-\> zbus::Result\<Vec\<zbus::zvariant::OwnedObjectPath\>\>; 7  
        * \# async fn get\_display\_device(\&self) \-\> zbus::Result\<zbus::zvariant::OwnedObjectPath\>\>; 7  
        * \#\[zbus(name \= "GetCriticalAction")\] async fn get\_critical\_action(\&self) \-\> zbus::Result\<String\>\>; 7  
      * Properties (als Methoden im Proxy generiert):  
        * \#\[zbus(property)\] async fn on\_battery(\&self) \-\> zbus::Result\<bool\>; 7  
        * \#\[zbus(property)\] async fn lid\_is\_closed(\&self) \-\> zbus::Result\<bool\>; 7  
        * \#\[zbus(property)\] async fn lid\_is\_present(\&self) \-\> zbus::Result\<bool\>; 7  
        * \#\[zbus(property)\] async fn daemon\_version(\&self) \-\> zbus::Result\<String\>; 7  
      * Signale (als Methoden im Proxy generiert, die einen SignalStream zurückgeben):  
        * \#\[zbus(signal)\] async fn device\_added(\&self, device\_path: zbus::zvariant::OwnedObjectPath) \-\> zbus::Result\<()\>; (Das Signal selbst hat Argumente, die receive\_ Methode wird diese liefern) 7  
        * \#\[zbus(signal)\] async fn device\_removed(\&self, device\_path: zbus::zvariant::OwnedObjectPath) \-\> zbus::Result\<()\>; 7  
        * (Das PropertiesChanged-Signal wird über zbus::Proxy::receive\_properties\_changed\_with\_args() oder ähnliche Methoden des generierten Proxys gehandhabt).  
    * UPowerDeviceProxy für org.freedesktop.UPower.Device (Pfad variabel, daher default\_path nicht im Makro).  
      * Properties (Beispiele):  
        * \#\[zbus(property)\] async fn type\_(\&self) \-\> zbus::Result\<u32\>; (Suffix \_ um Keyword-Kollision zu vermeiden)  
        * \#\[zbus(property)\] async fn state(\&self) \-\> zbus::Result\<u32\>;  
        * \#\[zbus(property)\] async fn percentage(\&self) \-\> zbus::Result\<f64\>;  
        * \#\[zbus(property)\] async fn time\_to\_empty(\&self) \-\> zbus::Result\<i64\>; 8  
        * \#\[zbus(property)\] async fn time\_to\_full(\&self) \-\> zbus::Result\<i64\>; 8  
        * \#\[zbus(property, name \= "IsPresent")\] async fn is\_present(\&self) \-\> zbus::Result\<bool\>;  
        * \#\[zbus(property, name \= "IconName")\] async fn icon\_name(\&self) \-\> zbus::Result\<String\>;  
        * (Weitere Properties analog definieren: Vendor, Model, Serial, NativePath, Temperature, Voltage, Energy, EnergyEmpty, EnergyFull, EnergyFullDesign, EnergyRate, IsRechargeable, WarningLevel, Capacity, Technology).  
  * **Struktur**: UPowerClient  
    * Felder: connection\_manager: Arc\<DBusConnectionManager\>, manager\_proxy\_path: Arc\<zbus::zvariant::ObjectPath\<'static\>\> (Cache für den Manager-Pfad).  
  * **Methoden** für UPowerClient:  
    * pub async fn new(conn\_manager: Arc\<DBusConnectionManager\>) \-\> Result\<Self, DBusError\>: Initialisiert den Client. Speichert den conn\_manager. Der manager\_proxy\_path wird auf /org/freedesktop/UPower gesetzt.  
    * async fn get\_manager\_proxy(\&self) \-\> Result\<UPowerManagerProxy\<'\_\>, DBusError\>: Private Hilfsmethode, um den UPowerManagerProxy zu erstellen. Holt die Systembus-Verbindung vom connection\_manager.  
    * async fn get\_device\_proxy\<'a\>(\&self, device\_path: &'a zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<UPowerDeviceProxy\<'a\>, DBusError\>: Private Hilfsmethode, um einen UPowerDeviceProxy für einen gegebenen Pfad zu erstellen.  
    * pub async fn get\_properties(\&self) \-\> Result\<UPowerProperties, DBusError\>: Ruft die on\_battery, lid\_is\_closed, lid\_is\_present und daemon\_version Properties vom UPowerManagerProxy ab und fasst sie in UPowerProperties zusammen.  
    * pub async fn enumerate\_devices(\&self) \-\> Result\<Vec\<zbus::zvariant::OwnedObjectPath\>, DBusError\>: Ruft UPowerManagerProxy::enumerate\_devices() auf.  
    * pub async fn get\_display\_device\_path(\&self) \-\> Result\<zbus::zvariant::OwnedObjectPath, DBusError\>: Ruft UPowerManagerProxy::get\_display\_device() auf.  
    * pub async fn get\_device\_details(\&self, device\_path: \&zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<PowerDeviceDetails, DBusError\>: Erstellt einen UPowerDeviceProxy für den device\_path. Ruft alle relevanten Properties ab und konvertiert sie in die PowerDeviceDetails-Struktur. Nutzt try\_into() für Enums.  
    * pub async fn on\_battery(\&self) \-\> Result\<bool, DBusError\>: Ruft die on\_battery Property vom UPowerManagerProxy ab.  
    * pub async fn subscribe\_device\_added(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<zbus::zvariant::OwnedObjectPath, DBusError\>\>, DBusError\>: Erstellt einen UPowerManagerProxy, ruft receive\_device\_added().await? auf.1 Mappt die Signaldaten ((OwnedObjectPath,)) und Fehler.  
    * pub async fn subscribe\_device\_removed(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<zbus::zvariant::OwnedObjectPath, DBusError\>\>, DBusError\>: Analog zu subscribe\_device\_added.  
    * pub async fn subscribe\_upower\_properties\_changed(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<HashMap\<String, zbus::zvariant::OwnedValue\>, DBusError\>\>, DBusError\>: Verwendet UPowerManagerProxy::receive\_properties\_changed().await?.  
    * pub async fn subscribe\_device\_properties\_changed(\&self, device\_path: zbus::zvariant::OwnedObjectPath) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<(String, HashMap\<String, zbus::zvariant::OwnedValue\>, Vec\<String\>), DBusError\>\>, DBusError\>: Erstellt einen UPowerDeviceProxy für den Pfad und verwendet receive\_properties\_changed\_with\_args().await?. Die Argumente des Signals sind (String, HashMap\<String, Value\>, Vec\<String\>).  
* **Implementierungsschritte**:  
  1. Definition der Typen in upower\_types.rs inklusive TryFrom\<u32\> für Enums.  
  2. Generierung der Proxy-Traits in upower\_client.rs.  
  3. Implementierung der UPowerClient-Struktur und ihrer Methoden. Die Methoden sollten die Proxy-Aufrufe kapseln und Fehler in DBusError umwandeln.  
  4. Signal-Abonnementmethoden geben einen Stream zurück, den der Aufrufer verarbeiten kann. Die Verarbeitung der Signaldaten (z.B. Extrahieren des device\_path aus dem Signal-Message-Body) und Fehlerbehandlung muss sorgfältig erfolgen.  
* **Publisher/Subscriber**:  
  * Publisher: org.freedesktop.UPower D-Bus Dienst.  
  * Subscriber: UPowerClient (bzw. die Systemschicht, die diesen Client nutzt).  
* Die Notwendigkeit, Signal-Streams korrekt zu verwalten, um Ressourcenlecks oder Callbacks auf ungültige Zustände zu vermeiden, ist ein wichtiger Aspekt. Wenn ein UPowerClient nicht mehr benötigt wird oder die Verbindung abbricht, müssen die assoziierten Streams ebenfalls beendet werden. Dies kann durch tokio::select\! in Kombination mit einem Shutdown-Signal oder durch das Droppen des Streams geschehen.

### **4\. Submodul: system::dbus::logind\_client – Systemd-Logind D-Bus Client**

Dieser Client interagiert mit org.freedesktop.login1 für Sitzungsmanagement, Sperr-/Entsperr-Operationen und Benachrichtigungen über Systemzustandsänderungen wie Suspend/Resume.10

* **Dateien**: system/dbus/logind\_client.rs, system/dbus/logind\_types.rs  
* **Spezifikation (logind\_types.rs)**:  
  * pub struct SessionInfo { pub id: String, pub user\_id: u32, pub user\_name: String, pub seat\_id: String, pub object\_path: zbus::zvariant::OwnedObjectPath }.10  
  * pub struct UserInfo { pub id: u32, pub name: String, pub object\_path: zbus::zvariant::OwnedObjectPath }.  
  * pub enum SessionState { Active, Online, Closing, Gone, Unknown } (basierend auf typischen Logind-Zuständen).  
* **Spezifikation (logind\_client.rs)**:  
  * **Proxy-Definitionen**:  
    * LogindManagerProxy für org.freedesktop.login1.Manager auf /org/freedesktop/login1.  
      * Methoden:  
        * \# async fn get\_session(\&self, session\_id: \&str) \-\> zbus::Result\<zbus::zvariant::OwnedObjectPath\>; 10  
        * \# async fn get\_session\_by\_pid(\&self, pid: u32) \-\> zbus::Result\<zbus::zvariant::OwnedObjectPath\>; 11  
        * \#\[zbus(name \= "GetUser")\] async fn get\_user(\&self, uid: u32) \-\> zbus::Result\<zbus::zvariant::OwnedObjectPath\>; 10  
        * \# async fn list\_sessions(\&self) \-\> zbus::Result\<Vec\<(String, u32, String, String, zbus::zvariant::OwnedObjectPath)\>\>; 10  
        * \# async fn lock\_session(\&self, session\_id: \&str) \-\> zbus::Result\<()\>; 10  
        * \# async fn unlock\_session(\&self, session\_id: \&str) \-\> zbus::Result\<()\>; 10  
        * \# async fn lock\_sessions(\&self) \-\> zbus::Result\<()\>; 10  
        * \# async fn unlock\_sessions(\&self) \-\> zbus::Result\<()\>; 10  
      * Signale:  
        * \#\[zbus(signal)\] async fn session\_new(\&self, session\_id: String, object\_path: zbus::zvariant::OwnedObjectPath) \-\> zbus::Result\<()\>; 12  
        * \#\[zbus(signal)\] async fn session\_removed(\&self, session\_id: String, object\_path: zbus::zvariant::OwnedObjectPath) \-\> zbus::Result\<()\>; 12  
        * \# async fn prepare\_for\_sleep(\&self, start\_or\_stop: bool) \-\> zbus::Result\<()\>; 10  
    * LogindSessionProxy für org.freedesktop.login1.Session (Pfad variabel).  
      * Methoden:  
        * \#\[zbus(name \= "Lock")\] async fn lock(\&self) \-\> zbus::Result\<()\>; 10  
        * \#\[zbus(name \= "Unlock")\] async fn unlock(\&self) \-\> zbus::Result\<()\>; 10  
        * \# async fn terminate(\&self) \-\> zbus::Result\<()\>; 10  
      * Properties (Beispiele): Id: String, User: (u32, zbus::zvariant::OwnedObjectPath), Name: String, Timestamp: u64, TimestampMonotonic: u64, VTNr: u32, Seat: (String, zbus::zvariant::OwnedObjectPath), TTY: String, Remote: bool, RemoteHost: String, Service: String, Scope: String, Leader: u32, Audit: u32, Type: String, Class: String, Active: bool, State: String, IdleHint: bool, IdleSinceHint: u64, IdleSinceHintMonotonic: u64.  
      * Signale:  
        * \#\[zbus(signal, name \= "Lock")\] async fn lock\_signal(\&self) \-\> zbus::Result\<()\>; 10  
        * \#\[zbus(signal, name \= "Unlock")\] async fn unlock\_signal(\&self) \-\> zbus::Result\<()\>; 10  
        * \#\[zbus(signal, name \= "PropertyChanged")\] async fn property\_changed\_signal(\&self, name: String, value: zbus::zvariant::OwnedValue) \-\> zbus::Result\<()\>; (Standard-Signal)  
    * LogindUserProxy für org.freedesktop.login1.User (Pfad variabel).  
      * Methoden:  
        * \# async fn terminate(\&self) \-\> zbus::Result\<()\>; 10  
      * Properties (Beispiele): UID: u32, GID: u32, Name: String, Timestamp: u64, TimestampMonotonic: u64, RuntimePath: String, Service: String, Slice: String, Display: (String, zbus::zvariant::OwnedObjectPath), State: String, Sessions: Vec\<(String, zbus::zvariant::OwnedObjectPath)\>, IdleHint: bool, IdleSinceHint: u64, IdleSinceHintMonotonic: u64, Linger: bool.  
  * **Struktur**: LogindClient  
    * Felder: connection\_manager: Arc\<DBusConnectionManager\>, manager\_proxy\_path: Arc\<zbus::zvariant::ObjectPath\<'static\>\>.  
  * **Methoden** für LogindClient:  
    * pub async fn new(conn\_manager: Arc\<DBusConnectionManager\>) \-\> Result\<Self, DBusError\>  
    * async fn get\_manager\_proxy(\&self) \-\> Result\<LogindManagerProxy\<'\_\>, DBusError\>  
    * async fn get\_session\_proxy\<'a\>(\&self, session\_path: &'a zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<LogindSessionProxy\<'a\>, DBusError\>  
    * pub async fn list\_sessions(\&self) \-\> Result\<Vec\<SessionInfo\>, DBusError\>: Ruft LogindManagerProxy::list\_sessions() auf und konvertiert das Tupel-Array in Vec\<SessionInfo\>.  
    * pub async fn get\_session\_details(\&self, session\_path: \&zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<SessionInfo, DBusError\>: Ruft Properties vom LogindSessionProxy ab.  
    * pub async fn lock\_session(\&self, session\_id: \&str) \-\> Result\<(), DBusError\>  
    * pub async fn unlock\_session(\&self, session\_id: \&str) \-\> Result\<(), DBusError\>  
    * pub async fn lock\_all\_sessions(\&self) \-\> Result\<(), DBusError\>  
    * pub async fn unlock\_all\_sessions(\&self) \-\> Result\<(), DBusError\>  
    * pub async fn subscribe\_session\_new(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<SessionInfo, DBusError\>\>, DBusError\>: Abonniert SessionNew, konvertiert die Daten in SessionInfo.  
    * pub async fn subscribe\_session\_removed(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<(String, zbus::zvariant::OwnedObjectPath), DBusError\>\>, DBusError\>  
    * pub async fn subscribe\_prepare\_for\_sleep(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<bool, DBusError\>\>, DBusError\> Das PrepareForSleep-Signal ist von besonderer Bedeutung. Wenn start\_or\_stop true ist, kündigt dies einen bevorstehenden Suspend- oder Hibernate-Vorgang an.10 Die Desktop-Umgebung muss darauf reagieren, indem sie beispielsweise den Bildschirm sperrt, laufende Anwendungen benachrichtigt (falls ein entsprechendes Protokoll existiert) und kritische Zustände sichert. Bei false signalisiert es das Aufwachen des Systems, woraufhin der Desktop entsperrt und Dienste reaktiviert werden können.  
    * pub async fn subscribe\_session\_lock(\&self, session\_path: zbus::zvariant::OwnedObjectPath) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<(), DBusError\>\>, DBusError\>: Abonniert das Lock-Signal des spezifischen Session-Objekts.  
    * pub async fn subscribe\_session\_unlock(\&self, session\_path: zbus::zvariant::OwnedObjectPath) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<(), DBusError\>\>, DBusError\>: Abonniert das Unlock-Signal des spezifischen Session-Objekts.  
* **Implementierungsschritte**: Analog zu UPowerClient. Besondere Aufmerksamkeit gilt der korrekten Handhabung der PrepareForSleep-Signale und der Interaktion mit den Session-spezifischen Lock/Unlock-Signalen.  
* **Publisher/Subscriber**:  
  * Publisher: org.freedesktop.login1 D-Bus Dienst.  
  * Subscriber: LogindClient.

### **5\. Submodul: system::dbus::networkmanager\_client – NetworkManager D-Bus Client**

Dieser Client interagiert mit org.freedesktop.NetworkManager, um Netzwerkinformationen abzurufen und auf Zustandsänderungen zu reagieren. Diese Informationen sind sowohl für die UI-Darstellung als auch für KI-Funktionen (z.B. Online-Status-Prüfung) relevant.

* **Dateien**: system/dbus/networkmanager\_client.rs, system/dbus/networkmanager\_types.rs  
* **Spezifikation (networkmanager\_types.rs)**:  
  * pub enum NetworkManagerState { Unknown \= 0, Asleep \= 10, Disconnected \= 20, Disconnecting \= 30, Connecting \= 40, ConnectedLocal \= 50, ConnectedSite \= 60, ConnectedGlobal \= 70 } (Werte gemäß NMState aus der NetworkManager-Dokumentation).  
  * pub enum NetworkDeviceType { Unknown \= 0, Ethernet \= 1, Wifi \= 2, Wimax \= 5, Modem \= 6, Bluetooth \= 7, /\*... weitere Typen... \*/ } (Werte gemäß NMDeviceType).  
  * pub enum NetworkConnectivityState { Unknown \= 0, None \= 1, Portal \= 2, Limited \= 3, Full \= 4 } (Werte gemäß NMConnectivityState).  
  * pub struct NetworkDevice { pub object\_path: zbus::zvariant::OwnedObjectPath, pub interface: String, pub ip\_interface: String, pub driver: String, pub device\_type: NetworkDeviceType, pub state: u32, /\* NMDeviceState \*/ pub available\_connections: Vec\<zbus::zvariant::OwnedObjectPath\>, pub managed: bool, pub firmare\_missing: bool, pub plugged: bool, /\*... weitere Felder... \*/ }.  
  * pub struct ActiveConnection { pub object\_path: zbus::zvariant::OwnedObjectPath, pub connection\_object\_path: zbus::zvariant::OwnedObjectPath, pub specific\_object\_path: zbus::zvariant::OwnedObjectPath, pub id: String, pub uuid: String, pub conn\_type: String, pub devices: Vec\<zbus::zvariant::OwnedObjectPath\>, pub state: u32, /\* NMActiveConnectionState \*/ pub default: bool, pub default6: bool, pub vpn: bool, /\*... weitere Felder... \*/ }.  
  * pub struct NetworkManagerProperties { pub state: NetworkManagerState, pub connectivity: NetworkConnectivityState, pub wireless\_enabled: bool, pub wwan\_enabled: bool, pub active\_connections: Vec\<zbus::zvariant::OwnedObjectPath\>, /\*... \*/ }.  
* **Spezifikation (networkmanager\_client.rs)**:  
  * **Proxy-Definitionen**:  
    * NetworkManagerProxy für org.freedesktop.NetworkManager auf /org/freedesktop/NetworkManager.  
      * Methoden: GetDevices() \-\> zbus::Result\<Vec\<zbus::zvariant::OwnedObjectPath\>\>, GetActiveConnections() \-\> zbus::Result\<Vec\<zbus::zvariant::OwnedObjectPath\>\>, ActivateConnection(connection: \&zbus::zvariant::ObjectPath\<'\_\>, device: \&zbus::zvariant::ObjectPath\<'\_\>, specific\_object: \&zbus::zvariant::ObjectPath\<'\_\>) \-\> zbus::Result\<zbus::zvariant::OwnedObjectPath\>.  
      * Properties: State: u32, Connectivity: u32, WirelessEnabled: bool, WwanEnabled: bool, ActiveConnections: Vec\<zbus::zvariant::OwnedObjectPath\>.  
      * Signale: StateChanged(state: u32), DeviceAdded(device\_path: zbus::zvariant::OwnedObjectPath), DeviceRemoved(device\_path: zbus::zvariant::OwnedObjectPath).  
    * NMDeviceProxy für org.freedesktop.NetworkManager.Device (Pfad variabel).  
      * Properties: Udi: String, Interface: String, IpInterface: String, Driver: String, DeviceType: u32, State: u32, Managed: bool, AvailableConnections: Vec\<zbus::zvariant::OwnedObjectPath\>, FirmwareMissing: bool, Plugged: bool.  
    * NMActiveConnectionProxy für org.freedesktop.NetworkManager.Connection.Active (Pfad variabel).  
      * Properties: Connection: zbus::zvariant::OwnedObjectPath, SpecificObject: zbus::zvariant::OwnedObjectPath, Id: String, Uuid: String, Type: String, Devices: Vec\<zbus::zvariant::OwnedObjectPath\>, State: u32, Default: bool, Default6: bool, Vpn: bool.  
  * **Struktur**: NetworkManagerClient  
    * Felder: connection\_manager: Arc\<DBusConnectionManager\>, manager\_proxy\_path: Arc\<zbus::zvariant::ObjectPath\<'static\>\>.  
  * **Methoden** für NetworkManagerClient:  
    * pub async fn new(conn\_manager: Arc\<DBusConnectionManager\>) \-\> Result\<Self, DBusError\>  
    * async fn get\_manager\_proxy(\&self) \-\> Result\<NetworkManagerProxy\<'\_\>, DBusError\>  
    * async fn get\_device\_proxy\<'a\>(\&self, device\_path: &'a zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<NMDeviceProxy\<'a\>, DBusError\>  
    * async fn get\_active\_connection\_proxy\<'a\>(\&self, ac\_path: &'a zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<NMActiveConnectionProxy\<'a\>, DBusError\>  
    * pub async fn get\_properties(\&self) \-\> Result\<NetworkManagerProperties, DBusError\>  
    * pub async fn get\_devices(\&self) \-\> Result\<Vec\<NetworkDevice\>, DBusError\>: Ruft Pfade über GetDevices ab, dann für jeden Pfad die Details über NMDeviceProxy.  
    * pub async fn get\_active\_connections(\&self) \-\> Result\<Vec\<ActiveConnection\>, DBusError\>: Ruft Pfade über GetActiveConnections ab, dann für jeden Pfad die Details über NMActiveConnectionProxy.  
    * pub async fn subscribe\_state\_changed(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<NetworkManagerState, DBusError\>\>, DBusError\>: Abonniert StateChanged, konvertiert u32 in NetworkManagerState.  
    * pub async fn subscribe\_device\_added(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<NetworkDevice, DBusError\>\>, DBusError\>: Abonniert DeviceAdded, ruft dann Details für den neuen Pfad ab.  
    * pub async fn subscribe\_device\_removed(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<zbus::zvariant::OwnedObjectPath, DBusError\>\>, DBusError\>  
* **Implementierungsschritte**: Analog zu UPowerClient. Die Datenstrukturen müssen die komplexen Informationen von NetworkManager korrekt abbilden.  
* **Publisher/Subscriber**:  
  * Publisher: org.freedesktop.NetworkManager D-Bus Dienst.  
  * Subscriber: NetworkManagerClient.  
* Die reaktive Aktualisierung des Netzwerkstatus bei Signalempfang ist für eine responsive UI und zuverlässige KI-Funktionen von Bedeutung. Änderungen an der Liste der Geräte oder aktiven Verbindungen erfordern, dass der Client die entsprechenden Detailinformationen neu abruft, da die Signale oft nur die Objektpfade der geänderten Entitäten enthalten.

### **6\. Submodul: system::dbus::secrets\_client – Freedesktop Secret Service D-Bus Client**

Dieser Client interagiert mit dem org.freedesktop.secrets-Dienst zum sicheren Speichern und Abrufen von sensiblen Daten wie API-Schlüsseln für Cloud-LLMs.13

* **Dateien**: system/dbus/secrets\_client.rs, system/dbus/secrets\_types.rs  
* **Spezifikation (secrets\_types.rs)**:  
  * pub struct Secret { pub session: zbus::zvariant::OwnedObjectPath, pub parameters: Vec\<u8\>, pub value: Vec\<u8\>, pub content\_type: String }  
  * pub struct SecretItemInfo { pub object\_path: zbus::zvariant::OwnedObjectPath, pub label: String, pub attributes: HashMap\<String, String\>, pub created: u64, pub modified: u64, pub locked: bool }  
  * pub struct SecretCollectionInfo { pub object\_path: zbus::zvariant::OwnedObjectPath, pub label: String, pub created: u64, pub modified: u64, pub locked: bool }  
  * pub enum PromptCompletedResult { Dismissed, Continue(Option\<zbus::zvariant::OwnedValue\> )}  
* **Spezifikation (secrets\_client.rs)**:  
  * **Proxy-Definitionen**:  
    * SecretServiceProxy für org.freedesktop.Secret.Service auf /org/freedesktop/secrets.  
      * Methoden: OpenSession(algorithm: \&str, input: \&zbus::zvariant::Value\<'\_\>) \-\> zbus::Result\<(zbus::zvariant::OwnedValue, zbus::zvariant::OwnedObjectPath)\>, CreateCollection(properties: HashMap\<\&str, \&zbus::zvariant::Value\<'\_\>\>, alias: \&str) \-\> zbus::Result\<(zbus::zvariant::OwnedObjectPath, zbus::zvariant::OwnedObjectPath /\* prompt \*/)\>, SearchItems(attributes: HashMap\<\&str, \&str\>) \-\> zbus::Result\<(Vec\<zbus::zvariant::OwnedObjectPath\>, Vec\<zbus::zvariant::OwnedObjectPath\>) /\* unlocked, locked \*/\>, Unlock(objects: &\[\&zbus::zvariant::ObjectPath\<'\_\>\]) \-\> zbus::Result\<(Vec\<zbus::zvariant::OwnedObjectPath\>, zbus::zvariant::OwnedObjectPath /\* prompt \*/)\>, Lock(objects: &\[\&zbus::zvariant::ObjectPath\<'\_\>\]) \-\> zbus::Result\<(Vec\<zbus::zvariant::OwnedObjectPath\>, zbus::zvariant::OwnedObjectPath /\* prompt \*/)\>, GetSecrets(items: &\[\&zbus::zvariant::ObjectPath\<'\_\>\], session: \&zbus::zvariant::ObjectPath\<'\_\>) \-\> zbus::Result\<HashMap\<zbus::zvariant::OwnedObjectPath, Secret\>\>.  
      * Properties: Collections: Vec\<zbus::zvariant::OwnedObjectPath\>.  
      * Signale: CollectionCreated(collection\_path: zbus::zvariant::OwnedObjectPath), CollectionChanged(collection\_path: zbus::zvariant::OwnedObjectPath), CollectionDeleted(collection\_path: zbus::zvariant::OwnedObjectPath).  
    * SecretCollectionProxy für org.freedesktop.Secret.Collection (Pfad variabel).  
      * Methoden: CreateItem(properties: HashMap\<\&str, \&zbus::zvariant::Value\<'\_\>\>, secret: \&Secret, replace: bool) \-\> zbus::Result\<(zbus::zvariant::OwnedObjectPath /\* item \*/, zbus::zvariant::OwnedObjectPath /\* prompt \*/)\>, SearchItems(attributes: HashMap\<\&str, \&str\>) \-\> zbus::Result\<Vec\<zbus::zvariant::OwnedObjectPath\>\>, Delete() \-\> zbus::Result\<zbus::zvariant::OwnedObjectPath /\* prompt \*/\>.  
      * Properties: Label: String, Created: u64, Modified: u64, Locked: bool, Items: Vec\<zbus::zvariant::OwnedObjectPath\>.  
    * SecretItemProxy für org.freedesktop.Secret.Item (Pfad variabel).  
      * Methoden: GetSecret(session: \&zbus::zvariant::ObjectPath\<'\_\>) \-\> zbus::Result\<Secret\>, SetSecret(secret: \&Secret) \-\> zbus::Result\<()\>, Delete() \-\> zbus::Result\<zbus::zvariant::OwnedObjectPath /\* prompt \*/\>.  
      * Properties: Label: String, Attributes: HashMap\<String, String\>, Created: u64, Modified: u64, Locked: bool.  
    * SecretPromptProxy für org.freedesktop.Secret.Prompt (Pfad variabel).  
      * Methoden: Prompt(window\_id: \&str) \-\> zbus::Result\<()\>  
      * Signale: Completed(dismissed: bool, result: zbus::zvariant::Value\<'static\>)  
  * **Struktur**: SecretsClient  
    * Felder: connection\_manager: Arc\<DBusConnectionManager\>, service\_proxy\_path: Arc\<zbus::zvariant::ObjectPath\<'static\>\>.  
  * **Methoden** für SecretsClient:  
    * pub async fn new(conn\_manager: Arc\<DBusConnectionManager\>) \-\> Result\<Self, DBusError\>  
    * async fn get\_service\_proxy(\&self) \-\> Result\<SecretServiceProxy\<'\_\>, DBusError\>  
    * async fn get\_collection\_proxy\<'a\>(\&self, path: &'a zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<SecretCollectionProxy\<'a\>, DBusError\>  
    * async fn get\_item\_proxy\<'a\>(\&self, path: &'a zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<SecretItemProxy\<'a\>, DBusError\>  
    * async fn get\_prompt\_proxy\<'a\>(\&self, path: &'a zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<SecretPromptProxy\<'a\>, DBusError\>  
    * pub async fn open\_session(\&self) \-\> Result\<zbus::zvariant::OwnedObjectPath /\* session\_path \*/, DBusError\>: Verwendet "plain" Algorithmus und leeren Input.  
    * pub async fn get\_default\_collection(\&self) \-\> Result\<zbus::zvariant::OwnedObjectPath, DBusError\>: Sucht nach der Collection mit Alias "default" oder erstellt sie.  
    * pub async fn store\_secret(\&self, collection\_path: \&zbus::zvariant::ObjectPath\<'\_\>, label: \&str, secret\_value: &\[u8\], attributes: HashMap\<String, String\>, session\_path: \&zbus::zvariant::ObjectPath\<'\_\>, window\_id\_provider: impl Fn() \-\> String \+ Send \+ Sync) \-\> Result\<zbus::zvariant::OwnedObjectPath, DBusError\>: Erstellt ein Secret-Struct, ruft CreateItem auf der Collection auf. Behandelt den zurückgegebenen Prompt-Pfad mit handle\_prompt\_if\_needed.  
    * pub async fn retrieve\_secret(\&self, item\_path: \&zbus::zvariant::ObjectPath\<'\_\>, session\_path: \&zbus::zvariant::ObjectPath\<'\_\>, window\_id\_provider: impl Fn() \-\> String \+ Send \+ Sync) \-\> Result\<Option\<Vec\<u8\>\>, DBusError\>: Ruft GetSecret auf dem Item auf. Falls das Item oder die Collection gesperrt ist, wird Unlock auf dem Service-Proxy versucht, was einen Prompt auslösen kann.  
    * pub async fn search\_items(\&self, attributes: HashMap\<String, String\>) \-\> Result\<Vec\<SecretItemInfo\>, DBusError\>: Ruft SearchItems auf dem Service-Proxy auf, dann für jeden gefundenen Pfad die Properties vom SecretItemProxy.  
    * async fn handle\_prompt\_if\_needed(\&self, prompt\_path: \&zbus::zvariant::ObjectPath\<'\_\>, window\_id\_provider: impl Fn() \-\> String \+ Send \+ Sync) \-\> Result\<PromptCompletedResult, DBusError\>: Diese Methode ist zentral für die Benutzerinteraktion. Wenn prompt\_path nicht "/" ist (was "kein Prompt nötig" bedeutet), wird ein SecretPromptProxy erstellt. Prompt(window\_id) wird aufgerufen, wobei window\_id von der UI-Schicht über window\_id\_provider dynamisch bereitgestellt wird. Anschließend wird auf das Completed-Signal des Prompts gewartet. Das Ergebnis des Signals (dismissed, result) wird in PromptCompletedResult umgewandelt. Die Notwendigkeit einer window\_id für Prompts erfordert eine enge Kopplung oder einen Callback-Mechanismus mit der UI-Schicht, da die Systemschicht selbst keine Fensterkonzepte oder \-IDs direkt verwaltet.  
* **Implementierungsschritte**: Definition der Typen, Generierung der Proxies. Besondere Sorgfalt ist beim Management von Sessions und der Handhabung von Prompts geboten. Der secret-service-rs Crate 13 kann als Referenz für die korrekte Implementierung der komplexen Abläufe dienen.  
* **Publisher/Subscriber**:  
  * Publisher: org.freedesktop.secrets D-Bus Dienst.  
  * Subscriber: SecretsClient.

### **7\. Submodul: system::dbus::policykit\_client – PolicyKit D-Bus Client**

Dieser Client interagiert mit org.freedesktop.PolicyKit1.Authority zur Überprüfung von Berechtigungen für privilegierte Aktionen \[User Query III.11\].

* **Dateien**: system/dbus/policykit\_client.rs, system/dbus/policykit\_types.rs  
* **Spezifikation (policykit\_types.rs)**:  
  * Bitflags-Struktur PolicyKitCheckAuthFlags:  
    * None \= 0  
    * AllowUserInteraction \= 1  
    * NoUserInteraction \= 2 (obwohl AllowUserInteraction \= false dasselbe bewirkt)  
    * AllowDowngrade \= 4  
    * RetainAuthorization \= 8  
  * pub struct PolicyKitSubject\<'a\> { pub kind: &'a str, pub details: HashMap\<&'a str, zbus::zvariant::Value\<'a\>\> } (z.B. kind \= "unix-process", details \= {"pid" \-\> Value::U32(self\_pid)}).  
  * pub struct PolicyKitAuthorizationResult { pub is\_authorized: bool, pub is\_challenge: bool, pub details: HashMap\<String, zbus::zvariant::OwnedValue\> }  
* **Spezifikation (policykit\_client.rs)**:  
  * **Proxy-Definition**:  
    * PolicyKitAuthorityProxy für org.freedesktop.PolicyKit1.Authority auf /org/freedesktop/PolicyKit1/Authority.  
      * Methoden: CheckAuthorization\<'a\>(subject: PolicyKitSubject\<'a\>, action\_id: \&str, details: HashMap\<\&str, \&str\>, flags: u32, cancellation\_id: \&str) \-\> zbus::Result\<PolicyKitAuthorizationResult\>.  
  * **Struktur**: PolicyKitClient  
    * Felder: connection\_manager: Arc\<DBusConnectionManager\>, authority\_proxy\_path: Arc\<zbus::zvariant::ObjectPath\<'static\>\>.  
  * **Methoden** für PolicyKitClient:  
    * pub async fn new(conn\_manager: Arc\<DBusConnectionManager\>) \-\> Result\<Self, DBusError\>  
    * async fn get\_authority\_proxy(\&self) \-\> Result\<PolicyKitAuthorityProxy\<'\_\>, DBusError\>  
    * pub async fn check\_authorization(\&self, subject\_pid: Option\<u32\>, action\_id: \&str, details: HashMap\<String, String\>, allow\_interaction: bool) \-\> Result\<PolicyKitAuthorizationResult, DBusError\>: Erstellt ein PolicyKitSubject. Wenn subject\_pid Some(pid) ist, wird kind \= "unix-process" und details \= {"pid": Value::U32(pid)} verwendet. Andernfalls wird der PID des aktuellen Prozesses verwendet. Setzt die flags basierend auf allow\_interaction. cancellation\_id kann leer sein. Ruft PolicyKitAuthorityProxy::CheckAuthorization auf. Die korrekte Definition des subject ist sicherheitskritisch. Es muss klar sein, im Kontext welcher Entität (der Desktop-Umgebung selbst oder einer anfragenden Anwendung) die Berechtigung geprüft wird.  
* **Implementierungsschritte**: Proxy-Generierung, Implementierung der Client-Methoden. Die subject-Erstellung muss sorgfältig implementiert werden.  
* **Publisher/Subscriber**:  
  * Publisher: org.freedesktop.PolicyKit1.Authority D-Bus Dienst.  
  * Subscriber: PolicyKitClient.

## **B. Modul: system::outputs – Verwaltung der Anzeigeausgänge (Display Output Management)**

Dieses Modul ist für die Erkennung, Konfiguration und Verwaltung von Anzeigeausgängen (Monitoren) zuständig. Es implementiert die serverseitige Logik für die relevanten Wayland-Protokolle (wl\_output, xdg-output-unstable-v1, wlr-output-management-unstable-v1, wlr-output-power-management-unstable-v1) unter Verwendung der Abstraktionen von Smithay.14 Die korrekte Handhabung von Monitorkonfigurationen, Auflösungen, Skalierung und Hotplugging ist entscheidend für eine gute Benutzererfahrung, insbesondere in Multi-Monitor-Umgebungen.

### **1\. Submodul: system::outputs::error – Fehlerbehandlung für Output-Operationen**

Definiert spezifische Fehlertypen für Operationen im Zusammenhang mit Anzeigeausgängen.

* **Datei**: system/outputs/error.rs  
* **Spezifikation**:  
  * Öffentliches Enum OutputError mit thiserror::Error und Debug.  
  * **Varianten**:  
    * \# DeviceAccessFailed { device: String, \#\[source\] source: std::io::Error } (Relevant bei direktem DRM-Zugriff, z.B. über smithay::backend::drm).  
    * \#\[error("Wayland protocol error for '{protocol}': {message}")\] ProtocolError { protocol: String, message: String } (Für Fehler bei der Implementierung von Wayland-Protokollen).  
    * \#\[error("Output configuration conflict: {details}")\] ConfigurationConflict { details: String } (Wenn eine angeforderte Konfiguration nicht angewendet werden kann).  
    * \#\[error("Failed to create Wayland resource '{resource}': {reason}")\] ResourceCreationFailed { resource: String, reason: String }.  
    * \# SmithayOutputError { \#\[source\] source: smithay::output::OutputError } (Falls Smithay spezifische Fehler für smithay::output::Output-Operationen definiert).  
    * \#\[error("Output '{name}' not found")\] OutputNotFound { name: String }.  
    * \#\[error("Mode not supported by output '{output\_name}'")\] ModeNotSupported { output\_name: String, mode\_details: String }.  
* **Implementierungsschritte**: Definition des Enums, \#\[error(...)\]-Attribute und From-Implementierungen für zugrundeliegende Fehler (z.B. std::io::Error).

### **2\. Submodul: system::outputs::output\_device – Kernrepräsentation eines Anzeigeausgangs**

Diese Struktur kapselt den Zustand und die Logik eines einzelnen physischen Anzeigeausgangs.

* **Datei**: system/outputs/output\_device.rs  
* **Spezifikation**:  
  * **Struktur**: OutputDevice  
    * Felder:  
      * name: String (Eindeutiger Name des Outputs, z.B. "DP-1", "HDMI-A-2").  
      * smithay\_output: smithay::output::Output 15: Die Kernabstraktion von Smithay für einen Output. Enthält physische Eigenschaften, aktuelle und bevorzugte Modi.  
      * wl\_output\_global: Option\<wayland\_server::backend::GlobalId\>: Die ID des wl\_output-Globals, das diesen physischen Output repräsentiert.  
      * xdg\_output\_global: Option\<wayland\_server::backend::GlobalId\>: Die ID des zxdg\_output\_v1-Globals.  
      * wlr\_head\_global: Option\<wayland\_server::backend::GlobalId\>: Die ID des zwlr\_output\_head\_v1-Globals (für wlr-output-management).  
      * wlr\_power\_global: Option\<wayland\_server::backend::GlobalId\>: Die ID des zwlr\_output\_power\_v1-Globals (für wlr-output-power-management).  
      * enabled: bool: Gibt an, ob der Output aktuell aktiviert ist.  
      * current\_dpms\_state: DpmsState: Enum für den DPMS-Zustand (On, Standby, Suspend, Off).  
      * pending\_config\_serial: Option\<u32\>: Das Serial einer laufenden wlr-output-management-Konfiguration.  
  * **Struktur**: OutputDevicePendingState (für wlr-output-management)  
    * Felder: mode: Option\<smithay::output::Mode\>, position: Option\<smithay::utils::Point\<i32, smithay::utils::Logical\>\>, transform: Option\<smithay::utils::Transform\>, scale: Option\<f64\>, enabled: Option\<bool\>, adaptive\_sync\_enabled: Option\<bool\>.  
  * **Enum**: DpmsState { On, Standby, Suspend, Off }  
  * **Methoden** für OutputDevice:  
    * pub fn new(name: String, physical\_properties: smithay::output::PhysicalProperties, preferred\_mode: Option\<smithay::output::Mode\>, possible\_modes: Vec\<smithay::output::Mode\>, display\_handle: \&wayland\_server::DisplayHandle, compositor\_state: \&mut YourCompositorState) \-\> Result\<Self, OutputError\>: Erstellt ein neues OutputDevice. Initialisiert self.smithay\_output \= smithay::output::Output::new(name.clone(), physical\_properties.clone());. Fügt die possible\_modes und preferred\_mode zum smithay\_output hinzu (add\_mode(), set\_preferred\_mode()). Setzt einen initialen Zustand (z.B. bevorzugter Modus, Position (0,0), normale Transformation, Skalierung 1.0) via self.apply\_state\_internal(...). Das Erstellen der Globals (wl\_output\_global, xdg\_output\_global, etc.) erfolgt typischerweise durch den OutputManager oder die jeweiligen Protokoll-Handler, nicht direkt im Konstruktor des OutputDevice, da dies den globalen Display-Zustand modifiziert.  
    * pub fn name(\&self) \-\> \&str  
    * pub fn smithay\_output(\&self) \-\> \&smithay::output::Output  
    * pub fn current\_mode(\&self) \-\> Option\<smithay::output::Mode\>: Gibt den aktuellen Modus aus smithay\_output.current\_mode() zurück.  
    * pub fn current\_transform(\&self) \-\> smithay::utils::Transform: Gibt die aktuelle Transformation aus smithay\_output.current\_transform() zurück.  
    * pub fn current\_scale(\&self) \-\> smithay::output::Scale: Gibt die aktuelle Skalierung aus smithay\_output.current\_scale() zurück.  
    * pub fn current\_position(\&self) \-\> smithay::utils::Point\<i32, smithay::utils::Logical\>: Gibt die aktuelle Position aus smithay\_output.current\_position() zurück.  
    * pub fn is\_enabled(\&self) \-\> bool  
    * pub fn apply\_state(\&mut self, mode: Option\<smithay::output::Mode\>, transform: Option\<smithay::utils::Transform\>, scale: Option\<smithay::output::Scale\>, position: Option\<smithay::utils::Point\<i32, smithay::utils::Logical\>\>, enabled: bool) \-\> Result\<(), OutputError\>: Interne Methode, die self.smithay\_output.change\_current\_state(mode, transform, scale, position) aufruft.15 Aktualisiert self.enabled. Wenn enabled false ist, wird None für mode an change\_current\_state übergeben. Smithay sendet die wl\_output und xdg\_output Events (geometry, mode, scale, done, logical\_position, logical\_size) automatisch.  
    * pub fn set\_dpms\_state(\&mut self, state: DpmsState) \-\> Result\<(), OutputError\>: Ändert den DPMS-Zustand des Outputs (z.B. über DRM). Aktualisiert self.current\_dpms\_state. Löst ggf. Events für wlr-output-power-management aus.  
    * pub fn supported\_modes(\&self) \-\> Vec\<smithay::output::Mode\>: Gibt self.smithay\_output.modes() zurück.  
    * pub fn physical\_properties(\&self) \-\> smithay::output::PhysicalProperties: Gibt self.smithay\_output.physical\_properties() zurück.  
    * pub fn add\_mode(\&mut self, mode: smithay::output::Mode): Fügt einen Modus zu self.smithay\_output hinzu.  
    * pub fn set\_preferred\_mode(\&mut self, mode: smithay::output::Mode): Setzt den bevorzugten Modus in self.smithay\_output.  
    * Methoden zum Setzen und Abrufen der Global-IDs (wl\_output\_global, xdg\_output\_global, etc.).  
    * pub fn destroy\_globals(\&mut self, display\_handle: \&wayland\_server::DisplayHandle): Entfernt alle zugehörigen Globals vom DisplayHandle.  
* **Implementierungsschritte**:  
  1. Definiere OutputDevice, OutputDevicePendingState und DpmsState.  
  2. Implementiere new(): Initialisiert smithay::output::Output korrekt.  
  3. Implementiere apply\_state(): Ruft smithay\_output.change\_current\_state() auf.  
  4. Implementiere set\_dpms\_state(): Interagiert mit der DRM-Schicht oder dem entsprechenden Backend, um den Energiezustand zu ändern.

### **3\. Submodul: system::outputs::manager – Zentrales Management der Anzeigeausgänge**

Der OutputManager verwaltet eine Liste aller bekannten OutputDevice-Instanzen und behandelt Hotplug-Events.

* **Datei**: system/outputs/manager.rs  
* **Spezifikation**:  
  * **Struktur**: OutputManager  
    * Felder: outputs: HashMap\<String, Arc\<Mutex\<OutputDevice\>\>\> (HashMap mit Output-Name als Schlüssel), udev\_event\_source\_token: Option\<calloop::RegistrationToken\> (falls udev verwendet wird). Die Verwendung von Arc\<Mutex\<OutputDevice\>\> ist hier geboten, da OutputDevice-Instanzen von verschiedenen Teilen des Systems (z.B. DRM-Event-Handler, Wayland-Dispatcher für wlr-output-management, D-Bus-Handler für Power-Events) potenziell nebenläufig modifiziert werden könnten. Arc ermöglicht das Teilen des Besitzes, und Mutex stellt den exklusiven Zugriff für Schreiboperationen sicher, um Datenkonsistenz zu gewährleisten.5  
  * **Enum**: HotplugEvent  
    * DeviceAdded { name: String, path: std::path::PathBuf, physical\_properties: smithay::output::PhysicalProperties, modes: Vec\<smithay::output::Mode\>, preferred\_mode: Option\<smithay::output::Mode\>, enabled: bool, is\_drm: bool, drm\_device\_fd: Option\<std::os::unix::io::OwnedFd\> /\* nur wenn is\_drm true \*/ }  
    * DeviceRemoved { name: String }  
  * **Methoden** für OutputManager:  
    * pub fn new() \-\> Self  
    * pub fn add\_output(\&mut self, output\_device: Arc\<Mutex\<OutputDevice\>\>): Fügt ein OutputDevice zur outputs-Map hinzu.  
    * pub fn remove\_output(\&mut self, name: \&str, display\_handle: \&wayland\_server::DisplayHandle) \-\> Option\<Arc\<Mutex\<OutputDevice\>\>\>: Entfernt ein OutputDevice anhand seines Namens, zerstört dessen Globals und gibt es zurück.  
    * pub fn find\_output\_by\_name(\&self, name: \&str) \-\> Option\<Arc\<Mutex\<OutputDevice\>\>\>  
    * pub fn all\_outputs(\&self) \-\> Vec\<Arc\<Mutex\<OutputDevice\>\>\>: Gibt eine geklonte Liste aller Arc\<Mutex\<OutputDevice\>\> zurück.  
    * pub fn handle\_hotplug\_event(\&mut self, event: HotplugEvent, display\_handle: \&wayland\_server::DisplayHandle, compositor\_state: \&mut YourCompositorState) \-\> Result\<(), OutputError\>: Verarbeitet Hotplug-Events. Bei DeviceAdded: 1\. Prüft, ob ein Output mit diesem Namen bereits existiert. 2\. Erstellt ein neues OutputDevice mit den übergebenen Eigenschaften. 3\. Ruft output\_device\_created\_notifications auf, um die notwendigen Globals zu erstellen und Handler zu informieren. 4\. Fügt das neue OutputDevice zur outputs-Map hinzu. Bei DeviceRemoved: 1\. Sucht das OutputDevice anhand des Namens. 2\. Ruft output\_device\_removed\_notifications auf, um Globals zu zerstören und Handler zu informieren. 3\. Entfernt das OutputDevice aus der outputs-Map. Die Hotplug-Logik ist stark abhängig vom verwendeten Backend. Bei einem DRM/udev-Backend kommen die Events vom UdevBackend 18, die dann in HotplugEvent übersetzt werden müssen.  
    * fn output\_device\_created\_notifications(\&self, output\_device: \&Arc\<Mutex\<OutputDevice\>\>, display\_handle: \&wayland\_server::DisplayHandle, compositor\_state: \&mut YourCompositorState): Private Hilfsmethode. Erstellt wl\_output, zxdg\_output\_v1 und zwlr\_output\_head\_v1 Globals für das neue Gerät. Benachrichtigt die WlrOutputManagementState und WlrOutputPowerManagementState über das neue Gerät.  
    * fn output\_device\_removed\_notifications(\&self, output\_device: \&Arc\<Mutex\<OutputDevice\>\>, display\_handle: \&wayland\_server::DisplayHandle, compositor\_state: \&mut YourCompositorState): Private Hilfsmethode. Zerstört die Globals des entfernten Geräts. Benachrichtigt die relevanten Handler.  
* **Implementierungsschritte**:  
  1. Definiere OutputManager und HotplugEvent.  
  2. Implementiere CRUD-Methoden für OutputDevice-Instanzen.  
  3. Implementiere handle\_hotplug\_event. Die genaue Quelle der HotplugEvents (z.B. Udev-Integration) muss hier berücksichtigt werden.  
  4. Implementiere die ...\_notifications-Hilfsmethoden, um die Erstellung/Zerstörung von Globals und die Benachrichtigung anderer Handler zu zentralisieren.

### **4\. Submodul: system::outputs::wl\_output\_handler – Implementierung des wl\_output Protokolls**

Die Logik für wl\_output wird durch Smithays Output-Typ und den OutputHandler-Trait gehandhabt.15

* **Datei**: Integration in den globalen Compositor-Zustand und system::outputs::manager.rs.  
* **Spezifikation**:  
  * **Smithay Integration**:  
    * Der globale Compositor-Zustand (YourCompositorState) implementiert smithay::wayland::output::OutputHandler.  
    * smithay::delegate\_output\!(YourCompositorState); muss im globalen Zustand deklariert werden.  
    * Beim Hinzufügen eines neuen physischen Outputs im OutputManager::handle\_hotplug\_event (oder einer ähnlichen Funktion) wird für das neue OutputDevice (welches ein smithay::output::Output enthält) die Methode output\_dev.smithay\_output().create\_global::\<YourCompositorState\>(display\_handle) aufgerufen.15 Die zurückgegebene GlobalId wird im OutputDevice::wl\_output\_global gespeichert.  
  * **Implementierung des OutputHandler-Traits für YourCompositorState**:  
    * fn output\_state(\&mut self) \-\> \&mut smithay::wayland::output::OutputManagerState: Gibt eine Referenz zum OutputManagerState des Compositors zurück. Dieser OutputManagerState wird typischerweise im globalen Zustand des Compositors gehalten und bei der Initialisierung mit OutputManagerState::new() oder OutputManagerState::new\_with\_xdg\_output() 15 erstellt.  
    * fn new\_output(\&mut self, \_output: \&smithay::reexports::wayland\_server::protocol::wl\_output::WlOutput, \_output\_data: \&smithay::wayland::output::OutputData): Diese Methode wird aufgerufen, wenn ein Client an ein wl\_output-Global bindet. Hier kann client-spezifischer Zustand initialisiert werden, falls nötig. OutputData enthält eine Referenz zum smithay::output::Output.  
    * fn output\_destroyed(\&mut self, \_output: \&smithay::reexports::wayland\_server::protocol::wl\_output::WlOutput, \_output\_data: \&smithay::wayland::output::OutputData): Wird aufgerufen, wenn ein wl\_output-Global zerstört wird.  
  * Smithay sendet geometry, mode, scale, done Events an wl\_output-Clients automatisch, wenn Output::change\_current\_state() auf dem entsprechenden smithay::output::Output aufgerufen wird.15  
* **Implementierungsschritte**:  
  1. Stelle sicher, dass der globale Compositor-Zustand (YourCompositorState) ein Feld für OutputManagerState hat und den OutputHandler-Trait implementiert.  
  2. Integriere den Aufruf von smithay\_output().create\_global() in die Logik, die neue OutputDevice-Instanzen erstellt (z.B. in OutputManager::output\_device\_created\_notifications).  
  3. Implementiere die Methoden des OutputHandler-Traits. Oftmals ist hier keine spezifische Logik notwendig, da Smithay vieles übernimmt.

### **5\. Submodul: system::outputs::wlr\_output\_management\_handler – Implementierung des wlr-output-management-unstable-v1 Protokolls**

Dieses Submodul implementiert die serverseitige Logik für das wlr-output-management-unstable-v1-Protokoll, das es Clients (wie kanshi 19) ermöglicht, Display-Konfigurationen abzufragen und zu ändern.20

* **Dateien**: system/outputs/wlr\_output\_management/mod.rs, system/outputs/wlr\_output\_management/manager\_handler.rs, system/outputs/wlr\_output\_management/head\_handler.rs, system/outputs/wlr\_output\_management/mode\_handler.rs, system/outputs/wlr\_output\_management/configuration\_handler.rs  
* **Protokoll-Objekte**: zwlr\_output\_manager\_v1, zwlr\_output\_head\_v1, zwlr\_output\_mode\_v1, zwlr\_output\_configuration\_v1, zwlr\_output\_configuration\_head\_v1.  
* **Spezifikation**:  
  * **Struktur**: WlrOutputManagementState (im globalen Compositor-Zustand)  
    * Felder:  
      * output\_manager: Arc\<Mutex\<OutputManager\>\> (Referenz zum globalen OutputManager).  
      * configurations: HashMap\<wayland\_server::backend::ObjectId, Arc\<Mutex\<OutputConfigurationRequest\>\>\> (speichert laufende Konfigurationsanfragen, Schlüssel ist die ID des zwlr\_output\_configuration\_v1-Objekts).  
      * global\_serial: std::sync::atomic::AtomicU32 (für die done-Events des Managers).  
  * **Struktur**: OutputConfigurationRequest  
    * Felder: serial: u32 (Serial, mit dem die Konfiguration erstellt wurde), client: wayland\_server::Client, pending\_changes: HashMap\<String /\* OutputDevice name \*/, HeadChangeRequest\>, config\_resource: wayland\_server::Resource\<ZwlrOutputConfigurationV1\>.  
  * **Struktur**: HeadChangeRequest  
    * Felder: mode: Option\<smithay::output::Mode\>, position: Option\<smithay::utils::Point\<i32, smithay::utils::Logical\>\>, transform: Option\<smithay::utils::Transform\>, scale: Option\<f64\>, enabled: Option\<bool\>, adaptive\_sync\_enabled: Option\<bool\>.  
  * **User Data Structs**:  
    * WlrOutputManagerGlobalData { output\_manager\_state: Weak\<Mutex\<WlrOutputManagementState\>\> } (für zwlr\_output\_manager\_v1 Global).  
    * WlrOutputHeadGlobalData { output\_device: Weak\<Mutex\<OutputDevice\>\>, output\_manager\_state: Weak\<Mutex\<WlrOutputManagementState\>\> } (für zwlr\_output\_head\_v1 Ressourcen).  
    * WlrOutputModeGlobalData { mode: smithay::output::Mode } (für zwlr\_output\_mode\_v1 Ressourcen).  
    * WlrOutputConfigurationUserData { id: wayland\_server::backend::ObjectId, output\_manager\_state: Weak\<Mutex\<WlrOutputManagementState\>\> } (für zwlr\_output\_configuration\_v1 Ressourcen).  
    * WlrOutputConfigurationHeadUserData { output\_device\_name: String, config\_request\_id: wayland\_server::backend::ObjectId, output\_manager\_state: Weak\<Mutex\<WlrOutputManagementState\>\> } (für zwlr\_output\_configuration\_head\_v1 Ressourcen).  
  * **Smithay Integration**: Der globale Compositor-Zustand (YourCompositorState) implementiert:  
    * GlobalDispatch\<ZwlrOutputManagerV1, WlrOutputManagerGlobalData\>  
    * Dispatch\<ZwlrOutputManagerV1, WlrOutputManagerGlobalData, YourCompositorState\>  
    * Dispatch\<ZwlrOutputHeadV1, WlrOutputHeadGlobalData, YourCompositorState\>  
    * Dispatch\<ZwlrOutputModeV1, WlrOutputModeGlobalData, YourCompositorState\>  
    * Dispatch\<ZwlrOutputConfigurationV1, WlrOutputConfigurationUserData, YourCompositorState\>  
    * Dispatch\<ZwlrOutputConfigurationHeadV1, WlrOutputConfigurationHeadUserData, YourCompositorState\>  
    * smithay::delegate\_dispatch\!(YourCompositorState:);  
  * **Initialisierung**:  
    * Ein WlrOutputManagementState wird im globalen Compositor-Zustand erstellt.  
    * Ein zwlr\_output\_manager\_v1-Global wird mit display\_handle.create\_global() registriert.  
  * **Anfragebehandlung für zwlr\_output\_manager\_v1 (manager\_handler.rs)**:  
    * bind: Sendet den aktuellen Zustand aller Outputs (Heads und deren Modi) an den Client über die head, mode, done, finished Events des Managers.20  
    * destroy: Standard.  
    * create\_configuration(config\_resource: ZwlrOutputConfigurationV1, serial: u32):  
      1. Erstellt ein neues OutputConfigurationRequest mit dem gegebenen serial und der Client-ID. Speichert es in WlrOutputManagementState::configurations.  
      2. Sendet den aktuellen Zustand aller OutputDevices (als zwlr\_output\_head\_v1-Events: name, description, physical\_size, enabled, current\_mode, position, transform, scale, make, model, serial\_number, adaptive\_sync) und deren unterstützte Modi (als zwlr\_output\_mode\_v1-Events: size, refresh, preferred) an das neue config\_resource.  
      3. Jeder Kopf und Modus erhält eine eigene Ressource (ZwlrOutputHeadV1, ZwlrOutputModeV1), die mit den entsprechenden Daten initialisiert wird.  
      4. Beendet die Sequenz mit zwlr\_output\_head\_v1.done() für jeden Kopf und zwlr\_output\_manager\_v1.done(current\_serial) für den Manager selbst. Der serial-Parameter ist hierbei zentral: Die gesendeten Kopf- und Modusinformationen müssen dem Zustand entsprechen, den der Client mit diesem serial erwartet.  
  * **Anfragebehandlung für zwlr\_output\_configuration\_head\_v1 (configuration\_handler.rs)**:  
    * destroy: Standard.  
    * enable(), disable(): Aktualisiert enabled im HeadChangeRequest des zugehörigen OutputConfigurationRequest.  
    * set\_mode(mode: \&ZwlrOutputModeV1): Speichert den Modus (aus WlrOutputModeGlobalData) im HeadChangeRequest.  
    * set\_custom\_mode(...), set\_position(...), set\_transform(...), set\_scale(...), set\_adaptive\_sync(...): Speichern die angeforderten Änderungen im HeadChangeRequest.  
  * **Anfragebehandlung für zwlr\_output\_configuration\_v1 (configuration\_handler.rs)**:  
    * destroy: Verwirft die Konfigurationsanfrage und entfernt sie aus WlrOutputManagementState::configurations.  
    * apply():  
      1. Überprüft, ob der serial der Konfiguration noch aktuell ist (d.h. ob sich der globale Output-Zustand seit Erstellung der Konfiguration geändert hat, z.B. durch Hotplug). Wenn nicht, sendet cancelled und zerstört die Konfiguration.  
      2. Versucht, alle pending\_changes im OutputConfigurationRequest auf die entsprechenden OutputDevice-Instanzen (via OutputManager) anzuwenden.  
      3. Wenn alle Änderungen erfolgreich sind: Sendet succeeded an den Client und zerstört die Konfiguration. Aktualisiert den globalen OutputManager-Serial und sendet done an alle zwlr\_output\_manager\_v1-Instanzen.  
      4. Wenn Fehler auftreten: Sendet failed an den Client, macht Änderungen rückgängig (falls möglich) und zerstört die Konfiguration.  
    * test(): Ähnlich wie apply(), aber ohne die Änderungen tatsächlich anzuwenden. Validiert die Konfiguration.  
  * **Event-Generierung**: Der OutputManager (oder eine dedizierte Komponente) muss bei Änderungen am Output-Zustand (Hotplug, Modusänderung durch andere Quellen) die head, mode, done, finished Events an alle gebundenen zwlr\_output\_manager\_v1-Instanzen senden und den globalen Serial erhöhen.  
* **Implementierungsschritte**:  
  1. Definiere die Zustands- und UserData-Strukturen.  
  2. Implementiere GlobalDispatch für ZwlrOutputManagerV1.  
  3. Implementiere Dispatch für alle relevanten Protokollobjekte.  
  4. Die apply/test-Logik muss sorgfältig implementiert werden, um Atomarität (oder zumindest Fehlererkennung und \-behandlung) und korrekte Serial-Handhabung sicherzustellen.  
  5. Die Benachrichtigung über Änderungen im globalen Output-Zustand an alle Manager-Instanzen ist entscheidend. Dies kann über einen Listener-Mechanismus oder Callbacks im OutputManager erfolgen.  
* **Tabelle: WLR-Output-Management Protokoll Interaktionen**

| Client Aktion | Server Reaktion (Requests an Client, Events an Client) | Betroffene Zustände (Server) |
| :---- | :---- | :---- |
| Bindet an zwlr\_output\_manager\_v1 | Für jeden Output: head (mit Name, Desc, etc.), mode (für jeden Modus), enabled, current\_mode, position, etc. done (pro Kopf). Dann done(serial) vom Manager. | WlrOutputManagementState (neuer Client registriert), global\_serial |
| create\_configuration(serial) | Erstellt zwlr\_output\_configuration\_v1. Sendet aktuellen Output-Zustand (Heads, Modi) an diese Konfigurationsinstanz. | WlrOutputManagementState::configurations (neue Anfrage hinzugefügt) |
| zwlr\_output\_configuration\_head\_v1.set\_X(...) | Keine direkten Events an Client. | OutputConfigurationRequest::pending\_changes aktualisiert. |
| zwlr\_output\_configuration\_v1.apply() | Wenn serial aktuell & Konfig gültig: succeeded. Dann head/mode/done Events vom Manager mit neuem globalen Serial. Wenn serial veraltet: cancelled. Wenn Konfig ungültig: failed. | OutputManager::outputs (Zustand der OutputDevices geändert), global\_serial erhöht. WlrOutputManagementState::configurations (Anfrage entfernt). |
| zwlr\_output\_configuration\_v1.test() | Wenn serial aktuell & Konfig gültig: succeeded. Wenn serial veraltet: cancelled. Wenn Konfig ungültig: failed. | WlrOutputManagementState::configurations (Anfrage entfernt). Keine Zustandsänderung an Outputs. |
| Hotplug (z.B. Monitor angeschlossen/abgezogen) | An alle zwlr\_output\_manager\_v1: head (für neuen Output) / finished (für entfernten Output), done(new\_serial). | OutputManager::outputs aktualisiert, global\_serial erhöht. Laufende Konfigurationen werden bei nächstem apply/test als cancelled markiert. |

Diese Tabelle verdeutlicht die komplexen Interaktionsflüsse und die Bedeutung der Serial-Nummern für die Zustandssynchronisation zwischen Client und Compositor.

### **6\. Submodul: system::outputs::wlr\_output\_power\_management\_handler – Implementierung des wlr-output-power-management-unstable-v1 Protokolls**

Dieses Submodul implementiert die serverseitige Logik für das wlr-output-power-management-unstable-v1-Protokoll, das es Clients erlaubt, den Energiezustand von Monitoren zu steuern (z.B. An/Aus).22

* **Dateien**: system/outputs/wlr\_output\_power\_management/mod.rs, system/outputs/wlr\_output\_power\_management/manager\_handler.rs, system/outputs/wlr\_output\_power\_management/power\_control\_handler.rs  
* **Protokoll-Objekte**: zwlr\_output\_power\_manager\_v1, zwlr\_output\_power\_v1.  
* **Spezifikation**:  
  * **Struktur**: WlrOutputPowerManagementState (im globalen Compositor-Zustand)  
    * Felder:  
      * output\_manager: Arc\<Mutex\<OutputManager\>\>  
      * active\_controllers: HashMap\<String /\* OutputDevice name \*/, wayland\_server::Resource\<ZwlrOutputPowerV1\>\>: Speichert den aktiven Controller pro Output-Namen.  
  * **User Data Structs**:  
    * WlrOutputPowerManagerGlobalData { output\_power\_manager\_state: Weak\<Mutex\<WlrOutputPowerManagementState\>\> }.  
    * WlrOutputPowerControlUserData { output\_device\_name: String, output\_power\_manager\_state: Weak\<Mutex\<WlrOutputPowerManagementState\>\> }.  
  * **Smithay Integration**: Der globale Compositor-Zustand (YourCompositorState) implementiert:  
    * GlobalDispatch\<ZwlrOutputPowerManagerV1, WlrOutputPowerManagerGlobalData\>  
    * Dispatch\<ZwlrOutputPowerManagerV1, WlrOutputPowerManagerGlobalData, YourCompositorState\>  
    * Dispatch\<ZwlrOutputPowerV1, WlrOutputPowerControlUserData, YourCompositorState\>  
    * smithay::delegate\_dispatch\!(YourCompositorState:);  
  * **Initialisierung**: Ein WlrOutputPowerManagementState wird im globalen Zustand erstellt. Ein zwlr\_output\_power\_manager\_v1-Global wird registriert.  
  * **Anfragebehandlung für zwlr\_output\_power\_manager\_v1 (manager\_handler.rs)**:  
    * bind: Standard.  
    * destroy: Standard.  
    * get\_output\_power(output\_power\_resource: ZwlrOutputPowerV1, output: \&WlOutput):  
      1. Ermittelt den Namen des OutputDevice, das zum WlOutput gehört (z.B. über UserData des WlOutput).  
      2. Prüft, ob bereits ein aktiver Controller für diesen Output-Namen in active\_controllers existiert.  
      3. Wenn ja: Sendet failed an output\_power\_resource und zerstört es. Es darf nur einen Controller pro Output geben.22  
      4. Wenn nein: Speichert output\_power\_resource in active\_controllers für den Output-Namen. Sendet den aktuellen DPMS-Zustand des OutputDevice als initiales mode-Event an output\_power\_resource.  
  * **Anfragebehandlung für zwlr\_output\_power\_v1 (power\_control\_handler.rs)**:  
    * destroy: Entfernt den Controller aus active\_controllers.  
    * set\_mode(mode: u32):  
      1. Ermittelt das zugehörige OutputDevice anhand des in WlrOutputPowerControlUserData gespeicherten Namens.  
      2. Konvertiert mode (0 für Off, 1 für On 22) in den entsprechenden DpmsState.  
      3. Ruft output\_device.lock().unwrap().set\_dpms\_state(new\_dpms\_state) auf.  
      4. Wenn erfolgreich, sendet mode(mode) an den Client.  
      5. Wenn der Output den Modus nicht unterstützt oder ein anderer Fehler auftritt, sendet failed.  
  * **Event-Generierung**:  
    * Wenn sich der DPMS-Zustand eines OutputDevice ändert (auch extern, z.B. durch Inaktivität), muss der WlrOutputPowerManagementState dies erkennen und das mode-Event an den ggf. existierenden aktiven Controller für diesen Output senden.  
    * Wenn ein OutputDevice entfernt wird, muss ein failed-Event an den zugehörigen Controller gesendet und dieser zerstört werden.  
* **Implementierungsschritte**:  
  1. Definiere die Zustands- und UserData-Strukturen.  
  2. Implementiere GlobalDispatch für ZwlrOutputPowerManagerV1.  
  3. Implementiere Dispatch für ZwlrOutputPowerManagerV1 und ZwlrOutputPowerV1.  
  4. Die set\_mode-Anfrage muss mit der tatsächlichen Hardware-Steuerung (z.B. DRM DPMS über das OutputDevice) interagieren.  
  5. Sicherstellen, dass Änderungen des Power-Modus das mode-Event auslösen und die Exklusivität der Controller gewahrt bleibt.

### **7\. Submodul: system::outputs::xdg\_output\_handler – Implementierung des xdg-output-unstable-v1 Protokolls**

Dieses Submodul implementiert die serverseitige Logik für das xdg-output-unstable-v1-Protokoll, das Clients detailliertere Informationen über die logische Geometrie von Outputs liefert.

* **Datei**: system/outputs/xdg\_output\_handler.rs (kann auch als Integration in wl\_output\_handler oder manager erfolgen).  
* **Protokoll-Objekte**: zxdg\_output\_manager\_v1, zxdg\_output\_v1.  
* **Spezifikation**:  
  * **Smithay Integration**:  
    * Der globale Compositor-Zustand (YourCompositorState) implementiert:  
      * GlobalDispatch\<ZxdgOutputManagerV1, XdgOutputManagerGlobalData\>  
      * Dispatch\<ZxdgOutputManagerV1, XdgOutputManagerGlobalData, YourCompositorState\>  
      * Dispatch\<ZxdgOutputV1, XdgOutputGlobalData, YourCompositorState\>  
      * smithay::delegate\_dispatch\!(YourCompositorState:);  
    * XdgOutputManagerGlobalData { output\_manager: Weak\<Mutex\<OutputManager\>\> }.  
    * XdgOutputGlobalData { output\_device: Weak\<Mutex\<OutputDevice\>\> }.  
    * Die Erstellung der zxdg\_output\_manager\_v1-Globals und zxdg\_output\_v1-Ressourcen kann über Smithay's OutputManagerState::new\_with\_xdg\_output() 15 erfolgen, das automatisch ein zxdg\_output\_v1-Global erstellt, wenn ein wl\_output-Global erstellt wird. Alternativ kann dies manuell im OutputManager::output\_device\_created\_notifications geschehen.  
  * **Initialisierung**: Ein zxdg\_output\_manager\_v1-Global wird registriert.  
  * **Anfragebehandlung für zxdg\_output\_manager\_v1**:  
    * bind: Standard.  
    * destroy: Standard.  
    * get\_xdg\_output(xdg\_output\_resource: ZxdgOutputV1, output: \&WlOutput):  
      1. Ermittelt das OutputDevice, das zum WlOutput gehört.  
      2. Initialisiert xdg\_output\_resource mit den aktuellen logischen Daten des OutputDevice (Position, Größe) und sendet logical\_position, logical\_size, name, description, gefolgt von done.  
  * **Anfragebehandlung für zxdg\_output\_v1**:  
    * destroy: Standard.  
  * **Event-Generierung**:  
    * Wenn sich die logische Position, Größe, der Name oder die Beschreibung eines OutputDevice ändern, müssen die entsprechenden Events (logical\_position, logical\_size, name, description) an alle gebundenen zxdg\_output\_v1-Instanzen gesendet werden, gefolgt von einem done-Event. Dies wird typischerweise von Smithay gehandhabt, wenn Output::change\_current\_state() aufgerufen wird.  
* **Implementierungsschritte**:  
  1. Definiere die UserData-Strukturen.  
  2. Implementiere GlobalDispatch für ZxdgOutputManagerV1.  
  3. Implementiere Dispatch für ZxdgOutputManagerV1 und ZxdgOutputV1.  
  4. Sicherstellen, dass Änderungen an den relevanten OutputDevice-Eigenschaften (Position, Größe, Name, Beschreibung) die korrekten Events auslösen. Smithay's Output-Struktur sollte dies bei korrekter Verwendung von change\_current\_state bereits gewährleisten.

## **III. Implementierungsleitfaden (Implementation Guide)**

A. Allgemeine Hinweise: Die Implementierung aller hier spezifizierten Module und Submodule muss streng den in der technischen Gesamtspezifikation definierten Entwicklungsrichtlinien folgen. Dies umfasst insbesondere:  
\* Coding Style & Formatierung: Verbindliche Nutzung von rustfmt mit Standardkonfiguration und Einhaltung der Rust API Guidelines \[User Query IV.4.1\].  
\* API-Design: Befolgung der Rust API Guidelines Checklist für konsistente und idiomatische Schnittstellen \[User Query IV.4.2\].  
\* Fehlerbehandlung: Konsequente Verwendung des thiserror-Crates zur Definition spezifischer Fehler-Enums pro Modul (DBusError, OutputError) \[User Query IV.4.3\].  
\* Logging & Tracing: Einsatz des tracing-Crate-Frameworks für strukturiertes, kontextbezogenes Logging und Tracing von Operationen \[User Query IV.4.4\].  
B. Detaillierte Schritte pro Sub-Modul: Die oben in den Spezifikationen genannten Implementierungsschritte für jedes Submodul sind als detaillierte Arbeitsanweisungen zu verstehen. Dies beinhaltet:  
\* Strukturen und Enums: Exakte Definition aller Felder mit Typen und Sichtbarkeitsmodifikatoren (pub, pub(crate), private).  
\* Methodenimplementierung: Vollständige Implementierung aller öffentlichen Methoden gemäß den Signaturen. Vor- und Nachbedingungen sind zu beachten. Interne Logik muss robust und fehlerresistent sein.  
\* D-Bus Clients: Die generierten zbus-Proxies sind die primäre Schnittstelle zu den D-Bus-Diensten. Die Client-Wrapper-Klassen (UPowerClient, LogindClient, etc.) müssen die Rohdaten der Proxies in die anwendungsfreundlichen Typen aus den \*\_types.rs-Dateien konvertieren und Fehlerbehandlung durchführen. Signal-Handler müssen asynchron implementiert werden und die empfangenen Daten korrekt parsen.  
\* Wayland Protocol Handler: Die Implementierung der Dispatch- und GlobalDispatch-Traits für die Output-Protokolle erfordert sorgfältiges Management des Zustands, der oft in UserData-Strukturen der Wayland-Ressourcen gespeichert wird. Das korrekte Senden von Events an die Clients als Reaktion auf Anfragen oder Zustandsänderungen ist entscheidend.  
\* Interaktion der Submodule:  
\* Der OutputManager ist die zentrale Verwaltungsinstanz für OutputDevice-Objekte.  
\* Die Wayland-Protokoll-Handler für Outputs (wl\_output\_handler, wlr\_output\_management\_handler, etc.) greifen auf den OutputManager und die darin enthaltenen OutputDevice-Instanzen zu, um Informationen abzufragen oder Konfigurationen anzuwenden.  
\* Beispielsweise wird der wlr\_output\_management\_handler bei einer apply()-Anfrage die gewünschten Änderungen an die entsprechenden OutputDevice-Instanzen im OutputManager weiterleiten. Diese wiederum nutzen ihr internes smithay::output::Output-Objekt, um die Änderungen wirksam zu machen, was dann die notwendigen wl\_output- und xdg\_output-Events auslöst.  
\* Änderungen durch Hotplug-Events, die vom OutputManager verarbeitet werden, müssen Benachrichtigungen an die wlr-output-management und wlr-output-power-management Handler auslösen, damit diese ihre Clients über die geänderte Output-Konfiguration informieren können (z.B. Senden von head und done Events).

## **IV. Anhang (Appendix)**

### **A. D-Bus Schnittstellenübersicht**

Die folgende Tabelle fasst die wichtigsten D-Bus-Dienste zusammen, mit denen die Systemschicht interagiert:  
**Tabelle: D-Bus Service Details**

| Dienstname | Objektpfad (Manager/Service) | Interface (Haupt) | Relevante Methoden/Signale/Properties (Beispiele) | Korrespondierendes system::dbus Submodul |
| :---- | :---- | :---- | :---- | :---- |
| UPower | /org/freedesktop/UPower | org.freedesktop.UPower | EnumerateDevices(), GetDisplayDevice(), OnBattery (Prop), DeviceAdded (Sig), DeviceRemoved (Sig). Für Devices (org.freedesktop.UPower.Device): Type, State, Percentage, TimeToEmpty, TimeToFull (Props).7 | upower\_client |
| systemd-logind | /org/freedesktop/login1 | org.freedesktop.login1.Manager | ListSessions(), LockSession(), UnlockSession(), PrepareForSleep (Sig), SessionNew (Sig), SessionRemoved (Sig). Für Sessions (org.freedesktop.login1.Session): Lock() (Sig), Unlock() (Sig), Active (Prop).10 | logind\_client |
| NetworkManager | /org/freedesktop/NetworkManager | org.freedesktop.NetworkManager | GetDevices(), GetActiveConnections(), State (Prop), Connectivity (Prop), StateChanged (Sig), DeviceAdded (Sig). Für Devices (org.freedesktop.NetworkManager.Device): DeviceType, State (Props). Für Active Connections (org.freedesktop.NetworkManager.Connection.Active): Type, State, Default (Props). | networkmanager\_client |
| Freedesktop Secret Service | /org/freedesktop/secrets | org.freedesktop.Secret.Service | OpenSession(), CreateCollection(), SearchItems(), Unlock(), GetSecrets(), CollectionCreated (Sig). Für Collections (org.freedesktop.Secret.Collection): CreateItem(), Label (Prop). Für Items (org.freedesktop.Secret.Item): GetSecret(), SetSecret(), Label (Prop). Für Prompts (org.freedesktop.Secret.Prompt): Prompt(), Completed (Sig).13 | secrets\_client |
| PolicyKit | /org/freedesktop/PolicyKit1/Authority | org.freedesktop.PolicyKit1.Authority | CheckAuthorization() \[User Query III.11\]. | policykit\_client |

Diese Übersicht dient als Referenz für die spezifischen D-Bus-Interaktionen und deren Implementierungsort innerhalb des system::dbus-Moduls. Sie erleichtert das Verständnis der Abhängigkeiten von externen Systemdiensten.

### **B. Wayland Output Protokollübersicht**

Die folgende Tabelle gibt einen Überblick über die im system::outputs-Modul implementierten Wayland-Protokolle und deren Handler:  
**Tabelle: Wayland Output Protocol Handler**

| Protokollname | Hauptinterface(s) (Server) | Verantwortlicher Handler (Trait/Struktur im Code) | Wichtige Requests (vom Client an Server) | Wichtige Events (vom Server an Client) | Korrespondierendes system::outputs Submodul |
| :---- | :---- | :---- | :---- | :---- | :---- |
| Wayland Core Output | wl\_output | YourCompositorState (implementiert smithay::wayland::output::OutputHandler) | release | geometry, mode, done, scale 15 | wl\_output\_handler (Integration) |
| XDG Output | zxdg\_output\_manager\_v1, zxdg\_output\_v1 | YourCompositorState (implementiert GlobalDispatch und Dispatch für XDG Output Interfaces) | destroy (manager/output), get\_xdg\_output (manager) | logical\_position, logical\_size, done, name, description (output) | xdg\_output\_handler |
| WLR Output Management | zwlr\_output\_manager\_v1, zwlr\_output\_head\_v1, zwlr\_output\_mode\_v1, zwlr\_output\_configuration\_v1, zwlr\_output\_configuration\_head\_v1 | WlrOutputManagementState, YourCompositorState (implementiert relevante Dispatch-Traits) | create\_configuration (manager), apply, test (configuration), enable\_head, set\_mode (config\_head) 20 | head, done (manager), name, mode, current\_mode (head), succeeded, failed, cancelled (configuration) 20 | wlr\_output\_management\_handler |
| WLR Output Power Management | zwlr\_output\_power\_manager\_v1, zwlr\_output\_power\_v1 | WlrOutputPowerManagementState, YourCompositorState (implementiert relevante Dispatch-Traits) | get\_output\_power (manager), set\_mode (power\_control) 22 | mode, failed (power\_control) 22 | wlr\_output\_power\_management\_handler |

Diese Tabelle dient als Referenz für die implementierten Wayland-Protokolle im Bereich der Output-Verwaltung und zeigt die jeweiligen Zuständigkeiten der Handler-Komponenten auf. Sie ist nützlich, um die Struktur und die Verantwortlichkeiten innerhalb des system::outputs-Moduls nachzuvollziehen.

# **Implementierungsleitfaden Systemschicht (Teil 3/4)**

## **I. Einleitung zu den Spezifikationen der Systemschicht (Teil 3/4)**

### **Überblick**

Die Systemschicht, wie in der technischen Gesamtspezifikation dargelegt, bildet das kritische Bindeglied zwischen der abstrakten Logik der Domänenschicht, der Präsentationslogik der Benutzeroberflächenschicht und den konkreten Funktionalitäten des zugrundeliegenden Linux-Betriebssystems sowie der Hardware. Ihre Hauptaufgabe besteht darin, die "Mechanik" der Desktop-Umgebung zu implementieren, indem sie übergeordnete Richtlinien und Benutzerinteraktionen in handfeste Systemaktionen übersetzt. Dieser Prozess erfordert eine präzise und robuste Interaktion mit einer Vielzahl externer Komponenten, darunter Wayland-Protokolle, die über Bibliotheken wie Smithay gehandhabt werden, D-Bus-Systemdienste wie UPower und Logind sowie potenziell direkte Hardware-Interaktionen, beispielsweise über das Direct Rendering Manager (DRM)-Subsystem.  
Die Stabilität und Reaktionsfähigkeit der gesamten Desktop-Umgebung hängt maßgeblich von der Zuverlässigkeit der Systemschicht ab. Da diese Schicht intensiv mit externen, oft asynchronen Systemen kommuniziert, können Unvorhersehbarkeiten wie Latenzen, Fehler oder unerwartete Zustandsänderungen auftreten. Eine unzureichend robuste Systemschicht, die beispielsweise bei einem langsamen D-Bus-Aufruf blockiert, bei einem unerwarteten Wayland-Ereignis in Panik gerät oder den Ausfall eines Dienstes nicht korrekt behandelt, würde die Stabilität der gesamten Desktop-Umgebung direkt gefährden. Daher muss das Design jedes Moduls der Systemschicht Resilienz als oberste Priorität behandeln. Dies bedeutet konkret den Einsatz asynchroner Operationen für alle potenziell blockierenden E/A-Vorgänge, insbesondere bei D-Bus-Aufrufen (unterstützt durch zbus) und der Wayland-Ereignisverarbeitung. Ein umfassendes, typisiertes Fehlermanagement pro Modul (mittels thiserror) ist unerlässlich, um höheren Schichten eine angemessene Reaktion auf Fehlerzustände zu ermöglichen. Dies schließt die Behandlung von D-Bus-Fehlern, Wayland-Protokollfehlern und internen Logikfehlern ein. Wo immer möglich, sollten Interaktionen mit externen Diensten Timeouts beinhalten, und Fallback-Mechanismen oder eine graceful degradation der Funktionalität müssen in Betracht gezogen werden, falls ein Dienst nicht verfügbar oder nicht reaktionsfähig ist. Eine sorgfältige Zustandssynchronisation ist ebenfalls von entscheidender Bedeutung, insbesondere wenn der Zustand von externen Komponenten abgeleitet wird oder diese beeinflusst. Mechanismen zur Erkennung und Behebung von Zustandsdiskrepanzen, wie z.B. die Verwendung von Serialnummern in Wayland-Protokollen, müssen akribisch implementiert werden.

### **Zweck dieses Dokuments**

Dieses Dokument, "Teil 3/4" der Spezifikationen für die Systemschicht, legt vier detaillierte, ultrafeingranulare Implementierungspläne für Schlüsselmodule dieser Schicht vor. Ziel ist es, den Entwicklern so präzise Vorgaben an die Hand zu geben, dass eine direkte Implementierung ohne weitere architektonische oder tiefgreifende Designentscheidungen möglich wird.

### **Beziehung zur Gesamtarchitektur**

Die hier spezifizierten Module – system::outputs::output\_manager, system::outputs::power\_manager, system::dbus::upower\_interface und system::dbus::logind\_interface – sind fundamental für die Verwaltung der Display-Hardware und die Integration mit essenziellen Systemdiensten. Sie bauen auf den in der Kernschicht definierten grundlegenden Datentypen und Dienstprogrammen auf und stellen notwendige Funktionalitäten und Ereignisse für die Domänen- und Benutzeroberflächenschicht bereit.

## **II. Ultra-Feinspezifikation: system::outputs::output\_manager (Wayland Output Konfiguration)**

### **A. Modulübersicht und Zweck**

* **Verantwortlichkeit:** Dieses Modul implementiert die serverseitige Logik für das Wayland-Protokoll wlr-output-management-unstable-v1. Seine primäre Funktion besteht darin, Wayland-Clients – typischerweise Display-Konfigurationswerkzeuge – zu ermöglichen, verfügbare Display-Ausgänge zu erkennen, deren Fähigkeiten abzufragen (Modi, unterstützte Auflösungen, Bildwiederholraten, physische Dimensionen, Skalierung, Transformation) und atomare Änderungen an ihrer Konfiguration anzufordern (z.B. Setzen eines neuen Modus, Positionierung, Aktivieren/Deaktivieren eines Ausgangs).  
* **Interaktion:** Es interagiert mit der internen Repräsentation von Display-Ausgängen des Compositors, die wahrscheinlich durch Smithays Output- und OutputManagerState-Strukturen verwaltet werden.1 Über dieses Protokoll angeforderte Änderungen werden in Operationen auf diesen internen Smithay-Objekten übersetzt, die wiederum mit dem DRM-Backend (Direct Rendering Manager) interagieren können, um Hardware-Änderungen zu bewirken.  
* **Schlüsselprotokollelemente:** zwlr\_output\_manager\_v1, zwlr\_output\_head\_v1, zwlr\_output\_mode\_v1, zwlr\_output\_configuration\_v1.  
* **Relevante Referenzmaterialien & Analyse:**  
  * 2 (Protokollübersicht): Liefert die XML-Definition und detailliert Anfragen wie create\_configuration, apply, test sowie Ereignisse wie head, done, succeeded, failed. Dies ist die primäre Quelle für die Struktur der Protokollnachrichten.  
  * 1 (Smithay Output, OutputManagerState, OutputHandler): Diese Smithay-Komponenten sind fundamental. Output repräsentiert ein physisches Display im Compositor. OutputManagerState hilft bei der Verwaltung von wl\_output-Globalen. Der OutputHandler (oder ein spezifischerer Handler für dieses Protokoll) wird implementiert, um Client-Anfragen zu verarbeiten. Dieses Modul wird im Wesentlichen eine Brücke zwischen dem wlr-output-management-Protokoll und diesen Smithay-Abstraktionen schlagen.  
  * 26 (Anvil DRM Output Management): Zeigt ein praktisches Beispiel, wie Smithays Output basierend auf DRM-Geräteinformationen erstellt und konfiguriert wird. Während dieses Modul die Wayland-Protokollseite behandelt, werden die zugrundeliegenden Mechanismen zur Anwendung von Änderungen denen im DRM-Backend von Anvil ähneln.  
  * 1 (Smithay OutputHandler und wlr-output-management): Bestärken die Verbindung zwischen Smithays Output-Handling und dem wlr-output-management-Protokoll.

### **B. Entwicklungs-Submodule & Dateien**

* **1\. system::outputs::output\_manager::manager\_global**  
  * Dateien: system/outputs/output\_manager/manager\_global.rs  
  * Verantwortlichkeiten: Verwaltet den Lebenszyklus des zwlr\_output\_manager\_v1-Globals. Behandelt Bindeanfragen von Clients für dieses Global. Leitet Client-Anfragen zur Erstellung neuer zwlr\_output\_configuration\_v1-Objekte weiter.  
* **2\. system::outputs::output\_manager::head\_handler**  
  * Dateien: system/outputs/output\_manager/head\_handler.rs  
  * Verantwortlichkeiten: Verwaltet zwlr\_output\_head\_v1-Objekte. Sendet name, description, physical\_size, mode, enabled, current\_mode, position, transform, scale, finished, make, model, serial\_number-Ereignisse an den Client, basierend auf dem Zustand des entsprechenden smithay::output::Output.  
* **3\. system::outputs::output\_manager::mode\_handler**  
  * Dateien: system/outputs/output\_manager/mode\_handler.rs  
  * Verantwortlichkeiten: Verwaltet zwlr\_output\_mode\_v1-Objekte. Sendet size, refresh, preferred, finished-Ereignisse basierend auf den für ein smithay::output::Output verfügbaren Modi.  
* **4\. system::outputs::output\_manager::configuration\_handler**  
  * Dateien: system/outputs/output\_manager/configuration\_handler.rs  
  * Verantwortlichkeiten: Verwaltet zwlr\_output\_configuration\_v1- und zwlr\_output\_configuration\_head\_v1-Objekte. Speichert vom Client angeforderte, ausstehende Änderungen. Implementiert die Logik für test- und apply-Anfragen, interagiert mit dem Kern-Output-Zustand des Compositors und potenziell dem DRM-Backend. Sendet succeeded-, failed- oder cancelled-Ereignisse.  
* **5\. system::outputs::output\_manager::types**  
  * Dateien: system/outputs/output\_manager/types.rs  
  * Verantwortlichkeiten: Definiert Rust-Strukturen und \-Enums, die Protokolltypen widerspiegeln oder internen Zustand für die Verwaltung von Konfigurationen repräsentieren (z.B. PendingHeadConfiguration, AppliedConfigurationAttempt).  
* **6\. system::outputs::output\_manager::errors**  
  * Dateien: system/outputs/output\_manager/errors.rs  
  * Verantwortlichkeiten: Definiert das OutputManagerError-Enum mittels thiserror für Fehler, die spezifisch für die Operationen dieses Moduls sind.

### **C. Schlüsseldatenstrukturen**

* OutputManagerModuleState:  
  * output\_manager\_global: Option\<GlobalId\> (Smithay-Global für zwlr\_output\_manager\_v1)  
  * active\_configurations: HashMap\<ObjectId, Arc\<Mutex\<PendingOutputConfiguration\>\>\> (Verfolgt aktive zwlr\_output\_configuration\_v1-Instanzen)  
  * compositor\_output\_serial: u32 (Wird inkrementiert, wenn sich das Output-Layout des Compositors ändert)  
* PendingOutputConfiguration: Repräsentiert eine vom Client angeforderte Konfiguration über zwlr\_output\_configuration\_v1.  
  * serial: u32 (Vom Client bei Erstellung bereitgestellte Serialnummer)  
  * head\_configs: HashMap\<WlOutput, HeadConfigChange\> (Mappt wl\_output auf gewünschte Änderungen)  
  * is\_applied\_or\_tested: bool  
* HeadConfigChange:  
  * target\_output\_name: String (Interner Name/ID des Output-Objekts des Compositors)  
  * enabled: Option\<bool\>  
  * mode: Option\<OutputModeRequest\> (Könnte spezifische Mode-ID oder benutzerdefinierte Modusparameter sein)  
  * position: Option\<Point\<i32, Logical\>\>  
  * transform: Option\<wl\_output::Transform\>  
  * scale: Option\<f64\>  
* OutputModeRequest: Enum für ExistingMode(ModeId) oder CustomMode { width: i32, height: i32, refresh: i32 }.

**Tabelle: OutputManager-Datenstrukturen**

| Struct/Enum Name | Felder (Name, Rust-Typ, nullable, Mutabilität) | Beschreibung | Korrespondierendes Wayland-Protokollelement/Konzept |
| :---- | :---- | :---- | :---- |
| OutputManagerModuleState | output\_manager\_global: Option\<GlobalId\> (intern, veränderlich) \<br\> active\_configurations: HashMap\<ObjectId, Arc\<Mutex\<PendingOutputConfiguration\>\>\> (intern, veränderlich) \<br\> compositor\_output\_serial: u32 (intern, veränderlich) | Hauptzustand des Moduls, verwaltet das Global und aktive Konfigurationen. | zwlr\_output\_manager\_v1 |
| PendingOutputConfiguration | serial: u32 (intern, unveränderlich nach Erstellung) \<br\> head\_configs: HashMap\<WlOutput, HeadConfigChange\> (intern, veränderlich durch Client-Requests) \<br\> is\_applied\_or\_tested: bool (intern, veränderlich) | Speichert eine vom Client initiierte, aber noch nicht angewendete oder getestete Konfiguration. | zwlr\_output\_configuration\_v1 |
| HeadConfigChange | target\_output\_name: String (intern) \<br\> enabled: Option\<bool\> (optional) \<br\> mode: Option\<OutputModeRequest\> (optional) \<br\> position: Option\<Point\<i32, Logical\>\> (optional) \<br\> transform: Option\<wl\_output::Transform\> (optional) \<br\> scale: Option\<f64\> (optional) | Repräsentiert die gewünschten Änderungen für einen einzelnen Output (head). | zwlr\_output\_configuration\_head\_v1-Anfragen |
| OutputModeRequest | ExistingMode(ModeId) \<br\> CustomMode { width: i32, height: i32, refresh: i32 } | Unterscheidet zwischen der Auswahl eines existierenden Modus oder der Definition eines benutzerdefinierten Modus. | zwlr\_output\_configuration\_head\_v1.set\_mode, zwlr\_output\_configuration\_head\_v1.set\_custom\_mode |

Diese Datenstrukturen sind fundamental, um den Zustand der von Clients initiierten Output-Konfigurationen zu verfolgen. Die OutputManagerModuleState dient als zentraler Punkt für die Verwaltung des globalen zwlr\_output\_manager\_v1 und der damit verbundenen Konfigurationsobjekte. Jede PendingOutputConfiguration kapselt die Gesamtheit der Änderungen, die ein Client für eine Gruppe von Outputs vornehmen möchte, bevor diese getestet oder angewendet werden. Die compositor\_output\_serial ist entscheidend für die Synchronisation des Client-Wissens mit dem tatsächlichen Zustand der Outputs im Compositor.

### **D. Protokollbehandlung: zwlr\_output\_manager\_v1 (Interface Version: 3 2)**

* **Smithay Handler:** Die Zustandsverwaltung und Anforderungsbehandlung für das zwlr\_output\_manager\_v1-Global wird durch Implementierung der Traits GlobalDispatch\<ZwlrOutputManagerV1, GlobalData, YourCompositorState\> und Dispatch\<ZwlrOutputManagerV1, UserData, YourCompositorState\> für die OutputManagerModuleState-Struktur realisiert. GlobalData könnte hier leer sein oder minimale globale Informationen enthalten, während UserData für gebundene Manager-Instanzen spezifisch sein kann, falls erforderlich (oftmals ist für Singleton-Manager-Globale keine komplexe UserData nötig).  
* **Globalerstellung:** Das zwlr\_output\_manager\_v1-Global wird einmalig beim Start des Compositors oder bei der Initialisierung dieses Moduls mittels DisplayHandle::create\_global erstellt und dem Wayland-Display hinzugefügt. Die zurückgegebene GlobalId wird in OutputManagerModuleState::output\_manager\_global gespeichert.  
* **Anfrage: create\_configuration(id: New\<ZwlrOutputConfigurationV1\>, serial: u32)**  
  * Rust Signatur:  
    Rust  
    fn create\_configuration(  
        \&mut self,  
        \_client: \&Client, // wayland\_server::Client  
        \_manager: \&ZwlrOutputManagerV1, // wayland\_protocols::wlr::output\_management::v1::server::zwlr\_output\_manager\_v1::ZwlrOutputManagerV1  
        new\_id: New\<ZwlrOutputConfigurationV1\>, // wayland\_server::New\<ZwlrOutputConfigurationV1\>  
        serial: u32,  
        data\_init: \&mut DataInit\<'\_, YourCompositorState\> // wayland\_server::DataInit  
    ) {... }  
    (Hinweis: Die genaue Signatur hängt von der Implementierung des Dispatch-Traits ab; Result\<(), BindError\> ist bei GlobalDispatch nicht direkt der Rückgabewert der bind-Methode, sondern die Initialisierung erfolgt innerhalb.)  
  * Implementierung:  
    1. Die vom Client bereitgestellte serial wird mit der aktuellen self.compositor\_output\_serial verglichen. Obwohl das Protokoll nicht explizit eine Ablehnung bei Serial-Mismatch hier vorschreibt, ist es ein Indikator dafür, dass der Client möglicherweise veraltete Informationen hat. Eine Warnung kann geloggt werden. Die eigentliche Konsequenz eines Serial-Mismatchs wird typischerweise beim apply oder test relevant, wo eine cancelled-Nachricht gesendet werden kann.2  
    2. Eine neue Instanz von PendingOutputConfiguration wird mit der clientseitigen serial erstellt.  
    3. Diese PendingOutputConfiguration wird in einem Arc\<Mutex\<...\>\> verpackt und in OutputManagerModuleState::active\_configurations gespeichert, wobei die ObjectId des neuen zwlr\_output\_configuration\_v1-Objekts als Schlüssel dient.  
    4. Die zwlr\_output\_configuration\_v1-Ressource wird für den Client initialisiert und mit dem Arc\<Mutex\<PendingOutputConfiguration\>\> als UserData versehen. data\_init.init(new\_id, user\_data\_arc\_clone);  
* **Anfrage: stop() (seit Version 3\)**  
  * Rust Signatur:  
    Rust  
    fn stop(  
        \&mut self,  
        \_client: \&Client,  
        \_manager: \&ZwlrOutputManagerV1  
    ) {... }

  * Implementierung:  
    1. Wenn der Client die entsprechende Berechtigung hat (üblicherweise jeder Client, der den Manager gebunden hat), wird das zwlr\_output\_manager\_v1-Global zerstört.  
    2. Dies bedeutet, dass self.output\_manager\_global.take().map(|id| display\_handle.remove\_global(id)); aufgerufen wird, sodass keine neuen Clients mehr binden können.  
    3. Bestehende zwlr\_output\_configuration\_v1-Objekte könnten gemäß Protokollspezifikation weiterhin gültig bleiben, bis sie explizit vom Client zerstört werden oder ihre Operationen mit succeeded, failed oder cancelled abschließen. Die finished-Nachricht auf dem Manager signalisiert Clients, dass der Manager nicht mehr verwendet werden kann.  
* **Vom Compositor gesendete Ereignisse (beim Binden oder bei Änderung des Output-Zustands):**  
  * head(output: WlOutput): Für jedes aktuell vom Compositor verwaltete smithay::output::Output. Das WlOutput-Objekt wird dem Client übergeben.  
  * done(serial: u32): Nach allen head-Ereignissen wird die aktuelle compositor\_output\_serial gesendet.  
  * finished(): Wenn das Manager-Global zerstört wird (z.B. durch stop() oder beim Herunterfahren des Compositors).

**Tabelle: zwlr\_output\_manager\_v1 Interface-Behandlung**

| Anfrage/Ereignis | Richtung | Smithay Handler Signatur (Beispiel) | Parameter (Name, Wayland-Typ, Rust-Typ) | Vorbedingungen | Nachbedingungen | Fehlerbedingungen | Beschreibung |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| create\_configuration | Client \-\> Server | fn create\_configuration(..., new\_id: New\<ZwlrOutputConfigurationV1\>, serial: u32,...) | id: new\_id (New\<ZwlrOutputConfigurationV1\>), serial: uint (u32) | Manager-Global existiert. | Neues ZwlrOutputConfigurationV1-Objekt erstellt und mit PendingOutputConfiguration assoziiert. | Protokollfehler bei ungültiger ID. | Erstellt ein neues Konfigurationsobjekt. |
| stop | Client \-\> Server | fn stop(...) | \- | Manager-Global existiert. | Manager-Global wird für neue Bindungen deaktiviert/zerstört. finished-Ereignis wird gesendet. | \- | Stoppt den Output-Manager. |
| head | Server \-\> Client | \- (Intern ausgelöst) | output: object (WlOutput) | Output existiert im Compositor. | Client erhält Referenz auf ein WlOutput-Objekt. | \- | Informiert Client über einen verfügbaren Output. |
| done | Server \-\> Client | \- (Intern ausgelöst) | serial: uint (u32) | Alle head-Ereignisse für aktuellen Zustand gesendet. | Client kennt aktuelle Output-Serialnummer des Compositors. | \- | Signalisiert Ende der Output-Auflistung. |
| finished | Server \-\> Client | \- (Intern ausgelöst) | \- | Manager-Global wird zerstört. | Client weiß, dass der Manager nicht mehr nutzbar ist. | \- | Manager wurde beendet. |

### **E. Protokollbehandlung: zwlr\_output\_configuration\_v1 (Interface Version: 3\)**

* **Smithay Handler:** impl Dispatch\<ZwlrOutputConfigurationV1, Arc\<Mutex\<PendingOutputConfiguration\>\>, YourCompositorState\> for OutputManagerModuleState. Die UserData für jede zwlr\_output\_configuration\_v1-Ressource ist ein Arc\<Mutex\<PendingOutputConfiguration\>\>, das den Zustand der vom Client angeforderten, aber noch nicht angewendeten Konfiguration enthält.  
* **Anfragen vom Client (modifizieren PendingOutputConfiguration):**  
  * destroy(): Entfernt die zugehörige PendingOutputConfiguration aus OutputManagerModuleState::active\_configurations. Die Ressource wird von Smithay automatisch bereinigt.  
  * enable\_head(head: \&WlOutput): Setzt enabled \= Some(true) in der HeadConfigChange für den gegebenen head in PendingOutputConfiguration.  
  * disable\_head(head: \&WlOutput): Setzt enabled \= Some(false).  
  * set\_mode(head: \&WlOutput, mode: \&ZwlrOutputModeV1): Aktualisiert mode \= Some(OutputModeRequest::ExistingMode(mode\_id)) in HeadConfigChange. Die mode\_id muss aus dem ZwlrOutputModeV1-Objekt extrahiert werden (z.B. über dessen UserData).  
  * set\_custom\_mode(head: \&WlOutput, width: i32, height: i32, refresh: i32): Aktualisiert mode \= Some(OutputModeRequest::CustomMode { width, height, refresh }).  
  * set\_position(head: \&WlOutput, x: i32, y: i32): Aktualisiert position \= Some(Point::from((x, y))).  
  * set\_transform(head: \&WlOutput, transform: wl\_output::Transform): Aktualisiert transform \= Some(transform).  
  * set\_scale(head: \&WlOutput, scale: u32): Aktualisiert scale \= Some(scale as f64 / 256.0). Die Skalierung wird als Festkommazahl (multipliziert mit 256\) über das Protokoll gesendet. Alle diese Anfragen dürfen nur aufgerufen werden, wenn die Konfiguration noch nicht mit test() oder apply() verarbeitet wurde (PendingOutputConfiguration::is\_applied\_or\_tested \== false). Andernfalls ist es ein Protokollfehler (already\_applied\_or\_tested).  
* **Anfrage: test()**  
  * Implementierung:  
    1. Sperre den Mutex der PendingOutputConfiguration.  
    2. Wenn is\_applied\_or\_tested \== true, sende Protokollfehler already\_applied\_or\_tested und gib zurück.  
    3. Iteriere über head\_configs. Für jede HeadConfigChange:  
       * Identifiziere das Ziel-smithay::output::Output-Objekt anhand von WlOutput (z.B. über dessen UserData, das den Namen/ID des Smithay-Outputs enthält).  
       * Validiere die angeforderte Konfiguration:  
         * Existiert der Output noch?  
         * Wenn enabled \== Some(true):  
           * Ist der angeforderte Modus (existierend oder benutzerdefiniert) vom Output unterstützt? (Prüfe gegen Output::modes()).  
           * Ist die Position im Rahmen der Compositor-Policy gültig (z.B. keine unmöglichen Überlappungen, falls der Compositor dies prüft)?  
           * Sind Skalierung und Transformation gültige Werte?  
    4. Wenn alle Prüfungen erfolgreich sind, sende das succeeded()-Ereignis auf dem zwlr\_output\_configuration\_v1-Objekt.  
    5. Andernfalls sende das failed()-Ereignis.  
    6. Setze is\_applied\_or\_tested \= true.  
* **Anfrage: apply()**  
  * Implementierung:  
    1. Sperre den Mutex der PendingOutputConfiguration.  
    2. Wenn is\_applied\_or\_tested \== true, sende Protokollfehler already\_applied\_or\_tested und gib zurück.  
    3. Vergleiche PendingOutputConfiguration::serial mit OutputManagerModuleState::compositor\_output\_serial. Wenn sie nicht übereinstimmen, bedeutet dies, dass sich der Output-Zustand des Compositors geändert hat, seit der Client diese Konfiguration erstellt hat. Sende das cancelled()-Ereignis und gib zurück.  
    4. Führe Validierungen ähnlich wie bei test() durch. Wenn ungültig, sende failed() und gib zurück.  
    5. Versuche, die Konfiguration auf die tatsächlichen smithay::output::Output-Objekte des Compositors anzuwenden. Dies kann das Batchen von Änderungen beinhalten, wenn das DRM-Backend atomares Modesetting unterstützt.  
       * Für jede HeadConfigChange im PendingOutputConfiguration:  
         * Rufe output.change\_current\_state(...) mit den neuen Eigenschaften auf. Diese Methode in smithay::output::Output ist dafür verantwortlich, die Änderungen an das Backend (z.B. DRM) weiterzuleiten.  
         * Sammle die Ergebnisse dieser Operationen.  
    6. Wenn alle Hardware-Änderungen erfolgreich waren (oder erfolgreich simuliert wurden, falls kein echtes Backend):  
       * Inkrementiere OutputManagerModuleState::compositor\_output\_serial.  
       * Sende das succeeded()-Ereignis auf dem zwlr\_output\_configuration\_v1-Objekt.  
       * Benachrichtige alle zwlr\_output\_manager\_v1-Clients über den neuen Zustand, indem neue head-Ereignisse und ein done-Ereignis mit der neuen compositor\_output\_serial gesendet werden. Dies stellt sicher, dass alle Clients über die erfolgreiche Konfigurationsänderung informiert werden.  
    7. Wenn eine Hardware-Änderung fehlschlägt:  
       * Versuche, alle bereits teilweise angewendeten Änderungen dieser Konfiguration zurückzusetzen (Best-Effort-Basis). Dies ist ein komplexer Teil und hängt stark von den Fähigkeiten des Backends ab.  
       * Sende das failed()-Ereignis.  
    8. Setze is\_applied\_or\_tested \= true.  
* **Ereignisse an den Client:** succeeded(), failed(), cancelled().

**Tabelle: zwlr\_output\_configuration\_v1 Interface-Behandlung**

| Anfrage/Ereignis | Richtung | Smithay Handler Signatur (Beispiel) | Parameter (Name, Wayland-Typ, Rust-Typ) | Vorbedingungen | Nachbedingungen | Fehlerbedingungen | Beschreibung |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| destroy | Client \-\> Server | fn destroyed(..., \_data: \&Arc\<Mutex\<PendingOutputConfiguration\>\>) | \- | Konfigurationsobjekt existiert. | Konfigurationsobjekt und zugehöriger Zustand werden bereinigt. | \- | Zerstört das Konfigurationsobjekt. |
| enable\_head | Client \-\> Server | fn request(..., request: zwlr\_output\_configuration\_v1::Request, data: \&Arc\<Mutex\<PendingOutputConfiguration\>\>...) | head: object (WlOutput) | is\_applied\_or\_tested \== false. head ist valides WlOutput. | PendingOutputConfiguration für head wird auf enabled \= Some(true) gesetzt. | already\_applied\_or\_tested. | Aktiviert einen Output in der pend. Konfiguration. |
| disable\_head | Client \-\> Server | (wie enable\_head) | head: object (WlOutput) | (wie enable\_head) | PendingOutputConfiguration für head wird auf enabled \= Some(false) gesetzt. | already\_applied\_or\_tested. | Deaktiviert einen Output in der pend. Konfiguration. |
| set\_mode | Client \-\> Server | (wie enable\_head) | head: object (WlOutput), mode: object (ZwlrOutputModeV1) | (wie enable\_head). mode ist valider Modus für head. | PendingOutputConfiguration für head wird auf neuen Modus gesetzt. | already\_applied\_or\_tested. | Setzt einen existierenden Modus. |
| set\_custom\_mode | Client \-\> Server | (wie enable\_head) | head: object (WlOutput), width: int32, height: int32, refresh: int32 | (wie enable\_head) | PendingOutputConfiguration für head wird auf benutzerdef. Modus gesetzt. | already\_applied\_or\_tested. | Setzt einen benutzerdefinierten Modus. |
| set\_position | Client \-\> Server | (wie enable\_head) | head: object (WlOutput), x: int32, y: int32 | (wie enable\_head) | PendingOutputConfiguration für head wird auf neue Position gesetzt. | already\_applied\_or\_tested. | Setzt die Position eines Outputs. |
| set\_transform | Client \-\> Server | (wie enable\_head) | head: object (WlOutput), transform: uint (wl\_output::Transform) | (wie enable\_head) | PendingOutputConfiguration für head wird auf neue Transformation gesetzt. | already\_applied\_or\_tested. | Setzt die Transformation. |
| set\_scale | Client \-\> Server | (wie enable\_head) | head: object (WlOutput), scale: uint (Fixed-point 24.8) | (wie enable\_head) | PendingOutputConfiguration für head wird auf neue Skalierung gesetzt. | already\_applied\_or\_tested. | Setzt die Skalierung. |
| test | Client \-\> Server | (wie enable\_head) | \- | is\_applied\_or\_tested \== false. | is\_applied\_or\_tested \= true. succeeded oder failed wird gesendet. | already\_applied\_or\_tested. | Testet die pend. Konfiguration. |
| apply | Client \-\> Server | (wie enable\_head) | \- | is\_applied\_or\_tested \== false. | is\_applied\_or\_tested \= true. Konfiguration wird angewendet. succeeded, failed oder cancelled wird gesendet. Output-Serial wird ggf. aktualisiert & an Clients propagiert. | already\_applied\_or\_tested. | Wendet die pend. Konfiguration an. |
| succeeded | Server \-\> Client | \- | \- | test oder apply war erfolgreich. | Client weiß, dass Konfiguration gültig/angewendet ist. | \- | Konfiguration erfolgreich. |
| failed | Server \-\> Client | \- | \- | test oder apply ist fehlgeschlagen. | Client weiß, dass Konfiguration ungültig/nicht angewendet wurde. | \- | Konfiguration fehlgeschlagen. |
| cancelled | Server \-\> Client | \- | \- | apply wurde abgebrochen (z.B. Serial-Mismatch). | Client weiß, dass Konfiguration veraltet ist. | \- | Konfiguration abgebrochen. |

### **F. Fehlerbehandlung**

* OutputManagerError Enum (definiert in system/outputs/output\_manager/errors.rs):  
  Rust  
  use thiserror::Error;  
  use smithay::utils::Point; // Assuming Logical is part of Point's definition path  
  use wayland\_server::protocol::wl\_output;

  \#  
  pub enum OutputManagerError {  
      \#\[error("Invalid WlOutput reference provided by client.")\]  
      InvalidWlOutput,

      \#  
      InvalidModeForOutput,

      \#\[error("Configuration object has already been applied or tested and cannot be modified further.")\]  
      AlreadyProcessed,

      \#  
      BackendError(String),

      \#\[error("Client serial {client\_serial} does not match compositor output serial {server\_serial}; configuration cancelled.")\]  
      SerialMismatch { client\_serial: u32, server\_serial: u32 },

      \#\[error("Attempted to configure a non-existent or no longer available output: {output\_name}")\]  
      UnknownOutput { output\_name: String },

      \#  
      InvalidMode {  
          output\_name: String,  
          width: i32,  
          height: i32,  
          refresh: i32,  
      },

      \#\[error("Configuration test failed: {reason}")\]  
      TestFailed { reason: String },

      \#\[error("Configuration application failed: {reason}")\]  
      ApplyFailed { reason: String },

      \#\[error("Configuration was cancelled due to a concurrent output state change.")\]  
      Cancelled,

      \#\[error("A generic protocol error occurred: {0}")\]  
      ProtocolError(String), // For generic protocol violations by the client  
  }

**Tabelle: OutputManagerError Varianten**

| Variantenname | Beschreibung | Typischer Auslöser | Empfohlene Client-Aktion |
| :---- | :---- | :---- | :---- |
| InvalidWlOutput | Eine ungültige WlOutput-Referenz wurde vom Client bereitgestellt. | Client sendet eine Anfrage mit einer WlOutput-Ressource, die dem Compositor nicht (mehr) bekannt ist. | Client sollte seine Output-Liste aktualisieren. Protokollfehler. |
| InvalidModeForOutput | Der referenzierte ZwlrOutputModeV1 ist für den gegebenen WlOutput nicht gültig. | Client versucht, einen Modus zu setzen, der nicht zu den vom Output angebotenen Modi gehört. | Client sollte die Modi des Outputs erneut prüfen. Protokollfehler. |
| AlreadyProcessed | Das Konfigurationsobjekt wurde bereits angewendet oder getestet und kann nicht weiter modifiziert werden. | Client sendet eine Modifikationsanfrage (z.B. set\_mode) an ein zwlr\_output\_configuration\_v1-Objekt, nachdem bereits test() oder apply() darauf aufgerufen wurde. | Client muss ein neues Konfigurationsobjekt erstellen. Protokollfehler. |
| BackendError | Ein Fehler im DRM- oder Hardware-Backend während der Konfigurationsanwendung. | Fehler beim Aufruf von DRM ioctls oder anderen Backend-spezifischen Operationen. | Client kann versuchen, die Operation später erneut auszuführen oder eine einfachere Konfiguration wählen. Der Compositor sendet failed(). |
| SerialMismatch | Die Serialnummer des Clients stimmt nicht mit der des Compositors überein; Konfiguration abgebrochen. | Der Output-Zustand des Compositors hat sich geändert, seit der Client die Konfiguration erstellt hat. | Client muss seine Output-Informationen aktualisieren (auf head/done-Ereignisse warten) und eine neue Konfiguration erstellen. Der Compositor sendet cancelled(). |
| UnknownOutput | Versuch, einen nicht existierenden oder nicht mehr verfügbaren Output zu konfigurieren. | Client referenziert einen Output (z.B. per Name/ID intern), der nicht (mehr) existiert. | Client sollte seine Output-Liste aktualisieren. Der Compositor sendet failed() oder cancelled(). |
| InvalidMode | Ein ungültiger Modus (Dimensionen, Refresh-Rate) wurde für einen Output spezifiziert. | Client spezifiziert einen custom\_mode mit Werten, die vom Output oder Compositor nicht unterstützt werden. | Client sollte unterstützte Modi verwenden oder Parameter anpassen. Der Compositor sendet failed(). |
| TestFailed | Der Konfigurationstest ist fehlgeschlagen. | Die vorgeschlagene Konfiguration ist aus Sicht des Compositors ungültig (z.B. ungültige Modi, Überlappungen). | Client sollte die Konfiguration anpassen. Der Compositor sendet failed(). |
| ApplyFailed | Die Anwendung der Konfiguration ist fehlgeschlagen. | Die Konfiguration war zwar gültig, konnte aber aufgrund eines Backend-Fehlers oder eines Laufzeitproblems nicht angewendet werden. | Client kann es erneut versuchen oder eine andere Konfiguration wählen. Der Compositor sendet failed(). |
| Cancelled | Die Konfiguration wurde aufgrund einer gleichzeitigen Zustandsänderung des Outputs abgebrochen. | Typischerweise durch einen Serial-Mismatch bei apply() oder wenn sich der Output-Zustand während des apply-Vorgangs ändert. | Client muss seine Output-Informationen aktualisieren und eine neue Konfiguration erstellen. Der Compositor sendet cancelled(). |
| ProtocolError | Ein generischer Protokollfehler seitens des Clients. | Client sendet eine Anfrage, die gegen die Protokollregeln verstößt (z.B. falsche Argumente, falsche Reihenfolge). | Client-Fehler. Der Compositor kann die Client-Verbindung beenden. |

### **G. Detaillierte Implementierungsschritte (Zusammenfassung)**

1. **Global Setup:** OutputManagerModuleState initialisieren. Das zwlr\_output\_manager\_v1-Global erstellen und im Wayland-Display bekannt machen. GlobalDispatch für dieses Global implementieren, um Client-Bindungen zu handhaben.  
2. **Manager Request Handling:** Dispatch für ZwlrOutputManagerV1 implementieren.  
   * Bei create\_configuration: Eine neue PendingOutputConfiguration-Instanz (eingebettet in Arc\<Mutex\<...\>\>) erstellen, diese mit der neuen zwlr\_output\_configuration\_v1-Ressource als UserData assoziieren und in active\_configurations speichern. Die aktuelle compositor\_output\_serial in PendingOutputConfiguration speichern.  
   * Bei stop: Das Global aus dem Display entfernen.  
3. **Configuration Request Handling:** Dispatch für ZwlrOutputConfigurationV1 implementieren.  
   * Anfragen wie enable\_head, disable\_head, set\_mode, set\_custom\_mode, set\_position, set\_transform, set\_scale modifizieren den Zustand der assoziierten PendingOutputConfiguration. Vor jeder Modifikation prüfen, ob is\_applied\_or\_tested false ist; andernfalls einen Protokollfehler (already\_applied\_or\_tested) senden.  
4. **Test/Apply Logic:**  
   * Für test(): Die in PendingOutputConfiguration gespeicherten Änderungen validieren. Dies beinhaltet die Prüfung, ob die referenzierten Outputs und Modi existieren und gültig sind und ob die Gesamtkonfiguration plausibel ist (z.B. keine unmöglichen Überlappungen gemäß Compositor-Policy). Ergebnis mit succeeded() oder failed() an den Client senden. is\_applied\_or\_tested auf true setzen.  
   * Für apply(): Zuerst die PendingOutputConfiguration::serial mit der aktuellen compositor\_output\_serial vergleichen. Bei Abweichung cancelled() senden. Andernfalls Validierung wie bei test() durchführen. Wenn gültig, versuchen, die Änderungen auf die internen smithay::output::Output-Objekte anzuwenden (z.B. via output.change\_current\_state(...)). Bei Erfolg succeeded() senden, die compositor\_output\_serial inkrementieren und alle Manager-Clients über den neuen Zustand und die neue Serial informieren. Bei Fehlschlag (z.B. Backend-Fehler) versuchen, Änderungen zurückzurollen und failed() senden. is\_applied\_or\_tested auf true setzen.  
5. **Event Emission:**  
   * Wenn sich der Zustand eines smithay::output::Output ändert (z.B. durch Hotplug oder erfolgreiches apply), müssen alle gebundenen zwlr\_output\_manager\_v1-Clients aktualisierte head-Informationen und ein done-Ereignis mit der neuen compositor\_output\_serial erhalten.  
   * zwlr\_output\_configuration\_v1 sendet succeeded, failed oder cancelled als Antwort auf test oder apply.  
6. **State Synchronization:** Die compositor\_output\_serial ist der Schlüssel zur Konsistenzerhaltung. Sie wird bei jeder erfolgreichen Anwendung einer Konfiguration oder bei jeder vom Compositor initiierten Änderung des Output-Layouts (z.B. Hotplug) inkrementiert. Clients verwenden diese Serial, um sicherzustellen, dass ihre Konfigurationsanfragen auf dem aktuellen Stand basieren.

### **H. Interaktionen**

* **Compositor Core (AnvilState oder Äquivalent):** Stellt die Liste der smithay::output::Output-Objekte bereit, deren aktuellen Zustände (Modi, Positionen, etc.) und die aktuelle compositor\_output\_serial. Nimmt Anfragen zur Zustandsänderung von Outputs entgegen.  
* **DRM Backend (oder anderes Hardware-Backend):** Die apply()-Logik ruft letztendlich Funktionen des Backends auf, um physische Display-Eigenschaften zu ändern (z.B. via DRM ioctls für Modesetting, Positionierung über CRTC-Konfiguration).  
* **UI Layer (indirekt):** Display-Konfigurationswerkzeuge (z.B. ein Einstellungsdialog) sind die primären Clients dieses Protokolls. Sie nutzen es, um dem Benutzer die Kontrolle über die Display-Einstellungen zu ermöglichen.

### **I. Vertiefende Betrachtungen & Implikationen**

Die Implementierung des wlr-output-management-unstable-v1-Protokolls erfordert sorgfältige Beachtung der Atomarität von Konfigurationsänderungen und der Synchronisation des Client-Zustands mit dem Compositor.  
Die Semantik von test() und apply() 2 legt nahe, dass der Compositor in der Lage sein muss, einen vollständigen Satz von Output-Änderungen zu validieren, *bevor* er versucht, sie anzuwenden. Dies ist entscheidend, um zu verhindern, dass das System in einem inkonsistenten oder unbrauchbaren Display-Zustand verbleibt. Scheitert ein apply(), sollte idealerweise ein Rollback zum vorherigen Zustand erfolgen. Dies kann komplex sein, wenn das zugrundeliegende DRM-Backend nicht für alle relevanten Eigenschaften atomare Updates unterstützt oder wenn eine Sequenz von Änderungen erforderlich ist. Ein robuster Compositor muss hier entweder auf Backend-Fähigkeiten für atomare Commits zurückgreifen oder eine eigene Logik implementieren, um den aktuellen Hardware-Zustand zu lesen, Änderungen zu versuchen und bei Fehlschlägen einzelne Schritte zurückzunehmen – letzteres ist deutlich komplexer. Smithays DRM-Abstraktionen 3 zielen darauf ab, dies zu vereinfachen, aber die Atomaritätsanforderung des Protokolls stellt eine Herausforderung dar.  
Das Management von Serialnummern ist ein weiterer kritischer Aspekt. Das serial-Argument in create\_configuration und das done-Ereignis des Managers 2 ermöglichen es Clients zu erkennen, ob ihr Verständnis des Output-Layouts aktuell ist. Ändert sich das Output-Layout des Compositors (z.B. durch Hotplugging eines Monitors), nachdem ein Client ein done-Ereignis empfangen hat, aber bevor er create\_configuration aufruft, ermöglicht der Serialnummern-Mismatch dem Compositor, die Konfiguration effektiv abzubrechen (typischerweise durch Senden von cancelled bei apply()). Dies zwingt den Client, den Output-Zustand neu zu evaluieren, und verhindert Operationen auf einem veralteten Setup.  
Schließlich ist die zuverlässige Zuordnung von clientseitigen WlOutput-Ressourcen zu den internen smithay::output::Output-Instanzen des Compositors unerlässlich. Das Protokoll operiert mit WlOutput-Objekten. Der Compositor muss diese clientseitigen Ressourcen eindeutig seinen internen Repräsentationen der physischen Outputs zuordnen können, um Fähigkeiten abzufragen und Änderungen anzuwenden. Diese Zuordnung wird typischerweise etabliert, wenn das wl\_output-Global vom Client gebunden wird. Smithays UserData-Mechanismus oder interne Maps, die ObjectIds als Schlüssel verwenden, sind hierfür gängige Lösungen. Die Output-Struktur von Smithay selbst verwaltet die WlOutput-Globale für Clients.1

## **III. Ultra-Feinspezifikation: system::outputs::power\_manager (Wayland Output Power Management)**

### **A. Modulübersicht und Zweck**

* **Verantwortlichkeit:** Dieses Modul implementiert die serverseitige Logik für das Wayland-Protokoll wlr-output-power-management-unstable-v1. Es ermöglicht autorisierten Wayland-Clients, typischerweise übergeordneten Shell-Komponenten, den Energiezustand (z.B. An, Aus) einzelner Display-Ausgänge zu steuern.  
* **Interaktion:** Es interagiert mit den internen smithay::output::Output-Objekten des Compositors. Anfragen zur Änderung des Energiezustands werden in Operationen auf diesen Objekten übersetzt, die dann typischerweise mit dem DRM-Backend (z.B. mittels DPMS) interagieren, um die physische Hardware zu steuern.  
* **Schlüsselprotokollelemente:** zwlr\_output\_power\_manager\_v1, zwlr\_output\_power\_v1.  
* **Relevante Referenzmaterialien & Analyse:**  
  * 28 (Protokoll-XML), 5 (Protokollspezifikation): Dies sind die primären Quellen, die Anfragen, Ereignisse und Enums (on, off) definieren. 5 merkt an, dass Modusänderungen "sofort wirksam" sind.  
  * 29 (wayland-rs Changelog): Weist auf die Verfügbarkeit des Protokolls in wayland-protocols hin.  
  * 5 (wayland.app Übersicht): Allgemeine Beschreibung und Links.  
  * 30 (lib.rs Erwähnung): Zeigt, dass es sich um ein bekanntes Protokoll handelt. Die Analyse dieser Quellen ergibt, dass dieses Protokoll im Vergleich zum Output-Management-Protokoll einfacher ist und sich auf zwei Zustände (An/Aus) konzentriert. Die Herausforderung liegt in der korrekten Autorisierung von Anfragen (implizit, da für "spezielle Clients" gedacht) und der zuverlässigen Weitergabe von Zustandsänderungen an die zugrundeliegende Display-Hardware.

### **B. Entwicklungs-Submodule & Dateien**

* **1\. system::outputs::power\_manager::manager\_global**  
  * Dateien: system/outputs/power\_manager/manager\_global.rs  
  * Verantwortlichkeiten: Verwaltet das zwlr\_output\_power\_manager\_v1-Global, behandelt Client-Bindungen und leitet get\_output\_power-Anfragen weiter.  
* **2\. system::outputs::power\_manager::power\_control\_handler**  
  * Dateien: system/outputs/power\_manager/power\_control\_handler.rs  
  * Verantwortlichkeiten: Verwaltet zwlr\_output\_power\_v1-Instanzen. Behandelt set\_mode-Anfragen von Clients und sendet mode- oder failed-Ereignisse.  
* **3\. system::outputs::power\_manager::types**  
  * Dateien: system/outputs/power\_manager/types.rs  
  * Verantwortlichkeiten: Definiert Rust-Enums für zwlr\_output\_power\_v1::Mode (z.B. InternalPowerMode { On, Off }).  
* **4\. system::outputs::power\_manager::errors**  
  * Dateien: system/outputs/power\_manager/errors.rs  
  * Verantwortlichkeiten: Definiert OutputPowerError.

### **C. Schlüsseldatenstrukturen**

* OutputPowerManagerModuleState:  
  * power\_manager\_global: Option\<GlobalId\> (Smithay-Global für zwlr\_output\_power\_manager\_v1)  
  * active\_power\_controls: HashMap\<ObjectId, Arc\<Mutex\<OutputPowerControlState\>\>\> (Verfolgt aktive zwlr\_output\_power\_v1-Instanzen, Schlüssel ist die ObjectId der ZwlrOutputPowerV1-Ressource)  
* OutputPowerControlState: Repräsentiert den Zustand einer zwlr\_output\_power\_v1-Instanz.  
  * wl\_output\_resource: WlOutput (Die clientgebundene WlOutput-Ressource, für die diese Kontrolle gilt)  
  * compositor\_output\_name: String (Ein eindeutiger Bezeichner für das interne smithay::output::Output-Objekt, das diesem WlOutput entspricht)  
  * current\_mode: InternalPowerMode (Spiegelt den zuletzt erfolgreich gesetzten Modus wider)  
* InternalPowerMode (Rust Enum): On, Off.

**Tabelle: OutputPowerManager-Datenstrukturen**

| Struct/Enum Name | Felder (Name, Rust-Typ, nullable, Mutabilität) | Beschreibung | Korrespondierendes Wayland-Protokollelement/Konzept |
| :---- | :---- | :---- | :---- |
| OutputPowerManagerModuleState | power\_manager\_global: Option\<GlobalId\> (intern, veränderlich) \<br\> active\_power\_controls: HashMap\<ObjectId, Arc\<Mutex\<OutputPowerControlState\>\>\> (intern, veränderlich) | Hauptzustand des Moduls, verwaltet das Global und aktive Energiezustandskontrollen. | zwlr\_output\_power\_manager\_v1 |
| OutputPowerControlState | wl\_output\_resource: WlOutput (intern, unveränderlich nach Erstellung) \<br\> compositor\_output\_name: String (intern, unveränderlich nach Erstellung) \<br\> current\_mode: InternalPowerMode (intern, veränderlich) | Speichert den Zustand einer einzelnen Energiezustandskontrolle für einen bestimmten Output. | zwlr\_output\_power\_v1 |
| InternalPowerMode | On, Off | Rust-interne Repräsentation der Energiezustände. | zwlr\_output\_power\_v1::mode Enum (on, off) |

Diese Strukturen sind notwendig, um den Überblick über die globalen Dienste und die individuellen Steuerungsobjekte für jeden Output zu behalten. active\_power\_controls ermöglicht es, auf Anfragen zu einem spezifischen zwlr\_output\_power\_v1-Objekt zu reagieren und dessen Zustand (insbesondere den current\_mode) zu verwalten.

### **D. Protokollbehandlung: zwlr\_output\_power\_manager\_v1 (Interface Version: 1\)**

* **Smithay Handler:** Die Implementierung erfolgt über GlobalDispatch\<ZwlrOutputPowerManagerV1, GlobalData, YourCompositorState\> und Dispatch\<ZwlrOutputPowerManagerV1, UserData, YourCompositorState\> für OutputPowerManagerModuleState. GlobalData ist hier typischerweise leer. UserData für den Manager ist ebenfalls oft nicht komplex.  
* **Anfrage: get\_output\_power(id: New\<ZwlrOutputPowerV1\>, output: WlOutput)**  
  * Rust Signatur (innerhalb des Dispatch-Traits für den Manager):  
    Rust  
    fn request(  
        \&mut self,  
        client: \&Client,  
        manager: \&ZwlrOutputPowerManagerV1,  
        request: zwlr\_output\_power\_manager\_v1::Request,  
        data: \&Self::UserData, // UserData des Managers  
        dhandle: \&DisplayHandle,  
        data\_init: \&mut DataInit\<'\_, YourCompositorState\>,  
    ) {  
        if let zwlr\_output\_power\_manager\_v1::Request::GetOutputPower { id, output: wl\_output\_resource } \= request {  
            //... Implementierungslogik...  
        }  
    }

  * Implementierung:  
    1. Identifiziere das interne smithay::output::Output-Objekt, das der vom Client übergebenen wl\_output\_resource entspricht. Dies geschieht typischerweise durch Abrufen von UserData, das mit der wl\_output\_resource assoziiert ist und den Namen oder eine ID des smithay::output::Output enthält. Wenn kein entsprechender interner Output gefunden wird, sollte das neu erstellte ZwlrOutputPowerV1-Objekt später ein failed-Ereignis senden.  
    2. Prüfe, ob bereits ein anderer Client die Energiekontrolle für diesen spezifischen wl\_output\_resource besitzt. Das Protokoll 5 deutet an, dass nur ein Client exklusive Kontrolle haben sollte ("Another client already has exclusive power management mode control"). Wenn ein Konflikt besteht, sollte das neu erstellte ZwlrOutputPowerV1-Objekt dem neuen Client ein failed-Ereignis senden, sobald es initialisiert ist oder bei der ersten set\_mode-Anfrage.  
    3. Erstelle eine neue Instanz von OutputPowerControlState. Der compositor\_output\_name wird auf den Bezeichner des internen Smithay-Outputs gesetzt. Der current\_mode wird durch Abfrage des tatsächlichen Energiezustands des physischen Outputs (z.B. über DRM DPMS) initialisiert.  
    4. Assoziiere diesen OutputPowerControlState (eingepackt in Arc\<Mutex\<...\>\>) mit der neuen id (New\<ZwlrOutputPowerV1\>) über data\_init.init(id, Arc::new(Mutex::new(power\_control\_state)));.  
    5. Sende unmittelbar nach der Erstellung des ZwlrOutputPowerV1-Objekts das initiale mode-Ereignis an den Client, das den aktuellen Energiezustand des Outputs widerspiegelt.5  
* **Anfrage: destroy()**  
  * Implementierung: Zerstört das zwlr\_output\_power\_manager\_v1-Global. Bestehende ZwlrOutputPowerV1-Objekte bleiben gemäß Protokoll 5 gültig. Das Entfernen des Globals aus dem DisplayHandle verhindert, dass neue Clients binden.

**Tabelle: zwlr\_output\_power\_manager\_v1 Interface-Behandlung**

| Anfrage/Ereignis | Richtung | Smithay Handler Signatur (Beispiel) | Parameter (Name, Wayland-Typ, Rust-Typ) | Vorbedingungen | Nachbedingungen | Fehlerbedingungen | Beschreibung |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| get\_output\_power | Client \-\> Server | Dispatch::request (match auf Request::GetOutputPower) | id: new\_id (New\<ZwlrOutputPowerV1\>), output: object (WlOutput) | Manager-Global existiert. output ist ein gültiges WlOutput-Objekt. | Neues ZwlrOutputPowerV1-Objekt erstellt und mit OutputPowerControlState assoziiert. Initiales mode-Ereignis wird an das neue Objekt gesendet. | Protokollfehler bei ungültiger ID. Interner Fehler, wenn output nicht zugeordnet werden kann (führt zu failed auf dem neuen Objekt). | Erstellt ein Energiekontroll-Objekt für einen Output. |
| destroy | Client \-\> Server | Dispatch::request (match auf Request::Destroy) | \- | Manager-Global existiert. | Manager-Global wird für neue Bindungen deaktiviert/zerstört. | \- | Zerstört das Manager-Objekt. |

### **E. Protokollbehandlung: zwlr\_output\_power\_v1 (Interface Version: 1\)**

* **Smithay Handler:** impl Dispatch\<ZwlrOutputPowerV1, Arc\<Mutex\<OutputPowerControlState\>\>, YourCompositorState\> for OutputPowerManagerModuleState. Die UserData ist hier der Arc\<Mutex\<OutputPowerControlState\>\>, der bei get\_output\_power erstellt wurde.  
* **Anfrage vom Client: set\_mode(mode: zwlr\_output\_power\_v1::Mode)**  
  * Implementierung:  
    1. Sperre den Mutex des OutputPowerControlState, um exklusiven Zugriff zu erhalten.  
    2. Übersetze das mode-Enum des Protokolls (On oder Off) in einen internen Steuerungswert (z.B. einen DPMS-Zustand für das DRM-Backend).  
    3. Versuche, diesen Energiezustand auf den physischen Output anzuwenden. Dies geschieht durch einen Aufruf an das entsprechende Backend (z.B. DRM-Backend, um den DPMS-Status zu setzen). Der compositor\_output\_name im OutputPowerControlState wird verwendet, um den korrekten internen smithay::output::Output zu identifizieren.  
    4. Wenn die Backend-Operation erfolgreich war:  
       * Aktualisiere OutputPowerControlState::current\_mode mit dem neuen Zustand.  
       * Sende das mode(actual\_new\_mode)-Ereignis über die ZwlrOutputPowerV1-Ressource an den Client. Der actual\_new\_mode sollte dem angeforderten Modus entsprechen.  
    5. Wenn die Backend-Operation fehlschlägt (z.B. der Output unterstützt den Modus nicht, ein Fehler im Backend tritt auf):  
       * Sende das failed()-Ereignis über die ZwlrOutputPowerV1-Ressource an den Client.  
* **Anfrage vom Client: destroy()**  
  * Implementierung: Die Dispatch::destroyed-Methode wird von Smithay aufgerufen, wenn der Client die Ressource zerstört. Hier wird der OutputPowerControlState aus der active\_power\_controls-Map im OutputPowerManagerModuleState entfernt, um Ressourcen freizugeben und sicherzustellen, dass keine veralteten Kontrollen mehr existieren.  
* **Ereignisse an den Client:**  
  * mode(mode: zwlr\_output\_power\_v1::Mode): Gesendet bei erfolgreicher set\_mode-Anfrage oder bei der Erstellung des ZwlrOutputPowerV1-Objekts, um den initialen Zustand zu übermitteln.  
  * failed(): Gesendet, wenn set\_mode fehlschlägt, der referenzierte Output ungültig wird (z.B. abgesteckt) oder ein anderer Client bereits die exklusive Kontrolle hat.

**Tabelle: zwlr\_output\_power\_v1 Interface-Behandlung**

| Anfrage/Ereignis | Richtung | Smithay Handler Signatur (Beispiel) | Parameter (Name, Wayland-Typ, Rust-Typ) | Vorbedingungen | Nachbedingungen | Fehlerbedingungen | Beschreibung |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| set\_mode | Client \-\> Server | Dispatch::request (match auf Request::SetMode) | mode: uint (zwlr\_output\_power\_v1::Mode) | ZwlrOutputPowerV1-Objekt existiert und ist gültig. | Energiezustand des Outputs wird geändert. mode oder failed Ereignis wird gesendet. | Output unterstützt Modus nicht. Backend-Fehler. | Setzt den Energiezustand des Outputs. |
| destroy | Client \-\> Server | Dispatch::destroyed | \- | ZwlrOutputPowerV1-Objekt existiert. | Zugehöriger OutputPowerControlState wird bereinigt. | \- | Zerstört das Energiekontroll-Objekt. |
| mode | Server \-\> Client | \- (Intern ausgelöst durch set\_mode oder Initialisierung) | mode: uint (zwlr\_output\_power\_v1::Mode) | Erfolgreiche Modusänderung oder Initialisierung. | Client kennt den aktuellen Energiezustand. | \- | Meldet eine Änderung des Energiezustands. |
| failed | Server \-\> Client | \- (Intern ausgelöst bei Fehlern) | \- | set\_mode fehlgeschlagen, Output ungültig, oder Kontrollkonflikt. | Client weiß, dass das Objekt ungültig ist. | \- | Objekt ist nicht mehr gültig. |

### **F. Fehlerbehandlung**

* OutputPowerError Enum (definiert in system/outputs/power\_manager/errors.rs):  
  Rust  
  use thiserror::Error;

  \#  
  pub enum OutputPowerError {  
      \#\[error("Output {output\_name:?} does not support power management.")\]  
      OutputDoesNotSupportPowerManagement { output\_name: String },

      \#\[error("Failed to set power mode for output {output\_name:?} due to backend error: {reason}")\]  
      BackendSetModeFailed { output\_name: String, reason: String },

      \#\[error("Output {output\_name:?} is no longer available.")\]  
      OutputVanished { output\_name: String },

      \#\[error("Another client already has exclusive power management control for output {output\_name:?}.")\]  
      ExclusiveControlConflict { output\_name: String },

      \#\[error("Invalid WlOutput reference provided by client.")\]  
      InvalidWlOutput,

      \#\[error("A generic protocol error occurred: {0}")\]  
      ProtocolError(String),  
  }

**Tabelle: OutputPowerError Varianten**

| Variantenname | Beschreibung | Typischer Auslöser | Empfohlene Client-Aktion (via failed Event) |
| :---- | :---- | :---- | :---- |
| OutputDoesNotSupportPowerManagement | Der angegebene Output unterstützt keine Energieverwaltung. | set\_mode für einen Output, der dies nicht kann. | Client sollte das ZwlrOutputPowerV1-Objekt zerstören. |
| BackendSetModeFailed | Das Setzen des Energiemodus im Backend ist fehlgeschlagen. | DRM/Hardware-Fehler während des DPMS-Aufrufs. | Client kann es später erneut versuchen oder den Fehler protokollieren; Objekt zerstören. |
| OutputVanished | Der Output, auf den sich das Kontrollobjekt bezieht, ist nicht mehr verfügbar. | Monitor wurde abgesteckt. | Client sollte das ZwlrOutputPowerV1-Objekt zerstören. |
| ExclusiveControlConflict | Ein anderer Client hat bereits die exklusive Kontrolle über die Energieverwaltung dieses Outputs. | get\_output\_power wird für einen bereits kontrollierten Output von einem anderen Client aufgerufen. | Client sollte das ZwlrOutputPowerV1-Objekt zerstören. |
| InvalidWlOutput | Eine ungültige WlOutput-Referenz wurde vom Client bereitgestellt. | Client sendet eine WlOutput-Ressource, die dem Compositor nicht bekannt ist, an get\_output\_power. | Client sollte seine Output-Liste aktualisieren. Protokollfehler. |
| ProtocolError | Ein generischer Protokollfehler seitens des Clients. | Client sendet eine Anfrage, die gegen die Protokollregeln verstößt. | Client-Fehler. Der Compositor kann die Client-Verbindung beenden. |

### **G. Detaillierte Implementierungsschritte (Zusammenfassung)**

1. **Global Setup:** OutputPowerManagerModuleState initialisieren. Das zwlr\_output\_power\_manager\_v1-Global erstellen und im Wayland-Display bekannt machen. GlobalDispatch für dieses Global implementieren.  
2. **Manager Request Handling:** Dispatch für ZwlrOutputPowerManagerV1 implementieren.  
   * Bei get\_output\_power: Internes smithay::output::Output-Objekt identifizieren. Prüfen auf exklusive Kontrolle. OutputPowerControlState erstellen (den aktuellen Energiezustand vom Backend abfragen und speichern). Das neue ZwlrOutputPowerV1-Objekt mit diesem Zustand als UserData initialisieren. Initiales mode-Ereignis an den Client senden.  
3. **Power Control Request Handling:** Dispatch für ZwlrOutputPowerV1 implementieren.  
   * Bei set\_mode: Den angeforderten Modus an das Backend (DRM DPMS) weiterleiten. Bei Erfolg den internen Zustand aktualisieren und mode-Ereignis senden. Bei Fehlschlag failed-Ereignis senden.  
4. **Output Disappearance:** Wenn ein physischer Output entfernt wird (z.B. durch Hot-Unplugging, das vom DRM-Modul erkannt wird), müssen alle zugehörigen ZwlrOutputPowerV1-Objekte ein failed-Ereignis erhalten. Der OutputPowerControlState für diesen Output sollte dann aus active\_power\_controls entfernt werden.  
5. **Compositor-Initiated Power Changes:** Wenn der Compositor selbst den Energiezustand eines Outputs ändert (z.B. durch eine Idle-Policy), muss er den current\_mode im entsprechenden OutputPowerControlState aktualisieren und ein mode-Ereignis an den gebundenen Client senden.

### **H. Interaktionen**

* **Compositor Core (AnvilState oder Äquivalent):** Stellt Zugriff auf smithay::output::Output-Instanzen und deren Zuordnung zu WlOutput-Ressourcen bereit. Benachrichtigt dieses Modul möglicherweise über das Verschwinden von Outputs.  
* **DRM Backend:** Wird aufgerufen, um DPMS-Zustände (Display Power Management Signaling) oder äquivalente hardwarenahe Energiesparfunktionen zu setzen (z.B. DRM\_MODE\_DPMS\_ON, DRM\_MODE\_DPMS\_OFF).  
* **Domain Layer:** Kann Energiesparrichtlinien auslösen (z.B. Bildschirm nach Inaktivität ausschalten), indem es entweder direkt D-Bus-Dienste aufruft, die dann dieses Protokoll verwenden könnten (wenn die Shell ein Client ist), oder indem es eine interne API des System-Layers aufruft, die letztendlich dieses Modul zur Steuerung der Output-Energie verwendet.

### **I. Vertiefende Betrachtungen & Implikationen**

Die Implementierung des wlr-output-power-management-unstable-v1-Protokolls ist im Vergleich zum Output-Konfigurationsprotokoll geradliniger, birgt aber eigene spezifische Herausforderungen in Bezug auf Exklusivität und Synchronisation mit dem tatsächlichen Hardwarezustand.  
Die Protokollbeschreibung 5 legt nahe, dass Änderungen des Energiemodus "sofort wirksam" sind. Dies impliziert eine direkte Interaktion mit der Hardware ohne eine vorgelagerte Testphase, wie sie bei wlr-output-management existiert. Für den Compositor bedeutet dies, dass bei einer set\_mode-Anfrage unmittelbar versucht werden muss, den Hardwarezustand zu ändern. Die Komplexität der Zustandsverwaltung reduziert sich dadurch, da keine komplexen pendelnden Zustände für eine Testphase vorgehalten werden müssen. Die Rückmeldung an den Client ist binär: Entweder die Aktion war erfolgreich (signalisiert durch ein mode-Ereignis mit dem neuen Zustand) oder sie schlug fehl (signalisiert durch ein failed-Ereignis).  
Das failed-Ereignis 5 dient als umfassender Fehlermechanismus. Es wird nicht nur bei direkten Fehlschlägen von set\_mode verwendet, sondern auch, wenn der zugrundeliegende Output ungültig wird (z.B. durch Abstecken des Monitors) oder wenn ein anderer Client bereits die exklusive Kontrolle über den Energiezustand des Outputs hat. Dies erfordert vom Compositor eine proaktive Überwachung des Zustands der physischen Outputs. Bei Änderungen, wie dem Entfernen eines Outputs, muss der Compositor alle assoziierten zwlr\_output\_power\_v1-Objekte identifizieren und ihnen ein failed-Ereignis senden. Dies stellt sicher, dass Clients darüber informiert werden, dass ihre Kontrollobjekte nicht mehr gültig sind und zerstört werden sollten.  
Ein weiterer wichtiger Aspekt ist die Möglichkeit, dass der Compositor selbst den Energiezustand eines Outputs ändert, unabhängig von Client-Anfragen über dieses Protokoll (z.B. aufgrund einer systemweiten Idle-Richtlinie). Das Protokoll 5 spezifiziert, dass das mode-Ereignis auch gesendet wird, wenn "der Compositor entscheidet, den Modus eines Outputs zu ändern". Wenn also die interne Logik des Compositors einen Bildschirm ausschaltet, muss dies im OutputPowerControlState des betroffenen Outputs reflektiert und ein entsprechendes mode-Ereignis an alle gebundenen zwlr\_output\_power\_v1-Clients gesendet werden. Dies gewährleistet, dass Clients stets über den aktuellen Energiezustand des Outputs informiert sind, auch wenn die Änderung nicht durch sie initiiert wurde.

## **IV. Ultra-Feinspezifikation: system::dbus::upower\_interface (UPower D-Bus Client)**

### **A. Modulübersicht und Zweck**

* **Verantwortlichkeit:** Dieses Modul stellt eine Schnittstelle zum org.freedesktop.UPower-D-Bus-Dienst bereit. Es ist dafür zuständig, den Systemstromstatus zu überwachen, einschließlich Batteriestand, Netzteilverbindung und den Zustand des Laptopdeckels (geöffnet/geschlossen).  
* **Informationsbereitstellung:** Die gesammelten Informationen werden anderen Teilen der Desktop-Umgebung zur Verfügung gestellt. Beispielsweise kann die Benutzeroberflächenschicht diese Daten für Batterieanzeigen oder Warnungen bei niedrigem Akkustand nutzen, während die Domänenschicht sie für die Implementierung von Energiesparrichtlinien verwenden kann.  
* **Relevante Referenzmaterialien & Analyse:**  
  * 31 (UPower D-Bus ref.xml), 6 (UPower Interface-Details), 32 (UPower Methoden/Signale), 32 (UPower D-Bus API Referenz): Diese Dokumente beschreiben die D-Bus-Schnittstelle von UPower, einschließlich der relevanten Objekte, Methoden (EnumerateDevices, GetDisplayDevice), Signale (DeviceAdded, DeviceRemoved, PropertiesChanged) und Eigenschaften (OnBattery, LidIsClosed, Percentage, State, TimeToEmpty, TimeToFull).  
  * 11 (PropertiesChanged-Signal), 33 (DeviceAdded-Signal), 34 (DeviceRemoved-Signal): Spezifische Details zu wichtigen Signalen.  
  * zbus-Snippets 8: Diese demonstrieren die allgemeine Verwendung der zbus-Bibliothek für die D-Bus-Kommunikation, einschließlich Proxy-Generierung, Methodenaufrufe und Signalbehandlung, was direkt auf die Implementierung dieses Moduls anwendbar ist. Die Analyse dieser Quellen zeigt, dass dieses Modul zbus verwenden wird, um Proxys für die Interfaces org.freedesktop.UPower und org.freedesktop.UPower.Device zu generieren. Es muss eine Verbindung zum System-Bus herstellen, Geräte auflisten, das "Display-Gerät" abrufen und Signale wie PropertiesChanged auf relevanten Geräteobjekten sowie DeviceAdded/DeviceRemoved auf dem Manager-Objekt abonnieren.

### **B. Entwicklungs-Submodule & Dateien**

* **1\. system::dbus::upower\_interface::client**  
  * Dateien: system/dbus/upower\_interface/client.rs  
  * Verantwortlichkeiten: Verwaltet die D-Bus-Verbindung, Proxy-Objekte, Methodenaufrufe und die Behandlung von Signalen. Enthält die Hauptlogik des UPower-Clients.  
* **2\. system::dbus::upower\_interface::types**  
  * Dateien: system/dbus/upower\_interface/types.rs  
  * Verantwortlichkeiten: Definiert Rust-Strukturen und Enums, die UPower-Daten abbilden (z.B. PowerDeviceDetails, PowerDeviceState, PowerSupplyType, UPowerManagerProperties). Diese Strukturen dienen der internen Repräsentation der von D-Bus erhaltenen Daten.  
* **3\. system::dbus::upower\_interface::errors**  
  * Dateien: system/dbus/upower\_interface/errors.rs  
  * Verantwortlichkeiten: Definiert das UPowerError-Enum für spezifische Fehler dieses Moduls.

### **C. Schlüsseldatenstrukturen**

* UPowerClient: Hauptstruktur des Moduls, die den Zustand des UPower-Clients verwaltet.  
  * connection: zbus::Connection (Die aktive D-Bus-Verbindung)  
  * manager\_proxy: Arc\<UPowerManagerProxy\> (Proxy für org.freedesktop.UPower)  
  * devices: Arc\<Mutex\<HashMap\<ObjectPath\<'static\>, PowerDeviceDetails\>\>\> (Speichert Details zu allen bekannten Energiegeräten, geschützt durch einen Mutex für thread-sicheren Zugriff)  
  * display\_device\_path: Arc\<Mutex\<Option\<ObjectPath\<'static\>\>\>\> (Pfad zum "Display Device")  
  * manager\_properties: Arc\<Mutex\<UPowerManagerProperties\>\> (Aktuelle Eigenschaften des UPower-Managers wie OnBattery, LidIsClosed, LidIsPresent)  
  * internal\_event\_sender: tokio::sync::broadcast::Sender\<UPowerEvent\> (Sender für interne Ereignisse)  
* UPowerManagerProperties: Speichert die Eigenschaften des org.freedesktop.UPower-Managers.  
  * daemon\_version: String  
  * on\_battery: bool  
  * lid\_is\_closed: bool  
  * lid\_is\_present: bool  
* PowerDeviceDetails (Rust-Struktur zur Abbildung von org.freedesktop.UPower.Device-Eigenschaften):  
  * object\_path: ObjectPath\<'static\>  
  * vendor: String  
  * model: String  
  * kind: PowerSupplyType (Rust Enum, das uint32 UPowerDeviceLevel abbildet: Unknown, None, LinePower, Battery, Ups, Monitor, Mouse, Keyboard, Pda, Phone, GamingInput, BluetoothGeneric, Tablet, Camera, PortableAudioPlayer, Toy, Computer, Wireless, Last)  
  * percentage: f64  
  * state: PowerDeviceState (Rust Enum, das uint32 UPowerDeviceState abbildet: Unknown, Charging, Discharging, Empty, FullyCharged, PendingCharge, PendingDischarge)  
  * time\_to\_empty: Option\<std::time::Duration\>  
  * time\_to\_full: Option\<std::time::Duration\>  
  * icon\_name: String  
  * is\_rechargeable: bool  
  * capacity: f64 (in Prozent, normalisierte Kapazität)  
  * technology: PowerDeviceTechnology (Rust Enum: Unknown, LithiumIon, LithiumPolymer, LithiumIronPhosphate, LeadAcid, NickelCadmium, NickelMetalHydride)  
  * temperature: Option\<f64\> (in Grad Celsius)  
  * serial: String  
* UPowerEvent (internes Event-Enum):  
  * DeviceAdded { path: ObjectPath\<'static\>, details: PowerDeviceDetails }  
  * DeviceRemoved { path: ObjectPath\<'static\> }  
  * DeviceUpdated { path: ObjectPath\<'static\>, details: PowerDeviceDetails }  
  * ManagerPropertiesChanged { properties: UPowerManagerProperties }

**Tabelle: UPower Interface-Datenstrukturen**

| Struct/Enum Name | Felder (Name, Rust-Typ, nullable, Mutabilität) | Beschreibung | Korrespondierendes D-Bus-Element/Konzept |
| :---- | :---- | :---- | :---- |
| UPowerClient | connection: zbus::Connection \<br\> manager\_proxy: Arc\<UPowerManagerProxy\> \<br\> devices: Arc\<Mutex\<HashMap\<ObjectPath\<'static\>, PowerDeviceDetails\>\>\> \<br\> display\_device\_path: Arc\<Mutex\<Option\<ObjectPath\<'static\>\>\>\> \<br\> manager\_properties: Arc\<Mutex\<UPowerManagerProperties\>\> \<br\> internal\_event\_sender: tokio::sync::broadcast::Sender\<UPowerEvent\> | Hauptclientstruktur, verwaltet Verbindung, Proxys und aggregierten Zustand. | Gesamte Interaktion mit UPower |
| UPowerManagerProperties | daemon\_version: String \<br\> on\_battery: bool \<br\> lid\_is\_closed: bool \<br\> lid\_is\_present: bool | Speichert die Eigenschaften des UPower-Managers. | Eigenschaften von org.freedesktop.UPower |
| PowerDeviceDetails | object\_path: ObjectPath\<'static\> \<br\> vendor: String \<br\> model: String \<br\> kind: PowerSupplyType \<br\> percentage: f64 \<br\> state: PowerDeviceState \<br\> time\_to\_empty: Option\<Duration\> \<br\> time\_to\_full: Option\<Duration\> \<br\> icon\_name: String \<br\> is\_rechargeable: bool \<br\> capacity: f64 \<br\> technology: PowerDeviceTechnology \<br\> temperature: Option\<f64\> \<br\> serial: String | Detaillierte Informationen über ein einzelnes Energiegerät. | Eigenschaften von org.freedesktop.UPower.Device |
| PowerSupplyType (Enum) | Varianten wie LinePower, Battery, etc. | Typ des Energieversorgungsgeräts. | Type Eigenschaft von org.freedesktop.UPower.Device (eine uint32) |
| PowerDeviceState (Enum) | Varianten wie Charging, Discharging, etc. | Aktueller Lade-/Entladezustand des Geräts. | State Eigenschaft von org.freedesktop.UPower.Device (eine uint32) |
| PowerDeviceTechnology (Enum) | Varianten wie LithiumIon, etc. | Technologie des Energiegeräts. | Technology Eigenschaft von org.freedesktop.UPower.Device (eine uint32) |
| UPowerEvent (Enum) | DeviceAdded, DeviceRemoved, DeviceUpdated, ManagerPropertiesChanged | Interne Ereignisse zur Signalisierung von Zustandsänderungen. | D-Bus Signale von UPower |

Die sorgfältige Definition dieser Rust-Strukturen und Enums ist entscheidend, um die über D-Bus empfangenen Daten typsicher und ergonomisch in der Rust-Umgebung zu verarbeiten. Die Verwendung von Arc\<Mutex\<...\>\> für gemeinsam genutzte Zustände wie devices und manager\_properties ist notwendig, um thread-sicheren Zugriff aus asynchronen Signal-Handlern zu gewährleisten. Der tokio::sync::broadcast::Sender ermöglicht es, interne Zustandsänderungen an andere Teile des Systems zu propagieren.

### **D. D-Bus Interface Proxys (Generiert durch zbus::proxy)**

* UPowerManagerProxy für org.freedesktop.UPower auf /org/freedesktop/UPower.  
  * Methoden:  
    * async fn enumerate\_devices(\&self) \-\> zbus::Result\<Vec\<ObjectPath\<'static\>\>\>; 6  
    * async fn get\_display\_device(\&self) \-\> zbus::Result\<ObjectPath\<'static\>\>; 6  
    * async fn get\_critical\_action(\&self) \-\> zbus::Result\<String\>; 6  
  * Eigenschaften (mittels \#\[zbus(property)\] auf Getter-Methoden):  
    * async fn daemon\_version(\&self) \-\> zbus::Result\<String\>; 6  
    * async fn on\_battery(\&self) \-\> zbus::Result\<bool\>; 6  
    * async fn lid\_is\_closed(\&self) \-\> zbus::Result\<bool\>; 6  
    * async fn lid\_is\_present(\&self) \-\> zbus::Result\<bool\>; 6  
  * Signale (mittels \#\[zbus(signal)\] auf Handler-Methoden im Trait, die dann Streams zurückgeben):  
    * async fn receive\_device\_added(\&self) \-\> zbus::Result\<zbus::SignalStream\<'\_, ObjectPath\<'static\>\>\>; (für DeviceAdded(o object\_path)) 6  
    * async fn receive\_device\_removed(\&self) \-\> zbus::Result\<zbus::SignalStream\<'\_, ObjectPath\<'static\>\>\>; (für DeviceRemoved(o object\_path)) 6  
    * 6  
* UPowerDeviceProxy für org.freedesktop.UPower.Device auf gerätespezifischen Pfaden.  
  * Eigenschaften (Beispiele, alle als async fn name(\&self) \-\> zbus::Result\<Type\>;):  
    * vendor (String)  
    * model (String)  
    * type\_ (u32) \-\> wird zu PowerSupplyType gemappt  
    * percentage (f64)  
    * state (u32) \-\> wird zu PowerDeviceState gemappt  
    * time\_to\_empty (i64) \-\> wird zu Option\<Duration\> gemappt  
    * time\_to\_full (i64) \-\> wird zu Option\<Duration\> gemappt  
    * icon\_name (String)  
    * is\_rechargeable (bool)  
    * capacity (f64)  
    * technology (u32) \-\> wird zu PowerDeviceTechnology gemappt  
    * temperature (f64) (kann nicht vorhanden sein, daher Option\<f64\>)  
    * serial (String)  
  * Signal:  
    * async fn receive\_properties\_changed(\&self) \-\> zbus::Result\<zbus::SignalStream\<'\_, PropertiesChangedArgs\>\>;  
      * PropertiesChangedArgs struct:  
        Rust  
        \#  
        pub struct PropertiesChangedArgs {  
            pub interface\_name: String,  
            pub changed\_properties: std::collections::HashMap\<String, zbus::zvariant::OwnedValue\>,  
            pub invalidated\_properties: Vec\<String\>,  
        }  
        7

**Tabelle: UPower D-Bus Proxys und Member**

| Proxy Name | D-Bus Interface | Schlüsselelemente (Methoden/Eigenschaften/Signale) | Rust Signatur (Beispiel) | Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| UPowerManagerProxy | org.freedesktop.UPower | EnumerateDevices (Methode) | async fn enumerate\_devices(\&self) \-\> zbus::Result\<Vec\<ObjectPath\<'static\>\>\> | Listet alle bekannten Energiegeräte auf. |
|  |  | GetDisplayDevice (Methode) | async fn get\_display\_device(\&self) \-\> zbus::Result\<ObjectPath\<'static\>\> | Gibt den Pfad des primären Anzeigegeräts zurück. |
|  |  | OnBattery (Eigenschaft) | \#\[zbus(property)\] async fn on\_battery(\&self) \-\> zbus::Result\<bool\> | Gibt an, ob das System im Akkubetrieb läuft. |
|  |  | LidIsClosed (Eigenschaft) | \#\[zbus(property)\] async fn lid\_is\_closed(\&self) \-\> zbus::Result\<bool\> | Gibt an, ob der Laptopdeckel geschlossen ist. |
|  |  | DeviceAdded (Signal) | \#\[zbus(signal)\] async fn device\_added(\&self, device\_path: ObjectPath\<'static\>) \-\> zbus::Result\<()\>; (Stream-Methode: receive\_device\_added) | Wird gesendet, wenn ein neues Energiegerät hinzugefügt wird. |
|  |  | DeviceRemoved (Signal) | \#\[zbus(signal)\] async fn device\_removed(\&self, device\_path: ObjectPath\<'static\>) \-\> zbus::Result\<()\>; (Stream-Methode: receive\_device\_removed) | Wird gesendet, wenn ein Energiegerät entfernt wird. |
| UPowerDeviceProxy | org.freedesktop.UPower.Device | Percentage (Eigenschaft) | \#\[zbus(property)\] async fn percentage(\&self) \-\> zbus::Result\<f64\> | Aktueller Ladestand in Prozent. |
|  |  | State (Eigenschaft) | \#\[zbus(property)\] async fn state(\&self) \-\> zbus::Result\<u32\> | Aktueller Zustand des Geräts (Laden, Entladen, etc.). |
|  |  | TimeToEmpty (Eigenschaft) | \#\[zbus(property)\] async fn time\_to\_empty(\&self) \-\> zbus::Result\<i64\> | Geschätzte verbleibende Zeit bis leer (Sekunden). |
|  |  | PropertiesChanged (Signal) | \#\[zbus(signal)\] async fn properties\_changed(\&self, interface\_name: String, changed\_properties: HashMap\<String, zvariant::OwnedValue\>, invalidated\_properties: Vec\<String\>) \-\> zbus::Result\<()\>; (Stream-Methode: receive\_properties\_changed) | Wird gesendet, wenn sich Eigenschaften des Geräts ändern. |

Diese Tabellenstruktur verdeutlicht die direkte Abbildung zwischen den D-Bus-Spezifikationen und der Rust-Proxy-Implementierung, was für Entwickler, die diese Schnittstelle nutzen oder erweitern müssen, von großem Wert ist. Die Verwendung des \#\[zbus(proxy)\]-Makros 9 automatisiert die Generierung des Boilerplate-Codes für diese Proxys erheblich.

### **E. Fehlerbehandlung**

* UPowerError Enum (definiert in system/dbus/upower\_interface/errors.rs):  
  Rust  
  use thiserror::Error;  
  use zbus::zvariant::ObjectPath;

  \#  
  pub enum UPowerError {  
      \#  
      Connection(\#\[from\] zbus::Error),

      \#  
      ServiceUnavailable,

      \#  
      MethodCall { method: String, error: zbus::Error },

      \#\[error("Invalid data received from UPower service: {context}")\]  
      InvalidData { context: String },

      \#\[error("UPower device not found at path: {path}")\]  
      DeviceNotFound { path: String }, // Früher: path: ObjectPath\<'static\> \- String ist einfacher für Display

      \#  
      SignalSubscriptionFailed { signal\_name: String, error: zbus::Error },

      \#\[error("Internal error during UPower client operation: {0}")\]  
      Internal(String),  
  }

**Tabelle: UPowerError Varianten**

| Variantenname | Beschreibung | Typischer Auslöser |
| :---- | :---- | :---- |
| Connection | Fehler beim Herstellen der D-Bus-Verbindung oder allgemeiner D-Bus-Fehler. | zbus::Connection::system().await schlägt fehl; zugrundeliegende D-Bus-Fehler von zbus. |
| ServiceUnavailable | Der UPower-Dienst (org.freedesktop.UPower) ist auf dem System-Bus nicht erreichbar. | UPower-Daemon läuft nicht oder ist nicht korrekt registriert. |
| MethodCall | Fehler beim Aufrufen einer D-Bus-Methode auf einem UPower-Interface. | Methode existiert nicht, falsche Parameter, Dienst antwortet mit Fehler. |
| InvalidData | Ungültige oder unerwartete Daten vom UPower-Dienst empfangen. | Unerwartete Variant-Typen, Enum-Werte außerhalb des definierten Bereichs. |
| DeviceNotFound | Ein spezifisches UPower-Gerät konnte unter dem erwarteten Pfad nicht gefunden werden. | GetDisplayDevice gibt einen Pfad zurück, der nicht mehr gültig ist; veraltete Gerätepfade. |
| SignalSubscriptionFailed | Fehler beim Abonnieren eines D-Bus-Signals von UPower. | Probleme mit Match-Regeln, Dienst unterstützt Signal nicht wie erwartet. |
| Internal | Ein interner Fehler im UPower-Client-Modul. | Logische Fehler in der Client-Implementierung. |

### **F. Detaillierte Implementierungsschritte**

1. **Proxy-Definitionen:** Definiere die Rust-Traits UPowerManagerProxy und UPowerDeviceProxy mit dem \#\[zbus::proxy\]-Attribut, die die Methoden, Eigenschaften und Signale der entsprechenden D-Bus-Interfaces (org.freedesktop.UPower und org.freedesktop.UPower.Device) abbilden.9  
2. **UPowerClient::connect\_and\_initialize() asynchrone Funktion:**  
   * Stelle eine Verbindung zum D-Bus System-Bus her: let connection \= zbus::Connection::system().await.map\_err(UPowerError::Connection)?;  
   * Erstelle den UPowerManagerProxy: let manager\_proxy \= Arc::new(UPowerManagerProxy::new(\&connection).await.map\_err(|e| UPowerError::MethodCall { method: "UPowerManagerProxy::new".to\_string(), error: e })?);  
   * Initialisiere devices: Arc\<Mutex\<HashMap\<ObjectPath\<'static\>, PowerDeviceDetails\>\>\> als leer.  
   * Initialisiere manager\_properties: Arc\<Mutex\<UPowerManagerProperties\>\> durch Abrufen aller Manager-Eigenschaften (daemon\_version, on\_battery, lid\_is\_closed, lid\_is\_present) über den manager\_proxy.  
   * Rufe manager\_proxy.enumerate\_devices().await auf. Für jeden zurückgegebenen ObjectPath:  
     * Erstelle einen UPowerDeviceProxy für diesen Pfad: let device\_proxy \= UPowerDeviceProxy::builder(\&connection).path(path.clone())?.build().await?;  
     * Rufe alle relevanten Eigenschaften dieses device\_proxy ab (z.B. percentage(), state(), kind(), time\_to\_empty(), time\_to\_full(), icon\_name(), vendor(), model(), etc.).  
     * Konvertiere die Rohdaten (z.B. u32 für state und kind) in die entsprechenden Rust-Enums (PowerDeviceState, PowerSupplyType). Konvertiere i64 Sekunden in Option\<Duration\>.  
     * Erstelle eine PowerDeviceDetails-Instanz und füge sie zur devices-HashMap hinzu.  
   * Rufe manager\_proxy.get\_display\_device().await auf und speichere den Pfad in display\_device\_path.  
   * Erstelle den tokio::sync::broadcast::channel für UPowerEvent.  
   * Gib eine UPowerClient-Instanz mit der Verbindung, den Proxys, dem initialen Zustand und dem Sender des Broadcast-Kanals zurück.  
3. **Signalbehandlung (in separaten tokio::spawn-Tasks oder integriert in einen Haupt-Event-Loop-Dispatcher):**  
   * **Manager-Signale:**  
     * Abonniere manager\_proxy.receive\_device\_added().await?. In der Schleife:  
       * Wenn ein DeviceAdded(path)-Signal empfangen wird: Erstelle einen neuen UPowerDeviceProxy für path, rufe alle seine Eigenschaften ab, erstelle PowerDeviceDetails, füge es zu devices (unter Mutex-Sperre) hinzu und sende ein UPowerEvent::DeviceAdded über den Broadcast-Kanal.  
     * Abonniere manager\_proxy.receive\_device\_removed().await?. In der Schleife:  
       * Wenn ein DeviceRemoved(path)-Signal empfangen wird: Entferne den Eintrag aus devices (unter Mutex-Sperre) und sende ein UPowerEvent::DeviceRemoved über den Broadcast-Kanal.  
     * Abonniere manager\_proxy.receive\_properties\_changed().await? (für Eigenschaften des Manager-Objekts selbst, wie OnBattery, LidIsClosed). In der Schleife:  
       * Aktualisiere die Felder in manager\_properties (unter Mutex-Sperre) basierend auf den changed\_properties im Signal.  
       * Sende ein UPowerEvent::ManagerPropertiesChanged über den Broadcast-Kanal.  
   * **Device-Signale (für jedes Gerät in devices):**  
     * Beim Hinzufügen eines Geräts (oder bei der Initialisierung), abonniere dessen device\_proxy.receive\_properties\_changed().await?. In der Schleife für jedes Gerät:  
       * Wenn ein PropertiesChanged-Signal für dieses Gerät empfangen wird:  
         * Extrahiere changed\_properties und invalidated\_properties aus den Signal-Argumenten.  
         * Aktualisiere die entsprechenden Felder in der PowerDeviceDetails-Instanz für dieses Gerät in der devices-HashMap (unter Mutex-Sperre). Achte auf die korrekte Deserialisierung der zbus::zvariant::OwnedValue.  
         * Sende ein UPowerEvent::DeviceUpdated mit dem Pfad und den aktualisierten Details über den Broadcast-Kanal.  
4. **Öffentliche Methoden auf UPowerClient:**  
   * fn is\_on\_battery(\&self) \-\> bool: Gibt den Wert aus self.manager\_properties zurück.  
   * fn is\_lid\_closed(\&self) \-\> bool: Gibt den Wert aus self.manager\_properties zurück.  
   * fn get\_all\_devices(\&self) \-\> Vec\<PowerDeviceDetails\>: Gibt eine Kopie der Werte aus self.devices zurück.  
   * fn get\_display\_device\_details(\&self) \-\> Option\<PowerDeviceDetails\>: Gibt die Details für das Gerät unter self.display\_device\_path zurück.  
   * fn subscribe\_events(\&self) \-\> tokio::sync::broadcast::Receiver\<UPowerEvent\>: Gibt einen neuen Empfänger für den internen Event-Kanal zurück.

### **G. Interaktionen**

* **Core Layer:** Stellt die async-Laufzeitumgebung (z.B. tokio) bereit, die für zbus und die asynchrone Signalbehandlung benötigt wird.  
* **Domain Layer:** Abonniert die von UPowerClient über den internen Event-Bus (Broadcast-Kanal) gesendeten UPowerEvent-Ereignisse. Nutzt diese Informationen, um Energiesparrichtlinien zu implementieren (z.B. Bildschirm dimmen bei niedrigem Akkustand, System in den Ruhezustand versetzen bei kritischem Akkustand, Aktionen bei geschlossenem Deckel).  
* **UI Layer:** Abonniert ebenfalls die UPowerEvent-Ereignisse. Verwendet die Informationen, um Energiestatusanzeigen (Batterie-Icon, verbleibende Zeit, Ladestatus), Warnungen und ggf. Einstellungsoptionen für Energieverwaltung darzustellen.  
* **Event Bus:** Der UPowerClient fungiert als Herausgeber von UPowerEvent-Ereignissen (DeviceAdded, DeviceRemoved, DeviceUpdated, ManagerPropertiesChanged) auf einem internen, systemweiten Event-Bus (hier implementiert mit tokio::sync::broadcast).

### **H. Vertiefende Betrachtungen & Implikationen**

Die Implementierung eines robusten UPower-Clients erfordert eine sorgfältige Handhabung von asynchronen Signalen und die korrekte Interpretation der feingranularen Eigenschaftsänderungen.  
UPower's PropertiesChanged-Signal 7 liefert detaillierte Informationen darüber, welche Eigenschaften sich geändert haben und welche ungültig geworden sind. Anstatt bei jedem Signal alle Eigenschaften eines Geräts neu abzufragen, sollte der Client die changed\_properties (ein Dictionary von Eigenschaftsnamen zu neuen Werten) und invalidated\_properties (eine Liste von Eigenschaftsnamen, deren Werte nicht mehr gültig sind) auswerten. Dies erfordert eine effiziente Aktualisierung der lokalen PowerDeviceDetails-Struktur, indem nur die betroffenen Felder modifiziert werden. Eine sorgfältige Zuordnung zwischen den D-Bus-Eigenschaftsnamen (Strings) und den Feldern der Rust-Struktur sowie eine robuste Deserialisierung der zbus::zvariant::Value-Typen sind hierbei unerlässlich. Dieser Ansatz minimiert die D-Bus-Kommunikation und verbessert die Reaktionsfähigkeit.  
Das Konzept des "Display Device" 6 unter /org/freedesktop/UPower/devices/DisplayDevice ist eine wichtige Abstraktion, die UPower für Desktop-Umgebungen bereitstellt. Es handelt sich um ein zusammengesetztes Gerät, das den Gesamtstatus der Energieversorgung repräsentiert, der typischerweise in der Benutzeroberfläche angezeigt wird. Obwohl dieses Gerät einen bequemen Zugriff auf aggregierte Informationen bietet, ist es für ein vollständiges Bild der Energieversorgung – insbesondere in Systemen mit mehreren Batterien oder komplexen Energiekonfigurationen – notwendig, dass der Client alle Geräte über EnumerateDevices erfasst und deren Zustand individuell überwacht. Die UI-Schicht wird wahrscheinlich primär das "Display Device" für ihre Hauptanzeige nutzen, aber die Systemschicht sollte über diesen Client Zugriff auf die Details aller einzelnen Geräte ermöglichen.  
Die asynchrone Natur der D-Bus-Signalbehandlung erfordert besondere Aufmerksamkeit bei der Verwaltung des gemeinsamen Zustands. Da Signale wie DeviceAdded oder PropertiesChanged für verschiedene Geräte potenziell gleichzeitig eintreffen und verarbeitet werden könnten (abhängig von der Konfiguration des async-Executors), muss der Zugriff auf gemeinsam genutzte Datenstrukturen wie die Liste der Geräte (devices in UPowerClient) synchronisiert werden. Die Verwendung von Arc\<Mutex\<...\>\> ist hier ein gängiges Muster in Rust, um Datenkorruption oder inkonsistente Lesezugriffe zu verhindern. Die internen Ereignisse, die dieses Modul über den Broadcast-Kanal aussendet, sollten entweder unveränderliche Momentaufnahmen der Daten transportieren, oder die Abonnenten dieser Ereignisse müssen ebenfalls für eine korrekte Synchronisation sorgen, falls sie auf gemeinsam genutzte Zustände zugreifen, die durch diese Ereignisse modifiziert werden könnten.

## **V. Ultra-Feinspezifikation: system::dbus::logind\_interface (Logind D-Bus Client)**

### **A. Modulübersicht und Zweck**

* **Verantwortlichkeit:** Dieses Modul interagiert mit den D-Bus-Diensten org.freedesktop.login1.Manager und org.freedesktop.login1.Session. Es überwacht Benutzersitzungen, den Status von "Seats" (logische Gruppierungen von Eingabe-/Ausgabegeräten) und Systemereignisse wie das Vorbereiten des Ruhezustands (PrepareForSleep) und das Aufwachen.  
* **Funktionen:** Es ermöglicht der Desktop-Umgebung, auf das Sperren/Entsperren von Sitzungen, Benutzerwechsel und das Vorbereiten des Systems auf den Ruhezustand zu reagieren. Es kann auch Aktionen wie das Anfordern einer Sitzungssperre initiieren.  
* **Relevante Referenzmaterialien & Analyse:**  
  * 12 (logind man page Übersicht), 13 (logind Manager Methoden), 13 (logind Manager Methoden/Signale): Geben einen Überblick über die org.freedesktop.login1.Manager-Schnittstelle, einschließlich Methoden wie GetSession, ListSessions, LockSession, UnlockSession, Inhibit und Signale wie SessionNew, SessionRemoved, PrepareForSleep.  
  * 14 (SessionNew/SessionRemoved Signale), 15 (PrepareForSleep Signal), 16 (Lock/Unlock Signale auf Session-Objekt): Spezifische Details zu wichtigen Signalen. Die Analyse dieser Quellen zeigt, dass dieses Modul zbus für die Interaktion mit logind nutzen wird. Zentrale Aspekte sind das Verfolgen der aktiven Sitzung, das Reagieren auf das PrepareForSleep-Signal zur Durchführung notwendiger Aktionen vor dem Suspend (und das zuverlässige Freigeben von Inhibit-Locks) sowie das Reagieren auf Lock/Unlock-Signale zur Steuerung des Sitzungszustands (z.B. Aktivierung des Sperrbildschirms).

### **B. Entwicklungs-Submodule & Dateien**

* **1\. system::dbus::logind\_interface::client**  
  * Dateien: system/dbus/logind\_interface/client.rs  
  * Verantwortlichkeiten: Hauptlogik des Logind-Clients, D-Bus-Verwaltung, Proxy-Interaktionen, Signalbehandlung.  
* **2\. system::dbus::logind\_interface::types**  
  * Dateien: system/dbus/logind\_interface/types.rs  
  * Verantwortlichkeiten: Definition von Rust-Strukturen und \-Enums zur Abbildung von Logind-Daten (z.B. SessionInfo, ActiveSessionState, SleepPreparationState).  
* **3\. system::dbus::logind\_interface::errors**  
  * Dateien: system/dbus/logind\_interface/errors.rs  
  * Verantwortlichkeiten: Definition des LogindError-Enums.

### **C. Schlüsseldatenstrukturen**

* LogindClient: Hauptstruktur des Moduls.  
  * connection: zbus::Connection  
  * manager\_proxy: Arc\<LogindManagerProxy\> (Proxy für org.freedesktop.login1.Manager)  
  * active\_session\_id: Arc\<Mutex\<Option\<String\>\>\> (ID der aktuellen aktiven Sitzung)  
  * active\_session\_path: Arc\<Mutex\<Option\<ObjectPath\<'static\>\>\>\>  
  * active\_session\_proxy: Arc\<Mutex\<Option\<LogindSessionProxy\>\>\> (Proxy für die aktive org.freedesktop.login1.Session)  
  * sleep\_inhibitor\_lock: Arc\<Mutex\<Option\<zbus::zvariant::OwnedFd\>\>\> (File Descriptor für den Sleep-Inhibitor-Lock)  
  * internal\_event\_sender: tokio::sync::broadcast::Sender\<LogindEvent\>  
* SessionInfo: Repräsentiert Informationen über eine Benutzersitzung.  
  * id: String  
  * user\_id: u32  
  * user\_name: String  
  * seat\_id: String  
  * object\_path: ObjectPath\<'static\>  
  * is\_active: bool  
  * is\_locked\_hint: bool (Basierend auf der LockedHint-Eigenschaft der Session)  
* LogindEvent (internes Event-Enum):  
  * PrepareForSleep { starting: bool }  
  * ActiveSessionLocked  
  * ActiveSessionUnlocked  
  * ActiveSessionChanged { new\_session\_id: Option\<String\> }  
  * SessionListChanged { sessions: Vec\<SessionInfo\> }

**Tabelle: Logind Interface-Datenstrukturen**

| Struct/Enum Name | Felder (Name, Rust-Typ, nullable, Mutabilität) | Beschreibung | Korrespondierendes D-Bus-Element/Konzept |
| :---- | :---- | :---- | :---- |
| LogindClient | connection: zbus::Connection \<br\> manager\_proxy: Arc\<LogindManagerProxy\> \<br\> active\_session\_id: Arc\<Mutex\<Option\<String\>\>\> \<br\> active\_session\_path: Arc\<Mutex\<Option\<ObjectPath\<'static\>\>\>\> \<br\> active\_session\_proxy: Arc\<Mutex\<Option\<LogindSessionProxy\>\>\> \<br\> sleep\_inhibitor\_lock: Arc\<Mutex\<Option\<zbus::zvariant::OwnedFd\>\>\> \<br\> internal\_event\_sender: tokio::sync::broadcast::Sender\<LogindEvent\> | Hauptclientstruktur, verwaltet Verbindung, Proxys, aktive Sitzungsinformationen und Inhibit-Locks. | Gesamte Interaktion mit Logind |
| SessionInfo | id: String \<br\> user\_id: u32 \<br\> user\_name: String \<br\> seat\_id: String \<br\> object\_path: ObjectPath\<'static\> \<br\> is\_active: bool \<br\> is\_locked\_hint: bool | Detaillierte Informationen über eine einzelne Benutzersitzung. | Struktur der Rückgabewerte von ListSessions und Eigenschaften von org.freedesktop.login1.Session |
| LogindEvent (Enum) | PrepareForSleep { starting: bool } \<br\> ActiveSessionLocked \<br\> ActiveSessionUnlocked \<br\> ActiveSessionChanged {... } \<br\> SessionListChanged {... } | Interne Ereignisse zur Signalisierung von Zustandsänderungen im Logind-Kontext. | D-Bus Signale von Logind (PrepareForSleep, Lock, Unlock auf Session-Objekt, SessionNew, SessionRemoved) |

Die LogindClient-Struktur kapselt die gesamte Logik für die Interaktion mit logind. Die active\_session\_id und der zugehörige Proxy sind zentral, da viele Aktionen sitzungsspezifisch sind. Der sleep\_inhibitor\_lock ist kritisch für die korrekte Handhabung von Suspend-Zyklen.

### **D. D-Bus Interface Proxys (Generiert durch zbus::proxy)**

* LogindManagerProxy für org.freedesktop.login1.Manager auf /org/freedesktop/login1.  
  * Methoden:  
    * async fn get\_session(\&self, session\_id: \&str) \-\> zbus::Result\<ObjectPath\<'static\>\>; 12  
    * async fn list\_sessions(\&self) \-\> zbus::Result\<Vec\<(String, u32, String, String, ObjectPath\<'static\>)\>\>; (session\_id, uid, user\_name, seat\_id, object\_path) 13  
    * async fn lock\_session(\&self, session\_id: \&str) \-\> zbus::Result\<()\>; 13  
    * async fn unlock\_session(\&self, session\_id: \&str) \-\> zbus::Result\<()\>; 13  
    * async fn inhibit(\&self, what: \&str, who: \&str, why: \&str, mode: \&str) \-\> zbus::Result\<zbus::zvariant::OwnedFd\>; (z.B. what: "sleep:shutdown:idle", who: "Desktop Environment", why: "Saving state", mode: "delay") 13  
  * Signale:  
    * async fn receive\_session\_new(\&self) \-\> zbus::Result\<zbus::SignalStream\<'\_, SessionNewArgs\>\>; (struct SessionNewArgs { session\_id: String, object\_path: ObjectPath\<'static\> }) 14  
    * async fn receive\_session\_removed(\&self) \-\> zbus::Result\<zbus::SignalStream\<'\_, SessionRemovedArgs\>\>; (struct SessionRemovedArgs { session\_id: String, object\_path: ObjectPath\<'static\> }) 14  
    * async fn receive\_prepare\_for\_sleep(\&self) \-\> zbus::Result\<zbus::SignalStream\<'\_, bool\>\>; (start: bool) 15  
* LogindSessionProxy für org.freedesktop.login1.Session auf sitzungsspezifischen Pfaden.  
  * Eigenschaften:  
    * \#\[zbus(property)\] async fn active(\&self) \-\> zbus::Result\<bool\>;  
    * \#\[zbus(property)\] async fn locked\_hint(\&self) \-\> zbus::Result\<bool\>;  
    * \#\[zbus(property)\] async fn id(\&self) \-\> zbus::Result\<String\>;  
    * \#\[zbus(property)\] async fn user(\&self) \-\> zbus::Result\<(u32, ObjectPath\<'static\>)\>; (uid, user\_path)  
    * \#\[zbus(property)\] async fn seat(\&self) \-\> zbus::Result\<(String, ObjectPath\<'static\>)\>; (seat\_id, seat\_path)  
  * Signale (die der Session-Manager der DE abhört, nicht unbedingt dieser Client direkt, aber relevant für das Verständnis):  
    * Lock() 16  
    * Unlock() 16

**Tabelle: Logind D-Bus Proxys und Member**

| Proxy Name | D-Bus Interface | Schlüsselelemente (Methoden/Eigenschaften/Signale) | Rust Signatur (Beispiel) | Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| LogindManagerProxy | org.freedesktop.login1.Manager | ListSessions (Methode) | async fn list\_sessions(\&self) \-\> zbus::Result\<Vec\<(String, u32, String, String, ObjectPath\<'static\>)\>\> | Listet alle aktuellen Benutzersitzungen auf. |
|  |  | LockSession (Methode) | async fn lock\_session(\&self, session\_id: \&str) \-\> zbus::Result\<()\> | Fordert das Sperren einer bestimmten Sitzung an. |
|  |  | Inhibit (Methode) | async fn inhibit(\&self, what: \&str, who: \&str, why: \&str, mode: \&str) \-\> zbus::Result\<zbus::zvariant::OwnedFd\> | Nimmt einen Inhibit-Lock, um Systemaktionen (z.B. Suspend) zu verzögern. |
|  |  | SessionNew (Signal) | \#\[zbus(signal)\] async fn session\_new(\&self, session\_id: String, object\_path: ObjectPath\<'static\>) \-\> zbus::Result\<()\>; | Wird gesendet, wenn eine neue Sitzung erstellt wird. |
|  |  | PrepareForSleep (Signal) | \#\[zbus(signal)\] async fn prepare\_for\_sleep(\&self, start: bool) \-\> zbus::Result\<()\>; | Wird gesendet, bevor das System in den Ruhezustand geht oder nachdem es aufwacht. |
| LogindSessionProxy | org.freedesktop.login1.Session | Active (Eigenschaft) | \#\[zbus(property)\] async fn active(\&self) \-\> zbus::Result\<bool\>; | Gibt an, ob die Sitzung aktiv ist. |
|  |  | LockedHint (Eigenschaft) | \#\[zbus(property)\] async fn locked\_hint(\&self) \-\> zbus::Result\<bool\>; | Gibt an, ob die Sitzung als gesperrt markiert ist. |
|  |  | Lock (Signal) | \#\[zbus(signal)\] async fn lock(\&self) \-\> zbus::Result\<()\>; | Signalisiert, dass die Sitzung gesperrt werden soll (wird vom Session-Manager empfangen). |

### **E. Fehlerbehandlung**

* LogindError Enum (definiert in system/dbus/logind\_interface/errors.rs):  
  Rust  
  use thiserror::Error;  
  use zbus::zvariant::OwnedObjectPath; // Korrigiert von ObjectPath zu OwnedObjectPath für SignalArgs

  \#  
  pub enum LogindError {  
      \#  
      Connection(\#\[from\] zbus::Error),

      \#  
      ServiceUnavailable,

      \#  
      MethodCall { method: String, error: zbus::Error },

      \#  
      SessionNotFound { session\_id: String },

      \#\[error("Failed to take inhibitor lock from logind: {reason}")\]  
      InhibitFailed { reason: String },

      \#\[error("No active session found for this desktop environment.")\]  
      NoActiveSession,

      \#  
      SignalSubscriptionFailed { signal\_name: String, error: zbus::Error },

      \#\[error("Internal error during logind client operation: {0}")\]  
      Internal(String),  
  }

**Tabelle: LogindError Varianten**

| Variantenname | Beschreibung | Typischer Auslöser |
| :---- | :---- | :---- |
| Connection | Fehler beim Herstellen der D-Bus-Verbindung oder allgemeiner D-Bus-Fehler. | zbus::Connection::system().await schlägt fehl. |
| ServiceUnavailable | Der Logind-Dienst ist auf dem System-Bus nicht erreichbar. | systemd-logind läuft nicht oder ist nicht korrekt registriert. |
| MethodCall | Fehler beim Aufrufen einer D-Bus-Methode auf einem Logind-Interface. | Methode existiert nicht, falsche Parameter, Dienst antwortet mit Fehler. |
| SessionNotFound | Eine Sitzung mit der angegebenen ID konnte nicht gefunden werden. | LockSession mit einer ungültigen ID aufgerufen. |
| InhibitFailed | Fehler beim Anfordern eines Inhibit-Locks von Logind. | Logind verweigert den Lock (z.B. keine Berechtigung, ungültige Parameter). |
| NoActiveSession | Es konnte keine aktive Sitzung für die laufende Desktop-Umgebung identifiziert werden. | Fehler bei der Logik zur Erkennung der aktiven Sitzung. |
| SignalSubscriptionFailed | Fehler beim Abonnieren eines D-Bus-Signals von Logind. | Probleme mit Match-Regeln. |
| Internal | Ein interner Fehler im Logind-Client-Modul. | Logische Fehler in der Client-Implementierung. |

### **F. Detaillierte Implementierungsschritte**

1. **Proxy-Definitionen:** Definiere die Rust-Traits LogindManagerProxy und LogindSessionProxy mit dem \#\[zbus::proxy\]-Attribut für die D-Bus-Interfaces org.freedesktop.login1.Manager und org.freedesktop.login1.Session.  
2. **LogindClient::connect\_and\_initialize() asynchrone Funktion:**  
   * Stelle Verbindung zum D-Bus System-Bus her und erstelle LogindManagerProxy.  
   * Identifiziere die aktive Sitzung:  
     * Rufe manager\_proxy.list\_sessions().await auf.  
     * Iteriere durch die Liste der Sessions. Für jede Session, erstelle temporär einen LogindSessionProxy für deren ObjectPath.  
     * Rufe die active().await-Eigenschaft auf diesem Session-Proxy ab.  
     * Die erste Session mit active \== true (und idealerweise passendem seat\_id, falls bekannt) wird als die aktive Sitzung betrachtet. Speichere deren session\_id, object\_path und den LogindSessionProxy in den Arc\<Mutex\<...\>\>-Feldern von LogindClient.  
     * Wenn keine aktive Sitzung gefunden wird, gib LogindError::NoActiveSession zurück.  
   * Erstelle den tokio::sync::broadcast::channel für LogindEvent.  
   * Gib eine LogindClient-Instanz zurück.  
3. **Signalbehandlung (in separaten tokio::spawn-Tasks):**  
   * **PrepareForSleep-Signal:**  
     * Abonniere manager\_proxy.receive\_prepare\_for\_sleep().await?.  
     * In der Signal-Schleife:  
       * Wenn start \== true (System bereitet sich auf Suspend vor):  
         * Versuche, einen Inhibit-Lock zu nehmen: let fd \= manager\_proxy.inhibit("sleep", "MyDesktopEnvironment", "Preparing for sleep", "delay").await.map\_err(|e| LogindError::InhibitFailed { reason: e.to\_string() })?;  
         * Speichere den OwnedFd (File Descriptor) in sleep\_inhibitor\_lock (unter Mutex-Sperre).  
         * Sende LogindEvent::PrepareForSleep { starting: true } über den Broadcast-Kanal.  
         * (Die Domänen-/UI-Schicht muss auf dieses Event reagieren und ihre Vorbereitungen treffen. Nach Abschluss oder Timeout muss ein Mechanismus existieren, um den Inhibit-Lock freizugeben.)  
       * Wenn start \== false (System wacht auf):  
         * Gib den Inhibit-Lock frei, falls einer gehalten wird: if let Some(fd) \= self.sleep\_inhibitor\_lock.lock().await.take() { drop(fd); } (Das drop auf OwnedFd schließt den FD und gibt den Lock frei).  
         * Sende LogindEvent::PrepareForSleep { starting: false } über den Broadcast-Kanal.  
   * **SessionNew / SessionRemoved-Signale:**  
     * Abonniere manager\_proxy.receive\_session\_new().await? und manager\_proxy.receive\_session\_removed().await?.  
     * Bei Empfang: Aktualisiere die interne Liste der bekannten Sitzungen (falls eine solche geführt wird, ansonsten primär für die ActiveSessionChanged-Logik relevant). Prüfe, ob sich die aktive Sitzung geändert hat. Wenn ja, aktualisiere active\_session\_id, active\_session\_path, active\_session\_proxy und sende LogindEvent::ActiveSessionChanged. Sende auch LogindEvent::SessionListChanged.  
   * **Lock / Unlock-Signale der aktiven Session (optional, falls die DE nicht selbst der Session-Manager ist, der diese direkt verarbeitet):**  
     * Wenn ein active\_session\_proxy vorhanden ist, abonniere dessen receive\_lock\_signal().await? und receive\_unlock\_signal().await? (falls diese Signale vom LogindSessionProxy so generiert werden; alternativ PropertiesChanged für LockedHint überwachen).  
     * Bei Lock-Signal: Sende LogindEvent::ActiveSessionLocked.  
     * Bei Unlock-Signal: Sende LogindEvent::ActiveSessionUnlocked.  
     * Bei PropertiesChanged auf LockedHint der aktiven Session: Entsprechend ActiveSessionLocked/Unlocked senden.  
4. **Öffentliche Methoden auf LogindClient:**  
   * async fn request\_lock\_active\_session(\&self) \-\> Result\<(), LogindError\>:  
     * Rufe die active\_session\_id ab (unter Mutex-Sperre).  
     * Wenn vorhanden, rufe self.manager\_proxy.lock\_session(\&session\_id).await.  
   * async fn request\_unlock\_active\_session(\&self) \-\> Result\<(), LogindError\>:  
     * Analog zu request\_lock\_active\_session mit unlock\_session.  
   * fn subscribe\_events(\&self) \-\> tokio::sync::broadcast::Receiver\<LogindEvent\>: Gibt einen neuen Empfänger für den internen Event-Kanal zurück.  
   * fn release\_sleep\_inhibitor(\&self): Methode, die von anderen Teilen des Systems aufgerufen werden kann, um den Sleep-Inhibitor explizit freizugeben, nachdem die Vorbereitungen für den Suspend abgeschlossen sind.

### **G. Interaktionen**

* **Core Layer:** Stellt die async-Laufzeitumgebung und FD-Handling-Fähigkeiten bereit (für den Inhibit-Lock).  
* **Domain Layer:** Empfängt LogindEvent::PrepareForSleep, um Zustände zu speichern oder laufende Operationen zu pausieren. Reagiert auf ActiveSessionLocked/Unlocked für Policy-Anpassungen (z.B. Deaktivierung bestimmter Hintergrunddienste).  
* **UI Layer:** Empfängt ActiveSessionLocked/Unlocked, um den Sperrbildschirm anzuzeigen/auszublenden oder andere UI-Anpassungen vorzunehmen. Kann request\_lock\_active\_session aufrufen.  
* **Event Bus:** Der LogindClient gibt LogindEvent-Ereignisse (PrepareForSleep, ActiveSessionLocked, ActiveSessionUnlocked, ActiveSessionChanged, SessionListChanged) auf einem internen Event-Bus aus.

### **H. Vertiefende Betrachtungen & Implikationen**

Die korrekte Handhabung von Inhibit-Locks im Kontext des PrepareForSleep-Signals ist für die Systemstabilität von entscheidender Bedeutung. Wenn die Desktop-Umgebung einen solchen Lock nimmt, um sich auf den Suspend-Vorgang vorzubereiten (z.B. durch Speichern von Zuständen, sicheres Beenden von Anwendungen, Dimmen des Bildschirms), muss dieser Lock unbedingt wieder freigegeben werden, sobald diese Vorbereitungen abgeschlossen sind oder ein definierter Timeout erreicht ist. Ein nicht freigegebener Inhibit-Lock kann den Suspend- oder Shutdown-Vorgang des gesamten Systems blockieren.13 Die Implementierung muss daher sicherstellen, dass der durch manager\_proxy.inhibit(...) erhaltene File Deskriptor zuverlässig geschlossen wird, auch im Fehlerfall oder bei einem unerwarteten Beenden der Desktop-Komponente. Dies erfordert eine robuste Fehlerbehandlung und möglicherweise den Einsatz von RAII-Mustern (Resource Acquisition Is Initialization), um sicherzustellen, dass der OwnedFd beim Verlassen des Gültigkeitsbereichs automatisch geschlossen wird.  
Die Unterscheidung zwischen dem *Anfordern* einer Sitzungssperre und dem tatsächlichen *gesperrten Zustand* der Sitzung ist ebenfalls wichtig. logind selbst sperrt den Bildschirm nicht direkt. Die Methode LockSession auf dem Manager-Objekt bewirkt, dass logind ein Lock-Signal an das entsprechende Session-Objekt sendet.13 Der Session-Manager, der typischerweise Teil der Desktop-Umgebung ist (oft in der UI-Schicht angesiedelt), lauscht auf dieses Lock-Signal auf seinem *eigenen* Session-D-Bus-Objekt. Nach Empfang dieses Signals ist der Session-Manager dafür verantwortlich, den Sperrbildschirm zu aktivieren. Sobald der Sperrbildschirm aktiv ist, sollte der Session-Manager logind darüber informieren, indem er die Eigenschaft LockedHint des Session-Objekts auf true setzt. Dieses Modul (system::dbus::logind\_interface) kann primär dafür zuständig sein, Sperr- und Entsperranforderungen über die Manager-Methoden zu initiieren und das PrepareForSleep-Signal zu überwachen. Die eigentliche UI des Sperrbildschirms und das Setzen von LockedHint wären Aufgaben der UI-Schicht, obwohl dieses Modul Änderungen der LockedHint-Eigenschaft der aktiven Sitzung überwachen könnte, um ein vollständiges Bild des Sitzungszustands zu erhalten.  
Die zuverlässige Identifizierung und Verfolgung der "aktiven" Sitzung ist eine weitere Herausforderung. Ein System kann mehrere Benutzersitzungen gleichzeitig haben (z.B. durch Fast User Switching oder Remote-Logins). Die Desktop-Umgebung läuft jedoch typischerweise innerhalb einer einzigen "aktiven" grafischen Sitzung. Viele logind-Operationen sind sitzungsspezifisch und erfordern eine Session-ID. Das logind\_interface-Modul muss daher zuverlässig die Session-ID ermitteln, die zur aktuell laufenden Desktop-Umgebung gehört. Dies kann durch Aufrufen von ListSessions und Überprüfen der Active-Eigenschaft jedes Session-Objekts geschehen.12 Alternativ, wenn die Desktop-Umgebung ihre eigene Session-ID kennt (z.B. aus Umgebungsvariablen, die von pam\_systemd gesetzt wurden), kann sie diese direkt verwenden. Das Modul muss auch Änderungen der aktiven Sitzung behandeln können, falls Funktionen wie Benutzerwechsel unterstützt werden sollen.

## **VI. Schlussfolgerung für Systemschicht (Teil 3/4)**

Die in diesem Teil spezifizierten Module – system::outputs::output\_manager, system::outputs::power\_manager, system::dbus::upower\_interface und system::dbus::logind\_interface – bilden wesentliche Komponenten der Systemschicht. Sie ermöglichen eine detaillierte Steuerung und Überwachung der Display-Hardware sowie die Integration mit grundlegenden Systemdiensten für Energieverwaltung und Sitzungsmanagement.  
Die dargelegten Ultra-Feinspezifikationen folgen dem Prinzip höchster Präzision und Detailgenauigkeit. Sie definieren exakte Schnittstellen, Datenstrukturen, Methoden-Signaturen, Fehlerbehandlungspfade und Interaktionsmuster. Ziel war es, einen direkten Implementierungsleitfaden für Entwickler bereitzustellen, der die Notwendigkeit eigener architektonischer oder logischer Entwurfsentscheidungen minimiert und eine konsistente und robuste Implementierung sicherstellt. Die sorgfältige Beachtung der Atomarität bei Konfigurationsänderungen, die Synchronisation von Zuständen mit externen Diensten und die robuste Fehlerbehandlung sind wiederkehrende Themen, die für die Stabilität der gesamten Desktop-Umgebung von entscheidender Bedeutung sind.  
Der nächste und letzte Teil der Systemschichtspezifikationen (Teil 4/4) wird sich mit weiteren kritischen Aspekten befassen, darunter die XWayland-Integration, die Implementierung von XDG Desktop Portals und die Audio-Management-Schnittstelle, um die Funktionalität der Systemschicht zu vervollständigen.

# **Technische Gesamtspezifikation und Entwicklungsrichtlinien: Systemschicht Teil 4/4**

Dieses Dokument ist die Fortsetzung der detaillierten Spezifikation der Systemschicht und behandelt die Module system::audio, system::mcp und system::portals.

## **5\. system::audio \- PipeWire Client-Integration**

Das Modul system::audio ist die maßgebliche Komponente für alle audiobezogenen Operationen innerhalb der Desktop-Umgebung. Es nutzt das PipeWire Multimedia-Framework, um Audiogeräte (Sinks und Quellen), Lautstärke- und Stummschaltungszustände sowohl für Geräte als auch für Anwendungsströme zu verwalten und auf audiobezogene Systemereignisse zu reagieren. Dieses Modul agiert als PipeWire-Client und abstrahiert die Komplexität der PipeWire C-API durch die pipewire-rs Rust-Bindings.  
Die zentrale Designphilosophie dieses Moduls ist die Zentralisierung der gesamten PipeWire-Interaktionslogik, um eine saubere, übergeordnete API für andere Teile der Desktop-Umgebung bereitzustellen. Es basiert auf einer ereignisgesteuerten Architektur, die asynchron auf PipeWire-Ereignisse (Geräteänderungen, Stream-Status, Lautstärkeaktualisierungen) lauscht und diese in interne Systemereignisse übersetzt, die von der UI- und Domänenschicht konsumiert werden können. Eine robuste Fehlerbehandlung wird durch die Verwendung von thiserror für spezifische AudioError-Typen gewährleistet, die klar zwischen PipeWire-spezifischen Problemen und internen Logikfehlern unterscheiden.  
Die Architektur von PipeWire 1 dreht sich um eine MainLoop, einen Context, einen Core und eine Registry. Client-Anwendungen entdecken und interagieren mit entfernten Objekten (Nodes, Devices, Streams) über Proxys, die von der Registry bezogen werden. Die Ereignisbehandlung ist callback-basiert. Die Desktop-Umgebung muss sich dynamisch an Änderungen in der Audiolandschaft anpassen, beispielsweise beim Anschließen eines USB-Headsets oder wenn eine Anwendung die Audiowiedergabe startet oder stoppt. Dies erfordert eine kontinuierliche Überwachung des PipeWire-Status. Das Registry-Objekt sendet global- und global\_remove-Ereignisse für Objekte, die erscheinen oder verschwinden.4 Einzelne Objekte (Proxys für Nodes, Devices) senden Ereignisse für Eigenschaftsänderungen, z.B. param\_changed für Lautstärke/Stummschaltung eines Nodes.15 Die pipewire-rs Bibliothek stellt idiomatische Rust-Wrapper für diese Konzepte bereit.1 Beispiele wie 9 demonstrieren die Initialisierung der Main Loop, des Context, des Core, der Registry und das Hinzufügen von Listenern. Daraus folgt, dass system::audio seine eigene PipeWire MainLoop verwalten muss. Diese Schleife wird wahrscheinlich in einem dedizierten Thread ausgeführt, um ein Blockieren der Hauptereignisschleife der Desktop-Umgebung (z.B. Calloop) zu vermeiden. Asynchrone Kommunikationskanäle (wie tokio::sync::mpsc und tokio::sync::broadcast) werden verwendet, um Befehle und Ereignisse zwischen dem PipeWire-Thread und dem Rest des Systems zu überbrücken. Dies steht im Einklang mit den Multithreading-Richtlinien von pipewire-rs.1  
Die Lautstärkeregelung in PipeWire kann nuanciert sein und entweder Props auf einem Node (oft für Software-/Stream-Lautstärken) oder Route-Parameter auf einem Device (für Hardware-/Master-Lautstärken) betreffen. Benutzer erwarten, sowohl die Master-Ausgabelautstärke als auch die Lautstärke pro Anwendung steuern zu können. Kommandozeilenwerkzeuge wie pw-cli und wpctl demonstrieren das Setzen von channelVolumes über Props auf einem Node 26 oder über Route-Parameter auf einem Device.26 Die Parameter SPA\_PARAM\_Props und SPA\_PARAM\_Route sind zentrale PipeWire-Parameter (SPA \- Simple Plugin API). Die Methode Node::set\_param von pipewire-rs wird verwendet, was die Konstruktion von SpaPod-Objekten für diese Parameter erfordert.15 Das Modul system::audio muss daher zwischen der Steuerung der Master-Lautstärke des Geräts und der Lautstärke des Anwendungsstroms unterscheiden und die entsprechenden PipeWire-Objekte und \-Parameter verwenden. Lautstärkewerte erfordern oft eine kubische Skalierung für eine lineare Benutzerwahrnehmung.  
**Modulstruktur und Dateien:**

* system/audio/mod.rs: Öffentliche API des Audio-Moduls, Definition der AudioError Enum.  
* system/audio/client.rs: Kernstruktur PipeWireClient, verwaltet PipeWire-Verbindung, Hauptschleife, Ereignis-/Befehlskanäle.  
* system/audio/manager.rs: Handhabt die Erkennung, Verfolgung und Eigenschaftsaktualisierungen von AudioDevice- und StreamInfo-Objekten über Registry- und Proxy-Ereignisse.  
* system/audio/control.rs: Implementiert Logik für Lautstärke-/Stummschaltungsbefehle, Konstruktion von SpaPods und Aufruf von set\_param.  
* system/audio/types.rs: Definiert AudioDevice, StreamInfo, AudioEvent, AudioCommand, AudioDeviceType, Volume, etc.  
* system/audio/spa\_pod\_utils.rs: Hilfsfunktionen zur Konstruktion komplexer SpaPod-Objekte für Lautstärke, Stummschaltung und potenziell andere Parameter.  
* system/audio/error.rs: Fehlerbehandlung für das Audio-Modul.

### **5.3.1. Submodul: system::audio::client \- PipeWire Verbindungs- und Ereignisschleifenmanagement**

* **Datei:** system/audio/client.rs  
* **Zweck:** Dieses Submodul ist verantwortlich für die Verwaltung der Low-Level-Verbindung zu PipeWire. Es startet und unterhält die PipeWire-Haupt-Ereignisschleife in einem dedizierten Thread und dient als Brücke für die Weiterleitung von Befehlen an das PipeWire-System und die Verteilung von PipeWire-Ereignissen an andere Teile des Audio-Moduls.

#### **5.3.1.1. Strukuren**

* pub struct PipeWireClient:  
  * core: std::sync::Arc\<pipewire::Core\>: Ein Proxy zum PipeWire-Core, der die Hauptverbindung zum PipeWire-Daemon darstellt. Wird als Arc gehalten, um sicher zwischen Threads geteilt zu werden.  
  * mainloop\_thread\_handle: Option\<std::thread::JoinHandle\<()\>\>: Ein Handle für den dedizierten OS-Thread, in dem die PipeWire-Hauptereignisschleife läuft. Wird beim Beenden des Clients zum sauberen Herunterfahren des Threads verwendet.  
  * command\_sender: tokio::sync::mpsc::Sender\<AudioCommand\>: Ein asynchroner Sender zum Übermitteln von AudioCommands von anderen Teilen des Systems (z.B. UI-Interaktionen) an den PipeWire-Loop-Thread.  
  * internal\_event\_sender: tokio::sync::mpsc::Sender\<InternalAudioEvent\>: Ein interner Sender, der von Worker-Tasks innerhalb dieses Moduls (z.B. Registry-Listener) verwendet wird, um rohe PipeWire-Ereignisse an den Hauptverarbeitungslogik-Task im PipeWire-Thread zu senden.  
  * Initialwerte: core und registry werden während der Initialisierung gesetzt. mainloop\_thread\_handle ist anfangs None und wird nach dem Starten des Threads gesetzt. Die Sender werden beim Erstellen der Kanäle initialisiert.  
  * Invarianten: core und registry müssen immer gültig sein, solange der mainloop\_thread\_handle Some ist.  
* struct PipeWireLoopData: Diese Struktur kapselt alle Daten, die innerhalb des dedizierten PipeWire-Loop-Threads benötigt werden.  
  * core: std::sync::Arc\<pipewire::Core\>: Geteilter Zugriff auf den PipeWire Core.  
  * registry: std::sync::Arc\<pipewire::Registry\>: Geteilter Zugriff auf die PipeWire Registry.  
  * audio\_event\_broadcaster: tokio::sync::broadcast::Sender\<AudioEvent\>: Ein Sender zum Verteilen von aufbereiteten AudioEvents an alle interessierten Listener im System (z.B. UI-Komponenten).  
  * command\_receiver: tokio::sync::mpsc::Receiver\<AudioCommand\>: Empfängt Befehle, die an das Audio-System gesendet werden.  
  * internal\_event\_receiver: tokio::sync::mpsc::Receiver\<InternalAudioEvent\>: Empfängt interne Ereignisse von PipeWire-Callbacks.  
  * active\_devices: std::collections::HashMap\<u32, MonitoredDevice\>: Eine Map zur Verfolgung der aktuell aktiven Audiogeräte (Nodes oder Devices), ihrer Proxys, Eigenschaften und Listener-Hooks. Der Key ist die PipeWire Global ID.  
  * active\_streams: std::collections::HashMap\<u32, MonitoredStream\>: Eine Map zur Verfolgung aktiver Audio-Streams (Nodes mit Anwendungsbezug). Der Key ist die PipeWire Global ID.  
  * default\_sink\_id: Option\<u32\>: Die ID des aktuellen Standard-Audioausgabegeräts.  
  * default\_source\_id: Option\<u32\>: Die ID des aktuellen Standard-Audioeingabegeräts.  
  * pipewire\_mainloop: pipewire::MainLoop: Die PipeWire-Hauptereignisschleife.  
  * pipewire\_context: pipewire::Context: Der PipeWire-Kontext.  
  * metadata\_proxy: Option\<std::sync::Arc\<pipewire::metadata::Metadata\>\>: Proxy zum PipeWire Metadaten-Objekt, um Standardgeräte zu setzen/lesen.  
  * metadata\_listener\_hook: Option\<pipewire::spa::SpaHook\>: Listener für Änderungen am Metadaten-Objekt.  
* struct MonitoredDevice: Repräsentiert ein überwachtes Audiogerät.  
  * proxy: std::sync::Arc\<dyn pipewire::proxy::ProxyT \+ Send \+ Sync\>: Ein generischer Proxy, der entweder ein pw::node::Node oder pw::device::Device sein kann, abhängig davon, wie die Lautstärke/Stummschaltung gesteuert wird (Props vs. Route).  
  * proxy\_id: u32: Die ID des Proxy-Objekts.  
  * global\_id: u32: Die globale ID des PipeWire-Objekts.  
  * properties: pipewire::spa::SpaDict: Die zuletzt bekannten Eigenschaften des Geräts.  
  * param\_listener\_hook: Option\<pipewire::spa::SpaHook\>: Hook für den param\_changed Listener des Node/Device-Proxys.  
  * info: AudioDevice: Die zwischengespeicherte, aufbereitete AudioDevice-Struktur für die externe API.  
* struct MonitoredStream: Repräsentiert einen überwachten Audio-Stream.  
  * proxy: std::sync::Arc\<pipewire::node::Node\>: Proxy zum Stream-Node.  
  * proxy\_id: u32: Die ID des Proxy-Objekts.  
  * global\_id: u32: Die globale ID des PipeWire-Objekts.  
  * properties: pipewire::spa::SpaDict: Die zuletzt bekannten Eigenschaften des Streams.  
  * param\_listener\_hook: Option\<pipewire::spa::SpaHook\>: Hook für den param\_changed Listener des Node-Proxys.  
  * info: StreamInfo: Die zwischengespeicherte, aufbereitete StreamInfo-Struktur.  
* enum InternalAudioEvent: Interne Ereignisse zur Kommunikation innerhalb des Audio-Moduls.  
  * PwGlobalAdded(pipewire::registry::GlobalObject\<pipewire::spa::SpaDict\>)  
  * PwGlobalRemoved(u32)  
  * PwNodeParamChanged { node\_id: u32, param\_id: u32, pod: Option\<pipewire::spa::Pod\> }  
  * PwDeviceParamChanged { device\_id: u32, param\_id: u32, pod: Option\<pipewire::spa::Pod\> }  
  * PwMetadataPropsChanged { metadata\_id: u32, props: pipewire::spa::SpaDict }

#### **5.3.1.2. Methoden für PipeWireClient**

* pub async fn new(audio\_event\_broadcaster: tokio::sync::broadcast::Sender\<AudioEvent\>) \-\> Result\<Self, AudioError\>:  
  * **Vorbedingungen:** Keine.  
  * **Schritte:**  
    1. pipewire::init() aufrufen, um die PipeWire-Bibliothek zu initialisieren.4 Falls dies fehlschlägt, AudioError::PipeWireInitFailed zurückgeben.  
    2. Zwei tokio::sync::mpsc::channel erstellen:  
       * command\_channel für AudioCommand (Kapazität z.B. 32).  
       * internal\_event\_channel für InternalAudioEvent (Kapazität z.B. 64).  
    3. Die Sender (command\_sender, internal\_event\_sender) und Empfänger (command\_receiver, internal\_event\_receiver) aus den Kanälen extrahieren.  
    4. Einen tokio::sync::oneshot::channel erstellen (init\_signal\_tx, init\_signal\_rx) zur Signalisierung der erfolgreichen Initialisierung des PipeWire-Threads.  
    5. Einen neuen OS-Thread mit std::thread::spawn starten. Dieser Thread führt die Funktion run\_pipewire\_loop aus. Der audio\_event\_broadcaster, command\_receiver, internal\_event\_receiver, internal\_event\_sender\_clone (für Callbacks) und init\_signal\_tx werden in den Thread verschoben.  
       * **Thread-Logik (run\_pipewire\_loop Funktion):**  
         1. let mainloop \= MainLoop::new(None).map\_err(AudioError::MainLoopCreationFailed)?;.4  
         2. let context \= Context::new(\&mainloop).map\_err(AudioError::ContextCreationFailed)?;.4  
         3. let core \= Arc::new(context.connect(None).map\_err(AudioError::CoreConnectionFailed)?);.4  
         4. let registry \= Arc::new(core.get\_registry().map\_err(AudioError::RegistryCreationFailed)?);.4  
         5. Die erfolgreiche Initialisierung von core und registry über init\_signal\_tx.send(Ok((core.clone(), registry.clone()))) signalisieren.  
         6. Eine PipeWireLoopData-Instanz erstellen, die core, registry, den übergebenen audio\_event\_broadcaster, command\_receiver und internal\_event\_receiver enthält.  
         7. Einen Listener auf der registry mit add\_listener\_local() registrieren.4  
            * Im global-Callback: Ein InternalAudioEvent::PwGlobalAdded(global\_object) an den internal\_event\_sender\_clone senden. global\_object ist hier das Argument des Callbacks.  
            * Im global\_remove-Callback: Ein InternalAudioEvent::PwGlobalRemoved(id) an den internal\_event\_sender\_clone senden. id ist das Argument des Callbacks.  
         8. Eine Timer-Quelle zur mainloop hinzufügen (mainloop.loop\_().add\_timer(...)), die periodisch (z.B. alle 10ms) eine Funktion aufruft. Diese Funktion (process\_external\_messages) versucht, Nachrichten von command\_receiver und internal\_event\_receiver mit try\_recv() zu empfangen und verarbeitet diese.  
            * Die Integration von Tokio MPSC-Kanälen mit der blockierenden mainloop.run() erfordert einen Mechanismus, um die Schleife periodisch zu unterbrechen oder die MPSC-Empfänger nicht-blockierend abzufragen. Ein Timer ist ein gängiger Ansatz hierfür.1  
         9. mainloop.run() aufrufen. Diese Funktion blockiert den Thread und verarbeitet PipeWire-Ereignisse und Timer-Callbacks.  
    6. Auf das Ergebnis von init\_signal\_rx.await warten. Bei Erfolg die core und registry Arcs aus dem Ergebnis entnehmen. Bei Fehler AudioError::PipeWireThreadPanicked oder den empfangenen Fehler zurückgeben.  
    7. Den mainloop\_thread\_handle, die erhaltenen core und registry Arcs und den command\_sender in der PipeWireClient-Instanz speichern.  
    8. Ok(Self) zurückgeben.  
  * **Nachbedingungen:** Ein PipeWireClient ist initialisiert und der PipeWire-Loop-Thread läuft.  
  * **Fehlerfälle:** AudioError::PipeWireInitFailed, AudioError::MainLoopCreationFailed, AudioError::ContextCreationFailed, AudioError::CoreConnectionFailed, AudioError::RegistryCreationFailed, AudioError::PipeWireThreadPanicked.  
* pub fn get\_command\_sender(\&self) \-\> tokio::sync::mpsc::Sender\<AudioCommand\>:  
  * **Vorbedingungen:** Der PipeWireClient wurde erfolgreich initialisiert.  
  * **Schritte:** Gibt ein Klon des command\_sender zurück.  
  * **Nachbedingungen:** Keine Zustandsänderung.  
  * **Fehlerfälle:** Keine.

#### **5.3.1.3. Private statische Funktion run\_pipewire\_loop**

* fn run\_pipewire\_loop(audio\_event\_broadcaster: tokio::sync::broadcast::Sender\<AudioEvent\>, mut command\_receiver: tokio::sync::mpsc::Receiver\<AudioCommand\>, mut internal\_event\_receiver: tokio::sync::mpsc::Receiver\<InternalAudioEvent\>, internal\_event\_sender\_clone: tokio::sync::mpsc::Sender\<InternalAudioEvent\>, init\_signal\_tx: tokio::sync::oneshot::Sender\<Result\<(std::sync::Arc\<pipewire::Core\>, std::sync::Arc\<pipewire::Registry\>), AudioError\>\>):  
  * **Logik:** Wie oben unter PipeWireClient::new beschrieben (Schritt 5.1 bis 5.9).  
  * Die Funktion process\_external\_messages(loop\_data: \&mut PipeWireLoopData) wird vom Timer aufgerufen:  
    * **Befehlsverarbeitung (von loop\_data.command\_receiver.try\_recv()):**  
      * AudioCommand::SetDeviceVolume { device\_id, volume, curve }: Ruft system::audio::control::set\_device\_volume(\&loop\_data, device\_id, volume, curve) auf.  
      * AudioCommand::SetDeviceMute { device\_id, mute }: Ruft system::audio::control::set\_device\_mute(\&loop\_data, device\_id, mute) auf.  
      * AudioCommand::SetStreamVolume { stream\_id, volume, curve }: Ruft system::audio::control::set\_node\_volume(\&loop\_data, stream\_id, volume, curve) auf (da Streams als Nodes repräsentiert werden).  
      * AudioCommand::SetStreamMute { stream\_id, mute }: Ruft system::audio::control::set\_node\_mute(\&loop\_data, stream\_id, mute) auf.  
      * AudioCommand::SetDefaultDevice { device\_type, device\_id }: Ruft system::audio::control::set\_default\_device(\&loop\_data, device\_type, device\_id) auf.  
      * AudioCommand::RequestDeviceList: Sendet den aktuellen Stand von loop\_data.active\_devices über den audio\_event\_broadcaster als AudioEvent::DeviceListUpdated.  
      * AudioCommand::RequestStreamList: Sendet den aktuellen Stand von loop\_data.active\_streams über den audio\_event\_broadcaster als AudioEvent::StreamListUpdated.  
    * **Interne Ereignisverarbeitung (von loop\_data.internal\_event\_receiver.try\_recv()):**  
      * InternalAudioEvent::PwGlobalAdded(global): Ruft system::audio::manager::handle\_pipewire\_global\_added(\&mut loop\_data, global, \&internal\_event\_sender\_clone).  
      * InternalAudioEvent::PwGlobalRemoved(id): Ruft system::audio::manager::handle\_pipewire\_global\_removed(\&mut loop\_data, id).  
      * InternalAudioEvent::PwNodeParamChanged { node\_id, param\_id, pod }: Ruft system::audio::manager::handle\_node\_param\_changed(\&mut loop\_data, node\_id, param\_id, pod).  
      * InternalAudioEvent::PwDeviceParamChanged { device\_id, param\_id, pod }: Ruft system::audio::manager::handle\_device\_param\_changed(\&mut loop\_data, device\_id, param\_id, pod).  
      * InternalAudioEvent::PwMetadataPropsChanged { metadata\_id, props}: Ruft system::audio::manager::handle\_metadata\_props\_changed(\&mut loop\_data, metadata\_id, props).

### **5.3.2. Submodul: system::audio::manager \- Geräte- und Stream-Zustandsmanagement**

* **Datei:** system/audio/manager.rs  
* **Zweck:** Dieses Submodul enthält die Logik zur Verarbeitung von PipeWire-Registry-Ereignissen, zur Verwaltung der AudioDevice- und StreamInfo-Strukturen und zur Handhabung von Eigenschafts-/Parameteränderungen dieser Objekte. Es interagiert eng mit dem PipeWireClient, um auf Low-Level-Ereignisse zu reagieren und den Zustand der Audio-Entitäten im System zu aktualisieren.

#### **5.3.2.1. Funktionen (aufgerufen von PipeWireClient's Loop)**

* pub(super) fn handle\_pipewire\_global\_added(loop\_data: \&mut PipeWireLoopData, global: pipewire::registry::GlobalObject\<pipewire::spa::SpaDict\>, internal\_event\_sender: \&tokio::sync::mpsc::Sender\<InternalAudioEvent\>) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** loop\_data ist initialisiert. global ist ein neu entdecktes PipeWire-Global-Objekt.  
  * **Schritte:**  
    1. Loggt das neue globale Objekt: tracing::info\!("PipeWire Global Added: id={}, type={:?}, version={}, props={:?}", global.id, global.type\_, global.version, global.props.as\_ref().map\_or\_else(|| "None", |p| format\!("{:?}", p)));  
    2. Abhängig von global.type\_:  
       * ObjectType::Node:  
         1. Eigenschaften aus global.props extrahieren (falls vorhanden): media.class, node.name, node.description, application.process.id, application.name, audio.format, audio.channels, object.serial.  
         2. Bestimmen, ob es sich um ein Gerät (Sink/Source) oder einen Anwendungsstream handelt:  
            * **Gerät (Sink/Source Node):** Typischerweise media.class ist "Audio/Sink" oder "Audio/Source" und application.name ist nicht gesetzt oder verweist auf einen Systemdienst.  
              * Proxy binden: let node\_proxy \= Arc::new(loop\_data.registry.bind::\<pipewire::node::Node\>(\&global.into\_proxy\_properties(None)?)?);.8 Die into\_proxy\_properties Methode wird hier verwendet, um die bereits vorhandenen Properties direkt zu nutzen.  
              * Die global.id ist die ID des globalen Objekts, node\_proxy.id() ist die ID des gebundenen Proxys.  
              * Anfängliche Parameter abrufen (insbesondere SPA\_PARAM\_Props für Lautstärke/Mute): node\_proxy.enum\_params\_sync(pipewire::spa::param::ParamType::Props.as\_raw(), None, None, None) aufrufen. Den ersten zurückgegebenen SpaPod parsen, um channelVolumes und mute zu extrahieren (siehe spa\_pod\_utils).  
              * Eine AudioDevice-Instanz erstellen und mit den extrahierten und abgerufenen Informationen füllen. is\_default wird gesetzt, wenn global.id mit loop\_data.default\_sink\_id oder loop\_data.default\_source\_id übereinstimmt.  
              * Einen param\_changed-Listener auf dem node\_proxy registrieren:  
                Rust  
                let internal\_sender\_clone \= internal\_event\_sender.clone();  
                let proxy\_id \= node\_proxy.id(); // ID des gebundenen Proxys  
                let listener\_hook \= node\_proxy.add\_listener\_local()  
                   .param(move |\_id, \_seq, param\_id, \_index, \_next, pod| {  
                        let \_ \= internal\_sender\_clone.try\_send(InternalAudioEvent::PwNodeParamChanged {  
                            node\_id: proxy\_id, // Wichtig: ID des Proxys, nicht die globale ID  
                            param\_id,  
                            pod: pod.cloned(), // Klonen, da Pod nur als Referenz übergeben wird  
                        });  
                    })  
                   .register();

              * MonitoredDevice erstellen und in loop\_data.active\_devices mit global.id als Schlüssel einfügen. Die listener\_hook muss in MonitoredDevice gespeichert werden, um sie später entfernen zu können.  
              * AudioEvent::DeviceAdded(new\_device\_info) über loop\_data.audio\_event\_broadcaster senden.  
            * **Anwendungsstream:** Typischerweise ist application.name gesetzt.  
              * Proxy binden: let node\_proxy \= Arc::new(loop\_data.registry.bind::\<pipewire::node::Node\>(\&global.into\_proxy\_properties(None)?)?);  
              * Anfängliche Parameter (Lautstärke/Mute) wie bei Geräten abrufen.  
              * StreamInfo-Instanz erstellen.  
              * param\_changed-Listener auf node\_proxy registrieren (analog zu Geräten, sendet InternalAudioEvent::PwNodeParamChanged).  
              * MonitoredStream erstellen und in loop\_data.active\_streams mit global.id als Schlüssel einfügen.  
              * AudioEvent::StreamAdded(new\_stream\_info) über loop\_data.audio\_event\_broadcaster senden.  
       * ObjectType::Device:  
         1. Eigenschaften extrahieren: device.api, device.nick, device.description, media.class.  
         2. Wenn media.class "Audio/Sink" oder "Audio/Source" ist und dies ein "echtes" Hardware-Gerät darstellt (oft über device.api wie "alsa" identifizierbar), könnte dies für Master-Lautstärkeregelung über SPA\_PARAM\_Route relevant sein.  
            * Proxy binden: let device\_proxy \= Arc::new(loop\_data.registry.bind::\<pipewire::device::Device\>(\&global.into\_proxy\_properties(None)?)?);  
            * Anfängliche SPA\_PARAM\_Route-Parameter abrufen: device\_proxy.enum\_params\_sync(pipewire::spa::param::ParamType::Route.as\_raw(), None, None, None). Parsen, um aktive Route und deren Lautstärke/Mute zu finden.  
            * Eine AudioDevice-Instanz erstellen.  
            * Einen param\_changed-Listener auf dem device\_proxy registrieren, der InternalAudioEvent::PwDeviceParamChanged sendet.  
            * MonitoredDevice erstellen und in loop\_data.active\_devices einfügen.  
            * AudioEvent::DeviceAdded senden.  
       * ObjectType::Metadata:  
         1. Eigenschaften extrahieren: metadata.name.  
         2. Wenn metadata.name \== "default" ist:  
            * Proxy binden: let metadata\_proxy \= Arc::new(loop\_data.registry.bind::\<pipewire::metadata::Metadata\>(\&global.into\_proxy\_properties(None)?)?);  
            * loop\_data.metadata\_proxy \= Some(metadata\_proxy.clone());  
            * Die props-Eigenschaft des Metadatenobjekts enthält die Standardgeräte-IDs (z.B. default.audio.sink, default.audio.source).10 Diese parsen und loop\_data.default\_sink\_id/default\_source\_id aktualisieren.  
            * Einen props-Listener auf dem metadata\_proxy registrieren:  
              Rust  
              let internal\_sender\_clone \= internal\_event\_sender.clone();  
              let proxy\_id \= metadata\_proxy.id();  
              let listener\_hook \= metadata\_proxy.add\_listener\_local()  
                 .props(move |\_id, props| {  
                      let \_ \= internal\_sender\_clone.try\_send(InternalAudioEvent::PwMetadataPropsChanged {  
                          metadata\_id: proxy\_id,  
                          props: props.cloned(),  
                      });  
                  })  
                 .register();  
              loop\_data.metadata\_listener\_hook \= Some(listener\_hook);

            * AudioEvent::DefaultSinkChanged / DefaultSourceChanged senden, falls sich die IDs geändert haben.  
  * **Nachbedingungen:** Relevante Proxys sind gebunden, Listener registriert, und der Zustand in loop\_data ist aktualisiert. Entsprechende AudioEvents wurden gesendet.  
  * **Fehlerfälle:** AudioError::ProxyBindFailed, AudioError::ParameterEnumerationFailed.  
* pub(super) fn handle\_pipewire\_global\_removed(loop\_data: \&mut PipeWireLoopData, id: u32) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** id ist die globale ID eines entfernten PipeWire-Objekts.  
  * **Schritte:**  
    1. Loggt die Entfernung: tracing::info\!("PipeWire Global Removed: id={}", id);  
    2. Wenn id in loop\_data.active\_devices vorhanden ist:  
       * MonitoredDevice entfernen. Der param\_listener\_hook wird automatisch durch das Droppen des SpaHook-Objekts (oder durch explizites remove() auf dem Listener) entfernt, wenn der Proxy gedroppt wird. Der Proxy selbst wird gedroppt, wenn der Arc keine Referenzen mehr hat.  
       * AudioEvent::DeviceRemoved(id) über loop\_data.audio\_event\_broadcaster senden.  
    3. Wenn id in loop\_data.active\_streams vorhanden ist:  
       * MonitoredStream entfernen. Listener-Hook wird ebenfalls entfernt.  
       * AudioEvent::StreamRemoved(id) über loop\_data.audio\_event\_broadcaster senden.  
    4. Wenn die ID des loop\_data.metadata\_proxy (falls vorhanden) mit id übereinstimmt:  
       * loop\_data.metadata\_proxy \= None;  
       * loop\_data.metadata\_listener\_hook \= None; (wird gedroppt)  
  * **Nachbedingungen:** Das Objekt ist aus dem internen Zustand entfernt, Listener sind deregistriert. AudioEvent wurde gesendet.  
  * **Fehlerfälle:** Keine spezifischen Fehler erwartet, außer Logging-Fehler.  
* pub(super) fn handle\_node\_param\_changed(loop\_data: \&mut PipeWireLoopData, node\_id: u32, param\_id: u32, pod: Option\<pipewire::spa::Pod\>) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** node\_id ist die Proxy-ID eines Nodes. param\_id gibt den Typ des geänderten Parameters an. pod enthält die neuen Parameterdaten.  
  * **Schritte:**  
    1. Loggt die Parameteränderung: tracing::debug\!("Node Param Changed: node\_id={}, param\_id={}, pod\_is\_some={}", node\_id, param\_id, pod.is\_some());  
    2. Suchen des MonitoredDevice oder MonitoredStream in loop\_data.active\_devices oder loop\_data.active\_streams, dessen proxy.id() mit node\_id übereinstimmt.  
    3. Wenn gefunden und param\_id \== pipewire::spa::param::ParamType::Props.as\_raw():  
       * Wenn pod Some ist, die neuen Lautstärke- (channelVolumes) und Mute- (mute) Werte aus dem SpaPod parsen (siehe spa\_pod\_utils).  
       * Die info (entweder AudioDevice oder StreamInfo) im MonitoredDevice/MonitoredStream aktualisieren.  
       * Das entsprechende AudioEvent (DeviceVolumeChanged, DeviceMuteChanged, StreamVolumeChanged, StreamMuteChanged) über loop\_data.audio\_event\_broadcaster senden.  
  * **Nachbedingungen:** Der interne Zustand des Geräts/Streams ist aktualisiert und ein AudioEvent wurde gesendet.  
  * **Fehlerfälle:** AudioError::SpaPodParseFailed.  
* pub(super) fn handle\_device\_param\_changed(loop\_data: \&mut PipeWireLoopData, device\_id: u32, param\_id: u32, pod: Option\<pipewire::spa::Pod\>) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** device\_id ist die Proxy-ID eines Devices.  
  * **Schritte:**  
    1. Loggt die Parameteränderung.  
    2. Suchen des MonitoredDevice in loop\_data.active\_devices, dessen proxy.id() mit device\_id übereinstimmt.  
    3. Wenn gefunden und param\_id \== pipewire::spa::param::ParamType::Route.as\_raw():  
       * Wenn pod Some ist, die neuen Routenparameter parsen, um Lautstärke/Mute der aktiven Route zu extrahieren.  
       * Die info (AudioDevice) im MonitoredDevice aktualisieren.  
       * AudioEvent::DeviceVolumeChanged / DeviceMuteChanged senden.  
  * **Nachbedingungen:** Der interne Zustand des Geräts ist aktualisiert.  
  * **Fehlerfälle:** AudioError::SpaPodParseFailed.  
* pub(super) fn handle\_metadata\_props\_changed(loop\_data: \&mut PipeWireLoopData, metadata\_id: u32, props: pipewire::spa::SpaDict) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** metadata\_id ist die Proxy-ID des Metadaten-Objekts. props sind die geänderten Eigenschaften.  
  * **Schritte:**  
    1. Loggt die Änderung.  
    2. Überprüfen, ob loop\_data.metadata\_proxy existiert und seine ID mit metadata\_id übereinstimmt.  
    3. Die neuen Standard-Sink/Source-IDs aus props extrahieren (z.B. props.get("default.audio.sink").and\_then(|s| s.parse().ok())).  
    4. Wenn sich loop\_data.default\_sink\_id geändert hat:  
       * Altes Standardgerät (falls vorhanden) in active\_devices suchen und is\_default \= false setzen. AudioEvent::DeviceUpdated senden.  
       * Neues Standardgerät in active\_devices suchen und is\_default \= true setzen. AudioEvent::DeviceUpdated senden.  
       * loop\_data.default\_sink\_id aktualisieren.  
       * AudioEvent::DefaultSinkChanged(new\_id) senden.  
    5. Analog für default\_source\_id.  
  * **Nachbedingungen:** Standardgeräte-IDs und is\_default-Flags sind aktualisiert. AudioEvents wurden gesendet.  
  * **Fehlerfälle:** Keine spezifischen Fehler erwartet.

### **5.3.3. Submodul: system::audio::control \- Lautstärke-, Stummschaltungs- und Gerätesteuerung**

* **Datei:** system/audio/control.rs  
* **Zweck:** Implementiert die Logik zum Senden von Steuerbefehlen an PipeWire-Objekte, insbesondere zum Setzen von Lautstärke und Stummschaltung sowie zur Auswahl von Standardgeräten.

#### **5.3.3.1. Funktionen (aufgerufen von PipeWireClient's Loop bei AudioCommand Verarbeitung)**

* pub(super) fn set\_node\_volume(loop\_data: \&PipeWireLoopData, node\_id: u32, volume: Volume, curve: VolumeCurve) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** node\_id ist eine gültige Proxy-ID eines MonitoredDevice (als Node) oder MonitoredStream in loop\_data.  
  * **Schritte:**  
    1. Sucht den MonitoredDevice oder MonitoredStream anhand der node\_id (Proxy-ID).  
    2. Wenn nicht gefunden, AudioError::DeviceOrStreamNotFound(node\_id) zurückgeben.  
    3. Den pipewire::node::Node-Proxy extrahieren.  
    4. Die volume.channel\_volumes (Array von f32) entsprechend der VolumeCurve (z.B. Linear, Cubic) anpassen. Für Cubic wäre das vadj​=v3.  
    5. Einen SpaPod für SPA\_PARAM\_Props erstellen, der channelVolumes enthält (siehe spa\_pod\_utils::build\_volume\_props\_pod).  
    6. node\_proxy.set\_param(pipewire::spa::param::ParamType::Props.as\_raw(), 0, \&pod) aufrufen.27  
    7. Bei Fehler AudioError::PipeWireCommandFailed zurückgeben.  
  * **Nachbedingungen:** Der Lautstärkebefehl wurde an den PipeWire-Node gesendet.  
  * **Fehlerfälle:** AudioError::DeviceOrStreamNotFound, AudioError::SpaPodBuildFailed, AudioError::PipeWireCommandFailed.  
* pub(super) fn set\_node\_mute(loop\_data: \&PipeWireLoopData, node\_id: u32, mute: bool) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** node\_id ist eine gültige Proxy-ID.  
  * **Schritte:**  
    1. Sucht den MonitoredDevice oder MonitoredStream.  
    2. Den pipewire::node::Node-Proxy extrahieren.  
    3. Einen SpaPod für SPA\_PARAM\_Props erstellen, der mute enthält (siehe spa\_pod\_utils::build\_mute\_props\_pod).  
    4. node\_proxy.set\_param(pipewire::spa::param::ParamType::Props.as\_raw(), 0, \&pod) aufrufen.  
  * **Nachbedingungen:** Der Stummschaltungsbefehl wurde gesendet.  
  * **Fehlerfälle:** AudioError::DeviceOrStreamNotFound, AudioError::SpaPodBuildFailed, AudioError::PipeWireCommandFailed.  
* pub(super) fn set\_device\_volume(loop\_data: \&PipeWireLoopData, device\_id: u32, volume: Volume, curve: VolumeCurve) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** device\_id ist eine gültige Proxy-ID eines MonitoredDevice, dessen Proxy ein pipewire::device::Device ist.  
  * **Schritte:**  
    1. Sucht den MonitoredDevice anhand der device\_id.  
    2. Den pipewire::device::Device-Proxy extrahieren.  
    3. Die volume.channel\_volumes entsprechend der VolumeCurve anpassen.  
    4. Die aktuelle aktive Route für das Gerät ermitteln (ggf. durch enum\_params\_sync für SPA\_PARAM\_Route und Auswahl der Route mit dem höchsten priority oder dem passenden index).  
    5. Einen SpaPod für SPA\_PARAM\_Route erstellen, der die index, device (oft 0 für die Route selbst) und die neuen props (mit channelVolumes) enthält (siehe spa\_pod\_utils::build\_route\_volume\_pod). 26  
    6. device\_proxy.set\_param(pipewire::spa::param::ParamType::Route.as\_raw(), 0, \&pod) aufrufen.  
  * **Nachbedingungen:** Der Lautstärkebefehl für die Geräteroute wurde gesendet.  
  * **Fehlerfälle:** AudioError::DeviceOrStreamNotFound, AudioError::SpaPodBuildFailed, AudioError::PipeWireCommandFailed, AudioError::NoActiveRouteFound.  
* pub(super) fn set\_device\_mute(loop\_data: \&PipeWireLoopData, device\_id: u32, mute: bool) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** device\_id ist eine gültige Proxy-ID eines MonitoredDevice (Device-Proxy).  
  * **Schritte:**  
    1. Sucht den MonitoredDevice.  
    2. Den pipewire::device::Device-Proxy extrahieren.  
    3. Aktive Route ermitteln.  
    4. Einen SpaPod für SPA\_PARAM\_Route erstellen, der die props (mit mute) enthält (siehe spa\_pod\_utils::build\_route\_mute\_pod).  
    5. device\_proxy.set\_param(pipewire::spa::param::ParamType::Route.as\_raw(), 0, \&pod) aufrufen.  
  * **Nachbedingungen:** Der Stummschaltungsbefehl für die Geräteroute wurde gesendet.  
  * **Fehlerfälle:** AudioError::DeviceOrStreamNotFound, AudioError::SpaPodBuildFailed, AudioError::PipeWireCommandFailed, AudioError::NoActiveRouteFound.  
* pub(super) fn set\_default\_device(loop\_data: \&mut PipeWireLoopData, device\_type: AudioDeviceType, global\_id: u32) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** loop\_data.metadata\_proxy ist Some. global\_id ist die globale ID des Geräts, das zum Standard werden soll.  
  * **Schritte:**  
    1. Wenn loop\_data.metadata\_proxy None ist, AudioError::MetadataProxyNotAvailable zurückgeben.  
    2. Den pipewire::metadata::Metadata-Proxy extrahieren.  
    3. Den Eigenschaftsnamen basierend auf device\_type bestimmen:  
       * AudioDeviceType::Sink \=\> "default.audio.sink"  
       * AudioDeviceType::Source \=\> "default.audio.source"  
    4. Den Wert als String der global\_id vorbereiten.  
    5. metadata\_proxy.set\_property(property\_name, "Spa:String:JSON", \&global\_id\_string) aufrufen. Die Typangabe "Spa:String:JSON" könnte auch einfach "string" sein, je nachdem was PipeWire erwartet.  
       * **Anmerkung:** Die genaue Methode zum Setzen von Metadaten-Eigenschaften muss anhand der pipewire-rs API für Metadata überprüft werden. Es könnte sein, dass ein SpaDict mit den zu setzenden Properties übergeben werden muss.  
    6. Bei Erfolg wird der PwMetadataPropsChanged-Event ausgelöst und von handle\_metadata\_props\_changed verarbeitet, was den internen Zustand und die is\_default-Flags aktualisiert.  
  * **Nachbedingungen:** Der Befehl zum Ändern des Standardgeräts wurde an PipeWire gesendet.  
  * **Fehlerfälle:** AudioError::MetadataProxyNotAvailable, AudioError::PipeWireCommandFailed.

### **5.3.4. Submodul: system::audio::types \- Kerndatenstrukturen für Audio**

* **Datei:** system/audio/types.rs  
* **Zweck:** Definiert die primären Datenstrukturen, die vom Audio-Modul verwendet und nach außen exponiert werden.

#### **5.3.4.1. Enums**

* \#  
  pub enum AudioError {... } (Definition im error.rs Modul, hier nur als Referenz)  
* \#  
  pub enum AudioDeviceType { Sink, Source, Unknown }  
  * **Zweck:** Repräsentiert den Typ eines Audiogeräts.  
  * **Ableitung:** Aus media.class Property von PipeWire-Objekten (z.B. "Audio/Sink", "Audio/Source").  
* \#  
  pub enum VolumeCurve { Linear, Cubic }  
  * **Zweck:** Definiert die Kurve, die bei der Lautstärkeanpassung verwendet wird. Cubic wird oft für eine natürlichere Wahrnehmung der Lautstärkeänderung verwendet.  
  * **Initialwert:** Typischerweise Cubic für UI-Interaktionen.  
* \#  
  pub enum AudioCommand {... } (siehe Tabelle 5.2)  
* \#  
  pub enum AudioEvent {... } (siehe Tabelle 5.3)

#### **5.3.4.2. Strukuren**

* \#  
  pub struct Volume { pub channel\_volumes: Vec\<f32\> }  
  * **Zweck:** Repräsentiert die Lautstärke für jeden Kanal eines Geräts oder Streams. Werte typischerweise zwischen 0.0 und 1.0 (oder höher, falls Übersteuerung erlaubt ist).  
  * **Invarianten:** channel\_volumes sollte nicht leer sein, wenn das Gerät aktiv ist. Alle Werte sollten ≥0.0.  
  * **Initialwert:** Abhängig vom Gerät; oft 1.0 für jeden Kanal.  
* \#  
  pub struct AudioDevice {... } (siehe Tabelle 5.1)  
* \#  
  pub struct StreamInfo {  
  * pub id: u32, // Globale PipeWire ID des Node-Objekts  
  * pub name: Option\<String\>, // Aus node.name oder application.name  
  * pub application\_name: Option\<String\>, // Aus application.name  
  * pub process\_id: Option\<u32\>, // Aus application.process.id  
  * pub volume: Volume,  
  * pub is\_muted: bool,  
  * pub media\_class: Option\<String\>, // z.B. "Stream/Output/Audio"  
  * pub node\_id\_pw: u32, // PipeWire interne Node ID (object.serial oder node.id) }  
  * **Zweck:** Repräsentiert einen aktiven Audio-Stream einer Anwendung.  
  * **Ableitung:** Aus den Eigenschaften eines PipeWire Node-Objekts.

#### **Tabelle 5.1: AudioDevice Strukturdefinition**

| Feldname | Rust-Typ | PipeWire Property / Quelle | Beschreibung | Initialwert (Beispiel) | Sichtbarkeit |
| :---- | :---- | :---- | :---- | :---- | :---- |
| id | u32 | global.id | Eindeutige globale ID des PipeWire-Objekts (Node oder Device). | \- | pub |
| proxy\_id | u32 | proxy.id() | ID des gebundenen Proxy-Objekts. | \- | pub(super) |
| name | Option\<String\> | node.nick, device.nick, node.name, device.name | Benutzerfreundlicher Name des Geräts. | None | pub |
| description | Option\<String\> | node.description, device.description | Detailliertere Beschreibung des Geräts. | None | pub |
| device\_type | AudioDeviceType | media.class (z.B. "Audio/Sink", "Audio/Source") | Typ des Audiogeräts (Sink oder Quelle). | Unknown | pub |
| volume | Volume | SPA\_PARAM\_Props (channelVolumes) oder SPA\_PARAM\_Route | Aktuelle Lautstärkeeinstellungen für jeden Kanal. | Volume { vols: vec\! } | pub |
| is\_muted | bool | SPA\_PARAM\_Props (mute) oder SPA\_PARAM\_Route | Gibt an, ob das Gerät stummgeschaltet ist. | false | pub |
| is\_default | bool | PipeWire:Interface:Metadata Objekt (default.audio.sink/source) | Gibt an, ob dies das Standardgerät seines Typs ist. | false | pub |
| ports | Option\<Vec\<PortInfo\>\> | SPA\_PARAM\_PortConfig / SPA\_PARAM\_EnumPortInfo | Informationen über die Ports des Geräts (optional, falls benötigt). | None | pub |
| properties\_spa | Option\<pipewire::spa::SpaDict\> | global.props / proxy.get\_properties() | Rohe PipeWire SPA-Eigenschaften (für Debugging oder erweiterte Infos). | None | pub(super) |
| is\_hardware\_device | bool | Abgeleitet aus device.api (z.B. "alsa", "bluez\_input") | Gibt an, ob es sich um ein physisches Hardwaregerät handelt. | false | pub |
| api\_name | Option\<String\> | device.api | Name der zugrundeliegenden API (z.B. "alsa", "v4l2", "libcamera"). | None | pub |

#### **Tabelle 5.2: AudioCommand Enum Varianten**

| Variante | Parameter | Beschreibung |
| :---- | :---- | :---- |
| SetDeviceVolume | device\_id: u32, volume: Volume, curve: VolumeCurve | Setzt die Lautstärke für ein bestimmtes Gerät. |
| SetDeviceMute | device\_id: u32, mute: bool | Schaltet ein bestimmtes Gerät stumm oder hebt die Stummschaltung auf. |
| SetStreamVolume | stream\_id: u32, volume: Volume, curve: VolumeCurve | Setzt die Lautstärke für einen bestimmten Anwendungsstream. |
| SetStreamMute | stream\_id: u32, mute: bool | Schaltet einen bestimmten Anwendungsstream stumm oder hebt die Stummschaltung auf. |
| SetDefaultDevice | device\_type: AudioDeviceType, device\_id: u32 | Setzt das Standardgerät für den angegebenen Typ (Sink/Source). |
| RequestDeviceList | \- | Fordert die aktuelle Liste aller bekannten Audiogeräte an. |
| RequestStreamList | \- | Fordert die aktuelle Liste aller bekannten Audio-Streams an. |

#### **Tabelle 5.3: AudioEvent Enum Varianten**

| Variante | Payload | Beschreibung |
| :---- | :---- | :---- |
| DeviceAdded | device: AudioDevice | Ein neues Audiogerät wurde dem System hinzugefügt. |
| DeviceRemoved | device\_id: u32 | Ein Audiogerät wurde vom System entfernt. |
| DeviceUpdated | device: AudioDevice | Eigenschaften eines Audiogeräts haben sich geändert (z.B. Name, Beschreibung). |
| DeviceVolumeChanged | device\_id: u32, new\_volume: Volume | Die Lautstärke eines Geräts hat sich geändert. |
| DeviceMuteChanged | device\_id: u32, is\_muted: bool | Der Stummschaltungsstatus eines Geräts hat sich geändert. |
| StreamAdded | stream: StreamInfo | Ein neuer Audio-Stream einer Anwendung wurde erkannt. |
| StreamRemoved | stream\_id: u32 | Ein Audio-Stream einer Anwendung wurde beendet. |
| StreamUpdated | stream: StreamInfo | Eigenschaften eines Streams haben sich geändert. |
| StreamVolumeChanged | stream\_id: u32, new\_volume: Volume | Die Lautstärke eines Anwendungsstreams hat sich geändert. |
| StreamMuteChanged | stream\_id: u32, is\_muted: bool | Der Stummschaltungsstatus eines Anwendungsstreams hat sich geändert. |
| DefaultSinkChanged | new\_device\_id: Option\<u32\> | Das Standard-Audioausgabegerät hat sich geändert. |
| DefaultSourceChanged | new\_device\_id: Option\<u32\> | Das Standard-Audioeingabegerät hat sich geändert. |
| AudioErrorOccurred | error: String | Ein Fehler im Audio-Subsystem ist aufgetreten. |
| DeviceListUpdated | devices: Vec\<AudioDevice\> | Antwort auf RequestDeviceList, enthält die aktuelle Geräteliste. |
| StreamListUpdated | streams: Vec\<StreamInfo\> | Antwort auf RequestStreamList, enthält die aktuelle Streamliste. |

### **5.3.5. Submodul: system::audio::spa\_pod\_utils \- SPA POD Konstruktionshilfsmittel**

* **Datei:** system/audio/spa\_pod\_utils.rs  
* **Zweck:** Enthält Hilfsfunktionen zur Erstellung von pipewire::spa::Pod (Simple Plugin API Plain Old Data) Objekten, die für das Setzen von Parametern wie Lautstärke und Stummschaltung über die PipeWire API benötigt werden.

#### **5.3.5.1. Funktionen**

* pub(super) fn build\_volume\_props\_pod(channel\_volumes: &\[f32\]) \-\> Result\<pipewire::spa::Pod, AudioError\>:  
  * **Vorbedingungen:** channel\_volumes enthält die gewünschten Lautstärkewerte pro Kanal (normalisiert, z.B. 0.0 bis 1.0).  
  * **Schritte:**  
    1. Erstellt einen pipewire::spa::pod::PodBuilder.  
    2. Beginnt ein Objekt (push\_object) vom Typ SPA\_TYPE\_OBJECT\_Props und ID SPA\_PARAM\_Props.  
    3. Fügt die Eigenschaft SPA\_PROP\_channelVolumes hinzu (prop(pipewire::spa::param::prop\_info::PropInfoType::channelVolumes.as\_raw(), 0)).  
    4. Fügt ein Array (push\_array) für die Float-Werte hinzu.  
    5. Iteriert über channel\_volumes und fügt jeden Wert als Float zum Array hinzu (float(vol)).  
    6. Schließt das Array (pop) und das Objekt (pop).  
    7. Gibt den erstellten Pod zurück.  
  * **Nachbedingungen:** Ein gültiger SpaPod für die Lautstärkeeinstellung ist erstellt.  
  * **Fehlerfälle:** AudioError::SpaPodBuildFailed, falls die Erstellung fehlschlägt.  
* pub(super) fn build\_mute\_props\_pod(mute: bool) \-\> Result\<pipewire::spa::Pod, AudioError\>:  
  * **Vorbedingungen:** mute enthält den gewünschten Stummschaltungsstatus.  
  * **Schritte:**  
    1. Erstellt einen pipewire::spa::pod::PodBuilder.  
    2. Beginnt ein Objekt (push\_object) vom Typ SPA\_TYPE\_OBJECT\_Props und ID SPA\_PARAM\_Props.  
    3. Fügt die Eigenschaft SPA\_PROP\_mute hinzu (prop(pipewire::spa::param::prop\_info::PropInfoType::mute.as\_raw(), 0)).  
    4. Fügt den booleschen Wert hinzu (boolean(mute)).  
    5. Schließt das Objekt (pop).  
    6. Gibt den erstellten Pod zurück.  
  * **Nachbedingungen:** Ein gültiger SpaPod für die Stummschaltung ist erstellt.  
  * **Fehlerfälle:** AudioError::SpaPodBuildFailed.  
* pub(super) fn build\_route\_volume\_pod(route\_index: u32, route\_device\_id: u32, channel\_volumes: &\[f32\]) \-\> Result\<pipewire::spa::Pod, AudioError\>:  
  * **Vorbedingungen:** route\_index und route\_device\_id identifizieren die Zielroute. channel\_volumes enthält die Lautstärkewerte.  
  * **Schritte:**  
    1. Erstellt einen pipewire::spa::pod::PodBuilder.  
    2. Beginnt ein Objekt (push\_object) vom Typ SPA\_TYPE\_OBJECT\_ParamRoute und ID SPA\_PARAM\_Route.  
    3. Fügt die Eigenschaft SPA\_PARAM\_ROUTE\_index mit route\_index hinzu (prop(...).int(route\_index)).  
    4. Fügt die Eigenschaft SPA\_PARAM\_ROUTE\_device mit route\_device\_id hinzu (prop(...).int(route\_device\_id)).  
    5. Fügt die Eigenschaft SPA\_PARAM\_ROUTE\_props hinzu.  
    6. Innerhalb von SPA\_PARAM\_ROUTE\_props ein weiteres Objekt (push\_object) vom Typ SPA\_TYPE\_OBJECT\_Props erstellen (ohne explizite ID, da es Teil der Route-Props ist).  
    7. Fügt SPA\_PROP\_channelVolumes und das Array der Float-Werte hinzu, wie in build\_volume\_props\_pod.  
    8. Schließt das innere Props-Objekt (pop) und das äußere Route-Objekt (pop).  
    9. Gibt den erstellten Pod zurück.  
  * **Nachbedingungen:** Ein SpaPod zum Setzen der Lautstärke einer spezifischen Route ist erstellt.  
  * **Fehlerfälle:** AudioError::SpaPodBuildFailed.  
* pub(super) fn build\_route\_mute\_pod(route\_index: u32, route\_device\_id: u32, mute: bool) \-\> Result\<pipewire::spa::Pod, AudioError\>:  
  * **Analoge Schritte** zu build\_route\_volume\_pod, aber für die SPA\_PROP\_mute-Eigenschaft innerhalb der SPA\_PARAM\_ROUTE\_props.  
* pub(super) fn parse\_props\_volume\_mute(pod: \&pipewire::spa::Pod) \-\> Result\<(Option\<Volume\>, Option\<bool\>), AudioError\>:  
  * **Vorbedingungen:** pod ist ein SpaPod, der vermutlich SPA\_PARAM\_Props repräsentiert.  
  * **Schritte:**  
    1. Iteriert durch die Eigenschaften des SpaPod-Objekts.  
    2. Sucht nach SPA\_PROP\_channelVolumes: Wenn gefunden, die Float-Werte aus dem Array extrahieren und in Volume verpacken.  
    3. Sucht nach SPA\_PROP\_mute: Wenn gefunden, den booleschen Wert extrahieren.  
    4. Gibt ein Tupel (Option\<Volume\>, Option\<bool\>) zurück.  
  * **Nachbedingungen:** Lautstärke und Mute-Status sind aus dem Pod extrahiert, falls vorhanden.  
  * **Fehlerfälle:** AudioError::SpaPodParseFailed, wenn die Struktur des Pods unerwartet ist.  
* pub(super) fn parse\_route\_props\_volume\_mute(pod: \&pipewire::spa::Pod) \-\> Result\<(Option\<Volume\>, Option\<bool\>), AudioError\>:  
  * **Vorbedingungen:** pod ist ein SpaPod, der SPA\_PARAM\_Route repräsentiert.  
  * **Schritte:**  
    1. Iteriert durch die Eigenschaften des SpaPod-Objekts (SPA\_TYPE\_OBJECT\_ParamRoute).  
    2. Sucht nach SPA\_PARAM\_ROUTE\_props.  
    3. Wenn gefunden, den inneren SpaPod (der SPA\_TYPE\_OBJECT\_Props sein sollte) mit parse\_props\_volume\_mute parsen.  
  * **Nachbedingungen:** Lautstärke und Mute-Status der Route sind extrahiert.  
  * **Fehlerfälle:** AudioError::SpaPodParseFailed.

### **5.3.6. Submodul: system::audio::error \- Fehlerbehandlung im Audio-Modul**

* **Datei:** system/audio/error.rs  
* **Zweck:** Definiert die spezifischen Fehlertypen für das system::audio-Modul unter Verwendung von thiserror.

#### **5.3.6.1. Enum AudioError**

* \# pub enum AudioError {  
  * \#\[error("PipeWire C API initialization failed.")\]  
    PipeWireInitFailed,  
  * \#\[error("Failed to create PipeWire MainLoop.")\]  
    MainLoopCreationFailed(\#\[source\] pipewire::Error),  
  * \#\[error("Failed to create PipeWire Context.")\]  
    ContextCreationFailed(\#\[source\] pipewire::Error),  
  * \#\[error("Failed to connect to PipeWire Core.")\]  
    CoreConnectionFailed(\#\[source\] pipewire::Error),  
  * \#  
    RegistryCreationFailed(\#\[source\] pipewire::Error),  
  * \#\[error("PipeWire thread panicked or failed to initialize.")\]  
    PipeWireThreadPanicked,  
  * \#\[error("Failed to bind to PipeWire proxy for global id {global\_id}: {source}")\]  
    ProxyBindFailed { global\_id: u32, \#\[source\] source: pipewire::Error },  
  * \#\[error("Failed to enumerate parameters for object id {object\_id}: {source}")\]  
    ParameterEnumerationFailed { object\_id: u32, \#\[source\] source: pipewire::Error },  
  * \#  
    SpaPodParseFailed { message: String },  
  * \#  
    SpaPodBuildFailed { message: String },  
  * \#\[error("PipeWire command failed for object {object\_id}: {source}")\]  
    PipeWireCommandFailed { object\_id: u32, \#\[source\] source: pipewire::Error },  
  * \#  
    DeviceOrStreamNotFound(u32),  
  * \#  
    NoActiveRouteFound(u32),  
  * \#\[error("PipeWire Metadata proxy is not available.")\]  
    MetadataProxyNotAvailable,  
  * \#  
    InternalChannelSendError(String),  
  * \#  
    InternalBroadcastSendError(String),  
    }  
  * **Begründung für thiserror**: thiserror wird verwendet, um Boilerplate-Code für die Implementierung von std::error::Error und std::fmt::Display zu reduzieren. Es ermöglicht klare, kontextbezogene Fehlermeldungen und die einfache Einbettung von Quellfehlern (\#\[from\] oder \#\[source\]). Dies ist entscheidend für die Diagnose von Problemen in einem komplexen Subsystem wie der Audioverwaltung.33 Die spezifischen Fehlervarianten ermöglichen es aufrufendem Code, differenziert auf Fehler zu reagieren.

## **6\. system::mcp \- Model Context Protocol Client**

Das Modul system::mcp implementiert einen Client für das Model Context Protocol (MCP). MCP ist ein offener Standard für die sichere und standardisierte Verbindung von KI-Modellen (LLMs) mit externen Werkzeugen, Datenquellen und Anwendungen, wie dieser Desktop-Umgebung.37 Dieses Modul ermöglicht es der Desktop-Umgebung, mit lokalen oder Cloud-basierten MCP-Servern zu kommunizieren, um KI-gestützte Funktionen bereitzustellen. Die Kommunikation erfolgt typischerweise über Stdio, wobei JSON-RPC-Nachrichten ausgetauscht werden.

* **Kernfunktionalität**:  
  * Senden von Anfragen an einen MCP-Server (z.B. tool\_run, resource\_list).  
  * Empfangen und Verarbeiten von Antworten und asynchronen Benachrichtigungen vom Server.  
  * Verwaltung des Verbindungsstatus zum MCP-Server.  
* **Verwendete Crates**: mcp\_client\_rs 37 oder mcpr 38 als Basis für die MCP-Client-Implementierung. Die Wahl fiel auf mcp\_client\_rs (von darinkishore) aufgrund seiner direkten Stdio-Transportunterstützung und klaren Client-API.  
* **Modulstruktur und Dateien**:  
  * system/mcp/mod.rs: Öffentliche API, McpError Enum.  
  * system/mcp/client.rs: McpClient-Struktur, Logik zum Senden von Anfragen und Empfangen von Antworten/Benachrichtigungen.  
  * system/mcp/transport.rs: Implementierung des Stdio-Transports, falls nicht vollständig vom Crate abgedeckt oder Anpassungen nötig sind.  
  * system/mcp/types.rs: Definitionen für MCP-Anfragen, \-Antworten und \-Benachrichtigungen, die für die Desktop-Umgebung relevant sind (ggf. Wrapper um Crate-Typen).  
  * system/mcp/error.rs: Fehlerbehandlung für das MCP-Modul.

### **5.4.1. Submodul: system::mcp::client \- MCP Client Kernlogik**

* **Datei:** system/mcp/client.rs  
* **Zweck:** Dieses Submodul enthält die Kernlogik für die Interaktion mit einem MCP-Server. Es ist verantwortlich für das Starten des MCP-Server-Prozesses (falls lokal), das Senden von Anfragen und das Verarbeiten von Antworten und serverseitigen Benachrichtigungen.

#### **5.4.1.1. Strukuren**

* pub struct McpClient:  
  * client\_handle: Option\<mcp\_client\_rs::client::Client\>: Die eigentliche Client-Instanz aus dem mcp\_client\_rs-Crate. Option, da die Verbindung fehlschlagen oder noch nicht etabliert sein kann.  
  * server\_process: Option\<tokio::process::Child\>: Handle für den Kindprozess des MCP-Servers, falls dieser lokal von der Desktop-Umgebung gestartet wird.  
  * command\_sender: tokio::sync::mpsc::Sender\<McpCommand\>: Sender für Befehle an den MCP-Verwaltungs-Task.  
  * notification\_broadcaster: tokio::sync::broadcast::Sender\<McpNotification\>: Sender zum Verteilen von MCP-Benachrichtigungen an interessierte Systemkomponenten.  
  * status\_broadcaster: tokio::sync::broadcast::Sender\<McpClientStatus\>: Sender zum Verteilen von Statusänderungen des MCP-Clients.  
  * request\_id\_counter: std::sync::Arc\<std::sync::atomic::AtomicU64\>: Atomarer Zähler zur Generierung eindeutiger Request-IDs für JSON-RPC.  
  * pending\_requests: std::sync::Arc\<tokio::sync::Mutex\<std::collections::HashMap\<String, tokio::sync::oneshot::Sender\<Result\<serde\_json::Value, McpError\>\>\>\>\>: Speichert oneshot::Sender für jede ausstehende Anfrage, um die Antwort an den ursprünglichen Aufrufer weiterzuleiten. Der Key ist die Request-ID.  
  * listen\_task\_handle: Option\<tokio::task::JoinHandle\<()\>\>: Handle für den Tokio-Task, der eingehende Nachrichten vom MCP-Server verarbeitet.  
* pub struct McpServerConfig:  
  * command: String: Der auszuführende Befehl zum Starten des MCP-Servers (z.B. "/usr/bin/my\_mcp\_server").  
  * args: Vec\<String\>: Argumente für den Server-Befehl.  
  * working\_directory: Option\<String\>: Arbeitsverzeichnis für den Serverprozess.

#### **5.4.1.2. Enums**

* pub enum McpClientStatus:  
  * Disconnected: Der Client ist nicht verbunden.  
  * Connecting: Der Client versucht, eine Verbindung herzustellen.  
  * Connected: Der Client ist verbunden und initialisiert.  
  * Error(String): Ein Fehler ist aufgetreten.  
* pub enum McpCommand:  
  * Initialize { params: mcp\_client\_rs::protocol::InitializeParams }  
  * ListResources { params: mcp\_client\_rs::protocol::ListResourcesParams, response\_tx: tokio::sync::oneshot::Sender\<Result\<mcp\_client\_rs::protocol::ListResourcesResult, McpError\>\> }  
  * ReadResource { params: mcp\_client\_rs::protocol::ReadResourceParams, response\_tx: tokio::sync::oneshot::Sender\<Result\<mcp\_client\_rs::protocol::ReadResourceResult, McpError\>\> }  
  * CallTool { params: mcp\_client\_rs::protocol::CallToolParams, response\_tx: tokio::sync::oneshot::Sender\<Result\<mcp\_client\_rs::protocol::CallToolResult, McpError\>\> }  
  * Shutdown  
  * SubscribeToNotifications { subscriber: tokio::sync::broadcast::Sender\<McpNotification\> } (Beispiel für eine spezifischere Benachrichtigungsbehandlung)

#### **5.4.1.3. Methoden für McpClient**

* pub async fn new(server\_config: McpServerConfig, notification\_broadcaster: tokio::sync::broadcast::Sender\<McpNotification\>, status\_broadcaster: tokio::sync::broadcast::Sender\<McpClientStatus\>) \-\> Result\<Self, McpError\>:  
  * **Vorbedingungen:** server\_config ist gültig.  
  * **Schritte:**  
    1. Erstellt einen tokio::sync::mpsc::channel für McpCommand.  
    2. Initialisiert request\_id\_counter und pending\_requests.  
    3. Startet den MCP-Serverprozess gemäß server\_config mit tokio::process::Command. Stdin, Stdout und Stderr des Kindprozesses müssen für die Kommunikation verfügbar gemacht werden (Pipes). 37  
       * let mut command \= tokio::process::Command::new(\&server\_config.command);  
       * command.args(\&server\_config.args).stdin(std::process::Stdio::piped()).stdout(std::process::Stdio::piped()).stderr(std::process::Stdio::piped());  
       * if let Some(wd) \= \&server\_config.working\_directory { command.current\_dir(wd); }  
       * let child \= command.spawn().map\_err(|e| McpError::ServerSpawnFailed(e.to\_string()))?;  
    4. Nimmt stdin und stdout des Kindprozesses.  
    5. Erstellt einen mcp\_client\_rs::transport::stdio::StdioTransport mit den Pipes des Kindprozesses. 37  
    6. Erstellt eine mcp\_client\_rs::client::Client-Instanz mit dem Transport.  
    7. Speichert client\_handle und server\_process.  
    8. Startet den listen\_task (siehe unten) mit tokio::spawn.  
    9. Sendet McpClientStatus::Connecting über status\_broadcaster.  
    10. Sendet einen Initialize-Befehl an den command\_sender, um die MCP-Sitzung zu initialisieren. Wartet auf die Antwort.  
    11. Bei Erfolg: Sendet McpClientStatus::Connected über status\_broadcaster.  
    12. Bei Fehler: Sendet McpClientStatus::Error und gibt Fehler zurück.  
  * **Nachbedingungen:** MCP-Client ist initialisiert und verbunden, oder ein Fehler wird zurückgegeben. Der listen\_task läuft.  
  * **Fehlerfälle:** McpError::ServerSpawnFailed, McpError::TransportError, McpError::InitializationFailed.  
* async fn listen\_task(mut client\_transport\_rx: mcp\_client\_rs::transport::stdio::StdioTransportReceiver, /\*... \*/):  
  * **Logik:** Diese asynchrone Funktion läuft in einem eigenen Tokio-Task.  
  * Sie lauscht kontinuierlich auf eingehende Nachrichten vom StdioTransportReceiver (der rx-Teil des StdioTransport).  
  * Jede empfangene Nachricht (eine JSON-Zeichenkette) wird deserialisiert:  
    * Wenn es eine Antwort auf eine Anfrage ist (enthält id):  
      1. Sucht den passenden oneshot::Sender in pending\_requests anhand der id.  
      2. Sendet das Ergebnis (erfolgreiche Antwort oder Fehlerobjekt aus der Nachricht) über den oneshot::Sender.  
      3. Entfernt den Eintrag aus pending\_requests.  
    * Wenn es eine Benachrichtigung ist (enthält method, aber keine id):  
      1. Konvertiert die Benachrichtigung in eine McpNotification.  
      2. Sendet die McpNotification über den notification\_broadcaster.  
    * Wenn es eine Fehlermeldung ist, die nicht zu einer bestimmten Anfrage gehört (selten, aber möglich):  
      1. Loggt den Fehler.  
      2. Sendet ggf. McpClientStatus::Error.  
  * Behandelt Lese-/Deserialisierungsfehler und den Fall, dass der Server die Verbindung schließt (EOF auf Stdio). In solchen Fällen wird McpClientStatus::Disconnected oder McpClientStatus::Error gesendet und der Task beendet sich.  
  * Die mcp\_client\_rs Bibliothek könnte bereits einen Mechanismus zum Empfangen und Verarbeiten von Nachrichten bereitstellen (z.B. einen Stream von Nachrichten oder Callbacks). Diese Funktion würde diesen Mechanismus nutzen. 37  
* async fn send\_request\_generic\<P, R\>(\&self, method: \&str, params: P) \-\> Result\<R, McpError\>  
  where P: serde::Serialize \+ Send, R: serde::de::DeserializeOwned \+ Send:  
  * **Vorbedingungen:** Client ist verbunden.  
  * **Schritte:**  
    1. Wenn client\_handle None ist, McpError::NotConnected zurückgeben.  
    2. Generiert eine eindeutige request\_id (z.B. mit self.request\_id\_counter.fetch\_add(1, std::sync::atomic::Ordering::Relaxed).to\_string()).  
    3. Erstellt einen tokio::sync::oneshot::channel für die Antwort.  
    4. Speichert den response\_tx in pending\_requests mit der request\_id als Schlüssel.  
    5. Erstellt die JSON-RPC-Anfrage-Struktur (z.B. mcp\_client\_rs::protocol::Request).  
    6. Serialisiert die Anfrage zu einem JSON-String.  
    7. Sendet den JSON-String über den writer-Teil des StdioTransport des client\_handle. Dies wird von mcp\_client\_rs intern gehandhabt, z.B. durch eine Methode wie client.send\_request(req\_obj).await.  
    8. Wartet auf die Antwort über response\_rx.await.  
    9. Gibt das Ergebnis zurück.  
  * **Nachbedingungen:** Anfrage wurde gesendet und auf Antwort gewartet.  
  * **Fehlerfälle:** McpError::NotConnected, McpError::SerializationFailed, McpError::TransportError, McpError::RequestTimeout (falls implementiert), McpError::ServerReturnedError.  
* pub async fn list\_resources(\&self, params: mcp\_client\_rs::protocol::ListResourcesParams) \-\> Result\<mcp\_client\_rs::protocol::ListResourcesResult, McpError\>:  
  * Ruft self.send\_request\_generic("resource/list", params).await auf.  
* pub async fn read\_resource(\&self, params: mcp\_client\_rs::protocol::ReadResourceParams) \-\> Result\<mcp\_client\_rs::protocol::ReadResourceResult, McpError\>:  
  * Ruft self.send\_request\_generic("resource/read", params).await auf.  
* pub async fn call\_tool(\&self, params: mcp\_client\_rs::protocol::CallToolParams) \-\> Result\<mcp\_client\_rs::protocol::CallToolResult, McpError\>:  
  * Ruft self.send\_request\_generic("tool/run", params).await auf. 37  
* pub async fn shutdown(\&mut self) \-\> Result\<(), McpError\>:  
  * **Vorbedingungen:** Keine.  
  * **Schritte:**  
    1. Wenn client\_handle Some ist, eine shutdown-Anfrage an den Server senden (falls vom MCP-Protokoll spezifiziert und von mcp\_client\_rs unterstützt).  
    2. Den listen\_task abbrechen (self.listen\_task\_handle.as\_ref().map(|h| h.abort())).  
    3. Wenn server\_process Some ist, dem Kindprozess ein SIGTERM senden und auf sein Beenden warten (child.kill().await, child.wait().await).  
    4. self.client\_handle \= None; self.server\_process \= None;  
    5. Sendet McpClientStatus::Disconnected über status\_broadcaster.  
  * **Nachbedingungen:** Client ist heruntergefahren, Serverprozess (falls lokal) ist beendet.  
  * **Fehlerfälle:** McpError::TransportError.  
* pub fn get\_command\_sender(\&self) \-\> tokio::sync::mpsc::Sender\<McpCommand\>:  
  * Gibt einen Klon des command\_sender zurück.

### **5.4.2. Submodul: system::mcp::transport \- MCP Kommunikationstransport**

* **Datei:** system/mcp/transport.rs  
* **Zweck:** Dieses Submodul ist primär eine Abstraktionsebene, falls die verwendete mcp\_client\_rs-Bibliothek keine direkte oder anpassbare Stdio-Transportimplementierung bietet, die unseren Anforderungen genügt (z.B. spezifische Fehlerbehandlung, Logging-Integration). In den meisten Fällen wird die Transportlogik direkt vom mcp\_client\_rs::transport::stdio::StdioTransport gehandhabt.  
  * Die mcp\_client\_rs Bibliothek 37 und mcpr 38 bieten bereits Stdio-Transportmechanismen. Diese werden direkt in system::mcp::client verwendet.  
  * Dieses Modul würde nur dann eigene Implementierungen enthalten, wenn eine tiefgreifende Anpassung des Transports notwendig wäre, was aktuell nicht der Fall ist.

### **5.4.3. Submodul: system::mcp::types \- MCP Nachrichtenstrukturen und Datentypen**

* **Datei:** system/mcp/types.rs  
* **Zweck:** Definiert Rust-Strukturen, die MCP-Anfragen, \-Antworten und \-Benachrichtigungen entsprechen, sowie alle relevanten Datentypen. Diese können direkte Wrapper um die Typen aus mcp\_client\_rs::protocol und mcp\_client\_rs::types sein oder bei Bedarf eigene, anwendungsspezifische Abstraktionen darstellen.

#### **5.4.3.1. Strukuren und Enums (Beispiele, basierend auf mcp\_client\_rs und MCP-Spezifikation)**

Die meisten dieser Typen werden direkt aus dem mcp\_client\_rs::protocol und mcp\_client\_rs::types Modul re-exportiert oder als dünne Wrapper verwendet.

* pub use mcp\_client\_rs::protocol::{InitializeParams, InitializeResult, ErrorResponse, Notification, Request, Response, ListResourcesParams, ListResourcesResult, ReadResourceParams, ReadResourceResult, CallToolParams, CallToolResult, Resource, Tool}; 37  
* pub use mcp\_client\_rs::types::{Content, Document, ErrorCode, ErrorData, Message, MessageId, NotificationMessage, RequestMessage, ResponseMessage, Version}; 37  
* \#  
  pub struct McpNotification {  
  * pub method: String,  
  * pub params: Option\<serde\_json::Value\>, }  
  * **Zweck:** Eine generische Struktur für vom Server empfangene Benachrichtigungen.  
  * **Ableitung:** Aus mcp\_client\_rs::protocol::Notification.

### **5.4.4. Submodul: system::mcp::error \- MCP Client Fehlerbehandlung**

* **Datei:** system/mcp/error.rs  
* **Zweck:** Definiert die spezifischen Fehlertypen für das system::mcp-Modul.

#### **5.4.4.1. Enum McpError**

* \# pub enum McpError {  
  * \#\[error("Failed to spawn MCP server process: {0}")\]  
    ServerSpawnFailed(String),  
  * \#  
    TransportError(\#\[from\] mcp\_client\_rs::Error), // Direkte Konvertierung von Fehlern des mcp\_client\_rs Crates  
  * \#\[error("MCP client is not connected or initialized.")\]  
    NotConnected,  
  * \#\[error("Failed to initialize MCP session with server: {0}")\]  
    InitializationFailed(String), // Kann Details vom Server-Error enthalten  
  * \#\[error("Failed to serialize request: {0}")\]  
    SerializationFailed(\#\[from\] serde\_json::Error),  
  * \#  
    RequestTimeout,  
  * \#\[error("MCP server returned an error: {code} \- {message}")\]  
    ServerReturnedError { code: i64, message: String, data: Option\<serde\_json::Value\> }, // Basierend auf JSON-RPC Fehlerobjekt  
  * \#  
    UnexpectedResponse { request\_id: String },  
  * \#  
    ResponseChannelDropped { request\_id: String },  
  * \#\[error("Failed to send command to MCP client task: {0}")\]  
    CommandSendError(String),  
    }  
  * Die Felder in ServerReturnedError entsprechen typischen JSON-RPC-Fehlerobjekten.  
  * \#\[from\] wird verwendet, um Fehler von serde\_json und mcp\_client\_rs::Error direkt in McpError umzuwandeln, was die Fehlerbehandlung vereinfacht.33

## **7\. system::portals \- XDG Desktop Portals Backend**

Das Modul system::portals implementiert die Backend-Logik für ausgewählte XDG Desktop Portals.60 Diese Portale ermöglichen es sandboxed Anwendungen (wie Flatpaks, aber auch nativen Anwendungen), sicher auf Ressourcen außerhalb ihrer Sandbox zuzugreifen, z.B. für Dateiauswahldialoge oder Screenshots. Dieses Modul agiert als D-Bus-Dienst, der die Portal-Schnittstellen implementiert und Anfragen von Client-Anwendungen bearbeitet.

* **Kernfunktionalität**:  
  * Implementierung der D-Bus-Schnittstellen für org.freedesktop.portal.FileChooser und org.freedesktop.portal.Screenshot.  
  * Interaktion mit der UI-Schicht zur Anzeige von Dialogen (z.B. Dateiauswahl).  
  * Interaktion mit dem Compositor (Systemschicht) für Aktionen wie Screenshots.  
* **Verwendete Crates**: zbus für die D-Bus-Implementierung 83, ashpd (Rust-Bindings für XDG Desktop Portals, falls für Backend-Implementierung nützlich, ansonsten direkte D-Bus-Implementierung). Die Entscheidung fällt auf eine direkte Implementierung mit zbus, um volle Kontrolle zu behalten und keine unnötigen Abstraktionen einzuführen, da wir das Backend selbst bereitstellen.  
* **Modulstruktur und Dateien**:  
  * system/portals/mod.rs: Öffentliche API, PortalsError Enum, Startpunkt für den D-Bus-Dienst.  
  * system/portals/file\_chooser.rs: Implementierung des org.freedesktop.portal.FileChooser-Interfaces.  
  * system/portals/screenshot.rs: Implementierung des org.freedesktop.portal.Screenshot-Interfaces.  
  * system/portals/common.rs: Gemeinsame Hilfsfunktionen, D-Bus-Setup, Request-Handling-Logik.  
  * system/portals/error.rs: Fehlerbehandlung für das Portals-Modul.

### **5.5.1. Submodul: system::portals::file\_chooser \- FileChooser Portal Backend**

* **Datei:** system/portals/file\_chooser.rs  
* **Zweck:** Implementiert die D-Bus-Schnittstelle org.freedesktop.portal.FileChooser. Dieses Portal ermöglicht Anwendungen das Öffnen und Speichern von Dateien über einen systemeigenen Dialog, der vom Desktop-Environment bereitgestellt wird.

#### **5.5.1.1. Struktur FileChooserPortal**

* pub struct FileChooserPortal {  
  * connection: std::sync::Arc\<zbus::Connection\>,  
  * // Referenz auf UI-Service oder Kommunikationskanal zur UI-Schicht,  
  * // um Dateiauswahldialoge anzuzeigen.  
  * // z.B. ui\_event\_sender: tokio::sync::mpsc::Sender\<UiPortalCommand\> }  
  * **Initialwerte:** connection wird bei der Instanziierung übergeben. UI-Kommunikationskanäle werden ebenfalls initialisiert.  
  * **Invarianten:** connection muss eine gültige D-Bus-Verbindung sein.

#### **5.5.1.2. D-Bus Interface Implementierung (\#\[zbus::interface\])**

* **Interface-Name:** org.freedesktop.portal.FileChooser  
* **Objektpfad:** (Wird vom system::portals::common oder main.rs beim Starten des Dienstes festgelegt, typischerweise /org/freedesktop/portal/desktop)  
* **Methoden:**  
  * async fn OpenFile(\&self, parent\_window: String, title: String, options: std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>) \-\> zbus::fdo::Result\<(u32, std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>)\>  
    * **Spezifikation:** 66  
    * **Parameter parent\_window (s):** Kennung des Anwendungsfensters (oft leer, "x11:XID" oder "wayland:HANDLE"). Wird derzeit nicht streng validiert, aber für zukünftige Modalitätslogik gespeichert.  
    * **Parameter title (s):** Titel für den Dialog.  
    * **Parameter options (a{sv}):**  
      * handle\_token (s): Eindeutiges Token für die Anfrage.  
      * accept\_label (s): Optionaler Text für den "Öffnen"-Button.  
      * modal (b): Ob der Dialog modal sein soll (Standard: true).  
      * multiple (b): Ob Mehrfachauswahl erlaubt ist (Standard: false).  
      * directory (b): Ob Ordner statt Dateien ausgewählt werden sollen (Standard: false).  
      * filters (a(sa(us))): Liste von Dateifiltern. Jeder Filter: (String Name, Array\<Tuple\<u32 Typ, String Muster/MIME\>\>)  
      * current\_filter ((sa(us))): Standardmäßig ausgewählter Filter.  
      * choices (a(ssa(ss)s)): Zusätzliche Auswahlmöglichkeiten (Comboboxen/Checkboxen).  
      * current\_folder (ay): Vorgeschlagener Startordner (als Byte-Array, NUL-terminiert).  
    * **Rückgabe:** handle (o) \- Ein Objektpfad für das Request-Objekt. Die eigentlichen Ergebnisse (URIs) werden asynchron über das Response-Signal des Request-Objekts gesendet.  
      * Die Implementierung hier gibt ein Tupel (u32 response\_code, a{sv} results) direkt zurück, wie es in vielen Portal-Implementierungen üblich ist, wenn kein separates Request-Objekt für einfache Fälle erstellt wird. response\_code \= 0 für Erfolg.  
      * results enthält uris (as) und choices (a(ss)).  
    * **Implementierungsschritte:**  
      1. Generiert eine eindeutige request\_handle (z.B. basierend auf handle\_token oder UUID).  
      2. Extrahiert Optionen wie multiple, directory, filters aus options.  
      3. Sendet einen Befehl an die UI-Schicht, um einen Dateiauswahldialog mit den gegebenen Parametern anzuzeigen. Dies erfordert einen Mechanismus (z.B. einen MPSC-Kanal), um mit der UI-Schicht zu kommunizieren und das Ergebnis (ausgewählte URIs) zurückzuerhalten.  
      4. Wartet asynchron auf die Antwort von der UI-Schicht.  
      5. Wenn die UI einen oder mehrere Datei-URIs zurückgibt:  
         * Erstellt ein results Dictionary: {"uris": zbus::zvariant::Value::from(vec\!\["file:///path/to/file1",...\])}.  
         * Gibt Ok((0, results\_dict)) zurück.  
      6. Wenn der Benutzer abbricht oder ein Fehler auftritt:  
         * Gibt Ok((1, HashMap::new())) für Abbruch durch Benutzer oder einen entsprechenden Fehlercode für andere Fehler zurück.  
         * Alternativ einen D-Bus-Fehler werfen: Err(zbus::fdo::Error::Failed("Dialog cancelled by user".into())).  
  * async fn SaveFile(\&self, parent\_window: String, title: String, options: std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>) \-\> zbus::fdo::Result\<(u32, std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>)\>  
    * **Spezifikation:** 66  
    * **Parameter options (a{sv}):** Zusätzlich zu den OpenFile-Optionen:  
      * current\_name (s): Vorgeschlagener Dateiname.  
      * current\_file (ay): Pfad zur aktuell zu speichernden Datei (falls "Speichern unter" für eine vorhandene Datei).  
    * **Implementierungsschritte:** Ähnlich wie OpenFile, aber die UI zeigt einen "Speichern"-Dialog an. Die UI gibt einen einzelnen URI zurück.  
  * async fn SaveFiles(\&self, parent\_window: String, title: String, options: std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>) \-\> zbus::fdo::Result\<(u32, std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>)\>  
    * **Spezifikation:** 66  
    * **Parameter options (a{sv}):** Zusätzlich zu den OpenFile-Optionen (außer multiple, directory):  
      * files (aay): Array von Byte-Arrays, die die zu speichernden Dateinamen repräsentieren.  
    * **Implementierungsschritte:**  
      1. Die UI wird angewiesen, einen Ordnerauswahldialog anzuzeigen.  
      2. Nach Auswahl eines Ordners durch den Benutzer konstruiert dieses Backend die vollständigen URIs, indem die in options\["files"\] übergebenen Dateinamen an den ausgewählten Ordnerpfad angehängt werden.  
      3. Gibt die Liste der resultierenden URIs zurück.  
* **Signale:** Das FileChooser-Interface selbst definiert keine Signale. Antworten werden über das Response-Signal des Request-Objekts gesendet, das durch den handle-Ausgabeparameter der Methoden referenziert wird. Für eine vereinfachte Implementierung ohne explizite Request-Objekte werden die Ergebnisse direkt zurückgegeben.

### **5.5.2. Submodul: system::portals::screenshot \- Screenshot Portal Backend**

* **Datei:** system/portals/screenshot.rs  
* **Zweck:** Implementiert die D-Bus-Schnittstelle org.freedesktop.portal.Screenshot. Dieses Portal ermöglicht Anwendungen das Erstellen von Screenshots und das Auswählen von Bildschirmfarben.

#### **5.5.2.1. Struktur ScreenshotPortal**

* pub struct ScreenshotPortal {  
  * connection: std::sync::Arc\<zbus::Connection\>,  
  * // Referenz/Kanal zum Compositor (Systemschicht), um Screenshot-Aktionen auszulösen  
  * // z.B. compositor\_command\_sender: tokio::sync::mpsc::Sender\<CompositorScreenshotCommand\> }  
  * **Initialwerte:** connection wird bei der Instanziierung übergeben. Compositor-Kommunikationskanäle werden ebenfalls initialisiert.  
  * **Invarianten:** connection muss eine gültige D-Bus-Verbindung sein.

#### **5.5.2.2. D-Bus Interface Implementierung (\#\[zbus::interface\])**

* **Interface-Name:** org.freedesktop.portal.Screenshot  
* **Objektpfad:** (Wird vom system::portals::common oder main.rs beim Starten des Dienstes festgelegt, typischerweise /org/freedesktop/portal/desktop)  
* **Methoden:**  
  * async fn Screenshot(\&self, parent\_window: String, options: std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>) \-\> zbus::fdo::Result\<(u32, std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>)\>  
    * **Spezifikation:** 67  
    * **Parameter options (a{sv}):**  
      * handle\_token (s): Eindeutiges Token für die Anfrage.  
      * modal (b): Ob der Dialog modal sein soll (Standard: true).  
      * interactive (b): Ob der Benutzer Optionen zur Auswahl des Bereichs etc. erhalten soll (Standard: false). **Seit Version 2 des Protokolls.**  
    * **Rückgabe:** handle (o) \- Objektpfad für das Request-Objekt. Hier vereinfacht zu direkter Rückgabe.  
    * **Implementierungsschritte:**  
      1. Extrahiert interactive aus options.  
      2. Sendet einen Befehl an den Compositor (Systemschicht), einen Screenshot zu erstellen.  
         * Wenn interactive true ist, sollte der Compositor dem Benutzer erlauben, einen Bereich auszuwählen oder ein Fenster etc.  
         * Wenn interactive false ist, wird ein Screenshot des gesamten Bildschirms (oder des primären Bildschirms) erstellt.  
      3. Der Compositor speichert den Screenshot temporär (z.B. in $XDG\_RUNTIME\_DIR/screenshots) und gibt den Dateipfad zurück.  
      4. Konvertiert den Dateipfad in einen file:// URI.  
      5. Erstellt ein results Dictionary: {"uri": zbus::zvariant::Value::from(screenshot\_uri)}.  
      6. Gibt Ok((0, results\_dict)) zurück.  
      7. Bei Fehlern (Compositor-Fehler, Speicherfehler): Ok((error\_code,...)) oder Err(zbus::fdo::Error).  
  * async fn PickColor(\&self, parent\_window: String, options: std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>) \-\> zbus::fdo::Result\<(u32, std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>)\>  
    * **Spezifikation:** 67  
    * **Parameter options (a{sv}):**  
      * handle\_token (s): Eindeutiges Token.  
    * **Implementierungsschritte:**  
      1. Sendet einen Befehl an den Compositor, den Farbauswahlmodus zu starten (z.B. Anzeige einer Lupe unter dem Cursor).  
      2. Der Compositor meldet die ausgewählte Farbe (RGB-Werte, typischerweise als Tupel von f64 im Bereich ) zurück.  
      3. Erstellt ein results Dictionary: {"color": zbus::zvariant::Value::from((r, g, b))}.  
      4. Gibt Ok((0, results\_dict)) zurück.  
* **Properties (Version Property):**  
  * \#\[zbus(property(emits\_changed\_signal \= "const"))\] async fn version(\&self) \-\> u32 { 2 } // Oder die höchste unterstützte Version  
    * **Spezifikation:** 77  
    * Gibt die implementierte Version des Screenshot-Portals zurück.

### **5.5.3. Submodul: system::portals::common \- Gemeinsame Portal-Hilfsmittel & D-Bus Handhabung**

* **Datei:** system/portals/common.rs  
* **Zweck:** Enthält Code, der von mehreren Portal-Implementierungen gemeinsam genutzt wird, wie z.B. das Starten des D-Bus-Dienstes, die Registrierung von Objekten und Schnittstellen sowie Hilfsfunktionen für die Interaktion mit der UI- oder Systemschicht.

#### **5.5.3.1. Funktionen**

* pub async fn run\_portal\_service(ui\_command\_sender: tokio::sync::mpsc::Sender\<UiPortalCommand\>, compositor\_command\_sender: tokio::sync::mpsc::Sender\<CompositorScreenshotCommand\>) \-\> Result\<(), PortalsError\>:  
  * **Vorbedingungen:** Keine.  
  * **Schritte:**  
    1. Erstellt eine neue D-Bus-Verbindung zum Session-Bus: let connection \= zbus::ConnectionBuilder::session()?.build().await?;.83  
    2. Registriert den Dienstnamen org.freedesktop.portal.Desktop: connection.request\_name("org.freedesktop.portal.Desktop").await?;  
    3. Erstellt Instanzen der Portal-Implementierungen:  
       * let file\_chooser\_portal \= Arc::new(FileChooserPortal { connection: connection.clone(), /\* ui\_event\_sender \*/ });  
       * let screenshot\_portal \= Arc::new(ScreenshotPortal { connection: connection.clone(), /\* compositor\_command\_sender \*/ });  
    4. Registriert die Portal-Objekte und ihre Schnittstellen beim ObjectServer der Verbindung:  
       * connection.object\_server().at("/org/freedesktop/portal/desktop", file\_chooser\_portal).await?;  
       * connection.object\_server().at("/org/freedesktop/portal/desktop", screenshot\_portal).await?;  
         * **Hinweis:** zbus erlaubt das Hinzufügen mehrerer Interfaces zum selben Pfad, wenn die Interfaces unterschiedliche Namen haben. Wenn FileChooserPortal und ScreenshotPortal als separate Rust-Strukturen implementiert sind, die jeweils ein Interface bereitstellen, müssen sie entweder auf unterschiedlichen Pfaden registriert werden (was nicht der XDG-Spezifikation entspricht) oder eine einzelne Struktur muss alle Portal-Interfaces implementieren, die unter /org/freedesktop/portal/desktop angeboten werden.  
         * **Korrekter Ansatz:** Eine einzelne Struktur DesktopPortal erstellen, die alle Portal-Interfaces (FileChooser, Screenshot, etc.) als Traits implementiert oder Instanzen der spezifischen Portal-Handler hält und die Aufrufe an diese delegiert.

    Rust  
           // In system::portals::common.rs oder mod.rs  
           pub struct DesktopPortal {  
               file\_chooser: Arc\<FileChooserPortal\>,  
               screenshot: Arc\<ScreenshotPortal\>,  
               //... andere Portale  
           }

           \#\[zbus::interface(name \= "org.freedesktop.portal.FileChooser")\]  
           impl DesktopPortal {  
               async fn OpenFile(...) { self.file\_chooser.OpenFile(...).await }  
               //...  
           }

           \#  
           impl DesktopPortal {  
               async fn Screenshot(...) { self.screenshot.Screenshot(...).await }  
               //...  
           }  
           // In run\_portal\_service:  
           // let desktop\_portal\_impl \= Arc::new(DesktopPortal { file\_chooser, screenshot });  
           // connection.object\_server().at("/org/freedesktop/portal/desktop", desktop\_portal\_impl).await?;

    5. Die Funktion tritt in eine Schleife ein oder verwendet std::future::pending().await, um den Dienst am Laufen zu halten und auf D-Bus-Anfragen zu warten.  
  * **Nachbedingungen:** Der D-Bus-Dienst für die Portale läuft und ist bereit, Anfragen zu bearbeiten.  
  * **Fehlerfälle:** PortalsError::DBusConnectionFailed, PortalsError::DBusNameAcquisitionFailed, PortalsError::DBusInterfaceRegistrationFailed.  
* fn generate\_request\_handle(token\_prefix: \&str) \-\> String:  
  * Erzeugt einen eindeutigen Handle-String für Portal-Anfragen, typischerweise unter Verwendung eines Präfixes und einer UUID oder eines Zeitstempels. Beispiel: format\!("/org/freedesktop/portal/desktop/request/{}/{}", token\_prefix, uuid::Uuid::new\_v4().to\_string().replace('-', "")).

#### **5.5.3.2. Hilfsstrukturen (Beispiel)**

* pub enum UiPortalCommand {  
  * ShowOpenFile { request\_id: String, parent\_window: String, title: String, options: OpenFileOptions, response\_tx: tokio::sync::oneshot::Sender\<Result\<Vec\<String\>, PortalUiError\>\> },  
  * ShowSaveFile { request\_id: String, parent\_window: String, title: String, options: SaveFileOptions, response\_tx: tokio::sync::oneshot::Sender\<Result\<String, PortalUiError\>\> },  
  * //... weitere Befehle }  
* pub struct OpenFileOptions { /\* Felder entsprechend den D-Bus Optionen \*/ }  
* pub struct SaveFileOptions { /\* Felder entsprechend den D-Bus Optionen \*/ }  
* pub enum PortalUiError { CancelledByUser, InternalError(String) }  
* pub enum CompositorScreenshotCommand {  
  * TakeScreenshot { request\_id: String, interactive: bool, response\_tx: tokio::sync::oneshot::Sender\<Result\<String, CompositorError\>\> }, // String ist der URI  
  * PickColor { request\_id: String, response\_tx: tokio::sync::oneshot::Sender\<Result\<(f64, f64, f64), CompositorError\>\> }, }

### **5.5.4. Submodul: system::portals::error \- Fehlerbehandlung im Portals-Modul**

* **Datei:** system/portals/error.rs  
* **Zweck:** Definiert die spezifischen Fehlertypen für das system::portals-Modul.

#### **5.5.4.1. Enum PortalsError**

* \# pub enum PortalsError {  
  * \#  
    DBusConnectionFailed(\#\[from\] zbus::Error),  
  * \#  
    DBusNameAcquisitionFailed { service\_name: String, \#\[source\] source: zbus::Error },  
  * \#  
    DBusInterfaceRegistrationFailed { interface\_name: String, object\_path: String, \#\[source\] source: zbus::Error },  
  * \#\[error("Failed to send command to UI layer: {0}")\]  
    UiCommandSendError(String),  
  * \#\[error("Failed to send command to Compositor layer: {0}")\]  
    CompositorCommandSendError(String),  
  * \#\[error("UI interaction failed or was cancelled: {0}")\]  
    UiInteractionFailed(String),  
  * \#\[error("Compositor interaction failed: {0}")\]  
    CompositorInteractionFailed(String),  
  * \#\[error("Invalid options provided for portal request: {0}")\]  
    InvalidOptions(String),  
    }  
  * Die Verwendung von \#\[from\] für zbus::Error ermöglicht eine einfache Konvertierung von zbus-Fehlern.104

---

**Schlussfolgerung Systemschicht Teil 4/4**  
Mit der Spezifikation der Module system::audio, system::mcp und system::portals ist die detaillierte Ausarbeitung der Systemschicht abgeschlossen. Diese Module stellen kritische Schnittstellen zum Audiosystem, zur KI-Integration und zu Desktop-übergreifenden Diensten bereit. Die Implementierung gemäß dieser Ultra-Feinspezifikation wird eine robuste und gut integrierte Systemschicht gewährleisten, die als solide Grundlage für die darüberliegende Benutzeroberflächenschicht dient. Die konsequente Nutzung von Rust, PipeWire, D-Bus und etablierten Freedesktop-Standards sichert Modernität, Leistung und Kompatibilität. Die detaillierte Definition von Datenstrukturen, Methoden, Fehlerbehandlung und Interaktionsprotokollen minimiert Ambiguitäten und ermöglicht eine effiziente Implementierung.

# NovaDE: Ultra-Granulare Definition Interner Schnittstellen

## Präambel: Grundlegende Prinzipien

Die Architektur von NovaDE basiert auf einer Reihe fundamentaler Kommunikations- und Strukturprinzipien, die darauf abzielen, ein robustes, modulares und wartbares System zu schaffen. Diese Prinzipien sind entscheidend für das Erreichen der übergeordneten Projektziele wie Performance, intuitive Bedienung, Modernität, Modularität, Anpassbarkeit, sichere KI-Integration und Stabilität.

- **Kernprinzipien der Kommunikation:**
    - Die Interaktion zwischen den verschiedenen Schichten des Systems – Kern (Core), Domäne (Domain), System und Benutzeroberfläche (UI) – erfolgt primär über klar definierte öffentliche Programmierschnittstellen (APIs). Diese APIs werden in der Regel als Rust-Traits spezifiziert und von Service-Strukturen innerhalb der jeweiligen Schicht implementiert. Dieser Ansatz fördert ein vertragsbasiertes Interaktionsmodell, das die Kopplung zwischen den Schichten minimiert und die Austauschbarkeit von Implementierungen erleichtert.
    - Ein integraler Bestandteil der Architektur ist ein robustes, ereignisgesteuertes System. Dieses System dient der Benachrichtigung über Zustandsänderungen und ermöglicht entkoppelte Interaktionen zwischen den Schichten. Komponenten können auf relevante Ereignisse reagieren, ohne direkte Abhängigkeiten zu den Ereigniserzeugern aufbauen zu müssen. Dies ist besonders für die UI-Schicht von Bedeutung, da es reaktive Updates auf Änderungen im Domänenzustand oder Systemstatus ohne Polling-Mechanismen ermöglicht.
    - Eine strikte Schichtenarchitektur wird durchgesetzt: Höhere Schichten dürfen typischerweise nur von unmittelbar tieferliegenden Schichten abhängen. Dieses hierarchische Abhängigkeitsmodell verbessert die Modularität, Testbarkeit und Wartbarkeit, indem es zirkuläre Abhängigkeiten und unkontrollierte Interaktionen verhindert.
    - **Fehlerbehandlung:** Eine konsistente Fehlerbehandlungsstrategie wird über alle Schichten hinweg angewendet. Die `thiserror`-Bibliothek wird für die Definition von spezifischen, benutzerdefinierten Fehlertypen genutzt. `core::errors::CoreError` dient als fundamentaler Basistyp für Fehler. Es ist zwingend erforderlich, dass Fehlerketten (abrufbar über die `source()`-Methode) bei der Weitergabe oder beim Wrappen von Fehlern erhalten bleiben, um eine umfassende Fehlerdiagnose zu gewährleisten.

Die Kombination aus strikter Schichtung, einem API-First-Design (mittels Rust-Traits) und einem ereignisgesteuerten Ansatz bildet ein leistungsfähiges Fundament für NovaDE. Das Ereignissystem ist insbesondere für die UI-Schicht von entscheidender Bedeutung, da es ihr ermöglicht, reaktiv auf zugrundeliegende Änderungen im Domänenzustand oder Systemstatus zu reagieren, ohne auf ineffiziente Polling-Mechanismen zurückgreifen zu müssen. Beispielsweise kann die UI dynamisch aktualisiert werden, wenn ein `ThemeChangedEvent` vom `ThemingEngine` ausgelöst wird, anstatt periodisch den aktuellen Theme-Status abfragen zu müssen. Diese Entkopplung reduziert die Systemlast und verbessert die Reaktionsfähigkeit der Benutzeroberfläche. Die nachfolgende ultra-granulare Definition wird daher nicht nur die synchronen API-Methoden detailliert beschreiben, sondern auch die präzise Struktur, den Payload und die Semantik jedes Ereignisses, das zwischen den Schichten ausgetauscht wird. Dies stellt sicher, dass sowohl API-Konsumenten als auch Ereignis-Abonnenten ein klares und eindeutiges Verständnis der Daten haben, die sie senden oder empfangen werden.

---

**Teil 1: Ultra-Granulare Schnittstellendefinition der UI-Schicht**

Dieser Teil adressiert die primäre Anforderung einer detaillierten Schnittstellendefinition für die UI-Schicht und konzentriert sich darauf, wie diese mit der Domänen- und der Systemschicht interagiert. Die UI-Schicht ist für die Präsentation von Informationen für den Benutzer und die Übersetzung von Benutzereingaben in Aktionen auf den unteren Schichten verantwortlich.

- **1.1. Interaktionsprinzipien der UI-Schicht mit unteren Schichten**
    
    - **UI als Konsument von Domänenlogik und Systemdiensten:**
        - Die UI-Schicht agiert als primärer Interaktionspunkt mit dem Benutzer. Sie übersetzt Benutzereingaben (z.B. Klicks, Tastatureingaben, Gesten) in spezifische, wohldefinierte Aufrufe von Methoden, die von Diensten der Domänenschicht (für Geschäftslogik und Anwendungszustandsmanipulation) oder der Systemschicht (für Betriebssystem- oder Hardwareinteraktionen) bereitgestellt werden.
        - Ein entscheidender Aspekt ist, dass die UI-Schicht Ereignisse abonniert, die sowohl von der Domänen- als auch von der Systemschicht stammen. Diese Ereignisse signalisieren Zustandsänderungen oder das Auftreten bemerkenswerter Systemaktivitäten. Dies ermöglicht es der UI, ihre Darstellung dynamisch und reaktiv zu aktualisieren und so den aktuellen Zustand der Anwendung und des zugrundeliegenden Systems widerzuspiegeln.
        - Obwohl die interne Implementierung von UI-Komponenten stark auf einem Toolkit wie GTK4 basieren wird, werden die in diesem Dokument definierten Schnittstellen (zwischen UI und Domäne/System) in Form von reinen Rust-Typen, Traits und Ereignis-Strukturen spezifiziert. Diese Abstraktion stellt sicher, dass die Kernlogik von NovaDE nicht intrinsisch an ein spezifisches UI-Toolkit gebunden ist. Beispielsweise wird ein `core::types::Color` in API-Signaturen verwendet, nicht ein Toolkit-spezifischer Typ wie `gdk4::RGBA`.
    - **Zustandsverwaltung in der UI:**
        - Die UI-Schicht ist für die Verwaltung ihres eigenen Präsentationszustands verantwortlich (oft als ViewModels oder UI-spezifischer Zustand bezeichnet). Dieser Zustand wird von dem Zustand abgeleitet, der von der Domänen- und Systemschicht verwaltet wird, und muss mit diesem synchron gehalten werden.
        - Eine robuste und effiziente UI-Zustandsverwaltung ist für eine reaktionsschnelle und konsistente Benutzererfahrung von größter Bedeutung. Während die UI-Schicht ihre visuelle Darstellung und temporäre Interaktionszustände verwaltet, befindet sich die autoritative "Wahrheitsquelle" (Source of Truth) für geschäftskritische Daten innerhalb der Domänenschicht und für den Systemstatus innerhalb der Systemschicht. Die UI muss so aufgebaut sein, dass sie effizient auf Änderungen reagiert, die von diesen unteren Schichten signalisiert werden.
        - Die Benutzeranfrage liefert ein Beispiel: `ui::theming_gtk` konsumiert `AppliedThemeState` von `ThemingEngine`. Dieses Interaktionsmuster impliziert einen reaktiven Aktualisierungsmechanismus. Verschiedene Ansätze zur Zustandsverwaltung in `gtk-rs`-Anwendungen, einschließlich der Verwendung von `Rc<RefCell<T>>` für Single-Threaded Shared Mutability oder Mustern wie TEA (The Elm Architecture) oder Relm4, werden in der Forschung diskutiert.1 Für die geschichtete Architektur von NovaDE ist der am besten geeignete Ansatz, dass die UI-Schicht Domänen- und Systemereignisse abonniert. Nach dem Empfang eines Ereignisses aktualisiert die UI ihren lokalen Zustand (der GObject-Eigenschaften, Relm4-Modellfelder oder andere UI-Toolkit-spezifische Zustandscontainer sein können). Dieser ereignisgesteuerte Ansatz vermeidet eine enge Kopplung, bei der die Domänen- oder Systemschicht direkte Kenntnis von GTK-GObjects oder anderen UI-internen Details haben müsste.
        - Ereignisbehandlungsmechanismen innerhalb von GTK4 und verschiedene Zustandsverwaltungsmuster 1 sind für die interne Implementierung der UI-Schicht relevant. Dieses Schnittstellendefinitionsdokument konzentriert sich jedoch auf die Ereignisse, die die UI von unteren Schichten konsumiert, und die Daten-Payloads, die diese Ereignisse transportieren.
    - **Strategie zur Fehlerpräsentation:**
        - Die UI-Schicht trägt die Verantwortung für die Übersetzung von Fehlern, die von der Domänen- und Systemschicht empfangen werden, in benutzerfreundliche und kontextuell angemessene Benachrichtigungen, Dialoge oder visuelle Hinweise. Rohe technische Fehlerdetails sollten dem Endbenutzer nicht direkt präsentiert werden.
        - Intern könnte die UI `gtk::AlertDialog` 6 oder benutzerdefinierte Benachrichtigungs-Widgets (potenziell unter Verwendung von `gtk4-layer-shell` 9 für nicht-modale Popups) zur Darstellung dieser übersetzten Fehler verwenden. Diese Schnittstellendefinition wird spezifizieren, wie Fehlertypen (z.B. `ThemingError`, `CompositorError`) von unteren Schichten erwartet werden, von der UI behandelt und potenziell auf standardisierte benutzerorientierte Fehlerkategorien oder -nachrichten abgebildet zu werden.
        - Eine konsistente und verständliche Fehlerpräsentationsstrategie ist grundlegend für eine gute Benutzererfahrung. Die UI muss als Filter und Übersetzer fungieren und Benutzer vor komplexen oder kryptischen internen Fehlerdetails schützen. Die Benutzeranfrage spezifiziert, dass alle Schichten `thiserror`-basierte Fehler-Enums verwenden. Die UI-Schicht wird diese spezifischen Fehlertypen empfangen. Wenn beispielsweise der `WorkspaceManager` einen `WorkspaceManagerError::WorkspaceNotFound` zurückgibt, sollte die UI-Schicht diese rohe Enum-Variante nicht anzeigen. Stattdessen sollte sie dies in eine für Menschen lesbare Nachricht wie "Der ausgewählte Arbeitsbereich konnte nicht gefunden werden." übersetzen oder gegebenenfalls einen Dialog mit Wiederherstellungsoptionen anbieten. Diese Übersetzungs- und Präsentationslogik ist eine Kernaufgabe der UI-Schicht. Die Schnittstellendefinition sollte dies leiten, indem sie Fehlerkategorien vorschlägt, die die UI von jedem Dienst zu behandeln bereit sein sollte.
- 1.2. Schnittstelle der UI-Schicht mit der Domänenschicht
    
    Dieser Abschnitt definiert ultra-granular die Interaktionen der UI-Schicht mit jedem von der Domänenschicht bereitgestellten Dienst.
    
    - **1.2.1. `ThemingEngine`-API-Nutzung durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, das aktuelle visuelle Thema der NovaDE-Umgebung abzufragen und zu ändern.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `update_configuration`: `domain::theming::ThemeConfigurationUpdate { theme_name: Option<String>, variant_name: Option<String>, custom_color_palette: Option<HashMap<String, core::types::Color>> }`
            - Ausgabe von `get_current_theme_state`: `domain::theming::AppliedThemeState { theme_name: String, variant_name: String, primary_accent_color: core::types::Color, secondary_accent_color: core::types::Color, default_background_color: core::types::Color, default_text_color: core::types::Color, default_font_family: String, default_font_size: u16, border_radius: u8, shadow_intensity: f32 }`
            - Ausgabe von `get_available_themes`: `Vec<domain::theming::ThemeIdentifier { theme_id: String, display_name: String, available_variants: Vec<String>, preview_icon_path: Option<PathBuf>, author: Option<String>, description: Option<String> }>`
            - Ausgabe von `get_current_configuration`: `domain::theming::CurrentThemeConfiguration { theme_name: String, variant_name: String, custom_palette: HashMap<String, core::types::Color> }`
        - **Von der UI aufgerufene API-Methoden (aus `domain::ThemingEngine`-Trait):**
            - `fn get_current_theme_state(&self) -> Result<domain::theming::AppliedThemeState, domain::ThemingError>;`
            - `fn get_available_themes(&self) -> Result<Vec<domain::theming::ThemeIdentifier>, domain::ThemingError>;`
            - `fn get_current_configuration(&self) -> Result<domain::theming::CurrentThemeConfiguration, domain::ThemingError>;`
            - `fn update_configuration(&self, config_update: domain::theming::ThemeConfigurationUpdate) -> Result<(), domain::ThemingError>;`
            - `fn reload_themes_and_tokens(&self) -> Result<(), domain::ThemingError>;`
            - `// Die Ereignisabonnierung erfolgt über einen globalen EventBus oder eine dedizierte Abonnementmethode, falls eine feingranulare Steuerung erforderlich ist.`
        - **Von der UI konsumierte Event-Payloads:**
            - `domain::theming::ThemeChangedEvent { new_state: domain::theming::AppliedThemeState }`
        - **Fehlerbehandlung durch die UI:** Die UI muss `domain::ThemingError`-Varianten (z.B. `ThemeNotFound`, `InvalidConfiguration`, `AssetLoadFailure`) auf angemessene benutzerorientierte Nachrichten oder Wiederherstellungsaktionen abbilden.
    - **1.2.2. `WorkspaceManager`-API-Nutzung durch die UI:**
        
        - **Zweck:** Ermöglicht der UI die Verwaltung virtueller Arbeitsbereiche, einschließlich deren Erstellung, Löschung, Aktivierung und Zuweisung von Fenstern.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `create_workspace`: `domain::workspaces::CreateWorkspaceParams { name: Option<String>, layout_hint: Option<domain::workspaces::WorkspaceLayoutType>, icon_name: Option<String> }`
            - Eingabe für `assign_window_to_workspace`: `window_id: core::types::WindowId`, `workspace_id: core::types::WorkspaceId`
            - Eingabe für `rename_workspace`: `workspace_id: core::types::WorkspaceId`, `new_name: String`
            - Ausgabe von `get_active_workspace`, `get_workspace_by_id`, `list_workspaces`: `domain::workspaces::WorkspaceDescriptor { id: core::types::WorkspaceId, name: String, display_name: String, icon_name: Option<String>, layout: domain::workspaces::WorkspaceLayoutType, window_ids: Vec<core::types::WindowId>, is_active: bool, creation_timestamp: core::types::DateTime<Utc> }`
            - Enum `domain::workspaces::WorkspaceLayoutType { TilingHorizontal, TilingVertical, Floating, Maximized }`
        - **Von der UI aufgerufene API-Methoden (aus `domain::WorkspaceManager`-Trait):**
            - `fn create_workspace(&self, params: domain::workspaces::CreateWorkspaceParams) -> Result<core::types::WorkspaceId, domain::WorkspaceManagerError>;`
            - `fn delete_workspace(&self, id: core::types::WorkspaceId) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn set_active_workspace(&self, id: core::types::WorkspaceId) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn get_active_workspace(&self) -> Result<Option<domain::workspaces::WorkspaceDescriptor>, domain::WorkspaceManagerError>;`
            - `fn get_workspace_by_id(&self, id: core::types::WorkspaceId) -> Result<Option<domain::workspaces::WorkspaceDescriptor>, domain::WorkspaceManagerError>;`
            - `fn list_workspaces(&self) -> Result<Vec<domain::workspaces::WorkspaceDescriptor>, domain::WorkspaceManagerError>;`
            - `fn assign_window_to_workspace(&self, window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn remove_window_from_workspace(&self, window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn get_window_assignment(&self, window_id: core::types::WindowId) -> Result<Option<core::types::WorkspaceId>, domain::WorkspaceManagerError>;`
            - `fn save_workspace_configuration(&self) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn rename_workspace(&self, workspace_id: core::types::WorkspaceId, new_name: String) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn set_workspace_layout(&self, workspace_id: core::types::WorkspaceId, layout: domain::workspaces::WorkspaceLayoutType) -> Result<(), domain::WorkspaceManagerError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `domain::workspaces::WorkspaceCreatedEvent { descriptor: domain::workspaces::WorkspaceDescriptor }`
            - `domain::workspaces::WorkspaceDeletedEvent { workspace_id: core::types::WorkspaceId, previous_name: String }`
            - `domain::workspaces::ActiveWorkspaceChangedEvent { old_workspace_id: Option<core::types::WorkspaceId>, new_workspace_id: core::types::WorkspaceId }`
            - `domain::workspaces::WorkspaceLayoutChangedEvent { workspace_id: core::types::WorkspaceId, new_layout: domain::workspaces::WorkspaceLayoutType }`
            - `domain::workspaces::WindowAssignedToWorkspaceEvent { window_id: core::types::WindowId, new_workspace_id: core::types::WorkspaceId, old_workspace_id: Option<core::types::WorkspaceId> }`
            - `domain::workspaces::WindowRemovedFromWorkspaceEvent { window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId }`
            - `domain::workspaces::WorkspaceRenamedEvent { workspace_id: core::types::WorkspaceId, new_name: String, old_name: String }`
            - `domain::workspaces::WorkspaceOrderChangedEvent { ordered_workspace_ids: Vec<core::types::WorkspaceId> }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `domain::WorkspaceManagerError`-Varianten (z.B. `WorkspaceNotFound`, `WindowNotManaged`, `NameConflict`) auf Benutzerfeedback.
    - **1.2.3. `AIInteractionLogicService`-API-Nutzung durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, KI-gestützte Interaktionen zu initiieren, Kontextinformationen abzurufen und Benutzereinwilligungen zu verwalten.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `initiate_interaction`: `domain::ai::InteractionRequest { prompt_text: String, context_type: domain::ai::AIContextType, attachments: Option<Vec<domain::ai::AIAttachment>>, preferred_model_id: Option<String> }`
            - Enum `domain::ai::AIContextType { GeneralText, CodeGeneration, ImageAnalysis, /*... */ }`
            - Struct `domain::ai::AIAttachment { mime_type: String, data_uri: String /* or PathBuf if local */, name: Option<String> }`
            - Ausgabe von `initiate_interaction`: `domain::ai::InteractionResponseHandle { interaction_id: core::types::Uuid }` (Weitere Ergebnisse/Streams könnten über Events oder eine Streaming-API kommen)
            - Ausgabe von `get_interaction_context`: `domain::ai::InteractionContext { interaction_id: core::types::Uuid, status: domain::ai::AIInteractionStatus, history: Vec<domain::ai::AIMessage>, available_actions: Vec<domain::ai::AIActionSuggestion> }`
            - Enum `domain::ai::AIInteractionStatus { PendingInput, Processing, AwaitingConsent, Completed, Error }`
            - Struct `domain::ai::AIMessage { role: domain::ai::AIRole, content: String, timestamp: core::types::DateTime<Utc> }`
            - Enum `domain::ai::AIRole { User, Assistant, System }`
            - Struct `domain::ai::AIActionSuggestion { action_id: String, display_text: String, action_type: domain::ai::AIActionType }`
            - Enum `domain::ai::AIActionType { ExecuteCommand, InsertText, OpenLink }`
            - Eingabe für `provide_consent`: `interaction_id: core::types::Uuid, model_id: String, consent_granted: bool`
            - Ausgabe von `get_consent_for_model`: `domain::ai::AIConsentStatus { model_id: String, granted: bool, last_updated: core::types::DateTime<Utc> }`
            - Struct `domain::ai::AIModelProfile { model_id: String, display_name: String, provider: String, capabilities: Vec<domain::ai::AIContextType>, requires_consent: bool }`
        - **Von der UI aufgerufene API-Methoden (aus `domain::AIInteractionLogicService`-Trait):**
            - `async fn initiate_interaction(&self, request: domain::ai::InteractionRequest) -> Result<domain::ai::InteractionResponseHandle, domain::AIInteractionError>;`
            - `async fn get_interaction_context(&self, interaction_id: core::types::Uuid) -> Result<domain::ai::InteractionContext, domain::AIInteractionError>;`
            - `async fn provide_consent(&self, interaction_id: core::types::Uuid, model_id: String, consent_granted: bool) -> Result<(), domain::AIInteractionError>;`
            - `async fn get_consent_for_model(&self, model_id: String) -> Result<domain::ai::AIConsentStatus, domain::AIInteractionError>;`
            - `async fn store_consent(&self, model_id: String, granted: bool) -> Result<(), domain::AIInteractionError>;`
            - `async fn load_model_profiles(&self) -> Result<Vec<domain::ai::AIModelProfile>, domain::AIInteractionError>;`
            - `async fn send_message_to_interaction(&self, interaction_id: core::types::Uuid, message: domain::ai::AIMessage) -> Result<(), domain::AIInteractionError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `domain::ai::AIInteractionInitiatedEvent { interaction_id: core::types::Uuid, initial_prompt: String }`
            - `domain::ai::AIConsentUpdatedEvent { model_id: String, new_status: domain::ai::AIConsentStatus }`
            - `domain::ai::AIInteractionStatusChangedEvent { interaction_id: core::types::Uuid, new_status: domain::ai::AIInteractionStatus, details: Option<String> }`
            - `domain::ai::NewAIMessageEvent { interaction_id: core::types::Uuid, message: domain::ai::AIMessage }`
            - `domain::ai::AIInteractionErrorEvent { interaction_id: Option<core::types::Uuid>, error_message: String, is_fatal: bool }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `domain::AIInteractionError`-Varianten (z.B. `ModelUnavailable`, `ConsentRequired`, `NetworkError`) auf Benutzerfeedback.
    - **1.2.4. `NotificationService`-API-Nutzung durch die UI (primär für das Posten von UI-generierten Benachrichtigungen):**
        
        - **Zweck:** Ermöglicht der UI, anwendungsspezifische Benachrichtigungen zu erstellen und anzuzeigen, sowie bestehende Benachrichtigungen zu verwalten.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `post_notification`: `domain::notifications::NotificationData { app_name: String, app_icon: Option<String>, summary: String, body: Option<String>, actions: Vec<domain::notifications::NotificationAction>, urgency: domain::notifications::NotificationUrgency, timeout_ms: Option<u32>, category: Option<String>, transient: bool }`
            - Struct `domain::notifications::NotificationAction { id: String, display_text: String }`
            - Enum `domain::notifications::NotificationUrgency { Low, Normal, Critical }`
            - Ausgabe von `post_notification`: `notification_id: core::types::Uuid`
            - Ausgabe von `get_notification`, `list_notifications`: `domain::notifications::Notification { id: core::types::Uuid, data: domain::notifications::NotificationData, timestamp: core::types::DateTime<Utc>, is_read: bool, is_dismissed: bool }`
        - **Von der UI aufgerufene API-Methoden (aus `domain::NotificationService`-Trait):**
            - `fn post_notification(&self, notification_data: domain::notifications::NotificationData) -> Result<core::types::Uuid, domain::NotificationError>;`
            - `fn get_notification(&self, id: core::types::Uuid) -> Result<Option<domain::notifications::Notification>, domain::NotificationError>;`
            - `fn list_notifications(&self, filter: Option<domain::notifications::NotificationFilter>) -> Result<Vec<domain::notifications::Notification>, domain::NotificationError>;` // Filter könnte `unread_only`, `app_name` etc. sein
            - `fn mark_as_read(&self, id: core::types::Uuid) -> Result<(), domain::NotificationError>;`
            - `fn dismiss_notification(&self, id: core::types::Uuid) -> Result<(), domain::NotificationError>;`
            - `fn invoke_action_on_notification(&self, notification_id: core::types::Uuid, action_id: String) -> Result<(), domain::NotificationError>;`
            - `fn set_do_not_disturb(&self, enabled: bool) -> Result<(), domain::NotificationError>;`
            - `fn get_do_not_disturb_status(&self) -> Result<bool, domain::NotificationError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `domain::notifications::NotificationPostedEvent { notification: domain::notifications::Notification }`
            - `domain::notifications::NotificationDismissedEvent { notification_id: core::types::Uuid, reason: domain::notifications::DismissReason }`
            - `domain::notifications::NotificationActionInvokedEvent { notification_id: core::types::Uuid, action_id: String }`
            - `domain::notifications::DoNotDisturbChangedEvent { is_enabled: bool }`
            - Enum `domain::notifications::DismissReason { User, Timeout, Programmatic }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `domain::NotificationError`-Varianten (z.B. `NotificationNotFound`, `ActionNotFound`) auf Benutzerfeedback.
    - **1.2.5. `GlobalSettingsService`-API-Nutzung durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, globale Anwendungseinstellungen zu lesen, zu ändern und auf Standardwerte zurückzusetzen.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `update_setting`: `key: String`, `value: glib::Variant`
            - Ausgabe von `get_setting`: `Result<Option<glib::Variant>, domain::GlobalSettingsError>`
            - Ausgabe von `get_current_settings`: `Result<HashMap<String, glib::Variant>, domain::GlobalSettingsError>`
            - Struct `domain::settings::SettingDescriptor { key: String, display_name: String, description: Option<String>, value_type: glib::VariantType, current_value: glib::Variant, default_value: glib::Variant, possible_values: Option<Vec<glib::Variant>>, range: Option<(glib::Variant, glib::Variant)>, category: String }`
        - **Von der UI aufgerufene API-Methoden (aus `domain::GlobalSettingsService`-Trait):**
            - `fn load_settings(&self) -> Result<(), domain::GlobalSettingsError>;`
            - `fn save_settings(&self) -> Result<(), domain::GlobalSettingsError>;`
            - `fn get_current_settings(&self) -> Result<HashMap<String, glib::Variant>, domain::GlobalSettingsError>;`
            - `fn get_setting_descriptors(&self) -> Result<Vec<domain::settings::SettingDescriptor>, domain::GlobalSettingsError>;`
            - `fn update_setting(&self, key: String, value: glib::Variant) -> Result<(), domain::GlobalSettingsError>;`
            - `fn get_setting(&self, key: String) -> Result<Option<glib::Variant>, domain::GlobalSettingsError>;`
            - `fn reset_setting_to_default(&self, key: String) -> Result<(), domain::GlobalSettingsError>;`
            - `fn reset_all_settings_to_defaults(&self) -> Result<(), domain::GlobalSettingsError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `domain::settings::SettingChangedEvent { key: String, new_value: glib::Variant, old_value: glib::Variant }`
            - `domain::settings::SettingsLoadedEvent { settings: HashMap<String, glib::Variant> }`
            - `domain::settings::SettingsSavedEvent {}`
        - **Fehlerbehandlung durch die UI:** Abbildung von `domain::GlobalSettingsError`-Varianten (z.B. `SettingNotFound`, `InvalidValueType`, `PersistenceError`) auf Benutzerfeedback. Die Verwendung von `glib::Variant` für Einstellwerte 12 ermöglicht eine flexible Handhabung verschiedener Datentypen für Einstellungen.
    - **Schlüsseltabellen für Teil 1.2:**
        
        Für jede Methode der Domänendienst-API:
        
        1. **Methodensignatur-Tabelle:**

|   |   |   |   |
|---|---|---|---|
|**Methode**|**Parameter**|**Rückgabetyp**|**Kurzbeschreibung**|
|`ThemingEngine::get_current_theme_state`|`&self`|`Result<domain::theming::AppliedThemeState, domain::ThemingError>`|Ruft den aktuell angewendeten Theme-Zustand ab.|
|`WorkspaceManager::create_workspace`|`&self, params: domain::workspaces::CreateWorkspaceParams`|`Result<core::types::WorkspaceId, domain::WorkspaceManagerError>`|Erstellt einen neuen Arbeitsbereich.|
|...|...|...|...|

```
    2.  **Parameterdetail-Tabelle (Beispiel für `ThemingEngine::update_configuration`):**
```

|   |   |   |   |
|---|---|---|---|
|**Parametername**|**Typ**|**Erforderlich**|**Beschreibung**|
|`config_update`|`domain::theming::ThemeConfigurationUpdate`|Ja|Ein Objekt, das die gewünschten Änderungen an der Theme-Konfiguration enthält.|

```
    3.  **Rückgabewertdetail-Tabelle (Beispiel für `ThemingEngine::get_current_theme_state`):**
```

|   |   |   |
|---|---|---|
|**Erfolgsfall (Ok)**|**Fehlerfall (Err)**|**Beschreibung**|
|`domain::theming::AppliedThemeState`|`domain::ThemingError`|Enthält Details zum aktuell angewendeten Theme oder einen Fehler bei der Abfrage.|

```
    Für jedes von der UI konsumierte Domänenereignis:
    4.  **Ereignis-Payload-Detail-Tabelle (Beispiel für `ThemeChangedEvent`):**
```

|   |   |   |
|---|---|---|
|**Feldname**|**Typ**|**Beschreibung**|
|`new_state`|`domain::theming::AppliedThemeState`|Der neue Zustand des Themes nach der Änderung.|

```
    Diese Tabellen sind unerlässlich, um Entwicklern eine eindeutige und leicht zugängliche Referenz zu bieten. Sie erzwingen Konsistenz bei der Typverwendung und Methodenaufrufen und reduzieren so Integrationsfehler zwischen der UI- und der Domänenschicht erheblich. Beispielsweise beschreibt eine detaillierte Tabelle für `WorkspaceDescriptor` klar alle Informationen, die die UI über einen Arbeitsbereich erwarten kann, was die Entwicklung von UI-Komponenten wie Arbeitsbereichswechslern erleichtert.
```

- 1.3. Schnittstelle der UI-Schicht mit der Systemschicht
    
    Dieser Abschnitt definiert ultra-granular die Interaktionen der UI-Schicht mit Diensten, die von der Systemschicht bereitgestellt werden. Die Systemschicht abstrahiert Details des zugrundeliegenden Betriebssystems, der Hardware und des Fenstersystems (Wayland/X11).
    
    - **1.3.1. Compositor-Interaktion (`system::compositor_iface`) durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, Fensterinformationen abzufragen, Fensterzustände (Fokus, Geometrie) zu verwalten und Aktualisierungen über den Lebenszyklus und die Eigenschaften von Fenstern zu erhalten. Diese Schnittstelle abstrahiert die zugrundeliegenden Wayland-Compositor-Interaktionen. Die UI interagiert nicht direkt mit Wayland-Protokollen wie `wlr-foreign-toplevel-management` 17 oder `ext-foreign-toplevel-list-v1` 17; stattdessen konsumiert sie die von der Systemschicht bereitgestellten Abstraktionen.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `request_focus`: `window_id: core::types::WindowId`
            - Eingabe für `configure_window`: `window_id: core::types::WindowId`, `config: system::compositor::WindowConfigurationRequest { new_position: Option<core::types::PointInt>, new_size: Option<core::types::SizeInt>, new_state: Option<system::compositor::CompositorWindowState>, new_workspace_id: Option<core::types::WorkspaceId> }`
            - Enum `system::compositor::CompositorWindowState { Maximized, Minimized, Fullscreen, Normal, TiledLeft, TiledRight }`
            - Ausgabe von `get_window_info`, `list_managed_windows`: `system::compositor::WindowInfo { id: core::types::WindowId, title: String, app_id: core::types::AppId, class: Option<String>, geometry: core::types::RectInt, is_focused: bool, is_maximized: bool, is_minimized: bool, is_fullscreen: bool, workspace_id: Option<core::types::WorkspaceId>, can_resize: bool, can_maximize: bool, can_minimize: bool, can_close: bool, parent_window_id: Option<core::types::WindowId>, transient_for: Option<core::types::WindowId> }`
            - Ausgabe von `get_output_info`, `list_outputs`: `system::compositor::OutputInfo { id: String, name: String, description: String, geometry: core::types::RectInt, scale_factor: f32, refresh_rate_mhz: u32, current_resolution: core::types::SizeInt, available_resolutions: Vec<core::types::SizeInt>, is_primary: bool, is_enabled: bool }`
        - **Von der UI aufgerufene API-Methoden (aus `system::CompositorInterface`-Trait):**
            - `fn request_focus(&self, window_id: core::types::WindowId) -> Result<(), system::CompositorError>;`
            - `fn configure_window(&self, window_id: core::types::WindowId, config: system::compositor::WindowConfigurationRequest) -> Result<(), system::CompositorError>;`
            - `fn get_window_info(&self, window_id: core::types::WindowId) -> Result<Option<system::compositor::WindowInfo>, system::CompositorError>;`
            - `fn list_managed_windows(&self) -> Result<Vec<system::compositor::WindowInfo>, system::CompositorError>;`
            - `fn close_window(&self, window_id: core::types::WindowId) -> Result<(), system::CompositorError>;`
            - `fn list_outputs(&self) -> Result<Vec<system::compositor::OutputInfo>, system::CompositorError>;`
            - `fn get_output_info(&self, output_id: String) -> Result<Option<system::compositor::OutputInfo>, system::CompositorError>;`
            - `fn get_cursor_position(&self) -> Result<core::types::PointInt, system::CompositorError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `system::compositor::WindowCreatedEvent { info: system::compositor::WindowInfo }`
            - `system::compositor::WindowClosedEvent { window_id: core::types::WindowId }`
            - `system::compositor::WindowFocusedEvent { window_id: core::types::WindowId }`
            - `system::compositor::WindowUnfocusedEvent { window_id: core::types::WindowId }`
            - `system::compositor::WindowPropertiesChangedEvent { window_id: core::types::WindowId, changed_title: Option<String>, changed_app_id: Option<core::types::AppId>, changed_geometry: Option<core::types::RectInt>, changed_state: Option<system::compositor::CompositorWindowState> }`
            - `system::compositor::OutputAddedEvent { info: system::compositor::OutputInfo }`
            - `system::compositor::OutputRemovedEvent { output_id: String }`
            - `system::compositor::OutputConfigurationChangedEvent { info: system::compositor::OutputInfo }`
            - `system::compositor::CursorPositionChangedEvent { position: core::types::PointInt }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::CompositorError`-Varianten (z.B. `WindowNotFound`, `WaylandProtocolError`, `InvalidConfiguration`) auf Benutzerfeedback.
    - **1.3.2. Eingabeverarbeitung (`system::input_iface`) durch die UI:**
        
        - **Zweck:** Liefert der UI verarbeitete Eingabeereignisse (Tastatur, Maus, Touch, Gesten) und ermöglicht es der UI, den Fokus zu steuern.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `request_keyboard_focus`: `window_id: core::types::WindowId` (kann auch über `compositor_iface` laufen, hier zur Verdeutlichung der Input-Intention)
            - Event-Payloads für `KeyboardEvent`, `PointerEvent`, `TouchEvent`, `GestureEvent` (detaillierte Definitionen erforderlich, z.B. `KeyEvent { key_code: u32, modifiers: KeyModifiers, state: KeyState, utf8: Option<String> }`).
        - **Von der UI aufgerufene API-Methoden (aus `system::InputInterface`-Trait):**
            - `fn request_keyboard_focus(&self, window_id: core::types::WindowId) -> Result<(), system::InputError>;` (kann Duplikat zu Compositor-API sein, aber semantisch hier relevant)
            - `fn set_cursor_theme(&self, theme_name: String, size: u32) -> Result<(), system::InputError>;`
            - `fn get_current_keyboard_layout(&self) -> Result<String, system::InputError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `system::input::KeyboardEvent { window_id: Option<core::types::WindowId>, /*... event details... */ }`
            - `system::input::PointerButtonEvent { window_id: Option<core::types::WindowId>, /*... event details... */ }`
            - `system::input::PointerMotionEvent { window_id: Option<core::types::WindowId>, /*... event details... */ }`
            - `system::input::PointerAxisEvent { window_id: Option<core::types::WindowId>, /*... event details... */ }`
            - `system::input::TouchEvent { window_id: Option<core::types::WindowId>, /*... event details... */ }`
            - `system::input::GestureEvent { window_id: Option<core::types::WindowId>, gesture_type: system::input::GestureType, /*... event details... */ }`
            - `system::input::FocusChangedEvent { new_focus_window_id: Option<core::types::WindowId>, old_focus_window_id: Option<core::types::WindowId> }` (kann auch vom Compositor kommen)
            - `system::input::KeyboardLayoutChangedEvent { new_layout_name: String }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::InputError`-Varianten.
    - **1.3.3. D-Bus Client-Schnittstellen (`system::dbus::*`) Nutzung durch die UI:**
        
        - **Allgemein:** Die UI interagiert mit D-Bus-Diensten über typsichere Rust-Wrapper, die von der Systemschicht bereitgestellt werden. Die UI konsumiert Ereignisse und ruft Methoden dieser Wrapper auf. Die Komplexität der D-Bus-Kommunikation (z.B. mit `zbus` 19 oder `gio::DBusConnection` 22) wird von der Systemschicht gekapselt.
        - **`system::dbus::upower_client_iface`:**
            - Events: `system::dbus::UPowerDeviceChangedEvent { device_id: String, percentage: f64, state: UPowerDeviceState, time_to_empty_s: Option<u64>, time_to_full_s: Option<u64> }`
        - **`system::dbus::logind_client_iface`:**
            - Methoden: `fn lock_session(&self) -> Result<(), system::DBusError>;`
            - Events: `system::dbus::LogindSessionEvent { event_type: LogindEventType /* Lock, Unlock, Sleep, Wakeup */ }`
        - **`system::dbus::networkmanager_client_iface`:**
            - Methoden: `fn list_access_points(&self, device_path: String) -> Result<Vec<system::dbus::AccessPointInfo>, system::DBusError>;`, `fn connect_to_access_point(&self, device_path: String, ap_bssid: String, password: Option<String>) -> Result<(), system::DBusError>;`
            - Datenstrukturen: `AccessPointInfo { bssid: String, ssid: String, strength: u8, security_flags: u32, is_active: bool }` (basierend auf NetworkManager D-Bus API 23)
            - Events: `system::dbus::NetworkStateChangedEvent { connectivity: NetworkConnectivityState, primary_connection_type: Option<String> }`, `system::dbus::AccessPointsChangedEvent { device_path: String }`
        - **`system::dbus::secrets_client_iface`:**
            - Methoden: `async fn prompt_for_secret(&self, prompt_message: String) -> Result<Option<String>, system::DBusError>;` (interagiert mit UI für Prompts)
    - **1.3.4. Output-Management (`system::outputs_iface`) durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, Informationen über angeschlossene Displays abzurufen und deren Konfiguration (Auflösung, Skalierung, Position) zu ändern.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `configure_output`: `output_id: String`, `config: system::outputs::OutputConfigurationRequest { resolution: Option<core::types::SizeInt>, scale: Option<f32>, position: Option<core::types::PointInt>, enabled: Option<bool>, refresh_rate_mhz: Option<u32> }`
            - Ausgabe von `list_outputs`, `get_output_details`: `system::outputs::OutputDetails` (ähnlich `system::compositor::OutputInfo`, aber ggf. mit mehr Konfigurationsdetails wie verfügbare Modi, aktuelle Skalierung, etc.)
        - **Von der UI aufgerufene API-Methoden (aus `system::OutputInterface`-Trait):**
            - `fn list_outputs(&self) -> Result<Vec<system::outputs::OutputDetails>, system::OutputError>;`
            - `fn get_output_details(&self, output_id: String) -> Result<Option<system::outputs::OutputDetails>, system::OutputError>;`
            - `fn configure_output(&self, output_id: String, config: system::outputs::OutputConfigurationRequest) -> Result<(), system::OutputError>;`
            - `fn set_primary_output(&self, output_id: String) -> Result<(), system::OutputError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `system::outputs::OutputConfigurationChangedEvent { output_id: String, new_details: system::outputs::OutputDetails }` (kann auch vom Compositor kommen, hier ggf. spezifischer für Output-Management-Aktionen)
            - `system::outputs::OutputConnectedEvent { details: system::outputs::OutputDetails }`
            - `system::outputs::OutputDisconnectedEvent { output_id: String }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::OutputError`-Varianten.
    - **1.3.5. Audio-Management (`system::audio_iface`) durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, Audio-Geräte und -Streams zu verwalten, Lautstärken zu regeln und Audio-Ereignisse zu empfangen. Abstrahiert PipeWire-Interaktionen.26
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `set_volume`: `device_id: String`, `stream_id: Option<String>`, `volume_percent: f32`, `is_muted: Option<bool>`
            - Ausgabe von `list_audio_devices`, `get_audio_device_details`: `system::audio::AudioDeviceDetails { id: String, name: String, device_type: AudioDeviceType /* Input, Output */, current_volume_percent: f32, is_muted: bool, available_ports: Vec<String>, active_port: Option<String> }`
            - Ausgabe von `list_audio_streams`: `system::audio::AudioStreamDetails { id: String, application_name: String, media_role: String, current_volume_percent: f32, is_muted: bool }`
        - **Von der UI aufgerufene API-Methoden (aus `system::AudioInterface`-Trait):**
            - `fn list_audio_devices(&self, device_type_filter: Option<system::audio::AudioDeviceType>) -> Result<Vec<system::audio::AudioDeviceDetails>, system::AudioError>;`
            - `fn get_audio_device_details(&self, device_id: String) -> Result<Option<system::audio::AudioDeviceDetails>, system::AudioError>;`
            - `fn set_device_volume(&self, device_id: String, volume_percent: f32) -> Result<(), system::AudioError>;`
            - `fn set_device_mute(&self, device_id: String, muted: bool) -> Result<(), system::AudioError>;`
            - `fn set_default_output_device(&self, device_id: String) -> Result<(), system::AudioError>;`
            - `fn set_default_input_device(&self, device_id: String) -> Result<(), system::AudioError>;`
            - `fn list_audio_streams(&self) -> Result<Vec<system::audio::AudioStreamDetails>, system::AudioError>;`
            - `fn set_stream_volume(&self, stream_id: String, volume_percent: f32) -> Result<(), system::AudioError>;`
            - `fn set_stream_mute(&self, stream_id: String, muted: bool) -> Result<(), system::AudioError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `system::audio::AudioDeviceChangedEvent { device_details: system::audio::AudioDeviceDetails }`
            - `system::audio::AudioDeviceAddedEvent { device_details: system::audio::AudioDeviceDetails }`
            - `system::audio::AudioDeviceRemovedEvent { device_id: String }`
            - `system::audio::AudioStreamAddedEvent { stream_details: system::audio::AudioStreamDetails }`
            - `system::audio::AudioStreamRemovedEvent { stream_id: String }`
            - `system::audio::AudioStreamVolumeChangedEvent { stream_id: String, new_volume_percent: f32, is_muted: bool }`
            - `system::audio::DefaultDeviceChangedEvent { device_type: system::audio::AudioDeviceType, new_default_device_id: String }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::AudioError`-Varianten.
    - **1.3.6. MCP-Client (`system::mcp_client_iface`) Nutzung durch die UI:**
        
        - **Zweck:** Stellt der UI KI-Funktionen zur Verfügung, z.B. für die Befehlspalette oder andere intelligente UI-Elemente.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `request_ai_completion`: `prompt: String`, `context_data: HashMap<String, glib::Variant>`, `max_tokens: Option<u32>`
            - Ausgabe von `request_ai_completion`: `system::mcp::AICompletionResponse { completion_id: core::types::Uuid, text_result: Option<String>, structured_result: Option<glib::Variant>, error_message: Option<String> }`
        - **Von der UI aufgerufene API-Methoden (aus `system::MCPClientInterface`-Trait):**
            - `async fn request_ai_completion(&self, prompt: String, context_data: HashMap<String, glib::Variant>, options: system::mcp::AICompletionOptions) -> Result<system::mcp::AICompletionResponse, system::MCPError>;`
            - `async fn get_ai_capabilities(&self) -> Result<Vec<system::mcp::AICapabilityDescriptor>, system::MCPError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `system::mcp::AIModelStatusChangedEvent { model_id: String, is_available: bool }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::MCPError`-Varianten.
    - **1.3.7. XDG Desktop Portals (`system::portals_iface`) Nutzung durch die UI:**
        
        - **Zweck:** Ermöglicht der UI die Interaktion mit XDG Desktop Portals für Aktionen wie Dateiauswahl, Screenshots, etc., auf eine sandkastenfreundliche Weise. Die Systemschicht abstrahiert die direkte D-Bus-Kommunikation mit den Portal-Diensten. Die `ashpd`-Bibliothek 28 ist ein gutes Beispiel für eine solche Abstraktionsebene, die die Systemschicht intern nutzen könnte.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `open_file_dialog`: `parent_window_identifier: system::portals::WindowIdentifier`, `title: String`, `options: system::portals::OpenFileOptions { multiple: bool, directory: bool, filters: Vec<system::portals::FileFilter> }`
            - Struct `system::portals::FileFilter { name: String, patterns: Vec<String> /* z.B. "*.txt" */ }`
            - Ausgabe von `open_file_dialog`: `Vec<PathBuf>` (URIs werden von der Systemschicht in Pfade konvertiert)
            - Eingabe für `save_file_dialog`: `parent_window_identifier: system::portals::WindowIdentifier`, `title: String`, `options: system::portals::SaveFileOptions { current_name: Option<String>, current_folder: Option<PathBuf>, filters: Vec<system::portals::FileFilter> }`
            - Ausgabe von `save_file_dialog`: `Option<PathBuf>`
            - Typ `system::portals::WindowIdentifier`: Ein plattformagnostischer Handle für ein Fenster, der intern zu Wayland- oder X11-spezifischen Handles aufgelöst wird, wie von `ashpd` benötigt.
        - **Von der UI aufgerufene API-Methoden (aus `system::PortalsInterface`-Trait):**
            - `async fn open_file_dialog(&self, parent_window_identifier: system::portals::WindowIdentifier, title: String, options: system::portals::OpenFileOptions) -> Result<Vec<PathBuf>, system::PortalError>;`
            - `async fn save_file_dialog(&self, parent_window_identifier: system::portals::WindowIdentifier, title: String, options: system::portals::SaveFileOptions) -> Result<Option<PathBuf>, system::PortalError>;`
            - `async fn take_screenshot(&self, parent_window_identifier: system::portals::WindowIdentifier, interactive: bool, include_cursor: bool) -> Result<Option<PathBuf>, system::PortalError>;`
            - `async fn pick_color(&self, parent_window_identifier: system::portals::WindowIdentifier) -> Result<Option<core::types::Color>, system::PortalError>;`
        - **Von der UI konsumierte Event-Payloads:** (Portals sind typischerweise Request-Response, weniger eventbasiert für die UI direkt, außer Status-Events des Portal-Dienstes selbst, die hier aber nicht im Fokus stehen).
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::PortalError`-Varianten (z.B. `UserCancelled`, `PortalNotAvailable`, `BackendError`).
    - **Schlüsseltabellen für Teil 1.3:** Ähnlich wie in Teil 1.2 werden Tabellen für Methodensignaturen, Parameterdetails, Rückgabewertdetails und Ereignis-Payload-Details für jede definierte Systemschicht-Schnittstelle erstellt.
        
        - Die Interaktionen der Systemschicht sind oft komplex und beinhalten viele Low-Level-Details (z.B. D-Bus-Varianten, Wayland-Protokollspezifika). Tabellen machen die abstrahierte Rust-API klar und reduzieren die Mehrdeutigkeit für UI-Entwickler.

---

**Teil 2: Ultra-Granulare Schnittstellendefinition der Kernschicht (Erweiterung des Benutzerdokuments)**

- 2.1. Kernschicht zu allen höheren Schichten
    
    Die Kernschicht (core) stellt fundamentale Bausteine und Dienste bereit, die von allen höheren Schichten (Domäne, System, UI) genutzt werden. Ihre Schnittstellen müssen daher besonders stabil und klar definiert sein.
    
    - **`core::types`:**
        
        - **Datentypen:** Stellt eine Sammlung grundlegender, wiederverwendbarer Datentypen bereit.
            - `Point<T> { x: T, y: T }` (generisch für numerische Typen wie `f32`, `i32`)
            - `Size<T> { width: T, height: T }` (generisch)
            - `Rect<T> { origin: Point<T>, size: Size<T> }` (generisch)
            - `RectInt` ist ein Typalias für `Rect<i32>`.
            - `Color { r: u8, g: u8, b: u8, a: u8 }` (RGBA-Format)
            - `Orientation { Horizontal, Vertical }` (Enum)
            - `Uuid` (Wrapper um die `uuid::Uuid`-Bibliothek, um eine konsistente Verwendung sicherzustellen)
            - `DateTime<Utc>` (Wrapper um `chrono::DateTime<chrono::Utc>`, um Zeitzonenprobleme zu standardisieren)
            - `WindowId` (Typalias, z.B. `pub type WindowId = u64;` oder eine spezifischere Struktur, falls Metadaten benötigt werden)
            - `WorkspaceId` (Typalias, z.B. `pub type WorkspaceId = core::types::Uuid;`)
            - `AppId` (Typalias, z.B. `pub type AppId = String;`, oft im Reverse-DNS-Format wie `org.novade.FileExplorer`)
        - **Nutzung:** Diese Typen werden direkt in den öffentlichen APIs und internen Logiken der höheren Schichten für Geometrieberechnungen, Farbangaben, eindeutige Identifikatoren, Zeitstempel und spezifische Entitäts-IDs verwendet. Die Standardisierung dieser Typen in der Kernschicht verhindert Inkonsistenzen und erleichtert die Interoperabilität zwischen den Modulen.
    - **`core::errors`:**
        
        - **Basis-Fehlertyp:**
            
            Rust
            
            ```
            #
            pub enum CoreError {
                #[error("I/O error: {source}")]
                Io { #[from] source: std::io::Error },
                #[error("Configuration parsing error: {0}")]
                ConfigParseError(String),
                #[error("Invalid state: {0}")]
                InvalidState(String),
                #[error("Functionality not implemented")]
                NotImplemented,
                #[error("Custom error: {0}")]
                Custom(String),
                #
                SerializationJson { #[from] source: serde_json::Error },
                // Weitere generische Fehlerkategorien hier hinzufügen
            }
            ```
            
        - **Modul-spezifische Fehlerstrategie:** Höhere Schichten und Module innerhalb der Kernschicht definieren ihre eigenen spezifischen Fehler-Enums mit `thiserror`. Diese spezifischen Fehler sollten `CoreError` oder andere relevante Fehler wrappen, um die Fehlerkette zu erhalten.
            - Beispiel: `core::config::ConfigError` könnte eine Variante haben wie:
                
                Rust
                
                ```
                #
                pub enum ConfigError {
                    #[error("Failed to open configuration file '{path}': {source}")]
                    FileOpenFailed { path: PathBuf, #[source] source: CoreError },
                    #[error("Failed to parse configuration: {message}")]
                    ParseFailed { message: String, #[source] source: Option<serde_json::Error> },
                    //...
                }
                ```
                
        - **Fehler-Wrapping-Illustration:**
            
            Rust
            
            ```
            // In einem hypothetischen Modul
            #
            pub enum MyModuleError {
                #[error("Failed to read file for stuff: {source}")]
                FileReadFailed(#[source] CoreError),
                //...
            }
            
            fn read_file_content(path: &PathBuf) -> Result<String, CoreError> {
                std::fs::read_to_string(path).map_err(CoreError::from)
            }
            
            fn load_stuff(file_path: &PathBuf) -> Result<(), MyModuleError> {
                let _content = read_file_content(file_path).map_err(MyModuleError::FileReadFailed)?;
                //... weitere Logik...
                Ok(())
            }
            ```
            
            Diese Strategie stellt sicher, dass der ursprüngliche Kontext des Fehlers (`source()`) verfügbar bleibt, was die Fehlersuche und -behebung erheblich erleichtert.
    - **`core::logging`:**
        
        - **Initialisierungsroutine:**
            
            Rust
            
            ```
            pub enum LogOutput {
                Stdout,
                Stderr,
                File(PathBuf),
            }
            
            pub fn initialize_logging(level: tracing::Level, output: LogOutput, format: LogFormat) -> Result<(), CoreError>;
            pub enum LogFormat { Json, Pretty, Compact }
            ```
            
            Diese Funktion konfiguriert das globale Logging-System (basierend auf `tracing`).
        - **Konvention für `tracing`-Makros:**
            - Alle Schichten verwenden die Standard-`tracing`-Makros (`trace!`, `debug!`, `info!`, `warn!`, `error!`).
            - Strukturierte Log-Nachrichten werden bevorzugt, um kontextbezogene Daten effizient zu erfassen: `trace!(target: "core::module_name", "Processing item {}", item_id, item_type = %item.kind, user_id = %current_user.id);`
            - Das `target`-Feld sollte das Modul oder die Komponente angeben, aus der die Log-Nachricht stammt (z.B. `core::config`, `domain::theming`).
            - Spezifische Felder (z.B., `window.id = %window_id`, `event.name = "ThemeChanged"`) sollten verwendet werden, um das Filtern und Analysieren von Logs zu erleichtern.
    - **`core::config`:**
        
        - **`CoreConfig`-Struktur:** Definiert die globalen Kernkonfigurationen. Diese Struktur wird beim Start der Anwendung geladen und als unveränderlich betrachtet.
            
            Rust
            
            ```
            #
            pub struct LoggingConfig {
                pub level: String, // z.B. "info", "debug"
                pub output: String, // z.B. "stdout", "/var/log/novade.log"
                pub format: String, // z.B. "json", "pretty"
            }
            
            #
            pub struct ThemeConfig {
                pub default_theme_name: String,
                pub default_variant: String,
                pub icon_theme: String,
            }
            
            #
            pub struct AIServiceConfig {
                pub service_url: Option<String>,
                pub default_model_id: Option<String>,
                pub consent_required_by_default: bool,
            }
            
            #
            pub struct CoreConfig {
                pub logging: LoggingConfig,
                pub theming: ThemeConfig,
                pub ai: AIServiceConfig,
                pub default_workspace_layout: String, // z.B. "Tiling", "Floating"
                // Weitere Kernkonfigurationen
            }
            ```
            
        - **Konfigurations-API:**
            - `pub fn load_core_config(path: &PathBuf) -> Result<CoreConfig, ConfigError>;` Lädt die Konfiguration aus einer Datei (z.B. TOML oder JSON).
            - `pub fn get_core_config() -> Result<&'static CoreConfig, CoreError>;` Bietet globalen, schreibgeschützten Zugriff auf die geladene Kernkonfiguration. Dies setzt voraus, dass die Konfiguration nach der Initialisierung in einem globalen statischen Speicher (z.B. `once_cell::sync::OnceCell` oder `std::sync::OnceLock`) gehalten wird.
        - **`ConfigError`-Enum:**
            
            Rust
            
            ```
            #
            pub enum ConfigError {
                #[error("Configuration file not found at path: {0}")]
                FileNotFound(PathBuf),
                #[error("Failed to open configuration file '{path}': {source}")]
                FileOpenFailed { path: PathBuf, #[source] source: CoreError },
                #[error("Failed to read configuration file '{path}': {source}")]
                FileReadFailed { path: PathBuf, #[source] source: CoreError },
                #[error("Failed to parse configuration from '{path}': {message}")]
                ParseFailed { path: PathBuf, message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync>> }, // Box für Flexibilität bei Parser-Fehlern
                #[error("Configuration validation failed: {0}")]
                ValidationError(String),
            }
            ```
            
            (Hinweis: `Box<dyn std::error::Error + Send + Sync>` für `source` in `ParseFailed` ermöglicht das Wrappen verschiedener Parser-Fehler, z.B. `serde_json::Error`, `toml::de::Error`).
    - **`core::utils`:**
        
        - **Hilfsfunktionen:** Stellt allgemeine, zustandslose Hilfsfunktionen bereit, die von mehreren Schichten genutzt werden können. Diese sollten in thematisch gruppierten Untermodulen organisiert sein.
            - `core::utils::string_utils`: Funktionen zur String-Manipulation (z.B. `truncate_with_ellipsis(text: &str, max_len: usize) -> String;`).
            - `core::utils::geometry_utils`: Einfache geometrische Berechnungen, die nicht in `core::types` selbst implementiert sind (z.B. `fn calculate_rect_area(rect: &core::types::RectInt) -> i32;`).
            - `core::utils::time_utils`: Formatierungs- oder Vergleichsfunktionen für `DateTime<Utc>` (z.B. `fn format_datetime_human_readable(dt: &core::types::DateTime<Utc>) -> String;` unter Verwendung von `chrono::format::strftime`).
            - `core::utils::uuid_utils`: Funktionen zur Erzeugung oder Validierung von UUIDs (z.B. `fn generate_v4_uuid() -> core::types::Uuid;`).
        - **Nutzung:** Direkte Verwendung durch alle höheren Schichten nach Bedarf. Da diese Funktionen zustandslos sind, führen sie keine Seiteneffekte ein und sind einfach zu testen. Die Signaturen dieser Hilfsfunktionen sind Teil der internen API der Kernschicht und sollten bei Stabilitätserwägungen berücksichtigt werden.
    - **Schlüsseltabellen für Teil 2.1:**
        
        1. **`core::types` Detail-Tabelle:**

|   |   |   |   |
|---|---|---|---|
|**Typname**|**Struktur / Enum-Definition**|**Generische Parameter**|**Beschreibung**|
|`Point<T>`|`struct Point<T> { x: T, y: T }`|`T: Copy + Num`|Repräsentiert einen Punkt im 2D-Raum.|
|`Color`|`struct Color { r: u8, g: u8, b: u8, a: u8 }`|-|Repräsentiert eine RGBA-Farbe.|
|`Uuid`|`struct Uuid(uuid::Uuid);`|-|Wrapper für einen universell eindeutigen Identifikator.|
|`DateTime<Utc>`|`struct DateTime<Utc>(chrono::DateTime<chrono::Utc>);`|-|Repräsentiert einen Zeitpunkt in UTC.|
|...|...|...|...|

```
    2.  **`CoreError` Varianten-Tabelle:**
```

|   |   |   |
|---|---|---|
|**Variante**|**Assoziierte Daten (#[from], #[source], Felder)**|**#[error("...")] Format-String**|
|`Io`|`#[from] source: std::io::Error`|`"I/O error: {source}"`|
|`ConfigParseError`|`String` (Meldung)|`"Configuration parsing error: {0}"`|
|`SerializationJson`|`#[from] source: serde_json::Error`|`"Serialization error (serde_json): {source}"`|
|...|...|...|

```
    3.  **`CoreConfig` Felder-Tabelle:**
```

|   |   |   |   |
|---|---|---|---|
|**Feldname**|**Typ**|**Beschreibung**|**Standardwert (falls zutreffend)**|
|`logging`|`LoggingConfig`|Konfiguration für das Logging-System.|Siehe `LoggingConfig`|
|`theming`|`ThemeConfig`|Standard-Theme-Einstellungen.|Siehe `ThemeConfig`|
|`default_workspace_layout`|`String`|Standard-Layout für neue Arbeitsbereiche (z.B. "Tiling").|`"Floating"`|
|...|...|...|...|

```
    Diese Tabellen bieten eine klare, strukturierte Übersicht über die von der Kernschicht bereitgestellten fundamentalen Elemente und sind für Entwickler aller höheren Schichten von entscheidender Bedeutung.
```

---

**Teil 3: Ultra-Granulare Schnittstellendefinition der Domänenschicht (Erweiterung des Benutzerdokuments)**

Die Domänenschicht enthält die Kernlogik und den Zustand der Anwendung. Ihre Schnittstellen definieren, wie höhere Schichten (System und UI) diese Logik nutzen und auf Zustandsänderungen reagieren können.

- **3.1. Domänenschicht zu System- & UI-Schichten (Allgemeine Prinzipien)**
    
    - **Logik und Zustand:** Jede Domänen-Service-Komponente kapselt einen spezifischen Aspekt der Geschäftslogik und des zugehörigen Zustands. Diese werden über öffentliche Methoden der Service-Traits und durch das Aussenden von domänenspezifischen Ereignissen bereitgestellt.
        - Für jeden Domänendienst wird explizit der von ihm verwaltete Zustand (z.B. für `ThemingEngine`: aktuelles Theme, verfügbare Themes, benutzerdefinierte Farbpaletten) und die wichtigsten Geschäftsregeln, die er durchsetzt (z.B. für `WorkspaceManager`: keine zwei Arbeitsbereiche mit demselben Namen, ein Fenster kann nur einem Arbeitsbereich zugewiesen sein), dokumentiert.
    - **Fehlertypen:** Jedes Modul innerhalb der Domänenschicht definiert seine eigenen, auf `thiserror` basierenden Fehler-Enums. Diese Fehler sind spezifisch für die jeweilige Domänenlogik und bieten detaillierte Informationen über aufgetretene Probleme.
        - Beispiel für `ThemingError`:
            
            Rust
            
            ```
            #
            pub enum ThemingError {
                #
                ThemeNotFound { name: String, path: Option<PathBuf> },
                #
                VariantNotFound { theme_name: String, variant_name: String },
                #[error("Failed to load theme assets for '{theme_name}': {source}")]
                AssetLoadError { theme_name: String, #[source] source: core::errors::CoreError },
                #[error("Invalid theme configuration: {message}")]
                InvalidConfiguration { message: String },
                #
                TokenNotFound { theme_name: String, token_name: String },
                #[error("Failed to parse color value '{value}' for token '{token_name}'")]
                ColorParseError { token_name: String, value: String },
            }
            ```
            
            (Diese detaillierte Definition wird für alle im Benutzerdokument genannten Fehler wie `WorkspaceCoreError`, `WindowAssignmentError`, etc. wiederholt.)
    - **Events:** Domänenspezifische Ereignisse werden ausgelöst, um andere Schichten über signifikante Zustandsänderungen oder abgeschlossene Aktionen zu informieren. Die Payload jedes Ereignisses ist so gestaltet, dass sie alle relevanten Informationen enthält, die ein Konsument benötigt, um ohne weitere Abfragen reagieren zu können.
        - Beispiel für `ThemeChangedEvent`:
            
            Rust
            
            ```
            # // Serialize/Deserialize falls Events über IPC gehen könnten
            pub struct PaletteDetails {
                pub primary_accent: core::types::Color,
                pub secondary_accent: core::types::Color,
                pub foreground: core::types::Color,
                pub background: core::types::Color,
                //... weitere relevante Farbdefinitionen
            }
            
            #
            pub struct ThemeChangedEvent {
                pub new_theme_name: String,
                pub new_variant_name: String,
                pub applied_palette: PaletteDetails, // Statt nur IDs, die volle Information
                pub font_details: FontDescription, // Annahme einer Struktur für Font-Details
            }
            
            #
            pub struct FontDescription {
                pub family: String,
                pub size_pt: f32,
                pub style: String, // z.B. "Regular", "Bold"
            }
            ```
            
            (Diese detaillierte Definition wird für alle im Benutzerdokument genannten Ereignisse wie `WorkspaceEvent`, `AIInteractionInitiatedEvent`, etc. wiederholt.)
- **3.2. Spezifische Domänen-Service-Schnittstellen (Ultra-Granular):**
    
    - **`ThemingEngine` API:**
        
        - **Trait Definition:**
            
            Rust
            
            ```
            pub trait ThemingEngine: Send + Sync {
                /// Ruft den aktuell angewendeten und aufgelösten Theme-Zustand ab.
                fn get_current_theme_state(&self) -> Result<AppliedThemeState, ThemingError>;
            
                /// Listet alle verfügbaren Themes und deren Varianten auf.
                fn get_available_themes(&self) -> Result<Vec<ThemeIdentifier>, ThemingError>;
            
                /// Ruft die aktuelle, persistierte Theme-Konfiguration ab (z.B. ausgewählter Theme-Name, Variante, Overrides).
                fn get_current_configuration(&self) -> Result<ThemeConfiguration, ThemingError>;
            
                /// Aktualisiert die Theme-Konfiguration. Änderungen werden persistiert und lösen ggf. ein `ThemeChangedEvent` aus.
                fn update_configuration(&self, config_update: ThemeConfigurationUpdate) -> Result<(), ThemingError>;
            
                /// Lädt alle Theme-Definitionen und Farb-Token neu vom Dateisystem oder der konfigurierten Quelle.
                fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>;
            
                /// Abonniert Änderungen am Theme-Zustand.
                /// Gibt einen Receiver-Endpunkt eines Broadcast-Kanals zurück, über den `ThemeChangedEvent`s empfangen werden können.
                /// Alternativ könnte dies über einen zentralen EventBus erfolgen.
                fn subscribe_to_theme_changes(&self) -> Result<tokio::sync::broadcast::Receiver<ThemeChangedEvent>, ThemingError>;
            }
            ```
            
        - **Datenstrukturen:**
            - `AppliedThemeState { name: String, variant: String, primary_color: core::types::Color, text_color: core::types::Color, background_color: core::types::Color, accent_colors: HashMap<String, core::types::Color>, font_family: String, font_size_pt: f32, raw_tokens: HashMap<String, String> /* Für Debugging oder fortgeschrittene Nutzung */ }`
            - `ThemeIdentifier { id: String, name: String, display_name: String, description: Option<String>, author: Option<String>, variants: Vec<ThemeVariantIdentifier> }`
            - `ThemeVariantIdentifier { id: String, name: String, display_name: String, preview_image_path: Option<PathBuf> }`
            - `ThemeConfiguration { current_theme_id: String, current_variant_id: String, custom_palette_overrides: HashMap<String, core::types::Color>, font_scale_factor: Option<f32> }`
            - `ThemeConfigurationUpdate { theme_id: Option<String>, variant_id: Option<String>, set_custom_palette_overrides: Option<HashMap<String, core::types::Color>>, remove_custom_palette_overrides: Option<Vec<String>>, font_scale_factor: Option<f32> }`
        - **Events:**
            - `ThemeChangedEvent { new_state: AppliedThemeState }` (wie oben definiert, Payload enthält alle relevanten Infos)
        - **Fehler:** `ThemingError` (Varianten wie oben detailliert definiert: `ThemeNotFound`, `VariantNotFound`, `AssetLoadError`, `InvalidConfiguration`, `TokenNotFound`, `ColorParseError`).
    - **`WorkspaceManager` API:**
        
        - **Trait Definition:**
            
            Rust
            
            ```
            pub trait WorkspaceManager: Send + Sync {
                fn create_workspace(&self, params: CreateWorkspaceParams) -> Result<WorkspaceDescriptor, WorkspaceManagerError>;
                fn delete_workspace(&self, workspace_id: core::types::WorkspaceId) -> Result<(), WorkspaceManagerError>;
                fn set_active_workspace(&self, workspace_id: core::types::WorkspaceId) -> Result<(), WorkspaceManagerError>;
                fn get_active_workspace(&self) -> Result<Option<WorkspaceDescriptor>, WorkspaceManagerError>;
                fn get_workspace_by_id(&self, workspace_id: core::types::WorkspaceId) -> Result<Option<WorkspaceDescriptor>, WorkspaceManagerError>;
                fn list_workspaces(&self) -> Result<Vec<WorkspaceDescriptor>, WorkspaceManagerError>;
                fn assign_window_to_workspace(&self, window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId) -> Result<(), WorkspaceManagerError>;
                fn assign_window_to_active_workspace(&self, window_id: core::types::WindowId) -> Result<(), WorkspaceManagerError>;
                fn remove_window_from_workspace(&self, window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId) -> Result<(), WorkspaceManagerError>;
                fn get_window_assignment(&self, window_id: core::types::WindowId) -> Result<Option<core::types::WorkspaceId>, WorkspaceManagerError>;
                fn save_configuration(&self) -> Result<(), WorkspaceManagerError>; // Persistiert die aktuelle Arbeitsbereichsanordnung und -konfiguration
                fn load_configuration(&self) -> Result<(), WorkspaceManagerError>; // Lädt die Konfiguration beim Start
                fn rename_workspace(&self, workspace_id: core::types::WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>;
                fn set_workspace_layout(&self, workspace_id: core::types::WorkspaceId, layout: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>;
                fn reorder_workspaces(&self, ordered_workspace_ids: Vec<core::types::WorkspaceId>) -> Result<(), WorkspaceManagerError>;
                fn subscribe_to_workspace_events(&self) -> Result<tokio::sync::broadcast::Receiver<WorkspaceEvent>, WorkspaceManagerError>;
            }
            ```
            
        - **Datenstrukturen:**
            - `CreateWorkspaceParams { name: Option<String>, layout_hint: Option<WorkspaceLayoutType>, icon_name: Option<String>, activate_when_created: bool }`
            - `WorkspaceDescriptor { id: core::types::WorkspaceId, name: String, display_name: String, icon_name: Option<String>, layout: WorkspaceLayoutType, window_ids: Vec<core::types::WindowId>, is_active: bool, creation_timestamp: core::types::DateTime<Utc>, last_accessed_timestamp: core::types::DateTime<Utc> }`
            - `WorkspaceLayoutType { TilingHorizontal, TilingVertical, Floating, MaximizedSingleWindow }`
        - **Events (als Enum `WorkspaceEvent` zusammengefasst für einfacheres Abonnement):**
            
            Rust
            
            ```
            #
            pub enum WorkspaceEvent {
                WorkspaceCreated { descriptor: WorkspaceDescriptor },
                WorkspaceDeleted { workspace_id: core::types::WorkspaceId, previous_name: String },
                ActiveWorkspaceChanged { old_workspace_id: Option<core::types::WorkspaceId>, new_workspace_id: core::types::WorkspaceId, new_descriptor: WorkspaceDescriptor },
                WorkspaceLayoutChanged { workspace_id: core::types::WorkspaceId, new_layout: WorkspaceLayoutType },
                WindowAssignedToWorkspace { window_id: core::types::WindowId, new_workspace_id: core::types::WorkspaceId, old_workspace_id: Option<core::types::WorkspaceId> },
                WindowRemovedFromWorkspace { window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId },
                WorkspaceRenamed { workspace_id: core::types::WorkspaceId, new_name: String, old_name: String },
                WorkspaceOrderChanged { ordered_workspace_ids: Vec<core::types::WorkspaceId> },
                WorkspaceConfigurationSaved,
                WorkspaceConfigurationLoaded,
            }
            ```
            
        - **Fehler:** `WorkspaceManagerError`, `WorkspaceConfigError`, `WindowAssignmentError` (jeweils mit detaillierten Varianten wie `WorkspaceNotFound`, `NameAlreadyExists`, `WindowNotKnownToCompositor`, `ConfigSaveFailed`, `ConfigLoadFailed`).
    - **(Diese Detailtiefe wird für `AIInteractionLogicService`, `NotificationService` und `GlobalSettingsService` wiederholt, basierend auf den im Benutzerdokument und in Teil 1.2 dieses Dokuments skizzierten Schnittstellen. Für `GlobalSettingsService` ist die Verwendung von `glib::Variant` für Einstellwerte hervorzuheben, um Flexibilität bei den Datentypen zu gewährleisten.12)**
        
    - Schlüsseltabellen für Teil 3.2:
        
        Ähnlich wie in Teil 1.2 und Teil 2.1 werden für jeden Domänendienst detaillierte Tabellen für Methodensignaturen, Parameter, Rückgabewerte und Ereignis-Payloads erstellt.
        
        - **Beispiel: `AIInteractionLogicService` Methodenübersicht**

|   |   |   |   |
|---|---|---|---|
|**Methode**|**Parameter**|**Rückgabetyp (async Result<_, _>)**|**Kurzbeschreibung**|
|`initiate_interaction`|`&self, request: domain::ai::InteractionRequest`|`Result<domain::ai::InteractionResponseHandle, domain::AIInteractionError>`|Startet eine neue KI-Interaktion.|
|`get_interaction_context`|`&self, interaction_id: core::types::Uuid`|`Result<domain::ai::InteractionContext, domain::AIInteractionError>`|Ruft den aktuellen Kontext und Verlauf einer Interaktion ab.|
|`provide_consent`|`&self, interaction_id: core::types::Uuid, model_id: String, granted: bool`|`Result<(), domain::AIInteractionError>`|Gibt die Zustimmung für ein bestimmtes Modell im Kontext einer Interaktion.|
|...|...|...|...|

```
    *   **Beispiel: `AIInteractionStatusChangedEvent` Payload**
```

|   |   |   |
|---|---|---|
|**Feldname**|**Typ**|**Beschreibung**|
|`interaction_id`|`core::types::Uuid`|ID der Interaktion, deren Status sich geändert hat.|
|`new_status`|`domain::ai::AIInteractionStatus`|Der neue Status der Interaktion.|
|`details`|`Option<String>`|Zusätzliche Details oder Fehlermeldung zum Statuswechsel.|

```
    Die präzise Definition dieser Domänenschnittstellen ist fundamental, da sie die Kernfunktionalität von NovaDE kapseln und die Verträge für die Interaktion mit der System- und UI-Schicht festlegen.
```

---

**Teil 4: Ultra-Granulare Schnittstellendefinition der Systemschicht (Erweiterung des Benutzerdokuments)**

Die Systemschicht ist verantwortlich für die Interaktion mit dem zugrundeliegenden Betriebssystem, der Hardware und Low-Level-Diensten wie dem Compositor, Eingabegeräten und D-Bus-Diensten. Sie stellt der UI-Schicht abstrahierte Schnittstellen zu diesen systemnahen Funktionen bereit.

- **4.1. Systemschicht zu UI-Schicht (Allgemeine Prinzipien)**
    
    - **Systemnahe Dienste und Ereignisse:** Die Systemschicht stellt der UI-Schicht Informationen und Ereignisse bereit, die direkt vom Betriebssystem, der Hardware oder systemnahen Daemons stammen. Für jede Kategorie (z.B. Fenstergeometrie, Eingabeereignisse, Systemstatusänderungen) werden spezifische Ereignisse mit detaillierten Payloads definiert.
    - **Technische Umsetzung von UI-Befehlen:** Die Systemschicht empfängt Befehle von der UI-Schicht (z.B. Fenster verschieben, Arbeitsbereich wechseln, Fokus anfordern) und setzt diese technisch um, indem sie mit dem Compositor, dem Fenstermanager oder anderen Systemkomponenten interagiert. Für jeden solchen Befehl wird eine exakte Methodensignatur in der API der Systemschicht definiert, die von der UI aufgerufen wird.
    - **Renderer-Schnittstelle (`system::compositor::renderer_interface`):** Obwohl nicht direkt von der UI-Schicht konsumiert, stellt diese Schnittstelle eine Abstraktion für das Rendering bereit. Wenn diese Schnittstelle Implikationen dafür hat, wie UI-Elemente letztendlich dargestellt werden (z.B. unterstützte Oberflächenformate, Anforderungen an Textur-Sharing), werden diese kurz vermerkt, da sie indirekt die UI-Implementierung beeinflussen können.
    - **Fehlertypen:** Jedes Modul der Systemschicht (z.B. `system::compositor`, `system::input`) definiert eigene, auf `thiserror` basierende Fehler-Enums (z.B. `CompositorError`, `InputError`). Diese Fehler-Enums listen alle spezifischen Fehlerzustände auf, die bei der Interaktion mit den jeweiligen Systemkomponenten auftreten können.
- **4.2. Spezifische Systemschicht-Schnittstellen (Ultra-Granular, für UI-Interaktion):**
    
    - **Compositor-Schnittstelle (`system::compositor_iface`):**
        
        - Diese Schnittstelle wird als Trait `CompositorInterface` definiert, um eine klare API für die UI-Schicht bereitzustellen.
        - **Methoden, die von der UI aufgerufen werden:**
            
            Rust
            
            ```
            pub trait CompositorInterface: Send + Sync {
                /// Fordert den Fokus für ein bestimmtes Fenster an.
                fn request_focus(&self, window_id: core::types::WindowId) -> Result<(), CompositorError>;
            
                /// Verschiebt ein Fenster an eine neue Position.
                fn move_window(&self, window_id: core::types::WindowId, new_pos: core::types::PointInt) -> Result<(), CompositorError>;
            
                /// Ändert die Größe eines Fensters.
                fn resize_window(&self, window_id: core::types::WindowId, new_size: core::types::SizeInt) -> Result<(), CompositorError>;
            
                /// Fordert einen neuen Zustand für ein Fenster an (z.B. Maximieren, Minimieren).
                fn set_window_state(&self, window_id: core::types::WindowId, state: CompositorWindowState) -> Result<(), CompositorError>;
            
                /// Schließt ein Fenster.
                fn close_window(&self, window_id: core::types::WindowId) -> Result<(), CompositorError>;
            
                /// Ruft detaillierte Informationen zu einem bestimmten Fenster ab.
                fn get_window_info(&self, window_id: core::types::WindowId) -> Result<Option<WindowInfo>, CompositorError>;
            
                /// Listet alle aktuell vom Compositor verwalteten Fenster auf.
                fn list_windows(&self) -> Result<Vec<WindowInfo>, CompositorError>;
            
                /// Ruft Informationen zu allen verfügbaren Outputs (Monitoren) ab.
                fn list_outputs(&self) -> Result<Vec<OutputInfo>, CompositorError>;
            
                /// Konfiguriert einen Output (Auflösung, Skalierung, etc.).
                fn configure_output(&self, output_id: String, config: OutputConfigurationRequest) -> Result<(), CompositorError>;
            
                /// Abonniert Compositor-Ereignisse.
                fn subscribe_to_compositor_events(&self) -> Result<tokio::sync::broadcast::Receiver<CompositorEvent>, CompositorError>;
            }
            ```
            
        - **Datenstrukturen:**
            - `WindowInfo { id: core::types::WindowId, title: String, app_id: core::types::AppId, class: Option<String>, geometry: core::types::RectInt, is_focused: bool, is_fullscreen: bool, is_maximized: bool, is_minimized: bool, workspace_id: Option<core::types::WorkspaceId>, parent_id: Option<core::types::WindowId>, transient_for_id: Option<core::types::WindowId>, can_resize: bool, can_maximize: bool, can_minimize: bool, can_close: bool, pid: Option<u32> }`
            - `CompositorWindowState { Maximized, Minimized, Fullscreen, Normal, TiledLeft, TiledRight, Floating }`
            - `OutputInfo { id: String, name: String, description: String, manufacturer: Option<String>, model: Option<String>, serial_number: Option<String>, physical_size_mm: Option<core::types::Size<u32>>, geometry_pixels: core::types::RectInt, scale_factor: f32, current_refresh_rate_mhz: u32, current_mode: OutputMode, available_modes: Vec<OutputMode>, is_primary: bool, is_enabled: bool, transform: core::types::Orientation }`
            - `OutputMode { width_px: u32, height_px: u32, refresh_rate_mhz: u32, is_preferred: bool }`
            - `OutputConfigurationRequest { resolution: Option<core::types::SizeInt>, scale: Option<f32>, position: Option<core::types::PointInt>, enabled: Option<bool>, refresh_rate_mhz: Option<u32>, transform: Option<core::types::Orientation>, is_primary: Option<bool> }`
        - **Events (als Enum `CompositorEvent` für das Abonnement):**
            
            Rust
            
            ```
            #
            pub enum CompositorEvent {
                WindowCreated { info: WindowInfo },
                WindowClosed { window_id: core::types::WindowId, app_id: core::types::AppId },
                WindowFocused { window_id: core::types::WindowId },
                WindowUnfocused { window_id: core::types::WindowId },
                WindowPropertiesChanged { window_id: core::types::WindowId, changed_properties: WindowPropertiesDelta },
                OutputAdded { info: OutputInfo },
                OutputRemoved { output_id: String },
                OutputConfigurationChanged { info: OutputInfo }, // Enthält den neuen Zustand des Outputs
                // Weitere Ereignisse wie Workspace-Wechsel, wenn vom Compositor direkt gemeldet
            }
            
            #
            pub struct WindowPropertiesDelta {
                pub title: Option<String>,
                pub app_id: Option<core::types::AppId>,
                pub class: Option<Option<String>>, // Option<Option<T>> um 'wurde auf None gesetzt' von 'wurde nicht geändert' zu unterscheiden
                pub geometry: Option<core::types::RectInt>,
                pub is_fullscreen: Option<bool>,
                pub is_maximized: Option<bool>,
                pub is_minimized: Option<bool>,
                pub workspace_id: Option<Option<core::types::WorkspaceId>>,
            }
            ```
            
        - **Fehler:** `CompositorError` mit Varianten wie `WindowNotFound`, `OutputNotFound`, `InvalidOperationForWindowState`, `WaylandCommunicationError(String)`, `X11CommunicationError(String)`.
        - Die Systemschicht abstrahiert hier die Komplexität von Wayland-Protokollen wie `wlr-foreign-toplevel-management` 17 oder `ext-foreign-toplevel-list-v1` 17, die für Taskbars und Docks zur Abfrage von Fensterlisten fundamental sind. Die UI konsumiert die `WindowInfo`-Struktur, die von dieser Abstraktion bereitgestellt wird. Für die Implementierung von UI-Elementen wie Panels oder Docks, die eine feste Position auf dem Bildschirm einnehmen, wird die Systemschicht intern `gtk4-layer-shell` 9 verwenden und eine abstrahierte API dafür anbieten.
    - **(Diese Detailtiefe wird für `system::input_iface`, `system::dbus::upower_client_iface`, `system::dbus::logind_client_iface`, `system::dbus::networkmanager_client_iface` (unter Berücksichtigung von D-Bus-Spezifikationen für NetworkManager 23 und BlueZ 20), `system::outputs_iface` (bereits teilweise in Compositor-Schnittstelle enthalten, hier ggf. spezifischere Konfigurationsmethoden), `system::audio_iface` (Abstraktion von PipeWire 26), `system::mcp_client_iface` und `system::portals_iface` (Abstraktion von XDG Desktop Portals, potenziell unter Verwendung von Bibliotheken wie `ashpd` 28) wiederholt, wie in Teil 1, Abschnitt 1.3 skizziert.)**
        
        - Für `system::portals_iface` ist die `WindowIdentifier`-Struktur, die von `ashpd` verwendet wird, ein wichtiger Aspekt, um Portal-Dialoge korrekt dem aufrufenden Anwendungsfenster zuzuordnen. Die Systemschicht muss einen Mechanismus bereitstellen, um diese Kennung von der UI zu erhalten oder abzuleiten.
    - Schlüsseltabellen für Teil 4.2:
        
        Ähnlich wie in den vorherigen Teilen werden für jede Systemschicht-Schnittstelle detaillierte Tabellen für Methodensignaturen, Parameter, Rückgabewerte und Ereignis-Payloads erstellt.
        
        - **Beispiel: `InputInterface` Methodenübersicht**

|   |   |   |   |
|---|---|---|---|
|**Methode**|**Parameter**|**Rückgabetyp (Result<_, _>)**|**Kurzbeschreibung**|
|`set_cursor_theme`|`&self, theme_name: String, size: u32`|`Result<(), system::InputError>`|Setzt das Cursor-Theme und die Größe.|
|`get_current_keyboard_layout`|`&self`|`Result<String, system::InputError>`|Ruft das aktuell aktive Tastaturlayout ab.|
|`subscribe_to_input_events`|`&self`|`Result<tokio::sync::broadcast::Receiver<system::input::InputEventEnum>, system::InputError>`|Abonniert verarbeitete Eingabeereignisse.|

```
    *   **Beispiel: `system::input::InputEventEnum` Payload (Auszug)**
        ```rust
        #
        pub enum InputEventEnum {
            Keyboard(KeyboardEvent),
            PointerButton(PointerButtonEvent),
            PointerMotion(PointerMotionEvent),
            //... weitere Event-Typen
        }

        #
        pub struct KeyboardEvent {
            pub window_id: Option<core::types::WindowId>, // Fenster, das den Fokus hatte, falls zutreffend
            pub key_code: u32,          // System-agnostischer Keycode
            pub raw_key_code: u32,      // Hardware-Keycode
            pub modifiers: KeyModifiers, // Bitmaske für Shift, Ctrl, Alt, Super
            pub state: KeyState,        // Pressed, Released
            pub utf8: Option<String>,   // Decodiertes Zeichen, falls vorhanden
            pub timestamp_us: u64,      // Zeitstempel in Mikrosekunden
        }
        // Definitionen für KeyModifiers, KeyState, PointerButtonEvent etc. folgen
        ```

    Die klare Definition dieser Systemschicht-APIs ist entscheidend, da sie die Brücke zwischen der plattformunabhängigen UI-Logik und den plattformspezifischen Implementierungen schlägt.
```

---

**Teil 5: Verfeinerte Schichtübergreifende Schnittstellenprinzipien und Fortgeschrittene Themen**

Dieser Abschnitt behandelt übergreifende Prinzipien und fortgeschrittene Aspekte, die für das Design und die Implementierung der internen Schnittstellen von NovaDE von Bedeutung sind.

- 5.1. Asynchrone Operationen und UI-Synchronisation
    
    Die Reaktionsfähigkeit der Benutzeroberfläche ist ein primäres Ziel. Viele Operationen, insbesondere solche, die Netzwerkzugriffe, Dateisystemoperationen oder komplexe Berechnungen beinhalten (z.B. Aufrufe an AIInteractionLogicService oder MCPClientInterface), sind inhärent asynchron. Es ist unerlässlich, dass die UI nicht blockiert, während auf den Abschluss dieser Operationen gewartet wird.
    
    - **Muster für von der UI initiierte asynchrone Aufrufe:**
        
        - Die UI-Schicht ruft eine `async fn` Methode eines Domänen- oder Systemdienstes auf (z.B. `async fn perform_long_task() -> Result<Data, ServiceError>;`).
        - Um ein Blockieren des UI-Threads zu verhindern, sollte die UI-Komponente, die die Operation initiiert (z.B. bei einem Button-Klick), die asynchrone Funktion in einer separaten Task ausführen. In einer `gtk4-rs` Umgebung wird hierfür typischerweise `tokio::spawn` (oder ein äquivalenter Executor) verwendet, falls die Service-Methode selbst `Send` ist, oder `glib::MainContext::spawn_local` für nicht-`Send` Futures, die auf dem Hauptthread laufen müssen, aber dennoch asynchron sind.
    - **Übermittlung von Ergebnissen/Fehlern an den UI-Thread:**
        
        - **`glib::MainContext::spawn_local`:** Dies ist der bevorzugte Mechanismus in `gtk4-rs`, um UI-Aktualisierungen sicher auf dem Haupt-GTK-Thread zu planen, sobald eine asynchrone Operation abgeschlossen ist.3
            - **Ablaufbeispiel:**
                1. Eine UI-Komponente (z.B. ein Button-Klick-Handler) startet eine Tokio-Task (`tokio::spawn`).
                2. Diese Tokio-Task führt `await` auf den Aufruf des Domänen- oder Systemdienstes aus.
                3. Nach Abschluss der Operation (ob `Ok` oder `Err`) verwendet die Tokio-Task `main_context.spawn_local(...)`, um eine Closure zu planen.
                4. Diese Closure, die nun garantiert auf dem Hauptthread ausgeführt wird, aktualisiert die GTK-Widgets mit dem Ergebnis oder dem Fehler.
        - **Kanäle (z.B. `tokio::sync::mpsc`, `async_channel`):**
            - Der UI-Thread hält das `Receiver`-Ende des Kanals. Die asynchrone Task (z.B. in einem Tokio-Thread) hält das `Sender`-Ende.
            - Nach Abschluss der asynchronen Operation wird das Ergebnis oder der Fehler über den Kanal gesendet.
            - Der UI-Thread, typischerweise in einer `glib::idle_add_local`-Schleife oder einem `glib::MainContext::spawn_local`-Future, das den Receiver abfragt, verarbeitet eingehende Nachrichten und aktualisiert die Widgets.
            - Es ist wichtig zu beachten, dass `glib::MainContext::channel()` in neueren GLib-Versionen entfernt wurde.39 Der empfohlene Ansatz ist die Verwendung von Standard-Async-Kanälen (wie `async_channel` oder `tokio::sync::mpsc`) und dann `glib::MainContext::default().spawn_local()`, um die Ergebnisse auf den Hauptthread für UI-Aktualisierungen zu bringen. Diese Änderung vereinfacht die Codebasis, da sie auf etablierte asynchrone Rust-Patterns setzt, anstatt eine GLib-spezifische Kanallösung zu verwenden. Die Schnittstellendefinition selbst schreibt diese interne UI-Implementierung nicht vor, aber die Dokumentation für UI-Entwickler, die diese asynchronen APIs konsumieren, sollte dieses Muster empfehlen.
        - **Fehlerbehandlung in asynchroner UI:** Fehler von asynchronen Operationen müssen ebenfalls auf den Hauptthread gemarshallt und angemessen dargestellt werden. Dies kann beispielsweise durch die Anzeige eines `gtk::AlertDialog` 6 oder einer nicht-modalen Benachrichtigung geschehen.
    - **Tabelle: Asynchrones Interaktionsmuster**
        

|   |   |   |   |   |
|---|---|---|---|---|
|**Schritt**|**Aktion**|**Thread**|**Mechanismus**|**Anmerkungen**|
|1|Benutzerinteraktion|UI-Thread|GTK-Signal|z.B. Button-Klick|
|2|Asynchronen Aufruf initiieren|UI-Thread|`tokio::spawn` (für `Send` Futures)|Startet eine neue Task für den Service-Aufruf, um den UI-Thread nicht zu blockieren.|
|3|Service-Methode ausführen|Worker-Thread (Tokio)|`await service.method()`|Ruft die asynchrone Methode des Domänen-/Systemdienstes auf.|
|4a|Ergebnis/Fehler senden (Kanal-Ansatz)|Worker-Thread (Tokio)|`sender.send(result).await`|Sendet das Ergebnis an einen Kanal, der vom UI-Thread überwacht wird.|
|4b|UI-Update planen (Direkter Spawn-Ansatz)|Worker-Thread (Tokio)|`main_context.spawn_local(async move {... })`|Plant direkt eine Closure zur UI-Aktualisierung auf dem Hauptthread.|
|5a|Empfangen & Verarbeiten (Kanal-Ansatz)|UI-Thread|`receiver.recv().await` (in `spawn_local`)|Die Closure in `spawn_local` empfängt die Nachricht und aktualisiert GTK-Widgets.|
|5b|UI-Update ausführen (Direkter Spawn-Ansatz)|UI-Thread|Ausführung der Closure|Die geplante Closure wird ausgeführt und aktualisiert GTK-Widgets.|

```
    Diese Tabelle verdeutlicht das Threading-Modell und den Kommunikationsfluss für asynchrone Operationen, die von der UI initiiert werden. Dies ist ein häufiger Bereich für Komplexität und Fehlerquellen, daher ist ein klares Verständnis dieses Musters entscheidend.
```

- 5.2. Ereignissystem: Granulare Semantik
    
    Das Ereignissystem ist ein Rückgrat für die reaktive Natur von NovaDE. Eine präzise Definition der Ereignissemantik ist unerlässlich.
    
    - **Ereignisdefinition:** Jede Ereignisstruktur (`struct`) muss vollständig definiert sein, einschließlich aller Felder und deren exakter Rust-Typen. Die Nutzdaten (Payload) eines Ereignisses sollten umfassend sein, um es den Konsumenten zu ermöglichen, ohne zusätzliche Abfragen an den Ereigniserzeuger zu reagieren. Beispielsweise sollte ein `ThemeChangedEvent` nicht nur eine ID des neuen Themes enthalten, sondern direkt die `AppliedThemeState`-Struktur, die alle relevanten Details des neuen Themes beinhaltet. Dies minimiert den Kommunikationsaufwand und verbessert die Performance.
    - **Payload-Serialisierung:** Für die interne Kommunikation zwischen den Schichten innerhalb desselben Prozesses ist eine direkte Übergabe von Rust-Strukturen ausreichend und performant. Sollten Ereignisse jedoch zukünftig über Prozessgrenzen hinweg kommuniziert werden (z.B. über D-Bus an externe Komponenten), muss ein Serialisierungsformat (z.B. Serde mit JSON/CBOR oder GVariant für D-Bus) definiert werden. Die aktuellen Ereignisstrukturen sollten mit `#` annotiert werden, um diese zukünftige Erweiterbarkeit vorzubereiten.
    - **Ereignisgarantien:**
        - **Reihenfolge:** Innerhalb eines bestimmten Geltungsbereichs (z.B. Ereignisse von einem einzelnen Service) ist typischerweise davon auszugehen, dass Ereignisse in der Reihenfolge empfangen werden, in der sie ausgelöst wurden, vorausgesetzt, der Emitter ist single-threaded oder verwendet geeignete Synchronisationsmechanismen. Für einen systemweiten Event-Bus kann die globale Reihenfolge komplexer sein und hängt von der Implementierung des Busses ab.
        - **Zustellung:** Für einen In-Prozess-Event-Bus wird typischerweise eine "At-least-once"-Zustellung angestrebt, solange die Abonnenten aktiv sind und keine Fehler im Bus selbst auftreten. Garantien für "Exactly-once" sind komplexer zu implementieren.
    - **Abonnement-Mechanismus:**
        - Es muss eine klare API für Komponenten geben, um spezifische Ereignistypen zu abonnieren. Dies könnte über einen zentralen `EventBus` erfolgen: `event_bus.subscribe::<ThemeChangedEvent>(|event: &ThemeChangedEvent| { /* UI-Logik hier */ });`.
        - Der Event-Bus sollte Filterfunktionen unterstützen, z.B. das Abonnieren von `WorkspaceEvent` nur für eine bestimmte `workspace_id` oder das Filtern von `SettingChangedEvent` nach einem bestimmten `setting_key`.
        - Die zurückgegebenen `tokio::sync::broadcast::Receiver` von den `subscribe_to_..._events` Methoden der Service-Traits sind ein Beispiel für einen solchen Mechanismus.
    - **Broadcasting vs. Gezielte Ereignisse:** Die meisten Domänen- und Systemereignisse werden als Broadcast an alle interessierten Abonnenten gesendet. Gezielte Ereignisse (nur an einen bestimmten Listener) sind seltener und erfordern einen komplexeren Registrierungs- und Routing-Mechanismus. Für die interne Schichtkommunikation ist Broadcasting meist ausreichend.
    - Die Reaktivität der Benutzeroberfläche hängt stark von einem wohldefinierten und zuverlässigen Ereignissystem ab. Granulare Ereignis-Payloads sind der Schlüssel zur Minimierung von Daten-Refetching und zur Gewährleistung einer performanten UI. GTK4-Signale und Ereignisbehandlungsmechanismen werden intern von der UI-Schicht verwendet, um auf diese anwendungsweiten Ereignisse zu reagieren, die von den unteren Schichten über den Event-Bus oder direkte Abonnements empfangen werden.
- **5.3. API-Versionierung und Evolution (Kurzer Hinweis)**
    
    - APIs unterliegen im Laufe der Zeit Änderungen. Um die Stabilität und Wartbarkeit des Systems langfristig zu gewährleisten, sollten Strategien für die API-Evolution berücksichtigt werden:
        - **Hinzufügen neuer Methoden zu Traits:** Dies ist für bestehende Implementierer nicht-brechend, wenn die neuen Methoden Standardimplementierungen haben (obwohl dies für Kern-APIs seltener der Fall ist).
        - **Hinzufügen neuer optionaler Felder zu Strukturen/Event-Payloads:** Erfordert eine sorgfältige Behandlung durch die Konsumenten (z.B. Verwendung von `Option<T>` und `#[serde(default)]`).
        - **Einführung neuer Versionen von Traits (z.B. `ThemingEngineV2`):** Für signifikante, brechende Änderungen ist dies der sauberste Ansatz.
    - Diese Überlegungen sind zunächst auf hoher Ebene, aber wichtig für die langfristige Gesundheit des Projekts. Eine klare Dokumentation von Änderungen und Deprecation-Policys ist ebenfalls entscheidend.

---

**Teil 6: Schnittstellendetails UI-Komponenten-spezifisch**

Dieser Abschnitt widmet sich der ultra-granularen Definition der Interaktionen spezifischer UI-Komponenten mit den zuvor definierten Domänen- und System-APIs. Er beleuchtet, wie Schlüsselkomponenten der Benutzeroberfläche diese Schnittstellen nutzen, um ihre Funktionalität zu realisieren.

- **6.1. Window Manager Frontend (`ui::window_manager_frontend`)**
    - **Verantwortlichkeiten:** Anzeige von Fensterrepräsentationen (z.B. in einer Taskleiste, Alt-Tab-Umschalter), Bearbeitung von Fokusanfragen für Fenster von UI-Elementen.
    - **Interaktion mit `system::compositor_iface`:**
        - Konsumiert `system::compositor::WindowCreatedEvent`, `WindowClosedEvent`, `WindowFocusedEvent`, `WindowUnfocusedEvent`, `WindowPropertiesChangedEvent`, um seine interne Liste der Fenster und deren Zustände zu aktualisieren.
        - Ruft `compositor_iface.request_focus(window_id)` auf, wenn der Benutzer ein Fenster auswählt (z.B. durch Klick in der Taskleiste).
        - Ruft `compositor_iface.set_window_state(window_id, CompositorWindowState::Minimized)` oder `close_window(window_id)` auf, basierend auf Benutzeraktionen.
    - **Interne UI-Modelldatenstrukturen:**
        - `UIWindowRepresentation { id: core::types::WindowId, title: String, app_id: core::types::AppId, icon_name: Option<String>, // Name für Themed Icon gtk_icon: Option<gtk::gdk_pixbuf::Pixbuf>, // Geladenes Icon is_focused: bool, is_minimized: bool, workspace_tag: Option<String> /* z.B. "WS1" */ }`
    - **GTK-Implementierungshinweise:**
        - Könnte `gtk::ListView` 40 oder `gtk::FlowBox` 45 mit benutzerdefinierten Widgets für jedes Fenster verwenden. Jedes benutzerdefinierte Widget würde an eine `UIWindowRepresentation` binden.
        - Für die Fenster-Thumbnails oder Live-Vorschauen (wie in einem Alt-Tab-Switcher) sind Wayland-spezifische Protokolle oder Compositor-Features notwendig. Die Systemschicht müsste eine API bereitstellen, um solche Texturen oder Oberflächen-Handles zu liefern, die dann in einem GTK-Widget (ggf. ein spezielles Wayland-Oberflächen-Widget oder ein `gtk::Picture` mit aktualisierten Snapshots) dargestellt werden könnten. Wakefield 47 ist ein Beispiel für einen GTK-basierten Compositor, der Client-Oberflächen in GTK-Widgets einbetten kann; ähnliche Konzepte könnten für Vorschauen relevant sein, auch wenn NovaDE kein verschachtelter Compositor ist. Die `ext-foreign-toplevel-list-v1` und `wlr-foreign-toplevel-management-unstable-v1` Protokolle 17 sind fundamental für Taskleisten, um Fensterlisten und Metadaten zu erhalten. Die Systemschicht abstrahiert diese Protokolle, und die UI konsumiert die `WindowInfo`-Strukturen.
    - **Tabellen:**
        - **Interaktion `ui::window_manager_frontend` mit `system::compositor_iface`**

|   |   |   |   |
|---|---|---|---|
|**UI-Aktion**|**Aufgerufene compositor_iface-Methode**|**Konsumierte CompositorEvents**|**Aktualisierte UI-Daten**|
|Fenster in Taskleiste anklicken|`request_focus(window_id)`|`WindowFocusedEvent`, `WindowUnfocusedEvent`|`UIWindowRepresentation::is_focused`|
|Fenster minimieren|`set_window_state(id, Minimized)`|`WindowPropertiesChangedEvent` (mit `is_minimized = true`)|`UIWindowRepresentation::is_minimized`|
|Neues Fenster erscheint|-|`WindowCreatedEvent`|Neue `UIWindowRepresentation`|
|Fenstertitel ändert sich|-|`WindowPropertiesChangedEvent` (mit `changed_title`)|`UIWindowRepresentation::title`|

- **6.2. Desktop Shell (`ui::shell`) - Panels, Docks**
    
    - **Verantwortlichkeiten:** Anzeige von Panels (oben, unten, seitlich), Docks, Arbeitsbereichswechslern, Uhr, Systemindikatoren (Netzwerk, Lautstärke, Akku etc.).
    - **Interaktion mit `gtk4-layer-shell` (über Systemschicht-Abstraktion):**
        - Die Systemschicht stellt eine API bereit, z.B. `system::desktop_shell_iface`, um Layer-Oberflächen zu erstellen und zu verwalten. Diese API kapselt die direkte Verwendung von `gtk4-layer-shell`.9
        - `fn create_layer_surface(&self, params: LayerSurfaceParams) -> Result<LayerSurfaceHandle, ShellError>;`
            - `LayerSurfaceParams { window_handle: gtk::WindowHandle, // Das GTK-Fenster, das als Layer-Oberfläche dient anchor: LayerShellAnchor, // Bitflags: Top, Bottom, Left, Right exclusivity: LayerShellExclusivity, // Exclusive, OnDemand keyboard_interactivity: LayerShellKeyboardInteractivity // None, Exclusive, OnDemand margins: (i32, i32, i32, i32) // top, right, bottom, left }`
        - Die UI verwendet dieses `LayerSurfaceHandle`, um ihre GTK-Panel- oder Dock-Widgets in der Layer-Oberfläche zu positionieren und zu verankern.
        - Die Verwendung von `gtk4-layer-shell` ist entscheidend für die korrekte Integration von Panels und Docks in Wayland-Umgebungen, da es Apps erlaubt, sich über oder unter normalen Fenstern zu positionieren und Platz auf dem Bildschirm zu reservieren.9
    - **Arbeitsbereichswechsler:**
        - Konsumiert `domain::workspaces::WorkspaceEvent`-Ereignisse vom `WorkspaceManager`.
        - Zeigt `domain::workspaces::WorkspaceDescriptor`-Daten an (Name, Icon, aktive Fenster).
        - Ruft `WorkspaceManager::set_active_workspace(workspace_id)` bei Benutzerinteraktion auf.
        - GTK-Implementierung: Könnte eine `gtk::Box` mit `gtk::ToggleButton`s oder benutzerdefinierten gezeichneten Elementen für jeden Arbeitsbereich sein. `chunks-rs` 50 und allgemeine Pager-Beispiele 51 zeigen Konzepte für die Implementierung von Arbeitsbereichswechslern in GTK.
    - **Uhr / Kalenderanzeige:**
        - Verwendet `core::utils::time_utils` (basierend auf `chrono`) zur Formatierung von Datum und Uhrzeit.
        - Kann ein `gtk::Calendar` in einem `gtk::Popover` anzeigen, wenn auf die Uhr geklickt wird. Das Popover wird relativ zum Uhr-Widget positioniert.
    - **Systemindikatoren (Lautstärke, Netzwerk, Akku, Bluetooth etc.):**
        - **Lautstärke:**
            - Konsumiert `system::audio::AudioDeviceChangedEvent`, `AudioStreamVolumeChangedEvent` etc. vom `system::audio_iface`.
            - Zeigt aktuelle Lautstärke mit `gtk::Scale` (als Slider) oder `gtk::VolumeButton` 52 an.
            - Sendet `system::audio_iface::set_device_volume()` bei Benutzerinteraktion.
        - **Netzwerk:**
            - Konsumiert `system::dbus::NetworkStateChangedEvent`, `AccessPointsChangedEvent` vom `system::dbus::networkmanager_client_iface`.
            - Zeigt Verbindungsstatus (Icon), SSID, verfügbare Netzwerke in einem `gtk::Popover` mit einer `gtk::ListBox` an.
            - Ruft `system::dbus::networkmanager_client_iface::connect_to_access_point()` auf.
        - **Akku:**
            - Konsumiert `system::dbus::UPowerDeviceChangedEvent` vom `system::dbus::upower_client_iface`.
            - Zeigt Akkustand (Icon, Prozent) und geschätzte Restlaufzeit an.
        - **Bluetooth:**
            - Konsumiert Ereignisse von einem `system::dbus::bluez_adapter_iface` (analog zu NetworkManager).
            - Zeigt Bluetooth-Status, gekoppelte und verfügbare Geräte an.
            - Ruft Methoden wie `pair_device()`, `connect_device()` auf der BlueZ-Schnittstelle auf.20
        - **StatusNotifierItem/Ayatana Indicators (System Tray):**
            - Die Implementierung eines System Trays unter Wayland ist komplex. Die Spezifikation `StatusNotifierItem` (SNI) 48 ist der De-facto-Standard, der über D-Bus funktioniert.
            - Die `ui::shell` müsste als `StatusNotifierHost` agieren. Dies beinhaltet das Lauschen auf den D-Bus nach Diensten, die `StatusNotifierWatcher.RegisterStatusNotifierItem` aufrufen, und dann die Interaktion mit jedem `StatusNotifierItem` über dessen D-Bus-Schnittstelle, um Icon, Tooltip, Menü etc. abzurufen und darzustellen.
            - Die UI-Elemente für jedes Tray-Icon (typischerweise ein `gtk::Button` mit einem `gtk::Image` und einem `gtk::MenuButton` oder `gtk::Popover` für das Kontextmenü) würden dynamisch in einem Bereich des Panels erstellt.
            - Alternative Ansätze oder Herausforderungen unter Wayland werden diskutiert.58 NovaDE wird sich auf die `StatusNotifierItem`-Spezifikation konzentrieren, da sie am weitesten verbreitet ist. Die `libayatana-indicator`-Bibliothek 63 bietet eine Implementierung, die als Referenz dienen kann, obwohl NovaDE seine eigene D-Bus-Interaktion wahrscheinlich direkt mit `zbus` oder `gio::DBusConnection` implementieren würde, abstrahiert durch die Systemschicht.
            - Die Systemschicht würde eine `system::status_notifier_host_iface` bereitstellen, die Ereignisse wie `StatusNotifierItemRegisteredEvent { service_name: String, object_path: String }` und `StatusNotifierItemUnregisteredEvent` aussendet. Die UI würde diese abonnieren und dann die `system::status_notifier_item_proxy_iface` verwenden, um mit den einzelnen Items zu interagieren (z.B. `get_icon_pixmap()`, `get_tooltip()`, `activate()`, `context_menu()`).
- **6.3. Benachrichtigungs-Popups (`ui::notification_popups`)**
    
    - **Verantwortlichkeiten:** Anzeige von transienten Benachrichtigungs-Popups.
    - **Interaktion mit `domain::NotificationService`:**
        - Konsumiert `domain::notifications::NotificationPostedEvent`.
        - Zeigt die `domain::notifications::Notification`-Daten (Zusammenfassung, Textkörper, Icon, Aktionen) an.
    - **Interaktion mit `gtk4-layer-shell` (über Systemschicht-Abstraktion):**
        - Verwendet das Layer-Shell-Protokoll, um Benachrichtigungs-Popups an einer bestimmten Bildschirmkante (z.B. oben rechts) ohne Interferenz mit anderen Fenstern zu positionieren. Dies ist entscheidend für nicht-invasive Benachrichtigungen.9
        - Die Systemschicht stellt eine Methode bereit, z.B. `system::desktop_shell_iface::create_notification_layer_surface(params: NotificationSurfaceParams) -> Result<LayerSurfaceHandle, ShellError>;`, wobei `NotificationSurfaceParams` Details wie Anker, Dauer und Größe enthalten kann.
    - **Benutzerinteraktion:**
        - Klick auf eine Benachrichtigung könnte `NotificationService::dismiss_notification(id)` aufrufen oder eine Standardaktion auslösen (falls definiert).
        - Klick auf einen Aktionsbutton in einer Benachrichtigung (z.B. "Antworten", "Archivieren") resultiert in einem Aufruf an `NotificationService::invoke_action_on_notification(notification_id, action_id)`, was wiederum ein `domain::notifications::NotificationActionInvokedEvent` auslösen kann, auf das andere Teile der Anwendung reagieren können.
    - **GTK-Implementierungshinweise:**
        - Jedes Popup ist ein eigenes `gtk::Window`, das als Layer-Oberfläche konfiguriert ist. Es enthält typischerweise `gtk::Image` für das Icon, `gtk::Label` für Text und `gtk::Button` für Aktionen.
        - Mehrere Popups müssen verwaltet werden (z.B. in einer Warteschlange oder gestapelt auf dem Bildschirm).65
    - NovaDE wird seine eigenen Benachrichtigungen zeichnen, um volle Kontrolle über das Erscheinungsbild und die Integration mit dem Theming-System zu haben, anstatt sich auf einen externen Freedesktop-Benachrichtigungsdaemon zu verlassen.67 Der `domain::NotificationService` dient als zentrale Anlaufstelle und leitet die `NotificationPostedEvent` an die `ui::notification_popups`-Komponente weiter.
- **6.4. Anwendungsstarter (z.B. Dock, Anwendungsraster)**
    
    - **Verantwortlichkeiten:** Anzeige verfügbarer Anwendungen, Starten von Anwendungen.
    - **Interaktion mit `system::app_launcher_iface`:**
        - Ruft `system::app_launcher_iface::list_applications()` auf, um eine `Vec<system::applications::ApplicationEntry>` zu erhalten.
        - Zeigt diese Einträge an (Icon, Name). Die Icons werden basierend auf dem Icon-Namen und dem aktuellen Theme geladen.
        - Ruft `system::app_launcher_iface::launch_application(app_id, files_to_open: Option<Vec<PathBuf>>)` bei Benutzeraktivierung (Klick) oder per Drag-and-Drop auf.
    - **Interne UI-Modelldatenstrukturen:**
        - `UIAppEntry { id: String, // Desktop-Datei-ID oder AppStream-ID name: String, generic_name: Option<String>, comment: Option<String>, icon_name: Option<String>, gtk_icon: Option<gtk::gdk_pixbuf::Pixbuf>, categories: Vec<String>, keywords: Vec<String> }`
        - Die `system::app_launcher_iface` würde intern `freedesktop_entry_parser` 71 oder ähnliche Mechanismen verwenden, um `.desktop`-Dateien zu parsen und die `ApplicationEntry`-Daten bereitzustellen. Die UI konsumiert diese abstrahierten Daten.
    - **GTK-Implementierungshinweise:**
        - `gtk::FlowBox` 45 oder `gtk::GridView` (mit `gtk::SignalListItemFactory` 42) eignen sich gut zur Anzeige von App-Icons.
        - Jedes Icon könnte ein benutzerdefiniertes `gtk::Button` sein, das ein `gtk::Image` und optional ein `gtk::Label` enthält.
    - **Drag-and-Drop zum Starten:**
        - App-Icons fungieren als `GtkDropTarget`.74
        - Bei einem Drop werden Datei-URIs/Pfade extrahiert und an `system::app_launcher_iface::launch_application(app_id, Some(dropped_files))` übergeben.
        - Die `system::app_launcher_iface` verwendet intern `gio::AppInfo` und verwandte APIs, um Anwendungen zu starten [76,
# Implementierungsleitfaden für die UI-Schicht: Modul 1 – Applikations-Shell und Kernnavigation

Dieses Dokument beschreibt die Ultra-Feinspezifikationen und hochdetaillierten Implementierungspläne für das erste Modul der UI-Schicht. Das Modul "Applikations-Shell und Kernnavigation" umfasst grundlegende Komponenten, die für den Start, die Hauptfensterverwaltung und zentrale UI-Dienste der Applikation zuständig sind. Jede Komponente ist so detailliert spezifiziert, dass Entwickler sie direkt implementieren können, ohne eigene Entscheidungen treffen oder Logiken entwerfen zu müssen.

## 2. UI-Schicht: Implementierungsplan

### Modul 1: Applikations-Shell und Kernnavigation

Die folgenden Abschnitte definieren die Spezifikationen für die Kernkomponenten der Applikations-Shell und der grundlegenden Navigationsinfrastruktur.

#### 2.1. `AppInitializer` (Service/Non-Widget GObject)

##### 2.1.1. Übersicht und Zweck

Der `AppInitializer` ist ein zentraler Service, der für die Initialisierung der GTK-Applikation verantwortlich ist. Seine Hauptaufgaben umfassen das Einrichten globaler Ressourcen, die Registrierung der Applikations-ID und die Behandlung der `activate`- und `startup`-Signale der `gtk::Application`. Darüber hinaus verwaltet der `AppInitializer` den Lebenszyklus des globalen `ApplicationState`-Objekts, das anwendungsweite Zustandsinformationen und Dienste bündelt. Diese Komponente stellt sicher, dass die Applikation korrekt gestartet wird und das Hauptfenster bei Bedarf erstellt und angezeigt wird. Die Kapselung dieser Logik in `AppInitializer` fördert die Modularität und entkoppelt die applikationsspezifische Startlogik von der allgemeinen GTK-Struktur.

##### 2.1.2. Dateistruktur

Die Implementierung des `AppInitializer` wird in folgenden Dateien organisiert:

- `src/app_shell/app_initializer/mod.rs`: Öffentliches Modul und Wrapper-Definition.
- `src/app_shell/app_initializer/imp.rs`: Private Implementierungsdetails und GObject-Subklassifizierung.

##### 2.1.3. GObject-Definition

- **Wrapper-Typ:**
    
    Rust
    
    ```
    use gtk::glib;
    use gtk::gio;
    use std::cell::{Cell, OnceCell, RefCell};
    use std::rc::Rc;
    use crate::app_shell::main_window::MainWindow; // Annahme: MainWindow ist definiert
    use crate::app_shell::action_handler::MasterActionHandler; // Annahme: MasterActionHandler ist definiert
    use crate::app_shell::settings_service::SettingsService; // Annahme: SettingsService ist definiert
    
    glib::wrapper! {
        pub struct AppInitializer(ObjectSubclass<imp::AppInitializerImp>)
            @extends glib::Object;
    }
    ```
    
- **Implementierungs-Struktur (`imp`):**
    
    Rust
    
    ```
    // In src/app_shell/app_initializer/imp.rs
    use gtk::glib;
    use gtk::gio;
    use gtk::prelude::*;
    use gtk::subclass::prelude::*;
    use std::cell::{Cell, OnceCell, RefCell};
    use std::rc::Rc;
    use crate::app_shell::main_window::MainWindow;
    use crate::app_shell::action_handler::MasterActionHandler;
    use crate::app_shell::settings_service::SettingsService;
    
    #
    pub struct ApplicationState {
        pub settings_service: Option<SettingsService>,
        // Weitere globale Zustände oder Dienste hier
    }
    
    #
    pub struct AppInitializerImp {
        app: OnceCell<gtk::Application>,
        main_window: Cell<Option<MainWindow>>,
        app_state: OnceCell<Rc<RefCell<ApplicationState>>>,
        master_action_handler: OnceCell<Rc<MasterActionHandler>>,
    }
    
    #[glib::object_subclass]
    impl ObjectSubclass for AppInitializerImp {
        const NAME: &'static str = "MyAppInitializer";
        type Type = super::AppInitializer;
        type ParentType = glib::Object;
    
        fn new() -> Self {
            Self {
                app: OnceCell::new(),
                main_window: Cell::new(None),
                app_state: OnceCell::new(),
                master_action_handler: OnceCell::new(),
            }
        }
    }
    
    impl ObjectImpl for AppInitializerImp {
        fn constructed(&self) {
            self.parent_constructed();
            // Initialisiere app_state hier, da es von anderen Komponenten benötigt wird
            let initial_app_state = ApplicationState {
                settings_service: None, // Wird später in on_startup initialisiert
                // Initialisiere andere Felder von ApplicationState
            };
            self.app_state.set(Rc::new(RefCell::new(initial_app_state)))
               .expect("ApplicationState konnte nicht initialisiert werden.");
    
            let action_handler = Rc::new(MasterActionHandler::new());
            self.master_action_handler.set(action_handler)
               .expect("MasterActionHandler konnte nicht initialisiert werden.");
        }
    }
    ```
    
    Die Initialisierung von `ApplicationState` und `MasterActionHandler` in `constructed` stellt sicher, dass diese Kernkomponenten frühzeitig verfügbar sind. `ApplicationState` wird als `Rc<RefCell<ApplicationState>>` gespeichert, um gemeinsam genutzten, veränderlichen Zugriff zu ermöglichen.
    

##### 2.1.4. Eigenschaften

Für den `AppInitializer` selbst sind keine öffentlich exponierten GObject-Eigenschaften vorgesehen, die über die interne Zustandsverwaltung hinausgehen. Der Zustand wird intern durch die Felder in `AppInitializerImp` verwaltet.

##### 2.1.5. Methoden

- **`pub fn new(application_id: &str, flags: gio::ApplicationFlags) -> Self`**
    
    - **Signatur:** `pub fn new(application_id: &str, flags: gio::ApplicationFlags) -> super::AppInitializer`
    - **Zugriffsmodifikator:** `pub`
    - **Parameter:**
        - `application_id`: `&str` – Die eindeutige ID der Applikation (z.B. "org.example.myapp").
        - `flags`: `gio::ApplicationFlags` – Flags zur Konfiguration des Applikationsverhaltens (z.B. `gio::ApplicationFlags::HANDLES_OPEN`).
    - **Rückgabewert:** `super::AppInitializer` – Eine neue Instanz des `AppInitializer`.
    - **Vorbedingungen:** `application_id` darf nicht leer sein und muss einem gültigen Format für Applikations-IDs entsprechen.
    - **Nachbedingungen:** Eine `gtk::Application`-Instanz wurde erstellt und im `AppInitializerImp` gespeichert. Die Signale `startup` und `activate` der `gtk::Application` sind mit den entsprechenden internen Methoden des `AppInitializer` verbunden. Der `AppInitializer` ist bereit, die Applikation auszuführen.
    - **Implementierungslogik (Schritt-für-Schritt):**
        1. Erstelle eine neue `glib::Object`-Instanz vom Typ `super::AppInitializer`. Dies ruft `AppInitializerImp::constructed` auf.
        2. Hole die private Implementierung (`imp`) der erstellten `AppInitializer`-Instanz.
        3. Erstelle die `gtk::Application`:
            
            Rust
            
            ```
            let gtk_app = gtk::Application::builder()
               .application_id(application_id)
               .flags(flags)
               .build();
            ```
            
        4. Speichere `gtk_app` im Feld `imp.app`. Es ist wichtig, `set` nur einmal aufzurufen, da `OnceCell` dies erzwingt.
            
            Rust
            
            ```
            imp.app.set(gtk_app.clone()).expect("gtk::Application konnte nicht gesetzt werden.");
            ```
            
        5. Verbinde das `startup`-Signal der `gtk::Application`. Das Klonen von `app_initializer` ist notwendig, um es in den Closure zu bewegen.
            
            Rust
            
            ```
            let app_initializer_clone_startup = obj.clone(); // obj ist die Self-Instanz
            gtk_app.connect_startup(move |app| {
                app_initializer_clone_startup.imp().on_startup(app);
            });
            ```
            
        6. Verbinde das `activate`-Signal der `gtk::Application`.
            
            Rust
            
            ```
            let app_initializer_clone_activate = obj.clone(); // obj ist die Self-Instanz
            gtk_app.connect_activate(move |app| {
                app_initializer_clone_activate.imp().on_activate(app);
            });
            ```
            
        7. Optional: Registriere die Applikation bei D-Bus, falls dies für die Funktionalität (z.B. Single-Instance-Verhalten über D-Bus) erforderlich ist. Dies geschieht typischerweise im `startup`-Handler, nachdem die Applikation die Kontrolle über die ID erlangt hat.1
            
            Rust
            
            ```
            // Beispielhafte D-Bus Registrierung (kann in on_startup erfolgen)
            // if flags.contains(gio::ApplicationFlags::IS_SERVICE) {
            //     gtk_app.register(None::<&gio::Cancellable>).expect("D-Bus Registrierung fehlgeschlagen");
            // }
            ```
            
        8. Gib die erstellte `AppInitializer`-Instanz zurück.
- **`pub fn run(&self) -> glib::ExitCode`**
    
    - **Signatur:** `pub fn run(&self) -> glib::ExitCode`
    - **Zugriffsmodifikator:** `pub`
    - **Parameter:** Keine.
    - **Rückgabewert:** `glib::ExitCode` – Der Exit-Code der Applikation nach deren Beendigung.
    - **Vorbedingungen:** Die `new`-Methode muss erfolgreich aufgerufen worden sein.
    - **Nachbedingungen:** Die GTK-Applikation wird gestartet und die Hauptschleife betreten. Die Methode blockiert, bis die Applikation beendet wird.
    - **Implementierungslogik (Schritt-für-Schritt):**
        1. Hole die `gtk::Application`-Instanz aus `self.imp().app`.
            
            Rust
            
            ```
            let gtk_app = self.imp().app.get().expect("gtk::Application wurde nicht initialisiert.");
            ```
            
        2. Rufe `gtk_app.run()` auf. Da die GTK-Dokumentation für `gtk_application_run` keine Argumente für `argc` und `argv` in der Rust-Binding-Variante direkt zeigt, wird die parameterlose Variante verwendet, die die Kommandozeilenargumente implizit handhabt.3
            
            Rust
            
            ```
            gtk_app.run()
            ```
            
- **`fn on_startup(&self, app: &gtk::Application)`**
    
    - **Signatur:** `fn on_startup(&self, app: &gtk::Application)`
    - **Zugriffsmodifikator:** Privat (intern von `AppInitializerImp`)
    - **Parameter:**
        - `app`: `&gtk::Application` – Die GTK-Applikationsinstanz.
    - **Rückgabewert:** Keiner.
    - **Vorbedingungen:** Wird vom `startup`-Signal der `gtk::Application` aufgerufen.
    - **Nachbedingungen:** Globale Dienste wie `MasterActionHandler` und `SettingsService` sind initialisiert und konfiguriert. Applikationsweite Aktionen sind registriert.
    - **Implementierungslogik (Schritt-für-Schritt):**
        1. Hole den `MasterActionHandler` aus `self.master_action_handler`.
            
            Rust
            
            ```
            let action_handler = self.master_action_handler.get().expect("MasterActionHandler nicht initialisiert.").clone();
            ```
            
        2. Initialisiere und registriere applikationsweite Aktionen über den `MasterActionHandler`.
            
            Rust
            
            ```
            // Beispiel: action_handler.register_app_action(...);
            // Hier sollten globale Aktionen wie "quit", "about" etc. definiert werden.
            // Siehe Spezifikation für MasterActionHandler (2.4).
            let about_action = gio::SimpleAction::new("about", None);
            let self_clone_for_about = self.clone();
            about_action.connect_activate(move |_, _| {
                self_clone_for_about.show_about_dialog();
            });
            action_handler.register_app_action(app, &about_action);
            ```
            
        3. Initialisiere den `SettingsService`. Der Schema-Name muss mit der gschema.xml-Datei übereinstimmen.
            
            Rust
            
            ```
            let settings_service = SettingsService::new("org.example.myapp")
               .expect("SettingsService konnte nicht initialisiert werden.");
            // Speichere settings_service im ApplicationState
            let app_state = self.app_state.get().expect("ApplicationState nicht initialisiert.");
            app_state.borrow_mut().settings_service = Some(settings_service);
            ```
            
        4. Führe weitere einmalige Initialisierungsaufgaben durch (z.B. Laden von Ressourcen, Konfiguration von Logging).
        5. Stelle sicher, dass die Applikation die Kontrolle über die ID hat, bevor D-Bus-Operationen durchgeführt werden, falls relevant. Die `startup`-Phase ist dafür geeignet.
- **`fn on_activate(&self, app: &gtk::Application)`**
    
    - **Signatur:** `fn on_activate(&self, app: &gtk::Application)`
    - **Zugriffsmodifikator:** Privat (intern von `AppInitializerImp`)
    - **Parameter:**
        - `app`: `&gtk::Application` – Die GTK-Applikationsinstanz.
    - **Rückgabewert:** Keiner.
    - **Vorbedingungen:** Wird vom `activate`-Signal der `gtk::Application` aufgerufen. Dies kann mehrfach geschehen, z.B. wenn versucht wird, eine bereits laufende Instanz erneut zu starten.
    - **Nachbedingungen:** Das Hauptfenster der Applikation (`MainWindow`) wird erstellt (falls noch nicht vorhanden) und angezeigt.
    - **Implementierungslogik (Schritt-für-Schritt):**
        
        1. Überprüfe, ob bereits ein Hauptfenster (`self.main_window`) existiert.
            
            Rust
            
            ```
            if self.main_window.get().is_none() {
                // Hauptfenster existiert noch nicht, erstelle es.
                let app_state = self.app_state.get().expect("ApplicationState nicht initialisiert.").clone();
                let main_window_instance = MainWindow::new(app, app_state);
                self.main_window.set(Some(main_window_instance));
            }
            ```
            
        2. Hole das Hauptfenster (entweder das neu erstellte oder das existierende).
            
            Rust
            
            ```
            let window_to_present = self.main_window.get().clone().expect("Hauptfenster konnte nicht abgerufen werden.");
            ```
            
        3. Zeige das Hauptfenster an und bringe es in den Vordergrund.
            
            Rust
            
            ```
            window_to_present.present();
            ```
            
        
        Die Logik stellt sicher, dass bei wiederholten `activate`-Signalen nicht mehrere Fenster erzeugt werden, sondern das existierende Fenster in den Vordergrund gebracht wird. Dies ist ein typisches Verhalten für Desktop-Applikationen.3
- **`fn show_about_dialog(&self)`**
    
    - **Signatur:** `fn show_about_dialog(&self)`
    - **Zugriffsmodifikator:** Privat (kann aber von einer Action aufgerufen werden)
    - **Parameter:** Keine.
    - **Rückgabewert:** Keiner.
    - **Implementierungslogik (Schritt-für-Schritt):**
        1. Erstelle einen `gtk::AboutDialog`.
            
            Rust
            
            ```
            let about_dialog = gtk::AboutDialog::new();
            ```
            
        2. Setze die Eigenschaften des Dialogs (Programmname, Version, Copyright, Webseite, Autoren etc.). Diese Informationen sollten zentral verwaltet oder aus Build-Informationen bezogen werden.
            
            Rust
            
            ```
            about_dialog.set_program_name("Meine Anwendung");
            about_dialog.set_version(Some("1.0.0"));
            about_dialog.set_copyright(Some("© 2025 Mein Name"));
            about_dialog.set_website(Some("https://example.com"));
            // about_dialog.set_authors(&["Autor 1", "Autor 2"]);
            // about_dialog.set_logo_icon_name(Some("application-x-executable")); // Beispiel Icon
            ```
            
        3. Setze das transiente Elternfenster, falls das Hauptfenster bereits existiert.
            
            Rust
            
            ```
            if let Some(main_window) = self.main_window.get().as_ref() {
                about_dialog.set_transient_for(Some(main_window));
                about_dialog.set_modal(true);
            }
            ```
            
        4. Zeige den Dialog an.
            
            Rust
            
            ```
            about_dialog.present();
            ```
            

##### 2.1.6. Signale

- **Emittierte Signale:** Der `AppInitializer` selbst emittiert keine eigenen GObject-Signale.
- **Behandelte Signale:**
    - `gtk::Application::startup`: Verbunden mit `AppInitializerImp::on_startup`. Dient zur einmaligen Initialisierung der Applikation.
    - `gtk::Application::activate`: Verbunden mit `AppInitializerImp::on_activate`. Dient zur Erstellung und/oder Anzeige des Hauptfensters.

##### 2.1.7. Datenstrukturen

- **`ApplicationState`**
    - **Definition:**
        
        Rust
        
        ```
        // Bereits in imp.rs definiert
        // pub struct ApplicationState {
        //     pub settings_service: Option<SettingsService>,
        //     // Weitere globale Zustände oder Dienste hier
        // }
        ```
        
    - **Attribute:**
        - `settings_service`: `Option<SettingsService>`, `pub` – Hält eine Instanz des `SettingsService` für den Zugriff auf Anwendungseinstellungen. Wird in `on_startup` initialisiert.
    - **Invarianten:** Nach `on_startup` sollte `settings_service` `Some` sein.
    - **Zweck:** Dient als Container für global verfügbare Dienste und Zustandsinformationen, die über `Rc<RefCell<ApplicationState>>` an verschiedene UI-Komponenten weitergegeben werden können. Dies ist eine gängige Methode zur Zustandsverwaltung in GTK-Anwendungen, um Prop-Drilling zu vermeiden und einen zentralen Zugriffspunkt für gemeinsam genutzte Daten zu schaffen.5

##### 2.1.8. UI Layout und Styling

Nicht anwendbar, da `AppInitializer` ein nicht-visueller Service ist.

##### 2.1.9. Exception Handling / Error Types

Fehler bei der Initialisierung (z.B. Laden von Settings, D-Bus-Registrierung) werden über `Result` oder `expect` behandelt. Kritische Fehler während des Starts sollten zum kontrollierten Beenden der Applikation führen.

##### 2.1.10. Asynchrone Operationen

Der `AppInitializer` führt primär synchrone Operationen während der Startup- und Activate-Phasen aus. Asynchrone Operationen könnten bei der D-Bus-Registrierung oder beim Laden von Ressourcen auftreten, würden aber typischerweise innerhalb der Signalhandler mit `glib::MainContext::block_on` oder durch Spawnen auf den Main-Context gehandhabt, falls sie nicht blockierend sein dürfen.

##### 2.1.11. Abhängigkeiten

- `MainWindow`: Für die Erstellung des Hauptfensters.
- `MasterActionHandler`: Für die Registrierung globaler Aktionen.
- `SettingsService`: Für den Zugriff auf und die Initialisierung von Anwendungseinstellungen.
- `gtk::Application`, `gtk::gio`, `gtk::glib`.

##### 2.1.12. Testplan

- **Unit-Tests:**
    - Verifiziere, dass `new()` eine gültige `AppInitializer`-Instanz zurückgibt und die `gtk::Application` korrekt konfiguriert ist (ID, Flags).
    - Teste das Verhalten von `on_startup` (Mocking von Abhängigkeiten wie `SettingsService` könnte notwendig sein, um die korrekte Initialisierung zu überprüfen).
    - Teste das Verhalten von `on_activate`:
        - Erstellt `MainWindow` beim ersten Aufruf.
        - Zeigt existierende `MainWindow` bei nachfolgenden Aufrufen an.
- **Integrationstests:**
    - Simuliere den Applikationsstart und überprüfe, ob das Hauptfenster erscheint.
    - Teste die Reaktion auf mehrfache Aktivierungssignale.
    - Überprüfe die korrekte Registrierung von D-Bus-Diensten (falls implementiert).

#### 2.2. `MainWindow` (Benutzerdefiniertes GTK Widget)

##### 2.2.1. Übersicht und Zweck

Das `MainWindow` ist das Hauptfenster der Applikation und dient als primärer Container für alle anderen UI-Elemente. Es definiert die grundlegende Layoutstruktur, typischerweise bestehend aus einer Seitenleiste für die Navigation, einem Hauptinhaltsbereich und einem Integrationspunkt für die Befehlspalette. Als Unterklasse von `gtk::ApplicationWindow` integriert es sich nahtlos in den Lebenszyklus der `gtk::Application`.3 Die Verwendung eines benutzerdefinierten Widgets für das Hauptfenster ermöglicht eine bessere Kapselung der fensterspezifischen Logik und des Layouts.

##### 2.2.2. Dateistruktur

- `src/app_shell/main_window/mod.rs`: Öffentliches Modul und Wrapper-Definition.
- `src/app_shell/main_window/imp.rs`: Private Implementierungsdetails und GObject-Subklassifizierung.
- `resources/ui/main_window.ui`: (Optional) UI-Definitionsdatei für das Fensterlayout, falls Composite Templates verwendet werden.

##### 2.2.3. GObject-Definition

- **Wrapper-Typ:**
    
    Rust
    
    ```
    // In src/app_shell/main_window/mod.rs
    use gtk::glib;
    use gtk::subclass::prelude::*;
    use gtk::{gio, ApplicationWindow, Widget}; // Weitere Imports nach Bedarf
    use std::rc::Rc;
    use std::cell::RefCell;
    use crate::app_shell::app_initializer::ApplicationState; // Pfad anpassen
    
    glib::wrapper! {
        pub struct MainWindow(ObjectSubclass<imp::MainWindowImp>)
            @extends ApplicationWindow, gtk::Window, Widget,
            @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible,
                        gtk::Buildable, gtk::ConstraintTarget, gtk::Native,
                        gtk::Root, gtk::ShortcutManager;
    }
    ```
    
    Die Implementierung der zahlreichen Interfaces (`gio::ActionGroup`, `gio::ActionMap`, etc.) wird durch `glib::wrapper!` und die Vererbung von `gtk::ApplicationWindow` bereitgestellt.7
    
- **Implementierungs-Struktur (`imp`):**
    
    Rust
    
    ```
    // In src/app_shell/main_window/imp.rs
    use gtk::glib::{self, Properties};
    use gtk::subclass::prelude::*;
    use gtk::{
        ApplicationWindow, Box as GtkBox, Revealer, CompositeTemplate, TemplateChild,
        gio
    };
    use std::cell::{Cell, RefCell};
    use std::rc::Rc;
    use crate::app_shell::app_initializer::ApplicationState; // Pfad anpassen
    use crate::app_shell::command_palette::CommandPaletteWidget; // Annahme
    use crate::app_shell::sidebar::SidebarNavigationWidget; // Annahme
    use crate::app_shell::content_view::ContentViewManager; // Annahme
    
    
    #
    #[template(resource = "/org/example/myapp/main_window.ui")] // Pfad zur UI-Datei
    #[properties(wrapper_type = super::MainWindow)]
    pub struct MainWindowImp {
        #[template_child]
        pub main_box: TemplateChild<GtkBox>,
    
        #[template_child]
        pub content_area_box: TemplateChild<GtkBox>, // Container für Sidebar und Content
    
        #[template_child]
        pub command_palette_revealer: TemplateChild<Revealer>,
    
        #[template_child]
        pub command_palette_widget: TemplateChild<CommandPaletteWidget>, // Instanz der CommandPalette
    
        // Interner Zustand
        #[property(get, set, name = "is-command-palette-visible", nick="Command Palette Visible", blurb="Whether the command palette is currently visible", default=false)]
        is_command_palette_visible_prop: Cell<bool>,
    
        app_state: RefCell<Option<Rc<RefCell<ApplicationState>>>>,
        actions: gio::SimpleActionGroup,
    }
    
    #[glib::object_subclass]
    impl ObjectSubclass for MainWindowImp {
        const NAME: &'static str = "MyMainWindow";
        type Type = super::MainWindow;
        type ParentType = ApplicationWindow;
    
        fn class_init(klass: &mut Self::Class) {
            // UI-Template binden
            klass.bind_template();
            // Template Callbacks binden, falls vorhanden
            // klass.bind_template_callbacks();
        }
    
        fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
            obj.init_template();
        }
    }
    
    #[glib::derived_properties]
    impl ObjectImpl for MainWindowImp {
        fn constructed(&self) {
            self.parent_constructed();
    
            // Aktionen initialisieren und hinzufügen
            self.obj().setup_actions();
            self.obj().setup_keyboard_shortcuts();
    
            // Command Palette initialisieren und zum Revealer hinzufügen
            // self.command_palette_revealer.set_child(Some(&*self.command_palette_widget));
            // Die obige Zeile ist nicht notwendig, wenn command_palette_widget als Kind von
            // command_palette_revealer in der.ui Datei definiert ist.
    
            // Initialisiere Sidebar und Content View Manager und füge sie zum content_area_box hinzu
            // let sidebar = SidebarNavigationWidget::new(self.app_state.borrow().as_ref().unwrap().clone());
            // let content_manager = ContentViewManager::new(self.app_state.borrow().as_ref().unwrap().clone());
            // self.content_area_box.append(&sidebar);
            // self.content_area_box.append(&content_manager);
            // Diese Initialisierung sollte idealerweise in der UI-Datei oder durch Template-Callbacks erfolgen,
            // um die Logik hier sauber zu halten.
        }
    }
    
    impl WidgetImpl for MainWindowImp {
        // Überschreibe size_allocate, falls notwendig für benutzerdefinierte Layout-Logik
    }
    
    impl WindowImpl for MainWindowImp {
        // Behandle Fensterzustandsänderungen, z.B. Schließen-Anfrage
        fn close_request(&self) -> glib::Propagation {
            // Hier könnte Logik zum Speichern des Zustands oder Bestätigungsdialoge implementiert werden
            println!("Close request received for MainWindow");
            // Um das Schließen tatsächlich zu verhindern:
            // return glib::Propagation::Stop;
            self.parent_close_request()
        }
    }
    impl ApplicationWindowImpl for MainWindowImp {}
    ```
    
    Die Verwendung von `#[derive(Properties)]` und `#[properties(wrapper_type =...)]` ermöglicht die Definition von GObject-Eigenschaften direkt in der `imp`-Struktur.8 Die `#[template_child]`-Annotationen verbinden Felder mit Widgets, die in der UI-Datei definiert sind.10 Die `constructed`-Methode ist der geeignete Ort, um Aktionen einzurichten und initiale UI-Konfigurationen vorzunehmen.7
    
- **UI-Definition (`main_window.ui`):**
    
    XML
    
    ```
    <?xml version="1.0" encoding="UTF-8"?>
    <interface>
      <requires lib="gtk" version="4.0"/>
      <template class="MyMainWindow" parent="GtkApplicationWindow">
        <property name="title" translatable="yes">Meine Anwendung</property>
        <property name="default-width">1024</property>
        <property name="default-height">768</property>
        <child>
          <object class="GtkBox" id="main_box">
            <property name="orientation">vertical</property>
            <child>
              <object class="GtkHeaderBar" id="header_bar">
                </object>
            </child>
            <child>
              <object class="GtkBox" id="content_area_box">
                <property name="orientation">horizontal</property>
                <property name="hexpand">true</property>
                <property name="vexpand">true</property>
                </object>
            </child>
            <child>
              <object class="GtkRevealer" id="command_palette_revealer">
                <property name="transition-type">slide-down</property>
                <property name="transition-duration">250</property>
                <property name="reveal-child">false</property>
                <child>
                  <object class="CommandPaletteWidget" id="command_palette_widget"/>
                </child>
              </object>
            </child>
          </object>
        </child>
      </template>
    </interface>
    ```
    
    Die UI-Datei definiert die Struktur des Fensters. `TemplateChild`-Felder in `MainWindowImp` werden mit den Widgets mit den entsprechenden IDs (`main_box`, `command_palette_revealer`, etc.) verbunden. Die Verwendung von UI-Templates fördert die Trennung von UI-Definition und Logik.10
    

##### 2.2.4. Eigenschaften

- **`is-command-palette-visible`**:
    - **GObject-Name:** `is-command-palette-visible`
    - **Rust-Typ:** `bool` (intern `Cell<bool>`)
    - **Zugriff:** Lesen/Schreiben (R/W)
    - **Standardwert:** `false`
    - **Beschreibung:** Steuert die Sichtbarkeit des `command_palette_revealer`. Änderungen an dieser Eigenschaft lösen ein `notify::is-command-palette-visible`-Signal aus.
    - **Implementierung:** Die Eigenschaft wird durch das `#[property(...)]`-Makro auf `is_command_palette_visible_prop` in `MainWindowImp` generiert. Der Getter liest aus `is_command_palette_visible_prop`. Der Setter schreibt in `is_command_palette_visible_prop` und ruft `self.obj().notify("is-command-palette-visible")` auf, sowie `self.command_palette_revealer.set_reveal_child(new_value)`.

##### 2.2.5. Methoden

- **`pub fn new(app: &gtk::Application, app_state: Rc<RefCell<ApplicationState>>) -> Self`**
    
    - **Signatur:** `pub fn new(app: &gtk::Application, app_state: Rc<RefCell<ApplicationState>>) -> Self`
    - **Zugriffsmodifikator:** `pub`
    - **Parameter:**
        - `app`: `&gtk::Application` – Die Hauptapplikationsinstanz.
        - `app_state`: `Rc<RefCell<ApplicationState>>` – Der globale Anwendungszustand.
    - **Rückgabewert:** `Self` – Eine neue Instanz von `MainWindow`.
    - **Vorbedingungen:** `app` und `app_state` sind gültige, initialisierte Instanzen.
    - **Nachbedingungen:** Ein neues `MainWindow` wird erstellt, mit der Applikation verknüpft und der `app_state` intern gespeichert.
    - **Implementierungslogik (Schritt-für-Schritt):**
        1. Erstelle das Objekt mit `glib::Object::builder().property("application", app).build()`.
        2. Hole die `imp`-Struktur des neu erstellten Fensters.
        3. Speichere `app_state` in `imp.app_state.borrow_mut().replace(app_state);`.
- **`pub fn toggle_command_palette(&self)`**
    
    - **Signatur:** `pub fn toggle_command_palette(&self)`
    - **Zugriffsmodifikator:** `pub`
    - **Parameter:** Keine.
    - **Rückgabewert:** Keiner.
    - **Vorbedingungen:** Das `MainWindow` und seine internen Widgets (`command_palette_revealer`, `command_palette_widget`) sind initialisiert.
    - **Nachbedingungen:** Die Sichtbarkeit der Befehlspalette wird umgeschaltet. Die Eigenschaft `is-command-palette-visible` wird aktualisiert und das Signal `command_palette_toggled` wird emittiert.
    - **Implementierungslogik (Schritt-für-Schritt):**
        1. Hole die `imp`-Struktur.
        2. Lese den aktuellen Zustand von `imp.command_palette_revealer.reveals_child()`.
        3. Setze den neuen Zustand: `imp.command_palette_revealer.set_reveal_child(!current_state)`.
        4. Aktualisiere die Eigenschaft: `self.set_is_command_palette_visible(!current_state)`. Dies löst automatisch das `notify`-Signal für die Eigenschaft aus.
        5. Wenn die Palette sichtbar wird, setze den Fokus auf das Eingabefeld der `CommandPaletteWidget`: `imp.command_palette_widget.grab_focus_entry();` (Annahme: `grab_focus_entry` ist eine Methode von `CommandPaletteWidget`).
        6. Emittiere das `command_palette_toggled`-Signal: `self.emit_by_name::<()>("command-palette-toggled", &[&!current_state]);`.
- **`fn setup_actions(&self)`** (Privat, aufgerufen in `constructed`)
    
    - **Signatur:** `fn setup_actions(&self)`
    - **Implementierungslogik:**
        1. Erstelle `gio::SimpleActionGroup`.
        2. Definiere Aktionen spezifisch für das Fenster (z.B. "toggle-command-palette").
            
            Rust
            
            ```
            let imp = self.imp();
            let toggle_cp_action = gio::SimpleAction::new("toggle-command-palette", None);
            let window_clone = self.clone();
            toggle_cp_action.connect_activate(move |_, _| {
                window_clone.toggle_command_palette();
            });
            imp.actions.add_action(&toggle_cp_action);
            ```
            
        3. Füge die `SimpleActionGroup` zum Fenster hinzu: `self.insert_action_group("win", Some(&imp.actions));`. Der Präfix "win" ist Konvention für fensterspezifische Aktionen.12
- **`fn setup_keyboard_shortcuts(&self)`** (Privat, aufgerufen in `constructed`)
    
    - **Signatur:** `fn setup_keyboard_shortcuts(&self)`
    - **Implementierungslogik:**
        
        1. Definiere Tastenkürzel für Fensteraktionen. Zum Beispiel `Ctrl+P` für die Befehlspalette.
            
            Rust
            
            ```
            let app = self.application().expect("Anwendung nicht gefunden für MainWindow");
            app.set_accels_for_action("win.toggle-command-palette", &["<Primary>P"]);
            // Weitere Kürzel hier definieren
            ```
            
        
        Die Aktionen müssen bereits in der `gio::ActionGroup` des Fensters (hier "win") registriert sein.12

##### 2.2.6. Signale

- **Emittierte Signale:**
    
    - **Signal Name:** `command-palette-toggled`
        - **GObject Name:** `command-palette-toggled`
        - **Parameter:**
            - `visible`: `bool` (Rust), `glib::VariantType::BOOLEAN` (`glib::Variant`) – Gibt an, ob die Palette sichtbar (`true`) oder unsichtbar (`false`) wurde.
        - **Beschreibung:** Wird emittiert, nachdem die Sichtbarkeit der Befehlspalette geändert wurde.
        - **Definition in `ObjectImpl::signals()`:**
            
            Rust
            
            ```
            // In MainWindowImp
            fn signals() -> &'static {
                static SIGNALS: OnceCell<Vec<glib::subclass::Signal>> = OnceCell::new();
                SIGNALS.get_or_init(|| {
                    vec!)
                           .build(),
                    ]
                })
            }
            ```
            
            Die Definition von Signalen erfolgt typischerweise in der `ObjectImpl` der Implementierungsstruktur.11
- **Behandelte Signale:**
    
    - Verbindungen zu Signalen von Kind-Widgets (z.B. `command_palette_widget.command-executed`) werden intern in `constructed` oder bei der Initialisierung der Kind-Widgets eingerichtet.

##### 2.2.7. Datenstrukturen

Keine spezifischen öffentlichen Datenstrukturen, die von `MainWindow` direkt exponiert werden, außer den GObject-Eigenschaften. Der `ApplicationState` wird intern referenziert.

##### 2.2.8. UI Layout und Styling

- **Widget-Hierarchie:**
    - `MyMainWindow` (`gtk::ApplicationWindow`)
        - `main_box` (`gtk::Box`, vertikal)
            - `header_bar` (`gtk::HeaderBar`) (optional, falls nicht CSD)
            - `content_area_box` (`gtk::Box`, horizontal)
                - `SidebarNavigationWidget` (benutzerdefiniert, links)
                - `ContentViewManager` (benutzerdefiniert, rechts, `hexpand=true`)
            - `command_palette_revealer` (`gtk::Revealer`)
                - `command_palette_widget` (`CommandPaletteWidget`, benutzerdefiniert)
- **Layout Manager:** Primär `gtk::Box` für die Hauptstrukturierung.
- **CSS-Klassen und -Namen:**
    - `MainWindow`: CSS-Name `main-window`.
    - `content_area_box`: CSS-Klasse `content-area`.
    - `sidebar_nav` (falls als TemplateChild): CSS-Klasse `sidebar-navigation`.
    - `command_palette_revealer`: CSS-Klasse `command-palette-container`. Styling erfolgt über eine zentrale CSS-Datei, die von der Applikation geladen wird. Spezifische Stile für `MainWindow` und seine Hauptbereiche werden über diese Klassen und Namen ermöglicht.14

##### 2.2.9. Exception Handling / Error Types

Fehler bei der UI-Erstellung (z.B. Laden der UI-Datei) sollten durch `expect` oder `Result` behandelt und geloggt werden. Laufzeitfehler sind typischerweise unwahrscheinlich, es sei denn, es gibt Probleme mit Kind-Widgets.

##### 2.2.10. Asynchrone Operationen

Das `MainWindow` selbst führt keine langlaufenden asynchronen Operationen durch. Es kann jedoch UI-Aktualisierungen als Reaktion auf Ereignisse von asynchronen Diensten (via `ApplicationState` und `AsyncUIManager`) durchführen.

##### 2.2.11. Abhängigkeiten

- `CommandPaletteWidget`: Für die Anzeige und Interaktion mit der Befehlspalette.
- `SidebarNavigationWidget`: Für die Hauptnavigation (Spezifikation folgt).
- `ContentViewManager`: Für die Verwaltung und Anzeige verschiedener Inhaltsansichten (Spezifikation folgt).
- `ApplicationState`: Für den Zugriff auf globale Zustände und Dienste.
- `MasterActionHandler`: Für die Verbindung von UI-Elementen mit globalen Aktionen.
- `gtk::Application`, `gtk::ApplicationWindow`, `gtk::Box`, `gtk::Revealer`, `gtk::gio`.

##### 2.2.12. Testplan

- **Unit-Tests:**
    - Teste die Erstellung des `MainWindow`.
    - Teste die `toggle_command_palette`-Methode:
        - Sichtbarkeit des `command_palette_revealer` ändert sich korrekt.
        - Eigenschaft `is-command-palette-visible` wird aktualisiert.
        - Signal `command_palette_toggled` wird mit korrektem Parameter emittiert.
    - Überprüfe die korrekte Einrichtung der Aktionen (`win.toggle-command-palette`).
- **Integrationstests (mit GTK-Testumgebung):**
    - Überprüfe das korrekte Laden der UI-Datei (falls verwendet).
    - Teste die Reaktion auf das Tastenkürzel zum Öffnen der Befehlspalette.
    - Teste das Schließen des Fensters und die korrekte Ausführung von `close_request`.

#### 2.3. `CommandPaletteWidget` (Benutzerdefiniertes GTK Widget)

##### 2.3.1. Übersicht und Zweck

Das `CommandPaletteWidget` ist eine zentrale UI-Komponente, die es Benutzern ermöglicht, schnell nach Befehlen, Aktionen oder anderen navigierbaren Elementen innerhalb der Applikation zu suchen und diese auszuführen. Es verwendet eine Texteingabe mit Fuzzy-Suche, um eine dynamisch gefilterte Liste von Ergebnissen anzuzeigen. Dieses Konzept ist inspiriert von ähnlichen Funktionen in modernen Entwicklungsumgebungen und Produktivitätswerkzeugen.15 Die Palette wird typischerweise als Pop-up oder einblendbares Element (`gtk::Revealer`) im `MainWindow` integriert.

##### 2.3.2. Dateistruktur

- `src/app_shell/command_palette/mod.rs`: Öffentliches Modul und Wrapper-Definition.
- `src/app_shell/command_palette/imp.rs`: Private Implementierungsdetails und GObject-Subklassifizierung.
- `src/app_shell/command_palette/fuzzy_searcher.rs`: Modul für die Fuzzy-Suchlogik.
- `src/app_shell/command_palette/item.rs`: Definition des `CommandPaletteItem`-GObjects.
- `resources/ui/command_palette_widget.ui`: (Optional) UI-Definitionsdatei.
- `resources/ui/command_palette_item.ui`: (Optional) UI-Definitionsdatei für ein einzelnes Listenelement.

##### 2.3.3. GObject-Definition

- **Wrapper-Typ:**
    
    Rust
    
    ```
    // In src/app_shell/command_palette/mod.rs
    use gtk::glib;
    use gtk::subclass::prelude::*;
    use gtk::{Box as GtkBox, Widget}; // Weitere Imports nach Bedarf
    use crate::app_shell::action_handler::MasterActionHandler; // Annahme
    use std::rc::Rc;
    
    glib::wrapper! {
        pub struct CommandPaletteWidget(ObjectSubclass<imp::CommandPaletteWidgetImp>)
            @extends GtkBox, Widget,
            @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Orientable;
    }
    
    impl CommandPaletteWidget {
        pub fn new(action_handler: Rc<MasterActionHandler>) -> Self {
            let widget: Self = glib::Object::builder().build();
            widget.imp().action_handler.set(Some(action_handler)).expect("ActionHandler konnte nicht gesetzt werden");
            widget
        }
    
        pub fn grab_focus_entry(&self) {
            self.imp().search_entry.grab_focus();
        }
    }
    ```
    
- **Implementierungs-Struktur (`imp`):**
    
    Rust
    
    ```
    // In src/app_shell/command_palette/imp.rs
    use gtk::glib::{self, Properties, Propagation, Variant};
    use gtk::prelude::*;
    use gtk::subclass::prelude::*;
    use gtk::{
        Box as GtkBox, SearchEntry, ListView, ScrolledWindow, SignalListItemFactory,
        ListItem, SingleSelection, FilterListModel, CustomFilter, NoSelection,
        gio, Orientation, Align,
    };
    use std::cell::{Cell, OnceCell, RefCell};
    use std::rc::Rc;
    use crate::app_shell::action_handler::MasterActionHandler;
    use super::fuzzy_searcher::{FuzzySearchAlgorithm, FuzzySearcher}; // Annahme
    use super::item::CommandPaletteItem; // Annahme
    
    #
    #[template(resource = "/org/example/myapp/command_palette_widget.ui")]
    #[properties(wrapper_type = super::CommandPaletteWidget)]
    pub struct CommandPaletteWidgetImp {
        #[template_child]
        pub search_entry: TemplateChild<SearchEntry>,
    
        #[template_child]
        pub results_scrolled_window: TemplateChild<ScrolledWindow>,
    
        #[template_child]
        pub results_list_view: TemplateChild<ListView>,
    
        // Interner Zustand
        list_store: OnceCell<gio::ListStore>, // Speichert CommandPaletteItem GObjects
        filter_model: OnceCell<FilterListModel>,
        selection_model: OnceCell<NoSelection>, // Oder SingleSelection, falls gewünscht
    
        fuzzy_searcher: FuzzySearcher, // Enthält den Algorithmus
        action_handler: OnceCell<Rc<MasterActionHandler>>,
        all_commands: RefCell<Vec<Rc<CommandPaletteItem>>>, // Cache aller verfügbaren Befehle
    }
    
    
    #[glib::object_subclass]
    impl ObjectSubclass for CommandPaletteWidgetImp {
        const NAME: &'static str = "MyCommandPaletteWidget";
        type Type = super::CommandPaletteWidget;
        type ParentType = GtkBox;
    
        fn class_init(klass: &mut Self::Class) {
            klass.bind_template();
            // Template Callbacks für UI-Datei-Events, falls benötigt
            // klass.bind_template_callback("search_entry_search_changed_cb", |widget: &super::CommandPaletteWidget, entry: &SearchEntry| {
            // widget.imp().on_search_changed(entry);
            // });
        }
    
        fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
            obj.init_template();
        }
    }
    
    #[glib::derived_properties]
    impl ObjectImpl for CommandPaletteWidgetImp {
        fn constructed(&self) {
            self.parent_constructed();
            let obj = self.obj(); // Wrapper-Instanz
    
            // Initialisiere list_store
            let store = gio::ListStore::new::<CommandPaletteItem>();
            self.list_store.set(store).expect("ListStore konnte nicht gesetzt werden.");
    
            // Initialisiere FilterListModel
            let filter = CustomFilter::new(|item_obj| {
                // Anfänglich alle Items zulassen, Filterung erfolgt durch Neusetzen der Ergebnisse
                // oder durch eine komplexere Filterlogik, die auf einer Eigenschaft des CommandPaletteItem basiert.
                // Für Fuzzy-Suche ist es oft einfacher, die `list_store` direkt neu zu befüllen.
                // Alternativ: item_obj.downcast_ref::<CommandPaletteItem>().unwrap().is_match() (wenn is_match eine Eigenschaft wäre)
                true
            });
            let filter_model = FilterListModel::new(Some(self.list_store.get().unwrap()), Some(filter));
            self.filter_model.set(filter_model).expect("FilterModel konnte nicht gesetzt werden.");
    
            // Initialisiere SelectionModel
            let selection_model = NoSelection::new(Some(self.filter_model.get().unwrap()));
            // Oder SingleSelection, wenn eine Auswahl gewünscht ist:
            // let selection_model = SingleSelection::new(Some(self.filter_model.get().unwrap()));
            self.selection_model.set(selection_model).expect("SelectionModel konnte nicht gesetzt werden.");
    
            // Konfiguriere ListView
            let factory = SignalListItemFactory::new();
            factory.connect_setup(move |_, list_item_gtk| {
                // Erstelle das Widget für ein Listenelement (z.B. eine GtkBox mit Icon und Label)
                // Dies kann auch über eine.ui-Datei für das ListItem geschehen (BuilderListItemFactory)
                let item_widget = gtk::Label::new(None); // Vereinfachtes Beispiel
                item_widget.set_halign(Align::Start);
                list_item_gtk.set_child(Some(&item_widget));
            });
    
            factory.connect_bind(move |_, list_item_gtk| {
                let list_item_gtk = list_item_gtk.downcast_ref::<ListItem>().expect("Muss ListItem sein");
                let command_item = list_item_gtk.item()
                   .and_downcast::<CommandPaletteItem>()
                   .expect("Item muss CommandPaletteItem sein");
    
                let child_widget = list_item_gtk.child().and_downcast::<gtk::Label>().expect("Child muss Label sein");
                // Binde Eigenschaften von command_item an child_widget
                // Hier nur der Name als Beispiel
                child_widget.set_label(&command_item.display_name());
    
                // Hier könnte man auch ein komplexeres Widget binden, das Icon etc. anzeigt
            });
    
            self.results_list_view.set_model(Some(self.selection_model.get().unwrap()));
            self.results_list_view.set_factory(Some(&factory));
    
            // Signale verbinden
            self.search_entry.connect_search_changed(glib::clone!(@weak obj => move |entry| {
                obj.imp().on_search_changed(entry);
            }));
    
            // Aktivierung eines Eintrags in der ListView
            self.results_list_view.connect_activate(glib::clone!(@weak obj => move |list_view, position| {
                obj.imp().on_item_activated(list_view, position);
            }));
    
            // Tastaturnavigation für ListView und SearchEntry
            self.setup_keyboard_navigation();
    
    
            // Lade initial alle verfügbaren Befehle
            self.load_all_commands();
        }
    }
    
    impl WidgetImpl for CommandPaletteWidgetImp {
        fn grab_focus(&self) -> bool {
            self.search_entry.grab_focus()
        }
    }
    impl BoxImpl for CommandPaletteWidgetImp {}
    
    // Private Methoden für CommandPaletteWidgetImp
    impl CommandPaletteWidgetImp {
        fn load_all_commands(&self) {
            let action_handler = self.action_handler.get().expect("ActionHandler nicht verfügbar").clone();
            let mut commands = Vec::new();
    
            // Hier app-weite und fenster-spezifische Aktionen vom MasterActionHandler abrufen
            // und in CommandPaletteItem-Objekte umwandeln.
            // Dies ist eine vereinfachte Darstellung. In einer echten Anwendung
            // müsste MasterActionHandler eine Methode bereitstellen, um beschreibende
            // Informationen über Aktionen zu liefern (Name, Icon, Parameter-Typen etc.).
    
            // Beispielhafte statische Befehle:
            commands.push(Rc::new(CommandPaletteItem::new(
                "quit".to_string(),
                "Anwendung beenden".to_string(),
                Some("application-exit".to_string()),
                "app.quit".to_string(), // Gio Action Name
                None
            )));
            commands.push(Rc::new(CommandPaletteItem::new(
                "about".to_string(),
                "Über diese Anwendung".to_string(),
                Some("help-about".to_string()),
                "app.about".to_string(), // Gio Action Name
                None
            )));
            //... weitere Befehle aus verschiedenen Quellen hinzufügen
    
            *self.all_commands.borrow_mut() = commands;
            self.update_displayed_results(&self.all_commands.borrow());
        }
    
        fn on_search_changed(&self, entry: &SearchEntry) {
            let query = entry.text().to_lowercase();
            if query.is_empty() {
                self.update_displayed_results(&self.all_commands.borrow());
                self.results_scrolled_window.set_visible(false);
            } else {
                let all_cmds = self.all_commands.borrow();
                let filtered_results: Vec<Rc<CommandPaletteItem>> = all_cmds
                   .iter()
                   .filter_map(|item| {
                        // Hier die Fuzzy-Suche anwenden.
                        // Die FuzzySearcher-Klasse sollte eine Methode wie `calculate_score` haben.
                        let score = self.fuzzy_searcher.calculate_score(&item.display_name().to_lowercase(), &query);
                        if score > 0.5 { // Schwellenwert für die Anzeige
                            let mut new_item_data = item.item_data().clone(); // Annahme: CommandPaletteItemData ist Clone
                            new_item_data.score = score;
                            Some(Rc::new(CommandPaletteItem::from_data(new_item_data))) // Erzeuge neues Item mit Score
                        } else {
                            None
                        }
                    })
                   .collect::<Vec<_>>();
    
                // Sortiere nach Score (höchster zuerst)
                // let mut sorted_results = filtered_results;
                // sorted_results.sort_by(|a, b| b.score().partial_cmp(&a.score()).unwrap_or(std::cmp::Ordering::Equal));
                // Da CommandPaletteItem ein GObject ist, kann man nicht einfach sortieren, wenn es schon im Store ist.
                // Besser: Den Store leeren und neu befüllen oder einen SortListModel verwenden.
                // Für dieses Beispiel wird der Store direkt mit gefilterten (aber nicht unbedingt sortierten) Ergebnissen befüllt.
                // Eine robustere Lösung würde einen GtkSortListModel verwenden.
    
                self.update_displayed_results(&filtered_results);
                self.results_scrolled_window.set_visible(!filtered_results.is_empty());
            }
        }
    
        fn update_displayed_results(&self, results: &) {
            let list_store = self.list_store.get().unwrap();
            list_store.remove_all();
            for item_rc in results {
                // Da CommandPaletteItem ein GObject ist, muss es geklont werden, wenn es
                // an mehreren Stellen gehalten wird (z.B. all_commands und list_store).
                // Wenn es nur für den list_store erstellt wird, ist kein Klonen nötig.
                // Hier wird angenommen, dass `results` bereits `Rc<CommandPaletteItem>` enthält.
                // Für `gio::ListStore::append` wird ein Verweis auf das GObject benötigt.
                list_store.append(item_rc.as_ref());
            }
        }
    
        fn on_item_activated(&self, _list_view: &ListView, position: u32) {
            let model = self.filter_model.get().unwrap(); // Oder direkt list_store, wenn kein Filter aktiv
            if let Some(item_obj) = model.item(position) {
                if let Ok(command_item) = item_obj.downcast::<CommandPaletteItem>() {
                    let action_name = command_item.action_name();
                    let param = command_item.action_param_variant(); // Methode, die Option<Variant> zurückgibt
    
                    if let Some(action_handler) = self.action_handler.get() {
                        action_handler.activate_action(&action_name, param.as_ref());
                        self.obj().emit_by_name::<()>("command-executed", &[&action_name, &param]);
                        // Palette ausblenden, typischerweise durch das MainWindow gesteuert
                        if let Some(revealer) = self.obj().parent().and_then(|p| p.downcast::<Revealer>().ok()) {
                             revealer.set_reveal_child(false);
                             let main_window = revealer.ancestor(MainWindow::static_type()).and_then(|a| a.downcast::<MainWindow>().ok());
                             if let Some(mw) = main_window {
                                 mw.set_is_command_palette_visible(false);
                             }
                        } else if let Some(popover) = self.obj().ancestor(gtk::Popover::static_type()).and_then(|p| p.downcast::<gtk::Popover>().ok()){
                            popover.popdown();
                             let main_window = popover.ancestor(MainWindow::static_type()).and_then(|a| a.downcast::<MainWindow>().ok());
                             if let Some(mw) = main_window {
                                 mw.set_is_command_palette_visible(false);
                             }
                        }
                    }
                }
            }
        }
    
        fn setup_keyboard_navigation(&self) {
            let search_entry = self.search_entry.get().unwrap();
            let list_view = self.results_list_view.get().unwrap();
    
            search_entry.add_controller({
                let key_controller = gtk::EventControllerKey::new();
                let list_view_clone = list_view.clone();
                key_controller.connect_key_pressed(move |_, keyval, _, _| {
                    match keyval {
                        gdk::Key::Down => {
                            // Fokus auf ListView setzen und erstes Element auswählen
                            list_view_clone.grab_focus();
                            // Ggf. erstes Element programmatisch auswählen, falls NoSelection verwendet wird
                            // oder die Logik für die Auswahl in SingleSelection anpassen.
                            // Für NoSelection ist dies komplexer, da es keine "aktuelle Auswahl" gibt.
                            // Man könnte den Fokus auf das erste Kind-Widget der ListView setzen.
                            Propagation::Stop
                        }
                        gdk::Key::Escape => {
                            // Palette schließen (durch MainWindow gesteuert)
                             if let Some(revealer) = search_entry.ancestor(gtk::Revealer::static_type()).and_then(|p| p.downcast::<gtk::Revealer>().ok()) {
                                 revealer.set_reveal_child(false);
                                 let main_window = revealer.ancestor(MainWindow::static_type()).and_then(|a| a.downcast::<MainWindow>().ok());
                                 if let Some(mw) = main_window {
                                     mw.set_is_command_palette_visible(false);
                                 }
                             } else if let Some(popover) = search_entry.ancestor(gtk::Popover::static_type()).and_then(|p| p.downcast::<gtk::Popover>().ok()){
                                popover.popdown();
                                 let main_window = popover.ancestor(MainWindow::static_type()).and_then(|a| a.downcast::<MainWindow>().ok());
                                 if let Some(mw) = main_window {
                                     mw.set_is_command_palette_visible(false);
                                 }
                            }
                            Propagation::Stop
                        }
                        _ => Propagation::Proceed,
                    }
                });
                key_controller
            });
    
            // ListView benötigt ebenfalls einen KeyController für Enter/Escape
            list_view.add_controller({
                let key_controller = gtk::EventControllerKey::new();
                let search_entry_clone = search_entry.clone();
                key_controller.connect_key_pressed(move |event_controller_key, keyval, _, _| {
                    let list_view_widget = event_controller_key.widget().unwrap().downcast::<ListView>().unwrap();
                    match keyval {
                        gdk::Key::Return | gdk::Key::KP_Enter => {
                            // Aktiviere das aktuell fokussierte/ausgewählte Element
                            // Dies erfordert, dass SingleSelection verwendet wird und ein Element fokussiert ist.
                            // Die `activate` Signalverbindung oben sollte dies bereits behandeln, wenn
                            // die ListView den Fokus hat und ein Element ausgewählt/aktiviert werden kann.
                            // Hier könnte man explizit die Aktion `list.activate-item` aufrufen.
                            // GtkListView::activate_action ist nicht direkt verfügbar, aber das Signal wird ausgelöst.
                            // Man könnte die aktuelle Cursorposition abfragen und das activate Signal manuell emittieren
                            // oder auf das existierende `activate` Signal vertrauen.
                            Propagation::Stop
                        }
                        gdk::Key::Escape => {
                            search_entry_clone.grab_focus(); // Fokus zurück zum Suchfeld
                            Propagation::Stop
                        }
                        _ => Propagation::Proceed,
                    }
                });
                key_controller
            });
        }
    }
    ```
    
    Die Verwendung von `gio::ListStore` in Kombination mit `gtk::ListView` und `gtk::SignalListItemFactory` ist ein moderner Ansatz in GTK4 zur Darstellung dynamischer Listen.21 `GtkFilterListModel` kann verwendet werden, um die im `ListStore` enthaltenen Elemente basierend auf der Suchanfrage zu filtern, obwohl für eine echte Fuzzy-Suche oft das Neupopulieren des Stores oder ein spezialisierter Filter effektiver ist. Die `fuzzy-search`-Bibliothek 26 bietet Algorithmen wie SymSpell, die hierfür geeignet sind.
    
- **UI-Definition (`command_palette_widget.ui`):**
    
    XML
    
    ```
    <?xml version="1.0" encoding="UTF-8"?>
    <interface>
      <requires lib="gtk" version="4.0"/>
      <template class="MyCommandPaletteWidget" parent="GtkBox">
        <property name="orientation">vertical</property>
        <property name="spacing">6</property>
        <child>
          <object class="GtkSearchEntry" id="search_entry">
            <property name="placeholder-text" translatable="yes">Befehl eingeben...</property>
            <property name="hexpand">true</property>
          </object>
        </child>
        <child>
          <object class="GtkScrolledWindow" id="results_scrolled_window">
            <property name="hscrollbar-policy">never</property>
            <property name="vscrollbar-policy">automatic</property>
            <property name="min-content-height">100</property> <property name="max-content-height">300</property> <property name="vexpand">false</property> <property name="visible">false</property> <child>
              <object class="GtkListView" id="results_list_view">
                <property name="css-classes">results-list</property>
              </object>
            </child>
          </object>
        </child>
      </template>
    </interface>
    ```
    

##### 2.3.4. Eigenschaften

Keine öffentlich exponierten GObject-Eigenschaften. Der interne Zustand wird durch die Felder in `CommandPaletteWidgetImp` verwaltet.

##### 2.3.5. Methoden

- **`pub fn new(action_handler: Rc<MasterActionHandler>) -> Self`** (bereits im Wrapper definiert)
    
    - **Nachbedingungen:** Das Widget ist initialisiert, der `action_handler` ist gespeichert. Die `list_store`, `filter_model`, `selection_model` und `results_list_view` sind konfiguriert. `search_entry` ist mit `on_search_changed` verbunden. `results_list_view` ist mit `on_item_activated` verbunden. Tastaturnavigation ist eingerichtet. Initiale Befehlsliste ist geladen.
- **`pub fn show_palette(&self)`**
    
    - **Signatur:** `pub fn show_palette(&self)`
    - **Zugriffsmodifikator:** `pub`
    - **Nachbedingungen:** Das `search_entry` erhält den Fokus, vorherige Suchanfragen und Ergebnisse werden gelöscht, und die Ergebnisliste wird initial (ggf. leer oder mit allen Befehlen) angezeigt und sichtbar gemacht, falls Ergebnisse vorhanden sind.
    - **Implementierungslogik:**
        1. Hole `imp`.
        2. `imp.search_entry.set_text("")`.
        3. `imp.search_entry.grab_focus()`.
        4. `imp.update_displayed_results(&imp.all_commands.borrow())` (oder leere Liste, je nach gewünschtem Verhalten).
        5. `imp.results_scrolled_window.set_visible(!imp.list_store.get().unwrap().n_items() == 0)`.
- **`pub fn hide_palette(&self)`**
    
    - **Signatur:** `pub fn hide_palette(&self)`
    - **Zugriffsmodifikator:** `pub`
    - **Nachbedingungen:** Die Palette wird ausgeblendet (typischerweise durch das `MainWindow`, das den `Revealer` steuert). Suchfeld wird geleert.
    - **Implementierungslogik:**
        1. Hole `imp`.
        2. `imp.search_entry.set_text("")`.
        3. Die eigentliche Ausblendlogik (z.B. `revealer.set_reveal_child(false)`) sollte vom `MainWindow` gesteuert werden, welches diese Methode aufruft oder auf ein Signal reagiert.
- **`fn on_search_changed(&self, entry: &gtk::SearchEntry)`** (Privat, in `CommandPaletteWidgetImp` implementiert)
    
    - **Implementierungslogik Details:**
        1. Hole den Suchbegriff von `entry.text()`.
        2. Wenn der Suchbegriff leer ist:
            - Zeige alle Befehle oder keine (je nach Designentscheidung). `self.update_displayed_results(&self.all_commands.borrow());`
            - `self.results_scrolled_window.set_visible(!self.list_store.get().unwrap().n_items() == 0);`
            - Beende.
        3. Hole die gecachte Liste aller `CommandPaletteItem`s (`self.all_commands.borrow()`).
        4. Iteriere über `all_commands`:
            - Für jedes Kommando, berechne den Fuzzy-Match-Score mit `self.fuzzy_searcher.calculate_score(&command_item.display_name().to_lowercase(), &query)`. Die `fuzzy-search`-Bibliothek 26 bietet hierfür geeignete Algorithmen.
            - Wenn der Score einen Schwellenwert überschreitet, erstelle ein neues `CommandPaletteItem`-GObject (oder klone das existierende und aktualisiere dessen `score`-Eigenschaft). Füge es zu einer temporären Ergebnisliste hinzu.
        5. Sortiere die temporäre Ergebnisliste nach Score (absteigend).
        6. Aktualisiere `self.list_store` mit den sortierten Ergebnissen mittels `self.update_displayed_results(&sorted_results)`.
        7. `self.results_scrolled_window.set_visible(!sorted_results.is_empty());`
- **`fn on_item_activated(&self, _list_view: &gtk::ListView, position: u32)`** (Privat, in `CommandPaletteWidgetImp` implementiert)
    
    - **Implementierungslogik Details:**
        1. Hole das `CommandPaletteItem`-GObject an der gegebenen `position` aus dem `self.filter_model.get().unwrap()` (oder `self.list_store.get().unwrap()`, falls kein Filtermodell verwendet wird). 27
        2. Extrahiere `action_name` und `action_param` (als `Option<glib::Variant>`) aus dem `CommandPaletteItem`.
        3. Rufe `self.action_handler.get().unwrap().activate_action(&action_name, action_param.as_ref())` auf.
        4. Emittiere das `command_executed`-Signal: `self.obj().emit_by_name::<()>("command-executed", &[&action_name, &action_param]);`.
        5. Veranlasse das Schließen der Palette (z.B. durch ein Signal an `MainWindow` oder direkten Aufruf von `MainWindow::hide_palette`, falls eine Referenz vorhanden ist und dies architektonisch sinnvoll ist. Eine sauberere Methode ist, dass `MainWindow` auf `command-executed` hört und die Palette schließt). Hier wird die Logik aus `setup_keyboard_navigation` für Escape wiederverwendet.

##### 2.3.6. Signale

- **Emittierte Signale:**
    - **Signal Name:** `command-executed`
        - **GObject Name:** `command-executed`
        - **Parameter:**
            - `action_name`: `String` (Rust), `glib::VariantType::STRING` (`glib::Variant`) – Der Name der ausgeführten Aktion.
            - `parameter`: `Option<glib::Variant>` (Rust), `glib::VariantType::VARIANT` (`glib::Variant`) – Der Parameter, mit dem die Aktion ausgeführt wurde (kann `None` sein).
        - **Beschreibung:** Wird emittiert, nachdem ein Befehl aus der Palette erfolgreich ausgewählt und dessen Aktion ausgelöst wurde.
        - **Definition in `ObjectImpl::signals()` (in `CommandPaletteWidgetImp`):**
            
            Rust
            
            ```
            fn signals() -> &'static {
                static SIGNALS: OnceCell<Vec<glib::subclass::Signal>> = OnceCell::new();
                SIGNALS.get_or_init(|| {
                    vec!) // glib::Variant kann None sein
                           .build(),
                    ]
                })
            }
            ```
            

##### 2.3.7. Datenstrukturen

- **`CommandPaletteItem` (GObject)**
    
    - **Datei:** `src/app_shell/command_palette/item.rs`
    - **Wrapper:** `pub struct CommandPaletteItem(ObjectSubclass<imp::CommandPaletteItemImp>)`
    - **Implementierung (`imp`):**
        
        Rust
        
        ```
        // In src/app_shell/command_palette/item/imp.rs
        use gtk::glib::{self, Properties, Variant};
        use gtk::prelude::*;
        use gtk::subclass::prelude::*;
        use std::cell::{Cell, RefCell};
        
        # // Clone für item_data
        #[properties(wrapper_type = super::CommandPaletteItem)]
        pub struct CommandPaletteItemData {
            #
            pub id: RefCell<String>,
            #
            pub display_name: RefCell<String>,
            #[property(get, set, name="icon-name", nick="Icon Name", blurb="Optional icon name for the command")]
            pub icon_name: RefCell<Option<String>>,
            #[property(get, set, name="action-name", nick="Action Name", blurb="gio::Action name to execute")]
            pub action_name: RefCell<String>,
            #[property(get, set, name="action-param", nick="Action Parameter", blurb="Optional parameter for the action")]
            pub action_param: RefCell<Option<Variant>>, // Speichert glib::Variant direkt
            #
            pub score: Cell<f32>,
        }
        
        #
        pub struct CommandPaletteItemImp {
            #[property(get, set)]
            data: RefCell<CommandPaletteItemData>,
        }
        
        
        #[glib::object_subclass]
        impl ObjectSubclass for CommandPaletteItemImp {
            const NAME: &'static str = "MyCommandPaletteItem";
            type Type = super::CommandPaletteItem;
            type ParentType = glib::Object;
        }
        
        // Manuelle Implementierung von ObjectImpl, um Properties von CommandPaletteItemData weiterzuleiten
        // oder #[glib::derived_properties] auf CommandPaletteItemImp verwenden, wenn data direkt Properties hätte.
        // Da data ein RefCell<CommandPaletteItemData> ist und CommandPaletteItemData #[derive(Properties)] hat,
        // benötigen wir eine Brücke oder eine flachere Struktur.
        // Einfacher ist es, die Properties direkt in CommandPaletteItemImp zu definieren, wenn möglich,
        // oder Getter/Setter im Wrapper zu implementieren, die auf `data` zugreifen.
        // Für dieses Beispiel gehen wir davon aus, dass die Properties direkt auf CommandPaletteItemImp definiert werden
        // oder dass der Wrapper entsprechende Zugriffsmethoden bereitstellt.
        // Die #[property] Attribute in CommandPaletteItemData sind für den Fall, dass CommandPaletteItemData selbst
        // als GObject verwendet würde. Hier ist es eingebettet.
        // Eine bessere Struktur wäre, die Felder direkt in CommandPaletteItemImp zu haben und dort #[property] zu verwenden.
        // Wir passen das an, um die Properties direkt im GObject zu haben:
        
        // In src/app_shell/command_palette/item/imp.rs (angepasst)
        //... imports...
        #
        #[properties(wrapper_type = super::CommandPaletteItem)]
        pub struct CommandPaletteItemImp {
            #
            pub id: RefCell<String>,
            #
            pub display_name: RefCell<String>,
            #[property(get, set, name="icon-name", nick="Icon Name", blurb="Optional icon name for the command")]
            pub icon_name: RefCell<Option<String>>,
            #[property(get, set, name="action-name", nick="Action Name", blurb="gio::Action name to execute")]
            pub action_name: RefCell<String>,
            #[property(get, set, name="action-param-variant", nick="Action Parameter Variant", blurb="Optional parameter for the action as GVariant")]
            pub action_param_variant: RefCell<Option<Variant>>,
            #
            pub score: Cell<f32>,
        }
        
        #[glib::object_subclass]
        impl ObjectSubclass for CommandPaletteItemImp {
            const NAME: &'static str = "MyCommandPaletteItem";
            type Type = super::CommandPaletteItem;
            type ParentType = glib::Object;
        }
        
        #[glib::derived_properties]
        impl ObjectImpl for CommandPaletteItemImp {}
        ```
        
    - **Wrapper-Methoden für `CommandPaletteItem` (in `item/mod.rs`):**
        
        Rust
        
        ```
        // In src/app_shell/command_palette/item/mod.rs
        use gtk::glib::{self, Variant};
        use gtk::subclass::prelude::*;
        
        mod imp;
        
        glib::wrapper! {
            pub struct CommandPaletteItem(ObjectSubclass<imp::CommandPaletteItemImp>)
                @extends glib::Object;
        }
        
        impl CommandPaletteItem {
            pub fn new(
                id: String,
                display_name: String,
                icon_name: Option<String>,
                action_name: String,
                action_param: Option<Variant>,
            ) -> Self {
                glib::Object::builder()
                   .property("item-id", &id)
                   .property("display-name", &display_name)
                   .property("icon-name", &icon_name)
                   .property("action-name", &action_name)
                   .property("action-param-variant", &action_param)
                   .build()
            }
            // Getter für die Properties werden durch #[glib::derived_properties] und #[property(get)] generiert.
            // z.B. self.item_id(), self.display_name() etc.
        }
        ```
        
    - Die Verwendung eines dedizierten GObject für Listeneinträge ist notwendig für `gio::ListStore` und ermöglicht saubere Datenbindung und Property-Management.23
- **`FuzzySearchAlgorithm` Enum (in `fuzzy_searcher.rs`):**
    
    Rust
    
    ```
    pub enum FuzzySearchAlgorithm {
        Levenshtein,
        SymSpell, // Von fuzzy-search crate [26]
        // Weitere Algorithmen...
    }
    
    pub struct FuzzySearcher {
        algorithm: FuzzySearchAlgorithm,
        // Ggf. initialisierte Strukturen für den gewählten Algorithmus, z.B. SymSpell Dictionary
    }
    
    impl FuzzySearcher {
        pub fn new(algorithm: FuzzySearchAlgorithm) -> Self {
            // Initialisiere den Sucher basierend auf dem Algorithmus
            Self { algorithm, /*... */ }
        }
    
        pub fn calculate_score(&self, text: &str, query: &str) -> f32 {
            match self.algorithm {
                FuzzySearchAlgorithm::Levenshtein => {
                    let distance = levenshtein::levenshtein(query, text);
                    // Konvertiere Distanz in einen Score (z.B. 1.0 - (distance / max_len))
                    // Je höher der Score, desto besser der Match.
                    // Dies ist eine einfache Heuristik.
                    let max_len = std::cmp::max(text.len(), query.len()) as f32;
                    if max_len == 0.0 { return if query == text {1.0} else {0.0}; }
                    1.0 - (distance as f32 / max_len)
                }
                FuzzySearchAlgorithm::SymSpell => {
                    // Verwendung der fuzzy-search crate [26]
                    // Die Crate gibt typischerweise direkt passende Strings oder Distanzen zurück.
                    // Hier müsste eine Adaption erfolgen, um einen Score zu erhalten.
                    // Beispiel: Wenn ein Match gefunden wird, Score > 0.5, sonst 0.
                    // Die `fuzzy-search` Crate bietet `levenshtein` als Funktion.
                    // Für SymSpell müsste man die `SymSpell::lookup` Methode verwenden und die Ergebnisse interpretieren.
                    // Für dieses Beispiel wird Levenshtein als Fallback verwendet, wenn SymSpell nicht direkt einen Score liefert.
                    let distance = levenshtein::levenshtein(query, text);
                    let max_len = std::cmp::max(text.len(), query.len()) as f32;
                    if max_len == 0.0 { return if query == text {1.0} else {0.0}; }
                    1.0 - (distance as f32 / max_len)
                }
            }
        }
    }
    ```
    
- **Tabelle: `CommandPaletteItem` Eigenschaften**
    

|   |   |   |   |   |
|---|---|---|---|---|
|**Eigenschaftsname (GObject)**|**Rust-Feld (Imp)**|**Rust-Typ**|**Standardwert**|**Beschreibung**|
|`item-id`|`id`|`RefCell<String>`|`""`|Eindeutige ID des Befehlseintrags.|
|`display-name`|`display_name`|`RefCell<String>`|`""`|Für den Benutzer sichtbarer Name des Befehls.|
|`icon-name`|`icon_name`|`RefCell<Option<String>>`|`None`|Optionaler Icon-Name für den Befehl (gemäß Freedesktop Icon Naming Spec).|
|`action-name`|`action_name`|`RefCell<String>`|`""`|Der Name der `gio::Action`, die ausgeführt werden soll.|
|`action-param-variant`|`action_param_variant`|`RefCell<Option<Variant>>`|`None`|Optionaler Parameter für die Aktion, als `glib::Variant`.|
|`score`|`score`|`Cell<f32>`|`0.0`|Score des Fuzzy-Suchalgorithmus für diesen Eintrag (höher ist besser).|

```
Diese Tabelle dokumentiert die Struktur der `CommandPaletteItem`-Objekte, die in der Ergebnisliste angezeigt werden. Sie ist entscheidend für Entwickler, die neue Befehle zur Palette hinzufügen oder das Verhalten der Palette anpassen möchten.
```

##### 2.3.8. UI Layout und Styling

- **Widget-Hierarchie:** (Wie in `command_palette_widget.ui` definiert)
    - `MyCommandPaletteWidget` (`gtk::Box`, vertikal, `spacing=6`)
        - `search_entry` (`gtk::SearchEntry`, `hexpand=true`, `placeholder-text="Befehl eingeben..."`)
        - `results_scrolled_window` (`gtk::ScrolledWindow`, `hscrollbar-policy=never`, `vscrollbar-policy=automatic`, `min-content-height`, `max-content-height`, `vexpand=false`, `visible=false`)
            - `results_list_view` (`gtk::ListView`, CSS-Klasse `results-list`)
- **Styling:**
    - `CommandPaletteWidget`: CSS-Name `command-palette`.
    - `search_entry`: Standard-Styling oder CSS-Klasse `command-palette-search-entry`.
    - `results_list_view`: CSS-Klasse `results-list`.
    - `ListItem`-Widgets (in der Factory erstellt): CSS-Klasse `command-palette-item`. Aktive/Hover-Zustände können über CSS definiert werden. Die Verwendung von `vexpand=false` für das `ScrolledWindow` und `min/max-content-height` stellt sicher, dass die Ergebnisliste nicht den gesamten verfügbaren Platz einnimmt, sondern sich dynamisch bis zu einer maximalen Höhe anpasst.

##### 2.3.9. Exception Handling / Error Types

Fehler bei der Interaktion mit dem `MasterActionHandler` oder bei der D-Bus-Kommunikation (falls Aktionen über D-Bus ausgelöst werden) sollten abgefangen und geloggt werden. UI-Fehler (z.B. fehlerhafte Item-Erstellung) sollten ebenfalls behandelt werden.

##### 2.3.10. Asynchrone Operationen

Die Fuzzy-Suche selbst könnte bei sehr vielen Befehlen potenziell blockierend sein. Falls dies der Fall ist, sollte die Suchlogik in `on_search_changed` in einen separaten Thread oder eine asynchrone Aufgabe ausgelagert werden, die dann die `list_store` über den `AsyncUIManager` aktualisiert. Für die typische Anzahl von Befehlen in einer Palette ist dies jedoch oft nicht notwendig.

##### 2.3.11. Abhängigkeiten

- `MasterActionHandler`: Zum Abrufen verfügbarer Aktionen und zum Auslösen ausgewählter Aktionen.
- `fuzzy-search` Crate (oder eine ähnliche Bibliothek) für die Fuzzy-Suchlogik.26
- `gtk::SearchEntry`, `gtk::ListView`, `gtk::ScrolledWindow`, `gio::ListStore`, `gtk::FilterListModel`, `gtk::SignalListItemFactory`.

##### 2.3.12. Testplan

- **Unit-Tests (`fuzzy_searcher.rs`):**
    - Teste verschiedene Suchanfragen gegen eine bekannte Menge von Befehlsnamen.
    - Überprüfe Korrektheit der Scores und der Sortierung.
    - Teste Randfälle (leere Query, keine Treffer, exakte Treffer).
- **Unit-Tests (`CommandPaletteItem`):**
    - Teste Erstellung und Property-Zugriff.
- **Widget-Tests (`CommandPaletteWidget` mit GTK-Testumgebung):**
    - Teste `show_palette()` und `hide_palette()` (indirekt über `MainWindow`).
    - Simuliere Texteingabe in `search_entry` und überprüfe:
        - Korrekte Filterung und Anzeige der Ergebnisse in `results_list_view`.
        - Korrekte Sortierung der Ergebnisse.
        - Sichtbarkeit des `results_scrolled_window`.
    - Simuliere Item-Aktivierung (`results_list_view.activate`) und überprüfe:
        - Aufruf von `MasterActionHandler::activate_action` mit korrekten Parametern.
        - Emission des `command_executed`-Signals.
        - Schließen der Palette.
    - Teste Tastaturnavigation (Pfeiltasten, Enter, Escape).

#### 2.4. `MasterActionHandler` (Service/Non-Widget GObject)

##### 2.4.1. Übersicht und Zweck

Der `MasterActionHandler` ist ein zentraler Dienst innerhalb der Applikation, der als Registrierungsstelle und Auslöser für globale und fensterspezifische `gio::Action`-Instanzen dient. Er ermöglicht es verschiedenen Komponenten, Aktionen zu definieren und bereitzustellen, ohne dass eine direkte Kopplung zwischen dem Auslöser (z.B. einem Menüpunkt, einem Button oder der `CommandPaletteWidget`) und dem Aktionsempfänger bestehen muss. Dies fördert die Entkopplung und Wiederverwendbarkeit von Aktionen. GTK selbst nutzt `gio::Action` intensiv für Menüs, Tastenkürzel und UI-Elemente, die Aktionen auslösen können.12 Der `MasterActionHandler` stellt eine Abstraktionsebene darüber bereit, um die Verwaltung dieser Aktionen applikationsweit zu vereinfachen.

##### 2.4.2. Dateistruktur

- `src/app_shell/action_handler/mod.rs`: Öffentliches Modul und Wrapper-Definition.
- `src/app_shell/action_handler/imp.rs`: Private Implementierungsdetails und GObject-Subklassifizierung.

##### 2.4.3. GObject-Definition

- **Wrapper-Typ:**
    
    Rust
    
    ```
    // In src/app_shell/action_handler/mod.rs
    use gtk::glib;
    use gtk::gio;
    use gtk::subclass::prelude::*;
    use std::collections::HashMap;
    use std::cell::RefCell;
    use gtk::ApplicationWindow; // Für window_actions
    
    glib::wrapper! {
        pub struct MasterActionHandler(ObjectSubclass<imp::MasterActionHandlerImp>)
            @extends glib::Object;
    }
    
    impl MasterActionHandler {
        pub fn new() -> Self {
            glib::Object::builder().build()
        }
    
        // Wrapper-Methoden für die Logik in imp
        pub fn register_app_action(&self, app: &gtk::Application, action: &impl IsA<gio::Action>) {
            self.imp().register_app_action(app, action);
        }
    
        pub fn register_window_action(&self, window: &ApplicationWindow, action_name_prefix: &str, action: &impl IsA<gio::Action>) {
            self.imp().register_window_action(window, action_name_prefix, action);
        }
    
        pub fn activate_action(&self, active_window: Option<&ApplicationWindow>, action_name: &str, parameter: Option<&glib::Variant>) {
            self.imp().activate_action(active_window, action_name, parameter);
        }
    
        pub fn create_action_entry<F>(
            name: &str,
            parameter_type: Option<&glib::VariantTy>,
            state: Option<&glib::Variant>,
            activate_callback: F,
        ) -> gio::ActionEntry
        where
            F: Fn(&gio::SimpleAction, Option<&glib::Variant>) + 'static,
        {
            // Diese Methode ist statisch oder Teil des Imp, da sie keine Self-Referenz benötigt,
            // wenn sie nur eine ActionEntry erstellt.
            // Wenn sie jedoch Zugriff auf den MasterActionHandler selbst benötigt (z.B. um
            // this.obj() in der Closure zu verwenden), dann muss sie eine &self Referenz haben.
            // Für eine reine Factory-Methode ist static ok.
    
            let action = gio::SimpleAction::new_stateful(name, parameter_type, state.unwrap_or(&Variant::unit()));
            action.connect_activate(move |act, param| {
                activate_callback(act, param);
            });
            // ActionEntry::builder() ist oft einfacher für die direkte Verwendung mit add_action_entries.
            // Diese Methode hier ist eher für die manuelle Erstellung und Registrierung einzelner SimpleActions.
            // Die Anforderung war ActionEntry, daher:
            ActionEntry::builder(name)
               .parameter_type(parameter_type.cloned())
               .state(state.cloned())
               .activate(move |_target_obj: &glib::Object, act: &gio::SimpleAction, param: Option<&Variant>| {
                    // Die Closure-Signatur für ActionEntry::activate ist anders.
                    // Sie erhält das Zielobjekt (App oder Window), die Aktion und den Parameter.
                    // Der Aufruf von activate_callback muss hier angepasst werden.
                    // Da activate_callback hier eine generische Fn ist, die SimpleAction erwartet,
                    // ist die direkte Verwendung in ActionEntry::activate schwierig ohne Anpassung.
                    // Einfacher ist es, SimpleAction zu erstellen und dann add_action zu verwenden.
    
                    // Für ActionEntry wäre es eher so:
                    // activate: move |target_obj, simple_action, param_variant| {
                    //     // Logik hier, die auf target_obj (App/Window), simple_action und param_variant zugreift
                    // }
                    // Die bereitgestellte activate_callback Signatur passt besser zu SimpleAction::connect_activate.
                    // Wir gehen davon aus, dass die ActionEntry dann manuell einer ActionMap hinzugefügt wird.
                    // Oder, die activate_callback wird so angepasst, dass sie mit ActionEntry kompatibel ist.
                })
               .build()
        }
    }
    
    impl Default for MasterActionHandler {
        fn default() -> Self {
            Self::new()
        }
    }
    ```
    
- **Implementierungs-Struktur (`imp`):**
    
    Rust
    
    ```
    // In src/app_shell/action_handler/imp.rs
    use gtk::glib::{self, Variant, VariantTy};
    use gtk::gio::{self, prelude::*, ActionMap, SimpleActionGroup};
    use gtk::subclass::prelude::*;
    use gtk::ApplicationWindow;
    use std::collections::HashMap;
    use std::cell::RefCell;
    use std::rc::Rc; // Für das Signal
    
    #
    pub struct MasterActionHandlerImp {
        // app_actions wird direkt auf gtk::Application gesetzt, daher hier nicht unbedingt nötig.
        // Stattdessen halten wir eine Referenz auf die App, um Aktionen zu setzen.
        app: RefCell<Option<gtk::Application>>,
        window_actions: RefCell<HashMap<String, gio::SimpleActionGroup>>, // Key: Window ID (z.B. GObject Pointer als String oder eine eindeutige ID)
    }
    
    #[glib::object_subclass]
    impl ObjectSubclass for MasterActionHandlerImp {
        const NAME: &'static str = "MyMasterActionHandler";
        type Type = super::MasterActionHandler;
        type ParentType = glib::Object;
    }
    
    impl ObjectImpl for MasterActionHandlerImp {
        fn signals() -> &'static {
            static SIGNALS: OnceCell<Vec<glib::subclass::Signal>> = OnceCell::new();
            SIGNALS.get_or_init(|| {
                vec!) // action_name, success
                       .build(),
                ]
            })
        }
    }
    
    impl MasterActionHandlerImp {
        pub fn register_app_action(&self, app: &gtk::Application, action: &impl IsA<gio::Action>) {
            // Speichere die App-Referenz, falls noch nicht geschehen
            if self.app.borrow().is_none() {
                *self.app.borrow_mut() = Some(app.clone());
            }
            app.add_action(action); // gtk::Application implementiert gio::ActionMap
        }
    
        pub fn register_window_action(
            &self,
            window: &ApplicationWindow,
            action_name_prefix: &str, // z.B. "win"
            action: &impl IsA<gio::Action>,
        ) {
            // Eindeutige ID für das Fenster generieren (z.B. Pfad oder eine interne ID)
            // Für dieses Beispiel verwenden wir den GObject-Pfad, falls verfügbar, oder eine einfache Zählung.
            // Eine robustere Lösung wäre, eine eindeutige ID pro Fenster zu verwalten.
            let window_id = window.path().map_or_else(
    ```
    

|

| format!("{:p}", window.as_ptr()), // Fallback: Pointer-Adresse als ID

|p| p.to_string()

);

````
        let mut window_actions_map = self.window_actions.borrow_mut();
        let action_group = window_actions_map
           .entry(window_id.clone())
           .or_insert_with(SimpleActionGroup::new);
        
        action_group.add_action(action);

        // Stelle sicher, dass die ActionGroup auch tatsächlich am Fenster registriert ist.
        // GTK fügt automatisch eine "win" ActionGroup zu ApplicationWindows hinzu.
        // Wenn wir eine eigene Gruppe verwenden wollen, müssen wir sie einfügen.
        // Für Standard "win." Aktionen:
        if action_name_prefix == "win" {
             window.lookup_action(&action.name().unwrap_or_default().to_string()); // Prüfen ob schon da
             window.add_action(action); // Fügt zur Standard "win" Gruppe hinzu
        } else {
            // Für benutzerdefinierte Gruppen
            if window.lookup_action_group(action_name_prefix).is_none() {
                window.insert_action_group(action_name_prefix, Some(action_group));
            }
        }
    }

    pub fn activate_action(
        &self,
        active_window: Option<&ApplicationWindow>,
        action_name: &str,
        parameter: Option<&Variant>,
    ) {
        let mut success = false;
        // Versuche zuerst, die Aktion im Kontext des aktiven Fensters auszuführen
        if let Some(window) = active_window {
            if let Some(action) = window.lookup_action(action_name) {
                action.activate(parameter);
                success = true;
            }
            // Man könnte auch nach präfixierten Aktionen suchen, z.B. "win.my-action"
            // oder spezifische ActionGroups durchsuchen, die am Fenster registriert sind.
            // Die aktuelle Implementierung von register_window_action fügt Aktionen
            // direkt zur Standard "win" Gruppe des Fensters hinzu oder zu einer benutzerdefinierten Gruppe.
            // `window.lookup_action` sollte also "prefix.action" finden, wenn so registriert.
        }

        // Wenn nicht im Fensterkontext gefunden oder kein aktives Fenster, versuche App-Aktionen
        if!success {
            if let Some(app) = self.app.borrow().as_ref() {
                if let Some(action) = app.lookup_action(action_name) {
                    action.activate(parameter);
                    success = true;
                }
            }
        }

        if!success {
            eprintln!("Aktion '{}' konnte nicht gefunden oder aktiviert werden.", action_name);
        }
        
        self.obj().emit_by_name::<()>("action-activated", &[&action_name, &success]);
    }
}
```
Die Verwaltung von Aktionen ist zentral für GTK-Anwendungen. `gio::Action` und `gio::ActionMap` (implementiert von `gtk::Application` und `gtk::ApplicationWindow`) sind die Kernkomponenten.[12, 30] `gio::SimpleActionGroup` kann verwendet werden, um Aktionen zu bündeln.[31, 32] Der `MasterActionHandler` kapselt die Logik zur Registrierung und Aktivierung dieser Aktionen.
````

##### 2.4.4. Eigenschaften

Keine öffentlich exponierten GObject-Eigenschaften.

##### 2.4.5. Methoden

- **`pub fn new() -> Self`** (bereits im Wrapper definiert)
    
    - **Nachbedingungen:** Ein neuer `MasterActionHandler` wird erstellt. Interne Maps für Fensteraktionen sind initialisiert.
- **`pub fn register_app_action(&self, app: &gtk::Application, action: &impl IsA<gio::Action>)`** (Wrapper für `imp`-Methode)
    
    - **Signatur (Imp):** `pub fn register_app_action(&self, app: &gtk::Application, action: &impl IsA<gio::Action>)`
    - **Parameter:**
        - `app`: `&gtk::Application` – Die Applikationsinstanz.
        - `action`: `&impl IsA<gio::Action>` – Die zu registrierende App-Aktion.
    - **Nachbedingungen:** Die Aktion ist in der `ActionMap` der `gtk::Application` registriert und kann global aufgerufen werden (z.B. mit Präfix "app.").
    - **Implementierungslogik (Imp):**
        1. Rufe `app.add_action(action)` auf. `gtk::Application` implementiert `gio::ActionMap`.30
- **`pub fn register_window_action(&self, window: &ApplicationWindow, action_name_prefix: &str, action: &impl IsA<gio::Action>)`** (Wrapper für `imp`-Methode)
    
    - **Signatur (Imp):** `pub fn register_window_action(&self, window: &ApplicationWindow, action_name_prefix: &str, action: &impl IsA<gio::Action>)`
    - **Parameter:**
        - `window`: `&ApplicationWindow` – Das Fenster, für das die Aktion registriert wird.
        - `action_name_prefix`: `&str` – Ein Präfix für die Aktionsgruppe (z.B. "win").
        - `action`: `&impl IsA<gio::Action>` – Die zu registrierende Fenster-Aktion.
    - **Nachbedingungen:** Die Aktion ist in einer `ActionMap` registriert, die mit dem Fenster assoziiert ist. Sie kann über das Fenster aufgerufen werden (z.B. mit Präfix "win.").
    - **Implementierungslogik (Imp):**
        1. Generiere eine eindeutige ID für das `window` (z.B. `window.path()` oder Pointer-Adresse).
        2. Hole oder erstelle eine `gio::SimpleActionGroup` für diese Fenster-ID aus `self.window_actions`.
        3. Füge `action` zur `SimpleActionGroup` hinzu.
        4. Füge die `SimpleActionGroup` zur `ActionMap` des `window` hinzu, falls sie nicht schon existiert, unter Verwendung des `action_name_prefix`: `window.insert_action_group(action_name_prefix, Some(&action_group));`.31 Wenn der Präfix "win" ist, kann die Aktion direkt zum Fenster hinzugefügt werden, da `ApplicationWindow` bereits eine "win"-Gruppe hat: `window.add_action(action);`.
- **`pub fn activate_action(&self, active_window: Option<&ApplicationWindow>, action_name: &str, parameter: Option<&glib::Variant>)`** (Wrapper für `imp`-Methode)
    
    - **Signatur (Imp):** `pub fn activate_action(&self, active_window: Option<&ApplicationWindow>, action_name: &str, parameter: Option<&glib::Variant>)`
    - **Parameter:**
        - `active_window`: `Option<&ApplicationWindow>` – Das aktuell aktive Fenster, falls vorhanden.
        - `action_name`: `&str` – Der vollständige Name der zu aktivierenden Aktion (z.B. "win.close" oder "app.about").
        - `parameter`: `Option<&glib::Variant>` – Der Parameter für die Aktion.
    - **Nachbedingungen:** Die angeforderte Aktion wird ausgeführt, falls sie gefunden wird. Das `action_activated`-Signal wird emittiert.
    - **Implementierungslogik (Imp):**
        1. `success = false`.
        2. Wenn `active_window` `Some(window)` ist:
            - Versuche, die Aktion `action_name` direkt auf `window` zu finden und zu aktivieren: `window.activate_action(action_name, parameter)`. `gtk::ApplicationWindow` implementiert `gio::ActionGroup` und `gio::ActionMap`.30
            - Wenn erfolgreich, setze `success = true`.
        3. Wenn nicht erfolgreich und `action_name` app-spezifisch ist (z.B. beginnt mit "app.") oder global gesucht werden soll:
            - Hole die `gtk::Application`-Instanz aus `self.app`.
            - Versuche, die Aktion `action_name` auf der Applikation zu finden und zu aktivieren: `app.activate_action(action_name, parameter)`.
            - Wenn erfolgreich, setze `success = true`.
        4. Wenn immer noch nicht erfolgreich, logge einen Fehler.
        5. Emittiere das `action-activated`-Signal mit `action_name` und `success`.
- **`pub fn create_action_entry<F>(name: &str, parameter_type: Option<&glib::VariantTy>, state: Option<&glib::Variant>, activate_callback: F) -> gio::ActionEntry`** (Statische Hilfsmethode oder Methode auf `MasterActionHandlerImp`)
    
    - **Signatur:** Wie im Wrapper definiert. `F: Fn(&gio::SimpleAction, Option<&glib::Variant>) + 'static`
    - **Beschreibung:** Eine Hilfsfunktion zur einfacheren Erstellung von `gio::ActionEntry`-Strukturen, die für `add_action_entries` verwendet werden können. Dies ist besonders nützlich für zustandsbehaftete Aktionen oder Aktionen mit Parametern.12
    - **Implementierungslogik:**
        
        1. Erstelle eine `gio::SimpleAction` mit `gio::SimpleAction::new_stateful(name, parameter_type, state.unwrap_or_else(Variant::unit))`.
        2. Verbinde die `activate_callback` mit dem `activate`-Signal der `SimpleAction`.
        3. Erstelle eine `gio::ActionEntry` manuell, die diese `SimpleAction` repräsentiert, oder passe die Logik an, um `ActionEntry::builder()` zu verwenden, was oft direkter ist.
            
            Rust
            
            ```
            // Verwendung von ActionEntry::builder ist oft prägnanter:
            // ActionEntry::builder(name)
            //    .parameter_type(parameter_type.cloned())
            //    .state(state.cloned())
            //    .activate(move |obj, action_ref, param_variant| {
            //         // Die activate_callback müsste hier aufgerufen werden.
            //         // Die Signatur von activate_callback (Fn(&SimpleAction,...)) passt nicht direkt
            //         // zur Signatur von ActionEntry::activate (Fn(&TargetType, &SimpleAction,...)).
            //         // Es ist einfacher, SimpleActions zu erstellen und sie mit.add_action() hinzuzufügen.
            //         // Diese Hilfsmethode ist daher komplexer als nötig, wenn ActionEntry das Ziel ist.
            //     })
            //    .build()
            // Stattdessen sollte diese Methode vielleicht direkt eine konfigurierte SimpleAction zurückgeben,
            // die dann mit add_action registriert wird.
            // Wenn das Ziel eine ActionEntry ist, muss die Callback-Struktur angepasst werden.
            ```
            
        
        Die gtk-rs Dokumentation 12 zeigt, dass `ActionEntry::builder()` einen `activate`-Callback erwartet, der das Zielobjekt (App oder Window), die Aktion selbst und den Parameter erhält. Die `create_action_entry` Methode müsste entweder eine `SimpleAction` zurückgeben, die dann manuell hinzugefügt wird, oder die `activate_callback` müsste so angepasst werden, dass sie mit der Signatur von `ActionEntry` kompatibel ist. Für die direkte Verwendung mit `add_action_entries` ist `ActionEntry::builder()` der bevorzugte Weg.

##### 2.4.6. Signale

- **Emittierte Signale:**
    - **Signal Name:** `action-activated`
        - **GObject Name:** `action-activated`
        - **Parameter:**
            - `action_name`: `String` (Rust), `glib::VariantType::STRING` – Der Name der Aktion, die versucht wurde zu aktivieren.
            - `success`: `bool` (Rust), `glib::VariantType::BOOLEAN` – Gibt an, ob die Aktivierung erfolgreich war.
        - **Beschreibung:** Wird emittiert, nachdem versucht wurde, eine Aktion zu aktivieren.
        - **Definition in `ObjectImpl::signals()` (in `MasterActionHandlerImp`):**
            
            Rust
            
            ```
            // Bereits in imp.rs definiert
            // static SIGNALS: OnceCell<Vec<glib::subclass::Signal>> = OnceCell::new();
            // SIGNALS.get_or_init(|| {
            //     vec!)
            //            .build(),
            //     ]
            // })
            ```
            

##### 2.4.7. Datenstrukturen

Keine spezifischen öffentlichen Datenstrukturen, außer den intern verwendeten `HashMap` für fensterspezifische Aktionsgruppen.

##### 2.4.11. Abhängigkeiten

- `gtk::Application`, `gtk::ApplicationWindow`
- `gtk::gio` (insbesondere `Action`, `SimpleAction`, `ActionMap`, `SimpleActionGroup`, `ActionEntry`)
- `gtk::glib` (insbesondere `Variant`, `VariantTy`)

##### 2.4.12. Testplan

- **Unit-Tests:**
    - Teste `register_app_action`: Überprüfe, ob die Aktion korrekt zur `gtk::Application` hinzugefügt wird.
    - Teste `register_window_action`: Überprüfe, ob die Aktion korrekt zur `ActionGroup` des Fensters hinzugefügt wird.
    - Teste `activate_action`:
        - Aktivierung einer App-Aktion.
        - Aktivierung einer Fenster-Aktion (mit und ohne aktives Fenster).
        - Aktivierung einer nicht existierenden Aktion.
        - Korrekte Parameterübergabe.
        - Emission des `action-activated`-Signals mit korrekten Werten.
    - Teste `create_action_entry` (falls als Factory für `ActionEntry` implementiert): Korrekte Erstellung der `ActionEntry`.

#### 2.5. `SettingsService` (Service/Non-Widget GObject)

##### 2.5.1. Übersicht und Zweck

Der `SettingsService` dient als zentraler Zugriffspunkt für anwendungsspezifische Einstellungen, die persistent gespeichert werden. Er kapselt die Funktionalität von `gio::Settings` und stellt eine typsichere API zum Lesen, Schreiben und Überwachen von Einstellungen bereit. Dies ermöglicht eine saubere Trennung der Einstellungsverwaltung von anderen UI-Komponenten und erleichtert das Testen. Die Einstellungen werden typischerweise in einem GSchema XML-File definiert, das bei der Installation der Anwendung im System registriert wird.33

##### 2.5.2. Dateistruktur

- `src/app_shell/settings_service/mod.rs`: Öffentliches Modul und Wrapper-Definition.
- `src/app_shell/settings_service/imp.rs`: Private Implementierungsdetails und GObject-Subklassifizierung.
- `resources/schemas/org.example.myapp.gschema.xml`: GSettings-Schemadatei (Beispielname).

##### 2.5.3. GObject-Definition

- **Wrapper-Typ:**
    
    Rust
    
    ```
    // In src/app_shell/settings_service/mod.rs
    use gtk::glib;
    use gtk::gio;
    use gtk::subclass::prelude::*;
    
    glib::wrapper! {
        pub struct SettingsService(ObjectSubclass<imp::SettingsServiceImp>)
            @extends glib::Object;
    }
    
    impl SettingsService {
        pub fn new(schema_id: &str) -> Result<Self, glib::Error> {
            let service: Self = glib::Object::builder().build();
            service.imp().init_settings(schema_id)?;
            Ok(service)
        }
    
        // Wrapper für get_string, get_bool, etc.
        pub fn get_string(&self, key: &str) -> String {
            self.imp().settings.get().expect("Settings nicht initialisiert").string(key)
        }
        pub fn get_boolean(&self, key: &str) -> bool {
            self.imp().settings.get().expect("Settings nicht initialisiert").boolean(key)
        }
        pub fn get_int(&self, key: &str) -> i32 {
            self.imp().settings.get().expect("Settings nicht initialisiert").int(key)
        }
    
        // Wrapper für set_string, set_bool, etc.
        pub fn set_string(&self, key: &str, value: &str) -> Result<(), glib::Error> {
            self.imp().settings.get().expect("Settings nicht initialisiert").set_string(key, value)
        }
        pub fn set_boolean(&self, key: &str, value: bool) -> Result<(), glib::Error> {
            self.imp().settings.get().expect("Settings nicht initialisiert").set_boolean(key, value)
        }
        pub fn set_int(&self, key: &str, value: i32) -> Result<(), glib::Error> {
            self.imp().settings.get().expect("Settings nicht initialisiert").set_int(key, value)
        }
    
        pub fn bind_property<P: IsA<glib::Object>>(
            &self,
            key: &str,
            object: &P,
            property_name: &str,
            flags: gio::SettingsBindFlags,
        ) {
            self.imp().settings.get().expect("Settings nicht initialisiert").bind(key, object, property_name)
               .flags(flags)
               .build();
        }
    
        pub fn connect_changed<F: Fn(&Self, &str) + 'static + Clone>(
            &self,
            key: Option<&str>,
            callback: F,
        ) -> glib::SignalHandlerId {
            let self_clone = self.clone();
            self.imp().settings.get().expect("Settings nicht initialisiert").connect_changed(key, move |_, changed_key| {
                callback(&self_clone, changed_key);
                self_clone.emit_by_name::<()>("setting-changed", &[&changed_key]);
            })
        }
    }
    ```
    
- **Implementierungs-Struktur (`imp`):**
    
    Rust
    
    ```
    // In src/app_shell/settings_service/imp.rs
    use gtk::glib;
    use gtk::gio::{self, prelude::SettingsExtManual};
    use gtk::subclass::prelude::*;
    use std::cell::OnceCell;
    
    
    #
    pub struct SettingsServiceImp {
        settings: OnceCell<gio::Settings>,
    }
    
    #[glib::object_subclass]
    impl ObjectSubclass for SettingsServiceImp {
        const NAME: &'static str = "MySettingsService";
        type Type = super::SettingsService;
        type ParentType = glib::Object;
    }
    
    impl ObjectImpl for SettingsServiceImp {
        fn signals() -> &'static {
            static SIGNALS: OnceCell<Vec<glib::subclass::Signal>> = OnceCell::new();
            SIGNALS.get_or_init(|| {
                vec!) // key
                       .build(),
                ]
            })
        }
    }
    
    impl SettingsServiceImp {
        pub fn init_settings(&self, schema_id: &str) -> Result<(), glib::Error> {
            match gio::Settings::new(schema_id) {
                Ok(s) => {
                    self.settings.set(s).map_err(|_| glib::Error::new(glib::FileError::Failed, "Settings bereits initialisiert"))?;
                    Ok(())
                }
                Err(e) => Err(e),
            }
        }
    }
    ```
    
    Die `gio::Settings`-Instanz wird in `OnceCell` gespeichert, um sicherzustellen, dass sie nur einmal initialisiert wird. Die `init_settings`-Methode wird vom Wrapper `new` aufgerufen.
    
- **GSettings Schema (`org.example.myapp.gschema.xml`):**
    
    XML
    
    ```
    <schemalist>
      <schema id="org.example.myapp" path="/org/example/myapp/">
        <key name="window-width" type="i">
          <default>1024</default>
          <summary>Main window width</summary>
          <description>The last saved width of the main application window.</description>
        </key>
        <key name="window-height" type="i">
          <default>768</default>
          <summary>Main window height</summary>
          <description>The last saved height of the main application window.</description>
        </key>
        <key name="dark-mode" type="b">
          <default>false</default>
          <summary>Enable dark mode</summary>
          <description>Whether the application should use a dark theme variant.</description>
        </key>
        <key name="last-opened-file" type="s">
          <default>''</default>
          <summary>Last opened file</summary>
          <description>Path to the last successfully opened file.</description>
        </key>
        </schema>
    </schemalist>
    ```
    
    Diese Datei muss während des Build-Prozesses kompiliert (mit `glib-compile-schemas`) und an einem Ort installiert werden, an dem GSettings sie finden kann (z.B. `$XDG_DATA_DIRS/glib-2.0/schemas/`).33
    

##### 2.5.4. Eigenschaften

Keine öffentlich exponierten GObject-Eigenschaften für den `SettingsService` selbst. Die Einstellungen sind über die get/set-Methoden zugänglich.

##### 2.5.5. Methoden

- **`pub fn new(schema_id: &str) -> Result<Self, glib::Error>`** (bereits im Wrapper definiert)
    
    - **Nachbedingungen:** Der `SettingsService` ist initialisiert und hat das GSettings-Schema mit der gegebenen `schema_id` geladen. Gibt `Err` zurück, falls das Schema nicht geladen werden konnte.
- **`pub fn get_string(&self, key: &str) -> String`** (Wrapper für `gio::Settings::string`)
    
    - **Parameter:** `key: &str` – Der Schlüssel der Einstellung.
    - **Rückgabewert:** `String` – Der Wert der Einstellung.
    - **Vorbedingungen:** `key` muss im Schema als String-Typ definiert sein.
    - **Fehlerbehandlung:** Panik, wenn der Schlüssel nicht existiert oder einen anderen Typ hat.
- **`pub fn get_boolean(&self, key: &str) -> bool`** (Wrapper für `gio::Settings::boolean`)
    
    - **Parameter:** `key: &str` – Der Schlüssel der Einstellung.
    - **Rückgabewert:** `bool` – Der Wert der Einstellung.
    - **Vorbedingungen:** `key` muss im Schema als Boolean-Typ definiert sein.
- **`pub fn get_int(&self, key: &str) -> i32`** (Wrapper für `gio::Settings::int`)
    
    - **Parameter:** `key: &str` – Der Schlüssel der Einstellung.
    - **Rückgabewert:** `i32` – Der Wert der Einstellung.
    - **Vorbedingungen:** `key` muss im Schema als Integer-Typ definiert sein.
- **`pub fn set_string(&self, key: &str, value: &str) -> Result<(), glib::Error>`** (Wrapper für `gio::Settings::set_string`)
    
    - **Parameter:**
        - `key: &str` – Der Schlüssel der Einstellung.
        - `value: &str` – Der zu setzende Wert.
    - **Rückgabewert:** `Result<(), glib::Error>` – `Ok(())` bei Erfolg, sonst `Err`.
    - **Vorbedingungen:** `key` muss im Schema als String-Typ definiert sein.
- **`pub fn set_boolean(&self, key: &str, value: bool) -> Result<(), glib::Error>`** (Wrapper für `gio::Settings::set_boolean`)
    
- **`pub fn set_int(&self, key: &str, value: i32) -> Result<(), glib::Error>`** (Wrapper für `gio::Settings::set_int`)
    
- **`pub fn bind_property<W: IsA<glib::Object>>(&self, key: &str, object: &W, property_name: &str, flags: gio::SettingsBindFlags)`** (Wrapper für `gio::Settings::bind`)
    
    - **Parameter:**
        - `key: &str` – Der GSettings-Schlüssel.
        - `object: &W` – Das GObject, dessen Eigenschaft gebunden werden soll.
        - `property_name: &str` – Der Name der GObject-Eigenschaft.
        - `flags: gio::SettingsBindFlags` – Flags zur Steuerung der Bindung (z.B. `DEFAULT`, `BIDIRECTIONAL`).
    - **Nachbedingungen:** Die GObject-Eigenschaft ist an die GSetting gebunden. Änderungen werden synchronisiert gemäß den `flags`.33
- **`pub fn connect_changed<F: Fn(&Self, &str) + 'static + Clone>(&self, key: Option<&str>, callback: F) -> glib::SignalHandlerId`** (Wrapper für `gio::Settings::connect_changed`)
    
    - **Parameter:**
        - `key: Option<&str>` – Der zu überwachende Schlüssel. `None` für alle Schlüssel.
        - `callback: F` – Die Funktion, die bei Änderungen aufgerufen wird. Erhält den `SettingsService` und den geänderten Schlüssel als Parameter.
    - **Rückgabewert:** `glib::SignalHandlerId` – Zur möglichen Trennung der Verbindung.
    - **Nachbedingungen:** Die `callback`-Funktion wird aufgerufen, wenn sich der spezifizierte Schlüssel (oder ein beliebiger Schlüssel, falls `key` `None` ist) ändert. Das `setting-changed`-Signal des `SettingsService` wird ebenfalls emittiert.

##### 2.5.6. Signale

- **Emittierte Signale:**
    - **Signal Name:** `setting-changed`
        - **GObject Name:** `setting-changed`
        - **Parameter:**
            - `key`: `String` (Rust), `glib::VariantType::STRING` – Der Name des geänderten Schlüssels.
        - **Beschreibung:** Wird emittiert, nachdem sich eine Einstellung geändert hat. Dies ist ein Wrapper um das `changed`-Signal von `gio::Settings`.
        - **Definition in `ObjectImpl::signals()` (in `SettingsServiceImp`):**
            
            Rust
            
            ```
            // Bereits in imp.rs definiert
            // static SIGNALS: OnceCell<Vec<glib::subclass::Signal>> = OnceCell::new();
            // SIGNALS.get_or_init(|| {
            //     vec!)
            //            .build(),
            //     ]
            // })
            ```
            
- **Behandelte Signale:**
    - `gio::Settings::changed`: Intern verbunden, um das `setting-changed`-Signal des `SettingsService` auszulösen.

##### 2.5.7. Datenstrukturen

- **Tabelle: GSettings Schema (`org.example.myapp.gschema.xml`)**

|   |   |   |   |   |
|---|---|---|---|---|
|**Schlüsselname**|**GVariant Typ**|**Standardwert**|**Zusammenfassung**|**Beschreibung**|
|`window-width`|`i`|`1024`|Fensterbreite|Die zuletzt gespeicherte Breite des Hauptfensters.|
|`window-height`|`i`|`768`|Fensterhöhe|Die zuletzt gespeicherte Höhe des Hauptfensters.|
|`dark-mode`|`b`|`false`|Dunkelmodus aktivieren|Ob die Anwendung eine dunkle Theme-Variante verwenden soll.|
|`last-opened-file`|`s`|`''`|Zuletzt geöffnete Datei|Pfad zur zuletzt erfolgreich geöffneten Datei.|
|`sidebar-visible`|`b`|`true`|Seitenleiste sichtbar|Ob die Navigationsseitenleiste standardmäßig sichtbar ist.|
|`command-palette-hotkey`|`s`|`<Primary>P`|Hotkey Befehlspalette|Tastenkombination zum Öffnen der Befehlspalette.|

```
Diese Tabelle ist essentiell, da sie die persistenten Einstellungen der Anwendung definiert.
```

##### 2.5.11. Abhängigkeiten

- `gtk::gio` (insbesondere `Settings`, `SettingsBindFlags`)
- `gtk::glib`

##### 2.5.12. Testplan

- **Unit-Tests:**
    - Teste `new()`: Erfolgreiches Laden eines Test-Schemas, Fehlerbehandlung bei ungültigem Schema-ID.
    - Teste `get_` und `set_` Methoden für jeden Typ (String, bool, i32): Korrektes Lesen und Schreiben von Werten.
    - Teste `bind_property`: Bindung an eine Eigenschaft eines Mock-GObjects, Überprüfung der Synchronisation in beide Richtungen (falls `BIDIRECTIONAL`).
    - Teste `connect_changed`: Registrierung eines Callbacks, Überprüfung, ob der Callback und das `setting-changed`-Signal bei Wertänderungen ausgelöst werden.
- **Integrationstests:** (Erfordert eine Testumgebung, in der GSettings funktionieren)
    - Überprüfe, ob Änderungen an Einstellungen persistent sind nach Neustart der Test-Applikation.

#### 2.6. `NotificationService` (Service/Non-Widget GObject)

##### 2.6.1. Übersicht und Zweck

Der `NotificationService` ist verantwortlich für die Anzeige von Benachrichtigungen innerhalb der Applikation und optional für die Interaktion mit dem systemweiten Freedesktop-Benachrichtigungsdienst. Er unterscheidet zwischen In-App-Benachrichtigungen (z.B. als `gtk::Popover` 34 oder über `gtk4-layer-shell` 37 für benutzerdefinierte Popups) und Desktop-Benachrichtigungen. In-App-Benachrichtigungen bieten mehr Kontrolle über Aussehen und Verhalten im Kontext der Anwendung, während Desktop-Benachrichtigungen die Konsistenz mit der Desktop-Umgebung des Benutzers wahren.39

##### 2.6.2. Dateistruktur

- `src/app_shell/notification_service/mod.rs`: Öffentliches Modul und Wrapper-Definition.
- `src/app_shell/notification_service/imp.rs`: Private Implementierungsdetails.
- `src/app_shell/notification_service/desktop_notifier.rs`: (Optional) Modul für die Interaktion mit `org.freedesktop.Notifications` via D-Bus.

##### 2.6.3. GObject-Definition

- **Wrapper-Typ:**
    
    Rust
    
    ```
    // In src/app_shell/notification_service/mod.rs
    use gtk::glib;
    use gtk::gio; // für Cancellable
    use gtk::subclass::prelude::*;
    use gtk::{Widget, Popover}; // Für In-App Notifikationen
    use std::cell::RefCell;
    use std::collections::VecDeque;
    use zbus; // Für Desktop-Notifikationen
    
    // Enum für interne Verwendung im Service
    #
    pub enum NotificationLevel {
        Info,
        Warning,
        Error,
        Success, // Hinzugefügt für positive Rückmeldungen
    }
    
    #
    pub enum DesktopNotificationUrgency {
        Low,
        Normal,
        Critical,
    }
    
    glib::wrapper! {
        pub struct NotificationService(ObjectSubclass<imp::NotificationServiceImp>)
            @extends glib::Object;
    }
    
    impl NotificationService {
        pub fn new(app_name: String, app_icon: String) -> Self {
            let service: Self = glib::Object::builder().build();
            service.imp().init_desktop_notifier(app_name, app_icon);
            service
        }
    
        pub fn show_in_app_notification(
            &self,
            parent_widget: &impl IsA<Widget>,
            message: &str,
            level: NotificationLevel,
            autohide_ms: Option<u32>,
        ) {
            self.imp().show_in_app_notification(parent_widget, message, level, autohide_ms);
        }
    
        pub async fn show_desktop_notification(
            &self,
            summary: &str,
            body: &str,
            icon: Option<&str>,
            actions: Option<&[(&str, &str)]>, // Vec aus (action_key, display_name)
            urgency: Option<DesktopNotificationUrgency>,
            timeout_ms: Option<i32>, // Hinzugefügt für Timeout
        ) -> Result<u32, zbus::Error> {
            self.imp().show_desktop_notification(summary, body, icon, actions, urgency, timeout_ms).await
        }
    }
    ```
    
- **Implementierungs-Struktur (`imp`):**
    
    Rust
    
    ```
    // In src/app_shell/notification_service/imp.rs
    use gtk::glib;
    use gtk::gio;
    use gtk::prelude::*;
    use gtk::subclass::prelude::*;
    use gtk::{Widget, Popover, Box as GtkBox, Label, Image, Align, Orientation};
    use std::cell::RefCell;
    use std::collections::VecDeque;
    use zbus::Connection; // Für Desktop-Notifikationen
    use once_cell::sync::Lazy; // Für statische Connection
    
    use super::{NotificationLevel, DesktopNotificationUrgency}; // Importiere die Enums
    
    const DEFAULT_IN_APP_AUTOHIDE_MS: u32 = 5000; // 5 Sekunden
    
    // Statische D-Bus Verbindung für Desktop-Notifikationen
    static DBUS_CONNECTION: Lazy<Result<Connection, zbus::Error>> = Lazy::new(Connection::session);
    
    
    #
    pub struct NotificationServiceImp {
        active_popovers: RefCell<VecDeque<Popover>>, // Verwende VecDeque als einfache Queue
        app_name_for_desktop: RefCell<
    ```


# Implementierungsleitfaden UI-Schicht NovaDE: Modul 2 - `PanelWidget`

## 1. Einleitung und Zielsetzung

### 1.1. Zweck dieses Dokuments

Dieses Dokument stellt Teil 2 einer Serie von 8 bis 16 Modulspezifikationen für die Implementierung der Benutzeroberflächenschicht (UI-Schicht) der Linux-Desktop-Umgebung "NovaDE" dar. Es definiert die Ultra-Feinspezifikationen und hochdetaillierten Implementierungspläne für das Modul `PanelWidget`. Ziel ist es, einen lückenlosen Entwickler-Implementierungsleitfaden bereitzustellen, der so detailliert ist, dass Entwickler ihn direkt zur Implementierung verwenden können, ohne eigenständige Designentscheidungen treffen oder Kernlogiken und Algorithmen selbst entwerfen zu müssen. Alle relevanten Aspekte wurden recherchiert, entschieden und werden hier präzise spezifiziert.

### 1.2. Geltungsbereich: `PanelWidget` als Kernkomponente der `ui::shell`

Das `PanelWidget` ist eine zentrale Komponente innerhalb des `ui::shell`-Moduls von NovaDE. Es repräsentiert die Hauptkontroll- und Systemleiste(n) des Desktops. Dieses Dokument umfasst die vollständige Spezifikation des `PanelWidget`, einschließlich seiner internen Struktur, seiner öffentlichen Schnittstelle (Eigenschaften, Signale, Methoden), seines Verhaltens, seines Erscheinungsbilds (Layout und Theming) sowie seiner Interaktion mit anderen Modulen und Schichten von NovaDE. Die Spezifikationen für die einzelnen Elemente, die _innerhalb_ des Panels angezeigt werden (z.B. Uhr, System-Tray, AppMenu-Button), sind Gegenstand separater Moduldokumentationen; dieses Dokument definiert jedoch die Schnittstellen und Mechanismen für deren Integration in das `PanelWidget`.

### 1.3. Bezug zur Gesamtarchitektur von NovaDE

NovaDE basiert auf einer strengen Vier-Schichten-Architektur (Kern, Domäne, System, Benutzeroberfläche). Das `PanelWidget` ist integraler Bestandteil der **Benutzeroberflächenschicht**. Es interagiert mit:

- Anderen UI-Modulen innerhalb von `ui::shell` (z.B. `QuickSettingsPanelWidget`, `NotificationCenterPanelWidget`) und `ui::widgets`.
- Der **Domänenschicht**, insbesondere `domain::theming` für das Erscheinungsbild und `domain::global_settings_and_state_management` für Konfigurationen.
- Indirekt mit der **Systemschicht**, beispielsweise wenn im Panel gehostete Indikator-Widgets Daten von Systemdiensten (via D-Bus) anzeigen.

Die Implementierung des `PanelWidget` muss die in der "Technischen Gesamtspezifikation & Richtlinien" von NovaDE festgelegten Prinzipien der Modularität, losen Kopplung und hohen Kohäsion strikt einhalten.

## 2. Modul `ui::shell::panel_widget` - Spezifikation und Implementierungsplan

### 2.1. Verantwortlichkeiten und Features des `PanelWidget`

Das `PanelWidget` ist verantwortlich für:

- Die Bereitstellung einer horizontalen (oder potenziell vertikalen, obwohl initial nicht primär gefordert) Leiste am Bildschirmrand.
- Das Hosting und die Anordnung von verschiedenen UI-Elementen wie Anwendungsmenü-Button, Workspace-Indikator, Uhr, System-Tray, Schnelleinstellungs-Button, Benachrichtigungszentrum-Button sowie diversen Statusindikatoren (Netzwerk, Energie, Audio).
- Die Implementierung eines "eleganten Leisten-Designs mit optionalem Leuchtakzent", dessen Farbe sich dynamisch an das System-Theme anpasst.
- Die Konfigurierbarkeit hinsichtlich Position (z.B. oben, unten am Bildschirm) und Höhe.
- Die Reaktion auf Theme-Änderungen (Hell/Dunkel-Modus, Akzentfarben) aus `domain::theming`.

Es ist _nicht_ verantwortlich für die Implementierung der Logik der einzelnen gehosteten Elemente (z.B. das Anzeigen der Schnelleinstellungen selbst), sondern nur für deren Integration und die Bereitstellung der Auslöser (z.B. Buttons).

### 2.2. Dateistruktur und Modul-Setup

#### 2.2.1. Verzeichnisstruktur

Die empfohlene Verzeichnisstruktur für das `PanelWidget`-Modul innerhalb des `ui::shell`-Verzeichnisses ist wie folgt:

```
nova_de/
└── src/
    └── ui/
        └── shell/
            ├── panel_widget/
            │   ├── mod.rs         // Öffentliche API des PanelWidget, Wrapper-Definition
            │   ├── imp.rs         // Interne Implementierung (ObjectSubclass)
            │   ├── panel_widget.ui // GTK Composite Template UI-Definition
            │   ├── panel_widget.css // Modulspezifische CSS-Stile (optional)
            │   └── error.rs       // Modulspezifische Fehlerdefinitionen
            └──...                // Andere Shell-Module
```

Diese Struktur folgt etablierten Konventionen in der gtk-rs Community, wie sie beispielsweise in Dokumentationen und Beispielen zu finden sind.1 Eine solche Standardisierung fördert die Lesbarkeit und Wartbarkeit des Codes, da sich Entwickler, die mit GTK4 und Rust vertraut sind, schneller zurechtfinden. Die Trennung der öffentlichen API (`mod.rs`) von der internen `ObjectSubclass`-Implementierung (`imp.rs`) ist ein gängiges Muster, das die Einarbeitungszeit für neue Projektmitglieder reduziert.

#### 2.2.2. `Cargo.toml` Konfiguration

Die relevanten Abhängigkeiten für das `PanelWidget` und die UI-Schicht im Allgemeinen sind in der `Cargo.toml` des `nova_de_ui`-Crates (oder des entsprechenden Sub-Crates) zu deklarieren:

Ini, TOML

```
[dependencies]
gtk = { package = "gtk4", version = "0.8", features = ["v4_10"] } # Aktuellste stabile Version, v4_10 für PopoverMenuFlags, etc.
gdk = { package = "gdk4", version = "0.8" }
glib = { package = "glib", version = "0.19" } # Aktuellste stabile Version
gio = { package = "gio", version = "0.19" }
tokio = { version = "1", features = ["full"] } # Für asynchrone Operationen, falls benötigt
tracing = "0.1"
thiserror = "1.0"

# Workspace-interne Abhängigkeiten (Beispiele, genaue Pfade anpassen)
# nova_de_core = { path = "../../../core" }
# nova_de_domain_theming = { path = "../../../domain/theming" }
```

Die Spezifikation von Feature-Flags für GTK, wie z.B. `features = ["v4_10"]` 3, ist entscheidend, um Zugriff auf neuere API-Elemente zu erhalten. Diese können für bestimmte Funktionalitäten, wie erweiterte Optionen für `GtkPopoverMenu` 4 (relevant für im Panel getriggerte Elemente wie das Schnelleinstellungs-Panel), erforderlich sein. Eine frühzeitige Berücksichtigung stellt sicher, dass die notwendigen APIs verfügbar sind.

### 2.3. `PanelWidget`: Rust Struct-Definition und Initialisierung

#### 2.3.1. Definition des `PanelWidget` Structs (Verwendung von `gtk::glib::wrapper!`, `CompositeTemplate`)

Das `PanelWidget` wird als benutzerdefiniertes GTK-Widget implementiert. Die öffentliche Struktur wird in `panel_widget/mod.rs` definiert:

Rust

```
use gtk::glib;
use gtk::subclass::prelude::*;

glib::wrapper! {
    pub struct PanelWidget(ObjectSubclass<imp::PanelWidget>)
        @extends gtk::Widget, gtk::Box; // gtk::Box als Basis für einfaches Layout der Kinder
}

impl PanelWidget {
    pub fn new() -> Self {
        glib::Object::new(&) // Erzeugt eine neue Instanz des PanelWidget
    }
}

// Enum zur Definition der Panel-Position (Beispiel, kann auch globaler sein)
#
#
pub enum PanelPosition {
    #
    Top,
    #
    Bottom,
    // Ggf. Left, Right für vertikale Panels später
}

impl Default for PanelPosition {
    fn default() -> Self {
        PanelPosition::Top
    }
}

// Enum zur Definition der Bereiche für Kind-Widgets
#
pub enum PanelChildrenArea {
    Left,
    Center,
    Right,
}
```

Die Entscheidung, von `gtk::Box` abzuleiten, ermöglicht eine unkomplizierte Anordnung von Kind-Widgets in horizontalen oder vertikalen Segmenten (links, zentriert, rechts). Für die typische Struktur einer Panelleiste ist `gtk::Box` oft ausreichend und einfacher zu handhaben als beispielsweise `gtk::Grid`, welches für komplexere, gitterbasierte Layouts vorgesehen ist.

#### 2.3.2. Implementierung von `imp::PanelWidget` (`ObjectSubclass`, `WidgetImpl`, `BoxImpl` etc.)

Die interne Implementierung des `PanelWidget` erfolgt in `panel_widget/imp.rs`:

Rust

```
use gtk::glib::{self, subclass::InitializingObject, Cell, RefCell};
use gtk::subclass::prelude::*;
use gtk::{gio, gdk, CompositeTemplate, Box as GtkBox}; // GtkBox hier importieren für Klarheit

use super::PanelPosition; // PanelPosition aus mod.rs importieren

#
#[template(resource = "/org/nova_de/ui/shell/panel_widget.ui")] // Pfad zur.ui Datei
pub struct PanelWidget {
    #[template_child]
    pub(super) left_box: TemplateChild<GtkBox>,
    #[template_child]
    pub(super) center_box: TemplateChild<GtkBox>,
    #[template_child]
    pub(super) right_box: TemplateChild<GtkBox>,

    // Interne Zustandsvariablen für GObject-Properties
    #[property(get, set, explicit_notify)]
    position: Cell<PanelPosition>,
    #[property[10]] // Beispiel für Property-Attribute
    height_request_prop: Cell<i32>, // Name mit Suffix _prop zur Unterscheidung von Widget-Property
    #[property(get, set, explicit_notify)]
    auto_hide: Cell<bool>,
    #[property(get, set, explicit_notify)]
    show_glow_accent: Cell<bool>,
    #[property(get, /* no set from outside */ explicit_notify)]
    glow_accent_color_prop: RefCell<Option<gdk::RGBA>>,
    #[property(get, set, explicit_notify)] // Init-only wird in Setter-Logik behandelt
    monitor_index: Cell<i32>,

    // Weitere interne Zustandsvariablen
    // settings: RefCell<Option<gio::Settings>>, // Für GSettings
    // children_configs: RefCell<Vec<PanelChildConfig>>, // Für dynamische Kinder-Konfiguration
}

#[glib::object_subclass]
impl ObjectSubclass for PanelWidget {
    const NAME: &'static str = "NovaDEPanelWidget";
    type Type = super::PanelWidget;
    type ParentType = GtkBox; // Muss mit @extends oben übereinstimmen

    fn class_init(klass: &mut Self::Class) {
        klass.bind_template();
        // CSS laden, falls modulspezifisch vorhanden
        // Self::Type::load_css(); // Methode muss in PanelWidget (mod.rs) definiert werden

        // GObject Properties manuell installieren, wenn #[property] nicht alles abdeckt
        // oder man mehr Kontrolle braucht. Hier durch #[derive(Properties)] und #[property] abgedeckt.
        // Siehe 2.4.
    }

    fn instance_init(obj: &InitializingObject<Self>) {
        obj.init_template();
    }
}

impl ObjectImpl for PanelWidget {
    fn properties() -> &'static {
        // Diese Methode wird benötigt, wenn man Properties manuell definiert.
        // Mit #[derive(Properties)] und #[property(...)] wird dies oft automatisch generiert.
        // Hier explizit für Klarheit und falls Anpassungen nötig sind.
        use once_cell::sync::Lazy;
        static PROPERTIES: Lazy<Vec<glib::ParamSpec>> = Lazy::new(|| vec!);
        PROPERTIES.as_ref()
    }

    fn set_property(&self, _id: usize, value: &glib::Value, pspec: &glib::ParamSpec) {
        match pspec.name() {
            "position" => self.position.set(value.get().expect("Value must be of type PanelPosition")),
            "height-request" => self.height_request_prop.set(value.get().expect("Value must be of type i32")),
            "auto-hide" => self.auto_hide.set(value.get().expect("Value must be of type bool")),
            "show-glow-accent" => self.show_glow_accent.set(value.get().expect("Value must be of type bool")),
            // "glow-accent-color" ist nur lesbar, kein Setter von außen
            "monitor-index" => {
                // Hier könnte Logik für "Init-only" implementiert werden,
                // z.B. prüfen, ob das Widget bereits konstruiert ist.
                self.monitor_index.set(value.get().expect("Value must be of type i32"));
            }
            _ => unimplemented!(),
        }
        self.obj().notify_by_pspec(pspec); // Wichtig für explizites Notify
    }

    fn property(&self, _id: usize, pspec: &glib::ParamSpec) -> glib::Value {
        match pspec.name() {
            "position" => self.position.get().to_value(),
            "height-request" => self.height_request_prop.get().to_value(),
            "auto-hide" => self.auto_hide.get().to_value(),
            "show-glow-accent" => self.show_glow_accent.get().to_value(),
            "glow-accent-color" => self.glow_accent_color_prop.borrow().to_value(),
            "monitor-index" => self.monitor_index.get().to_value(),
            _ => unimplemented!(),
        }
    }

    fn constructed(&self) {
        self.parent_constructed(); // Wichtig: Aufruf der Methode der Elternklasse
        // Initialisierung nach Template-Initialisierung
        // z.B. Standard-Widgets hinzufügen, Signale verbinden, CSS laden
        let obj = self.obj();
        obj.set_property("height-request", self.height_request_prop.get()); // Initialen Wert setzen
        // Weitere Initialisierungen...
        // self.connect_theme_signals();
        // self.setup_default_children();
    }

    fn dispose(&self) {
        // Aufräumarbeiten, z.B. explizites Freigeben von Kind-Widgets
        // die nicht automatisch durch GTK verwaltet werden oder
        // um Referenzzyklen aufzulösen.
        while let Some(child) = self.obj().first_child() {
            child.unparent();
        }
    }
}

impl WidgetImpl for PanelWidget {} // Standardimplementierung oft ausreichend
impl BoxImpl for PanelWidget {}    // Standardimplementierung oft ausreichend
```

Die Verwendung von `#` und `#[template_child]` vereinfacht die Anbindung der im UI-File definierten Elemente an das Rust-Struct.1 Die `left_box`, `center_box` und `right_box` dienen als klar definierte Container für die typische Dreiteilung eines Panels, was das Layoutmanagement erheblich vereinfacht.

Die `dispose`-Methode spielt eine wichtige Rolle im Lebenszyklus von GTK4-Widgets. Für Container-Widgets wie das `PanelWidget`, die viele Kind-Widgets verwalten, ist eine sorgfältige Implementierung von `dispose` unerlässlich. GTK4 hat `gtk_widget_destroy()` für Nicht-Toplevel-Widgets entfernt und setzt stattdessen auf reguläres Referenzzählen.6 Die GTK-Dokumentation und Diskussionen legen nahe, dass benutzerdefinierte Container-Widgets in ihrer `dispose`-Methode `gtk_widget_unparent()` (oder das Äquivalent in den Bindings) für alle ihre Kinder aufrufen sollten.7 Dies hilft, Referenzzyklen zu durchbrechen und stellt sicher, dass Ressourcen korrekt freigegeben werden, insbesondere wenn Kind-Widgets komplexe interne Zustände oder eigene Referenzen halten.

#### 2.3.3. Interne Zustandsvariablen (private Felder)

Zusätzlich zu den über `#[template_child]` angebundenen UI-Elementen und den GObject-Properties (siehe 2.3.2 und 2.4) kann `PanelWidget` weitere interne Zustandsvariablen benötigen:

- `settings: RefCell<Option<gio::Settings>>`: Für den Zugriff auf GSettings, um Panel-spezifische Einstellungen (z.B. Auto-Hide-Verhalten, falls nicht über Property gesteuert) zu laden und zu beobachten.8
- `accent_color_cache: RefCell<Option<gdk::RGBA>>`: Ein interner Cache für die vom Theme bereitgestellte Akzentfarbe, um schnelle Aktualisierungen des "Leuchtakzents" zu ermöglichen. `glow_accent_color_prop` dient als GObject-Property-Spiegelung.
- `children_configs: RefCell<Vec<PanelChildConfig>>`: Potenziell eine Struktur, die die Konfiguration (Widget-Typ, Position, Reihenfolge) der dynamisch hinzugefügten Kind-Elemente speichert. Dies ist relevant, wenn das Panel hochgradig dynamisch konfigurierbar sein soll.

#### 2.3.4. Konstruktor (`fn new() -> Self`) und Initialisierungslogik (`constructed`, `class_init`, `instance_init`)

- `PanelWidget::new()`: Erstellt eine neue Instanz des `PanelWidget` über `glib::Object::new()`.
- `class_init()`: Wird einmal pro Klasse aufgerufen. Hier wird das Composite Template (`.ui`-Datei) mittels `klass.bind_template()` an die Klasse gebunden. Falls das Template Signal-Handler-Namen enthält, die auf Rust-Methoden gemappt werden sollen (Template Callbacks), muss hier auch `klass.bind_template_callbacks()` aufgerufen werden.2 Hier ist auch der Ort, um modulspezifisches CSS zu laden oder GObject-Properties und -Signale zu registrieren, falls dies nicht deklarativ über Makros geschieht.
- `instance_init()`: Wird für jede neue Instanz aufgerufen. Hier wird das Template für die spezifische Instanz mittels `obj.init_template()` initialisiert.2
- `constructed()`: Wird aufgerufen, nachdem das Objekt vollständig konstruiert und das Template für die Instanz initialisiert wurde. An dieser Stelle können:
    - Standard-Kind-Widgets (Platzhalter oder finale Widgets für AppMenu, Uhr etc.) programmatisch erstellt und in die `left_box`, `center_box`, `right_box` eingefügt werden.
    - Verbindungen zu Signalen der Domänenschicht (z.B. Theme-Änderungen von `domain::theming` via `gio::Settings` oder D-Bus) hergestellt werden.
    - Initialwerte für interne Zustände gesetzt und GObject-Properties initialisiert werden (z.B. die initiale Höhe des Panels).

Die konsequente Nutzung von Composite Templates wird in der gtk-rs Dokumentation 2 und Beispielen 1 stark betont und von GTK-Entwicklern empfohlen.9 Dieser Ansatz sollte als Standard für alle komplexeren Widgets in NovaDE etabliert werden, um Konsistenz zu fördern und die Einarbeitung zu erleichtern. Wenn das `PanelWidget` als eines der ersten komplexen UI-Module diesen Weg beschreitet, setzt es einen wichtigen Präzedenzfall.

### 2.4. `PanelWidget`: GObject-Eigenschaften (Properties)

GObject-Eigenschaften ermöglichen die Konfiguration des `PanelWidget` von außen, beispielsweise durch das `ui::control_center` oder programmatisch durch andere Teile der Anwendung. Sie werden üblicherweise mit dem `#[derive(Properties)]` Makro (nicht direkt in gtk-rs, aber `glib::Properties` ist das Äquivalent) und `#[property]` Attributen innerhalb der `imp::PanelWidget` Struktur definiert oder explizit über die `properties()`, `set_property()`, `property()` Methoden im `ObjectImpl` Trait implementiert.10

#### 2.4.1. Tabelle der definierten Eigenschaften

Die folgende Tabelle listet die für das `PanelWidget` definierten GObject-Eigenschaften auf.

**Tabelle 2.4.1: `PanelWidget` GObject-Eigenschaften**

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|**Eigenschaftsname (Rust / XML)**|**Rust-Datentyp (intern)**|**GObject-Typ (extern)**|**Lese-/Schreibzugriff**|**Standardwert**|**Beschreibung**|
|`position` / `position`|`Cell<PanelPosition>`|`NovaDEPanelPosition` (Enum)|R/W|`PanelPosition::Top`|Position des Panels auf dem Bildschirm (Oben, Unten). `PanelPosition` ist ein `glib::Enum`.|
|`height-request` / `height-request`|`Cell<i32>`|`gint`|R/W|`48`|Angeforderte Höhe des Panels in Pixeln. Min: 24, Max: 128.|
|`auto-hide` / `auto-hide`|`Cell<bool>`|`gboolean`|R/W|`false`|Ob das Panel automatisch versteckt werden soll. Die detaillierte Logik ist extern.|
|`show-glow-accent` / `show-glow-accent`|`Cell<bool>`|`gboolean`|R/W|`true`|Ob der "Leuchtakzent" angezeigt werden soll.|
|`glow-accent-color` / `glow-accent-color`|`RefCell<Option<gdk::RGBA>>`|`GdkRGBA*` (boxed)|R (intern W)|`None` (wird vom Theme abgeleitet)|Die Farbe des Leuchtakzents. Wird primär intern gesetzt basierend auf dem System-Theme.|
|`monitor-index` / `monitor-index`|`Cell<i32>`|`gint`|R/W (Init-only Logik)|`0` (Primärmonitor)|Index des Monitors, auf dem dieses Panel angezeigt wird. Minimum: 0.|

Diese Tabelle ist entscheidend für Entwickler, die das Panel verwenden oder konfigurieren (z.B. aus dem Control Center). Sie liefert alle notwendigen Informationen auf einen Blick: wie die Eigenschaft in Rust und XML heißt, welcher Datentyp erwartet wird, ob sie gelesen/geschrieben werden kann, was der Standard ist und was sie bewirkt. Dies ist essentiell für die korrekte Ansteuerung und das Verständnis des Widgets und dient als Checkliste während der Implementierung.

#### 2.4.2. Detaillierte Spezifikation jeder Eigenschaft

- `position`:
    - Verwendet den in `panel_widget/mod.rs` definierten `PanelPosition` Enum, der als `glib::Enum` registriert sein muss, um in GObject-Properties verwendet zu werden.
    - Der Setter sollte den Wert validieren. Bei einem ungültigen Wert (falls der Enum nicht korrekt übergeben wird) wird eine Warnung via `tracing::warn` ausgegeben und der Wert nicht geändert.
    - Eine Änderung der Position löst eine Neuzeichnung und potenziell eine Neupositionierung des Panels durch die übergeordnete Shell-Logik aus. Das Panel selbst passt seine CSS-Klassen an (z.B. `.panel-top`, `.panel-bottom`).
- `height-request`:
    - Der Setter validiert den übergebenen Wert gegen die definierten Min/Max-Grenzen (24-128 Pixel). Werte außerhalb dieses Bereichs führen zu einer Warnung und werden ggf. auf den nächstgelegenen gültigen Wert korrigiert oder ignoriert.
    - Eine Änderung dieser Eigenschaft führt dazu, dass das Widget eine neue Größenanforderung (`gtk_widget_queue_resize`) auslöst.
- `auto-hide`:
    - Diese Eigenschaft dient als reiner Schalter. Die komplexe Logik für das automatische Verstecken und Anzeigen (z.B. Reaktion auf Maus am Bildschirmrand, Überlappung mit maximierten Fenstern, Animationen) ist nicht Teil des `PanelWidget` selbst, sondern wird von einer dedizierten Policy oder einem Manager in der `ui::shell` gesteuert. Diese Trennung von Konfiguration (Eigenschaft) und Mechanismus (Logik) hält das `PanelWidget` fokussiert und modular.
- `show-glow-accent`:
    - Steuert die Sichtbarkeit des CSS-basierten Leuchtakzents. Bei Änderung wird eine CSS-Klasse (z.B. `glow-accent-visible`) am Widget gesetzt oder entfernt, was eine Neuzeichnung auslöst.
- `glow-accent-color`:
    - Diese Eigenschaft ist primär von außen lesbar. Intern wird sie aktualisiert, wenn sich die System-Akzentfarbe ändert. Das Panel muss hierfür auf entsprechende Signale von `domain::theming` (z.B. über `gio::Settings` oder einen D-Bus Service) hören. Eine Änderung dieser internen Property aktualisiert die CSS-Variable, die für den Akzentstil verwendet wird, oder eine spezifische CSS-Regel.
- `monitor-index`:
    - Diese Eigenschaft sollte idealerweise nur bei der Initialisierung des Panels gesetzt werden. Eine spätere Änderung ist komplex, da sie eine vollständige Neuinitialisierung des Panels auf einem anderen Monitor bedeuten würde. Der Setter kann eine Warnung ausgeben, wenn versucht wird, den Wert nach der `constructed`-Phase zu ändern.

Die Verwendung eines spezifischen Enum-Typs (`PanelPosition`) anstelle von einfachen Strings oder Integern für die Position ist robuster und typsicherer, was durch `glib::ParamSpecEnum` unterstützt wird. Dies verhindert ungültige Werte und macht den Code selbstdokumentierender.

### 2.5. `PanelWidget`: Signale

Signale werden vom `PanelWidget` emittiert, um andere Teile der Anwendung über Zustandsänderungen oder spezifische Benutzerinteraktionen innerhalb des Panels zu informieren. Sie werden typischerweise im `ObjectImpl`-Block mit dem `#[signal]`-Attribut (oder durch manuelle Registrierung in `class_init`) definiert.8

#### 2.5.1. Tabelle der definierten Signale

**Tabelle 2.5.1: `PanelWidget` Signale**

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|**Signalname (Rust / XML)**|**Parameter (Name, Typ)**|**Beschreibung**|**Typische Publisher**|**Typische Subscriber**|**Emissionsbedingungen**|
|`quick-settings-toggled` / `quick-settings-toggled`|`is_open: bool`|Informiert darüber, dass der Schnelleinstellungs-Button betätigt wurde und der gewünschte neue Zustand des Popups.|`PanelWidget` (intern, bei Klick auf den entsprechenden Button)|`ui::shell` Logik oder `QuickSettingsPanelWidget` direkt|Klick auf den Schnelleinstellungs-Button im Panel.|
|`notification-center-toggled` / `notification-center-toggled`|`is_open: bool`|Informiert darüber, dass der Benachrichtigungszentrum-Button betätigt wurde und der gewünschte neue Zustand des Popups.|`PanelWidget` (intern, bei Klick auf den entsprechenden Button)|`ui::shell` Logik oder `NotificationCenterPanelWidget` direkt|Klick auf den Benachrichtigungszentrum-Button im Panel.|
|`app-menu-toggled` / `app-menu-toggled`|`is_open: bool`|Informiert darüber, dass der AppMenu-Button betätigt wurde und der gewünschte neue Zustand des Menüs.|`PanelWidget` (intern, bei Klick auf den entsprechenden Button)|`ui::shell` (AppMenu-Logik)|Klick auf den AppMenu-Button im Panel.|

Diese Tabelle ist entscheidend für Entwickler, die auf Ereignisse innerhalb des Panels reagieren müssen. Sie listet klar auf, welche Signale existieren, welche Daten sie mitliefern und unter welchen Umständen sie ausgelöst werden. Dies ermöglicht es anderen Modulen, sich korrekt mit dem Panel zu integrieren.

#### 2.5.2. Detaillierte Spezifikation jedes Signals

- `quick-settings-toggled (is_open: bool)`:
    - Wird emittiert, wenn der Benutzer auf den Button zum Öffnen/Schließen der Schnelleinstellungen im Panel klickt.
    - Der Parameter `is_open` signalisiert den _gewünschten_ Zustand des Schnelleinstellungs-Popups (true für öffnen, false für schließen). Die Logik, die auf dieses Signal hört, ist dafür verantwortlich, den tatsächlichen Zustand des Popups entsprechend zu ändern.
- `notification-center-toggled (is_open: bool)`:
    - Analog zu `quick-settings-toggled`, jedoch für das Benachrichtigungszentrum.
- `app-menu-toggled (is_open: bool)`:
    - Analog zu `quick-settings-toggled`, jedoch für das Hauptanwendungsmenü.

Das ursprünglich in der Grobplanung erwogene Signal `child-widget-requested` wird nicht implementiert. Widgets sollten typischerweise nicht ihre eigenen Kinder "anfordern", sondern diese entweder intern erstellen oder von einer übergeordneten Instanz hinzugefügt bekommen. Die Verantwortung für die Komposition der Shell-Elemente und das Bestücken des Panels liegt bei der `ui::shell`-Logik, nicht beim Panel selbst. Dies vermeidet eine Umkehrung des Kontrollflusses und potenzielle schwer nachvollziehbare Abhängigkeiten.

Die hier definierten `*-toggled`-Signale sind ein exzellentes Beispiel für lose Kopplung. Das `PanelWidget` muss nicht wissen, wie das Schnelleinstellungs-Panel (`QuickSettingsPanelWidget`) implementiert ist oder wo es sich befindet. Es signalisiert lediglich die Absicht des Benutzers, dieses zu öffnen oder zu schließen. Die übergeordnete Shell-Logik oder das `QuickSettingsPanelWidget` selbst kann auf dieses Signal reagieren. Diese ereignisbasierte Kommunikation erhöht die Modularität, Flexibilität und Testbarkeit des Gesamtsystems erheblich.

### 2.6. `PanelWidget`: Methoden (Öffentliche API und interne Logik)

Die Methoden des `PanelWidget` definieren seine programmatische Schnittstelle und interne Hilfsfunktionen.

#### 2.6.1. Öffentliche Methoden

Diese Methoden bilden die öffentliche API des `PanelWidget` und werden in `panel_widget/mod.rs` innerhalb des `impl PanelWidget`-Blocks definiert.

**Tabelle 2.6.1: `PanelWidget` Öffentliche API-Methoden**

|   |   |   |   |   |
|---|---|---|---|---|
|**Methodensignatur (Rust)**|**Beschreibung**|**Vorbedingungen**|**Nachbedingungen**|**Ausgelöste Fehler (Typ $PanelWidgetError$)**|
|`pub fn new() -> Self`|Konstruktor. Erstellt eine neue Instanz des `PanelWidget`.|GTK-Umgebung ist initialisiert.|Eine gültige, initialisierte `PanelWidget`-Instanz wird zurückgegeben.|-|
|`pub fn add_child_widget(&self, child: &impl IsA<gtk::Widget>, area: PanelChildrenArea, order: i32)`|Fügt ein Kind-Widget einem bestimmten Bereich (`Left`, `Center`, `Right`) des Panels hinzu. `order` dient als Sortierhinweis.|`child` ist ein gültiges `gtk::Widget`. `area` ist ein gültiger `PanelChildrenArea`-Wert.|`child` wird dem spezifizierten Bereich des Panels hinzugefügt und ist sichtbar (wenn das Panel sichtbar ist).|`ChildWidgetAddFailed` (z.B. wenn `child` bereits ein Parent hat)|
|`pub fn remove_child_widget(&self, child: &impl IsA<gtk::Widget>) -> Result<(), PanelWidgetError>`|Entfernt ein spezifisches Kind-Widget aus dem Panel.|`child` ist ein aktuelles Kind-Widget des Panels.|`child` wird aus dem Panel entfernt und dessen Parent-Beziehung aufgelöst.|`ChildWidgetRemoveFailed` (z.B. wenn `child` nicht gefunden wird)|
|`pub fn update_theme_dependent_elements(&self, accent_color: &gdk::RGBA, theme_name: &str)`|Aktualisiert UI-Elemente, die vom Theme abhängen (insbesondere den Leuchtakzent und Hell/Dunkel-Modus Anpassungen).|`accent_color` ist gültig. `theme_name` gibt das aktuelle GTK-Theme an.|Leuchtakzent und andere themenabhängige Stile werden entsprechend der neuen Akzentfarbe und des Themes aktualisiert.|-|

Die Tabelle der öffentlichen API-Methoden dient als "Vertragsdokument" für andere Teile der UI-Schicht, die mit dem Panel interagieren. Sie definiert klar die unterstützten Operationen, deren Verhalten und Parameter.

#### 2.6.2. Interne Hilfsmethoden

Diese Methoden sind nicht Teil der öffentlichen API und dienen der internen Strukturierung und Logik. Sie werden typischerweise in `panel_widget/imp.rs` definiert oder als private Methoden in `panel_widget/mod.rs`.

**Tabelle 2.6.2: `PanelWidget` Interne Hilfsmethoden**

|   |   |   |
|---|---|---|
|**Methodensignatur (Rust) (Beispielhaft)**|**Beschreibung**|**Kontext der Verwendung**|
|`fn setup_initial_state(obj: &super::PanelWidget)`|Setzt initiale Property-Werte und verbindet notwendige Signale nach der Konstruktion.|Aufgerufen am Ende von `ObjectImpl::constructed()` für `imp::PanelWidget`.|
|`fn load_specific_css(obj: &super::PanelWidget)`|Lädt die `panel_widget.css` Datei (falls vorhanden) und wendet sie auf das Widget an.|Aufgerufen in `ObjectImpl::constructed()` oder `class_init`.|
|`fn update_glow_accent_style(obj: &super::PanelWidget, color: Option<&gdk::RGBA>, position: PanelPosition)`|Aktualisiert dynamisch die CSS-Klasse oder Inline-Stile für den Leuchtakzent.|Aufgerufen von `update_theme_dependent_elements` oder bei Änderung der `show-glow-accent` Eigenschaft.|
|`fn connect_theme_signals(obj: &super::PanelWidget)`|Verbindet mit Signalen von `domain::theming` (z.B. `gio::Settings` für `gtk-theme-name` und `color-scheme`) um Theme-Änderungen zu empfangen.|Aufgerufen in `setup_initial_state` oder `constructed`.|
|`fn get_target_box(obj: &super::PanelWidget, area: PanelChildrenArea) -> GtkBox`|Gibt eine geklonte Referenz auf die `left_box`, `center_box` oder `right_box` zurück.|Von `add_child_widget`.|

Interne Hilfsmethoden verbessern die Organisation und Wartbarkeit des Panel-Codes, indem sie wiederverwendbare Logik kapseln.

#### 2.6.3. Detaillierte Schritt-für-Schritt Implementierungslogik für ausgewählte Methoden

- `PanelWidget::add_child_widget(&self, child: &impl IsA<gtk::Widget>, area: PanelChildrenArea, order: i32)`:
    
    1. Ermittle das `imp::PanelWidget`-Objekt (interner Zustand) aus `self`.
    2. Rufe `get_target_box(area)` auf, um den Ziel-`gtk::Box` Container (`left_box`, `center_box` oder `right_box`) zu erhalten. Diese Boxen sind `TemplateChild<GtkBox>`.
    3. Prüfe, ob `child` bereits einen Parent hat. Wenn ja, und dieser Parent nicht das `PanelWidget` selbst ist, gib `$Result::Err(PanelWidgetError::ChildWidgetAddFailed("Widget already has a parent".into()))$` zurück.
    4. Setze eine benutzerdefinierte Eigenschaft oder ein `qdata`-Feld auf dem `child` mit dem Wert `order`. Dies ist optional und dient dazu, die Sortierreihenfolge zu speichern, falls eine dynamische Neusortierung implementiert wird. GTK `Box` selbst sortiert Kinder nicht dynamisch basierend auf einer Property; die Reihenfolge wird durch `append`, `prepend` oder `reorder_child` bestimmt.
    5. Füge `child` dem Ziel-`gtk::Box` hinzu: `target_box.append(child);`.
    6. Falls eine explizite Sortierung basierend auf `order` erforderlich ist und nicht durch die Reihenfolge des Hinzufügens gewährleistet wird:
        - Iteriere über die Kinder der `target_box`.
        - Entferne `child` temporär.
        - Finde die korrekte Einfügeposition basierend auf den `order`-Werten der anderen Kinder.
        - Füge `child` an der korrekten Position wieder ein (`target_box.insert_child_after(child, Option<previous_sibling>)` oder `target_box.reorder_child(child, new_index)`).
        - **Entscheidung für die Erstimplementierung:** Die Sortierung erfolgt primär durch die Wahl der `PanelChildrenArea` und die Reihenfolge, in der Widgets hinzugefügt werden. Die `order`-Eigenschaft dient als Vorbereitung für eventuell komplexere, zukünftige Sortieranforderungen.
    7. Gib `$Result::Ok(())$` zurück.
- `PanelWidget::update_theme_dependent_elements(&self, accent_color: &gdk::RGBA, theme_name: &str)`:
    
    1. Ermittle das `imp::PanelWidget`-Objekt.
    2. Aktualisiere die interne `glow_accent_color_prop` Property: `imp.glow_accent_color_prop.replace(Some(accent_color.clone()));`. Emittiere `notify::glow-accent-color`.
    3. Rufe `update_glow_accent_style(self, Some(accent_color), self.position())` auf.
    4. Passe ggf. CSS-Klassen für Hell/Dunkel-Modus an, basierend auf `theme_name` (z.B. wenn das Panel spezifische Stile für Dark-Mode hat, die nicht global greifen). Dies geschieht meist automatisch durch das GTK-Theming-System, aber manuelle Anpassungen sind hier möglich.
        
        Rust
        
        ```
        // In panel_widget/mod.rs
        //...
        // fn update_glow_accent_style(&self, color: Option<&gdk::RGBA>, position: PanelPosition) {
        //     let style_context = self.style_context();
        //     style_context.remove_class("glow-accent-visible"); // Alte Klasse entfernen
        //
        //     if self.show_glow_accent() && color.is_some() {
        //         style_context.add_class("glow-accent-visible");
        //
        //         // Dynamisches Setzen einer CSS-Variable für die Akzentfarbe
        //         // Dies ist der bevorzugte Weg, um Farben an CSS zu übergeben.
        //         let c = color.unwrap();
        //         let css_color = format!("rgba({},{},{},{})",
        //                                (c.red() * 255.0) as u8,
        //                                (c.green() * 255.0) as u8,
        //                                (c.blue() * 255.0) as u8,
        //                                c.alpha());
        //
        //         let provider = gtk::CssProvider::new();
        //         let css_data = format!(
        //             ".nova-panel-widget.glow-accent-visible {{ --nova-panel-glow-color: {}; }}",
        //             css_color
        //         );
        //         provider.load_from_data(&css_data);
        //
        //         // Provider mit hoher Priorität hinzufügen, um globale Theme-Variablen zu überschreiben,
        //         // oder besser: Theme stellt --nova-accent-color bereit und CSS nutzt diese.
        //         // Hier wird angenommen, dass das Panel seine eigene Akzentfarbe setzt.
        //         gtk::StyleContext::add_provider_for_display(
        //             &self.display(),
        //             &provider,
        //             gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
        //         );
        //
        //         // Panel-spezifische Klassen für Position (oben/unten)
        //         style_context.remove_class("panel-top");
        //         style_context.remove_class("panel-bottom");
        //         match position {
        //             PanelPosition::Top => style_context.add_class("panel-top"),
        //             PanelPosition::Bottom => style_context.add_class("panel-bottom"),
        //         }
        //     }
        // }
        ```
        
        Die bevorzugte Methode zur Anwendung der Akzentfarbe ist jedoch die Verwendung von CSS-Variablen, die vom globalen Theme bereitgestellt werden.12 Das `PanelWidget` würde dann nur eine Klasse wie `glow-accent-visible` setzen, und die Farbe käme automatisch vom Theme (`var(--nova-accent-color)` im CSS). Die obige `update_glow_accent_style` Methode sollte sich darauf konzentrieren, die notwendigen CSS-Klassen zu setzen und sicherzustellen, dass das Widget neu gezeichnet wird. Die direkte Manipulation von CSS-Providern für Farbwerte sollte vermieden werden, wenn das Theming-System dies global handhaben kann.

Die Methoden `add_child_widget` und `remove_child_widget` sind entscheidend für die Flexibilität des Panels. NovaDE könnte es Nutzern erlauben, Panel-Elemente zur Laufzeit anzupassen, oder verschiedene Profile könnten unterschiedliche Elementkombinationen laden. Die Methode `update_theme_dependent_elements` ist kritisch für die Einhaltung des visuellen Stils von NovaDE, insbesondere für den "Leuchtakzent", und muss bei jeder relevanten Theme-Änderung aufgerufen werden.

### 2.7. `PanelWidget`: UI-Layout und Theming (GTK4 Composite Template & CSS)

Das Layout und das grundlegende Erscheinungsbild des `PanelWidget` werden durch eine GTK4 Composite Template UI-Datei (`.ui`) und zugehörige CSS-Regeln definiert.

#### 2.7.1. Struktur der `panel_widget.ui` Datei

Die UI-Definition basiert auf `GtkBox` als Wurzel-Template-Klasse. Die Datei befindet sich unter `resources/ui/shell/panel_widget.ui` (oder einem ähnlichen Pfad, der über `gio::resources_register_include!` im Build-Skript eingebunden wird) und wird im Code mit `@template(resource = "/org/nova_de/ui/shell/panel_widget.ui")` referenziert.

XML

```
<?xml version="1.0" encoding="UTF-8"?>
<interface domain="nova-de"> <template class="NovaDEPanelWidget" parent="GtkBox">
    <property name="orientation">horizontal</property>
    <property name="css_classes">nova-panel-widget</property>
    <child>
      <object class="GtkBox" id="left_box">
        <property name="orientation">horizontal</property>
        <property name="halign">start</property>
        <property name="hexpand">true</property> <property name="css_classes">panel-area panel-left-area</property>
        <style>
          <class name="spacing-small"/> </style>
      </object>
    </child>
    <child>
      <object class="GtkBox" id="center_box">
        <property name="orientation">horizontal</property>
        <property name="halign">center</property>
        <property name="hexpand">false</property> <property name="css_classes">panel-area panel-center-area</property>
        <style>
          <class name="spacing-small"/>
        </style>
      </object>
    </child>
    <child>
      <object class="GtkBox" id="right_box">
        <property name="orientation">horizontal</property>
        <property name="halign">end</property>
        <property name="hexpand">true</property> <property name="css_classes">panel-area panel-right-area</property>
        <style>
          <class name="spacing-small"/>
        </style>
      </object>
    </child>
  </template>
</interface>
```

Die `hexpand`-Eigenschaften sind so konfiguriert, dass die `center_box` zentriert bleibt, während `left_box` und `right_box` den verfügbaren Raum dynamisch aufteilen. Die Klasse `spacing-small` (oder ähnlich) könnte im globalen CSS definiert sein, um konsistente Abstände zwischen den Panel-Elementen zu gewährleisten.

**Tabelle 2.7.1: `PanelWidget.ui` Kind-Widget-IDs und Typen (Primärcontainer)**

|   |   |   |
|---|---|---|
|**ID (#[template_child])**|**GTK-Widget-Typ**|**Zweck**|
|`left_box`|`GtkBox`|Container für linksbündige Panel-Elemente (z.B. AppMenu, WorkspaceSwitcher).|
|`center_box`|`GtkBox`|Container für zentrierte Panel-Elemente (z.B. Uhr).|
|`right_box`|`GtkBox`|Container für rechtsbündige Panel-Elemente (z.B. Tray, Indikatoren).|

Die deklarative Natur der `.ui`-Datei 2 erlaubt eine visuell nachvollziehbare Definition der Panel-Grundstruktur. Layout-Änderungen können oft direkt im XML erfolgen, ohne Rust-Code anpassen zu müssen.9 Dies beschleunigt die UI-Entwicklung. Die Tabelle 2.7.1 dokumentiert die Brücke zwischen XML-Deklaration und Rust-Code (`#[template_child]`).

#### 2.7.2. CSS-Klassen und -IDs für das `PanelWidget` und seine primären Elemente

Für das Styling werden CSS-Klassen verwendet. IDs sollten primär für die `#[template_child]`-Anbindung genutzt werden und im CSS nur sparsam, um die Spezifität niedrig zu halten.14

**Tabelle 2.7.2: `PanelWidget` CSS-Klassen**

|   |   |   |
|---|---|---|
|**CSS-Klasse**|**Anwendungsbereich**|**Beschreibung**|
|`nova-panel-widget`|Das Haupt-Widget des Panels (`NovaDEPanelWidget`)|Basis-Styling für das Panel (Hintergrund, Padding, Schrift etc.).|
|`panel-top`|`nova-panel-widget` (wenn Position oben)|Spezifische Stile für ein oben positioniertes Panel (z.B. unterer Rand/Schatten für Leuchtakzent).|
|`panel-bottom`|`nova-panel-widget` (wenn Position unten)|Spezifische Stile für ein unten positioniertes Panel (z.B. oberer Rand/Schatten für Leuchtakzent).|
|`panel-area`|`left_box`, `center_box`, `right_box`|Gemeinsames Styling für die Hauptbereiche (z.B. vertikales Padding).|
|`panel-left-area`|`left_box`|Spezifisches Styling für den linken Bereich.|
|`panel-center-area`|`center_box`|Spezifisches Styling für den mittleren Bereich.|
|`panel-right-area`|`right_box`|Spezifisches Styling für den rechten Bereich.|
|`glow-accent-visible`|`nova-panel-widget`|Wird dynamisch via Code gesetzt, um den Leuchtakzent sichtbar zu machen. Das CSS definiert dann den eigentlichen Stil.|
|`panel-child-item`|Alle direkten Kinder in `left/center/right_box`|Einheitliches Styling für Panel-Elemente (z.B. Margins, Paddings, vertikale Ausrichtung).|
|`spacing-small` / `spacing-medium`|`GtkBox` Container oder einzelne Elemente|Definiert Standardabstände (z.B. `column-spacing` für Boxen, `margin` für Items).|

Diese CSS-Klassen (Tabelle 2.7.2) sind unverzichtbar für Theme-Entwickler und UI-Designer, die das Aussehen des Panels anpassen wollen, da sie die "Haken" für das CSS-Styling bereitstellen.

#### 2.7.3. Anwendung von Design-Tokens (`domain::theming`) via `GtkCssProvider`

Das globale NovaDE-Theme, definiert in domain::theming, stellt Design-Tokens als CSS-Variablen bereit (z.B. --nova-accent-color, --nova-panel-background, --nova-text-color). Diese werden über GtkSettings:gtk-theme-name und GtkStyleContext::add_provider_for_display systemweit geladen.12

Das PanelWidget und sein spezifisches panel_widget.css (falls vorhanden) nutzen diese vordefinierten CSS-Variablen.

Beispielhafte Verwendung in `panel_widget.css` oder im globalen Theme:

CSS

```
.nova-panel-widget {
    background-color: var(--nova-panel-background, #23272e); /* Fallback-Farbe */
    color: var(--nova-fg-color, white);
    padding: 0 6px; /* Globales horizontales Padding für das Panel */
    min-height: 24px; /* Mindesthöhe sicherstellen */
}

.panel-area >.panel-child-item { /* Styling für Elemente direkt in den Bereichen */
    padding: 4px 6px; /* Vertikales und horizontales Padding für jedes Element */
    margin: 0 2px;    /* Kleiner horizontaler Abstand zwischen Elementen */
}

.nova-panel-widget.panel-top.glow-accent-visible {
    border-bottom: 2px solid var(--nova-accent-color, #5294e2); /* Standard-Akzentfarbe als Fallback */
    box-shadow: 0px 2px 5px 0px alpha(var(--nova-accent-color, #5294e2), 0.3);
}

.nova-panel-widget.panel-bottom.glow-accent-visible {
    border-top: 2px solid var(--nova-accent-color, #5294e2);
    box-shadow: 0px -2px 5px 0px alpha(var(--nova-accent-color, #5294e2), 0.3);
}

/* Beispiel für Abstands-Klassen, die im.ui File verwendet werden könnten */
.spacing-small > * { /* Gilt für direkte Kinder einer Box mit.spacing-small */
    margin-left: 4px;
    margin-right: 4px;
}
.spacing-small > *:first-child {
    margin-left: 0;
}
.spacing-small > *:last-child {
    margin-right: 0;
}
```

Die konsequente Nutzung von CSS-Variablen 15 ist der Schlüssel zur Erfüllung der Anforderungen an Anpassbarkeit und dynamische Theme-Wechsel. Das `PanelWidget` wird so zu einem integralen Bestandteil des visuell konsistenten NovaDE-Ökosystems.

#### 2.7.4. Spezifikation des "optionalen Leuchtakzents"

Der Leuchtakzent ist ein Kernmerkmal des Panel-Designs und wird primär über CSS realisiert:

- Eine CSS-Klasse, z.B. `glow-accent-visible`, wird dem `NovaDEPanelWidget`-Wurzelelement dynamisch hinzugefügt oder entfernt, basierend auf dem Wert der GObject-Eigenschaft `show-glow-accent`.
- Zusätzliche Klassen wie `panel-top` oder `panel-bottom` (basierend auf der `position`-Eigenschaft) bestimmen, ob der Akzent als unterer oder oberer Rand/Schatten erscheint.
- Die Farbe des Akzents wird durch die CSS-Variable `--nova-accent-color` (oder eine spezifischere wie `--nova-panel-glow-color`, falls abweichend vom globalen Akzent gewünscht) gesteuert. Diese Variable wird vom Theming-System (`domain::theming`) bereitgestellt und bei Theme-Wechseln aktualisiert.
- Der Akzent selbst wird durch eine Kombination aus `border` (z.B. `border-bottom` oder `border-top`) und einem subtilen `box-shadow` in der Akzentfarbe implementiert, um einen "Leucht"-Effekt zu erzeugen.
- Die genaue visuelle Ausprägung (Dicke des Borders, Farbe, Weichzeichnung und Ausdehnung des Schattens) wird in der CSS-Datei des Themes oder in einer spezifischen `panel_widget.css` definiert, die die Theme-Variablen nutzt.

Dieser Ansatz der Trennung von Struktur (UI-XML), Stil (CSS) und Verhalten (Rust), gefördert durch GTK4 und Composite Templates 2, ist eine bewährte Methode zur Entwicklung wartbarer und flexibler Benutzeroberflächen.

### 2.8. `PanelWidget`: Integration von Sub-Modulen (Platzhalter-Schnittstellen)

Das `PanelWidget` dient als Container. Die eigentlichen funktionalen Elemente (AppMenu-Button, Uhr, Indikatoren etc.) sind eigenständige Widgets/Module, die separat spezifiziert werden. Das `PanelWidget` stellt lediglich die Mechanismen bereit, um diese Kind-Widgets aufzunehmen und anzuordnen.

Die Integration erfolgt über die öffentliche Methode `PanelWidget::add_child_widget(&self, child: &impl IsA<gtk::Widget>, area: PanelChildrenArea, order: i32)`. Die übergeordnete `ui::shell`-Logik ist dafür verantwortlich, Instanzen der Sub-Modul-Widgets zu erstellen und sie dem entsprechenden `PanelWidget` (potenziell eines pro Monitor) hinzuzufügen.

- **2.8.1. AppMenu-Integration:** Ein `AppMenuButtonWidget` (separat spezifiziert) wird erstellt und via `add_child_widget` der `PanelChildrenArea::Left` hinzugefügt. Dieser Button löst das `app-menu-toggled`-Signal aus.
- **2.8.2. Workspace-Indikator-Integration:** Ein `WorkspaceIndicatorWidget` (separat spezifiziert) wird erstellt und der `PanelChildrenArea::Left` (oder `Center`, je nach Designentscheidung) hinzugefügt.
- **2.8.3. Uhr-Integration:** Ein `ClockWidget` (separat spezifiziert) wird erstellt und der `PanelChildrenArea::Center` (oder `Right`) hinzugefügt.
- **2.8.4. System-Tray-Integration:** Ein `SystemTrayWidget` (separat spezifiziert, potenziell komplex aufgrund des `StatusNotifierItem`-Protokolls) wird erstellt und der `PanelChildrenArea::Right` hinzugefügt.
- **2.8.5. Schnelleinstellungen-Button-Integration:** Ein `QuickSettingsButtonWidget` (separat spezifiziert, könnte ein einfacher `gtk::Button` oder `gtk::MenuButton` sein) wird erstellt und der `PanelChildrenArea::Right` hinzugefügt. Dieser Button löst das `quick-settings-toggled`-Signal aus, woraufhin das `QuickSettingsPanelWidget` (ein Popover-Typ 16) angezeigt wird.
- **2.8.6. Benachrichtigungszentrum-Button-Integration:** Ein `NotificationCenterButtonWidget` (analog zum Schnelleinstellungen-Button) wird erstellt und der `PanelChildrenArea::Right` hinzugefügt. Dieser Button löst das `notification-center-toggled`-Signal aus.
- **2.8.7. Netzwerk-, Energie-, Audio-Indikator-Integration:** Jeder Indikator (z.B. `NetworkIndicatorWidget`, `PowerIndicatorWidget`, `AudioIndicatorWidget` – alle separat spezifiziert) wird als eigenständiges Widget erstellt und der `PanelChildrenArea::Right` hinzugefügt. Diese Widgets sind dafür verantwortlich, Daten von relevanten Systemdiensten (z.B. NetworkManager, UPower 18, PipeWire) über D-Bus 11 oder andere Mechanismen der System- oder Domänenschicht zu beziehen und darzustellen.

Die Entscheidung, Sub-Module als separate Widgets zu behandeln, die über eine generische `add_child_widget`-Methode integriert werden, ist ein starkes Bekenntnis zur Modularität. Es erzwingt, dass jedes dieser Sub-Module eine wohldefinierte `gtk::Widget`-Schnittstelle besitzt und keine versteckten Abhängigkeiten zum `PanelWidget` aufbaut. Das Panel bleibt ein reiner Container, und die funktionalen Elemente können unabhängig entwickelt, getestet und potenziell wiederverwendet werden. Viele der durch Panel-Buttons ausgelösten Interaktionen, wie das Anzeigen von Schnelleinstellungen oder Kalendern, werden typischerweise als `GtkPopover` oder `GtkPopoverMenu` implementiert.4 Das Panel selbst hostet nur die Auslöser (Buttons), nicht die Popovers; die Signale des Panels sind das Bindeglied.

### 2.9. `PanelWidget`: Fehlerbehandlung und Ausnahmeklassen

Eine robuste Fehlerbehandlung ist essentiell für die Stabilität der UI.

#### 2.9.1. Definition der `PanelWidgetError` Enum (via `thiserror`)

In `panel_widget/error.rs` wird eine spezifische Fehler-Enum für das `PanelWidget`-Modul definiert:

Rust

```
use thiserror::Error;

#
pub enum PanelWidgetError {
    #[error("Failed to add child widget to panel: {0}")]
    ChildWidgetAddFailed(String),

    #[error("Failed to remove child widget from panel: {0}")]
    ChildWidgetRemoveFailed(String),

    #[error("Invalid configuration provided for panel widget: {0}")]
    InvalidConfiguration(String),

    #[error("Failed to apply style to panel widget: {0}")]
    StylingError(String),
    // Weitere spezifische Fehlerarten nach Bedarf
}
```

Diese Enum, die `thiserror::Error` ableitet, ermöglicht eine klare und typisierte Fehlerkommunikation. Aufrufer können spezifisch auf Fehler reagieren.

#### 2.9.2. Fehlerbehandlungsstrategien innerhalb des Moduls

- Öffentliche Methoden, die fehlschlagen können (z.B. `add_child_widget`, `remove_child_widget`), geben `$Result<T, PanelWidgetError>$` zurück, wie in den Entwicklungsrichtlinien von NovaDE vorgesehen.
- Interne Fehler, die nicht nach außen propagiert werden müssen oder können (z.B. Fehler beim Laden optionaler Ressourcen, die zu einem Fallback-Verhalten führen), werden mit `tracing::error!` oder `tracing::warn!` geloggt.
- Panics sind strikt zu vermeiden, außer bei nicht behebbaren Programmierfehlern (z.B. Nichterfüllung von Vorbedingungen, die durch `debug_assert!` in Entwicklungs-Builds geprüft werden könnten). Solche Fälle deuten auf Fehler in der Logik hin und sollten während der Entwicklung identifiziert und behoben werden.

Die konsequente Anwendung dieser Fehlerbehandlungsstrategien erhöht die Robustheit und Wartbarkeit des `PanelWidget` und des Gesamtsystems.

### 2.10. `PanelWidget`: Interaktion mit Domänen- und Systemschicht

Das `PanelWidget` muss die in der NovaDE-Architektur definierten Schichtengrenzen wahren.

#### 2.10.1. Abruf von Daten

- **Theme-Informationen:** Das `PanelWidget` reagiert auf Änderungen der globalen Akzentfarbe und des Hell/Dunkel-Modus. Diese Informationen werden von `domain::theming` bereitgestellt. Die Anbindung erfolgt typischerweise über:
    - Beobachtung von `gio::Settings`-Schlüsseln (z.B. `org.gnome.desktop.interface gtk-theme`, `org.gnome.desktop.interface color-scheme`).
    - Beobachtung eines NovaDE-spezifischen `gio::Settings`-Schlüssels oder eines D-Bus-Signals für die Akzentfarbe, falls diese nicht über Standardmechanismen abgedeckt ist. Die Methode `connect_theme_signals` im `PanelWidget` ist für die Einrichtung dieser Beobachter zuständig. Bei Empfang einer Änderung wird `update_theme_dependent_elements` aufgerufen.
- **Workspace-Informationen:** Das `PanelWidget` selbst benötigt keine direkten Workspace-Daten. Diese werden vom `WorkspaceIndicatorWidget` (oder einem ähnlichen, im Panel gehosteten Widget) verarbeitet, das seinerseits mit `domain::workspaces` kommuniziert.
- **Status-Indikatoren (Netzwerk, Energie, etc.):** Analog zu den Workspace-Informationen beziehen die jeweiligen Indikator-Widgets ihre Daten von der System- oder Domänenschicht (z.B. UPower-Status via D-Bus 18). Das `PanelWidget` stellt nur den Container bereit.

#### 2.10.2. Auslösen von Aktionen

- Das `PanelWidget` löst primär UI-interne Aktionen aus, wie das Anzeigen von Popovers (z.B. Schnelleinstellungen, Benachrichtigungszentrum) über seine GObject-Signale.
- Das Öffnen von Systemeinstellungsmodulen (z.B. Klick auf den Netzwerk-Indikator öffnet die Netzwerkeinstellungen im `ui::control_center`) wird von den jeweiligen Indikator-Widgets selbst initiiert. Diese können hierfür D-Bus-Methodenaufrufe an `ui::control_center` senden oder andere IPC-Mechanismen nutzen, die von der `ui::shell` oder `ui::control_center` bereitgestellt werden.

Diese klare Trennung stellt sicher, dass das `PanelWidget` ein reines UI-Element bleibt und nicht mit systemspezifischer Logik oder direkten Datenabfragen aus tieferen Schichten überfrachtet wird. Dies erhält die Modularität und Testbarkeit der Gesamtarchitektur. Viele Daten, die im Panel angezeigt werden (Netzwerkstatus, Akkustand), fließen nicht direkt in das Panel, sondern in die spezialisierten Indikator-Widgets, die das Panel hostet. Das Panel ist somit eher ein "Präsentator von Präsentatoren".

### 2.11. `PanelWidget`: Testaspekte und -szenarien

Umfassende Tests sind gemäß den Entwicklungsrichtlinien von NovaDE für alle Module erforderlich.

#### 2.11.1. Unit-Tests für kritische Logik

- **Property-Handling:** Testen der Setter und Getter für alle GObject-Properties, einschließlich Validierungslogik (z.B. für `height-request`) und korrekte Emission von `notify::*`-Signalen bei Wertänderungen.
- **Kind-Widget-Management:** Testen der Logik zum Hinzufügen (`add_child_widget`) und Entfernen (`remove_child_widget`) von Kind-Widgets. Dies beinhaltet die Überprüfung, ob Widgets korrekt den Bereichen `left_box`, `center_box`, `right_box` hinzugefügt und wieder entfernt werden und ob Fehlerfälle (z.B. Hinzufügen eines Widgets, das bereits einen Parent hat) korrekt mit `$PanelWidgetError$` behandelt werden.
- **Zustandsänderungen:** Testen interner Zustandsänderungen als Reaktion auf den Aufruf öffentlicher Methoden oder die Änderung von Properties (z.B. Setzen der CSS-Klasse `glow-accent-visible` bei Änderung von `show-glow-accent`).
- **Abhängigkeits-Mocking:** Wo das `PanelWidget` von externen Signalen abhängt (z.B. Theme-Änderungen), sollten diese Abhängigkeiten in Unit-Tests gemockt werden, um die Reaktion des Panels (z.B. Aufruf von `update_theme_dependent_elements`) isoliert zu testen.

#### 2.11.2. Integrationsszenarien mit (simulierten) Sub-Modulen

- **Layout-Tests:** Testen des korrekten Layouts von hinzugefügten (Mock-)Kind-Widgets in den drei Hauptbereichen. Überprüfung, ob `hexpand`-Einstellungen und Ausrichtung wie erwartet funktionieren.
- **Signal-Emission:** Testen, ob das `PanelWidget` die definierten Signale (z.B. `quick-settings-toggled`) korrekt emittiert, wenn simulierte Kind-Buttons (die diese Aktionen auslösen würden) "geklickt" werden (programmatische Aktivierung im Test).
- **Interaktion mit Popovers:** Obwohl die Popovers selbst separate Widgets sind, kann getestet werden, ob die Signale des Panels korrekt von einer Mock-Logik empfangen werden, die ein Popover simulieren würde.

#### 2.11.3. Überlegungen zu UI-Tests

Für UI-Tests können Werkzeuge aus dem gtk-rs Ökosystem oder externe Test-Frameworks in Betracht gezogen werden. Szenarien umfassen:

- **Sichtbarkeit und Erscheinungsbild:** Überprüfung der korrekten Anzeige des Panels und seiner Hauptbereiche auf einem simulierten Bildschirm. Visuelle Überprüfung (ggf. automatisiert durch Screenshot-Vergleiche) des Leuchtakzents und seiner Reaktion auf Theme-Änderungen.
- **Interaktion:** Simulation von Benutzerinteraktionen wie Klicks auf Buttons im Panel und Überprüfung, ob die entsprechenden Aktionen (z.B. das (simulierte) Öffnen eines Popovers oder Menüs) ausgelöst werden.
- **Dynamische Anpassungen:** Testen der Reaktion des Panels auf Laufzeitänderungen von Eigenschaften (z.B. Höhe, Position).

Das Testen von Widgets, die Composite Templates verwenden, erfordert möglicherweise spezifische Ansätze, um Template-Kinder zu inspizieren oder zu mocken. Die Test-Utilities von gtk-rs oder Ansätze, die eine laufende GTK-Anwendungsumgebung für Tests bereitstellen, können hier nützlich sein. Durch die Definition von Testszenarien bereits in der Spezifikationsphase wird sichergestellt, dass Testbarkeit von Anfang an ein Designkriterium ist, was spätere Probleme bei der Testautomatisierung vermeiden hilft.

## 3. Anhang

### 3.1. Referenzen zur "Technischen Gesamtspezifikation & Richtlinien"

Dieses Dokument ist im Kontext der übergeordneten "Technischen Gesamtspezifikation & Richtlinien für NovaDE" zu verstehen. Dieses Hauptdokument enthält verbindliche Vorgaben bezüglich der Gesamtarchitektur, des Technologie-Stacks, der Code-Qualitätsstandards und der allgemeinen Entwicklungsrichtlinien, die auch für die Implementierung des `PanelWidget` gelten.

### 3.2. Glossar für `PanelWidget`-spezifische Begriffe

- **Leuchtakzent:** Ein visueller Effekt, typischerweise ein farbiger Rand und/oder Schatten, am oberen oder unteren Rand des Panels, dessen Farbe sich dynamisch an die Akzentfarbe des System-Themes anpasst.
- **`PanelChildrenArea`:** Eine Rust-Enum (`Left`, `Center`, `Right`), die zur Spezifizierung dient, in welchem Hauptbereich eines `PanelWidget` ein Kind-Widget platziert werden soll.
- **Composite Template:** Eine XML-basierte UI-Definitionsdatei (`.ui`), die die Struktur und das initiale Layout eines benutzerdefinierten GTK-Widgets beschreibt und im Rust-Code über Makros an die Widget-Implementierung gebunden wird.2
- **Design-Token:** Abstrakte Variablen (oft als CSS-Variablen implementiert), die Designentscheidungen wie Farben, Schriftgrößen oder Abstände repräsentieren und eine konsistente und anpassbare Gestaltung über die gesamte Anwendung hinweg ermöglichen.15

**Technische Gesamtspezifikation & Richtlinien: Linux Desktop-Umgebung "NovaDE" (Essenz)**

**I. Vision und Kernziele**

- **Vision:** NovaDE ist eine innovative Linux-Desktop-Umgebung, die eine moderne, schnelle, intuitive und KI-gestützte Benutzererfahrung für Entwickler, Kreative und alltägliche Nutzer schafft. Ziel ist die Maximierung von Produktivität und Freude an der Systeminteraktion.
- **Kernziele:**
    - **Performance:** Durchgehend schnelle, reaktionsschnelle Umgebung.
    - **Intuition:** Natürlich anfühlende, leicht erlernbare und intelligent unterstützende UI.
    - **Modernität:** Einsatz aktueller Technologien und Designprinzipien.
    - **Modularität & Wartbarkeit:** Klare Architektur für einfache Erweiterung, Testbarkeit und Wartung.
    - **Anpassbarkeit:** Weitreichende Personalisierungsmöglichkeiten für Optik und Verhalten.
    - **KI-Integration:** Nahtlose, sichere KI-Assistenz unter voller Benutzerkontrolle.
    - **Stabilität & Sicherheit:** Höchste Priorität durch geeignete Technologien und Entwicklungspraktiken.

**II. Architektonischer Überblick: Vier-Schichten-Architektur**

NovaDE nutzt eine strikte, vier-schichtige Architektur für Modularität, lose Kopplung und hohe Kohäsion. Kommunikation zwischen Schichten erfolgt ausschließlich über wohldefinierte Schnittstellen.

1. **Kernschicht (Core Layer): Systemfundament**
    
    - **Verantwortlichkeiten:** Fundamentale Datentypen (`Point<T>`, `Color`, `TokenIdentifier`), allgemeine Dienstprogramme, Basis-Infrastruktur für Konfigurationsparsing und -zugriff (TOML, Serde), globales Logging-Framework (`tracing`), allgemeine Fehlerdefinitionen (`thiserror`).
    - **Abhängigkeiten:** Minimal (Rust std, uuid, chrono, thiserror, tracing, serde, toml, once_cell). Keine NovaDE-internen Abhängigkeiten.
    - **Interaktionen:** Stellt Funktionalität für alle höheren Schichten bereit.
2. **Domänenschicht (Domain Layer): Geschäftslogik & Regeln**
    
    - **Verantwortlichkeiten:** UI-unabhängige Kernlogik.
        - `domain::theming`: Logik der Theming-Engine, Design-Token-Verwaltung, dynamische Theme-Wechsel, `AppliedThemeState`.
        - `domain::workspaces`: Logik für Arbeitsbereiche ("Spaces"), Fensterzuweisung (`WindowIdentifier`, `WorkspaceId`), Workspace-Management, Persistenz.
        - `domain::user_centric_services`: KI-Interaktionslogik (`AIInteractionContext`), Einwilligungsmanagement (`AIConsent`, `AIDataCategory`, `AIModelProfile`), Benachrichtigungslogik (`Notification`, `NotificationUrgency`).
        - `domain::notifications_rules`: Regelbasierte Benachrichtigungsverarbeitung.
        - `domain::global_settings_and_state_management`: Verwaltung globaler Desktop-Einstellungen (`GlobalDesktopSettings`, `SettingValue`).
        - `domain::window_management_policy`: High-Level-Richtlinien für Fensterplatzierung, Tiling (Spalten, Spiralen), Snapping, Gaps.
    - **Abhängigkeiten:** Nur Kernschicht.
    - **Interaktionen:** Stellt Logik und Zustand für System- und UI-Schicht bereit (oft via Traits und Events wie `ThemeChangedEvent`).
3. **Systemschicht (System Layer): OS-Interaktion & technische Umsetzung**
    
    - **Verantwortlichkeiten:** Interaktion mit OS, Hardware, externen Diensten. Setzt Domänenrichtlinien technisch um.
        - `system::compositor`: Smithay-basierter Wayland-Compositor (`xdg-shell`, `wlr-layer-shell`, etc.), XWayland.
        - `system::input`: `libinput`-basierte Eingabeverarbeitung, Gesten, Seat-Management (`xkbcommon`).
        - `system::dbus`: `zbus`-Schnittstellen zu Systemdiensten (NetworkManager, UPower, logind, org.freedesktop.Notifications, org.freedesktop.secrets, PolicyKit).
        - `system::outputs`: Monitorkonfiguration (`wlr-output-management`, DPMS).
        - `system::audio`: `pipewire-rs` Client für Audio-Management.
        - `system::mcp`: `mcp_client_rs` für KI-Modell-Kommunikation basierend auf `domain::user_centric_services`.
        - `system::portals`: Backend für XDG Desktop Portals (FileChooser, Screenshot).
        - `system::window_mechanics`: Technische Umsetzung des Fenstermanagements (Positionierung, Tiling, Fokus) gemäß `domain::window_management_policy`. Technische Basis für "Intelligente Tab-Leiste".
    - **Abhängigkeiten:** Kern- und Domänenschicht.
    - **Interaktionen:** Stellt systemnahe Dienste/Events für UI-Schicht bereit. Empfängt UI-Befehle.
4. **Benutzeroberflächenschicht (User Interface Layer): Darstellung & Benutzerinteraktion**
    
    - **Verantwortlichkeiten:** Grafische Darstellung und direkte Benutzerinteraktion. Basiert auf GTK4 (`gtk4-rs`).
        - `ui::shell`: Haupt-Shell-UI (PanelWidget, SmartTabBarWidget pro "Space", QuickSettingsPanelWidget, WorkspaceSwitcherWidget, QuickActionDockWidget, NotificationCenterPanelWidget).
        - `ui::control_center`: Modulare GTK4-Anwendung für Systemeinstellungen.
        - `ui::widgets`: Widget-System (RightSidebarWidget, WidgetManagerService, WidgetPickerPopover, diverse Widgets wie ClockWidget).
        - `ui::window_manager_frontend`: UI-Aspekte des Fenstermanagements (CSD, OverviewModeWidget, AltTabSwitcherWidget).
        - `ui::notifications_frontend`: Pop-up-Benachrichtigungen (NotificationPopupWidget).
        - `ui::theming_gtk`: Anwendung von CSS (aus `domain::theming`) via `GtkCssProvider`.
        - `ui::components`: Wiederverwendbare GTK4-Widgets.
        - `ui::speed_dial`: Startansicht für leere Workspaces.
        - `ui::command_palette`: Kontextuelle Befehlspalette.
    - **Abhängigkeiten:** Alle darunterliegenden Schichten.
    - **Interaktionen:** Empfängt System-Events. Visualisiert Daten aus Domäne/System. Löst Aktionen in Domäne/System aus.

**III. Technologie-Stack (Verbindliche Auswahl)**

|Bereich|Technologie/Standard|
|:--|:--|
|Programmiersprache|Rust|
|Build-System|Meson|
|GUI-Toolkit|GTK4 (mit `gtk4-rs` Bindings)|
|Wayland Compositor & Bibliotheken|Smithay Toolkit|
|Essentielle Wayland-Protokolle|`wayland.xml`, `xdg-shell`, `wlr-layer-shell-unstable-v1`, `xdg-decoration-unstable-v1`, `wlr-foreign-toplevel-management-unstable-v1`, `wlr-output-management-unstable-v1`, etc.|
|Inter-Prozess-Kommunikation (IPC)|D-Bus (mit `zbus` Crate)|
|KI-Integration|Model Context Protocol (MCP) (mit `mcp_client_rs` Crate)|
|Eingabeverarbeitung|`libinput` (integriert via Smithay)|
|Audio-Management|PipeWire (mit `pipewire-rs` Crate)|
|Geheimnisverwaltung|Freedesktop Secret Service API (via D-Bus)|
|Rechteverwaltung|PolicyKit (polkit) (via D-Bus)|
|Theming-Implementierung (UI)|Token-basiert, GTK4 CSS Custom Properties (`var()`)|
|Sandboxing-Interaktion|XDG Desktop Portals (via D-Bus)|

In Google Sheets exportieren

**IV. Entwicklungsrichtlinien (Verbindlich)**

- **Rust:**
    - **Stil:** `rustfmt` (Standard), max. 100 Zeichen/Zeile, 4 Leerzeichen Einrückung.
    - **API-Design:** Rust API Guidelines Checklist.
    - **Fehlerbehandlung:** `thiserror` pro Modul, `Result<T, E>`, Panics nur für interne Invariantenverletzungen/Tests. Klare `#[error]`-Nachrichten, keine sensiblen Daten. `source()`-Kette erhalten.
    - **Logging & Tracing:** `tracing` Crate, Spans (`#[tracing::instrument]`), Standard-Level, keine sensiblen Daten.
    - **Nebenläufigkeit:** `async/await` (tokio, `glib::MainContext::spawn_local`), thread-sichere Datenstrukturen.
    - **Crate-Struktur:** Logische Aufteilung (z.B. `novade-core`, `novade-domain`), klare APIs.
- **Versionskontrolle:** Git, GitHub Flow, PRs mit Review & CI-Checks, Conventional Commits.
- **Teststrategie:** Unit-Tests (Kern, Domäne, Logik-Komponenten), Integrationstests, Compositor-Tests (Smithay Headless Backends), UI-Tests (Accessibility-APIs).
- **CI-Pipeline:** Tests, `cargo fmt --check`, `cargo clippy -D warnings`, `cargo audit`.
- **Dokumentation:**
    - **Code (rustdoc):** Umfassend für alle öffentlichen APIs (Was, Warum, Wie, Fehler, Sicherheit, Beispiele).
    - **Architektur:** Dieses Dokument als Referenz, High-Level-Diagramme.
    - **READMEs:** Pro Crate/Komponente.
    - **Metadaten:** Vollständige `Cargo.toml`.
    - **Benutzer-/Entwicklerdoku:** Parallel erstellen.

**V. Initiale Schicht- und Komponentenspezifikationen (Struktur)**

Detaillierte Spezifikationen pro Komponente/Schicht folgen einer einheitlichen Struktur: Modul-/Komponentenübersicht, Datenstrukturen/Typdefinitionen (Rust-Syntax), Öffentliche API/Interne Schnittstellen (Signaturen, Logik, Events), Fehlerbehandlung (`thiserror`-Enum), Interaktionen/Abhängigkeiten, Implementierungsschritte, Testaspekte.

**VI. Deployment-Überlegungen**

- **Paketierung:** Native Pakete (.deb, .rpm), Flatpak (evaluieren). Meson-Build für Artefakte.
- **Systemintegration:** Display Manager (GDM, LightDM), `systemd` User Sessions, PAM, XDG Base Directory Specification.
- **Konfiguration:** Sinnvolle Standardkonfiguration, UI-basierte Anpassung (`ui::control_center`), Trennung System-/Benutzerkonfig.
- **Updates:** Distro-Paketmanager, Flatpak-Mechanismus. SemVer. Konfigurationsmigration.

**VII. Anforderungen aus der Benutzererfahrung (Essenz)**

NovaDE soll eine **intelligente, intuitive und persönliche** Erfahrung bieten, die sich wie eine natürliche Erweiterung des Nutzers anfühlt.

- **Ästhetik & Navigation:** Klare, dunkle Ästhetik mit benutzerwählbaren Akzentfarben. Flüssige Animationen (Wayland-basiert). Mühelose Navigation und Informationszugriff.
- **Personalisierung (Theming):** Dynamischer Wechsel zwischen Designs (Hell/Dunkel) und Akzentfarben zur Laufzeit (Token-basiertes Theming).
- **Fenster- & Workspace-Management ("Spaces"):**
    - **Intelligente Tab-Leiste pro Space:** Zeigt "angepinnte" Apps/Split-Views.
    - **Workspace-Switcher (Linke Seitenleiste):** Visueller Wechsel zwischen Spaces mit Icons/Namen.
    - **Fortschrittliche Fensterverwaltung:** Automatisches Tiling (Spalten, Spiralen etc.), Snapping, Stacking, Floating mischbar, konfigurierbare Gaps.
    - **Übersichtsmodus:** Visuelle Darstellung aller Fenster/Spaces, Drag & Drop zwischen Spaces.
- **Interaktionskomponenten:**
    - **Kontroll-/Systemleiste(n):** Schneller Zugriff auf Systemfunktionen, Benachrichtigungszentrum.
    - **Quick-Settings-Panel:** Schnelleinstellungen ohne Control Center.
    - **Control Center:** Zentrale, modulare Systemeinstellungen mit Live-Vorschau.
    - **Schnellaktionsdock:** Konfigurierbar für Apps, Dateien, Aktionen; intelligente Vorschläge.
    - **Adaptive Seitenleisten & Widgets:** Links für Navigation/"Spaces", rechts für informative Widgets (Uhr, Kalender, Wetter, etc.), anpassbar via Drag & Drop.
    - **Speed-Dial:** Startansicht für leere Workspaces mit Favoriten und intelligenten Vorschlägen.
    - **Kontextuelle Befehlspalette (`Super+Space`):** Schneller Zugriff auf Aktionen, Einstellungen, Apps via Texteingabe mit Fuzzy-Matching und Kontextsensitivität.
- **KI-Integration (Sicher & Kontrolliert):**
    - **Model Context Protocol (MCP):** Sicherer, standardisierter Zugriff auf lokale/Cloud-LLMs.
    - **Explizite Zustimmung:** Keine KI-Aktion ohne klares Verständnis und Erlaubnis des Nutzers. Feingranulare Berechtigungen.
    - **Praktische Funktionen:** Sprachsteuerung, automatisierte Dateiaufgaben, kontextbezogene Informationen.
    - **Sichere Speicherung:** Sensible Daten (API-Keys) via Freedesktop Secret Service.
- **Systemintegration:**
    - **Wayland & XWayland:** Moderne, sichere Darstellung.
    - **D-Bus:** Kommunikation mit Systemdiensten.
    - **PolicyKit:** Sicherheit für privilegierte Aktionen.
    - **`libinput`:** Präzise Eingabe, Gestensteuerung.
    - Multi-Monitor-Support (Auflösung, Skalierung, Anordnung).
    - Audio-Management (PipeWire).
    - Effiziente Energienutzung.

**VIII. Schlussfolgerung**

Diese Gesamtspezifikation legt das verbindliche Fundament für NovaDE. Die präzisen Entscheidungen zu Architektur, Technologien und Richtlinien, kombiniert mit den Anforderungen aus der Nutzererfahrung, bilden die Grundlage für die detaillierte Implementierung. Konsequente Einhaltung dieser Spezifikation wird eine hochwertige, moderne, sichere, performante und anpassungsfähige Desktop-Umgebung hervorbringen.

 Quellen

Jetzt bitte inklusive Beschreibung der Features wie in der ersten anfrage mitgesendet als eine Kompakte Gesamtdefinition

S

Systemingeneur

Benutzerdefiniertes Gem

Absolut. Hier ist die optimierte Essenz der technischen Gesamtspezifikation und Richtlinien für NovaDE, nun inklusive einer kompakten Beschreibung der Features, die die Anforderungen aus der Nutzererfahrung widerspiegeln:

**Technische Gesamtspezifikation & Richtlinien: Linux Desktop-Umgebung "NovaDE" (Kompakte Gesamtdefinition inkl. Features)**

**I. Vision und Kernziele**

- **Vision:** NovaDE (Nova Desktop Environment) ist eine innovative Linux-Desktop-Umgebung, die eine moderne, schnelle, intuitive und KI-gestützte Benutzererfahrung schafft. Sie ist optimiert für Entwickler, Kreative und alltägliche Nutzer und zielt darauf ab, Produktivität und Freude an der Interaktion mit dem System zu maximieren.
- **Kernziele:** Performance, Intuition, Modernität, Modularität & Wartbarkeit, Anpassbarkeit, sichere KI-Integration, Stabilität & Sicherheit.

**II. Architektonischer Überblick: Vier-Schichten-Architektur**

NovaDE basiert auf einer strengen, vier-schichtigen Architektur (Kern, Domäne, System, Benutzeroberfläche) für Modularität, lose Kopplung und hohe Kohäsion. Kommunikation erfolgt über wohldefinierte Schnittstellen.

1. **Kernschicht (Core Layer):**
    
    - **Verantwortlichkeiten:** Fundamentale Datentypen (z.B. `Point<T>`, `Color`), Dienstprogramme, Konfigurationsprimitive (TOML, Serde), Logging (`tracing`), Basis-Fehler (`thiserror`).
    - **Featurespiegelung:** Stellt die atomaren Bausteine für alle visuellen und logischen Elemente bereit.
2. **Domänenschicht (Domain Layer):**
    
    - **Verantwortlichkeiten:** UI-unabhängige Geschäftslogik.
        - `domain::theming`: Logik für das Erscheinungsbild, Design-Token-Verwaltung, dynamische Theme-Wechsel (Hell/Dunkel, Akzentfarben).
        - `domain::workspaces`: Verwaltung von Arbeitsbereichen ("Spaces"), Fensterzuweisung, Workspace-Orchestrierung und -Persistenz.
        - `domain::user_centric_services`: Logik für KI-Interaktionen (inkl. Einwilligungsmanagement für Datenkategorien wie `FileSystemRead`, `ClipboardAccess`), Benachrichtigungsverwaltung.
        - `domain::notifications_rules`: Regelbasierte, dynamische Verarbeitung von Benachrichtigungen.
        - `domain::global_settings_and_state_management`: Verwaltung globaler Desktop-Einstellungen.
        - `domain::window_management_policy`: Richtlinien für Fensterplatzierung, automatisches Tiling (Layouts: Spalten, Spiralen), Snapping, Fenstergruppierung, Gap-Management.
    - **Featurespiegelung:** Definiert _was_ personalisierbar ist (Themes, Akzente), _wie_ Arbeitsbereiche funktionieren (Spaces mit Icons, gepinnten Apps), _wie_ KI sicher und mit Zustimmung agiert und _welche_ Regeln für Fenster gelten.
3. **Systemschicht (System Layer):**
    
    - **Verantwortlichkeiten:** OS-Interaktion, technische Umsetzung der Domänenrichtlinien.
        - `system::compositor`: Smithay-basierter Wayland-Compositor (Implementierung von `xdg-shell`, `wlr-layer-shell-unstable-v1`, etc.), XWayland.
        - `system::input`: `libinput`-basierte Eingabeverarbeitung, Gestenerkennung, Seat-Management (`xkbcommon`).
        - `system::dbus`: `zbus`-Schnittstellen zu Systemdiensten (NetworkManager, UPower, logind, org.freedesktop.Notifications, org.freedesktop.secrets, PolicyKit).
        - `system::outputs`: Monitorkonfiguration (Auflösung, Skalierung, DPMS über `wlr-output-management`).
        - `system::audio`: PipeWire-Client (`pipewire-rs`) für Audio-Management.
        - `system::mcp`: MCP-Client (`mcp_client_rs`) für KI-Modell-Kommunikation.
        - `system::portals`: Backend für XDG Desktop Portals (FileChooser, Screenshot).
        - `system::window_mechanics`: Technische Umsetzung des Fenstermanagements (Positionierung, Anwendung von Tiling-Layouts, Fokus, Fensterdekorationen). Technische Basis für die "Intelligente Tab-Leiste".
    - **Featurespiegelung:** Ermöglicht flüssige Darstellung (Wayland), präzise Eingabe (`libinput`, Gesten), Integration mit Systemdiensten für Energie, Netzwerk, Sound (PipeWire) und sichere KI-Kommunikation (MCP). Setzt Fensterregeln (Tiling, Snapping) technisch um.
4. **Benutzeroberflächenschicht (User Interface Layer):**
    
    - **Verantwortlichkeiten:** Grafische Darstellung, Benutzerinteraktion (GTK4, `gtk4-rs`).
        - `ui::shell`:
            - **Kontroll-/Systemleiste(n) (PanelWidget):** Module für AppMenu, Workspace-Indikator, Uhr, System-Tray, Schnelleinstellungen, Benachrichtigungszentrum, Netzwerk-, Energie-, Audio-Indikatoren. _Elegante Leiste mit optionalem Leuchtakzent._
            - **Intelligente Tab-Leiste (SmartTabBarWidget):** Pro "Space", mit ApplicationTabWidgets für "angepinnte" Apps/Split-Views, aktive Tabs mit Akzentfarbe. _Moderne Tabs mit abgerundeten oberen Ecken._
            - **Schnelleinstellungs-Panel (QuickSettingsPanelWidget):** Ausklappbar für WLAN, Bluetooth, Lautstärke, Dark Mode.
            - **Workspace-Switcher (WorkspaceSwitcherWidget):** Adaptive linke Seitenleiste mit SpaceIconWidgets (Icons der gepinnten App oder benutzerdefiniert) für schnelle Navigation zwischen "Spaces", mit Hervorhebung des aktiven Space. _Bei Mouse-Over/Geste aufklappbar mit Namen/Vorschau._
            - **Schnellaktionsdock (QuickActionDockWidget):** Konfigurierbares Dock (schwebend/angedockt) für Apps, Dateien, Aktionen; intelligente Vorschläge, Tastaturbedienung.
            - **Benachrichtigungszentrum (NotificationCenterPanelWidget):** Anzeige von Benachrichtigungsliste und -historie.
        - `ui::control_center`: Modulare GTK4-Anwendung für alle Systemeinstellungen (Erscheinungsbild, Netzwerk, etc.) mit Live-Vorschau.
        - `ui::widgets`:
            - **Adaptive rechte Seitenleiste (RightSidebarWidget):** Optional, mit dezent transluzentem Hintergrund für informative Widgets (Uhr, Kalender, Wetter, Systemmonitor), per Drag & Drop anpassbar.
            - WidgetManagerService, WidgetPickerPopover.
        - `ui::window_manager_frontend`:
            - **Client-Side Decorations (CSD):** Logik (z.B. via `Gtk::HeaderBar`).
            - **Übersichtsmodus (OverviewModeWidget):** Fenster- und Workspace-Übersicht als interaktive Kacheln mit Live-Vorschau, Drag & Drop von Fenstern zwischen Spaces. _Hintergrund abgedunkelt/unscharf._
            - AltTabSwitcherWidget.
        - `ui::notifications_frontend`: **Pop-up-Benachrichtigungen (NotificationPopupWidget):** Dezent, im Dark Mode Stil mit Akzentfarbe für Dringlichkeit.
        - `ui::theming_gtk`: Anwendung von CSS-Stilen aus `domain::theming` via `GtkCssProvider`.
        - `ui::speed_dial`: GTK4-Implementierung der Startansicht für leere Workspaces mit Favoriten und intelligenten Vorschlägen.
        - `ui::command_palette`: GTK4-Implementierung der kontextuellen Befehlspalette (`Super+Space`).
    - **Featurespiegelung:** Setzt die gesamte beschriebene Nutzererfahrung um: dunkle Ästhetik mit Akzentfarben, Panel(s), intelligente Tab-Leiste, adaptive Seitenleisten mit Widgets, Workspace-Switcher, Schnellaktionsdock, Control Center, Speed-Dial, Übersichtsmodus und die kontextuelle Befehlspalette. Ermöglicht die Personalisierung und direkte Manipulation.

**III. Technologie-Stack (Verbindliche Auswahl)**

Rust, Meson, GTK4 (`gtk4-rs`), Smithay Toolkit, Wayland (xdg-shell, wlr-Protokolle), D-Bus (`zbus`), Model Context Protocol (MCP), `libinput`, PipeWire (`pipewire-rs`), Freedesktop Secret Service API, PolicyKit, Token-basiertes CSS-Theming, XDG Desktop Portals.

**IV. Entwicklungsrichtlinien (Verbindlich)**

- **Rust:** `rustfmt`, Rust API Guidelines, `thiserror` pro Modul, `Result<T,E>`, `tracing` für Logging, `async/await` (Tokio, GLib).
- **Allgemein:** Git (GitHub Flow), Conventional Commits, umfassende Tests (Unit, Integration, Compositor, UI), CI-Pipeline, detaillierte Dokumentation (rustdoc, Architektur, READMEs).

**V. Deployment-Überlegungen**

Native Pakete (.deb, .rpm), Flatpak (evaluieren), Integration mit Display Managern, `systemd` User Sessions, PAM, XDG Base Directory Specification. SemVer.

**VI. Schlussfolgerung**

Diese Gesamtspezifikation legt das Fundament für NovaDE, eine moderne, performante, anpassungsfähige und KI-gestützte Desktop-Umgebung. Die klare Architektur, der robuste Technologie-Stack und die detaillierten Richtlinien, in Verbindung mit den aus der Nutzererfahrung abgeleiteten Features, ermöglichen die Entwicklung einer intuitiven und effizienten Plattform.

# **NovaDE UI-Schicht: Implementierungsleitfaden – ui::shell::PanelWidget und AppMenuButton**

## **1\. Einleitung**

### **1.1. Zweck des Dokuments**

Dieses Dokument dient als detaillierter Implementierungsleitfaden für ausgewählte Module der UI-Schicht der Nova Desktop Environment (NovaDE). Es spezifiziert die Architektur, das Design, die Datenstrukturen, Schnittstellen und Implementierungsdetails auf einer ultrafeinen Ebene, sodass Entwicklerteams diese Spezifikationen direkt für die Codierung verwenden können, ohne grundlegende Designentscheidungen treffen oder Kernlogiken selbst entwerfen zu müssen. Dieses erste Teildokument fokussiert sich auf die Kernkomponente ui::shell::PanelWidget und dessen Submodul ui::shell::panel\_widget::AppMenuButton.

### **1.2. Zielgruppe**

Dieses Dokument richtet sich an Softwareentwickler und \-architekten, die an der Implementierung der NovaDE UI-Schicht beteiligt sind. Es wird ein Verständnis von Rust, GTK4 und den gtk4-rs Bindings sowie grundlegenden Konzepten der Softwarearchitektur und des UI-Designs vorausgesetzt.

### **1.3. Umfang (Teil 1: ui::shell::PanelWidget und AppMenuButton)**

Dieser erste Teil des Implementierungsleitfadens für die UI-Schicht behandelt die folgenden Module:

* **ui::shell::PanelWidget**: Die Haupt-Panel-Komponente der Desktop-Shell, verantwortlich für die Aufnahme und Anordnung verschiedener Panel-Module.  
* **ui::shell::panel\_widget::AppMenuButton**: Ein spezifisches Panel-Modul innerhalb des PanelWidget, das das globale Anwendungsmenü der aktiven Applikation anzeigt.

Nachfolgende Teildokumente werden weitere Module der UI-Schicht detaillieren.

### **1.4. Technologie-Stack (Verbindlich)**

Die Implementierung der UI-Schicht erfolgt unter strikter Verwendung des folgenden Technologie-Stacks:

* **GUI-Toolkit**: GTK4 1  
* **Rust-Bindings**: gtk4-rs 1  
* **Programmiersprache**: Rust 4  
* **Asynchrone Operationen**: Integration mit Rusts async/await über glib::MainContext::spawn\_local 7  
* **Theming**: Anwendung von CSS-Stilen über gtk::CssProvider, generiert durch domain::theming 9  
* **D-Bus-Kommunikation**: zbus Crate für Interaktionen mit Systemdiensten und anderen Anwendungen 12

### **1.5. Allgemeine UI/UX-Prinzipien (Wiederholung)**

Die Entwicklung der UI-Schicht orientiert sich an den folgenden übergeordneten UI/UX-Prinzipien, die eine visionstreue Umsetzung gewährleisten:

* **Konsistenz**: Einheitliches Erscheinungsbild und Verhalten über alle UI-Komponenten hinweg.  
* **Feedback**: Klares visuelles (und ggf. haptisches) Feedback auf Benutzeraktionen.  
* **Effizienz**: Minimierung der notwendigen Schritte zur Erledigung häufiger Aufgaben.  
* **Zugänglichkeit (Accessibility)**: Einhaltung der a11y-Standards (ATK/AT-SPI).23  
* **Performance**: Flüssige Animationen, schnelle Reaktionszeiten und geringer Ressourcenverbrauch.24  
* **Anpassbarkeit**: Ermöglichung benutzerdefinierter Konfigurationen von Layouts, Widgets und Verhalten.

## **2\. Modul: ui::shell::PanelWidget (Haupt-Panel-Implementierung)**

### **2.1.1. Übersicht und Verantwortlichkeiten**

Das PanelWidget ist die zentrale Komponente der ui::shell, die als primäre(s) Kontroll- und Systemleiste(n) der NovaDE dient. Es ist verantwortlich für:

* Die Bereitstellung einer oder mehrerer horizontaler Leisten am Bildschirmrand (oben oder unten, konfigurierbar).  
* Die Aufnahme, Anordnung und Verwaltung verschiedener, modularer Panel-Elemente (Submodule wie AppMenuButton, ClockDateTimeWidget, etc.).  
* Die Implementierung grundlegender Panel-Eigenschaften wie Höhe, Transparenz und eines visuellen "Leuchtakzent"-Effekts.  
* Die Interaktion mit dem gtk4-layer-shell-Protokoll, um sich korrekt in Wayland-Compositors zu integrieren, die dieses Protokoll unterstützen (z.B. wlroots-basierte wie Sway, Mir, KDE Plasma).26  
* Das dynamische Laden und Anwenden von Theming-Informationen, insbesondere für den "Leuchtakzent" und Hintergrundstile.

### **2.1.2. Visuelles Design und Theming**

* **Positionierung**: Konfigurierbar am oberen oder unteren Bildschirmrand.  
* **Höhe**: Konfigurierbare Höhe, z.B. zwischen 24px und 128px.  
* **Transparenz**: Optionale Transparenz des Panel-Hintergrunds. Dies wird durch Setzen der Opazität des Hauptfensters und/oder durch Verwendung von RGBA-Farben im CSS und im benutzerdefinierten Zeichencode erreicht. Für Wayland-Compositors, die transparente Oberflächen unterstützen, muss das zugrundeliegende GdkSurface entsprechend konfiguriert werden. Die gtk4-layer-shell kann hierbei relevant sein, um sicherzustellen, dass der Compositor die Transparenz korrekt handhabt.26  
* **"Leuchtakzent"-Effekt**: Ein subtiler Leuchteffekt entlang einer Kante des Panels (z.B. die dem Bildschirmzentrum zugewandte Kante), dessen Farbe und Intensität durch das Theming-System (domain::theming) gesteuert wird. Die Implementierung erfolgt entweder durch CSS (box-shadow mit entsprechenden Offsets und Blur-Radien 36) oder durch benutzerdefiniertes Zeichnen mit Cairo auf einem gtk::DrawingArea.37  
* **CSS-Styling**:  
  * **CSS-Knoten**: Das PanelWidget selbst (als GtkApplicationWindow) hat den CSS-Knoten window. Wenn es einen internen Hauptcontainer (z.B. GtkBox) verwendet, hat dieser den Knoten box.42 Spezifische CSS-Klassen werden zugewiesen, um das Styling zu erleichtern.  
  * **CSS-Klassen**:  
    * .nova-panel: Allgemeine Klasse für das Panel.  
    * .panel-top, .panel-bottom: Je nach Positionierung.  
    * .transparent-panel: Wenn Transparenz aktiviert ist.  
  * Die Anwendung von CSS erfolgt über einen globalen gtk::CssProvider, der durch ui::theming\_gtk verwaltet wird.10 Das Panel reagiert auf ThemeChangedEvents, um dynamische Stiländerungen zu übernehmen.

### **2.1.3. Datenstrukturen, Eigenschaften und Zustand**

Das PanelWidget wird als benutzerdefiniertes GObject-Widget implementiert, das von gtk::ApplicationWindow erbt, um die Integration mit gtk4-layer-shell zu ermöglichen.27

* GObject-Definition (PanelWidget):  
  Die Definition erfolgt in zwei Hauptdateien: mod.rs für die öffentliche API und imp.rs für die private GObject-Implementierung.  
  *Auszug aus src/ui/shell/panel\_widget/mod.rs (vereinfacht):*  
  Rust  
  use gtk::glib;  
  use gtk::subclass::prelude::\*;  
  use std::cell::{Cell, RefCell};

  mod imp;

  glib::wrapper\! {  
      pub struct PanelWidget(ObjectSubclass\<imp::PanelWidget\>)  
          @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,  
          @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;  
  }

  impl PanelWidget {  
      pub fn new(app: \&gtk::Application) \-\> Self {  
          glib::Object::builder::\<Self\>()  
             .property("application", app)  
             .build()  
      }

      // Öffentliche Methoden hier definieren, z.B.:  
      pub fn add\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>, position: imp::ModulePosition, order: i32) {  
          self.imp().add\_module(module, position, order);  
      }

      pub fn remove\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>) {  
          self.imp().remove\_module(module);  
      }  
  }

  *Auszug aus src/ui/shell/panel\_widget/imp.rs (vereinfacht):*  
  Rust  
  use gtk::glib;  
  use gtk::subclass::prelude::\*;  
  use gtk::{CompositeTemplate, Align};  
  use std::cell::{Cell, RefCell};  
  use std::collections::HashMap;  
  use once\_cell::sync::Lazy; // \[123\]

  // Enum für PanelPosition  
  \#  
  \#  
  pub enum PanelPosition {  
      \#\[default\]  
      Top,  
      Bottom,  
  }

  \#  
  \#  
  pub enum ModulePosition {  
      Start,  
      Center,  
      End,  
  }

  static PANEL\_PROPERTIES: Lazy\<Vec\<glib::ParamSpec\>\> \= Lazy::new(|| {  
      vec\!  
  });

  // Hier könnten benutzerdefinierte Signale definiert werden, falls benötigt.  
  // static PANEL\_SIGNALS: Lazy\<HashMap\<String, glib::subclass::Signal\>\> \= Lazy::new(|| HashMap::new());

  \#  
  \#\[template(resource \= "/org/nova\_de/ui/shell/panel\_widget.ui")\] // Pfad zur UI-Datei  
  pub struct PanelWidget {  
      \#\[template\_child\]  
      pub(super) main\_box: TemplateChild\<gtk::Box\>,  
      \#\[template\_child\]  
      pub(super) start\_box: TemplateChild\<gtk::Box\>,  
      \#\[template\_child\]  
      pub(super) center\_box: TemplateChild\<gtk::Box\>,  
      \#\[template\_child\]  
      pub(super) end\_box: TemplateChild\<gtk::Box\>,

      // Für benutzerdefiniertes Zeichnen, falls CSS nicht ausreicht  
      drawing\_area: RefCell\<Option\<gtk::DrawingArea\>\>,

      \#\[property(get, set, explicit\_notify)\]  
      position: RefCell\<PanelPosition\>,  
      \#\[property(get, set, explicit\_notify)\]  
      panel\_height: Cell\<i32\>,  
      \#\[property(get, set, explicit\_notify)\]  
      transparency\_enabled: Cell\<bool\>,  
      \#\[property(get, set, explicit\_notify)\]  
      leuchtakzent\_color: RefCell\<Option\<gdk::RGBA\>\>,  
      \#\[property(get, set, explicit\_notify)\]  
      leuchtakzent\_intensity: Cell\<f64\>,

      // Interne Verwaltung der Module  
      modules\_start: RefCell\<Vec\<gtk::Widget\>\>,  
      modules\_center: RefCell\<Vec\<gtk::Widget\>\>,  
      modules\_end: RefCell\<Vec\<gtk::Widget\>\>,  
  }

  \#\[glib::object\_subclass\]  
  impl ObjectSubclass for PanelWidget {  
      const NAME: &'static str \= "NovaDEPanelWidget";  
      type Type \= super::PanelWidget;  
      type ParentType \= gtk::ApplicationWindow;

      fn class\_init(klass: \&mut Self::Class) {  
          klass.bind\_template();  
          klass.install\_properties(\&PANEL\_PROPERTIES);  
          // klass.install\_signals(\&PANEL\_SIGNALS, false); // Falls Signale vorhanden

          // CSS-Name für das Widget setzen, falls nicht über UI-Datei  
          klass.set\_css\_name("panelwidget");  
      }

      fn instance\_init(obj: \&glib::subclass::InitializingObject\<Self\>) {  
          obj.init\_template();  
      }  
  }

  impl ObjectImpl for PanelWidget {  
      fn constructed(\&self) {  
          self.parent\_constructed();  
          let obj \= self.obj();

          // Standardwerte setzen, falls nicht durch Properties initialisiert  
          if self.position.borrow().eq(\&PanelPosition::default()) {  
               self.position.replace(PanelPosition::Top);  
          }  
          if self.panel\_height.get() \== 0 { // GObject Int default ist 0  
              self.panel\_height.set(36); // Expliziter Standardwert  
          }  
           if self.leuchtakzent\_intensity.get() \== 0.0 { // GObject Double default ist 0.0  
              self.leuchtakzent\_intensity.set(0.5);  
          }

          // Layer Shell initialisieren  
          obj.setup\_layer\_shell();  
          obj.update\_layout(); // Erstes Layout anwenden

          // Eventuell DrawingArea initialisieren und verbinden  
          // let drawing\_area \= gtk::DrawingArea::new();  
          // drawing\_area.set\_content\_width(obj.width\_request()); // Beispiel  
          // drawing\_area.set\_content\_height(self.panel\_height.get());  
          // self.main\_box.prepend(\&drawing\_area); // Oder als Hintergrund  
          // self.drawing\_area.replace(Some(drawing\_area));  
          // self.obj().connect\_draw\_signal();  
      }

      fn properties() \-\> &'static {  
          PANEL\_PROPERTIES.as\_ref()  
      }

      fn set\_property(\&self, \_id: usize, value: \&glib::Value, pspec: \&glib::ParamSpec) {  
          match pspec.name() {  
              "position" \=\> {  
                  let position: PanelPosition \= value.get().expect("Value must be PanelPosition");  
                  self.position.replace(position);  
                  self.obj().setup\_layer\_shell(); // Layer Shell neu konfigurieren bei Positionsänderung  
                  self.obj().notify\_position();   
              }  
              "panel-height" \=\> {  
                  let height: i32 \= value.get().expect("Value must be i32");  
                  self.panel\_height.set(height);  
                  self.obj().set\_default\_height(height); // Fensterhöhe anpassen  
                  self.main\_box.set\_height\_request(height);  
                  // Ggf. DrawingArea Höhe anpassen  
                  // if let Some(da) \= self.drawing\_area.borrow().as\_ref() {  
                  //    da.set\_content\_height(height);  
                  // }  
                  self.obj().queue\_draw(); // Neuzeichnen anfordern  
                  self.obj().notify\_panel\_height();  
              }  
              "transparency-enabled" \=\> {  
                  let enabled: bool \= value.get().expect("Value must be bool");  
                  self.transparency\_enabled.set(enabled);  
                  self.obj().update\_transparency();  
                  self.obj().notify\_transparency\_enabled();  
              }  
              "leuchtakzent-color" \=\> {  
                  let color: Option\<gdk::RGBA\> \= value.get().expect("Value must be Option\<gdk::RGBA\>");  
                  self.leuchtakzent\_color.replace(color);  
                  self.obj().queue\_draw();  
                  self.obj().notify\_leuchtakzent\_color();  
              }  
              "leuchtakzent-intensity" \=\> {  
                  let intensity: f64 \= value.get().expect("Value must be f64");  
                  self.leuchtakzent\_intensity.set(intensity);  
                  self.obj().queue\_draw();  
                  self.obj().notify\_leuchtakzent\_intensity();  
              }  
              \_ \=\> unimplemented\!(),  
          }  
      }

      fn property(\&self, \_id: usize, pspec: \&glib::ParamSpec) \-\> glib::Value {  
          match pspec.name() {  
              "position" \=\> self.position.borrow().to\_value(),  
              "panel-height" \=\> self.panel\_height.get().to\_value(),  
              "transparency-enabled" \=\> self.transparency\_enabled.get().to\_value(),  
              "leuchtakzent-color" \=\> self.leuchtakzent\_color.borrow().to\_value(),  
              "leuchtakzent-intensity" \=\> self.leuchtakzent\_intensity.get().to\_value(),  
              \_ \=\> unimplemented\!(),  
          }  
      }  
  }  
  impl WidgetImpl for PanelWidget {  
      fn map(\&self) {  
          self.parent\_map();  
          // Sicherstellen, dass Layer Shell korrekt initialisiert ist, bevor das Fenster angezeigt wird  
          self.obj().setup\_layer\_shell();  
      }  
       fn size\_allocate(\&self, width: i32, height: i32, baseline: i32) {  
          self.parent\_size\_allocate(width, height, baseline);  
          // Ggf. Layout der internen Boxen hier anpassen oder DrawingArea Größe  
      }  
  }  
  impl WindowImpl for PanelWidget {  
      // Fenster-spezifische Implementierungen, z.B. Schließen-Verhalten  
  }  
  impl ApplicationWindowImpl for PanelWidget {}

  // Implementierung der öffentlichen und privaten Methoden für PanelWidget  
  impl super::PanelWidget {  
      fn setup\_layer\_shell(\&self) {  
          let imp \= self.imp();  
          gtk\_layer\_shell::init\_for\_window(self);  
          gtk\_layer\_shell::set\_layer(self, gtk\_layer\_shell::Layer::Top);  
          gtk\_layer\_shell::set\_keyboard\_mode(self, gtk\_layer\_shell::KeyboardMode::None); // Panels benötigen i.d.R. keinen direkten Fokus  
          gtk\_layer\_shell::auto\_exclusive\_zone\_enable(self); // Platz reservieren  
          gtk\_layer\_shell::set\_namespace(self, "NovaDEPanel");

          let position \= \*imp.position.borrow();  
          match position {  
              PanelPosition::Top \=\> {  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Top, true);  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Left, true);  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Right, true);  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Bottom, false);  
              }  
              PanelPosition::Bottom \=\> {  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Bottom, true);  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Left, true);  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Right, true);  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Top, false);  
              }  
          }  
          self.set\_default\_height(imp.panel\_height.get());  
          // Margins könnten hier auch gesetzt werden, falls gewünscht  
          // gtk\_layer\_shell::set\_margin(self, gtk\_layer\_shell::Edge::Top, 5);  
      }

      fn update\_layout(\&self) {  
          let imp \= self.imp();  
          // Entferne alle Kinder aus start\_box, center\_box, end\_box  
          while let Some(child) \= imp.start\_box.first\_child() {  
              imp.start\_box.remove(\&child);  
          }  
          while let Some(child) \= imp.center\_box.first\_child() {  
              imp.center\_box.remove(\&child);  
          }  
          while let Some(child) \= imp.end\_box.first\_child() {  
              imp.end\_box.remove(\&child);  
          }

          // Füge Module entsprechend ihrer Reihenfolge und Position hinzu  
          // Diese Logik muss verfeinert werden, um die \`order\` Eigenschaft zu berücksichtigen  
          for widget in imp.modules\_start.borrow().iter() {  
              imp.start\_box.append(widget);  
          }  
          for widget in imp.modules\_center.borrow().iter() {  
              imp.center\_box.append(widget);  
          }  
          for widget in imp.modules\_end.borrow().iter() {  
              imp.end\_box.append(widget);  
          }  
      }

      fn update\_transparency(\&self) {  
          let imp \= self.imp();  
          let visual \= if imp.transparency\_enabled.get() {  
              self.display().rgba\_visual()  
          } else {  
              None // Oder Standard-Visual  
          };  
          self.set\_visual(visual.as\_ref()); // Benötigt GdkDisplay

          // Für echte Transparenz unter Wayland muss der Compositor dies unterstützen  
          // und das Fenster muss ggf. mit einem Alpha-Kanal gezeichnet werden.  
          // CSS kann auch für Hintergrundtransparenz verwendet werden.  
          self.queue\_draw();  
      }

      // Beispiel für das Verbinden des Draw-Signals, falls benutzerdefiniertes Zeichnen  
      // fn connect\_draw\_signal(\&self) {  
      //     if let Some(da) \= self.imp().drawing\_area.borrow().as\_ref() {  
      //        da.set\_draw\_func(glib::clone\!(@weak self as panel \=\> move |\_, cr, width, height| {  
      //            panel.imp().draw\_background\_and\_accent(cr, width, height);  
      //        }));  
      //    } else { // Wenn das PanelWindow selbst zeichnet (komplexer wegen Layer Shell)  
      //        self.connect\_realize(|widget| { // Realize statt draw für Fensterhintergrund  
      //            widget.set\_decorated(false); // Wichtig für custom drawing  
      //            if widget.imp().transparency\_enabled.get() {  
      //                 if let Some(surface) \= widget.surface() {  
      //                    surface.set\_opaque\_region(None); // Versuch für Transparenz  
      //                 }  
      //            }  
      //        });  
      //        // Das direkte Zeichnen auf einem GtkApplicationWindow ist nicht trivial.  
      //        // Besser ist ein Kind-Widget (GtkDrawingArea) zu verwenden.  
      //    }  
      // }  
  }

  // Private Implementierungsmethoden  
  impl PanelWidget {  
      fn add\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>, position: ModulePosition, \_order: i32) {  
          // TODO: Ordnung berücksichtigen  
          match position {  
              ModulePosition::Start \=\> {  
                  self.imp().modules\_start.borrow\_mut().push(module.clone().upcast());  
                  self.imp().start\_box.append(module);  
              }  
              ModulePosition::Center \=\> {  
                  self.imp().modules\_center.borrow\_mut().push(module.clone().upcast());  
                  self.imp().center\_box.append(module);  
              }  
              ModulePosition::End \=\> {  
                  self.imp().modules\_end.borrow\_mut().push(module.clone().upcast());  
                  self.imp().end\_box.append(module);  
              }  
          }  
          // Signal 'module-layout-changed' emittieren  
      }

      fn remove\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>) {  
          let widget\_ptr \= module.as\_ref().to\_glib\_none().0;  
          if self.imp().modules\_start.borrow\_mut().retain(|m| m.to\_glib\_none().0\!= widget\_ptr).len() \< self.imp().modules\_start.borrow().len() {  
               self.imp().start\_box.remove(module);  
          } else if self.imp().modules\_center.borrow\_mut().retain(|m| m.to\_glib\_none().0\!= widget\_ptr).len() \< self.imp().modules\_center.borrow().len() {  
               self.imp().center\_box.remove(module);  
          } else if self.imp().modules\_end.borrow\_mut().retain(|m| m.to\_glib\_none().0\!= widget\_ptr).len() \< self.imp().modules\_end.borrow().len() {  
               self.imp().end\_box.remove(module);  
          }  
          // Signal 'module-layout-changed' emittieren  
      }  
  }

* Eigenschaften (Properties):  
  Die GObject-Eigenschaften ermöglichen die Konfiguration und Zustandsabfrage des PanelWidget. Sie werden über das glib::Properties-Makro und die install\_properties-Methode im ObjectSubclass-Trait deklariert.47  
  **Tabelle: PanelWidget Eigenschaften**

| Eigenschaftsname | Typ | Zugriff | Standardwert | Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| position | PanelPosition | Lesen/Schreiben | Top | Bildschirmkante, an der das Panel verankert ist (Oben, Unten). |
| panel-height | i32 | Lesen/Schreiben | 36 | Höhe des Panels in Pixeln (Min: 24, Max: 128). |
| transparency-enabled | bool | Lesen/Schreiben | false | Gibt an, ob Transparenzeffekte für das Panel aktiv sind. |
| leuchtakzent-color | Option\<gdk::RGBA\> | Lesen/Schreiben | None | Farbe des Leuchtakzents. Wird typischerweise vom Theming-System aktualisiert. |
| leuchtakzent-intensity | f64 | Lesen/Schreiben | 0.5 | Intensität/Opazität des Leuchtakzents (Bereich: 0.0 bis 1.0). |

\*Bedeutung der Tabelle:\* Diese Tabelle bietet eine klare, strukturierte Definition der konfigurierbaren Aspekte des Panels. Sie ist essentiell für Entwickler, um die API des Widgets zu verstehen und es in Einstellungssysteme zu integrieren. Sie adressiert direkt die Anforderung der Anfrage nach der Definition von Eigenschaften mit exakten Typen und Initialwerten.

* **Interner Zustand:**  
  * modules\_start: RefCell\<Vec\<gtk::Widget\>\>: Speichert Referenzen auf die Panel-Module im Startbereich.  
  * modules\_center: RefCell\<Vec\<gtk::Widget\>\>: Speichert Referenzen auf die Panel-Module im Mittelbereich.  
  * modules\_end: RefCell\<Vec\<gtk::Widget\>\>: Speichert Referenzen auf die Panel-Module im Endbereich.  
  * Die Verwendung von RefCell ist notwendig für die innere Veränderlichkeit innerhalb des GObject-Systems, da GObject-Methoden typischerweise \&self erhalten.51

### **2.1.4. GTK-Widget-Implementierungsstrategie**

* **Basis-Widget**: Das PanelWidget erbt von gtk::ApplicationWindow.43 Diese Wahl ist entscheidend für die Integration mit gtk4-layer-shell, da dessen Funktionen wie init\_for\_window, set\_layer, set\_anchor und set\_margin auf einem gtk::Window operieren.26  
  * Die Initialisierung der Layer-Shell-Eigenschaften (gtk\_layer\_shell::init\_for\_window(self), etc.) muss erfolgen, bevor das Fenster zum ersten Mal realisiert (mapped) wird.29  
  * gtk\_layer\_shell::set\_layer(self.as\_ref(), gtk\_layer\_shell::Layer::Top) positioniert das Panel über normalen Anwendungsfenstern.  
  * gtk\_layer\_shell::set\_keyboard\_mode(self.as\_ref(), gtk\_layer\_shell::KeyboardMode::None) ist typisch für Panels, da sie selten direkten Tastaturfokus benötigen; dieser wird von den einzelnen Modulen gehandhabt.  
  * gtk\_layer\_shell::auto\_exclusive\_zone\_enable(self.as\_ref()) sorgt dafür, dass das Panel Platz auf dem Bildschirm reserviert und andere Fenster nicht verdeckt.  
* **Internes Layout**:  
  * Das PanelWidget verwendet eine panel\_widget.ui-Datei (Composite Template 55) oder definiert sein internes Layout programmatisch.  
  * Eine Haupt-gtk::Box (main\_box) mit horizontaler Orientierung dient als primärer Container.  
  * Innerhalb dieser main\_box befinden sich drei weitere gtk::Box-Widgets: start\_box, center\_box, und end\_box.42 Diese dienen zur Aufnahme der jeweiligen Panel-Module. start\_box und end\_box haben eine feste Größe basierend auf ihrem Inhalt, während center\_box den verbleibenden Raum einnimmt und sich horizontal ausdehnt (hexpand \= true).  
  * Alternativ kann gtk::CenterBox verwendet werden, wenn die UI-Definition dies unterstützt und die Anforderungen an die Ausrichtung der Kindelemente erfüllt.63  
* **Benutzerdefiniertes Zeichnen für "Leuchtakzent" und Hintergrund**:  
  * Falls CSS (box-shadow 36) für den "Leuchtakzent" oder komplexe Hintergründe nicht ausreicht oder die gewünschte Performance nicht liefert, wird ein gtk::DrawingArea eingesetzt.34  
  * Diese DrawingArea würde als unterste Ebene im PanelWidget platziert, oder das PanelWidget (als ApplicationWindow) muss seine Hintergrundzeichnung sorgfältig handhaben. Dies kann erreicht werden, indem das Fenster selbst transparent gemacht wird (widget.set\_visual(Some(\&display.rgba\_visual())) 34) und auf einer Kind-DrawingArea gezeichnet wird.  
  * Das draw-Signal der DrawingArea wird mit cairo-rs verwendet, um den Akzent und den Hintergrund zu zeichnen. Die Transparenz wird durch cairo::Context::set\_source\_rgba und die opacity-Eigenschaft von GtkWidget gesteuert.68

### **2.1.5. Methoden und Funktionssignaturen**

Die Methoden des PanelWidget definieren seine öffentliche API und interne Logik.

* **Öffentliche API (Auszug)**:  
  * pub fn add\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>, position: ModulePosition, order: i32) noexcept;  
    * Fügt ein gtk::Widget-basiertes Modul dem Panel hinzu.  
    * position: Enum (Start, Center, End), das den Bereich im Panel angibt.  
    * order: Ein i32-Wert, der die Reihenfolge innerhalb des Bereichs bestimmt (niedrigere Werte zuerst).  
  * pub fn remove\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>) noexcept;  
    * Entfernt ein zuvor hinzugefügtes Modul aus dem Panel.  
* **Interne Methoden (Auszug)**:  
  * fn setup\_layer\_shell(\&self) noexcept;  
    * Initialisiert und konfiguriert die gtk4-layer-shell-Eigenschaften basierend auf den aktuellen Panel-Einstellungen (Position, Höhe).  
  * fn update\_layout(\&self) noexcept;  
    * Ordnet die Module innerhalb der start\_box, center\_box und end\_box neu an, basierend auf ihrer order-Eigenschaft und aktuellen Konfiguration.  
  * fn draw\_background\_and\_accent(\&self, cr: \&cairo::Context, width: i32, height: i32) noexcept;  
    * Wird von der draw-Signal-Callback-Funktion der DrawingArea aufgerufen, um den benutzerdefinierten Hintergrund und den Leuchtakzent zu zeichnen. Verwendet leuchtakzent-color und leuchtakzent-intensity.  
  * fn update\_transparency(\&self) noexcept;  
    * Passt die Visuals des Fensters an, um Transparenz zu (de-)aktivieren.

**Tabelle: PanelWidget Methoden (Auswahl)**

| Signatur | Beschreibung | const | noexcept |
| :---- | :---- | :---- | :---- |
| pub fn new(app: \&gtk::Application) \-\> Self | Konstruktor, erstellt eine neue Instanz des PanelWidget. | Nein | Nein |
| pub fn add\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>, position: ModulePosition, order: i32) | Fügt ein Widget-Modul einem bestimmten Bereich (Start, Center, End) des Panels hinzu, unter Berücksichtigung der order. | Nein | Ja |
| pub fn remove\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>) | Entfernt das angegebene Widget-Modul aus dem Panel. | Nein | Ja |
| fn setup\_layer\_shell(\&self) | Interne Methode zur Konfiguration der gtk4-layer-shell-Parameter (Anker, Layer, Exklusivzone etc.) basierend auf den Panel-Eigenschaften wie position und panel-height. | Nein | Ja |
| fn update\_layout(\&self) | Interne Methode, die das Layout der Module in den Start-, Mittel- und Endbereichen aktualisiert, z.B. nach Hinzufügen/Entfernen eines Moduls oder einer Konfigurationsänderung. | Nein | Ja |

\*Bedeutung der Tabelle:\* Diese Tabelle ist entscheidend für Entwickler, die das \`PanelWidget\` verwenden oder erweitern, da sie einen klaren API-Vertrag bereitstellt und die Kernfunktionalitäten dokumentiert. Sie erfüllt die Anforderung der Anfrage nach exakten Methodensignaturen.

### **2.1.6. Signale**

Signale ermöglichen die Kommunikation von Zustandsänderungen oder Ereignissen des PanelWidget.

* **Benutzerdefinierte Signale**:  
  * module-layout-changed:  
    * Parameter: Keine.  
    * Emission: Wird emittiert, nachdem Module hinzugefügt, entfernt oder neu angeordnet wurden.  
    * Zweck: Ermöglicht anderen UI-Komponenten oder Logikmodulen, auf Änderungen im Panel-Layout zu reagieren.  
* **Verbundene Signale**:  
  * Lauscht auf ThemeChangedEvent von domain::theming::ThemingEngine:  
    * Handler-Aktion: Aktualisiert die Eigenschaft leuchtakzent-color und andere themenabhängige visuelle Aspekte. Fordert ein Neuzeichnen des Panels an (self.queue\_draw()).  
  * Verbindet sich mit notify::gtk-theme-name und notify::gtk-application-prefer-dark-theme von gtk::Settings::default() 10:  
    * Handler-Aktion: Lädt bei Bedarf Panel-spezifisches CSS neu oder passt Stile an, um Änderungen im System-Theme oder Dark-Mode-Präferenzen Rechnung zu tragen.

**Tabelle: PanelWidget emittierte Signale**

| Signalname | Parameter | Beschreibung |
| :---- | :---- | :---- |
| module-layout-changed | Keine | Wird emittiert, wenn sich die Anordnung oder der Satz der Module im Panel ändert. |

\*\*Tabelle: \`PanelWidget\` verbundene Signale\*\*

| Quelle | Signal | Handler-Aktion |
| :---- | :---- | :---- |
| domain::theming::ThemingEngine | ThemeChangedEvent | Aktualisiert leuchtakzent-color, fordert Neuzeichnen an. |
| gtk::Settings::default() | notify::gtk-theme-name | Lädt bei Bedarf panel-spezifisches CSS neu oder passt Stile an. |
| gtk::Settings::default() | notify::gtk-application-prefer-dark-theme | Passt Stile für Dark Mode an, lädt ggf. spezifisches CSS. |

\*Bedeutung der Tabellen:\* Diese Tabellen verdeutlichen die ereignisgesteuerten Interaktionen des \`PanelWidget\`. Dies ist entscheidend für das Verständnis seines dynamischen Verhaltens und für das Debugging.

### **2.1.7. Ereignisbehandlung**

* Das PanelWidget behandelt primär interne Layout-Aktualisierungen, die durch Eigenschaftsänderungen oder das Hinzufügen/Entfernen von Modulen ausgelöst werden.  
* Mausereignisse (z.B. enter-notify-event, leave-notify-event für Tooltips auf dem Panel selbst, falls vorhanden) werden über gtk::EventControllerMotion gehandhabt.70 Das Panel selbst wird jedoch in der Regel keinen komplexen Mausinteraktionen ausgesetzt sein; diese werden von den einzelnen Modulen übernommen.  
* Tastaturereignisse werden nicht direkt vom PanelWidget verarbeitet. Der Tastaturfokus wird von den einzelnen, fokussierbaren Panel-Modulen verwaltet.

### **2.1.8. Interaktionen**

* **domain::global\_settings\_and\_state\_management**:  
  * Liest die Panel-Konfiguration (Position, Höhe, Transparenzoptionen, Liste und Reihenfolge der Module) beim Start.  
  * Beobachtet Änderungen an diesen Einstellungen (z.B. über gio::Settings 21 oder ein anwendungsspezifisches Event-System), um das Panel dynamisch zu aktualisieren. Änderungen an Eigenschaften wie position oder panel-height führen zu Aufrufen von setup\_layer\_shell und update\_layout.  
* **system::compositor**:  
  * Die Interaktion erfolgt indirekt über die gtk4-layer-shell-Bibliothek.26 Das PanelWidget deklariert sich als Layer Surface (z.B. Layer::Top), setzt Anker und Margins, um seine Position und Größe relativ zum Output zu definieren.  
* **domain::theming::ThemingEngine**:  
  * Abonniert das ThemeChangedEvent, um Design-Tokens (insbesondere für leuchtakzent-color und Hintergrund) zu erhalten und anzuwenden. Dies löst ein Neuzeichnen des Panels aus.

### **2.1.9. Ausnahmebehandlung**

Zur robusten Fehlerbehandlung wird ein spezifischer Fehlertyp für das PanelWidget definiert.

* **enum PanelWidgetError** (definiert mit thiserror 72):  
  * LayerShellInitializationFailed(String): Wird zurückgegeben oder geloggt, wenn die Initialisierung mit gtk4-layer-shell fehlschlägt (z.B. wenn der Compositor das Protokoll nicht unterstützt).  
  * SettingsReadError(String): Wenn die Panel-Konfiguration nicht gelesen werden kann.  
  * InvalidModulePosition(String): Wenn versucht wird, ein Modul an einer ungültigen Position hinzuzufügen.  
* Fehler werden über das tracing-Crate geloggt 73, um Diagnose und Debugging zu erleichtern. Kritische Fehler, die die Funktionalität des Panels verhindern (z.B. LayerShellInitializationFailed), können dazu führen, dass das Panel nicht angezeigt wird, mit einer entsprechenden Log-Meldung.

### **2.1.10. Auflösung "Untersuchungsbedarf"**

* **Best Practices für gtk4-layer-shell-Integration**:  
  * Die Initialisierung der Layer-Shell-Eigenschaften (gtk\_layer\_shell::init\_for\_window, set\_layer, set\_anchor, set\_margin, auto\_exclusive\_zone\_enable) muss erfolgen, *bevor* das Panel-Fenster zum ersten Mal realisiert/gemappt wird. Dies geschieht typischerweise im constructed-Handler oder kurz vor dem ersten present()-Aufruf.26  
  * Der Tastaturinteraktivitätsmodus sollte sorgfältig gewählt werden. Für ein typisches Panel ist gtk\_layer\_shell::KeyboardMode::None oft angemessen, da die Panel-Module selbst den Fokus handhaben. KeyboardMode::OnDemand könnte relevant sein, wenn das Panel selbst oder bestimmte nicht-interaktive Bereiche des Panels temporär Fokus benötigen könnten.29  
  * Ein eindeutiger Namespace (z.B. "novade-panel") sollte mittels gtk\_layer\_shell::set\_namespace gesetzt werden. Dies hilft dem Compositor, verschiedene Layer-Shell-Clients zu identifizieren.29  
  * Für Multi-Monitor-Setups: Das Panel kann über gtk\_layer\_shell::set\_monitor einem spezifischen Monitor zugewiesen werden. Um Panels auf allen Monitoren darzustellen, müsste für jeden Monitor eine eigene PanelWidget-Instanz erstellt und konfiguriert werden. Die Liste der Monitore ist über gdk::Display::monitors() zugänglich.74 Änderungen in der Monitorkonfiguration (An-/Abstecken) können über Signale von gdk::Display (monitor-added, monitor-removed) überwacht werden.  
* **Implementierung des konfigurierbaren "Leuchtakzents" mit Cairo/GSK**:  
  * Das PanelWidget (oder eine dedizierte Kind-gtk::DrawingArea, die unter den Modul-Containern liegt) verbindet sich mit dem draw-Signal.  
  * Im Draw-Handler (fn draw\_background\_and\_accent):  
    1. Die aktuellen Werte der Eigenschaften leuchtakzent-color (ein gdk::RGBA) und leuchtakzent-intensity (ein f64 zwischen 0.0 und 1.0) werden abgerufen.  
    2. Der cairo::Context (cr) wird verwendet.  
    3. **Hintergrund zeichnen**: Zuerst wird der Panel-Hintergrund gezeichnet. Wenn Transparenz (transparency-enabled) aktiv ist, wird cr.set\_source\_rgba() mit einem Alpha-Wert \< 1.0 verwendet. Ansonsten eine deckende Farbe gemäß Theme. Abgerundete Ecken, falls spezifiziert, werden hier berücksichtigt (z.B. mit arc\_to und line\_to Pfaden).  
    4. **Leuchtakzent-Pfad definieren**: Ein Pfad wird für den Leuchteffekt erstellt. Dies könnte eine Linie oder ein schmales Rechteck entlang der Kante des Panels sein, die dem Bildschirmzentrum zugewandt ist. Die Position hängt von der position-Eigenschaft des Panels ab (oben oder unten).  
    5. **Leuchtakzent zeichnen**:  
       * **Farbe und Intensität**: cr.set\_source\_rgba() wird mit der leuchtakzent-color und einer durch leuchtakzent-intensity modulierten Alpha-Komponente aufgerufen.  
       * **Weicher Effekt**: Um einen weichen "Glow"-Effekt zu erzielen, können verschiedene Cairo-Techniken verwendet werden:  
         * **Gradienten**: Ein cairo::LinearGradient kann erstellt werden, der von der Akzentfarbe zu einer transparenten Version derselben Farbe oder zur Hintergrundfarbe übergeht. Der Gradient wird so ausgerichtet, dass er senkrecht zur Panelkante verläuft und nach außen hin ausblendet.41  
         * **Mehrfaches Zeichnen mit Unschärfe (simuliert)**: Da Cairo keine direkte Gausssche Unschärfe für Pfade bietet, kann ein ähnlicher Effekt durch mehrfaches Zeichnen des Akzentpfades mit leicht variierenden Offsets, Größen und abnehmender Deckkraft erzielt werden. Dies ist rechenintensiv und sollte mit Bedacht eingesetzt werden.  
         * **Schatten-API (falls anwendbar)**: Obwohl Cairo keine direkte box-shadow-Entsprechung für Pfade hat, könnte man einen Schatten simulieren, indem man eine versetzte, gefärbte und leicht transparente Version des Panelrands zeichnet und darüber den eigentlichen Panelinhalt.  
       * Die gezeichneten Elemente müssen die panel-height und die Gesamtbreite des Panels berücksichtigen.  
    6. Die GSK-Rendering-Pipeline von GTK4 wird diese Cairo-Operationen effizient auf die GPU übertragen.64 Es ist wichtig, queue\_draw() nur dann aufzurufen, wenn sich visuelle Aspekte tatsächlich ändern, um unnötiges Neuzeichnen zu vermeiden.  
  * Die Transparenz des Panel-Fensters selbst wird über gtk\_widget\_set\_opacity() 68 und die korrekte Konfiguration des GDK-Visuals für RGBA-Unterstützung gehandhabt, falls der Compositor dies erfordert und unterstützt.34

### **2.1.11. Dateistruktur**

Die Implementierung des PanelWidget wird in folgendem Verzeichnisbaum organisiert:

src/  
└── ui/  
    └── shell/  
        └── panel\_widget/  
            ├── mod.rs              // Öffentliche API, GObject Wrapper (PanelWidget struct)  
            ├── imp.rs              // Private GObject Implementierung (Subclass-Logik)  
            ├── panel\_widget.ui     // (Optional) XML-Definition für Composite Template  
            └── error.rs            // (Optional) Definition von PanelWidgetError

* mod.rs: Enthält die glib::wrapper\! Makrodefinition und öffentliche Methoden, die an die imp-Struktur delegieren.  
* imp.rs: Beinhaltet die \# Struktur, die \#\[glib::object\_subclass\] Implementierung und die Implementierungen für ObjectImpl, WidgetImpl, WindowImpl, und ApplicationWindowImpl. Hier werden Eigenschaften und Signale definiert und die Kernlogik des Widgets implementiert.  
* panel\_widget.ui: Falls Composite Templates für das interne Layout des Panels (z.B. die Anordnung von start\_box, center\_box, end\_box) verwendet werden, wird die XML-Struktur hier definiert.56  
* error.rs: Definiert PanelWidgetError unter Verwendung von thiserror.

Diese Struktur fördert die Modularität und Trennung von öffentlicher Schnittstelle und Implementierungsdetails, wie es in der gtk-rs Community üblich ist.5

### ---

**2.2. Sub-Modul: ui::shell::panel\_widget::AppMenuButton**

#### **2.2.1. Übersicht und Verantwortlichkeiten**

Das AppMenuButton ist ein spezialisiertes Panel-Modul, das als gtk::MenuButton (oder eine benutzerdefinierte Ableitung davon) implementiert wird. Seine Hauptverantwortung ist die Darstellung des globalen Anwendungsmenüs der aktuell fokussierten Applikation. Hierzu muss es:

1. Den app\_id (oder eine äquivalente Kennung) des aktiven Fensters ermitteln.  
2. Basierend auf dem app\_id das gio::MenuModel der aktiven Anwendung über D-Bus abrufen.  
3. Das abgerufene Menümodell in einem gtk::PopoverMenu darstellen, das beim Klick auf den Button erscheint.  
4. Das Aussehen des Buttons dynamisch an die aktive Anwendung anpassen (z.B. Icon und/oder Name anzeigen).

Die Komplexität dieser Komponente ergibt sich aus der Notwendigkeit, mit externen Systemkomponenten (Wayland Compositor für Fensterinformationen, D-Bus für Menüdaten) zu interagieren und auf Änderungen des Fensterfokus zu reagieren.

#### **2.2.2. Visuelles Design und Theming**

* **Anzeige**: Zeigt typischerweise das Icon der aktiven Anwendung. Falls kein Icon verfügbar ist oder keine Anwendung ein Menü bereitstellt, wird ein generisches "Anwendungsmenü"-Icon oder ein Platzhaltertext angezeigt.  
* **Beschriftung**: Kann optional den Namen der aktiven Anwendung neben dem Icon anzeigen, abhängig von der Konfiguration und dem verfügbaren Platz im Panel.  
* **Styling**:  
  * Als Instanz von gtk::MenuButton oder einer benutzerdefinierten, von gtk::Button abgeleiteten Klasse, die ein Popover öffnet. Es kann als ui::components::StyledButtonWidget implementiert werden, um ein konsistentes Erscheinungsbild mit anderen Buttons im Panel zu gewährleisten.  
  * **CSS-Knoten**: button (wenn von gtk::Button abgeleitet) oder menubutton (wenn von gtk::MenuButton).  
  * **CSS-Klassen**:  
    * .app-menu-button: Allgemeine Klasse für spezifisches Styling.  
    * .active-app: Wenn ein Anwendungsmenü erfolgreich geladen wurde.  
    * .no-app-menu: Wenn kein Menü für die aktive Anwendung verfügbar ist oder keine Anwendung fokussiert ist.  
* Der Tooltip des Buttons zeigt den Namen der aktiven Anwendung an, falls nicht bereits als Label sichtbar.76

#### **2.2.3. Datenstrukturen, Eigenschaften und Zustand**

Das AppMenuButton wird als GObject-Widget implementiert.

* **GObject-Definition (AppMenuButton)**:  
  *Auszug aus src/ui/shell/panel\_widget/app\_menu\_button/imp.rs (vereinfacht):*  
  Rust  
  use gtk::glib;  
  use gtk::subclass::prelude::\*;  
  use gtk::{gio, CompositeTemplate};  
  use std::cell::{Cell, RefCell};  
  use once\_cell::sync::Lazy;  
  use zbus::Connection; // \[12\]

  // Enum für den Status der Menüabfrage  
  \#  
  pub enum MenuFetchStatus {  
      \#\[default\]  
      Idle,  
      Loading,  
      Success,  
      Error(String), // Enthält Fehlermeldung  
  }

  static APP\_MENU\_BUTTON\_PROPERTIES: Lazy\<Vec\<glib::ParamSpec\>\> \= Lazy::new(|| {  
      vec\!  
  });

  \#  
  pub struct AppMenuButton {  
      // Eigenschaften  
      active\_app\_id: RefCell\<Option\<String\>\>,  
      active\_app\_name: RefCell\<Option\<String\>\>,  
      active\_app\_icon\_name: RefCell\<Option\<String\>\>,  
      has\_menu: Cell\<bool\>,  
      menu\_fetch\_status: RefCell\<MenuFetchStatus\>,

      // Interner Zustand  
      current\_menu\_model: RefCell\<Option\<gio::MenuModel\>\>,  
      dbus\_connection: RefCell\<Option\<Connection\>\>, // Zbus-Verbindung \[12\]

      // Referenz auf das GtkMenuButton-Widget selbst (oder das Popover, falls custom)  
      menu\_button\_widget: RefCell\<Option\<gtk::MenuButton\>\>, // Wird in constructed gesetzt  
  }

  \#\[glib::object\_subclass\]  
  impl ObjectSubclass for AppMenuButton {  
      const NAME: &'static str \= "NovaDEAppMenuButton";  
      type Type \= super::AppMenuButton;  
      type ParentType \= gtk::MenuButton; // Oder gtk::Button, wenn ein Popover manuell verwaltet wird

      fn new() \-\> Self {  
          Self {  
              active\_app\_id: RefCell::new(None),  
              active\_app\_name: RefCell::new(None),  
              active\_app\_icon\_name: RefCell::new(None),  
              has\_menu: Cell::new(false),  
              menu\_fetch\_status: RefCell::new(MenuFetchStatus::Idle),  
              current\_menu\_model: RefCell::new(None),  
              dbus\_connection: RefCell::new(None),  
              menu\_button\_widget: RefCell::new(None),  
          }  
      }

      fn class\_init(klass: \&mut Self::Class) {  
          klass.install\_properties(\&APP\_MENU\_BUTTON\_PROPERTIES);  
          // CSS-Name setzen  
          klass.set\_css\_name("appmenubutton");  
      }  
  }

  impl ObjectImpl for AppMenuButton {  
      fn constructed(\&self) {  
          self.parent\_constructed();  
          let obj \= self.obj();  
          // Speichere eine Referenz auf das Widget selbst für einfachen Zugriff  
          // self.menu\_button\_widget.replace(Some(obj.clone()));

          // Initialisiere D-Bus Verbindung und abonniere aktive Fensteränderungen  
          // Dies sollte idealerweise asynchron geschehen.  
          let widget \= obj.clone();  
          glib::MainContext::default().spawn\_local(async move {  
              match Connection::session().await { // \[12\]  
                  Ok(conn) \=\> {  
                      widget.imp().dbus\_connection.replace(Some(conn));  
                      // Hier Logik zum Abonnieren von Änderungen des aktiven Fensters einfügen  
                      // z.B. über einen internen Service, der Wayland-Events verarbeitet  
                      // widget.subscribe\_to\_active\_window\_changes();  
                  }  
                  Err(e) \=\> {  
                      tracing::error\!("Failed to connect to D-Bus for AppMenuButton: {}", e);  
                      widget.imp().menu\_fetch\_status.replace(MenuFetchStatus::Error(format\!("D-Bus connection failed: {}", e)));  
                      widget.update\_button\_appearance\_and\_state();  
                  }  
              }  
          });  
          obj.update\_button\_appearance\_and\_state(); // Initiales Aussehen  
      }

      fn properties() \-\> &'static {  
          APP\_MENU\_BUTTON\_PROPERTIES.as\_ref()  
      }

      fn property(\&self, \_id: usize, pspec: \&glib::ParamSpec) \-\> glib::Value {  
          match pspec.name() {  
              "active-app-name" \=\> self.active\_app\_name.borrow().to\_value(),  
              "active-app-icon-name" \=\> self.active\_app\_icon\_name.borrow().to\_value(),  
              "has-menu" \=\> self.has\_menu.get().to\_value(),  
              \_ \=\> unimplemented\!(),  
          }  
      }  
      // set\_property ist hier nicht nötig, da die Eigenschaften Read-only sind und intern gesetzt werden.  
  }  
  impl WidgetImpl for AppMenuButton {  
      fn map(\&self) {  
          self.parent\_map();  
          // Beim Sichtbarwerden ggf. aktuellen Status neu abfragen  
          self.obj().trigger\_menu\_update\_for\_current\_app();  
      }  
  }  
  impl ButtonImpl for AppMenuButton {} // Falls ParentType gtk::Button  
  impl MenuButtonImpl for AppMenuButton {} // Falls ParentType gtk::MenuButton

* **Eigenschaften (Properties)**:  
  **Tabelle: AppMenuButton Eigenschaften**

| Eigenschaftsname | Typ | Zugriff | Standardwert | Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| active-app-name | Option\<String\> | Nur Lesen | None | Name der Anwendung, deren Menü aktuell angezeigt wird oder angezielt ist. |
| active-app-icon-name | Option\<String\> | Nur Lesen | None | Icon-Name (für Theming) der Anwendung, deren Menü angezielt ist. |
| has-menu | bool | Nur Lesen | false | true, wenn ein Menü für die aktive Anwendung verfügbar und geladen ist. |

\*Bedeutung der Tabelle:\* Definiert den beobachtbaren Zustand des \`AppMenuButton\`, nützlich für Binding oder um auf Änderungen im Menü der aktiven Anwendung zu reagieren.

* **Interner Zustand**:  
  * active\_app\_id: RefCell\<Option\<String\>\>: Speichert die ID der aktuell fokussierten Anwendung.  
  * menu\_fetch\_status: RefCell\<MenuFetchStatus\>: Verfolgt den Zustand des Menüabrufs.  
  * current\_menu\_model: RefCell\<Option\<gio::MenuModel\>\>: Hält das aktuell geladene Menümodell.  
  * dbus\_connection: RefCell\<Option\<zbus::Connection\>\>: Die D-Bus-Verbindung für Abfragen.

#### **2.2.4. GTK-Widget-Implementierung**

* Das AppMenuButton erbt von gtk::MenuButton.77 Diese Klasse bietet bereits die Funktionalität, ein Popover beim Klick anzuzeigen.  
* Das Popover wird ein gtk::PopoverMenu sein.79  
* Die Eigenschaft menu-model des gtk::MenuButton (oder des internen gtk::PopoverMenu) wird dynamisch mit dem über D-Bus abgerufenen gio::MenuModel aktualisiert.  
  * gtk::MenuButton::set\_menu\_model(Some(menu\_model))  
  * Wenn kein Menü verfügbar ist, wird gtk::MenuButton::set\_menu\_model(None) gesetzt oder das Popover deaktiviert.

#### **2.2.5. Methoden und Funktionssignaturen**

* **Öffentliche Methoden (vom Panel oder einem Dienst für aktive Fenster aufgerufen)**:  
  * pub fn update\_active\_window\_info(\&self, app\_id: Option\<String\>, window\_title: Option\<String\>, icon\_name: Option\<String\>) noexcept;  
    * Wird aufgerufen, wenn sich das aktive Fenster *oder* dessen Metadaten ändern.  
    * Speichert app\_id, window\_title, icon\_name intern.  
    * Löst trigger\_menu\_update\_for\_current\_app aus.  
    * Aktualisiert sofort das Aussehen des Buttons (Icon/Label) basierend auf icon\_name und window\_title/app\_id.  
* **Interne Methoden**:  
  * fn trigger\_menu\_update\_for\_current\_app(\&self) noexcept;  
    * Prüft, ob active\_app\_id gesetzt ist.  
    * Wenn ja, startet die asynchrone fetch\_menu\_for\_app-Operation.  
    * Setzt menu\_fetch\_status auf Loading.  
    * Aktualisiert das Button-Aussehen (z.B. Ladeindikator).  
  * async fn fetch\_menu\_for\_app(dbus\_conn: Connection, app\_id: String) \-\> Result\<gio::MenuModel, AppMenuError\>;  
    * Diese Funktion ist async und wird mit glib::MainContext::spawn\_local ausgeführt.7  
    * Versucht, das gio::MenuModel für den gegebenen app\_id über D-Bus zu beziehen (siehe 2.2.8 Interaktionen).  
    * Gibt das gio::MenuModel oder einen AppMenuError zurück.  
  * fn handle\_menu\_fetch\_result(\&self, result: Result\<gio::MenuModel, AppMenuError\>) noexcept;  
    * Wird im glib::MainContext aufgerufen, nachdem fetch\_menu\_for\_app abgeschlossen ist.  
    * Aktualisiert current\_menu\_model, has\_menu, und menu\_fetch\_status.  
    * Ruft display\_menu und update\_button\_appearance\_and\_state auf.  
  * fn display\_menu(\&self) noexcept;  
    * Setzt das current\_menu\_model auf den gtk::MenuButton.  
  * fn update\_button\_appearance\_and\_state(\&self) noexcept;  
    * Aktualisiert Icon (z.B. gtk::Image::set\_from\_icon\_name 84) und Label des gtk::MenuButton basierend auf active\_app\_icon\_name, active\_app\_name und menu\_fetch\_status.  
    * Setzt den sensitive-Zustand des Buttons (z.B. deaktiviert, wenn kein Menü geladen werden kann oder Loading).  
    * Aktualisiert die GObject-Properties (active-app-name, active-app-icon-name, has-menu) und emittiert notify Signale.

**Tabelle: AppMenuButton Methoden (Auswahl)**

| Signatur | Beschreibung | async | noexcept |
| :---- | :---- | :---- | :---- |
| pub fn update\_active\_window\_info(\&self, app\_id: Option\<String\>, window\_title: Option\<String\>, icon\_name: Option\<String\>) | Aktualisiert die Informationen über das aktive Fenster und löst ggf. eine Menüaktualisierung aus. | Nein | Ja |
| fn trigger\_menu\_update\_for\_current\_app(\&self) | Startet den Prozess zum Abrufen und Anzeigen des Menüs für die aktuell zwischengespeicherte app\_id. | Nein | Ja |
| async fn fetch\_menu\_for\_app(dbus\_conn: Connection, app\_id: String) \-\> Result\<gio::MenuModel, AppMenuError\> | Ruft asynchron das GMenuModel für die gegebene app\_id über D-Bus ab. | Ja | Nein |
| fn handle\_menu\_fetch\_result(\&self, result: Result\<gio::MenuModel, AppMenuError\>) | Verarbeitet das Ergebnis von fetch\_menu\_for\_app, aktualisiert den internen Zustand und die UI. | Nein | Ja |

#### **2.2.6. Signale**

* **Benutzerdefinierte Signale**: Keine spezifischen benutzerdefinierten Signale für diese Komponente vorgesehen. Es erbt die Signale von gtk::MenuButton (z.B. clicked, activate).  
* **Verbundene Signale**:  
  * Intern: Lauscht auf ein Signal von einem übergeordneten Dienst (z.B. innerhalb von ui::shell), das Änderungen des aktiven Fensters (app\_id, Titel, Icon) meldet.

#### **2.2.7. Ereignisbehandlung**

* Die Hauptinteraktion ist der Klick auf den Button, der durch die gtk::MenuButton-Basisklasse gehandhabt wird und das Popover mit dem Menü anzeigt.  
* Interne Reaktionen auf die Ergebnisse der asynchronen D-Bus-Menüabfrage und auf Änderungen des aktiven Fensters sind entscheidend für die dynamische Aktualisierung.

#### **2.2.8. Interaktionen**

* **system::compositor (Fensterinformationen)**:  
  * Das AppMenuButton selbst interagiert nicht direkt mit dem Compositor. Es ist auf einen Dienst innerhalb der ui::shell angewiesen, der Informationen über das aktive Fenster bereitstellt. Dieser Dienst nutzt Wayland-Protokolle.  
  * **Wayland-Protokolle**:  
    * wlr-foreign-toplevel-management-unstable-v1: Dieses Protokoll ermöglicht es einem Client (dem NovaDE-Shell-Dienst), eine Liste von Toplevel-Fenstern zu erhalten und deren Zustände (inkl. app\_id, title, state) zu überwachen. Der Dienst würde das activated-Ereignis nutzen, um das aktuell fokussierte Fenster zu identifizieren.85  
    * ext-foreign-toplevel-list-v1: Ein alternatives oder ergänzendes Protokoll, das ebenfalls zur Auflistung von Toplevel-Fenstern dient.85  
  * Die Implementierung dieser Wayland-Client-Logik sollte zentral in einem ui::shell-Modul erfolgen (z.B. ui::shell::active\_window\_service) und nicht im AppMenuButton selbst, um Redundanz zu vermeiden und die Komplexität zu kapseln. Dieser Dienst würde dann ein internes Signal oder einen Event für das AppMenuButton bereitstellen.  
* **D-Bus (Menüabruf)**:  
  * Sobald der app\_id des aktiven Fensters bekannt ist, wird versucht, dessen Menümodell über D-Bus abzurufen.  
  * **Primärer Mechanismus (org.gtk.Menus)**:  
    * GTK4-Anwendungen, die GApplication verwenden, exportieren ihre Menüs (typischerweise GMenuModel für Anwendungsmenü und Menüleiste) oft über D-Bus unter ihrem eigenen Bus-Namen (welcher dem app\_id entspricht, z.B. org.gnome.TextEditor).  
    * Der Standard-Objektpfad für das Menü ist oft /org/gtk/menus/menubar oder ein ähnlicher, durch GApplication festgelegter Pfad.91  
    * Die Schnittstelle ist org.gtk.Menus.  
    * gio::DBusMenuModel::new(bus\_name, object\_path) kann verwendet werden, um ein GMenuModel direkt von einem D-Bus-Dienst zu erstellen, was die Details der Methodenaufrufe abstrahiert.21  
  * **Fallback-Mechanismus (com.canonical.AppMenu.Registrar)**:  
    * Ein älterer Mechanismus, der von Unity verwendet wurde. Anwendungen registrieren ihre Fenster-ID und den D-Bus-Pfad zu ihrem Menü bei diesem Dienst.15  
    * Dienstname: com.canonical.AppMenu.Registrar  
    * Objektpfad: /com/canonical/AppMenu/Registrar  
    * Schnittstelle: com.canonical.AppMenu.Registrar  
    * Methode: GetMenuForWindow(window\_id\_uint32). Dies ist problematisch in einer reinen Wayland-Umgebung, da X11-Fenster-IDs nicht direkt verfügbar oder relevant sind. Eine Wayland-kompatible Anwendung müsste ihren Menüpfad auf andere Weise bekannt geben.  
  * **D-Bus-Client-Implementierung**: Das zbus-Crate wird verwendet, um D-Bus-Proxies zu erstellen und Methoden aufzurufen.12  
    * Ein zbus::Proxy wird für den Zieldienst erstellt (entweder der app\_id oder com.canonical.AppMenu.Registrar).  
    * Die entsprechenden Methoden werden asynchron aufgerufen.  
    * Das Ergebnis (oft ein Pfad zu einem DBusMenu-Objekt) wird verwendet, um ein gio::MenuModel zu instanziieren, typischerweise mit gio::DBusMenuModel.

**Tabelle: AppMenuButton D-Bus Interaktionen**

| Interaktion | Zieldienst (Primär) | Objektpfad (Primär) | Schnittstelle (Primär) | Methode/Eigenschaft (Primär) | Zieldienst (Fallback) | Objektpfad (Fallback) | Schnittstelle (Fallback) | Methode (Fallback) |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| GMenuModel für aktive Anwendung abrufen | \[app\_id\_der\_aktiven\_Anwendung\] | /org/gtk/menus/menubar (oder Konvention) | org.gtk.Menus (oder org.freedesktop.DBus.Properties) | gio::DBusMenuModel::new(bus\_name, object\_path) (abstrahiert Methodenaufrufe) | com.canonical.AppMenu.Registrar | /com/canonical/AppMenu/Registrar | com.canonical.AppMenu.Registrar | GetMenuForWindow (XID-abhängig) oder App registriert Menüpfad |

\*Bedeutung der Tabelle:\* Verdeutlicht die komplexen D-Bus-Interaktionen, die für das Abrufen von Anwendungsmenüs erforderlich sind. Dies ist entscheidend für die Implementierung und das Debugging, insbesondere angesichts der verschiedenen Mechanismen, über die Menüs bereitgestellt werden können.

#### **2.2.9. Ausnahmebehandlung**

* **enum AppMenuError** (definiert mit thiserror 72):  
  * WaylandError(String): Fehler beim Abrufen von Informationen zum aktiven Fenster.  
  * DBusConnectionError(zbus::Error): Fehler bei der D-Bus-Kommunikation.  
  * MenuServiceUnavailable(String): Der D-Bus-Dienst für die Anwendung (z.B. app\_id oder AppMenu.Registrar) ist nicht erreichbar.  
  * MenuNotFound(String): Die Anwendung (app\_id) exportiert kein bekanntes Menü oder das Menü ist leer.  
  * MenuModelParseError(String): Fehler beim Parsen oder Interpretieren der Menüdaten.  
* Im Fehlerfall zeigt der AppMenuButton einen deaktivierten Zustand oder ein generisches Icon an. Fehlerdetails werden über tracing geloggt.73

#### **2.2.10. Auflösung "Untersuchungsbedarf"**

* **Zuverlässige Methode zur Ermittlung des aktiven Fensters/app\_id unter Wayland**:  
  * Die bevorzugte Methode ist die Verwendung des wlr-foreign-toplevel-management-unstable-v1-Protokolls.86 Ein zentraler Shell-Dienst (nicht der AppMenuButton selbst) agiert als Client dieses Protokolls.  
  * Der Dienst bindet sich an den globalen zwlr\_foreign\_toplevel\_manager\_v1.  
  * Für jedes gemeldete Toplevel (zwlr\_foreign\_toplevel\_handle\_v1) lauscht der Dienst auf die Ereignisse app\_id, title und state.  
  * Das state-Ereignis enthält Flags, darunter activated. Das Toplevel mit dem activated-Flag ist das aktuell fokussierte Fenster.  
  * Die smithay-client-toolkit 85 könnte Rust-Abstraktionen für dieses Protokoll bereitstellen. Falls nicht, ist die direkte Verwendung von wayland-client mit den wayland-protocols-Bindings (speziell wlr-protocols) notwendig.89  
  * Dieser zentrale Dienst stellt dann die Informationen über das aktive Fenster (insbesondere app\_id, title, icon\_name) dem AppMenuButton und anderen interessierten UI-Komponenten über ein internes Event-System oder Signale zur Verfügung.  
* **Ermittlung und Konsumierung von GMenuModel via D-Bus**:  
  * **Primärer Pfad (für GTK4-Anwendungen)**: Moderne GTK-Anwendungen, die GApplication verwenden, exportieren ihr Hauptmenü (GMenuModel) typischerweise über D-Bus auf ihrem eigenen, durch den app\_id bestimmten Bus-Namen. Der Objektpfad ist oft standardisiert, z.B. /org/gtk/menus/menubar oder ein anderer Pfad, den GApplication für diesen Zweck nutzt.91 Ein gio::DBusMenuModel wird dann mit diesem Bus-Namen und Objektpfad instanziiert, um das Menümodell zu erhalten.21  
  * **Fallback (StatusNotifierItem)**: Falls eine Anwendung ein StatusNotifierItem bereitstellt, kann dessen Menu-Eigenschaft einen D-Bus-Objektpfad zu einem Menü (oft im com.canonical.dbusmenu-Format) enthalten.102 Dies ist relevant, wenn die Anwendung primär über ein Tray-Icon interagiert.  
  * **Fallback (AppMenu Registrar)**: Der com.canonical.AppMenu.Registrar D-Bus-Dienst ist ein älterer Mechanismus.15 Seine Verwendung in einer reinen Wayland-Umgebung ist aufgrund der Abhängigkeit von X11-Fenster-IDs problematisch und sollte nur als letzte Option in Betracht gezogen werden, falls Anwendungen keine anderen Mechanismen anbieten.  
  * **Implementierungsentscheidung**: Die Strategie sollte sein, zuerst den primären Pfad (org.gtk.Menus auf dem app\_id-Bus) zu versuchen. Schlägt dies fehl und ist ein StatusNotifierItem für die App vorhanden, kann dessen Menüpfad versucht werden. Der AppMenuRegistrar wird aufgrund seiner X11-Lastigkeit tendenziell vermieden.  
  * Das AppMenuButton verwendet das erhaltene gio::MenuModel, um seinen internen gtk::PopoverMenu zu füllen.79

Die Implementierung des AppMenuButton erfordert eine sorgfältige Orchestrierung asynchroner Operationen für Wayland-Events und D-Bus-Aufrufe, um die UI reaktionsfähig zu halten (glib::MainContext::spawn\_local 7). Fehlerzustände (z.B. keine aktive Anwendung, keine Menüdaten, D-Bus-Fehler) müssen robust gehandhabt und dem Benutzer klar signalisiert werden (z.B. durch ein deaktiviertes oder generisches Icon).

#### **2.2.11. Dateistruktur**

src/  
└── ui/  
    └── shell/  
        └── panel\_widget/  
            └── app\_menu\_button/  
                ├── mod.rs          // Öffentliche API, GObject Wrapper (AppMenuButton struct)  
                ├── imp.rs          // Private GObject Implementierung  
                ├── dbus.rs         // Logik für D-Bus Interaktionen (Menüabruf)  
                └── error.rs        // Definition von AppMenuError

Diese Struktur kapselt die Komplexität des AppMenuButton und trennt die D-Bus-Logik klar ab.  
---

**(Hinweis: Die detaillierte Ausarbeitung weiterer Submodule des PanelWidget wie WorkspaceIndicatorWidget, ClockDateTimeWidget, SystemTrayEquivalentWidget etc. würde einem ähnlichen Detaillierungsgrad folgen und die spezifischen "Untersuchungsbedarfe" adressieren. Insbesondere das SystemTrayEquivalentWidget erfordert eine tiefgreifende Auseinandersetzung mit der StatusNotifierItem-Spezifikation und deren D-Bus-Implementierung mittels zbus, wie in der Gliederung angedeutet.102)**  
Die Implementierung eines SystemTrayEquivalentWidget ist ein komplexes Unterfangen, da Wayland selbst kein natives "System Tray"-Protokoll definiert. Die De-facto-Standardlösung ist die StatusNotifierItem (SNI) Spezifikation von Freedesktop.org, die auf D-Bus basiert.102  
Ein SystemTrayEquivalentWidget müsste folgende Kernkomponenten umfassen:

1. **StatusNotifierHost-Registrierung**: Das Panel (oder dieses Widget) muss sich als org.freedesktop.StatusNotifierHost auf dem Session-Bus registrieren. Dies signalisiert dem StatusNotifierWatcher, dass ein Host für Items vorhanden ist.106 Die Registrierung erfolgt typischerweise durch das Anfordern eines eindeutigen Bus-Namens (z.B. org.freedesktop.StatusNotifierHost-PID oder org.freedesktop.StatusNotifierHost-NovaDE).  
2. **Interaktion mit StatusNotifierWatcher**:  
   * Der StatusNotifierWatcher (org.freedesktop.StatusNotifierWatcher) ist der zentrale Dienst zur Verwaltung von SNIs.102  
   * Das Widget muss diesen Watcher auf dem D-Bus finden (Standardname org.freedesktop.StatusNotifierWatcher, Pfad /org/freedesktop/StatusNotifierWatcher).  
   * Es muss die Methode RegisterStatusNotifierHost am Watcher aufrufen, um sich selbst als Host zu registrieren.  
   * Es muss die Eigenschaft RegisteredStatusNotifierItems des Watchers abfragen, um eine initiale Liste aller bereits vorhandenen SNIs zu erhalten.  
   * Es muss die Signale StatusNotifierItemRegistered und StatusNotifierItemUnregistered des Watchers abonnieren, um dynamisch auf neue oder entfernte SNIs zu reagieren. zbus wird hierfür verwendet, um Signal-Handler einzurichten.109  
3. **Interaktion mit einzelnen StatusNotifierItems**:  
   * Für jeden von StatusNotifierWatcher gemeldeten Dienstnamen eines SNI (z.B. org.freedesktop.StatusNotifierItem-PID-ID) muss ein zbus::Proxy erstellt werden.17  
   * Über diesen Proxy werden die Eigenschaften des SNI ausgelesen: Category, Id, Title, Status, WindowId, IconName, IconPixmap, OverlayIconName, OverlayIconPixmap, AttentionIconName, AttentionIconPixmap, AttentionMovieName, ToolTip, ItemIsMenu, Menu.102  
   * Signale des SNI (z.B. NewIcon, NewStatus, NewToolTip, NewMenu) müssen abonniert werden, um auf Änderungen zu reagieren und die Darstellung des entsprechenden Indikator-Widgets im Panel zu aktualisieren.16  
4. **Darstellung der Indikatoren**:  
   * Für jedes aktive SNI wird ein kleines Widget im SystemTrayEquivalentWidget (das selbst eine gtk::Box oder ein ähnlicher Container ist) angezeigt.  
   * **Icon**: IconName wird verwendet, um ein themenbasiertes Icon über gtk::Image::from\_icon\_name zu laden.84 Falls IconPixmap bereitgestellt wird, müssen die Rohpixeldaten (oft ein Array von Tupeln (width, height, data)) in ein gdk\_pixbuf::Pixbuf konvertiert werden (z.B. mit Pixbuf::from\_mut\_slice oder PixbufLoader, falls die Daten gestreamt ankommen, was hier aber unwahrscheinlich ist) und dann in einem gtk::Image angezeigt werden.117  
   * **Tooltip**: Die ToolTip-Eigenschaft des SNI (eine Struktur mit Titel, Text, Icon) wird verwendet, um einen Tooltip für das Indikator-Widget mittels gtk::Widget::set\_tooltip\_markup oder gtk::Widget::set\_tooltip\_text zu setzen.76  
   * **Status**: Die Status-Eigenschaft (Passive, Active, NeedsAttention) kann verwendet werden, um das Aussehen des Indikators anzupassen (z.B. Hervorhebung bei NeedsAttention).  
5. **Interaktion mit den Indikatoren**:  
   * **Linksklick (Activate)**: Ein Klick auf das Indikator-Widget ruft die Activate(x, y)-Methode des SNI über D-Bus auf.103  
   * **Rechtsklick (ContextMenu)**: Ein Rechtsklick ruft die ContextMenu(x, y)-Methode des SNI auf. Wenn die ItemIsMenu-Eigenschaft true ist und die Menu-Eigenschaft einen gültigen D-Bus-Pfad zu einem com.canonical.dbusmenu-Objekt enthält, wird dieses Menü abgerufen (mittels gio::DBusMenuModel 96) und als gtk::PopoverMenu angezeigt.79  
   * **Scrollen**: Mausrad-Events über dem Indikator rufen die Scroll(delta, orientation)-Methode des SNI auf.  
6. **Asynchronität**: Alle D-Bus-Interaktionen (Methodenaufrufe, Signal-Handling) müssen asynchron mit glib::MainContext::spawn\_local erfolgen, um die UI nicht zu blockieren.7

Die "Alternativen unter Wayland" 104 beziehen sich darauf, dass Wayland selbst kein Tray-Protokoll spezifiziert. StatusNotifierItem ist die etablierte D-Bus-basierte Lösung. Einige Desktop-Umgebungen könnten eigene Protokolle haben, aber für eine breite Kompatibilität ist SNI der Standard. Die Herausforderung besteht darin, dass nicht alle Anwendungen SNI korrekt oder vollständig implementieren.

## ---

**3\. Übergreifende Belange – Initiale Spezifikationen**

Dieser Abschnitt definiert initiale Strategien für Aspekte, die mehrere UI-Module betreffen und eine konsistente Handhabung erfordern.

### **3.1. UI-Zustandsverwaltungsstrategie**

Die Verwaltung des UI-Zustands ist entscheidend für eine reaktive und wartbare Benutzeroberfläche. In NovaDE wird ein mehrschichtiger Ansatz verfolgt, der die Stärken von GObject mit Rust-Idiomen kombiniert:

* **GObject-Eigenschaften für Widget-Zustand**:  
  * Der primäre Mechanismus zur Verwaltung des Zustands einzelner Widgets sind GObject-Eigenschaften. Diese werden mit dem glib::Properties-Derive-Makro und klass.install\_properties() in der ObjectSubclass-Implementierung definiert.47  
  * Beispiel: Die panel-height-Eigenschaft des PanelWidget.  
  * Änderungen an diesen Eigenschaften lösen automatisch "notify::property-name"-Signale aus, auf die andere Teile der UI oder die interne Logik des Widgets reagieren können. Explizite Benachrichtigung kann mit self.obj().notify\_propertyName() erzwungen werden, falls die automatische Benachrichtigung nicht ausreicht oder benutzerdefinierte Logik vor der Benachrichtigung ausgeführt werden muss.  
* **Benutzerdefinierte GObject-Signale**:  
  * Für komplexere Zustandsänderungen oder Ereignisse, die nicht direkt durch eine einzelne Eigenschaftsänderung abgebildet werden, werden benutzerdefinierte GObject-Signale definiert.115  
  * Beispiel: Das module-layout-changed-Signal des PanelWidget.  
  * Signale werden in ObjectImpl::signals() definiert und können mit self.obj().emit\_by\_name::\<()\>("signal-name", &\[\&param1, \&param2\]) ausgelöst werden.  
* **Rc\<RefCell\<T\>\> für gemeinsam genutzten UI-Zustand**:  
  * Für UI-Zustände, die von mehreren Widgets gemeinsam genutzt werden und nicht in einer direkten GObject-Eltern-Kind-Beziehung stehen oder nicht sinnvoll als globale GSettings abgebildet werden können, wird das Rust-Idiom Rc\<RefCell\<T\>\> verwendet.51  
  * Rc ermöglicht das Teilen des Besitzes im Single-Threaded-Kontext des GTK-Mainloops.  
  * RefCell ermöglicht die innere Veränderlichkeit (mutable borrows zur Laufzeit geprüft).  
  * Dies ist nützlich für z.B. einen gemeinsam genutzten D-Bus-Verbindungsmanager, der von mehreren UI-Komponenten verwendet wird, oder für View-Modelle, die Daten für mehrere, lose gekoppelte Widgets halten.  
  * Vorsicht ist geboten, um Zyklen von Rc-Referenzen zu vermeiden, die zu Speicherlecks führen können. Weak\<RefCell\<T\>\> kann hier Abhilfe schaffen.  
* **Datenbindung (Property Binding)**:  
  * GObject-Eigenschaftsbindungen (GObject.bind\_property()) werden intensiv genutzt, um UI-Elemente direkt an Zustandseigenschaften zu koppeln. Dies reduziert manuellen Synchronisationscode und fördert eine deklarative UI-Logik.  
  * Beispiel: Die label-Eigenschaft eines gtk::Label könnte an eine String-Eigenschaft eines View-Modell-Objekts gebunden werden.  
* **Adaption von MVVM/MVC-Mustern**:  
  * Obwohl GTK nicht explizit für ein bestimmtes UI-Architekturmuster wie MVVM oder MVC ausgelegt ist, können deren Prinzipien adaptiert werden:  
    * **Model**: Repräsentiert die Anwendungsdaten und Geschäftslogik (primär in der domain-Schicht, aber auch UI-spezifische Zustandsmodelle).  
    * **View**: Die GTK-Widgets selbst.  
    * **ViewModel/Controller**: GObject-Instanzen, die UI-spezifische Logik und Zustand halten (ViewModel-Aspekt) und Benutzerinteraktionen verarbeiten (Controller-Aspekt). GObject-Eigenschaften des ViewModels werden an die View (Widgets) gebunden. Methoden im ViewModel/Controller reagieren auf UI-Events und interagieren mit dem Model.  
* **Kommunikation mit unteren Schichten**:  
  * Zustandsänderungen, die von der domain- oder system-Schicht ausgehen (z.B. durch Ereignisse oder Callbacks von asynchronen Operationen), werden in UI-Zustandsaktualisierungen übersetzt.  
  * Dies geschieht typischerweise innerhalb von Closures, die mit glib::MainContext::spawn\_local auf dem UI-Thread ausgeführt werden, um Thread-Sicherheit zu gewährleisten.7  
  * Beispiel: Ein NetworkStatusChangedEvent aus der system-Schicht könnte die icon-name-Eigenschaft eines NetworkIndicatorWidget aktualisieren.

Dieser Ansatz ermöglicht eine klare Trennung der Belange, nutzt die Stärken des GObject-Systems für Widget-spezifischen Zustand und bietet gleichzeitig flexible Rust-basierte Lösungen für komplexere oder gemeinsam genutzte UI-Zustände.

### **3.2. Fehlerbehandlungs-Framework für die UI-Schicht**

Eine konsistente und benutzerfreundliche Fehlerbehandlung ist unerlässlich.

* **Fehlerdefinition mit thiserror**:  
  * Für jedes Hauptmodul der UI-Schicht (z.B. ui::shell, ui::control\_center) und ggf. für komplexe Submodule (z.B. AppMenuButton) werden spezifische Error-Enums mit thiserror::Error definiert.72 Beispiel: PanelWidgetError, AppMenuError.  
  * Diese modul-spezifischen Fehler werden in einem übergeordneten UI-Fehler-Enum (z.B. NovaUiError) zusammengefasst, ebenfalls unter Verwendung von \#\[from\]-Attributen in thiserror für eine einfache Konvertierung.  
    Rust  
    // Beispiel: src/ui/error.rs  
    use thiserror::Error;

    \#  
    pub enum PanelWidgetError {  
        \#\[error("Layer shell initialization failed: {0}")\]  
        LayerShellInitializationFailed(String),  
        // Weitere Panel-spezifische Fehler  
    }

    \#  
    pub enum AppMenuError {  
        \#\[error("Failed to get active window info from Wayland: {0}")\]  
        WaylandError(String),  
        \#  
        DBusConnectionError(\#\[from\] zbus::Error),  
        \#\[error("Menu service for app '{0}' unavailable")\]  
        MenuServiceUnavailable(String),  
        \#\[error("Menu not found for app '{0}'")\]  
        MenuNotFound(String),  
    }

    \#  
    pub enum NovaUiError {  
        \#\[error("Panel widget error: {0}")\]  
        Panel(\#\[from\] PanelWidgetError),  
        \#\[error("AppMenu button error: {0}")\]  
        AppMenu(\#\[from\] AppMenuError),  
        \#  
        Theming(String), // Fehler von ui::theming\_gtk  
        \#\[error("I/O error: {0}")\]  
        Io(\#\[from\] std::io::Error),  
        // Weitere Fehlerkategorien  
    }

* **Fehlerdarstellung**:  
  * **Kritische Fehler**: Fehler, die die grundlegende Funktionalität einer Komponente oder der UI stark beeinträchtigen (z.B. D-Bus-Verbindung nicht möglich, Layer-Shell-Initialisierung fehlgeschlagen), werden dem Benutzer über ein gtk::AlertDialog mitgeteilt. Der Dialog sollte eine klare Fehlermeldung und ggf. Vorschläge zur Fehlerbehebung oder einen Hinweis auf Log-Dateien enthalten.  
  * **Nicht-kritische Fehler**: Weniger schwerwiegende Fehler (z.B. ein einzelnes Panel-Modul kann nicht geladen werden, eine Einstellung kann nicht gelesen werden) werden als NotificationPopupWidget (siehe ui::notifications\_frontend) oder durch eine Zustandsänderung im Widget selbst (z.B. ausgegrautes Icon, Fehlermeldung im Tooltip) angezeigt.  
  * Fehlermeldungen für den Benutzer werden internationalisiert (i18n).  
* **Fehlerpropagation**: Fehler aus unteren Schichten (domain, system) werden in entsprechende NovaUiError-Varianten umgewandelt und nach oben propagiert oder an der Stelle behandelt, an der sie für die UI relevant werden.

### **3.3. Logging-Strategie**

Strukturiertes Logging ist für Diagnose und Debugging unerlässlich.

* **Bibliothek**: Das tracing-Crate wird für alle Logging-Aufgaben in der UI-Schicht verwendet.73  
* **Log-Level**:  
  * trace\!: Sehr detaillierte Informationen für tiefgreifendes Debugging (z.B. einzelne D-Bus-Nachrichten, detaillierte Widget-Zustandsänderungen). Standardmäßig deaktiviert.  
  * debug\!: Informationen, die für das Debugging nützlich sind (z.B. Erstellung von Widgets, Aufruf wichtiger interner Methoden, empfangene Ereignisse).  
  * info\!: Allgemeine Informationen über den Betrieb (z.B. Modul geladen, Einstellung geändert).  
  * warn\!: Unerwartete, aber nicht unbedingt fehlerhafte Zustände (z.B. optionale Konfigurationsdatei nicht gefunden, Fallback-Verhalten aktiviert).  
  * error\!: Fehlerzustände, die die Funktionalität beeinträchtigen (z.B. D-Bus-Aufruf fehlgeschlagen, Widget konnte nicht erstellt werden). Details zum Fehlerobjekt werden mitgeloggt.  
* **Strukturierte Felder**: Log-Nachrichten sollen relevante Kontextinformationen als strukturierte Felder enthalten.  
  * Beispiel: tracing::debug\!(widget\_name \= %self.widget\_name(), event \=?event\_type, "Event received");  
* **Span-Nutzung**: tracing::span\! wird verwendet, um wichtige Operationen oder Lebenszyklen von Komponenten zu umfassen, insbesondere bei asynchronen Abläufen.  
* **Konfiguration**:  
  * Die Konfiguration des tracing-Subscribers (z.B. tracing\_subscriber::fmt für Konsolenausgabe oder tracing\_journald für systemd-journal-Integration) erfolgt im Hauptanwendungseinstiegspunkt (main.rs).  
  * Die Standard-Logstufe für Entwicklungs-Builds ist DEBUG, für Release-Builds INFO. Die Logstufe kann zur Laufzeit über Umgebungsvariablen (z.B. RUST\_LOG) angepasst werden.

### **3.4. Initiales Teststrategie-Framework**

Eine mehrschichtige Teststrategie stellt die Qualität und Korrektheit der UI-Schicht sicher.

* **Unit-Tests**:  
  * Fokus: Testen von isolierter Logik innerhalb von UI-Komponenten, die nicht direkt vom GTK-Rendering oder \-Eventloop abhängt (z.B. Hilfsfunktionen, Datenkonvertierungslogik, Zustandsmanagement-Helfer).  
  * Werkzeuge: Standard Rust \#\[test\], Mocking-Bibliotheken (z.B. mockall) für Abhängigkeiten zu unteren Schichten oder externen Diensten.  
* **Widget-Tests**:  
  * Fokus: Testen des Verhaltens und Zustands einzelner GTK-Widgets und benutzerdefinierter GObject-Komponenten.  
  * Werkzeuge:  
    * gtk::test Namespace: Bietet Funktionen zum Initialisieren von GTK in Testumgebungen.  
    * Programmatische Interaktion: Simulieren von Signalen (z.B. widget.emit\_by\_name::\<()\>("clicked", &)), Setzen und Abfragen von GObject-Eigenschaften.  
    * Inspektion: Überprüfung von Widget-Zuständen (z.B. label.text(), button.is\_sensitive()).  
    * GTK-Inspektionswerkzeuge und Accessibility-APIs (ATK) können programmatisch genutzt werden, um Widget-Zustände und \-Eigenschaften zu überprüfen.122 Die Evaluierung von Frameworks wie gtk4-rs-test-utils (falls existent und passend) oder ähnlichen Ansätzen ist Teil des Untersuchungsbedarfs.  
* **Accessibility-Tests**:  
  * Fokus: Sicherstellen, dass UI-Komponenten für assistive Technologien zugänglich sind.  
  * Werkzeuge: Überprüfung von ATK-Eigenschaften (Rolle, Name, Beschreibung, Zustand) der Widgets. Manuelle Tests mit Screenreadern (z.B. Orca) sind ebenfalls notwendig. gtk::Accessible.23  
* **Visuelle Regressionstests**: (Zur Evaluierung)  
  * Fokus: Erkennen von unbeabsichtigten visuellen Änderungen in der UI.  
  * Werkzeuge: Evaluierung von Werkzeugen für den visuellen Vergleich von UI-Zuständen (Screenshots). Dies ist oft aufwendig und wird initial möglicherweise zurückgestellt.  
* **Integrations-/End-to-End-Tests**: (Herausfordernd, für kritische Pfade)  
  * Fokus: Testen des Zusammenspiels mehrerer UI-Komponenten und deren Interaktion mit unteren Schichten.  
  * Werkzeuge: Simulation von Benutzerinteraktionen auf Wayland-Ebene (z.B. mit Tools wie ydotool oder spezialisierten Test-Frameworks, falls verfügbar und integrierbar). Überprüfung des Systemverhaltens. Dies ist sehr komplex und wird nur für kritische User Journeys in Betracht gezogen.

### **3.5. Richtlinien für Performance-Optimierung und Profiling**

Die Sicherstellung einer performanten UI ist ein Kernziel.

* **Profiling-Werkzeuge**:  
  * **Rust-spezifisch**: perf unter Linux, cargo flamegraph, tracing mit tracing-flame für CPU-Profiling. Speicher-Profiler wie heaptrack oder Valgrind (mit Massif) können zur Analyse des Speicherverbrauchs herangezogen werden.  
  * **GTK4-spezifisch**: Der GTK Inspector enthält einen Profiler, der Rendering-Zeiten und Widget-Updates visualisiert. GSK-spezifische Debug-Flags (GSK\_DEBUG) können Aufschluss über Rendering-Pfade geben.  
* **Optimierungsbereiche**:  
  * **Widget-Zeichnung**: Bei benutzerdefinierten Zeichnungen mit Cairo (GtkDrawingArea) darauf achten, nur die notwendigen Bereiche neu zu zeichnen (gtk\_widget\_queue\_draw\_area). Komplexität der Zeichenoperationen minimieren.  
  * **CSS-Anwendung**: CSS-Selektoren einfach halten. Komplexe Selektoren und Regeln können die Performance beeinträchtigen. Effiziente Aktualisierung von CSS bei Theme-Wechseln.10  
  * **Datenbindung**: Übermäßige Nutzung von GObject-Property-Bindings oder zu häufige Benachrichtigungen bei kleinen Änderungen können zu Performance-Engpässen führen. Änderungen ggf. bündeln.  
  * **Layout-Performance**: Vermeidung unnötig tiefer Widget-Hierarchien. Effiziente Nutzung von Layout-Managern wie GtkBox und GtkGrid.  
  * **Asynchrone Operationen**: Konsequente Nutzung von glib::MainContext::spawn\_local für alle potenziell blockierenden Operationen (Netzwerk, Datei-I/O, aufwändige Berechnungen in der Domänenschicht), um UI-Blockaden zu verhindern.7 Visuelles Feedback (Spinner, Fortschrittsbalken) für laufende Operationen bereitstellen.  
* **Allgemeine Rust-Optimierungen**: Zero-Cost-Abstraktionen nutzen, unnötige Allokationen vermeiden, effiziente Datenstrukturen wählen.24

Performance-Messungen und \-Optimierungen sollten ein integraler Bestandteil des Entwicklungsprozesses sein, nicht eine nachträgliche Maßnahme.

## **4\. Plan für nachfolgende UI-Layer-Module**

### **4.1. Priorisierung für nächste Module**

Nach der initialen Implementierung und Stabilisierung des PanelWidget und des AppMenuButton sowie der grundlegenden übergreifenden Frameworks (Theming, State Management, Error Handling, Logging) werden die UI-Module in folgender logischer Reihenfolge priorisiert:

1. **Weitere Kern-Panel-Module (ui::shell)**:  
   * WorkspaceIndicatorWidget: Essentiell für die Workspace-Navigation.  
   * ClockDateTimeWidget: Grundlegende Benutzerinformation.  
   * SystemTrayEquivalentWidget: Kritisch für die Integration von Drittanbieter-Anwendungen. Aufgrund seiner Komplexität (siehe oben) wird hierfür frühzeitig mit der Detailplanung und Prototyping begonnen.  
   * QuickSettingsButtonWidget und NotificationCenterButtonWidget: Wichtige Zugriffspunkte für Systemfunktionen.  
   * Weitere Indikatoren (NetworkIndicatorWidget, PowerIndicatorWidget, AudioIndicatorWidget).  
2. **Ausklappbare Panel-Inhalte (ui::shell)**:  
   * QuickSettingsPanelWidget: Wird vom QuickSettingsButtonWidget geöffnet.  
   * NotificationCenterPanelWidget: Wird vom NotificationCenterButtonWidget geöffnet und interagiert mit ui::notifications\_frontend.  
3. **Weitere Shell-Komponenten (ui::shell)**:  
   * SmartTabBarWidget  
   * WorkspaceSwitcherWidget  
   * QuickActionDockWidget  
4. **Systemeinstellungsanwendung (ui::control\_center)**:  
   * Dies ist eine größere, eigenständige Anwendung und wird parallel zu weniger kritischen Shell-Komponenten entwickelt, sobald die Kern-Shell-Interaktionen stabil sind.  
5. **Spezifische UI-Frontends und Widgets**:  
   * ui::notifications\_frontend (Popups)  
   * ui::widgets (Sidebar-Widgets)  
   * ui::window\_manager\_frontend  
   * ui::speed\_dial  
   * ui::command\_palette

Diese Priorisierung zielt darauf ab, schnell einen funktionalen Kern der Desktop-Shell zu etablieren und dann schrittweise weitere Funktionen und Anwendungen hinzuzufügen.

### **4.2. Identifizierte Abhängigkeiten und Parallelisierungsmöglichkeiten**

* **Abhängigkeiten**:  
  * Alle Panel-Module hängen von einem stabilen PanelWidget und dessen API ab.  
  * AppMenuButton und SystemTrayEquivalentWidget haben starke Abhängigkeiten von D-Bus-Interaktionen und Wayland-Protokollen (bzw. den Abstraktionsdiensten dafür).  
  * NetworkIndicatorWidget, PowerIndicatorWidget, AudioIndicatorWidget hängen von den entsprechenden D-Bus-Schnittstellen der system-Schicht ab.  
  * NotificationCenterPanelWidget hängt von domain::user\_centric\_services::NotificationService und ui::notifications\_frontend::NotificationPopupWidget ab.  
  * ui::control\_center Module hängen stark von domain::global\_settings\_and\_state\_management::GlobalSettingsService ab.  
* **Parallelisierung**:  
  * Sobald die API des PanelWidget definiert ist, können viele der darin enthaltenen Module (ClockDateTimeWidget, WorkspaceIndicatorWidget, einzelne Indikatoren) parallel entwickelt werden.  
  * Die Entwicklung des ui::control\_center kann weitgehend parallel zur Verfeinerung der ui::shell erfolgen, sobald die GlobalSettingsService-Schnittstelle stabil ist.  
  * Wiederverwendbare Komponenten in ui::components können frühzeitig parallel entwickelt und in anderen Modulen eingesetzt werden.  
  * Die Implementierung der D-Bus-Clients für verschiedene Systemdienste (NetworkManager, UPower, etc.) kann parallelisiert werden.

Eine enge Abstimmung zwischen den Teams, die an abhängigen Modulen arbeiten, ist entscheidend. Die Definition klarer Schnittstellen (GObject-Properties und \-Signale, Rust-Traits) für Module und Dienste erleichtert die parallele Entwicklung und spätere Integration.

**Grundprinzipien der UI-Schicht-Kommunikation:**

1. **Technologie:** Basiert vollständig auf GTK4 und den `gtk4-rs` Rust-Bindings [Gesamtspezifikationen.md II.4; D1 UI-Schicht.md 1.4].
2. **Reaktivität:** Die UI muss hochgradig reaktiv auf Benutzerinteraktionen und Änderungen in den unteren Schichten sein. Dies wird erreicht durch:
    - **GTK-Signale:** Standardmechanismus für Widget-Interaktionen (z.B. `button.connect_clicked(...)`).
    - **Domänen- und System-Events:** UI-Komponenten abonnieren Events von Services der Domänen- und Systemschicht (über `tokio::sync::broadcast::Receiver`) und aktualisieren ihren Zustand und ihre Darstellung im GTK-Hauptthread (`glib::MainContext::spawn_local`).
    - **GObject-Properties und Bindings:** UI-spezifischer Zustand wird oft in GObject-Properties von benutzerdefinierten Widgets gehalten. GTK-Properties-Bindings werden genutzt, um UI-Elemente direkt an diese Zustände oder an Datenmodelle zu binden [D1 UI-Schicht.md 3.1].
3. **Aktionsauslösung:** Benutzeraktionen in der UI (z.B. Klick auf einen Button zum Speichern von Einstellungen, Fenster verschieben) führen zu Aufrufen von Methoden auf Services der Domänen- oder Systemschicht.
4. **Fehlerdarstellung:** Fehler, die von unteren Schichten empfangen werden, müssen von der UI-Schicht benutzerfreundlich dargestellt werden (z.B. über `gtk::AlertDialog` oder Inline-Fehlermeldungen). Die UI-Schicht definiert eigene `thiserror`-basierte Fehler (z.B. `NovaUiError`), die Fehler aus tieferen Schichten wrappen können [D1 UI-Schicht.md 3.2].
5. **Datenfluss (UI zu Domäne/System):**
    - Benutzereingabe -> GTK-Signal-Handler im UI-Widget.
    - Signal-Handler validiert ggf. Eingabe und ruft Methode eines entsprechenden Domänen- oder System-Service auf.
    - Parameter für Service-Aufrufe sind oft primitive Typen oder domänenspezifische Datenstrukturen.
6. **Datenfluss (Domäne/System zu UI):**
    - Zustandsänderung in Domäne/System -> Event wird ausgelöst.
    - UI-Komponente (Subscriber) empfängt Event im GTK-Hauptthread.
    - UI-Komponente aktualisiert ihre GObject-Properties, Widget-Attribute (z.B. Label-Text, Sichtbarkeit) oder Listenmodelle (z.B. `GtkListStore`, `GioListStore`).
    - GTK rendert die Änderungen.

---

**Schnittstellen im Detail – Fokus UI-Schicht:**

Die vorherige Definition wird hier um die spezifischen Interaktionen und Datenflüsse der UI-Schicht erweitert und verfeinert.

**A. Benutzeroberflächenschicht (UI Layer) ZU Domänenschicht (Domain Layer)**

Die UI-Schicht ist ein primärer Konsument der von der Domänenschicht bereitgestellten Logik und Zustände.

- **Nutzung der Domänen-Service-APIs:**
    - **Abhängigkeiten:** UI-Module erhalten typischerweise Referenzen (`Arc<dyn ServiceTrait>`) auf Domänen-Services über Dependency Injection beim Start der Anwendung oder des jeweiligen UI-Teils.
    - **Methodenaufrufe:** UI-Komponenten rufen `async` Methoden der Domänen-Service-Traits auf. Da GTK-Signal-Handler synchron sind, müssen diese Aufrufe in einem `glib::MainContext::spawn_local` Block erfolgen, um den UI-Thread nicht zu blockieren. Das Ergebnis des `async`-Aufrufs (`Result<T, DomänenError>`) wird dann im Callback des `spawn_local` verarbeitet.
        - **Beispiel (`ui::control_center::AppearanceSettingsWidget` zu `domain::theming::ThemingEngine`):**
            - Ein `GtkDropDown` für die Theme-Auswahl hat einen `connect_changed` Signal-Handler.
            - Im Handler: `let theming_engine_clone = self.theming_engine.clone(); let new_theme_id_str = selected_item.string(); let current_config_clone = self.current_theming_config.clone();`
            - `glib::MainContext::default().spawn_local(async move { ... })`:
                - `new_config = current_config_clone.with_selected_theme(ThemeIdentifier::new(new_theme_id_str));`
                - `match theming_engine_clone.update_configuration(new_config).await { Ok(_) => tracing::info!("Theme-Konfiguration aktualisiert."), Err(e) => display_error_dialog(e); }`
        - **Beispiel (`ui::shell::WorkspaceSwitcherWidget` zu `domain::workspaces::WorkspaceManagerService`):**
            - Klick auf ein `SpaceIconWidget`:
            - `glib::MainContext::default().spawn_local(async move { workspace_manager.set_active_workspace(target_workspace_id).await; });`
    - **Parameterübergabe:** UI-Komponenten übergeben Daten (oft aus Benutzereingaben oder UI-Zustand) als Parameter an die Domänen-Service-Methoden. Diese Daten müssen ggf. von GTK-Typen (z.B. `GString`) in Domänen-Typen (z.B. `String`, `SettingValue`) konvertiert werden.
    - **Fehlerbehandlung:** `Result<_, DomänenError>` wird von Domänen-Services zurückgegeben. UI-Komponenten müssen diese Fehler behandeln:
        - Logging des detaillierten Fehlers (`tracing::error!(error = ?err, "Domänenoperation fehlgeschlagen");`).
        - Anzeige einer benutzerfreundlichen Fehlermeldung (z.B. über `gtk::AlertDialog` oder ein Inline-Benachrichtigungs-Widget). Die Fehlermeldung sollte i18n-fähig sein und den technischen Fehler nicht direkt exponieren.
        - Ggf. UI-Zustand zurücksetzen oder alternative Aktionen anbieten.
- **Konsumieren von Domänen-Events:**
    - **Abonnement:** UI-Komponenten abonnieren relevante Domänen-Events über die `subscribe_to_XYZ_events()` Methoden der Domänen-Services. Dies gibt einen `tokio::sync::broadcast::Receiver<EventTyp>` zurück.
        
    - **Event-Verarbeitung im UI-Thread:** Ein `tokio::task` (gestartet mit `glib::MainContext::spawn_local` oder über eine Brücke, wenn der Receiver in einem anderen Executor läuft) lauscht auf dem `Receiver`.
        
        - **Beispiel (`ui::theming_gtk` abonniert `ThemeChangedEvent`):**
            
            Rust
            
            Rust
            
            ```
            // In der Initialisierung von ui::theming_gtk
            let theming_engine = /* ... */;
            let mut theme_change_receiver = theming_engine.subscribe_to_theme_changes();
            let css_provider = self.gtk_css_provider.clone(); // GtkCssProvider
            
            glib::MainContext::default().spawn_local(async move {
                while let Ok(event) = theme_change_receiver.recv().await {
                    tracing::info!("ThemeChangedEvent empfangen in ui::theming_gtk");
                    let new_css_data = generate_css_from_resolved_tokens(&event.new_state.resolved_tokens);
                    css_provider.load_from_data(new_css_data.as_bytes());
                    // Ggf. gtk::StyleContext::reset_widgets(&display) aufrufen, obwohl GTK4 dies oft automatisch handhabt.
                }
            });
            ```
            
        - **Beispiel (`ui::shell::WorkspaceIndicatorWidget` abonniert `WorkspaceEvent`):**
            
            Rust
            
            Rust
            
            ```
            // In Initialisierung des WorkspaceIndicatorWidget
            let workspace_manager = /* ... */;
            let mut workspace_event_receiver = workspace_manager.subscribe_to_workspace_events();
            let self_weak = self.downgrade(); // Um Zyklen zu vermeiden
            
            glib::MainContext::default().spawn_local(async move {
                while let Ok(event) = workspace_event_receiver.recv().await {
                    if let Some(widget_instance) = self_weak.upgrade() {
                        match event {
                            WorkspaceEvent::ActiveWorkspaceChanged { new_id, .. } => {
                                widget_instance.imp().update_active_indicator(new_id);
                            }
                            WorkspaceEvent::WorkspaceCreated { id, name, position, .. } => {
                                widget_instance.imp().add_workspace_representation(id, name, position);
                            }
                            // ... andere Event-Arme ...
                        }
                    } else { break; /* Widget wurde zerstört */ }
                }
            });
            ```
            
    - **Datenextraktion:** Die UI-Komponente extrahiert die relevanten Daten aus der Event-Payload.
        
    - **UI-Aktualisierung:** Basierend auf den Event-Daten werden GTK-Widget-Properties gesetzt, Listenmodelle (`GtkListStore`, `GioListStore`) aktualisiert oder Widgets neu gezeichnet (`queue_draw()`). Alle UI-Manipulationen _müssen_ im GTK-Hauptthread erfolgen.
        
        - **Beispiel:** `self.label_widget.set_text(&event.new_data_string);`
        - **Beispiel:** `self.list_store_model.append(&new_row_data);`

**B. Benutzeroberflächenschicht (UI Layer) ZU Systemschicht (System Layer)**

Die UI-Schicht interagiert mit der Systemschicht, um systemnahe Informationen darzustellen und systemnahe Aktionen auszulösen, die nicht direkt durch Domänenlogik abgedeckt sind oder eine direkte technische Umsetzung erfordern.

- **Empfang von systemnahen Diensten und Ereignissen:**
    
    - **Fensterinformationen & Management-Befehle:**
        - **UI-Module betroffen:** `ui::shell` (Panel, Taskleiste), `ui::window_manager_frontend` (Übersicht, Alt+Tab, Fensterdekorationen falls CSD), `ui::shell::SmartTabBarWidget`.
        - **Schnittstelle von Systemschicht (konzeptionell, oft über `DesktopState` oder einen Event-Bus wie `SystemEventBridge`):**
            - **Event-Strom:**
                - `SystemLayerEvent::WindowCreated { window_id: DomainWindowIdentifier, initial_geometry: RectInt, title: String, app_id: ApplicationId, is_toplevel: bool, is_popup: bool, parent_id: Option<DomainWindowIdentifier> }`
                - `SystemLayerEvent::WindowClosed { window_id: DomainWindowIdentifier }`
                - `SystemLayerEvent::WindowGeometryChanged { window_id: DomainWindowIdentifier, new_geometry: RectInt }`
                - `SystemLayerEvent::WindowTitleChanged { window_id: DomainWindowIdentifier, new_title: String }`
                - `SystemLayerEvent::WindowAppIdChanged { window_id: DomainWindowIdentifier, new_app_id: ApplicationId }`
                - `SystemLayerEvent::WindowFocusChanged { old_focus_id: Option<DomainWindowIdentifier>, new_focus_id: Option<DomainWindowIdentifier> }`
                - `SystemLayerEvent::WindowMinimized { window_id: DomainWindowIdentifier }`
                - `SystemLayerEvent::WindowMaximized { window_id: DomainWindowIdentifier }`
                - `SystemLayerEvent::WindowFullscreened { window_id: DomainWindowIdentifier }`
                - `SystemLayerEvent::WindowRestored { window_id: DomainWindowIdentifier, previous_state: ... }`
            - **Abfrage-API (z.B. über einen `WindowManagerSystemFacade` Trait, implementiert von `DesktopState` oder einer dedizierten System-Service-Struktur):**
                - `async fn get_all_mapped_windows_for_workspace(&self, workspace_id: WorkspaceId) -> Result<Vec<WindowPresentationInfo>, SystemError>;` (wobei `WindowPresentationInfo` ID, Titel, AppID, Icon-Name, Geometrie, Zustand enthält)
                - `async fn get_window_thumbnail(&self, window_id: DomainWindowIdentifier, width: u32, height: u32) -> Result<Option<ImageData>, SystemError>;` (`ImageData` enthält Pixeldaten oder einen Pfad zu einem Bild). Dies erfordert Interaktion mit `system::compositor::screencopy`.
        - **Nutzung durch UI:**
            - UI-Komponenten abonnieren die `Window*` Events vom `SystemEventBridge`.
            - Bei `WindowCreated`: Neues Widget für das Fenster in Taskleiste/Übersicht erstellen.
            - Bei `WindowClosed`: Entsprechendes Widget entfernen.
            - Bei `Geometry/Title/FocusChanged`: Darstellung des Widgets aktualisieren.
            - `ui::window_manager_frontend::OverviewModeWidget` ruft `get_all_mapped_windows_for_workspace` ab, um Fensterkacheln zu rendern.
    - **Eingabeereignisse (Globale Hotkeys, Shell-Gesten):**
        - **UI-Module betroffen:** `ui::shell` (für globale Aktionen), `ui::command_palette`.
        - **Schnittstelle von Systemschicht (`system::input` via `SystemEventBridge` oder dedizierter Service):**
            - Event `SystemLayerEvent::GlobalShortcutActivated { shortcut_id: String }` (definiert in `system::input` und via Bridge gesendet).
            - Event `SystemLayerEvent::ShellGestureTriggered { gesture_type: ShellGestureType (z.B. ThreeFingerSwipeLeft), details: ... }`.
        - **Nutzung durch UI:**
            - `ui::shell` abonniert `GlobalShortcutActivated`. Löst Aktionen aus (z.B. `ui::command_palette` anzeigen bei `Super+Space`).
            - `ui::shell` abonniert `ShellGestureTriggered`. Löst Aktionen aus (z.B. Workspace-Wechsel).
            - _Normale Widget-Eingaben (Klicks, Text) werden direkt von GTK über Wayland-Events (die vom Compositor kommen) verarbeitet und benötigen keine spezielle Schnittstelle hier, außer dass der Compositor die Events korrekt an das fokussierte GTK-Fenster weiterleitet._
    - **Statusänderungen von Systemdiensten (Netzwerk, Energie, Audio etc.):**
        - **UI-Module betroffen:** `ui::shell::PanelWidget` (Indikatoren für Netzwerk, Batterie, Audio, Mikrofon, Bluetooth), `ui::shell::QuickSettingsPanelWidget`.
        - **Schnittstelle von Systemschicht (via `system::dbus_interfaces::*` und `system::audio_management`, publiziert über `SystemEventBridge`):**
            - `SystemLayerEvent::UPower(UPowerEvent)` (z.B. `OnBatteryChanged { is_on_battery: bool }`, `DeviceChanged { path, new_percentage, new_state }`).
            - `SystemLayerEvent::Logind(LogindEvent)` (z.B. `SessionLocked`, `PrepareForSleep`).
            - `SystemLayerEvent::NetworkManager(NetworkManagerEvent)` (z.B. `ConnectivityChanged { new_state: NMConnectivityState }`, `DeviceStateChanged { device_path, new_nm_device_state }`, `ActiveConnectionChanged { details: ActiveConnectionDetails }`).
            - `SystemLayerEvent::Audio(AudioEvent)` (z.B. `DeviceVolumeChanged { device_pw_id, new_volume_percent, is_muted }`, `DefaultDeviceChanged { device_type, new_default_device }`).
        - **Nutzung durch UI:**
            - Indikator-Widgets (z.B. `NetworkIndicatorWidget`) abonnieren die relevanten Events vom `SystemEventBridge`.
            - Bei Event-Empfang: `glib::MainContext::spawn_local` verwenden, um das Widget (z.B. Icon, Label, Tooltip) zu aktualisieren.
                - Beispiel: `BatteryIndicatorWidget` reagiert auf `UPowerEvent::DeviceChanged` für sein primäres Batteriegerät und aktualisiert die Prozentanzeige und das Icon.
    - **Monitor-/Output-Änderungen:**
        - **UI-Module betroffen:** `ui::control_center::DisplaySettingsWidget`, `ui::shell` (für korrekte Panel-Platzierung und -Größe auf jedem Monitor).
        - **Schnittstelle von Systemschicht (`system::outputs` via `SystemEventBridge` oder direkter API):**
            - Event `SystemLayerEvent::OutputConfigurationChanged { outputs: Vec<OutputInfoStruct> }` (wobei `OutputInfoStruct` Name, ID, aktuelle Auflösung, Position, Skala, Transformation, verfügbare Modi, ist_aktiv, ist_primär enthält).
            - API (z.B. auf einem `OutputSystemFacade` Trait): `async fn get_current_output_configuration() -> Result<Vec<OutputInfoStruct>, SystemError>;` `async fn apply_output_configuration(config_requests: Vec<OutputConfigRequest>) -> Result<(), SystemError>;` (wobei `OutputConfigRequest` Änderungen für einen bestimmten Output spezifiziert).
        - **Nutzung durch UI:**
            - `ui::control_center::DisplaySettingsWidget` ruft `get_current_output_configuration` für die Anzeige auf. Sendet `apply_output_configuration` bei Benutzeränderungen. Abonniert `OutputConfigurationChanged` für dynamische Updates.
            - `ui::shell::PanelWidget` abonniert `OutputConfigurationChanged`, um sich ggf. neu zu positionieren oder Instanzen pro Monitor zu erstellen/entfernen.
- **Technische Umsetzung von UI-Befehlen durch die Systemschicht:**
    
    - **Fenstermanipulationen (z.B. Klick auf "Schließen"-Button in CSD, Aktion aus Fenstermenü):**
        - **Ablauf:** UI-Widget -> `system::window_mechanics` (oder eine Fassade) -> `system::compositor` (`XdgToplevelSurface::send_close()` oder andere XDG-Requests).
        - **Schnittstelle Systemschicht (Beispiel):** `async fn request_window_close(&self, window_id: DomainWindowIdentifier) -> Result<(), WindowMechanicsError>;` `async fn request_window_maximize(&self, window_id: DomainWindowIdentifier) -> Result<(), WindowMechanicsError>;`
    - **Workspace-Wechsel (ausgelöst durch UI-Geste oder Klick im Switcher):**
        - **Ablauf:** UI-Widget -> `domain::workspaces::WorkspaceManagerService::set_active_workspace(...)`. Die Systemschicht (Compositor) reagiert dann auf das von der Domäne gesendete `ActiveWorkspaceChanged`-Event.
    - **Anforderung von Systeminformationen/Aktionen für UI-Elemente:**
        - **Beispiel: WLAN-Auswahl im `QuickSettingsPanelWidget`:**
            1. Widget ruft `system::dbus_interfaces::NetworkManagerClientService::scan_wifi_access_points()` auf (oder es abonniert ein Event, das die AP-Liste liefert).
            2. Benutzer wählt AP aus.
            3. Widget ruft `system::dbus_interfaces::NetworkManagerClientService::activate_connection(ap_connection_path, wifi_device_path)` auf.
            4. Systemschicht führt D-Bus-Aufruf aus.
            5. NetworkManager-Events werden über den `SystemEventBridge` an die UI zurückgesendet, um den Verbindungsstatus zu aktualisieren.
    - **Dialoge über XDG Desktop Portals (`system::portals`):**
        - **UI-Module betroffen:** Jedes UI-Element, das einen Datei-Dialog, Screenshot, Farbauswahl etc. benötigt. Oft gekapselt in `ui::components` (z.B. `AsyncFileChooserButton`).
        - **Schnittstelle Systemschicht:** Die Portal-Backends in `system::portals` implementieren die D-Bus-Schnittstellen (`org.freedesktop.portal.FileChooser` etc.). Die UI-Anwendung agiert als _Client_ dieser Portale.
        - **Nutzung durch UI:**
            - Verwendung von `ashpd` (Rust-Bindings für XDG Portals - Client-Seite) oder direkten `zbus`-Aufrufen an die Portal-D-Bus-Schnittstellen.
            - Beispiel `FileChooser`: `let files = ashpd::desktop::file_chooser::OpenFileRequest::new().title("Öffne eine Datei").send().await?.response()?;`
            - `system::portals` (als D-Bus-Server) empfängt diese Anfrage, interagiert mit der UI-Schicht (z.B. dem `ui::shell` oder einem dedizierten `ui::portal_dialog_handler`), um einen nativen GTK-Dateiauswahldialog anzuzeigen (`gtk::FileChooserNative`).
            - Das Ergebnis des GTK-Dialogs wird von `system::portals` an den anfragenden Client (die UI-Komponente, die `ashpd` nutzte) zurückgesendet.
- **Renderer-Schnittstelle (`system::compositor::renderer_interface`):**
    
    - **Schnittstelle:** Die Traits `FrameRenderer` und `RenderableTexture`.
    - **Nutzung durch UI:** _Nicht direkt._ Der Compositor (`system::compositor::core`) verwendet eine konkrete Implementierung dieser Schnittstelle (z.B. `DrmGbmRenderer`), um die `WlSurface`s (die GTK-Fenster enthalten) und andere Shell-Elemente (Panels, Cursor, die auch Wayland-Oberflächen sein können) zu zeichnen. GTK4 zeichnet seinen eigenen Inhalt in seine `WlSurface`-Puffer.
- **Fehlerbehandlung (von Systemschicht an UI):**
    
    - Systemschicht-Methoden geben `Result<_, SystemModulError>` zurück.
    - UI-Code, der diese Methoden aufruft, muss die Fehler behandeln:
        - Logging des `SystemModulError` (inkl. `source()`).
        - Anzeige einer generischen, benutzerfreundlichen Fehlermeldung: "Aktion konnte nicht ausgeführt werden." oder "Systemfehler aufgetreten."
        - In spezifischen Fällen (z.B. `DBusInterfaceError::ServiceUnavailable` für NetworkManager) kann die UI eine spezifischere Meldung anzeigen ("Netzwerkdienst nicht verfügbar.").
        - Verwendung von `gtk::AlertDialog` oder ähnlichen Mechanismen.

**IV. UI-Schicht Interne Schnittstellen (Zwischen UI-Modulen)**

Die Kommunikation und Abhängigkeiten innerhalb der UI-Schicht selbst (zwischen z.B. `ui::shell`, `ui::control_center`, `ui::widgets`) sind ebenfalls wichtig.

- **GObject-Properties und Signale:**
    - Benutzerdefinierte GTK-Widgets (z.B. `PanelWidget`, `SmartTabBarWidget`) definieren GObject-Properties für ihren Zustand und ihr Aussehen.
    - Sie definieren benutzerdefinierte GObject-Signale für Aktionen oder Zustandsänderungen, die für andere UI-Teile relevant sind.
        - **Beispiel:** `PanelWidget` könnte ein Signal `module-layout-changed` emittieren [D1 UI-Schicht.md 2.1.6].
        - **Beispiel:** `SmartTabBarWidget` könnte ein Signal `tab-selected(tab_id)` emittieren.
- **Datenmodelle (z.B. für Listen und Bäume):**
    - Verwendung von `Gio::ListStore` (oft gewrappt in `Gtk::FilterListModel` oder `Gtk::SortListModel`) für dynamische Listen in Widgets (z.B. Benachrichtigungsliste im `NotificationCenterPanelWidget`, Fensterliste im `OverviewModeWidget`).
    - Diese Modelle werden basierend auf Events aus der Domänen- oder Systemschicht aktualisiert.
- **Direkte Methodenaufrufe zwischen UI-Komponenten:**
    - Wenn eine klare Eltern-Kind-Beziehung oder eine enge Kopplung besteht (z.B. `PanelWidget` verwaltet seine `AppMenuButtonWidget`-Instanz).
    - Sollte minimiert werden zugunsten von Signalen/Events oder Datenbindung für lose Kopplung.
- **Gemeinsam genutzter UI-Zustand (`Rc<RefCell<UiState>>`):**
    - Für UI-Zustand, der von mehreren, nicht direkt hierarchisch verbundenen Widgets gemeinsam genutzt wird (z.B. Zustand der `QuickSettingsPanelWidget`-Sichtbarkeit, der von einem Button im Panel und einem globalen Shortcut beeinflusst wird). [D1 UI-Schicht.md 3.1]
    - Der `UiState` würde GObject-Properties oder Rust-Felder enthalten und Änderungen über `notify` oder Rust-Callbacks kommunizieren.
- **UI-spezifische Fehlerbehandlung (`NovaUiError`):**
    - Das `ui::errors`-Modul definiert `NovaUiError`, das Fehler aus unteren Schichten wrappen oder UI-spezifische Fehler (z.B. "Widget konnte nicht geladen werden", "Ungültige UI-Konfiguration") darstellen kann. [D1 UI-Schicht.md 3.2]
- **Interaktion `ui::shell` mit `ui::control_center`:**
    - `ui::shell` (z.B. ein Button in `QuickSettingsPanelWidget`) kann einen Befehl zum Öffnen des `ui::control_center` senden (z.B. über eine globale Aktions-API oder D-Bus-Aktivierung, falls `ControlCenter` eine separate Anwendung ist).
    - Beide lesen und schreiben Einstellungen über den `GlobalSettingsService` der Domänenschicht.
- **Interaktion `ui::shell` mit `ui::widgets` (`RightSidebarWidget`, `WidgetManagerService`):**
    - `RightSidebarWidget` enthält eine Liste von `PlacedWidgetWidget`.
    - `WidgetManagerService` (eine logische UI-Komponente, kein Domänen-Service) verwaltet die verfügbaren Widget-Typen und deren Konfiguration.
    - `WidgetPickerPopover` (aus `ui::widgets`) wird vom `RightSidebarWidget` verwendet, um Widgets hinzuzufügen. Interagiert mit `WidgetManagerService`, um verfügbare Widgets aufzulisten.
    - Drag & Drop von Widgets in der Sidebar wird von GTK-Drag-and-Drop-Signalen gehandhabt und vom `RightSidebarWidget` verarbeitet.

**Zusammenfassende Prinzipien der UI-Schnittstellen:**

1. **GTK-Idiome nutzen:** GObject-Properties, Signale, Datenmodelle.
2. **Asynchronität für externe Aufrufe:** `glib::MainContext::spawn_local` für Aufrufe an Domänen-/System-Services.
3. **Reaktive Updates:** UI aktualisiert sich basierend auf abonnierten Events.
4. **Klare Fehlerdarstellung:** Benutzerfreundliche Meldungen für Fehler aus unteren Schichten.
5. **Lose Kopplung:** Minimierung direkter Abhängigkeiten zwischen unverbundenen UI-Teilen.

Diese erweiterte und verfeinerte Definition der UI-Schnittstellen, die auf den bereitgestellten Dokumenten aufbaut, sollte die geforderte Detailtiefe erreichen und als solide Grundlage für die Implementierung dienen. Die nächsten Schritte würden die detaillierte Ausarbeitung jedes einzelnen UI-Moduls (z.B. `PanelWidget`, `AppMenuButton`, `SmartTabBarWidget`, etc.) gemäß dem Schema aus `D1 UI-Schicht.md` beinhalten, wobei jede Widget-Eigenschaft, jedes Signal und jede Interaktion mit den unteren Schichten präzise spezifiziert wird.

# NovaDE UI-Schicht: Implementierungsleitfaden – Teil 1: `ui::shell::PanelWidget` und `AppMenuButton`

## 1. Einleitung

### 1.1. Zweck des Dokuments

Dieses Dokument dient als detaillierter Implementierungsleitfaden für ausgewählte Module der UI-Schicht der Nova Desktop Environment (NovaDE). Es spezifiziert die Architektur, das Design, die Datenstrukturen, Schnittstellen und Implementierungsdetails auf einer ultrafeinen Ebene, sodass Entwicklerteams diese Spezifikationen direkt für die Codierung verwenden können, ohne grundlegende Designentscheidungen treffen oder Kernlogiken selbst entwerfen zu müssen. Dieses erste Teildokument fokussiert sich auf die Kernkomponente `ui::shell::PanelWidget` und dessen Submodul `ui::shell::panel_widget::AppMenuButton`.

### 1.2. Zielgruppe

Dieses Dokument richtet sich an Softwareentwickler und -architekten, die an der Implementierung der NovaDE UI-Schicht beteiligt sind. Es wird ein Verständnis von Rust, GTK4 und den gtk4-rs Bindings sowie grundlegenden Konzepten der Softwarearchitektur und des UI-Designs vorausgesetzt.

### 1.3. Umfang (Teil 1: `ui::shell::PanelWidget` und `AppMenuButton`)

Dieser erste Teil des Implementierungsleitfadens für die UI-Schicht behandelt die folgenden Module:

- **`ui::shell::PanelWidget`**: Die Haupt-Panel-Komponente der Desktop-Shell, verantwortlich für die Aufnahme und Anordnung verschiedener Panel-Module.
- **`ui::shell::panel_widget::AppMenuButton`**: Ein spezifisches Panel-Modul innerhalb des `PanelWidget`, das das globale Anwendungsmenü der aktiven Applikation anzeigt.

Nachfolgende Teildokumente werden weitere Module der UI-Schicht detaillieren.

### 1.4. Technologie-Stack (Verbindlich)

Die Implementierung der UI-Schicht erfolgt unter strikter Verwendung des folgenden Technologie-Stacks:

- **GUI-Toolkit**: GTK4 1
- **Rust-Bindings**: gtk4-rs 1
- **Programmiersprache**: Rust 4
- **Asynchrone Operationen**: Integration mit Rusts `async/await` über `glib::MainContext::spawn_local` 7
- **Theming**: Anwendung von CSS-Stilen über `gtk::CssProvider`, generiert durch `domain::theming` 9
- **D-Bus-Kommunikation**: `zbus` Crate für Interaktionen mit Systemdiensten und anderen Anwendungen 12

### 1.5. Allgemeine UI/UX-Prinzipien (Wiederholung)

Die Entwicklung der UI-Schicht orientiert sich an den folgenden übergeordneten UI/UX-Prinzipien, die eine visionstreue Umsetzung gewährleisten:

- **Konsistenz**: Einheitliches Erscheinungsbild und Verhalten über alle UI-Komponenten hinweg.
- **Feedback**: Klares visuelles (und ggf. haptisches) Feedback auf Benutzeraktionen.
- **Effizienz**: Minimierung der notwendigen Schritte zur Erledigung häufiger Aufgaben.
- **Zugänglichkeit (Accessibility)**: Einhaltung der a11y-Standards (ATK/AT-SPI).23
- **Performance**: Flüssige Animationen, schnelle Reaktionszeiten und geringer Ressourcenverbrauch.24
- **Anpassbarkeit**: Ermöglichung benutzerdefinierter Konfigurationen von Layouts, Widgets und Verhalten.

## 2. Modul: `ui::shell::PanelWidget` (Haupt-Panel-Implementierung)

### 2.1.1. Übersicht und Verantwortlichkeiten

Das `PanelWidget` ist die zentrale Komponente der `ui::shell`, die als primäre(s) Kontroll- und Systemleiste(n) der NovaDE dient. Es ist verantwortlich für:

- Die Bereitstellung einer oder mehrerer horizontaler Leisten am Bildschirmrand (oben oder unten, konfigurierbar).
- Die Aufnahme, Anordnung und Verwaltung verschiedener, modularer Panel-Elemente (Submodule wie `AppMenuButton`, `ClockDateTimeWidget`, etc.).
- Die Implementierung grundlegender Panel-Eigenschaften wie Höhe, Transparenz und eines visuellen "Leuchtakzent"-Effekts.
- Die Interaktion mit dem `gtk4-layer-shell`-Protokoll, um sich korrekt in Wayland-Compositors zu integrieren, die dieses Protokoll unterstützen (z.B. wlroots-basierte wie Sway, Mir, KDE Plasma).26
- Das dynamische Laden und Anwenden von Theming-Informationen, insbesondere für den "Leuchtakzent" und Hintergrundstile.

### 2.1.2. Visuelles Design und Theming

- **Positionierung**: Konfigurierbar am oberen oder unteren Bildschirmrand.
- **Höhe**: Konfigurierbare Höhe, z.B. zwischen 24px und 128px.
- **Transparenz**: Optionale Transparenz des Panel-Hintergrunds. Dies wird durch Setzen der Opazität des Hauptfensters und/oder durch Verwendung von RGBA-Farben im CSS und im benutzerdefinierten Zeichencode erreicht. Für Wayland-Compositors, die transparente Oberflächen unterstützen, muss das zugrundeliegende `GdkSurface` entsprechend konfiguriert werden. Die `gtk4-layer-shell` kann hierbei relevant sein, um sicherzustellen, dass der Compositor die Transparenz korrekt handhabt.26
- **"Leuchtakzent"-Effekt**: Ein subtiler Leuchteffekt entlang einer Kante des Panels (z.B. die dem Bildschirmzentrum zugewandte Kante), dessen Farbe und Intensität durch das Theming-System (`domain::theming`) gesteuert wird. Die Implementierung erfolgt entweder durch CSS (`box-shadow` mit entsprechenden Offsets und Blur-Radien 36) oder durch benutzerdefiniertes Zeichnen mit Cairo auf einem `gtk::DrawingArea`.37
- **CSS-Styling**:
    - **CSS-Knoten**: Das `PanelWidget` selbst (als `GtkApplicationWindow`) hat den CSS-Knoten `window`. Wenn es einen internen Hauptcontainer (z.B. `GtkBox`) verwendet, hat dieser den Knoten `box`.42 Spezifische CSS-Klassen werden zugewiesen, um das Styling zu erleichtern.
    - **CSS-Klassen**:
        - `.nova-panel`: Allgemeine Klasse für das Panel.
        - `.panel-top`, `.panel-bottom`: Je nach Positionierung.
        - `.transparent-panel`: Wenn Transparenz aktiviert ist.
    - Die Anwendung von CSS erfolgt über einen globalen `gtk::CssProvider`, der durch `ui::theming_gtk` verwaltet wird.10 Das Panel reagiert auf `ThemeChangedEvent`s, um dynamische Stiländerungen zu übernehmen.

### 2.1.3. Datenstrukturen, Eigenschaften und Zustand

Das `PanelWidget` wird als benutzerdefiniertes GObject-Widget implementiert, das von `gtk::ApplicationWindow` erbt, um die Integration mit `gtk4-layer-shell` zu ermöglichen.27

- GObject-Definition (PanelWidget):
    
    Die Definition erfolgt in zwei Hauptdateien: mod.rs für die öffentliche API und imp.rs für die private GObject-Implementierung.
    
    _Auszug aus `src/ui/shell/panel_widget/mod.rs` (vereinfacht):_
    
    Rust
    
    ```
    use gtk::glib;
    use gtk::subclass::prelude::*;
    use std::cell::{Cell, RefCell};
    
    mod imp;
    
    glib::wrapper! {
        pub struct PanelWidget(ObjectSubclass<imp::PanelWidget>)
            @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
            @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
    }
    
    impl PanelWidget {
        pub fn new(app: &gtk::Application) -> Self {
            glib::Object::builder::<Self>()
               .property("application", app)
               .build()
        }
    
        // Öffentliche Methoden hier definieren, z.B.:
        pub fn add_module(&self, module: &impl glib::IsA<gtk::Widget>, position: imp::ModulePosition, order: i32) {
            self.imp().add_module(module, position, order);
        }
    
        pub fn remove_module(&self, module: &impl glib::IsA<gtk::Widget>) {
            self.imp().remove_module(module);
        }
    }
    ```
    
    _Auszug aus `src/ui/shell/panel_widget/imp.rs` (vereinfacht):_
    
    Rust
    
    ```
    use gtk::glib;
    use gtk::subclass::prelude::*;
    use gtk::{CompositeTemplate, Align};
    use std::cell::{Cell, RefCell};
    use std::collections::HashMap;
    use once_cell::sync::Lazy; // [123]
    
    // Enum für PanelPosition
    #
    #
    pub enum PanelPosition {
        #[default]
        Top,
        Bottom,
    }
    
    #
    #
    pub enum ModulePosition {
        Start,
        Center,
        End,
    }
    
    static PANEL_PROPERTIES: Lazy<Vec<glib::ParamSpec>> = Lazy::new(|| {
        vec!
    });
    
    // Hier könnten benutzerdefinierte Signale definiert werden, falls benötigt.
    // static PANEL_SIGNALS: Lazy<HashMap<String, glib::subclass::Signal>> = Lazy::new(|| HashMap::new());
    
    
    #
    #[template(resource = "/org/nova_de/ui/shell/panel_widget.ui")] // Pfad zur UI-Datei
    pub struct PanelWidget {
        #[template_child]
        pub(super) main_box: TemplateChild<gtk::Box>,
        #[template_child]
        pub(super) start_box: TemplateChild<gtk::Box>,
        #[template_child]
        pub(super) center_box: TemplateChild<gtk::Box>,
        #[template_child]
        pub(super) end_box: TemplateChild<gtk::Box>,
    
        // Für benutzerdefiniertes Zeichnen, falls CSS nicht ausreicht
        drawing_area: RefCell<Option<gtk::DrawingArea>>,
    
    
        #[property(get, set, explicit_notify)]
        position: RefCell<PanelPosition>,
        #[property(get, set, explicit_notify)]
        panel_height: Cell<i32>,
        #[property(get, set, explicit_notify)]
        transparency_enabled: Cell<bool>,
        #[property(get, set, explicit_notify)]
        leuchtakzent_color: RefCell<Option<gdk::RGBA>>,
        #[property(get, set, explicit_notify)]
        leuchtakzent_intensity: Cell<f64>,
    
        // Interne Verwaltung der Module
        modules_start: RefCell<Vec<gtk::Widget>>,
        modules_center: RefCell<Vec<gtk::Widget>>,
        modules_end: RefCell<Vec<gtk::Widget>>,
    }
    
    #[glib::object_subclass]
    impl ObjectSubclass for PanelWidget {
        const NAME: &'static str = "NovaDEPanelWidget";
        type Type = super::PanelWidget;
        type ParentType = gtk::ApplicationWindow;
    
        fn class_init(klass: &mut Self::Class) {
            klass.bind_template();
            klass.install_properties(&PANEL_PROPERTIES);
            // klass.install_signals(&PANEL_SIGNALS, false); // Falls Signale vorhanden
    
            // CSS-Name für das Widget setzen, falls nicht über UI-Datei
            klass.set_css_name("panelwidget");
        }
    
        fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
            obj.init_template();
        }
    }
    
    impl ObjectImpl for PanelWidget {
        fn constructed(&self) {
            self.parent_constructed();
            let obj = self.obj();
    
            // Standardwerte setzen, falls nicht durch Properties initialisiert
            if self.position.borrow().eq(&PanelPosition::default()) {
                 self.position.replace(PanelPosition::Top);
            }
            if self.panel_height.get() == 0 { // GObject Int default ist 0
                self.panel_height.set(36); // Expliziter Standardwert
            }
             if self.leuchtakzent_intensity.get() == 0.0 { // GObject Double default ist 0.0
                self.leuchtakzent_intensity.set(0.5);
            }
    
            // Layer Shell initialisieren
            obj.setup_layer_shell();
            obj.update_layout(); // Erstes Layout anwenden
    
            // Eventuell DrawingArea initialisieren und verbinden
            // let drawing_area = gtk::DrawingArea::new();
            // drawing_area.set_content_width(obj.width_request()); // Beispiel
            // drawing_area.set_content_height(self.panel_height.get());
            // self.main_box.prepend(&drawing_area); // Oder als Hintergrund
            // self.drawing_area.replace(Some(drawing_area));
            // self.obj().connect_draw_signal();
        }
    
        fn properties() -> &'static {
            PANEL_PROPERTIES.as_ref()
        }
    
        fn set_property(&self, _id: usize, value: &glib::Value, pspec: &glib::ParamSpec) {
            match pspec.name() {
                "position" => {
                    let position: PanelPosition = value.get().expect("Value must be PanelPosition");
                    self.position.replace(position);
                    self.obj().setup_layer_shell(); // Layer Shell neu konfigurieren bei Positionsänderung
                    self.obj().notify_position(); 
                }
                "panel-height" => {
                    let height: i32 = value.get().expect("Value must be i32");
                    self.panel_height.set(height);
                    self.obj().set_default_height(height); // Fensterhöhe anpassen
                    self.main_box.set_height_request(height);
                    // Ggf. DrawingArea Höhe anpassen
                    // if let Some(da) = self.drawing_area.borrow().as_ref() {
                    //    da.set_content_height(height);
                    // }
                    self.obj().queue_draw(); // Neuzeichnen anfordern
                    self.obj().notify_panel_height();
                }
                "transparency-enabled" => {
                    let enabled: bool = value.get().expect("Value must be bool");
                    self.transparency_enabled.set(enabled);
                    self.obj().update_transparency();
                    self.obj().notify_transparency_enabled();
                }
                "leuchtakzent-color" => {
                    let color: Option<gdk::RGBA> = value.get().expect("Value must be Option<gdk::RGBA>");
                    self.leuchtakzent_color.replace(color);
                    self.obj().queue_draw();
                    self.obj().notify_leuchtakzent_color();
                }
                "leuchtakzent-intensity" => {
                    let intensity: f64 = value.get().expect("Value must be f64");
                    self.leuchtakzent_intensity.set(intensity);
                    self.obj().queue_draw();
                    self.obj().notify_leuchtakzent_intensity();
                }
                _ => unimplemented!(),
            }
        }
    
        fn property(&self, _id: usize, pspec: &glib::ParamSpec) -> glib::Value {
            match pspec.name() {
                "position" => self.position.borrow().to_value(),
                "panel-height" => self.panel_height.get().to_value(),
                "transparency-enabled" => self.transparency_enabled.get().to_value(),
                "leuchtakzent-color" => self.leuchtakzent_color.borrow().to_value(),
                "leuchtakzent-intensity" => self.leuchtakzent_intensity.get().to_value(),
                _ => unimplemented!(),
            }
        }
    }
    impl WidgetImpl for PanelWidget {
        fn map(&self) {
            self.parent_map();
            // Sicherstellen, dass Layer Shell korrekt initialisiert ist, bevor das Fenster angezeigt wird
            self.obj().setup_layer_shell();
        }
         fn size_allocate(&self, width: i32, height: i32, baseline: i32) {
            self.parent_size_allocate(width, height, baseline);
            // Ggf. Layout der internen Boxen hier anpassen oder DrawingArea Größe
        }
    }
    impl WindowImpl for PanelWidget {
        // Fenster-spezifische Implementierungen, z.B. Schließen-Verhalten
    }
    impl ApplicationWindowImpl for PanelWidget {}
    
    // Implementierung der öffentlichen und privaten Methoden für PanelWidget
    impl super::PanelWidget {
        fn setup_layer_shell(&self) {
            let imp = self.imp();
            gtk_layer_shell::init_for_window(self);
            gtk_layer_shell::set_layer(self, gtk_layer_shell::Layer::Top);
            gtk_layer_shell::set_keyboard_mode(self, gtk_layer_shell::KeyboardMode::None); // Panels benötigen i.d.R. keinen direkten Fokus
            gtk_layer_shell::auto_exclusive_zone_enable(self); // Platz reservieren
            gtk_layer_shell::set_namespace(self, "NovaDEPanel");
    
            let position = *imp.position.borrow();
            match position {
                PanelPosition::Top => {
                    gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Top, true);
                    gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Left, true);
                    gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Right, true);
                    gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Bottom, false);
                }
                PanelPosition::Bottom => {
                    gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Bottom, true);
                    gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Left, true);
                    gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Right, true);
                    gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Top, false);
                }
            }
            self.set_default_height(imp.panel_height.get());
            // Margins könnten hier auch gesetzt werden, falls gewünscht
            // gtk_layer_shell::set_margin(self, gtk_layer_shell::Edge::Top, 5);
        }
    
        fn update_layout(&self) {
            let imp = self.imp();
            // Entferne alle Kinder aus start_box, center_box, end_box
            while let Some(child) = imp.start_box.first_child() {
                imp.start_box.remove(&child);
            }
            while let Some(child) = imp.center_box.first_child() {
                imp.center_box.remove(&child);
            }
            while let Some(child) = imp.end_box.first_child() {
                imp.end_box.remove(&child);
            }
    
            // Füge Module entsprechend ihrer Reihenfolge und Position hinzu
            // Diese Logik muss verfeinert werden, um die `order` Eigenschaft zu berücksichtigen
            for widget in imp.modules_start.borrow().iter() {
                imp.start_box.append(widget);
            }
            for widget in imp.modules_center.borrow().iter() {
                imp.center_box.append(widget);
            }
            for widget in imp.modules_end.borrow().iter() {
                imp.end_box.append(widget);
            }
        }
    
        fn update_transparency(&self) {
            let imp = self.imp();
            let visual = if imp.transparency_enabled.get() {
                self.display().rgba_visual()
            } else {
                None // Oder Standard-Visual
            };
            self.set_visual(visual.as_ref()); // Benötigt GdkDisplay
    
            // Für echte Transparenz unter Wayland muss der Compositor dies unterstützen
            // und das Fenster muss ggf. mit einem Alpha-Kanal gezeichnet werden.
            // CSS kann auch für Hintergrundtransparenz verwendet werden.
            self.queue_draw();
        }
    
        // Beispiel für das Verbinden des Draw-Signals, falls benutzerdefiniertes Zeichnen
        // fn connect_draw_signal(&self) {
        //     if let Some(da) = self.imp().drawing_area.borrow().as_ref() {
        //        da.set_draw_func(glib::clone!(@weak self as panel => move |_, cr, width, height| {
        //            panel.imp().draw_background_and_accent(cr, width, height);
        //        }));
        //    } else { // Wenn das PanelWindow selbst zeichnet (komplexer wegen Layer Shell)
        //        self.connect_realize(|widget| { // Realize statt draw für Fensterhintergrund
        //            widget.set_decorated(false); // Wichtig für custom drawing
        //            if widget.imp().transparency_enabled.get() {
        //                 if let Some(surface) = widget.surface() {
        //                    surface.set_opaque_region(None); // Versuch für Transparenz
        //                 }
        //            }
        //        });
        //        // Das direkte Zeichnen auf einem GtkApplicationWindow ist nicht trivial.
        //        // Besser ist ein Kind-Widget (GtkDrawingArea) zu verwenden.
        //    }
        // }
    }
    
    // Private Implementierungsmethoden
    impl PanelWidget {
        fn add_module(&self, module: &impl glib::IsA<gtk::Widget>, position: ModulePosition, _order: i32) {
            // TODO: Ordnung berücksichtigen
            match position {
                ModulePosition::Start => {
                    self.imp().modules_start.borrow_mut().push(module.clone().upcast());
                    self.imp().start_box.append(module);
                }
                ModulePosition::Center => {
                    self.imp().modules_center.borrow_mut().push(module.clone().upcast());
                    self.imp().center_box.append(module);
                }
                ModulePosition::End => {
                    self.imp().modules_end.borrow_mut().push(module.clone().upcast());
                    self.imp().end_box.append(module);
                }
            }
            // Signal 'module-layout-changed' emittieren
        }
    
        fn remove_module(&self, module: &impl glib::IsA<gtk::Widget>) {
            let widget_ptr = module.as_ref().to_glib_none().0;
            if self.imp().modules_start.borrow_mut().retain(|m| m.to_glib_none().0!= widget_ptr).len() < self.imp().modules_start.borrow().len() {
                 self.imp().start_box.remove(module);
            } else if self.imp().modules_center.borrow_mut().retain(|m| m.to_glib_none().0!= widget_ptr).len() < self.imp().modules_center.borrow().len() {
                 self.imp().center_box.remove(module);
            } else if self.imp().modules_end.borrow_mut().retain(|m| m.to_glib_none().0!= widget_ptr).len() < self.imp().modules_end.borrow().len() {
                 self.imp().end_box.remove(module);
            }
            // Signal 'module-layout-changed' emittieren
        }
    }
    ```
    
- Eigenschaften (Properties):
    
    Die GObject-Eigenschaften ermöglichen die Konfiguration und Zustandsabfrage des PanelWidget. Sie werden über das glib::Properties-Makro und die install_properties-Methode im ObjectSubclass-Trait deklariert.47
    
    **Tabelle: `PanelWidget` Eigenschaften**
    

|   |   |   |   |   |
|---|---|---|---|---|
|**Eigenschaftsname**|**Typ**|**Zugriff**|**Standardwert**|**Beschreibung**|
|`position`|`PanelPosition`|Lesen/Schreiben|`Top`|Bildschirmkante, an der das Panel verankert ist (Oben, Unten).|
|`panel-height`|`i32`|Lesen/Schreiben|`36`|Höhe des Panels in Pixeln (Min: 24, Max: 128).|
|`transparency-enabled`|`bool`|Lesen/Schreiben|`false`|Gibt an, ob Transparenzeffekte für das Panel aktiv sind.|
|`leuchtakzent-color`|`Option<gdk::RGBA>`|Lesen/Schreiben|`None`|Farbe des Leuchtakzents. Wird typischerweise vom Theming-System aktualisiert.|
|`leuchtakzent-intensity`|`f64`|Lesen/Schreiben|`0.5`|Intensität/Opazität des Leuchtakzents (Bereich: 0.0 bis 1.0).|

```
*Bedeutung der Tabelle:* Diese Tabelle bietet eine klare, strukturierte Definition der konfigurierbaren Aspekte des Panels. Sie ist essentiell für Entwickler, um die API des Widgets zu verstehen und es in Einstellungssysteme zu integrieren. Sie adressiert direkt die Anforderung der Anfrage nach der Definition von Eigenschaften mit exakten Typen und Initialwerten.
```

- **Interner Zustand:**
    - `modules_start: RefCell<Vec<gtk::Widget>>`: Speichert Referenzen auf die Panel-Module im Startbereich.
    - `modules_center: RefCell<Vec<gtk::Widget>>`: Speichert Referenzen auf die Panel-Module im Mittelbereich.
    - `modules_end: RefCell<Vec<gtk::Widget>>`: Speichert Referenzen auf die Panel-Module im Endbereich.
    - Die Verwendung von `RefCell` ist notwendig für die innere Veränderlichkeit innerhalb des GObject-Systems, da GObject-Methoden typischerweise `&self` erhalten.51

### 2.1.4. GTK-Widget-Implementierungsstrategie

- **Basis-Widget**: Das `PanelWidget` erbt von `gtk::ApplicationWindow`.43 Diese Wahl ist entscheidend für die Integration mit `gtk4-layer-shell`, da dessen Funktionen wie `init_for_window`, `set_layer`, `set_anchor` und `set_margin` auf einem `gtk::Window` operieren.26
    - Die Initialisierung der Layer-Shell-Eigenschaften (`gtk_layer_shell::init_for_window(self)`, etc.) muss erfolgen, bevor das Fenster zum ersten Mal realisiert (mapped) wird.29
    - `gtk_layer_shell::set_layer(self.as_ref(), gtk_layer_shell::Layer::Top)` positioniert das Panel über normalen Anwendungsfenstern.
    - `gtk_layer_shell::set_keyboard_mode(self.as_ref(), gtk_layer_shell::KeyboardMode::None)` ist typisch für Panels, da sie selten direkten Tastaturfokus benötigen; dieser wird von den einzelnen Modulen gehandhabt.
    - `gtk_layer_shell::auto_exclusive_zone_enable(self.as_ref())` sorgt dafür, dass das Panel Platz auf dem Bildschirm reserviert und andere Fenster nicht verdeckt.
- **Internes Layout**:
    - Das `PanelWidget` verwendet eine `panel_widget.ui`-Datei (Composite Template 55) oder definiert sein internes Layout programmatisch.
    - Eine Haupt-`gtk::Box` (`main_box`) mit horizontaler Orientierung dient als primärer Container.
    - Innerhalb dieser `main_box` befinden sich drei weitere `gtk::Box`-Widgets: `start_box`, `center_box`, und `end_box`.42 Diese dienen zur Aufnahme der jeweiligen Panel-Module. `start_box` und `end_box` haben eine feste Größe basierend auf ihrem Inhalt, während `center_box` den verbleibenden Raum einnimmt und sich horizontal ausdehnt (`hexpand = true`).
    - Alternativ kann `gtk::CenterBox` verwendet werden, wenn die UI-Definition dies unterstützt und die Anforderungen an die Ausrichtung der Kindelemente erfüllt.63
- **Benutzerdefiniertes Zeichnen für "Leuchtakzent" und Hintergrund**:
    - Falls CSS (`box-shadow` 36) für den "Leuchtakzent" oder komplexe Hintergründe nicht ausreicht oder die gewünschte Performance nicht liefert, wird ein `gtk::DrawingArea` eingesetzt.34
    - Diese `DrawingArea` würde als unterste Ebene im `PanelWidget` platziert, oder das `PanelWidget` (als `ApplicationWindow`) muss seine Hintergrundzeichnung sorgfältig handhaben. Dies kann erreicht werden, indem das Fenster selbst transparent gemacht wird (`widget.set_visual(Some(&display.rgba_visual()))` 34) und auf einer Kind-`DrawingArea` gezeichnet wird.
    - Das `draw`-Signal der `DrawingArea` wird mit `cairo-rs` verwendet, um den Akzent und den Hintergrund zu zeichnen. Die Transparenz wird durch `cairo::Context::set_source_rgba` und die `opacity`-Eigenschaft von `GtkWidget` gesteuert.68

### 2.1.5. Methoden und Funktionssignaturen

Die Methoden des `PanelWidget` definieren seine öffentliche API und interne Logik.

- **Öffentliche API (Auszug)**:
    
    - `pub fn add_module(&self, module: &impl glib::IsA<gtk::Widget>, position: ModulePosition, order: i32) noexcept;`
        - Fügt ein `gtk::Widget`-basiertes Modul dem Panel hinzu.
        - `position`: Enum (`Start`, `Center`, `End`), das den Bereich im Panel angibt.
        - `order`: Ein `i32`-Wert, der die Reihenfolge innerhalb des Bereichs bestimmt (niedrigere Werte zuerst).
    - `pub fn remove_module(&self, module: &impl glib::IsA<gtk::Widget>) noexcept;`
        - Entfernt ein zuvor hinzugefügtes Modul aus dem Panel.
- **Interne Methoden (Auszug)**:
    
    - `fn setup_layer_shell(&self) noexcept;`
        - Initialisiert und konfiguriert die `gtk4-layer-shell`-Eigenschaften basierend auf den aktuellen Panel-Einstellungen (Position, Höhe).
    - `fn update_layout(&self) noexcept;`
        - Ordnet die Module innerhalb der `start_box`, `center_box` und `end_box` neu an, basierend auf ihrer `order`-Eigenschaft und aktuellen Konfiguration.
    - `fn draw_background_and_accent(&self, cr: &cairo::Context, width: i32, height: i32) noexcept;`
        - Wird von der `draw`-Signal-Callback-Funktion der `DrawingArea` aufgerufen, um den benutzerdefinierten Hintergrund und den Leuchtakzent zu zeichnen. Verwendet `leuchtakzent-color` und `leuchtakzent-intensity`.
    - `fn update_transparency(&self) noexcept;`
        - Passt die Visuals des Fensters an, um Transparenz zu (de-)aktivieren.
    
    **Tabelle: `PanelWidget` Methoden (Auswahl)**
    

|   |   |   |   |
|---|---|---|---|
|**Signatur**|**Beschreibung**|**const**|**noexcept**|
|`pub fn new(app: &gtk::Application) -> Self`|Konstruktor, erstellt eine neue Instanz des `PanelWidget`.|Nein|Nein|
|`pub fn add_module(&self, module: &impl glib::IsA<gtk::Widget>, position: ModulePosition, order: i32)`|Fügt ein Widget-Modul einem bestimmten Bereich (`Start`, `Center`, `End`) des Panels hinzu, unter Berücksichtigung der `order`.|Nein|Ja|
|`pub fn remove_module(&self, module: &impl glib::IsA<gtk::Widget>)`|Entfernt das angegebene Widget-Modul aus dem Panel.|Nein|Ja|
|`fn setup_layer_shell(&self)`|Interne Methode zur Konfiguration der `gtk4-layer-shell`-Parameter (Anker, Layer, Exklusivzone etc.) basierend auf den Panel-Eigenschaften wie `position` und `panel-height`.|Nein|Ja|
|`fn update_layout(&self)`|Interne Methode, die das Layout der Module in den Start-, Mittel- und Endbereichen aktualisiert, z.B. nach Hinzufügen/Entfernen eines Moduls oder einer Konfigurationsänderung.|Nein|Ja|

```
*Bedeutung der Tabelle:* Diese Tabelle ist entscheidend für Entwickler, die das `PanelWidget` verwenden oder erweitern, da sie einen klaren API-Vertrag bereitstellt und die Kernfunktionalitäten dokumentiert. Sie erfüllt die Anforderung der Anfrage nach exakten Methodensignaturen.
```

### 2.1.6. Signale

Signale ermöglichen die Kommunikation von Zustandsänderungen oder Ereignissen des `PanelWidget`.

- **Benutzerdefinierte Signale**:
    
    - `module-layout-changed`:
        - Parameter: Keine.
        - Emission: Wird emittiert, nachdem Module hinzugefügt, entfernt oder neu angeordnet wurden.
        - Zweck: Ermöglicht anderen UI-Komponenten oder Logikmodulen, auf Änderungen im Panel-Layout zu reagieren.
- **Verbundene Signale**:
    
    - Lauscht auf `ThemeChangedEvent` von `domain::theming::ThemingEngine`:
        - Handler-Aktion: Aktualisiert die Eigenschaft `leuchtakzent-color` und andere themenabhängige visuelle Aspekte. Fordert ein Neuzeichnen des Panels an (`self.queue_draw()`).
    - Verbindet sich mit `notify::gtk-theme-name` und `notify::gtk-application-prefer-dark-theme` von `gtk::Settings::default()` 10:
        - Handler-Aktion: Lädt bei Bedarf Panel-spezifisches CSS neu oder passt Stile an, um Änderungen im System-Theme oder Dark-Mode-Präferenzen Rechnung zu tragen.
    
    **Tabelle: `PanelWidget` emittierte Signale**
    

|   |   |   |
|---|---|---|
|**Signalname**|**Parameter**|**Beschreibung**|
|`module-layout-changed`|Keine|Wird emittiert, wenn sich die Anordnung oder der Satz der Module im Panel ändert.|

```
**Tabelle: `PanelWidget` verbundene Signale**
```

|   |   |   |
|---|---|---|
|**Quelle**|**Signal**|**Handler-Aktion**|
|`domain::theming::ThemingEngine`|`ThemeChangedEvent`|Aktualisiert `leuchtakzent-color`, fordert Neuzeichnen an.|
|`gtk::Settings::default()`|`notify::gtk-theme-name`|Lädt bei Bedarf panel-spezifisches CSS neu oder passt Stile an.|
|`gtk::Settings::default()`|`notify::gtk-application-prefer-dark-theme`|Passt Stile für Dark Mode an, lädt ggf. spezifisches CSS.|

```
*Bedeutung der Tabellen:* Diese Tabellen verdeutlichen die ereignisgesteuerten Interaktionen des `PanelWidget`. Dies ist entscheidend für das Verständnis seines dynamischen Verhaltens und für das Debugging.
```

### 2.1.7. Ereignisbehandlung

- Das `PanelWidget` behandelt primär interne Layout-Aktualisierungen, die durch Eigenschaftsänderungen oder das Hinzufügen/Entfernen von Modulen ausgelöst werden.
- Mausereignisse (z.B. `enter-notify-event`, `leave-notify-event` für Tooltips auf dem Panel selbst, falls vorhanden) werden über `gtk::EventControllerMotion` gehandhabt.70 Das Panel selbst wird jedoch in der Regel keinen komplexen Mausinteraktionen ausgesetzt sein; diese werden von den einzelnen Modulen übernommen.
- Tastaturereignisse werden nicht direkt vom `PanelWidget` verarbeitet. Der Tastaturfokus wird von den einzelnen, fokussierbaren Panel-Modulen verwaltet.

### 2.1.8. Interaktionen

- **`domain::global_settings_and_state_management`**:
    - Liest die Panel-Konfiguration (Position, Höhe, Transparenzoptionen, Liste und Reihenfolge der Module) beim Start.
    - Beobachtet Änderungen an diesen Einstellungen (z.B. über `gio::Settings` 21 oder ein anwendungsspezifisches Event-System), um das Panel dynamisch zu aktualisieren. Änderungen an Eigenschaften wie `position` oder `panel-height` führen zu Aufrufen von `setup_layer_shell` und `update_layout`.
- **`system::compositor`**:
    - Die Interaktion erfolgt indirekt über die `gtk4-layer-shell`-Bibliothek.26 Das `PanelWidget` deklariert sich als Layer Surface (z.B. `Layer::Top`), setzt Anker und Margins, um seine Position und Größe relativ zum Output zu definieren.
- **`domain::theming::ThemingEngine`**:
    - Abonniert das `ThemeChangedEvent`, um Design-Tokens (insbesondere für `leuchtakzent-color` und Hintergrund) zu erhalten und anzuwenden. Dies löst ein Neuzeichnen des Panels aus.

### 2.1.9. Ausnahmebehandlung

Zur robusten Fehlerbehandlung wird ein spezifischer Fehlertyp für das `PanelWidget` definiert.

- **`enum PanelWidgetError`** (definiert mit `thiserror` 72):
    - `LayerShellInitializationFailed(String)`: Wird zurückgegeben oder geloggt, wenn die Initialisierung mit `gtk4-layer-shell` fehlschlägt (z.B. wenn der Compositor das Protokoll nicht unterstützt).
    - `SettingsReadError(String)`: Wenn die Panel-Konfiguration nicht gelesen werden kann.
    - `InvalidModulePosition(String)`: Wenn versucht wird, ein Modul an einer ungültigen Position hinzuzufügen.
- Fehler werden über das `tracing`-Crate geloggt 73, um Diagnose und Debugging zu erleichtern. Kritische Fehler, die die Funktionalität des Panels verhindern (z.B. `LayerShellInitializationFailed`), können dazu führen, dass das Panel nicht angezeigt wird, mit einer entsprechenden Log-Meldung.

### 2.1.10. Auflösung "Untersuchungsbedarf"

- **Best Practices für `gtk4-layer-shell`-Integration**:
    - Die Initialisierung der Layer-Shell-Eigenschaften (`gtk_layer_shell::init_for_window`, `set_layer`, `set_anchor`, `set_margin`, `auto_exclusive_zone_enable`) muss erfolgen, _bevor_ das Panel-Fenster zum ersten Mal realisiert/gemappt wird. Dies geschieht typischerweise im `constructed`-Handler oder kurz vor dem ersten `present()`-Aufruf.26
    - Der Tastaturinteraktivitätsmodus sollte sorgfältig gewählt werden. Für ein typisches Panel ist `gtk_layer_shell::KeyboardMode::None` oft angemessen, da die Panel-Module selbst den Fokus handhaben. `KeyboardMode::OnDemand` könnte relevant sein, wenn das Panel selbst oder bestimmte nicht-interaktive Bereiche des Panels temporär Fokus benötigen könnten.29
    - Ein eindeutiger Namespace (z.B. "novade-panel") sollte mittels `gtk_layer_shell::set_namespace` gesetzt werden. Dies hilft dem Compositor, verschiedene Layer-Shell-Clients zu identifizieren.29
    - Für Multi-Monitor-Setups: Das Panel kann über `gtk_layer_shell::set_monitor` einem spezifischen Monitor zugewiesen werden. Um Panels auf allen Monitoren darzustellen, müsste für jeden Monitor eine eigene `PanelWidget`-Instanz erstellt und konfiguriert werden. Die Liste der Monitore ist über `gdk::Display::monitors()` zugänglich.74 Änderungen in der Monitorkonfiguration (An-/Abstecken) können über Signale von `gdk::Display` (`monitor-added`, `monitor-removed`) überwacht werden.
- **Implementierung des konfigurierbaren "Leuchtakzents" mit Cairo/GSK**:
    - Das `PanelWidget` (oder eine dedizierte Kind-`gtk::DrawingArea`, die unter den Modul-Containern liegt) verbindet sich mit dem `draw`-Signal.
    - Im Draw-Handler (`fn draw_background_and_accent`):
        1. Die aktuellen Werte der Eigenschaften `leuchtakzent-color` (ein `gdk::RGBA`) und `leuchtakzent-intensity` (ein `f64` zwischen 0.0 und 1.0) werden abgerufen.
        2. Der `cairo::Context` (`cr`) wird verwendet.
        3. **Hintergrund zeichnen**: Zuerst wird der Panel-Hintergrund gezeichnet. Wenn Transparenz (`transparency-enabled`) aktiv ist, wird `cr.set_source_rgba()` mit einem Alpha-Wert < 1.0 verwendet. Ansonsten eine deckende Farbe gemäß Theme. Abgerundete Ecken, falls spezifiziert, werden hier berücksichtigt (z.B. mit `arc_to` und `line_to` Pfaden).
        4. **Leuchtakzent-Pfad definieren**: Ein Pfad wird für den Leuchteffekt erstellt. Dies könnte eine Linie oder ein schmales Rechteck entlang der Kante des Panels sein, die dem Bildschirmzentrum zugewandt ist. Die Position hängt von der `position`-Eigenschaft des Panels ab (oben oder unten).
        5. **Leuchtakzent zeichnen**:
            - **Farbe und Intensität**: `cr.set_source_rgba()` wird mit der `leuchtakzent-color` und einer durch `leuchtakzent-intensity` modulierten Alpha-Komponente aufgerufen.
            - **Weicher Effekt**: Um einen weichen "Glow"-Effekt zu erzielen, können verschiedene Cairo-Techniken verwendet werden:
                - **Gradienten**: Ein `cairo::LinearGradient` kann erstellt werden, der von der Akzentfarbe zu einer transparenten Version derselben Farbe oder zur Hintergrundfarbe übergeht. Der Gradient wird so ausgerichtet, dass er senkrecht zur Panelkante verläuft und nach außen hin ausblendet.41
                - **Mehrfaches Zeichnen mit Unschärfe (simuliert)**: Da Cairo keine direkte Gausssche Unschärfe für Pfade bietet, kann ein ähnlicher Effekt durch mehrfaches Zeichnen des Akzentpfades mit leicht variierenden Offsets, Größen und abnehmender Deckkraft erzielt werden. Dies ist rechenintensiv und sollte mit Bedacht eingesetzt werden.
                - **Schatten-API (falls anwendbar)**: Obwohl Cairo keine direkte `box-shadow`-Entsprechung für Pfade hat, könnte man einen Schatten simulieren, indem man eine versetzte, gefärbte und leicht transparente Version des Panelrands zeichnet und darüber den eigentlichen Panelinhalt.
            - Die gezeichneten Elemente müssen die `panel-height` und die Gesamtbreite des Panels berücksichtigen.
        6. Die GSK-Rendering-Pipeline von GTK4 wird diese Cairo-Operationen effizient auf die GPU übertragen.64 Es ist wichtig, `queue_draw()` nur dann aufzurufen, wenn sich visuelle Aspekte tatsächlich ändern, um unnötiges Neuzeichnen zu vermeiden.
    - Die Transparenz des Panel-Fensters selbst wird über `gtk_widget_set_opacity()` 68 und die korrekte Konfiguration des GDK-Visuals für RGBA-Unterstützung gehandhabt, falls der Compositor dies erfordert und unterstützt.34

### 2.1.11. Dateistruktur

Die Implementierung des `PanelWidget` wird in folgendem Verzeichnisbaum organisiert:

```
src/
└── ui/
    └── shell/
        └── panel_widget/
            ├── mod.rs              // Öffentliche API, GObject Wrapper (PanelWidget struct)
            ├── imp.rs              // Private GObject Implementierung (Subclass-Logik)
            ├── panel_widget.ui     // (Optional) XML-Definition für Composite Template
            └── error.rs            // (Optional) Definition von PanelWidgetError
```

- `mod.rs`: Enthält die `glib::wrapper!` Makrodefinition und öffentliche Methoden, die an die `imp`-Struktur delegieren.
- `imp.rs`: Beinhaltet die `#` Struktur, die `#[glib::object_subclass]` Implementierung und die Implementierungen für `ObjectImpl`, `WidgetImpl`, `WindowImpl`, und `ApplicationWindowImpl`. Hier werden Eigenschaften und Signale definiert und die Kernlogik des Widgets implementiert.
- `panel_widget.ui`: Falls Composite Templates für das interne Layout des Panels (z.B. die Anordnung von `start_box`, `center_box`, `end_box`) verwendet werden, wird die XML-Struktur hier definiert.56
- `error.rs`: Definiert `PanelWidgetError` unter Verwendung von `thiserror`.

Diese Struktur fördert die Modularität und Trennung von öffentlicher Schnittstelle und Implementierungsdetails, wie es in der `gtk-rs` Community üblich ist.5

---

### 2.2. Sub-Modul: `ui::shell::panel_widget::AppMenuButton`

#### 2.2.1. Übersicht und Verantwortlichkeiten

Das `AppMenuButton` ist ein spezialisiertes Panel-Modul, das als `gtk::MenuButton` (oder eine benutzerdefinierte Ableitung davon) implementiert wird. Seine Hauptverantwortung ist die Darstellung des globalen Anwendungsmenüs der aktuell fokussierten Applikation. Hierzu muss es:

1. Den `app_id` (oder eine äquivalente Kennung) des aktiven Fensters ermitteln.
2. Basierend auf dem `app_id` das `gio::MenuModel` der aktiven Anwendung über D-Bus abrufen.
3. Das abgerufene Menümodell in einem `gtk::PopoverMenu` darstellen, das beim Klick auf den Button erscheint.
4. Das Aussehen des Buttons dynamisch an die aktive Anwendung anpassen (z.B. Icon und/oder Name anzeigen).

Die Komplexität dieser Komponente ergibt sich aus der Notwendigkeit, mit externen Systemkomponenten (Wayland Compositor für Fensterinformationen, D-Bus für Menüdaten) zu interagieren und auf Änderungen des Fensterfokus zu reagieren.

#### 2.2.2. Visuelles Design und Theming

- **Anzeige**: Zeigt typischerweise das Icon der aktiven Anwendung. Falls kein Icon verfügbar ist oder keine Anwendung ein Menü bereitstellt, wird ein generisches "Anwendungsmenü"-Icon oder ein Platzhaltertext angezeigt.
- **Beschriftung**: Kann optional den Namen der aktiven Anwendung neben dem Icon anzeigen, abhängig von der Konfiguration und dem verfügbaren Platz im Panel.
- **Styling**:
    - Als Instanz von `gtk::MenuButton` oder einer benutzerdefinierten, von `gtk::Button` abgeleiteten Klasse, die ein Popover öffnet. Es kann als `ui::components::StyledButtonWidget` implementiert werden, um ein konsistentes Erscheinungsbild mit anderen Buttons im Panel zu gewährleisten.
    - **CSS-Knoten**: `button` (wenn von `gtk::Button` abgeleitet) oder `menubutton` (wenn von `gtk::MenuButton`).
    - **CSS-Klassen**:
        - `.app-menu-button`: Allgemeine Klasse für spezifisches Styling.
        - `.active-app`: Wenn ein Anwendungsmenü erfolgreich geladen wurde.
        - `.no-app-menu`: Wenn kein Menü für die aktive Anwendung verfügbar ist oder keine Anwendung fokussiert ist.
- Der Tooltip des Buttons zeigt den Namen der aktiven Anwendung an, falls nicht bereits als Label sichtbar.76

#### 2.2.3. Datenstrukturen, Eigenschaften und Zustand

Das `AppMenuButton` wird als GObject-Widget implementiert.

- **GObject-Definition (`AppMenuButton`)**:
    
    _Auszug aus `src/ui/shell/panel_widget/app_menu_button/imp.rs` (vereinfacht):_
    
    Rust
    
    ```
    use gtk::glib;
    use gtk::subclass::prelude::*;
    use gtk::{gio, CompositeTemplate};
    use std::cell::{Cell, RefCell};
    use once_cell::sync::Lazy;
    use zbus::Connection; // [12]
    
    // Enum für den Status der Menüabfrage
    #
    pub enum MenuFetchStatus {
        #[default]
        Idle,
        Loading,
        Success,
        Error(String), // Enthält Fehlermeldung
    }
    
    static APP_MENU_BUTTON_PROPERTIES: Lazy<Vec<glib::ParamSpec>> = Lazy::new(|| {
        vec!
    });
    
    #
    pub struct AppMenuButton {
        // Eigenschaften
        active_app_id: RefCell<Option<String>>,
        active_app_name: RefCell<Option<String>>,
        active_app_icon_name: RefCell<Option<String>>,
        has_menu: Cell<bool>,
        menu_fetch_status: RefCell<MenuFetchStatus>,
    
        // Interner Zustand
        current_menu_model: RefCell<Option<gio::MenuModel>>,
        dbus_connection: RefCell<Option<Connection>>, // Zbus-Verbindung [12]
    
        // Referenz auf das GtkMenuButton-Widget selbst (oder das Popover, falls custom)
        menu_button_widget: RefCell<Option<gtk::MenuButton>>, // Wird in constructed gesetzt
    }
    
    #[glib::object_subclass]
    impl ObjectSubclass for AppMenuButton {
        const NAME: &'static str = "NovaDEAppMenuButton";
        type Type = super::AppMenuButton;
        type ParentType = gtk::MenuButton; // Oder gtk::Button, wenn ein Popover manuell verwaltet wird
    
        fn new() -> Self {
            Self {
                active_app_id: RefCell::new(None),
                active_app_name: RefCell::new(None),
                active_app_icon_name: RefCell::new(None),
                has_menu: Cell::new(false),
                menu_fetch_status: RefCell::new(MenuFetchStatus::Idle),
                current_menu_model: RefCell::new(None),
                dbus_connection: RefCell::new(None),
                menu_button_widget: RefCell::new(None),
            }
        }
    
        fn class_init(klass: &mut Self::Class) {
            klass.install_properties(&APP_MENU_BUTTON_PROPERTIES);
            // CSS-Name setzen
            klass.set_css_name("appmenubutton");
        }
    }
    
    impl ObjectImpl for AppMenuButton {
        fn constructed(&self) {
            self.parent_constructed();
            let obj = self.obj();
            // Speichere eine Referenz auf das Widget selbst für einfachen Zugriff
            // self.menu_button_widget.replace(Some(obj.clone()));
    
            // Initialisiere D-Bus Verbindung und abonniere aktive Fensteränderungen
            // Dies sollte idealerweise asynchron geschehen.
            let widget = obj.clone();
            glib::MainContext::default().spawn_local(async move {
                match Connection::session().await { // [12]
                    Ok(conn) => {
                        widget.imp().dbus_connection.replace(Some(conn));
                        // Hier Logik zum Abonnieren von Änderungen des aktiven Fensters einfügen
                        // z.B. über einen internen Service, der Wayland-Events verarbeitet
                        // widget.subscribe_to_active_window_changes();
                    }
                    Err(e) => {
                        tracing::error!("Failed to connect to D-Bus for AppMenuButton: {}", e);
                        widget.imp().menu_fetch_status.replace(MenuFetchStatus::Error(format!("D-Bus connection failed: {}", e)));
                        widget.update_button_appearance_and_state();
                    }
                }
            });
            obj.update_button_appearance_and_state(); // Initiales Aussehen
        }
    
        fn properties() -> &'static {
            APP_MENU_BUTTON_PROPERTIES.as_ref()
        }
    
        fn property(&self, _id: usize, pspec: &glib::ParamSpec) -> glib::Value {
            match pspec.name() {
                "active-app-name" => self.active_app_name.borrow().to_value(),
                "active-app-icon-name" => self.active_app_icon_name.borrow().to_value(),
                "has-menu" => self.has_menu.get().to_value(),
                _ => unimplemented!(),
            }
        }
        // set_property ist hier nicht nötig, da die Eigenschaften Read-only sind und intern gesetzt werden.
    }
    impl WidgetImpl for AppMenuButton {
        fn map(&self) {
            self.parent_map();
            // Beim Sichtbarwerden ggf. aktuellen Status neu abfragen
            self.obj().trigger_menu_update_for_current_app();
        }
    }
    impl ButtonImpl for AppMenuButton {} // Falls ParentType gtk::Button
    impl MenuButtonImpl for AppMenuButton {} // Falls ParentType gtk::MenuButton
    ```
    
- **Eigenschaften (Properties)**:
    
    **Tabelle: `AppMenuButton` Eigenschaften**
    

|   |   |   |   |   |
|---|---|---|---|---|
|**Eigenschaftsname**|**Typ**|**Zugriff**|**Standardwert**|**Beschreibung**|
|`active-app-name`|`Option<String>`|Nur Lesen|`None`|Name der Anwendung, deren Menü aktuell angezeigt wird oder angezielt ist.|
|`active-app-icon-name`|`Option<String>`|Nur Lesen|`None`|Icon-Name (für Theming) der Anwendung, deren Menü angezielt ist.|
|`has-menu`|`bool`|Nur Lesen|`false`|`true`, wenn ein Menü für die aktive Anwendung verfügbar und geladen ist.|

```
*Bedeutung der Tabelle:* Definiert den beobachtbaren Zustand des `AppMenuButton`, nützlich für Binding oder um auf Änderungen im Menü der aktiven Anwendung zu reagieren.
```

- **Interner Zustand**:
    - `active_app_id: RefCell<Option<String>>`: Speichert die ID der aktuell fokussierten Anwendung.
    - `menu_fetch_status: RefCell<MenuFetchStatus>`: Verfolgt den Zustand des Menüabrufs.
    - `current_menu_model: RefCell<Option<gio::MenuModel>>`: Hält das aktuell geladene Menümodell.
    - `dbus_connection: RefCell<Option<zbus::Connection>>`: Die D-Bus-Verbindung für Abfragen.

#### 2.2.4. GTK-Widget-Implementierung

- Das `AppMenuButton` erbt von `gtk::MenuButton`.77 Diese Klasse bietet bereits die Funktionalität, ein Popover beim Klick anzuzeigen.
- Das Popover wird ein `gtk::PopoverMenu` sein.79
- Die Eigenschaft `menu-model` des `gtk::MenuButton` (oder des internen `gtk::PopoverMenu`) wird dynamisch mit dem über D-Bus abgerufenen `gio::MenuModel` aktualisiert.
    - `gtk::MenuButton::set_menu_model(Some(menu_model))`
    - Wenn kein Menü verfügbar ist, wird `gtk::MenuButton::set_menu_model(None)` gesetzt oder das Popover deaktiviert.

#### 2.2.5. Methoden und Funktionssignaturen

- **Öffentliche Methoden (vom Panel oder einem Dienst für aktive Fenster aufgerufen)**:
    
    - `pub fn update_active_window_info(&self, app_id: Option<String>, window_title: Option<String>, icon_name: Option<String>) noexcept;`
        - Wird aufgerufen, wenn sich das aktive Fenster _oder_ dessen Metadaten ändern.
        - Speichert `app_id`, `window_title`, `icon_name` intern.
        - Löst `trigger_menu_update_for_current_app` aus.
        - Aktualisiert sofort das Aussehen des Buttons (Icon/Label) basierend auf `icon_name` und `window_title`/`app_id`.
- **Interne Methoden**:
    
    - `fn trigger_menu_update_for_current_app(&self) noexcept;`
        - Prüft, ob `active_app_id` gesetzt ist.
        - Wenn ja, startet die asynchrone `fetch_menu_for_app`-Operation.
        - Setzt `menu_fetch_status` auf `Loading`.
        - Aktualisiert das Button-Aussehen (z.B. Ladeindikator).
    - `async fn fetch_menu_for_app(dbus_conn: Connection, app_id: String) -> Result<gio::MenuModel, AppMenuError>;`
        - Diese Funktion ist `async` und wird mit `glib::MainContext::spawn_local` ausgeführt.7
        - Versucht, das `gio::MenuModel` für den gegebenen `app_id` über D-Bus zu beziehen (siehe 2.2.8 Interaktionen).
        - Gibt das `gio::MenuModel` oder einen `AppMenuError` zurück.
    - `fn handle_menu_fetch_result(&self, result: Result<gio::MenuModel, AppMenuError>) noexcept;`
        - Wird im `glib::MainContext` aufgerufen, nachdem `fetch_menu_for_app` abgeschlossen ist.
        - Aktualisiert `current_menu_model`, `has_menu`, und `menu_fetch_status`.
        - Ruft `display_menu` und `update_button_appearance_and_state` auf.
    - `fn display_menu(&self) noexcept;`
        - Setzt das `current_menu_model` auf den `gtk::MenuButton`.
    - `fn update_button_appearance_and_state(&self) noexcept;`
        - Aktualisiert Icon (z.B. `gtk::Image::set_from_icon_name` 84) und Label des `gtk::MenuButton` basierend auf `active_app_icon_name`, `active_app_name` und `menu_fetch_status`.
        - Setzt den `sensitive`-Zustand des Buttons (z.B. deaktiviert, wenn kein Menü geladen werden kann oder `Loading`).
        - Aktualisiert die GObject-Properties (`active-app-name`, `active-app-icon-name`, `has-menu`) und emittiert `notify` Signale.
    
    **Tabelle: `AppMenuButton` Methoden (Auswahl)**
    

|   |   |   |   |
|---|---|---|---|
|**Signatur**|**Beschreibung**|**async**|**noexcept**|
|`pub fn update_active_window_info(&self, app_id: Option<String>, window_title: Option<String>, icon_name: Option<String>)`|Aktualisiert die Informationen über das aktive Fenster und löst ggf. eine Menüaktualisierung aus.|Nein|Ja|
|`fn trigger_menu_update_for_current_app(&self)`|Startet den Prozess zum Abrufen und Anzeigen des Menüs für die aktuell zwischengespeicherte `app_id`.|Nein|Ja|
|`async fn fetch_menu_for_app(dbus_conn: Connection, app_id: String) -> Result<gio::MenuModel, AppMenuError>`|Ruft asynchron das `GMenuModel` für die gegebene `app_id` über D-Bus ab.|Ja|Nein|
|`fn handle_menu_fetch_result(&self, result: Result<gio::MenuModel, AppMenuError>)`|Verarbeitet das Ergebnis von `fetch_menu_for_app`, aktualisiert den internen Zustand und die UI.|Nein|Ja|

#### 2.2.6. Signale

- **Benutzerdefinierte Signale**: Keine spezifischen benutzerdefinierten Signale für diese Komponente vorgesehen. Es erbt die Signale von `gtk::MenuButton` (z.B. `clicked`, `activate`).
- **Verbundene Signale**:
    - Intern: Lauscht auf ein Signal von einem übergeordneten Dienst (z.B. innerhalb von `ui::shell`), das Änderungen des aktiven Fensters (`app_id`, Titel, Icon) meldet.

#### 2.2.7. Ereignisbehandlung

- Die Hauptinteraktion ist der Klick auf den Button, der durch die `gtk::MenuButton`-Basisklasse gehandhabt wird und das Popover mit dem Menü anzeigt.
- Interne Reaktionen auf die Ergebnisse der asynchronen D-Bus-Menüabfrage und auf Änderungen des aktiven Fensters sind entscheidend für die dynamische Aktualisierung.

#### 2.2.8. Interaktionen

- **`system::compositor` (Fensterinformationen)**:
    
    - Das `AppMenuButton` selbst interagiert nicht direkt mit dem Compositor. Es ist auf einen Dienst innerhalb der `ui::shell` angewiesen, der Informationen über das aktive Fenster bereitstellt. Dieser Dienst nutzt Wayland-Protokolle.
    - **Wayland-Protokolle**:
        - `wlr-foreign-toplevel-management-unstable-v1`: Dieses Protokoll ermöglicht es einem Client (dem NovaDE-Shell-Dienst), eine Liste von Toplevel-Fenstern zu erhalten und deren Zustände (inkl. `app_id`, `title`, `state`) zu überwachen. Der Dienst würde das `activated`-Ereignis nutzen, um das aktuell fokussierte Fenster zu identifizieren.85
        - `ext-foreign-toplevel-list-v1`: Ein alternatives oder ergänzendes Protokoll, das ebenfalls zur Auflistung von Toplevel-Fenstern dient.85
    - Die Implementierung dieser Wayland-Client-Logik sollte zentral in einem `ui::shell`-Modul erfolgen (z.B. `ui::shell::active_window_service`) und nicht im `AppMenuButton` selbst, um Redundanz zu vermeiden und die Komplexität zu kapseln. Dieser Dienst würde dann ein internes Signal oder einen Event für das `AppMenuButton` bereitstellen.
- **D-Bus (Menüabruf)**:
    
    - Sobald der `app_id` des aktiven Fensters bekannt ist, wird versucht, dessen Menümodell über D-Bus abzurufen.
    - **Primärer Mechanismus (`org.gtk.Menus`)**:
        - GTK4-Anwendungen, die `GApplication` verwenden, exportieren ihre Menüs (typischerweise `GMenuModel` für Anwendungsmenü und Menüleiste) oft über D-Bus unter ihrem eigenen Bus-Namen (welcher dem `app_id` entspricht, z.B. `org.gnome.TextEditor`).
        - Der Standard-Objektpfad für das Menü ist oft `/org/gtk/menus/menubar` oder ein ähnlicher, durch `GApplication` festgelegter Pfad.91
        - Die Schnittstelle ist `org.gtk.Menus`.
        - `gio::DBusMenuModel::new(bus_name, object_path)` kann verwendet werden, um ein `GMenuModel` direkt von einem D-Bus-Dienst zu erstellen, was die Details der Methodenaufrufe abstrahiert.21
    - **Fallback-Mechanismus (`com.canonical.AppMenu.Registrar`)**:
        - Ein älterer Mechanismus, der von Unity verwendet wurde. Anwendungen registrieren ihre Fenster-ID und den D-Bus-Pfad zu ihrem Menü bei diesem Dienst.15
        - Dienstname: `com.canonical.AppMenu.Registrar`
        - Objektpfad: `/com/canonical/AppMenu/Registrar`
        - Schnittstelle: `com.canonical.AppMenu.Registrar`
        - Methode: `GetMenuForWindow(window_id_uint32)`. Dies ist problematisch in einer reinen Wayland-Umgebung, da X11-Fenster-IDs nicht direkt verfügbar oder relevant sind. Eine Wayland-kompatible Anwendung müsste ihren Menüpfad auf andere Weise bekannt geben.
    - **D-Bus-Client-Implementierung**: Das `zbus`-Crate wird verwendet, um D-Bus-Proxies zu erstellen und Methoden aufzurufen.12
        - Ein `zbus::Proxy` wird für den Zieldienst erstellt (entweder der `app_id` oder `com.canonical.AppMenu.Registrar`).
        - Die entsprechenden Methoden werden asynchron aufgerufen.
        - Das Ergebnis (oft ein Pfad zu einem `DBusMenu`-Objekt) wird verwendet, um ein `gio::MenuModel` zu instanziieren, typischerweise mit `gio::DBusMenuModel`.
    
    **Tabelle: `AppMenuButton` D-Bus Interaktionen**
    

|   |   |   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|---|---|
|**Interaktion**|**Zieldienst (Primär)**|**Objektpfad (Primär)**|**Schnittstelle (Primär)**|**Methode/Eigenschaft (Primär)**|**Zieldienst (Fallback)**|**Objektpfad (Fallback)**|**Schnittstelle (Fallback)**|**Methode (Fallback)**|
|GMenuModel für aktive Anwendung abrufen|`[app_id_der_aktiven_Anwendung]`|`/org/gtk/menus/menubar` (oder Konvention)|`org.gtk.Menus` (oder `org.freedesktop.DBus.Properties`)|`gio::DBusMenuModel::new(bus_name, object_path)` (abstrahiert Methodenaufrufe)|`com.canonical.AppMenu.Registrar`|`/com/canonical/AppMenu/Registrar`|`com.canonical.AppMenu.Registrar`|`GetMenuForWindow` (XID-abhängig) oder App registriert Menüpfad|

```
*Bedeutung der Tabelle:* Verdeutlicht die komplexen D-Bus-Interaktionen, die für das Abrufen von Anwendungsmenüs erforderlich sind. Dies ist entscheidend für die Implementierung und das Debugging, insbesondere angesichts der verschiedenen Mechanismen, über die Menüs bereitgestellt werden können.
```

#### 2.2.9. Ausnahmebehandlung

- **`enum AppMenuError`** (definiert mit `thiserror` 72):
    - `WaylandError(String)`: Fehler beim Abrufen von Informationen zum aktiven Fenster.
    - `DBusConnectionError(zbus::Error)`: Fehler bei der D-Bus-Kommunikation.
    - `MenuServiceUnavailable(String)`: Der D-Bus-Dienst für die Anwendung (z.B. `app_id` oder `AppMenu.Registrar`) ist nicht erreichbar.
    - `MenuNotFound(String)`: Die Anwendung (`app_id`) exportiert kein bekanntes Menü oder das Menü ist leer.
    - `MenuModelParseError(String)`: Fehler beim Parsen oder Interpretieren der Menüdaten.
- Im Fehlerfall zeigt der `AppMenuButton` einen deaktivierten Zustand oder ein generisches Icon an. Fehlerdetails werden über `tracing` geloggt.73

#### 2.2.10. Auflösung "Untersuchungsbedarf"

- **Zuverlässige Methode zur Ermittlung des aktiven Fensters/`app_id` unter Wayland**:
    - Die bevorzugte Methode ist die Verwendung des `wlr-foreign-toplevel-management-unstable-v1`-Protokolls.86 Ein zentraler Shell-Dienst (nicht der `AppMenuButton` selbst) agiert als Client dieses Protokolls.
    - Der Dienst bindet sich an den globalen `zwlr_foreign_toplevel_manager_v1`.
    - Für jedes gemeldete Toplevel (`zwlr_foreign_toplevel_handle_v1`) lauscht der Dienst auf die Ereignisse `app_id`, `title` und `state`.
    - Das `state`-Ereignis enthält Flags, darunter `activated`. Das Toplevel mit dem `activated`-Flag ist das aktuell fokussierte Fenster.
    - Die `smithay-client-toolkit` 85 könnte Rust-Abstraktionen für dieses Protokoll bereitstellen. Falls nicht, ist die direkte Verwendung von `wayland-client` mit den `wayland-protocols`-Bindings (speziell `wlr-protocols`) notwendig.89
    - Dieser zentrale Dienst stellt dann die Informationen über das aktive Fenster (insbesondere `app_id`, `title`, `icon_name`) dem `AppMenuButton` und anderen interessierten UI-Komponenten über ein internes Event-System oder Signale zur Verfügung.
- **Ermittlung und Konsumierung von `GMenuModel` via D-Bus**:
    - **Primärer Pfad (für GTK4-Anwendungen)**: Moderne GTK-Anwendungen, die `GApplication` verwenden, exportieren ihr Hauptmenü (`GMenuModel`) typischerweise über D-Bus auf ihrem eigenen, durch den `app_id` bestimmten Bus-Namen. Der Objektpfad ist oft standardisiert, z.B. `/org/gtk/menus/menubar` oder ein anderer Pfad, den `GApplication` für diesen Zweck nutzt.91 Ein `gio::DBusMenuModel` wird dann mit diesem Bus-Namen und Objektpfad instanziiert, um das Menümodell zu erhalten.21
    - **Fallback (StatusNotifierItem)**: Falls eine Anwendung ein `StatusNotifierItem` bereitstellt, kann dessen `Menu`-Eigenschaft einen D-Bus-Objektpfad zu einem Menü (oft im `com.canonical.dbusmenu`-Format) enthalten.102 Dies ist relevant, wenn die Anwendung primär über ein Tray-Icon interagiert.
    - **Fallback (AppMenu Registrar)**: Der `com.canonical.AppMenu.Registrar` D-Bus-Dienst ist ein älterer Mechanismus.15 Seine Verwendung in einer reinen Wayland-Umgebung ist aufgrund der Abhängigkeit von X11-Fenster-IDs problematisch und sollte nur als letzte Option in Betracht gezogen werden, falls Anwendungen keine anderen Mechanismen anbieten.
    - **Implementierungsentscheidung**: Die Strategie sollte sein, zuerst den primären Pfad (`org.gtk.Menus` auf dem `app_id`-Bus) zu versuchen. Schlägt dies fehl und ist ein `StatusNotifierItem` für die App vorhanden, kann dessen Menüpfad versucht werden. Der `AppMenuRegistrar` wird aufgrund seiner X11-Lastigkeit tendenziell vermieden.
    - Das `AppMenuButton` verwendet das erhaltene `gio::MenuModel`, um seinen internen `gtk::PopoverMenu` zu füllen.79

Die Implementierung des `AppMenuButton` erfordert eine sorgfältige Orchestrierung asynchroner Operationen für Wayland-Events und D-Bus-Aufrufe, um die UI reaktionsfähig zu halten (`glib::MainContext::spawn_local` 7). Fehlerzustände (z.B. keine aktive Anwendung, keine Menüdaten, D-Bus-Fehler) müssen robust gehandhabt und dem Benutzer klar signalisiert werden (z.B. durch ein deaktiviertes oder generisches Icon).

#### 2.2.11. Dateistruktur

```
src/
└── ui/
    └── shell/
        └── panel_widget/
            └── app_menu_button/
                ├── mod.rs          // Öffentliche API, GObject Wrapper (AppMenuButton struct)
                ├── imp.rs          // Private GObject Implementierung
                ├── dbus.rs         // Logik für D-Bus Interaktionen (Menüabruf)
                └── error.rs        // Definition von AppMenuError
```

Diese Struktur kapselt die Komplexität des `AppMenuButton` und trennt die D-Bus-Logik klar ab.

---

**(Hinweis: Die detaillierte Ausarbeitung weiterer Submodule des `PanelWidget` wie `WorkspaceIndicatorWidget`, `ClockDateTimeWidget`, `SystemTrayEquivalentWidget` etc. würde einem ähnlichen Detaillierungsgrad folgen und die spezifischen "Untersuchungsbedarfe" adressieren. Insbesondere das `SystemTrayEquivalentWidget` erfordert eine tiefgreifende Auseinandersetzung mit der `StatusNotifierItem`-Spezifikation und deren D-Bus-Implementierung mittels `zbus`, wie in der Gliederung angedeutet.102)**

Die Implementierung eines `SystemTrayEquivalentWidget` ist ein komplexes Unterfangen, da Wayland selbst kein natives "System Tray"-Protokoll definiert. Die De-facto-Standardlösung ist die `StatusNotifierItem` (SNI) Spezifikation von Freedesktop.org, die auf D-Bus basiert.102

Ein `SystemTrayEquivalentWidget` müsste folgende Kernkomponenten umfassen:

1. **StatusNotifierHost-Registrierung**: Das Panel (oder dieses Widget) muss sich als `org.freedesktop.StatusNotifierHost` auf dem Session-Bus registrieren. Dies signalisiert dem `StatusNotifierWatcher`, dass ein Host für Items vorhanden ist.106 Die Registrierung erfolgt typischerweise durch das Anfordern eines eindeutigen Bus-Namens (z.B. `org.freedesktop.StatusNotifierHost-PID` oder `org.freedesktop.StatusNotifierHost-NovaDE`).
2. **Interaktion mit StatusNotifierWatcher**:
    - Der `StatusNotifierWatcher` (`org.freedesktop.StatusNotifierWatcher`) ist der zentrale Dienst zur Verwaltung von SNIs.102
    - Das Widget muss diesen Watcher auf dem D-Bus finden (Standardname `org.freedesktop.StatusNotifierWatcher`, Pfad `/org/freedesktop/StatusNotifierWatcher`).
    - Es muss die Methode `RegisterStatusNotifierHost` am Watcher aufrufen, um sich selbst als Host zu registrieren.
    - Es muss die Eigenschaft `RegisteredStatusNotifierItems` des Watchers abfragen, um eine initiale Liste aller bereits vorhandenen SNIs zu erhalten.
    - Es muss die Signale `StatusNotifierItemRegistered` und `StatusNotifierItemUnregistered` des Watchers abonnieren, um dynamisch auf neue oder entfernte SNIs zu reagieren. `zbus` wird hierfür verwendet, um Signal-Handler einzurichten.109
3. **Interaktion mit einzelnen StatusNotifierItems**:
    - Für jeden von `StatusNotifierWatcher` gemeldeten Dienstnamen eines SNI (z.B. `org.freedesktop.StatusNotifierItem-PID-ID`) muss ein `zbus::Proxy` erstellt werden.17
    - Über diesen Proxy werden die Eigenschaften des SNI ausgelesen: `Category`, `Id`, `Title`, `Status`, `WindowId`, `IconName`, `IconPixmap`, `OverlayIconName`, `OverlayIconPixmap`, `AttentionIconName`, `AttentionIconPixmap`, `AttentionMovieName`, `ToolTip`, `ItemIsMenu`, `Menu`.102
    - Signale des SNI (z.B. `NewIcon`, `NewStatus`, `NewToolTip`, `NewMenu`) müssen abonniert werden, um auf Änderungen zu reagieren und die Darstellung des entsprechenden Indikator-Widgets im Panel zu aktualisieren.16
4. **Darstellung der Indikatoren**:
    - Für jedes aktive SNI wird ein kleines Widget im `SystemTrayEquivalentWidget` (das selbst eine `gtk::Box` oder ein ähnlicher Container ist) angezeigt.
    - **Icon**: `IconName` wird verwendet, um ein themenbasiertes Icon über `gtk::Image::from_icon_name` zu laden.84 Falls `IconPixmap` bereitgestellt wird, müssen die Rohpixeldaten (oft ein Array von Tupeln `(width, height, data)`) in ein `gdk_pixbuf::Pixbuf` konvertiert werden (z.B. mit `Pixbuf::from_mut_slice` oder `PixbufLoader`, falls die Daten gestreamt ankommen, was hier aber unwahrscheinlich ist) und dann in einem `gtk::Image` angezeigt werden.117
    - **Tooltip**: Die `ToolTip`-Eigenschaft des SNI (eine Struktur mit Titel, Text, Icon) wird verwendet, um einen Tooltip für das Indikator-Widget mittels `gtk::Widget::set_tooltip_markup` oder `gtk::Widget::set_tooltip_text` zu setzen.76
    - **Status**: Die `Status`-Eigenschaft (`Passive`, `Active`, `NeedsAttention`) kann verwendet werden, um das Aussehen des Indikators anzupassen (z.B. Hervorhebung bei `NeedsAttention`).
5. **Interaktion mit den Indikatoren**:
    - **Linksklick (Activate)**: Ein Klick auf das Indikator-Widget ruft die `Activate(x, y)`-Methode des SNI über D-Bus auf.103
    - **Rechtsklick (ContextMenu)**: Ein Rechtsklick ruft die `ContextMenu(x, y)`-Methode des SNI auf. Wenn die `ItemIsMenu`-Eigenschaft `true` ist und die `Menu`-Eigenschaft einen gültigen D-Bus-Pfad zu einem `com.canonical.dbusmenu`-Objekt enthält, wird dieses Menü abgerufen (mittels `gio::DBusMenuModel` 96) und als `gtk::PopoverMenu` angezeigt.79
    - **Scrollen**: Mausrad-Events über dem Indikator rufen die `Scroll(delta, orientation)`-Methode des SNI auf.
6. **Asynchronität**: Alle D-Bus-Interaktionen (Methodenaufrufe, Signal-Handling) müssen asynchron mit `glib::MainContext::spawn_local` erfolgen, um die UI nicht zu blockieren.7

Die "Alternativen unter Wayland" 104 beziehen sich darauf, dass Wayland selbst kein Tray-Protokoll spezifiziert. StatusNotifierItem ist die etablierte D-Bus-basierte Lösung. Einige Desktop-Umgebungen könnten eigene Protokolle haben, aber für eine breite Kompatibilität ist SNI der Standard. Die Herausforderung besteht darin, dass nicht alle Anwendungen SNI korrekt oder vollständig implementieren.

---

## 3. Übergreifende Belange – Initiale Spezifikationen

Dieser Abschnitt definiert initiale Strategien für Aspekte, die mehrere UI-Module betreffen und eine konsistente Handhabung erfordern.

### 3.1. UI-Zustandsverwaltungsstrategie

Die Verwaltung des UI-Zustands ist entscheidend für eine reaktive und wartbare Benutzeroberfläche. In NovaDE wird ein mehrschichtiger Ansatz verfolgt, der die Stärken von GObject mit Rust-Idiomen kombiniert:

- **GObject-Eigenschaften für Widget-Zustand**:
    - Der primäre Mechanismus zur Verwaltung des Zustands einzelner Widgets sind GObject-Eigenschaften. Diese werden mit dem `glib::Properties`-Derive-Makro und `klass.install_properties()` in der `ObjectSubclass`-Implementierung definiert.47
    - Beispiel: Die `panel-height`-Eigenschaft des `PanelWidget`.
    - Änderungen an diesen Eigenschaften lösen automatisch "notify::property-name"-Signale aus, auf die andere Teile der UI oder die interne Logik des Widgets reagieren können. Explizite Benachrichtigung kann mit `self.obj().notify_propertyName()` erzwungen werden, falls die automatische Benachrichtigung nicht ausreicht oder benutzerdefinierte Logik vor der Benachrichtigung ausgeführt werden muss.
- **Benutzerdefinierte GObject-Signale**:
    - Für komplexere Zustandsänderungen oder Ereignisse, die nicht direkt durch eine einzelne Eigenschaftsänderung abgebildet werden, werden benutzerdefinierte GObject-Signale definiert.115
    - Beispiel: Das `module-layout-changed`-Signal des `PanelWidget`.
    - Signale werden in `ObjectImpl::signals()` definiert und können mit `self.obj().emit_by_name::<()>("signal-name", &[&param1, &param2])` ausgelöst werden.
- **`Rc<RefCell<T>>` für gemeinsam genutzten UI-Zustand**:
    - Für UI-Zustände, die von mehreren Widgets gemeinsam genutzt werden und nicht in einer direkten GObject-Eltern-Kind-Beziehung stehen oder nicht sinnvoll als globale GSettings abgebildet werden können, wird das Rust-Idiom `Rc<RefCell<T>>` verwendet.51
    - `Rc` ermöglicht das Teilen des Besitzes im Single-Threaded-Kontext des GTK-Mainloops.
    - `RefCell` ermöglicht die innere Veränderlichkeit (mutable borrows zur Laufzeit geprüft).
    - Dies ist nützlich für z.B. einen gemeinsam genutzten D-Bus-Verbindungsmanager, der von mehreren UI-Komponenten verwendet wird, oder für View-Modelle, die Daten für mehrere, lose gekoppelte Widgets halten.
    - Vorsicht ist geboten, um Zyklen von `Rc`-Referenzen zu vermeiden, die zu Speicherlecks führen können. `Weak<RefCell<T>>` kann hier Abhilfe schaffen.
- **Datenbindung (Property Binding)**:
    - GObject-Eigenschaftsbindungen (`GObject.bind_property()`) werden intensiv genutzt, um UI-Elemente direkt an Zustandseigenschaften zu koppeln. Dies reduziert manuellen Synchronisationscode und fördert eine deklarative UI-Logik.
    - Beispiel: Die `label`-Eigenschaft eines `gtk::Label` könnte an eine `String`-Eigenschaft eines View-Modell-Objekts gebunden werden.
- **Adaption von MVVM/MVC-Mustern**:
    - Obwohl GTK nicht explizit für ein bestimmtes UI-Architekturmuster wie MVVM oder MVC ausgelegt ist, können deren Prinzipien adaptiert werden:
        - **Model**: Repräsentiert die Anwendungsdaten und Geschäftslogik (primär in der `domain`-Schicht, aber auch UI-spezifische Zustandsmodelle).
        - **View**: Die GTK-Widgets selbst.
        - **ViewModel/Controller**: GObject-Instanzen, die UI-spezifische Logik und Zustand halten (ViewModel-Aspekt) und Benutzerinteraktionen verarbeiten (Controller-Aspekt). GObject-Eigenschaften des ViewModels werden an die View (Widgets) gebunden. Methoden im ViewModel/Controller reagieren auf UI-Events und interagieren mit dem Model.
- **Kommunikation mit unteren Schichten**:
    - Zustandsänderungen, die von der `domain`- oder `system`-Schicht ausgehen (z.B. durch Ereignisse oder Callbacks von asynchronen Operationen), werden in UI-Zustandsaktualisierungen übersetzt.
    - Dies geschieht typischerweise innerhalb von Closures, die mit `glib::MainContext::spawn_local` auf dem UI-Thread ausgeführt werden, um Thread-Sicherheit zu gewährleisten.7
    - Beispiel: Ein `NetworkStatusChangedEvent` aus der `system`-Schicht könnte die `icon-name`-Eigenschaft eines `NetworkIndicatorWidget` aktualisieren.

Dieser Ansatz ermöglicht eine klare Trennung der Belange, nutzt die Stärken des GObject-Systems für Widget-spezifischen Zustand und bietet gleichzeitig flexible Rust-basierte Lösungen für komplexere oder gemeinsam genutzte UI-Zustände.

### 3.2. Fehlerbehandlungs-Framework für die UI-Schicht

Eine konsistente und benutzerfreundliche Fehlerbehandlung ist unerlässlich.

- **Fehlerdefinition mit `thiserror`**:
    - Für jedes Hauptmodul der UI-Schicht (z.B. `ui::shell`, `ui::control_center`) und ggf. für komplexe Submodule (z.B. `AppMenuButton`) werden spezifische Error-Enums mit `thiserror::Error` definiert.72 Beispiel: `PanelWidgetError`, `AppMenuError`.
    - Diese modul-spezifischen Fehler werden in einem übergeordneten UI-Fehler-Enum (z.B. `NovaUiError`) zusammengefasst, ebenfalls unter Verwendung von `#[from]`-Attributen in `thiserror` für eine einfache Konvertierung.
        
        Rust
        
        ```
        // Beispiel: src/ui/error.rs
        use thiserror::Error;
        
        #
        pub enum PanelWidgetError {
            #[error("Layer shell initialization failed: {0}")]
            LayerShellInitializationFailed(String),
            // Weitere Panel-spezifische Fehler
        }
        
        #
        pub enum AppMenuError {
            #[error("Failed to get active window info from Wayland: {0}")]
            WaylandError(String),
            #
            DBusConnectionError(#[from] zbus::Error),
            #[error("Menu service for app '{0}' unavailable")]
            MenuServiceUnavailable(String),
            #[error("Menu not found for app '{0}'")]
            MenuNotFound(String),
        }
        
        #
        pub enum NovaUiError {
            #[error("Panel widget error: {0}")]
            Panel(#[from] PanelWidgetError),
            #[error("AppMenu button error: {0}")]
            AppMenu(#[from] AppMenuError),
            #
            Theming(String), // Fehler von ui::theming_gtk
            #[error("I/O error: {0}")]
            Io(#[from] std::io::Error),
            // Weitere Fehlerkategorien
        }
        ```
        
- **Fehlerdarstellung**:
    - **Kritische Fehler**: Fehler, die die grundlegende Funktionalität einer Komponente oder der UI stark beeinträchtigen (z.B. D-Bus-Verbindung nicht möglich, Layer-Shell-Initialisierung fehlgeschlagen), werden dem Benutzer über ein `gtk::AlertDialog` mitgeteilt. Der Dialog sollte eine klare Fehlermeldung und ggf. Vorschläge zur Fehlerbehebung oder einen Hinweis auf Log-Dateien enthalten.
    - **Nicht-kritische Fehler**: Weniger schwerwiegende Fehler (z.B. ein einzelnes Panel-Modul kann nicht geladen werden, eine Einstellung kann nicht gelesen werden) werden als `NotificationPopupWidget` (siehe `ui::notifications_frontend`) oder durch eine Zustandsänderung im Widget selbst (z.B. ausgegrautes Icon, Fehlermeldung im Tooltip) angezeigt.
    - Fehlermeldungen für den Benutzer werden internationalisiert (i18n).
- **Fehlerpropagation**: Fehler aus unteren Schichten (`domain`, `system`) werden in entsprechende `NovaUiError`-Varianten umgewandelt und nach oben propagiert oder an der Stelle behandelt, an der sie für die UI relevant werden.

### 3.3. Logging-Strategie

Strukturiertes Logging ist für Diagnose und Debugging unerlässlich.

- **Bibliothek**: Das `tracing`-Crate wird für alle Logging-Aufgaben in der UI-Schicht verwendet.73
- **Log-Level**:
    - `trace!`: Sehr detaillierte Informationen für tiefgreifendes Debugging (z.B. einzelne D-Bus-Nachrichten, detaillierte Widget-Zustandsänderungen). Standardmäßig deaktiviert.
    - `debug!`: Informationen, die für das Debugging nützlich sind (z.B. Erstellung von Widgets, Aufruf wichtiger interner Methoden, empfangene Ereignisse).
    - `info!`: Allgemeine Informationen über den Betrieb (z.B. Modul geladen, Einstellung geändert).
    - `warn!`: Unerwartete, aber nicht unbedingt fehlerhafte Zustände (z.B. optionale Konfigurationsdatei nicht gefunden, Fallback-Verhalten aktiviert).
    - `error!`: Fehlerzustände, die die Funktionalität beeinträchtigen (z.B. D-Bus-Aufruf fehlgeschlagen, Widget konnte nicht erstellt werden). Details zum Fehlerobjekt werden mitgeloggt.
- **Strukturierte Felder**: Log-Nachrichten sollen relevante Kontextinformationen als strukturierte Felder enthalten.
    - Beispiel: `tracing::debug!(widget_name = %self.widget_name(), event =?event_type, "Event received");`
- **Span-Nutzung**: `tracing::span!` wird verwendet, um wichtige Operationen oder Lebenszyklen von Komponenten zu umfassen, insbesondere bei asynchronen Abläufen.
- **Konfiguration**:
    - Die Konfiguration des `tracing`-Subscribers (z.B. `tracing_subscriber::fmt` für Konsolenausgabe oder `tracing_journald` für systemd-journal-Integration) erfolgt im Hauptanwendungseinstiegspunkt (`main.rs`).
    - Die Standard-Logstufe für Entwicklungs-Builds ist `DEBUG`, für Release-Builds `INFO`. Die Logstufe kann zur Laufzeit über Umgebungsvariablen (z.B. `RUST_LOG`) angepasst werden.

### 3.4. Initiales Teststrategie-Framework

Eine mehrschichtige Teststrategie stellt die Qualität und Korrektheit der UI-Schicht sicher.

- **Unit-Tests**:
    - Fokus: Testen von isolierter Logik innerhalb von UI-Komponenten, die nicht direkt vom GTK-Rendering oder -Eventloop abhängt (z.B. Hilfsfunktionen, Datenkonvertierungslogik, Zustandsmanagement-Helfer).
    - Werkzeuge: Standard Rust `#[test]`, Mocking-Bibliotheken (z.B. `mockall`) für Abhängigkeiten zu unteren Schichten oder externen Diensten.
- **Widget-Tests**:
    - Fokus: Testen des Verhaltens und Zustands einzelner GTK-Widgets und benutzerdefinierter GObject-Komponenten.
    - Werkzeuge:
        - `gtk::test` Namespace: Bietet Funktionen zum Initialisieren von GTK in Testumgebungen.
        - Programmatische Interaktion: Simulieren von Signalen (z.B. `widget.emit_by_name::<()>("clicked", &)`), Setzen und Abfragen von GObject-Eigenschaften.
        - Inspektion: Überprüfung von Widget-Zuständen (z.B. `label.text()`, `button.is_sensitive()`).
        - GTK-Inspektionswerkzeuge und Accessibility-APIs (ATK) können programmatisch genutzt werden, um Widget-Zustände und -Eigenschaften zu überprüfen.122 Die Evaluierung von Frameworks wie `gtk4-rs-test-utils` (falls existent und passend) oder ähnlichen Ansätzen ist Teil des Untersuchungsbedarfs.
- **Accessibility-Tests**:
    - Fokus: Sicherstellen, dass UI-Komponenten für assistive Technologien zugänglich sind.
    - Werkzeuge: Überprüfung von ATK-Eigenschaften (Rolle, Name, Beschreibung, Zustand) der Widgets. Manuelle Tests mit Screenreadern (z.B. Orca) sind ebenfalls notwendig. `gtk::Accessible`.23
- **Visuelle Regressionstests**: (Zur Evaluierung)
    - Fokus: Erkennen von unbeabsichtigten visuellen Änderungen in der UI.
    - Werkzeuge: Evaluierung von Werkzeugen für den visuellen Vergleich von UI-Zuständen (Screenshots). Dies ist oft aufwendig und wird initial möglicherweise zurückgestellt.
- **Integrations-/End-to-End-Tests**: (Herausfordernd, für kritische Pfade)
    - Fokus: Testen des Zusammenspiels mehrerer UI-Komponenten und deren Interaktion mit unteren Schichten.
    - Werkzeuge: Simulation von Benutzerinteraktionen auf Wayland-Ebene (z.B. mit Tools wie `ydotool` oder spezialisierten Test-Frameworks, falls verfügbar und integrierbar). Überprüfung des Systemverhaltens. Dies ist sehr komplex und wird nur für kritische User Journeys in Betracht gezogen.

### 3.5. Richtlinien für Performance-Optimierung und Profiling

Die Sicherstellung einer performanten UI ist ein Kernziel.

- **Profiling-Werkzeuge**:
    - **Rust-spezifisch**: `perf` unter Linux, `cargo flamegraph`, `tracing` mit `tracing-flame` für CPU-Profiling. Speicher-Profiler wie `heaptrack` oder Valgrind (mit Massif) können zur Analyse des Speicherverbrauchs herangezogen werden.
    - **GTK4-spezifisch**: Der GTK Inspector enthält einen Profiler, der Rendering-Zeiten und Widget-Updates visualisiert. GSK-spezifische Debug-Flags (`GSK_DEBUG`) können Aufschluss über Rendering-Pfade geben.
- **Optimierungsbereiche**:
    - **Widget-Zeichnung**: Bei benutzerdefinierten Zeichnungen mit Cairo (`GtkDrawingArea`) darauf achten, nur die notwendigen Bereiche neu zu zeichnen (`gtk_widget_queue_draw_area`). Komplexität der Zeichenoperationen minimieren.
    - **CSS-Anwendung**: CSS-Selektoren einfach halten. Komplexe Selektoren und Regeln können die Performance beeinträchtigen. Effiziente Aktualisierung von CSS bei Theme-Wechseln.10
    - **Datenbindung**: Übermäßige Nutzung von GObject-Property-Bindings oder zu häufige Benachrichtigungen bei kleinen Änderungen können zu Performance-Engpässen führen. Änderungen ggf. bündeln.
    - **Layout-Performance**: Vermeidung unnötig tiefer Widget-Hierarchien. Effiziente Nutzung von Layout-Managern wie `GtkBox` und `GtkGrid`.
    - **Asynchrone Operationen**: Konsequente Nutzung von `glib::MainContext::spawn_local` für alle potenziell blockierenden Operationen (Netzwerk, Datei-I/O, aufwändige Berechnungen in der Domänenschicht), um UI-Blockaden zu verhindern.7 Visuelles Feedback (Spinner, Fortschrittsbalken) für laufende Operationen bereitstellen.
- **Allgemeine Rust-Optimierungen**: Zero-Cost-Abstraktionen nutzen, unnötige Allokationen vermeiden, effiziente Datenstrukturen wählen.24

Performance-Messungen und -Optimierungen sollten ein integraler Bestandteil des Entwicklungsprozesses sein, nicht eine nachträgliche Maßnahme.

## 4. Plan für nachfolgende UI-Layer-Module

### 4.1. Priorisierung für nächste Module

Nach der initialen Implementierung und Stabilisierung des `PanelWidget` und des `AppMenuButton` sowie der grundlegenden übergreifenden Frameworks (Theming, State Management, Error Handling, Logging) werden die UI-Module in folgender logischer Reihenfolge priorisiert:

1. **Weitere Kern-Panel-Module (`ui::shell`)**:
    - `WorkspaceIndicatorWidget`: Essentiell für die Workspace-Navigation.
    - `ClockDateTimeWidget`: Grundlegende Benutzerinformation.
    - `SystemTrayEquivalentWidget`: Kritisch für die Integration von Drittanbieter-Anwendungen. Aufgrund seiner Komplexität (siehe oben) wird hierfür frühzeitig mit der Detailplanung und Prototyping begonnen.
    - `QuickSettingsButtonWidget` und `NotificationCenterButtonWidget`: Wichtige Zugriffspunkte für Systemfunktionen.
    - Weitere Indikatoren (`NetworkIndicatorWidget`, `PowerIndicatorWidget`, `AudioIndicatorWidget`).
2. **Ausklappbare Panel-Inhalte (`ui::shell`)**:
    - `QuickSettingsPanelWidget`: Wird vom `QuickSettingsButtonWidget` geöffnet.
    - `NotificationCenterPanelWidget`: Wird vom `NotificationCenterButtonWidget` geöffnet und interagiert mit `ui::notifications_frontend`.
3. **Weitere Shell-Komponenten (`ui::shell`)**:
    - `SmartTabBarWidget`
    - `WorkspaceSwitcherWidget`
    - `QuickActionDockWidget`
4. **Systemeinstellungsanwendung (`ui::control_center`)**:
    - Dies ist eine größere, eigenständige Anwendung und wird parallel zu weniger kritischen Shell-Komponenten entwickelt, sobald die Kern-Shell-Interaktionen stabil sind.
5. **Spezifische UI-Frontends und Widgets**:
    - `ui::notifications_frontend` (Popups)
    - `ui::widgets` (Sidebar-Widgets)
    - `ui::window_manager_frontend`
    - `ui::speed_dial`
    - `ui::command_palette`

Diese Priorisierung zielt darauf ab, schnell einen funktionalen Kern der Desktop-Shell zu etablieren und dann schrittweise weitere Funktionen und Anwendungen hinzuzufügen.

### 4.2. Identifizierte Abhängigkeiten und Parallelisierungsmöglichkeiten

- **Abhängigkeiten**:
    - Alle Panel-Module hängen von einem stabilen `PanelWidget` und dessen API ab.
    - `AppMenuButton` und `SystemTrayEquivalentWidget` haben starke Abhängigkeiten von D-Bus-Interaktionen und Wayland-Protokollen (bzw. den Abstraktionsdiensten dafür).
    - `NetworkIndicatorWidget`, `PowerIndicatorWidget`, `AudioIndicatorWidget` hängen von den entsprechenden D-Bus-Schnittstellen der `system`-Schicht ab.
    - `NotificationCenterPanelWidget` hängt von `domain::user_centric_services::NotificationService` und `ui::notifications_frontend::NotificationPopupWidget` ab.
    - `ui::control_center` Module hängen stark von `domain::global_settings_and_state_management::GlobalSettingsService` ab.
- **Parallelisierung**:
    - Sobald die API des `PanelWidget` definiert ist, können viele der darin enthaltenen Module (`ClockDateTimeWidget`, `WorkspaceIndicatorWidget`, einzelne Indikatoren) parallel entwickelt werden.
    - Die Entwicklung des `ui::control_center` kann weitgehend parallel zur Verfeinerung der `ui::shell` erfolgen, sobald die `GlobalSettingsService`-Schnittstelle stabil ist.
    - Wiederverwendbare Komponenten in `ui::components` können frühzeitig parallel entwickelt und in anderen Modulen eingesetzt werden.
    - Die Implementierung der D-Bus-Clients für verschiedene Systemdienste (`NetworkManager`, `UPower`, etc.) kann parallelisiert werden.

Eine enge Abstimmung zwischen den Teams, die an abhängigen Modulen arbeiten, ist entscheidend. Die Definition klarer Schnittstellen (GObject-Properties und -Signale, Rust-Traits) für Module und Dienste erleichtert die parallele Entwicklung und spätere Integration.

# NovaDE UI-Schicht: Implementierungsleitfaden – Teil 2: `WorkspaceIndicatorWidget` und `ClockDateTimeWidget`

## 1. Einleitung

### 1.1. Zweck des Dokuments

Dieses Dokument ist der zweite Teil des detaillierten Implementierungsleitfadens für die UI-Schicht der Nova Desktop Environment (NovaDE). Es baut auf den im ersten Teil etablierten Grundlagen und Spezifikationen auf und fokussiert sich auf zwei weitere wichtige Module innerhalb des `PanelWidget`: das `WorkspaceIndicatorWidget` und das `ClockDateTimeWidget`. Ziel ist es weiterhin, eine ultrafeine Spezifikation bereitzustellen, die Entwicklern eine direkte Implementierung ohne eigene grundlegende Designentscheidungen ermöglicht.

### 1.2. Zielgruppe

Dieses Dokument richtet sich an Softwareentwickler und -architekten, die an der Implementierung der NovaDE UI-Schicht beteiligt sind. Es wird ein Verständnis von Rust, GTK4 und den gtk4-rs Bindings sowie der im ersten Teil dieses Leitfadens beschriebenen Konzepte vorausgesetzt.

### 1.3. Umfang (Teil 2: `WorkspaceIndicatorWidget` und `ClockDateTimeWidget`)

Dieser Teil des Implementierungsleitfadens behandelt die folgenden Module:

- **`ui::shell::panel_widget::WorkspaceIndicatorWidget`**: Ein Panel-Modul zur visuellen Darstellung der verfügbaren Arbeitsbereiche ("Spaces") und des aktuell aktiven Space.
- **`ui::shell::panel_widget::ClockDateTimeWidget`**: Ein Panel-Modul zur Anzeige der aktuellen Uhrzeit und des Datums, mit optionaler Kalenderfunktionalität.

### 1.4. Referenzen auf vorherige Dokumente

Dieser Leitfaden bezieht sich auf die allgemeinen UI-Schicht-Prinzipien, Technologie-Stack-Definitionen und die Spezifikationen für `PanelWidget` und `AppMenuButton` aus "NovaDE UI-Schicht: Implementierungsleitfaden – Teil 1: `ui::shell::PanelWidget` und `AppMenuButton`". Die dort definierten Strategien für Zustandsmanagement, Fehlerbehandlung, Logging und Theming gelten auch hier.

## 2. Modul: `ui::shell::panel_widget::WorkspaceIndicatorWidget`

### 2.1. Übersicht und Verantwortlichkeiten

Das `WorkspaceIndicatorWidget` ist ein Panel-Modul, das dem Benutzer eine klare visuelle Rückmeldung über die verfügbaren und den aktuell aktiven Arbeitsbereich ("Space") gibt. Seine Hauptverantwortlichkeiten sind:

- Anzeige einer konfigurierbaren Anzahl von Indikatoren, die die einzelnen Workspaces repräsentieren.
- Visuelle Hervorhebung des aktuell aktiven Workspace.
- Ermöglichung des Wechsels zu einem anderen Workspace durch Klicken auf den entsprechenden Indikator.
- Dynamische Aktualisierung der Anzeige basierend auf Änderungen in `domain::workspaces::WorkspaceManager`.

### 2.2. Visuelles Design und Theming

- **Darstellung**: Das Widget besteht aus einer horizontalen Anordnung von einzelnen `WorkspaceItemWidget`-Instanzen. Jedes `WorkspaceItemWidget` repräsentiert einen Workspace.
    - **Optionen für `WorkspaceItemWidget`**:
        - **Nummeriert**: Zeigt die Nummer des Workspace an.
        - **Icons**: Zeigt ein Icon an, das dem Workspace zugeordnet ist (z.B. das Icon der primär gepinnten Anwendung oder ein benutzerdefiniertes Space-Icon aus `domain::workspaces`).
        - **Kombiniert**: Icon mit einer kleinen Nummer als Overlay.
    - **Aktiver Workspace**: Das `WorkspaceItemWidget` des aktiven Workspace wird deutlich hervorgehoben, z.B. durch eine andere Hintergrundfarbe (Akzentfarbe des Systems oder des Spaces), einen Rahmen oder eine hellere Text-/Iconfarbe.
- **Layout**: Die `WorkspaceItemWidget`s werden horizontal in einer `gtk::Box` angeordnet.
- **CSS-Styling**:
    - **CSS-Knoten**:
        - `WorkspaceIndicatorWidget` (als `gtk::Box`): `box`.1
        - `WorkspaceItemWidget` (als `gtk::Button` oder benutzerdefiniertes Widget): `button` oder ein benutzerdefinierter CSS-Name.2
    - **CSS-Klassen**:
        - `.workspace-indicator`: Für das Hauptcontainer-Widget.
        - `.workspace-item`: Für jedes einzelne `WorkspaceItemWidget`.
        - `.active-workspace`: Für das `WorkspaceItemWidget`, das den aktiven Workspace repräsentiert.
        - `.workspace-occupied`: (Optional) Für `WorkspaceItemWidget`s, die Fenster enthalten.

### 2.3. Datenstrukturen, Eigenschaften und Zustand

#### 2.3.1. `WorkspaceInfo` (UI-spezifische Datenstruktur)

Diese Struktur dient dem Datenaustausch zwischen der Domänenschicht und dem `WorkspaceIndicatorWidget`.

Rust

```
// In src/ui/shell/panel_widget/workspace_indicator_widget/types.rs (oder ähnlich)
#
pub struct WorkspaceInfo {
    pub id: String, // Eindeutige ID des Workspace (von domain::workspaces::WorkspaceId)
    pub name: String, // Name des Workspace
    pub icon_name: Option<String>, // Optionaler Icon-Name für den Workspace
    pub number: usize, // Ordnungsnummer des Workspace
    pub is_active: bool, // True, wenn dies der aktive Workspace ist
    pub is_occupied: bool, // True, wenn der Workspace Fenster enthält (optional für Styling)
}
```

#### 2.3.2. `WorkspaceItemWidget` (GObject-Subklasse)

Jeder Indikator im `WorkspaceIndicatorWidget` ist eine Instanz von `WorkspaceItemWidget`.

- GObject-Definition (WorkspaceItemWidget):
    
    Erbend von gtk::Button für einfache Klickbarkeit und Styling.
    
    _Auszug aus `src/ui/shell/panel_widget/workspace_indicator_widget/workspace_item_widget/imp.rs` (vereinfacht):_
    
    Rust
    
    ```
    use gtk::glib;
    use gtk::subclass::prelude::*;
    use std::cell::RefCell;
    
    #
    pub struct WorkspaceItemWidget {
        workspace_id: RefCell<Option<String>>,
        workspace_number: RefCell<Option<usize>>,
        // Ggf. Referenz auf ein internes gtk::Label oder gtk::Image
        label_widget: TemplateChild<gtk::Label>, // Beispiel, wenn CompositeTemplate genutzt wird
        icon_widget: TemplateChild<gtk::Image>,  // Beispiel
    }
    
    #[glib::object_subclass]
    impl ObjectSubclass for WorkspaceItemWidget {
        const NAME: &'static str = "NovaDEWorkspaceItemWidget";
        type Type = super::WorkspaceItemWidget;
        type ParentType = gtk::Button; // Erbt von gtk::Button
    
        fn new() -> Self {
            Self {
                workspace_id: RefCell::new(None),
                workspace_number: RefCell::new(None),
                label_widget: TemplateChild::default(),
                icon_widget: TemplateChild::default(),
            }
        }
        fn class_init(klass: &mut Self::Class) {
            // klass.bind_template(); // Falls.ui Datei verwendet wird
            klass.set_css_name("workspaceitemwidget");
        }
        // fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
        //     obj.init_template();
        // }
    }
    impl ObjectImpl for WorkspaceItemWidget {
        // Eigenschaften hier definieren, falls nötig (z.B. "workspace-id", "is-active-item")
        // Für dieses Widget reicht es oft, den Zustand über Methoden zu setzen und
        // das Aussehen direkt anzupassen.
    }
    impl WidgetImpl for WorkspaceItemWidget {}
    impl ButtonImpl for WorkspaceItemWidget {}
    ```
    
    _Auszug aus `src/ui/shell/panel_widget/workspace_indicator_widget/workspace_item_widget/mod.rs` (vereinfacht):_
    
    Rust
    
    ```
    use gtk::glib;
    use gtk::subclass::prelude::*;
    use super::types::WorkspaceInfo; // Annahme, dass WorkspaceInfo hier definiert ist
    
    mod imp;
    
    glib::wrapper! {
        pub struct WorkspaceItemWidget(ObjectSubclass<imp::WorkspaceItemWidget>)
            @extends gtk::Button, gtk::Widget,
            @implements gtk::Accessible, gtk::Actionable, gtk::Buildable, gtk::ConstraintTarget;
    }
    
    impl WorkspaceItemWidget {
        pub fn new(info: &WorkspaceInfo) -> Self {
            let item: Self = glib::Object::new();
            item.update_content(info);
            item.set_workspace_id(Some(info.id.clone()));
            item.set_workspace_number(Some(info.number));
            item
        }
    
        pub fn workspace_id(&self) -> Option<String> {
            self.imp().workspace_id.borrow().clone()
        }
    
        fn set_workspace_id(&self, id: Option<String>) {
            self.imp().workspace_id.replace(id);
        }
    
        pub fn workspace_number(&self) -> Option<usize> {
            *self.imp().workspace_number.borrow()
        }
    
        fn set_workspace_number(&self, num: Option<usize>) {
            self.imp().workspace_number.replace(num);
        }
    
        pub fn update_content(&self, info: &WorkspaceInfo) {
            // Logik zum Setzen des Labels (Nummer oder Name) oder Icons
            // Beispiel: self.set_label(&info.number.to_string());
            // Oder: self.imp().label_widget.set_text(&info.number.to_string());
            // Oder: if let Some(icon_name) = &info.icon_name {
            //           self.imp().icon_widget.set_from_icon_name(Some(icon_name));
            //           self.set_child(Some(&self.imp().icon_widget));
            //       } else {
            //           self.imp().label_widget.set_text(&info.number.to_string());
            //           self.set_child(Some(&self.imp().label_widget));
            //       }
    
            if info.is_active {
                self.add_css_class("active-workspace");
            } else {
                self.remove_css_class("active-workspace");
            }
            // Ggf. Tooltip setzen: self.set_tooltip_text(Some(&info.name));
        }
    }
    ```
    

#### 2.3.3. `WorkspaceIndicatorWidget` (GObject-Subklasse)

- GObject-Definition (WorkspaceIndicatorWidget):
    
    Erbend von gtk::Box.
    
    _Auszug aus `src/ui/shell/panel_widget/workspace_indicator_widget/imp.rs` (vereinfacht):_
    
    Rust
    
    ```
    use gtk::glib;
    use gtk::subclass::prelude::*;
    use std::cell::RefCell;
    use std::collections::HashMap;
    use super::workspace_item_widget::WorkspaceItemWidget;
    use super::types::WorkspaceInfo;
    
    #
    pub struct WorkspaceIndicatorWidget {
        // GObject Properties
        max_visible_items: RefCell<u32>, // 0 für unbegrenzt
        show_workspace_names: RefCell<bool>, // Beeinflusst Darstellung in WorkspaceItemWidget
    
        // Interner Zustand
        workspace_items_container: TemplateChild<gtk::Box>, // Die Box, die WorkspaceItemWidgets hält
        workspace_item_widgets: RefCell<HashMap<String, WorkspaceItemWidget>>, // Map von Workspace-ID zu Widget
        // Referenz auf den WorkspaceManager-Proxy oder Event-Listener
        // workspace_event_listener_id: RefCell<Option<glib::SignalHandlerId>>, // Beispiel
    }
    
    #[glib::object_subclass]
    impl ObjectSubclass for WorkspaceIndicatorWidget {
        const NAME: &'static str = "NovaDEWorkspaceIndicatorWidget";
        type Type = super::WorkspaceIndicatorWidget;
        type ParentType = gtk::Box;
    
        fn new() -> Self {
            Self {
                max_visible_items: RefCell::new(10), // Standard: max 10 Items
                show_workspace_names: RefCell::new(false), // Standard: Nummern/Icons
                workspace_items_container: TemplateChild::default(),
                workspace_item_widgets: RefCell::new(HashMap::new()),
            }
        }
        fn class_init(klass: &mut Self::Class) {
            // klass.bind_template(); // Falls.ui Datei verwendet wird
            // Properties hier installieren
            klass.set_css_name("workspaceindicator");
        }
        // fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
        //     obj.init_template();
        // }
    }
    impl ObjectImpl for WorkspaceIndicatorWidget {
        fn constructed(&self) {
            self.parent_constructed();
            let obj = self.obj();
            obj.set_orientation(gtk::Orientation::Horizontal);
            obj.set_spacing(4); // Beispiel für Abstand zwischen Items
            // Initialisiere workspace_items_container, falls nicht über Template
            // self.workspace_items_container.set_orientation(gtk::Orientation::Horizontal);
            // self.obj().append(&self.workspace_items_container);
    
            // Hier Logik zum Abonnieren von Workspace-Events von domain::workspaces
            // obj.subscribe_to_workspace_events();
        }
        // fn dispose() und fn finalize() für Aufräumarbeiten (z.B. Signalhandler trennen)
    }
    impl WidgetImpl for WorkspaceIndicatorWidget {}
    impl BoxImpl for WorkspaceIndicatorWidget {}
    ```
    
- **Eigenschaften (Properties) für `WorkspaceIndicatorWidget`**:
    
    **Tabelle 2.1: `WorkspaceIndicatorWidget` Eigenschaften**
    

|   |   |   |   |   |
|---|---|---|---|---|
|**Eigenschaftsname**|**Typ**|**Zugriff**|**Standardwert**|**Beschreibung**|
|`max-visible-items`|`u32`|Lesen/Schreiben|`10`|Maximale Anzahl von Workspace-Indikatoren, die angezeigt werden. `0` bedeutet unbegrenzt. Bei Überschreitung könnten z.B. Pfeile oder ein Überlaufmenü erscheinen (zukünftige Erweiterung).|
|`show-workspace-names`|`bool`|Lesen/Schreiben|`false`|Wenn `true`, versuchen `WorkspaceItemWidget`s, den Namen des Workspace anzuzeigen, sonst eher Nummer oder Icon.|

### 2.4. API und Methoden

#### 2.4.1. `WorkspaceIndicatorWidget`

- `pub fn new() -> Self`
    - Signatur: `pub fn new() -> Self`
    - Verantwortlichkeit: Konstruktor. Initialisiert die interne `gtk::Box` für die `WorkspaceItemWidget`s und abonniert sich bei `domain::workspaces::WorkspaceManager` für `WorkspaceEvent`s.
- `pub fn update_workspaces(&self, workspaces_info: Vec<WorkspaceInfo>) noexcept;`
    - Signatur: `pub fn update_workspaces(&self, workspaces_info: Vec<super::types::WorkspaceInfo>) noexcept`
    - Verantwortlichkeit: Hauptmethode zur Aktualisierung der Anzeige.
        1. Entfernt alle aktuellen `WorkspaceItemWidget`s aus dem internen Container.
        2. Löscht den `workspace_item_widgets` HashMap.
        3. Iteriert über `workspaces_info`:
            - Erstellt für jeden Eintrag ein neues `WorkspaceItemWidget` mit den Daten aus `WorkspaceInfo`.
            - Verbindet das `clicked`-Signal des `WorkspaceItemWidget` mit der internen Methode `on_workspace_item_clicked`.
            - Fügt das `WorkspaceItemWidget` dem internen Container (`workspace_items_container`) hinzu.
            - Speichert das `WorkspaceItemWidget` im `workspace_item_widgets` HashMap (ID als Schlüssel).
        4. Berücksichtigt `max-visible-items` (initial einfach abschneiden, später ggf. komplexere Logik).
- `fn on_workspace_item_clicked(&self, item_widget: &WorkspaceItemWidget) noexcept;`
    - Signatur: `fn on_workspace_item_clicked(&self, item_widget: &super::workspace_item_widget::WorkspaceItemWidget) noexcept`
    - Verantwortlichkeit: Wird aufgerufen, wenn ein `WorkspaceItemWidget` geklickt wird.
        1. Ermittelt die `workspace_id` des geklickten Items.
        2. Sendet einen Befehl/Aktion an `domain::workspaces::WorkspaceManager`, um den aktiven Workspace zu wechseln (z.B. über eine UI-Aktionsschicht oder einen direkten Aufruf, falls die Architektur dies erlaubt und Thread-sicher ist).
- `fn handle_workspace_event(&self, event: &domain::workspaces::WorkspaceEvent) noexcept;` (Beispielhafter Name)
    - Signatur: `fn handle_workspace_event(&self, event: &<Pfad_zu_domain>::workspaces::WorkspaceEvent) noexcept`
    - Verantwortlichkeit: Callback-Funktion, die auf `WorkspaceEvent`s von `domain::workspaces::WorkspaceManager` reagiert.
        1. Fordert die aktuelle Liste aller Workspaces und den aktiven Workspace vom `WorkspaceManager` an.
        2. Konvertiert die Domain-Daten in eine `Vec<WorkspaceInfo>`.
        3. Ruft `self.update_workspaces()` mit den neuen Daten auf. _Diese Funktion wird typischerweise über `glib::MainContext::spawn_local` aufgerufen, wenn das Domain-Event aus einem anderen Thread kommt._ 4

#### 2.4.2. `WorkspaceItemWidget`

- `pub fn new(info: &WorkspaceInfo) -> Self` (siehe oben)
- `pub fn update_content(&self, info: &WorkspaceInfo) noexcept;` (siehe oben)
    - Aktualisiert das Label (Nummer/Name) und/oder das Icon basierend auf `info.icon_name`, `info.name`, `info.number` und der `show-workspace-names`-Eigenschaft des Parent-`WorkspaceIndicatorWidget`.
    - Setzt die CSS-Klasse `.active-workspace` basierend auf `info.is_active`.
    - Setzt optional einen Tooltip mit `info.name`.

### 2.5. Signale und Ereignisse

#### 2.5.1. `WorkspaceIndicatorWidget`

- **Emittierte Signale**: Keine spezifischen benutzerdefinierten Signale für externe Nutzung vorgesehen. Interne Logik wird durch Methodenaufrufe und Property-Änderungen gesteuert.
- **Verbundene Signale/Events**:
    - Abonniert `WorkspaceEvent`s von `domain::workspaces::WorkspaceManager`.
        - Publisher: `domain::workspaces::WorkspaceManager`.
        - Subscriber: `WorkspaceIndicatorWidget::handle_workspace_event`.
        - Zweck: Aktualisierung der Workspace-Anzeige bei Änderungen in der Domänenschicht.

#### 2.5.2. `WorkspaceItemWidget`

- **Emittierte Signale**: Erbt das `clicked`-Signal von `gtk::Button`.
- **Verbundene Signale**: Keine spezifischen.

### 2.6. Fehlerbehandlung

- **`enum WorkspaceIndicatorError`** (definiert mit `thiserror`):
    - `DomainCommunicationError(String)`: Fehler bei der Kommunikation mit `domain::workspaces::WorkspaceManager`.
    - `ItemCreationFailed(String)`: Wenn ein `WorkspaceItemWidget` nicht erstellt werden kann.
- Fehler werden primär geloggt (`tracing`). Eine fehlerhafte Aktualisierung könnte dazu führen, dass der Indikator veraltete Informationen anzeigt oder leer ist. Kritische Fehler bei der Initialisierung (z.B. Verbindung zum Domain-Service nicht möglich) könnten das Hinzufügen des Widgets zum Panel verhindern.

### 2.7. Implementierungsplan und Schritte

1. Definiere `WorkspaceInfo` Struktur.
2. Implementiere `WorkspaceItemWidget` (`workspace_item_widget/mod.rs` und `imp.rs`):
    - Subklasse von `gtk::Button`.
    - Implementiere `new()` und `update_content()`.
    - Stelle sicher, dass Klick-Events korrekt weitergeleitet werden können (durch das `clicked`-Signal der Basisklasse).
3. Implementiere `WorkspaceIndicatorWidget` (`workspace_indicator_widget/mod.rs` und `imp.rs`):
    - Subklasse von `gtk::Box`.
    - Definiere GObject-Properties (`max-visible-items`, `show-workspace-names`).
    - Implementiere `new()`: Initialisiere internen Container, abonniere Workspace-Events.
    - Implementiere `update_workspaces()`: Logik zum Leeren und neu Befüllen des Containers mit `WorkspaceItemWidget`s.
    - Implementiere `on_workspace_item_clicked()`: Logik zum Auslösen des Workspace-Wechsels.
    - Implementiere `handle_workspace_event()`: Anforderung neuer Daten und Aufruf von `update_workspaces`.
4. Integration: Das `PanelWidget` instanziiert das `WorkspaceIndicatorWidget` und fügt es einem seiner Bereiche hinzu.

### 2.8. Dateistruktur

```
src/
└── ui/
    └── shell/
        └── panel_widget/
            └── workspace_indicator_widget/
                ├── mod.rs                      // Öffentliche API für WorkspaceIndicatorWidget
                ├── imp.rs                      // GObject-Implementierung für WorkspaceIndicatorWidget
                ├── types.rs                    // Definition von WorkspaceInfo
                ├── workspace_item_widget.rs    // Enthält mod.rs und imp.rs für WorkspaceItemWidget
                │   ├── mod.rs                  // Öffentliche API für WorkspaceItemWidget
                │   └── imp.rs                  // GObject-Implementierung für WorkspaceItemWidget
                └── error.rs                    // (Optional) Definition von WorkspaceIndicatorError
```

## 3. Modul: `ui::shell::panel_widget::ClockDateTimeWidget`

### 3.1. Übersicht und Verantwortlichkeiten

Das `ClockDateTimeWidget` ist ein Panel-Modul, das die aktuelle Systemzeit und das Datum anzeigt. Optional kann es bei einem Klick ein Popover mit einem Kalender anzeigen.

- Anzeige der formatierten aktuellen Uhrzeit und des Datums.
- Regelmäßige Aktualisierung der Anzeige.
- Optionale Anzeige eines Kalender-Popovers bei Klick.
- Konfigurierbarkeit des Zeit-/Datumsformats.

### 3.2. Visuelles Design und Theming

- **Anzeige**: Textbasierte Anzeige der Zeit und des Datums.
    - Schriftart, -größe und -farbe werden durch das globale GTK-Theme und spezifische CSS-Regeln gesteuert.
- **Kalender-Popover**: Ein Standard `gtk::Popover`, das ein `gtk::Calendar`-Widget enthält.6
- **CSS-Styling**:
    - **CSS-Knoten**:
        - `ClockDateTimeWidget` (als `gtk::Button` oder `gtk::Label`): `button` oder `label`.
        - Kalender-Popover: `popover`.
    - **CSS-Klassen**:
        - `.clock-datetime-widget`: Für das Haupt-Widget.
        - `.calendar-popover-content`: Für den Inhalt des Kalender-Popovers (falls benutzerdefinierte Anpassungen nötig sind).

### 3.3. Datenstrukturen, Eigenschaften und Zustand

- GObject-Definition (ClockDateTimeWidget):
    
    Erbend von gtk::Button (um Klickbarkeit für das Popover zu ermöglichen) oder gtk::Label (wenn kein Popover). Für die Popover-Funktionalität ist gtk::Button oder ein gtk::Box mit einem gtk::GestureClick geeigneter.
    
    _Auszug aus `src/ui/shell/panel_widget/clock_datetime_widget/imp.rs` (vereinfacht):_
    
    Rust
    
    ```
    use gtk::glib;
    use gtk::subclass::prelude::*;
    use std::cell::{Cell, RefCell};
    use chrono::{DateTime, Local, SecondsFormat}; // [8]
    
    #
    pub struct ClockDateTimeWidget {
        // GObject Properties
        format_string: RefCell<String>,
        show_calendar_on_click: Cell<bool>,
    
        // Interner Zustand
        timer_id: RefCell<Option<glib::SourceId>>, // Für den Aktualisierungs-Timer [9, 10]
        calendar_popover: RefCell<Option<gtk::Popover>>,
        // Das Label-Widget, das die Zeit anzeigt (kann Kind des Buttons sein)
        time_label: TemplateChild<gtk::Label>,
    }
    
    #[glib::object_subclass]
    impl ObjectSubclass for ClockDateTimeWidget {
        const NAME: &'static str = "NovaDEClockDateTimeWidget";
        type Type = super::ClockDateTimeWidget;
        // Erbt von gtk::Button, um Klickbarkeit und Popover-Ankerung zu erleichtern
        type ParentType = gtk::Button;
    
        fn new() -> Self {
            Self {
                format_string: RefCell::new("%H:%M".to_string()), // Standardformat [11]
                show_calendar_on_click: Cell::new(true),
                timer_id: RefCell::new(None),
                calendar_popover: RefCell::new(None),
                time_label: TemplateChild::default(),
            }
        }
        fn class_init(klass: &mut Self::Class) {
            // klass.bind_template(); // Falls.ui Datei verwendet wird
            // Properties hier installieren
            klass.set_css_name("clockdatetimewidget");
        }
        // fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
        //     obj.init_template();
        // }
    }
    
    impl ObjectImpl for ClockDateTimeWidget {
        fn constructed(&self) {
            self.parent_constructed();
            let obj = self.obj();
    
            // Initialisiere time_label, falls nicht über Template
            // self.time_label.set_use_markup(true); // Für Pango-Markup, falls benötigt
            // obj.set_child(Some(&self.time_label));
    
            obj.update_display(); // Erste Anzeige
            obj.setup_timer();    // Timer starten
    
            // Klick-Handler für Popover verbinden, falls show_calendar_on_click
            if self.show_calendar_on_click.get() {
                obj.connect_clicked(glib::clone!(@weak obj => move |_| {
                    obj.show_calendar_popover();
                }));
            }
        }
        fn dispose(&self) {
            if let Some(source_id) = self.timer_id.borrow_mut().take() {
                source_id.remove();
            }
            if let Some(popover) = self.calendar_popover.borrow_mut().take() {
                popover.unparent(); // Sicherstellen, dass das Popover entfernt wird
            }
        }
        // Properties hier implementieren (set_property, property)
    }
    impl WidgetImpl for ClockDateTimeWidget {}
    impl ButtonImpl for ClockDateTimeWidget {}
    ```
    
- **Eigenschaften (Properties) für `ClockDateTimeWidget`**:
    
    **Tabelle 3.1: `ClockDateTimeWidget` Eigenschaften**
    

|   |   |   |   |   |
|---|---|---|---|---|
|**Eigenschaftsname**|**Typ**|**Zugriff**|**Standardwert**|**Beschreibung**|
|`format-string`|`String`|Lesen/Schreiben|`"%H:%M"`|Der `strftime`-kompatible Format-String für die Zeit-/Datumsanzeige.11|
|`show-calendar-on-click`|`bool`|Lesen/Schreiben|`true`|Wenn `true`, wird bei Klick auf das Widget ein Kalender-Popover angezeigt.|

### 3.4. API und Methoden

- `pub fn new() -> Self`
    - Signatur: `pub fn new() -> Self`
    - Verantwortlichkeit: Konstruktor. Initialisiert das Label, startet den Timer und verbindet ggf. den Klick-Handler für das Kalender-Popover.
- `fn update_display(&self) noexcept;`
    - Signatur: `fn update_display(&self) noexcept`
    - Verantwortlichkeit: Ruft die aktuelle Zeit ab (`chrono::Local::now()` 8), formatiert sie gemäß `format-string` und aktualisiert den Text des internen `gtk::Label` (oder des Button-Labels).
    - Beispiel Formatierung: `Local::now().format(self.imp().format_string.borrow().as_str()).to_string()`.11
- `fn setup_timer(&self) noexcept;`
    - Signatur: `fn setup_timer(&self) noexcept`
    - Verantwortlichkeit: Startet einen Timer, der periodisch (z.B. jede Sekunde oder Minute, abhängig von der Granularität des `format-string`) `update_display` aufruft.
    - Verwendet `glib::timeout_add_seconds_local` oder `glib::timeout_add_local` für feinere Intervalle.9
    - Speichert die `glib::SourceId` im `timer_id`-Feld, um den Timer später entfernen zu können (im `dispose`-Handler).
- `fn show_calendar_popover(&self) noexcept;`
    - Signatur: `fn show_calendar_popover(&self) noexcept`
    - Verantwortlichkeit: Erstellt (falls noch nicht geschehen) und zeigt ein `gtk::Popover` an, das ein `gtk::Calendar`-Widget enthält.6
        1. Wenn `self.imp().calendar_popover` `None` ist:
            - Erstelle ein `gtk::Calendar::new()`.
            - Erstelle ein `gtk::Popover::builder().child(&calendar_widget).build()`.
            - Setze das Popover als Kind des `ClockDateTimeWidget` (oder eines spezifischen Ankerpunkts).
            - Speichere das Popover in `self.imp().calendar_popover`.
        2. Setze das Popover relativ zum `ClockDateTimeWidget` (dem Button): `popover.set_parent(self.obj().as_ref())`.
        3. Zeige das Popover: `popover.popup()`.

### 3.5. Signale und Ereignisse

- **Emittierte Signale**: Keine spezifischen benutzerdefinierten Signale. Erbt Signale von `gtk::Button` (z.B. `clicked`).
- **Verbundene Signale/Events**:
    - Interner Timer-Event von `glib::timeout_add_seconds_local`.
    - `clicked`-Signal des Buttons (falls `show-calendar-on-click` true ist), um `show_calendar_popover` aufzurufen.
    - Lauscht auf Änderungen der relevanten Einstellungen von `domain::global_settings_and_state_management` (z.B. für `format-string`), um die GObject-Properties zu aktualisieren.

### 3.6. Fehlerbehandlung

- **`enum ClockDateTimeError`** (definiert mit `thiserror`):
    - `InvalidFormatString(String)`: Wenn der `format-string` ungültig ist und `chrono::format` fehlschlägt.
    - `TimerSetupFailed(String)`: Wenn der `glib`-Timer nicht eingerichtet werden kann.
- Fehler werden geloggt. Ein ungültiger Format-String könnte zu einer Standardanzeige oder einer Fehlermeldung im Widget führen.

### 3.7. Implementierungsplan und Schritte

1. Definiere `ClockDateTimeWidget` (`clock_datetime_widget/mod.rs` und `imp.rs`):
    - Subklasse von `gtk::Button`.
    - Definiere GObject-Properties (`format-string`, `show-calendar-on-click`).
    - Implementiere `new()`: Initialisiere das interne Label (als Kind des Buttons), rufe `update_display()` und `setup_timer()` auf. Verbinde `clicked`-Signal, falls `show-calendar-on-click`.
2. Implementiere `update_display()`: Hole aktuelle Zeit, formatiere sie, setze Label-Text.
3. Implementiere `setup_timer()`: Nutze `glib::timeout_add_seconds_local` (z.B. für sekündliche Updates), speichere `SourceId`. Der Callback ruft `update_display()` auf und gibt `glib::ControlFlow::Continue` zurück.
4. Implementiere `show_calendar_popover()`: Erstelle und zeige `gtk::Popover` mit `gtk::Calendar`.
5. Implementiere den `dispose`-Handler, um den Timer zu entfernen.
6. Integration: Das `PanelWidget` instanziiert das `ClockDateTimeWidget` und fügt es einem seiner Bereiche hinzu.
7. Verbindung mit `domain::global_settings_and_state_management`: Lausche auf Änderungen der Format-String-Einstellung und aktualisiere die `format-string`-Property des Widgets.

### 3.8. Dateistruktur

```
src/
└── ui/
    └── shell/
        └── panel_widget/
            └── clock_datetime_widget/
                ├── mod.rs          // Öffentliche API für ClockDateTimeWidget
                ├── imp.rs          // GObject-Implementierung
                └── error.rs        // (Optional) Definition von ClockDateTimeError
```

## 4. Schlussfolgerungen (für Teil 2)

Die Spezifikationen für `WorkspaceIndicatorWidget` und `ClockDateTimeWidget` erweitern die Funktionalität des `PanelWidget` um zwei wichtige, benutzerorientierte Module. Die Implementierung des `WorkspaceIndicatorWidget` erfordert eine enge Kopplung mit `domain::workspaces::WorkspaceManager`, um stets aktuelle Informationen über die Arbeitsbereiche anzuzeigen und Interaktionen zu ermöglichen. Das `ClockDateTimeWidget` bietet eine grundlegende, aber essentielle Funktion mit optionaler Erweiterung durch ein Kalender-Popover.

Die konsequente Anwendung von GObject-Subclassing, die Nutzung von GTK-Standardwidgets und -Containern sowie die klare Definition von Schnittstellen und Verantwortlichkeiten sind weiterhin zentrale Aspekte. Die Fehlerbehandlung und das Logging folgen den im ersten Teil etablierten Mustern.

Mit diesen Modulen nimmt die Kernfunktionalität des Panels weiter Gestalt an. Die nächsten Schritte werden sich auf weitere Indikatoren und komplexere Panel-Module wie das `SystemTrayEquivalentWidget` konzentrieren.

NovaDE UI-Schicht: Implementierungsleitfaden – Teil 2: WorkspaceIndicatorWidget und ClockDateTimeWidget1. Einleitung1.1. Zweck des DokumentsDieses Dokument ist der zweite Teil des detaillierten Implementierungsleitfadens für die UI-Schicht der Nova Desktop Environment (NovaDE). Es baut auf den im ersten Teil etablierten Grundlagen und Spezifikationen auf und fokussiert sich auf zwei weitere wichtige Module innerhalb des PanelWidget: das WorkspaceIndicatorWidget und das ClockDateTimeWidget. Ziel ist es weiterhin, eine ultrafeine Spezifikation bereitzustellen, die Entwicklern eine direkte Implementierung ohne eigene grundlegende Designentscheidungen ermöglicht.1.2. ZielgruppeDieses Dokument richtet sich an Softwareentwickler und -architekten, die an der Implementierung der NovaDE UI-Schicht beteiligt sind. Es wird ein Verständnis von Rust, GTK4 und den gtk4-rs Bindings sowie der im ersten Teil dieses Leitfadens beschriebenen Konzepte vorausgesetzt.1.3. Umfang (Teil 2: WorkspaceIndicatorWidget und ClockDateTimeWidget)Dieser Teil des Implementierungsleitfadens behandelt die folgenden Module:
ui::shell::panel_widget::WorkspaceIndicatorWidget: Ein Panel-Modul zur visuellen Darstellung der verfügbaren Arbeitsbereiche ("Spaces") und des aktuell aktiven Space.
ui::shell::panel_widget::ClockDateTimeWidget: Ein Panel-Modul zur Anzeige der aktuellen Uhrzeit und des Datums, mit optionaler Kalenderfunktionalität.
1.4. Referenzen auf vorherige DokumenteDieser Leitfaden bezieht sich auf die allgemeinen UI-Schicht-Prinzipien, Technologie-Stack-Definitionen und die Spezifikationen für PanelWidget und AppMenuButton aus "NovaDE UI-Schicht: Implementierungsleitfaden – Teil 1: ui::shell::PanelWidget und AppMenuButton". Die dort definierten Strategien für Zustandsmanagement, Fehlerbehandlung, Logging und Theming gelten auch hier.2. Modul: ui::shell::panel_widget::WorkspaceIndicatorWidget2.1. Übersicht und VerantwortlichkeitenDas WorkspaceIndicatorWidget ist ein Panel-Modul, das dem Benutzer eine klare visuelle Rückmeldung über die verfügbaren und den aktuell aktiven Arbeitsbereich ("Space") gibt. Seine Hauptverantwortlichkeiten sind:
Anzeige einer konfigurierbaren Anzahl von Indikatoren, die die einzelnen Workspaces repräsentieren.
Visuelle Hervorhebung des aktuell aktiven Workspace.
Ermöglichung des Wechsels zu einem anderen Workspace durch Klicken auf den entsprechenden Indikator.
Dynamische Aktualisierung der Anzeige basierend auf Änderungen in domain::workspaces::WorkspaceManager.
2.2. Visuelles Design und Theming
Darstellung: Das Widget besteht aus einer horizontalen Anordnung von einzelnen WorkspaceItemWidget-Instanzen. Jedes WorkspaceItemWidget repräsentiert einen Workspace.

Optionen für WorkspaceItemWidget:

Nummeriert: Zeigt die Nummer des Workspace an.
Icons: Zeigt ein Icon an, das dem Workspace zugeordnet ist (z.B. das Icon der primär gepinnten Anwendung oder ein benutzerdefiniertes Space-Icon aus domain::workspaces).
Kombiniert: Icon mit einer kleinen Nummer als Overlay.


Aktiver Workspace: Das WorkspaceItemWidget des aktiven Workspace wird deutlich hervorgehoben, z.B. durch eine andere Hintergrundfarbe (Akzentfarbe des Systems oder des Spaces), einen Rahmen oder eine hellere Text-/Iconfarbe.


Layout: Die WorkspaceItemWidgets werden horizontal in einer gtk::Box angeordnet.
CSS-Styling:

CSS-Knoten:

WorkspaceIndicatorWidget (als gtk::Box): box.1
WorkspaceItemWidget (als gtk::Button oder benutzerdefiniertes Widget): button oder ein benutzerdefinierter CSS-Name.2


CSS-Klassen:

.workspace-indicator: Für das Hauptcontainer-Widget.
.workspace-item: Für jedes einzelne WorkspaceItemWidget.
.active-workspace: Für das WorkspaceItemWidget, das den aktiven Workspace repräsentiert.
.workspace-occupied: (Optional) Für WorkspaceItemWidgets, die Fenster enthalten.




2.3. Datenstrukturen, Eigenschaften und Zustand2.3.1. WorkspaceInfo (UI-spezifische Datenstruktur)Diese Struktur dient dem Datenaustausch zwischen der Domänenschicht und dem WorkspaceIndicatorWidget.Rust// In src/ui/shell/panel_widget/workspace_indicator_widget/types.rs (oder ähnlich)
#
pub struct WorkspaceInfo {
    pub id: String, // Eindeutige ID des Workspace (von domain::workspaces::WorkspaceId)
    pub name: String, // Name des Workspace
    pub icon_name: Option<String>, // Optionaler Icon-Name für den Workspace
    pub number: usize, // Ordnungsnummer des Workspace
    pub is_active: bool, // True, wenn dies der aktive Workspace ist
    pub is_occupied: bool, // True, wenn der Workspace Fenster enthält (optional für Styling)
}
2.3.2. WorkspaceItemWidget (GObject-Subklasse)Jeder Indikator im WorkspaceIndicatorWidget ist eine Instanz von WorkspaceItemWidget.

GObject-Definition (WorkspaceItemWidget):Erbend von gtk::Button für einfache Klickbarkeit und Styling.
Auszug aus src/ui/shell/panel_widget/workspace_indicator_widget/workspace_item_widget/imp.rs (vereinfacht):
Rustuse gtk::glib;
use gtk::subclass::prelude::*;
use std::cell::RefCell;

#
pub struct WorkspaceItemWidget {
    workspace_id: RefCell<Option<String>>,
    workspace_number: RefCell<Option<usize>>,
    // Ggf. Referenz auf ein internes gtk::Label oder gtk::Image
    label_widget: TemplateChild<gtk::Label>, // Beispiel, wenn CompositeTemplate genutzt wird
    icon_widget: TemplateChild<gtk::Image>,  // Beispiel
}

#[glib::object_subclass]
impl ObjectSubclass for WorkspaceItemWidget {
    const NAME: &'static str = "NovaDEWorkspaceItemWidget";
    type Type = super::WorkspaceItemWidget;
    type ParentType = gtk::Button; // Erbt von gtk::Button

    fn new() -> Self {
        Self {
            workspace_id: RefCell::new(None),
            workspace_number: RefCell::new(None),
            label_widget: TemplateChild::default(),
            icon_widget: TemplateChild::default(),
        }
    }
    fn class_init(klass: &mut Self::Class) {
        // klass.bind_template(); // Falls.ui Datei verwendet wird
        klass.set_css_name("workspaceitemwidget");
    }
    // fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
    //     obj.init_template();
    // }
}
impl ObjectImpl for WorkspaceItemWidget {
    // Eigenschaften hier definieren, falls nötig (z.B. "workspace-id", "is-active-item")
    // Für dieses Widget reicht es oft, den Zustand über Methoden zu setzen und
    // das Aussehen direkt anzupassen.
}
impl WidgetImpl for WorkspaceItemWidget {}
impl ButtonImpl for WorkspaceItemWidget {}

Auszug aus src/ui/shell/panel_widget/workspace_indicator_widget/workspace_item_widget/mod.rs (vereinfacht):
Rustuse gtk::glib;
use gtk::subclass::prelude::*;
use super::types::WorkspaceInfo; // Annahme, dass WorkspaceInfo hier definiert ist

mod imp;

glib::wrapper! {
    pub struct WorkspaceItemWidget(ObjectSubclass<imp::WorkspaceItemWidget>)
        @extends gtk::Button, gtk::Widget,
        @implements gtk::Accessible, gtk::Actionable, gtk::Buildable, gtk::ConstraintTarget;
}

impl WorkspaceItemWidget {
    pub fn new(info: &WorkspaceInfo) -> Self {
        let item: Self = glib::Object::new();
        item.update_content(info);
        item.set_workspace_id(Some(info.id.clone()));
        item.set_workspace_number(Some(info.number));
        item
    }

    pub fn workspace_id(&self) -> Option<String> {
        self.imp().workspace_id.borrow().clone()
    }

    fn set_workspace_id(&self, id: Option<String>) {
        self.imp().workspace_id.replace(id);
    }

    pub fn workspace_number(&self) -> Option<usize> {
        *self.imp().workspace_number.borrow()
    }

    fn set_workspace_number(&self, num: Option<usize>) {
        self.imp().workspace_number.replace(num);
    }

    pub fn update_content(&self, info: &WorkspaceInfo) {
        // Logik zum Setzen des Labels (Nummer oder Name) oder Icons
        // Beispiel: self.set_label(&info.number.to_string());
        // Oder: self.imp().label_widget.set_text(&info.number.to_string());
        // Oder: if let Some(icon_name) = &info.icon_name {
        //           self.imp().icon_widget.set_from_icon_name(Some(icon_name));
        //           self.set_child(Some(&self.imp().icon_widget));
        //       } else {
        //           self.imp().label_widget.set_text(&info.number.to_string());
        //           self.set_child(Some(&self.imp().label_widget));
        //       }

        if info.is_active {
            self.add_css_class("active-workspace");
        } else {
            self.remove_css_class("active-workspace");
        }
        // Ggf. Tooltip setzen: self.set_tooltip_text(Some(&info.name));
    }
}


2.3.3. WorkspaceIndicatorWidget (GObject-Subklasse)

GObject-Definition (WorkspaceIndicatorWidget):Erbend von gtk::Box.
Auszug aus src/ui/shell/panel_widget/workspace_indicator_widget/imp.rs (vereinfacht):
Rustuse gtk::glib;
use gtk::subclass::prelude::*;
use std::cell::RefCell;
use std::collections::HashMap;
use super::workspace_item_widget::WorkspaceItemWidget;
use super::types::WorkspaceInfo;

#
pub struct WorkspaceIndicatorWidget {
    // GObject Properties
    max_visible_items: RefCell<u32>, // 0 für unbegrenzt
    show_workspace_names: RefCell<bool>, // Beeinflusst Darstellung in WorkspaceItemWidget

    // Interner Zustand
    workspace_items_container: TemplateChild<gtk::Box>, // Die Box, die WorkspaceItemWidgets hält
    workspace_item_widgets: RefCell<HashMap<String, WorkspaceItemWidget>>, // Map von Workspace-ID zu Widget
    // Referenz auf den WorkspaceManager-Proxy oder Event-Listener
    // workspace_event_listener_id: RefCell<Option<glib::SignalHandlerId>>, // Beispiel
}

#[glib::object_subclass]
impl ObjectSubclass for WorkspaceIndicatorWidget {
    const NAME: &'static str = "NovaDEWorkspaceIndicatorWidget";
    type Type = super::WorkspaceIndicatorWidget;
    type ParentType = gtk::Box;

    fn new() -> Self {
        Self {
            max_visible_items: RefCell::new(10), // Standard: max 10 Items
            show_workspace_names: RefCell::new(false), // Standard: Nummern/Icons
            workspace_items_container: TemplateChild::default(),
            workspace_item_widgets: RefCell::new(HashMap::new()),
        }
    }
    fn class_init(klass: &mut Self::Class) {
        // klass.bind_template(); // Falls.ui Datei verwendet wird
        // Properties hier installieren
        klass.set_css_name("workspaceindicator");
    }
    // fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
    //     obj.init_template();
    // }
}
impl ObjectImpl for WorkspaceIndicatorWidget {
    fn constructed(&self) {
        self.parent_constructed();
        let obj = self.obj();
        obj.set_orientation(gtk::Orientation::Horizontal);
        obj.set_spacing(4); // Beispiel für Abstand zwischen Items
        // Initialisiere workspace_items_container, falls nicht über Template
        // self.workspace_items_container.set_orientation(gtk::Orientation::Horizontal);
        // self.obj().append(&self.workspace_items_container);

        // Hier Logik zum Abonnieren von Workspace-Events von domain::workspaces
        // obj.subscribe_to_workspace_events();
    }
    // fn dispose() und fn finalize() für Aufräumarbeiten (z.B. Signalhandler trennen)
}
impl WidgetImpl for WorkspaceIndicatorWidget {}
impl BoxImpl for WorkspaceIndicatorWidget {}



Eigenschaften (Properties) für WorkspaceIndicatorWidget:
Tabelle 2.1: WorkspaceIndicatorWidget Eigenschaften

EigenschaftsnameTypZugriffStandardwertBeschreibungmax-visible-itemsu32Lesen/Schreiben10Maximale Anzahl von Workspace-Indikatoren, die angezeigt werden. 0 bedeutet unbegrenzt. Bei Überschreitung könnten z.B. Pfeile oder ein Überlaufmenü erscheinen (zukünftige Erweiterung).show-workspace-namesboolLesen/SchreibenfalseWenn true, versuchen WorkspaceItemWidgets, den Namen des Workspace anzuzeigen, sonst eher Nummer oder Icon.2.4. API und Methoden2.4.1. WorkspaceIndicatorWidget
pub fn new() -> Self

Signatur: pub fn new() -> Self
Verantwortlichkeit: Konstruktor. Initialisiert die interne gtk::Box für die WorkspaceItemWidgets und abonniert sich bei domain::workspaces::WorkspaceManager für WorkspaceEvents.


pub fn update_workspaces(&self, workspaces_info: Vec<WorkspaceInfo>) noexcept;

Signatur: pub fn update_workspaces(&self, workspaces_info: Vec<super::types::WorkspaceInfo>) noexcept
Verantwortlichkeit: Hauptmethode zur Aktualisierung der Anzeige.

Entfernt alle aktuellen WorkspaceItemWidgets aus dem internen Container.
Löscht den workspace_item_widgets HashMap.
Iteriert über workspaces_info:

Erstellt für jeden Eintrag ein neues WorkspaceItemWidget mit den Daten aus WorkspaceInfo.
Verbindet das clicked-Signal des WorkspaceItemWidget mit der internen Methode on_workspace_item_clicked.
Fügt das WorkspaceItemWidget dem internen Container (workspace_items_container) hinzu.
Speichert das WorkspaceItemWidget im workspace_item_widgets HashMap (ID als Schlüssel).


Berücksichtigt max-visible-items (initial einfach abschneiden, später ggf. komplexere Logik).




fn on_workspace_item_clicked(&self, item_widget: &WorkspaceItemWidget) noexcept;

Signatur: fn on_workspace_item_clicked(&self, item_widget: &super::workspace_item_widget::WorkspaceItemWidget) noexcept
Verantwortlichkeit: Wird aufgerufen, wenn ein WorkspaceItemWidget geklickt wird.

Ermittelt die workspace_id des geklickten Items.
Sendet einen Befehl/Aktion an domain::workspaces::WorkspaceManager, um den aktiven Workspace zu wechseln (z.B. über eine UI-Aktionsschicht oder einen direkten Aufruf, falls die Architektur dies erlaubt und Thread-sicher ist).




fn handle_workspace_event(&self, event: &domain::workspaces::WorkspaceEvent) noexcept; (Beispielhafter Name)

Signatur: fn handle_workspace_event(&self, event: &<Pfad_zu_domain>::workspaces::WorkspaceEvent) noexcept
Verantwortlichkeit: Callback-Funktion, die auf WorkspaceEvents von domain::workspaces::WorkspaceManager reagiert.

Fordert die aktuelle Liste aller Workspaces und den aktiven Workspace vom WorkspaceManager an.
Konvertiert die Domain-Daten in eine Vec<WorkspaceInfo>.
Ruft self.update_workspaces() mit den neuen Daten auf.
Diese Funktion wird typischerweise über glib::MainContext::spawn_local aufgerufen, wenn das Domain-Event aus einem anderen Thread kommt. 4




2.4.2. WorkspaceItemWidget
pub fn new(info: &WorkspaceInfo) -> Self (siehe oben)
pub fn update_content(&self, info: &WorkspaceInfo) noexcept; (siehe oben)

Aktualisiert das Label (Nummer/Name) und/oder das Icon basierend auf info.icon_name, info.name, info.number und der show-workspace-names-Eigenschaft des Parent-WorkspaceIndicatorWidget.
Setzt die CSS-Klasse .active-workspace basierend auf info.is_active.
Setzt optional einen Tooltip mit info.name.


2.5. Signale und Ereignisse2.5.1. WorkspaceIndicatorWidget
Emittierte Signale: Keine spezifischen benutzerdefinierten Signale für externe Nutzung vorgesehen. Interne Logik wird durch Methodenaufrufe und Property-Änderungen gesteuert.
Verbundene Signale/Events:

Abonniert WorkspaceEvents von domain::workspaces::WorkspaceManager.

Publisher: domain::workspaces::WorkspaceManager.
Subscriber: WorkspaceIndicatorWidget::handle_workspace_event.
Zweck: Aktualisierung der Workspace-Anzeige bei Änderungen in der Domänenschicht.




2.5.2. WorkspaceItemWidget
Emittierte Signale: Erbt das clicked-Signal von gtk::Button.
Verbundene Signale: Keine spezifischen.
2.6. Fehlerbehandlung
enum WorkspaceIndicatorError (definiert mit thiserror):

DomainCommunicationError(String): Fehler bei der Kommunikation mit domain::workspaces::WorkspaceManager.
ItemCreationFailed(String): Wenn ein WorkspaceItemWidget nicht erstellt werden kann.


Fehler werden primär geloggt (tracing). Eine fehlerhafte Aktualisierung könnte dazu führen, dass der Indikator veraltete Informationen anzeigt oder leer ist. Kritische Fehler bei der Initialisierung (z.B. Verbindung zum Domain-Service nicht möglich) könnten das Hinzufügen des Widgets zum Panel verhindern.
2.7. Implementierungsplan und Schritte
Definiere WorkspaceInfo Struktur.
Implementiere WorkspaceItemWidget (workspace_item_widget/mod.rs und imp.rs):

Subklasse von gtk::Button.
Implementiere new() und update_content().
Stelle sicher, dass Klick-Events korrekt weitergeleitet werden können (durch das clicked-Signal der Basisklasse).


Implementiere WorkspaceIndicatorWidget (workspace_indicator_widget/mod.rs und imp.rs):

Subklasse von gtk::Box.
Definiere GObject-Properties (max-visible-items, show-workspace-names).
Implementiere new(): Initialisiere internen Container, abonniere Workspace-Events.
Implementiere update_workspaces(): Logik zum Leeren und neu Befüllen des Containers mit WorkspaceItemWidgets.
Implementiere on_workspace_item_clicked(): Logik zum Auslösen des Workspace-Wechsels.
Implementiere handle_workspace_event(): Anforderung neuer Daten und Aufruf von update_workspaces.


Integration: Das PanelWidget instanziiert das WorkspaceIndicatorWidget und fügt es einem seiner Bereiche hinzu.
2.8. Dateistruktursrc/
└── ui/
    └── shell/
        └── panel_widget/
            └── workspace_indicator_widget/
                ├── mod.rs                      // Öffentliche API für WorkspaceIndicatorWidget
                ├── imp.rs                      // GObject-Implementierung für WorkspaceIndicatorWidget
                ├── types.rs                    // Definition von WorkspaceInfo
                ├── workspace_item_widget.rs    // Enthält mod.rs und imp.rs für WorkspaceItemWidget
                │   ├── mod.rs                  // Öffentliche API für WorkspaceItemWidget
                │   └── imp.rs                  // GObject-Implementierung für WorkspaceItemWidget
                └── error.rs                    // (Optional) Definition von WorkspaceIndicatorError
3. Modul: ui::shell::panel_widget::ClockDateTimeWidget3.1. Übersicht und VerantwortlichkeitenDas ClockDateTimeWidget ist ein Panel-Modul, das die aktuelle Systemzeit und das Datum anzeigt. Optional kann es bei einem Klick ein Popover mit einem Kalender anzeigen.
Anzeige der formatierten aktuellen Uhrzeit und des Datums.
Regelmäßige Aktualisierung der Anzeige.
Optionale Anzeige eines Kalender-Popovers bei Klick.
Konfigurierbarkeit des Zeit-/Datumsformats.
3.2. Visuelles Design und Theming
Anzeige: Textbasierte Anzeige der Zeit und des Datums.

Schriftart, -größe und -farbe werden durch das globale GTK-Theme und spezifische CSS-Regeln gesteuert.


Kalender-Popover: Ein Standard gtk::Popover, das ein gtk::Calendar-Widget enthält.6
CSS-Styling:

CSS-Knoten:

ClockDateTimeWidget (als gtk::Button oder gtk::Label): button oder label.
Kalender-Popover: popover.


CSS-Klassen:

.clock-datetime-widget: Für das Haupt-Widget.
.calendar-popover-content: Für den Inhalt des Kalender-Popovers (falls benutzerdefinierte Anpassungen nötig sind).




3.3. Datenstrukturen, Eigenschaften und Zustand

GObject-Definition (ClockDateTimeWidget):Erbend von gtk::Button (um Klickbarkeit für das Popover zu ermöglichen) oder gtk::Label (wenn kein Popover). Für die Popover-Funktionalität ist gtk::Button oder ein gtk::Box mit einem gtk::GestureClick geeigneter.
Auszug aus src/ui/shell/panel_widget/clock_datetime_widget/imp.rs (vereinfacht):
Rustuse gtk::glib;
use gtk::subclass::prelude::*;
use std::cell::{Cell, RefCell};
use chrono::{DateTime, Local, SecondsFormat}; // [8]

#
pub struct ClockDateTimeWidget {
    // GObject Properties
    format_string: RefCell<String>,
    show_calendar_on_click: Cell<bool>,

    // Interner Zustand
    timer_id: RefCell<Option<glib::SourceId>>, // Für den Aktualisierungs-Timer [9, 10]
    calendar_popover: RefCell<Option<gtk::Popover>>,
    // Das Label-Widget, das die Zeit anzeigt (kann Kind des Buttons sein)
    time_label: TemplateChild<gtk::Label>,
}

#[glib::object_subclass]
impl ObjectSubclass for ClockDateTimeWidget {
    const NAME: &'static str = "NovaDEClockDateTimeWidget";
    type Type = super::ClockDateTimeWidget;
    // Erbt von gtk::Button, um Klickbarkeit und Popover-Ankerung zu erleichtern
    type ParentType = gtk::Button;

    fn new() -> Self {
        Self {
            format_string: RefCell::new("%H:%M".to_string()), // Standardformat [11]
            show_calendar_on_click: Cell::new(true),
            timer_id: RefCell::new(None),
            calendar_popover: RefCell::new(None),
            time_label: TemplateChild::default(),
        }
    }
    fn class_init(klass: &mut Self::Class) {
        // klass.bind_template(); // Falls.ui Datei verwendet wird
        // Properties hier installieren
        klass.set_css_name("clockdatetimewidget");
    }
    // fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
    //     obj.init_template();
    // }
}

impl ObjectImpl for ClockDateTimeWidget {
    fn constructed(&self) {
        self.parent_constructed();
        let obj = self.obj();

        // Initialisiere time_label, falls nicht über Template
        // self.time_label.set_use_markup(true); // Für Pango-Markup, falls benötigt
        // obj.set_child(Some(&self.time_label));

        obj.update_display(); // Erste Anzeige
        obj.setup_timer();    // Timer starten

        // Klick-Handler für Popover verbinden, falls show_calendar_on_click
        if self.show_calendar_on_click.get() {
            obj.connect_clicked(glib::clone!(@weak obj => move |_| {
                obj.show_calendar_popover();
            }));
        }
    }
    fn dispose(&self) {
        if let Some(source_id) = self.timer_id.borrow_mut().take() {
            source_id.remove();
        }
        if let Some(popover) = self.calendar_popover.borrow_mut().take() {
            popover.unparent(); // Sicherstellen, dass das Popover entfernt wird
        }
    }
    // Properties hier implementieren (set_property, property)
}
impl WidgetImpl for ClockDateTimeWidget {}
impl ButtonImpl for ClockDateTimeWidget {}



Eigenschaften (Properties) für ClockDateTimeWidget:
Tabelle 3.1: ClockDateTimeWidget Eigenschaften


EigenschaftsnameTypZugriffStandardwertBeschreibungformat-stringStringLesen/Schreiben"%H:%M"Der strftime-kompatible Format-String für die Zeit-/Datumsanzeige.11show-calendar-on-clickboolLesen/SchreibentrueWenn true, wird bei Klick auf das Widget ein Kalender-Popover angezeigt.
3.4. API und Methoden
pub fn new() -> Self

Signatur: pub fn new() -> Self
Verantwortlichkeit: Konstruktor. Initialisiert das Label, startet den Timer und verbindet ggf. den Klick-Handler für das Kalender-Popover.


fn update_display(&self) noexcept;

Signatur: fn update_display(&self) noexcept
Verantwortlichkeit: Ruft die aktuelle Zeit ab (chrono::Local::now() 8), formatiert sie gemäß format-string und aktualisiert den Text des internen gtk::Label (oder des Button-Labels).
Beispiel Formatierung: Local::now().format(self.imp().format_string.borrow().as_str()).to_string().11


fn setup_timer(&self) noexcept;

Signatur: fn setup_timer(&self) noexcept
Verantwortlichkeit: Startet einen Timer, der periodisch (z.B. jede Sekunde oder Minute, abhängig von der Granularität des format-string) update_display aufruft.
Verwendet glib::timeout_add_seconds_local oder glib::timeout_add_local für feinere Intervalle.9
Speichert die glib::SourceId im timer_id-Feld, um den Timer später entfernen zu können (im dispose-Handler).


fn show_calendar_popover(&self) noexcept;

Signatur: fn show_calendar_popover(&self) noexcept
Verantwortlichkeit: Erstellt (falls noch nicht geschehen) und zeigt ein gtk::Popover an, das ein gtk::Calendar-Widget enthält.6

Wenn self.imp().calendar_popover None ist:

Erstelle ein gtk::Calendar::new().
Erstelle ein gtk::Popover::builder().child(&calendar_widget).build().
Setze das Popover als Kind des ClockDateTimeWidget (oder eines spezifischen Ankerpunkts).
Speichere das Popover in self.imp().calendar_popover.


Setze das Popover relativ zum ClockDateTimeWidget (dem Button): popover.set_parent(self.obj().as_ref()).
Zeige das Popover: popover.popup().




3.5. Signale und Ereignisse
Emittierte Signale: Keine spezifischen benutzerdefinierten Signale. Erbt Signale von gtk::Button (z.B. clicked).
Verbundene Signale/Events:

Interner Timer-Event von glib::timeout_add_seconds_local.
clicked-Signal des Buttons (falls show-calendar-on-click true ist), um show_calendar_popover aufzurufen.
Lauscht auf Änderungen der relevanten Einstellungen von domain::global_settings_and_state_management (z.B. für format-string), um die GObject-Properties zu aktualisieren.


3.6. Fehlerbehandlung
enum ClockDateTimeError (definiert mit thiserror):

InvalidFormatString(String): Wenn der format-string ungültig ist und chrono::format fehlschlägt.
TimerSetupFailed(String): Wenn der glib-Timer nicht eingerichtet werden kann.


Fehler werden geloggt. Ein ungültiger Format-String könnte zu einer Standardanzeige oder einer Fehlermeldung im Widget führen.
3.7. Implementierungsplan und Schritte
Definiere ClockDateTimeWidget (clock_datetime_widget/mod.rs und imp.rs):

Subklasse von gtk::Button.
Definiere GObject-Properties (format-string, show-calendar-on-click).
Implementiere new(): Initialisiere das interne Label (als Kind des Buttons), rufe update_display() und setup_timer() auf. Verbinde clicked-Signal, falls show-calendar-on-click.


Implementiere update_display(): Hole aktuelle Zeit, formatiere sie, setze Label-Text.
Implementiere setup_timer(): Nutze glib::timeout_add_seconds_local (z.B. für sekündliche Updates), speichere SourceId. Der Callback ruft update_display() auf und gibt glib::ControlFlow::Continue zurück.
Implementiere show_calendar_popover(): Erstelle und zeige gtk::Popover mit gtk::Calendar.
Implementiere den dispose-Handler, um den Timer zu entfernen.
Integration: Das PanelWidget instanziiert das ClockDateTimeWidget und fügt es einem seiner Bereiche hinzu.
Verbindung mit domain::global_settings_and_state_management: Lausche auf Änderungen der Format-String-Einstellung und aktualisiere die format-string-Property des Widgets.
3.8. Dateistruktursrc/
└── ui/
    └── shell/
        └── panel_widget/
            └── clock_datetime_widget/
                ├── mod.rs          // Öffentliche API für ClockDateTimeWidget
                ├── imp.rs          // GObject-Implementierung
                └── error.rs        // (Optional) Definition von ClockDateTimeError
4. Schlussfolgerungen (für Teil 2)Die Spezifikationen für WorkspaceIndicatorWidget und ClockDateTimeWidget erweitern die Funktionalität des PanelWidget um zwei wichtige, benutzerorientierte Module. Die Implementierung des WorkspaceIndicatorWidget erfordert eine enge Kopplung mit domain::workspaces::WorkspaceManager, um stets aktuelle Informationen über die Arbeitsbereiche anzuzeigen und Interaktionen zu ermöglichen. Das ClockDateTimeWidget bietet eine grundlegende, aber essentielle Funktion mit optionaler Erweiterung durch ein Kalender-Popover.Die konsequente Anwendung von GObject-Subclassing, die Nutzung von GTK-Standardwidgets und -Containern sowie die klare Definition von Schnittstellen und Verantwortlichkeiten sind weiterhin zentrale Aspekte. Die Fehlerbehandlung und das Logging folgen den im ersten Teil etablierten Mustern.Mit diesen Modulen nimmt die Kernfunktionalität des Panels weiter Gestalt an. Die nächsten Schritte werden sich auf weitere Indikatoren und komplexere Panel-Module wie das SystemTrayEquivalentWidget konzentrieren.

# NovaDE: Ultra-Granulare Definition Interner Schnittstellen

## Präambel: Grundlegende Prinzipien

Die Architektur von NovaDE basiert auf einer Reihe fundamentaler Kommunikations- und Strukturprinzipien, die darauf abzielen, ein robustes, modulares und wartbares System zu schaffen. Diese Prinzipien sind entscheidend für das Erreichen der übergeordneten Projektziele wie Performance, intuitive Bedienung, Modernität, Modularität, Anpassbarkeit, sichere KI-Integration und Stabilität.

- **Kernprinzipien der Kommunikation:**
    - Die Interaktion zwischen den verschiedenen Schichten des Systems – Kern (Core), Domäne (Domain), System und Benutzeroberfläche (UI) – erfolgt primär über klar definierte öffentliche Programmierschnittstellen (APIs). Diese APIs werden in der Regel als Rust-Traits spezifiziert und von Service-Strukturen innerhalb der jeweiligen Schicht implementiert. Dieser Ansatz fördert ein vertragsbasiertes Interaktionsmodell, das die Kopplung zwischen den Schichten minimiert und die Austauschbarkeit von Implementierungen erleichtert.
    - Ein integraler Bestandteil der Architektur ist ein robustes, ereignisgesteuertes System. Dieses System dient der Benachrichtigung über Zustandsänderungen und ermöglicht entkoppelte Interaktionen zwischen den Schichten. Komponenten können auf relevante Ereignisse reagieren, ohne direkte Abhängigkeiten zu den Ereigniserzeugern aufbauen zu müssen. Dies ist besonders für die UI-Schicht von Bedeutung, da es reaktive Updates auf Änderungen im Domänenzustand oder Systemstatus ohne Polling-Mechanismen ermöglicht.
    - Eine strikte Schichtenarchitektur wird durchgesetzt: Höhere Schichten dürfen typischerweise nur von unmittelbar tieferliegenden Schichten abhängen. Dieses hierarchische Abhängigkeitsmodell verbessert die Modularität, Testbarkeit und Wartbarkeit, indem es zirkuläre Abhängigkeiten und unkontrollierte Interaktionen verhindert.
    - **Fehlerbehandlung:** Eine konsistente Fehlerbehandlungsstrategie wird über alle Schichten hinweg angewendet. Die `thiserror`-Bibliothek wird für die Definition von spezifischen, benutzerdefinierten Fehlertypen genutzt. `core::errors::CoreError` dient als fundamentaler Basistyp für Fehler. Es ist zwingend erforderlich, dass Fehlerketten (abrufbar über die `source()`-Methode) bei der Weitergabe oder beim Wrappen von Fehlern erhalten bleiben, um eine umfassende Fehlerdiagnose zu gewährleisten.

Die Kombination aus strikter Schichtung, einem API-First-Design (mittels Rust-Traits) und einem ereignisgesteuerten Ansatz bildet ein leistungsfähiges Fundament für NovaDE. Das Ereignissystem ist insbesondere für die UI-Schicht von entscheidender Bedeutung, da es ihr ermöglicht, reaktiv auf zugrundeliegende Änderungen im Domänenzustand oder Systemstatus zu reagieren, ohne auf ineffiziente Polling-Mechanismen zurückgreifen zu müssen. Beispielsweise kann die UI dynamisch aktualisiert werden, wenn ein `ThemeChangedEvent` vom `ThemingEngine` ausgelöst wird, anstatt periodisch den aktuellen Theme-Status abfragen zu müssen. Diese Entkopplung reduziert die Systemlast und verbessert die Reaktionsfähigkeit der Benutzeroberfläche. Die nachfolgende ultra-granulare Definition wird daher nicht nur die synchronen API-Methoden detailliert beschreiben, sondern auch die präzise Struktur, den Payload und die Semantik jedes Ereignisses, das zwischen den Schichten ausgetauscht wird. Dies stellt sicher, dass sowohl API-Konsumenten als auch Ereignis-Abonnenten ein klares und eindeutiges Verständnis der Daten haben, die sie senden oder empfangen werden.

---

**Teil 1: Ultra-Granulare Schnittstellendefinition der UI-Schicht**

Dieser Teil adressiert die primäre Anforderung einer detaillierten Schnittstellendefinition für die UI-Schicht und konzentriert sich darauf, wie diese mit der Domänen- und der Systemschicht interagiert. Die UI-Schicht ist für die Präsentation von Informationen für den Benutzer und die Übersetzung von Benutzereingaben in Aktionen auf den unteren Schichten verantwortlich.

- **1.1. Interaktionsprinzipien der UI-Schicht mit unteren Schichten**
    
    - **UI als Konsument von Domänenlogik und Systemdiensten:**
        - Die UI-Schicht agiert als primärer Interaktionspunkt mit dem Benutzer. Sie übersetzt Benutzereingaben (z.B. Klicks, Tastatureingaben, Gesten) in spezifische, wohldefinierte Aufrufe von Methoden, die von Diensten der Domänenschicht (für Geschäftslogik und Anwendungszustandsmanipulation) oder der Systemschicht (für Betriebssystem- oder Hardwareinteraktionen) bereitgestellt werden.
        - Ein entscheidender Aspekt ist, dass die UI-Schicht Ereignisse abonniert, die sowohl von der Domänen- als auch von der Systemschicht stammen. Diese Ereignisse signalisieren Zustandsänderungen oder das Auftreten bemerkenswerter Systemaktivitäten. Dies ermöglicht es der UI, ihre Darstellung dynamisch und reaktiv zu aktualisieren und so den aktuellen Zustand der Anwendung und des zugrundeliegenden Systems widerzuspiegeln.
        - Obwohl die interne Implementierung von UI-Komponenten stark auf einem Toolkit wie GTK4 basieren wird, werden die in diesem Dokument definierten Schnittstellen (zwischen UI und Domäne/System) in Form von reinen Rust-Typen, Traits und Ereignis-Strukturen spezifiziert. Diese Abstraktion stellt sicher, dass die Kernlogik von NovaDE nicht intrinsisch an ein spezifisches UI-Toolkit gebunden ist. Beispielsweise wird ein `core::types::Color` in API-Signaturen verwendet, nicht ein Toolkit-spezifischer Typ wie `gdk4::RGBA`.
    - **Zustandsverwaltung in der UI:**
        - Die UI-Schicht ist für die Verwaltung ihres eigenen Präsentationszustands verantwortlich (oft als ViewModels oder UI-spezifischer Zustand bezeichnet). Dieser Zustand wird von dem Zustand abgeleitet, der von der Domänen- und Systemschicht verwaltet wird, und muss mit diesem synchron gehalten werden.
        - Eine robuste und effiziente UI-Zustandsverwaltung ist für eine reaktionsschnelle und konsistente Benutzererfahrung von größter Bedeutung. Während die UI-Schicht ihre visuelle Darstellung und temporäre Interaktionszustände verwaltet, befindet sich die autoritative "Wahrheitsquelle" (Source of Truth) für geschäftskritische Daten innerhalb der Domänenschicht und für den Systemstatus innerhalb der Systemschicht. Die UI muss so aufgebaut sein, dass sie effizient auf Änderungen reagiert, die von diesen unteren Schichten signalisiert werden.
        - Die Benutzeranfrage liefert ein Beispiel: `ui::theming_gtk` konsumiert `AppliedThemeState` von `ThemingEngine`. Dieses Interaktionsmuster impliziert einen reaktiven Aktualisierungsmechanismus. Verschiedene Ansätze zur Zustandsverwaltung in `gtk-rs`-Anwendungen, einschließlich der Verwendung von `Rc<RefCell<T>>` für Single-Threaded Shared Mutability oder Mustern wie TEA (The Elm Architecture) oder Relm4, werden in der Forschung diskutiert.1 Für die geschichtete Architektur von NovaDE ist der am besten geeignete Ansatz, dass die UI-Schicht Domänen- und Systemereignisse abonniert. Nach dem Empfang eines Ereignisses aktualisiert die UI ihren lokalen Zustand (der GObject-Eigenschaften, Relm4-Modellfelder oder andere UI-Toolkit-spezifische Zustandscontainer sein können). Dieser ereignisgesteuerte Ansatz vermeidet eine enge Kopplung, bei der die Domänen- oder Systemschicht direkte Kenntnis von GTK-GObjects oder anderen UI-internen Details haben müsste.
        - Ereignisbehandlungsmechanismen innerhalb von GTK4 und verschiedene Zustandsverwaltungsmuster 1 sind für die interne Implementierung der UI-Schicht relevant. Dieses Schnittstellendefinitionsdokument konzentriert sich jedoch auf die Ereignisse, die die UI von unteren Schichten konsumiert, und die Daten-Payloads, die diese Ereignisse transportieren.
    - **Strategie zur Fehlerpräsentation:**
        - Die UI-Schicht trägt die Verantwortung für die Übersetzung von Fehlern, die von der Domänen- und Systemschicht empfangen werden, in benutzerfreundliche und kontextuell angemessene Benachrichtigungen, Dialoge oder visuelle Hinweise. Rohe technische Fehlerdetails sollten dem Endbenutzer nicht direkt präsentiert werden.
        - Intern könnte die UI `gtk::AlertDialog` 6 oder benutzerdefinierte Benachrichtigungs-Widgets (potenziell unter Verwendung von `gtk4-layer-shell` 9 für nicht-modale Popups) zur Darstellung dieser übersetzten Fehler verwenden. Diese Schnittstellendefinition wird spezifizieren, wie Fehlertypen (z.B. `ThemingError`, `CompositorError`) von unteren Schichten erwartet werden, von der UI behandelt und potenziell auf standardisierte benutzerorientierte Fehlerkategorien oder -nachrichten abgebildet zu werden.
        - Eine konsistente und verständliche Fehlerpräsentationsstrategie ist grundlegend für eine gute Benutzererfahrung. Die UI muss als Filter und Übersetzer fungieren und Benutzer vor komplexen oder kryptischen internen Fehlerdetails schützen. Die Benutzeranfrage spezifiziert, dass alle Schichten `thiserror`-basierte Fehler-Enums verwenden. Die UI-Schicht wird diese spezifischen Fehlertypen empfangen. Wenn beispielsweise der `WorkspaceManager` einen `WorkspaceManagerError::WorkspaceNotFound` zurückgibt, sollte die UI-Schicht diese rohe Enum-Variante nicht anzeigen. Stattdessen sollte sie dies in eine für Menschen lesbare Nachricht wie "Der ausgewählte Arbeitsbereich konnte nicht gefunden werden." übersetzen oder gegebenenfalls einen Dialog mit Wiederherstellungsoptionen anbieten. Diese Übersetzungs- und Präsentationslogik ist eine Kernaufgabe der UI-Schicht. Die Schnittstellendefinition sollte dies leiten, indem sie Fehlerkategorien vorschlägt, die die UI von jedem Dienst zu behandeln bereit sein sollte.
- 1.2. Schnittstelle der UI-Schicht mit der Domänenschicht
    
    Dieser Abschnitt definiert ultra-granular die Interaktionen der UI-Schicht mit jedem von der Domänenschicht bereitgestellten Dienst.
    
    - **1.2.1. `ThemingEngine`-API-Nutzung durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, das aktuelle visuelle Thema der NovaDE-Umgebung abzufragen und zu ändern.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `update_configuration`: `domain::theming::ThemeConfigurationUpdate { theme_name: Option<String>, variant_name: Option<String>, custom_color_palette: Option<HashMap<String, core::types::Color>> }`
            - Ausgabe von `get_current_theme_state`: `domain::theming::AppliedThemeState { theme_name: String, variant_name: String, primary_accent_color: core::types::Color, secondary_accent_color: core::types::Color, default_background_color: core::types::Color, default_text_color: core::types::Color, default_font_family: String, default_font_size: u16, border_radius: u8, shadow_intensity: f32 }`
            - Ausgabe von `get_available_themes`: `Vec<domain::theming::ThemeIdentifier { theme_id: String, display_name: String, available_variants: Vec<String>, preview_icon_path: Option<PathBuf>, author: Option<String>, description: Option<String> }>`
            - Ausgabe von `get_current_configuration`: `domain::theming::CurrentThemeConfiguration { theme_name: String, variant_name: String, custom_palette: HashMap<String, core::types::Color> }`
        - **Von der UI aufgerufene API-Methoden (aus `domain::ThemingEngine`-Trait):**
            - `fn get_current_theme_state(&self) -> Result<domain::theming::AppliedThemeState, domain::ThemingError>;`
            - `fn get_available_themes(&self) -> Result<Vec<domain::theming::ThemeIdentifier>, domain::ThemingError>;`
            - `fn get_current_configuration(&self) -> Result<domain::theming::CurrentThemeConfiguration, domain::ThemingError>;`
            - `fn update_configuration(&self, config_update: domain::theming::ThemeConfigurationUpdate) -> Result<(), domain::ThemingError>;`
            - `fn reload_themes_and_tokens(&self) -> Result<(), domain::ThemingError>;`
            - `// Die Ereignisabonnierung erfolgt über einen globalen EventBus oder eine dedizierte Abonnementmethode, falls eine feingranulare Steuerung erforderlich ist.`
        - **Von der UI konsumierte Event-Payloads:**
            - `domain::theming::ThemeChangedEvent { new_state: domain::theming::AppliedThemeState }`
        - **Fehlerbehandlung durch die UI:** Die UI muss `domain::ThemingError`-Varianten (z.B. `ThemeNotFound`, `InvalidConfiguration`, `AssetLoadFailure`) auf angemessene benutzerorientierte Nachrichten oder Wiederherstellungsaktionen abbilden.
    - **1.2.2. `WorkspaceManager`-API-Nutzung durch die UI:**
        
        - **Zweck:** Ermöglicht der UI die Verwaltung virtueller Arbeitsbereiche, einschließlich deren Erstellung, Löschung, Aktivierung und Zuweisung von Fenstern.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `create_workspace`: `domain::workspaces::CreateWorkspaceParams { name: Option<String>, layout_hint: Option<domain::workspaces::WorkspaceLayoutType>, icon_name: Option<String> }`
            - Eingabe für `assign_window_to_workspace`: `window_id: core::types::WindowId`, `workspace_id: core::types::WorkspaceId`
            - Eingabe für `rename_workspace`: `workspace_id: core::types::WorkspaceId`, `new_name: String`
            - Ausgabe von `get_active_workspace`, `get_workspace_by_id`, `list_workspaces`: `domain::workspaces::WorkspaceDescriptor { id: core::types::WorkspaceId, name: String, display_name: String, icon_name: Option<String>, layout: domain::workspaces::WorkspaceLayoutType, window_ids: Vec<core::types::WindowId>, is_active: bool, creation_timestamp: core::types::DateTime<Utc> }`
            - Enum `domain::workspaces::WorkspaceLayoutType { TilingHorizontal, TilingVertical, Floating, Maximized }`
        - **Von der UI aufgerufene API-Methoden (aus `domain::WorkspaceManager`-Trait):**
            - `fn create_workspace(&self, params: domain::workspaces::CreateWorkspaceParams) -> Result<core::types::WorkspaceId, domain::WorkspaceManagerError>;`
            - `fn delete_workspace(&self, id: core::types::WorkspaceId) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn set_active_workspace(&self, id: core::types::WorkspaceId) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn get_active_workspace(&self) -> Result<Option<domain::workspaces::WorkspaceDescriptor>, domain::WorkspaceManagerError>;`
            - `fn get_workspace_by_id(&self, id: core::types::WorkspaceId) -> Result<Option<domain::workspaces::WorkspaceDescriptor>, domain::WorkspaceManagerError>;`
            - `fn list_workspaces(&self) -> Result<Vec<domain::workspaces::WorkspaceDescriptor>, domain::WorkspaceManagerError>;`
            - `fn assign_window_to_workspace(&self, window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn remove_window_from_workspace(&self, window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn get_window_assignment(&self, window_id: core::types::WindowId) -> Result<Option<core::types::WorkspaceId>, domain::WorkspaceManagerError>;`
            - `fn save_workspace_configuration(&self) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn rename_workspace(&self, workspace_id: core::types::WorkspaceId, new_name: String) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn set_workspace_layout(&self, workspace_id: core::types::WorkspaceId, layout: domain::workspaces::WorkspaceLayoutType) -> Result<(), domain::WorkspaceManagerError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `domain::workspaces::WorkspaceCreatedEvent { descriptor: domain::workspaces::WorkspaceDescriptor }`
            - `domain::workspaces::WorkspaceDeletedEvent { workspace_id: core::types::WorkspaceId, previous_name: String }`
            - `domain::workspaces::ActiveWorkspaceChangedEvent { old_workspace_id: Option<core::types::WorkspaceId>, new_workspace_id: core::types::WorkspaceId }`
            - `domain::workspaces::WorkspaceLayoutChangedEvent { workspace_id: core::types::WorkspaceId, new_layout: domain::workspaces::WorkspaceLayoutType }`
            - `domain::workspaces::WindowAssignedToWorkspaceEvent { window_id: core::types::WindowId, new_workspace_id: core::types::WorkspaceId, old_workspace_id: Option<core::types::WorkspaceId> }`
            - `domain::workspaces::WindowRemovedFromWorkspaceEvent { window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId }`
            - `domain::workspaces::WorkspaceRenamedEvent { workspace_id: core::types::WorkspaceId, new_name: String, old_name: String }`
            - `domain::workspaces::WorkspaceOrderChangedEvent { ordered_workspace_ids: Vec<core::types::WorkspaceId> }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `domain::WorkspaceManagerError`-Varianten (z.B. `WorkspaceNotFound`, `WindowNotManaged`, `NameConflict`) auf Benutzerfeedback.
    - **1.2.3. `AIInteractionLogicService`-API-Nutzung durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, KI-gestützte Interaktionen zu initiieren, Kontextinformationen abzurufen und Benutzereinwilligungen zu verwalten.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `initiate_interaction`: `domain::ai::InteractionRequest { prompt_text: String, context_type: domain::ai::AIContextType, attachments: Option<Vec<domain::ai::AIAttachment>>, preferred_model_id: Option<String> }`
            - Enum `domain::ai::AIContextType { GeneralText, CodeGeneration, ImageAnalysis, /*... */ }`
            - Struct `domain::ai::AIAttachment { mime_type: String, data_uri: String /* or PathBuf if local */, name: Option<String> }`
            - Ausgabe von `initiate_interaction`: `domain::ai::InteractionResponseHandle { interaction_id: core::types::Uuid }` (Weitere Ergebnisse/Streams könnten über Events oder eine Streaming-API kommen)
            - Ausgabe von `get_interaction_context`: `domain::ai::InteractionContext { interaction_id: core::types::Uuid, status: domain::ai::AIInteractionStatus, history: Vec<domain::ai::AIMessage>, available_actions: Vec<domain::ai::AIActionSuggestion> }`
            - Enum `domain::ai::AIInteractionStatus { PendingInput, Processing, AwaitingConsent, Completed, Error }`
            - Struct `domain::ai::AIMessage { role: domain::ai::AIRole, content: String, timestamp: core::types::DateTime<Utc> }`
            - Enum `domain::ai::AIRole { User, Assistant, System }`
            - Struct `domain::ai::AIActionSuggestion { action_id: String, display_text: String, action_type: domain::ai::AIActionType }`
            - Enum `domain::ai::AIActionType { ExecuteCommand, InsertText, OpenLink }`
            - Eingabe für `provide_consent`: `interaction_id: core::types::Uuid, model_id: String, consent_granted: bool`
            - Ausgabe von `get_consent_for_model`: `domain::ai::AIConsentStatus { model_id: String, granted: bool, last_updated: core::types::DateTime<Utc> }`
            - Struct `domain::ai::AIModelProfile { model_id: String, display_name: String, provider: String, capabilities: Vec<domain::ai::AIContextType>, requires_consent: bool }`
        - **Von der UI aufgerufene API-Methoden (aus `domain::AIInteractionLogicService`-Trait):**
            - `async fn initiate_interaction(&self, request: domain::ai::InteractionRequest) -> Result<domain::ai::InteractionResponseHandle, domain::AIInteractionError>;`
            - `async fn get_interaction_context(&self, interaction_id: core::types::Uuid) -> Result<domain::ai::InteractionContext, domain::AIInteractionError>;`
            - `async fn provide_consent(&self, interaction_id: core::types::Uuid, model_id: String, consent_granted: bool) -> Result<(), domain::AIInteractionError>;`
            - `async fn get_consent_for_model(&self, model_id: String) -> Result<domain::ai::AIConsentStatus, domain::AIInteractionError>;`
            - `async fn store_consent(&self, model_id: String, granted: bool) -> Result<(), domain::AIInteractionError>;`
            - `async fn load_model_profiles(&self) -> Result<Vec<domain::ai::AIModelProfile>, domain::AIInteractionError>;`
            - `async fn send_message_to_interaction(&self, interaction_id: core::types::Uuid, message: domain::ai::AIMessage) -> Result<(), domain::AIInteractionError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `domain::ai::AIInteractionInitiatedEvent { interaction_id: core::types::Uuid, initial_prompt: String }`
            - `domain::ai::AIConsentUpdatedEvent { model_id: String, new_status: domain::ai::AIConsentStatus }`
            - `domain::ai::AIInteractionStatusChangedEvent { interaction_id: core::types::Uuid, new_status: domain::ai::AIInteractionStatus, details: Option<String> }`
            - `domain::ai::NewAIMessageEvent { interaction_id: core::types::Uuid, message: domain::ai::AIMessage }`
            - `domain::ai::AIInteractionErrorEvent { interaction_id: Option<core::types::Uuid>, error_message: String, is_fatal: bool }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `domain::AIInteractionError`-Varianten (z.B. `ModelUnavailable`, `ConsentRequired`, `NetworkError`) auf Benutzerfeedback.
    - **1.2.4. `NotificationService`-API-Nutzung durch die UI (primär für das Posten von UI-generierten Benachrichtigungen):**
        
        - **Zweck:** Ermöglicht der UI, anwendungsspezifische Benachrichtigungen zu erstellen und anzuzeigen, sowie bestehende Benachrichtigungen zu verwalten.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `post_notification`: `domain::notifications::NotificationData { app_name: String, app_icon: Option<String>, summary: String, body: Option<String>, actions: Vec<domain::notifications::NotificationAction>, urgency: domain::notifications::NotificationUrgency, timeout_ms: Option<u32>, category: Option<String>, transient: bool }`
            - Struct `domain::notifications::NotificationAction { id: String, display_text: String }`
            - Enum `domain::notifications::NotificationUrgency { Low, Normal, Critical }`
            - Ausgabe von `post_notification`: `notification_id: core::types::Uuid`
            - Ausgabe von `get_notification`, `list_notifications`: `domain::notifications::Notification { id: core::types::Uuid, data: domain::notifications::NotificationData, timestamp: core::types::DateTime<Utc>, is_read: bool, is_dismissed: bool }`
        - **Von der UI aufgerufene API-Methoden (aus `domain::NotificationService`-Trait):**
            - `fn post_notification(&self, notification_data: domain::notifications::NotificationData) -> Result<core::types::Uuid, domain::NotificationError>;`
            - `fn get_notification(&self, id: core::types::Uuid) -> Result<Option<domain::notifications::Notification>, domain::NotificationError>;`
            - `fn list_notifications(&self, filter: Option<domain::notifications::NotificationFilter>) -> Result<Vec<domain::notifications::Notification>, domain::NotificationError>;` // Filter könnte `unread_only`, `app_name` etc. sein
            - `fn mark_as_read(&self, id: core::types::Uuid) -> Result<(), domain::NotificationError>;`
            - `fn dismiss_notification(&self, id: core::types::Uuid) -> Result<(), domain::NotificationError>;`
            - `fn invoke_action_on_notification(&self, notification_id: core::types::Uuid, action_id: String) -> Result<(), domain::NotificationError>;`
            - `fn set_do_not_disturb(&self, enabled: bool) -> Result<(), domain::NotificationError>;`
            - `fn get_do_not_disturb_status(&self) -> Result<bool, domain::NotificationError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `domain::notifications::NotificationPostedEvent { notification: domain::notifications::Notification }`
            - `domain::notifications::NotificationDismissedEvent { notification_id: core::types::Uuid, reason: domain::notifications::DismissReason }`
            - `domain::notifications::NotificationActionInvokedEvent { notification_id: core::types::Uuid, action_id: String }`
            - `domain::notifications::DoNotDisturbChangedEvent { is_enabled: bool }`
            - Enum `domain::notifications::DismissReason { User, Timeout, Programmatic }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `domain::NotificationError`-Varianten (z.B. `NotificationNotFound`, `ActionNotFound`) auf Benutzerfeedback.
    - **1.2.5. `GlobalSettingsService`-API-Nutzung durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, globale Anwendungseinstellungen zu lesen, zu ändern und auf Standardwerte zurückzusetzen.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `update_setting`: `key: String`, `value: glib::Variant`
            - Ausgabe von `get_setting`: `Result<Option<glib::Variant>, domain::GlobalSettingsError>`
            - Ausgabe von `get_current_settings`: `Result<HashMap<String, glib::Variant>, domain::GlobalSettingsError>`
            - Struct `domain::settings::SettingDescriptor { key: String, display_name: String, description: Option<String>, value_type: glib::VariantType, current_value: glib::Variant, default_value: glib::Variant, possible_values: Option<Vec<glib::Variant>>, range: Option<(glib::Variant, glib::Variant)>, category: String }`
        - **Von der UI aufgerufene API-Methoden (aus `domain::GlobalSettingsService`-Trait):**
            - `fn load_settings(&self) -> Result<(), domain::GlobalSettingsError>;`
            - `fn save_settings(&self) -> Result<(), domain::GlobalSettingsError>;`
            - `fn get_current_settings(&self) -> Result<HashMap<String, glib::Variant>, domain::GlobalSettingsError>;`
            - `fn get_setting_descriptors(&self) -> Result<Vec<domain::settings::SettingDescriptor>, domain::GlobalSettingsError>;`
            - `fn update_setting(&self, key: String, value: glib::Variant) -> Result<(), domain::GlobalSettingsError>;`
            - `fn get_setting(&self, key: String) -> Result<Option<glib::Variant>, domain::GlobalSettingsError>;`
            - `fn reset_setting_to_default(&self, key: String) -> Result<(), domain::GlobalSettingsError>;`
            - `fn reset_all_settings_to_defaults(&self) -> Result<(), domain::GlobalSettingsError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `domain::settings::SettingChangedEvent { key: String, new_value: glib::Variant, old_value: glib::Variant }`
            - `domain::settings::SettingsLoadedEvent { settings: HashMap<String, glib::Variant> }`
            - `domain::settings::SettingsSavedEvent {}`
        - **Fehlerbehandlung durch die UI:** Abbildung von `domain::GlobalSettingsError`-Varianten (z.B. `SettingNotFound`, `InvalidValueType`, `PersistenceError`) auf Benutzerfeedback. Die Verwendung von `glib::Variant` für Einstellwerte 12 ermöglicht eine flexible Handhabung verschiedener Datentypen für Einstellungen.
    - **Schlüsseltabellen für Teil 1.2:**
        
        Für jede Methode der Domänendienst-API:
        
        1. **Methodensignatur-Tabelle:**

|   |   |   |   |
|---|---|---|---|
|**Methode**|**Parameter**|**Rückgabetyp**|**Kurzbeschreibung**|
|`ThemingEngine::get_current_theme_state`|`&self`|`Result<domain::theming::AppliedThemeState, domain::ThemingError>`|Ruft den aktuell angewendeten Theme-Zustand ab.|
|`WorkspaceManager::create_workspace`|`&self, params: domain::workspaces::CreateWorkspaceParams`|`Result<core::types::WorkspaceId, domain::WorkspaceManagerError>`|Erstellt einen neuen Arbeitsbereich.|
|...|...|...|...|

```
    2.  **Parameterdetail-Tabelle (Beispiel für `ThemingEngine::update_configuration`):**
```

|   |   |   |   |
|---|---|---|---|
|**Parametername**|**Typ**|**Erforderlich**|**Beschreibung**|
|`config_update`|`domain::theming::ThemeConfigurationUpdate`|Ja|Ein Objekt, das die gewünschten Änderungen an der Theme-Konfiguration enthält.|

```
    3.  **Rückgabewertdetail-Tabelle (Beispiel für `ThemingEngine::get_current_theme_state`):**
```

|   |   |   |
|---|---|---|
|**Erfolgsfall (Ok)**|**Fehlerfall (Err)**|**Beschreibung**|
|`domain::theming::AppliedThemeState`|`domain::ThemingError`|Enthält Details zum aktuell angewendeten Theme oder einen Fehler bei der Abfrage.|

```
    Für jedes von der UI konsumierte Domänenereignis:
    4.  **Ereignis-Payload-Detail-Tabelle (Beispiel für `ThemeChangedEvent`):**
```

|   |   |   |
|---|---|---|
|**Feldname**|**Typ**|**Beschreibung**|
|`new_state`|`domain::theming::AppliedThemeState`|Der neue Zustand des Themes nach der Änderung.|

```
    Diese Tabellen sind unerlässlich, um Entwicklern eine eindeutige und leicht zugängliche Referenz zu bieten. Sie erzwingen Konsistenz bei der Typverwendung und Methodenaufrufen und reduzieren so Integrationsfehler zwischen der UI- und der Domänenschicht erheblich. Beispielsweise beschreibt eine detaillierte Tabelle für `WorkspaceDescriptor` klar alle Informationen, die die UI über einen Arbeitsbereich erwarten kann, was die Entwicklung von UI-Komponenten wie Arbeitsbereichswechslern erleichtert.
```

- 1.3. Schnittstelle der UI-Schicht mit der Systemschicht
    
    Dieser Abschnitt definiert ultra-granular die Interaktionen der UI-Schicht mit Diensten, die von der Systemschicht bereitgestellt werden. Die Systemschicht abstrahiert Details des zugrundeliegenden Betriebssystems, der Hardware und des Fenstersystems (Wayland/X11).
    
    - **1.3.1. Compositor-Interaktion (`system::compositor_iface`) durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, Fensterinformationen abzufragen, Fensterzustände (Fokus, Geometrie) zu verwalten und Aktualisierungen über den Lebenszyklus und die Eigenschaften von Fenstern zu erhalten. Diese Schnittstelle abstrahiert die zugrundeliegenden Wayland-Compositor-Interaktionen. Die UI interagiert nicht direkt mit Wayland-Protokollen wie `wlr-foreign-toplevel-management` 17 oder `ext-foreign-toplevel-list-v1` 17; stattdessen konsumiert sie die von der Systemschicht bereitgestellten Abstraktionen.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `request_focus`: `window_id: core::types::WindowId`
            - Eingabe für `configure_window`: `window_id: core::types::WindowId`, `config: system::compositor::WindowConfigurationRequest { new_position: Option<core::types::PointInt>, new_size: Option<core::types::SizeInt>, new_state: Option<system::compositor::CompositorWindowState>, new_workspace_id: Option<core::types::WorkspaceId> }`
            - Enum `system::compositor::CompositorWindowState { Maximized, Minimized, Fullscreen, Normal, TiledLeft, TiledRight }`
            - Ausgabe von `get_window_info`, `list_managed_windows`: `system::compositor::WindowInfo { id: core::types::WindowId, title: String, app_id: core::types::AppId, class: Option<String>, geometry: core::types::RectInt, is_focused: bool, is_maximized: bool, is_minimized: bool, is_fullscreen: bool, workspace_id: Option<core::types::WorkspaceId>, can_resize: bool, can_maximize: bool, can_minimize: bool, can_close: bool, parent_window_id: Option<core::types::WindowId>, transient_for: Option<core::types::WindowId> }`
            - Ausgabe von `get_output_info`, `list_outputs`: `system::compositor::OutputInfo { id: String, name: String, description: String, geometry: core::types::RectInt, scale_factor: f32, refresh_rate_mhz: u32, current_resolution: core::types::SizeInt, available_resolutions: Vec<core::types::SizeInt>, is_primary: bool, is_enabled: bool }`
        - **Von der UI aufgerufene API-Methoden (aus `system::CompositorInterface`-Trait):**
            - `fn request_focus(&self, window_id: core::types::WindowId) -> Result<(), system::CompositorError>;`
            - `fn configure_window(&self, window_id: core::types::WindowId, config: system::compositor::WindowConfigurationRequest) -> Result<(), system::CompositorError>;`
            - `fn get_window_info(&self, window_id: core::types::WindowId) -> Result<Option<system::compositor::WindowInfo>, system::CompositorError>;`
            - `fn list_managed_windows(&self) -> Result<Vec<system::compositor::WindowInfo>, system::CompositorError>;`
            - `fn close_window(&self, window_id: core::types::WindowId) -> Result<(), system::CompositorError>;`
            - `fn list_outputs(&self) -> Result<Vec<system::compositor::OutputInfo>, system::CompositorError>;`
            - `fn get_output_info(&self, output_id: String) -> Result<Option<system::compositor::OutputInfo>, system::CompositorError>;`
            - `fn get_cursor_position(&self) -> Result<core::types::PointInt, system::CompositorError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `system::compositor::WindowCreatedEvent { info: system::compositor::WindowInfo }`
            - `system::compositor::WindowClosedEvent { window_id: core::types::WindowId }`
            - `system::compositor::WindowFocusedEvent { window_id: core::types::WindowId }`
            - `system::compositor::WindowUnfocusedEvent { window_id: core::types::WindowId }`
            - `system::compositor::WindowPropertiesChangedEvent { window_id: core::types::WindowId, changed_title: Option<String>, changed_app_id: Option<core::types::AppId>, changed_geometry: Option<core::types::RectInt>, changed_state: Option<system::compositor::CompositorWindowState> }`
            - `system::compositor::OutputAddedEvent { info: system::compositor::OutputInfo }`
            - `system::compositor::OutputRemovedEvent { output_id: String }`
            - `system::compositor::OutputConfigurationChangedEvent { info: system::compositor::OutputInfo }`
            - `system::compositor::CursorPositionChangedEvent { position: core::types::PointInt }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::CompositorError`-Varianten (z.B. `WindowNotFound`, `WaylandProtocolError`, `InvalidConfiguration`) auf Benutzerfeedback.
    - **1.3.2. Eingabeverarbeitung (`system::input_iface`) durch die UI:**
        
        - **Zweck:** Liefert der UI verarbeitete Eingabeereignisse (Tastatur, Maus, Touch, Gesten) und ermöglicht es der UI, den Fokus zu steuern.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `request_keyboard_focus`: `window_id: core::types::WindowId` (kann auch über `compositor_iface` laufen, hier zur Verdeutlichung der Input-Intention)
            - Event-Payloads für `KeyboardEvent`, `PointerEvent`, `TouchEvent`, `GestureEvent` (detaillierte Definitionen erforderlich, z.B. `KeyEvent { key_code: u32, modifiers: KeyModifiers, state: KeyState, utf8: Option<String> }`).
        - **Von der UI aufgerufene API-Methoden (aus `system::InputInterface`-Trait):**
            - `fn request_keyboard_focus(&self, window_id: core::types::WindowId) -> Result<(), system::InputError>;` (kann Duplikat zu Compositor-API sein, aber semantisch hier relevant)
            - `fn set_cursor_theme(&self, theme_name: String, size: u32) -> Result<(), system::InputError>;`
            - `fn get_current_keyboard_layout(&self) -> Result<String, system::InputError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `system::input::KeyboardEvent { window_id: Option<core::types::WindowId>, /*... event details... */ }`
            - `system::input::PointerButtonEvent { window_id: Option<core::types::WindowId>, /*... event details... */ }`
            - `system::input::PointerMotionEvent { window_id: Option<core::types::WindowId>, /*... event details... */ }`
            - `system::input::PointerAxisEvent { window_id: Option<core::types::WindowId>, /*... event details... */ }`
            - `system::input::TouchEvent { window_id: Option<core::types::WindowId>, /*... event details... */ }`
            - `system::input::GestureEvent { window_id: Option<core::types::WindowId>, gesture_type: system::input::GestureType, /*... event details... */ }`
            - `system::input::FocusChangedEvent { new_focus_window_id: Option<core::types::WindowId>, old_focus_window_id: Option<core::types::WindowId> }` (kann auch vom Compositor kommen)
            - `system::input::KeyboardLayoutChangedEvent { new_layout_name: String }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::InputError`-Varianten.
    - **1.3.3. D-Bus Client-Schnittstellen (`system::dbus::*`) Nutzung durch die UI:**
        
        - **Allgemein:** Die UI interagiert mit D-Bus-Diensten über typsichere Rust-Wrapper, die von der Systemschicht bereitgestellt werden. Die UI konsumiert Ereignisse und ruft Methoden dieser Wrapper auf. Die Komplexität der D-Bus-Kommunikation (z.B. mit `zbus` 19 oder `gio::DBusConnection` 22) wird von der Systemschicht gekapselt.
        - **`system::dbus::upower_client_iface`:**
            - Events: `system::dbus::UPowerDeviceChangedEvent { device_id: String, percentage: f64, state: UPowerDeviceState, time_to_empty_s: Option<u64>, time_to_full_s: Option<u64> }`
        - **`system::dbus::logind_client_iface`:**
            - Methoden: `fn lock_session(&self) -> Result<(), system::DBusError>;`
            - Events: `system::dbus::LogindSessionEvent { event_type: LogindEventType /* Lock, Unlock, Sleep, Wakeup */ }`
        - **`system::dbus::networkmanager_client_iface`:**
            - Methoden: `fn list_access_points(&self, device_path: String) -> Result<Vec<system::dbus::AccessPointInfo>, system::DBusError>;`, `fn connect_to_access_point(&self, device_path: String, ap_bssid: String, password: Option<String>) -> Result<(), system::DBusError>;`
            - Datenstrukturen: `AccessPointInfo { bssid: String, ssid: String, strength: u8, security_flags: u32, is_active: bool }` (basierend auf NetworkManager D-Bus API 23)
            - Events: `system::dbus::NetworkStateChangedEvent { connectivity: NetworkConnectivityState, primary_connection_type: Option<String> }`, `system::dbus::AccessPointsChangedEvent { device_path: String }`
        - **`system::dbus::secrets_client_iface`:**
            - Methoden: `async fn prompt_for_secret(&self, prompt_message: String) -> Result<Option<String>, system::DBusError>;` (interagiert mit UI für Prompts)
    - **1.3.4. Output-Management (`system::outputs_iface`) durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, Informationen über angeschlossene Displays abzurufen und deren Konfiguration (Auflösung, Skalierung, Position) zu ändern.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `configure_output`: `output_id: String`, `config: system::outputs::OutputConfigurationRequest { resolution: Option<core::types::SizeInt>, scale: Option<f32>, position: Option<core::types::PointInt>, enabled: Option<bool>, refresh_rate_mhz: Option<u32> }`
            - Ausgabe von `list_outputs`, `get_output_details`: `system::outputs::OutputDetails` (ähnlich `system::compositor::OutputInfo`, aber ggf. mit mehr Konfigurationsdetails wie verfügbare Modi, aktuelle Skalierung, etc.)
        - **Von der UI aufgerufene API-Methoden (aus `system::OutputInterface`-Trait):**
            - `fn list_outputs(&self) -> Result<Vec<system::outputs::OutputDetails>, system::OutputError>;`
            - `fn get_output_details(&self, output_id: String) -> Result<Option<system::outputs::OutputDetails>, system::OutputError>;`
            - `fn configure_output(&self, output_id: String, config: system::outputs::OutputConfigurationRequest) -> Result<(), system::OutputError>;`
            - `fn set_primary_output(&self, output_id: String) -> Result<(), system::OutputError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `system::outputs::OutputConfigurationChangedEvent { output_id: String, new_details: system::outputs::OutputDetails }` (kann auch vom Compositor kommen, hier ggf. spezifischer für Output-Management-Aktionen)
            - `system::outputs::OutputConnectedEvent { details: system::outputs::OutputDetails }`
            - `system::outputs::OutputDisconnectedEvent { output_id: String }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::OutputError`-Varianten.
    - **1.3.5. Audio-Management (`system::audio_iface`) durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, Audio-Geräte und -Streams zu verwalten, Lautstärken zu regeln und Audio-Ereignisse zu empfangen. Abstrahiert PipeWire-Interaktionen.26
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `set_volume`: `device_id: String`, `stream_id: Option<String>`, `volume_percent: f32`, `is_muted: Option<bool>`
            - Ausgabe von `list_audio_devices`, `get_audio_device_details`: `system::audio::AudioDeviceDetails { id: String, name: String, device_type: AudioDeviceType /* Input, Output */, current_volume_percent: f32, is_muted: bool, available_ports: Vec<String>, active_port: Option<String> }`
            - Ausgabe von `list_audio_streams`: `system::audio::AudioStreamDetails { id: String, application_name: String, media_role: String, current_volume_percent: f32, is_muted: bool }`
        - **Von der UI aufgerufene API-Methoden (aus `system::AudioInterface`-Trait):**
            - `fn list_audio_devices(&self, device_type_filter: Option<system::audio::AudioDeviceType>) -> Result<Vec<system::audio::AudioDeviceDetails>, system::AudioError>;`
            - `fn get_audio_device_details(&self, device_id: String) -> Result<Option<system::audio::AudioDeviceDetails>, system::AudioError>;`
            - `fn set_device_volume(&self, device_id: String, volume_percent: f32) -> Result<(), system::AudioError>;`
            - `fn set_device_mute(&self, device_id: String, muted: bool) -> Result<(), system::AudioError>;`
            - `fn set_default_output_device(&self, device_id: String) -> Result<(), system::AudioError>;`
            - `fn set_default_input_device(&self, device_id: String) -> Result<(), system::AudioError>;`
            - `fn list_audio_streams(&self) -> Result<Vec<system::audio::AudioStreamDetails>, system::AudioError>;`
            - `fn set_stream_volume(&self, stream_id: String, volume_percent: f32) -> Result<(), system::AudioError>;`
            - `fn set_stream_mute(&self, stream_id: String, muted: bool) -> Result<(), system::AudioError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `system::audio::AudioDeviceChangedEvent { device_details: system::audio::AudioDeviceDetails }`
            - `system::audio::AudioDeviceAddedEvent { device_details: system::audio::AudioDeviceDetails }`
            - `system::audio::AudioDeviceRemovedEvent { device_id: String }`
            - `system::audio::AudioStreamAddedEvent { stream_details: system::audio::AudioStreamDetails }`
            - `system::audio::AudioStreamRemovedEvent { stream_id: String }`
            - `system::audio::AudioStreamVolumeChangedEvent { stream_id: String, new_volume_percent: f32, is_muted: bool }`
            - `system::audio::DefaultDeviceChangedEvent { device_type: system::audio::AudioDeviceType, new_default_device_id: String }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::AudioError`-Varianten.
    - **1.3.6. MCP-Client (`system::mcp_client_iface`) Nutzung durch die UI:**
        
        - **Zweck:** Stellt der UI KI-Funktionen zur Verfügung, z.B. für die Befehlspalette oder andere intelligente UI-Elemente.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `request_ai_completion`: `prompt: String`, `context_data: HashMap<String, glib::Variant>`, `max_tokens: Option<u32>`
            - Ausgabe von `request_ai_completion`: `system::mcp::AICompletionResponse { completion_id: core::types::Uuid, text_result: Option<String>, structured_result: Option<glib::Variant>, error_message: Option<String> }`
        - **Von der UI aufgerufene API-Methoden (aus `system::MCPClientInterface`-Trait):**
            - `async fn request_ai_completion(&self, prompt: String, context_data: HashMap<String, glib::Variant>, options: system::mcp::AICompletionOptions) -> Result<system::mcp::AICompletionResponse, system::MCPError>;`
            - `async fn get_ai_capabilities(&self) -> Result<Vec<system::mcp::AICapabilityDescriptor>, system::MCPError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `system::mcp::AIModelStatusChangedEvent { model_id: String, is_available: bool }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::MCPError`-Varianten.
    - **1.3.7. XDG Desktop Portals (`system::portals_iface`) Nutzung durch die UI:**
        
        - **Zweck:** Ermöglicht der UI die Interaktion mit XDG Desktop Portals für Aktionen wie Dateiauswahl, Screenshots, etc., auf eine sandkastenfreundliche Weise. Die Systemschicht abstrahiert die direkte D-Bus-Kommunikation mit den Portal-Diensten. Die `ashpd`-Bibliothek 28 ist ein gutes Beispiel für eine solche Abstraktionsebene, die die Systemschicht intern nutzen könnte.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `open_file_dialog`: `parent_window_identifier: system::portals::WindowIdentifier`, `title: String`, `options: system::portals::OpenFileOptions { multiple: bool, directory: bool, filters: Vec<system::portals::FileFilter> }`
            - Struct `system::portals::FileFilter { name: String, patterns: Vec<String> /* z.B. "*.txt" */ }`
            - Ausgabe von `open_file_dialog`: `Vec<PathBuf>` (URIs werden von der Systemschicht in Pfade konvertiert)
            - Eingabe für `save_file_dialog`: `parent_window_identifier: system::portals::WindowIdentifier`, `title: String`, `options: system::portals::SaveFileOptions { current_name: Option<String>, current_folder: Option<PathBuf>, filters: Vec<system::portals::FileFilter> }`
            - Ausgabe von `save_file_dialog`: `Option<PathBuf>`
            - Typ `system::portals::WindowIdentifier`: Ein plattformagnostischer Handle für ein Fenster, der intern zu Wayland- oder X11-spezifischen Handles aufgelöst wird, wie von `ashpd` benötigt.
        - **Von der UI aufgerufene API-Methoden (aus `system::PortalsInterface`-Trait):**
            - `async fn open_file_dialog(&self, parent_window_identifier: system::portals::WindowIdentifier, title: String, options: system::portals::OpenFileOptions) -> Result<Vec<PathBuf>, system::PortalError>;`
            - `async fn save_file_dialog(&self, parent_window_identifier: system::portals::WindowIdentifier, title: String, options: system::portals::SaveFileOptions) -> Result<Option<PathBuf>, system::PortalError>;`
            - `async fn take_screenshot(&self, parent_window_identifier: system::portals::WindowIdentifier, interactive: bool, include_cursor: bool) -> Result<Option<PathBuf>, system::PortalError>;`
            - `async fn pick_color(&self, parent_window_identifier: system::portals::WindowIdentifier) -> Result<Option<core::types::Color>, system::PortalError>;`
        - **Von der UI konsumierte Event-Payloads:** (Portals sind typischerweise Request-Response, weniger eventbasiert für die UI direkt, außer Status-Events des Portal-Dienstes selbst, die hier aber nicht im Fokus stehen).
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::PortalError`-Varianten (z.B. `UserCancelled`, `PortalNotAvailable`, `BackendError`).
    - **Schlüsseltabellen für Teil 1.3:** Ähnlich wie in Teil 1.2 werden Tabellen für Methodensignaturen, Parameterdetails, Rückgabewertdetails und Ereignis-Payload-Details für jede definierte Systemschicht-Schnittstelle erstellt.
        
        - Die Interaktionen der Systemschicht sind oft komplex und beinhalten viele Low-Level-Details (z.B. D-Bus-Varianten, Wayland-Protokollspezifika). Tabellen machen die abstrahierte Rust-API klar und reduzieren die Mehrdeutigkeit für UI-Entwickler.

---

**Teil 2: Ultra-Granulare Schnittstellendefinition der Kernschicht (Erweiterung des Benutzerdokuments)**

- 2.1. Kernschicht zu allen höheren Schichten
    
    Die Kernschicht (core) stellt fundamentale Bausteine und Dienste bereit, die von allen höheren Schichten (Domäne, System, UI) genutzt werden. Ihre Schnittstellen müssen daher besonders stabil und klar definiert sein.
    
    - **`core::types`:**
        
        - **Datentypen:** Stellt eine Sammlung grundlegender, wiederverwendbarer Datentypen bereit.
            - `Point<T> { x: T, y: T }` (generisch für numerische Typen wie `f32`, `i32`)
            - `Size<T> { width: T, height: T }` (generisch)
            - `Rect<T> { origin: Point<T>, size: Size<T> }` (generisch)
            - `RectInt` ist ein Typalias für `Rect<i32>`.
            - `Color { r: u8, g: u8, b: u8, a: u8 }` (RGBA-Format)
            - `Orientation { Horizontal, Vertical }` (Enum)
            - `Uuid` (Wrapper um die `uuid::Uuid`-Bibliothek, um eine konsistente Verwendung sicherzustellen)
            - `DateTime<Utc>` (Wrapper um `chrono::DateTime<chrono::Utc>`, um Zeitzonenprobleme zu standardisieren)
            - `WindowId` (Typalias, z.B. `pub type WindowId = u64;` oder eine spezifischere Struktur, falls Metadaten benötigt werden)
            - `WorkspaceId` (Typalias, z.B. `pub type WorkspaceId = core::types::Uuid;`)
            - `AppId` (Typalias, z.B. `pub type AppId = String;`, oft im Reverse-DNS-Format wie `org.novade.FileExplorer`)
        - **Nutzung:** Diese Typen werden direkt in den öffentlichen APIs und internen Logiken der höheren Schichten für Geometrieberechnungen, Farbangaben, eindeutige Identifikatoren, Zeitstempel und spezifische Entitäts-IDs verwendet. Die Standardisierung dieser Typen in der Kernschicht verhindert Inkonsistenzen und erleichtert die Interoperabilität zwischen den Modulen.
    - **`core::errors`:**
        
        - **Basis-Fehlertyp:**
            
            Rust
            
            ```
            #
            pub enum CoreError {
                #[error("I/O error: {source}")]
                Io { #[from] source: std::io::Error },
                #[error("Configuration parsing error: {0}")]
                ConfigParseError(String),
                #[error("Invalid state: {0}")]
                InvalidState(String),
                #[error("Functionality not implemented")]
                NotImplemented,
                #[error("Custom error: {0}")]
                Custom(String),
                #
                SerializationJson { #[from] source: serde_json::Error },
                // Weitere generische Fehlerkategorien hier hinzufügen
            }
            ```
            
        - **Modul-spezifische Fehlerstrategie:** Höhere Schichten und Module innerhalb der Kernschicht definieren ihre eigenen spezifischen Fehler-Enums mit `thiserror`. Diese spezifischen Fehler sollten `CoreError` oder andere relevante Fehler wrappen, um die Fehlerkette zu erhalten.
            - Beispiel: `core::config::ConfigError` könnte eine Variante haben wie:
                
                Rust
                
                ```
                #
                pub enum ConfigError {
                    #[error("Failed to open configuration file '{path}': {source}")]
                    FileOpenFailed { path: PathBuf, #[source] source: CoreError },
                    #[error("Failed to parse configuration: {message}")]
                    ParseFailed { message: String, #[source] source: Option<serde_json::Error> },
                    //...
                }
                ```
                
        - **Fehler-Wrapping-Illustration:**
            
            Rust
            
            ```
            // In einem hypothetischen Modul
            #
            pub enum MyModuleError {
                #[error("Failed to read file for stuff: {source}")]
                FileReadFailed(#[source] CoreError),
                //...
            }
            
            fn read_file_content(path: &PathBuf) -> Result<String, CoreError> {
                std::fs::read_to_string(path).map_err(CoreError::from)
            }
            
            fn load_stuff(file_path: &PathBuf) -> Result<(), MyModuleError> {
                let _content = read_file_content(file_path).map_err(MyModuleError::FileReadFailed)?;
                //... weitere Logik...
                Ok(())
            }
            ```
            
            Diese Strategie stellt sicher, dass der ursprüngliche Kontext des Fehlers (`source()`) verfügbar bleibt, was die Fehlersuche und -behebung erheblich erleichtert.
    - **`core::logging`:**
        
        - **Initialisierungsroutine:**
            
            Rust
            
            ```
            pub enum LogOutput {
                Stdout,
                Stderr,
                File(PathBuf),
            }
            
            pub fn initialize_logging(level: tracing::Level, output: LogOutput, format: LogFormat) -> Result<(), CoreError>;
            pub enum LogFormat { Json, Pretty, Compact }
            ```
            
            Diese Funktion konfiguriert das globale Logging-System (basierend auf `tracing`).
        - **Konvention für `tracing`-Makros:**
            - Alle Schichten verwenden die Standard-`tracing`-Makros (`trace!`, `debug!`, `info!`, `warn!`, `error!`).
            - Strukturierte Log-Nachrichten werden bevorzugt, um kontextbezogene Daten effizient zu erfassen: `trace!(target: "core::module_name", "Processing item {}", item_id, item_type = %item.kind, user_id = %current_user.id);`
            - Das `target`-Feld sollte das Modul oder die Komponente angeben, aus der die Log-Nachricht stammt (z.B. `core::config`, `domain::theming`).
            - Spezifische Felder (z.B., `window.id = %window_id`, `event.name = "ThemeChanged"`) sollten verwendet werden, um das Filtern und Analysieren von Logs zu erleichtern.
    - **`core::config`:**
        
        - **`CoreConfig`-Struktur:** Definiert die globalen Kernkonfigurationen. Diese Struktur wird beim Start der Anwendung geladen und als unveränderlich betrachtet.
            
            Rust
            
            ```
            #
            pub struct LoggingConfig {
                pub level: String, // z.B. "info", "debug"
                pub output: String, // z.B. "stdout", "/var/log/novade.log"
                pub format: String, // z.B. "json", "pretty"
            }
            
            #
            pub struct ThemeConfig {
                pub default_theme_name: String,
                pub default_variant: String,
                pub icon_theme: String,
            }
            
            #
            pub struct AIServiceConfig {
                pub service_url: Option<String>,
                pub default_model_id: Option<String>,
                pub consent_required_by_default: bool,
            }
            
            #
            pub struct CoreConfig {
                pub logging: LoggingConfig,
                pub theming: ThemeConfig,
                pub ai: AIServiceConfig,
                pub default_workspace_layout: String, // z.B. "Tiling", "Floating"
                // Weitere Kernkonfigurationen
            }
            ```
            
        - **Konfigurations-API:**
            - `pub fn load_core_config(path: &PathBuf) -> Result<CoreConfig, ConfigError>;` Lädt die Konfiguration aus einer Datei (z.B. TOML oder JSON).
            - `pub fn get_core_config() -> Result<&'static CoreConfig, CoreError>;` Bietet globalen, schreibgeschützten Zugriff auf die geladene Kernkonfiguration. Dies setzt voraus, dass die Konfiguration nach der Initialisierung in einem globalen statischen Speicher (z.B. `once_cell::sync::OnceCell` oder `std::sync::OnceLock`) gehalten wird.
        - **`ConfigError`-Enum:**
            
            Rust
            
            ```
            #
            pub enum ConfigError {
                #[error("Configuration file not found at path: {0}")]
                FileNotFound(PathBuf),
                #[error("Failed to open configuration file '{path}': {source}")]
                FileOpenFailed { path: PathBuf, #[source] source: CoreError },
                #[error("Failed to read configuration file '{path}': {source}")]
                FileReadFailed { path: PathBuf, #[source] source: CoreError },
                #[error("Failed to parse configuration from '{path}': {message}")]
                ParseFailed { path: PathBuf, message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync>> }, // Box für Flexibilität bei Parser-Fehlern
                #[error("Configuration validation failed: {0}")]
                ValidationError(String),
            }
            ```
            
            (Hinweis: `Box<dyn std::error::Error + Send + Sync>` für `source` in `ParseFailed` ermöglicht das Wrappen verschiedener Parser-Fehler, z.B. `serde_json::Error`, `toml::de::Error`).
    - **`core::utils`:**
        
        - **Hilfsfunktionen:** Stellt allgemeine, zustandslose Hilfsfunktionen bereit, die von mehreren Schichten genutzt werden können. Diese sollten in thematisch gruppierten Untermodulen organisiert sein.
            - `core::utils::string_utils`: Funktionen zur String-Manipulation (z.B. `truncate_with_ellipsis(text: &str, max_len: usize) -> String;`).
            - `core::utils::geometry_utils`: Einfache geometrische Berechnungen, die nicht in `core::types` selbst implementiert sind (z.B. `fn calculate_rect_area(rect: &core::types::RectInt) -> i32;`).
            - `core::utils::time_utils`: Formatierungs- oder Vergleichsfunktionen für `DateTime<Utc>` (z.B. `fn format_datetime_human_readable(dt: &core::types::DateTime<Utc>) -> String;` unter Verwendung von `chrono::format::strftime`).
            - `core::utils::uuid_utils`: Funktionen zur Erzeugung oder Validierung von UUIDs (z.B. `fn generate_v4_uuid() -> core::types::Uuid;`).
        - **Nutzung:** Direkte Verwendung durch alle höheren Schichten nach Bedarf. Da diese Funktionen zustandslos sind, führen sie keine Seiteneffekte ein und sind einfach zu testen. Die Signaturen dieser Hilfsfunktionen sind Teil der internen API der Kernschicht und sollten bei Stabilitätserwägungen berücksichtigt werden.
    - **Schlüsseltabellen für Teil 2.1:**
        
        1. **`core::types` Detail-Tabelle:**

|   |   |   |   |
|---|---|---|---|
|**Typname**|**Struktur / Enum-Definition**|**Generische Parameter**|**Beschreibung**|
|`Point<T>`|`struct Point<T> { x: T, y: T }`|`T: Copy + Num`|Repräsentiert einen Punkt im 2D-Raum.|
|`Color`|`struct Color { r: u8, g: u8, b: u8, a: u8 }`|-|Repräsentiert eine RGBA-Farbe.|
|`Uuid`|`struct Uuid(uuid::Uuid);`|-|Wrapper für einen universell eindeutigen Identifikator.|
|`DateTime<Utc>`|`struct DateTime<Utc>(chrono::DateTime<chrono::Utc>);`|-|Repräsentiert einen Zeitpunkt in UTC.|
|...|...|...|...|

```
    2.  **`CoreError` Varianten-Tabelle:**
```

|   |   |   |
|---|---|---|
|**Variante**|**Assoziierte Daten (#[from], #[source], Felder)**|**#[error("...")] Format-String**|
|`Io`|`#[from] source: std::io::Error`|`"I/O error: {source}"`|
|`ConfigParseError`|`String` (Meldung)|`"Configuration parsing error: {0}"`|
|`SerializationJson`|`#[from] source: serde_json::Error`|`"Serialization error (serde_json): {source}"`|
|...|...|...|

```
    3.  **`CoreConfig` Felder-Tabelle:**
```

|   |   |   |   |
|---|---|---|---|
|**Feldname**|**Typ**|**Beschreibung**|**Standardwert (falls zutreffend)**|
|`logging`|`LoggingConfig`|Konfiguration für das Logging-System.|Siehe `LoggingConfig`|
|`theming`|`ThemeConfig`|Standard-Theme-Einstellungen.|Siehe `ThemeConfig`|
|`default_workspace_layout`|`String`|Standard-Layout für neue Arbeitsbereiche (z.B. "Tiling").|`"Floating"`|
|...|...|...|...|

```
    Diese Tabellen bieten eine klare, strukturierte Übersicht über die von der Kernschicht bereitgestellten fundamentalen Elemente und sind für Entwickler aller höheren Schichten von entscheidender Bedeutung.
```

---

**Teil 3: Ultra-Granulare Schnittstellendefinition der Domänenschicht (Erweiterung des Benutzerdokuments)**

Die Domänenschicht enthält die Kernlogik und den Zustand der Anwendung. Ihre Schnittstellen definieren, wie höhere Schichten (System und UI) diese Logik nutzen und auf Zustandsänderungen reagieren können.

- **3.1. Domänenschicht zu System- & UI-Schichten (Allgemeine Prinzipien)**
    
    - **Logik und Zustand:** Jede Domänen-Service-Komponente kapselt einen spezifischen Aspekt der Geschäftslogik und des zugehörigen Zustands. Diese werden über öffentliche Methoden der Service-Traits und durch das Aussenden von domänenspezifischen Ereignissen bereitgestellt.
        - Für jeden Domänendienst wird explizit der von ihm verwaltete Zustand (z.B. für `ThemingEngine`: aktuelles Theme, verfügbare Themes, benutzerdefinierte Farbpaletten) und die wichtigsten Geschäftsregeln, die er durchsetzt (z.B. für `WorkspaceManager`: keine zwei Arbeitsbereiche mit demselben Namen, ein Fenster kann nur einem Arbeitsbereich zugewiesen sein), dokumentiert.
    - **Fehlertypen:** Jedes Modul innerhalb der Domänenschicht definiert seine eigenen, auf `thiserror` basierenden Fehler-Enums. Diese Fehler sind spezifisch für die jeweilige Domänenlogik und bieten detaillierte Informationen über aufgetretene Probleme.
        - Beispiel für `ThemingError`:
            
            Rust
            
            ```
            #
            pub enum ThemingError {
                #
                ThemeNotFound { name: String, path: Option<PathBuf> },
                #
                VariantNotFound { theme_name: String, variant_name: String },
                #[error("Failed to load theme assets for '{theme_name}': {source}")]
                AssetLoadError { theme_name: String, #[source] source: core::errors::CoreError },
                #[error("Invalid theme configuration: {message}")]
                InvalidConfiguration { message: String },
                #
                TokenNotFound { theme_name: String, token_name: String },
                #[error("Failed to parse color value '{value}' for token '{token_name}'")]
                ColorParseError { token_name: String, value: String },
            }
            ```
            
            (Diese detaillierte Definition wird für alle im Benutzerdokument genannten Fehler wie `WorkspaceCoreError`, `WindowAssignmentError`, etc. wiederholt.)
    - **Events:** Domänenspezifische Ereignisse werden ausgelöst, um andere Schichten über signifikante Zustandsänderungen oder abgeschlossene Aktionen zu informieren. Die Payload jedes Ereignisses ist so gestaltet, dass sie alle relevanten Informationen enthält, die ein Konsument benötigt, um ohne weitere Abfragen reagieren zu können.
        - Beispiel für `ThemeChangedEvent`:
            
            Rust
            
            ```
            # // Serialize/Deserialize falls Events über IPC gehen könnten
            pub struct PaletteDetails {
                pub primary_accent: core::types::Color,
                pub secondary_accent: core::types::Color,
                pub foreground: core::types::Color,
                pub background: core::types::Color,
                //... weitere relevante Farbdefinitionen
            }
            
            #
            pub struct ThemeChangedEvent {
                pub new_theme_name: String,
                pub new_variant_name: String,
                pub applied_palette: PaletteDetails, // Statt nur IDs, die volle Information
                pub font_details: FontDescription, // Annahme einer Struktur für Font-Details
            }
            
            #
            pub struct FontDescription {
                pub family: String,
                pub size_pt: f32,
                pub style: String, // z.B. "Regular", "Bold"
            }
            ```
            
            (Diese detaillierte Definition wird für alle im Benutzerdokument genannten Ereignisse wie `WorkspaceEvent`, `AIInteractionInitiatedEvent`, etc. wiederholt.)
- **3.2. Spezifische Domänen-Service-Schnittstellen (Ultra-Granular):**
    
    - **`ThemingEngine` API:**
        
        - **Trait Definition:**
            
            Rust
            
            ```
            pub trait ThemingEngine: Send + Sync {
                /// Ruft den aktuell angewendeten und aufgelösten Theme-Zustand ab.
                fn get_current_theme_state(&self) -> Result<AppliedThemeState, ThemingError>;
            
                /// Listet alle verfügbaren Themes und deren Varianten auf.
                fn get_available_themes(&self) -> Result<Vec<ThemeIdentifier>, ThemingError>;
            
                /// Ruft die aktuelle, persistierte Theme-Konfiguration ab (z.B. ausgewählter Theme-Name, Variante, Overrides).
                fn get_current_configuration(&self) -> Result<ThemeConfiguration, ThemingError>;
            
                /// Aktualisiert die Theme-Konfiguration. Änderungen werden persistiert und lösen ggf. ein `ThemeChangedEvent` aus.
                fn update_configuration(&self, config_update: ThemeConfigurationUpdate) -> Result<(), ThemingError>;
            
                /// Lädt alle Theme-Definitionen und Farb-Token neu vom Dateisystem oder der konfigurierten Quelle.
                fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>;
            
                /// Abonniert Änderungen am Theme-Zustand.
                /// Gibt einen Receiver-Endpunkt eines Broadcast-Kanals zurück, über den `ThemeChangedEvent`s empfangen werden können.
                /// Alternativ könnte dies über einen zentralen EventBus erfolgen.
                fn subscribe_to_theme_changes(&self) -> Result<tokio::sync::broadcast::Receiver<ThemeChangedEvent>, ThemingError>;
            }
            ```
            
        - **Datenstrukturen:**
            - `AppliedThemeState { name: String, variant: String, primary_color: core::types::Color, text_color: core::types::Color, background_color: core::types::Color, accent_colors: HashMap<String, core::types::Color>, font_family: String, font_size_pt: f32, raw_tokens: HashMap<String, String> /* Für Debugging oder fortgeschrittene Nutzung */ }`
            - `ThemeIdentifier { id: String, name: String, display_name: String, description: Option<String>, author: Option<String>, variants: Vec<ThemeVariantIdentifier> }`
            - `ThemeVariantIdentifier { id: String, name: String, display_name: String, preview_image_path: Option<PathBuf> }`
            - `ThemeConfiguration { current_theme_id: String, current_variant_id: String, custom_palette_overrides: HashMap<String, core::types::Color>, font_scale_factor: Option<f32> }`
            - `ThemeConfigurationUpdate { theme_id: Option<String>, variant_id: Option<String>, set_custom_palette_overrides: Option<HashMap<String, core::types::Color>>, remove_custom_palette_overrides: Option<Vec<String>>, font_scale_factor: Option<f32> }`
        - **Events:**
            - `ThemeChangedEvent { new_state: AppliedThemeState }` (wie oben definiert, Payload enthält alle relevanten Infos)
        - **Fehler:** `ThemingError` (Varianten wie oben detailliert definiert: `ThemeNotFound`, `VariantNotFound`, `AssetLoadError`, `InvalidConfiguration`, `TokenNotFound`, `ColorParseError`).
    - **`WorkspaceManager` API:**
        
        - **Trait Definition:**
            
            Rust
            
            ```
            pub trait WorkspaceManager: Send + Sync {
                fn create_workspace(&self, params: CreateWorkspaceParams) -> Result<WorkspaceDescriptor, WorkspaceManagerError>;
                fn delete_workspace(&self, workspace_id: core::types::WorkspaceId) -> Result<(), WorkspaceManagerError>;
                fn set_active_workspace(&self, workspace_id: core::types::WorkspaceId) -> Result<(), WorkspaceManagerError>;
                fn get_active_workspace(&self) -> Result<Option<WorkspaceDescriptor>, WorkspaceManagerError>;
                fn get_workspace_by_id(&self, workspace_id: core::types::WorkspaceId) -> Result<Option<WorkspaceDescriptor>, WorkspaceManagerError>;
                fn list_workspaces(&self) -> Result<Vec<WorkspaceDescriptor>, WorkspaceManagerError>;
                fn assign_window_to_workspace(&self, window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId) -> Result<(), WorkspaceManagerError>;
                fn assign_window_to_active_workspace(&self, window_id: core::types::WindowId) -> Result<(), WorkspaceManagerError>;
                fn remove_window_from_workspace(&self, window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId) -> Result<(), WorkspaceManagerError>;
                fn get_window_assignment(&self, window_id: core::types::WindowId) -> Result<Option<core::types::WorkspaceId>, WorkspaceManagerError>;
                fn save_configuration(&self) -> Result<(), WorkspaceManagerError>; // Persistiert die aktuelle Arbeitsbereichsanordnung und -konfiguration
                fn load_configuration(&self) -> Result<(), WorkspaceManagerError>; // Lädt die Konfiguration beim Start
                fn rename_workspace(&self, workspace_id: core::types::WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>;
                fn set_workspace_layout(&self, workspace_id: core::types::WorkspaceId, layout: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>;
                fn reorder_workspaces(&self, ordered_workspace_ids: Vec<core::types::WorkspaceId>) -> Result<(), WorkspaceManagerError>;
                fn subscribe_to_workspace_events(&self) -> Result<tokio::sync::broadcast::Receiver<WorkspaceEvent>, WorkspaceManagerError>;
            }
            ```
            
        - **Datenstrukturen:**
            - `CreateWorkspaceParams { name: Option<String>, layout_hint: Option<WorkspaceLayoutType>, icon_name: Option<String>, activate_when_created: bool }`
            - `WorkspaceDescriptor { id: core::types::WorkspaceId, name: String, display_name: String, icon_name: Option<String>, layout: WorkspaceLayoutType, window_ids: Vec<core::types::WindowId>, is_active: bool, creation_timestamp: core::types::DateTime<Utc>, last_accessed_timestamp: core::types::DateTime<Utc> }`
            - `WorkspaceLayoutType { TilingHorizontal, TilingVertical, Floating, MaximizedSingleWindow }`
        - **Events (als Enum `WorkspaceEvent` zusammengefasst für einfacheres Abonnement):**
            
            Rust
            
            ```
            #
            pub enum WorkspaceEvent {
                WorkspaceCreated { descriptor: WorkspaceDescriptor },
                WorkspaceDeleted { workspace_id: core::types::WorkspaceId, previous_name: String },
                ActiveWorkspaceChanged { old_workspace_id: Option<core::types::WorkspaceId>, new_workspace_id: core::types::WorkspaceId, new_descriptor: WorkspaceDescriptor },
                WorkspaceLayoutChanged { workspace_id: core::types::WorkspaceId, new_layout: WorkspaceLayoutType },
                WindowAssignedToWorkspace { window_id: core::types::WindowId, new_workspace_id: core::types::WorkspaceId, old_workspace_id: Option<core::types::WorkspaceId> },
                WindowRemovedFromWorkspace { window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId },
                WorkspaceRenamed { workspace_id: core::types::WorkspaceId, new_name: String, old_name: String },
                WorkspaceOrderChanged { ordered_workspace_ids: Vec<core::types::WorkspaceId> },
                WorkspaceConfigurationSaved,
                WorkspaceConfigurationLoaded,
            }
            ```
            
        - **Fehler:** `WorkspaceManagerError`, `WorkspaceConfigError`, `WindowAssignmentError` (jeweils mit detaillierten Varianten wie `WorkspaceNotFound`, `NameAlreadyExists`, `WindowNotKnownToCompositor`, `ConfigSaveFailed`, `ConfigLoadFailed`).
    - **(Diese Detailtiefe wird für `AIInteractionLogicService`, `NotificationService` und `GlobalSettingsService` wiederholt, basierend auf den im Benutzerdokument und in Teil 1.2 dieses Dokuments skizzierten Schnittstellen. Für `GlobalSettingsService` ist die Verwendung von `glib::Variant` für Einstellwerte hervorzuheben, um Flexibilität bei den Datentypen zu gewährleisten.12)**
        
    - Schlüsseltabellen für Teil 3.2:
        
        Ähnlich wie in Teil 1.2 und Teil 2.1 werden für jeden Domänendienst detaillierte Tabellen für Methodensignaturen, Parameter, Rückgabewerte und Ereignis-Payloads erstellt.
        
        - **Beispiel: `AIInteractionLogicService` Methodenübersicht**

|   |   |   |   |
|---|---|---|---|
|**Methode**|**Parameter**|**Rückgabetyp (async Result<_, _>)**|**Kurzbeschreibung**|
|`initiate_interaction`|`&self, request: domain::ai::InteractionRequest`|`Result<domain::ai::InteractionResponseHandle, domain::AIInteractionError>`|Startet eine neue KI-Interaktion.|
|`get_interaction_context`|`&self, interaction_id: core::types::Uuid`|`Result<domain::ai::InteractionContext, domain::AIInteractionError>`|Ruft den aktuellen Kontext und Verlauf einer Interaktion ab.|
|`provide_consent`|`&self, interaction_id: core::types::Uuid, model_id: String, granted: bool`|`Result<(), domain::AIInteractionError>`|Gibt die Zustimmung für ein bestimmtes Modell im Kontext einer Interaktion.|
|...|...|...|...|

```
    *   **Beispiel: `AIInteractionStatusChangedEvent` Payload**
```

|   |   |   |
|---|---|---|
|**Feldname**|**Typ**|**Beschreibung**|
|`interaction_id`|`core::types::Uuid`|ID der Interaktion, deren Status sich geändert hat.|
|`new_status`|`domain::ai::AIInteractionStatus`|Der neue Status der Interaktion.|
|`details`|`Option<String>`|Zusätzliche Details oder Fehlermeldung zum Statuswechsel.|

```
    Die präzise Definition dieser Domänenschnittstellen ist fundamental, da sie die Kernfunktionalität von NovaDE kapseln und die Verträge für die Interaktion mit der System- und UI-Schicht festlegen.
```

---

**Teil 4: Ultra-Granulare Schnittstellendefinition der Systemschicht (Erweiterung des Benutzerdokuments)**

Die Systemschicht ist verantwortlich für die Interaktion mit dem zugrundeliegenden Betriebssystem, der Hardware und Low-Level-Diensten wie dem Compositor, Eingabegeräten und D-Bus-Diensten. Sie stellt der UI-Schicht abstrahierte Schnittstellen zu diesen systemnahen Funktionen bereit.

- **4.1. Systemschicht zu UI-Schicht (Allgemeine Prinzipien)**
    
    - **Systemnahe Dienste und Ereignisse:** Die Systemschicht stellt der UI-Schicht Informationen und Ereignisse bereit, die direkt vom Betriebssystem, der Hardware oder systemnahen Daemons stammen. Für jede Kategorie (z.B. Fenstergeometrie, Eingabeereignisse, Systemstatusänderungen) werden spezifische Ereignisse mit detaillierten Payloads definiert.
    - **Technische Umsetzung von UI-Befehlen:** Die Systemschicht empfängt Befehle von der UI-Schicht (z.B. Fenster verschieben, Arbeitsbereich wechseln, Fokus anfordern) und setzt diese technisch um, indem sie mit dem Compositor, dem Fenstermanager oder anderen Systemkomponenten interagiert. Für jeden solchen Befehl wird eine exakte Methodensignatur in der API der Systemschicht definiert, die von der UI aufgerufen wird.
    - **Renderer-Schnittstelle (`system::compositor::renderer_interface`):** Obwohl nicht direkt von der UI-Schicht konsumiert, stellt diese Schnittstelle eine Abstraktion für das Rendering bereit. Wenn diese Schnittstelle Implikationen dafür hat, wie UI-Elemente letztendlich dargestellt werden (z.B. unterstützte Oberflächenformate, Anforderungen an Textur-Sharing), werden diese kurz vermerkt, da sie indirekt die UI-Implementierung beeinflussen können.
    - **Fehlertypen:** Jedes Modul der Systemschicht (z.B. `system::compositor`, `system::input`) definiert eigene, auf `thiserror` basierende Fehler-Enums (z.B. `CompositorError`, `InputError`). Diese Fehler-Enums listen alle spezifischen Fehlerzustände auf, die bei der Interaktion mit den jeweiligen Systemkomponenten auftreten können.
- **4.2. Spezifische Systemschicht-Schnittstellen (Ultra-Granular, für UI-Interaktion):**
    
    - **Compositor-Schnittstelle (`system::compositor_iface`):**
        
        - Diese Schnittstelle wird als Trait `CompositorInterface` definiert, um eine klare API für die UI-Schicht bereitzustellen.
        - **Methoden, die von der UI aufgerufen werden:**
            
            Rust
            
            ```
            pub trait CompositorInterface: Send + Sync {
                /// Fordert den Fokus für ein bestimmtes Fenster an.
                fn request_focus(&self, window_id: core::types::WindowId) -> Result<(), CompositorError>;
            
                /// Verschiebt ein Fenster an eine neue Position.
                fn move_window(&self, window_id: core::types::WindowId, new_pos: core::types::PointInt) -> Result<(), CompositorError>;
            
                /// Ändert die Größe eines Fensters.
                fn resize_window(&self, window_id: core::types::WindowId, new_size: core::types::SizeInt) -> Result<(), CompositorError>;
            
                /// Fordert einen neuen Zustand für ein Fenster an (z.B. Maximieren, Minimieren).
                fn set_window_state(&self, window_id: core::types::WindowId, state: CompositorWindowState) -> Result<(), CompositorError>;
            
                /// Schließt ein Fenster.
                fn close_window(&self, window_id: core::types::WindowId) -> Result<(), CompositorError>;
            
                /// Ruft detaillierte Informationen zu einem bestimmten Fenster ab.
                fn get_window_info(&self, window_id: core::types::WindowId) -> Result<Option<WindowInfo>, CompositorError>;
            
                /// Listet alle aktuell vom Compositor verwalteten Fenster auf.
                fn list_windows(&self) -> Result<Vec<WindowInfo>, CompositorError>;
            
                /// Ruft Informationen zu allen verfügbaren Outputs (Monitoren) ab.
                fn list_outputs(&self) -> Result<Vec<OutputInfo>, CompositorError>;
            
                /// Konfiguriert einen Output (Auflösung, Skalierung, etc.).
                fn configure_output(&self, output_id: String, config: OutputConfigurationRequest) -> Result<(), CompositorError>;
            
                /// Abonniert Compositor-Ereignisse.
                fn subscribe_to_compositor_events(&self) -> Result<tokio::sync::broadcast::Receiver<CompositorEvent>, CompositorError>;
            }
            ```
            
        - **Datenstrukturen:**
            - `WindowInfo { id: core::types::WindowId, title: String, app_id: core::types::AppId, class: Option<String>, geometry: core::types::RectInt, is_focused: bool, is_fullscreen: bool, is_maximized: bool, is_minimized: bool, workspace_id: Option<core::types::WorkspaceId>, parent_id: Option<core::types::WindowId>, transient_for_id: Option<core::types::WindowId>, can_resize: bool, can_maximize: bool, can_minimize: bool, can_close: bool, pid: Option<u32> }`
            - `CompositorWindowState { Maximized, Minimized, Fullscreen, Normal, TiledLeft, TiledRight, Floating }`
            - `OutputInfo { id: String, name: String, description: String, manufacturer: Option<String>, model: Option<String>, serial_number: Option<String>, physical_size_mm: Option<core::types::Size<u32>>, geometry_pixels: core::types::RectInt, scale_factor: f32, current_refresh_rate_mhz: u32, current_mode: OutputMode, available_modes: Vec<OutputMode>, is_primary: bool, is_enabled: bool, transform: core::types::Orientation }`
            - `OutputMode { width_px: u32, height_px: u32, refresh_rate_mhz: u32, is_preferred: bool }`
            - `OutputConfigurationRequest { resolution: Option<core::types::SizeInt>, scale: Option<f32>, position: Option<core::types::PointInt>, enabled: Option<bool>, refresh_rate_mhz: Option<u32>, transform: Option<core::types::Orientation>, is_primary: Option<bool> }`
        - **Events (als Enum `CompositorEvent` für das Abonnement):**
            
            Rust
            
            ```
            #
            pub enum CompositorEvent {
                WindowCreated { info: WindowInfo },
                WindowClosed { window_id: core::types::WindowId, app_id: core::types::AppId },
                WindowFocused { window_id: core::types::WindowId },
                WindowUnfocused { window_id: core::types::WindowId },
                WindowPropertiesChanged { window_id: core::types::WindowId, changed_properties: WindowPropertiesDelta },
                OutputAdded { info: OutputInfo },
                OutputRemoved { output_id: String },
                OutputConfigurationChanged { info: OutputInfo }, // Enthält den neuen Zustand des Outputs
                // Weitere Ereignisse wie Workspace-Wechsel, wenn vom Compositor direkt gemeldet
            }
            
            #
            pub struct WindowPropertiesDelta {
                pub title: Option<String>,
                pub app_id: Option<core::types::AppId>,
                pub class: Option<Option<String>>, // Option<Option<T>> um 'wurde auf None gesetzt' von 'wurde nicht geändert' zu unterscheiden
                pub geometry: Option<core::types::RectInt>,
                pub is_fullscreen: Option<bool>,
                pub is_maximized: Option<bool>,
                pub is_minimized: Option<bool>,
                pub workspace_id: Option<Option<core::types::WorkspaceId>>,
            }
            ```
            
        - **Fehler:** `CompositorError` mit Varianten wie `WindowNotFound`, `OutputNotFound`, `InvalidOperationForWindowState`, `WaylandCommunicationError(String)`, `X11CommunicationError(String)`.
        - Die Systemschicht abstrahiert hier die Komplexität von Wayland-Protokollen wie `wlr-foreign-toplevel-management` 17 oder `ext-foreign-toplevel-list-v1` 17, die für Taskbars und Docks zur Abfrage von Fensterlisten fundamental sind. Die UI konsumiert die `WindowInfo`-Struktur, die von dieser Abstraktion bereitgestellt wird. Für die Implementierung von UI-Elementen wie Panels oder Docks, die eine feste Position auf dem Bildschirm einnehmen, wird die Systemschicht intern `gtk4-layer-shell` 9 verwenden und eine abstrahierte API dafür anbieten.
    - **(Diese Detailtiefe wird für `system::input_iface`, `system::dbus::upower_client_iface`, `system::dbus::logind_client_iface`, `system::dbus::networkmanager_client_iface` (unter Berücksichtigung von D-Bus-Spezifikationen für NetworkManager 23 und BlueZ 20), `system::outputs_iface` (bereits teilweise in Compositor-Schnittstelle enthalten, hier ggf. spezifischere Konfigurationsmethoden), `system::audio_iface` (Abstraktion von PipeWire 26), `system::mcp_client_iface` und `system::portals_iface` (Abstraktion von XDG Desktop Portals, potenziell unter Verwendung von Bibliotheken wie `ashpd` 28) wiederholt, wie in Teil 1, Abschnitt 1.3 skizziert.)**
        
        - Für `system::portals_iface` ist die `WindowIdentifier`-Struktur, die von `ashpd` verwendet wird, ein wichtiger Aspekt, um Portal-Dialoge korrekt dem aufrufenden Anwendungsfenster zuzuordnen. Die Systemschicht muss einen Mechanismus bereitstellen, um diese Kennung von der UI zu erhalten oder abzuleiten.
    - Schlüsseltabellen für Teil 4.2:
        
        Ähnlich wie in den vorherigen Teilen werden für jede Systemschicht-Schnittstelle detaillierte Tabellen für Methodensignaturen, Parameter, Rückgabewerte und Ereignis-Payloads erstellt.
        
        - **Beispiel: `InputInterface` Methodenübersicht**

|   |   |   |   |
|---|---|---|---|
|**Methode**|**Parameter**|**Rückgabetyp (Result<_, _>)**|**Kurzbeschreibung**|
|`set_cursor_theme`|`&self, theme_name: String, size: u32`|`Result<(), system::InputError>`|Setzt das Cursor-Theme und die Größe.|
|`get_current_keyboard_layout`|`&self`|`Result<String, system::InputError>`|Ruft das aktuell aktive Tastaturlayout ab.|
|`subscribe_to_input_events`|`&self`|`Result<tokio::sync::broadcast::Receiver<system::input::InputEventEnum>, system::InputError>`|Abonniert verarbeitete Eingabeereignisse.|

```
    *   **Beispiel: `system::input::InputEventEnum` Payload (Auszug)**
        ```rust
        #
        pub enum InputEventEnum {
            Keyboard(KeyboardEvent),
            PointerButton(PointerButtonEvent),
            PointerMotion(PointerMotionEvent),
            //... weitere Event-Typen
        }

        #
        pub struct KeyboardEvent {
            pub window_id: Option<core::types::WindowId>, // Fenster, das den Fokus hatte, falls zutreffend
            pub key_code: u32,          // System-agnostischer Keycode
            pub raw_key_code: u32,      // Hardware-Keycode
            pub modifiers: KeyModifiers, // Bitmaske für Shift, Ctrl, Alt, Super
            pub state: KeyState,        // Pressed, Released
            pub utf8: Option<String>,   // Decodiertes Zeichen, falls vorhanden
            pub timestamp_us: u64,      // Zeitstempel in Mikrosekunden
        }
        // Definitionen für KeyModifiers, KeyState, PointerButtonEvent etc. folgen
        ```

    Die klare Definition dieser Systemschicht-APIs ist entscheidend, da sie die Brücke zwischen der plattformunabhängigen UI-Logik und den plattformspezifischen Implementierungen schlägt.
```

---

**Teil 5: Verfeinerte Schichtübergreifende Schnittstellenprinzipien und Fortgeschrittene Themen**

Dieser Abschnitt behandelt übergreifende Prinzipien und fortgeschrittene Aspekte, die für das Design und die Implementierung der internen Schnittstellen von NovaDE von Bedeutung sind.

- 5.1. Asynchrone Operationen und UI-Synchronisation
    
    Die Reaktionsfähigkeit der Benutzeroberfläche ist ein primäres Ziel. Viele Operationen, insbesondere solche, die Netzwerkzugriffe, Dateisystemoperationen oder komplexe Berechnungen beinhalten (z.B. Aufrufe an AIInteractionLogicService oder MCPClientInterface), sind inhärent asynchron. Es ist unerlässlich, dass die UI nicht blockiert, während auf den Abschluss dieser Operationen gewartet wird.
    
    - **Muster für von der UI initiierte asynchrone Aufrufe:**
        
        - Die UI-Schicht ruft eine `async fn` Methode eines Domänen- oder Systemdienstes auf (z.B. `async fn perform_long_task() -> Result<Data, ServiceError>;`).
        - Um ein Blockieren des UI-Threads zu verhindern, sollte die UI-Komponente, die die Operation initiiert (z.B. bei einem Button-Klick), die asynchrone Funktion in einer separaten Task ausführen. In einer `gtk4-rs` Umgebung wird hierfür typischerweise `tokio::spawn` (oder ein äquivalenter Executor) verwendet, falls die Service-Methode selbst `Send` ist, oder `glib::MainContext::spawn_local` für nicht-`Send` Futures, die auf dem Hauptthread laufen müssen, aber dennoch asynchron sind.
    - **Übermittlung von Ergebnissen/Fehlern an den UI-Thread:**
        
        - **`glib::MainContext::spawn_local`:** Dies ist der bevorzugte Mechanismus in `gtk4-rs`, um UI-Aktualisierungen sicher auf dem Haupt-GTK-Thread zu planen, sobald eine asynchrone Operation abgeschlossen ist.3
            - **Ablaufbeispiel:**
                1. Eine UI-Komponente (z.B. ein Button-Klick-Handler) startet eine Tokio-Task (`tokio::spawn`).
                2. Diese Tokio-Task führt `await` auf den Aufruf des Domänen- oder Systemdienstes aus.
                3. Nach Abschluss der Operation (ob `Ok` oder `Err`) verwendet die Tokio-Task `main_context.spawn_local(...)`, um eine Closure zu planen.
                4. Diese Closure, die nun garantiert auf dem Hauptthread ausgeführt wird, aktualisiert die GTK-Widgets mit dem Ergebnis oder dem Fehler.
        - **Kanäle (z.B. `tokio::sync::mpsc`, `async_channel`):**
            - Der UI-Thread hält das `Receiver`-Ende des Kanals. Die asynchrone Task (z.B. in einem Tokio-Thread) hält das `Sender`-Ende.
            - Nach Abschluss der asynchronen Operation wird das Ergebnis oder der Fehler über den Kanal gesendet.
            - Der UI-Thread, typischerweise in einer `glib::idle_add_local`-Schleife oder einem `glib::MainContext::spawn_local`-Future, das den Receiver abfragt, verarbeitet eingehende Nachrichten und aktualisiert die Widgets.
            - Es ist wichtig zu beachten, dass `glib::MainContext::channel()` in neueren GLib-Versionen entfernt wurde.39 Der empfohlene Ansatz ist die Verwendung von Standard-Async-Kanälen (wie `async_channel` oder `tokio::sync::mpsc`) und dann `glib::MainContext::default().spawn_local()`, um die Ergebnisse auf den Hauptthread für UI-Aktualisierungen zu bringen. Diese Änderung vereinfacht die Codebasis, da sie auf etablierte asynchrone Rust-Patterns setzt, anstatt eine GLib-spezifische Kanallösung zu verwenden. Die Schnittstellendefinition selbst schreibt diese interne UI-Implementierung nicht vor, aber die Dokumentation für UI-Entwickler, die diese asynchronen APIs konsumieren, sollte dieses Muster empfehlen.
        - **Fehlerbehandlung in asynchroner UI:** Fehler von asynchronen Operationen müssen ebenfalls auf den Hauptthread gemarshallt und angemessen dargestellt werden. Dies kann beispielsweise durch die Anzeige eines `gtk::AlertDialog` 6 oder einer nicht-modalen Benachrichtigung geschehen.
    - **Tabelle: Asynchrones Interaktionsmuster**
        

|   |   |   |   |   |
|---|---|---|---|---|
|**Schritt**|**Aktion**|**Thread**|**Mechanismus**|**Anmerkungen**|
|1|Benutzerinteraktion|UI-Thread|GTK-Signal|z.B. Button-Klick|
|2|Asynchronen Aufruf initiieren|UI-Thread|`tokio::spawn` (für `Send` Futures)|Startet eine neue Task für den Service-Aufruf, um den UI-Thread nicht zu blockieren.|
|3|Service-Methode ausführen|Worker-Thread (Tokio)|`await service.method()`|Ruft die asynchrone Methode des Domänen-/Systemdienstes auf.|
|4a|Ergebnis/Fehler senden (Kanal-Ansatz)|Worker-Thread (Tokio)|`sender.send(result).await`|Sendet das Ergebnis an einen Kanal, der vom UI-Thread überwacht wird.|
|4b|UI-Update planen (Direkter Spawn-Ansatz)|Worker-Thread (Tokio)|`main_context.spawn_local(async move {... })`|Plant direkt eine Closure zur UI-Aktualisierung auf dem Hauptthread.|
|5a|Empfangen & Verarbeiten (Kanal-Ansatz)|UI-Thread|`receiver.recv().await` (in `spawn_local`)|Die Closure in `spawn_local` empfängt die Nachricht und aktualisiert GTK-Widgets.|
|5b|UI-Update ausführen (Direkter Spawn-Ansatz)|UI-Thread|Ausführung der Closure|Die geplante Closure wird ausgeführt und aktualisiert GTK-Widgets.|

```
    Diese Tabelle verdeutlicht das Threading-Modell und den Kommunikationsfluss für asynchrone Operationen, die von der UI initiiert werden. Dies ist ein häufiger Bereich für Komplexität und Fehlerquellen, daher ist ein klares Verständnis dieses Musters entscheidend.
```

- 5.2. Ereignissystem: Granulare Semantik
    
    Das Ereignissystem ist ein Rückgrat für die reaktive Natur von NovaDE. Eine präzise Definition der Ereignissemantik ist unerlässlich.
    
    - **Ereignisdefinition:** Jede Ereignisstruktur (`struct`) muss vollständig definiert sein, einschließlich aller Felder und deren exakter Rust-Typen. Die Nutzdaten (Payload) eines Ereignisses sollten umfassend sein, um es den Konsumenten zu ermöglichen, ohne zusätzliche Abfragen an den Ereigniserzeuger zu reagieren. Beispielsweise sollte ein `ThemeChangedEvent` nicht nur eine ID des neuen Themes enthalten, sondern direkt die `AppliedThemeState`-Struktur, die alle relevanten Details des neuen Themes beinhaltet. Dies minimiert den Kommunikationsaufwand und verbessert die Performance.
    - **Payload-Serialisierung:** Für die interne Kommunikation zwischen den Schichten innerhalb desselben Prozesses ist eine direkte Übergabe von Rust-Strukturen ausreichend und performant. Sollten Ereignisse jedoch zukünftig über Prozessgrenzen hinweg kommuniziert werden (z.B. über D-Bus an externe Komponenten), muss ein Serialisierungsformat (z.B. Serde mit JSON/CBOR oder GVariant für D-Bus) definiert werden. Die aktuellen Ereignisstrukturen sollten mit `#` annotiert werden, um diese zukünftige Erweiterbarkeit vorzubereiten.
    - **Ereignisgarantien:**
        - **Reihenfolge:** Innerhalb eines bestimmten Geltungsbereichs (z.B. Ereignisse von einem einzelnen Service) ist typischerweise davon auszugehen, dass Ereignisse in der Reihenfolge empfangen werden, in der sie ausgelöst wurden, vorausgesetzt, der Emitter ist single-threaded oder verwendet geeignete Synchronisationsmechanismen. Für einen systemweiten Event-Bus kann die globale Reihenfolge komplexer sein und hängt von der Implementierung des Busses ab.
        - **Zustellung:** Für einen In-Prozess-Event-Bus wird typischerweise eine "At-least-once"-Zustellung angestrebt, solange die Abonnenten aktiv sind und keine Fehler im Bus selbst auftreten. Garantien für "Exactly-once" sind komplexer zu implementieren.
    - **Abonnement-Mechanismus:**
        - Es muss eine klare API für Komponenten geben, um spezifische Ereignistypen zu abonnieren. Dies könnte über einen zentralen `EventBus` erfolgen: `event_bus.subscribe::<ThemeChangedEvent>(|event: &ThemeChangedEvent| { /* UI-Logik hier */ });`.
        - Der Event-Bus sollte Filterfunktionen unterstützen, z.B. das Abonnieren von `WorkspaceEvent` nur für eine bestimmte `workspace_id` oder das Filtern von `SettingChangedEvent` nach einem bestimmten `setting_key`.
        - Die zurückgegebenen `tokio::sync::broadcast::Receiver` von den `subscribe_to_..._events` Methoden der Service-Traits sind ein Beispiel für einen solchen Mechanismus.
    - **Broadcasting vs. Gezielte Ereignisse:** Die meisten Domänen- und Systemereignisse werden als Broadcast an alle interessierten Abonnenten gesendet. Gezielte Ereignisse (nur an einen bestimmten Listener) sind seltener und erfordern einen komplexeren Registrierungs- und Routing-Mechanismus. Für die interne Schichtkommunikation ist Broadcasting meist ausreichend.
    - Die Reaktivität der Benutzeroberfläche hängt stark von einem wohldefinierten und zuverlässigen Ereignissystem ab. Granulare Ereignis-Payloads sind der Schlüssel zur Minimierung von Daten-Refetching und zur Gewährleistung einer performanten UI. GTK4-Signale und Ereignisbehandlungsmechanismen werden intern von der UI-Schicht verwendet, um auf diese anwendungsweiten Ereignisse zu reagieren, die von den unteren Schichten über den Event-Bus oder direkte Abonnements empfangen werden.
- **5.3. API-Versionierung und Evolution (Kurzer Hinweis)**
    
    - APIs unterliegen im Laufe der Zeit Änderungen. Um die Stabilität und Wartbarkeit des Systems langfristig zu gewährleisten, sollten Strategien für die API-Evolution berücksichtigt werden:
        - **Hinzufügen neuer Methoden zu Traits:** Dies ist für bestehende Implementierer nicht-brechend, wenn die neuen Methoden Standardimplementierungen haben (obwohl dies für Kern-APIs seltener der Fall ist).
        - **Hinzufügen neuer optionaler Felder zu Strukturen/Event-Payloads:** Erfordert eine sorgfältige Behandlung durch die Konsumenten (z.B. Verwendung von `Option<T>` und `#[serde(default)]`).
        - **Einführung neuer Versionen von Traits (z.B. `ThemingEngineV2`):** Für signifikante, brechende Änderungen ist dies der sauberste Ansatz.
    - Diese Überlegungen sind zunächst auf hoher Ebene, aber wichtig für die langfristige Gesundheit des Projekts. Eine klare Dokumentation von Änderungen und Deprecation-Policys ist ebenfalls entscheidend.

---

**Teil 6: Schnittstellendetails UI-Komponenten-spezifisch**

Dieser Abschnitt widmet sich der ultra-granularen Definition der Interaktionen spezifischer UI-Komponenten mit den zuvor definierten Domänen- und System-APIs. Er beleuchtet, wie Schlüsselkomponenten der Benutzeroberfläche diese Schnittstellen nutzen, um ihre Funktionalität zu realisieren.

- **6.1. Window Manager Frontend (`ui::window_manager_frontend`)**
    - **Verantwortlichkeiten:** Anzeige von Fensterrepräsentationen (z.B. in einer Taskleiste, Alt-Tab-Umschalter), Bearbeitung von Fokusanfragen für Fenster von UI-Elementen.
    - **Interaktion mit `system::compositor_iface`:**
        - Konsumiert `system::compositor::WindowCreatedEvent`, `WindowClosedEvent`, `WindowFocusedEvent`, `WindowUnfocusedEvent`, `WindowPropertiesChangedEvent`, um seine interne Liste der Fenster und deren Zustände zu aktualisieren.
        - Ruft `compositor_iface.request_focus(window_id)` auf, wenn der Benutzer ein Fenster auswählt (z.B. durch Klick in der Taskleiste).
        - Ruft `compositor_iface.set_window_state(window_id, CompositorWindowState::Minimized)` oder `close_window(window_id)` auf, basierend auf Benutzeraktionen.
    - **Interne UI-Modelldatenstrukturen:**
        - `UIWindowRepresentation { id: core::types::WindowId, title: String, app_id: core::types::AppId, icon_name: Option<String>, // Name für Themed Icon gtk_icon: Option<gtk::gdk_pixbuf::Pixbuf>, // Geladenes Icon is_focused: bool, is_minimized: bool, workspace_tag: Option<String> /* z.B. "WS1" */ }`
    - **GTK-Implementierungshinweise:**
        - Könnte `gtk::ListView` 40 oder `gtk::FlowBox` 45 mit benutzerdefinierten Widgets für jedes Fenster verwenden. Jedes benutzerdefinierte Widget würde an eine `UIWindowRepresentation` binden.
        - Für die Fenster-Thumbnails oder Live-Vorschauen (wie in einem Alt-Tab-Switcher) sind Wayland-spezifische Protokolle oder Compositor-Features notwendig. Die Systemschicht müsste eine API bereitstellen, um solche Texturen oder Oberflächen-Handles zu liefern, die dann in einem GTK-Widget (ggf. ein spezielles Wayland-Oberflächen-Widget oder ein `gtk::Picture` mit aktualisierten Snapshots) dargestellt werden könnten. Wakefield 47 ist ein Beispiel für einen GTK-basierten Compositor, der Client-Oberflächen in GTK-Widgets einbetten kann; ähnliche Konzepte könnten für Vorschauen relevant sein, auch wenn NovaDE kein verschachtelter Compositor ist. Die `ext-foreign-toplevel-list-v1` und `wlr-foreign-toplevel-management-unstable-v1` Protokolle 17 sind fundamental für Taskleisten, um Fensterlisten und Metadaten zu erhalten. Die Systemschicht abstrahiert diese Protokolle, und die UI konsumiert die `WindowInfo`-Strukturen.
    - **Tabellen:**
        - **Interaktion `ui::window_manager_frontend` mit `system::compositor_iface`**

|   |   |   |   |
|---|---|---|---|
|**UI-Aktion**|**Aufgerufene compositor_iface-Methode**|**Konsumierte CompositorEvents**|**Aktualisierte UI-Daten**|
|Fenster in Taskleiste anklicken|`request_focus(window_id)`|`WindowFocusedEvent`, `WindowUnfocusedEvent`|`UIWindowRepresentation::is_focused`|
|Fenster minimieren|`set_window_state(id, Minimized)`|`WindowPropertiesChangedEvent` (mit `is_minimized = true`)|`UIWindowRepresentation::is_minimized`|
|Neues Fenster erscheint|-|`WindowCreatedEvent`|Neue `UIWindowRepresentation`|
|Fenstertitel ändert sich|-|`WindowPropertiesChangedEvent` (mit `changed_title`)|`UIWindowRepresentation::title`|

- **6.2. Desktop Shell (`ui::shell`) - Panels, Docks**
    
    - **Verantwortlichkeiten:** Anzeige von Panels (oben, unten, seitlich), Docks, Arbeitsbereichswechslern, Uhr, Systemindikatoren (Netzwerk, Lautstärke, Akku etc.).
    - **Interaktion mit `gtk4-layer-shell` (über Systemschicht-Abstraktion):**
        - Die Systemschicht stellt eine API bereit, z.B. `system::desktop_shell_iface`, um Layer-Oberflächen zu erstellen und zu verwalten. Diese API kapselt die direkte Verwendung von `gtk4-layer-shell`.9
        - `fn create_layer_surface(&self, params: LayerSurfaceParams) -> Result<LayerSurfaceHandle, ShellError>;`
            - `LayerSurfaceParams { window_handle: gtk::WindowHandle, // Das GTK-Fenster, das als Layer-Oberfläche dient anchor: LayerShellAnchor, // Bitflags: Top, Bottom, Left, Right exclusivity: LayerShellExclusivity, // Exclusive, OnDemand keyboard_interactivity: LayerShellKeyboardInteractivity // None, Exclusive, OnDemand margins: (i32, i32, i32, i32) // top, right, bottom, left }`
        - Die UI verwendet dieses `LayerSurfaceHandle`, um ihre GTK-Panel- oder Dock-Widgets in der Layer-Oberfläche zu positionieren und zu verankern.
        - Die Verwendung von `gtk4-layer-shell` ist entscheidend für die korrekte Integration von Panels und Docks in Wayland-Umgebungen, da es Apps erlaubt, sich über oder unter normalen Fenstern zu positionieren und Platz auf dem Bildschirm zu reservieren.9
    - **Arbeitsbereichswechsler:**
        - Konsumiert `domain::workspaces::WorkspaceEvent`-Ereignisse vom `WorkspaceManager`.
        - Zeigt `domain::workspaces::WorkspaceDescriptor`-Daten an (Name, Icon, aktive Fenster).
        - Ruft `WorkspaceManager::set_active_workspace(workspace_id)` bei Benutzerinteraktion auf.
        - GTK-Implementierung: Könnte eine `gtk::Box` mit `gtk::ToggleButton`s oder benutzerdefinierten gezeichneten Elementen für jeden Arbeitsbereich sein. `chunks-rs` 50 und allgemeine Pager-Beispiele 51 zeigen Konzepte für die Implementierung von Arbeitsbereichswechslern in GTK.
    - **Uhr / Kalenderanzeige:**
        - Verwendet `core::utils::time_utils` (basierend auf `chrono`) zur Formatierung von Datum und Uhrzeit.
        - Kann ein `gtk::Calendar` in einem `gtk::Popover` anzeigen, wenn auf die Uhr geklickt wird. Das Popover wird relativ zum Uhr-Widget positioniert.
    - **Systemindikatoren (Lautstärke, Netzwerk, Akku, Bluetooth etc.):**
        - **Lautstärke:**
            - Konsumiert `system::audio::AudioDeviceChangedEvent`, `AudioStreamVolumeChangedEvent` etc. vom `system::audio_iface`.
            - Zeigt aktuelle Lautstärke mit `gtk::Scale` (als Slider) oder `gtk::VolumeButton` 52 an.
            - Sendet `system::audio_iface::set_device_volume()` bei Benutzerinteraktion.
        - **Netzwerk:**
            - Konsumiert `system::dbus::NetworkStateChangedEvent`, `AccessPointsChangedEvent` vom `system::dbus::networkmanager_client_iface`.
            - Zeigt Verbindungsstatus (Icon), SSID, verfügbare Netzwerke in einem `gtk::Popover` mit einer `gtk::ListBox` an.
            - Ruft `system::dbus::networkmanager_client_iface::connect_to_access_point()` auf.
        - **Akku:**
            - Konsumiert `system::dbus::UPowerDeviceChangedEvent` vom `system::dbus::upower_client_iface`.
            - Zeigt Akkustand (Icon, Prozent) und geschätzte Restlaufzeit an.
        - **Bluetooth:**
            - Konsumiert Ereignisse von einem `system::dbus::bluez_adapter_iface` (analog zu NetworkManager).
            - Zeigt Bluetooth-Status, gekoppelte und verfügbare Geräte an.
            - Ruft Methoden wie `pair_device()`, `connect_device()` auf der BlueZ-Schnittstelle auf.20
        - **StatusNotifierItem/Ayatana Indicators (System Tray):**
            - Die Implementierung eines System Trays unter Wayland ist komplex. Die Spezifikation `StatusNotifierItem` (SNI) 48 ist der De-facto-Standard, der über D-Bus funktioniert.
            - Die `ui::shell` müsste als `StatusNotifierHost` agieren. Dies beinhaltet das Lauschen auf den D-Bus nach Diensten, die `StatusNotifierWatcher.RegisterStatusNotifierItem` aufrufen, und dann die Interaktion mit jedem `StatusNotifierItem` über dessen D-Bus-Schnittstelle, um Icon, Tooltip, Menü etc. abzurufen und darzustellen.
            - Die UI-Elemente für jedes Tray-Icon (typischerweise ein `gtk::Button` mit einem `gtk::Image` und einem `gtk::MenuButton` oder `gtk::Popover` für das Kontextmenü) würden dynamisch in einem Bereich des Panels erstellt.
            - Alternative Ansätze oder Herausforderungen unter Wayland werden diskutiert.58 NovaDE wird sich auf die `StatusNotifierItem`-Spezifikation konzentrieren, da sie am weitesten verbreitet ist. Die `libayatana-indicator`-Bibliothek 63 bietet eine Implementierung, die als Referenz dienen kann, obwohl NovaDE seine eigene D-Bus-Interaktion wahrscheinlich direkt mit `zbus` oder `gio::DBusConnection` implementieren würde, abstrahiert durch die Systemschicht.
            - Die Systemschicht würde eine `system::status_notifier_host_iface` bereitstellen, die Ereignisse wie `StatusNotifierItemRegisteredEvent { service_name: String, object_path: String }` und `StatusNotifierItemUnregisteredEvent` aussendet. Die UI würde diese abonnieren und dann die `system::status_notifier_item_proxy_iface` verwenden, um mit den einzelnen Items zu interagieren (z.B. `get_icon_pixmap()`, `get_tooltip()`, `activate()`, `context_menu()`).
- **6.3. Benachrichtigungs-Popups (`ui::notification_popups`)**
    
    - **Verantwortlichkeiten:** Anzeige von transienten Benachrichtigungs-Popups.
    - **Interaktion mit `domain::NotificationService`:**
        - Konsumiert `domain::notifications::NotificationPostedEvent`.
        - Zeigt die `domain::notifications::Notification`-Daten (Zusammenfassung, Textkörper, Icon, Aktionen) an.
    - **Interaktion mit `gtk4-layer-shell` (über Systemschicht-Abstraktion):**
        - Verwendet das Layer-Shell-Protokoll, um Benachrichtigungs-Popups an einer bestimmten Bildschirmkante (z.B. oben rechts) ohne Interferenz mit anderen Fenstern zu positionieren. Dies ist entscheidend für nicht-invasive Benachrichtigungen.9
        - Die Systemschicht stellt eine Methode bereit, z.B. `system::desktop_shell_iface::create_notification_layer_surface(params: NotificationSurfaceParams) -> Result<LayerSurfaceHandle, ShellError>;`, wobei `NotificationSurfaceParams` Details wie Anker, Dauer und Größe enthalten kann.
    - **Benutzerinteraktion:**
        - Klick auf eine Benachrichtigung könnte `NotificationService::dismiss_notification(id)` aufrufen oder eine Standardaktion auslösen (falls definiert).
        - Klick auf einen Aktionsbutton in einer Benachrichtigung (z.B. "Antworten", "Archivieren") resultiert in einem Aufruf an `NotificationService::invoke_action_on_notification(notification_id, action_id)`, was wiederum ein `domain::notifications::NotificationActionInvokedEvent` auslösen kann, auf das andere Teile der Anwendung reagieren können.
    - **GTK-Implementierungshinweise:**
        - Jedes Popup ist ein eigenes `gtk::Window`, das als Layer-Oberfläche konfiguriert ist. Es enthält typischerweise `gtk::Image` für das Icon, `gtk::Label` für Text und `gtk::Button` für Aktionen.
        - Mehrere Popups müssen verwaltet werden (z.B. in einer Warteschlange oder gestapelt auf dem Bildschirm).65
    - NovaDE wird seine eigenen Benachrichtigungen zeichnen, um volle Kontrolle über das Erscheinungsbild und die Integration mit dem Theming-System zu haben, anstatt sich auf einen externen Freedesktop-Benachrichtigungsdaemon zu verlassen.67 Der `domain::NotificationService` dient als zentrale Anlaufstelle und leitet die `NotificationPostedEvent` an die `ui::notification_popups`-Komponente weiter.
- **6.4. Anwendungsstarter (z.B. Dock, Anwendungsraster)**
    
    - **Verantwortlichkeiten:** Anzeige verfügbarer Anwendungen, Starten von Anwendungen.
    - **Interaktion mit `system::app_launcher_iface`:**
        - Ruft `system::app_launcher_iface::list_applications()` auf, um eine `Vec<system::applications::ApplicationEntry>` zu erhalten.
        - Zeigt diese Einträge an (Icon, Name). Die Icons werden basierend auf dem Icon-Namen und dem aktuellen Theme geladen.
        - Ruft `system::app_launcher_iface::launch_application(app_id, files_to_open: Option<Vec<PathBuf>>)` bei Benutzeraktivierung (Klick) oder per Drag-and-Drop auf.
    - **Interne UI-Modelldatenstrukturen:**
        - `UIAppEntry { id: String, // Desktop-Datei-ID oder AppStream-ID name: String, generic_name: Option<String>, comment: Option<String>, icon_name: Option<String>, gtk_icon: Option<gtk::gdk_pixbuf::Pixbuf>, categories: Vec<String>, keywords: Vec<String> }`
        - Die `system::app_launcher_iface` würde intern `freedesktop_entry_parser` 71 oder ähnliche Mechanismen verwenden, um `.desktop`-Dateien zu parsen und die `ApplicationEntry`-Daten bereitzustellen. Die UI konsumiert diese abstrahierten Daten.
    - **GTK-Implementierungshinweise:**
        - `gtk::FlowBox` 45 oder `gtk::GridView` (mit `gtk::SignalListItemFactory` 42) eignen sich gut zur Anzeige von App-Icons.
        - Jedes Icon könnte ein benutzerdefiniertes `gtk::Button` sein, das ein `gtk::Image` und optional ein `gtk::Label` enthält.
    - **Drag-and-Drop zum Starten:**
        - App-Icons fungieren als `GtkDropTarget`.74
        - Bei einem Drop werden Datei-URIs/Pfade extrahiert und an `system::app_launcher_iface::launch_application(app_id, Some(dropped_files))` übergeben.
        - Die `system::app_launcher_iface` verwendet intern `gio::AppInfo` und verwandte APIs, um Anwendungen zu starten [76,
    
    
# Technische Spezifikation: Benutzeroberflächenschicht (UI Layer)**

**I. Einleitung und Zweck**

Dieses Dokument definiert die detaillierten technischen Spezifikationen für die Benutzeroberflächenschicht (UI Layer) der zu entwickelnden Linux-Desktop-Umgebung. Es dient als direkte und verbindliche Implementierungsgrundlage für das Entwicklungsteam. Die UI-Schicht ist die dem Benutzer zugewandte Ebene und verantwortlich für die gesamte visuelle Darstellung sowie die Entgegennahme und Verarbeitung direkter Benutzerinteraktionen. Sie baut auf dem GTK4-Toolkit auf und arbeitet eng mit den darunterliegenden System- und Domänenschichten zusammen, um eine kohärente, intuitive und leistungsstarke Benutzererfahrung zu schaffen, die sich durch eine moderne, dunkle Ästhetik mit benutzerdefinierbaren Akzentfarben auszeichnet. Alle hier getroffenen Festlegungen sind das Ergebnis vorheriger Analysen und Designentscheidungen des Gesamtprojekts.

**II. Architektonische Einordnung und Verantwortlichkeiten**

Die UI-Schicht bildet die oberste Ebene der etablierten vier-schichtigen Architektur:

1. **Kernschicht (Core Layer):** Stellt fundamentale Datentypen, Dienstprogramme, Basiskonfigurationen, Logging-Mechanismen und grundlegende Fehlerdefinitionen bereit.
2. **Domänenschicht (Domain Layer):** Beinhaltet die Kernlogik und Geschäftsregeln der Desktop-Umgebung, wie Workspace-Verwaltung ("Spaces"), das Theming-System, Logik für KI-Interaktionen inklusive Einwilligungsmanagement, Verwaltung von Benachrichtigungen und die Definition von Richtlinien für das Fenstermanagement.
3. **Systemschicht (System Layer):** Implementiert die Interaktion mit dem zugrundeliegenden Betriebssystem und externen Diensten. Dies schließt den Wayland-Compositor, die Eingabeverarbeitung, die Kommunikation über D-Bus mit Systemdiensten, die Implementierung von Wayland-Protokollen, die XWayland-Integration, die MCP-Client-Implementierung und die Interaktion mit XDG Desktop Portals ein.
4. **Benutzeroberflächenschicht (User Interface Layer):**
    - **Primäre Verantwortlichkeit:** Darstellung aller visuellen Elemente der Desktop-Umgebung und Handhabung der direkten Interaktion mit dem Benutzer.
    - **Kernkomponenten:** Umfasst die Shell-UI (bestehend aus Panels/Leisten, dem Schnellaktionsdock, der intelligenten Tab-Leiste pro "Space", dem Workspace-Switcher und dem Quick-Settings-Panel), das Control Center für Systemeinstellungen, das Widget-System inklusive der adaptiven Seitenleisten, den Übersichtsmodus für Fenster- und Workspace-Management, die kontextuelle Befehlspalette und die Speed-Dial-Startansicht.
    - **Technologische Basis:** Verwendet das GTK4-Toolkit und die Rust-Programmiersprache.
    - **Interaktionen:**
        - **Mit der Systemschicht:** Zur Steuerung und Abfrage von Fensterzuständen (Positionierung, Größe, Sichtbarkeit), zum Empfang von Eingabeereignissen (Tastatur, Maus, Touch), zur Interaktion mit Systemdiensten (z.B. Netzwerkstatus, Energieverwaltung, Audio-Kontrolle) und zur Nutzung von Wayland-Protokollen für spezielle UI-Elemente (z.B. Panels via `wlr-layer-shell-unstable-v1`).
        - **Mit der Domänenschicht:** Zur Visualisierung von Zuständen (z.B. aktuelles Theme, Struktur und Inhalt von "Spaces", Liste der Benachrichtigungen, globale Einstellungen) und zum Auslösen von Geschäftslogik (z.B. Änderung einer Einstellung, Auswahl eines Themes, Erstellung eines neuen "Space").
        - **Mit dem Benutzer:** Entgegennahme von Eingaben über grafische Elemente und Weiterleitung entsprechender Befehle an die System- oder Domänenschicht. Präsentation von Informationen und Systemfeedback.

**III. Technologie-Stack (UI-Schicht-Spezifika)**

|Bereich|Technologie/Standard|Kernaspekte für die UI-Schicht|
|:--|:--|:--|
|GUI-Toolkit|GTK4|Moderne Widget-Bibliothek; Wayland-First-Ansatz; offizielle und gepflegte Rust-Bindings (`gtk4-rs`); CSS-basiertes Theming zur Umsetzung des Token-basierten Designsystems; Fähigkeit zum dynamischen Wechsel von Themes und Styles zur Laufzeit; Unterstützung für Composite Templates (`*.ui`-Dateien) zur Trennung von Layout und Code.|
|Programmiersprache|Rust|Gewährleistet Speichersicherheit und Performance, auch für komplexe UI-Logik; gute Integration mit GTK4 über `gtk4-rs`.|
|Wayland-Protokolle (Client)|`wlr-layer-shell-unstable-v1`, `wlr-foreign-toplevel-management-unstable-v1`|`wlr-layer-shell` wird für die korrekte Positionierung und das Verhalten von Shell-UI-Elementen wie Panels und Docks benötigt, die über oder unter normalen Anwendungsfenstern liegen. `wlr-foreign-toplevel-management` ist essentiell für Funktionen wie den Übersichtsmodus oder Taskleisten-Äquivalente, um Informationen über Fenster anderer Anwendungen zu erhalten und diese zu steuern.|
|Inter-Prozess-Kommunikation|D-Bus|Ermöglicht die Kommunikation mit Systemdiensten (Netzwerk, Energie, Audio etc. via Systemschicht) und potenziell mit internen Diensten der Desktop-Umgebung für entkoppelte Komponenteninteraktion.|
|Theming-Implementierung|Token-basiertes System via GTK4 CSS Custom Properties (`var()`)|Ermöglicht die dynamische Anwendung von Design-Tokens (Farben, Schriftgrößen, Abstände etc.), die von der Domänenschicht (`domain::theming`) verwaltet werden. Änderungen an den Tokens führen zu Laufzeitaktualisierungen des UI-Erscheinungsbildes.|
|Grafische Darstellung|Über den Wayland Compositor der Systemschicht|Die UI-Schicht ist primär für die Beschreibung der Szene und die Logik der UI-Elemente zuständig. Das eigentliche Rendern der Fenster und UI-Elemente auf dem Bildschirm wird vom Compositor (basierend auf Smithay) in der Systemschicht übernommen.|
|Eingabeverarbeitung|Empfang von Wayland-Events von der Systemschicht|Die UI-Schicht empfängt bereits prozessierte Eingabeereignisse (Tastatur, Maus, Touch, Gesten) als Wayland-Events vom Compositor, der diese mittels `libinput` aufbereitet hat. Die UI-Schicht ist dann für die semantische Interpretation dieser Events im Kontext der fokussierten UI-Elemente zuständig.|

In Google Sheets exportieren

**IV. Entwicklungsrichtlinien (UI-Schicht-Ergänzungen)**

Über die allgemeinen Projektrichtlinien hinaus gelten für die UI-Schicht folgende spezifische Vorgaben:

- **GTK4 Best Practices:**
    - Konsequente Nutzung von GTK4-Idiomen und -Mustern.
    - Verwendung von Composite Templates (`*.ui`-Dateien mit `blueprint` oder XML) zur Definition des UI-Layouts, um eine klare Trennung von der Rust-Logik zu gewährleisten. Widgets werden in Rust-Code über `#[template_child]` referenziert.
    - Nutzung der `Gtk::Application`-Klasse als Einstiegspunkt und für die Verwaltung des Anwendungslebenszyklus der Desktop-Shell. Hauptfenster sind Instanzen von `Gtk::ApplicationWindow` oder spezialisierten Ableitungen.
- **Asynchrone Programmierung:**
    - Alle potenziell blockierenden Operationen (z.B. Netzwerkzugriffe für Widgets, komplexe Berechnungen, die nicht sofort abgeschlossen werden können) müssen asynchron implementiert werden, um die Reaktionsfähigkeit der UI sicherzustellen.
    - Bevorzugte Nutzung von `async/await` in Verbindung mit `glib::MainContext::spawn_local` für GTK-kompatible asynchrone Aufgaben.
- **Zustandsverwaltung:**
    - Strikte Trennung von Darstellungslogik und Anwendungszustand. Die UI-Komponenten sollen primär als Visualisierung des Zustands dienen, der von der Domänen- oder Systemschicht gehalten und bereitgestellt wird.
    - Änderungen des Zustands werden durch Benutzerinteraktionen ausgelöst und an die zuständigen unteren Schichten delegiert. Die UI aktualisiert sich dann reaktiv auf Events oder geänderte Daten von diesen Schichten.
    - Lokaler UI-Zustand (z.B. Zustand einer Animation, geöffnete Popovers) ist auf das absolute Minimum zu beschränken.
- **CSS-Styling und Theming:**
    - Verwendung eines konsistenten und modularen CSS-Namensschemas (z.B. BEM-inspiriert) für alle Widgets und UI-Elemente, um die Lesbarkeit und Wartbarkeit der Stylesheets zu verbessern.
    - Stylesheets werden dynamisch über `Gtk::CssProvider` geladen und aktualisiert, basierend auf den Vorgaben der `ui::theming_gtk`-Komponente, die wiederum von der `domain::theming`-Logik gesteuert wird.
    - Die UI-Elemente müssen so gestaltet sein, dass sie korrekt auf Änderungen der globalen Design-Tokens (Akzentfarben, Basis-Theme-Farben, Schriftarten) reagieren.
- **Barrierefreiheit (Accessibility - A11y):**
    - Barrierefreiheit ist von Beginn an ein integraler Bestandteil des UI-Designs und der Implementierung.
    - Korrekte Implementierung von Accessibility-Informationen für alle Widgets unter Verwendung der von GTK4 und ATK bereitgestellten Mechanismen (z.B. Setzen von Accessible Roles, States und Properties).
    - Sicherstellung der Tastaturnavigation für alle interaktiven Elemente.
- **Performance und Optimierung:**
    - Die UI muss auf schnelle Startzeiten und flüssige Interaktionen sowie Animationen optimiert werden.
    - Vermeidung unnötiger Neuzeichnungen (`Gtk::Widget::queue_draw` nur bei tatsächlichen Änderungen).
    - Effiziente Nutzung von GTK-Layout-Managern.
    - Regelmäßiges Profiling der UI-Performance mit geeigneten Werkzeugen (z.B. Sysprof, GTK Inspector).
- **Responsive Design-Elemente:**
    - Obwohl der primäre Fokus auf Desktop-Systemen liegt, sollen UI-Elemente und Layouts so gestaltet werden, dass sie sich in einem gewissen Rahmen an unterschiedliche Fenstergrößen und -proportionen anpassen können, ohne dass das Layout bricht.
- **UI-Teststrategie:**
    - Entwicklung von Unit-Tests für einzelne UI-Komponenten und deren Logik.
    - Evaluierung und Einsatz von Werkzeugen für Integrationstests der UI, z.B. durch Simulation von Benutzerinteraktionen auf Widget-Ebene oder Wayland-Ebene.
    - Prüfung der Möglichkeit von visuellen Regressionstests, um unbeabsichtigte Änderungen am Erscheinungsbild frühzeitig zu erkennen.
    - Accessibility-Tests zur Überprüfung der korrekten Implementierung von A11y-Features.

**V. Detaillierte Spezifikation der UI-Schicht-Komponenten**

Diese Spezifikation beschreibt die Kernkomponenten der UI-Schicht, ihre Verantwortlichkeiten, Struktur und Interaktionen, basierend auf den etablierten Designzielen und Anwendungsfällen des Projekts.

**1. Modul: `ui::shell` (Implementierung der Haupt-Shell-UI)**

- **Verantwortlichkeit:** Bereitstellung der grundlegenden Rahmenstruktur und der primären Interaktionselemente des Desktops. Nutzt GTK4 und das `wlr-layer-shell-unstable-v1`-Protokoll für die korrekte Positionierung von Elementen wie Panels auf dem Bildschirm.
    
- **Unterkomponenten:**
    
    - **1.1. `ui::shell::panel` (Kontroll- und Systemleiste(n))**
        
        - **Definition:** Eine oder mehrere Leisten, deren Position (oben/unten) durch den Benutzer konfigurierbar ist. Dient als primärer Ankerpunkt für Systeminformationen und Schnellzugriffe.
        - **Struktur:** Ein `Gtk::Box`-Container, der dynamisch Abschnitte für Module (links, zentriert, rechts) bereitstellt. Das Erscheinungsbild ist durch das globale Theme bestimmt (dunkle Basis, Akzentfarben), mit optionaler Transluzenz und einem subtilen Leuchtakzent am Rand, realisiert über CSS.
        - **Kernmodule (als eigenständige GTK4-Widgets):**
            - `AppMenuButton`: Zeigt den Namen der fokussierten Anwendung und deren Anwendungsmenü. Interagiert clientseitig mit `wlr-foreign-toplevel-management` für Informationen über die aktive Anwendung und ggf. mit D-Bus (AppMenu-Spezifikation) zur Abfrage des Menüs.
            - `WorkspaceIndicatorWidget`: Integriert den `ui::shell::workspace_switcher` (siehe 1.3) oder eine kompaktere Variante davon direkt im Panel.
            - `ClockDateTimeWidget`: Zeigt Systemdatum und -uhrzeit. Ein Klick kann ein Popover mit einem Kalender-Widget (aus `ui::widgets`) und/oder einen Schnellzugriff zum `ui::shell::notification_center` öffnen.
            - `SystemTrayEquivalentWidget`: Stellt eine moderne Alternative zu traditionellen System-Tray-Icons dar, möglicherweise durch Integration mit der `org.freedesktop.StatusNotifierWatcher`-D-Bus-Schnittstelle.
            - `QuickSettingsButtonWidget`: Ein `Gtk::Button`, der bei Klick das `ui::shell::quick_settings`-Panel öffnet.
            - `NotificationCenterButtonWidget`: Ein `Gtk::Button`, der das `ui::shell::notification_center`-Panel öffnet/schließt.
            - `NetworkIndicatorWidget`: Zeigt den aktuellen Netzwerkstatus (WLAN-Signalstärke, Kabelverbindungssymbol). Bezieht Daten vom `NetworkManagerClient` der Systemschicht.
            - `PowerIndicatorWidget`: Zeigt den Akkustand (als Icon und/oder Prozentwert) und den Ladestatus. Bezieht Daten vom `UPowerClient` der Systemschicht.
            - `AudioIndicatorWidget`: Zeigt die aktuelle Systemlautstärke und den Stummschaltungsstatus. Ein Klick öffnet Lautstärkeregler und ggf. Gerätauswahl im `QuickSettingsPanel`. Bezieht Daten vom `PipeWireClient` der Systemschicht.
        - **Interaktionen:**
            - Kommuniziert mit dem Compositor (Systemschicht) über `wlr-layer-shell-unstable-v1` zur exklusiven Reservierung des Bildschirmbereichs und Positionierung.
            - Bezieht Zustandsinformationen (Netzwerk, Energie, Audio, aktuelles Theme) von den entsprechenden Diensten der Domänen- und Systemschicht.
            - Löst Aktionen aus (z.B. Öffnen des Quick-Settings-Panels) durch Weiterleitung an zuständige Handler.
        - **Styling:** Festgelegt durch das aktive, Token-basierte Theme. CSS-Klassen ermöglichen die gezielte Anpassung der Module und ihrer Zustände (z.B. :hover, :active).
    - **1.2. `ui::shell::smart_tab_bar` (Intelligente Tab-Leiste pro "Space")**
        
        - **Definition:** Eine horizontale `Gtk::Box`-basierte Leiste, die direkt im Hauptbereich jedes "Space" angezeigt wird. Sie visualisiert die dem aktuellen "Space" zugeordneten Anwendungen, insbesondere die "angepinnten" Anwendungen, als Tabs.
        - **Struktur und Verhalten:**
            - Enthält eine dynamische Liste von `ApplicationTabWidget`-Instanzen.
            - Der aktive (fokussierte) Tab wird durch die systemweite Akzentfarbe hervorgehoben.
            - Tabs sind modern gestaltet mit abgerundeten oberen Ecken.
            - Implementiert eine Überlauf-Logik (z.B. Scrollbuttons oder Dropdown-Liste), falls mehr Tabs vorhanden sind, als angezeigt werden können.
        - **`ApplicationTabWidget` (abgeleitet von `Gtk::ToggleButton` oder `Gtk::Box` mit Event-Handling):**
            - Zeigt das Icon und den Titel der Anwendung.
            - Kann spezielle Indikatoren für Split-View-Konfigurationen anzeigen (wenn mehrere Anwendungen als ein "gepinnter" Tab-Eintrag dargestellt werden).
            - Bietet ein Kontextmenü (Rechtsklick) mit Optionen wie "Fenster schließen", "An Space anpinnen/lösen", "Fenster in neuen Space verschieben".
        - **Interaktionen:**
            - Bezieht Informationen über die Struktur der "Spaces" und die darin "angepinnten" Anwendungen vom `domain::workspaces::manager`.
            - Nutzt `wlr-foreign-toplevel-management` (clientseitig über die Systemschicht), um Informationen über laufende Fenster (Titel, App-ID, Zugehörigkeit zu "Spaces") zu erhalten und den Fokus auf eine Anwendung zu setzen, wenn deren Tab angeklickt wird.
            - Die Tabs repräsentieren primär die Fenster, die dem aktuellen "Space" zugeordnet sind. "Gepinnte" Anwendungen können als persistente Tabs dargestellt werden, die bei Klick die Anwendung starten, falls sie noch nicht läuft.
        - **Styling:** Konsistent mit der Ästhetik des Panels. Akzentfarben für den aktiven Tab und Hover-Effekte.
    - **1.3. `ui::shell::workspace_switcher` (Linke Seitenleiste für Navigation & "Spaces")**
        
        - **Definition:** Eine optional einblendbare, adaptive Seitenleiste am linken Bildschirmrand, die primär der Navigation zwischen "Spaces" dient.
        - **Struktur (`Gtk::Revealer` umschließt ein `Gtk::Box`):**
            - **Eingeklappter Zustand:** Zeigt eine vertikale Liste von `SpaceIconWidget`-Instanzen. Der aktuell aktive "Space" wird visuell hervorgehoben (z.B. durch einen Indikator in Akzentfarbe).
            - **Ausgeklappter Zustand (ausgelöst durch Mouse-Over oder eine konfigurierbare Geste):** Erweitert sich, um zusätzlich zu den Icons die Namen der "Spaces" anzuzeigen. Optional können hier auch Miniaturansichten der "Spaces" oder eine kompakte Liste der darin geöffneten Fenster dargestellt werden.
            - Beinhaltet am oberen oder unteren Ende fest positionierte Elemente wie einen globalen Such-Button (der die `ui::command_palette` öffnet), einen Button zum Öffnen des Anwendungsstarters (`ui::app_launcher`) und einen Schnellzugriff zum `ui::control_center`.
        - **`SpaceIconWidget` (abgeleitet von `Gtk::Button`):**
            - Zeigt ein Icon, das den "Space" repräsentiert. Dies kann das Icon der primär "angepinnten" Anwendung, ein vom Benutzer gewähltes Symbol oder ein Standard-Workspace-Icon sein.
            - Ein Tooltip zeigt den vollständigen Namen des "Space" an.
        - **Interaktionen:**
            - Bezieht die Liste der `Workspace`-Objekte und die ID des aktiven Workspace vom `domain::workspaces::manager`.
            - Sendet bei Klick auf ein `SpaceIconWidget` einen Befehl zum Wechseln des aktiven Workspace an den `domain::workspaces::manager`.
            - Abonniert `WorkspaceEvent`s (z.B. `WorkspaceCreated`, `WorkspaceDeleted`, `ActiveWorkspaceChanged`, `WorkspaceRenamed`) vom `domain::workspaces::manager`, um seine Darstellung dynamisch zu aktualisieren.
        - **Styling:** Dunkler, dezent transluzenter Hintergrund, um sich leicht vom Desktop-Hintergrund abzuheben. Flüssige Animationen für das Ein- und Ausklappen. Klare visuelle Hervorhebung des aktiven "Space".
    - **1.4. `ui::shell::quick_settings` (Quick-Settings-Panel)**
        
        - **Definition:** Ein aus der Systemleiste (Panel) herausklappbares `Gtk::Popover` oder ein ähnliches transientes Widget, das schnellen Zugriff auf häufig benötigte Systemeinstellungen bietet.
        - **Struktur:** Ein `Gtk::Box` mit vertikaler Anordnung von Einstellungsmodulen.
        - **Module (Beispiele, als eigenständige GTK4-Widgets):**
            - WLAN-Auswahl und -Status (`Gtk::DropDown`, `Gtk::Switch`).
            - Bluetooth-Steuerung (An/Aus, Geräte koppeln via `Gtk::Switch`, `Gtk::Button`).
            - Lautstärkeregler (`Gtk::Scale`, Stummschalt-Button).
            - Dark Mode-Umschalter (`Gtk::Switch`).
            - Bildschirmhelligkeitsregler (`Gtk::Scale`).
        - **Interaktionen:**
            - Liest den aktuellen Zustand der jeweiligen Einstellungen vom `domain::global_settings_and_state_management` oder direkt von den Systemdiensten (über D-Bus-Schnittstellen der Systemschicht, z.B. `NetworkManagerClient`, `PipeWireClient`, `system::outputs` für Helligkeit).
            - Sendet Einstellungsänderungen an die entsprechenden Dienste oder den `GlobalSettingsService`.
        - **Styling:** Konsistent mit dem Panel und dem globalen dunklen Theme. Klare, leicht bedienbare Steuerelemente.
    - **1.5. `ui::shell::quick_action_dock` (Schnellaktionsdock)**
        
        - **Definition:** Ein vom Benutzer konfigurierbarer Bereich (kann schwebend oder an einem Bildschirmrand angedockt sein), der Schnellzugriffe auf favorisierte Anwendungen, häufig benötigte Dateien oder oft ausgeführte Aktionen ermöglicht.
        - **Struktur:** Implementiert als `Gtk::FlowBox` (für flexible Anordnung) oder `Gtk::Box`. Enthält eine Liste von `DockItemWidget`-Instanzen.
        - **`DockItemWidget` (abgeleitet von `Gtk::Button`):**
            - Zeigt das Icon der Anwendung/Datei oder ein Aktionssymbol.
            - Ein Tooltip zeigt den Namen oder Pfad.
            - Bietet ein Kontextmenü (Rechtsklick) für Optionen wie "Entfernen", "Eigenschaften".
        - **Interaktionen:**
            - Die Konfiguration (Inhalt, Position, Größe) wird über den `domain::global_settings_and_state_management` Service gespeichert und geladen.
            - Drag & Drop von Anwendungen (z.B. aus dem Anwendungsstarter) oder Dateien (z.B. aus dem Dateimanager) auf das Dock, um sie hinzuzufügen. Items können innerhalb des Docks neu angeordnet werden.
            - Startet Anwendungen (via `Gtk::AppInfo::launch` oder `XDG Desktop Portals` für sandboxed Apps) oder öffnet Dateien (via `Gtk::FileLauncher` oder Desktop Portals) bei Klick.
            - Potenzial für intelligente Vorschläge: Könnte mit `domain::ai` interagieren, um kontextsensitive Aktionen oder Anwendungen vorzuschlagen, basierend auf der aktuellen Aktivität oder Tageszeit des Benutzers.
        - **Styling:** Konsistent mit der Haupt-Shell-UI. Kann optional dezente Schwebeeffekte oder einen eigenen, leicht transluzenten Hintergrund haben.
    - **1.6. `ui::shell::notification_center` (Benachrichtigungszentrum)**
        
        - **Definition:** Ein Panel oder Popover (oft aus der Systemleiste zugänglich), das eine chronologische Liste der empfangenen Benachrichtigungen sowie eine Historie anzeigt.
        - **Struktur:** Ein `Gtk::ScrolledWindow`, das eine `Gtk::ListBox` enthält. Jedes Listenelement ist ein `NotificationWidget`. Bietet globale Aktionen wie "Alle Benachrichtigungen löschen" und einen Schalter für den "Bitte nicht stören"-Modus.
        - **`NotificationWidget` (abgeleitet von `Gtk::Frame` oder `Gtk::Box`):**
            - Zeigt Icon und Namen der sendenden Anwendung.
            - Stellt die Zusammenfassung (Titel) und den detaillierten Text (Body) der Benachrichtigung dar.
            - Zeigt interaktive Aktions-Buttons, falls von der Benachrichtigung bereitgestellt.
            - Zeigt den Zeitstempel des Eingangs.
            - Bietet eine Schaltfläche zum Schließen der einzelnen Benachrichtigung.
        - **Interaktionen:**
            - Ruft Methoden des `domain::user_centric_services::NotificationService` auf, um die Liste der aktiven Benachrichtigungen (`get_active_notifications`) und die Historie (`get_notification_history`) abzurufen.
            - Sendet Befehle wie `dismiss_notification` oder `invoke_action` (wenn ein Aktions-Button geklickt wird) an den `NotificationService`.
            - Reagiert auf Events wie `NotificationPostedEvent` oder `NotificationDismissedEvent` vom `NotificationService`, um die angezeigte Liste dynamisch zu aktualisieren.
        - **Styling:** Dunkles Design, klare visuelle Trennung zwischen einzelnen Benachrichtigungen. Akzentfarben können für Aktions-Buttons oder zur Hervorhebung der Dringlichkeit verwendet werden.

**2. Modul: `ui::control_center` (Zentrale Einstellungsverwaltung)**

- **Verantwortlichkeit:** Bereitstellung einer zentralen, grafischen Oberfläche für alle Systemeinstellungen der Desktop-Umgebung. Die Implementierung erfolgt mit GTK4.
- **Struktur:** Ein `Gtk::ApplicationWindow`, das eine Hauptnavigationsstruktur (z.B. eine `Gtk::StackSidebar` oder eine `Gtk::ListBox` als Seitenleiste) und einen Hauptbereich (`Gtk::Stack`) zur Anzeige der Einstellungsmodule für die ausgewählte Kategorie (z.B. "Erscheinungsbild", "Netzwerk", "Audio", "Energieverwaltung") verwendet.
- **Einstellungsmodule (Beispiele, implementiert als eigenständige GTK4-Widgets, die `Gtk::StackPage`s füllen):**
    - **`AppearanceSettingsWidget`:**
        - Theme-Auswahl: `Gtk::DropDown` zur Auswahl des aktiven Themes. Die Liste der Themes wird von `domain::theming::ThemingEngine::get_available_themes()` bezogen.
        - Farbschema-Auswahl: `Gtk::Switch` oder `Gtk::SegmentedButton` für "Hell", "Dunkel", "Automatisch".
        - Akzentfarben-Auswahl: `Gtk::ColorButton` oder ein Grid mit vordefinierten Farbpaletten, die von `ThemeDefinition::supported_accent_colors` des aktiven Themes stammen.
        - Einstellungen für Schriftarten (Familie, Größe für Standard, Monospace, Dokument), Icon-Theme, Cursor-Theme.
        - Schalter für Desktop-Animationen (`Gtk::Switch`).
        - Regler für die Skalierung der Benutzeroberfläche (`Gtk::Scale`).
        - Viele dieser Einstellungen bieten eine Live-Vorschau ihrer Auswirkungen.
    - **`NetworkSettingsWidget`:** Listet verfügbare Netzwerkadapter (LAN, WLAN). Zeigt verfügbare WLAN-Netzwerke an und ermöglicht deren Konfiguration (Passworteingabe etc.). VPN-Verwaltung.
    - **`AudioSettingsWidget`:** Auswahl von Standard-Audioein- und -ausgabegeräten. Lautstärkeregler für verschiedene Kanäle. Testmöglichkeit für Lautsprecher. Mikrofoneinstellungen.
    - **`PowerSettingsWidget`:** Konfiguration für Bildschirm-Timeout (im Akku- und Netzbetrieb), Verhalten beim Schließen des Laptop-Deckels, automatische Suspend-Zeiten. Option zur Anzeige des Batterieprozentsatzes.
    - **`MouseTouchpadSettingsWidget`:** Einstellungen für Mausbeschleunigungsprofil, Zeigerempfindlichkeit, natürliche Scrollrichtung (Maus und Touchpad), Tap-to-Click für Touchpads, Touchpad-Zeigergeschwindigkeit. Einstellungen für Tastaturwiederholungsverzögerung und -rate.
- **Interaktionen:**
    - Liest den aktuellen Zustand aller Einstellungen vom `domain::global_settings_and_state_management` Service (entweder durch Abruf des gesamten `GlobalDesktopSettings`-Objekts oder durch gezielte Abfrage einzelner Einstellungen via `GlobalSettingsService::get_setting()`).
    - Sendet geänderte Einstellungswerte über `GlobalSettingsService::update_setting()` an die Domänenschicht, wo sie validiert und persistiert werden.
    - Abonniert `SettingChangedEvent` vom `GlobalSettingsService`, um die UI-Anzeige zu aktualisieren, falls Einstellungen durch andere Mechanismen (z.B. Befehlspalette, Systemänderungen) modifiziert werden.
    - Für bestimmte systemnahe Einstellungen (z.B. sofortige Anwendung einer Netzwerkverbindung, Testton für Audio) kann eine direkte Kommunikation mit den entsprechenden D-Bus-Schnittstellen der Systemschicht erfolgen, um unmittelbares Feedback oder Aktionen auszulösen, die nicht direkt über das globale Einstellungs-Backend laufen.
- **Styling:** Muss sich nahtlos in das globale Theme der Desktop-Umgebung einfügen. Klare, intuitive und leicht verständliche Anordnung der Einstellungsoptionen.

**3. Modul: `ui::widgets` (Widget-System und Adaptive Seitenleisten)**

- **Verantwortlichkeit:** Implementierung des Systems für Desktop-Widgets, einschließlich der rechten adaptiven Seitenleiste als primären Container für diese Widgets. Stellt die Logik zum Laden, Anzeigen, Konfigurieren und Verwalten von Widgets bereit.
- **Struktur:**
    - **`RightSidebarWidget` (abgeleitet von `Gtk::Revealer` oder `Gtk::Box` mit benutzerdefinierter Ein-/Ausblendlogik):**
        - Positioniert an der rechten Bildschirmkante. Kann durch Benutzeraktion (Geste, Button) ein- und ausgeklappt werden.
        - Dient als primärer Container für eine vertikal angeordnete Liste von `PlacedWidgetWidget`-Instanzen.
        - Hat einen leicht abgesetzten, dezent transluzenten Hintergrund, um sich vom Haupt-Desktop-Inhalt zu unterscheiden.
    - **`WidgetManagerService` (kein UI-Element, sondern eine logische Komponente innerhalb der UI-Schicht oder ggf. Domänenschicht):**
        - Verantwortlich für das Entdecken und Laden verfügbarer Widgets (ggf. als Plugins implementiert).
        - Verwaltet die Konfiguration der platzierten Widgets (welche Widgets sind aktiv, in welcher Reihenfolge, ihre spezifischen Einstellungen) und speichert diese über den `domain::global_settings_and_state_management` Service.
    - **`WidgetPickerPopover` (abgeleitet von `Gtk::Popover`):** Ein Popover, das dem Benutzer eine Liste aller verfügbaren Widgets anzeigt und das Hinzufügen zur Seitenleiste per Klick oder Drag & Drop ermöglicht.
    - **`PlacedWidgetWidget` (abgeleitet von `Gtk::Frame` oder `Gtk::Box`):** Ein Standard-Wrapper-Widget, das ein `ActualWidget` enthält. Bietet gemeinsame Funktionen wie einen Rahmen, einen Titel (falls vom Widget gewünscht), eine Schaltfläche zum Entfernen des Widgets und Drag & Drop-Handles zur Neuanordnung innerhalb der Seitenleiste.
    - **`ActualWidget` (Basis-Trait oder ein Enum, das von allen konkreten Widget-Implementierungen genutzt wird):**
        - Definiert die Schnittstelle, die jedes Widget implementieren muss (z.B. `fn get_gtk_widget() -> Gtk::Widget`, `fn on_settings_changed(settings: &WidgetSettings)`).
        - **Beispiele für Standard-Widgets (jeweils als eigenständiges GTK4-Widget implementiert):**
            - `ClockWidget`: Zeigt die aktuelle Uhrzeit und optional das Datum an.
            - `CalendarWidget`: Zeigt einen Monatskalender. Klicks auf Tage könnten eine detailliertere Tagesansicht oder Termine aus einer Kalenderanwendung (via D-Bus oder `XDG Desktop Portals`) anzeigen.
            - `WeatherWidget`: Zeigt aktuelle Wetterinformationen (Temperatur, Icon, Ort) und eine kurze Vorhersage. Benötigt Netzwerkzugriff, der entweder über die Systemschicht (z.B. ein HTTP-Client-Service) oder sicher über `system::mcp` (falls eine KI-Integration für Wetterdaten genutzt wird) erfolgt.
            - `SystemMonitorWidget`: Zeigt Diagramme oder Textwerte für CPU-Auslastung, RAM-Nutzung und Netzwerkverkehr. Bezieht Daten von Systemdiensten oder durch direkten Zugriff auf Systeminformationen (z.B. `/proc`, via Systemschicht).
            - `NotesWidget`: Ein einfaches Textfeld oder eine Liste für kurze Notizen. Speichert Inhalt lokal (ggf. via `domain::global_settings_and_state_management` für einfache Notizen oder eine dedizierte kleine Datenbank/Datei für umfangreichere).
            - `WebBookmarksWidget`: Zeigt eine konfigurierbare Liste von Lesezeichen an und öffnet diese im Standardbrowser.
            - `ImageFeedWidget`: Zeigt dynamisch Bilder von einer vom Benutzer konfigurierten Quelle (lokaler Ordner, Online-Feed).
            - `ColorPaletteTrendWidget`: Zeigt aktuelle oder trendige Farbpaletten an, möglicherweise basierend auf Vorschlägen des `domain::ai` Moduls (via `system::mcp`).
- **Interaktionen:**
    - Benutzer können Widgets per Drag & Drop aus dem `WidgetPickerPopover` in die `RightSidebarWidget` ziehen oder direkt hinzufügen.
    - Widgets innerhalb der Seitenleiste können per Drag & Drop neu angeordnet werden.
    - Der `WidgetManagerService` lädt Widget-Definitionen (ggf. dynamisch als Plugins zur Laufzeit) und ist für die Instanziierung der `ActualWidget`-Implementierungen zuständig.
    - Einzelne Widgets können mit verschiedenen Diensten der Domänen- oder Systemschicht interagieren, um Daten abzurufen oder Aktionen auszuführen (z.B. das `WeatherWidget` mit einem Netzwerkdienst, das `SystemMonitorWidget` mit System-APIs).
- **Styling:** Widgets sollten ein konsistentes Erscheinungsbild innerhalb der Seitenleiste haben (z.B. ähnliche Rahmen, Abstände). Der Inhalt jedes Widgets wird individuell gestaltet, passt sich aber dem globalen Theme an.

**(Fortsetzung für `ui::window_manager_frontend`, `ui::notifications_frontend`, `ui::theming_gtk`, `ui::components`, `ui::speed_dial`, `ui::command_palette` sowie `VI. Zusammenspiel` und `VII. Deployment-Überlegungen` folgt in der nächsten Antwort, um den Rahmen nicht zu sprengen.)**

# Technische Gesamtspezifikation: Ergänzung Benutzeroberflächenschicht

Dieses Dokument ergänzt die bestehende technische Gesamtspezifikation um den detaillierten Entwurf der Benutzeroberflächenschicht (User Interface Layer).

## 4. Benutzeroberflächenschicht (User Interface Layer)

Die Benutzeroberflächenschicht ist die dem Benutzer zugewandte Komponente der Desktop-Umgebung. Sie ist verantwortlich für die visuelle Darstellung, die Entgegennahme von Benutzerinteraktionen und die Präsentation von Informationen aus den unteren Schichten.

### 4.1. Zweck und Verantwortlichkeiten

* **Visuelle Darstellung:** Erzeugung und Verwaltung aller grafischen Elemente des Desktops, einschließlich Shell, Fenster, Widgets und Dialoge.
* **Benutzerinteraktion:** Entgegennahme und Verarbeitung von Eingaben über Maus, Tastatur, Touch-Gesten und andere Eingabegeräte.
* **Zustandsvisualisierung:** Darstellung von Systemzuständen (z.B. Netzwerkkonnektivität, Akkustatus), Anwendungszuständen (z.B. aktive Fenster, Benachrichtigungen) und Konfigurationen.
* **Interaktive Steuerung:** Bereitstellung von Steuerelementen zur Bedienung der Desktop-Umgebung und ihrer Funktionen.
* **Technologische Basis:** Primäre Nutzung von GTK4 und den dazugehörigen Rust-Bindings (`gtk4-rs`). Optionale, aber empfohlene Nutzung von `libadwaita` für ein konsistentes Erscheinungsbild gemäß den Adwaita-Designrichtlinien und für den Zugriff auf spezialisierte Widgets.

### 4.2. Allgemeine Prinzipien und Entwicklungsrichtlinien der UI-Schicht

* **Technologie-Stack:**
    * **GUI-Toolkit:** GTK4.
    * **Rust-Bindings:** `gtk4-rs`.
    * **Styling & Widgets:** `libadwaita` (empfohlen für konsistentes Design und zusätzliche Widgets wie `AdwApplicationWindow`, `AdwHeaderBar`, `AdwPreferencesPage`).
    * **Programmiersprache:** Rust.
* **Reaktivität und Performance:**
    * Die Benutzeroberfläche muss stets flüssig und reaktionsschnell sein.
    * Langlaufende oder potenziell blockierende Operationen (z.B. Laden von Daten, komplexe Berechnungen) müssen asynchron ausgeführt werden, um ein Einfrieren der UI zu verhindern (z.B. mittels `glib::MainContext::spawn_local` oder `tokio` Runtime in Verbindung mit `glib`).
* **Zustandsverwaltung:**
    * Klare Trennung zwischen dem Zustand der UI-Komponenten und der Anwendungslogik in den Domänen- und Systemschichten.
    * Nutzung von Events, Signalen und dem Beobachter-Muster zur Kommunikation und Synchronisation von Zuständen zwischen den Schichten.
    * Für komplexe UI-Zustände können leichtgewichtige State-Management-Ansätze in Betracht gezogen werden.
* **Komponentenbasierte Architektur:**
    * Die UI wird aus modularen, wiederverwendbaren und möglichst voneinander unabhängigen Komponenten (Widgets, Dialoge, Ansichten) aufgebaut.
* **Theming:**
    * Tiefe Integration mit dem `domain::theming`-Modul. Design-Tokens und Stildefinitionen aus der Domänenschicht werden über GTK-CSS auf UI-Elemente angewendet.
    * Dynamische Theme-Wechsel (Hell/Dunkel, Akzentfarben) zur Laufzeit müssen unterstützt werden.
* **Accessibility (A11y – Barrierefreiheit):**
    * Strikte Einhaltung der Barrierefreiheitsrichtlinien (z.B. WCAG, soweit anwendbar).
    * Umfassende Nutzung der von GTK4 bereitgestellten Accessibility-Schnittstellen (`Accessible`, `AccessibleRole`).
    * Alle UI-Elemente müssen per Tastatur bedienbar sein und korrekte Informationen für assistive Technologien (z.B. Screenreader wie Orca) bereitstellen.
* **Internationalisierung (i18n) und Lokalisierung (l10n):**
    * Alle für den Benutzer sichtbaren Zeichenketten müssen lokalisierbar sein.
    * Bevorzugte Technologie: `gettext` in Kombination mit Tools wie `cargo-i18n` oder `fluent-rs` für komplexere Lokalisierungsanforderungen.
* **Fehlerbehandlung:**
    * Benutzerfreundliche Darstellung von Fehlern aus unteren Schichten oder UI-spezifischen Problemen (z.B. über `GtkInfoBar`, Dialoge oder Toasts).
    * Detailliertes Logging von UI-spezifischen Fehlern über das `tracing`-Framework.
* **Testbarkeit:**
    * UI-Komponenten sollen so entworfen werden, dass ihre Logik möglichst isoliert von der reinen Darstellung testbar ist.
    * Prüfung der Machbarkeit von automatisierten UI-Tests (z.B. mit `gtk4-rs`-kompatiblen Test-Frameworks, falls verfügbar, oder über Accessibility-Schnittstellen).
* **Konsistenz:**
    * Einheitliches Design, Verhalten und Terminologie über alle Teile der Benutzeroberfläche hinweg, idealerweise unter Verwendung von `libadwaita` und den Human Interface Guidelines (HIG) von GNOME als Referenz.
* **API-Design (intern):**
    * Interne APIs zwischen UI-Modulen sollten klar definiert und gut dokumentiert sein.
    * Nutzung von Rusts Typsystem zur Sicherstellung der Korrektheit.

### 4.3. Kernkomponenten der UI-Schicht

Die Benutzeroberflächenschicht wird in mehrere spezialisierte Module unterteilt, die jeweils spezifische Aspekte der UI implementieren.

#### 4.3.1. Modul: `ui::shell` (Desktop Shell)

* **Verantwortlichkeiten:** Implementierung der primären Interaktionsflächen des Desktops. Dazu gehören Panels (oben, unten, seitlich), ein optionales Dock, die "Intelligente Tab-Leiste" (pro Space/Workspace), der Workspace-Switcher, Systemstatus-Indikatoren (Netzwerk, Akku, Lautstärke, Bluetooth etc.), Uhrzeit- und Kalenderanzeige, Anwendungsstarter/Menü und das Quick Settings Panel.
* **Technologien:** GTK4, `gtk4-rs`. Für die Positionierung von Panels und Docks wird das Wayland-Protokoll `wlr-layer-shell-unstable-v1` genutzt, dessen serverseitige Implementierung in `system::compositor` erwartet wird. Die Client-seitige Ansteuerung erfolgt über entsprechende Rust-Bindings.
* **Datenstrukturen und Zustand (Beispiele):**
    * `ShellConfig`: Konfiguration der Shell-Elemente (Position, Sichtbarkeit, Inhalt).
    * `Vec<WindowInfo>`: Liste der laufenden Anwendungen und deren Fenster (bezogen von `system::compositor`, z.B. über `wlr-foreign-toplevel-management-unstable-v1`).
    * `CurrentWorkspaceInfo`, `Vec<WorkspaceInfo>`: Informationen über den aktiven Workspace und alle verfügbaren Workspaces (bezogen von `domain::workspaces`, typischerweise über die Systemschicht).
    * `SystemStatus`: Aggregierter Zustand von Systemdiensten (Netzwerk, Akku etc.), aktualisiert durch Events von `system::dbus` Clients.
* **Kernlogik:**
    * Dynamische Erstellung, Verwaltung und Aktualisierung der GTK-Widgets für alle Shell-Elemente.
    * Korrekte Positionierung und Verhalten von Layer-Surfaces (Panels, Dock) gemäß `wlr-layer-shell`-Protokoll.
    * Aktualisierung der "Intelligenten Tab-Leiste" basierend auf den Fenstern des aktiven Workspaces und deren Metadaten.
    * Implementierung des visuellen Workspace-Switchers und der Interaktion damit.
    * Bereitstellung des Anwendungsstarters (Suche, Kategorien).
    * Implementierung des Quick Settings Panels für schnellen Zugriff auf häufig benötigte Einstellungen (z.B. Lautstärke, Helligkeit, Netzwerk, Dunkelmodus).
* **Interaktionen:**
    * `system::compositor`: Empfängt Fensterlisten, Workspace-Informationen und Fokusänderungen. Sendet Anfragen zur Fensteraktivierung, Workspace-Wechsel. Nutzt das Layer-Shell-Protokoll zur Platzierung von UI-Elementen.
    * `domain::workspaces` (via Systemschicht): Zeigt Workspace-Informationen an und initiiert Workspace-bezogene Operationen (Wechsel, Erstellung etc.).
    * `domain::theming` (via `ui::theming_gtk`): Wendet Theme-Änderungen auf alle Shell-Elemente an.
    * `system::dbus` (Clients): Empfängt kontinuierlich Status-Updates (Netzwerk, Akku, Audio, etc.) und zeigt diese an.
    * Benutzer: Direkte Interaktion über Klicks, Tastatureingaben für Starter, Menüs, Quick Settings und Fenster-Tabs.
* **Fehlerbehandlung:** Stabile Anzeige auch bei fehlenden oder fehlerhaften Daten von unteren Schichten (z.B. Anzeige von Platzhaltern oder Standardwerten). Logging von Fehlern bei der Kommunikation mit dem Compositor oder D-Bus-Diensten.
* **Theming:** Alle Shell-Elemente sind vollständig über GTK CSS und die Design-Tokens aus `domain::theming` anpassbar.

#### 4.3.2. Modul: `ui::control_center` (Einstellungszentrale)

* **Verantwortlichkeiten:** Bereitstellung einer zentralen grafischen Oberfläche zur Ansicht und Modifikation aller Desktop-Einstellungen. Dies umfasst typischerweise Bereiche wie Erscheinungsbild (Themes, Schriftarten, Hintergrund), Workspaces, Eingabegeräte (Maus, Tastatur, Touchpad), Netzwerkverbindungen, Energieoptionen, Standardanwendungen, Benutzerkonten, Datum/Uhrzeit, Barrierefreiheit etc.
* **Technologien:** GTK4, `gtk4-rs`. Dringend empfohlen: `libadwaita` für eine konsistente Struktur (`AdwApplicationWindow`, `AdwPreferencesPage`, `AdwPreferencesGroup`, `AdwActionRow`, `AdwEntryRow` etc.) und ein ansprechendes Design.
* **Datenstrukturen und Zustand (Beispiele):**
    * `SettingsViewModel`: Repräsentation der Einstellungsstruktur und der aktuellen Werte, synchronisiert mit `domain::global_settings_and_state_management`.
    * Zwischenspeicherung von Änderungen vor dem Anwenden.
* **Kernlogik:**
    * Dynamisches Erstellen von Einstellungsseiten und -gruppen basierend auf den in `domain::global_settings_and_state_management` definierten Einstellungsmodulen und -pfaden.
    * Zwei-Wege-Bindung von UI-Steuerelementen (z.B. Schalter, Slider, Dropdowns) an die entsprechenden Einstellungswerte.
    * Echtzeit-Validierung von Benutzereingaben gemäß den Metadaten der Einstellungen (z.B. Wertebereiche, Regex).
    * Anwenden und Speichern von geänderten Einstellungen über die API von `domain::global_settings_and_state_management`.
    * Reaktion auf externe Einstellungsänderungen zur Aktualisierung der UI.
* **Interaktionen:**
    * `domain::global_settings_and_state_management`: Liest aktuelle Einstellungswerte und Metadaten. Schreibt geänderte Einstellungswerte. Abonniert `SettingChangedEvent` zur dynamischen Aktualisierung der angezeigten Werte.
    * `domain::theming`: Stellt die UI zur Auswahl von Themes, Farbschemata und Akzentfarben bereit, interagiert mit `ThemingEngine`.
    * `system::outputs`: Stellt die UI zur Konfiguration von Monitoren (Auflösung, Skalierung, Anordnung) bereit, interagiert mit `OutputManager`.
    * `system::input`: Stellt die UI zur Konfiguration von Tastatur (Layouts, Wiederholrate), Maus (Zeigergeschwindigkeit, Tastenbelegung) und Touchpad (Gesten, Scrollrichtung) bereit.
    * `system::audio`: Stellt die UI zur Konfiguration von Audiogeräten (Ein-/Ausgabegeräte, Lautstärken) bereit.
    * Benutzer: Navigation durch die Einstellungsseiten, Modifikation von Werten über die bereitgestellten Steuerelemente.
* **Fehlerbehandlung:** Klare Anzeige von Validierungsfehlern direkt an den Eingabefeldern. Informative Meldungen bei Fehlern während des Speicherns oder Ladens von Einstellungen.
* **Theming:** Das Control Center selbst nutzt das globale Theme. Die Vorschau-Elemente für Theme-Einstellungen müssen das jeweils ausgewählte Theme korrekt widerspiegeln.

#### 4.3.3. Modul: `ui::widgets_system` (Widget-System und Seitenleiste/Dashboard)

* **Verantwortlichkeiten:** Verwaltung, Konfiguration und Anzeige von Desktop-Widgets. Dies kann in einer dedizierten Seitenleiste, einem Dashboard-Modus oder als frei platzierbare Elemente geschehen. Bereitstellung einer API für Drittanbieter-Widgets.
* **Technologien:** GTK4, `gtk4-rs`.
* **Datenstrukturen und Zustand (Beispiele):**
    * `AvailableWidgetsRegistry`: Verzeichnis aller installierten und verfügbaren Widgets.
    * `ActiveWidgetInstance`: Zustand und Konfiguration eines spezifischen, vom Benutzer hinzugefügten Widgets.
    * `WidgetLayoutConfig`: Speichert Anordnung und Sichtbarkeit der Widgets.
* **Kernlogik:**
    * Mechanismus zum dynamischen Laden von Widget-Definitionen (ggf. als separate Crates/Plugins, die ein definiertes Trait implementieren).
    * Bereitstellung einer UI zur Auswahl, Hinzufügung, Entfernung und Konfiguration von Widgets durch den Benutzer.
    * Anzeige der aktiven Widgets im vorgesehenen Container (z.B. Seitenleiste).
    * Unterstützung für Drag & Drop zur Anordnung von Widgets.
    * Kommunikation mit Datenquellen für Widgets (z.B. Abruf von Wetterdaten über eine API, Auslesen von Systeminformationen, Zugriff auf Kalenderdaten).
    * Implementierung von Standard-Widgets:
        * `ClockWidget`: Anzeige von Uhrzeit und Datum.
        * `CalendarWidget`: Monatsansicht, Termine.
        * `WeatherWidget`: Aktuelles Wetter und Vorhersage.
        * `SystemMonitorWidget`: CPU-, RAM-, Netzwerkauslastung.
        * `NotesWidget`: Einfache Notizen.
* **Interaktionen:**
    * `domain::global_settings_and_state_management`: Speichert die Konfiguration des Widget-Systems und der einzelnen Widgets.
    * Externe Dienste/APIs: Für datengetriebene Widgets (z.B. Wetter-API, Nachrichten-Feeds).
    * `system::*`: Für Widgets, die Systeminformationen anzeigen.
    * Benutzer: Hinzufügen, Entfernen, Anordnen und Konfigurieren von Widgets. Interaktion mit den Widgets selbst.
* **Fehlerbehandlung:** Fehlerhafte oder abstürzende Widgets sollten isoliert werden, ohne das gesamte Widget-System oder den Desktop zu beeinträchtigen. Klare Fehlermeldungen bei Problemen mit dem Laden von Widgets oder dem Abrufen von Widget-Daten.
* **Theming:** Widgets müssen sich nahtlos in das globale Desktop-Theme einfügen und idealerweise über GTK CSS anpassbar sein.

#### 4.3.4. Modul: `ui::window_manager_frontend` (Fenstermanagement-UI)

* **Verantwortlichkeiten:** Bereitstellung von UI-Elementen und Interaktionen, die direkt mit der Verwaltung von Anwendungsfenstern zusammenhängen und über die reine Darstellung in der Shell hinausgehen.
    * **Client-Seitige Dekorationen (CSD):** Zeichnen und Verwalten von Fensterdekorationen (Titelleiste, Minimieren-, Maximieren-, Schließen-Buttons) für Anwendungen, falls der Compositor dies via `xdg-decoration-unstable-v1` an den Client delegiert.
    * **Fensterwechsler-UI:** Implementierung der UI für den schnellen Wechsel zwischen offenen Fenstern (z.B. der klassische "Alt+Tab"-Dialog).
    * **Übersichtsmodus:** Implementierung einer "Exposé"-artigen Ansicht, die alle Fenster des aktuellen Workspaces (oder optional aller Workspaces) als skalierte Vorschauen anzeigt und eine Auswahl per Klick oder Tastatur ermöglicht.
    * **Snapping/Tiling-Hilfen:** Visuelle Hinweise und Vorschau-Bereiche beim Verschieben oder Skalieren von Fenstern, um das Andocken oder Kacheln zu erleichtern (in Zusammenarbeit mit der Logik aus `domain::window_management` und `system::compositor`).
* **Technologien:** GTK4, `gtk4-rs`. Enge Interaktion mit `system::compositor` für Fensterinformationen (Position, Größe, Metadaten, Vorschau-Puffer) und Steuerung. Nutzung von `xdg-decoration-unstable-v1` (Client-Seite) und `wlr-foreign-toplevel-management-unstable-v1` (Client-Seite).
* **Datenstrukturen und Zustand (Beispiele):**
    * `WindowListCache`: Zwischengespeicherte Liste aller bekannten Anwendungsfenster mit relevanten Metadaten (Titel, App-ID, Icon, ggf. eine kleine Vorschau-Textur vom Compositor).
    * `ActiveSwitcherState`: Zustand des aktuellen Fensterwechslers (z.B. ausgewähltes Fenster im Alt+Tab-Dialog).
    * `OverviewLayout`: Anordnung der Fenster im Übersichtsmodus.
* **Kernlogik:**
    * Für CSDs: Erstellung eines `GtkHeaderBar` oder äquivalenter Widgets, Integration der Fenstersteuerungsbuttons, Anzeige des Fenstertitels und -icons. Verarbeitung von Mausinteraktionen auf der Titelleiste (z.B. Fenster verschieben).
    * Für den Fensterwechsler: Anzeige eines modalen Dialogs oder Overlays mit einer Liste/einem Raster von Fenstervorschauen. Navigation per Tastatur (Tab, Pfeiltasten) und Maus.
    * Für den Übersichtsmodus: Animationen zum Ein- und Ausblenden. Dynamische Anordnung der Fenstervorschauen. Interaktion per Klick zur Auswahl eines Fensters oder per Drag & Drop zum Verschieben zwischen Workspaces (falls unterstützt).
* **Interaktionen:**
    * `system::compositor`: Empfängt kontinuierlich aktualisierte Fensterdaten (Liste, Geometrie, Zustand, Fokus). Sendet Befehle an den Compositor (Fokus setzen, Fenster aktivieren, minimieren, maximieren, schließen, verschieben, Größe ändern).
    * `domain::window_management` (via Systemschicht): Erhält Informationen über Tiling-Layouts oder Snapping-Zonen, um entsprechende UI-Hilfen anzuzeigen.
    * Benutzer: Tastenkombinationen (z.B. Alt+Tab, Super+S für Übersicht), Mausinteraktionen in der Übersicht oder auf CSDs.
* **Fehlerbehandlung:** Stabile Darstellung auch bei inkonsistenten oder fehlenden Fensterinformationen vom Compositor. Graceful Degradation von Funktionen, falls bestimmte Wayland-Protokolle nicht verfügbar sind.
* **Theming:** CSDs, Fensterwechsler und der Übersichtsmodus müssen vollständig thematisierbar sein.

#### 4.3.5. Modul: `ui::notifications_frontend` (Benachrichtigungsanzeige)

* **Verantwortlichkeiten:** Visuelle Darstellung von Desktop-Benachrichtigungen. Bereitstellung eines Benachrichtigungszentrums oder -verlaufs. Ermöglichung der Interaktion mit Aktionen, die in Benachrichtigungen enthalten sind.
* **Technologien:** GTK4, `gtk4-rs`. `libadwaita` kann für konsistente Toasts (`AdwToast`) und Listen im Benachrichtigungszentrum verwendet werden. Die Kommunikation erfolgt über D-Bus durch Lauschen auf Signale des `org.freedesktop.Notifications`-Dienstes (dessen serverseitige Logik in `domain::notifications_core` und die D-Bus-Exposition in `system::dbus` liegen könnte).
* **Datenstrukturen und Zustand (Beispiele):**
    * `ActiveNotificationsList`: Liste der aktuell angezeigten oder kürzlich empfangenen Benachrichtigungen.
    * `NotificationHistory`: Längerfristiger Verlauf von Benachrichtigungen (ggf. mit Filter- und Suchfunktion).
    * `DoNotDisturbState`: Aktueller "Nicht stören"-Status.
* **Kernlogik:**
    * Registrierung beim `org.freedesktop.Notifications`-Dienst, um neue Benachrichtigungen (`Notify` Signal) und Schließ-Events (`NotificationClosed` Signal) zu empfangen.
    * Anzeige von transienten Benachrichtigungen als Popups oder Toasts (z.B. am Bildschirmrand).
    * Implementierung eines Benachrichtigungszentrums (z.B. als Teil der Quick Settings oder als separate Seitenleiste), das eine Liste aller (oder relevanter) Benachrichtigungen anzeigt.
    * Darstellung von Aktionen (Buttons) innerhalb von Benachrichtigungen und Weiterleitung der Aktionsauslösung (`ActionInvoked` Signal) an den Benachrichtigungsdienst.
    * Verwaltung des "Gelesen"-Status von Benachrichtigungen.
* **Interaktionen:**
    * `system::dbus` (als Client des `org.freedesktop.Notifications` Dienstes): Empfängt Benachrichtigungsdaten. Sendet Signale zum Schließen von Benachrichtigungen oder zum Auslösen von Aktionen.
    * `domain::notifications_core` (indirekt über D-Bus): Liefert die Inhalte und Regeln für Benachrichtigungen.
    * Benutzer: Klick auf Benachrichtigungen, Interaktion mit Aktionsbuttons, Schließen von Benachrichtigungen, Öffnen und Verwalten des Benachrichtigungszentrums.
* **Fehlerbehandlung:** Korrekte und sichere Anzeige auch bei fehlerhaft formatierten oder potenziell schädlichen Daten in Benachrichtigungen (z.B. Sanitization von HTML, falls unterstützt). Stabile Funktion auch bei hoher Benachrichtigungsfrequenz.
* **Theming:** Das Aussehen von Benachrichtigungs-Popups und des Benachrichtigungszentrums ist über GTK CSS anpassbar.

#### 4.3.6. Modul: `ui::theming_gtk` (GTK Theming-Integration)

* **Verantwortlichkeiten:** Konkrete Anwendung der von `domain::theming` (ThemingEngine) aufgelösten Design-Tokens und Stildefinitionen auf alle GTK4-basierten UI-Komponenten der Desktop-Umgebung. Laden und dynamisches Wechseln von GTK-Themes (CSS-Dateien) zur Laufzeit.
* **Technologien:** GTK4 (`GtkCssProvider`, `GtkStyleContext`), `gtk4-rs`.
* **Kernlogik:**
    * Abonnieren des `ThemeChangedEvent` (oder eines äquivalenten Signals/Callbacks) von `domain::theming::ThemingEngine`.
    * Bei Empfang eines `ThemeChangedEvent`:
        * Abrufen des neuen `AppliedThemeState` (inklusive der aufgelösten Tokens als CSS-Variablen oder einer generierten CSS-Datei).
        * Erstellen eines neuen `GtkCssProvider`.
        * Laden der CSS-Daten (entweder direkt die generierten CSS-Variablen und -Regeln oder eine Pfadangabe zu einer CSS-Datei) in den `GtkCssProvider` mittels `load_from_data()` oder `load_from_path()`.
        * Entfernen des alten `GtkCssProvider` vom `GdkDisplay` und Hinzufügen des neuen Providers mittels `GtkStyleContext::add_provider_for_display()`. Dies löst eine Aktualisierung aller GTK-Widgets aus.
    * Falls `libadwaita` verwendet wird: Interaktion mit `AdwStyleManager` zum Umschalten zwischen Hell-, Dunkel- und Hochkontrast-Modi und zur Verwaltung der Akzentfarbe, falls diese nicht rein über CSS gesteuert wird.
* **Interaktionen:**
    * `domain::theming::ThemingEngine`: Empfängt Benachrichtigungen über Theme-Änderungen und die zugehörigen Styling-Daten.
    * GTK4-System: Interagiert mit `GdkDisplay` und `GtkStyleContext`, um das CSS global anzuwenden.
    * Alle anderen `ui::*` Module: Werden durch die Änderungen im globalen CSS automatisch neu gestylt.
* **Fehlerbehandlung:** Implementierung eines Fallback-Mechanismus auf ein Standard-GTK-Theme (z.B. Adwaita default), falls die vom `ThemingEngine` bereitgestellten CSS-Daten fehlerhaft sind oder nicht geladen werden können. Logging solcher Fehler.

#### 4.3.7. Modul: `ui::command_palette` (Befehlspalette)

* **Verantwortlichkeiten:** Bereitstellung einer schnell zugänglichen, textbasierten Befehlspalette (ähnlich wie in VS Code oder Spotlight unter macOS) für den schnellen Zugriff auf eine Vielzahl von Aktionen, Anwendungen, Einstellungen, Dateien und potenziell KI-gestützten Funktionen.
* **Technologien:** GTK4, `gtk4-rs`.
* **Datenstrukturen und Zustand (Beispiele):**
    * `CommandRegistry`: Dynamisch befülltes Verzeichnis aller verfügbaren Befehle, kategorisiert und mit Metadaten (Name, Beschreibung, Icon, auszuführende Aktion) versehen.
    * `SearchResultList`: Gefilterte und sortierte Liste der Befehle basierend auf der Benutzereingabe.
* **Kernlogik:**
    * Öffnen der Befehlspalette über eine globale Tastenkombination (definiert in `system::input` und weitergeleitet an die UI).
    * Dynamische Aggregation von Befehlen aus verschiedenen Quellen:
        * Installierte Anwendungen (aus `.desktop`-Dateien).
        * Aktionen der Shell (z.B. "Neues Fenster", "Workspace wechseln").
        * Direktzugriff auf spezifische Einstellungsseiten im `ui::control_center`.
        * Dateisuche (Integration mit einem Dateisuchindex wie Tracker oder einer einfacheren Implementierung).
        * KI-Aktionen, bereitgestellt über `system::mcp` (z.B. "Fasse Text zusammen", "Übersetze Satz").
    * Implementierung einer effizienten Fuzzy-Suche und Filterung der Befehle in Echtzeit während der Benutzereingabe.
    * Ausführung der vom Benutzer ausgewählten Aktion (kann das Starten einer Anwendung, das Aufrufen einer internen Funktion, das Senden eines D-Bus-Befehls oder eine MCP-Anfrage umfassen).
    * Kontextsensitivität: Die angebotenen Befehle können sich je nach aktivem Fenster oder Zustand des Desktops ändern.
* **Interaktionen:**
    * `ui::shell`: Registriert Shell-spezifische Aktionen.
    * `ui::control_center`: Registriert Direktzugriffe auf Einstellungsseiten.
    * `system::mcp`: Stellt KI-gestützte Aktionen und potenziell Suchergebnisse bereit.
    * Dateisystem/Suchindex: Für die Dateisuche.
    * Anwendungsstarter-Logik: Zum Starten von Anwendungen.
    * Benutzer: Eingabe von Suchbegriffen, Auswahl von Befehlen per Tastatur oder Maus.
* **Fehlerbehandlung:** Klare Rückmeldung, falls keine passenden Befehle gefunden werden. Fehlerbehandlung und -anzeige bei Problemen während der Ausführung eines ausgewählten Befehls.
* **Theming:** Die Befehlspalette ist über GTK CSS thematisierbar.

#### 4.3.8. Modul: `ui::speed_dial` (Schnellstart-Ansicht)

* **Verantwortlichkeiten:** Anzeige einer Schnellstart-Seite oder eines "Neuer Tab"-Äquivalents, typischerweise beim Start einer neuen Sitzung oder eines neuen Fensters (falls anwendbar). Diese Ansicht kann häufig genutzte Anwendungen, Lesezeichen, kürzlich geöffnete Projekte oder andere für den Benutzer relevante Informationen enthalten.
* **Technologien:** GTK4, `gtk4-rs`.
* **Datenstrukturen und Zustand (Beispiele):**
    * `SpeedDialItemList`: Konfigurierbare und/oder dynamisch (lernbasiert) erstellte Liste der anzuzeigenden Schnellstart-Elemente.
    * `LayoutConfiguration`: Einstellungen zur Darstellung (Raster, Liste, Icongrößen).
* **Kernlogik:**
    * Anzeige der Schnellstart-Elemente in einem ansprechenden Layout (z.B. Raster von Icons mit Beschriftungen).
    * Ermöglichen des Hinzufügens, Entfernens und Anordnens von Elementen durch den Benutzer (Drag & Drop).
    * Potenzielle Integration mit dem Browser-Verlauf/Lesezeichen, dem Dateisystem (kürzliche Dateien/Projekte) oder Projektmanagement-Tools.
    * Lernalgorithmus zur Priorisierung oder Vorschlag von Elementen basierend auf Nutzungshäufigkeit.
* **Interaktionen:**
    * Benutzer: Klick auf Elemente zum Starten einer Anwendung oder Öffnen einer Datei/URL. Konfiguration der angezeigten Elemente und des Layouts.
    * Anwendungsstarter-Logik, Dateisystem-APIs.
* **Theming:** Die Schnellstart-Ansicht ist an das globale Desktop-Theme anpassbar.

#### 4.3.9. Modul: `ui::common_components` (Wiederverwendbare UI-Komponenten)

* **Verantwortlichkeiten:** Entwicklung und Bereitstellung einer Sammlung von anwendungsspezifischen, aber über verschiedene UI-Module hinweg wiederverwendbaren GTK4-Widgets und UI-Bausteinen. Ziel ist die Reduktion von Code-Duplikation und die Sicherstellung eines konsistenten Erscheinungsbilds und Verhaltens.
* **Beispiele:**
    * `ValidatedEntry`: Ein `GtkEntry`-Wrapper mit integrierter Validierungslogik und -anzeige.
    * `IconLabelButton`: Ein Button mit Icon und Text, der spezifische Styling- oder Verhaltensanforderungen erfüllt.
    * `PannableZoomableImageWidget`: Ein Widget zur Anzeige von Bildern mit Pan- und Zoom-Funktionalität.
    * Spezialisierte Layout-Container oder Listenelemente.
* **Technologien:** GTK4, `gtk4-rs`. Erstellung als `GtkWidget` Subklassen oder Composite Widgets.
* **Kernlogik:** Jede Komponente kapselt ihre spezifische Logik und Darstellung. Sie sollten gut dokumentiert und mit Beispielen versehen sein.
* **Interaktionen:** Werden von anderen UI-Modulen (`ui::shell`, `ui::control_center` etc.) instanziiert und verwendet.
* **Theming:** Die Komponenten müssen so gestaltet sein, dass sie das globale Theming respektieren und über GTK CSS angepasst werden können.

#### 4.3.10. Modul: `ui::input_handling` (UI-spezifische Eingabelogik)

* **Verantwortlichkeiten:** Verarbeitung von UI-spezifischen Tastenkombinationen (Shortcuts), die nicht global vom Compositor (`system::input`), sondern von der gerade aktiven UI-Komponente oder der Desktop-Anwendung als Ganzes behandelt werden sollen. Implementierung von UI-internen Gesten (z.B. Swipes in Listenansichten, Pinch-to-Zoom in einem Bildbetrachter-Widget innerhalb einer Anwendung).
* **Technologien:** GTK4 Event-Controller (`GtkGestureClick`, `GtkGestureDrag`, `GtkEventControllerKey`, `GtkShortcutManager`, `GtkShortcutsWindow`), `gtk4-rs`.
* **Kernlogik:**
    * Definition und Registrierung von UI-Aktionen und den zugehörigen Shortcuts über `GtkApplication::set_accels_for_action()` oder `GtkShortcutManager`.
    * Implementierung von Gestenerkennung für spezifische Widgets mittels GTK4 Event-Controllern.
    * Weiterleitung von verarbeiteten Eingabeereignissen an die entsprechenden Handler-Funktionen innerhalb der UI-Komponenten, um UI-spezifische Aktionen auszulösen.
    * Bereitstellung einer Hilfsansicht (z.B. über `GtkShortcutsWindow`) zur Anzeige aller verfügbaren Tastenkombinationen.
* **Interaktionen:**
    * GTK4-Framework: Empfängt rohe Eingabeereignisse vom Compositor und leitet sie an die Event-Controller und das Shortcut-Management weiter.
    * Andere `ui::*` Module: Definieren Aktionen und reagieren auf deren Auslösung durch Shortcuts oder Gesten.

#### 4.3.11. Modul: `ui::accessibility` (Barrierefreiheit)

* **Verantwortlichkeiten:** Zentralisierte Bemühungen und Richtlinien zur Sicherstellung, dass alle UI-Komponenten den etablierten Barrierefreiheitsstandards (z.B. WCAG AA als Ziel) entsprechen. Bereitstellung aller notwendigen Informationen und Schnittstellen für assistive Technologien (AT).
* **Technologien:** GTK4 Accessibility APIs (Implementierung des `GtkAccessible` Interfaces, Nutzung von `AtkObject` bzw. dessen Nachfolger-APIs), `gtk4-rs`. Testwerkzeuge wie `accerciser` und Screenreader wie Orca.
* **Kernlogik:**
    * Für alle benutzerdefinierten Widgets: Korrekte Implementierung der `GtkAccessible` Methoden, insbesondere die Zuweisung der korrekten `AccessibleRole`.
    * Sicherstellung, dass alle interaktiven Elemente zugängliche Namen (accessible names) und ggf. Beschreibungen (accessible descriptions) haben, die ihren Zweck und Zustand klar kommunizieren.
    * Gewährleistung einer vollständigen und logischen Tastaturnavigation für alle interaktiven UI-Elemente.
    * Ausreichender Farbkontrast gemäß den Richtlinien.
    * Unterstützung für Hochkontrast-Themes.
    * Regelmäßige Tests mit Screenreadern und anderen assistiven Technologien.
* **Interaktionen:**
    * Assistive Technologien (z.B. Orca): Greifen auf die von den GTK-Widgets bereitgestellten Accessibility-Informationen zu, um die UI für Benutzer mit Einschränkungen interpretierbar und bedienbar zu machen.
    * Alle anderen `ui::*` Module: Müssen bei der Implementierung ihrer Widgets die Accessibility-Anforderungen berücksichtigen.

#### 4.3.12. Modul: `ui::state_management` (UI-Zustandsverwaltung)

* **Verantwortlichkeiten:** Definition und Implementierung konsistenter Muster und Mechanismen zur Verwaltung des UI-Zustands und dessen Synchronisation mit den Daten und der Logik der Domänen- und Systemschichten. Dies ist besonders wichtig für komplexe UIs, um Datenkonsistenz zu gewährleisten und die Codebasis wartbar zu halten.
* **Technologien und Muster:**
    * Rust-Idiome: `Arc<Mutex<T>>` oder `Arc<RwLock<T>>` für sicher geteilten, veränderlichen Zustand.
    * Asynchrone Kanäle: `tokio::sync::watch` für "single producer, multiple consumer" Zustandsverteilung oder `tokio::sync::broadcast` für allgemeine Event-Benachrichtigungen, die Zustandsänderungen signalisieren.
    * Beobachter-Muster (Observer Pattern): UI-Komponenten registrieren sich bei Datenquellen (aus der Domänen- oder Systemschicht) und werden bei Änderungen benachrichtigt.
    * Model-View-ViewModel (MVVM) Anleihen: Trennung von UI (View), UI-Logik und Zustandspräsentation (ViewModel) und den eigentlichen Daten (Model in der Domänenschicht).
    * Nutzung von `glib::Object` Signalen für die Kommunikation zwischen GTK-Widgets und der Rust-Logik.
* **Kernlogik:**
    * Bereitstellung von Mechanismen, damit UI-Komponenten reaktiv auf Änderungen in der Domänen- oder Systemschicht reagieren können (z.B. automatische Aktualisierung einer Liste in der UI, wenn sich die zugrundeliegenden Daten in der Domänenschicht ändern).
    * Verwaltung von reinem UI-Zustand (z.B. ob ein Dropdown-Menü gerade geöffnet ist, der Scroll-Zustand einer Liste), der nicht in den unteren Schichten persistiert werden muss.
    * Sicherstellung der Datenkonsistenz zwischen der UI und den Backend-Schichten, insbesondere bei nebenläufigen Änderungen.
    * Abstraktion der Komplexität der direkten Interaktion mit nebenläufigen Primitiven für einzelne UI-Komponenten.
* **Interaktionen:**
    * Alle `ui::*` Module: Nutzen die bereitgestellten Zustandsverwaltungsmechanismen, um ihren eigenen Zustand zu verwalten und auf Änderungen von außen zu reagieren.
    * Domänen- und Systemschicht: Dienen als primäre Quelle für den Zustand, der in der UI dargestellt und modifiziert wird. Änderungen werden über definierte Schnittstellen (Events, Callbacks, Kanäle) an die UI-Schicht kommuniziert.

### 4.4. Interaktion mit anderen Schichten

Die UI-Schicht ist naturgemäß stark mit den darunterliegenden Schichten verbunden:

* **Interaktion mit der Systemschicht (`system::*`):**
    * **Empfängt:**
        * Fensterinformationen (Liste, Titel, App-ID, Fokus, Geometrie) von `system::compositor` (z.B. über `wlr-foreign-toplevel-management`).
        * Eingabeereignisse, die vom `system::compositor` und `system::input` an die fokussierte Anwendung (also die UI-Shell selbst oder andere Desktop-Komponenten) weitergeleitet werden.
        * Systemstatus-Events (z.B. Output-Änderungen von `system::outputs`, D-Bus-Signale von `system::dbus` für Netzwerk, Energie, Audio etc.).
        * Informationen über verfügbare MCP-Ressourcen oder Antworten von `system::mcp`.
    * **Sendet:**
        * Befehle an `system::compositor` (z.B. Fensterfokus ändern, Fenster verschieben/skalieren, Workspace wechseln, Layer-Surface-Konfiguration für `ui::shell`).
        * Befehle an D-Bus-Dienste über `system::dbus` (z.B. Lautstärke ändern, Netzwerkverbindung herstellen, Einstellungen ändern, die Systemdienste betreffen).
        * Anfragen an `system::mcp` für KI-Funktionen.
        * Anfragen an `system::portals` zur Durchführung von Aktionen im Namen von Anwendungen (z.B. Datei öffnen Dialog).
* **Interaktion mit der Domänenschicht (`domain::*`):**
    * **Liest (oft indirekt über Systemschicht-APIs oder dedizierte Services):**
        * Aktuelle Theme-Definitionen und aufgelöste Tokens von `domain::theming`.
        * Workspace-Konfigurationen und -zustände von `domain::workspaces`.
        * Globale Einstellungen von `domain::global_settings_and_state_management`.
        * Benachrichtigungslisten und -verläufe von `domain::notifications_core`.
        * KI-Einwilligungsstatus von `domain::user_centric_services::ai_interaction_service`.
    * **Löst Aktionen aus / Schreibt Daten (oft indirekt):**
        * Anforderung eines Theme-Wechsels an `domain::theming`.
        * Speichern von geänderten Einstellungen an `domain::global_settings_and_state_management`.
        * Markieren von Benachrichtigungen als gelesen oder Auslösen von Aktionen an `domain::notifications_core`.
        * Änderung des Workspace-Layouts oder Umbenennung an `domain::workspaces`.
    * **Abonniert Events:**
        * `ThemeChangedEvent` von `domain::theming` zur Aktualisierung des UI-Stylings.
        * `WorkspaceEvent` (z.B. `WorkspaceCreated`, `ActiveWorkspaceChanged`) von `domain::workspaces`.
        * `SettingChangedEvent` von `domain::global_settings_and_state_management`.
        * `NotificationEvent` (z.B. `NotificationPostedEvent`) von `domain::notifications_core`.
        * `AIConsentUpdatedEvent` von `domain::user_centric_services::ai_interaction_service`.
* **Interaktion mit der Kernschicht (`core::*`):**
    * Nutzt grundlegende Datentypen (`core::types` wie `Color`, `Rect`, `Point`, `Size`), sofern diese für UI-Berechnungen oder die Kommunikation mit anderen Schichten relevant sind.
    * Verwendet die Fehlerbehandlungsmechanismen (`core::errors`), um Fehler aus unteren Schichten zu verarbeiten oder eigene UI-spezifische Fehler zu definieren, die von `CoreError` abgeleitet sein können.
    * Nutzt die Logging-Infrastruktur (`core::logging` bzw. das `tracing`-Framework) für detailliertes Logging von UI-Aktivitäten und Fehlern.

Diese detaillierte Spezifikation der Benutzeroberflächenschicht sollte eine solide Grundlage für die weitere Entwicklung und Implementierung bieten.


---


---

## 1. Allgemeine Vorbemerkungen zur Implementierung

- **Rust Edition:** Es wird die jeweils aktuell stabile Rust-Edition zum Zeitpunkt der Implementierung verwendet (aktuell Rust 2021, potenziell Rust 2024, falls bis dahin relevant).
- **Abhängigkeitsmanagement:** Cargo wird für das Abhängigkeitsmanagement verwendet. Versionen von Abhängigkeiten sollten sorgfältig gewählt und bei Bedarf über `Cargo.lock` fixiert werden, um reproduzierbare Builds sicherzustellen. Es wird empfohlen, `cargo update -p <crate_name>` für gezielte Updates zu verwenden.
- **Asynchrone Runtime:** Wo nicht anders spezifiziert (z.B. für GTK-spezifische Aufgaben), wird `tokio` als primäre asynchrone Runtime für I/O-gebundene Operationen und Nebenläufigkeit verwendet, insbesondere in der System- und UI-Schicht.
- **Fehlerbehandlung (Globale Konvention):** Die Verwendung von `thiserror` für spezifische Fehler-Enums pro Modul und die Weitergabe von Fehlern über `Result<T, E>` ist verbindlich. Panics sind strikt zu vermeiden, außer in Tests oder bei nachweislich nicht behebbaren internen Invariantenverletzungen mit aussagekräftiger Begründung. Die `source()`-Kette von Fehlern muss erhalten bleiben.
- **Logging (Globale Konvention):** Das `tracing`-Framework ist für strukturiertes, kontextbezogenes Logging verbindlich. Sensible Daten dürfen niemals geloggt werden.
- **Code-Formatierung und Linting:** `rustfmt` mit Projektstandardkonfiguration und `clippy` (mit `-D warnings`) sind bei jedem Commit/Push obligatorisch und werden durch CI erzwungen.
- **Dokumentation:** Umfassende `rustdoc`-Kommentare für alle öffentlichen APIs sind zwingend erforderlich.
- **Tests:** Unit-Tests (`#[cfg(test)] mod tests { ... }`) müssen parallel zur Implementierung geschrieben werden und eine hohe Codeabdeckung anstreben. Integrationstests (`tests/integration_test.rs`) sind für das Zusammenspiel von Modulen/Crates vorzusehen.

---

## 2. Ultra-Feinspezifikation: Kernschicht (Core Layer)

Die Kernschicht (`novade-core` Crate) enthält die absolut grundlegendsten, systemweit genutzten Elemente und hat keine Abhängigkeiten zu anderen Schichten von NovaDE.

### Modul: `core::types` (Fundamentale Datentypen)

**Zweck:** Definition grundlegender, universell einsetzbarer Datentypen für Geometrie, Farben und allgemeine Enumerationen. Diese Typen sind reine Datenstrukturen ohne komplexe Geschäftslogik.

**Designphilosophie:** Modularität, Wiederverwendbarkeit, minimale Kopplung. Generische Typen wo sinnvoll. Klare Trennung von Datenrepräsentation und Fehlerbehandlung.

**Abhängigkeiten:** `std`, `uuid` (für IDs in höheren Schichten, hier als Beispiel für einen Basistyp), `chrono` (für Zeitstempel, dito), `serde` (optional, mit `derive`-Feature, falls Serialisierung hier benötigt wird), `num-traits` (optional).

#### Untermodul: `core::types::geometry`

**Datei:** `src/types/geometry.rs`

##### 1. Struct: `Point<T>`

- **Zweck:** Repräsentiert einen Punkt im 2D-Raum.
- **Generische Parameter:** `T`
- **Felder:**
    - `pub x: T`
    - `pub y: T`
- **Ableitungen (Basis):** `#[derive(Debug, Clone, Copy, PartialEq, Default)]`
    - `Eq` und `Hash` nur, wenn `T: Eq` bzw. `T: Hash`.
- **`serde` (optional):** `#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]`
- **Invarianten:** Keine spezifischen, hängen von `T` ab.
- **Methoden:**
    - `pub const fn new(x: T, y: T) -> Self`
        - **Logik:** Erstellt einen neuen Punkt.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** `self.x == x`, `self.y == y`.
    - `pub fn distance_squared(&self, other: &Point<T>) -> T`
        - **Generische Constraints:** `T: Copy + std::ops::Add<Output = T> + std::ops::Sub<Output = T> + std::ops::Mul<Output = T>`
        - **Logik:** Berechnet das Quadrat der euklidischen Distanz: `(self.x - other.x)^2 + (self.y - other.y)^2`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt das Quadrat der Distanz zurück.
    - `pub fn distance(&self, other: &Point<T>) -> T`
        - **Generische Constraints:** `T: Copy + std::ops::Add<Output = T> + std::ops::Sub<Output = T> + std::ops::Mul<Output = T> + num_traits::Float` (oder spezifische Implementierung für `f32`, `f64`)
        - **Logik:** Berechnet die euklidische Distanz: `sqrt((self.x - other.x)^2 + (self.y - other.y)^2)`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt die Distanz zurück.
    - `pub fn manhattan_distance(&self, other: &Point<T>) -> T`
        - **Generische Constraints:** `T: Copy + std::ops::Add<Output = T> + std::ops::Sub<Output = T> + num_traits::Signed`
        - **Logik:** Berechnet die Manhattan-Distanz: `abs(self.x - other.x) + abs(self.y - other.y)`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt die Manhattan-Distanz zurück.
- **Trait-Implementierungen (Zusätzlich):**
    - `impl<T: std::ops::Add<Output = T>> std::ops::Add for Point<T>`
    - `impl<T: std::ops::Sub<Output = T>> std::ops::Sub for Point<T>`
- **Assoziierte Konstanten:**
    - `pub const ZERO_I32: Point<i32> = Point { x: 0, y: 0 };`
    - `pub const ZERO_F32: Point<f32> = Point { x: 0.0, y: 0.0 };`
    - (Weitere für `u32`, `f64` etc.)

##### 2. Struct: `Size<T>`

- **Zweck:** Repräsentiert eine 2D-Dimension (Breite und Höhe).
- **Generische Parameter:** `T`
- **Felder:**
    - `pub width: T`
    - `pub height: T`
- **Ableitungen (Basis):** `#[derive(Debug, Clone, Copy, PartialEq, Default)]`
    - `Eq` und `Hash` nur, wenn `T: Eq` bzw. `T: Hash`.
- **`serde` (optional):** `#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]`
- **Invarianten:** Logisch sollten `width` und `height` nicht-negativ sein. Dies wird nicht durch den Typ erzwungen, aber durch `is_valid()` prüfbar gemacht.
- **Methoden:**
    - `pub const fn new(width: T, height: T) -> Self`
        - **Logik:** Erstellt eine neue Größe.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** `self.width == width`, `self.height == height`.
    - `pub fn area(&self) -> T`
        - **Generische Constraints:** `T: Copy + std::ops::Mul<Output = T>`
        - **Logik:** Berechnet die Fläche: `self.width * self.height`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt die Fläche zurück.
    - `pub fn is_empty(&self) -> bool`
        - **Generische Constraints:** `T: PartialEq + num_traits::Zero`
        - **Logik:** Prüft, ob `self.width == T::zero()` oder `self.height == T::zero()`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt `true` zurück, wenn leer, sonst `false`.
    - `pub fn is_valid(&self) -> bool`
        - **Generische Constraints:** `T: PartialOrd + num_traits::Zero`
        - **Logik:** Prüft, ob `self.width >= T::zero()` und `self.height >= T::zero()`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt `true` zurück, wenn gültig, sonst `false`.
- **Assoziierte Konstanten:**
    - `pub const ZERO_I32: Size<i32> = Size { width: 0, height: 0 };`
    - `pub const ZERO_F32: Size<f32> = Size { width: 0.0, height: 0.0 };`
    - (Weitere für `u32`, `f64` etc.)

##### 3. Struct: `Rect<T>`

- **Zweck:** Repräsentiert ein 2D-Rechteck, definiert durch Ursprung (oben-links) und Größe.
- **Generische Parameter:** `T`
- **Felder:**
    - `pub origin: Point<T>`
    - `pub size: Size<T>`
- **Ableitungen (Basis):** `#[derive(Debug, Clone, Copy, PartialEq, Default)]`
    - `Eq` und `Hash` nur, wenn `T: Eq` bzw. `T: Hash`.
- **`serde` (optional):** `#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]`
- **Invarianten:** Logisch sollten `size.width` und `size.height` nicht-negativ sein. `is_valid()` prüft dies. Die Verantwortung für das Melden eines Fehlers bei Verwendung eines ungültigen `Rect` liegt beim Aufrufer.
- **Methoden:**
    - `pub const fn new(origin: Point<T>, size: Size<T>) -> Self`
        - **Logik:** Erstellt ein neues Rechteck.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** `self.origin == origin`, `self.size == size`.
    - `pub fn from_coords(x: T, y: T, width: T, height: T) -> Self`
        - **Generische Constraints:** `T` muss die Constraints für `Point::new` und `Size::new` erfüllen.
        - **Logik:** Erstellt ein neues Rechteck aus Koordinaten und Dimensionen.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** `self.origin.x == x`, `self.origin.y == y`, `self.size.width == width`, `self.size.height == height`.
    - `pub fn x(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.origin.x` zurück.
    - `pub fn y(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.origin.y` zurück.
    - `pub fn width(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.size.width` zurück.
    - `pub fn height(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.size.height` zurück.
    - `pub fn top(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.y()` zurück.
    - `pub fn left(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.x()` zurück.
    - `pub fn bottom(&self) -> T` (Constraints: `T: Copy + std::ops::Add<Output = T>`) - Gibt `self.y() + self.height()` zurück.
    - `pub fn right(&self) -> T` (Constraints: `T: Copy + std::ops::Add<Output = T>`) - Gibt `self.x() + self.width()` zurück.
    - `pub fn center(&self) -> Point<T>`
        - **Generische Constraints:** `T: Copy + std::ops::Add<Output = T> + std::ops::Div<Output = T> + num_traits::FromPrimitive` (für `T::from(2).unwrap()`).
        - **Logik:** Berechnet den Mittelpunkt: `Point::new(self.x() + self.width() / 2, self.y() + self.height() / 2)`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt den Mittelpunkt zurück.
    - `pub fn contains_point(&self, point: &Point<T>) -> bool`
        - **Generische Constraints:** `T: Copy + PartialOrd + std::ops::Add<Output = T>`
        - **Logik:** `point.x >= self.left() && point.x < self.right() && point.y >= self.top() && point.y < self.bottom()`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt `true` zurück, wenn der Punkt enthalten ist, sonst `false`.
    - `pub fn intersects(&self, other: &Rect<T>) -> bool`
        - **Generische Constraints:** `T: Copy + PartialOrd + std::ops::Add<Output = T>`
        - **Logik:** `self.left() < other.right() && self.right() > other.left() && self.top() < other.bottom() && self.bottom() > other.top()`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt `true` zurück, wenn sich die Rechtecke überschneiden, sonst `false`.
    - `pub fn intersection(&self, other: &Rect<T>) -> Option<Rect<T>>`
        - **Generische Constraints:** `T: Copy + Ord + std::ops::Add<Output = T> + std::ops::Sub<Output = T> + num_traits::Zero`
        - **Logik:**
            1. `intersect_x = self.x().max(other.x())`
            2. `intersect_y = self.y().max(other.y())`
            3. `intersect_right = self.right().min(other.right())`
            4. `intersect_bottom = self.bottom().min(other.bottom())`
            5. Wenn `intersect_right > intersect_x` und `intersect_bottom > intersect_y`:
                - `intersect_width = intersect_right - intersect_x`
                - `intersect_height = intersect_bottom - intersect_y`
                - `Some(Rect::new(Point::new(intersect_x, intersect_y), Size::new(intersect_width, intersect_height)))`
            6. Sonst: `None`
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt das Schnittrechteck oder `None` zurück.
    - `pub fn union(&self, other: &Rect<T>) -> Rect<T>`
        - **Generische Constraints:** `T: Copy + Ord + std::ops::Add<Output = T> + std::ops::Sub<Output = T>`
        - **Logik:**
            1. `union_x = self.x().min(other.x())`
            2. `union_y = self.y().min(other.y())`
            3. `union_right = self.right().max(other.right())`
            4. `union_bottom = self.bottom().max(other.bottom())`
            5. `union_width = union_right - union_x`
            6. `union_height = union_bottom - union_y`
            7. `Rect::new(Point::new(union_x, union_y), Size::new(union_width, union_height))`
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt das umschließende Rechteck zurück.
    - `pub fn translated(&self, dx: T, dy: T) -> Rect<T>`
        - **Generische Constraints:** `T: Copy + std::ops::Add<Output = T>`
        - **Logik:** `Rect::new(Point::new(self.origin.x + dx, self.origin.y + dy), self.size)`
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt das verschobene Rechteck zurück.
    - `pub fn scaled(&self, sx: T, sy: T) -> Rect<T>` (Skaliert Ursprung und Größe)
        - **Generische Constraints:** `T: Copy + std::ops::Mul<Output = T>`
        - **Logik:** `Rect::new(Point::new(self.origin.x * sx, self.origin.y * sy), Size::new(self.size.width * sx, self.size.height * sy))`
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt das skalierte Rechteck zurück.
    - `pub fn is_valid(&self) -> bool`
        - **Generische Constraints:** `T` muss `Size::is_valid` unterstützen.
        - **Logik:** Ruft `self.size.is_valid()` auf.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt `true` zurück, wenn `size` gültig ist, sonst `false`.
- **Assoziierte Konstanten:**
    - `pub const ZERO_I32: Rect<i32> = Rect { origin: Point::ZERO_I32, size: Size::ZERO_I32 };`
    - `pub const ZERO_F32: Rect<f32> = Rect { origin: Point::ZERO_F32, size: Size::ZERO_F32 };`

##### 4. Struct `RectInt` (Spezifische Implementierung von `Rect<i32/u32>`)

- **Zweck:** Ein achsenparalleles Rechteck mit ganzzahligen `i32` Koordinaten und `u32` Dimensionen. Dies ist oft praktisch für Pixel-basierte Operationen und Fenstergeometrie.
- **Felder:**
    - `pub x: i32`
    - `pub y: i32`
    - `pub width: u32`
    - `pub height: u32`
- **Ableitungen:** `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default, Serialize, Deserialize)]` (Serde ist hier oft nützlich)
- **Invarianten:** `width >= 0`, `height >= 0` (durch `u32` Typ erzwungen).
- **Methoden (Beispiele, basierend auf):**
    - `pub const fn new(x: i32, y: i32, width: u32, height: u32) -> Self`
    - `pub fn from_points(p1: Point<i32>, p2: Point<i32>) -> Self`
        - **Logik:** `x = p1.x.min(p2.x)`, `y = p1.y.min(p2.y)`, `width = (p1.x - p2.x).abs() as u32`, `height = (p1.y - p2.y).abs() as u32`.
    - `pub fn top_left(&self) -> Point<i32>` - Gibt `Point::new(self.x, self.y)` zurück.
    - `pub fn size(&self) -> Size<u32>` - Gibt `Size::new(self.width, self.height)` zurück.
    - `pub fn right(&self) -> i32` - Gibt `self.x.saturating_add(self.width as i32)` zurück.
    - `pub fn bottom(&self) -> i32` - Gibt `self.y.saturating_add(self.height as i32)` zurück.
    - `pub fn contains_point(&self, p_x: i32, p_y: i32) -> bool` - `p_x >= self.x && p_x < self.right() && p_y >= self.y && p_y < self.bottom()`.
    - `pub fn intersects(&self, other: RectInt) -> bool` - `self.x < other.right() && self.right() > other.x && self.y < other.bottom() && self.bottom() > other.y`.
    - `pub fn intersection(&self, other: RectInt) -> Option<RectInt>` (Logik wie bei `Rect<T>`)
    - `pub fn union(&self, other: RectInt) -> RectInt` (Logik wie bei `Rect<T>`)
    - `pub fn translate(&self, dx: i32, dy: i32) -> RectInt` - `RectInt::new(self.x.saturating_add(dx), self.y.saturating_add(dy), self.width, self.height)`.
    - `pub fn inflate(&self, dw: i32, dh: i32) -> RectInt`
        - **Logik:** `new_x = self.x.saturating_sub(dw)`, `new_y = self.y.saturating_sub(dh)`. `new_width_signed = (self.width as i64).saturating_add(2 * dw as i64)`. `new_height_signed = (self.height as i64).saturating_add(2 * dh as i64)`. `RectInt::new(new_x, new_y, new_width_signed.max(0) as u32, new_height_signed.max(0) as u32)`.
    - `pub fn is_empty(&self) -> bool` - `self.width == 0 || self.height == 0`.

#### Untermodul: `core::types::color`

**Datei:** `src/types/color.rs`

##### 1. Struct: `Color` (RGBA)

- **Zweck:** Repräsentiert eine Farbe mit Rot-, Grün-, Blau- und Alpha-Komponenten.
- **Felder:**
    - `pub r: f32` (Bereich `[0.0, 1.0]`)
    - `pub g: f32` (Bereich `[0.0, 1.0]`)
    - `pub b: f32` (Bereich `[0.0, 1.0]`)
    - `pub a: f32` (Bereich `[0.0, 1.0]`)
- **Ableitungen:** `#[derive(Debug, Clone, Copy, PartialEq)]`
- **Invarianten:** Alle Komponenten `r, g, b, a` müssen im Bereich `[0.0, 1.0]` liegen. Konstruktoren und Methoden klemmen Werte entsprechend.
- **Methoden:**
    - `pub fn new(r: f32, g: f32, b: f32, a: f32) -> Self`
        - **Logik:** `Self { r: r.clamp(0.0, 1.0), g: g.clamp(0.0, 1.0), b: b.clamp(0.0, 1.0), a: a.clamp(0.0, 1.0) }`.
        - **Nachbedingungen:** Alle Felder sind im Bereich `[0.0, 1.0]`.
    - `pub fn from_rgba8(r_u8: u8, g_u8: u8, b_u8: u8, a_u8: u8) -> Self`
        - **Logik:** `Self::new(r_u8 as f32 / 255.0, g_u8 as f32 / 255.0, b_u8 as f32 / 255.0, a_u8 as f32 / 255.0)`.
    - `pub fn to_rgba8(&self) -> (u8, u8, u8, u8)`
        - **Logik:** `((self.r * 255.0).round() as u8, (self.g * 255.0).round() as u8, (self.b * 255.0).round() as u8, (self.a * 255.0).round() as u8)`.
    - `pub fn with_alpha(&self, alpha: f32) -> Self`
        - **Logik:** `Self::new(self.r, self.g, self.b, alpha)`.
    - `pub fn blend(&self, background: &Color) -> Color` (Source-Over Blending)
        - **Logik:**
            1. `fg_a = self.a`
            2. `bg_a = background.a`
            3. `out_a = fg_a + bg_a * (1.0 - fg_a)`
            4. Wenn `out_a == 0.0`, gib `Color::TRANSPARENT` zurück.
            5. `out_r = (self.r * fg_a + background.r * bg_a * (1.0 - fg_a)) / out_a`
            6. `out_g = (self.g * fg_a + background.g * bg_a * (1.0 - fg_a)) / out_a`
            7. `out_b = (self.b * fg_a + background.b * bg_a * (1.0 - fg_a)) / out_a`
            8. `Color::new(out_r, out_g, out_b, out_a)`
    - `pub fn lighten(&self, amount: f32) -> Color`
        - **Logik:** `amount_clamped = amount.clamp(0.0, 1.0)`. `Color::new(self.r + (1.0 - self.r) * amount_clamped, self.g + (1.0 - self.g) * amount_clamped, self.b + (1.0 - self.b) * amount_clamped, self.a)`
    - `pub fn darken(&self, amount: f32) -> Color`
        - **Logik:** `amount_clamped = amount.clamp(0.0, 1.0)`. `Color::new(self.r * (1.0 - amount_clamped), self.g * (1.0 - amount_clamped), self.b * (1.0 - amount_clamped), self.a)`
    - `pub fn interpolate(&self, other: Color, t: f32) -> Color`
        - **Logik:** `t_clamped = t.clamp(0.0, 1.0)`. `r = self.r * (1.0 - t_clamped) + other.r * t_clamped` `g = self.g * (1.0 - t_clamped) + other.g * t_clamped` `b = self.b * (1.0 - t_clamped) + other.b * t_clamped` `a = self.a * (1.0 - t_clamped) + other.a * t_clamped` `Color::new(r,g,b,a)`
    - `pub fn from_hex(hex_string: &str) -> Result<Self, ColorParseError>`
        - **Logik:**
            1. Entferne optionales `#`-Präfix.
            2. Validiere Länge (3, 4, 6, 8 Zeichen). Bei ungültiger Länge: `Err(ColorParseError::InvalidHexLength(hex_string.to_string()))`.
            3. Parse Hex-Zeichen in `u8` Komponenten. Bei ungültigen Zeichen: `Err(ColorParseError::InvalidHexDigit(...))`.
                - `#RGB`: `R`, `G`, `B` (Alpha = FF) -> `RR`, `GG`, `BB`
                - `#RGBA`: `R`, `G`, `B`, `A` -> `RR`, `GG`, `BB`, `AA`
                - `#RRGGBB`: `RR`, `GG`, `BB` (Alpha = FF)
                - `#RRGGBBAA`: `RR`, `GG`, `BB`, `AA`
            4. Konvertiere `u8` zu `f32` (`/ 255.0`).
            5. Erzeuge `Color` via `Color::new()`.
            6. Bei Erfolg `Ok(Self)`.
        - **Fehler:** `ColorParseError` (siehe `core::errors`)
    - `pub fn to_hex_string(&self, include_alpha: bool) -> String`
        - **Logik:** Konvertiere `r,g,b,a` zu `u8`. Formatiere als Hex-String.
            - Wenn `include_alpha` oder `self.a < 1.0` (oder immer Alpha für Konsistenz): `format!("#{:02X}{:02X}{:02X}{:02X}", r_u8, g_u8, b_u8, a_u8)`
            - Sonst: `format!("#{:02X}{:02X}{:02X}", r_u8, g_u8, b_u8)`
- **Trait-Implementierungen (Zusätzlich):**
    - `impl Default for Color { fn default() -> Self { Color::TRANSPARENT } }`
- **Assoziierte Konstanten:**
    - `pub const TRANSPARENT: Color = Color { r: 0.0, g: 0.0, b: 0.0, a: 0.0 };`
    - `pub const BLACK: Color = Color { r: 0.0, g: 0.0, b: 0.0, a: 1.0 };`
    - `pub const WHITE: Color = Color { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };`
    - (Weitere wie `RED`, `GREEN`, `BLUE`)
- **Serialisierung (`serde`):**
    - Soll als Hex-String serialisiert/deserialisiert werden (siehe).
    - `impl Serialize for Color { ... serializer.serialize_str(&self.to_hex_string(true)) ... }`
    - `impl<'de> Deserialize<'de> for Color { ... Color::from_hex(&s).map_err(serde::de::Error::custom) ... }`

#### Untermodul: `core::types::enums`

**Datei:** `src/types/enums.rs`

##### 1. Enum: `Orientation`

- **Zweck:** Repräsentiert eine horizontale oder vertikale Ausrichtung.
- **Varianten:**
    - `Horizontal`
    - `Vertical`
- **Ableitungen:** `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]`
- **Methoden:**
    - `pub fn toggle(&self) -> Self`
        - **Logik:** `match self { Orientation::Horizontal => Orientation::Vertical, Orientation::Vertical => Orientation::Horizontal }`.
- **Trait-Implementierungen (Zusätzlich):**
    - `impl Default for Orientation { fn default() -> Self { Orientation::Horizontal } }`

#### Untermodul: `core::types::ids`

Datei: src/types/ids.rs

(Obwohl in der Gesamtspezifikation WorkspaceId, WindowIdentifier etc. in core::types erwähnt werden, gehören sie semantisch eher in die Domänenschicht oder sind Newtypes um primitive IDs. Hier ein Beispiel für generische ID-Typen, falls benötigt.)

##### 1. Struct: `GenericId` (Beispiel)

- **Zweck:** Ein typsicherer Wrapper um `uuid::Uuid` für generische Entitäts-IDs.
- **Felder:** `pub id: uuid::Uuid`
- **Ableitungen:** `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]`
- **Methoden:**
    - `pub fnnew() -> Self { Self { id: Uuid::new_v4() } }`
    - `pub fnfrom_uuid(uuid: Uuid) -> Self { Self { id: uuid } }`
    - `pub fnas_uuid(&self) -> &Uuid { &self.id }`
- **Trait-Implementierungen:** `impl Default for GenericId { fn default() -> Self { Self::new() } }`

#### Moduldeklaration `core::types::mod.rs`

Rust

```
// src/types/mod.rs

pub mod color;
pub mod enums;
pub mod geometry;
// pub mod ids; // Falls vorhanden

pub use color::Color;
pub use enums::Orientation;
pub use geometry::{Point, Rect, Size, RectInt};
// pub use ids::GenericId;
```

#### Implementierungsschritte `core::types`

1. **Verzeichnis- und Dateierstellung:**
    - `core/src/types/mod.rs`
    - `core/src/types/geometry.rs`
    - `core/src/types/color.rs`
    - `core/src/types/enums.rs`
    - (`core/src/types/ids.rs` optional)
2. **Implementierung `geometry.rs`:**
    - `Point<T>`: Struktur, Ableitungen, Konstanten, Methoden (`new`, `distance_squared`, `distance`, `manhattan_distance`), Trait-Impls.
    - `Size<T>`: Struktur, Ableitungen, Konstanten, Methoden (`new`, `area`, `is_empty`, `is_valid`).
    - `Rect<T>`: Struktur, Ableitungen, Konstanten, Methoden (`new`, `from_coords`, Zugriffsmethoden, `center`, `contains_point`, `intersects`, `intersection`, `union`, `translated`, `scaled`, `is_valid`).
    - `RectInt`: Struktur, Ableitungen, Methoden wie spezifiziert.
    - Hinzufügen von `use num_traits::{Float, Signed, Zero};` und `use serde::{Serialize, Deserialize};` (letzteres mit `cfg_attr`).
3. **Implementierung `color.rs`:**
    - `Color`: Struktur, Ableitungen, Konstanten, Methoden (`new`, `from_rgba8`, `to_rgba8`, `with_alpha`, `blend`, `lighten`, `darken`, `interpolate`, `from_hex`, `to_hex_string`), `Default`-Impl, `Serialize`/`Deserialize`-Impls.
    - Benötigt `use crate::core::errors::ColorParseError;` (siehe `core::errors`) und `use serde::{Serializer, Deserializer, de::Error as SerdeError};`.
4. **Implementierung `enums.rs`:**
    - `Orientation`: Enum, Ableitungen, `toggle`-Methode, `Default`-Impl.
5. **Implementierung `ids.rs` (optional):**
    - `GenericId` (oder spezifischere ID-Typen, falls hier sinnvoll).
6. **Moduldeklaration `types/mod.rs`:** `pub mod ...` und `pub use ...` für alle definierten Typen.
7. **Aktualisierung `core/src/lib.rs`:** `pub mod types;`
8. **Unit-Tests:**
    - Für jeden Typ und jede Methode Testfälle erstellen.
    - `Point<T>`: Teste `new`, Distanzberechnungen für `i32` und `f32`.
    - `Size<T>`: Teste `new`, `area`, `is_empty`, `is_valid` für `i32`, `u32`, `f32`.
    - `Rect<T>`: Teste Konstruktoren, Zugriffsmethoden, `center`, `contains_point`, `intersects`, `intersection`, `union`.
    - `RectInt`: Teste alle Methoden, insbesondere `inflate` mit positiven/negativen Werten.
    - `Color`: Teste `new` (Klemmung), `from_rgba8`, `to_rgba8`, `blend`, `lighten`, `darken`, `from_hex` (alle Formate, Fehlerfälle), `to_hex_string`, `Default`.
    - `Orientation`: Teste `toggle`, `Default`.
    - Überprüfe `serde`-Implementierungen (Serialisierung zu erwartetem JSON/String, Deserialisierung).
9. **Dokumentation (`rustdoc`):**
    - Umfassende Kommentare für alle öffentlichen Elemente (Module, Structs, Enums, Felder, Methoden, Konstanten).
    - Erklärung von Invarianten, Wertebereichen, Vor-/Nachbedingungen.
    - `# Examples` für komplexere Methoden oder Typverwendungen.

---

### Modul: `core::errors` (Fehlerbehandlung)

**Zweck:** Definition einer robusten und konsistenten Fehlerbehandlungsstrategie und grundlegender Fehlertypen für die Kernschicht.

**Designphilosophie:** Verwendung von `thiserror` für spezifische Fehler-Enums pro Modul. Klare Trennung zwischen `Result<T, E>` für behebbare Fehler und `panic!` für nicht behebbare Programmierfehler. Kontextreiche Fehlermeldungen.

**Abhängigkeiten:** `std`, `thiserror`, `uuid` (für IDs in Fehlermeldungen), `std::path::PathBuf`.

**Datei:** `src/errors.rs`

##### 1. Enum: `CoreError` (Basis-Fehlertyp der Kernschicht)

- **Zweck:** Dient als primäre Schnittstelle für allgemeine Fehler, die von öffentlichen Funktionen der Kernschicht propagiert werden können, oder für Fehler, die keinem spezifischen Submodul zugeordnet werden können.
- **Ableitungen:** `#[derive(Debug, thiserror::Error)]`
- **Varianten:**
    - `#[error("Core component '{component}' failed to initialize")]` `InitializationFailed { component: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
    - `#[error("I/O error accessing path '{path}': {source}")]` `Io { path: PathBuf, #[source] source: std::io::Error }`
        - **Publisher:** Jede Kernfunktion, die direkt I/O-Operationen durchführt.
        - **Subscriber:** Aufrufer, die diese I/O-Fehler behandeln müssen.
    - `#[error("Serialization error: {description}")]` (für generische Serialisierungsfehler, spezifischere sollten eigene Typen haben) `Serialization { description: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
    - `#[error("Deserialization error: {description}")]` `Deserialization { description: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
    - `#[error("Invalid identifier provided: '{invalid_id}'")]` `InvalidId { invalid_id: String }`
    - `#[error("Resource not found: {resource_description}")]` `NotFound { resource_description: String }`
    - `#[error("Configuration error (core level): {message}")]` `CoreConfigError { message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }` (Spezifischere `ConfigError` in `core::config::errors`)
    - `#[error("An internal logic error occurred: {0}")]` `InternalError(String)` (Sollte selten verwendet werden; spezifischere Fehler sind vorzuziehen)

##### 2. Enum: `ColorParseError` (Spezifischer Fehler für `Color::from_hex`)

- **Zweck:** Repräsentiert Fehler, die beim Parsen eines Hex-Strings zu einer `Color` auftreten können.
- **Datei:** `src/types/color.rs` (oder `src/errors/color_errors.rs` und re-exportiert) – hier in `errors.rs` für Zentralität der Fehler.
- **Ableitungen:** `#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]`
- **Varianten:**
    - `#[error("Invalid hex color string format for '{0}'. Expected formats: #RGB, #RGBA, #RRGGBB, #RRGGBBAA.")]` `InvalidHexFormat(String)`
    - `#[error("Invalid hex digit in string '{0}': {source}")]` `InvalidHexDigit(String, #[source] std::num::ParseIntError)`
    - `#[error("Invalid hex color string length for '{0}'. Expected 3, 4, 6, or 8 characters after '#'.")]` `InvalidHexLength(String)`

##### Implementierungsschritte `core::errors`

1. **Abhängigkeiten in `core/Cargo.toml` sicherstellen:**
    
    Ini, TOML
    
    ```
    [dependencies]
    thiserror = "1.0"
    uuid = { version = "1.0", features = ["v4", "serde"] } # serde optional für Fehler
    chrono = { version = "0.4", features = ["serde"] } # serde optional
    # num-traits, serde, toml, once_cell je nach Bedarf anderer Module
    ```
    
2. **Datei `core/src/errors.rs` erstellen/modifizieren:**
    - `CoreError`-Enum mit allen Varianten, `#[error(...)]`-Attributen und `#[source]`-Feldern definieren.
    - `ColorParseError`-Enum definieren.
3. **Öffentliche API und Interne Schnittstellen:**
    - Alle Enums und ihre Varianten sind `pub`.
    - Die `source()`-Methode wird von `thiserror` bereitgestellt.
4. **Unit-Tests (`core/src/errors.rs` -> `#[cfg(test)] mod tests`):**
    - Für jede Fehlervariante testen, ob die `Display`-Implementierung (via `#[error]`) die erwartete Nachricht erzeugt.
    - Für Varianten mit `#[source]`, testen, ob `source()` den zugrunde liegenden Fehler korrekt zurückgibt.
        - Beispiel für `CoreError::Io`:
            
            Rust
            
            ```
            let original_io_err = std::io::Error::new(std::io::ErrorKind::NotFound, "file not found");
            let core_io_err = CoreError::Io { path: "test.txt".into(), source: original_io_err };
            assert!(core_io_err.source().is_some());
            // Ggf. den Typ des source-Fehlers prüfen.
            ```
            
    - Testen der `ColorParseError`-Varianten.
5. **Aktualisierung `core/src/lib.rs`:** `pub mod errors;`
    - `pub use errors::{CoreError, ColorParseError};` (oder nur `CoreError` und `ColorParseError` wird über `crate::types::Color::from_hex` verwendet)

---

### Modul: `core::logging` (Logging-Infrastruktur)

**Zweck:** Initialisierung und Konfiguration des globalen `tracing`-Frameworks.

**Designphilosophie:** Bereitstellung einer einfachen Initialisierungsfunktion. Die eigentliche Verwendung der `tracing::{trace, debug, info, warn, error}` Makros erfolgt direkt im Code der anderen Module/Schichten.

**Abhängigkeiten:** `tracing`, `tracing-subscriber` (mit Features wie `fmt`, `json`, `env-filter`).

**Datei:** `src/logging.rs`

##### 1. Enum: `LogFormat`

- **Zweck:** Definiert die möglichen Ausgabeformate für das Logging.
- **Varianten:**
    - `PlainTextDevelopment`
    - `JsonProduction`
- **Ableitungen:** `#[derive(Debug, Clone, Copy)]`

##### 2. Enum: `LoggingError`

- **Zweck:** Fehler, die bei der Initialisierung des Loggings auftreten können.
- **Ableitungen:** `#[derive(Debug, thiserror::Error)]`
- **Varianten:**
    - `#[error("Failed to set global default tracing subscriber: {0}")]` `SetGlobalDefaultError(String)` (Kapselt den Fehler von `tracing::subscriber::set_global_default`)
    - `#[error("Failed to initialize tracing subscriber: {0}")]` `InitializationError(String)`

##### 3. Funktion: `initialize_logging`

- **Signatur:** `pub fn initialize_logging(level_filter: tracing::LevelFilter, format: LogFormat) -> Result<(), LoggingError>`
- **Parameter:**
    - `level_filter: tracing::LevelFilter`: Der minimale Log-Level, der global gelten soll.
    - `format: LogFormat`: Das gewünschte Ausgabeformat.
- **Rückgabe:** `Result<(), LoggingError>`
- **Logik:**
    1. Erstelle einen `tracing_subscriber::fmt::Builder` oder einen `tracing_subscriber::Registry` mit Layern.
    2. Konfiguriere den Subscriber basierend auf `format`:
        - `LogFormat::PlainTextDevelopment`:
            - Verwende `tracing_subscriber::fmt::layer()`
            - `with_ansi(true)` (falls Terminal es unterstützt, kann über Feature-Flag gesteuert werden)
            - `with_target(true)` (Modulpfad anzeigen)
            - `with_file(true)`
            - `with_line_number(true)`
            - `with_level(true)`
            - `with_filter(level_filter)`
        - `LogFormat::JsonProduction`:
            - Verwende `tracing_subscriber::fmt::layer().json()`
            - `with_current_span(true)`
            - `with_span_list(true)`
            - `with_filter(level_filter)`
            - Alternativ: `tracing_bunyan_formatter` für spezifisches Bunyan-JSON-Format.
    3. Optional: Füge einen `EnvFilter` hinzu, um Log-Levels zur Laufzeit über `RUST_LOG` feingranularer zu steuern, zusätzlich zum globalen `level_filter`. `let env_filter = tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| tracing_subscriber::EnvFilter::new(level_filter.to_string()));` Der `level_filter` Parameter dient dann als Fallback, wenn `RUST_LOG` nicht gesetzt ist. Der Layer wird dann mit `with_filter(env_filter)` konfiguriert.
    4. Baue den Subscriber und versuche, ihn als globalen Default zu setzen: `tracing::subscriber::set_global_default(subscriber).map_err(|e| LoggingError::SetGlobalDefaultError(e.to_string()))`.
- **Fehlerbehandlung:** Gibt `LoggingError` zurück, falls die Initialisierung fehlschlägt.

##### Implementierungsschritte `core::logging`

1. **Abhängigkeiten in `core/Cargo.toml`:**
    
    Ini, TOML
    
    ```
    tracing = "0.1"
    tracing-subscriber = { version = "0.3", features = ["fmt", "json", "env-filter"] }
    # Ggf. tracing-bunyan-formatter
    ```
    
2. **Datei `core/src/logging.rs` erstellen:**
    - `LogFormat` Enum definieren.
    - `LoggingError` Enum mit `thiserror` definieren.
    - `initialize_logging` Funktion implementieren.
3. **Unit-Tests (konzeptionell, da `set_global_default` global ist):**
    - Testen, ob die Funktion mit verschiedenen Formaten und Leveln ohne Panic durchläuft. Das tatsächliche Setzen des globalen Subscribers ist schwer isoliert zu testen. Man könnte prüfen, ob der Builder korrekt konfiguriert wird.
4. **Aktualisierung `core/src/lib.rs`:** `pub mod logging;`
    - `pub use logging::{initialize_logging, LogFormat, LoggingError};`

---

### Modul: `core::config` (Konfigurationsprimitive)

**Zweck:** Definition von Mechanismen zum Laden, Parsen und Zugreifen auf Basiskonfigurationen.

**Designphilosophie:** Einfachheit, Robustheit. Verwendung von TOML als Konfigurationsformat und `serde` für (De-)Serialisierung.

**Abhängigkeiten:** `serde` (mit `derive`), `toml`, `once_cell` (für globalen Zugriff).

**Datei:** `src/config/mod.rs` (kann `errors.rs`, `types.rs`, `loader.rs` enthalten)

#### Untermodul: `core::config::errors`

**Datei:** `src/config/errors.rs`

##### 1. Enum: `ConfigError`

- **Zweck:** Fehler, die beim Laden oder Verarbeiten von Konfigurationen auftreten können.
- **Ableitungen:** `#[derive(Debug, thiserror::Error)]`
- **Varianten:**
    - `#[error("Failed to read configuration file from path '{path}': {source}")]` `FileReadError { path: PathBuf, #[source] source: std::io::Error }`
    - `#[error("Failed to deserialize configuration from path '{path}': {source}")]` `DeserializationError { path: PathBuf, #[source] source: toml::de::Error }`
    - `#[error("No configuration file found. Checked paths: {checked_paths:?}")]` `NoConfigurationFileFound { checked_paths: Vec<PathBuf> }`
    - `#[error("Configuration already initialized.")]` `AlreadyInitializedError`
    - `#[error("Configuration not yet initialized.")]` `NotInitializedError`
    - `#[error("Invalid configuration value for key '{key}': {reason}")]` (Falls Validierung hier stattfindet) `InvalidValueError { key: String, reason: String }`

#### Untermodul: `core::config::types`

**Datei:** `src/config/types.rs`

##### 1. Struct: `CoreConfig` (Beispielstruktur)

- **Zweck:** Hält alle spezifischen Konfigurationen der Kernschicht. Muss an die tatsächlichen Bedürfnisse angepasst werden.
- **Ableitungen:** `#[derive(Debug, Clone, serde::Deserialize, Default)]`
- **Attribute:** `#[serde(deny_unknown_fields)]` auf der Struktur.
- **Felder (Beispiele):**
    
    Rust
    
    ```
    use serde::Deserialize;
    use std::path::PathBuf;
    
    #[derive(Debug, Clone, Deserialize, Default)]
    #[serde(rename_all = "kebab-case")] // TOML verwendet oft kebab-case
    pub enum LogLevelConfig { // Muss auch in core::logging bekannt sein oder hierhin verschoben werden
        Trace,
        Debug,
        #[default]
        Info,
        Warn,
        Error,
    }
    
    #[derive(Debug, Clone, Deserialize)]
    #[serde(deny_unknown_fields)]
    pub struct CoreConfig {
        #[serde(default = "default_log_level")]
        pub log_level: LogLevelConfig,
        #[serde(default = "default_some_path")]
        pub some_critical_path: PathBuf,
        #[serde(default)] // Verwendet FeatureFlags::default()
        pub feature_flags: FeatureFlags,
    }
    
    // Default-Funktionen müssen den korrekten Typ zurückgeben
    fn default_log_level() -> LogLevelConfig { LogLevelConfig::default() }
    fn default_some_path() -> PathBuf { PathBuf::from("/usr/share/novade/default_resource") }
    
    impl Default for CoreConfig {
        fn default() -> Self {
            Self {
                log_level: default_log_level(),
                some_critical_path: default_some_path(),
                feature_flags: FeatureFlags::default(),
            }
        }
    }
    
    #[derive(Debug, Clone, Deserialize, Default)]
    #[serde(deny_unknown_fields)]
    pub struct FeatureFlags {
        #[serde(default)] // bool standardmäßig auf false
        pub enable_alpha_feature: bool,
        #[serde(default = "default_beta_timeout_ms")]
        pub beta_feature_timeout_ms: u64,
    }
    
    fn default_beta_timeout_ms() -> u64 { 1000 }
    ```
    
- **Validierung:** Grundlegende Validierung durch Typen und `serde`-Attribute. Komplexere Validierung kann nach Deserialisierung erfolgen (z.B. `TryFrom<RawCoreConfig>` oder `validate()`-Methode), die dann `ConfigError::InvalidValueError` zurückgibt.

#### Untermodul: `core::config::loader`

**Datei:** `src/config/loader.rs`

##### 1. Funktion: `load_core_config`

- **Signatur:** `pub fn load_core_config(config_paths: &[PathBuf]) -> Result<CoreConfig, ConfigError>` (Nimmt eine Liste von Pfaden, um sie der Reihe nach zu prüfen).
- **Logik:**
    1. Iteriere über `config_paths`.
    2. Für jeden Pfad:
        - Prüfe, ob die Datei existiert.
        - Wenn ja, versuche sie zu lesen: `std::fs::read_to_string(path).map_err(|e| ConfigError::FileReadError { path: path.to_path_buf(), source: e })?`.
        - Versuche, den Inhalt zu deserialisieren: `toml::from_str(&content_str).map_err(|e| ConfigError::DeserializationError { path: path.to_path_buf(), source: e })?`.
        - Wenn erfolgreich, gib `Ok(config)` zurück.
    3. Wenn keine Datei gefunden oder erfolgreich geparst wurde, gib `Err(ConfigError::NoConfigurationFileFound { checked_paths: config_paths.to_vec() })` zurück.

#### Statischer Zugriff (`core::config::mod.rs` oder `core::config::global.rs`)

Rust

```
// In core::config::mod.rs oder einem neuen core::config::global.rs
use super::types::CoreConfig;
use super::errors::ConfigError;
use once_cell::sync::OnceCell;
use std::path::PathBuf;

static CORE_CONFIG: OnceCell<CoreConfig> = OnceCell::new();

/// Initialisiert die globale Core-Konfiguration.
/// Darf nur einmal während des Anwendungsstarts aufgerufen werden.
pub fn initialize_global_core_config(config: CoreConfig) -> Result<(), ConfigError> {
    CORE_CONFIG.set(config).map_err(|_| ConfigError::AlreadyInitializedError)
}

/// Gibt eine Referenz auf die global initialisierte Core-Konfiguration zurück.
///
/// # Panics
///
/// Paniert, wenn `initialize_global_core_config()` nicht zuvor erfolgreich aufgerufen wurde.
/// Dies signalisiert einen schwerwiegenden Programmierfehler in der Anwendungsinitialisierung.
pub fn get_global_core_config() -> &'static CoreConfig {
    CORE_CONFIG.get().expect("CoreConfig wurde nicht initialisiert. initialize_global_core_config() muss zuerst aufgerufen werden.")
}

/// Lädt die Konfiguration von den angegebenen Pfaden und initialisiert sie global.
/// Dies ist eine Bequemlichkeitsfunktion.
pub fn load_and_initialize_global_config(config_paths: &[PathBuf]) -> Result<(), ConfigError> {
    use super::loader::load_core_config; // Pfad anpassen
    let config = load_core_config(config_paths)?;
    initialize_global_core_config(config)
}
```

##### Implementierungsschritte `core::config`

1. **Abhängigkeiten in `core/Cargo.toml`:**
    
    Ini, TOML
    
    ```
    serde = { version = "1.0", features = ["derive"] }
    toml = "0.8" # Aktuelle Version prüfen
    once_cell = "1.19" # Aktuelle Version prüfen
    ```
    
2. **Verzeichnisstruktur erstellen:** `core/src/config/`, darin `mod.rs`, `errors.rs`, `types.rs`, `loader.rs`, `global.rs` (optional).
3. **`errors.rs`:** `ConfigError` Enum implementieren.
4. **`types.rs`:** `CoreConfig` (und ggf. untergeordnete Strukturen wie `LogLevelConfig`, `FeatureFlags`) mit `serde`-Attributen und `Default`-Implementierungen definieren. Default-Funktionen erstellen.
5. **`loader.rs`:** `load_core_config` Funktion implementieren.
6. **`global.rs` (oder `mod.rs`):** Statische `CORE_CONFIG` Variable mit `OnceCell`, `initialize_global_core_config`, `get_global_core_config` und `load_and_initialize_global_config` implementieren.
7. **`config/mod.rs`:** Module deklarieren und öffentliche Typen/Funktionen re-exportieren.
    
    Rust
    
    ```
    pub mod errors;
    pub mod types;
    pub mod loader;
    pub mod global; // oder Inhalt direkt hier
    
    pub use errors::ConfigError;
    pub use types::{CoreConfig, LogLevelConfig, FeatureFlags}; // Beispiele
    pub use loader::load_core_config;
    pub use global::{initialize_global_core_config, get_global_core_config, load_and_initialize_global_config};
    ```
    
8. **Aktualisierung `core/src/lib.rs`:** `pub mod config;`
9. **Unit-Tests:**
    - `ConfigError`: Teste Display-Implementierungen.
    - `CoreConfig`: Teste `Default`-Implementierung und `serde` (De-)Serialisierung mit Beispieldaten (gültiges TOML, TOML mit fehlenden Feldern, TOML mit unbekannten Feldern bei `deny_unknown_fields`).
    - `load_core_config`:
        - Test mit gültiger Konfigurationsdatei.
        - Test mit mehreren Pfaden, wobei die erste gefundene Datei verwendet wird.
        - Test, wenn keine Datei gefunden wird (`NoConfigurationFileFound`).
        - Test mit nicht lesbarer Datei (`FileReadError`).
        - Test mit fehlerhafter TOML-Syntax (`DeserializationError`).
    - Globaler Zugriff: Teste `initialize_global_core_config` (Erfolg, Fehler bei Mehrfachinitialisierung), `get_global_core_config` (Erfolg nach Init, Panic vor Init).

---

### Modul: `core::utils` (Allgemeine Hilfsfunktionen)

**Zweck:** Beherbergt allgemeine, in sich geschlossene Hilfsfunktionen, die nicht in spezifischere Module passen.

**Designphilosophie:** Einfachheit, Reinheit (wo möglich), keine Abhängigkeiten zu anderen Kernschicht-Modulen außer `core::errors` (für Utility-spezifische Fehler).

**Abhängigkeiten:** `std`, `thiserror`.

**Struktur:** Dieses Modul kann in Submodule unterteilt werden, falls viele Utilities entstehen (z.B. `core::utils::string`, `core::utils::math`). Für den Anfang eine einzelne `src/utils.rs`.

**Datei:** `src/utils.rs` (und ggf. `src/utils/errors.rs`)

#### Beispiel: Utility-Submodul `core::utils::path_utils`

**Datei:** `src/utils/path_utils.rs`

##### 1. Enum: `PathUtilError`

- **Ableitungen:** `#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]`
- **Varianten:**
    - `#[error("Path normalization failed: {0}")]` `NormalizationFailed(String)`

##### 2. Funktion: `normalize_path_robustly` (Beispiel für ein komplexeres Utility)

- **Signatur:** `pub fn normalize_path_robustly(path: &std::path::Path) -> Result<PathBuf, PathUtilError>`
- **Logik:** (Hier würde eine detaillierte Schritt-für-Schritt-Beschreibung des Normalisierungsalgorithmus stehen, z.B. Auflösen von `.` und `..`, Umgang mit Symlinks (falls im Scope), Sicherstellung einer kanonischen Form). Für diese Spezifikation wird kein konkreter Algorithmus vorgegeben, da die Anforderung eines "komplexen" Utilities noch nicht klar ist.
- **Fehlerbehandlung:** Gibt `PathUtilError` zurück.

#### Allgemeine Richtlinien für `core::utils`

- **Geltungsbereich:** Nur wirklich allgemeine Utilities.
- **Einfachheit:** Einfache Funktionen bevorzugen.
- **Reinheit:** Reine Funktionen bevorzugen.
- **Fehlerbehandlung:** Jede fehleranfällige Utility-Funktion gibt `Result<T, YourUtilError>` zurück, wobei `YourUtilError` mit `thiserror` im Utility-Submodul definiert und in einen allgemeinen `UtilsError` (oder direkt in `CoreError` via `#[from]`, falls sehr generisch) gewrappt werden kann.
- **Dokumentation:** Umfassende `rustdoc`-Kommentare mit Beispielen.
- **Tests:** Gründliche Unit-Tests für jede Utility-Funktion.

##### Implementierungsschritte `core::utils`

1. **Datei `core/src/utils/mod.rs` (oder `core/src/utils.rs`) erstellen.**
2. Falls Submodule für Utilities benötigt werden (z.B. `path_utils.rs`), diese erstellen und in `utils/mod.rs` deklarieren.
3. Für jedes Utility oder Utility-Submodul ggf. eine eigene `errors.rs` erstellen oder Fehler im Haupt-`core::errors` definieren, falls extrem generisch.
4. Utility-Funktionen implementieren, dabei die oben genannten Richtlinien beachten.
5. Umfassende Unit-Tests für jede Funktion schreiben.
6. **Aktualisierung `core/src/lib.rs`:** `pub mod utils;`

---

**Finale `core/src/lib.rs` (Beispiel):**

Rust

```
// src/lib.rs

// Module deklarieren
pub mod config;
pub mod errors;
pub mod logging;
pub mod types;
pub mod utils;

// Wichtige Typen und Funktionen re-exportieren, falls gewünscht
pub use errors::{CoreError, ColorParseError}; // Beispiel
pub use types::{Point, Size, Rect, RectInt, Color, Orientation}; // Beispiel
// ...usw. für andere Module, falls eine flachere API für das Crate gewünscht ist.

// Dieser Crate dient als Fundament und sollte keine spezifische Anwendungslogik enthalten.
// Seine API sollte stabil und gut dokumentiert sein.
```

---

## 3. Ausblick auf weitere Schichten (Methodik)

Die Ultra-Feinspezifikationen für die Domänen-, System- und UI-Schicht würden derselben detaillierten Methodik folgen:

1. **Modulübersicht:** Zweck, Verantwortlichkeiten, Design-Rationale.
2. **Datenstrukturen und Typdefinitionen:**
    - Alle `struct`s, `enum`s, `trait`s, Typaliase in Rust-Syntax.
    - Felder/Varianten: Name, Typ, Sichtbarkeit, Initialwerte (falls zutreffend).
    - Ableitungen (`Debug`, `Clone`, `Serialize`, `Deserialize`, `Default`, `thiserror::Error`, etc.).
    - Invarianten und Geschäftsregeln, die durch die Typen abgebildet werden.
3. **Öffentliche API und Interne Schnittstellen:**
    - Exakte Signaturen aller `pub fn`, `pub trait`, `pub struct` Methoden (Parameter: Name, Typ; Rückgabetyp; `async`, `const`, Zugriffsmodifikatoren).
    - Vor- und Nachbedingungen für jede Methode.
    - Detaillierte Beschreibung der Logik/Algorithmen, die die Methode implementiert.
4. **Event-Spezifikationen (falls zutreffend):**
    - Eindeutiger Event-Name/Typ (Rust-Struktur).
    - Payload-Struktur (Felder und deren Typen).
    - Typische Publisher und Subscriber.
    - Auslösebedingungen für das Event.
5. **Fehlerbehandlung:**
    - Definition des modulspezifischen Fehler-Enums mit `thiserror`.
    - Jede Variante: `#[error("...")]`-Nachricht, Felder für Kontext.
    - Verwendung von `#[source]` und `#[from]` für Fehlerverkettung und -konvertierung.
    - Abbildung von Fehlern aus tieferliegenden Schichten oder externen Bibliotheken.
6. **Zustandsverwaltung und Lebenszyklus (für komplexe Komponenten):**
    - Detaillierte Beschreibung des internen Zustands.
    - Methoden zur Zustandsänderung und deren Auswirkungen.
    - Lebenszyklusmanagement (Initialisierung, Laufzeit, Beendigung).
7. **Interaktionen und Abhängigkeiten:**
    - Mit anderen Modulen derselben Schicht.
    - Mit Modulen anderer Schichten (explizite Nutzung von deren APIs oder Events).
8. **Detaillierte Implementierungsschritte:**
    - Ziel-Dateistruktur für das Modul.
    - Schritt-für-Schritt-Anleitung zur Implementierung von Datenstrukturen, Logik und API.
    - Reihenfolge der Implementierung von Funktionen/Methoden.
9. **Testaspekte:**
    - Identifikation testkritischer Logik.
    - Beispiele für Unit-Testfälle (Szenarien, Eingaben, erwartete Ausgaben/Fehler).
    - Hinweise zu Mocking-Strategien für Abhängigkeiten.

Für die **Domänenschicht** würde dies beispielsweise für `domain::theming`, `domain::workspaces`, `domain::user_centric_services` etc. detailliert erfolgen, wobei jede Entität, jeder Service-Trait und jede Methode genau spezifiziert wird.

Für die **Systemschicht** (z.B. `system::compositor`, `system::input`, `system::dbus`) wäre die Spezifikation besonders komplex, da sie die Interaktion mit externen Bibliotheken (Smithay, libinput, zbus), Wayland-Protokollen und Systemdiensten detailliert beschreiben muss. Hier wären die Handler-Implementierungen (z.B. `CompositorHandler`, `XdgShellHandler`) und die exakte Nutzung der Smithay-APIs im Fokus.

Für die **UI-Schicht** (z.B. `ui::shell`, `ui::widgets`, `ui::control_center`) würde die Spezifikation die GTK4-Widget-Struktur, das Layout, die Signal-Handler, die Datenbindung an Domänen-/Systemzustände und die Logik zur Auslösung von Aktionen in den unteren Schichten detailliert beschreiben.

Dieser extrem detaillierte Ansatz ist sehr aufwendig, stellt aber sicher, dass Entwickler eine klare, unmissverständliche Anleitung haben, was die Konsistenz und Qualität des Endprodukts maßgeblich verbessert.

---

**Struktur der Domänenschicht-Spezifikation:**

Die Domänenschicht (`novade-domain` Crate) wird in folgende logische Hauptmodule unterteilt, die teilweise bereits in Ihren Dokumenten skizziert wurden. Ich werde diese Struktur beibehalten und verfeinern:

1. **`domain::theming`**: Logik der Theming-Engine. (Basierend auf)
2. **`domain::workspaces`**: Umfassende Verwaltungslogik für Arbeitsbereiche. (Basierend auf)
    - `workspaces::core`
    - `workspaces::assignment`
    - `workspaces::manager`
    - `workspaces::config`
3. **`domain::user_centric_services`**: KI-Interaktion und Benachrichtigungsmanagement. (Basierend auf)
    - `user_centric_services::ai_interaction`
    - `user_centric_services::notifications_core`
4. **`domain::notifications_rules`**: Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf Regeln. (Basierend auf der Gesamtspezifikation und )
5. **`domain::global_settings_and_state_management`**: Repräsentation und Logik globaler Desktop-Einstellungen. (Basierend auf der Gesamtspezifikation und)
    - `global_settings::types` (Definition der Einstellungsstrukturen)
    - `global_settings::service` (Der `GlobalSettingsService` Trait und Implementierung)
    - `global_settings::paths` (Der `SettingPath` Enum)
    - `global_settings::persistence_iface` (Trait für die Persistenz, Interaktion mit `core::config`)
6. **`domain::window_management_policy`**: High-Level-Regeln und Richtlinien für Fensterplatzierung, Tiling etc. (Basierend auf der Gesamtspezifikation)
7. **`domain::common_events`**: Definition von Domänen-übergreifenden Events, die nicht spezifisch einem einzelnen Service zugeordnet sind, oder als gemeinsame Payloads dienen.
8. **`domain::shared_types`**: Wiederverwendbare, domänenspezifische Typen, die von mehreren Domänenmodulen genutzt werden, aber nicht in `core::types` gehören (z.B. spezifische IDs, Status-Enums).

**Allgemeine Entwicklungsrichtlinien für die Domänenschicht (Wiederholung und Erweiterung):**

- **UI-Unabhängigkeit:** Die Domänenschicht darf keine direkten Abhängigkeiten zu UI-Toolkits (GTK4) oder spezifischen UI-Implementierungen haben.
- **Systemunabhängigkeit:** Keine direkte Abhängigkeit von Systemdetails wie D-Bus oder Wayland-Protokollen. Diese werden von der Systemschicht gehandhabt.
- **Fokus auf Geschäftslogik:** Enthält die Kernregeln und -prozesse der Desktop-Umgebung.
- **API-Design:** Öffentliche Schnittstellen werden primär über Traits definiert, um Testbarkeit (Mocking) und lose Kopplung zu fördern.
- **Zustandsverwaltung:** Veränderliche Zustände innerhalb von Services werden threadsicher gekapselt (z.B. `Arc<Mutex<...>>` oder `Arc<RwLock<...>>`).
- **Asynchronität:** `async/await` und `async_trait` werden für Operationen verwendet, die potenziell blockieren könnten (z.B. Warten auf Ergebnisse von der Systemschicht, komplexe Berechnungen, die ausgelagert werden können). Die primäre Runtime (z.B. `tokio`) wird von der Anwendung bereitgestellt, die die Domänenschicht nutzt.
- **Events:** Ein klar definierter Event-Mechanismus (z.B. `tokio::sync::broadcast` oder ein dedizierter Event-Bus-Trait) wird für die Kommunikation von Zustandsänderungen zwischen Domänenmodulen und an höhere Schichten verwendet.
- **Fehlerbehandlung:** Konsequente Nutzung von `thiserror` für modulspezifische Fehler-Enums. Fehler aus der Kernschicht werden ggf. gewrappt (`#[from]`).
- **Validierung:** Eingabedaten und Zustandsänderungen werden aktiv validiert.
- **Serialisierung:** `serde` wird für Datenstrukturen verwendet, die persistiert oder über Schnittstellen ausgetauscht werden müssen.
- **Abhängigkeit zur Kernschicht:** Die Domänenschicht nutzt ausschließlich die Kernschicht (`core::*`) für fundamentale Typen, Fehlerbasis, Logging und Konfigurationsprimitive.

---

## Ultra-Feinspezifikation: Domänenschicht (`novade-domain` Crate)

### Modul 1: `domain::theming`

**Zweck:** Logik des Erscheinungsbilds (Theming), Verwaltung von Design-Tokens, Interpretation von Theme-Definitionen, dynamische Theme-Wechsel.

**Bestehende Spezifikation:** wird als Basis verwendet und hier integriert/verfeinert.

#### Untermodul: `domain::theming::types`

**Datei:** `src/theming/types.rs`

- **Struct `TokenIdentifier`**: Wie in spezifiziert.
    - **Ableitungen zusätzlich:** `Ord, PartialOrd` (für konsistente Sortierung in HashMaps/Sets, falls Schlüssel Iteriert werden).
- **Enum `TokenValue`**: Wie in spezifiziert.
    - **Ableitungen zusätzlich:** `Eq, Hash` (falls `TokenIdentifier` es ist und für `Color`, `Dimension` etc. eine Hash-Implementierung sinnvoll ist – für String-basierte Werte ist dies der Fall).
- **Struct `RawToken`**: Wie in spezifiziert.
- **Typalias `TokenSet`**: Wie in spezifiziert.
- **Struct `ThemeIdentifier`**: Wie in spezifiziert.
    - **Ableitungen zusätzlich:** `Ord, PartialOrd`.
- **Enum `ColorSchemeType`**: Wie in spezifiziert.
    - **Ableitungen zusätzlich:** `Eq, Hash`.
- **Struct `AccentColor`**: Wie in spezifiziert.
    - **Ableitungen zusätzlich:** `Eq, Hash` (falls `name` `Option<String>` ist und `value` `String`).
- **Struct `ThemeVariantDefinition`**: Wie in spezifiziert.
- **Struct `ThemeDefinition`**: Wie in spezifiziert.
- **Struct `AppliedThemeState`**: Wie in spezifiziert.
    - **Felder:**
        - `pub theme_id: ThemeIdentifier`
        - `pub color_scheme: ColorSchemeType`
        - `pub active_accent_color: Option<AccentColor>`
        - `pub resolved_tokens: std::collections::HashMap<TokenIdentifier, String>`
    - **Invarianten:** `resolved_tokens` darf keine Referenzen enthalten, alle Werte sind finale CSS-Strings.
- **Struct `ThemingConfiguration`**: Wie in spezifiziert.

#### Untermodul: `domain::theming::errors`

**Datei:** `src/theming/errors.rs`

- **Enum `ThemingError`**: Wie in spezifiziert.
    - **Varianten (Beispiele, konsolidiert):**
        - `TokenFileParseError { path: PathBuf, #[source] source: serde_json::Error }`
        - `TokenFileIoError { path: PathBuf, #[source] source: std::io::Error }`
        - `InvalidTokenData { path: PathBuf, message: String }`
        - `CyclicTokenReference { token_id: TokenIdentifier, cycle_path: Vec<TokenIdentifier> }`
        - `ThemeFileLoadError { theme_id: ThemeIdentifier, path: PathBuf, #[source] source: serde_json::Error }`
        - `ThemeFileIoError { theme_id: ThemeIdentifier, path: PathBuf, #[source] source: std::io::Error }`
        - `InvalidThemeData { theme_id: ThemeIdentifier, path: PathBuf, message: String }`
        - `ThemeNotFound { theme_id: ThemeIdentifier }`
        - `MissingTokenReference { referencing_token_id: TokenIdentifier, target_token_id: TokenIdentifier }`
        - `MaxReferenceDepthExceeded { token_id: TokenIdentifier, depth: u8 }`
        - `ThemeApplicationError { message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
        - `FallbackThemeLoadError { #[source] source: Box<dyn std::error::Error + Send + Sync + 'static> }`
        - `InitialConfigurationError(String)`
        - `InternalStateError(String)`
        - `EventSubscriptionError(String)`
        - `AccentColorProcessingError { theme_id: ThemeIdentifier, accent_value: String, message: String }` (Neu, für Fehler bei Akzentfarben-Anwendung)
        - `TokenResolutionError { token_id: TokenIdentifier, message: String }` (Allgemeiner Fehler während der Auflösung)

#### Untermodul: `domain::theming::logic` (oder `domain::theming::engine_internal`)

**Datei:** `src/theming/logic.rs` (oder aufgeteilt in `token_loader.rs`, `theme_loader.rs`, `token_resolver.rs` etc.)

- **Kernlogik und Geschäftsregeln** wie in spezifiziert:
    - Laden, Parsen, Validieren von Token- (_.tokens.json) und Theme-Definitionen (_.theme.json).
        - **Funktion:** `pub(crate) async fn load_and_validate_token_files(paths: &[PathBuf]) -> Result<TokenSet, ThemingError>`
        - **Funktion:** `pub(crate) async fn load_and_validate_theme_files(paths: &[PathBuf], global_tokens: &TokenSet) -> Result<Vec<ThemeDefinition>, ThemingError>`
    - Token Resolution Pipeline:
        - **Funktion:** `pub(crate) fn resolve_tokens_for_config(config: &ThemingConfiguration, theme_def: &ThemeDefinition, global_tokens: &TokenSet, max_depth: u8) -> Result<std::collections::HashMap<TokenIdentifier, String>, ThemingError>`
            - Schritt 1: Basissatz (Globale Tokens + Theme Base Tokens)
            - Schritt 2: Varianten-spezifische Tokens anwenden
            - Schritt 3: Akzentfarben-Logik anwenden (Direkte Ersetzung spezifischer Tokens, z.B. `token.system.accent.primary`, `token.system.accent.secondary`)
            - Schritt 4: Benutzerdefinierte globale Token-Overrides anwenden
            - Schritt 5: Rekursive Auflösung von `TokenValue::Reference` mit Zyklenerkennung und Tiefenbegrenzung.
            - Schritt 6: Finale Wertkonvertierung zu `String`.
    - Caching-Logik für `AppliedThemeState`.
        - **Typ:** `CacheKey(ThemeIdentifier, ColorSchemeType, Option<AccentColorHash>, UserOverridesHash)`
        - Cache-Struktur: `std::collections::HashMap<CacheKey, AppliedThemeState>`
    - Laden des Fallback-Themes (siehe).
        - **Funktion:** `pub(crate) fn load_fallback_theme_definition() -> Result<(ThemeDefinition, TokenSet), ThemingError>` (aus eingebetteten Strings)
        - **Funktion:** `pub(crate) fn generate_fallback_applied_state() -> AppliedThemeState`

#### Öffentliche API: `ThemingEngine` Service

**Datei:** `src/theming/mod.rs` (oder `src/theming/api.rs` oder `src/theming/service.rs`)

- **Struct `ThemingEngine`**: Wie in spezifiziert, verwendet `Arc<Mutex<ThemingEngineInternalState>>`.
    - **`ThemingEngineInternalState` Felder:**
        - `current_config: ThemingConfiguration`
        - `available_themes: Vec<ThemeDefinition>`
        - `global_raw_tokens: TokenSet`
        - `applied_state: AppliedThemeState`
        - `theme_load_paths: Vec<PathBuf>`
        - `token_load_paths: Vec<PathBuf>`
        - `resolved_state_cache: std::collections::HashMap<(ThemeIdentifier, ColorSchemeType, Option<String>, u64), AppliedThemeState>` (Cache-Schlüssel muss Hashable sein; Option&lt;AccentColor> könnte zu Option&lt;String> für den Farbwert vereinfacht werden, UserOverrides zu einem Hash).
        - `event_sender: tokio::sync::broadcast::Sender<ThemeChangedEvent>` (anstelle von `mpsc`)
- **Methoden der `ThemingEngine`**:
    - `pub async fn new(initial_config: ThemingConfiguration, theme_load_paths: Vec<PathBuf>, token_load_paths: Vec<PathBuf>, broadcast_capacity: usize) -> Result<Self, ThemingError>`
        - Initialisiert `event_sender = tokio::sync::broadcast::channel(broadcast_capacity).0;`
        - Lädt Themes und Tokens asynchron.
        - Berechnet initialen `applied_state` oder Fallback.
    - `pub async fn get_current_theme_state(&self) -> AppliedThemeState` (gibt Klon von `applied_state` zurück, kein `Result` wenn interner Zustand immer gültig ist).
    - `pub async fn get_available_themes(&self) -> Vec<ThemeDefinition>` (gibt Klon zurück).
    - `pub async fn get_current_configuration(&self) -> ThemingConfiguration` (gibt Klon zurück).
    - `pub async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
        - Berechnet neuen `applied_state`.
        - Wenn geändert, `self.event_sender.send(ThemeChangedEvent { ... }).map_err(...)`. Ignoriere Fehler, wenn keine Subscriber da sind (`Ok(_)`).
    - `pub async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`
        - Lädt Themes/Tokens neu.
        - Wendet `current_config` neu an, aktualisiert `applied_state`.
        - Sendet Event, falls geändert.
        - Invalidiert Cache.
    - `pub fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeChangedEvent>`
        - Gibt `self.event_sender.subscribe()` zurück.
- **Event `ThemeChangedEvent`**: Wie in spezifiziert.
    - **Payload:** `pub new_state: AppliedThemeState`
    - **Publisher:** `ThemingEngine`
    - **Subscriber:** `ui::theming_gtk`, andere UI-Komponenten, `domain::global_settings_service` (falls Theming von globalen Einstellungen abhängt).

#### Implementierungsschritte `domain::theming`

1. **Dateistruktur anlegen:** Gemäß.
2. **`types.rs` implementieren:** Alle Datenstrukturen mit `serde`-Attributen und Ableitungen.
3. **`errors.rs` implementieren:** `ThemingError`-Enum mit `thiserror`.
4. **`logic.rs` (oder Submodule) implementieren:**
    - Token-/Theme-Lade- und Validierungsfunktionen (asynchron).
    - Token Resolution Pipeline (synchron, da CPU-gebunden nach dem Laden).
    - Fallback-Theme-Logik.
    - Caching-Logik.
5. **`ThemingEngine`-Service (`mod.rs` oder `service.rs`) implementieren:**
    - `ThemingEngineInternalState` und `ThemingEngine` Strukturen.
    - `new()`-Konstruktor (asynchron).
    - Alle öffentlichen API-Methoden (asynchron, wo sinnvoll).
    - Event-Versand mit `tokio::sync::broadcast`.
6. **Unit-Tests:**
    - Für alle Datenstrukturen: Serialisierung/Deserialisierung.
    - Für `ThemingError`: `Display`-Implementierung und `source()`-Verhalten.
    - Für Lade-/Validierungslogik: Gültige/ungültige Dateien, Zyklen, fehlende Referenzen.
    - Für Token Resolution Pipeline: Verschiedene Szenarien (Basis, Varianten, Overrides, Akzente, komplexe Referenzen, Fehlerfälle).
    - Für `ThemingEngine`: API-Methodenverhalten, Zustandsänderungen, Event-Auslösung, Cache-Verhalten, Thread-Sicherheit (konzeptionell, durch korrekte Mutex-Nutzung).

---

### Modul 2: `domain::workspaces`

**Zweck:** Umfassende Verwaltungslogik für Arbeitsbereiche ("Spaces").

**Bestehende Spezifikation:** wird als Basis verwendet.

#### Untermodul: `domain::workspaces::core`

**Datei:** `src/workspaces/core/types.rs` (konsolidiert Typen hier)

- **Typalias `WorkspaceId`**: `pub type WorkspaceId = uuid::Uuid;`
- **Struct `WindowIdentifier`**: `#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)] pub struct WindowIdentifier(String);`
    - Methoden: `new(id: String) -> Result<Self, WorkspaceCoreError>`, `as_str()`. `From<String>` für einfache Konvertierung (kann Validierung in `new` haben). `Display`-Implementierung.
- **Enum `WorkspaceLayoutType`**: `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)] pub enum WorkspaceLayoutType { #[default] Floating, TilingHorizontal, TilingVertical, Maximized }`
- **Struct `Workspace`**: Wie in spezifiziert.
    - **Felder:** `id: WorkspaceId`, `name: String`, `persistent_id: Option<String>`, `layout_type: WorkspaceLayoutType`, `window_ids: HashSet<WindowIdentifier>`, `created_at: chrono::DateTime<chrono::Utc>`.
    - **Ableitungen:** `#[derive(Debug, Clone, Serialize, Deserialize)]` (`PartialEq` ggf. manuell wegen `HashSet`).
    - **Methoden:** `new(...) -> Result<Self, WorkspaceCoreError>`, `id()`, `name()`, `rename(...) -> Result<...>`, `layout_type()`, `set_layout_type(...)`, `add_window_id(&mut self, ...)` (pub(crate)), `remove_window_id(&mut self, ...)` (pub(crate)), `window_ids()`, `persistent_id()`, `set_persistent_id(...) -> Result<...>`, `created_at()`.

**Datei:** `src/workspaces/core/event_data.rs`

- **Event-Payload-Strukturen**: `WorkspaceRenamedData`, `WorkspaceLayoutChangedData`, `WindowAddedToWorkspaceData`, `WindowRemovedFromWorkspaceData`, `WorkspacePersistentIdChangedData` - wie in spezifiziert. Alle mit `#[derive(Debug, Clone, Serialize, Deserialize)]`.

**Datei:** `src/workspaces/core/errors.rs`

- **Konstante `MAX_WORKSPACE_NAME_LENGTH`**: `pub const MAX_WORKSPACE_NAME_LENGTH: usize = 64;`
- **Enum `WorkspaceCoreError`**: Wie in spezifiziert.
    - **Varianten (konsolidiert):**
        - `InvalidName(String)`
        - `NameCannotBeEmpty`
        - `NameTooLong { name: String, max_len: usize, actual_len: usize }`
        - `InvalidPersistentId(String)` (z.B. leer oder ungültige Zeichen)
        - `Internal { context: String }`
        - `WindowIdentifierEmpty` (Für `WindowIdentifier::new`)

#### Untermodul: `domain::workspaces::assignment`

**Datei:** `src/workspaces/assignment/mod.rs`

- **Öffentliche API-Funktionen**: Operieren auf `&mut std::collections::HashMap<WorkspaceId, Workspace>`. Wie in spezifiziert.
    - `pub fn assign_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier, ensure_unique_assignment: bool) -> Result<(), WindowAssignmentError>`
    - `pub fn remove_window_from_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, source_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<bool, WindowAssignmentError>`
    - `pub fn move_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, source_workspace_id: WorkspaceId, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WindowAssignmentError>`
    - `pub fn find_workspace_for_window(workspaces: &HashMap<WorkspaceId, Workspace>, window_id: &WindowIdentifier) -> Option<WorkspaceId>`

**Datei:** `src/workspaces/assignment/errors.rs`

- **Enum `WindowAssignmentError`**: Wie in spezifiziert.
    - **Varianten (konsolidiert):**
        - `WorkspaceNotFound(WorkspaceId)`
        - `WindowAlreadyAssigned { workspace_id: WorkspaceId, window_id: WindowIdentifier }`
        - `WindowNotAssignedToWorkspace { workspace_id: WorkspaceId, window_id: WindowIdentifier }`
        - `SourceWorkspaceNotFound(WorkspaceId)`
        - `TargetWorkspaceNotFound(WorkspaceId)`
        - `WindowNotOnSourceWorkspace { workspace_id: WorkspaceId, window_id: WindowIdentifier }`
        - `CannotMoveToSameWorkspace { workspace_id: WorkspaceId, window_id: WindowIdentifier }`
        - `RuleViolation { reason: String, window_id: Option<WindowIdentifier>, target_workspace_id: Option<WorkspaceId> }`
        - `Internal { context: String }`

#### Untermodul: `domain::workspaces::manager`

**Datei:** `src/workspaces/manager/events.rs`

- **Enum `WorkspaceEvent`**: Wie in spezifiziert. Alle Payloads mit `#[derive(Debug, Clone, Serialize, Deserialize)]`.
    - Payload-Strukturen aus `workspaces::core::event_data` werden hier verwendet.

**Datei:** `src/workspaces/manager/errors.rs`

- **Enum `WorkspaceManagerError`**: Wie in spezifiziert.
    - **Varianten (konsolidiert):**
        - `WorkspaceNotFound(WorkspaceId)`
        - `CannotDeleteLastWorkspace`
        - `DeleteRequiresFallbackForWindows { workspace_id: WorkspaceId, window_count: usize }`
        - `FallbackWorkspaceNotFound(WorkspaceId)`
        - `CoreError { #[from] source: crate::domain::workspaces::core::errors::WorkspaceCoreError }`
        - `AssignmentError { #[from] source: crate::domain::workspaces::assignment::errors::WindowAssignmentError }`
        - `ConfigError { #[from] source: crate::domain::workspaces::config::errors::WorkspaceConfigError }`
        - `SetActiveWorkspaceNotFound(WorkspaceId)`
        - `NoActiveWorkspace`
        - `DuplicatePersistentId(String)`
        - `Internal { context: String }`

**Datei:** `src/workspaces/manager/mod.rs` (oder `service.rs`)

- **Trait `EventPublisher<E>` (Beispiel, falls nicht global):** `pub trait EventPublisher<E: Clone + Send + 'static>: Send + Sync { fn publish(&self, event: E); }`
- **Struct `WorkspaceManager`**: Wie in spezifiziert.
    - **Felder:**
        - `workspaces: HashMap<WorkspaceId, Workspace>`
        - `active_workspace_id: Option<WorkspaceId>`
        - `ordered_workspace_ids: Vec<WorkspaceId>`
        - `next_workspace_number: u32`
        - `config_provider: Arc<dyn WorkspaceConfigProvider>` (aus `workspaces::config`)
        - `event_publisher: tokio::sync::broadcast::Sender<WorkspaceEvent>`
        - `ensure_unique_window_assignment: bool`
- **Methoden der `WorkspaceManager`** (alle `async` wo I/O oder potenziell blockierende Logik involviert ist, insbesondere `save_configuration` und `new`):
    - `pub async fn new(config_provider: Arc<dyn WorkspaceConfigProvider>, broadcast_capacity: usize, ensure_unique_window_assignment: bool) -> Result<Self, WorkspaceManagerError>`
    - `pub async fn create_workspace(&mut self, name: Option<String>, persistent_id: Option<String>) -> Result<WorkspaceId, WorkspaceManagerError>`
    - `pub async fn delete_workspace(&mut self, id: WorkspaceId, fallback_id_for_windows: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError>`
    - `pub fn get_workspace(&self, id: WorkspaceId) -> Option<&Workspace>`
    - `pub fn get_workspace_mut(&mut self, id: WorkspaceId) -> Option<&mut Workspace>`
    - `pub fn all_workspaces_ordered(&self) -> Vec<&Workspace>`
    - `pub fn active_workspace_id(&self) -> Option<WorkspaceId>`
    - `pub async fn set_active_workspace(&mut self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - `pub async fn assign_window_to_active_workspace(&mut self, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
    - `pub async fn assign_window_to_specific_workspace(&mut self, workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
    - `pub async fn remove_window_from_its_workspace(&mut self, window_id: &WindowIdentifier) -> Result<Option<WorkspaceId>, WorkspaceManagerError>`
    - `pub async fn move_window_to_specific_workspace(&mut self, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
    - `pub async fn rename_workspace(&mut self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`
    - `pub async fn set_workspace_layout(&mut self, id: WorkspaceId, layout_type: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>`
    - `pub async fn save_configuration(&self) -> Result<(), WorkspaceManagerError>`
    - `pub fn subscribe_to_workspace_events(&self) -> tokio::sync::broadcast::Receiver<WorkspaceEvent>`

#### Untermodul: `domain::workspaces::config`

**Datei:** `src/workspaces/config/errors.rs`

- **Enum `WorkspaceConfigError`**: Wie in spezifiziert.
    - **Varianten (konsolidiert):**
        - `LoadError { path: String, #[source] source: crate::core::config::ConfigError }` (nutzt `ConfigError` aus `core`)
        - `SaveError { path: String, #[source] source: crate::core::config::ConfigError }`
        - `InvalidData { reason: String, path: Option<String> }`
        - `SerializationError { message: String, #[source] source: Option<serde_json::Error> }` (oder `toml::ser::Error`)
        - `DeserializationError { message: String, snippet: Option<String>, #[source] source: Option<serde_json::Error> }` (oder `toml::de::Error`)
        - `PersistentIdNotFoundInLoadedSet { persistent_id: String }` (Umbenannt für Klarheit)
        - `DuplicatePersistentIdInLoadedSet { persistent_id: String }` (Umbenannt für Klarheit)
        - `VersionMismatch { expected: Option<String>, found: Option<String> }`
        - `Internal { context: String }`

**Datei:** `src/workspaces/config/mod.rs` (oder `provider.rs` und `types.rs` hier)

- **Struct `WorkspaceSnapshot`**: Wie in spezifiziert. `#[derive(Debug, Clone, Serialize, Deserialize)]`.
    - Felder: `persistent_id: String`, `name: String`, `layout_type: WorkspaceLayoutType`.
- **Struct `WorkspaceSetSnapshot`**: Wie in spezifiziert. `#[derive(Debug, Clone, Serialize, Deserialize, Default)]`.
    - Felder: `workspaces: Vec<WorkspaceSnapshot>`, `active_workspace_persistent_id: Option<String>`.
- **Trait `WorkspaceConfigProvider`**: `#[async_trait::async_trait] pub trait WorkspaceConfigProvider: Send + Sync { async fn load_workspace_config(&self) -> Result<WorkspaceSetSnapshot, WorkspaceConfigError>; async fn save_workspace_config(&self, config_snapshot: &WorkspaceSetSnapshot) -> Result<(), WorkspaceConfigError>; }` (Methoden sind `async` da Dateizugriff erfolgt).
- **Struct `FilesystemConfigProvider`**: Wie in spezifiziert.
    - Implementiert `WorkspaceConfigProvider` `async`. Nutzt `core::config::ConfigService` (oder `load_core_config`/`save_core_config` Äquivalente, die `async` sind).
        - **Logik für `load_workspace_config`**: Asynchrones Lesen der Datei, Deserialisierung, Validierung.
        - **Logik für `save_workspace_config`**: Serialisierung, asynchrones Schreiben der Datei.

#### Implementierungsschritte `domain::workspaces`

1. **`core` Modul implementieren:**
    - Dateien `types.rs`, `event_data.rs`, `errors.rs`, `mod.rs` anlegen.
    - Alle Typen, Enums, Fehler und `Workspace`-Methoden implementieren. Unit-Tests.
2. **`assignment` Modul implementieren:**
    - Dateien `errors.rs`, `mod.rs` anlegen.
    - `WindowAssignmentError` und Zuweisungsfunktionen implementieren. Unit-Tests.
3. **`config` Modul implementieren:**
    - Dateien `errors.rs`, `mod.rs` anlegen.
    - Snapshot-Structs, `WorkspaceConfigError`, `WorkspaceConfigProvider`-Trait und `FilesystemConfigProvider` implementieren (`async`). Unit-Tests mit Mocking für `core::config`.
4. **`manager` Modul implementieren:**
    - Dateien `events.rs`, `errors.rs`, `mod.rs` anlegen.
    - `WorkspaceEvent`, `WorkspaceManagerError` und `WorkspaceManager`-Service implementieren (`async`).
    - Integration von `core`, `assignment`, `config` Logik. Event-Versand mit `tokio::sync::broadcast`.
    - Umfassende Unit- und Integrationstests (Mocking für `config_provider` und `event_publisher`).

---

(Die Spezifikationen für die Module 3 bis 8 würden analog folgen, mit derselben Detailtiefe. Aufgrund der aktuellen Längenbeschränkung werde ich die Titel und eine kurze Zusammenfassung der Verantwortlichkeiten für die verbleibenden Module geben, basierend auf der Gesamtspezifikation und Ihrer vorherigen Ausgabe.)

### Modul 3: `domain::user_centric_services`

**Zweck:** KI-Interaktionsmanagement (inkl. Einwilligungen) und Benachrichtigungsmanagement.

**Bestehende Spezifikation:** wird als Basis verwendet.

#### Untermodul: `domain::user_centric_services::ai_interaction`

- **Datenstrukturen:** `AIInteractionContext`, `AIConsent`, `AIModelProfile`, `AttachmentData`, `AIConsentStatus`, `AIDataCategory`.
- **Service Trait:** `AIInteractionLogicService` (asynchron).
- **Fehler-Enum:** `AIInteractionError`.
- **Events:** `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`.

#### Untermodul: `domain::user_centric_services::notifications_core`

- **Datenstrukturen:** `Notification`, `NotificationAction`, `NotificationUrgency`, `NotificationActionType`, `NotificationFilterCriteria`, `NotificationSortOrder`.
- **Service Trait:** `NotificationService` (asynchron).
- **Fehler-Enum:** `NotificationError`.
- **Events:** `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `DoNotDisturbModeChangedEvent`.

**Implementierungsschritte:** Analog zu den vorherigen Modulen, mit Fokus auf die jeweilige Geschäftslogik, Fehlerbehandlung und Event-Auslösung. Die Persistenz von `AIConsent` und `AIModelProfile` wird an `core::config` delegiert.

---

### Modul 4: `domain::notifications_rules`

**Zweck:** Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf konfigurierbaren Regeln.

#### Untermodul: `domain::notifications_rules::types`

- **Struct `RuleCondition`**: Enum mit Varianten wie `AppNameIs(String)`, `SummaryContains(String)`, `UrgencyIs(NotificationUrgency)`, `SettingIsTrue(SettingPath)` etc. Muss rekursive Strukturen wie `And(Vec<RuleCondition>)`, `Or(Vec<RuleCondition>)`, `Not(Box<RuleCondition>)` unterstützen.
- **Struct `RuleAction`**: Enum mit Varianten wie `SuppressNotification`, `SetUrgency(NotificationUrgency)`, `PlaySound(String)`, `MarkAsPersistent(bool)`.
- **Struct `NotificationRule`**: Enthält `id: Uuid`, `description: String`, `conditions: RuleCondition`, `actions: Vec<RuleAction>`, `is_enabled: bool`, `priority: i32`, `stop_processing_after_match: bool`.
- **Typalias `NotificationRuleSet`**: `Vec<NotificationRule>`.

#### Untermodul: `domain::notifications_rules::errors`

- **Enum `NotificationRulesError`**: Varianten wie `InvalidRuleDefinition`, `ConditionEvaluationError` (mit Details zum Fehler), `ActionApplicationError`, `SettingsAccessError` (wenn `SettingIsTrue` evaluiert wird und `GlobalSettingsService` einen Fehler zurückgibt), `RulePersistenceError` (beim Laden/Speichern von Regeln).

#### Untermodul: `domain::notifications_rules::engine` (oder `service.rs`)

- **Struct `NotificationRulesEngine`**:
    - Hält `rules: NotificationRuleSet` (sortiert nach Priorität).
    - Abhängigkeit zum `GlobalSettingsService` (für `SettingIsTrue` Bedingungen).
    - Methode `pub async fn process_notification(&self, notification: &mut Notification, settings: &GlobalDesktopSettings) -> Result<RuleProcessingResult, NotificationRulesError>`
        - Iteriert durch `is_enabled` Regeln in Prioritätsreihenfolge.
        - Für jede Regel: `evaluate_condition(&rule.conditions, notification, settings)`.
        - Wenn Bedingung zutrifft: `apply_actions(&rule.actions, notification)`.
        - Gibt `RuleProcessingResult::Allow` (ggf. modifizierte Notification) oder `RuleProcessingResult::Suppress` zurück.
- **Enum `RuleProcessingResult`**: `Allow(Notification)`, `Suppress { rule_id: Uuid }`.
- **Interne Funktionen**: `evaluate_condition_recursive(...)`, `apply_action_internal(...)`.

#### Untermodul: `domain::notifications_rules::persistence_iface`

- **Trait `NotificationRulesProvider`**: `async fn load_rules() -> Result<NotificationRuleSet, NotificationRulesError>`, `async fn save_rules(rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`.
- Implementierung (z.B. `FilesystemNotificationRulesProvider`) interagiert mit `core::config`.

**Implementierungsschritte:** Datenstrukturen, Fehler, Logik der Engine (rekursive Bedingungsauswertung), Persistenzschnittstelle. Integration mit `notifications_core::NotificationService`.

---

### Modul 5: `domain::global_settings_and_state_management`

**Zweck:** Repräsentation, Logik zur Verwaltung und Konsistenz globaler Desktop-Einstellungen.

**Bestehende Spezifikation:** wird als Basis verwendet.

#### Untermodul: `domain::global_settings::types`

- **Strukturen:** `GlobalDesktopSettings`, `AppearanceSettings`, `WorkspaceSettings`, `FontSettings`, `InputBehaviorSettings`, `PowerManagementPolicySettings`, `DefaultApplicationsSettings` etc. mit allen Feldern und `serde`-Attributen.
- **Enums:** `ColorScheme`, `FontHinting`, `LidCloseAction` etc.
- `SerdeF32` Wrapper.

#### Untermodul: `domain::global_settings::paths`

- **Enum `SettingPath`**: Hierarchischer Enum zur typsicheren Adressierung von Einstellungen (z.B. `SettingPath::Appearance(AppearanceSettingPath::FontSettings(FontSettingPath::DefaultFontSize))`).

#### Untermodul: `domain::global_settings::errors`

- **Enum `GlobalSettingsError`**: Varianten wie `PathNotFound`, `InvalidValueType`, `ValidationError`, `SerializationError`, `DeserializationError`, `PersistenceError { #[from] source: crate::core::config::ConfigError }`.

#### Untermodul: `domain::global_settings::service`

- **Trait `GlobalSettingsService`**: Methoden (`async` wo nötig):
    - `load_settings()`
    - `save_settings()`
    - `get_current_settings() -> GlobalDesktopSettings`
    - `update_setting(path: SettingPath, value: serde_json::Value)`
    - `get_setting(path: &SettingPath) -> Result<serde_json::Value, GlobalSettingsError>`
    - `reset_to_defaults()`
    - `subscribe_to_changes() -> tokio::sync::broadcast::Receiver<SettingChangedEvent>`
- **Implementierung `DefaultGlobalSettingsService`**: Hält `settings: GlobalDesktopSettings`, `persistence_provider: Arc<dyn SettingsPersistenceProvider>`, `event_sender: tokio::sync::broadcast::Sender<SettingChangedEvent>`.

#### Untermodul: `domain::global_settings::persistence_iface`

- **Trait `SettingsPersistenceProvider`**: `async fn load_global_settings() -> Result<GlobalDesktopSettings, GlobalSettingsError>`, `async fn save_global_settings(settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`.
- Implementierung (z.B. `FilesystemSettingsProvider`) interagiert mit `core::config`.

**Events:** `SettingChangedEvent { path: SettingPath, new_value: serde_json::Value }`, `SettingsLoadedEvent { settings: GlobalDesktopSettings }`, `SettingsSavedEvent`.

**Implementierungsschritte:** Definition aller Einstellungsstrukturen, `SettingPath`, Fehler, Service-Trait und Implementierung, Persistenzschnittstelle. Event-Mechanismus.

---

### Modul 6: `domain::window_management_policy`

**Zweck:** Definition von High-Level-Regeln und Richtlinien für Fensterplatzierung, Logik für automatisches Tiling (Layout-Typen wie Spalten, Spiralen), Snapping-Verhalten, Fenstergruppierung und Gap-Management. Diese Schicht definiert die "Policy", die Systemschicht die "Mechanik".

#### Untermodul: `domain::window_management_policy::types`

- **Enum `TilingLayoutType`**: `Columns`, `Rows`, `Spiral`, `MaximizedFocused`, `Floating`.
- **Struct `GapSettings`**: `outer_gap: u32`, `inner_gap: u32`.
- **Struct `WindowSnappingPolicy`**: `snap_to_screen_edges: bool`, `snap_to_other_windows: bool`, `snap_distance: u32`.
- **Struct `WindowGroupingPolicy`**: (Regeln für automatische oder manuelle Fenstergruppierung, z.B. `group_by_application_id: bool`).
- **Struct `WindowPlacementPolicy`**: `new_window_placement_strategy: NewWindowPlacementStrategy` (Enum: `Smart`, `Center`, `Cascade`).
- **Struct `FocusPolicy`**: `focus_follows_mouse: bool`, `click_to_focus: bool`, `focus_new_windows: bool`.
- **Struct `ManagedWindowProperties`**: Hält domänenspezifische Eigenschaften eines Fensters, die für die Policy relevant sind (z.B. `current_tiling_layout_override: Option<TilingLayoutType>`, `user_defined_size: Option<Size<u32>>`, `is_floating_override: bool`). Wird über `WindowIdentifier` referenziert.

#### Untermodul: `domain::window_management_policy::errors`

- **Enum `WindowPolicyError`**: `LayoutCalculationError`, `InvalidPolicyConfiguration`.

#### Untermodul: `domain::window_management_policy::service`

- **Trait `WindowManagementPolicyService`**:
    - `async fn get_layout_for_workspace(&self, workspace_id: WorkspaceId, windows_on_workspace: Vec<WindowIdentifier>, available_space: RectInt) -> Result<HashMap<WindowIdentifier, RectInt>, WindowPolicyError>`: Berechnet die Geometrien für Fenster auf einem Workspace basierend auf der Policy.
    - `async fn apply_new_window_policy(&self, window_id: WindowIdentifier, workspace_id: WorkspaceId, current_windows: &[WindowIdentifier]) -> Result<RectInt, WindowPolicyError>`: Bestimmt die initiale Geometrie für ein neues Fenster.
    - `async fn get_snapping_target(&self, moving_window_id: WindowIdentifier, current_rect: RectInt, other_windows: &[(&WindowIdentifier, &RectInt)]) -> Option<RectInt>`: Berechnet ein "Snap"-Ziel.
    - (Weitere Methoden zur Abfrage/Aktualisierung von Policies für Tiling, Gaps, Snapping, Gruppierung, Fokus).
- **Implementierung `DefaultWindowManagementPolicyService`**:
    - Hält die aktuellen Policy-Konfigurationen (geladen von `GlobalSettingsService`).
    - Implementiert die Logik zur Layoutberechnung (Spalten, Spiralen etc.) und Snapping.

**Abhängigkeiten:** `domain::global_settings_service` (zum Lesen der Policy-Konfigurationen), `domain::workspaces` (um Infos über Workspaces und Fenster darauf zu erhalten).

**Interaktion:** Die Systemschicht (`system::window_mechanics`) ruft Methoden dieses Services auf, um die gewünschten Fenstergeometrien und -verhalten zu erhalten und technisch umzusetzen.

---

### Modul 7: `domain::common_events`

**Datei:** `src/common_events.rs`

- **Zweck:** Definition von Event-Typen, die von mehreren Domänenmodulen ausgelöst oder konsumiert werden können oder die als generische Payloads dienen.
- **Beispiele:**
    - `pub struct UserActivityDetectedEvent { timestamp: DateTime<Utc>, activity_type: UserActivityType }`
    - `pub enum UserActivityType { MouseMoved, KeyPressed, WorkspaceSwitched }`
    - `pub struct SystemShutdownInitiatedEvent { reason: String }`

---

### Modul 8: `domain::shared_types`

**Datei:** `src/shared_types.rs`

- **Zweck:** Definition von domänenspezifischen Typen, die von mehreren Domänenmodulen verwendet werden, aber nicht allgemein genug für `core::types` sind.
- **Beispiele:**
    - `pub type ApplicationId = String;` (Falls spezifischer als `WindowIdentifier`)
    - `pub enum UserSessionState { Active, Locked, Idle }` (Domänenrepräsentation, Systemschicht mappt Logind-Zustände darauf)
    - `pub struct ResourceIdentifier { pub r#type: String, pub id: String }` (Für KI-Interaktionen oder andere Ressourcen)

---

**Implementierungsleitfaden (Allgemein für Domänenschicht):**

1. **Crate-Struktur:** Erstellen Sie ein `novade-domain`-Crate.
2. **Modulstruktur:** Legen Sie die Verzeichnisstruktur für die oben genannten Hauptmodule an (z.B. `src/theming/`, `src/workspaces/`, etc.).
3. **Abhängigkeiten in `novade-domain/Cargo.toml`:**
    
    Ini, TOML
    
    ```
    [dependencies]
    novade-core = { path = "../novade-core" } # Relative Pfade anpassen
    thiserror = "1.0"
    serde = { version = "1.0", features = ["derive"] }
    serde_json = "1.0" # Für JsonValue und Fehler
    uuid = { version = "1.0", features = ["v4", "serde"] }
    chrono = { version = "0.4", features = ["serde"] }
    async-trait = "0.1"
    tokio = { version = "1", features = ["sync"] } # Für broadcast channels
    # Ggf. weitere spezifische Crates
    ```
    
4. **Implementierung pro Modul:**
    - Beginnen Sie mit `types.rs` und `errors.rs`.
    - Implementieren Sie dann die Service-Traits und deren interne Logik.
    - Definieren und implementieren Sie die Event-Strukturen und deren Versandlogik.
    - Schreiben Sie umfassende Unit-Tests für jede Komponente.
5. **`novade-domain/src/lib.rs`:** Deklarieren Sie alle öffentlichen Module und re-exportieren Sie die primären Service-Traits und wichtigsten Typen für eine saubere Crate-API.

Dieser detaillierte Plan für die Domänenschicht sollte es den Entwicklern ermöglichen, die Geschäftslogik der NovaDE-Desktop-Umgebung systematisch und konsistent zu implementieren. Der Fokus auf Traits, klare Fehlerdefinitionen und einen Event-basierten Ansatz wird zu einer robusten und wartbaren Schicht führen.

Okay, ich werde nun die Ultra-Feinspezifikation und den detaillierten Implementierungsplan für die **Domänenschicht** des NovaDE-Projekts entwickeln. Ich werde die bereits existierenden Spezifikationen (,,) als Grundlage nehmen, sie konsolidieren, verfeinern und erweitern, um einen lückenlosen Leitfaden zu erstellen.

**Autonome Entscheidung zur Sequenzierung und Submodul-Aufteilung:**

1. **`domain::shared_types`** (Wird zuerst definiert, da von vielen anderen Modulen genutzt)
2. **`domain::common_events`** (Ebenfalls früh, da Events modulübergreifend sein können)
3. **`domain::theming`**
4. **`domain::global_settings_and_state_management`** (Einstellungen beeinflussen viele andere Module)
5. **`domain::workspaces`**
6. **`domain::window_management_policy`** (Baut auf Workspaces und globalen Einstellungen auf)
7. **`domain::user_centric_services`** (KI und Benachrichtigungen, können Einstellungen und Kontext nutzen)
    - `user_centric_services::ai_interaction`
    - `user_centric_services::notifications_core`
8. **`domain::notifications_rules`** (Baut auf `notifications_core` und `global_settings` auf)

Diese Reihenfolge versucht, Abhängigkeiten zu berücksichtigen, indem grundlegendere oder breiter genutzte Module früher spezifiziert werden.

---

## Ultra-Feinspezifikation und Implementierungsplan: Domänenschicht (`novade-domain` Crate)

**Allgemeine Entwicklungsrichtlinien für die Domänenschicht:** (Wiederholung zur Betonung)

- **Sprache:** Rust (Edition 2021 oder neuer)
- **UI-Unabhängigkeit:** Strikte Trennung von UI-Belangen. Keine GTK-Abhängigkeiten.
- **Systemunabhängigkeit:** Keine direkten Systemaufrufe (D-Bus, Wayland-Protokolle).
- **Kernlogik:** Fokus auf Geschäftsregeln und -prozesse.
- **API-Design:** Öffentliche Schnittstellen primär über `async_trait` Traits.
- **Zustandsverwaltung:** Threadsichere Kapselung (`Arc<Mutex<...>>` oder `Arc<RwLock<...>>`).
- **Asynchronität:** `async/await` für potenziell blockierende Operationen. Runtime (`tokio`) wird von der Anwendung bereitgestellt.
- **Events:** `tokio::sync::broadcast` für die Event-Kommunikation.
- **Fehlerbehandlung:** `thiserror` für modulspezifische Fehler-Enums. Sauberes Wrapping von `novade-core::errors`.
- **Validierung:** Aktive Validierung von Eingaben und Zustandsänderungen.
- **Serialisierung:** `serde` für Datenstrukturen, die persistiert oder ausgetauscht werden.
- **Abhängigkeiten:**
    - `novade-core = { path = "../novade-core" }`
    - `thiserror = "1.0"`
    - `serde = { version = "1.0", features = ["derive"] }`
    - `serde_json = "1.0"`
    - `uuid = { version = "1.8", features = ["v4", "serde"] }` (Aktuelle Version prüfen)
    - `chrono = { version = "0.4", features = ["serde"] }` (Aktuelle Version prüfen)
    - `async-trait = "0.1"`
    - `tokio = { version = "1", features = ["sync"] }`
    - `tracing = "0.1"`
- **Logging:** Verwendung von `tracing::{trace, debug, info, warn, error}` Makros aus `novade-core`.

---

### Modul 1: `domain::shared_types`

Zweck: Definition von domänenspezifischen Typen, die von mehreren Domänenmodulen verwendet werden, aber nicht allgemein genug für core::types sind.

Datei: src/shared_types.rs

#### 1.1. Type Alias: `ApplicationId`

- **Definition:** `pub type ApplicationId = String;`
- **Zweck:** Eindeutiger Bezeichner für eine Anwendung (z.B. Reverse-DNS-Name wie "org.novade.FileExplorer").
- **Invarianten:** Sollte nicht leer sein. Formatierungsregeln können von der Systemschicht (z.B. AppID aus `.desktop`-Dateien) abhängen und hier nur als Konvention dokumentiert werden.
- **Ableitungen (indirekt durch String):** `Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Default`.

#### 1.2. Enum: `UserSessionState`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum UserSessionState {
        #[default]
        Active, // Normale Benutzersitzung
        Locked, // Sitzung gesperrt (z.B. Bildschirmschoner aktiv)
        Idle,   // Benutzer ist für eine bestimmte Zeit inaktiv
    }
    ```
    
- **Zweck:** Repräsentiert den aktuellen Zustand der Benutzersitzung aus Sicht der Domäne. Die Systemschicht mappt hierauf ggf. detailliertere Zustände von `logind` o.ä.
- **Initialwert:** `Active` (durch `#[default]`).

#### 1.3. Struct: `ResourceIdentifier`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    use uuid::Uuid;
    
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub struct ResourceIdentifier {
        pub r#type: String, // z.B. "file", "contact", "calendar_event"
        pub id: String,     // Eindeutige ID innerhalb des Typs, kann auch Uuid sein
    }
    
    impl ResourceIdentifier {
        pub fn new(r#type: impl Into<String>, id: impl Into<String>) -> Self {
            Self {
                r#type: r#type.into(),
                id: id.into(),
            }
        }
    }
    ```
    
- **Zweck:** Allgemeiner Bezeichner für eine Ressource, die von KI-Funktionen oder anderen Diensten referenziert werden könnte.
- **Felder:**
    - `r#type: String` (öffentlich): Der Typ der Ressource.
    - `id: String` (öffentlich): Die eindeutige ID der Ressource innerhalb ihres Typs.
- **Invarianten:** `r#type` und `id` sollten nicht leer sein.

#### 1.4. Implementierungsschritte `domain::shared_types`

1. **Datei erstellen:** `novade-domain/src/shared_types.rs`.
2. **Typen definieren:** `ApplicationId`, `UserSessionState`, `ResourceIdentifier` wie oben spezifiziert.
3. **`novade-domain/src/lib.rs` anpassen:**
    
    Rust
    
    ```
    pub mod shared_types;
    pub use shared_types::{ApplicationId, UserSessionState, ResourceIdentifier};
    ```
    
4. **Unit-Tests:**
    - Für `ResourceIdentifier::new`.
    - Für `UserSessionState`: `Default`-Implementierung.
    - Serialisierung/Deserialisierung der Typen testen.

---

### Modul 2: `domain::common_events`

Zweck: Definition von Event-Typen, die von mehreren Domänenmodulen ausgelöst oder konsumiert werden können.

Datei: src/common_events.rs

#### 2.1. Enum: `UserActivityType`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum UserActivityType {
        MouseMoved,
        MouseClicked,
        KeyPressed,
        WorkspaceSwitched,
        ApplicationFocused,
        // Weitere Typen nach Bedarf
    }
    ```
    
- **Zweck:** Kategorisierung von Benutzeraktivitäten.

#### 2.2. Struct: `UserActivityDetectedEvent`

- **Definition:**
    
    Rust
    
    ```
    use chrono::{DateTime, Utc};
    use serde::{Serialize, Deserialize};
    use super::shared_types::UserSessionState; // Oder spezifischere Aktivitätsdaten
    use super::UserActivityType; // aus demselben Modul
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct UserActivityDetectedEvent {
        pub timestamp: DateTime<Utc>,
        pub activity_type: UserActivityType,
        pub current_session_state: UserSessionState, // Beispielhafter zusätzlicher Kontext
        // Optional: pub source_component: String; // z.B. "system::input", "domain::workspaces"
        // Optional: pub details: serde_json::Value; // Für flexible Zusatzdaten
    }
    
    impl UserActivityDetectedEvent {
        pub fn new(activity_type: UserActivityType, current_session_state: UserSessionState) -> Self {
            Self {
                timestamp: Utc::now(),
                activity_type,
                current_session_state,
            }
        }
    }
    ```
    
- **Zweck:** Wird ausgelöst, wenn eine signifikante Benutzeraktivität erkannt wird. Kann für Idle-Detection, kontextsensitive Aktionen etc. verwendet werden.
- **Payload:**
    - `timestamp: DateTime<Utc>`
    - `activity_type: UserActivityType`
    - `current_session_state: UserSessionState`
- **Typische Publisher:** `system::input` (indirekt über Domänenadapter), `domain::workspaces::manager`.
- **Typische Subscriber:** `domain::user_centric_services` (für Idle-Timer der KI), `domain::power_management_policy` (für Idle-basierte Energiesparmaßnahmen), UI-Komponenten für Statusanzeigen.

#### 2.3. Struct: `SystemShutdownInitiatedEvent`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum ShutdownReason {
        UserRequest,
        PowerButton,
        LowBattery,
        SystemUpdate,
        Unknown,
    }
    
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub struct SystemShutdownInitiatedEvent {
        pub reason: ShutdownReason,
        pub delay_seconds: Option<u32>, // Optionale Verzögerung, bevor der Shutdown tatsächlich erfolgt
    }
    ```
    
- **Zweck:** Signalisiert, dass das System heruntergefahren oder neu gestartet wird.
- **Payload:**
    - `reason: ShutdownReason`
    - `delay_seconds: Option<u32>`
- **Typische Publisher:** Ein Systemdienst-Adapter in der Systemschicht (z.B. Reaktion auf `logind PrepareForShutdown`).
- **Typische Subscriber:** Alle Domänendienste, die Zustände speichern müssen (`ThemingEngine`, `WorkspaceManager`, `GlobalSettingsService`), Anwendungen (über Portals).

#### 2.4. Implementierungsschritte `domain::common_events`

1. **Datei erstellen:** `novade-domain/src/common_events.rs`.
2. **Typen definieren:** `UserActivityType`, `UserActivityDetectedEvent`, `ShutdownReason`, `SystemShutdownInitiatedEvent`.
3. **`novade-domain/src/lib.rs` anpassen:**
    
    Rust
    
    ```
    pub mod common_events;
    pub use common_events::{UserActivityType, UserActivityDetectedEvent, ShutdownReason, SystemShutdownInitiatedEvent};
    ```
    
4. **Unit-Tests:**
    - Für `UserActivityDetectedEvent::new`.
    - Serialisierung/Deserialisierung der Event-Strukturen.

---

### Modul 3: `domain::theming`

Bestehende Spezifikation: Übernommen und integriert aus, siehe vorherige Antwort.

Anpassungen/Verfeinerungen:

- Verwendung von `tokio::sync::broadcast` für `ThemeChangedEvent` ist bestätigt.
- Alle Ladeoperationen (`load_and_validate_token_files`, `load_and_validate_theme_files` in der Logik sowie `ThemingEngine::new` und `ThemingEngine::reload_themes_and_tokens` in der API) sind `async`, da sie potenziell Dateisystem-I/O beinhalten. Die Kernauflösungslogik (`resolve_tokens_for_config`) bleibt synchron, da sie CPU-gebunden ist.
- **Fehler-Enum `ThemingError`**:
    - Die Variante `FallbackThemeLoadError` erhält ein `#[source]`-Feld, da das Laden selbst fehlschlagen kann: `FallbackThemeLoadError { #[source] source: Box<dyn std::error::Error + Send + Sync + 'static> }`
    - `TokenResolutionError` hinzugefügt als allgemeinerer Fehler während der Auflösung. `#[error("Failed to resolve token '{token_id}': {message}")] TokenResolutionError { token_id: TokenIdentifier, message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
- **`ThemingEngineInternalState` Cache-Schlüssel:** Um `AccentColor` und `TokenSet` (für `custom_user_token_overrides`) hashbar zu machen, werden sie im Cache-Schlüssel durch einen Hash ihres Inhalts repräsentiert oder durch eine kanonische String-Repräsentation.
    - `AccentColor` wird im Cache-Key zu `Option<String>` (dem `value` der Akzentfarbe).
    - `custom_user_token_overrides: Option<TokenSet>` wird zu einem `u64`-Hash (z.B. mit `std::collections::hash_map::DefaultHasher`).
    - `resolved_state_cache: std::collections::HashMap<(ThemeIdentifier, ColorSchemeType, Option<String>, u64), AppliedThemeState>`

---

### Modul 4: `domain::global_settings_and_state_management`

Bestehende Spezifikation: Übernommen und integriert aus, siehe vorherige Antwort.

Anpassungen/Verfeinerungen:

#### `domain::global_settings::types`

- **Enum `MouseAccelerationProfile`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
    pub enum MouseAccelerationProfile {
        Adaptive,
        Flat,
        // Custom(f32) // Direktes f32 ist problematisch für Default und Eq.
                       // Besser wäre eine separate Einstellung für den Custom-Wert.
    }
    impl Default for MouseAccelerationProfile { fn default() -> Self { Self::Adaptive } }
    // Zusätzliches Feld in InputBehaviorSettings:
    // pub custom_mouse_acceleration_value: Option<f32>; // Nur relevant wenn Profil Custom(TODO: Wie Custom hier darstellen ohne f32?)
    // Alternative für Custom: Keine f32 im Enum, sondern ein Flag und separates Feld
    // Oder der Custom-Wert wird direkt über einen Slider gesetzt und das Enum
    // dient nur zur Auswahl des Profils. Für die Domäne ist es einfacher, wenn
    // `Custom` keine Daten enthält und der Wert separat verwaltet wird.
    // Hier vereinfacht zu: `Custom` (ohne Wert im Enum)
    ```
    
    Überarbeitung: `MouseAccelerationProfile` enthält kein `f32`. Der Custom-Wert wird ein separates Feld in `InputBehaviorSettings`: `pub custom_mouse_acceleration_factor: Option<f32>; // Aktiv, wenn Profil auf Custom gesetzt ist` Das Enum `MouseAccelerationProfile` wird: `Adaptive, Flat, Custom`.

#### `domain::global_settings::paths`

- Der `SettingPath`-Enum muss vollständig für alle Einstellungen in `GlobalDesktopSettings` und dessen Unterstrukturen ausdefiniert werden.
    - Beispiel für `InputBehaviorSettings`:
        
        Rust
        
        ```
        // In paths.rs
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum InputBehaviorSettingPath {
            MouseAccelerationProfile,
            CustomMouseAccelerationFactor, // Neu
            MouseSensitivity,
            NaturalScrollingMouse,
            NaturalScrollingTouchpad,
            TapToClickTouchpad,
            TouchpadPointerSpeed,
            KeyboardRepeatDelayMs,
            KeyboardRepeatRateCps,
        }
        ```
        
    - Dies muss für `WorkspaceSettingPath`, `PowerManagementPolicySettingPath`, `DefaultApplicationsSettingPath` etc. analog erfolgen.

#### `domain::global_settings::service`

- **Trait `GlobalSettingsService`**:
    - `load_settings()` und `save_settings()` sind `async`.
    - `update_setting()` ist `async`.
    - `reset_to_defaults()` ist `async`.
    - `subscribe_to_changes()` wird `pub fn subscribe_to_setting_changes(&self) -> tokio::sync::broadcast::Receiver<SettingChangedEvent>`
- **Implementierung `DefaultGlobalSettingsService`**:
    - Hält `persistence_provider: Arc<dyn SettingsPersistenceProvider>`.
    - Verwendet `tokio::sync::broadcast::Sender<SettingChangedEvent>`.
    - Die `update_setting` Logik zur Pfad-Navigation und Deserialisierung/Validierung muss robust implementiert werden. Hier ist ein Beispielansatz:
        - Eine interne Hilfsfunktion/Makro, die basierend auf `SettingPath` einen `&mut dyn std::any::Any` auf das Feld liefert und dessen `TypeId` kennt.
        - Dann `serde_json::from_value` verwenden und das Ergebnis dynamisch prüfen/casten und validieren.
        - Oder eine große `match`-Anweisung auf `SettingPath`.

#### `domain::global_settings::persistence_iface`

- **Trait `SettingsPersistenceProvider`**: Methoden sind `async`.
    - `async fn load_global_settings() -> Result<GlobalDesktopSettings, GlobalSettingsError>`
    - `async fn save_global_settings(settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`
- **Implementierung `FilesystemSettingsProvider`**:
    - Nutzt `Arc<dyn novade_core::config::ConfigServiceAsync>` (hypothetischer Trait für asynchronen Zugriff auf `core::config` oder direkt `novade_core::config::load_core_config_async` / `save_core_config_async`).
    - Die Methoden `load_global_settings` und `save_global_settings` werden `async`.

**Events:** `SettingChangedEvent { path: SettingPath, new_value: serde_json::Value }`, `SettingsLoadedEvent { settings: GlobalDesktopSettings }`, `SettingsSavedEvent`.

---

### Modul 5: `domain::workspaces`

Bestehende Spezifikation: Übernommen und integriert aus, siehe vorherige Antwort.

Anpassungen/Verfeinerungen:

- **`WorkspaceManager`**:
    - Der `event_publisher` wird `tokio::sync::broadcast::Sender<WorkspaceEvent>`.
    - Die Methode `subscribe_to_workspace_events()` gibt `tokio::sync::broadcast::Receiver<WorkspaceEvent>` zurück.
    - Alle Methoden, die potenziell die Konfiguration speichern (`create_workspace`, `delete_workspace`, `set_active_workspace`, `rename_workspace`, `set_workspace_layout`) oder laden (`new`), werden `async`, da `save_configuration` und `config_provider.load_workspace_config` `async` sind.
- **`FilesystemConfigProvider`**:
    - Nutzt einen asynchronen `core::config::ConfigServiceAsync` oder äquivalente `async` Funktionen zum Lesen/Schreiben von Dateien.
    - Die Methoden `load_workspace_config` und `save_workspace_config` sind `async`.

---

### Modul 6: `domain::window_management_policy`

Zweck: High-Level-Regeln für Fensterplatzierung, Tiling, Snapping, Gruppierung, Gap-Management.

Datei: src/window_management_policy/types.rs

#### 6.1. Typen

- **Enum `TilingMode`** (ersetzt `TilingLayoutType` für Klarheit, da Layouts spezifischer sind):
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum TilingMode {
        #[default]
        Manual, // Keine automatische Anordnung, Fenster sind floating
        Columns,
        Rows,
        Spiral, // Fibonacci-Spirale
        MaximizedFocused, // Aktives Fenster maximiert, andere ggf. versteckt/klein
    }
    ```
    
- **Struct `GapSettings`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub struct GapSettings {
        pub screen_outer_horizontal: u16, // Rand zum Bildschirm horizontal
        pub screen_outer_vertical: u16,   // Rand zum Bildschirm vertikal
        pub window_inner: u16,            // Abstand zwischen Fenstern
    }
    ```
    
- **Struct `WindowSnappingPolicy`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub struct WindowSnappingPolicy {
        pub snap_to_screen_edges: bool,
        pub snap_to_other_windows: bool,
        pub snap_to_workspace_gaps: bool, // Snapping an virtuelle Gap-Grenzen
        pub snap_distance_px: u16,
    }
    ```
    
- **Struct `WindowGroupingPolicy`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub struct WindowGroupingPolicy {
        pub enable_manual_grouping: bool,
        // Automatische Gruppierungsregeln (komplexer, für V2):
        // pub auto_group_by_application_id: bool,
        // pub auto_group_transients_with_parent: bool,
    }
    ```
    
- **Enum `NewWindowPlacementStrategy`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum NewWindowPlacementStrategy {
        #[default]
        Smart,    // Versucht intelligent zu platzieren (z.B. nicht überlappend, im größten freien Bereich)
        Center,   // Zentriert auf dem Bildschirm/Workspace
        Cascade,  // Kaskadierend vom letzten Fenster
        UnderMouse, // Unter dem Mauszeiger (falls zutreffend)
    }
    ```
    
- **Enum `FocusStealingPreventionLevel`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum FocusStealingPreventionLevel {
        None,   // Jedes Fenster darf Fokus anfordern
        #[default]
        Moderate, // Verhindert aggressives Stehlen, erlaubt aber legitime Anforderungen
        Strict, // Nur explizite Benutzeraktion kann Fokus ändern
    }
    ```
    
- **Struct `FocusPolicy`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub struct FocusPolicy {
        pub focus_follows_mouse: bool, // Mausbewegung ändert Fokus
        pub click_to_focus: bool,      // Klick erforderlich
        pub focus_new_windows_on_creation: bool, // Neue Fenster erhalten sofort Fokus
        pub focus_new_windows_on_workspace_switch: bool, // Beim Workspace-Wechsel wird das zuletzt fokussierte Fenster des Ziel-WS fokussiert
        pub focus_stealing_prevention: FocusStealingPreventionLevel,
    }
    ```
    
- **Struct `WindowPolicyOverrides`** (pro Fenster, optional, von Benutzer oder Regeln setzbar):
    
    Rust
    
    ```
    use crate::core::types::RectInt; // Aus der Kernschicht
    use uuid::Uuid;
    use serde::{Serialize, Deserialize};
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
    pub struct WindowPolicyOverrides {
        pub preferred_tiling_mode: Option<TilingMode>,
        pub is_always_floating: Option<bool>, // Überschreibt Workspace-Tiling-Modus
        pub fixed_size: Option<(u32, u32)>, // Breite, Höhe
        pub fixed_position: Option<(i32, i32)>, // x, y (relativ zum Workspace)
        pub prevent_focus_stealing: Option<bool>, // Individuelle Überschreibung der globalen Policy
        pub min_size_override: Option<(u32, u32)>,
        pub max_size_override: Option<(u32, u32)>,
    }
    ```
    
    - Dieses Struct würde nicht direkt in `GlobalDesktopSettings` sein, sondern dynamisch pro Fenster verwaltet (z.B. in einer `HashMap<WindowIdentifier, WindowPolicyOverrides>`).
- **Struct `WorkspaceWindowLayout`**: Repräsentiert das berechnete Layout für einen Workspace.
    
    Rust
    
    ```
    use crate::core::types::RectInt;
    use crate::domain::workspaces::core::types::WindowIdentifier;
    use std::collections::HashMap;
    
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct WorkspaceWindowLayout {
        // Fenster-ID zu seiner berechneten Geometrie (Position und Größe)
        pub window_geometries: HashMap<WindowIdentifier, RectInt>,
        // Bereich, der vom Layout genutzt wird (kann kleiner sein als available_space, z.B. bei zentrierten Layouts)
        pub occupied_area: Option<RectInt>,
    }
    ```
    

**Datei:** `src/window_management_policy/errors.rs`

- **Enum `WindowPolicyError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use crate::domain::workspaces::core::types::WorkspaceId;
    
    #[derive(Debug, Error)]
    pub enum WindowPolicyError {
        #[error("Failed to calculate layout for workspace '{workspace_id}': {reason}")]
        LayoutCalculationError { workspace_id: WorkspaceId, reason: String },
        #[error("Invalid window management policy configuration: {setting_path}, reason: {reason}")]
        InvalidPolicyConfiguration { setting_path: String, reason: String },
        #[error("Window referenced by identifier '{0:?}' not found for policy application.")]
        WindowNotFoundForPolicy(crate::domain::workspaces::core::types::WindowIdentifier),
        #[error("An internal error occurred in window management policy: {0}")]
        InternalError(String),
    }
    ```
    

**Datei:** `src/window_management_policy/service.rs` (oder `mod.rs`)

- **Trait `WindowManagementPolicyService`**:
    
    Rust
    
    ```
    use async_trait::async_trait;
    use std::collections::HashMap;
    use crate::core::types::{RectInt, Size, Point};
    use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType};
    use super::types::{TilingMode, GapSettings, WindowSnappingPolicy, NewWindowPlacementStrategy, WorkspaceWindowLayout, WindowPolicyOverrides};
    use super::errors::WindowPolicyError;
    use crate::domain::global_settings_and_state_management::types::GlobalDesktopSettings; // Für den Zugriff auf globale Policies
    
    #[async_trait]
    pub trait WindowManagementPolicyService: Send + Sync {
        /// Berechnet das Layout für alle Fenster auf einem gegebenen Workspace.
        /// `windows_on_workspace`: Liste der Fenster-IDs auf dem Workspace und ihre aktuellen (oder gewünschten Mindest-)Größen.
        /// `workspace_tiling_mode`: Der vom Workspace gewünschte Tiling-Modus.
        /// `global_settings`: Aktuelle globale Einstellungen, die Policies enthalten.
        /// `window_specific_overrides`: Map von Fenster-IDs zu ihren spezifischen Policy-Überschreibungen.
        async fn calculate_workspace_layout(
            &self,
            workspace_id: WorkspaceId,
            windows_on_workspace: &[(WindowIdentifier, Size<u32>)], // Fenster und ihre (Mindest-)Größen
            available_area: RectInt, // Der für Fenster verfügbare Bereich auf dem Workspace
            workspace_tiling_mode: TilingMode, // Vom Workspace Manager festgelegter Modus
            gap_settings: &GapSettings, // Aktuelle Gap-Einstellungen
            window_specific_overrides: &HashMap<WindowIdentifier, WindowPolicyOverrides>
        ) -> Result<WorkspaceWindowLayout, WindowPolicyError>;
    
        /// Bestimmt die initiale Geometrie und den Zustand für ein neues Fenster.
        async fn get_initial_window_geometry(
            &self,
            window_id: &WindowIdentifier,
            requested_size: Option<Size<u32>>, // Vom Fenster gewünschte Größe
            is_transient_for: Option<&WindowIdentifier>, // Elternfenster für transiente Fenster
            workspace_id: WorkspaceId,
            active_layout_on_workspace: &WorkspaceWindowLayout, // Aktuelles Layout des Ziel-Workspace
            available_area: RectInt,
            placement_strategy: NewWindowPlacementStrategy,
            window_specific_overrides: &Option<WindowPolicyOverrides>
        ) -> Result<RectInt, WindowPolicyError>;
    
        /// Berechnet ein potenzielles "Snap"-Ziel für ein sich bewegendes oder größenveränderndes Fenster.
        async fn calculate_snap_target(
            &self,
            moving_window_id: &WindowIdentifier,
            current_geometry: RectInt, // Aktuelle Geometrie des bewegten Fensters
            other_windows_on_workspace: &[(&WindowIdentifier, &RectInt)], // Andere Fenster
            workspace_area: RectInt, // Gesamtbereich des Workspace
            snapping_policy: &WindowSnappingPolicy,
            gap_settings: &GapSettings
        ) -> Option<RectInt>;
    
        /// Gibt die Fokus-Policy zurück.
        async fn get_focus_policy(&self, global_settings: &GlobalDesktopSettings) -> FocusPolicy;
    
        /// Gibt die Policy für neue Fensterplatzierung zurück.
        async fn get_new_window_placement_strategy(&self, global_settings: &GlobalDesktopSettings) -> NewWindowPlacementStrategy;
    
        // Ggf. Methoden zum Abrufen spezifischer Policy-Objekte wie GapSettings, WindowSnappingPolicy etc.
        // basierend auf global_settings oder Workspace-spezifischen Einstellungen.
    }
    ```
    
- **Implementierung `DefaultWindowManagementPolicyService`**:
    - **Konstruktor:** `pub fn new(settings_service: Arc<dyn GlobalSettingsService>) -> Self`
        - Hält eine Referenz (`Arc`) zum `GlobalSettingsService`, um bei Bedarf aktuelle Policy-Einstellungen abzurufen.
    - **`calculate_workspace_layout` Logik:**
        1. Ruft globale Einstellungen (Tiling-Modus-Präferenz, Gaps) vom `settings_service` ab (oder erhält sie als Parameter).
        2. Filtert Fenster heraus, die `is_always_floating == Some(true)` haben. Diese werden ignoriert für Tiling.
        3. Basierend auf dem `workspace_tiling_mode` (und ggf. Fenster-spezifischen `preferred_tiling_mode` Overrides):
            - `TilingMode::Manual`: Gibt aktuelle Geometrien zurück (oder platziert sie initial gemäß `NewWindowPlacementStrategy`).
            - `TilingMode::Columns`: Teilt `available_area` (unter Berücksichtigung von `gap_settings`) vertikal für jedes nicht-floating Fenster auf. Berücksichtigt `min_size_override`.
            - `TilingMode::Rows`: Teilt horizontal auf.
            - `TilingMode::Spiral`: Implementiert Fibonacci-Spiral-Layout-Algorithmus.
            - `TilingMode::MaximizedFocused`: Macht das "aktive" Fenster (muss als Parameter übergeben werden oder heuristisch bestimmt werden) bildschirmfüllend (innerhalb `available_area` minus Gaps), andere minimiert/versteckt.
        4. Floating-Fenster werden über den gekachelten Fenstern platziert, ihre Positionen bleiben relativ erhalten oder werden initial gemäß `get_initial_window_geometry` platziert.
        5. Erstellt und gibt `WorkspaceWindowLayout` zurück.
    - **`get_initial_window_geometry` Logik:**
        1. Berücksichtigt `requested_size`, `is_transient_for` (z.B. zentriert über Parent).
        2. Wendet `placement_strategy` an (`Smart` könnte versuchen, Überlappungen mit `active_layout_on_workspace` zu vermeiden).
        3. Berücksichtigt `window_specific_overrides.fixed_position` und `fixed_size`.
    - **`calculate_snap_target` Logik:**
        1. Prüft Distanz zu Bildschirmrändern, Gap-Grenzen und Kanten/Mittelpunkten anderer Fenster.
        2. Wenn innerhalb `snap_distance_px`, gibt die neue "eingerastete" `RectInt` zurück.

**Abhängigkeiten & Interaktion:**

- Liest Policy-Konfigurationen von `domain::global_settings_service`.
- Wird von der Systemschicht (`system::window_mechanics`) aufgerufen, um Layouts und Platzierungen zu bestimmen.
- Könnte von `domain::workspaces::manager` Events abonnieren (z.B. `WindowAddedToWorkspaceEvent`), um Layouts proaktiv neu zu berechnen.

**Implementierungsschritte:**

1. `types.rs` und `errors.rs` definieren.
2. `service.rs`: `WindowManagementPolicyService`-Trait definieren.
3. `DefaultWindowManagementPolicyService` implementieren:
    - Konstruktor.
    - Implementierung der Layout-Algorithmen (Columns, Rows, Spiral etc.) als private Hilfsfunktionen.
    - Implementierung der Snapping-Logik.
    - Implementierung der öffentlichen Trait-Methoden.
4. Unit-Tests für jeden Layout-Algorithmus, Snapping-Logik und die Service-Methoden mit verschiedenen Szenarien und Konfigurationen.

---

### Modul 7: `domain::user_centric_services`

Bestehende Spezifikation: Übernommen und integriert aus, siehe vorherige Antwort.

Anpassungen/Verfeinerungen:

#### `domain::user_centric_services::ai_interaction`

- **Strukturen/Enums:** Wie definiert in.
- **`AIInteractionLogicService` Trait & Implementierung `DefaultAIInteractionLogicService`**:
    - Methoden sind `async`.
    - `initiate_interaction`: Benötigt ggf. Zugriff auf `GlobalSettingsService` für Standardmodell oder globale KI-Einstellungen.
    - `provide_consent`: Muss den `AIConsentStatus` im `AIInteractionContext` und ggf. einen persistenten `AIConsent`-Eintrag aktualisieren.
    - `store_consent` / `get_all_user_consents`: Delegieren die Persistenz an einen `AIConsentProvider` (neuer Trait, ähnlich `SettingsPersistenceProvider`, interagiert mit `core::config`).
    - `load_model_profiles`: Lädt von `core::config` über einen `AIModelProfileProvider`.
- **Events:** `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent` (gesendet via `tokio::sync::broadcast`).

#### `domain::user_centric_services::notifications_core`

- **Strukturen/Enums:** Wie definiert in.
- **`NotificationService` Trait & Implementierung `DefaultNotificationService`**:
    - Methoden sind `async`.
    - `post_notification`: Berücksichtigt `DoNotDisturbModeChangedEvent` und DND-Status. Interagiert mit `domain::notifications_rules::NotificationRulesEngine` (wird als Abhängigkeit injiziert), um Benachrichtigungen vor dem Posten zu verarbeiten.
- **Events:** `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `DoNotDisturbModeChangedEvent` (gesendet via `tokio::sync::broadcast`).

**Neue Sub-Traits/Provider für Persistenz:**

- `domain::user_centric_services::ai_interaction::persistence_iface`:
    - `AIConsentProvider`: `async fn load_consents(user_id: &str) -> Result<Vec<AIConsent>, AIInteractionError>`, `async fn save_consent(consent: &AIConsent) -> Result<(), AIInteractionError>`.
    - `AIModelProfileProvider`: `async fn load_model_profiles() -> Result<Vec<AIModelProfile>, AIInteractionError>`.
    - Implementierungen nutzen `core::config`.

---

### Modul 8: `domain::notifications_rules`

Bestehende Spezifikation: Übernommen und integriert aus der vorherigen Antwort.

Anpassungen/Verfeinerungen:

#### `domain::notifications_rules::engine` (oder `service.rs`)

- **Struct `NotificationRulesEngine`**:
    - Konstruktor `pub async fn new(rules_provider: Arc<dyn NotificationRulesProvider>, settings_service: Arc<dyn GlobalSettingsService>) -> Self`
    - `load_rules()`-Methode, um Regeln vom `rules_provider` neu zu laden.
    - `process_notification`: Nimmt `&Notification` und gibt `Result<Option<Notification>, NotificationRulesError>` zurück (None, wenn unterdrückt, Some(modified_notification) wenn erlaubt/geändert).

#### `domain::notifications_rules::persistence_iface`

- **Trait `NotificationRulesProvider`**:
    - `async fn load_rules() -> Result<NotificationRuleSet, NotificationRulesError>`
    - `async fn save_rules(rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`
- Implementierung `FilesystemNotificationRulesProvider` nutzt `core::config`.

**Interaktion:**

- Der `notifications_core::DefaultNotificationService` wird eine Instanz des `NotificationRulesEngine` halten und `process_notification` aufrufen, bevor eine Benachrichtigung tatsächlich "gepostet" wird (d.h. bevor das `NotificationPostedEvent` ausgelöst und die Benachrichtigung den aktiven/historischen Listen hinzugefügt wird).
- Der `NotificationRulesEngine` benötigt Zugriff auf den `GlobalSettingsService`, um `SettingIsTrue`-Bedingungen auszuwerten.

---

**Finale `novade-domain/src/lib.rs` (Struktur):**

Rust

```
// novade-domain/src/lib.rs

// Kern-Abhängigkeiten (Beispiel)
// use novade_core; // Wird implizit durch Pfade wie crate::core::... genutzt

// Öffentliche Module deklarieren
pub mod common_events;
pub mod global_settings_and_state_management;
pub mod notifications_rules;
pub mod shared_types;
pub mod theming;
pub mod user_centric_services;
pub mod window_management_policy;
pub mod workspaces;

// Öffentliche API Re-Exports (Beispiele)
pub use common_events::{UserActivityDetectedEvent, SystemShutdownInitiatedEvent, /* ... */};
pub use global_settings_and_state_management::{
    GlobalSettingsService, GlobalDesktopSettings, SettingPath, GlobalSettingsError,
    SettingsPersistenceProvider, /* ... Untertypen und Enums ... */
};
pub use theming::{ThemingEngine, ThemeDefinition, AppliedThemeState, ThemingError, /* ... */};
pub use workspaces::{
    WorkspaceManager, Workspace, WorkspaceId, WindowIdentifier, WorkspaceEvent, WorkspaceLayoutType,
    WorkspaceConfigProvider, WorkspaceCoreError, WindowAssignmentError, WorkspaceManagerError, WorkspaceConfigError, /* ... */
};
pub use user_centric_services::{
    AIInteractionLogicService, NotificationService, AIInteractionContext, Notification, AIConsent, AIModelProfile,
    AIInteractionError, NotificationError, /* ... Events und andere Typen ... */
    // Ggf. auch die Provider-Traits für Persistenz
    ai_interaction::persistence_iface::{AIConsentProvider, AIModelProfileProvider},
};
pub use notifications_rules::{
    NotificationRulesEngine, NotificationRule, RuleCondition, RuleAction, NotificationRulesError,
    persistence_iface::NotificationRulesProvider,
};
pub use window_management_policy::{
    WindowManagementPolicyService, TilingMode, GapSettings, WorkspaceWindowLayout, WindowPolicyError, /* ... */
};
pub use shared_types::{ApplicationId, UserSessionState, ResourceIdentifier};

// Initialisierungsfunktion für die gesamte Domänenschicht könnte hier existieren,
// die alle Services instanziiert und ggf. miteinander verbindet.
// pub async fn initialize_domain_layer(
//     core_config_service: Arc<dyn novade_core::config::ConfigServiceAsync>,
//     // ... andere notwendige Abhängigkeiten aus der Kernschicht ...
// ) -> Result<DomainServices, DomainInitializationError> {
//     // ... Instanziiere alle Provider und Services ...
//     // Beispiel:
//     // let settings_persistence_provider = Arc::new(global_settings_and_state_management::FilesystemSettingsProvider::new(core_config_service.clone()));
//     // let settings_service = Arc::new(global_settings_and_state_management::DefaultGlobalSettingsService::new(settings_persistence_provider));
//     // settings_service.load_settings().await?;
//     // ...
//     // Ok(DomainServices { settings_service, ... })
// }

// pub struct DomainServices {
//     pub settings_service: Arc<dyn GlobalSettingsService>,
//     pub theming_engine: Arc<ThemingEngine>,
//     pub workspace_manager: Arc<WorkspaceManager>,
//     // ... andere Services
// }

// #[derive(Debug, thiserror::Error)]
// pub enum DomainInitializationError {
//     #[error("Failed to initialize settings service: {0}")]
//     SettingsInitError(#[from] global_settings_and_state_management::GlobalSettingsError),
//     // ... andere Initialisierungsfehler
// }
```

Diese umfassende Spezifikation für die Domänenschicht sollte eine sehr solide Grundlage für die Implementierung bieten. Jedes Modul ist klar abgegrenzt, und die Interaktionen sowie Abhängigkeiten sind definiert. Der nächste Schritt wäre, für jedes dieser Module die detaillierten Implementierungsschritte (wie im Beispiel für `core::types` gezeigt) und die Unit-Tests vollständig auszuarbeiten.

---

## Ultra-Feinspezifikation und Implementierungsplan: Domänenschicht (`novade-domain` Crate)

Allgemeine Entwicklungsrichtlinien für die Domänenschicht: (Siehe vorherige Antwort für eine vollständige Liste)

Kurzfassung: Rust (Edition 2021+), UI- und Systemunabhängigkeit, Fokus auf Geschäftslogik, APIs über async_trait Traits, threadsichere Zustandsverwaltung, tokio für Asynchronität und Events, thiserror für Fehler, serde für Serialisierung, Nutzung von novade-core.

**Cargo.toml für `novade-domain`:**

Ini, TOML

```
[package]
name = "novade-domain"
version = "0.1.0"
edition = "2021" # oder neuer

[dependencies]
novade-core = { path = "../novade-core" } # Pfad anpassen
thiserror = "1.0.58" # Aktuelle Version prüfen
serde = { version = "1.0.197", features = ["derive"] } # Aktuelle Version prüfen
serde_json = "1.0.115" # Aktuelle Version prüfen
uuid = { version = "1.8.0", features = ["v4", "serde"] } # Aktuelle Version prüfen
chrono = { version = "0.4.38", features = ["serde"] } # Aktuelle Version prüfen
async-trait = "0.1.79" # Aktuelle Version prüfen
tokio = { version = "1.37.0", features = ["sync", "macros", "rt-multi-thread"] } # Aktuelle Version prüfen, rt-multi-thread für broadcast ggf.
tracing = "0.1.40" # Aktuelle Version prüfen

# Optional, falls für spezifische Algorithmen benötigt
# parking_lot = "0.12" # Für Mutex/RwLock Alternativen
# im = { version = "15.1.0", features = ["serde"] } # Für persistente Datenstrukturen, falls HashMap/Vec nicht ausreichen
```

---

### Modul 1: `domain::shared_types`

Zweck: Definition von domänenspezifischen Typen, die von mehreren Domänenmodulen verwendet werden, aber nicht allgemein genug für core::types sind. Diese Typen sind oft einfache Wrapper oder Enums, die die Semantik im Domänencode verbessern.

Verantwortlichkeiten: Bereitstellung dieser gemeinsam genutzten Typen.

Design-Rationale: Zentralisierung vermeidet Duplikation und fördert Konsistenz.

**Datei:** `src/shared_types.rs`

#### 1.1. Type Alias: `ApplicationId`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    /// Eindeutiger Bezeichner für eine Anwendung.
    ///
    /// Repräsentiert typischerweise einen Reverse-DNS-Namen (z.B. "org.novade.FileExplorer")
    /// oder den Namen der .desktop-Datei ohne Erweiterung.
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Default, PartialOrd, Ord)]
    pub struct ApplicationId(String);
    
    impl ApplicationId {
        /// Erstellt eine neue `ApplicationId`.
        ///
        /// # Panics
        /// Paniert, wenn die `id` leer ist (im Debug-Modus).
        pub fn new(id: impl Into<String>) -> Self {
            let id_str = id.into();
            debug_assert!(!id_str.is_empty(), "ApplicationId darf nicht leer sein.");
            Self(id_str)
        }
    
        /// Gibt die `ApplicationId` als String-Slice zurück.
        pub fn as_str(&self) -> &str {
            &self.0
        }
    }
    
    impl From<String> for ApplicationId {
        fn from(s: String) -> Self {
            debug_assert!(!s.is_empty(), "ApplicationId (from String) darf nicht leer sein.");
            Self(s)
        }
    }
    
    impl From<&str> for ApplicationId {
        fn from(s: &str) -> Self {
            debug_assert!(!s.is_empty(), "ApplicationId (from &str) darf nicht leer sein.");
            Self(s.to_string())
        }
    }
    
    impl std::fmt::Display for ApplicationId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.0)
        }
    }
    ```
    
- **Zweck:** Eindeutiger Bezeichner für eine Anwendung.
- **Invarianten:** Der interne String darf nicht leer sein. Diese Invariante wird durch `debug_assert!` in `new()` und `From`-Implementierungen im Debug-Modus geprüft. Für Release-Builds wird auf die Korrektheit der Eingabe vertraut oder höhere Schichten validieren.
- **Methoden:** `new(id: impl Into<String>) -> Self`, `as_str(&self) -> &str`.
- **Trait-Implementierungen:** `From<String>`, `From<&str>`, `std::fmt::Display`.
- **Ableitungen:** `Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Default, PartialOrd, Ord`.

#### 1.2. Enum: `UserSessionState`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    /// Repräsentiert den aktuellen Zustand der Benutzersitzung aus Sicht der Domäne.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum UserSessionState {
        #[default]
        Active, // Normale Benutzersitzung, Benutzer ist aktiv
        Locked, // Sitzung gesperrt (z.B. durch Bildschirmsperre)
        Idle,   // Benutzer ist für eine definierte Zeit inaktiv
    }
    ```
    
- **Zweck:** Abstraktion des Sitzungszustands.
- **Initialwert:** `Active`.
- **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default`.

#### 1.3. Struct: `ResourceIdentifier`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    use uuid::Uuid; // Wird für das Beispiel eines Uuid-basierten IDs verwendet
    
    /// Allgemeiner Bezeichner für eine Ressource.
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub struct ResourceIdentifier {
        /// Der Typ der Ressource (z.B. "file", "contact", "calendar-event", "web-url").
        /// Sollte ein konsistenter, definierter Satz von Strings sein.
        pub r#type: String,
        /// Die eindeutige ID der Ressource innerhalb ihres Typs.
        /// Dies kann ein Pfad, eine URL, eine Datenbank-ID oder eine UUID sein.
        pub id: String,
        /// Optionale menschenlesbare Beschreibung oder Name der Ressource.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub label: Option<String>,
    }
    
    impl ResourceIdentifier {
        /// Erstellt einen neuen `ResourceIdentifier`.
        ///
        /// # Panics
        /// Paniert, wenn `resource_type` oder `resource_id` leer sind (im Debug-Modus).
        pub fn new(resource_type: impl Into<String>, resource_id: impl Into<String>, label: Option<String>) -> Self {
            let type_str = resource_type.into();
            let id_str = resource_id.into();
            debug_assert!(!type_str.is_empty(), "ResourceIdentifier type darf nicht leer sein.");
            debug_assert!(!id_str.is_empty(), "ResourceIdentifier id darf nicht leer sein.");
            Self {
                r#type: type_str,
                id: id_str,
                label,
            }
        }
    
        /// Erstellt einen `ResourceIdentifier` für eine Datei.
        pub fn file(path: impl Into<String>, label: Option<String>) -> Self {
            Self::new("file", path, label)
        }
    
        /// Erstellt einen `ResourceIdentifier` für eine URL.
        pub fn url(url_str: impl Into<String>, label: Option<String>) -> Self {
            Self::new("web-url", url_str, label)
        }
    
        /// Erstellt einen `ResourceIdentifier` mit einer generierten UUID.
        pub fn new_uuid(resource_type: impl Into<String>, label: Option<String>) -> Self {
            Self::new(resource_type, Uuid::new_v4().to_string(), label)
        }
    }
    ```
    
- **Zweck:** Allgemeiner, typisierter Bezeichner für Ressourcen.
- **Felder:**
    - `r#type: String` (öffentlich)
    - `id: String` (öffentlich)
    - `label: Option<String>` (öffentlich, optional)
- **Invarianten:** `r#type` und `id` dürfen nicht leer sein (geprüft via `debug_assert!`).
- **Methoden:** `new(...)`, `file(...)`, `url(...)`, `new_uuid(...)`.
- **Ableitungen:** `Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize`.

#### 1.4. Implementierungsschritte `domain::shared_types`

1. **Datei erstellen:** `novade-domain/src/shared_types.rs`.
2. **Typen definieren:** `ApplicationId`, `UserSessionState`, `ResourceIdentifier` wie oben spezifiziert, inklusive aller Methoden, Trait-Implementierungen und `serde`-Attributen.
3. **Unit-Tests erstellen (`novade-domain/src/shared_types.rs` -> `#[cfg(test)] mod tests { ... }`):**
    - Für `ApplicationId`:
        - `test_application_id_new()`: Erstellung, `as_str()`.
        - `test_application_id_from_string()`: Konvertierung.
        - `test_application_id_from_str()`: Konvertierung.
        - `test_application_id_display()`: `Display`-Trait.
        - `test_application_id_serde()`: Serialisierung zu JSON und Deserialisierung.
        - `#[should_panic]` (im Debug-Modus) für `ApplicationId::new("")`.
    - Für `UserSessionState`:
        - `test_user_session_state_default()`: Prüft `Active` als Default.
        - `test_user_session_state_serde()`: Serialisierung/Deserialisierung.
    - Für `ResourceIdentifier`:
        - `test_resource_identifier_new()`: Korrekte Erstellung.
        - `test_resource_identifier_file_url_uuid()`: Hilfskonstruktoren.
        - `test_resource_identifier_serde()`: Serialisierung/Deserialisierung (auch mit `Option<String>` für Label).
        - `#[should_panic]` (im Debug-Modus) für `ResourceIdentifier::new("", "id", None)` und `ResourceIdentifier::new("type", "", None)`.
4. **`novade-domain/src/lib.rs` anpassen:**
    
    Rust
    
    ```
    // In novade-domain/src/lib.rs
    pub mod shared_types;
    // Re-export für einfacheren Zugriff von anderen Crates/Modulen
    pub use shared_types::{ApplicationId, UserSessionState, ResourceIdentifier};
    ```
    

---

### Modul 2: `domain::common_events`

Zweck: Definition von Event-Typen, die von mehreren Domänenmodulen ausgelöst oder konsumiert werden können oder die als generische Payloads dienen.

Design-Rationale: Fördert lose Kopplung und eine klare Ereignis-basierte Architektur. Events sind Datenstrukturen, die Zustandsänderungen oder signifikante Vorkommnisse repräsentieren.

Event-Mechanismus: Es wird tokio::sync::broadcast für die Verteilung dieser Events angenommen, wo ein globaler oder Service-spezifischer broadcast::Sender verwendet wird.

**Datei:** `src/common_events.rs`

#### 2.1. Enum: `UserActivityType`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    /// Kategorisiert die Art einer erkannten Benutzeraktivität.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum UserActivityType {
        MouseMoved,
        MouseClicked,
        MouseWheelScrolled,
        KeyPressed,
        TouchInteraction, // Generisch für Touch-Events
        WorkspaceSwitched,
        ApplicationFocused,
        WindowOpened,
        WindowClosed,
        // Weitere spezifische Aktivitätstypen nach Bedarf
    }
    ```
    
- **Zweck:** Granulare Unterscheidung von Benutzeraktivitäten für verschiedene Zwecke (z.B. Idle-Detection, kontextuelle Aktionen).
- **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize`.

#### 2.2. Struct: `UserActivityDetectedEvent`

- **Definition:**
    
    Rust
    
    ```
    use chrono::{DateTime, Utc};
    use serde::{Serialize, Deserialize};
    use super::shared_types::{UserSessionState, ApplicationId}; // Pfad anpassen
    use super::UserActivityType; // Aus demselben Modul
    use uuid::Uuid;
    
    /// Wird ausgelöst, wenn eine signifikante Benutzeraktivität im System erkannt wird.
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct UserActivityDetectedEvent {
        /// Eindeutige ID des Events.
        pub event_id: Uuid,
        /// Zeitstempel der Aktivitätserkennung.
        pub timestamp: DateTime<Utc>,
        /// Art der erkannten Aktivität.
        pub activity_type: UserActivityType,
        /// Der Sitzungszustand des Benutzers zum Zeitpunkt der Aktivität.
        pub current_session_state: UserSessionState,
        /// Optional: ID der Anwendung, die im Fokus war oder die Aktivität ausgelöst hat.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active_application_id: Option<ApplicationId>,
        /// Optional: ID des Workspaces, auf dem die Aktivität stattfand.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active_workspace_id: Option<crate::workspaces::core::types::WorkspaceId>, // Pfad anpassen
        // Zukünftig: Optionale, spezifischere Daten zum Event, z.B. welcher Key gedrückt wurde (mit Bedacht auf PII)
        // pub details: Option<serde_json::Value>,
    }
    
    impl UserActivityDetectedEvent {
        pub fn new(
            activity_type: UserActivityType,
            current_session_state: UserSessionState,
            active_application_id: Option<ApplicationId>,
            active_workspace_id: Option<crate::workspaces::core::types::WorkspaceId> // Pfad anpassen
        ) -> Self {
            Self {
                event_id: Uuid::new_v4(),
                timestamp: Utc::now(),
                activity_type,
                current_session_state,
                active_application_id,
                active_workspace_id,
            }
        }
    }
    ```
    
- **Zweck:** Zentrales Event zur Signalisierung von Benutzeraktivität.
- **Payload:**
    - `event_id: Uuid` (öffentlich): Eindeutige ID für das Event selbst.
    - `timestamp: DateTime<Utc>` (öffentlich)
    - `activity_type: UserActivityType` (öffentlich)
    - `current_session_state: UserSessionState` (öffentlich)
    - `active_application_id: Option<ApplicationId>` (öffentlich, optional)
    - `active_workspace_id: Option<WorkspaceId>` (öffentlich, optional, Typ aus `domain::workspaces`)
- **Typische Publisher:** Ein Adapter in der Systemschicht, der rohe Input-Events von `system::input` konsumiert und aggregiert, oder spezifische Domänendienste wie `domain::workspaces::manager` bei einem Workspace-Wechsel.
- **Typische Subscriber:**
    - `domain::user_centric_services::ai_interaction` (z.B. für Reset von Idle-Timern für KI-Kontext-Timeouts).
    - `domain::power_management_policy` (für System-Idle-Detection und Auslösen von Energiesparmaßnahmen).
    - UI-Komponenten, die auf Benutzeraktivität reagieren (z.B. "Zuletzt aktiv"-Anzeigen, obwohl dies eher UI-Zustand ist).
    - Logging/Auditing-Systeme.

#### 2.3. Enum: `ShutdownReason`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    /// Definiert den Grund für ein System-Shutdown oder einen Neustart.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum ShutdownReason {
        #[default]
        UserRequest,     // Direkte Anforderung durch den Benutzer (z.B. über Menü)
        PowerButtonPress,  // Physischer Power-Button wurde gedrückt
        LowBattery,        // Kritischer Batteriestand erfordert Shutdown
        SystemUpdate,      // Shutdown/Neustart aufgrund eines Systemupdates
        ApplicationRequest,// Eine Anwendung hat einen Shutdown angefordert (selten, braucht spezielle Rechte)
        OsError,           // Kritischer OS-Fehler erfordert Neustart (hypothetisch für Domäne)
        Unknown,           // Unbekannter Grund
    }
    ```
    
- **Zweck:** Klare Angabe des Grundes für einen Shutdown.
- **Initialwert:** `UserRequest`.
- **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default`.

#### 2.4. Struct: `SystemShutdownInitiatedEvent`

- **Definition:**
    
    Rust
    
    ```
    use chrono::{DateTime, Utc};
    use serde::{Serialize, Deserialize};
    use super::ShutdownReason; // Aus demselben Modul
    use uuid::Uuid;
    
    /// Wird ausgelöst, wenn der Prozess des Herunterfahrens oder Neustarts des Systems initiiert wird.
    #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
    pub struct SystemShutdownInitiatedEvent {
        pub event_id: Uuid,
        pub timestamp: DateTime<Utc>,
        /// Der Grund für den Shutdown.
        pub reason: ShutdownReason,
        /// Gibt an, ob es sich um einen Neustart (`true`) oder ein Herunterfahren (`false`) handelt.
        pub is_reboot: bool,
        /// Optionale Verzögerung in Sekunden, bevor der eigentliche Shutdown/Neustart ausgeführt wird.
        /// Dies gibt Anwendungen Zeit, ihre Daten zu speichern.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delay_seconds: Option<u32>,
        /// Optionale Nachricht, die dem Benutzer angezeigt werden könnte.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub message: Option<String>,
    }
    
    impl SystemShutdownInitiatedEvent {
        pub fn new(reason: ShutdownReason, is_reboot: bool, delay_seconds: Option<u32>, message: Option<String>) -> Self {
            Self {
                event_id: Uuid::new_v4(),
                timestamp: Utc::now(),
                reason,
                is_reboot,
                delay_seconds,
                message,
            }
        }
    }
    ```
    
- **Zweck:** Signalisiert bevorstehenden System-Shutdown/Neustart.
- **Payload:**
    - `event_id: Uuid` (öffentlich)
    - `timestamp: DateTime<Utc>` (öffentlich)
    - `reason: ShutdownReason` (öffentlich)
    - `is_reboot: bool` (öffentlich): `true` für Neustart, `false` für Herunterfahren.
    - `delay_seconds: Option<u32>` (öffentlich, optional)
    - `message: Option<String>` (öffentlich, optional)
- **Typische Publisher:** Ein Adapter in der Systemschicht, der auf Signale von `logind` (z.B. `PrepareForShutdown(true/false)`) reagiert.
- **Typische Subscriber:**
    - Alle Domänendienste, die einen sauberen Shutdown-Prozess benötigen, um Zustände zu speichern (z.B. `GlobalSettingsService::save_settings`, `WorkspaceManager::save_configuration`, `ThemingEngine` falls er Caches persistiert, `AIInteractionLogicService` für `AIConsent`).
    - Die Systemschicht selbst, um z.B. Anwendungen über XDG Portals oder andere Mechanismen zu benachrichtigen.
    - Die UI-Schicht, um einen Shutdown-Dialog anzuzeigen.

#### 2.5. Implementierungsschritte `domain::common_events`

1. **Datei erstellen:** `novade-domain/src/common_events.rs`.
2. **Typen definieren:** `UserActivityType`, `UserActivityDetectedEvent`, `ShutdownReason`, `SystemShutdownInitiatedEvent` wie oben spezifiziert, inklusive aller Methoden und `serde`-Attribute.
3. **`novade-domain/src/lib.rs` anpassen:**
    
    Rust
    
    ```
    // In novade-domain/src/lib.rs
    pub mod common_events;
    // Re-export für einfacheren Zugriff
    pub use common_events::{
        UserActivityType, UserActivityDetectedEvent,
        ShutdownReason, SystemShutdownInitiatedEvent,
    };
    ```
    
4. **Unit-Tests erstellen (`novade-domain/src/common_events.rs` -> `#[cfg(test)] mod tests { ... }`):**
    - Für `UserActivityDetectedEvent`:
        - `test_user_activity_event_new()`: Korrekte Initialisierung von `event_id` und `timestamp`.
        - `test_user_activity_event_serde()`: Serialisierung/Deserialisierung.
    - Für `SystemShutdownInitiatedEvent`:
        - `test_system_shutdown_event_new()`: Korrekte Initialisierung.
        - `test_system_shutdown_event_serde()`: Serialisierung/Deserialisierung.
    - Für Enums: Teste `Default`-Implementierung und Serialisierung/Deserialisierung.

---

### Modul 3: `domain::theming`

Bestehende Spezifikation: und vorherige Antwort.

Verantwortlichkeiten: Logik für Erscheinungsbild, Design-Token-Verwaltung, dynamische Theme-Wechsel.

#### Verfeinerungen und Ergänzungen:

**3.1. `domain::theming::types` (`src/theming/types.rs`)**

- **`TokenIdentifier`**:
    - **Validierung in `new()`**: `debug_assert!(!id_str.is_empty() && id_str.chars().all(|c| c.is_ascii_alphanumeric() || c == '.' || c == '-'), "TokenIdentifier darf nur ASCII-Alphanumerisch, Punkte und Bindestriche enthalten und nicht leer sein.");`
- **`TokenValue`**:
    - **`Reference(TokenIdentifier)`**: Stellt sicher, dass Alias-Tokens klar definiert sind.
    - **Validierung**: Die String-Werte für `Color`, `Dimension` etc. sollten idealerweise bei der Erstellung oder beim Parsen einer Basisvalidierung unterzogen werden (z.B. Hex-Format für Farben, Suffix "px"/"rem" für Dimensionen). Dies kann durch spezifische Newtype-Wrapper oder Validierungsfunktionen in der Logikschicht erfolgen. Für die `TokenValue` selbst bleiben es Strings, die Validierung erfolgt in der `TokenResolutionPipeline`.
- **`AccentColor`**:
    - **`value: novade_core::types::Color`**: Anstatt `String` direkt den `Color`-Typ aus der Kernschicht verwenden. Dies erfordert, dass `Color` `serde` mit `from_hex`/`to_hex_string` implementiert.
        - **Konsequenz:** Die `from_hex`-Logik und `ColorParseError` aus `core::types::color` bzw. `core::errors` wird hier relevant.
- **`AppliedThemeState`**:
    - `resolved_tokens: std::collections::BTreeMap<TokenIdentifier, String>`: `BTreeMap` statt `HashMap` verwenden, um eine deterministische Reihenfolge der Tokens zu gewährleisten, was für Tests und das Debugging von generiertem CSS nützlich sein kann. `TokenIdentifier` muss `Ord` implementieren.
- **`ThemingConfiguration`**:
    - `selected_accent_color: Option<novade_core::types::Color>`: Verwendet `core::types::Color`.

**3.2. `domain::theming::errors` (`src/theming/errors.rs`)**

- **`ThemingError`**:
    - `InvalidTokenValue { token_id: TokenIdentifier, value_string: String, reason: String }`: Neuer Fehler für ungültige Werte innerhalb eines `RawToken` nach dem Parsen, aber vor der Auflösung.
    - `AccentColorApplicationError { theme_id: ThemeIdentifier, accent_color: novade_core::types::Color, details: String }`: Spezifischer Fehler für die Akzentfarbenanwendung.

**3.3. `domain::theming::logic` (oder `engine_internal`) (`src/theming/logic.rs`)**

- **Token- und Theme-Laden (`async fn load_and_validate_token_files`, `async fn load_and_validate_theme_files`):**
    - Nutzen `novade_core::config::ConfigServiceAsync` (hypothetischer Trait) für asynchronen Dateizugriff. Die Implementierung dieses Traits in `novade-core` würde `tokio::fs` verwenden.
    - Beim Parsen von `RawToken.value` (z.B. `TokenValue::Color(s)`) könnte eine erste Basisvalidierung des `s` erfolgen.
- **Token Resolution Pipeline (`resolve_tokens_for_config`):**
    - **Akzentfarben-Logik:**
        1. Die `ThemeDefinition` sollte definieren, welche Tokens "akzentfähig" sind und wie sie modifiziert werden (z.B. eine Liste von `(TokenIdentifier, AccentModificationType)` wobei `AccentModificationType` `DirectReplace`, `Lighten(f32)`, `Darken(f32)` sein könnte).
        2. Wenn `config.selected_accent_color` gesetzt ist:
            - Iteriere über die akzentfähigen Tokens des Themes.
            - `DirectReplace`: Der Wert des akzentfähigen Tokens (z.B. `token.system.accent.primary`) wird direkt auf den Wert der `selected_accent_color` gesetzt.
            - `Lighten/Darken`: Der Basiswert des akzentfähigen Tokens wird mit der `selected_accent_color` als Referenz aufgehellt/abgedunkelt (erfordert Farbmodifikationslogik, die ggf. `novade_core::types::Color` Methoden nutzt).
    - **Caching-Schlüssel für `resolved_state_cache`**:
        - `CacheKey(ThemeIdentifier, ColorSchemeType, Option<novade_core::types::Color>, u64)`: `AccentColor` direkt (da `Color` hashbar sein kann, wenn f32-Felder mit einer Wrapper-Struct gehasht werden, die Bit-Repräsentationen vergleicht oder eine feste Präzision annimmt – einfacher ist, `color.to_hex_string(true)` zu hashen oder zu verwenden). Für `u64` den Hash der `custom_user_token_overrides` verwenden.
- **Fallback-Theme Laden (`load_fallback_theme_definition`):**
    - JSON-Strings für Fallback-Theme und -Tokens werden mittels `include_str!("default_themes/fallback.theme.json")` etc. einkompiliert.

**3.4. `ThemingEngine` Service (`src/theming/service.rs`)**

- **`ThemingEngineInternalState`**:
    - `event_sender: tokio::sync::broadcast::Sender<ThemeChangedEvent>`: Wird korrekt initialisiert.
    - `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>`: Wird injiziert für das Laden von Dateien.
- **Methoden:**
    - `new(...)`: Benötigt `Arc<dyn novade_core::config::ConfigServiceAsync>`.
    - `reload_themes_and_tokens()`: Nutzt den injizierten `config_service` für asynchrones Neuladen.
    - Event-Versand: `if self.event_sender.send(event).is_err() { tracing::warn!("ThemingEngine: Keine aktiven Subscriber für ThemeChangedEvent vorhanden."); }`

**3.5. Detaillierte Implementierungsschritte `domain::theming`**

1. **Grundgerüst schaffen:** Verzeichnisstruktur anlegen, `Cargo.toml`-Abhängigkeiten prüfen/ergänzen.
2. **`types.rs` implementieren:**
    - `TokenIdentifier`, `TokenValue`, `RawToken`, `TokenSet` definieren.
    - `ThemeIdentifier`, `ColorSchemeType`, `AccentColor` (mit `core::types::Color`), `ThemeVariantDefinition`, `ThemeDefinition` definieren.
    - `AppliedThemeState` (mit `BTreeMap`), `ThemingConfiguration` (mit `core::types::Color`) definieren.
    - Alle notwendigen `derive`s (`Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`, `Default`, `Ord`, `Hash` wo sinnvoll) und `serde`-Attribute hinzufügen.
    - Unit-Tests für Serialisierung/Deserialisierung und `Default`-Werte schreiben.
3. **`errors.rs` implementieren:**
    - `ThemingError`-Enum mit allen Varianten und `thiserror`-Attributen.
    - Unit-Tests für `Display`-Format und `source()`-Verhalten.
4. **`logic.rs` (oder Submodule) implementieren:**
    - `load_and_validate_token_files_async`: Liest JSON-Dateien (via `config_service`), parst zu `TokenSet`, validiert (Duplikate, Basis-Format von Werten).
    - `load_and_validate_theme_files_async`: Liest JSON, parst zu `ThemeDefinition`, validiert (Token-Referenzen).
    - `validate_tokenset_for_cycles`: Implementiert Zyklenerkennung.
    - `resolve_tokens_for_config`: Implementiert die vollständige Pipeline (Basis, Variante, Akzent, Overrides, Referenzauflösung).
        - Private Hilfsfunktionen für jeden Schritt der Pipeline.
        - Funktion zur Anwendung von Akzentfarben (ggf. mit `Lighten`/`Darken`-Logik).
    - `generate_fallback_applied_state`: Lädt einkompilierte JSONs und erzeugt daraus einen minimalen `AppliedThemeState`.
    - Unit-Tests für jeden Logik-Schritt und Fehlerfall.
5. **`service.rs` (oder `mod.rs`) `ThemingEngine` implementieren:**
    - `ThemingEngineInternalState`-Struktur definieren.
    - `ThemingEngine`-Struktur mit `Arc<Mutex<ThemingEngineInternalState>>` und `broadcast::Sender`.
    - `new()`-Konstruktor: Initialisiert `event_sender`, `config_service`, lädt initial Themes/Tokens, berechnet ersten `applied_state` (oder Fallback), füllt Cache.
    - `get_current_theme_state()`, `get_available_themes()`, `get_current_configuration()`: Implementieren Klonen aus dem internen Zustand.
    - `update_configuration()`: Berechnet neuen Zustand, prüft auf Änderungen, aktualisiert internen Zustand, sendet Event, aktualisiert Cache.
    - `reload_themes_and_tokens()`: Lädt neu, berechnet neu, sendet Event, invalidiert Cache.
    - `subscribe_to_theme_changes()`: Gibt `event_sender.subscribe()` zurück.
    - Unit-Tests für alle API-Methoden, Zustandsänderungen, Event-Auslösung, Cache-Verhalten (Invalidierung, Treffer). Mocking des `ConfigServiceAsync`.
6. **`default_themes/` Verzeichnis anlegen:** `fallback.theme.json` und `base.tokens.json` mit minimalen, gültigen Werten erstellen.
7. **`src/theming/mod.rs` erstellen:** Module deklarieren und öffentliche API re-exportieren (`ThemingEngine`, `ThemeChangedEvent`, wichtige Typen aus `types.rs`, `ThemingError`).

---

Die Spezifikationen für die Module `domain::global_settings_and_state_management`, `domain::workspaces`, `domain::window_management_policy`, `domain::user_centric_services` und `domain::notifications_rules` würden mit derselben Detailtiefe folgen, aufbauend auf den bereits existierenden Zitationen und den hier gezeigten Verfeinerungen und Implementierungsschritten.

**Beispielhafte Verfeinerungen für `domain::global_settings_and_state_management`:**

- **`types.rs`**:
    - Für alle Einstellungs-Unterstrukturen (z.B. `AppearanceSettings`) eine `validate(&self) -> Result<(), GlobalSettingsError>`-Methode hinzufügen, die spezifische Konsistenzprüfungen durchführt (z.B. "wenn `color_scheme == AutoSystem`, dann darf `manual_dark_mode_active` nicht `true` sein" – hypothetisch). Diese wird von `DefaultGlobalSettingsService::update_setting` nach der Deserialisierung aufgerufen.
- **`paths.rs`**:
    - Implementierung von `impl std::fmt::Display for SettingPath` für menschenlesbare Pfade in Logs/Fehlern.
    - Implementierung von `impl TryFrom<&str> for SettingPath` und `impl From<SettingPath> for String` für die Konvertierung zu/von String-basierten Pfaden (nützlich für D-Bus APIs oder Debugging).
- **`service.rs`**:
    - `DefaultGlobalSettingsService::update_setting`:
        1. Auflösen des `SettingPath` zu einem mutierbaren Verweis auf das spezifische Feld in `self.settings` (z.B. mittels Makro oder einer großen `match`-Anweisung).
        2. Deserialisieren des `serde_json::Value` in den erwarteten Typ des Feldes. `Err(GlobalSettingsError::InvalidValueType)` bei Fehlschlag.
        3. Validieren des deserialisierten Wertes mit einer spezifischen Validierungsfunktion für diese Einstellung (oder einer Methode auf der Einstellungs-Unterstruktur). `Err(GlobalSettingsError::ValidationError)` bei Fehlschlag.
        4. Wert aktualisieren, `SettingChangedEvent` senden, `save_settings()` aufrufen.

Dieser extrem granulare Ansatz ist zwar aufwendig, aber unerlässlich, um das Ziel eines "finalen lückenlosen Entwickler-Implementierungsleitfadens" zu erreichen. Jede Komponente ist bis ins Detail durchdacht, was die Implementierung erheblich beschleunigt und die Fehleranfälligkeit reduziert.


---

### Modul 3: `domain::theming`

Zweck: Logik des Erscheinungsbilds (Theming), Verwaltung von Design-Tokens, Interpretation von Theme-Definitionen, dynamische Theme-Wechsel (Farbschema, Akzentfarben). Dieses Modul stellt sicher, dass die UI-Schicht die korrekten, aufgelösten Stilwerte erhält.

Verantwortlichkeiten: Parsen von Token- und Theme-Dateien, Auflösen von Token-Referenzen und -Hierarchien, Anwenden von Benutzerkonfigurationen auf Themes, Bereitstellen des finalen AppliedThemeState und Benachrichtigen bei Änderungen.

Design-Rationale: Trennung der Theming-Logik von der UI-Darstellung. Ein Token-basiertes System ermöglicht hohe Flexibilität und Konsistenz. Dynamische Wechsel zur Laufzeit sind ein Kernziel.

Bestehende Spezifikation: und vorherige Antwort.

#### 3.1. Untermodul: `domain::theming::types`

**Datei:** `src/theming/types.rs`

- **Struct `TokenIdentifier`**
    
    - **Definition:**
        
        Rust
        
        ```
        use serde::{Serialize, Deserialize};
        use std::fmt;
        
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
        pub struct TokenIdentifier(String);
        
        impl TokenIdentifier {
            pub fn new(id: impl Into<String>) -> Self {
                let id_str = id.into();
                // Invariante: Nicht leer und nur erlaubte Zeichen.
                // Hier nur Debug-Assert, da Validierung auch beim Parsen erfolgen kann.
                debug_assert!(!id_str.is_empty(), "TokenIdentifier darf nicht leer sein.");
                debug_assert!(
                    id_str.chars().all(|c| c.is_ascii_alphanumeric() || c == '.' || c == '-'),
                    "TokenIdentifier ({}) enthält ungültige Zeichen.", id_str
                );
                Self(id_str)
            }
            pub fn as_str(&self) -> &str { &self.0 }
        }
        impl fmt::Display for TokenIdentifier { /* ... */ } // Wie in [cite:656]
        impl From<&str> for TokenIdentifier { fn from(s: &str) -> Self { Self::new(s) } }
        ```
        
    - **Invarianten:** String nicht leer, enthält nur `a-zA-Z0-9.-`.
- **Enum `TokenValue`**
    
    - **Definition:**
        
        Rust
        
        ```
        // ... (andere Varianten wie in)
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        #[serde(rename_all = "kebab-case")]
        pub enum TokenValue {
            Color(String),      // CSS-kompatibler Farbwert, z.B. "#RRGGBB", "rgba(...)", "var(--andere-farbe)"
            Dimension(String),  // z.B. "16px", "2rem", "calc(100% - 20px)"
            FontSize(String),
            FontFamily(String),
            FontWeight(String), // z.B. "400", "bold"
            LineHeight(String), // z.B. "1.5", "150%"
            LetterSpacing(String),
            Border(String),     // z.B. "1px solid var(--border-color)"
            Shadow(String),
            Radius(String),
            Spacing(String),
            ZIndex(i32),
            Opacity(f64),       // Validierung: 0.0 <= opacity <= 1.0
            Text(String),
            Reference(TokenIdentifier), // Verweis auf eine andere TokenIdentifier
        }
        ```
        
    - **Invarianten:** Für `Opacity`, Wert muss zwischen 0.0 und 1.0 liegen. Die Strings in den anderen Varianten sollten gültige CSS-Werte sein (Validierung erfolgt später in der Pipeline oder bei der Anwendung).
- **Struct `RawToken`**
    
    - **Definition:** Wie in. `id: TokenIdentifier`, `value: TokenValue`, `description: Option<String>`, `group: Option<String>`.
    - **Ableitungen:** `Debug, Clone, PartialEq, Serialize, Deserialize`.
- **Typalias `TokenSet`**: `pub type TokenSet = std::collections::BTreeMap<TokenIdentifier, RawToken>;` (BTreeMap für deterministische Reihenfolge).
    
- **Struct `ThemeIdentifier`**
    
    - **Definition:** Analog zu `TokenIdentifier`.
        
        Rust
        
        ```
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
        pub struct ThemeIdentifier(String);
        // ... impls wie TokenIdentifier ...
        ```
        
    - **Invarianten:** String nicht leer, empfohlene Zeichen: `a-zA-Z0-9-`.
- **Enum `ColorSchemeType`**
    
    - **Definition:** Wie in. `Light`, `Dark`.
    - **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default`. (`#[default]` für `Light` oder `Dark` festlegen).
- **Struct `AccentColor`**
    
    - **Definition:**
        
        Rust
        
        ```
        use novade_core::types::Color as CoreColor; // Verwendung des Kerntyps
        
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AccentColor {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub name: Option<String>, // z.B. "Blau", "Waldgrün"
            pub value: CoreColor,     // Der tatsächliche Farbwert
        }
        // Eq und Hash manuell implementieren, wenn CoreColor::f32 nicht direkt Eq/Hash ist.
        // Für Cache-Zwecke kann der Hex-String von CoreColor verwendet werden.
        ```
        
- **Struct `ThemeVariantDefinition`**: Wie in. `applies_to_scheme: ColorSchemeType`, `tokens: TokenSet`.
    
- **Struct `ThemeDefinition`**: Wie in. Enthält `id`, `name`, `base_tokens`, `variants`, `supported_accent_colors: Option<Vec<AccentColor>>`.
    
- **Struct `AppliedThemeState`**
    
    - **Definition:** Wie in vorheriger Antwort verfeinert (mit `BTreeMap`).
        
        Rust
        
        ```
        use std::collections::BTreeMap;
        // ...
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)] // Serialize/Deserialize für Caching/Events
        pub struct AppliedThemeState {
            pub theme_id: ThemeIdentifier,
            pub color_scheme: ColorSchemeType,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub active_accent_color: Option<AccentColor>,
            pub resolved_tokens: BTreeMap<TokenIdentifier, String>, // CSS-finale Werte
        }
        ```
        
- **Struct `ThemingConfiguration`**
    
    - **Definition:** Wie in vorheriger Antwort verfeinert.
        
        Rust
        
        ```
        use novade_core::types::Color as CoreColor;
        // ...
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ThemingConfiguration {
            pub selected_theme_id: ThemeIdentifier,
            pub preferred_color_scheme: ColorSchemeType,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub selected_accent_color: Option<CoreColor>, // Verwendet CoreColor
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub custom_user_token_overrides: Option<TokenSet>,
        }
        impl Default for ThemingConfiguration { /* Sinnvolle Standardwerte, z.B. Fallback-Theme */ }
        ```
        

#### 3.2. Untermodul: `domain::theming::errors`

**Datei:** `src/theming/errors.rs`

- **Enum `ThemingError`**: Wie in vorheriger Antwort verfeinert (konsolidierte Liste aus und Ergänzungen).
    
    Rust
    
    ```
    use thiserror::Error;
    use std::path::PathBuf;
    use super::types::{TokenIdentifier, ThemeIdentifier}; // Lokale Typen
    use novade_core::types::Color as CoreColor; // Kerntyp
    
    #[derive(Debug, Error)]
    pub enum ThemingError {
        #[error("Failed to parse token file '{path}': {source}")]
        TokenFileParseError { path: PathBuf, #[source] source: serde_json::Error },
        #[error("I/O error while processing token file '{path}': {source}")]
        TokenFileIoError { path: PathBuf, #[source] source: std::io::Error },
        #[error("Invalid token data in file '{path}': {message}")]
        InvalidTokenData { path: PathBuf, message: String },
        #[error("Invalid token value for '{token_id}': '{value_string}'. Reason: {reason}")]
        InvalidTokenValue { token_id: TokenIdentifier, value_string: String, reason: String },
        #[error("Cyclic dependency detected involving token '{token_id}'. Cycle path: {cycle_path:?}")]
        CyclicTokenReference { token_id: TokenIdentifier, cycle_path: Vec<TokenIdentifier> },
        #[error("Failed to load theme definition '{theme_id}' from file '{path}': {source}")]
        ThemeFileLoadError { theme_id: ThemeIdentifier, path: PathBuf, #[source] source: serde_json::Error },
        #[error("I/O error while loading theme definition '{theme_id}' from file '{path}': {source}")]
        ThemeFileIoError { theme_id: ThemeIdentifier, path: PathBuf, #[source] source: std::io::Error },
        #[error("Invalid theme data for theme '{theme_id}' in file '{path}': {message}")]
        InvalidThemeData { theme_id: ThemeIdentifier, path: PathBuf, message: String },
        #[error("Theme with ID '{theme_id}' not found.")]
        ThemeNotFound { theme_id: ThemeIdentifier },
        #[error("Referenced token '{target_token_id}' not found (referenced by '{referencing_token_id}').")]
        MissingTokenReference { referencing_token_id: TokenIdentifier, target_token_id: TokenIdentifier },
        #[error("Maximum token reference depth ({depth}) exceeded while resolving '{token_id}'.")]
        MaxReferenceDepthExceeded { token_id: TokenIdentifier, depth: u8 },
        #[error("Failed to apply theming configuration: {message}")]
        ThemeApplicationError { message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> },
        #[error("Critical error: Failed to initialize theming engine because no suitable fallback theme could be loaded: {source}")]
        FallbackThemeLoadError { #[source] source: Box<dyn std::error::Error + Send + Sync + 'static> },
        #[error("Initial theming configuration is invalid: {0}")]
        InitialConfigurationError(String),
        #[error("Internal state error in ThemingEngine: {0}")]
        InternalStateError(String),
        #[error("Failed to subscribe to theme change events: {0}")]
        EventSubscriptionError(String),
        #[error("Error applying accent color '{accent_color}' to theme '{theme_id}': {details}")]
        AccentColorApplicationError { theme_id: ThemeIdentifier, accent_color: CoreColor, details: String },
        #[error("Failed to resolve token '{token_id}': {message}")]
        TokenResolutionError { token_id: TokenIdentifier, message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> },
        #[error("Filesystem operation error for ThemingEngine: {0}")] // Neuer Fehler für ConfigServiceAsync-Fehler
        FilesystemError(#[from] novade_core::errors::CoreError), // Annahme: ConfigServiceAsync gibt CoreError zurück
    }
    ```
    

#### 3.3. Untermodul: `domain::theming::logic` (oder `engine_internal`)

**Datei:** `src/theming/logic.rs` (und ggf. `token_loader.rs`, `theme_loader.rs`, `token_resolver.rs`)

- **Konstante:** `const MAX_TOKEN_RESOLUTION_DEPTH: u8 = 16;`
- **Funktion: `async fn load_raw_tokens_from_file(path: &Path, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`**
    1. `content = config_service.read_file_to_string(path).await.map_err(|e| ThemingError::TokenFileIoError { path: path.to_path_buf(), source: e.into_std_io_error_or_generic() })?;` (Annahme: `ConfigServiceAsync` gibt einen Fehler zurück, der in `std::io::Error` oder einen generischen `CoreError` konvertiert werden kann).
    2. `raw_tokens: Vec<RawToken> = serde_json::from_str(&content).map_err(|e| ThemingError::TokenFileParseError { path: path.to_path_buf(), source: e })?;`
    3. In `TokenSet` (`BTreeMap`) konvertieren. Bei Duplikaten: `ThemingError::InvalidTokenData`.
    4. Basisvalidierung jedes `RawToken.value` (z.B. `TokenValue::Opacity(o)` prüfen, ob `0.0 <= o <= 1.0`). Bei Fehler: `ThemingError::InvalidTokenValue`.
- **Funktion: `async fn load_and_validate_token_files(paths: &[PathBuf], config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`**
    1. Iteriert über `paths`, ruft `load_raw_tokens_from_file` für jede Datei auf.
    2. Mergt die `TokenSet`s (Benutzer-spezifische überschreiben System-spezifische, falls Pfade so interpretiert werden). Loggt Überschreibungen mit `tracing::debug!`.
    3. Ruft `validate_tokenset_for_cycles` für das finale Set auf.
- **Funktion: `async fn load_theme_definition_from_file(...)`**: Analog zu Tokens, parst zu `ThemeDefinition`.
- **Funktion: `async fn load_and_validate_theme_files(...)`**: Analog, validiert zusätzlich Referenzen mittels `validate_theme_definition_references`.
- **Funktion: `validate_tokenset_for_cycles(tokens: &TokenSet) -> Result<(), ThemingError>`**
    - Implementiert Tiefensuche. Verfolgt den aktuellen Pfad (`Vec<TokenIdentifier>`). Wenn ein bereits besuchtes Token im aktuellen Pfad erneut angetroffen wird -> Zyklus.
- **Funktion: `validate_theme_definition_references(theme_def: &ThemeDefinition, global_tokens: &TokenSet) -> Result<(), ThemingError>`** (Wie in).
- **Funktion: `resolve_tokens_for_config(...) -> Result<BTreeMap<TokenIdentifier, String>, ThemingError>`**
    1. **Ausgangspunkt:** Erstelle `current_resolved_tokens: BTreeMap<TokenIdentifier, TokenValue>` (noch nicht final Strings).
    2. **Basissatz:** Kopiere `global_tokens` nach `current_resolved_tokens`. Überschreibe/Merge mit `theme_def.base_tokens`.
    3. **Variante anwenden:** Finde passende `ThemeVariantDefinition` für `config.preferred_color_scheme`. Merge deren `tokens` in `current_resolved_tokens`.
    4. **Akzentfarbe anwenden:**
        - Wenn `config.selected_accent_color` (Typ `CoreColor`) vorhanden ist:
        - Iteriere über `theme_def.accentable_tokens` (neues Feld in `ThemeDefinition`: `Option<HashMap<TokenIdentifier, AccentModificationType>>`).
        - Für jeden `token_id_to_accent` und `modification_type`:
            - Hole den Basiswert des `token_id_to_accent` aus `current_resolved_tokens` (muss ein `TokenValue::Color` sein).
            - Wende `modification_type` an (z.B. `DirectReplace` -> setze auf `selected_accent_color`; `Lighten(0.2)` -> helle `selected_accent_color` um 20% auf und setze das als neuen Wert).
            - Aktualisiere `current_resolved_tokens`. Bei Fehlern: `ThemingError::AccentColorApplicationError`.
    5. **Benutzer-Overrides:** Merge `config.custom_user_token_overrides` (falls vorhanden) in `current_resolved_tokens`.
    6. **Rekursive Referenzauflösung:**
        - Iteriere über `current_resolved_tokens`. Für jedes `(id, value)`:
        - `final_value = resolve_single_token_value(id, value, &current_resolved_tokens, Vec::new(), max_depth)?`
        - Speichere `(id, final_value_as_string)` in `final_css_tokens: BTreeMap<TokenIdentifier, String>`.
        - Die `resolve_single_token_value` Funktion ist rekursiv:
            
            Rust
            
            ```
            fn resolve_single_token_value(
                original_id: &TokenIdentifier,
                current_value: &TokenValue,
                all_tokens: &BTreeMap<TokenIdentifier, TokenValue>, // Zustand vor String-Konvertierung
                visited_path: &mut Vec<TokenIdentifier>, // Für Zyklenerkennung
                max_depth: u8,
            ) -> Result<String, ThemingError> {
                if visited_path.len() > max_depth as usize {
                    return Err(ThemingError::MaxReferenceDepthExceeded { token_id: original_id.clone(), depth: max_depth });
                }
                if visited_path.contains(original_id) {
                    return Err(ThemingError::CyclicTokenReference { token_id: original_id.clone(), cycle_path: visited_path.clone() });
                }
                visited_path.push(original_id.clone());
            
                let result = match current_value {
                    TokenValue::Reference(target_id) => {
                        let target_raw_value = all_tokens.get(target_id)
                            .ok_or_else(|| ThemingError::MissingTokenReference {
                                referencing_token_id: original_id.clone(),
                                target_token_id: target_id.clone(),
                            })?;
                        // Rekursiver Aufruf für das Ziel
                        resolve_single_token_value(target_id, target_raw_value, all_tokens, visited_path, max_depth)
                    }
                    TokenValue::Color(s) => Ok(s.clone()),
                    TokenValue::Dimension(s) => Ok(s.clone()),
                    // ... andere direkte Typen zu String ...
                    TokenValue::Opacity(o) => Ok(format!("{:.2}", o.clamp(0.0, 1.0))),
                    TokenValue::ZIndex(z) => Ok(z.to_string()),
                    TokenValue::Text(s) => Ok(s.clone()),
                };
                visited_path.pop(); // Wichtig: Beim Verlassen des Rekursionsschritts entfernen
                result
            }
            ```
            
    7. Gib `final_css_tokens` zurück.
- **Caching-Logik:**
    - **Cache-Schlüssel:** `(ThemeIdentifier, ColorSchemeType, Option<String> /* hex von AccentColor */, u64 /* hash von Overrides */)`.
    - Vor der Auflösung im Cache nachsehen. Bei Treffer direkt zurückgeben.
    - Nach erfolgreicher Auflösung Ergebnis im Cache speichern.
- **Fallback-Theme Laden:**
    - `pub(crate) fn generate_fallback_applied_state() -> AppliedThemeState`: Parst einkompilierte JSONs für `fallback.theme.json` und `base.tokens.json`, führt minimale Auflösung durch (sollte keine komplexen Referenzen haben).

#### 3.4. Öffentliche API: `ThemingEngine` Service

**Datei:** `src/theming/service.rs` (oder `mod.rs`)

- **Struct `ThemingEngineInternalState`**:
    - `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>` (neu)
    - Rest wie in vorheriger Antwort (Cache-Typ angepasst).
- **Struct `ThemingEngine`**:
    - `internal_state: Arc<tokio::sync::Mutex<ThemingEngineInternalState>>` (Verwendung von `tokio::sync::Mutex` für `async` Methoden).
    - `event_sender: tokio::sync::broadcast::Sender<ThemeChangedEvent>`.
- **Methoden der `ThemingEngine`**:
    - `pub async fn new(initial_config: ThemingConfiguration, theme_load_paths: Vec<PathBuf>, token_load_paths: Vec<PathBuf>, config_service: Arc<dyn novade_core::config::ConfigServiceAsync>, broadcast_capacity: usize) -> Result<Self, ThemingError>`:
        1. Initialisiert `event_sender`, `config_service_ref`.
        2. Sperrt `internal_state` (initial leer).
        3. Speichert `theme_load_paths`, `token_load_paths`, `config_service_ref` in `internal_state`.
        4. Ruft `internal_load_themes_and_tokens_locked(&mut internal_state_guard).await?` auf.
        5. Ruft `internal_apply_configuration_locked(&mut internal_state_guard, initial_config, true /* is_initial */).await?` auf.
        6. Gibt `Self` zurück.
    - `async fn internal_load_themes_and_tokens_locked(&mut self_internal: &mut ThemingEngineInternalState) -> Result<(), ThemingError>`: Interne Methode zum Neuladen.
    - `async fn internal_apply_configuration_locked(&mut self_internal: &mut ThemingEngineInternalState, config: ThemingConfiguration, is_initial: bool) -> Result<(), ThemingError>`: Interne Methode zum Anwenden einer Konfig, prüft Cache, löst Pipeline aus, aktualisiert `applied_state`, `current_config`, sendet Event. Wenn `is_initial` und Auflösung fehlschlägt, wird `generate_fallback_applied_state` verwendet.
    - `pub async fn get_current_theme_state(&self) -> AppliedThemeState`: Sperrt `internal_state`, klont und gibt `applied_state` zurück.
    - `pub async fn get_available_themes(&self) -> Vec<ThemeDefinition>`: Sperrt, klont, gibt zurück.
    - `pub async fn get_current_configuration(&self) -> ThemingConfiguration`: Sperrt, klont, gibt zurück.
    - `pub async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`: Sperrt `internal_state`, ruft `internal_apply_configuration_locked(..., new_config, false).await`.
    - `pub async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`: Sperrt `internal_state`, ruft `internal_load_themes_and_tokens_locked().await`, dann `internal_apply_configuration_locked(..., self_internal.current_config.clone(), false).await`. Invalidiert kompletten Cache.
    - `pub fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeChangedEvent>`: Gibt `self.event_sender.subscribe()` zurück.
- **Event `ThemeChangedEvent`**:
    - **Payload:** `pub new_state: AppliedThemeState`
    - **Publisher:** `ThemingEngine` (via `event_sender`).
    - **Subscriber:** `ui::theming_gtk` (wendet CSS an), `domain::global_settings_service` (wenn Theming-Einstellungen sich auf globale Nicht-Theme-Einstellungen auswirken, z.B. Kontrastmodus).

#### 3.5. Implementierungsschritte `domain::theming`

(Wie in vorheriger Antwort, aber mit `async` für Ladeoperationen und `tokio::sync::Mutex` für `ThemingEngineInternalState`.)

1. **Grundgerüst** und `Cargo.toml` aktualisieren.
2. **`types.rs`**: `AccentColor` mit `CoreColor`, `AppliedThemeState` mit `BTreeMap`, `ThemingConfiguration` mit `CoreColor`. `TokenIdentifier` Validierung.
3. **`errors.rs`**: `ThemingError` um `InvalidTokenValue`, `AccentColorApplicationError`, `FilesystemError` erweitern. `FallbackThemeLoadError` mit `#[source]`.
4. **`logic.rs`**:
    - Ladefunktionen (`load_raw_tokens_from_file`, etc.) `async` machen, `ConfigServiceAsync` nutzen.
    - `resolve_tokens_for_config`: Akzentfarben-Logik detaillieren (Nutzung von `accentable_tokens` aus `ThemeDefinition`). `MAX_TOKEN_RESOLUTION_DEPTH` verwenden. Rekursive `resolve_single_token_value` Funktion implementieren.
    - Caching-Logik mit `CacheKey` (inkl. Hash für Overrides) implementieren.
    - `generate_fallback_applied_state`: JSONs parsen und minimalen State erzeugen.
5. **`service.rs`**: `ThemingEngine` mit `tokio::sync::Mutex` für `internal_state`. `async` API-Methoden. Interne `_locked`-Methoden für die Hauptlogik. Event-Versand über `tokio::sync::broadcast`.
6. **Unit-Tests**: An `async` anpassen. Mocking des `ConfigServiceAsync`. Tests für Akzentfarben, Cache-Logik (Treffer, Fehlschlag, Invalidierung).
7. **Fallback-JSONs** in `default_themes/` erstellen.
8. **`mod.rs`**: Öffentliche API re-exportieren.

---

### Modul 4: `domain::global_settings_and_state_management`

Zweck: Repräsentation, Logik zur Verwaltung und Konsistenz globaler Desktop-Einstellungen.

Bestehende Spezifikation: und vorherige Antwort.

#### Verfeinerungen und Ergänzungen:

**4.1. `domain::global_settings::types` (`src/global_settings/types.rs`)**

- Alle Einstellungs-Structs (z.B. `AppearanceSettings`, `InputBehaviorSettings`) müssen vollständig ausdefiniert werden, inklusive aller Felder, Typen, `serde`-Attribute (`#[serde(default)]`, `#[serde(rename_all = "kebab-case")]` für TOML-Kompatibilität) und `Default`-Implementierungen.
    
    Rust
    
    ```
    // Beispiel für InputBehaviorSettings
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    #[serde(default, rename_all = "kebab-case")]
    pub struct InputBehaviorSettings {
        pub mouse_acceleration_profile: MouseAccelerationProfile,
        pub custom_mouse_acceleration_factor: Option<f32>, // Validierung: 0.0 < factor
        pub mouse_sensitivity: f32, // Validierung: z.B. 0.1 - 10.0
        pub natural_scrolling_mouse: bool,
        pub natural_scrolling_touchpad: bool,
        pub tap_to_click_touchpad: bool,
        pub touchpad_pointer_speed: f32, // Validierung: z.B. 0.1 - 10.0
        pub keyboard_repeat_delay_ms: u32, // Validierung: z.B. 100-2000
        pub keyboard_repeat_rate_cps: u32, // Zeichen pro Sekunde; Validierung: z.B. 10-100
    }
    impl Default for InputBehaviorSettings { /* ... */ }
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum MouseAccelerationProfile { #[default] Adaptive, Flat, Custom }
    ```
    
- **Validierungsmethoden**: Jede Einstellungs-Unterstruktur sollte eine `pub fn validate(&self) -> Result<(), String>`-Methode (oder `Result<(), GlobalSettingsError::ValidationError>`) haben, die interne Konsistenz und Wertebereiche prüft.
    - Beispiel: `InputBehaviorSettings::validate(&self)` prüft, ob `custom_mouse_acceleration_factor` nur `Some` ist, wenn `mouse_acceleration_profile == Custom`, und ob Faktoren/Raten in gültigen Bereichen liegen.

**4.2. `domain::global_settings::paths` (`src/global_settings/paths.rs`)**

- Der `SettingPath`-Enum muss die gesamte Hierarchie von `GlobalDesktopSettings` exakt abbilden.
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum SettingPath {
        Appearance(AppearanceSettingPath),
        WorkspaceConfig(WorkspaceSettingPath),
        InputBehavior(InputBehaviorSettingPath),
        // ...
    }
    // ... für jede Unterstruktur
    ```
    
- **Implementierung von `TryFrom<&str>` und `Display` für `SettingPath`:**
    
    Rust
    
    ```
    // Beispielhaft für einen Teilpfad
    impl fmt::Display for AppearanceSettingPath {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                AppearanceSettingPath::ActiveThemeName => write!(f, "appearance.active-theme-name"),
                AppearanceSettingPath::FontSettings(fp) => write!(f, "appearance.font-settings.{}", fp),
                // ...
            }
        }
    }
    // TryFrom<&str> erfordert sorgfältiges Parsen des Strings.
    ```
    

**4.3. `domain::global_settings::errors` (`src/global_settings/errors.rs`)**

- **`GlobalSettingsError`**:
    - `ValidationError { path: SettingPath, reason: String }`: Verwendet `SettingPath` statt `String`.
    - `PathNotFound { path: SettingPath }`.
    - `PersistenceError` sollte den spezifischen Fehler aus dem `SettingsPersistenceProvider` wrappen.

**4.4. `domain::global_settings::persistence_iface` (`src/global_settings/persistence_iface.rs`)**

- **Trait `SettingsPersistenceProvider`**:
    
    Rust
    
    ```
    #[async_trait]
    pub trait SettingsPersistenceProvider: Send + Sync {
        async fn load_global_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>;
        async fn save_global_settings(&self, settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>;
    }
    ```
    
- **Implementierung `FilesystemSettingsProvider`**:
    - Nutzt `Arc<dyn novade_core::config::ConfigServiceAsync>`.
    - `load_global_settings`: Liest TOML-Datei, deserialisiert zu `GlobalDesktopSettings`. Bei Deserialisierungsfehlern (z.B. unbekannte Felder, wenn `deny_unknown_fields` aktiv ist, oder Typfehler), wird ein `GlobalSettingsError::DeserializationError` zurückgegeben. Wenn die Datei nicht existiert, wird `Ok(GlobalDesktopSettings::default())` zurückgegeben.
    - `save_global_settings`: Serialisiert `GlobalDesktopSettings` zu TOML, schreibt in Datei.

**4.5. `domain::global_settings::service` (`src/global_settings/service.rs`)**

- **`DefaultGlobalSettingsService`**:
    - Hält `settings: Arc<tokio::sync::RwLock<GlobalDesktopSettings>>` für threadsicheren Lese-/Schreibzugriff.
    - **`update_setting(path: SettingPath, value: serde_json::Value)`**:
        1. Holt eine Schreibsperre für `self.settings`.
        2. Erstellt einen Klon der aktuellen `settings` für die Modifikation (`let mut new_settings = (*settings_guard).clone();`).
        3. **Pfad-Navigation und Aktualisierung (komplex):**
            - Eine große `match path { ... }`-Anweisung, die für jede `SettingPath`-Variante:
                - Das entsprechende Feld in `new_settings` referenziert.
                - `serde_json::from_value::<TargetType>(value)` versucht. Bei Fehler -> `InvalidValueType`.
                - Den deserialisierten Wert in `new_settings` setzt.
        4. `new_settings.validate_recursive() -> Result<(), GlobalSettingsError::ValidationError>` aufrufen (eine Methode, die alle `validate()`-Methoden der Unterstrukturen aufruft). Bei Fehler, Änderung nicht anwenden, Fehler zurückgeben.
        5. Wenn Validierung erfolgreich: Ersetze `*settings_guard = new_settings;`.
        6. `self.event_sender.send(SettingChangedEvent { path, new_value: value /* oder serialisierter neuer Wert */})`.
        7. `self.save_settings_internal(settings_guard).await` (interne Methode, die die Sperre nutzt).
    - **`get_setting(path: &SettingPath) -> Result<serde_json::Value, GlobalSettingsError>`**:
        1. Holt eine Lesesperre.
        2. Navigiert zum Wert via `match path`.
        3. Serialisiert den Wert zu `serde_json::Value`.
- **Events:** `SettingChangedEvent`, `SettingsLoadedEvent`, `SettingsSavedEvent` (via `tokio::sync::broadcast`).

**4.6. Detaillierte Implementierungsschritte `domain::global_settings`**

1. **Grundgerüst**: Verzeichnisse, `Cargo.toml`.
2. **`types.rs`**: Alle Einstellungs-`struct`s und `enum`s mit `serde`, `Default`, `validate()`-Methoden.
3. **`paths.rs`**: `SettingPath` Enum vollständig definieren, `Display` und `TryFrom<&str>` implementieren.
4. **`errors.rs`**: `GlobalSettingsError` definieren.
5. **`persistence_iface.rs`**: `SettingsPersistenceProvider`-Trait. `FilesystemSettingsProvider` implementieren (mit Mocking von `ConfigServiceAsync` für Tests).
6. **`service.rs`**: `GlobalSettingsService`-Trait. `DefaultGlobalSettingsService` implementieren:
    - Konstruktor, `RwLock` für `settings`.
    - `load_settings`, `save_settings` (interagieren mit Provider).
    - `update_setting` mit detaillierter Pfad-Navigation, Deserialisierung, Validierung.
    - `get_setting`, `reset_to_defaults`.
    - Event-Versand (`tokio::sync::broadcast`).
7. **Unit-Tests**: Für jede Einstellungsstruktur (Validierung, Serde, Default). Für `SettingPath` (Konvertierungen). Für `FilesystemSettingsProvider` (Mocking). Für `DefaultGlobalSettingsService` (alle API-Methoden, Fehlerfälle, Event-Auslösung, korrekte Aktualisierung verschachtelter Einstellungen).
8. **`mod.rs`**: Module deklarieren, öffentliche API re-exportieren.

---

Dieser detaillierte Plan für die Module `domain::theming` und `domain::global_settings_and_state_management` sollte es Entwicklern ermöglichen, diese Komponenten präzise zu implementieren. Die verbleibenden Module (Workspaces, Window Management Policy, User-Centric Services, Notifications Rules) würden nach demselben Schema und mit derselben Detailtiefe ausgearbeitet.


---

### Modul 5: `domain::workspaces`

Zweck: Umfassende Verwaltungslogik für Arbeitsbereiche ("Spaces"), einschließlich ihrer Definition, Fensterzuweisung, Orchestrierung und Persistenz.

Verantwortlichkeiten: Definition der Workspace-Entität, Regeln für Fensterzuweisung, Verwaltung der Workspace-Sammlung (inkl. aktivem Workspace), Laden und Speichern der Workspace-Konfiguration, Publizieren von Workspace-bezogenen Events.

Design-Rationale: Kapselung aller Workspace-bezogenen Logik an einem Ort, um Konsistenz und Wartbarkeit zu gewährleisten. Strikte Trennung von UI- und Systemdetails.

Bestehende Spezifikation: und vorherige Antworten.

#### 5.1. Untermodul: `domain::workspaces::core`

**Zweck:** Fundamentale Definition der `Workspace`-Entität und zugehöriger Typen.

**Datei:** `src/workspaces/core/types.rs`

- **Typalias `WorkspaceId`**
    - **Definition:** `pub type WorkspaceId = uuid::Uuid;`
    - **Ableitungen:** (Keine direkt, `uuid::Uuid` hat eigene)
- **Struct `WindowIdentifier`**
    - **Definition:**
        
        Rust
        
        ```
        use serde::{Serialize, Deserialize};
        use std::fmt;
        use super::errors::WorkspaceCoreError; // Für Validierungsfehler
        
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
        pub struct WindowIdentifier(String);
        
        impl WindowIdentifier {
            pub fn new(id: impl Into<String>) -> Result<Self, WorkspaceCoreError> {
                let id_str = id.into();
                if id_str.is_empty() {
                    return Err(WorkspaceCoreError::WindowIdentifierEmpty);
                }
                // Ggf. weitere Validierungen (z.B. erlaubte Zeichen)
                Ok(Self(id_str))
            }
            pub fn as_str(&self) -> &str { &self.0 }
        }
        impl fmt::Display for WindowIdentifier { /* ... */ }
        impl From<&str> for WindowIdentifier { fn from(s: &str) -> Self { Self::new(s).expect("Ungültiger WindowIdentifier aus &str") } }
        // From<String> ist riskanter ohne Fehlerbehandlung, new() bevorzugen
        ```
        
    - **Invarianten:** String nicht leer.
- **Enum `WorkspaceLayoutType`**
    - **Definition:** Wie in und vorheriger Antwort.
        
        Rust
        
        ```
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
        pub enum WorkspaceLayoutType {
            #[default]
            Floating,
            TilingHorizontal, // Fenster nebeneinander
            TilingVertical,   // Fenster untereinander
            // Zukünftig ggf. komplexere Tiling-Modi direkt hier definieren oder durch
            // domain::window_management_policy referenzieren. Fürs Erste sind diese fix.
            Maximized,        // Ein Fenster ist maximiert, andere ggf. verborgen/minimiert
        }
        ```
        

**Datei:** `src/workspaces/core/mod.rs` (enthält `Workspace`-Struct-Definition)

- **Struct `Workspace`**
    - **Definition:**
        
        Rust
        
        ```
        use std::collections::HashSet;
        use uuid::Uuid;
        use chrono::{DateTime, Utc};
        use serde::{Serialize, Deserialize};
        use super::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType};
        use super::errors::WorkspaceCoreError;
        use super::errors::MAX_WORKSPACE_NAME_LENGTH;
        
        #[derive(Debug, Clone, Serialize, Deserialize)]
        // PartialEq manuell implementieren wegen HashSet, falls nötig, oder nur auf IDs vergleichen.
        // Für die meisten Anwendungsfälle ist der Vergleich über `id` ausreichend.
        pub struct Workspace {
            id: WorkspaceId,
            name: String,
            persistent_id: Option<String>,
            layout_type: WorkspaceLayoutType,
            window_ids: HashSet<WindowIdentifier>,
            created_at: DateTime<Utc>,
            // Neu: Optionale Metadaten für den Workspace, z.B. benutzerdefiniertes Icon/Farbe
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub icon_name: Option<String>, // Name eines Icons aus dem System-Theme
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub accent_color_hex: Option<String>, // z.B. "#RRGGBB"
        }
        
        impl Workspace {
            pub fn new(name: String, persistent_id: Option<String>, icon_name: Option<String>, accent_color_hex: Option<String>) -> Result<Self, WorkspaceCoreError> {
                if name.is_empty() {
                    return Err(WorkspaceCoreError::NameCannotBeEmpty);
                }
                if name.len() > MAX_WORKSPACE_NAME_LENGTH {
                    return Err(WorkspaceCoreError::NameTooLong {
                        name: name.clone(),
                        max_len: MAX_WORKSPACE_NAME_LENGTH,
                        actual_len: name.len(),
                    });
                }
                if let Some(pid) = &persistent_id {
                    if pid.is_empty() || pid.chars().any(|c| !c.is_ascii_alphanumeric() && c != '-' && c != '_') {
                        return Err(WorkspaceCoreError::InvalidPersistentId(pid.clone()));
                    }
                }
                if let Some(hex) = &accent_color_hex {
                    // Basis-Validierung für Hex-Farbe
                    if !(hex.starts_with('#') && (hex.len() == 7 || hex.len() == 9) && hex[1..].chars().all(|c| c.is_ascii_hexdigit())) {
                        return Err(WorkspaceCoreError::InvalidAccentColorFormat(hex.clone()));
                    }
                }
        
                Ok(Self {
                    id: Uuid::new_v4(),
                    name,
                    persistent_id,
                    layout_type: WorkspaceLayoutType::default(),
                    window_ids: HashSet::new(),
                    created_at: Utc::now(),
                    icon_name,
                    accent_color_hex,
                })
            }
        
            pub fn id(&self) -> WorkspaceId { self.id }
            pub fn name(&self) -> &str { &self.name }
            pub fn persistent_id(&self) -> Option<&str> { self.persistent_id.as_deref() }
            pub fn layout_type(&self) -> WorkspaceLayoutType { self.layout_type }
            pub fn window_ids(&self) -> &HashSet<WindowIdentifier> { &self.window_ids }
            pub fn created_at(&self) -> DateTime<Utc> { self.created_at }
            pub fn icon_name(&self) -> Option<&str> { self.icon_name.as_deref() }
            pub fn accent_color_hex(&self) -> Option<&str> { self.accent_color_hex.as_deref() }
        
            pub fn rename(&mut self, new_name: String) -> Result<(), WorkspaceCoreError> {
                if new_name.is_empty() { /* ... NameCannotBeEmpty ... */ }
                if new_name.len() > MAX_WORKSPACE_NAME_LENGTH { /* ... NameTooLong ... */ }
                self.name = new_name;
                Ok(())
            }
        
            pub fn set_layout_type(&mut self, layout_type: WorkspaceLayoutType) {
                self.layout_type = layout_type;
            }
        
            pub(crate) fn add_window_id(&mut self, window_id: WindowIdentifier) -> bool {
                self.window_ids.insert(window_id)
            }
        
            pub(crate) fn remove_window_id(&mut self, window_id: &WindowIdentifier) -> bool {
                self.window_ids.remove(window_id)
            }
        
            pub fn set_persistent_id(&mut self, pid: Option<String>) -> Result<(), WorkspaceCoreError> {
                if let Some(p) = &pid {
                    if p.is_empty() || p.chars().any(|c| !c.is_ascii_alphanumeric() && c != '-' && c != '_') {
                        return Err(WorkspaceCoreError::InvalidPersistentId(p.clone()));
                    }
                }
                self.persistent_id = pid;
                Ok(())
            }
        
            pub fn set_icon_name(&mut self, icon: Option<String>) {
                self.icon_name = icon;
            }
        
            pub fn set_accent_color_hex(&mut self, color_hex: Option<String>) -> Result<(), WorkspaceCoreError> {
                 if let Some(hex) = &color_hex {
                    if !(hex.starts_with('#') && (hex.len() == 7 || hex.len() == 9) && hex[1..].chars().all(|c| c.is_ascii_hexdigit())) {
                        return Err(WorkspaceCoreError::InvalidAccentColorFormat(hex.clone()));
                    }
                }
                self.accent_color_hex = color_hex;
                Ok(())
            }
        }
        ```
        
    - **Felder:** Wie in vorheriger Antwort, plus `icon_name: Option<String>`, `accent_color_hex: Option<String>`.
    - **Methoden:** Wie in vorheriger Antwort, plus `set_icon_name`, `set_accent_color_hex`. Die `new`-Methode wird angepasst, um die neuen Felder zu akzeptieren und zu validieren.

**Datei:** `src/workspaces/core/event_data.rs`

- **Event-Payload-Strukturen**: Wie in. Zusätzlich:
    - `pub struct WorkspaceIconChangedData { pub id: WorkspaceId, pub old_icon_name: Option<String>, pub new_icon_name: Option<String> }`
    - `pub struct WorkspaceAccentChangedData { pub id: WorkspaceId, pub old_color_hex: Option<String>, pub new_color_hex: Option<String> }`
    - Alle mit `#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]`.

**Datei:** `src/workspaces/core/errors.rs`

- **Konstante `MAX_WORKSPACE_NAME_LENGTH`**: `pub const MAX_WORKSPACE_NAME_LENGTH: usize = 64;`
- **Enum `WorkspaceCoreError`**: Wie in. Zusätzlich:
    - `WindowIdentifierEmpty`
    - `InvalidAccentColorFormat(String)`

#### 5.2. Untermodul: `domain::workspaces::assignment`

**Zweck:** Geschäftslogik für die Zuweisung von Fenstern zu Workspaces.

**Datei:** `src/workspaces/assignment/errors.rs`

- **Enum `WindowAssignmentError`**: Wie in. Keine Änderungen zur vorherigen Spezifikation notwendig, da es bereits umfassend war.

**Datei:** `src/workspaces/assignment/mod.rs`

- **API-Funktionen**: Wie in. Die Implementierung der Funktionen muss detailliert werden:
    - **`assign_window_to_workspace(...)` Logik:**
        1. Prüfe `target_workspace_id` in `workspaces`. Wenn nicht gefunden: `Err(WorkspaceNotFound)`.
        2. Wenn `ensure_unique_assignment` `true` ist:
            - Iteriere über alle `(ws_id, ws)` in `workspaces`.
            - Wenn `ws_id != target_workspace_id` UND `ws.window_ids().contains(window_id)`:
                - `ws.remove_window_id(window_id);` (Diese Methode ist `pub(crate)` in `Workspace`).
        3. Hole `target_ws = workspaces.get_mut(&target_workspace_id).unwrap()`.
        4. Wenn `target_ws.add_window_id(window_id.clone())` `false` zurückgibt (Fenster war bereits da):
            - `Ok(())` (Kein Fehler, wenn es bereits auf dem Ziel-Workspace ist, auch wenn `ensure_unique_assignment` `false` war. Die Semantik ist "stelle sicher, dass es auf dem Ziel ist").
        5. Sonst (wurde neu hinzugefügt): `Ok(())`.
    - **`remove_window_from_workspace(...)` Logik:**
        1. Prüfe `source_workspace_id`. Wenn nicht gefunden: `Err(WorkspaceNotFound)`.
        2. Hole `source_ws = workspaces.get_mut(&source_workspace_id).unwrap()`.
        3. `Ok(source_ws.remove_window_id(window_id))`
    - **`move_window_to_workspace(...)` Logik:**
        1. Wenn `source_workspace_id == target_workspace_id`: `Err(CannotMoveToSameWorkspace)`.
        2. Prüfe `source_workspace_id`. Wenn nicht: `Err(SourceWorkspaceNotFound)`.
        3. Prüfe `target_workspace_id`. Wenn nicht: `Err(TargetWorkspaceNotFound)`.
        4. `source_ws = workspaces.get_mut(&source_workspace_id).unwrap()`.
        5. Wenn `!source_ws.remove_window_id(window_id)`: `Err(WindowNotOnSourceWorkspace)`.
        6. `target_ws = workspaces.get_mut(&target_workspace_id).unwrap()`.
        7. `target_ws.add_window_id(window_id.clone());` (Rückgabewert hier ignorieren, da wir wissen, dass es von der Quelle entfernt wurde).
        8. `Ok(())`.
    - **`find_workspace_for_window(...)` Logik:**
        1. Iteriere `workspaces.values()`.
        2. Wenn `ws.window_ids().contains(window_id)`, gib `Some(ws.id())` zurück.
        3. Sonst `None`.

#### 5.3. Untermodul: `domain::workspaces::config`

**Zweck:** Persistenzlogik für Workspace-Konfigurationen.

**Datei:** `src/workspaces/config/errors.rs`

- **Enum `WorkspaceConfigError`**: Wie in vorheriger Antwort (basierend auf).

**Datei:** `src/workspaces/config/mod.rs` (oder `provider.rs` und `types.rs` hier)

- **Struct `WorkspaceSnapshot`**: Wie in vorheriger Antwort. Zusätzlich `icon_name: Option<String>`, `accent_color_hex: Option<String>`.
    
    Rust
    
    ```
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct WorkspaceSnapshot {
        pub persistent_id: String, // Eindeutig über Sitzungen
        pub name: String,
        pub layout_type: WorkspaceLayoutType,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub icon_name: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub accent_color_hex: Option<String>,
    }
    ```
    
- **Struct `WorkspaceSetSnapshot`**: Wie in vorheriger Antwort (`workspaces: Vec<WorkspaceSnapshot>`, `active_workspace_persistent_id: Option<String>`).
- **Trait `WorkspaceConfigProvider`**: Wie in vorheriger Antwort (`async fn load_workspace_config`, `async fn save_workspace_config`).
- **Struct `FilesystemConfigProvider`**:
    - **Felder:** `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>`, `config_key_or_path: String` (z.B. "workspaces.toml").
    - **Konstruktor:** `pub fn new(config_service: Arc<dyn novade_core::config::ConfigServiceAsync>, config_key_or_path: String) -> Self`.
    - **Implementierung von `WorkspaceConfigProvider`**:
        - **`load_workspace_config`**:
            1. `content_result = self.config_service.read_config_file_string(&self.config_key_or_path).await;`
            2. `match content_result { Ok(content_str) => { ... } Err(core_err) => { ... } }`
            3. Wenn `core_err` "nicht gefunden" signalisiert (z.B. `CoreError::Io` mit `ErrorKind::NotFound` oder spezifischer `ConfigError`-Typ): `Ok(WorkspaceSetSnapshot::default())` zurückgeben (Manager erstellt dann Standard).
            4. Wenn anderer `core_err`: `Err(WorkspaceConfigError::LoadError { ..., source: core_err })`.
            5. Wenn `Ok(content_str)`: `toml::from_str(&content_str).map_err(|e| DeserializationError { ... source: Some(e) })`.
            6. Nach Deserialisierung: Validierung (doppelte `persistent_id`s in `snapshot.workspaces`, Existenz von `active_workspace_persistent_id` im Set). Bei Fehlern `InvalidData` oder `PersistentIdNotFoundInLoadedSet`.
        - **`save_workspace_config`**:
            1. `serialized_content = toml::to_string_pretty(config_snapshot).map_err(|e| SerializationError { ... source: Some(e) })?;`
            2. `self.config_service.write_config_file_string(&self.config_key_or_path, serialized_content).await.map_err(|e| SaveError { ..., source: e })?;`

#### 5.4. Untermodul: `domain::workspaces::manager`

**Zweck:** Zentraler Orchestrator für Workspace-Operationen.

**Datei:** `src/workspaces/manager/events.rs`

- **Enum `WorkspaceEvent`**: Wie in vorheriger Antwort. Zusätzlich:
    - `WorkspaceIconChanged(WorkspaceIconChangedData)`
    - `WorkspaceAccentChanged(WorkspaceAccentChangedData)`

**Datei:** `src/workspaces/manager/errors.rs`

- **Enum `WorkspaceManagerError`**: Wie in vorheriger Antwort. Keine wesentlichen Änderungen.

**Datei:** `src/workspaces/manager/mod.rs` (oder `service.rs`)

- **Trait `WorkspaceManagerService`**: (Neuer Trait für die öffentliche API, um die Implementierung zu entkoppeln).
    
    Rust
    
    ```
    use async_trait::async_trait;
    // ... imports ...
    #[async_trait]
    pub trait WorkspaceManagerService: Send + Sync {
        async fn create_workspace(&self, name: Option<String>, persistent_id: Option<String>, icon_name: Option<String>, accent_color_hex: Option<String>) -> Result<WorkspaceId, WorkspaceManagerError>;
        async fn delete_workspace(&self, id: WorkspaceId, fallback_id_for_windows: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError>;
        fn get_workspace(&self, id: WorkspaceId) -> Option<Workspace>; // Gibt Klon zurück
        fn all_workspaces_ordered(&self) -> Vec<Workspace>; // Gibt Klone zurück
        fn active_workspace_id(&self) -> Option<WorkspaceId>;
        async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>;
        async fn assign_window_to_active_workspace(&self, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;
        async fn assign_window_to_specific_workspace(&self, workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;
        async fn remove_window_from_its_workspace(&self, window_id: &WindowIdentifier) -> Result<Option<WorkspaceId>, WorkspaceManagerError>;
        async fn move_window_to_specific_workspace(&self, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;
        async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>;
        async fn set_workspace_layout(&self, id: WorkspaceId, layout_type: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>;
        async fn set_workspace_icon(&self, id: WorkspaceId, icon_name: Option<String>) -> Result<(), WorkspaceManagerError>;
        async fn set_workspace_accent_color(&self, id: WorkspaceId, color_hex: Option<String>) -> Result<(), WorkspaceManagerError>;
        async fn save_configuration(&self) -> Result<(), WorkspaceManagerError>;
        fn subscribe_to_workspace_events(&self) -> tokio::sync::broadcast::Receiver<WorkspaceEvent>;
        // Neu: Methode zur Änderung der Reihenfolge
        async fn reorder_workspace(&self, workspace_id: WorkspaceId, new_index: usize) -> Result<(), WorkspaceManagerError>;
    }
    ```
    
- **Struct `WorkspaceManager`** (umbenannt zu `DefaultWorkspaceManager` für die Implementierung).
    - **Felder:** `internal: Arc<tokio::sync::Mutex<WorkspaceManagerInternalState>>`.
- **Struct `WorkspaceManagerInternalState`**:
    - `workspaces: HashMap<WorkspaceId, Workspace>`
    - `active_workspace_id: Option<WorkspaceId>`
    - `ordered_workspace_ids: Vec<WorkspaceId>`
    - `next_workspace_number: u32`
    - `config_provider: Arc<dyn WorkspaceConfigProvider>`
    - `event_publisher: tokio::sync::broadcast::Sender<WorkspaceEvent>`
    - `ensure_unique_window_assignment: bool`
- **Implementierung `#[async_trait] impl WorkspaceManagerService for DefaultWorkspaceManager`**:
    - **`new(...)`**:
        1. Sperrt `internal`, initialisiert Felder.
        2. `snapshot = self.internal.config_provider.load_workspace_config().await.map_err(WorkspaceManagerError::from)?;`
        3. Wenn `snapshot.workspaces` leer ist (oder `load_config` "nicht gefunden" signalisiert und Default zurückgibt):
            - Ruft `internal_create_workspace_locked` auf, um einen Standard-Workspace ("Workspace 1") zu erstellen.
            - Setzt diesen als aktiv.
        4. Sonst: Rekonstruiert `workspaces` und `ordered_workspace_ids` aus `snapshot`. Setzt `active_workspace_id` basierend auf `snapshot.active_workspace_persistent_id`.
        5. Aktualisiert `next_workspace_number`.
        6. Sendet `WorkspacesReloaded` und `ActiveWorkspaceChanged` Events.
    - **`create_workspace(...)`**:
        1. Sperrt `internal`.
        2. Prüft auf `DuplicatePersistentId`.
        3. Ruft `Workspace::new(...)`.
        4. Fügt zu `workspaces` und `ordered_workspace_ids` hinzu.
        5. Sendet `WorkspaceCreated`.
        6. Ruft `internal_save_configuration_locked()`.
    - **`delete_workspace(...)`**: Sperrt, prüft Bedingungen, verschiebt Fenster via `assignment`-Modul, sendet Events, speichert.
    - `get_workspace()` / `all_workspaces_ordered()`: Sperrt, klont die angeforderten `Workspace`-Objekte und gibt sie zurück.
    - **`set_active_workspace(...)`**: Sperrt, prüft, aktualisiert, sendet Event, speichert (optional).
    - **Fensterzuweisungsmethoden**: Sperren `internal`, rufen Funktionen aus `domain::workspaces::assignment` mit `&mut internal.workspaces` auf, senden Events.
    - **`rename_workspace(...)`, `set_workspace_layout(...)`, `set_workspace_icon(...)`, `set_workspace_accent_color(...)`**:
        1. Sperrt `internal`.
        2. Findet `workspace_mut` in `internal.workspaces`. Wenn nicht: `Err(WorkspaceNotFound)`.
        3. Ruft entsprechende `workspace_mut.set_...(...)` Methode auf.
        4. Sendet entsprechendes Event (`WorkspaceRenamed`, `WorkspaceLayoutChanged`, `WorkspaceIconChanged`, `WorkspaceAccentChanged`).
        5. Ruft `internal_save_configuration_locked()`.
    - **`reorder_workspace(...)`**:
        1. Sperrt `internal`.
        2. Validiert `workspace_id` und `new_index`.
        3. Entfernt `workspace_id` aus `ordered_workspace_ids` und fügt es an `new_index` wieder ein.
        4. Sendet `WorkspaceOrderChanged` mit der neuen `ordered_workspace_ids` (als Klon).
        5. Ruft `internal_save_configuration_locked()`.
    - **`save_configuration()`**: Sperrt `internal`, ruft `internal_save_configuration_locked()`.
    - **`internal_save_configuration_locked()`**: Private Hilfsmethode, die den Snapshot erstellt und `config_provider.save_workspace_config()` aufruft.
    - **`subscribe_to_workspace_events()`**: `self.internal.lock().await.event_publisher.subscribe()`.

#### 5.5. Implementierungsschritte `domain::workspaces`

(Reihenfolge und Tests wie in vorheriger Antwort, aber mit Fokus auf `async` wo spezifiziert und `tokio::sync::Mutex`.)

1. **`core` Modul**: `Workspace` um neue Felder und Methoden erweitern. Neue Event-Payloads. `WorkspaceCoreError` erweitern. Tests.
2. **`assignment` Modul**: Implementierungslogik der Funktionen detaillieren und testen.
3. **`config` Modul**: `WorkspaceSnapshot` anpassen. `FilesystemConfigProvider` mit `async` Methoden und `ConfigServiceAsync`. Tests (Mocking).
4. **`manager` Modul**: `WorkspaceEvent` erweitern. `WorkspaceManagerService` Trait definieren. `DefaultWorkspaceManager` mit `tokio::sync::Mutex` und `async` Methoden implementieren. `reorder_workspace` Methode hinzufügen. Umfassende Tests.
5. **`src/workspaces/mod.rs`**: Module deklarieren, öffentliche API (Service-Trait, wichtige Typen, Fehler, Events) re-exportieren.

---

### Modul 6: `domain::window_management_policy`

Zweck: Definition von High-Level-Regeln und Richtlinien für Fensterplatzierung, Tiling, Snapping, Gruppierung, Fokus und Gap-Management. Definiert die "Policy", die Systemschicht die "Mechanik".

Verantwortlichkeiten: Bereitstellung von Algorithmen zur Berechnung von Fenstergeometrien basierend auf aktuellen Policies und Workspace-Zuständen.

Design-Rationale: Entkopplung der komplexen Layout- und Policy-Logik von der technischen Umsetzung im Compositor. Ermöglicht flexible und austauschbare Fensterverwaltungsstrategien.

#### 6.1. Untermodul: `domain::window_management_policy::types`

**Datei:** `src/window_management_policy/types.rs`

- **Enum `TilingMode`**: Wie in vorheriger Antwort (Manual, Columns, Rows, Spiral, MaximizedFocused).
- **Struct `GapSettings`**: Wie in vorheriger Antwort.
- **Struct `WindowSnappingPolicy`**: Wie in vorheriger Antwort.
- **Struct `WindowGroupingPolicy`**: Wie in vorheriger Antwort.
- **Enum `NewWindowPlacementStrategy`**: Wie in vorheriger Antwort.
- **Enum `FocusStealingPreventionLevel`**: Wie in vorheriger Antwort.
- **Struct `FocusPolicy`**: Wie in vorheriger Antwort.
- **Struct `WindowPolicyOverrides`**: Wie in vorheriger Antwort.
- **Struct `WorkspaceWindowLayout`**: Wie in vorheriger Antwort.
    - **Zusatzfeld**: `pub tiling_mode_applied: TilingMode` (Speichert, welcher Modus tatsächlich für dieses Layout verwendet wurde).
- **Struct `WindowLayoutInfo`** (neu, für die Übergabe an `calculate_workspace_layout`):
    
    Rust
    
    ```
    use crate::domain::workspaces::core::types::WindowIdentifier;
    use crate::core::types::Size; // u32 Annahme
    
    #[derive(Debug, Clone, PartialEq)]
    pub struct WindowLayoutInfo {
        pub id: WindowIdentifier,
        pub requested_min_size: Option<Size<u32>>, // Vom Client oder Policy
        pub requested_base_size: Option<Size<u32>>,// Für Größeninkremente (zukünftig)
        pub is_fullscreen_requested: bool,
        pub is_maximized_requested: bool, // Expliziter Maximierungswunsch vom Client/User
        // Weitere Flags, die das Layout beeinflussen könnten
    }
    ```
    

#### 6.2. Untermodul: `domain::window_management_policy::errors`

**Datei:** `src/window_management_policy/errors.rs`

- **Enum `WindowPolicyError`**: Wie in vorheriger Antwort.

#### 6.3. Untermodul: `domain::window_management_policy::service`

**Datei:** `src/window_management_policy/service.rs` (oder `mod.rs`)

- **Trait `WindowManagementPolicyService`**:
    
    - **`calculate_workspace_layout` Signatur angepasst:**
        
        Rust
        
        ```
        async fn calculate_workspace_layout(
            &self,
            workspace_id: WorkspaceId,
            windows_to_layout: &[WindowLayoutInfo], // Geänderter Typ
            available_area: RectInt,
            // Policy-Einstellungen werden jetzt intern vom Service über GlobalSettingsService bezogen
            // oder es gibt spezifische Methoden, um sie zu setzen/abzurufen.
            // Hier gehen wir davon aus, dass sie intern über GlobalSettingsService bezogen werden.
            workspace_current_tiling_mode: TilingMode, // Tiling-Modus, der für diesen Workspace gilt
            focused_window_id: Option<&WindowIdentifier>, // Optional, für MaximizedFocused
            window_specific_overrides: &HashMap<WindowIdentifier, WindowPolicyOverrides>
        ) -> Result<WorkspaceWindowLayout, WindowPolicyError>;
        ```
        
    - **`get_initial_window_geometry` Signatur angepasst:**
        
        Rust
        
        ```
        async fn get_initial_window_geometry(
            &self,
            window_info: &WindowLayoutInfo, // Enthält requested_size etc.
            is_transient_for: Option<&WindowIdentifier>,
            parent_geometry: Option<RectInt>, // Geometrie des Elternfensters für transiente Fenster
            workspace_id: WorkspaceId,
            active_layout_on_workspace: &WorkspaceWindowLayout,
            available_area: RectInt,
            // placement_strategy wird intern vom Service via GlobalSettingsService bezogen
            window_specific_overrides: &Option<WindowPolicyOverrides>
        ) -> Result<RectInt, WindowPolicyError>;
        ```
        
    - **`calculate_snap_target`**: Signatur bleibt ähnlich.
    - **Neue Methoden zum Abruf von Teil-Policies (statt Übergabe von `GlobalDesktopSettings`):**
        
        Rust
        
        ```
        async fn get_effective_tiling_mode_for_workspace(&self, workspace_id: WorkspaceId) -> Result<TilingMode, WindowPolicyError>;
        async fn get_effective_gap_settings_for_workspace(&self, workspace_id: WorkspaceId) -> Result<GapSettings, WindowPolicyError>;
        async fn get_effective_snapping_policy(&self) -> Result<WindowSnappingPolicy, WindowPolicyError>;
        async fn get_effective_focus_policy(&self) -> Result<FocusPolicy, WindowPolicyError>;
        async fn get_effective_new_window_placement_strategy(&self) -> Result<NewWindowPlacementStrategy, WindowPolicyError>;
        // Diese Methoden würden intern den GlobalSettingsService konsultieren und
        // ggf. Workspace-spezifische Overrides berücksichtigen (falls diese in Zukunft eingeführt werden).
        ```
        
- **Implementierung `DefaultWindowManagementPolicyService`**:
    
    - **Konstruktor:** `pub fn new(settings_service: Arc<dyn GlobalSettingsService>) -> Self`.
    - **`calculate_workspace_layout` Logik (verfeinert):**
        1. Holt `GapSettings` über `self.get_effective_gap_settings_for_workspace()`.
        2. `effective_area = available_area` abzüglich äußerer `screen_outer_horizontal/vertical` Gaps.
        3. **Floating-Fenster herausfiltern:** Identifiziere Fenster mit `is_always_floating == Some(true)` aus `window_specific_overrides` oder solche, die aufgrund von Client-Hints (z.B. feste Größe, Dialoge - Information nicht direkt hier verfügbar, muss von Systemschicht kommen und in `WindowLayoutInfo` oder `WindowPolicyOverrides` reflektiert werden) als floating behandelt werden sollen. Für diese wird keine Tiling-Geometrie berechnet; ihre Positionen/Größen bleiben (oder werden initial gesetzt).
        4. `tiled_windows: Vec<&WindowLayoutInfo>` = verbleibende Fenster.
        5. Wenn `tiled_windows` leer ist oder `workspace_current_tiling_mode == TilingMode::Manual`:
            - Für jedes `window_info` in `windows_to_layout` (auch die "floating" markierten):
                - Wenn es ein Override für `fixed_position`/`fixed_size` gibt, dieses verwenden.
                - Sonst: Rufe `self.get_initial_window_geometry(...)` für dieses Fenster auf, um eine initiale Platzierung zu erhalten (oder behalte die aktuelle Position, falls es ein Re-Layout ist).
            - `WorkspaceWindowLayout` mit diesen Geometrien und `tiling_mode_applied = TilingMode::Manual` zurückgeben.
        6. **Tiling-Logik (Beispiel für `TilingMode::Columns`):**
            - `num_tiled_windows = tiled_windows.len()`.
            - `total_inner_gaps_width = gap_settings.window_inner * (num_tiled_windows - 1) as u16`.
            - `allocatable_width = effective_area.width - total_inner_gaps_width`.
            - `width_per_window = allocatable_width / num_tiled_windows as u32`. (Restbreite könnte verteilt oder ignoriert werden).
            - `current_x = effective_area.x`.
            - Für jedes `window_info` in `tiled_windows`:
                - `height = effective_area.height`.
                - `actual_width = width_per_window`. Ggf. Mindestbreite aus `window_info.requested_min_size` oder `WindowPolicyOverrides` berücksichtigen und `actual_width` anpassen (komplexere Verteilung nötig, wenn Mindestbreiten Summe überschreiten).
                - Speichere `RectInt::new(current_x, effective_area.y, actual_width, height)` für `window_info.id`.
                - `current_x += actual_width as i32 + gap_settings.window_inner as i32`.
            - `WorkspaceWindowLayout` mit diesen Geometrien und `tiling_mode_applied = TilingMode::Columns` zurückgeben.
        7. **`TilingMode::MaximizedFocused` Logik:**
            - Wenn `focused_window_id` und dieses Fenster in `tiled_windows` ist:
                - Geometrie für `focused_window_id` ist `effective_area`.
                - Andere `tiled_windows` erhalten eine (0,0)-Größe oder werden nicht in die `window_geometries` Map aufgenommen (signalisiert "versteckt").
            - Sonst (kein Fokus oder fokussiertes Fenster ist floating): Falle zurück auf `Manual` oder einen anderen Default-Tiling-Modus.
        8. Algorithmen für `Rows` (analog zu Columns), `Spiral` (Fibonacci-Partitionierung des `effective_area`) implementieren.
    - **Interne Hilfsfunktionen für Layout-Algorithmen.**

#### 6.4. Detaillierte Implementierungsschritte `domain::window_management_policy`

1. **Grundgerüst**: Verzeichnisse, `Cargo.toml`.
2. **`types.rs`**: Alle Policy-Typen (`TilingMode`, `GapSettings`, etc.), `WindowLayoutInfo`, `WorkspaceWindowLayout` definieren. `serde` und `Default`.
3. **`errors.rs`**: `WindowPolicyError` definieren.
4. **`service.rs`**:
    - `WindowManagementPolicyService`-Trait definieren mit den verfeinerten Signaturen.
    - `DefaultWindowManagementPolicyService`-Struktur mit `Arc<dyn GlobalSettingsService>`.
    - `new()`-Konstruktor implementieren.
    - `get_effective_*_policy()`-Methoden implementieren (lesen aus `GlobalSettingsService`).
    - `calculate_workspace_layout()`:
        - Implementiere Logik zum Herausfiltern von Floating-Fenstern.
        - Implementiere die spezifischen Layout-Algorithmen (Manual, Columns, Rows, Spiral, MaximizedFocused) als private Methoden, die `available_area`, `gap_settings` und die Liste der zu kachelnden Fenster berücksichtigen.
        - Stelle sicher, dass Mindest-/Maximalgrößen und Overrides aus `WindowPolicyOverrides` beachtet werden.
    - `get_initial_window_geometry()`: Implementiere verschiedene Strategien (`Smart`, `Center` etc.).
    - `calculate_snap_target()`: Implementiere Snapping-Logik.
5. **Unit-Tests**:
    - Für jeden Layout-Algorithmus: Verschiedene Anzahlen von Fenstern, verschiedene `available_area`, verschiedene Gap-Settings. Teste auch mit Mindestgrößen.
    - Für `get_initial_window_geometry`: Teste alle Platzierungsstrategien.
    - Für `calculate_snap_target`: Teste Snapping an Bildschirmränder und andere Fenster.
    - Für die Service-Methoden: Mocking des `GlobalSettingsService`. Teste, dass die korrekten Policies abgerufen und angewendet werden.

---

Die detaillierten Spezifikationen für die Module 7 (`user_centric_services`) und 8 (`notifications_rules`) werden in der nächsten Antwort folgen, basierend auf dieser Struktur und Methodik.
### Modul 7: `domain::user_centric_services`

Zweck: Bündelt die Logik für Dienste, die direkt auf die Bedürfnisse und Interaktionen des Benutzers ausgerichtet sind, insbesondere KI-Interaktionen (inklusive Einwilligungsmanagement) und ein umfassendes Benachrichtigungssystem.

Verantwortlichkeiten: Verwaltung von KI-Interaktionskontexten, Benutzereinwilligungen und KI-Modellprofilen. Entgegennahme, Verarbeitung, Speicherung und Verwaltung von System- und Anwendungsbenachrichtigungen.

Design-Rationale: Zentralisierung benutzerorientierter Dienste, um eine kohärente und kontrollierte Benutzererfahrung in Bezug auf Assistenzfunktionen und Benachrichtigungen zu ermöglichen. Trennung der Domänenlogik von der technischen Umsetzung (MCP-Kommunikation, D-Bus-Notification-Daemon-Interaktion) in der Systemschicht und der Darstellung in der UI-Schicht.

Bestehende Spezifikation: und vorherige Antworten.

#### 7.1. Untermodul: `domain::user_centric_services::ai_interaction`

**Zweck:** Verwaltung von KI-Interaktionen, Benutzereinwilligungen und KI-Modellprofilen.

**Datei:** `src/user_centric_services/ai_interaction/types.rs`

- **Enum `AIDataCategory`**
    
    - **Definition:** Wie in (UserProfile, ApplicationUsage, FileSystemRead, ClipboardAccess, LocationData, GenericText, GenericImage).
    - **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize`.
    - **Zusatz:**
        
        Rust
        
        ```
        // Optional: Methode zur menschenlesbaren Beschreibung
        impl AIDataCategory {
            pub fn description(&self) -> &'static str {
                match self {
                    AIDataCategory::UserProfile => "Persönliche Profilinformationen (z.B. Name, Einstellungen)",
                    AIDataCategory::ApplicationUsage => "Informationen über genutzte Anwendungen und deren Aktivität",
                    AIDataCategory::FileSystemRead => "Lesezugriff auf das Dateisystem",
                    AIDataCategory::ClipboardAccess => "Zugriff auf den Inhalt der Zwischenablage",
                    AIDataCategory::LocationData => "Standortinformationen",
                    AIDataCategory::GenericText => "Allgemeiner Textinhalt (z.B. vom Benutzer eingegeben)",
                    AIDataCategory::GenericImage => "Allgemeiner Bildinhalt",
                }
            }
        }
        ```
        
- **Enum `AIConsentStatus`**
    
    - **Definition:** Wie in (Granted, Denied, PendingUserAction, NotRequired).
    - **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize`.
- **Struct `AttachmentData`**
    
    - **Definition:** Wie in.
        
        Rust
        
        ```
        use uuid::Uuid;
        use serde::{Serialize, Deserialize};
        
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AttachmentData {
            pub id: Uuid,
            pub mime_type: String, // z.B. "text/plain", "image/png", "application/pdf"
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub source_uri: Option<String>, // z.B. "file:///path/to/file.txt"
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub content_base64: Option<String>, // Base64-kodierter Inhalt für Binärdaten
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub text_content: Option<String>, // Für reinen Textinhalt
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub description: Option<String>,
        }
        
        impl AttachmentData {
            pub fn new_text(text: String, description: Option<String>) -> Self { /* ... */ }
            pub fn new_from_uri(uri: String, mime_type: String, description: Option<String>) -> Self { /* ... */ }
            // new_from_binary_content(content: Vec<u8>, mime_type: String, description: Option<String>) -> Self
        }
        ```
        
    - **Verfeinerung:** `content: Option<Vec<u8>>` wird zu `content_base64: Option<String>` für leichtere Serialisierung (JSON) und `text_content: Option<String>`. `source_uri` bleibt für Verweise.
- **Struct `AIInteractionContext`**
    
    - **Definition:** Wie in.
        
        Rust
        
        ```
        use chrono::{DateTime, Utc};
        // ... andere Imports ...
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AIInteractionContext {
            pub id: Uuid,
            pub creation_timestamp: DateTime<Utc>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub active_model_id: Option<String>, // ID des KI-Modells
            pub consent_status: AIConsentStatus,
            pub associated_data_categories: Vec<AIDataCategory>,
            // interaction_history als separate Struktur für mehr Flexibilität
            pub history_entries: Vec<InteractionHistoryEntry>,
            pub attachments: Vec<AttachmentData>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub user_prompt_template: Option<String>, // Vorlage für den initialen Prompt
            #[serde(default)]
            pub is_active: bool, // Ob dieser Kontext gerade "offen" oder aktiv in der UI ist
        }
        ```
        
    - **Neue Struktur `InteractionHistoryEntry`**:
        
        Rust
        
        ```
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub enum InteractionParticipant { User, Assistant, System }
        
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct InteractionHistoryEntry {
            pub entry_id: Uuid,
            pub timestamp: DateTime<Utc>,
            pub participant: InteractionParticipant,
            pub content: String, // Text der Nachricht/Aktion
            #[serde(default, skip_serializing_if = "Vec::is_empty")]
            pub related_attachment_ids: Vec<Uuid>, // IDs von Attachments, die sich auf diesen Eintrag beziehen
        }
        ```
        
- **Struct `AIConsent`**
    
    - **Definition:** Wie in.
        
        Rust
        
        ```
        #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
        pub struct AIConsent {
            pub id: Uuid, // Eindeutige ID der Einwilligung selbst
            pub user_id: String, // Vereinfacht, könnte komplexer sein
            pub model_id: String, // Für welches spezifische Modell oder "*" für alle
            pub data_category: AIDataCategory, // Einwilligung pro Kategorie
            pub granted_timestamp: DateTime<Utc>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub expiry_timestamp: Option<DateTime<Utc>>,
            pub is_revoked: bool,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub last_used_timestamp: Option<DateTime<Utc>>, // Wann zuletzt genutzt
            pub consent_scope: AIConsentScope, // Neu
        }
        
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
        pub enum AIConsentScope { #[default] SessionOnly, PersistentUntilRevoked, SpecificDuration }
        ```
        
    - **Verfeinerung:** `data_categories: Vec<AIDataCategory>` wird zu `data_category: AIDataCategory`, um granularere Einwilligungen pro Kategorie zu ermöglichen (d.h. ein `AIConsent`-Objekt pro (user, model, category)-Tupel). `AIConsentScope` hinzugefügt.
- **Struct `AIModelProfile`**
    
    - **Definition:** Wie in.
        
        Rust
        
        ```
        #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
        pub struct AIModelProfile {
            pub model_id: String, // Eindeutig, z.B. "local-llama3-8b", "openai-gpt-4o"
            pub display_name: String,
            pub description: String,
            pub provider: String, // z.B. "Local", "OpenAI", "Groq"
            pub required_consent_categories: Vec<AIDataCategory>,
            pub capabilities: Vec<AIModelCapability>, // Enum statt String
            pub supports_streaming: bool, // Gibt das Modell Antworten im Stream zurück?
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub endpoint_url: Option<String>, // Für Remote-Modelle
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub api_key_secret_name: Option<String>, // Name des Secrets im Secret Service
            #[serde(default)]
            pub is_default_model: bool, // Kann nur ein Modell Default sein
            #[serde(default)]
            pub sort_order: i32, // Für die Anzeige in UI-Auswahlen
        }
        
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AIModelCapability { TextGeneration, CodeGeneration, Summarization, Translation, ImageAnalysis, FunctionCalling }
        ```
        
    - **Verfeinerung:** `capabilities` als Enum `AIModelCapability`. Zusätzliche Felder `supports_streaming`, `endpoint_url`, `api_key_secret_name`, `is_default_model`, `sort_order`.

**Datei:** `src/user_centric_services/ai_interaction/errors.rs`

- **Enum `AIInteractionError`**: Wie in. Zusätzlich/Verfeinert:
    - `ConsentCheckFailed { model_id: String, category: AIDataCategory, reason: String }`
    - `ApiKeyNotFoundInSecrets { secret_name: String }`
    - `ModelEndpointUnreachable { model_id: String, url: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }` (Dieser Fehler käme eher von der Systemschicht, wird hier aber als möglicher Domänenfehler bei der Modellvalidierung aufgeführt)
    - `NoDefaultModelConfigured`
    - `CoreConfigError(#[from] novade_core::config::ConfigError)` (Wenn Laden von Profilen/Consents fehlschlägt)

**Datei:** `src/user_centric_services/ai_interaction/persistence_iface.rs`

- **Trait `AIConsentProvider`**:
    
    Rust
    
    ```
    #[async_trait]
    pub trait AIConsentProvider: Send + Sync {
        async fn load_consents_for_user(&self, user_id: &str) -> Result<Vec<AIConsent>, AIInteractionError>;
        async fn save_consent(&self, consent: &AIConsent) -> Result<(), AIInteractionError>;
        async fn revoke_consent(&self, consent_id: Uuid, user_id: &str) -> Result<(), AIInteractionError>;
        // Ggf. Methode zum Löschen abgelaufener Consents
    }
    ```
    
- **Trait `AIModelProfileProvider`**:
    
    Rust
    
    ```
    #[async_trait]
    pub trait AIModelProfileProvider: Send + Sync {
        async fn load_model_profiles(&self) -> Result<Vec<AIModelProfile>, AIInteractionError>;
        // Ggf. async fn save_model_profiles(&self, profiles: &[AIModelProfile]) -> Result<(), AIInteractionError>;
    }
    ```
    
- **Implementierungen** (z.B. `FilesystemAIConsentProvider`, `FilesystemAIModelProfileProvider`) in einem `persistence.rs` Untermodul, die `Arc<dyn novade_core::config::ConfigServiceAsync>` nutzen, um Daten als TOML/JSON in spezifischen Dateien unter `$XDG_CONFIG_HOME/novade/ai/` zu speichern/laden.

**Datei:** `src/user_centric_services/ai_interaction/service.rs` (oder `mod.rs`)

- **Trait `AIInteractionLogicService`**:
    - **Signaturen:** Wie in.
    - **Zusätzliche Methoden/Verfeinerungen:**
        - `async fn get_consent_status_for_interaction(&self, context_id: Uuid, model_id: &str, required_categories: &[AIDataCategory]) -> Result<AIConsentStatus, AIInteractionError>;` (Prüft spezifisch für einen Kontext)
        - `async fn get_default_model(&self) -> Result<Option<AIModelProfile>, AIInteractionError>;`
        - `async fn update_interaction_history(&mut self, context_id: Uuid, entry: InteractionHistoryEntry) -> Result<(), AIInteractionError>;`
- **Implementierung `DefaultAIInteractionLogicService`**:
    - **Felder:**
        - `active_contexts: Arc<tokio::sync::Mutex<HashMap<Uuid, AIInteractionContext>>>`
        - `model_profiles: Arc<tokio::sync::RwLock<Vec<AIModelProfile>>>`
        - `user_consents: Arc<tokio::sync::Mutex<HashMap<String /* user_id */, Vec<AIConsent>>>>`
        - `consent_provider: Arc<dyn AIConsentProvider>`
        - `profile_provider: Arc<dyn AIModelProfileProvider>`
        - `event_publisher: tokio::sync::broadcast::Sender<super::events::AIInteractionEventEnum>` (Wrapper-Enum für Events)
    - **Konstruktor `new(...)`**: Nimmt Provider, lädt initial Profile und Consents für den aktuellen Benutzer.
    - **Logik `initiate_interaction`**: Erstellt `AIInteractionContext`, speichert in `active_contexts`, sendet `AIInteractionInitiatedEvent`.
    - **Logik `provide_consent`**:
        1. Findet oder erstellt `AIConsent`-Objekt(e) basierend auf `model_id`, `granted_categories`, `consent_decision`.
        2. Ruft `consent_provider.save_consent()` auf.
        3. Aktualisiert `user_consents` Cache.
        4. Aktualisiert `consent_status` im `AIInteractionContext` (falls `context_id` gegeben).
        5. Sendet `AIConsentUpdatedEvent`.
    - **Logik `get_consent_status_for_interaction`**:
        1. Lädt `active_model_id` aus `AIInteractionContext` (falls nicht direkt übergeben).
        2. Iteriert `required_categories`. Für jede Kategorie:
            - Sucht in `self.user_consents` nach einem gültigen (nicht abgelaufen, nicht widerrufen) `AIConsent` für den `user_id` (aus Kontext, hier vereinfacht), `model_id` und die `category`.
            - Wenn für eine Kategorie keine explizite Zustimmung (Granted) gefunden wird -> `AIConsentStatus::PendingUserAction` oder `Denied` (wenn zuvor explizit verweigert).
        3. Wenn für alle `Granted` -> `AIConsentStatus::Granted`.
        4. Wenn `model_profile.required_consent_categories` leer ist -> `AIConsentStatus::NotRequired`.
- **Events:** (Wrapper-Enum `AIInteractionEventEnum` für `tokio::sync::broadcast`)
    - `AIInteractionInitiatedEvent { context: AIInteractionContext }` (Payload enthält ganzen Kontext)
    - `AIConsentUpdatedEvent { user_id: String, model_id: String, category: AIDataCategory, new_status: AIConsentStatus, scope: AIConsentScope }`
    - `AIContextUpdatedEvent { context_id: Uuid, updated_field: String /* z.B. "history", "attachment" */}`
    - `AIModelProfilesReloadedEvent { profiles: Vec<AIModelProfile> }`

#### 7.2. Untermodul: `domain::user_centric_services::notifications_core`

**Zweck:** Kernlogik für das Verwalten von Benachrichtigungen.

**Datei:** `src/user_centric_services/notifications_core/types.rs`

- **Enum `NotificationUrgency`**: Wie in (Low, Normal, Critical).
- **Enum `NotificationActionType`**: Wie in (Callback, OpenLink).
- **Struct `NotificationAction`**: Wie in.
- **Struct `Notification`**: Wie in.
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct Notification {
        pub id: Uuid,
        pub application_name: String, // Optional: ApplicationId statt String
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub application_icon: Option<String>, // Icon-Name oder Pfad
        pub summary: String, // Darf nicht leer sein
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub body: Option<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub actions: Vec<NotificationAction>,
        pub urgency: NotificationUrgency,
        pub timestamp: DateTime<Utc>, // Zeitpunkt des Eintreffens in diesem Service
        #[serde(default)]
        pub is_read: bool,
        #[serde(default)]
        pub is_dismissed: bool, // Vom Benutzer aktiv geschlossen
        #[serde(default)]
        pub transient: bool, // Nicht in Historie speichern, wenn true
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub category: Option<String>, // Standardkategorien: "device", "email", "im", "transfer" etc.
        #[serde(default, skip_serializing_if = "HashMap::is_empty")]
        pub hints: HashMap<String, serde_json::Value>, // Für zusätzliche Daten (z.B. x-coordinates, image-data)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub timeout_ms: Option<u32>, // 0 für persistent, None für Standard-Timeout
    }
    impl Notification { /* ... new() ... mark_as_read(), dismiss() ... */ }
    ```
    
    - **Verfeinerung:** Zusätzliche Felder `category`, `hints`, `timeout_ms`.
- **Enum `NotificationFilterCriteria`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub enum NotificationFilterCriteria {
        Unread(bool), // true für nur ungelesene, false für nur gelesene
        Application(ApplicationId),
        Urgency(NotificationUrgency),
        Category(String),
        HasAction(String), // Action Key
        BodyContains(String),
        SummaryContains(String),
        IsTransient(bool),
        AndTimeRange { // Neu
            start: Option<DateTime<Utc>>,
            end: Option<DateTime<Utc>>,
        },
        And(Vec<NotificationFilterCriteria>), // Neu
        Or(Vec<NotificationFilterCriteria>),  // Neu
        Not(Box<NotificationFilterCriteria>), // Neu
    }
    ```
    
- **Enum `NotificationSortOrder`**: Wie in (TimestampAscending, TimestampDescending, Urgency). Zusätzlich: `ApplicationNameAscending`, `SummaryAscending`.

**Datei:** `src/user_centric_services/notifications_core/errors.rs`

- **Enum `NotificationError`**: Wie in. Zusätzlich:
    - `InvalidFilterCriteria(String)`
    - `ActionInvocationFailed { notification_id: Uuid, action_id: String, reason: String }`

**Datei:** `src/user_centric_services/notifications_core/service.rs` (oder `mod.rs`)

- **Trait `NotificationService`**:
    - **Signaturen:** Wie in.
    - `post_notification` nimmt `notification_data: NotificationInput` (eine vereinfachte Struktur ohne `id`, `timestamp`, `is_read`, `is_dismissed`).
    - **Neue Methoden:**
        - `async fn get_stats(&self) -> Result<NotificationStats, NotificationError>;`
        - `async fn clear_all_for_app(&mut self, app_id: &ApplicationId) -> Result<usize, NotificationError>;` (gibt Anzahl gelöschter zurück)
- **Implementierung `DefaultNotificationService`**:
    - **Felder:**
        - `active_notifications: Arc<tokio::sync::RwLock<VecDeque<Notification>>>` (VecDeque für einfaches FIFO-Verhalten, wenn ein Limit für aktive Popups existiert)
        - `history: Arc<tokio::sync::RwLock<VecDeque<Notification>>>`
        - `dnd_enabled: Arc<tokio::sync::RwLock<bool>>`
        - `rules_engine: Arc<dyn domain::notifications_rules::NotificationRulesEngine>` (Abhängigkeit injiziert)
        - `settings_service: Arc<dyn domain::global_settings_and_state_management::GlobalSettingsService>` (für MAX_HISTORY etc.)
        - `event_publisher: tokio::sync::broadcast::Sender<super::events::NotificationEventEnum>`
        - `max_active_popups: usize` (aus Einstellungen)
        - `max_history_items: usize` (aus Einstellungen)
    - **Konstruktor `new(...)`**: Nimmt Abhängigkeiten, lädt `max_active_popups` und `max_history_items` aus `settings_service`.
    - **Logik `post_notification(input: NotificationInput)`**:
        1. Erstellt `Notification`-Objekt aus `input`, generiert `id`, setzt `timestamp`.
        2. `processed_notification_option = self.rules_engine.process_notification(&mut notification_from_input, &current_global_settings).await?`
        3. Wenn `processed_notification_option` `None` ist (Regel hat unterdrückt) -> `Ok(notification_from_input.id)` (oder spezifischer Rückgabewert/Event).
        4. `let final_notification = processed_notification_option.unwrap();`
        5. Prüfe `dnd_enabled` und `final_notification.urgency`.
        6. Wenn nicht unterdrückt: Füge zu `active_notifications` hinzu. Wenn `max_active_popups` überschritten, ältestes entfernen (und ggf. Event für "Popup abgelaufen" senden). Sendet `NotificationPostedEvent { notification: final_notification.clone(), suppressed_by_dnd: false }`.
        7. Wenn unterdrückt: Sendet `NotificationPostedEvent { notification: final_notification.clone(), suppressed_by_dnd: true }`.
        8. Wenn `!final_notification.transient`: Füge zu `history` hinzu. Wenn `max_history_items` überschritten, ältestes aus `history` entfernen.
        9. `Ok(final_notification.id)`.
    - **Logik `get_active_notifications` / `get_notification_history`**: Implementiert Filterung (rekursiv für And/Or/Not) und Sortierung.
- **Struct `NotificationInput`**: Enthält Felder, die ein Client zum Erstellen einer Benachrichtigung bereitstellt (ohne `id`, `timestamp`, `is_read`, `is_dismissed`).
- **Struct `NotificationStats`**: `num_active: usize`, `num_history: usize`, `num_unread: usize`.
- **Events:** (Wrapper-Enum `NotificationEventEnum`)
    - `NotificationPostedEvent { notification: Notification, suppressed_by_dnd: bool }`
    - `NotificationDismissedEvent { notification_id: Uuid, reason: DismissReason }` (Grund für Dismiss, z.B. User, Timeout, Replaced)
    - `NotificationReadEvent { notification_id: Uuid }`
    - `NotificationActionInvokedEvent { notification_id: Uuid, action_key: String }`
    - `DoNotDisturbModeChangedEvent { dnd_enabled: bool }`
    - `NotificationHistoryClearedEvent`
    - `NotificationPopupExpiredEvent { notification_id: Uuid }` (Wenn aus aktiven Popups entfernt wegen Limit)

**Datei:** `src/user_centric_services/mod.rs`

- Deklariert Submodule `ai_interaction`, `notifications_core`, und ein gemeinsames `events.rs`.
- Re-exportiert öffentliche Traits (`AIInteractionLogicService`, `NotificationService`), Event-Enums und wichtige Typen.

#### 7.3. Implementierungsschritte `domain::user_centric_services`

1. **Grundgerüst:** Verzeichnisse für `ai_interaction` und `notifications_core` sowie gemeinsames `events.rs`.
2. **`ai_interaction` Modul:**
    - `types.rs`: Alle KI-bezogenen Typen und Enums.
    - `errors.rs`: `AIInteractionError`.
    - `persistence_iface.rs`: `AIConsentProvider`, `AIModelProfileProvider` Traits.
    - `persistence.rs` (intern): Implementierungen der Provider-Traits (z.B. `Filesystem...Provider`), die `Arc<dyn novade_core::config::ConfigServiceAsync>` nutzen.
    - `service.rs`: `AIInteractionLogicService`-Trait und `DefaultAIInteractionLogicService`-Implementierung.
    - Unit-Tests für Typen, Fehler, Provider-Implementierungen (Mocking `ConfigServiceAsync`), Service-Logik.
3. **`notifications_core` Modul:**
    - `types.rs`: Alle Benachrichtigungs-bezogenen Typen und Enums. `NotificationInput`.
    - `errors.rs`: `NotificationError`.
    - `service.rs`: `NotificationService`-Trait und `DefaultNotificationService`-Implementierung (nimmt `NotificationRulesEngine`, `GlobalSettingsService` als Abhängigkeiten).
    - Unit-Tests für Typen, Fehler, Service-Logik (insb. DND, History-Limit, Filter/Sort). Mocking von `NotificationRulesEngine` und `GlobalSettingsService`.
4. **`user_centric_services/events.rs`**: Event-Wrapper-Enums (`AIInteractionEventEnum`, `NotificationEventEnum`) definieren.
5. **`user_centric_services/mod.rs`**: Öffentliche API re-exportieren.
6. **Abhängigkeiten in `Cargo.toml`** für `user_centric_services` prüfen (insbesondere `uuid`, `chrono`, `serde`, `thiserror`, `async-trait`, `tokio`).

---

### Modul 8: `domain::notifications_rules`

Zweck: Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf konfigurierbaren Regeln. Diese Regeln modifizieren oder unterdrücken Benachrichtigungen, bevor sie dem Benutzer präsentiert oder in der Historie gespeichert werden.

Verantwortlichkeiten: Definition von Regelstrukturen, Laden/Speichern von Regeldefinitionen, Auswerten von Regeln gegen eingehende Benachrichtigungen.

Design-Rationale: Entkopplung der komplexen Regellogik vom Kern-Benachrichtigungsdienst. Ermöglicht es Benutzern oder Administratoren, das Benachrichtigungsverhalten fein granular anzupassen.

**Datei:** `src/notifications_rules/types.rs`

- **Enum `RuleConditionValue`** (neu, für Vergleiche):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub enum RuleConditionValue {
        String(String),
        Integer(i64),
        Boolean(bool),
        Urgency(NotificationUrgency), // NotificationUrgency aus notifications_core::types
        Regex(String), // Für Regex-Matching
    }
    ```
    
- **Enum `RuleConditionOperator`** (neu):
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum RuleConditionOperator {
        Is, IsNot,
        Contains, NotContains,
        StartsWith, EndsWith,
        MatchesRegex, NotMatchesRegex, // Für String-Werte gegen Regex
        GreaterThan, LessThan, GreaterThanOrEqual, LessThanOrEqual, // Für Integer
    }
    ```
    
- **Struct `RuleConditionField`** (neu, um das Feld der Notification zu spezifizieren):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum RuleConditionField {
        ApplicationName,
        Summary,
        Body,
        Urgency, // Vergleicht mit NotificationUrgency
        Category,
        HintExists(String), // Prüft Existenz eines Hints
        HintValue(String),  // Prüft Wert eines Hints (benötigt Operator und RuleConditionValue)
        // Zukünftig: ApplicationId, etc.
    }
    ```
    
- **Struct `SimpleRuleCondition`** (neu, für atomare Bedingungen):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct SimpleRuleCondition {
        pub field: RuleConditionField,
        pub operator: RuleConditionOperator,
        pub value: RuleConditionValue, // Wert, mit dem verglichen wird
    }
    ```
    
- **Enum `RuleCondition`** (rekursiv):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub enum RuleCondition {
        Simple(SimpleRuleCondition),
        SettingIsTrue(crate::global_settings_and_state_management::paths::SettingPath), // Pfad zu einer booleschen Einstellung
        And(Vec<RuleCondition>),
        Or(Vec<RuleCondition>),
        Not(Box<RuleCondition>),
    }
    ```
    
- **Enum `RuleAction`**:
    
    Rust
    
    ```
    use novade_core::types::Color as CoreColor; // Für das Setzen von Akzenten
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub enum RuleAction {
        SuppressNotification, // Benachrichtigung komplett unterdrücken
        SetUrgency(NotificationUrgency),
        AddActionToNotification(NotificationAction), // NotificationAction aus notifications_core::types
        SetHint(String /* key */, serde_json::Value /* value */),
        PlaySound(String /* sound_name_or_path */),
        MarkAsPersistent(bool), // Überschreibt transient-Flag der Notification
        SetTimeoutMs(Option<u32>), // Überschreibt Timeout
        SetCategory(String),
        // Neu:
        SetSummary(String), // Kann Template-Variablen enthalten, z.B. "{{original_summary}} - Wichtig!"
        SetBody(String),    // dito
        SetIcon(String),    // Icon-Name oder Pfad
        SetAccentColor(Option<CoreColor>), // Spezifische Akzentfarbe für diese Benachrichtigung
        StopProcessingFurtherRules, // Verhindert, dass nachfolgende Regeln ausgewertet werden
        LogMessage(String), // Loggt eine Nachricht, wenn die Regel zutrifft (für Debugging)
    }
    ```
    
- **Struct `NotificationRule`**:
    
    Rust
    
    ```
    use uuid::Uuid;
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct NotificationRule {
        pub id: Uuid,
        pub name: String, // Menschenlesbarer Name/Beschreibung der Regel
        pub condition: RuleCondition, // Die Bedingung(en)
        pub actions: Vec<RuleAction>, // Aktionen, die ausgeführt werden, wenn Bedingung zutrifft
        pub is_enabled: bool,
        pub priority: i32, // Höhere Zahl = höhere Priorität (wird früher ausgewertet)
        // stop_processing_after_match ist jetzt eine RuleAction::StopProcessingFurtherRules
    }
    impl Default for NotificationRule { /* ... id = new_v4(), is_enabled = true, priority = 0 ... */ }
    ```
    
- **Typalias `NotificationRuleSet`**: `pub type NotificationRuleSet = Vec<NotificationRule>;`

**Datei:** `src/notifications_rules/errors.rs`

- **Enum `NotificationRulesError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use super::types::NotificationRule; // Pfad ggf. anpassen
    
    #[derive(Debug, Error)]
    pub enum NotificationRulesError {
        #[error("Invalid rule definition for rule '{rule_name}' (ID: {rule_id}): {reason}")]
        InvalidRuleDefinition { rule_id: uuid::Uuid, rule_name: String, reason: String },
        #[error("Error evaluating condition for rule '{rule_name}' (ID: {rule_id}): {details}")]
        ConditionEvaluationError { rule_id: uuid::Uuid, rule_name: String, details: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> },
        #[error("Error applying action for rule '{rule_name}' (ID: {rule_id}): {details}")]
        ActionApplicationError { rule_id: uuid::Uuid, rule_name: String, details: String },
        #[error("Error accessing global settings for rule condition evaluation: {0}")]
        SettingsAccessError(#[from] crate::global_settings_and_state_management::GlobalSettingsError), // Pfad anpassen
        #[error("Error loading or saving notification rules: {0}")]
        RulePersistenceError(#[from] novade_core::errors::CoreError), // Annahme: Provider nutzt CoreError für I/O
        #[error("Invalid regex in rule condition: {0}")]
        InvalidRegex(String),
        #[error("An internal error occurred in notification rules engine: {0}")]
        InternalError(String),
    }
    ```
    

**Datei:** `src/notifications_rules/persistence_iface.rs`

- **Trait `NotificationRulesProvider`**: Wie in vorheriger Antwort.

**Datei:** `src/notifications_rules/persistence.rs` (intern)

- **Struct `FilesystemNotificationRulesProvider`**: Implementiert `NotificationRulesProvider`, nutzt `Arc<dyn novade_core::config::ConfigServiceAsync>` zum Laden/Speichern der `NotificationRuleSet` (z.B. als JSON-Array in `$XDG_CONFIG_HOME/novade/notification_rules.json`).

**Datei:** `src/notifications_rules/engine.rs` (oder `service.rs` / `mod.rs`)

- **Enum `RuleProcessingResult`**:
    
    Rust
    
    ```
    use crate::user_centric_services::notifications_core::types::Notification; // Pfad anpassen
    
    #[derive(Debug, Clone, PartialEq)]
    pub enum RuleProcessingResult {
        Allow(Notification),      // Benachrichtigung (ggf. modifiziert) erlauben
        Suppress { rule_id: uuid::Uuid }, // Benachrichtigung aufgrund dieser Regel unterdrücken
    }
    ```
    
- **Trait `NotificationRulesEngine`**:
    
    Rust
    
    ```
    use async_trait::async_trait;
    use crate::user_centric_services::notifications_core::types::Notification;
    use crate::global_settings_and_state_management::types::GlobalDesktopSettings;
    use super::types::NotificationRuleSet; // Eigene Typen
    use super::errors::NotificationRulesError;
    
    #[async_trait]
    pub trait NotificationRulesEngine: Send + Sync {
        /// Lädt oder aktualisiert die im System verwendeten Regeln.
        async fn reload_rules(&self) -> Result<(), NotificationRulesError>;
    
        /// Verarbeitet eine eingehende Benachrichtigung gegen die geladenen Regeln.
        /// Kann die Benachrichtigung modifizieren oder deren Unterdrückung signalisieren.
        async fn process_notification(
            &self,
            notification: Notification, // Nimmt Ownership, gibt ggf. modifizierte zurück
            // settings_snapshot: &GlobalDesktopSettings, // Benötigt aktuellen Snapshot für SettingIsTrue
        ) -> Result<RuleProcessingResult, NotificationRulesError>;
    
        /// Gibt die aktuell geladenen Regeln zurück (z.B. für UI zur Anzeige/Bearbeitung).
        async fn get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>;
    
        /// Speichert einen neuen Satz von Regeln.
        async fn update_rules(&self, new_rules: NotificationRuleSet) -> Result<(), NotificationRulesError>;
    }
    ```
    
- **Implementierung `DefaultNotificationRulesEngine`**:
    - **Felder:**
        - `rules: Arc<tokio::sync::RwLock<NotificationRuleSet>>`
        - `rules_provider: Arc<dyn NotificationRulesProvider>`
        - `settings_service: Arc<dyn crate::global_settings_and_state_management::GlobalSettingsService>`
    - **Konstruktor `new(...)`**: Nimmt Provider, lädt initial Regeln via `reload_rules_internal_locked()`.
    - **`reload_rules()`**: Sperrt `rules`-Lock, ruft `rules_provider.load_rules()`, sortiert nach `priority`, aktualisiert `self.rules`.
    - **`process_notification(...)` Logik:**
        1. Holt Lesesperre für `self.rules`. Holt aktuellen Snapshot der `GlobalDesktopSettings` vom `settings_service`.
        2. Iteriert durch eine Kopie der `enabled_rules` (sortiert nach `priority` DESC).
        3. `let mut current_notification = notification;` (mutable Kopie für mögliche Modifikationen).
        4. Für jede Regel:
            - `match self.evaluate_condition_recursive(&rule.condition, &current_notification, &settings_snapshot).await { ... }`
            - Wenn `Ok(true)` (Bedingung erfüllt):
                - `let stop_after_this = self.apply_actions_internal(&rule.actions, &mut current_notification, &rule).await?;`
                - Wenn eine Aktion `SuppressNotification` war: `return Ok(RuleProcessingResult::Suppress { rule_id: rule.id });`
                - Wenn `stop_after_this` (durch `RuleAction::StopProcessingFurtherRules`): `break;` (aus der Regelschleife).
            - Bei `Err(e)`: Logge Fehler, fahre ggf. mit nächster Regel fort oder gib Fehler zurück.
        5. `Ok(RuleProcessingResult::Allow(current_notification))`.
    - **`evaluate_condition_recursive(...)` Logik:**
        - `Simple(simple_cond)`: Wertet Feld gegen `operator` und `value` aus. Für `HintValue`, `Regex` etc.
        - `SettingIsTrue(setting_path)`: Ruft `settings_service.get_setting(&setting_path)` ab, prüft ob `serde_json::Value::Bool(true)`.
        - `And`, `Or`, `Not`: Rekursive Auswertung.
    - **`apply_actions_internal(...)` Logik:** Modifiziert `current_notification` basierend auf `RuleAction`s. Gibt `bool` zurück, ob Verarbeitung gestoppt werden soll.
    - **`get_rules()`**: Sperrt, klont, gibt `self.rules` zurück.
    - **`update_rules(...)`**: Sperrt, ersetzt `self.rules`, ruft `rules_provider.save_rules()` auf.

**Datei:** `src/notifications_rules/mod.rs`

- Deklariert Submodule. Re-exportiert `NotificationRulesEngine`-Trait, `NotificationRule`, `RuleCondition`, `RuleAction`, `NotificationRulesError`, `RuleProcessingResult` und den `NotificationRulesProvider`-Trait.

#### 7.4. Implementierungsschritte `domain::notifications_rules`

1. **Grundgerüst**: Verzeichnisse, `Cargo.toml`.
2. **`types.rs`**: Alle Regel-Typen (`RuleConditionValue`, `Operator`, `Field`, `SimpleRuleCondition`, `RuleCondition`, `RuleAction`, `NotificationRule`, `NotificationRuleSet`). `serde` und `Default`.
3. **`errors.rs`**: `NotificationRulesError` definieren.
4. **`persistence_iface.rs`**: `NotificationRulesProvider`-Trait definieren.
5. **`persistence.rs`**: `FilesystemNotificationRulesProvider` implementieren (nutzt `ConfigServiceAsync`). Tests mit Mocking.
6. **`engine.rs`**: `RuleProcessingResult` Enum. `NotificationRulesEngine`-Trait. `DefaultNotificationRulesEngine` implementieren:
    - Konstruktor, `RwLock` für `rules`.
    - `reload_rules()`, `process_notification()` (mit rekursiver Bedingungsauswertung und Aktionsanwendung), `get_rules()`, `update_rules()`.
    - Tests für Bedingungsauswertung (alle Operatoren, Feldtypen, logische Verknüpfungen, `SettingIsTrue`). Tests für Aktionsanwendung. Tests für Regelpriorisierung und `StopProcessingFurtherRules`. Mocking von `NotificationRulesProvider` und `GlobalSettingsService`.
7. **`mod.rs`**: Öffentliche API re-exportieren.

---

Diese detaillierten Pläne für die Module 1 bis 8 der Domänenschicht sollten eine sehr solide Grundlage für die Implementierung bieten. Jede Komponente ist klar abgegrenzt, und die Interaktionen sowie Abhängigkeiten sind definiert. Der nächste Schritt wäre, für jedes dieser Module die detaillierten Implementierungsschritte (wie im Beispiel für `core::types` und jetzt für die Domänenmodule gezeigt) und die Unit-Tests vollständig auszuarbeiten.

---


1. **Die detaillierte Aufteilung der Systemschicht in Hauptmodule und deren Submodule** basierend auf der Gesamtspezifikation () und Ihren Anforderungen festlegen.
2. Für **ein ausgewähltes, kritisches Hauptmodul (z.B. `system::compositor`) und dessen wichtigste Submodule eine vollständige Ultra-Feinspezifikation** mit der geforderten Detailtiefe erstellen, einschließlich Dateistruktur, Datentypen, API-Signaturen, Logikbeschreibungen und Implementierungsschritten.
3. Für die **weiteren Hauptmodule der Systemschicht die Struktur (Submodule) und die Kernverantwortlichkeiten skizzieren** sowie auf die relevanten Abschnitte in der Gesamtspezifikation () verweisen. Eine vollständige Ausarbeitung aller Module würde den Rahmen sprengen, aber die Methodik des detaillierten Moduls dient als Blaupause.

**Autonome Entscheidung zur Sequenzierung und Submodul-Aufteilung der Systemschicht:**

Basierend auf der Gesamtspezifikation () und der Notwendigkeit einer klaren Struktur, unterteile ich die Systemschicht (`novade-system` Crate) wie folgt:

1. **`system::compositor`**: Wayland-Compositor-Logik (Smithay-basiert).
    - `compositor::core`: Zentrale Compositor-Zustände und Handler.
    - `compositor::surface_management`: Verwaltung von `WlSurface`-Daten.
    - `compositor::shm`: SHM-Pufferbehandlung.
    - `compositor::xdg_shell`: XDG-Shell-Protokollintegration (Toplevels, Popups).
    - `compositor::layer_shell`: `wlr-layer-shell`-Integration für Panels, Docks etc.
    - `compositor::decoration`: `xdg-decoration`-Integration (Client/Server-Side Decorations).
    - `compositor::output_management`: `wlr-output-management` und `xdg-output` für Monitor-Konfiguration.
    - `compositor::input_method`: Integration von Eingabemethoden (IME).
    - `compositor::screencopy`: Screenshot- und Screencasting-Protokolle (z.B. `wlr-screencopy`).
    - `compositor::data_device`: Zwischenablage (Copy & Paste) und Drag & Drop.
    - `compositor::xwayland`: Integration und Verwaltung des XWayland-Servers.
    - `compositor::renderer_interface`: Abstrakte Schnittstelle zum Rendering-Backend.
    - `compositor::drm_gbm_renderer` (optional, eine konkrete Renderer-Implementierung).
    - `compositor::winit_renderer` (optional, eine weitere konkrete Renderer-Implementierung für verschachtelten Betrieb).
2. **`system::input`**: Eingabeverarbeitung (libinput-basiert).
    - `input::seat_manager`: Seat-Management, Fokus, Capabilities.
    - `input::libinput_handler`: Integration des Libinput-Backends.
    - `input::keyboard`: Tastaturereignis-Übersetzung, XKB-Management.
    - `input::pointer`: Maus-/Zeigerereignis-Verarbeitung, Cursor.
    - `input::touch`: Touch-Ereignis-Verarbeitung.
    - `input::gestures`: Gestenerkennung (aufbauend auf libinput-Events).
3. **`system::dbus_interfaces`**: Schnittstellen zu System-D-Bus-Diensten.
    - `dbus_interfaces::connection_manager`: Basis für D-Bus-Verbindungen.
    - `dbus_interfaces::network_manager`: Client für NetworkManager.
    - `dbus_interfaces::upower`: Client für UPower.
    - `dbus_interfaces::logind`: Client für systemd-logind.
    - `dbus_interfaces::notifications_server`: Implementierung des `org.freedesktop.Notifications`-Servers (nutzt `domain::user_centric_services::notifications_core`).
    - `dbus_interfaces::secrets_service`: Client für `org.freedesktop.secrets`.
    - `dbus_interfaces::policykit`: Client für PolicyKit.
    - `dbus_interfaces::xdg_desktop_portal_handler`: Backend-Logik für Portale (Interaktion mit Compositor etc.).
4. **`system::audio_management`**: PipeWire-Client-Integration.
    - `audio_management::client`: PipeWire-Core-Interaktion.
    - `audio_management::device_manager`: Verwaltung von Audio-Geräten.
    - `audio_management::stream_manager`: Verwaltung von Anwendungs-Streams.
    - `audio_management::volume_control`: Lautstärkeregelung.
5. **`system::mcp_client`**: Implementierung des Model Context Protocol Clients.
    - `mcp_client::connection`: Verwaltung der MCP-Server-Verbindung.
    - `mcp_client::protocol_handler`: Senden/Empfangen von MCP-Nachrichten.
    - `mcp_client::resource_provider`: Bereitstellung von Systemressourcen für KI-Modelle.
6. **`system::window_mechanics`**: Technische Umsetzung des Fenstermanagements.
    - `window_mechanics::placement`: Anwendung von Platzierungsrichtlinien.
    - `window_mechanics::tiling_engine`: Anwendung von Tiling-Layouts.
    - `window_mechanics::focus_arbitration`: Technische Fokushandhabung.
    - `window_mechanics::decoration_manager`: Koordination von SSD/CSD.
7. **`system::event_bridge`**: Brücke für Systemereignisse zur Domänenschicht und UI-Schicht.
8. **`system::power_management`**: Interaktion mit `wlr-output-power-management` und DPMS.

**Detailausarbeitung für `system::compositor` (Teil 1 - Kern & XDG Shell):**

---

## Ultra-Feinspezifikation und Implementierungsplan: Systemschicht (`novade-system` Crate)

**Allgemeine Entwicklungsrichtlinien für die Systemschicht:**

- **Sprache:** Rust (Edition 2021+).
- **Abhängigkeiten:** `novade-core`, `novade-domain`, `smithay` (spezifische Version, z.B. 0.10 oder neuer), `wayland-server`, `wayland-protocols`, `calloop`, `libinput`, `xkbcommon`, `zbus`, `pipewire-rs`, `mcp_client_rs`, `tracing`, `thiserror`, `uuid`, `serde`, `serde_json`, `parking_lot` (optional für Mutex).
- **Fehlerbehandlung:** Modulspezifische Fehler-Enums mit `thiserror`. Fehler aus `smithay` und anderen Bibliotheken werden gewrappt.
- **Asynchronität:** `calloop` ist die primäre Ereignisschleife für `smithay`. Andere asynchrone Operationen (z.B. `zbus`) müssen ggf. über Adapter integriert werden oder in eigenen Threads laufen und mit `calloop` über Kanäle/Signale kommunizieren. Wo `smithay` oder seine Abhängigkeiten `async/await` erfordern (z.B. einige `zbus`-Interaktionen), wird dies genutzt.
- **Zustandsverwaltung:** Eine zentrale `DesktopState`-Struktur wird die meisten `smithay`-Handler implementieren und die Zustände der Subsysteme halten.
- **Interaktion mit Domänenschicht:** Die Systemschicht ruft Services der Domänenschicht auf, um Geschäftslogik anzuwenden oder Zustände zu aktualisieren/abzufragen. Sie übersetzt Systemereignisse in Domänenereignisse oder -aufrufe.

**Cargo.toml für `novade-system` (Auszug):**

Ini, TOML

```
[dependencies]
novade-core = { path = "../novade-core" }
novade-domain = { path = "../novade-domain" }

smithay = { version = "0.10.0", features = ["renderer_gl", "backend_libinput", "backend_session", "backend_udev", "backend_drm", "backend_winit", "desktop", "xwayland", "use_system_lib"] } # Beispielversion, Features anpassen
wayland-server = "0.30" # Smithay-kompatible Version
wayland-protocols = { version = "0.30", features = ["server", "unstable_protocols"] } # Smithay-kompatible Version
calloop = "0.12"
libinput = "0.9"
xkbcommon = "0.7"
# ... weitere Abhängigkeiten ...
```

---

### Modul 1: `system::compositor`

Zweck: Implementierung des Wayland-Compositors unter Verwendung des Smithay-Toolkits.

Verantwortlichkeiten: Client-Verwaltung, Oberflächen-Lebenszyklus, Pufferbehandlung, Shell-Protokolle, Koordination des Renderings.

#### 1.1. Submodul: `system::compositor::core`

**Zweck:** Zentrale Compositor-Zustände, `DesktopState`-Definition, Basis-Handler-Implementierungen.

**Datei:** `src/compositor/core/errors.rs`

- **Enum `CompositorCoreError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use smithay::wayland::compositor::SurfaceRoleError;
    use wayland_server::{backend::ClientId, protocol::wl_surface::WlSurface};
    
    #[derive(Debug, Error)]
    pub enum CompositorCoreError {
        #[error("Failed to create Wayland global object '{0}'")]
        GlobalCreationFailed(String),
        #[error("Surface role error: {0}")]
        RoleError(#[from] SurfaceRoleError), // From smithay
        #[error("Client data not found for client ID {0:?}")]
        ClientDataMissing(ClientId),
        #[error("SurfaceData not found or of wrong type for WlSurface {0:?}")]
        SurfaceDataMissing(WlSurface),
        #[error("Invalid surface state: {0}")]
        InvalidSurfaceState(String),
        #[error("Renderer backend initialization failed: {0}")]
        RendererInitializationFailed(String),
        #[error("Display or EventLoop creation failed: {0}")]
        DisplayOrLoopCreationFailed(String),
        #[error("Failed to initialize XWayland: {0}")]
        XWaylandInitializationError(String),
        // Weitere spezifische Fehler
    }
    ```
    

**Datei:** `src/compositor/core/state.rs`

- **Struct `ClientCompositorData`** (für `Client::data_map`)
    
    Rust
    
    ```
    use smithay::wayland::compositor::CompositorClientState;
    use smithay::wayland::shell::xdg::XdgShellClientData; // Für XDG-Shell
    // Ggf. weitere Client-spezifische Zustände von Smithay-Modulen
    
    pub struct ClientCompositorData {
        pub compositor_state: CompositorClientState,
        // pub xdg_shell_data: XdgShellClientData, // Wird von XdgShellState::new_client verwaltet
    }
    
    impl ClientCompositorData {
        pub fn new() -> Self {
            Self {
                compositor_state: CompositorClientState::default(),
            }
        }
    }
    ```
    
- **Struct `DesktopState`** (Zentrale Zustandsstruktur)
    
    Rust
    
    ```
    use smithay::{
        backend::renderer::gles2::Gles2Renderer, // Beispiel-Renderer
        desktop::{Space, Window, WindowSurfaceType},
        input::{Seat, SeatState, pointer::CursorImageStatus},
        reexports::{
            calloop::{LoopHandle, Interest, Mode, PostAction},
            wayland_server::{Display, DisplayHandle, Client, backend::{GlobalId, ClientId}},
        },
        utils::{Clock, Logical, Point, Rectangle, Serial, Transform},
        wayland::{
            compositor::{CompositorState, CompositorClientState, CompositorHandler, SurfaceAttributes as WlSurfaceAttributes, add_destruction_hook},
            output::OutputManagerState, // Für wlr-output-management & xdg-output
            shell::{
                xdg::{XdgShellState, XdgShellHandler, XdgToplevelSurfaceData, XdgPopupSurfaceData, SurfaceCachedState, XdgWmBaseClientData},
                kde_decoration::KdeDecorationManagerState, // Beispiel für SSD
            },
            shm::{ShmState, ShmHandler},
            seat::WaylandSeatData, // Für wl_seat UserData
            // ... weitere Smithay-Module ...
            selection::data_device::{DataDeviceState, DataDeviceHandler},
            selection::primary_selection::{PrimarySelectionState, PrimarySelectionHandler},
            input_method::InputMethodManagerState,
            relative_pointer::RelativePointerManagerState,
            pointer_constraints::PointerConstraintsState,
            viewporter::ViewporterState,
            presentation::PresentationState,
            xdg_activation::XdgActivationState,
        },
    };
    use crate::domain::window_management_policy::{WindowManagementPolicyService, WindowPolicyOverrides, TilingMode, WorkspaceWindowLayout}; // Domain Service
    use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier as DomainWindowIdentifier};
    use crate::domain::workspaces::manager::WorkspaceManagerService;
    use std::{collections::HashMap, sync::{Arc, Mutex}}; // Mutex für Domain-Services
    use uuid::Uuid;
    use super::surface_management::{SurfaceData, RenderableElement}; // Eigene Typen
    use super::super::input::keyboard::xkb_config::XkbKeyboardData; // Aus system::input
    
    pub const CLOCK_ID: usize = 0;
    
    pub struct NovaDEWaylandState { /* Für Globals, die nur einmal existieren */
        pub shm_global: GlobalId,
        pub xdg_shell_global: GlobalId,
        pub output_manager_global: GlobalId,
        pub seat_global: GlobalId,
        pub data_device_global: GlobalId,
        // ... weitere GlobalIds ...
        pub xdg_activation_global: GlobalId,
    }
    
    pub struct DesktopState {
        pub display_handle: DisplayHandle,
        pub loop_handle: LoopHandle<'static, Self>, // 'static, wenn DesktopState global ist
        pub clock: Clock<u64>, // Für Timings, Animationen
    
        // Compositor & Core States
        pub compositor_state: CompositorState,
        pub shm_state: ShmState,
        pub presentation_state: PresentationState,
        pub viewporter_state: ViewporterState,
    
    
        // Shells & Window Management
        pub xdg_shell_state: XdgShellState,
        pub xdg_activation_state: XdgActivationState,
        // pub layer_shell_state: LayerShellState, // Für wlr-layer-shell
        // pub kde_decoration_state: KdeDecorationManagerState, // Für KWin SSD
    
        // Workspace & Window Tracking (Compositor-Sicht)
        pub space: Space<Window>, // Smithay's Desktop-Raum für Fensterverwaltung
        pub windows: HashMap<DomainWindowIdentifier, Window>, // Eigene Map für Zugriff via Domain ID
    
        // Input & Seat
        pub seat_state: SeatState<Self>,
        pub seat: Seat<Self>, // Der primäre Seat
        pub seat_name: String,
        pub input_method_manager_state: InputMethodManagerState, // Für IME
        pub relative_pointer_manager_state: RelativePointerManagerState,
        pub pointer_constraints_state: PointerConstraintsState,
        pub keyboard_data_map: HashMap<String /* seat_name oder device_id */, XkbKeyboardData>, // Für XKB
        pub current_cursor_status: Arc<Mutex<CursorImageStatus>>, // Für Cursor-Rendering
    
        // Output Management
        pub output_manager_state: OutputManagerState,
    
        // Data Exchange (Clipboard, DnD)
        pub data_device_state: DataDeviceState,
        // pub primary_selection_state: PrimarySelectionState,
    
        // XWayland
        // pub xwayland: XWayland, // Smithay's XWayland-Struktur
    
        // Domain Service Handles (Arc<Mutex<...>> oder Arc<dyn ...>)
        pub window_policy_service: Arc<dyn WindowManagementPolicyService>,
        pub workspace_manager_service: Arc<dyn WorkspaceManagerService>,
        // ... weitere Domain-Services ...
    
        // Renderer (wird später konkretisiert)
        // pub renderer: Gles2Renderer,
        // pub last_render_time: std::time::Instant,
    
        // Wayland Global IDs (um sie am Leben zu halten)
        pub wayland_globals: Option<NovaDEWaylandState>, // Wird nach Erstellung der Globals gefüllt
    }
    
    impl DesktopState {
        pub fn new(
            loop_handle: LoopHandle<'static, Self>,
            display_handle: DisplayHandle,
            window_policy_service: Arc<dyn WindowManagementPolicyService>,
            workspace_manager_service: Arc<dyn WorkspaceManagerService>,
        ) -> Self {
            let clock = Clock::new(Some(tracing::Span::current())); // tracing integration
            let compositor_state = CompositorState::new::<Self>(&display_handle, Some(tracing::Span::current()));
            let shm_state = ShmState::new::<Self>(&display_handle, vec![], Some(tracing::Span::current())); // Keine zusätzlichen Formate initial
            let presentation_state = PresentationState::new::<Self>(&display_handle, clock.id() as u32);
            let viewporter_state = ViewporterState::new::<Self>(&display_handle, Some(tracing::Span::current()));
    
            let xdg_shell_state = XdgShellState::new::<Self>(&display_handle, Some(tracing::Span::current()));
            let xdg_activation_state = XdgActivationState::new::<Self>(&display_handle, Some(tracing::Span::current()));
    
            let space = Space::new(Some(tracing::Span::current()));
    
            let mut seat_state = SeatState::new();
            let seat_name = "seat0".to_string();
            let seat = seat_state.new_wl_seat(&display_handle, seat_name.clone(), Some(tracing::Span::current()));
            // Capabilities (Keyboard, Pointer, Touch) werden später beim Input-Backend-Init hinzugefügt
    
            let input_method_manager_state = InputMethodManagerState::new::<Self>(&display_handle);
            let relative_pointer_manager_state = RelativePointerManagerState::new::<Self>(&display_handle);
            let pointer_constraints_state = PointerConstraintsState::new::<Self>(&display_handle, Some(tracing::Span::current()));
    
    
            let output_manager_state = OutputManagerState::new_with_xdg_output::<Self>(&display_handle);
            let data_device_state = DataDeviceState::new::<Self>(&display_handle, Some(tracing::Span::current()));
    
            Self {
                display_handle,
                loop_handle,
                clock,
                compositor_state,
                shm_state,
                presentation_state,
                viewporter_state,
                xdg_shell_state,
                xdg_activation_state,
                space,
                windows: HashMap::new(),
                seat_state,
                seat,
                seat_name,
                input_method_manager_state,
                relative_pointer_manager_state,
                pointer_constraints_state,
                keyboard_data_map: HashMap::new(),
                current_cursor_status: Arc::new(Mutex::new(CursorImageStatus::Default)),
                output_manager_state,
                data_device_state,
                window_policy_service,
                workspace_manager_service,
                wayland_globals: None,
            }
        }
    }
    ```
    
    - **Initialisierung der Smithay-States:** Erfolgt im `new()` Konstruktor von `DesktopState`. Die `Logger` Parameter sind in neueren Smithay-Versionen oft durch `Option<tracing::Span>` ersetzt oder implizit.
    - **Domain Service Handles:** Werden als `Arc<dyn TraitName>` gespeichert, um Flexibilität und Testbarkeit zu gewährleisten. Sie werden von außen injiziert.
- **Implementierung `CompositorHandler` für `DesktopState`**:
    - **`compositor_state(&mut self) -> &mut CompositorState`**: Gibt `&mut self.compositor_state` zurück.
    - **`client_compositor_state<'a>(&self, client: &'a Client) -> &'a CompositorClientState`**:
        1. `client.get_data::<ClientCompositorData>().unwrap().compositor_state` (Annahme: `ClientCompositorData` wird beim Client-Connect in `Client::data_map` eingefügt).
    - **`commit(&mut self, surface: &WlSurface)`**:
        1. `tracing::debug!(surface_id = ?surface.id(), "Commit für WlSurface");`
        2. `smithay::wayland::compositor::with_states(surface, |states| { ... })` verwenden, um auf `SurfaceAttributes` und `SurfaceData` zuzugreifen.
        3. `let surface_attributes = states.cached_state.current::<WlSurfaceAttributes>();`
        4. **Puffer-Handling:**
            - Wenn `surface_attributes.buffer.is_some()` und `surface_attributes.buffer_delta != (0,0)` oder ein neuer Puffer angehängt wurde:
                - Die `SurfaceData` für diesen `surface` abrufen (aus `states.data_map`).
                - `surface_data.lock().unwrap().current_buffer = surface_attributes.buffer.clone();`
                - `surface_data.lock().unwrap().buffer_scale = surface_attributes.buffer_scale;`
                - `surface_data.lock().unwrap().buffer_transform = surface_attributes.buffer_transform;`
                - Renderer benachrichtigen, die Textur für diesen Puffer zu aktualisieren/erstellen (Details im Renderer-Modul).
        5. **Schadensverfolgung (Damage Tracking):**
            - `let damage = &surface_attributes.damage;` (Liste von `Rectangle<i32, BufferCoords>`).
            - Die `SurfaceData` mit diesen Schadensregionen aktualisieren: `surface_data.lock().unwrap().damage_buffer_coords.extend(damage.iter().cloned());`
        6. **Rollenbasierte Commit-Logik:**
            - `let role = smithay::wayland::compositor::get_role(surface);`
            - `match role { Some("xdg_toplevel") => { ... }, Some("xdg_popup") => { ... }, ... }`
            - Ruft spezifische Commit-Handler für XDG-Toplevels, Popups, Subsurfaces, Layer-Surfaces etc. auf. Diese könnten in `SurfaceData` als Callbacks/Hooks gespeichert sein oder direkt hier behandelt werden. Für XDG-Shell wird dies oft vom `XdgShellHandler` übernommen. Smithay's `desktop::Space` und `Window` handhaben vieles davon.
        7. **Synchronisierte Subsurfaces:** `if surface.is_sync_subsurface() { ... }` Logik für Parent-Commit ( Schritt 8).
        8. Oberfläche für Neuzeichnung im nächsten Frame markieren (z.B. `self.space.damage_window(&window_für_surface, ...)`).
    - **`new_surface(&mut self, surface: &WlSurface, client_data: &Arc<ClientCompositorData>)`** (Signatur kann variieren, je nachdem wie Client-Daten übergeben werden):
        1. `tracing::info!(surface_id = ?surface.id(), client_id = ?surface.client().unwrap().id(), "Neue WlSurface erstellt");`
        2. Initialisiere `SurfaceData::new(surface.client().unwrap().id())`.
        3. `surface.data_map().insert_if_missing_threadsafe(|| Arc::new(Mutex::new(SurfaceData::new(...))));`
        4. `add_destruction_hook(surface, |data_map| { ... Bereinigung von SurfaceData ... });`
    - **`new_subsurface(&mut self, surface: &WlSurface, parent: &WlSurface, client_data: &Arc<ClientCompositorData>)`**:
        1. `tracing::info!(surface_id = ?surface.id(), parent_id = ?parent.id(), "Neue WlSubsurface erstellt");`
        2. `SurfaceData` von `surface` aktualisieren: `surface_data.lock().unwrap().parent = Some(parent.downgrade());`
        3. `SurfaceData` von `parent` aktualisieren: `parent_surface_data.lock().unwrap().children.push(surface.downgrade());`
    - **`destroyed(&mut self, surface: &WlSurface)`**:
        1. `tracing::info!(surface_id = ?surface.id(), "WlSurface zerstört");`
        2. Smithay kümmert sich um das Entfernen aus der `UserDataMap`.
        3. Sicherstellen, dass alle Referenzen auf diese `WlSurface` in `DesktopState` (z.B. in `space`, `windows`, Fokus-Listen) entfernt werden. Dies geschieht oft über den `destruction_hook` der `SurfaceData`.

#### 1.2. Submodul: `system::compositor::surface_management`

**Zweck:** Definition und Verwaltung von `SurfaceData`.

**Datei:** `src/compositor/surface_management/mod.rs`

- **Enum `RenderableElement`** (kann auch direkt Smithay's `Element` sein oder dieses wrappen)
    
    Rust
    
    ```
    // Beispiel, wird durch Renderer-Schnittstelle konkretisiert
    pub enum RenderableElement {
        WaylandSurface {
            surface: WlSurface, // Oder eine ID/Wrapper, der die Textur hält
            position: Point<i32, Logical>,
            scale: f64,
            transform: Transform, // Bildschirmrotation etc.
            damage_surface_local: Vec<Rectangle<i32, Logical>>, // Schaden relativ zur Oberfläche
            opaque_regions_surface_local: Vec<Rectangle<i32, Logical>>,
        },
        SolidColor { /* ... */ },
        Cursor { /* ... */ },
    }
    ```
    
- **Struct `SurfaceData`**:
    - **Felder:**
        - `pub id: Uuid` (Eigene interne ID)
        - `pub client_id: ClientId`
        - `pub role: Mutex<Option<String>>` (Rolle, z.B. "toplevel", "popup", "cursor", "layer")
        - `pub current_buffer_info: Mutex<Option<AttachedBufferInfo>>` (Infos zum aktuellen Puffer)
        - `pub texture_handle: Mutex<Option<Box<dyn RenderableTexture>>>` (Handle vom Renderer, `RenderableTexture` Trait wird in `renderer_interface` definiert)
        - `pub damage_buffer_coords: Mutex<Vec<Rectangle<i32, smithay::utils::Buffer>>>`
        - `pub damage_surface_coords: Mutex<Vec<Rectangle<i32, Logical>>>` (Transformierter Schaden)
        - `pub opaque_region_surface_local: Mutex<Option<smithay::utils::Region<Logical>>>`
        - `pub input_region_surface_local: Mutex<Option<smithay::utils::Region<Logical>>>`
        - `pub user_data_ext: UserDataMap` (Für anwendungsspezifische Daten, die von anderen Modulen wie XDG-Shell oder Layer-Shell hier abgelegt werden)
        - `pub parent: Mutex<Option<wayland_server::Weak<WlSurface>>>`
        - `pub children: Mutex<Vec<wayland_server::Weak<WlSurface>>>`
        - `pub pre_commit_hooks: Mutex<Vec<Box<dyn FnMut(&mut DesktopState, &WlSurface) + Send + Sync>>>`
        - `pub post_commit_hooks: Mutex<Vec<Box<dyn FnMut(&mut DesktopState, &WlSurface) + Send + Sync>>>`
        - `destruction_callback: Mutex<Option<Box<dyn FnOnce(&mut DesktopState, &WlSurface) + Send + Sync>>>` (Ein dedizierter Callback statt Vec für einmalige Zerstörung)
        - `pub surface_viewporter_state: Mutex<smithay::wayland::viewporter::SurfaceState>`
        - `pub surface_presentation_state: Mutex<smithay::wayland::presentation::SurfaceState>`
        - `pub surface_scale_factor: Mutex<f64>` (Skalierungsfaktor, der auf diese Oberfläche angewendet wird, z.B. vom Output)
    - **Struct `AttachedBufferInfo`**:
        
        Rust
        
        ```
        #[derive(Debug, Clone)]
        pub struct AttachedBufferInfo {
            pub buffer: WlBuffer,
            pub scale: i32, // Smithay's buffer_scale
            pub transform: Transform, // Smithay's buffer_transform
            pub dimensions: Size<i32, smithay::utils::Buffer>, // Größe des Puffers
        }
        ```
        
    - **Methoden für `SurfaceData`**:
        - `pub fn new(client_id: ClientId) -> Self`
        - `pub fn set_role(&self, role: &str) -> Result<(), CompositorCoreError>`
        - `pub fn get_role(&self) -> Option<String>`
        - `pub fn attach_buffer(&self, buffer_info: Option<AttachedBufferInfo>)`
        - `pub fn take_damage_buffer_coords(&self) -> Vec<Rectangle<i32, smithay::utils::Buffer>>`
        - `pub fn add_pre_commit_hook(...)`, `add_post_commit_hook(...)`
        - `pub fn set_destruction_callback(...)`
        - `pub fn get_effective_damage_and_transform(&self, output_transform: Transform) -> (Vec<Rectangle<i32, Logical>>, Transform)` (Berechnet transformierten Schaden)
- **Funktionen:**
    - `pub fn get_surface_data(surface: &WlSurface) -> Option<Arc<SurfaceData>>`: Ruft `Arc<SurfaceData>` aus `surface.data_map()` ab.
    - `pub fn with_surface_data_mut<F, R>(surface: &WlSurface, callback: F) -> Result<R, CompositorCoreError> where F: FnOnce(&mut SurfaceData, &WlSurfaceAttributes) -> R`: Kapselt Locken und Zugriff. `WlSurfaceAttributes` wird über `with_states` geholt.

#### 1.3. Submodul: `system::compositor::shm`

**Zweck:** SHM-Pufferbehandlung (`wl_shm`).

**Datei:** `src/compositor/shm/errors.rs`

- **Enum `ShmError`**: ()
    - `PoolCreationFailed(String)`
    - `BufferCreationFailed(String)`
    - `InvalidFormat(wl_shm::Format)`
    - `AccessError(#[from] smithay::wayland::shm::BufferAccessError)`

**Datei:** `src/compositor/shm/mod.rs` (oder `state.rs`)

- **Implementierung `ShmHandler` für `DesktopState`**:
    - `shm_state(&self) -> &ShmState`: Gibt `&self.shm_state` zurück.
- **Implementierung `BufferHandler` für `DesktopState`** (Hier spezifisch für SHM-Puffer, obwohl der Trait generisch ist):
    - `buffer_destroyed(&mut self, buffer: &wl_buffer::WlBuffer)`:
        1. `tracing::debug!(buffer_id = ?buffer.id(), "SHM WlBuffer zerstört");`
        2. Finde alle `SurfaceData`-Instanzen, die diesen `buffer` in `current_buffer_info` verwenden.
        3. Für jede gefundene Instanz:
            - Entferne die Referenz auf den Puffer.
            - Benachrichtige den Renderer, die zugehörige Textur freizugeben (`surface_data.texture_handle.take()`).
            - Markiere die Oberfläche als beschädigt, da ihr Inhalt nun ungültig ist.
- **Implementierung `GlobalDispatch<WlShm, ()>` für `DesktopState`**: ()
    - `bind(...)`: `data_init.init(resource, ());` (Smithay's `ShmState` kümmert sich um das Senden von Formaten).
- **Funktion `pub fn create_shm_global(state: &mut DesktopState, display_handle: &DisplayHandle)`**: ()
    1. `let shm_global_id = state.shm_state.global().clone();` (Da `shm_state` bereits in `DesktopState::new` initialisiert wurde).
    2. Speichere `shm_global_id` in `state.wayland_globals.as_mut().unwrap().shm_global`.
    3. `tracing::info!("wl_shm Global für Clients verfügbar gemacht. Unterstützte Formate: ARGB8888, XRGB8888.");`

**Datei:** `src/compositor/shm/buffer_access.rs`

- **Funktion `pub fn with_shm_buffer_contents<F, T>(buffer: &wl_buffer::WlBuffer, callback: F) -> Result<T, ShmError> where F: FnOnce(*const u8, usize, &smithay::wayland::shm::BufferData) -> T`**:
    1. `smithay::wayland::shm::with_buffer_contents(buffer, callback).map_err(ShmError::from)`

#### 1.4. Submodul: `system::compositor::xdg_shell`

**Zweck:** XDG-Shell-Protokollintegration (`xdg_wm_base`, `xdg_surface`, `xdg_toplevel`, `xdg_popup`).

**Datei:** `src/compositor/xdg_shell/errors.rs`

- **Enum `XdgShellError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use smithay::{utils::Serial, wayland::shell::xdg::ToplevelConfigureError};
    use wayland_server::protocol::wl_surface::WlSurface;
    use uuid::Uuid; // Für interne Window-IDs
    use crate::compositor::core::errors::CompositorCoreError;
    
    #[derive(Debug, Error)]
    pub enum XdgShellError {
        #[error("Surface {0:?} already has a different XDG role or is uninitialized.")]
        InvalidSurfaceRole(WlSurface),
        #[error("Window handling error for window ID {0}: {1}")]
        WindowHandlingError(Uuid, String), // Uuid ist die interne ID des ManagedWindow
        #[error("Popup positioning failed: {0}")]
        PopupPositioningError(String),
        #[error("Client provided invalid serial {client_serial:?} for configure, expected around {expected_serial:?}.")]
        InvalidAckConfigureSerial { client_serial: Serial, expected_serial: Serial },
        #[error("ManagedToplevel with ID {0} not found.")]
        ToplevelNotFound(Uuid),
        #[error("ManagedPopup with ID {0} not found.")]
        PopupNotFound(Uuid),
        #[error("XDG Toplevel configure operation failed: {0}")]
        ToplevelConfigureFailed(#[from] ToplevelConfigureError),
        #[error("Core compositor error during XDG operation: {0}")]
        CoreError(#[from] CompositorCoreError),
        #[error("XDG WM Base client data not found.")]
        XdgWmBaseClientDataMissing,
    }
    ```
    

**Datei:** `src/compositor/xdg_shell/types.rs`

- **Struct `ManagedWindow`** (ersetzt `ManagedToplevel` und `ManagedPopup` für Smithay's `Space<Window>`)
    
    Rust
    
    ```
    use smithay::{
        desktop::{Window, WindowSurface, WindowSurfaceType, Space},
        output::Output,
        reexports::wayland_protocols::xdg::shell::server::xdg_toplevel,
        utils::{Logical, Point, Rectangle, Size},
        wayland::shell::xdg::{ToplevelSurface, PopupSurface, PositionerState, XdgPopupSurfaceData, XdgToplevelSurfaceData},
    };
    use wayland_server::protocol::wl_surface::WlSurface;
    use wayland_server::Weak;
    use uuid::Uuid;
    use crate::domain::workspaces::core::types::WindowIdentifier as DomainWindowIdentifier; // Domain-ID
    use crate::compositor::surface_management::SurfaceData; // Zugriff auf SurfaceData
    use std::sync::{Arc, Mutex};
    
    #[derive(Debug, Clone, PartialEq)] // PartialEq ggf. manuell oder nur auf ID
    pub struct ManagedWindow {
        pub id: Uuid, // Interne Compositor-ID
        pub domain_id: DomainWindowIdentifier, // Verknüpfung zur Domänenschicht
        pub xdg_surface: WindowSurface, // Smithay's WindowSurface (Toplevel oder Popup)
        // app_id und title werden über xdg_surface.get_app_id() / .get_title() geholt
        pub current_geometry: Rectangle<i32, Logical>, // Berechnete Geometrie
        pub requested_size: Option<Size<i32, Logical>>,
        pub min_size: Option<Size<i32, Logical>>,
        pub max_size: Option<Size<i32, Logical>>,
        pub parent_id: Option<Uuid>, // Für transiente Toplevels oder Popups
        pub is_mapped: bool,
        // Weitere Zustände wie maximized, fullscreen, activated werden über xdg_surface.toplevel()
        // und dessen Methoden (e.g. current_states()) oder XdgToplevelSurfaceData verwaltet.
    }
    
    impl ManagedWindow {
        pub fn new_toplevel(toplevel_surface: ToplevelSurface, domain_id: DomainWindowIdentifier) -> Self {
            // Initialgeometrie etc. wird später vom Layout-Manager gesetzt
            Self {
                id: Uuid::new_v4(),
                domain_id,
                xdg_surface: WindowSurface::Toplevel(toplevel_surface),
                current_geometry: Rectangle::from_loc_and_size((0,0), (0,0)),
                requested_size: None, min_size: None, max_size: None,
                parent_id: None, // TODO: Parent-Logik für transiente Toplevel
                is_mapped: false,
            }
        }
    
        pub fn new_popup(popup_surface: PopupSurface, parent_domain_id: DomainWindowIdentifier) -> Self {
             // Popups haben eine komplexere Geometrieberechnung
            Self {
                id: Uuid::new_v4(),
                domain_id: DomainWindowIdentifier::new(format!("popup-{}", Uuid::new_v4())).unwrap(), // Eigene ID für Popups
                xdg_surface: WindowSurface::Popup(popup_surface),
                current_geometry: Rectangle::from_loc_and_size((0,0), (0,0)), // Wird durch Positioner bestimmt
                requested_size: None, min_size: None, max_size: None,
                parent_id: Some(Uuid::default()), // TODO: parent_id korrekt setzen auf Uuid des Parent ManagedWindow
                is_mapped: false,
            }
        }
    
        pub fn wl_surface(&self) -> &WlSurface {
            self.xdg_surface.wl_surface()
        }
        // ... weitere Hilfsmethoden ...
    }
    
    // Implementierung von smithay::desktop::Window für ManagedWindow
    impl Window for ManagedWindow {
        fn id(&self) -> usize {
            // Smithay's Space benötigt usize. Wir können die Bytes unserer Uuid nehmen.
            // Dies muss stabil sein für die Lebenszeit des Fensters.
            let mut hasher = std::collections::hash_map::DefaultHasher::new();
            self.id.hash(&mut hasher);
            std::hash::Hasher::finish(&hasher) as usize
        }
        fn wl_surface(&self) -> Option<WlSurface> { Some(self.xdg_surface.wl_surface().clone()) }
        fn surface_type(&self) -> WindowSurfaceType { self.xdg_surface.surface_type() }
        fn geometry(&self) -> Rectangle<i32, Logical> { self.current_geometry }
        fn is_mapped(&self) -> bool { self.is_mapped && self.xdg_surface.alive() } // Und ob die Wayland-Oberfläche noch existiert
        fn is_suspended(&self) -> bool {
            // Abfragen von XdgToplevelSurfaceData, ob minimiert etc.
            if let WindowSurface::Toplevel(t) = &self.xdg_surface {
                let data = t.user_data().get::<XdgToplevelSurfaceData>().unwrap();
                return data.minimized || data.suspended;
            }
            false
        }
        // ... weitere Methoden des Window-Traits implementieren (send_configure, set_activated etc.)
        // Diese rufen oft Methoden auf self.xdg_surface.toplevel() oder .popup() auf.
        fn send_frame(&self, output: &Output, time: impl Into<Duration>, throttle: Option<Duration>, primary_scan_out_output: Option<&Output>) {
            // Für Frame-Callbacks des Presentation-Time Protokolls
            if let Some(wl_surface) = self.wl_surface() {
                 smithay::wayland::presentation::send_frames_surface_dest harming_region_transform,
                    &wl_surface,
                    output,
                    time,
                    throttle,
                    primary_scan_out_output,
                );
            }
        }
        // ...
    }
    ```
    
    - **Verwendung von `smithay::desktop::Window` Trait**: Die `ManagedWindow`-Struktur implementiert diesen Trait, um mit `smithay::desktop::Space` kompatibel zu sein. Dies vereinfacht die Fensterverwaltung, das Stapeln und die Schadensberechnung für den Renderer erheblich.

**Datei:** `src/compositor/xdg_shell/handlers.rs`

- **Implementierung `XdgShellHandler` für `DesktopState`**:
    - **`xdg_shell_state(&mut self) -> &mut XdgShellState`**: Gibt `&mut self.xdg_shell_state` zurück.
    - **`new_toplevel(&mut self, surface: ToplevelSurface)`**:
        1. `tracing::info!(surface = ?surface.wl_surface().id(), "Neues XDG Toplevel wird erstellt.");`
        2. `let domain_window_id = DomainWindowIdentifier::new(format!("xdg-toplevel-{}", Uuid::new_v4())).unwrap();`
        3. `let mut managed_window = ManagedWindow::new_toplevel(surface.clone(), domain_window_id.clone());`
        4. **Initialgeometrie von Domäne anfordern:**
            - `let window_layout_info = WindowLayoutInfo { id: domain_window_id.clone(), requested_min_size: None, ... };`
            - `let initial_geom_result = block_on(self.window_policy_service.get_initial_window_geometry(&window_layout_info, ...));` (Blockieren hier ist problematisch in `calloop`. Besser: `get_initial_window_geometry` synchron machen oder die Fenstererstellung in eine Task-Pipeline verschieben.)
            - Wenn `Ok(geom)`, setze `managed_window.current_geometry = geom;`. Sonst Standardgeometrie.
        5. Füge `XdgToplevelSurfaceData` zur UserDataMap des `surface.wl_surface()` hinzu (Smithay macht das oft schon).
        6. `surface.with_pending_state(|state| { state.size = Some(managed_window.current_geometry.size); });`
        7. `surface.send_configure();` (Sendet initiale Größe etc. an Client).
        8. Füge `managed_window` zu `self.space` hinzu: `let window_arc = Arc::new(managed_window); self.space.map_window(window_arc.clone(), (initial_x, initial_y), true);` (Aktivieren, falls es Fokus bekommen soll).
        9. `self.windows.insert(domain_window_id, window_arc);`
    - **`new_popup(&mut self, surface: PopupSurface, _client_data: &XdgWmBaseClientData)`**:
        1. `tracing::info!(surface = ?surface.wl_surface().id(), "Neues XDG Popup wird erstellt.");`
        2. `let parent_wl_surface = surface.get_parent_surface().ok_or_else(|| XdgShellError::PopupPositioningError("Popup hat keine Elternoberfläche".into()))?;`
        3. Finde `parent_managed_window` über `parent_wl_surface` in `self.space` oder `self.windows`.
        4. `let managed_popup = ManagedWindow::new_popup(surface.clone(), parent_managed_window.domain_id.clone());`
        5. Füge `XdgPopupSurfaceData` zum `surface.wl_surface().data_map()` hinzu (Smithay macht das oft).
        6. Berechne Popup-Geometrie: `let positioner = surface.get_positioner(); let popup_geom = calculate_popup_geometry(&positioner, parent_managed_window.geometry());`
        7. `managed_popup.current_geometry = popup_geom;`
        8. `surface.send_configure();`
        9. Füge Popup zu `self.space` hinzu (Smithay's Space kann auch Popups verwalten, oder sie werden relativ zum Parent gerendert).
        10. `self.windows.insert(managed_popup.domain_id.clone(), Arc::new(managed_popup));`
    - **`map_toplevel(&mut self, surface: &ToplevelSurface)`**:
        1. Finde `ManagedWindow` für `surface.wl_surface()`.
        2. `managed_window.is_mapped = true;`
        3. Benachrichtige Domänenschicht (z.B. `workspace_manager_service.assign_window_to_active_workspace(&managed_window.domain_id)`).
        4. Fordere ein Re-Layout für den Workspace an.
        5. `self.space.damage_all_outputs();` (Oder spezifischer Schaden).
    - **`unmap_toplevel(&mut self, surface: &ToplevelSurface)`**:
        1. Finde `ManagedWindow`. `managed_window.is_mapped = false;`
        2. Entferne Fenster aus Workspace (`workspace_manager_service.remove_window_from_its_workspace`).
        3. `self.space.unmap_window(&managed_window_arc);`
    - **`ack_configure(&mut self, surface: WlSurface, configure_data: XdgSurfaceConfigureUserData)`**:
        1. `tracing::debug!(surface = ?surface.id(), serial = ?configure_data.serial, "XDG Surface ack_configure empfangen.");`
        2. Finde `ManagedWindow`.
        3. Logik für `ack_configure` gemäß Smithay-Dokumentation (Serial-Vergleich, Zustandsanwendung).
        4. `if let SurfaceCachedState::Toplevel(toplevel_data) = configure_data.cached_state { ... }`
    - **Andere `XdgShellHandler`-Methoden (`*_request_*`):**
        - Finde das `ManagedWindow`.
        - Aktualisiere den Zustand im `ManagedWindow` und/oder dessen `XdgToplevelSurfaceData` (z.B. `title`, `app_id`, `maximized`, `fullscreen`).
        - Interagiere mit `self.window_policy_service` für Größen-/Zustandsänderungen.
        - Rufe `toplevel_surface.send_configure()` auf, um den Client über den neuen Zustand zu informieren.
        - Für `move` und `resize`: Starte einen interaktiven Grab über `self.seat.start_pointer_grab(...)` oder `self.seat.start_touch_grab(...)`.
    - **`toplevel_destroyed(&mut self, toplevel: ToplevelSurface)`**:
        1. Finde `ManagedWindow`.
        2. `self.space.unmap_window(&managed_window_arc);`
        3. `self.windows.remove(&managed_window.domain_id);`
        4. Benachrichtige Domäne.
    - **`popup_destroyed(&mut self, popup: PopupSurface)`**: Analog.

**Datei:** `src/compositor/xdg_shell/mod.rs` (oder `state.rs`)

- **Implementierung `GlobalDispatch<XdgWmBase, ()>` für `DesktopState`**: ()
    - `bind(...)`:
        1. `let client_data = client.get_data::<Arc<Mutex<XdgWmBaseClientData>>>().cloned();` (oder `state.xdg_shell_state.new_client(client)` und speichern).
        2. `data_init.init(resource, client_data.expect("XdgWmBase client data must be set").clone());`
- **Funktion `pub fn create_xdg_shell_global(state: &mut DesktopState, display_handle: &DisplayHandle)`**: ()
    1. `let xdg_shell_global_id = state.xdg_shell_state.global().clone();`
    2. Speichere in `state.wayland_globals`.
    3. `tracing::info!("xdg_wm_base Global v{} für Clients verfügbar gemacht.", XdgWmBase::VERSION);`

#### 1.5. Implementierungsschritte `system::compositor` (Teil 1)

1. **Grundgerüst**: Verzeichnisse anlegen, `Cargo.toml` für Smithay etc. anpassen.
2. **`core/errors.rs`**: `CompositorCoreError` definieren.
3. **`surface_management/mod.rs`**: `SurfaceData`, `AttachedBufferInfo` definieren. `get_surface_data`, `with_surface_data_mut` implementieren.
4. **`core/state.rs`**: `ClientCompositorData`. `DesktopState` Grundstruktur mit `compositor_state`, `display_handle`, `loop_handle`, `clock`, `space`, `windows`, `seat_state`, `seat`, Domain-Service-Handles. `new()`-Konstruktor.
5. **`core/state.rs`**: `CompositorHandler` für `DesktopState` implementieren (`compositor_state`, `client_compositor_state`, `commit`, `new_surface`, `new_subsurface`, `destroyed`).
6. **`shm/errors.rs`**: `ShmError`.
7. **`shm/mod.rs`**: `ShmHandler` und `BufferHandler` (SHM-Teil) für `DesktopState`. `GlobalDispatch<WlShm, ()>`. `create_shm_global`.
8. **`shm/buffer_access.rs`**: `with_shm_buffer_contents`.
9. **`xdg_shell/errors.rs`**: `XdgShellError`.
10. **`xdg_shell/types.rs`**: `ManagedWindow` (implementiert `smithay::desktop::Window`), `XdgToplevelSurfaceData`, `XdgPopupSurfaceData` (Smithay-Typen, die via `UserDataMap` an `WlSurface` gehängt werden).
11. **`xdg_shell/handlers.rs`**: `XdgShellHandler` für `DesktopState` implementieren (alle Methoden, Interaktion mit `ManagedWindow`, `Space`, `window_policy_service`).
12. **`xdg_shell/mod.rs`**: `GlobalDispatch<XdgWmBase, ()>`. `create_xdg_shell_global`.
13. **`src/compositor/mod.rs`**: Öffentliche API des Compositor-Moduls definieren (z.B. Initialisierungsfunktionen, Zugriff auf `DesktopState` falls nötig).
14. **Unit-Tests (sehr anspruchsvoll für Compositor-Logik, Fokus auf Handler-Teillogik):**
    - Testen der Zustandsübergänge von `ManagedWindow`.
    - Testen der `SurfaceData`-Manipulation.
    - Mocking von Domain-Services, um Interaktionen mit `window_policy_service` etc. zu testen.
    - Smithay bietet Test-Utilities (`smithay::test_render`, Test-Clients), die evaluiert werden sollten.

---

**Nächste Schritte für `system::compositor` (Skizze für weitere Teile):**

- **`layer_shell`**: Implementierung von `WlrLayerShellHandler` etc. für Panels, Docks.
- **`decoration`**: `KdeDecorationManagerHandler` oder `XdgDecorationHandler`.
- **`output_management`**: `OutputManagerState`-Nutzung, `WlrOutputManagementHandlerV1`.
- **`input_method`**: `InputMethodManagerHandler`.
- **`screencopy`**, `data_device`, `xwayland` etc. analog.
- **`renderer_interface`**: Definition der Traits `FrameRenderer`, `RenderableTexture`.
- **Konkrete Renderer**: Implementierung für DRM/GBM und/oder Winit.

Diese detaillierte Ausarbeitung für den Kern des Compositors und XDG-Shell legt den Grundstein. Die weiteren Module der Systemschicht (`system::input`, `system::dbus_interfaces` etc.) würden mit ähnlicher Tiefe und Struktur spezifiziert werden, wobei jeweils die spezifischen Smithay-Komponenten, Systembibliotheken und Domäneninteraktionen im Fokus stehen.

---

### Modul 2: `system::input`

Zweck: Umfassende Verarbeitung von Benutzereingaben von diversen Geräten (Tastatur, Maus, Touchpad, Touchscreen, Tablets). Dies beinhaltet die Initialisierung und Verwaltung von Eingabegeräten mittels libinput, die Übersetzung roher Eingabeereignisse in für den Compositor und Wayland-Clients verständliche Formate, sowie die Handhabung des Seat-Managements, des Eingabefokus und der Cursor-Darstellung.

Verantwortlichkeiten: Integration mit libinput, Seat-Erstellung und -Verwaltung, Capability-Management (Tastatur, Zeiger, Touch), Fokuslogik, Übersetzung von Keycodes zu Keysyms/UTF-8 mittels xkbcommon, Verarbeitung von Zeigerbewegungen, Klicks, Scroll-Events, Touch-Interaktionen und Basis-Gesten.

Design-Rationale: Kapselung der komplexen Eingabelogik. libinput als Standard für die Geräteabstraktion unter Linux. Enge Verzahnung mit smithay's Seat-Management und Event-Strukturen. Die Logik muss performant und präzise sein, um eine direkte und reaktionsschnelle Benutzerinteraktion zu gewährleisten.

Bestehende Spezifikation: (ausführliche Basis aus Systemschicht Teil 1/4 der Recherche)

#### 2.1. Submodul: `system::input::errors`

**Datei:** `src/input/errors.rs`

- **Enum `InputError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use smithay::input::{SeatError, keyboard::KeyboardError};
    use std::io;
    
    #[derive(Debug, Error)]
    pub enum InputError {
        #[error("Failed to create or configure a seat: {0}")]
        SeatCreationFailed(String), // Generischer Fehler für Seat-Erstellung
        #[error("Failed to add capability '{capability}' to seat '{seat_name}': {source}")]
        CapabilityAdditionFailed {
            seat_name: String,
            capability: String,
            #[source]
            source: Box<dyn std::error::Error + Send + Sync + 'static>, // Kann SeatError oder KeyboardError sein
        },
        #[error("XKB configuration error for seat '{seat_name}': {message}")]
        XkbConfigError { seat_name: String, message: String },
        #[error("Libinput backend initialization or processing error: {0}")]
        LibinputError(String), // Für Fehler direkt von libinput oder dem Smithay-Backend
        #[error("Libinput session error: {0}")] // Für Fehler von der LibinputInterface (open_restricted/close_restricted)
        LibinputSessionError(#[from] io::Error),
        #[error("Seat '{0}' not found.")]
        SeatNotFound(String),
        #[error("Keyboard handle not found for seat '{0}'.")]
        KeyboardHandleNotFound(String),
        #[error("Pointer handle not found for seat '{0}'.")]
        PointerHandleNotFound(String),
        #[error("Touch handle not found for seat '{0}'.")]
        TouchHandleNotFound(String),
        #[error("Failed to initialize input event source in event loop: {0}")]
        EventSourceSetupError(String),
        #[error("Internal error in input system: {0}")]
        InternalError(String),
    }
    ```
    
    - **Begründung:** Diese Fehlerstruktur deckt die in genannten Fehler ab und erweitert sie um spezifischere Fälle für `libinput` und die Ereignisschleifenintegration. Das `CapabilityAdditionFailed` fasst Fehler von `seat.add_keyboard/pointer/touch` generisch zusammen.

#### 2.2. Submodul: `system::input::seat_manager`

**Zweck:** Definiert und verwaltet `SeatState` und `SeatHandler` für Eingabefokus und Capabilities.

**Datei:** `src/input/seat_manager/mod.rs` (oder `state.rs` und `handler.rs`)

- **Struktur `DesktopState` (Erweiterung für Input-Aspekte)**:
    
    Rust
    
    ```
    // In src/compositor/core/state.rs (oder wo DesktopState definiert ist)
    // ... existing fields ...
    // pub seat_state: SeatState<Self>, // Bereits vorhanden
    // pub seat: Seat<Self>,           // Bereits vorhanden
    // pub seat_name: String,          // Bereits vorhanden
    // pub keyboard_data_map: HashMap<String /* seat_name */, XkbKeyboardData>, // Bereits vorhanden
    // pub current_cursor_status: Arc<Mutex<CursorImageStatus>>, // Bereits vorhanden
    
    // Neu oder verfeinert für Fokusmanagement:
    pub pointer_location: Point<f64, Logical>, // Aktuelle globale Zeigerposition
    pub last_active_window_per_workspace: HashMap<WorkspaceId, Weak<ManagedWindow>>, // Für Fokuswiederherstellung
    pub active_input_surface: Option<Weak<WlSurface>>, // Die Oberfläche, die aktuell den logischen Input-Fokus hat (Tastatur, Zeiger, Touch)
                                                       // Dies kann komplexer sein, wenn Zeiger- und Tastaturfokus getrennt sind.
                                                       // Smithay's Seat/KeyboardHandle/PointerHandle verwalten den Fokus auf Protokollebene.
                                                       // Dieses Feld könnte den "logischen" Anwendungsfokus speichern.
    ```
    
- **Implementierung `SeatHandler` für `DesktopState`**: ()
    
    - **`type KeyboardFocus = WlSurface;`**
    - **`type PointerFocus = WlSurface;`**
    - **`type TouchFocus = WlSurface;`**
    - **`fn seat_state(&mut self) -> &mut SeatState<Self>`**: Gibt `&mut self.seat_state` zurück.
    - **`fn focus_changed(&mut self, seat: &Seat<Self>, focused: Option<&Self::KeyboardFocus>)`**:
        1. `tracing::debug!(seat_name = %seat.name(), old_focus = ?self.active_input_surface.as_ref().and_then(|w| w.upgrade()).map(|s| s.id()), new_focus = ?focused.map(|s| s.id()), "SeatHandler::focus_changed (keyboard) called");`
        2. **Wichtig**: Diese Methode wird von `KeyboardHandle::set_focus` aufgerufen. Sie sollte primär dazu dienen, _interne Compositor-Zustände_ zu aktualisieren, die von der Fokusänderung abhängen, nicht umgekehrt den Fokus erneut zu setzen.
        3. Die `KeyboardHandle` sendet bereits `wl_keyboard.enter/leave`.
        4. Aktualisiere `self.active_input_surface` (oder eine spezifischere Variable für Tastaturfokus).
        5. Benachrichtige die Domänenschicht (`workspace_manager_service` oder einen dedizierten `FocusManagerService` in der Domäne) über die Fokusänderung, damit diese z.B. Fenstertitel in der UI aktualisieren oder Policy-Entscheidungen treffen kann.
            
            Rust
            
            ```
            // Beispiel:
            // let domain_window_id = find_domain_window_id_for_surface(focused);
            // block_on(self.workspace_manager_service.notify_focus_changed(domain_window_id));
            ```
            
    - **`fn cursor_image(&mut self, seat: &Seat<Self>, image: CursorImageStatus)`**:
        1. `tracing::trace!(seat_name = %seat.name(), status = ?image, "Cursor-Image-Anfrage erhalten");`
        2. `let mut current_status_guard = self.current_cursor_status.lock().unwrap();`
        3. `*current_status_guard = image;`
        4. Renderer muss benachrichtigt werden, den Cursor neu zu zeichnen. Dies kann über ein Flag geschehen oder indem der Renderer den `current_cursor_status` direkt abfragt. Der Renderer braucht auch die `pointer_location`.
            - Wenn `image == CursorImageStatus::Hidden`, setzt der Renderer den Cursor unsichtbar.
            - Wenn `image == CursorImageStatus::Surface(surface)`, muss der Renderer den Puffer dieser `surface` als Cursor verwenden (Hotspot-Informationen sind in `SurfaceData` oder als Teil von `SurfaceAttributes`).
            - Wenn `image == CursorImageStatus::Named(name)`, muss eine Cursor-Theming-Logik den Namen in eine Textur auflösen (z.B. über `libwayland-cursor` oder eine eigene Implementierung, die XCursor-Themes parst). Diese Logik gehört ggf. in ein Hilfsmodul.
- **Funktion `pub fn create_seat(state: &mut DesktopState, display_handle: &DisplayHandle, seat_name: String) -> Result<Seat<DesktopState>, InputError>`**:
    
    1. `tracing::info!("Erstelle neuen Seat: {}", seat_name);`
    2. `let seat = state.seat_state.new_wl_seat(display_handle, seat_name.clone(), Some(tracing::Span::current()));`
    3. `seat.user_data().insert_if_missing(WaylandSeatData::default);` // Standard-UserData für wl_seat
    4. **Capabilities initialisieren (aber noch nicht setzen, wenn Geräte noch nicht bekannt):**
        - `state.keyboard_data_map.insert(seat_name.clone(), XkbKeyboardData::new(&Default::default())?);` (Mit Default-XKB-Config, wird später aktualisiert).
    5. `tracing::info!("Seat '{}' erfolgreich erstellt. Capabilities werden beim Hinzufügen von Geräten gesetzt.", seat_name);`
    6. Speichere `seat.clone()` in `state.seat` (falls dies der primäre Seat ist) und `state.active_seat_name`.
    7. `Ok(seat)`

#### 2.3. Submodul: `system::input::libinput_handler`

**Zweck:** Initialisiert und konfiguriert das `LibinputInputBackend` und leitet dessen Events an spezifische Handler weiter.

**Datei:** `src/input/libinput_handler/session_interface.rs`

- **Struct `LibinputSessionManager`**:
    
    Rust
    
    ```
    use smithay::backend::session::{Session, Signal as SessionSignal, SessionNotifier};
    use std::rc::Rc; // Oder Arc, wenn thread-übergreifend benötigt
    use calloop::LoopHandle;
    use super::super::core::state::DesktopState; // Pfad anpassen
    
    // Diese Struktur wird die Logik für das Öffnen/Schließen von Geräten kapseln,
    // basierend auf dem gewählten Session-Typ (logind, direct).
    // Für diese Spezifikation ist sie ein Platzhalter.
    pub struct LibinputSessionManager {
        // notifier: SessionNotifier, // Von Smithay's Session
        // session: Rc<dyn Session>, // Oder eine konkrete Session-Implementierung
    }
    
    impl LibinputSessionManager {
        // pub fn new(session: Rc<dyn Session>, loop_handle: LoopHandle<'static, DesktopState>) -> Self {
        //     let notifier = session.notifier(loop_handle).expect("Failed to create session notifier");
        //     Self { session, notifier }
        // }
    }
    
    // Implementiert smithay::backend::input::LibinputInterface
    impl smithay::backend::input::LibinputInterface for LibinputSessionManager {
        fn open_restricted(&mut self, path: &std::path::Path, flags: i32) -> Result<std::os::unix::io::RawFd, std::io::Error> {
            // self.session.open(path, flags)
            // Platzhalter:
            Err(std::io::Error::new(std::io::ErrorKind::Unsupported, "Session Management nicht implementiert"))
        }
        fn close_restricted(&mut self, fd: std::os::unix::io::RawFd) {
            // self.session.close(fd);
            // Platzhalter:
            let _ = fd;
        }
    }
    ```
    
    - **Wichtig:** Die konkrete Implementierung hängt stark vom gewählten `Session`-Typ ab (`smithay::backend::session::direct::DirectSession` für Start ohne `logind`, `smithay::backend::session::logind::LogindSession` für `logind`-Integration). Die `Session` selbst muss korrekt initialisiert und in die `calloop`-Schleife integriert werden (Behandlung von `SessionSignal`). Dies ist ein komplexes Thema für sich und wird hier nur angerissen. Für eine minimale Lauffähigkeit kann eine Dummy-Implementierung verwendet werden, die immer Fehler zurückgibt oder `/dev/input/*` direkt öffnet (was Root-Rechte erfordert).

**Datei:** `src/input/libinput_handler/mod.rs` (oder `backend_init.rs` und `event_dispatcher.rs`)

- **Funktion `pub fn init_libinput_backend<S: Session + 'static>(loop_handle: &LoopHandle<'static, DesktopState>, session: Rc<S>) -> Result<LibinputInputBackend, InputError>`**:
    1. `tracing::info!("Initialisiere Libinput-Backend...");`
    2. `let session_interface = Rc::new(std::cell::RefCell::new(smithay::backend::session::libinput_session_interface(session)));` (Smithay stellt diese Hilfsfunktion bereit).
    3. `let mut libinput_context = libinput::Libinput::new_from_path(session_interface.clone());`
    4. `libinput_context.udev_assign_seat("seat0").map_err(|e| InputError::LibinputError(format!("Zuweisung zu udev seat0 fehlgeschlagen: {:?}", e)))?;`
    5. `let libinput_backend = LibinputInputBackend::new(libinput_context, Some(tracing::Span::current()));`
    6. `tracing::info!("Libinput-Backend erfolgreich initialisiert.");`
    7. `Ok(libinput_backend)`
- **Funktion `pub fn register_libinput_source(loop_handle: &LoopHandle<'static, DesktopState>, libinput_backend: LibinputInputBackend, seat_name: String) -> Result<calloop::Source<LibinputInputBackend>, InputError>`**:
    1. `let libinput_event_source = loop_handle.insert_source(libinput_backend, move |event, _metadata, desktop_state| { // desktop_state ist hier &mut DesktopState // Rufe den zentralen Event-Dispatcher auf super::event_dispatcher::process_input_event(desktop_state, event, &seat_name); }).map_err(|e| InputError::EventSourceSetupError(e.to_string()))?;`
    2. `Ok(libinput_event_source)` (Der Rückgabewert ist hier nicht ganz korrekt, `insert_source` gibt `RegistrationToken` oder `Source` zurück, abhängig von der calloop-Version und Methode). Korrekt wäre, dass der `LibinputInputBackend` selbst die Quelle ist. Die Logik ist, dass der `LibinputInputBackend` in die Schleife eingefügt wird.
- **Datei: `src/input/event_dispatcher.rs`**
    - **Funktion `pub fn process_input_event(desktop_state: &mut DesktopState, event: InputEvent<LibinputInputBackend>, seat_name: &str)`**: ()
        1. `let seat = match desktop_state.seat_state.seats().find(|s| s.name() == seat_name) { Some(s) => s.clone(), None => { tracing::error!("Seat '{}' nicht gefunden für Input-Event.", seat_name); return; } };`
        2. `match event { ... }` wie in detailliert.
            - **`InputEvent::DeviceAdded { device }`**:
                - `tracing::info!("Eingabegerät hinzugefügt: {} (Sys: {})", device.name(), device.sysname());`
                - Wenn `device.has_capability(libinput::DeviceCapability::Keyboard)` und `seat.get_keyboard().is_none()`:
                    - `let kbd_config = XkbConfig::default(); // Oder aus GlobalSettings laden`
                    - `match seat.add_keyboard(kbd_config, 200, 25) { Ok(_) => tracing::info!("Tastatur-Capability zu Seat '{}' hinzugefügt.", seat_name), Err(e) => tracing::error!("Fehler beim Hinzufügen der Tastatur-Capability: {}", e), };`
                    - (XkbKeyboardData muss ggf. aktualisiert werden)
                - Analog für `Pointer` und `Touch`.
            - **`InputEvent::DeviceRemoved { device }`**:
                - `tracing::info!("Eingabegerät entfernt: {}", device.name());`
                - Wenn `device.has_capability(libinput::DeviceCapability::Keyboard)`: `seat.remove_keyboard();`
                - Analog für `Pointer` und `Touch`.

#### 2.4. Submodul: `system::input::keyboard`

**Zweck:** Tastaturereignis-Übersetzung, XKB-Management.

**Datei:** `src/input/keyboard/xkb_config.rs`

- **Struct `XkbKeyboardData`**:
    
    Rust
    
    ```
    use xkbcommon::xkb;
    use smithay::input::keyboard::{KeyboardConfig, ModifiersState as SmithayModifiersState};
    use calloop::TimerHandle;
    use smithay::reexports::wayland_server::protocol::wl_surface::WlSurface;
    use wayland_server::Weak;
    use smithay::utils::Serial;
    
    #[derive(Debug)] // TimerHandle ist nicht Debug
    pub struct XkbKeyboardData {
        pub context: xkb::Context,
        pub keymap: xkb::Keymap,
        pub state: xkb::State,
        pub repeat_timer: Option<TimerHandle>,
        pub repeat_info: Option<(u32 /* keycode */, xkb::Keycode /* xkb keycode */, SmithayModifiersState, std::time::Duration /* delay */, std::time::Duration /* rate */)>,
        pub focused_surface_on_seat: Option<Weak<WlSurface>>,
        pub repeat_key_serial: Option<Serial>,
        // Für Tastenwiederholung: Speichern des xkb-Keycodes, nicht nur des libinput-Keycodes.
    }
    
    impl XkbKeyboardData {
        pub fn new(config: &KeyboardConfig<'_>) -> Result<Self, InputError> {
            let context = xkb::Context::new(xkb::CONTEXT_NO_FLAGS);
            let keymap_name = config.keymap_name.as_deref().unwrap_or("default"); // Bessere Defaults nötig
            let rules = config.rules.as_deref().unwrap_or("evdev");
            let model = config.model.as_deref().unwrap_or("pc105");
            let layout = config.layout.as_deref().unwrap_or("us");
            let variant = config.variant.as_deref();
            let options = config.options.as_deref();
    
            tracing::debug!("Lade XKB Keymap: rules={}, model={}, layout={}, variant={:?}, options={:?}",
                rules, model, layout, variant, options);
    
            let mut keymap_builder = xkb::KeymapCompileArgsBuilder::new();
            keymap_builder.rules(rules);
            keymap_builder.model(model);
            keymap_builder.layout(layout);
            if let Some(v) = variant { keymap_builder.variant(v); }
            if let Some(o) = options { keymap_builder.options(o); }
    
    
            let keymap = match xkb::Keymap::new_from_names(
                &context,
                &keymap_builder.build(), // Verwende den Builder
                xkb::KEYMAP_COMPILE_NO_FLAGS,
            ) {
                Ok(km) => km,
                Err(_) => { // Fallback zu einfacherem Setup
                    tracing::warn!("Komplexe XKB-Keymap '{}' konnte nicht geladen werden, versuche Fallback (us).", keymap_name);
                    let fallback_args = xkb::KeymapCompileArgsBuilder::new()
                        .layout("us").build();
                    xkb::Keymap::new_from_names(&context, &fallback_args, xkb::KEYMAP_COMPILE_NO_FLAGS)
                        .map_err(|_| InputError::XkbConfigError { seat_name: "unknown".into(), message: "Fallback XKB Keymap (us) konnte nicht kompiliert werden".into() })?
                }
            };
    
            let state = xkb::State::new(&keymap);
            Ok(Self {
                context, keymap, state,
                repeat_timer: None, repeat_info: None, focused_surface_on_seat: None, repeat_key_serial: None
            })
        }
    }
    ```
    
- **`Default for KeyboardConfig`**: Wird benötigt, um `XkbKeyboardData::new(&Default::default())` aufrufen zu können.
    
    Rust
    
    ```
    // Ggf. in KeyboardConfig von Smithay oder hier lokal
    // impl Default for KeyboardConfig<'_> { ... }
    ```
    

**Datei:** `src/input/keyboard/key_event_translator.rs`

- **Funktion `pub fn handle_keyboard_key_event(...)`**: ()
    1. Hole `keyboard_handle = seat.get_keyboard().ok_or(...)?.clone();`
    2. Hole `xkb_data = desktop_state.keyboard_data_map.get_mut(seat_name).ok_or(...)?;`
    3. `let keycode = event.key_code();`
    4. `let xkb_keycode = keycode + 8; // Libinput keycodes sind XKB keycodes - 8`
    5. `let key_state_xkb = match event.state() { KeyState::Pressed => xkb::KeyDirection::Down, KeyState::Released => xkb::KeyDirection::Up, };`
    6. `xkb_data.state.update_key(xkb_keycode.into(), key_state_xkb);`
    7. `let smithay_mods_state = SmithayModifiersState { ... /* von xkb_data.state.serialize_mods etc. */ };`
    8. `keyboard_handle.modifiers(event.serial(), smithay_mods_state.clone(), Some(tracing::Span::current()));`
    9. Wenn `event.state() == KeyState::Pressed`:
        - `let serial = event.serial();`
        - `let time = event.time();`
        - `keyboard_handle.key(serial, time, xkb_keycode, KeyState::Pressed, Some(tracing::Span::current()));`
        - **Tastenwiederholung einrichten:**
            - `if let Some(timer) = xkb_data.repeat_timer.take() { timer.cancel(); }`
            - `if keyboard_handle.is_repeating(xkb_keycode) { ... }`
            - `let (delay, rate) = keyboard_handle.repeat_info();`
            - `xkb_data.repeat_info = Some((keycode, xkb_keycode.into(), smithay_mods_state, delay, rate));`
            - `xkb_data.repeat_key_serial = Some(serial);`
            - `let timer_seat_name = seat_name.to_string();`
            - `xkb_data.repeat_timer = Some(desktop_state.loop_handle.insert_timer(delay, move |ds: &mut DesktopState| { ... repeat_logic ... }).expect("Timer creation failed"));`
    10. Wenn `event.state() == KeyState::Released`:
        - `keyboard_handle.key(event.serial(), event.time(), xkb_keycode, KeyState::Released, Some(tracing::Span::current()));`
        - **Tastenwiederholung abbrechen:** `if xkb_data.repeat_info.map_or(false, |(_, rkc, ..)| rkc == xkb_keycode.into()) { ... cancel timer ... }`
- **Tastenwiederholungslogik im Timer-Callback:**
    1. Hole `xkb_data` für `timer_seat_name`.
    2. Wenn `xkb_data.repeat_info` `None` ist oder der Fokus gewechselt hat (prüfe `xkb_data.focused_surface_on_seat`), Timer abbrechen und `return;`.
    3. `let (keycode, xkb_keycode, mods_state, _, rate) = xkb_data.repeat_info.as_ref().unwrap().clone();`
    4. Hole aktuellen `seat` und `keyboard_handle`.
    5. `let new_serial = Serial::now();` // Wichtig: Neuer Serial für wiederholte Events
    6. `keyboard_handle.modifiers(new_serial, mods_state, Some(tracing::Span::current()));`
    7. `keyboard_handle.key(new_serial, current_time_ms(), xkb_keycode, KeyState::Pressed, Some(tracing::Span::current()));`
    8. `xkb_data.repeat_key_serial = Some(new_serial);`
    9. Timer mit `rate` neu planen.

**Datei:** `src/input/keyboard/focus.rs` (ersetzt `focus_handler_keyboard.rs`)

- **Funktion `pub fn set_keyboard_focus(desktop_state: &mut DesktopState, seat_name: &str, surface: Option<&WlSurface>, serial: Serial)`**:
    1. `tracing::debug!(seat = %seat_name, new_focus_surface = ?surface.map(|s| s.id()), ?serial, "Setze Tastaturfokus");`
    2. Hole `seat = desktop_state.seat_state.seats().find(|s| s.name() == seat_name).cloned().ok_or(...)`;
    3. Hole `keyboard = seat.get_keyboard().ok_or(...)?.clone();`
    4. Hole `xkb_data = desktop_state.keyboard_data_map.get_mut(seat_name).ok_or(...)?;`
    5. `let old_focus_wl_surface = xkb_data.focused_surface_on_seat.as_ref().and_then(|w| w.upgrade());`
    6. `if old_focus_wl_surface.as_ref() == surface { tracing::trace!("Tastaturfokus unverändert."); return Ok(()); }`
    7. `keyboard.set_focus(surface, serial, Some(tracing::Span::current()));` // Smithay sendet Enter/Leave
    8. `xkb_data.focused_surface_on_seat = surface.map(|s| s.downgrade());`
    9. // Domänenschicht über Fokusänderung informieren, falls `SeatHandler::focus_changed` nicht ausreicht
        
        Rust
        
        ```
        // let domain_window_id = surface.and_then(|s| find_domain_window_id_for_surface(desktop_state, s));
        // block_on(desktop_state.workspace_manager_service.notify_keyboard_focus_changed(domain_window_id));
        ```
        

#### 2.5. Submodul: `system::input::pointer`

**Zweck:** Maus-/Zeigerereignis-Verarbeitung, Cursor.

**Datei:** `src/input/pointer/mod.rs` (oder `event_translator.rs`, `focus.rs`, `cursor.rs`)

- **Funktion `pub fn handle_pointer_motion_event(...)`**: ()
    1. Hole `pointer_handle = seat.get_pointer().ok_or(...)?;`
    2. `desktop_state.pointer_location += event.delta();` // Einfache Akkumulation, ggf. an Bildschirmgrenzen klemmen.
    3. `let (new_focus_surface_option, surface_local_coords) = find_surface_and_coords_at_global_point(desktop_state, desktop_state.pointer_location);`
    4. `pointer_handle.motion(event.time(), new_focus_surface_option.as_ref(), serial, desktop_state.pointer_location, surface_local_coords, Some(tracing::Span::current()));` (Smithay's `motion` sendet `enter`/`leave` und `motion`).
    5. Aktualisiere `desktop_state.active_input_surface` basierend auf `new_focus_surface_option`.
    6. Renderer Cursor-Position aktualisieren (indem Renderer `desktop_state.pointer_location` liest).
- **Funktion `find_surface_and_coords_at_global_point(desktop_state: &DesktopState, global_pos: Point<f64, Logical>) -> (Option<WlSurface>, Point<f64, Logical>)`**:
    1. Iteriere über `desktop_state.space.elements_under(global_pos)` (Smithay's Space liefert Fenster in korrekter Reihenfolge).
    2. Für jedes `Window` (unsere `ManagedWindow`-Implementierung):
        - Hole `wl_surface = window.wl_surface()`.
        - Prüfe, ob `wl_surface` eine Eingaberegion hat (`SurfaceData::input_region_surface_local`).
        - Transformiere `global_pos` in Oberflächen-lokale Koordinaten.
        - Wenn `global_pos` innerhalb der Eingaberegion (oder der Oberflächengeometrie, falls keine Eingaberegion):
            - Gib `(Some(wl_surface.clone()), surface_local_coords)` zurück.
    3. Sonst: `(None, global_pos)` (oder `(0.0, 0.0)` für lokale Coords).
- **Funktion `handle_pointer_button_event(...)`**: ()
    1. Hole `pointer_handle`.
    2. `pointer_handle.button(event.button(), event.button_state().into(), event.serial(), event.time(), Some(tracing::Span::current()));`
    3. Wenn `event.button_state() == ButtonState::Pressed`:
        - `let (focused_surface_option, _) = find_surface_and_coords_at_global_point(desktop_state, desktop_state.pointer_location);`
        - Wenn `focused_surface_option` `Some(surface_to_focus)`:
            - `set_keyboard_focus(desktop_state, seat_name, Some(&surface_to_focus), event.serial())?;` (Click-to-focus).
            - Hier könnte auch Logik für Fenstermanagement-Aktionen (Move/Resize-Start) basierend auf `surface_to_focus` und Klickposition (relativ zu Dekorationen) ausgelöst werden.
- **Funktion `handle_pointer_axis_event(...)`**: ()
    1. Hole `pointer_handle`.
    2. `pointer_handle.axis(event.time(), event.axis(), event.axis_source().into(), event.axis_value_discrete(), event.axis_value(smithay::utils:: SERIAL_COUNTER_RANGE), event.serial(), Some(tracing::Span::current()));` (Smithay-Signatur anpassen).

#### 2.6. Submodul: `system::input::touch`

**Zweck:** Touch-Ereignis-Verarbeitung.

**Datei:** `src/input/touch/mod.rs` (oder `event_translator.rs`, `focus.rs`)

- **Logik für `handle_touch_down_event`**: ()
    1. Hole `touch_handle = seat.get_touch().ok_or(...)?;`
    2. `let slot = event.slot().ok_or_else(|| InputError::InternalError("Touch down event ohne Slot ID".into()))?;`
    3. `let (focused_surface_option, surface_local_coords) = find_surface_and_coords_at_global_point(desktop_state, event.position_transformed(output_size));`
    4. Wenn `focused_surface_option` `Some(surface)`:
        - Speichere `surface.clone()` als Fokus für diesen `slot` (z.B. in einer `HashMap<TouchSlotId, WlSurface>` in `DesktopState`).
        - `touch_handle.down(event.serial(), event.time(), slot, surface_local_coords, &surface, Some(tracing::Span::current()));`
        - `set_keyboard_focus(desktop_state, seat_name, Some(&surface), event.serial())?;` (Touch-to-focus).
- **Logik für `handle_touch_up_event`**: ()
    1. Hole `touch_handle`. `let slot = event.slot().ok_or(...)`;
    2. `touch_handle.up(event.serial(), event.time(), slot, Some(tracing::Span::current()));`
    3. Entferne Fokus für diesen `slot` aus der internen Map.
- **Logik für `handle_touch_motion_event`**: ()
    1. Hole `touch_handle`. `let slot = event.slot().ok_or(...)`;
    2. Hole die fokussierte Oberfläche für diesen `slot` aus der internen Map.
    3. Transformiere `event.position_transformed(output_size)` in lokale Koordinaten dieser Oberfläche.
    4. `touch_handle.motion(event.serial(), event.time(), slot, surface_local_coords, Some(tracing::Span::current()));`
- **`handle_touch_frame_event`, `handle_touch_cancel_event`**: Rufen entsprechende `touch_handle`-Methoden auf.

#### 2.7. Submodul: `system::input::gestures`

Zweck: Grundlegende Gestenerkennung (Pinch, Swipe) aufbauend auf libinput-Events.

Datei: src/input/gestures/mod.rs

- **Initial:** Für Gesten wie `InputEvent::GesturePinchBegin/Update/End`, `InputEvent::GestureSwipeBegin/Update/End`:
    1. Logge das Ereignis mit `tracing::debug!`.
    2. **Zukünftige Erweiterung:**
        - Eine `GestureState`-Struktur pro aktivem Seat, die laufende Gesten verfolgt.
        - Bei `GestureSwipeBegin`: Starte eine "Swipe"-Geste.
        - Bei `GestureSwipeUpdate`: Akkumuliere `event.dx()`, `event.dy()`. Wenn ein Schwellenwert überschritten wird:
            - Wandle in eine Domänenaktion um (z.B. Workspace wechseln). Rufe z.B. `desktop_state.workspace_manager_service.switch_to_next_workspace().await;`.
        - Bei `GestureSwipeEnd`: Beende die Geste.
        - Ähnlich für Pinch-to-Zoom (könnte z.B. Skalierungsfaktor einer App oder des Desktops beeinflussen - komplexe Interaktion mit Compositor/Anwendung).
- **Abhängigkeiten:** Benötigt Zugriff auf Domänenservices (z.B. `WorkspaceManagerService`).

#### 2.8. Implementierungsschritte `system::input`

1. **Grundgerüst**: Verzeichnisse anlegen, `Cargo.toml` für `libinput`, `xkbcommon` etc.
2. **`errors.rs`**: `InputError` Enum definieren.
3. **`seat_manager/mod.rs`**:
    - `DesktopState`-Felder für Input/Fokus erweitern.
    - `SeatHandler` für `DesktopState` implementieren (`focus_changed`, `cursor_image`).
    - `create_seat` Funktion implementieren.
4. **`libinput_handler/session_interface.rs`**: `LibinputSessionManager` (ggf. mit Dummy-Implementierung für `open/close_restricted` initial).
5. **`libinput_handler/mod.rs`**: `init_libinput_backend`, `register_libinput_source`.
6. **`event_dispatcher.rs`**: `process_input_event` mit `match` für alle relevanten `InputEvent`-Typen und Delegation an Handler in `keyboard`, `pointer`, `touch`. Logik für `DeviceAdded/Removed`.
7. **`keyboard/xkb_config.rs`**: `XkbKeyboardData`-Struct und `new()`-Methode.
8. **`keyboard/key_event_translator.rs`**: `handle_keyboard_key_event` inklusive Tastenwiederholungslogik (Timer-Setup und Callback).
9. **`keyboard/focus.rs`**: `set_keyboard_focus` implementieren.
10. **`pointer/mod.rs`**: `handle_pointer_motion_event` (inkl. `find_surface_and_coords_at_global_point`), `handle_pointer_button_event`, `handle_pointer_axis_event`.
11. **`touch/mod.rs`**: `handle_touch_down/up/motion/frame/cancel_event`. Interne Verwaltung des Touch-Fokus pro Slot.
12. **`gestures/mod.rs`**: Basis-Logging für Gesten-Events.
13. **`src/input/mod.rs`**: Öffentliche API des Input-Moduls definieren (z.B. Initialisierungsfunktionen).
14. **Unit-Tests (anspruchsvoll, erfordert oft Mocking von `Seat`, `KeyboardHandle` etc. oder Integrationstests):**
    - Testen der XKB-Keymap-Erstellung.
    - Testen der Keycode-zu-Keysym/UTF-8-Übersetzung für einige Tasten.
    - Testen der Fokussetzungslogik (Keyboard, Pointer, Touch).
    - Testen der Event-Weiterleitung für verschiedene Eingabetypen.
    - Testen der `find_surface_and_coords_at_global_point`-Logik mit verschiedenen Fensterlayouts.

---

**Nächste Schritte für `system` (Skizze für weitere Module):**

- **`system::dbus_interfaces`**:
    - **Verantwortlichkeiten:** Clients für wichtige Systemdienste (NetworkManager, UPower, logind, Secrets, PolicyKit) und Server für `org.freedesktop.Notifications`.
    - **Technologie:** `zbus` (async).
    - **Struktur:** Pro Dienst ein Submodul (z.B. `dbus_interfaces::upower_client`).
    - **Jedes Client-Submodul:**
        - Definiert Proxy-Structs für die D-Bus-Interfaces des Dienstes.
        - Implementiert Methoden zum Abrufen von Eigenschaften und Aufrufen von Methoden des Dienstes.
        - Implementiert Signal-Handler, um auf D-Bus-Signale zu reagieren und diese in interne System-Events oder Domänenaufrufe zu übersetzen.
        - Fehlerbehandlung mit spezifischem `DBusInterfaceError`.
    - **`notifications_server`**: Implementiert den `org.freedesktop.Notifications`-D-Bus-Service. Leitet eingehende `Notify`-Aufrufe an `domain::user_centric_services::NotificationService::post_notification` weiter. Handhabt `GetCapabilities`, `CloseNotification`, `GetServerInformation`. Sendet `NotificationClosed`, `ActionInvoked` Signale.
- **`system::audio_management`**:
    - **Verantwortlichkeiten:** Steuerung der Systemlautstärke, Auswahl von Audio-Geräten, Verwaltung von Anwendungs-Streams.
    - **Technologie:** `pipewire-rs`.
    - **Struktur:** `client` (Core-Verbindung), `device_manager`, `stream_manager`, `volume_control`.
    - Interaktion mit PipeWire-Registry, um Geräte und Streams zu entdecken.
    - Nutzung von `PWStream` für Lautstärkeregelung etc.
    - Übersetzung von PipeWire-Events in interne System-Events oder Domänenaufrufe.
- **`system::mcp_client`**:
    - **Verantwortlichkeiten:** Sichere Kommunikation mit lokalen/remote MCP-Servern.
    - **Technologie:** `mcp_client_rs`.
    - Nimmt Anweisungen und Kontextdaten von `domain::user_centric_services::ai_interaction` entgegen.
    - Ruft Methoden des `mcp_client_rs::McpClient` auf.
    - Leitet Ergebnisse/Fehler an die Domänenschicht zurück.
    - Verwaltet API-Schlüssel sicher (über `dbus_interfaces::secrets_service`).
- **`system::window_mechanics`**:
    - **Verantwortlichkeiten:** Konkrete Umsetzung der Fenstermanagement-"Mechanik" basierend auf Richtlinien aus `domain::window_management_policy`.
    - Interagiert eng mit `system::compositor::xdg_shell` und `smithay::desktop::Space`.
    - Ruft `domain::window_management_policy_service::calculate_workspace_layout()` auf und wendet die resultierenden Geometrien auf `ManagedWindow`s an (z.B. über deren `send_configure`-Methoden oder direkte Manipulation im `Space`).
    - Implementiert Snapping während interaktiver Move/Resize-Operationen.
    - Koordiniert Client-Side vs. Server-Side Decorations.
- **`system::event_bridge`**:
    - Ein Modul, das `tokio::sync::broadcast` Kanäle oder ähnliche Mechanismen nutzt, um System-interne Events (z.B. "Neues Eingabegerät", "Netzwerkstatus geändert", "Batteriestand niedrig") für andere Systemmodule oder Adapter zur Domänenschicht bereitzustellen.
- **`system::power_management`**:
    - Interagiert mit `wlr-output-power-management-unstable-v1` (serverseitig im Compositor implementiert).
    - Interagiert mit `system::dbus_interfaces::logind` für Suspend/Hibernate.
    - Setzt DPMS-Modi für Outputs basierend auf `domain::global_settings_service` und Benutzeraktivität (`domain::common_events::UserActivityDetectedEvent`).

Diese detaillierte Ausarbeitung für `system::input` und die Skizzen für die weiteren Module sollten eine solide Basis für die Implementierung der gesamten Systemschicht bilden. Jedes dieser Module erfordert eine ähnliche Tiefe der Spezifikation, insbesondere bei der Interaktion mit externen Bibliotheken und Protokollen.

Kurzfassung: Rust (Edition 2021+), Nutzung von novade-core und novade-domain, zbus für D-Bus-Interaktionen, smithay (wo relevant für Compositor-Interaktionen), tokio (oft von zbus benötigt), thiserror für Fehler.

**Cargo.toml für `novade-system` (relevante Ergänzungen für D-Bus):**

Ini, TOML

```
[dependencies]
# ... (bestehende Abhängigkeiten wie novade-core, novade-domain, smithay, etc.) ...
zbus = { version = "3.15", default-features = false, features = ["tokio"] } # Aktuelle zbus 4.x Version prüfen, tokio feature ist wichtig
serde = { version = "1.0.197", features = ["derive"] }
serde_json = "1.0.115" # Falls einige D-Bus Properties/Methoden JSON verwenden
tracing = "0.1.40"
thiserror = "1.0.58"
async-trait = "0.1.79"
tokio = { version = "1.37.0", features = ["sync", "rt", "macros"] }
# Ggf. spezifische Crates für Freedesktop-Spezifikationen, falls zbus nicht alles abdeckt
# oder für komplexere Typen (z.B. `dbus-crossroads` für Server-Seite, obwohl zbus auch Server kann)
```

---

### Modul 3: `system::dbus_interfaces`

Zweck: Implementierung von Schnittstellen zur Interaktion mit etablierten System-D-Bus-Diensten sowie Bereitstellung eigener D-Bus-Schnittstellen, wo dies von der Architektur vorgesehen ist (z.B. org.freedesktop.Notifications).

Verantwortlichkeiten:

- Erstellen und Verwalten von D-Bus-Verbindungen (Session und System Bus).
- Implementierung von Clients (Proxies) für externe D-Bus-Dienste wie NetworkManager, UPower, logind, org.freedesktop.secrets, PolicyKit.
- Abrufen von Eigenschaften, Aufrufen von Methoden und Abonnieren von Signalen dieser Dienste.
- Übersetzung von D-Bus-Daten und -Signalen in interne System-Events oder Aufrufe an die Domänenschicht.
- Implementierung von D-Bus-Server-Objekten für Dienste, die NovaDE selbst bereitstellt (z.B. `org.freedesktop.Notifications`). **Design-Rationale:** Kapselung aller D-Bus-spezifischen Logik. Verwendung von `zbus` als moderne, asynchrone D-Bus-Bibliothek in Rust. Klare Trennung zwischen D-Bus-Protokoll-Interaktion und der Verarbeitungslogik in anderen System- oder Domänenmodulen.

#### 3.1. Submodul: `system::dbus_interfaces::common`

**Zweck:** Definition gemeinsamer Typen, Fehler und Hilfsfunktionen für alle D-Bus-Interaktionen.

**Datei:** `src/dbus_interfaces/common/errors.rs`

- **Enum `DBusInterfaceError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use zbus::Error as ZBusError;
    use zbus::names::ErrorName;
    
    #[derive(Debug, Error)]
    pub enum DBusInterfaceError {
        #[error("D-Bus connection failed: {0}")]
        ConnectionFailed(#[from] ZBusError), // Direkter Fehler von zbus beim Verbindungsaufbau
        #[error("Failed to create D-Bus proxy for service '{service}' path '{path}' interface '{interface}': {source}")]
        ProxyCreationFailed {
            service: String,
            path: String,
            interface: String,
            #[source]
            source: ZBusError,
        },
        #[error("D-Bus method call '{method}' on '{interface}' failed: {source}")]
        MethodCallFailed {
            method: String,
            interface: String,
            #[source]
            source: ZBusError,
        },
        #[error("Failed to get D-Bus property '{property}' from '{interface}': {source}")]
        PropertyGetFailed {
            property: String,
            interface: String,
            #[source]
            source: ZBusError,
        },
        #[error("Failed to set D-Bus property '{property}' on '{interface}': {source}")]
        PropertySetFailed {
            property: String,
            interface: String,
            #[source]
            source: ZBusError,
        },
        #[error("Failed to subscribe to D-Bus signal '{signal}' from '{interface}': {source}")]
        SignalSubscriptionFailed {
            signal: String,
            interface: String,
            #[source]
            source: ZBusError,
        },
        #[error("Received D-Bus error reply: {name} - {body}")]
        DBusErrorReply {
            name: ErrorName<'static>, // 'static hier, da ErrorName oft geklont wird
            body: String, // Oft der Message-Teil des D-Bus-Fehlers
        },
        #[error("Type conversion error during D-Bus operation: {0}")]
        TypeConversionError(String), // Wenn z.B. ein zvariant nicht in den erwarteten Rust-Typ passt
        #[error("Required D-Bus service '{service}' is not available or not activatable.")]
        ServiceUnavailable { service: String },
        #[error("D-Bus object path '{0}' not found for service.")]
        ObjectPathNotFound(String),
        #[error("D-Bus interface '{0}' not found on object.")]
        InterfaceNotFound(String),
        #[error("An internal error occurred in a D-Bus interface: {0}")]
        InternalError(String),
    }
    
    // Hilfsfunktion, um zbus::Error in DBusErrorReply zu konvertieren, falls es ein D-Bus-Fehler war
    impl From<ZBusError> for DBusInterfaceError {
        fn from(err: ZBusError) -> Self {
            if let ZBusError::MethodError(name, body, _) = err {
                DBusInterfaceError::DBusErrorReply { name: name.into_static(), body: body.unwrap_or_default() }
            } else {
                // Für andere ZBusError-Typen, die nicht MethodError sind,
                // könnte man spezifischere Mappings oder eine generische Variante haben.
                // Hier als Beispiel: fallback auf MethodCallFailed (kontextabhängig anpassen)
                DBusInterfaceError::MethodCallFailed {
                    method: "unknown".to_string(),
                    interface: "unknown".to_string(),
                    source: err,
                }
            }
        }
    }
    ```
    
    - **Begründung:** Fasst generische D-Bus-Fehler und spezifischere Fälle wie `ProxyCreationFailed` oder `ServiceUnavailable` zusammen. Die `From<ZBusError>` Implementierung hilft, `zbus`-Fehler direkt in benutzerdefinierte Fehler zu überführen.

**Datei:** `src/dbus_interfaces/common/connection_manager.rs`

- **Struct `DBusConnectionManager`**:
    
    Rust
    
    ```
    use zbus::{Connection, ConnectionBuilder, Address, Transport};
    use super::errors::DBusInterfaceError;
    use std::sync::{Arc, OnceLock}; // OnceLock für Singleton-Verbindungen
    use tokio::sync::Mutex; // Mutex, falls die Verbindung modifiziert werden kann (selten)
    
    static SESSION_BUS: OnceLock<Arc<Connection>> = OnceLock::new();
    static SYSTEM_BUS: OnceLock<Arc<Connection>> = OnceLock::new();
    
    #[derive(Debug, Clone)]
    pub struct DBusConnectionManager;
    
    impl DBusConnectionManager {
        /// Stellt die Session-Bus-Verbindung her (oder gibt die bestehende zurück).
        pub async fn session_bus() -> Result<Arc<Connection>, DBusInterfaceError> {
            if let Some(conn) = SESSION_BUS.get() {
                return Ok(conn.clone());
            }
            let conn = ConnectionBuilder::session()?
                .build()
                .await?;
            let arc_conn = Arc::new(conn);
            match SESSION_BUS.set(arc_conn.clone()) {
                Ok(_) => Ok(arc_conn),
                Err(existing_conn_arc) => Ok(existing_conn_arc.clone()), // Rennen gewonnen von anderem Thread
            }
        }
    
        /// Stellt die System-Bus-Verbindung her (oder gibt die bestehende zurück).
        pub async fn system_bus() -> Result<Arc<Connection>, DBusInterfaceError> {
            if let Some(conn) = SYSTEM_BUS.get() {
                return Ok(conn.clone());
            }
            let conn = ConnectionBuilder::system()?
                .build()
                .await?;
            let arc_conn = Arc::new(conn);
            match SYSTEM_BUS.set(arc_conn.clone()) {
                Ok(_) => Ok(arc_conn),
                Err(existing_conn_arc) => Ok(existing_conn_arc.clone()),
            }
        }
    
        /// Erstellt einen zbus Proxy.
        pub async fn create_proxy<'a, T: zbus::ProxyDefault + Send + Sync + 'static>(
            connection: Arc<Connection>,
            destination: &'static str, // Muss 'static sein für einige Proxy-Konstrukte
            path: &'static str,
        ) -> Result<T, DBusInterfaceError> {
            T::builder(&connection)
                .destination(destination)?
                .path(path)?
                .build()
                .await
                .map_err(|e| DBusInterfaceError::ProxyCreationFailed {
                    service: destination.to_string(),
                    path: path.to_string(),
                    interface: T::INTERFACE.unwrap_or("unknown").to_string(), // T::INTERFACE ist Option<&'static str>
                    source: e,
                })
        }
    }
    ```
    
    - **Zweck:** Stellt sicher, dass nur eine Verbindung pro Bus-Typ (Session/System) besteht und verwaltet wird (`OnceLock` für Singleton-Pattern). Bietet eine Hilfsfunktion zum Erstellen von Proxies.
    - **Methoden:** `session_bus() -> Result<Arc<Connection>>`, `system_bus() -> Result<Arc<Connection>>`, `create_proxy<T>(...)`.
    - **Zustand:** Die `OnceLock`-statischen Variablen halten die globalen Verbindungen.

**Datei:** `src/dbus_interfaces/common/mod.rs`

- `pub mod errors;`
- `pub mod connection_manager;`
- `pub use errors::DBusInterfaceError;`
- `pub use connection_manager::DBusConnectionManager;`

#### 3.2. Submodul: `system::dbus_interfaces::upower_client`

Zweck: Client für den org.freedesktop.UPower Dienst zur Abfrage von Energieinformationen (Batteriestatus, Deckelzustand etc.).

Interaktion mit Domäne: Sendet UPowerEvent (neu zu definierendes Event in system::event_bridge oder direkt an einen Domänen-Service) an die Domänenschicht (z.B. domain::power_management_policy oder einen allgemeinen SystemStatusService).

**Datei:** `src/dbus_interfaces/upower_client/types.rs`

- **Enums (Spiegelung der D-Bus-Typen von UPower):**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize}; // Für Events
    use zbus::zvariant::Type; // Für D-Bus Typ-Annotationen
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Type, Serialize, Deserialize)]
    #[repr(u32)] // Entspricht den UPower-Enum-Werten
    pub enum PowerDeviceType {
        Unknown = 0,
        LinePower = 1,
        Battery = 2,
        Ups = 3,
        Monitor = 4,
        Mouse = 5,
        Keyboard = 6,
        Pda = 7,
        Phone = 8,
        MediaPlayer = 9,
        Tablet = 10,
        Computer = 11,
    }
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Type, Serialize, Deserialize)]
    #[repr(u32)]
    pub enum PowerState {
        Unknown = 0,
        Charging = 1,
        Discharging = 2,
        Empty = 3,
        FullyCharged = 4,
        PendingCharge = 5,
        PendingDischarge = 6,
    }
    
    #[derive(Debug, Clone, PartialEq, Type, Serialize, Deserialize)]
    pub struct PowerDeviceDetails {
        pub native_path: String, // z.B. /sys/class/power_supply/BAT0
        pub vendor: String,
        pub model: String,
        pub serial: String,
        pub update_time: u64, // Unix-Timestamp
        pub device_type: PowerDeviceType,
        pub online: bool,
        pub energy: f64, // Wh (Watt-hours)
        pub energy_empty: f64,
        pub energy_full: f64,
        pub energy_full_design: f64,
        pub energy_rate: f64, // Watt (aktuelle Leistung)
        pub voltage: f64,
        pub time_to_empty: u64, // Sekunden
        pub time_to_full: u64, // Sekunden
        pub percentage: f64, // 0.0 - 100.0
        pub temperature: f64, // Celsius
        pub is_rechargeable: bool,
        pub capacity: f64, // Prozentsatz der Design-Kapazität
        pub technology: u32, // Enum UPowerTechnology
        pub warning_level: u32, // Enum UPowerWarningLevel
        pub state: PowerState,
        pub icon_name: String,
        // Weitere Felder nach Bedarf aus `org.freedesktop.UPower.Device`
    }
    ```
    
- **Event-Struktur (für `system::event_bridge`):**
    
    Rust
    
    ```
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum UPowerEvent {
        DeviceAdded(String /* object_path */),
        DeviceRemoved(String /* object_path */),
        DeviceChanged(String /* object_path */), // Wenn Eigenschaften eines Geräts sich ändern
        LidStateChanged(bool /* is_closed */),
        OnBatteryChanged(bool /* is_on_battery */),
        PowerSupplyChanged, // Generelles Event, wenn sich etwas an der Stromversorgung ändert
    }
    ```
    

**Datei:** `src/dbus_interfaces/upower_client/proxies.rs`

- **zbus Proxy-Definitionen (manuell oder mit `zbus::proxy` Makro):**
    - **`UPowerProxy` für `org.freedesktop.UPower` auf `/org/freedesktop/UPower`**:
        
        Rust
        
        ```
        use zbus::proxy;
        use zbus::zvariant::{OwnedObjectPath, Value};
        use super::types::PowerDeviceDetails; // Annahme: PowerDeviceDetails ist als Value deserialisierbar
        
        #[proxy(
            interface = "org.freedesktop.UPower",
            default_service = "org.freedesktop.UPower",
            default_path = "/org/freedesktop/UPower"
        )]
        trait UPower {
            fn enumerate_devices(&self) -> zbus::Result<Vec<OwnedObjectPath>>;
            fn get_display_device(&self) -> zbus::Result<OwnedObjectPath>;
            fn get_critical_action(&self) -> zbus::Result<String>;
        
            #[zbus(property)]
            fn lid_is_closed(&self) -> zbus::Result<bool>;
            #[zbus(property)]
            fn lid_is_present(&self) -> zbus::Result<bool>;
            #[zbus(property)]
            fn on_battery(&self) -> zbus::Result<bool>;
            #[zbus(property)]
            fn daemon_version(&self) -> zbus::Result<String>;
        
            #[zbus(signal)]
            fn device_added(&self, device_path: OwnedObjectPath) -> zbus::Result<()>;
            #[zbus(signal)]
            fn device_removed(&self, device_path: OwnedObjectPath) -> zbus::Result<()>;
            // Weitere Signale: LidIsClosed, LidIsOpened, DeviceChanged (oft als PropertiesChanged auf Device-Interface)
        }
        ```
        
    - **`UPowerDeviceProxy` für `org.freedesktop.UPower.Device` (dynamischer Pfad)**:
        
        Rust
        
        ```
        #[proxy(
            interface = "org.freedesktop.UPower.Device",
            default_service = "org.freedesktop.UPower"
            // default_path wird dynamisch gesetzt
        )]
        trait UPowerDevice {
            fn refresh(&self) -> zbus::Result<()>;
            fn get_history(&self, type_: &str, timespan: u32, resolution: u32) -> zbus::Result<Vec<(u32, f64, u32)>>; // Array of (time, value, state)
            fn get_statistics(&self, type_: &str) -> zbus::Result<Vec<(f64, f64)>>; // Array of (value, accuracy)
        
            // Alle Eigenschaften aus PowerDeviceDetails als #[zbus(property)]
            #[zbus(property)] fn native_path(&self) -> zbus::Result<String>;
            #[zbus(property)] fn vendor(&self) -> zbus::Result<String>;
            #[zbus(property)] fn model(&self) -> zbus::Result<String>;
            #[zbus(property)] fn serial(&self) -> zbus::Result<String>;
            // ... alle weiteren Properties aus PowerDeviceDetails ...
            #[zbus(property)] fn state(&self) -> zbus::Result<super::types::PowerState>;
            #[zbus(property)] fn type_(&self) -> zbus::Result<super::types::PowerDeviceType>; // type ist ein Keyword
            #[zbus(property, name = "Type")] // Expliziter Name für D-Bus
            fn device_type_prop(&self) -> zbus::Result<super::types::PowerDeviceType>;
        
        
            // Oft wird `org.freedesktop.DBus.Properties.PropertiesChanged` Signal auf diesem Interface verwendet
        }
        ```
        
    - **Wichtig:** `zbus` erfordert, dass Enums, die direkt als D-Bus-Typen verwendet werden (wie `PowerState`, `PowerDeviceType`), `TryFrom<Value<'a>>` und `Into<Value<'static>>` implementieren, oder `zbus::zvariant::Type` und `serde` für automatische Konvertierung. `#[repr(u32)]` und `Type` sollten hier helfen.

**Datei:** `src/dbus_interfaces/upower_client/service.rs` (oder `client.rs`)

- **Struct `UPowerClientService`**:
    - **Felder:**
        - `connection: Arc<Connection>`
        - `proxy: UPowerProxy<'static>` (Proxy benötigt eine Lebenszeit, oft an die Connection gebunden)
        - `device_proxies: Arc<tokio::sync::Mutex<HashMap<OwnedObjectPath, UPowerDeviceProxy<'static>>>>`
        - `event_publisher: tokio::sync::broadcast::Sender<UPowerEvent>` (aus `system::event_bridge`)
        - `is_initialized: Arc<tokio::sync::watch::Sender<bool>>` (um Signale erst nach Initialisierung zu verarbeiten)
    - **Konstruktor `pub async fn new(event_publisher: tokio::sync::broadcast::Sender<UPowerEvent>) -> Result<Self, DBusInterfaceError>`**:
        1. `connection = DBusConnectionManager::system_bus().await?;`
        2. `proxy = UPowerProxy::new(&connection).await?;`
        3. Initialisiert `device_proxies` als leere Map.
        4. Initialisiert `is_initialized` Sender.
        5. Gibt `Self` zurück.
    - **Methode `pub async fn initialize_and_listen(&self) -> Result<(), DBusInterfaceError>`**:
        1. Ruft `proxy.enumerate_devices().await?` auf, um initiale Geräte zu bekommen.
        2. Für jedes Gerät: `self.add_device_proxy(device_path).await?;`
        3. Abonniert Signale des `UPowerProxy`:
            - `device_added_stream = proxy.receive_device_added().await?;` -> `self.handle_device_added(path).await;`
            - `device_removed_stream = proxy.receive_device_removed().await?;` -> `self.handle_device_removed(path).await;`
            - (Signale für LidIsClosed, LidIsOpened, OnBatteryChanged auf dem UPower-Interface, falls vorhanden, oder über PropertiesChanged)
        4. Abonniert `org.freedesktop.DBus.Properties.PropertiesChanged` auf dem `UPowerProxy` für Änderungen an `LidIsClosed`, `OnBattery`.
            
            Rust
            
            ```
            // let properties_changed_stream = self.proxy.receive_properties_changed().await?;
            // tokio::spawn(handle_property_changes_stream(properties_changed_stream, self.event_publisher.clone()));
            ```
            
        5. Setzt `*self.is_initialized.send(true).is_ok();`.
        6. Startet eine `tokio::task` für jeden Signal-Stream, der die Events verarbeitet.
    - **Private Methode `async fn add_device_proxy(&self, device_path: OwnedObjectPath) -> Result<(), DBusInterfaceError>`**:
        1. `let device_proxy = UPowerDeviceProxy::builder(&self.connection).path(device_path.clone())?.build().await?;`
        2. Abonniert `org.freedesktop.DBus.Properties.PropertiesChanged` auf `device_proxy`.
            
            Rust
            
            ```
            // let device_props_stream = device_proxy.receive_properties_changed().await?;
            // tokio::spawn(handle_device_property_changes_stream(device_path.clone(), device_props_stream, self.event_publisher.clone()));
            ```
            
        3. `self.device_proxies.lock().await.insert(device_path, device_proxy);`
        4. `self.event_publisher.send(UPowerEvent::DeviceAdded(device_path.into_inner().into_string())).ok();`
    - **Private Methode `async fn handle_device_added(&self, device_path: OwnedObjectPath)`**: Ruft `add_device_proxy`.
    - **Private Methode `async fn handle_device_removed(&self, device_path: OwnedObjectPath)`**: Entfernt aus `device_proxies`, sendet `DeviceRemoved` Event.
    - **Öffentliche Methoden zum Abrufen von Daten (Beispiele):**
        - `pub async fn get_all_device_details(&self) -> Result<Vec<PowerDeviceDetails>, DBusInterfaceError>`: Iteriert `device_proxies`, ruft alle Properties jedes Geräts ab und konstruiert `PowerDeviceDetails`.
        - `pub async fn is_lid_closed(&self) -> Result<bool, DBusInterfaceError>`: Ruft `proxy.lid_is_closed().await?`.
        - `pub async fn is_on_battery(&self) -> Result<bool, DBusInterfaceError>`: Ruft `proxy.on_battery().await?`.
- **Signal-Handler-Tasks (Beispiel für `PropertiesChanged` auf UPowerProxy):**
    
    Rust
    
    ```
    // async fn handle_upower_property_changes_stream(
    //     mut stream: zbus::fdo::PropertiesChangedStream<'_>, // Korrekter Stream-Typ
    //     event_publisher: tokio::sync::broadcast::Sender<UPowerEvent>,
    // ) {
    //     while let Some(signal) = stream.next().await {
    //         if let Ok(args) = signal.args() {
    //             if args.interface_name() == "org.freedesktop.UPower" {
    //                 if args.changed_properties().contains_key("LidIsClosed") {
    //                     if let Some(Value::Bool(closed)) = args.changed_properties().get("LidIsClosed") {
    //                         event_publisher.send(UPowerEvent::LidStateChanged(*closed)).ok();
    //                     }
    //                 }
    //                 if args.changed_properties().contains_key("OnBattery") {
    //                    // ... ähnlich ...
    //                    event_publisher.send(UPowerEvent::PowerSupplyChanged).ok(); // Generisches Event
    //                 }
    //             }
    //         }
    //     }
    // }
    ```
    

**Datei:** `src/dbus_interfaces/upower_client/mod.rs`

- `pub mod types;`
- `pub mod proxies;` // Ist oft intern, wenn Service die Fassade ist
- `pub mod service;`
- `pub use service::UPowerClientService;`
- `pub use types::{PowerDeviceDetails, PowerDeviceType, PowerState, UPowerEvent};`

#### 3.3. Implementierungsschritte `system::dbus_interfaces::upower_client`

1. **Grundgerüst**: Verzeichnis, `mod.rs`.
2. **`types.rs`**: `PowerDeviceType`, `PowerState`, `PowerDeviceDetails`, `UPowerEvent` definieren. `serde` und `zbus::zvariant::Type` implementieren.
3. **`proxies.rs`**: `UPowerProxy` und `UPowerDeviceProxy` mit `#[zbus::proxy]` definieren. Alle relevanten Methoden und Properties aus der UPower-Spezifikation aufnehmen.
4. **`service.rs`**: `UPowerClientService`-Struktur definieren.
    - `new()`-Konstruktor: D-Bus-Verbindung herstellen, Hauptproxy erstellen.
    - `initialize_and_listen()`: Initiale Geräte laden, Signal-Handler für `DeviceAdded`/`Removed` und `PropertiesChanged` (sowohl auf Hauptproxy als auch auf Geräteproxies) einrichten. Diese Handler laufen in eigenen `tokio::spawn`-Tasks.
    - `add_device_proxy()`: Erstellt, speichert und abonniert Signale für einen Geräteproxy.
    - Öffentliche Getter-Methoden (`get_all_device_details`, `is_lid_closed`, etc.) implementieren, die Properties von den Proxies abrufen.
5. **Event-Publishing**: Sicherstellen, dass bei relevanten Signalempfängen oder Zustandsänderungen die definierten `UPowerEvent`s über den `event_publisher` gesendet werden.
6. **Fehlerbehandlung**: Alle `zbus::Error`-Fälle in `DBusInterfaceError` umwandeln und propagieren.
7. **Unit-/Integrationstests**:
    - **Schwierig ohne laufenden D-Bus-Dienst.** Man könnte `zbus::MockConnection` verwenden, um D-Bus-Interaktionen zu mocken.
    - Testen der Proxy-Generierung.
    - Testen der Property-Abfrage-Logik gegen einen gemockten Dienst.
    - Testen der Signal-Verarbeitung (indem man Signale im Mock simuliert).
    - Testen der korrekten Event-Erzeugung.

---

**Nächste Schritte für `system::dbus_interfaces` (Skizze für weitere Dienste):**

- **`logind_client`**:
    - **Zweck:** Interaktion mit `org.freedesktop.login1` für Sitzungsmanagement (Sperren, Suspend, Shutdown-Signale).
    - **Proxies:** `LogindManagerProxy` (`/org/freedesktop/login1`), `LogindSessionProxy` (`/org/freedesktop/login1/session/self`).
    - **Signale:** `PrepareForShutdown`, `PrepareForSleep`, `Lock`, `Unlock` auf Session-Objekt.
    - **Events:** `LogindEvent::PrepareForShutdown(bool is_reboot)`, `LogindEvent::PrepareForSleep(bool is_suspending)`, `LogindEvent::SessionLocked`, `LogindEvent::SessionUnlocked`.
    - **Methoden:** `LockSession()`, `UnlockSession()`, `CanSuspend()`, `Suspend(bool interactive)`, etc. an Domäne weiterleiten oder von dort empfangen.
- **`network_manager_client`**:
    - **Zweck:** Abfrage von Netzwerkstatus, verfügbaren Verbindungen, Signalstärke (WLAN), IP-Adressen.
    - **Proxies:** `NetworkManagerProxy`, `NMDeviceProxy`, `NMActiveConnectionProxy`, `NMAccessPointProxy`, etc.
    - **Signale:** `StateChanged`, `DeviceAdded/Removed`, `PropertiesChanged` auf verschiedenen Objekten.
    - **Events:** `NetworkEvent::ConnectivityChanged(ConnectivityState)`, `NetworkEvent::WifiDeviceAdded/Removed`, `NetworkEvent::WiredDeviceAdded/Removed`, `NetworkEvent::ActiveConnectionChanged { ... }`.
    - **Typen:** `ConnectivityState` (Disconnected, Connecting, Limited, Full), `NetworkDeviceDetails`, `ActiveConnectionDetails`.
- **`notifications_server`**:
    - **Zweck:** Implementierung des `org.freedesktop.Notifications` D-Bus-Servers.
    - **Technologie:** `zbus` Server-Fähigkeiten (`#[dbus_interface(...)]` auf einem Struct).
    - **Methoden (D-Bus):** `Notify`, `CloseNotification`, `GetCapabilities`, `GetServerInformation`.
    - **Interaktion:** Leitet `Notify`-Aufrufe an `domain::user_centric_services::NotificationService::post_notification` weiter.
    - **Signale (D-Bus):** `NotificationClosed`, `ActionInvoked`. Reagiert auf `NotificationDismissedEvent` und `NotificationActionInvokedEvent` aus der Domäne, um diese D-Bus-Signale zu senden.
- **`secrets_service_client`**:
    - **Zweck:** Client für `org.freedesktop.secrets` zum sicheren Speichern und Abrufen von Geheimnissen (z.B. API-Keys für `mcp_client`).
    - **Proxies:** `SecretServiceProxy`, `SecretCollectionProxy`, `SecretItemProxy`.
    - **Methoden:** `CreateCollection`, `CreateItem`, `GetSecret`, `SearchItems`, `Unlock`.
    - **Interaktion:** Wird von anderen Systemmodulen (z.B. `mcp_client`) oder ggf. Domänendiensten genutzt. UI-Interaktion für Prompts (Unlock) wird oft vom Secret Service selbst gehandhabt (z.B. GNOME Keyring).
- **`policykit_client`**:
    - **Zweck:** Client für `org.freedesktop.PolicyKit1.Authority` zur Autorisierung privilegierter Aktionen.
    - **Proxy:** `PolicyKitAuthorityProxy`.
    - **Methode:** `CheckAuthorization`.
    - **Interaktion:** Wird von System- oder Domänenmodulen aufgerufen, bevor eine privilegierte Aktion ausgeführt wird. UI-Interaktion für Passwortabfragen wird vom PolicyKit-Agenten des Systems gehandhabt.
- **`xdg_desktop_portal_handler`**:
    - **Zweck:** Dies ist kein Client, sondern die Backend-Logik, die von den XDG Desktop Portal D-Bus-Server-Implementierungen (die NovaDE bereitstellt) aufgerufen wird.
    - **Schnittstellen:** Definiert Traits oder konkrete Methoden, die von den Portal-D-Bus-Objekten aufgerufen werden.
    - **Beispiele:**
        - Für `org.freedesktop.portal.FileChooser`: `async fn open_file_dialog(...) -> Result<Vec<PathBuf>, PortalError>`. Interagiert mit der UI-Schicht, um den Dialog anzuzeigen.
        - Für `org.freedesktop.portal.Screenshot`: `async fn take_screenshot(interactive: bool, region: Option<RectInt>) -> Result<PathBuf, PortalError>`. Interagiert mit `system::compositor::screencopy`.
        - Für `org.freedesktop.portal.ScreenCast`: Interagiert mit Compositor und PipeWire.
    - **Wichtig:** Die eigentlichen D-Bus-Server-Objekte für die Portale werden typischerweise in einem separaten Prozess oder zumindest einem dedizierten D-Bus-Dienst innerhalb von NovaDE laufen. Dieses Modul hier liefert die Logik, die diese D-Bus-Methoden ausführt.

Diese detaillierte Ausarbeitung für `system::dbus_interfaces::upower_client` und die Skizzen für die weiteren Dienste legen einen klaren Pfad für die Implementierung der D-Bus-Interaktionen fest. Jedes Client-Modul erfordert sorgfältige Definition der Proxy-Interfaces und die Übersetzung der D-Bus-spezifischen Daten und Signale in die internen Strukturen und Events von NovaDE.

---

### Modul 3: `system::dbus_interfaces` (Fortsetzung)

#### 3.4. Submodul: `system::dbus_interfaces::logind_client`

Zweck: Client für den org.freedesktop.login1 Dienst zur Abfrage und Steuerung von Sitzungsinformationen und Systemzuständen (Suspend, Shutdown).

Interaktion mit Domäne: Sendet LogindEvents an die Domänenschicht (z.B. domain::power_management_policy, domain::common_events). Empfängt Befehle (z.B. LockSession) von der Domäne oder UI über die Domäne.

**Datei:** `src/dbus_interfaces/logind_client/types.rs`

- **Event-Struktur (für `system::event_bridge` oder direkt an Domänen-Services):**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    use crate::dbus_interfaces::common::DBusObjectPath; // Typalias für String oder OwnedObjectPath
    
    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
    pub enum LogindPowerOperation {
        Suspend,
        Hibernate,
        HybridSleep,
        SuspendThenHibernate,
        Reboot,
        PowerOff,
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum LogindEvent {
        PrepareForShutdown(bool /* is_reboot */),
        PrepareForSleep(bool /* is_suspending_to_ram_not_disk */), // true für Suspend, false für Hibernate
        SessionLocked(DBusObjectPath /* session_id */),
        SessionUnlocked(DBusObjectPath /* session_id */),
        SessionRemoved(DBusObjectPath /* session_id */),
        SystemIdleHintChanged(bool /* is_idle */), // Falls logind IdleHint sendet
    }
    
    #[derive(Debug, Clone, Type, Serialize, Deserialize, PartialEq)] // zbus::zvariant::Type
    pub struct SessionDetails {
        pub id: String, // Session ID
        pub user_id: u32,
        pub user_name: String,
        pub seat_id: String,
        pub seat_path: DBusObjectPath,
        pub vtnr: u32,
        pub display: String, // z.B. ":0"
        pub remote: bool,
        pub remote_host: String,
        pub remote_user: String,
        pub service: String, // z.B. "gdm-password", "tty"
        pub desktop: String, // z.B. "NovaDE"
        pub scope: String, // z.B. "system-user"
        pub leader_pid: u32,
        pub audit_session_id: u32,
        pub session_class: String, // z.B. "user"
        pub session_type: String, // z.B. "wayland", "x11"
        pub active: bool,
        pub state: String, // z.B. "active", "online", "closing"
        pub idle_hint: bool,
        pub idle_since_hint_usec: u64, // Mikrosekunden
        pub locked_hint: bool,
    }
    ```
    

**Datei:** `src/dbus_interfaces/logind_client/proxies.rs`

- **`LogindManagerProxy` für `org.freedesktop.login1.Manager` auf `/org/freedesktop/login1`**:
    
    Rust
    
    ```
    use zbus::{proxy, zvariant::{OwnedObjectPath, Type, Value, Dict}};
    use super::types::SessionDetails;
    
    #[proxy(
        interface = "org.freedesktop.login1.Manager",
        default_service = "org.freedesktop.login1",
        default_path = "/org/freedesktop/login1"
    )]
    trait LogindManager {
        fn get_session(&self, session_id: &str) -> zbus::Result<OwnedObjectPath>;
        fn get_session_by_pid(&self, pid: u32) -> zbus::Result<OwnedObjectPath>;
        fn get_user(&self, uid: u32) -> zbus::Result<OwnedObjectPath>;
        fn get_user_by_pid(&self, pid: u32) -> zbus::Result<OwnedObjectPath>;
        fn get_seat(&self, seat_id: &str) -> zbus::Result<OwnedObjectPath>;
        fn list_sessions(&self) -> zbus::Result<Vec<(String, u32, String, String, OwnedObjectPath)>>; // (id, uid, user, seat, path)
        fn list_users(&self) -> zbus::Result<Vec<(u32, String, OwnedObjectPath)>>; // (uid, name, path)
        fn list_seats(&self) -> zbus::Result<Vec<(String, OwnedObjectPath)>>; // (id, path)
    
        fn inhibit(&self, what: &str, who: &str, why: &str, mode: &str) -> zbus::Result<zbus::zvariant::Fd>; // Returns FD for inhibitor lock
        fn can_power_off(&self) -> zbus::Result<String>; // "yes", "no", "challenge"
        fn can_reboot(&self) -> zbus::Result<String>;
        fn can_suspend(&self) -> zbus::Result<String>;
        fn can_hibernate(&self) -> zbus::Result<String>;
        fn can_hybrid_sleep(&self) -> zbus::Result<String>;
        fn can_suspend_then_hibernate(&self) -> zbus::Result<String>;
    
        fn power_off(&self, interactive: bool) -> zbus::Result<()>;
        fn reboot(&self, interactive: bool) -> zbus::Result<()>;
        fn suspend(&self, interactive: bool) -> zbus::Result<()>;
        fn hibernate(&self, interactive: bool) -> zbus::Result<()>;
        fn hybrid_sleep(&self, interactive: bool) -> zbus::Result<()>;
        fn suspend_then_hibernate(&self, interactive: bool) -> zbus::Result<()>;
        // TerminateSeat, TerminateSession, TerminateUser...
    
        #[zbus(signal)]
        fn session_new(&self, session_id: String, object_path: OwnedObjectPath) -> zbus::Result<()>;
        #[zbus(signal)]
        fn session_removed(&self, session_id: String, object_path: OwnedObjectPath) -> zbus::Result<()>;
        #[zbus(signal)]
        fn seat_new(&self, seat_id: String, object_path: OwnedObjectPath) -> zbus::Result<()>;
        #[zbus(signal)]
        fn seat_removed(&self, seat_id: String, object_path: OwnedObjectPath) -> zbus::Result<()>;
        #[zbus(signal)]
        fn prepare_for_shutdown(&self, start: bool) -> zbus::Result<()>; // true = about to shut down, false = cancelled
        #[zbus(signal)]
        fn prepare_for_sleep(&self, start: bool) -> zbus::Result<()>;   // true = about to suspend/hibernate, false = cancelled
    }
    ```
    
- **`LogindSessionProxy` für `org.freedesktop.login1.Session` (dynamischer Pfad)**:
    
    Rust
    
    ```
    #[proxy(
        interface = "org.freedesktop.login1.Session",
        default_service = "org.freedesktop.login1"
    )]
    trait LogindSession {
        fn terminate(&self) -> zbus::Result<()>;
        fn activate(&self) -> zbus::Result<()>;
        fn lock(&self) -> zbus::Result<()>;
        fn unlock(&self) -> zbus::Result<()>;
        fn set_idle_hint(&self, idle: bool) -> zbus::Result<()>;
        fn set_locked_hint(&self, locked: bool) -> zbus::Result<()>;
        // Kill(who: &str, signal_number: i32)
        // TakeControl(force: bool)
        // ReleaseControl()
        // TakeDevice(major: u32, minor: u32) -> zbus::Result<(zbus::zvariant::Fd, bool)>
        // ReleaseDevice(major: u32, minor: u32)
        // PauseDeviceComplete(major: u32, minor: u32)
        // SetBrightness(subsystem: &str, name: &str, value: u32)
    
        // Properties (viele, können über Properties.GetAll abgerufen werden)
        #[zbus(property)] fn id(&self) -> zbus::Result<String>;
        #[zbus(property)] fn user(&self) -> zbus::Result<(u32, OwnedObjectPath)>; // (uid, user_path)
        #[zbus(property)] fn name(&self) -> zbus::Result<String>; // Username
        #[zbus(property)] fn timestamp(&self) -> zbus::Result<u64>; // usec
        #[zbus(property)] fn timestamp_monotonic(&self) -> zbus::Result<u64>; // usec
        #[zbus(property)] fn vtnr(&self) -> zbus::Result<u32>;
        #[zbus(property)] fn seat(&self) -> zbus::Result<(String, OwnedObjectPath)>; // (seat_id, seat_path)
        #[zbus(property)] fn display(&self) -> zbus::Result<String>;
        #[zbus(property)] fn remote(&self) -> zbus::Result<bool>;
        #[zbus(property)] fn remote_host(&self) -> zbus::Result<String>;
        #[zbus(property)] fn remote_user(&self) -> zbus::Result<String>;
        #[zbus(property)] fn service(&self) -> zbus::Result<String>;
        #[zbus(property)] fn desktop(&self) -> zbus::Result<String>;
        #[zbus(property)] fn scope(&self) -> zbus::Result<String>;
        #[zbus(property)] fn leader(&self) -> zbus::Result<u32>; // PID
        #[zbus(property)] fn audit(&self) -> zbus::Result<u32>; // Audit Session ID
        #[zbus(property, name = "Class")] fn class_prop(&self) -> zbus::Result<String>; // "user", "greeter", ...
        #[zbus(property, name = "Type")] fn type_prop(&self) -> zbus::Result<String>;   // "x11", "wayland", "tty"
        #[zbus(property)] fn active(&self) -> zbus::Result<bool>;
        #[zbus(property)] fn state(&self) -> zbus::Result<String>;
        #[zbus(property)] fn idle_hint(&self) -> zbus::Result<bool>;
        #[zbus(property)] fn idle_since_hint(&self) -> zbus::Result<u64>; // usec
        #[zbus(property)] fn locked_hint(&self) -> zbus::Result<bool>;
    
        #[zbus(signal)]
        fn pause_device(&self, major: u32, minor: u32, type_: &str) -> zbus::Result<()>; // type: "pause", "force-pause", "timeout-pause"
        #[zbus(signal)]
        fn resume_device(&self, major: u32, minor: u32, fd_idx: zbus::zvariant::Fd, type_: &str) -> zbus::Result<()>; // type: "resume"
        #[zbus(signal)]
        fn lock(&self) -> zbus::Result<()>; // Sitzung wurde gesperrt
        #[zbus(signal)]
        fn unlock(&self) -> zbus::Result<()>; // Sitzung wurde entsperrt
    }
    ```
    

**Datei:** `src/dbus_interfaces/logind_client/service.rs`

- **Struct `LogindClientService`**:
    - **Felder:** `connection: Arc<Connection>`, `manager_proxy: LogindManagerProxy<'static>`, `session_proxies: Arc<tokio::sync::Mutex<HashMap<String /*session_id*/, LogindSessionProxy<'static>>>>`, `event_publisher: tokio::sync::broadcast::Sender<LogindEvent>`.
    - **Konstruktor `new(...)`**: Stellt Verbindung her, erstellt `manager_proxy`.
    - **Methode `initialize_and_listen()`**:
        1. `list_sessions()` vom `manager_proxy` abrufen, um initiale Sessions zu cachen und ggf. Proxies zu erstellen.
        2. `LogindManagerProxy`-Signale abonnieren (`SessionNew`, `SessionRemoved`, `PrepareForShutdown`, `PrepareForSleep`).
            - `SessionNew`: Erstelle `LogindSessionProxy`, speichere in `session_proxies`, abonniere dessen `Lock`/`Unlock`-Signale.
            - `SessionRemoved`: Entferne Proxy.
            - `PrepareForShutdown/Sleep`: Sende `LogindEvent` an `event_publisher`.
        3. `LogindSessionProxy`-Signale (`Lock`, `Unlock`) für jede aktive Session abonnieren und entsprechende `LogindEvent`s senden.
    - **Öffentliche Methoden (Beispiele):**
        - `pub async fn get_current_session_details(&self) -> Result<Option<SessionDetails>, DBusInterfaceError>`: Ruft `GetSessionByPid(std::process::id())` auf, dann alle Properties vom Session-Proxy.
        - `pub async fn lock_current_session(&self) -> Result<(), DBusInterfaceError>`: Ruft `Lock()` auf dem aktuellen Session-Proxy auf.
        - `pub async fn can_power_off(&self) -> Result<String, DBusInterfaceError>`: Ruft `manager_proxy.can_power_off()`.
        - `pub async fn power_off(&self, interactive: bool) -> Result<(), DBusInterfaceError>`: Ruft `manager_proxy.power_off(interactive)`. (Benötigt PolicyKit-Autorisierung, die von logind gehandhabt wird).

**Implementierungsschritte `logind_client`**:

1. `types.rs`: `LogindEvent`, `SessionDetails`, `LogindPowerOperation` definieren.
2. `proxies.rs`: `LogindManagerProxy` und `LogindSessionProxy` definieren.
3. `service.rs`: `LogindClientService` implementieren (Konstruktor, Initialisierung/Signal-Listener, öffentliche Methoden).
4. Tests mit gemockter D-Bus-Verbindung.

---

#### 3.5. Submodul: `system::dbus_interfaces::network_manager_client`

Zweck: Client für org.freedesktop.NetworkManager.

Interaktion: Sendet NetworkManagerEvents.

(Struktur analog zu upower_client und logind_client)

- **`types.rs`**: Enums (`NMState`, `NMDeviceType`, `NMConnectivityState`), Structs (`NetworkDeviceDetails`, `AccessPointDetails`, `ActiveConnectionDetails`), Event (`NetworkManagerEvent`).
- **`proxies.rs`**: `NetworkManagerProxy`, `NMDeviceProxy`, `NMActiveConnectionProxy`, `NMAccessPointProxy`, `NMSettingsConnectionProxy` etc.
- **`service.rs`**: `NetworkManagerClientService` mit Logik zum Auflisten von Geräten, Verbindungen, APs; Abonnieren von `StateChanged`, `DeviceAdded/Removed`, `PropertiesChanged` etc.

---

#### 3.6. Submodul: `system::dbus_interfaces::secrets_service_client`

Zweck: Client für org.freedesktop.Secret.Service.

Interaktion: Stellt Methoden zum Speichern/Abrufen von Geheimnissen bereit, die von anderen Systemmodulen (z.B. mcp_client) genutzt werden.

(Struktur analog zu upower_client)

- **`types.rs`**: Structs (`Secret`, `SecretItemAttributes`).
- **`proxies.rs`**: `SecretServiceProxy`, `SessionProxy` (für D-Bus-Session der Secret Service API), `CollectionProxy`, `ItemProxy`, `PromptProxy`.
- **`service.rs`**: `SecretsServiceClientService` mit Methoden wie `async fn store_secret(collection_alias: &str, label: &str, secret_content: &[u8], attributes: HashMap<String, String>, replace: bool) -> Result<DBusObjectPath, DBusInterfaceError>`, `async fn retrieve_secret(item_path: &DBusObjectPath) -> Result<Vec<u8>, DBusInterfaceError>`, `async fn search_items(attributes: HashMap<String, String>) -> Result<Vec<DBusObjectPath>, DBusInterfaceError>`. Handhabt Unlock-Prompts (oft delegiert an den Secret Service Agenten).

---

#### 3.7. Submodul: `system::dbus_interfaces::policykit_client`

Zweck: Client für org.freedesktop.PolicyKit1.Authority.

Interaktion: Stellt eine Methode zur Autorisierungsprüfung bereit.

(Struktur analog, aber einfacher, da meist nur eine Hauptmethode)

- **`types.rs`**: Enum `PolicyKitAuthorizationResult` (allow, challenge, deny). Structs für `Subject` (pid, uid), `ActionId`.
- **`proxies.rs`**: `PolicyKitAuthorityProxy`.
- **`service.rs`**: `PolicyKitClientService` mit Methode `async fn check_authorization(action_id: &str, subject_pid: Option<u32>, details: HashMap<String, String>, flags: u32 /* PolicyKitCheckAuthorizationFlags */) -> Result<PolicyKitAuthorizationResult, DBusInterfaceError>`.

---

#### 3.8. Submodul: `system::dbus_interfaces::notifications_server`

Zweck: Implementierung des org.freedesktop.Notifications D-Bus-Servers.

Interaktion: Empfängt Notify-Aufrufe und leitet sie an domain::user_centric_services::NotificationService weiter. Sendet NotificationClosed und ActionInvoked Signale basierend auf Events aus der Domänenschicht.

**Datei:** `src/dbus_interfaces/notifications_server/mod.rs` (kann `interface.rs`, `service_object.rs` enthalten)

- **Struct `FreedesktopNotificationsServer`** (Das D-Bus-Objekt):
    
    Rust
    
    ```
    use zbus::dbus_interface;
    use crate::domain::user_centric_services::{NotificationService, Notification, NotificationUrgency as DomainUrgency, NotificationAction as DomainAction}; // Domain Traits/Typen
    use crate::domain::user_centric_services::notifications_core::types::NotificationInput; // Für Notify
    use crate::domain::shared_types::ApplicationId;
    use std::sync::Arc;
    use tokio::sync::Mutex; // Für NotificationService Handle
    use zbus::zvariant::{Value, Dict, Array};
    use zbus::SignalContext;
    use super::common::DBusInterfaceError; // Eigener Fehlertyp
    
    pub struct FreedesktopNotificationsServer {
        notification_service: Arc<Mutex<dyn NotificationService>>, // Injizierter Domain-Service
        // Ggf. ein tokio::sync::broadcast::Receiver für Domain-Events (NotificationDismissedEvent etc.)
        // um D-Bus Signale zu senden.
    }
    
    impl FreedesktopNotificationsServer {
        pub fn new(notification_service: Arc<Mutex<dyn NotificationService>>) -> Self {
            Self { notification_service }
            // Hier den Event-Receiver von notification_service abonnieren und Task starten,
            // der Domain-Events in D-Bus-Signale umwandelt.
        }
    
        // Hilfsmethode zur Konvertierung von D-Bus Urgency zu Domain Urgency
        fn to_domain_urgency(level: u8) -> DomainUrgency {
            match level {
                0 => DomainUrgency::Low,
                1 => DomainUrgency::Normal,
                2 => DomainUrgency::Critical,
                _ => DomainUrgency::Normal, // Fallback
            }
        }
    }
    
    #[dbus_interface(name = "org.freedesktop.Notifications")]
    impl FreedesktopNotificationsServer {
        async fn get_capabilities(&self) -> Vec<String> {
            // Fähigkeiten, die NovaDE unterstützt, z.B. "body", "actions", "persistence", "icon-static"
            vec![
                "body".to_string(),
                "actions".to_string(),
                "persistence".to_string(), // Wenn Benachrichtigungen gespeichert werden
                "icon-static".to_string(),
                "body-markup".to_string(), // Wenn Pango-Markup im Body unterstützt wird
                // "sound"
            ]
        }
    
        async fn notify(
            &self,
            app_name: String,
            replaces_id: u32, // ID der zu ersetzenden Benachrichtigung (0 für neue)
            app_icon: String,  // Icon-Name oder Pfad
            summary: String,
            body: String,
            actions: Vec<String>, // Actions als flache Liste: [key1, label1, key2, label2, ...]
            hints: Dict<'_, String, Value<'_>>, // zbus Dict für a{sv}
            expire_timeout: i32, // Millisekunden, -1 für Default, 0 für persistent (laut Spezifikation)
        ) -> Result<u32, zbus::fdo::Error> { // Gibt die neue Notification ID zurück
            tracing::info!("D-Bus Notify: app='{}', summary='{}'", app_name, summary);
    
            let mut domain_actions = Vec::new();
            for chunk in actions.chunks_exact(2) {
                domain_actions.push(DomainAction {
                    key: chunk[0].clone(),
                    label: chunk[1].clone(),
                    // action_type wird hier nicht direkt übergeben, müsste ggf. aus Hints oder Konvention abgeleitet werden
                    // oder Aktionen sind immer "Callback" für D-Bus.
                    action_type: crate::domain::user_centric_services::notifications_core::types::NotificationActionType::Callback,
                });
            }
    
            let urgency_hint = hints.get("urgency")
                .and_then(|v| v.downcast_ref::<Value<'_>>()) // Value in Value ist seltsam, eher direkt u8 oder byte
                .and_then(|v_inner| v_inner.try_into().ok()) // u8
                .map(Self::to_domain_urgency)
                .unwrap_or(DomainUrgency::Normal);
    
            let category_hint = hints.get("category")
                                .and_then(|v| v.downcast_ref::<String>())
                                .cloned();
    
            // TODO: 'replaces_id' Logik implementieren (alte Notification mit dieser ID entfernen/aktualisieren)
            // TODO: 'app_icon' und 'hints' genauer verarbeiten (image-data, sound etc.)
    
            let notification_input = NotificationInput {
                application_name: app_name, // Optional: ApplicationId::new(app_name)
                application_icon: if app_icon.is_empty() { None } else { Some(app_icon) },
                summary,
                body: if body.is_empty() { None } else { Some(body) },
                actions: domain_actions,
                urgency: urgency_hint,
                transient: hints.get("transient").and_then(|v| v.try_into().ok()).unwrap_or(false),
                category: category_hint,
                hints: hints.iter().map(|(k,v)| (k.to_string(), serde_json::to_value(v).unwrap_or(serde_json::Value::Null))).collect(), // Konvertiere zbus::Value zu serde_json::Value
                timeout_ms: if expire_timeout == 0 { Some(0) } // 0 für persistent laut D-Bus
                             else if expire_timeout > 0 { Some(expire_timeout as u32) }
                             else { None }, // -1 für Default
            };
    
            let mut service_guard = self.notification_service.lock().await;
            match service_guard.post_notification(notification_input).await {
                // Die zurückgegebene u32 ID muss für D-Bus eindeutig sein.
                // Der Domain-Service verwendet Uuid. Hier muss eine Abbildung erfolgen,
                // z.B. eine laufende u32-ID, die der Uuid zugeordnet wird.
                // Für Einfachheit hier: Hash der Uuid (nicht ideal, da Kollisionen möglich)
                // Besser: Map<Uuid, u32> im Server halten.
                Ok(domain_id) => {
                    let dbus_id =贫穷的男子哈希(domain_id); // Vereinfacht
                    Ok(dbus_id)
                }
                Err(e) => {
                    tracing::error!("Fehler beim Posten der Benachrichtigung an den Domain-Service: {:?}", e);
                    Err(zbus::fdo::Error::Failed(format!("Interner Fehler beim Verarbeiten der Benachrichtigung: {}", e)))
                }
            }
        }
    
        async fn close_notification(&self, id: u32) -> zbus::fdo::Result<()> {
            tracing::info!("D-Bus CloseNotification für ID: {}", id);
            // TODO: ID von u32 (D-Bus) zu Uuid (Domain) mappen
            // let domain_id = map_dbus_id_to_domain_id(id);
            // let mut service_guard = self.notification_service.lock().await;
            // match service_guard.dismiss_notification(domain_id).await {
            //     Ok(_) => Ok(()),
            //     Err(domain::user_centric_services::NotificationError::NotFound(_)) => {
            //         // Gemäß Spezifikation kein Fehler, wenn ID unbekannt ist
            //         Ok(())
            //     }
            //     Err(e) => Err(zbus::fdo::Error::Failed(format!("Fehler beim Schließen: {}", e))),
            // }
            Ok(()) // Platzhalter
        }
    
        async fn get_server_information(&self) -> (String, String, String, String) {
            (
                "NovaDE Notification Server".to_string(), // name
                "NovaDE Team".to_string(),                // vendor
                "0.1.0".to_string(),                      // version
                "1.2".to_string(),                        // spec_version
            )
        }
    
        #[dbus_interface(signal)]
        async fn notification_closed(ctxt: &SignalContext<'_>, id: u32, reason: u32) -> zbus::Result<()>;
        // reason: 1=expired, 2=dismissed by user, 3=closed by call to CloseNotification, 4=undefined
    
        #[dbus_interface(signal)]
        async fn action_invoked(ctxt: &SignalContext<'_>, id: u32, action_key: String) -> zbus::Result<()>;
    }
    ```
    
- **Logik zur Signal-Weiterleitung:**
    - Der `FreedesktopNotificationsServer` muss `NotificationDismissedEvent` und `NotificationActionInvokedEvent` vom `NotificationService` abonnieren.
    - Wenn ein `NotificationDismissedEvent { notification_id, reason }` empfangen wird:
        - `dbus_id = map_domain_id_to_dbus_id(notification_id);`
        - `dbus_reason = match reason { DismissReason::User => 2, DismissReason::Timeout => 1, ... };`
        - `FreedesktopNotificationsServer::notification_closed(ctxt, dbus_id, dbus_reason).await;` (Benötigt `SignalContext`).
    - Wenn ein `NotificationActionInvokedEvent { notification_id, action_key }` empfangen wird:
        - `dbus_id = map_domain_id_to_dbus_id(notification_id);`
        - `FreedesktopNotificationsServer::action_invoked(ctxt, dbus_id, action_key).await;`

#### 3.9. Implementierungsschritte `system::dbus_interfaces` (Fortsetzung)

5. **`logind_client` implementieren**: Typen, Proxies, Service. Signal-Handler für `PrepareForShutdown/Sleep`, `SessionNew/Removed`, `Lock/Unlock`. Tests.
6. **`network_manager_client` implementieren**: Typen, Proxies, Service. Signal-Handler für relevante NM-Signale. Tests.
7. **`secrets_service_client` implementieren**: Typen, Proxies, Service. Methoden für Speichern/Abrufen. Tests.
8. **`policykit_client` implementieren**: Typen, Proxy, Service. `check_authorization`-Methode. Tests.
9. **`notifications_server` implementieren**:
    - D-Bus-Interface-Struct `FreedesktopNotificationsServer`.
    - Implementierung der Methoden (`Notify`, `CloseNotification`, etc.), die den `domain::NotificationService` aufrufen.
    - ID-Mapping zwischen D-Bus `u32` und Domain `Uuid` implementieren (z.B. `HashMap<u32, Uuid>` und `HashMap<Uuid, u32>`).
    - Task starten, der Domain-Events (`NotificationDismissedEvent`, `NotificationActionInvokedEvent`) abonniert und entsprechende D-Bus-Signale (`notification_closed`, `action_invoked`) über den `SignalContext` sendet.
    - Registrierung des D-Bus-Objekts auf dem Session-Bus.
10. **`xdg_desktop_portal_handler`** (wird später detailliert, da es von UI-Dialogen und Compositor-Funktionen abhängt).

---

### Modul 4: `system::audio_management`

Zweck: Integration mit PipeWire zur Steuerung der Systemlautstärke, Auswahl von Audio-Geräten und Verwaltung von Anwendungs-Streams.

Verantwortlichkeiten: Aufbau und Verwaltung der PipeWire-Verbindung, Auflisten von Audio-Geräten (Sinks, Sources) und Streams, Setzen/Abfragen von Lautstärke und Mute-Status, Auswahl von Standardgeräten.

Design-Rationale: PipeWire als moderner Standard für Audio unter Linux. Kapselung der PipeWire-spezifischen Logik. Bereitstellung einer abstrahierten Schnittstelle für die Domänen- und UI-Schicht.

Technologie: pipewire-rs Crate.

#### 4.1. Submodul: `system::audio_management::types`

**Datei:** `src/audio_management/types.rs`

- **Enum `AudioDeviceType`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum AudioDeviceType {
        Sink,    // Wiedergabegerät (z.B. Lautsprecher, Kopfhörer)
        Source,  // Aufnahmegerät (z.B. Mikrofon)
        Other,
    }
    ```
    
- **Struct `AudioDevice`**:
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    use uuid::Uuid; // Interne ID für das Domänenobjekt
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct AudioDevice {
        pub internal_id: Uuid, // Eigene ID, da PipeWire IDs u32 sind und sich ändern können
        pub pipewire_id: u32,  // Die aktuelle PipeWire Node ID
        pub name: String,      // z.B. "alsa_output.pci-0000_00_1f.3.analog-stereo"
        pub description: String, // Menschenlesbar, z.B. "Built-in Audio Analog Stereo"
        pub device_type: AudioDeviceType,
        pub volume_percent: u8, // 0-100 (oder höher, falls >100% unterstützt)
        pub is_muted: bool,
        pub is_default: bool,   // Ob es das Standardgerät seines Typs ist
        // Optional: channel_map, sample_format, etc.
    }
    ```
    
- **Struct `AudioStream`** (repräsentiert einen Anwendungs-Audiostream):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct AudioStream {
        pub internal_id: Uuid,
        pub pipewire_id: u32, // PipeWire Client/Stream ID
        pub application_name: Option<String>, // Name der Anwendung, die den Stream erzeugt
        pub media_role: Option<String>, // z.B. "Music", "Video", "Game", "Notification"
        pub volume_percent: u8,
        pub is_muted: bool,
        pub target_device_pw_id: Option<u32>, // PipeWire ID des Geräts, mit dem der Stream verbunden ist
    }
    ```
    
- **Event-Struktur (für `system::event_bridge` oder direkt an Domäne):**
    
    Rust
    
    ```
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AudioEvent {
        DeviceListChanged(Vec<AudioDevice>),
        DefaultDeviceChanged { device_type: AudioDeviceType, new_default_pw_id: Option<u32> },
        DeviceVolumeChanged { device_pw_id: u32, new_volume_percent: u8, is_muted: bool },
        StreamListChanged(Vec<AudioStream>),
        StreamVolumeChanged { stream_pw_id: u32, new_volume_percent: u8, is_muted: bool },
        ServerConnectionStateChanged(bool /* is_connected */),
    }
    ```
    

#### 4.2. Submodul: `system::audio_management::errors`

**Datei:** `src/audio_management/errors.rs`

- **Enum `AudioManagementError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    
    #[derive(Debug, Error)]
    pub enum AudioManagementError {
        #[error("PipeWire connection failed: {0}")]
        ConnectionFailed(String),
        #[error("PipeWire context error: {0}")]
        ContextError(String),
        #[error("PipeWire main loop error: {0}")]
        MainLoopError(String),
        #[error("PipeWire core error: {0}")]
        CoreError(String), // Generischer Fehler von pipewire-rs
        #[error("Failed to create PipeWire proxy or object: {0}")]
        ProxyCreationFailed(String),
        #[error("PipeWire object not found (ID: {0})")]
        ObjectNotFound(u32),
        #[error("Invalid parameter for PipeWire operation: {0}")]
        InvalidParameter(String),
        #[error("Operation timed out: {0}")]
        Timeout(String),
        #[error("Type conversion error in PipeWire data: {0}")]
        TypeConversionError(String),
        #[error("Audio device or stream is in an unexpected state: {0}")]
        InvalidState(String),
        #[error("An internal error occurred in audio management: {0}")]
        InternalError(String),
    }
    // Hilfsimplementierungen, um Fehler von pipewire-rs zu wrappen
    impl From<pipewire::Error> for AudioManagementError {
        fn from(err: pipewire::Error) -> Self {
            AudioManagementError::CoreError(err.to_string())
        }
    }
    ```
    

#### 4.3. Submodul: `system::audio_management::client`

**Zweck:** Kernlogik für die PipeWire-Verbindung, Event-Loop-Integration und Objektverwaltung.

**Datei:** `src/audio_management/client/mod.rs` (oder `service.rs`)

- **Struct `PipeWireClientService`**:
    - **Felder:**
        - `main_loop: Arc<pipewire::MainLoop>` (muss in eigenem Thread laufen oder in `calloop` integriert werden)
        - `context: Arc<pipewire::Context>`
        - `core: Arc<pipewire::Core>`
        - `registry: Arc<pipewire::Registry>`
        - `devices: Arc<tokio::sync::RwLock<HashMap<u32 /*pw_id*/, AudioDevice>>>`
        - `streams: Arc<tokio::sync::RwLock<HashMap<u32 /*pw_id*/, AudioStream>>>`
        - `default_sink_id: Arc<tokio::sync::RwLock<Option<u32>>>`
        - `default_source_id: Arc<tokio::sync::RwLock<Option<u32>>>`
        - `event_publisher: tokio::sync::broadcast::Sender<AudioEvent>`
        - `registry_listener: Option<pipewire::registry::Listener>` (muss `'static` sein oder anders verwaltet werden)
        - `core_listener: Option<pipewire::core::CoreListener>`
        - `loop_thread_handle: Option<std::thread::JoinHandle<()>>` (Falls MainLoop in eigenem Thread)
    - **Konstruktor `pub async fn new(event_publisher: tokio::sync::broadcast::Sender<AudioEvent>) -> Result<Self, AudioManagementError>`**:
        1. `pipewire::init()` aufrufen.
        2. `MainLoop::new(None)?` erstellen.
        3. `Context::new(&main_loop)?` erstellen.
        4. `Core::new(&context, None)?` (Verbindung zum PipeWire-Daemon herstellen).
        5. `Registry::new(&core)?` erstellen.
        6. Referenzen (`Arc`) für diese Objekte erstellen.
        7. `registry_listener` einrichten:
            - Im `global` Callback: Objekte filtern nach Typ (`PipewireObject::Node` für Geräte, `PipewireObject::Client` oder `PipewireObject::Stream` für Streams).
            - Für Nodes: Prüfen, ob es Audio Sinks/Sources sind (via Properties). `AudioDevice` erstellen, in `devices` speichern. `AudioEvent::DeviceListChanged` senden.
            - Für Streams: `AudioStream` erstellen, in `streams` speichern. `AudioEvent::StreamListChanged` senden.
            - `Metadata`-Objekt beobachten, um Standardgeräte zu finden (`default.audio.sink`, `default.audio.source`). `AudioEvent::DefaultDeviceChanged` senden.
        8. `core_listener` für `info` (um Server-Verbindungsstatus zu bekommen) und `error` einrichten.
        9. Wenn `main_loop` in eigenem Thread: `std::thread::spawn(move || main_loop_ref.run());`.
        10. Gibt `Self` zurück.
    - **Methode `pub async fn shutdown(&self)`**: Stoppt den `main_loop`-Thread sauber.
    - **Öffentliche Getter-Methoden (Beispiele):**
        - `pub async fn get_audio_devices(&self) -> Vec<AudioDevice>`: Gibt Klon von `self.devices.read().await.values()` zurück.
        - `pub async fn get_audio_streams(&self) -> Vec<AudioStream>`
        - `pub async fn get_default_sink(&self) -> Option<AudioDevice>`
        - `pub async fn get_default_source(&self) -> Option<AudioDevice>`
    - **Öffentliche Setter-Methoden (Beispiele):**
        - `pub async fn set_device_volume(&self, device_pw_id: u32, volume_percent: u8, is_muted: bool) -> Result<(), AudioManagementError>`:
            1. Findet das `Device` oder `Node` Proxy-Objekt für `device_pw_id` (muss im Registry-Handler gecacht werden).
            2. Erstellt `SpaPodBuilder` mit den neuen Lautstärkeparametern (`Props` mit `mute`, `channelVolumes`).
            3. Ruft `node_proxy.set_param("Props", 0, &pod)` auf.
            4. (PipeWire sendet dann über den Listener ein Event über die Volumenänderung, das dann ein `AudioEvent::DeviceVolumeChanged` auslöst).
        - `pub async fn set_stream_volume(...)` (analog).
        - `pub async fn set_default_device(&self, device_pw_id: u32, device_type: AudioDeviceType) -> Result<(), AudioManagementError>`:
            1. Erstellt `Metadata` Proxy für das `core`-Objekt.
            2. Setzt die Eigenschaft `default.audio.sink` oder `default.audio.source` auf die `device_pw_id`.
- **Wichtig:** Die `pipewire-rs` API ist Callback-basiert und integriert sich in eine `MainLoop`. Diese `MainLoop` muss entweder in einem dedizierten Thread laufen oder, falls möglich und komplexer, in die `calloop`-Schleife des Compositors integriert werden (z.B. indem der FD des PipeWire-Loops in `calloop` überwacht wird). Ein eigener Thread für den PipeWire-`MainLoop` ist oft einfacher zu handhaben. Die Kommunikation zwischen diesem Thread und den `async` Methoden des `PipeWireClientService` erfolgt dann über `tokio::sync::mpsc` Kanäle oder indem die `Arc<RwLock<...>>`-geschützten Zustände aktualisiert und `watch` Kanäle für Benachrichtigungen verwendet werden.

#### 4.4. Implementierungsschritte `system::audio_management`

1. **Grundgerüst**: Verzeichnis, `mod.rs`, `Cargo.toml` um `pipewire-rs` und ggf. `libspa` (falls für Pods nötig) erweitern.
2. **`types.rs`**: Alle Audio-bezogenen Typen und Enums (`AudioDeviceType`, `AudioDevice`, `AudioStream`, `AudioEvent`) definieren.
3. **`errors.rs`**: `AudioManagementError` Enum mit `thiserror` und `From<pipewire::Error>` definieren.
4. **`client/mod.rs`**:
    - `PipeWireClientService`-Struktur definieren.
    - `new()`-Konstruktor implementieren: Initialisiert PipeWire-Objekte (`MainLoop`, `Context`, `Core`, `Registry`).
    - `RegistryListener`-Logik implementieren:
        - `global` Callback: Erkennt Nodes (Sinks/Sources) und Streams. Parst deren Properties, um `AudioDevice`- und `AudioStream`-Objekte zu erstellen/aktualisieren. Speichert sie in den `RwLock`-geschützten HashMaps.
        - `global` Callback: Beobachtet `Metadata` für Default-Geräte.
        - Sendet entsprechende `AudioEvent`s über den `event_publisher`.
    - `CoreListener`-Logik für Fehler und Server-Info.
    - Startet den `MainLoop` in einem eigenen Thread.
    - `shutdown()`-Methode implementieren.
    - Öffentliche `async` Getter-Methoden implementieren (lesen aus den `RwLock`-geschützten Maps).
    - Öffentliche `async` Setter-Methoden implementieren (`set_device_volume`, `set_default_device` etc.), die PipeWire-Befehle (oft über Setzen von Properties/Params auf Nodes/Streams via SPA Pods) asynchron ausführen. Dies könnte das Senden von Nachrichten an den MainLoop-Thread über einen Kanal erfordern, falls die `pipewire-rs` Proxies nicht direkt `Send+Sync` sind oder Operationen im MainLoop-Kontext erfordern.
5. **Unit-/Integrationstests**:
    - Sehr schwierig ohne laufenden PipeWire-Server. Fokus auf:
    - Korrekte Erstellung/Parsen der eigenen Typen (`AudioDevice` etc.).
    - Logik der Listener-Callbacks (mocken von `Registry`, `GlobalObject` etc. ist aufwendig). Eventuell Tests, die auf einem Test-PipeWire-Server laufen (falls headless möglich).
    - Testen der Setter-Methoden, ob sie die korrekten PipeWire-Parameter (SPA Pods) generieren würden.

---

Diese detaillierten Pläne für die Module `system::dbus_interfaces` (Fortsetzung) und `system::audio_management` sollten eine sehr solide Grundlage für die Implementierung bieten. Die Komplexität liegt hier oft in der korrekten asynchronen Integration und der genauen Abbildung der externen D-Bus/PipeWire-APIs und -Events auf die internen Strukturen und das Event-System von NovaDE.

---

### Modul 3: `system::dbus_interfaces` (Fortsetzung und Vervollständigung)

#### 3.4. Submodul: `system::dbus_interfaces::logind_client` (Vervollständigung)

Zweck: Client für org.freedesktop.login1 für Sitzungsmanagement.

Bestehende Spezifikation: Skizziert in der vorherigen Antwort.

**Datei:** `src/dbus_interfaces/logind_client/service.rs` (Fortsetzung)

- **`LogindClientService` Implementierung (Methoden-Details):**
    - **`async fn initialize_and_listen(&self) -> Result<(), DBusInterfaceError>`**:
        1. `sessions = self.manager_proxy.list_sessions().await?.into_iter().map(|(id, _uid, _user, _seat, path)| (id, path)).collect::<HashMap<_,_>>();`
        2. Für jede `(id, path)` in `sessions`:
            - `self.add_session_proxy_and_listen(&id, path).await?;`
        3. Starte `tokio::task` für `manager_proxy.receive_session_new()`:
            - Bei `SessionNew { session_id, object_path }`: `self.add_session_proxy_and_listen(&session_id, object_path).await;` `self.event_publisher.send(LogindEvent::SessionNew(...))`.
        4. Starte `tokio::task` für `manager_proxy.receive_session_removed()`:
            - Bei `SessionRemoved { session_id, object_path }`: `self.session_proxies.lock().await.remove(&session_id);` `self.event_publisher.send(LogindEvent::SessionRemoved(...))`.
        5. Starte `tokio::task` für `manager_proxy.receive_prepare_for_shutdown()`:
            - `self.event_publisher.send(LogindEvent::PrepareForShutdown(start_signal_arg)).ok();`
        6. Starte `tokio::task` für `manager_proxy.receive_prepare_for_sleep()`:
            - `self.event_publisher.send(LogindEvent::PrepareForSleep(start_signal_arg)).ok();`
    - **`async fn add_session_proxy_and_listen(&self, session_id: &str, object_path: OwnedObjectPath) -> Result<(), DBusInterfaceError>`**:
        1. `session_proxy = LogindSessionProxy::builder(&self.connection).path(object_path.clone())?.build().await?;`
        2. Starte `tokio::task` für `session_proxy.receive_lock()`: `self.event_publisher.send(LogindEvent::SessionLocked(object_path.clone())).ok();`
        3. Starte `tokio::task` für `session_proxy.receive_unlock()`: `self.event_publisher.send(LogindEvent::SessionUnlocked(object_path.clone())).ok();`
        4. `self.session_proxies.lock().await.insert(session_id.to_string(), session_proxy);`
    - **`get_current_session_details()`**:
        1. `current_pid = std::process::id();`
        2. `session_path = self.manager_proxy.get_session_by_pid(current_pid).await?;`
        3. `session_proxy = LogindSessionProxy::builder(&self.connection).path(session_path.clone())?.build().await?;`
        4. Rufe alle Properties von `session_proxy` ab (z.B. `id()`, `user()`, `name()`, etc.) und fülle `SessionDetails`.
    - **`lock_current_session()`**:
        1. `session_path = self.manager_proxy.get_session_by_pid(std::process::id()).await?;`
        2. `session_proxy = self.session_proxies.lock().await.get(session_path.as_str())` (oder neu erstellen, falls nicht gecacht).
        3. `session_proxy.lock().await?;`
    - Andere Methoden (`can_power_off`, `power_off`, etc.) rufen die entsprechenden `manager_proxy`-Methoden auf.

**Datei:** `src/dbus_interfaces/logind_client/mod.rs`

- `pub mod types;`
- `pub mod proxies;`
- `pub mod service;`
- `pub use service::LogindClientService;`
- `pub use types::{LogindEvent, SessionDetails, LogindPowerOperation};`

#### 3.5. Submodul: `system::dbus_interfaces::network_manager_client` (Vervollständigung)

**Zweck:** Client für `org.freedesktop.NetworkManager`.

**Datei:** `src/dbus_interfaces/network_manager_client/types.rs`

- **Enums:**
    - `NMState`: `Unknown, Asleep, Disconnected, Disconnecting, Connecting, ConnectedLocal, ConnectedSite, ConnectedGlobal`. `#[repr(u32)]`, `Type`.
    - `NMDeviceType`: `Unknown, Ethernet, Wifi, Wimax, Modem, Bluetooth, OlpcMesh, WifiP2p, Bond, Vlan, Adsl, Bridge, Generic, Team, Tun, IpTunnel, Macvlan, Vxlan, Veth, Dummy, Sriov`. `#[repr(u32)]`, `Type`.
    - `NMConnectivityState`: `Unknown, None, Portal, Limited, Full`. `#[repr(u32)]`, `Type`.
    - `NMWifiAccessPointFlags`, `NMWifiAccessPointSecurityFlags`.
- **Structs:**
    - `NetworkDeviceDetails { id: u32, path: DBusObjectPath, interface: String, device_type: NMDeviceType, state: u32 /* NMDeviceState */, ip4_address: Option<String>, ip6_address: Option<String>, hw_address: Option<String>, mtu: u32, managed: bool, firmware_missing: bool, driver: String, ... }`
    - `AccessPointDetails { path: DBusObjectPath, ssid: String, bssid: String, strength: u8, frequency: u32, flags: u32, wpa_flags: u32, rsn_flags: u32, max_bitrate: u32, ... }`
    - `ActiveConnectionDetails { path: DBusObjectPath, uuid: String, connection_type: String, id: String, specific_object_path: DBusObjectPath, state: u32 /* NMActiveConnectionState */, default: bool, default6: bool, vpn: bool, master_path: Option<DBusObjectPath>, ip4_config_path: Option<DBusObjectPath>, ... }`
- **Event:**
    
    Rust
    
    ```
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum NetworkManagerEvent {
        ConnectivityChanged(NMConnectivityState),
        StateChanged(NMState),
        DeviceAdded(NetworkDeviceDetails),
        DeviceRemoved(DBusObjectPath /* device path */),
        DeviceStateChanged { device_path: DBusObjectPath, new_state: u32 /* NMDeviceState */, old_state: u32 },
        ActiveConnectionAdded(ActiveConnectionDetails),
        ActiveConnectionRemoved(DBusObjectPath /* active connection path */),
        AccessPointAdded(AccessPointDetails),
        AccessPointRemoved(DBusObjectPath /* ap path */),
        PrimaryConnectionChanged(Option<ActiveConnectionDetails>),
    }
    ```
    

**Datei:** `src/dbus_interfaces/network_manager_client/proxies.rs`

- **`NetworkManagerProxy` für `org.freedesktop.NetworkManager`**: Properties (`Connectivity`, `State`, `NetworkingEnabled`, `WirelessEnabled`, `WirelessHardwareEnabled`, `WwanEnabled`, `WwanHardwareEnabled`, `ActiveConnections`, `PrimaryConnection`, `Devices`, etc.). Methoden (`GetDevices`, `GetActiveConnections`, `ActivateConnection`, `DeactivateConnection`, `ScanWifiAccessPoints`, etc.). Signale (`CheckPermissions`, `StateChanged`, `PropertiesChanged`, `DeviceAdded`, `DeviceRemoved`, `ActiveConnectionAdded`, `ActiveConnectionRemoved`).
- **`NMDeviceProxy` für `org.freedesktop.NetworkManager.Device`**: Viele Properties (Interface, IpInterface, Udi, State, DeviceType, AvailableConnections, Ip4Config, Dhcp4Config, etc.).
- **`NMWifiDeviceProxy` für `org.freedesktop.NetworkManager.Device.Wireless`**: Properties (`HwAddress`, `PermHwAddress`, `Mode`, `Bitrate`, `ActiveAccessPoint`, etc.). Methoden (`GetAccessPoints`, `RequestScan`, etc.). Signale (`AccessPointAdded`, `AccessPointRemoved`, `PropertiesChanged`).
- **`NMAccessPointProxy` für `org.freedesktop.NetworkManager.AccessPoint`**: Properties (`Ssid`, `Frequency`, `HwAddress`, `Mode`, `MaxBitrate`, `Strength`, `Flags`, `WpaFlags`, `RsnFlags`, etc.).
- **`NMActiveConnectionProxy` für `org.freedesktop.NetworkManager.Connection.Active`**: Properties (`Connection` (path), `SpecificObject` (path), `Id`, `Uuid`, `Type`, `Devices`, `State`, `Default`, `Ip4Config`, etc.). Signale (`StateChanged`, `PropertiesChanged`).
- **`NMSettingsProxy` für `org.freedesktop.NetworkManager.Settings`**: Methoden (`ListConnections`, `AddConnection`, `GetConnectionByUuid`, etc.).
- **`NMSettingsConnectionProxy` für `org.freedesktop.NetworkManager.Settings.Connection`**: Methoden (`Update`, `Delete`, `GetSettings`, `GetSecrets`, etc.).

**Datei:** `src/dbus_interfaces/network_manager_client/service.rs`

- **`NetworkManagerClientService`**:
    - **Felder:** Connection, Hauptproxy, Maps für Geräte-, AP-, aktive Verbindungsproxies. Event-Publisher.
    - **`initialize_and_listen()`**: Initiales Laden von Devices, aktiven Verbindungen. Signale abonnieren (Hauptproxy, Geräte, aktive Verbindungen).
    - **Öffentliche Methoden:** `get_connectivity_state()`, `get_primary_connection_details()`, `list_devices()`, `list_active_connections()`, `list_wifi_access_points(device_path: &DBusObjectPath)`, `activate_connection(connection_path: &DBusObjectPath, device_path: &DBusObjectPath)`, etc.

**Implementierungsschritte `network_manager_client`**:

1. `types.rs`: Alle NM-bezogenen Typen und Events.
2. `proxies.rs`: Alle benötigten NM-Proxies.
3. `service.rs`: `NetworkManagerClientService` implementieren.
4. Tests (schwierig ohne NM, `zbus::MockConnection` verwenden).

---

#### 3.6. Submodul: `system::dbus_interfaces::secrets_service_client` (Vervollständigung)

**Zweck:** Client für `org.freedesktop.Secret.Service`.

**Datei:** `src/dbus_interfaces/secrets_service_client/types.rs`

- **Struct `Secret`**: `session: DBusObjectPath`, `parameters: Vec<u8>`, `value: Vec<u8>`, `content_type: String`.
- **Struct `SecretItemProperties`**: `label: String`, `attributes: HashMap<String, String>`, `created: u64`, `modified: u64`, `locked: bool`.
- **Event:** `SecretServiceEvent::PromptRequired { prompt_path: DBusObjectPath }`, `SecretServiceEvent::PromptCompleted { prompt_path: DBusObjectPath, dismissed: bool }`.

**Datei:** `src/dbus_interfaces/secrets_service_client/proxies.rs`

- **`SecretServiceProxy` (`org.freedesktop.Secret.Service`)**: Methoden (`OpenSession`, `CreateCollection`, `SearchItems`, `Unlock`, `Lock`, `GetSecrets`, `ReadAlias`, `SetAlias`). Properties (`Collections`, `State`). Signal (`CollectionCreated`, `CollectionDeleted`, `CollectionChanged`).
- **`SecretSessionProxy` (`org.freedesktop.Secret.Session`)**: Methode (`Close`). (Lebensdauer beachten).
- **`SecretCollectionProxy` (`org.freedesktop.Secret.Collection`)**: Methoden (`Delete`, `SearchItems`, `CreateItem`). Properties (`Items`, `Label`, `Locked`, `Created`, `Modified`). Signal (`ItemCreated`, `ItemDeleted`, `ItemChanged`).
- **`SecretItemProxy` (`org.freedesktop.Secret.Item`)**: Methoden (`Delete`, `GetSecret`, `SetSecret`). Properties (`Locked`, `Attributes`, `Label`, `Type`, `Created`, `Modified`).
- **`SecretPromptProxy` (`org.freedesktop.Secret.Prompt`)**: Methode (`Prompt`). Signal (`Completed`).

**Datei:** `src/dbus_interfaces/secrets_service_client/service.rs`

- **Struct `SecretsServiceClientService`**:
    - **Felder:** Connection, `service_proxy: SecretServiceProxy`, `default_collection_alias: String` (z.B. "novade_default" oder "login"), `open_sessions: Arc<tokio::sync::Mutex<HashMap<DBusObjectPath, SecretSessionProxy<'static>>>>`. Event-Publisher für `SecretServiceEvent`.
    - **Konstruktor:** `new(...)`.
    - **`initialize_and_listen()`**: Öffnet eine initiale Session für die Default-Collection (oder "login"). Abonniert Signale von `SecretServiceProxy`.
    - **Öffentliche Methoden:**
        - `async fn ensure_collection_exists(&self, alias: &str, label: &str) -> Result<DBusObjectPath, DBusInterfaceError>`
        - `async fn store_secret_in_collection(&self, collection_path_or_alias: &str, item_label: &str, secret_content: &[u8], attributes: HashMap<String, String>, content_type: &str, replace: bool) -> Result<DBusObjectPath /* item_path */, DBusInterfaceError>`
        - `async fn retrieve_secret_from_item(&self, item_path: &DBusObjectPath) -> Result<Vec<u8>, DBusInterfaceError>`
        - `async fn search_items_in_collection(&self, collection_path_or_alias: &str, attributes: HashMap<String, String>) -> Result<Vec<(DBusObjectPath, SecretItemProperties)>, DBusInterfaceError>`
        - `async fn delete_item(&self, item_path: &DBusObjectPath) -> Result<(), DBusInterfaceError>`
        - `async fn unlock_items_or_paths(&self, paths: &[DBusObjectPath]) -> Result<(), DBusInterfaceError>`: Ruft `Unlock` auf `SecretServiceProxy`. Startet Task, um `Prompt.Completed`-Signal zu behandeln.
    - **Handhabung von `Prompt`**: Wenn `Unlock` einen `Prompt`-Pfad zurückgibt, wird ein `SecretPromptProxy` erstellt, `Prompt()` aufgerufen und das `Completed`-Signal abgewartet. Das `SecretServiceEvent` wird gesendet, um UI ggf. zu informieren.

**Implementierungsschritte `secrets_service_client`**:

1. Typen, Proxies, Service-Struktur.
2. Implementierung der Methoden, insbesondere der komplexen Abläufe mit Sessions und Collections.
3. Sorgfältige Handhabung von `Unlock`-Prompts und deren Signalen.
4. Tests mit gemocktem D-Bus.

---

#### 3.7. Submodul: `system::dbus_interfaces::policykit_client` (Vervollständigung)

**Zweck:** Client für `org.freedesktop.PolicyKit1.Authority`.

**Datei:** `src/dbus_interfaces/policykit_client/types.rs`

- **Enum `PolicyKitImplicitAuthorization`**: (aus Polkit-Spezifikation) `Unknown, NotAuthorized, AuthenticationRequired, AdministratorAuthenticationRequired, AuthenticationRequiredRetained, AdministratorAuthenticationRequiredRetained, Authorized`. `#[repr(u32)]`, `Type`.
- **Struct `PolicyKitAuthorizationResultDetails`**: Enthält zusätzliche Daten vom Result.
- **Struct `PolicyKitSubjectSystemBusName`**: `name: String`.
- **Enum `PolicyKitSubjectKind`**: `User { user_id: u32 }`, `SystemBusName { name: String }`, `Binary { path: String, pid: Option<u32> }`. (Vereinfacht, Polkit hat komplexere Subject-Typen).

**Datei:** `src/dbus_interfaces/policykit_client/proxies.rs`

- **`PolicyKitAuthorityProxy` für `org.freedesktop.PolicyKit1.Authority`**:
    
    Rust
    
    ```
    #[proxy(
        interface = "org.freedesktop.PolicyKit1.Authority",
        default_service = "org.freedesktop.PolicyKit1",
        default_path = "/org/freedesktop/PolicyKit1/Authority"
    )]
    trait PolicyKitAuthority {
        // flags: 0x00000001 (ALLOW_USER_INTERACTION)
        // cancellation_id: String (leer für keinen)
        async fn check_authorization(
            &self,
            subject: zbus::zvariant::Value<'_>, // ('sys', {'unix-process': <{'pid': <uint32 ProcessID>, 'start-time': <uint64 StartTime>}>})
            action_id: &str,
            details: std::collections::HashMap<&str, &str>,
            flags: u32,
            cancellation_id: &str,
        ) -> zbus::Result<(bool, bool, Dict<'static, String, Value<'static>>)>; // (is_authorized, is_challenge, details)
        // Weitere Methoden wie EnumerateActions, RegisterAuthenticationAgent etc.
    }
    ```
    
    - **Hinweis:** Der `subject`-Parameter ist komplex (`a{sv}`). `zbus` sollte dies als `Value` oder `Dict` handhaben können.

**Datei:** `src/dbus_interfaces/policykit_client/service.rs`

- **Struct `PolicyKitClientService`**:
    - **Felder:** Connection, `authority_proxy: PolicyKitAuthorityProxy`.
    - **Konstruktor:** `new(...)`.
    - **Öffentliche Methode `async fn check_authorization(...) -> Result<PolicyKitAuthorizationDetails, DBusInterfaceError>`**:
        1. Konstruiert das `subject`-Value (z.B. für den aktuellen Prozess `std::process::id()`).
        2. Ruft `authority_proxy.check_authorization(...)`.
        3. Parst das Ergebnis-Tuple in `PolicyKitAuthorizationDetails`.
        4. UI-Interaktion für Passwortabfragen wird vom systemweiten PolicyKit-Agenten gehandhabt, nicht von diesem Client.

**Implementierungsschritte `policykit_client`**:

1. Typen, Proxy, Service-Struktur.
2. `check_authorization` Implementierung mit korrekter Erstellung des `subject`-Parameters.
3. Tests mit gemocktem D-Bus.

---

#### 3.8. Submodul: `system::dbus_interfaces::notifications_server` (Vervollständigung)

**Zweck:** Implementierung des `org.freedesktop.Notifications` D-Bus-Servers.

**Datei:** `src/dbus_interfaces/notifications_server/service_object.rs`

- **Struct `FreedesktopNotificationsServer`**:
    - **Felder:**
        - `notification_service: Arc<Mutex<dyn NotificationService>>`
        - `id_map: Arc<tokio::sync::Mutex<HashMap<u32, Uuid>>>` (D-Bus ID -> Domain ID)
        - `reverse_id_map: Arc<tokio::sync::Mutex<HashMap<Uuid, u32>>>` (Domain ID -> D-Bus ID)
        - `next_dbus_id: Arc<tokio::sync::atomic::AtomicU32>` (Für eindeutige D-Bus IDs)
        - `signal_ctxt_sender: tokio::sync::mpsc::Sender<DbusSignalTask>` (Um Signale aus einem anderen Kontext senden zu können)
    - **Enum `DbusSignalTask`**: `NotificationClosed { dbus_id: u32, reason: u32 }`, `ActionInvoked { dbus_id: u32, action_key: String }`.
    - **Konstruktor `new(...)`**: Initialisiert Felder. Startet einen `tokio::task`, der Domain-Events (`NotificationDismissedEvent`, `NotificationActionInvokedEvent`) vom `notification_service` empfängt (über dessen `subscribe` Methode), die Domain-UUIDs in D-Bus-`u32`-IDs umwandelt und Tasks über `signal_ctxt_sender` sendet, um die D-Bus-Signale zu emittieren.
    - **D-Bus Methoden Implementierung (`#[dbus_interface(...)]`)**:
        - **`notify(...)`**:
            1. Konvertiert D-Bus Parameter in `NotificationInput`.
            2. Ruft `self.notification_service.lock().await.post_notification(input).await`.
            3. Bei Erfolg: Generiert neue `dbus_id` (aus `next_dbus_id`), speichert Mapping zu Domain-`Uuid`, gibt `dbus_id` zurück.
        - **`close_notification(id: u32)`**:
            1. Findet Domain-`Uuid` für `id` in `id_map`.
            2. Ruft `self.notification_service.lock().await.dismiss_notification(domain_id, DismissReason::DbusRequest).await`. (Grund anpassen)
        - **`get_server_information()`, `get_capabilities()`**: Wie zuvor.
    - **D-Bus Signale**: (`notification_closed`, `action_invoked`) werden von dem separaten Task gesendet, der auf Domain-Events lauscht und den `SignalContext` vom Server-Objekt benötigt. Der `SignalContext` kann geklont und an den Task übergeben werden oder man verwendet den `signal_ctxt_sender` um die Aufgabe ans Hauptobjekt zu delegieren.
- **Funktion zum Starten des D-Bus Dienstes:**
    
    Rust
    
    ```
    // In service_object.rs oder mod.rs
    pub async fn run_notifications_server(
        notification_service: Arc<Mutex<dyn NotificationService>>,
        // broadcast_receiver_for_domain_events: tokio::sync::broadcast::Receiver<NotificationEventEnum>
    ) -> Result<(), DBusInterfaceError> {
        let conn = DBusConnectionManager::session_bus().await?;
        let server_logic = Arc::new(FreedesktopNotificationsServer::new(notification_service));
    
        // Task starten, der Domain-Events in D-Bus-Signale umwandelt
        // Dieser Task benötigt eine Möglichkeit, Signale zu senden.
        // Entweder durch Klonen des SignalContext (falls möglich und sicher)
        // oder durch einen internen MPSC-Kanal zum Server-Objekt.
        // setup_domain_event_to_dbus_signal_handler(server_logic.clone(), broadcast_receiver_for_domain_events);
    
        conn.object_server().at("/org/freedesktop/Notifications", server_logic)?.await?;
        conn.request_name("org.freedesktop.Notifications", zbus:: stazione::RequestNameFlags::ReplaceExisting.into()).await?;
        tracing::info!("org.freedesktop.Notifications D-Bus Service gestartet und Name angefordert.");
        // Die Connection muss am Leben erhalten werden, z.B. indem der Server in einem blockierenden Task läuft
        // oder die Connection selbst in einem Arc gehalten und nie fallengelassen wird.
        // Für einen langlaufenden Dienst ist es üblich, dass diese Funktion nicht zurückkehrt oder
        // die Connection in einer globalen Variable/einem Manager gehalten wird.
        std::future::pending::<()>().await; // Hält den Server am Laufen
        Ok(())
    }
    ```
    

#### 3.10. `system::dbus_interfaces::mod.rs`

- Deklariert alle Submodule (`common`, `upower_client`, `logind_client`, etc.).
- Re-exportiert die öffentlichen Service-Structs/Traits und wichtigen Event-Typen/Fehler.

---

### Modul 4: `system::audio_management` (Vervollständigung)

Zweck: PipeWire-Integration für Audio-Steuerung.

Bestehende Spezifikation: Skizziert in der vorherigen Antwort.

**Datei:** `src/audio_management/types.rs` (Vervollständigung)

- **`AudioDevice`**:
    - Zusätzliche Felder: `ports: Vec<AudioPortInfo>`, `active_profile_index: Option<u32>`, `profiles: Vec<AudioProfileInfo>`, `form_factor: String` (z.B. "headset", "speaker", "microphone"), `bus_path: String`.
- **`AudioPortInfo`**: `id: u32`, `name: String`, `direction: pipewire::spa::Direction`, `available: bool`.
- **`AudioProfileInfo`**: `index: u32`, `name: String`, `description: String`, `available: bool`, `priority: u32`.
- **`AudioStream`**:
    - Zusätzliche Felder: `process_id: Option<u32>`, `process_binary_name: Option<String>`, `is_corked: bool`.
- **`AudioEvent`**:
    - `DefaultDeviceChanged` Payload: `{ device_type: AudioDeviceType, new_default_device: Option<AudioDevice> }` (ganzes Objekt statt nur ID).
    - `DevicePropertiesChanged(AudioDevice)` (Wenn sich andere Properties als nur Volume/Mute ändern).
    - `StreamPropertiesChanged(AudioStream)`.

**Datei:** `src/audio_management/client/pipewire_listener.rs` (Neues Submodul/Datei)

- **Struct `PipeWireRegistryEventHandler`**:
    - **Felder:** `devices: Arc<tokio::sync::RwLock<HashMap<u32, AudioDevice>>>`, `streams: Arc<tokio::sync::RwLock<HashMap<u32, AudioStream>>>`, `default_sink_id: Arc<tokio::sync::RwLock<Option<u32>>>`, `default_source_id: Arc<tokio::sync::RwLock<Option<u32>>>`, `event_publisher: tokio::sync::broadcast::Sender<AudioEvent>`, `core_ref: Weak<pipewire::Core>` (um Proxies zu erstellen).
    - **Methoden (Callbacks für `RegistryListener`):**
        - **`global(global_object)`**:
            1. Prüft Typ (`Node` für Geräte, `Client`/`Stream` für Streams, `Metadata` für Defaults).
            2. Für `Node`:
                - `node_proxy = registry.bind::<pipewire::node::Node>(&global_object)?;`
                - Properties parsen (media.class, device.description, device.api, etc.) um `AudioDeviceType` zu bestimmen.
                - Listener für `node_proxy.receive_info_changed()` und `node_proxy.receive_param_changed()` einrichten.
                    - `info_changed`: Aktualisiert `AudioDevice`-Properties, sendet `DevicePropertiesChanged` oder `DeviceListChanged`.
                    - `param_changed` (für "Props", "Route"): Aktualisiert Volume/Mute in `AudioDevice`, sendet `DeviceVolumeChanged`.
                - Erstellt `AudioDevice`, speichert in `devices`, sendet `DeviceListChanged`.
            3. Für `Stream` (oder `Client`, das Streams hat): Analog für `AudioStream`.
            4. Für `Metadata` (Name "default"):
                - Listener für `metadata_proxy.receive_property_changed()` einrichten.
                - Bei Änderung von "default.audio.sink" oder "default.audio.source": Aktualisiere `default_sink_id`/`default_source_id`, finde das `AudioDevice`-Objekt, setze `is_default`, sende `DefaultDeviceChanged`.
        - **`global_remove(id)`**: Entfernt Objekt aus Maps, sendet `DeviceListChanged`/`StreamListChanged`.
- **Struct `PipeWireCoreEventHandler`**:
    - **Felder:** `event_publisher: tokio::sync::broadcast::Sender<AudioEvent>`.
    - **Methoden (Callbacks für `CoreListener`):**
        - `info(info)`: Prüft `info.change_mask` für `CoreChangeMask::PROPS`, um Server-Verbindungsstatus zu erkennen. Sendet `ServerConnectionStateChanged`.
        - `error(...)`: Loggt Fehler.

**Datei:** `src/audio_management/client/service.rs` (oder `mod.rs`)

- **`PipeWireClientService`**:
    - **Konstruktor `new(...)`**:
        1. Initialisiert PipeWire-Objekte.
        2. Erstellt `PipeWireRegistryEventHandler` und `PipeWireCoreEventHandler`.
        3. `registry.add_listener_local(registry_event_handler_struct)` (oder `Weak` Referenzen verwenden, um Zyklen zu vermeiden, Listener müssen `'static` sein für `add_listener_local`).
        4. `core.add_listener_local(core_event_handler_struct)`.
        5. Startet `MainLoop`-Thread.
    - **Setter-Methoden (`set_device_volume`, `set_default_device` etc.):**
        - Müssen nun asynchron mit dem `MainLoop`-Thread kommunizieren, wenn die `pipewire-rs`-Proxies nicht `Send` sind oder Operationen im Loop-Kontext erfordern.
        - **Ansatz 1 (Kanal zum MainLoop-Thread):**
            - `PipeWireClientService` hält `command_sender: tokio::sync::mpsc::Sender<AudioCommand>`.
            - Im `MainLoop`-Thread wird ein `mpsc::Receiver<AudioCommand>` abgefragt.
            - `AudioCommand` Enum: `SetDeviceVolume { pw_id: u32, volume: u8, mute: bool }, SetDefaultDevice { ... }`.
            - Setter-Methoden senden Befehl über Kanal. `MainLoop` führt Aktion aus, aktualisiert internen Zustand und der Listener sendet dann das `AudioEvent`.
        - **Ansatz 2 (Proxies direkt nutzen, wenn `Send`):** Wenn `pipewire::node::Node` (der Proxy) `Send` ist, können die Setter-Methoden ihn direkt verwenden. Die Aktualisierung der `AudioDevice`-Struktur und das Senden des `AudioEvent` erfolgt dann immer noch über den Listener-Pfad als Reaktion auf das `param_changed`-Signal von PipeWire.
    - **`Youtube_property(core_proxy: &Arc<Core>, key: &str) -> Option<String>`**: Hilfsfunktion zum Lesen von Metadaten-Properties für Default-Geräte.

#### 4.4. Implementierungsschritte `system::audio_management` (Fortsetzung)

1. **`types.rs`**: `AudioDevice`, `AudioStream`, `AudioEvent` vervollständigen. `AudioPortInfo`, `AudioProfileInfo`.
2. **`errors.rs`**: `AudioManagementError` vervollständigen.
3. **`client/pipewire_listener.rs`**: `PipeWireRegistryEventHandler` und `PipeWireCoreEventHandler` implementieren, inklusive der detaillierten Logik in den Callbacks zum Parsen von Properties und Senden von Events.
4. **`client/service.rs`**:
    - `PipeWireClientService`-Struktur mit Feldern für PipeWire-Objekte, Listener-Handles und Zustand (Maps, Default-IDs) definieren.
    - `new()`-Konstruktor: Initialisierung, Listener-Registrierung, `MainLoop`-Thread starten.
    - Getter-Methoden implementieren (lesen aus den `RwLock`-geschützten Maps).
    - Setter-Methoden implementieren:
        - Entscheiden, ob Kommunikation mit MainLoop-Thread via Kanal nötig ist oder ob Proxies direkt verwendet werden können.
        - SPA Pods für Lautstärke etc. korrekt erstellen.
        - `set_default_device` über PipeWire-Metadaten implementieren.
    - `shutdown()`-Methode.
5. **Tests**: Fokus auf korrekte Erstellung von SPA Pods, Parsing von Properties in Listenern (mit Beispiel-Property-Dicts), korrekte Event-Erzeugung. Integrationstests mit laufendem PipeWire-Server sind ideal, aber schwer aufzusetzen.

---

**Nächste Schritte für `system` (Skizze für verbleibende Module):**

- **Modul 5: `system::mcp_client`**:
    - **Zweck:** Implementierung des Model Context Protocol Clients.
    - **Verantwortlichkeiten:** Verbindung zu MCP-Servern, Senden von Anfragen (Ressourcenauflistung, Tool-Aufrufe) basierend auf Anweisungen von `domain::user_centric_services::ai_interaction`, Empfangen und Weiterleiten von Antworten/Benachrichtigungen. API-Schlüssel-Management via `secrets_service_client`.
    - **Technologie:** `mcp_client_rs` Crate.
    - **Struktur:** `connection.rs` (Verwaltung der Verbindung, ggf. Starten eines lokalen MCP-Server-Prozesses), `protocol_handler.rs` (Wrapper um `mcp_client_rs::McpClient`), `resource_provider.rs` (stellt `mcp_client_rs::Resource`s bereit, z.B. für Dateisystemzugriff, Zwischenablage – interagiert mit anderen Systemmodulen).
    - **Fehler:** `McpClientError`.
    - **Events:** `McpResponseEvent`, `McpNotificationEvent`.
- **Modul 6: `system::window_mechanics`**:
    - **Zweck:** Technische Umsetzung des Fenstermanagements (Positionierung, Größe, Stapelreihenfolge, Tiling, Fokus, Dekorationen).
    - **Verantwortlichkeiten:** Nimmt `WorkspaceWindowLayout` von `domain::window_management_policy` entgegen und wendet es auf `ManagedWindow`s im `system::compositor::core::DesktopState::space` an. Sendet `configure`-Events an Wayland-Clients. Handhabt interaktive Operationen (Move/Resize-Grabs). Koordiniert Server-Side Decorations (SSD) mit Client-Side Decorations (CSD) basierend auf `xdg-decoration`-Protokoll und Domänen-Policy.
    - **Interaktion:** Eng mit `system::compositor` (insb. `xdg_shell` und `Space`) und `domain::window_management_policy`.
    - **Fehler:** `WindowMechanicsError`.
- **Modul 7: `system::event_bridge`**:
    - **Zweck:** Eine zentrale Stelle für System-interne Events, die nicht direkt an einen spezifischen D-Bus-Dienst oder ein Wayland-Protokoll gebunden sind.
    - **Verantwortlichkeiten:** Definition von generischen System-Event-Typen. Bereitstellung von `tokio::sync::broadcast` Kanälen für diese Events.
    - **Beispiel-Events:** `InputDeviceHotplugEvent { device_name: String, event_type: HotplugType (Added/Removed) }`, `SystemSuspendRequestEvent { operation: SuspendOperation (Suspend/Hibernate) }`, `ActiveOutputConfigurationChangedEvent`.
    - Dient als Entkopplungsschicht innerhalb des Systems.
- **Modul 8: `system::power_management`**:
    - **Zweck:** Implementierung von DPMS und Interaktion mit `wlr-output-power-management`.
    - **Verantwortlichkeiten:** Hört auf `UserActivityDetectedEvent` und `LogindEvent::SystemIdleHintChanged`. Liest Energieeinstellungen von `domain::global_settings_service`. Steuert den DPMS-Zustand von Outputs über die Compositor-Schnittstelle (z.B. direkte Aufrufe an DRM-Backend oder über `wlr-output-power-management`-Protokoll, falls als Client implementiert).
    - **Interaktion:** `system::compositor::output_management` (für serverseitige `wlr-output-power-management`-Implementierung), `system::dbus_interfaces::logind_client`, `domain::global_settings_service`.
    - **Fehler:** `PowerManagementError`.

Diese detaillierte Aufschlüsselung und die Pläne für die einzelnen Module sollten eine sehr klare Richtung für die Implementierung der Systemschicht geben. Der Fokus liegt auf der korrekten Integration externer Bibliotheken und Protokolle, der robusten Fehlerbehandlung und der Bereitstellung klarer Schnittstellen zur Domänen- und UI-Schicht.

---

### Modul 5: `system::mcp_client`

Zweck: Implementierung des Clients für das Model Context Protocol (MCP), um sicher mit lokalen oder Cloud-basierten KI-Modellen (LLMs) zu interagieren.

Verantwortlichkeiten:

- Aufbau und Verwaltung der Verbindung zu einem MCP-Server (kann ein lokaler Prozess oder ein Remote-Endpunkt sein).
- Senden von Anfragen an den MCP-Server (z.B. `ListResources`, `CallTool`) basierend auf Anweisungen von `domain::user_centric_services::ai_interaction`.
- Empfangen von Antworten und asynchronen Benachrichtigungen vom MCP-Server.
- Sichere Handhabung von API-Schlüsseln (via `system::dbus_interfaces::secrets_service_client`) für Cloud-basierte Modelle.
- Bereitstellung einer abstrahierten Schnittstelle für die Domänenschicht, um KI-Funktionen anzufordern, ohne MCP-Protokolldetails kennen zu müssen. **Design-Rationale:** Kapselung der MCP-spezifischen Kommunikationslogik. Nutzung des `mcp_client_rs` Crates als Basis. Ermöglichung einer flexiblen Anbindung verschiedener KI-Modelle, die das MCP unterstützen. **Technologie:** `mcp_client_rs` Crate, `tokio` für asynchrone Operationen, `serde` für Datenstrukturen.

#### 5.1. Untermodul: `system::mcp_client::types`

**Datei:** `src/mcp_client/types.rs`

- **Struct `McpServerConfig`** (Konfiguration für die Verbindung zu einem MCP-Server):
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
    pub enum McpServerType {
        LocalExecutable {
            command: String,
            args: Vec<String>,
            working_directory: Option<String>,
        },
        RemoteHttp {
            endpoint_url: String, // z.B. "http://localhost:8000/mcp"
            // api_key_secret_name: Option<String>, // Wird über AIModelProfile gehandhabt
        },
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
    pub struct McpServerConfig {
        pub server_id: String, // Eindeutige ID für diese Serverkonfiguration
        pub server_type: McpServerType,
        #[serde(default)]
        pub default_request_timeout_ms: u64, // Standard-Timeout für Anfragen
    }
    
    impl Default for McpServerConfig {
        fn default() -> Self {
            Self {
                server_id: "default_local_mcp".to_string(),
                server_type: McpServerType::LocalExecutable {
                    command: "nova-mcp-server".to_string(), // Beispiel
                    args: vec![],
                    working_directory: None,
                },
                default_request_timeout_ms: 30000, // 30 Sekunden
            }
        }
    }
    ```
    
- **Re-Export und Wrapper für `mcp_client_rs::protocol` Typen (falls nötig):**
    - `pub use mcp_client_rs::protocol::{InitializeParams, InitializeResult, ListResourcesParams, ListResourcesResult, Resource, CallToolParams, CallToolResult, ToolCall, ToolResult, McpMessage, Notification, ErrorResponse, ErrorCode};`
    - Ggf. eigene Wrapper-Structs, wenn Felder hinzugefügt oder angepasst werden müssen.
- **Event-Struktur (für `system::event_bridge` oder direkt an Domäne):**
    
    Rust
    
    ```
    use mcp_client_rs::protocol::{Notification as McpNotification, ErrorResponse as McpErrorResponse, ToolResult as McpToolResult};
    use uuid::Uuid;
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum McpClientEvent {
        McpNotificationReceived {
            server_id: String,
            interaction_id: Option<Uuid>, // Interne ID der AIInteractionContext
            notification: McpNotification,
        },
        McpToolCallSuccessful {
            server_id: String,
            interaction_id: Uuid,
            request_id: String, // Aus CallToolParams
            tool_result: McpToolResult,
        },
        McpRequestFailed {
            server_id: String,
            interaction_id: Option<Uuid>,
            request_id: Option<String>,
            error: McpErrorResponse, // Der MCP-Fehler
        },
        McpServerError { // Für Verbindungsfehler etc.
            server_id: String,
            message: String,
        },
        McpServerConnectionStateChanged {
            server_id: String,
            is_connected: bool,
        }
    }
    ```
    

#### 5.2. Untermodul: `system::mcp_client::errors`

**Datei:** `src/mcp_client/errors.rs`

- **Enum `McpSystemClientError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use mcp_client_rs::Error as McpLibError;
    use crate::dbus_interfaces::common::DBusInterfaceError; // Für Secrets Service Fehler
    
    #[derive(Debug, Error)]
    pub enum McpSystemClientError {
        #[error("MCP Server configuration not found for ID: {0}")]
        ServerConfigNotFound(String),
        #[error("Failed to start local MCP server (command: '{command}'): {source}")]
        LocalServerStartFailed {
            command: String,
            #[source]
            source: std::io::Error,
        },
        #[error("MCP client library error: {0}")]
        McpLibError(#[from] McpLibError),
        #[error("Failed to retrieve API key '{secret_name}' from secrets service: {source}")]
        ApiKeyRetrievalFailed {
            secret_name: String,
            #[source]
            source: DBusInterfaceError,
        },
        #[error("API key '{secret_name}' not found in secrets service.")]
        ApiKeyNotFound(String),
        #[error("MCP request timed out for request ID '{request_id}' to server '{server_id}'.")]
        RequestTimeout { server_id: String, request_id: String },
        #[error("MCP Server '{server_id}' is not connected or connection lost.")]
        ServerNotConnected(String),
        #[error("No active MCP server connection available.")]
        NoActiveConnection,
        #[error("Internal MCP client error: {0}")]
        InternalError(String),
    }
    ```
    

#### 5.3. Submodul: `system::mcp_client::connection_manager`

**Zweck:** Verwaltung von Verbindungen zu MCP-Servern (lokal oder remote), inklusive Starten lokaler Server.

**Datei:** `src/mcp_client/connection_manager.rs`

- **Struct `McpConnection`**:
    - **Felder:**
        - `server_id: String`
        - `client: mcp_client_rs::McpClient` (Der eigentliche Client aus dem Crate)
        - `local_process_handle: Option<tokio::process::Child>` (Für lokale Server)
        - `is_connected: Arc<tokio::sync::watch::Sender<bool>>`
    - **Methoden:**
        - `pub async fn new(config: &McpServerConfig, api_key: Option<String>) -> Result<Self, McpSystemClientError>`:
            1. Wenn `config.server_type` `LocalExecutable`:
                - Starte den Prozess mit `tokio::process::Command`. Speichere `Child` Handle.
                - `client = McpClient::connect_local_stdio(child_process_stdio).await?`
            2. Wenn `config.server_type` `RemoteHttp`:
                - `client = McpClient::connect_http(&config.endpoint_url, api_key).await?`
            3. Setze `is_connected` auf `true`.
        - `pub async fn close(&mut self)`: Schließt die Verbindung, beendet ggf. lokalen Prozess.
        - Getter für `client`.
- **Struct `McpConnectionManager`**:
    - **Felder:**
        - `connections: Arc<tokio::sync::Mutex<HashMap<String /* server_id */, Arc<McpConnection>>>>`
        - `server_configs: Arc<tokio::sync::RwLock<HashMap<String /* server_id */, McpServerConfig>>>` (Geladen aus `core::config` oder `GlobalSettingsService`)
        - `secrets_service: Arc<dyn crate::dbus_interfaces::secrets_service_client::SecretsServiceClient>` // Pfad anpassen
        - `event_publisher: tokio::sync::broadcast::Sender<McpClientEvent>`
    - **Konstruktor `new(...)`**: Nimmt `secrets_service` und `event_publisher`. Lädt `server_configs` initial.
    - **Methoden:**
        - `pub async fn load_server_configs(&self, configs: Vec<McpServerConfig>)`: Aktualisiert `self.server_configs`.
        - `pub async fn get_or_connect(&self, server_id: &str, ai_model_profile: Option<&crate::domain::user_centric_services::ai_interaction::types::AIModelProfile>) -> Result<Arc<McpConnection>, McpSystemClientError>`:
            1. Prüft, ob Verbindung in `connections` existiert und verbunden ist. Wenn ja, zurückgeben.
            2. Sucht `McpServerConfig` in `server_configs`. Wenn nicht -> `ServerConfigNotFound`.
            3. Wenn `config.server_type` `RemoteHttp` und `ai_model_profile.api_key_secret_name` gesetzt ist:
                - Rufe `self.secrets_service.retrieve_secret_by_label_or_item_path(...)` auf, um API-Key zu holen. Fehler bei Fehlschlag.
            4. Erstelle neue `McpConnection::new(&config, api_key)`.
            5. Speichere in `connections`.
            6. Starte einen Task, der auf Nachrichten/Notifications vom `mcp_connection.client.receive_message()` lauscht und `McpClientEvent`s publiziert.
            7. Sendet `McpServerConnectionStateChanged`.
        - `pub async fn disconnect(&self, server_id: &str) -> Result<(), McpSystemClientError>`: Schließt Verbindung, entfernt aus `connections`. Sendet `McpServerConnectionStateChanged`.
        - `pub async fn get_active_connection_for_model(&self, model_profile: &crate::domain::user_centric_services::ai_interaction::types::AIModelProfile) -> Result<Arc<McpConnection>, McpSystemClientError>`:
            - Bestimmt `server_id` basierend auf `model_profile` (z.B. wenn Profil eine `mcp_server_id` enthält oder ein Default verwendet wird).
            - Ruft `get_or_connect(server_id, Some(model_profile))`.

#### 5.4. Submodul: `system::mcp_client::service`

**Zweck:** Implementierung des `SystemMcpService` Traits, der die Abstraktion zur Domänenschicht darstellt.

**Datei:** `src/mcp_client/service.rs`

- **Trait `SystemMcpService`** (definiert, was die Domänenschicht vom MCP-Client erwartet):
    
    Rust
    
    ```
    use async_trait::async_trait;
    use super::types::*; // McpClientEvent, McpSystemClientError etc.
    use crate::domain::user_centric_services::ai_interaction::types::AIModelProfile;
    use uuid::Uuid;
    
    #[async_trait]
    pub trait SystemMcpService: Send + Sync {
        /// Initialisiert den MCP-Client mit Serverkonfigurationen.
        async fn configure_servers(&self, server_configs: Vec<McpServerConfig>) -> Result<(), McpSystemClientError>;
    
        /// Sendet eine `Initialize` Nachricht an einen spezifischen MCP-Server.
        async fn initialize_server(
            &self,
            server_id: &str,
            params: InitializeParams,
            model_profile: Option<&AIModelProfile>, // Für API-Key etc.
        ) -> Result<InitializeResult, McpSystemClientError>;
    
        /// Listet Ressourcen vom MCP-Server auf.
        async fn list_resources(
            &self,
            server_id: &str,
            params: ListResourcesParams,
            model_profile: Option<&AIModelProfile>,
            interaction_id: Option<Uuid>, // Für Event-Korrelation
        ) -> Result<ListResourcesResult, McpSystemClientError>;
    
        /// Ruft ein Tool auf dem MCP-Server auf.
        async fn call_tool(
            &self,
            server_id: &str,
            params: CallToolParams,
            model_profile: Option<&AIModelProfile>,
            interaction_id: Uuid, // Für Event-Korrelation und Timeout-Management
        ) -> Result<CallToolResult, McpSystemClientError>; // McpClient::call_tool gibt McpMessage zurück
    
        /// Abonniert MCP-Client-Events.
        fn subscribe_to_mcp_events(&self) -> tokio::sync::broadcast::Receiver<McpClientEvent>;
    }
    ```
    
- **Struct `DefaultSystemMcpService`**:
    - **Felder:** `connection_manager: Arc<McpConnectionManager>`.
    - **Konstruktor `new(connection_manager: Arc<McpConnectionManager>) -> Self`**.
    - **Implementierung von `SystemMcpService`**:
        - `configure_servers`: Ruft `connection_manager.load_server_configs()`.
        - `initialize_server`, `list_resources`, `call_tool`:
            1. `mcp_conn = self.connection_manager.get_or_connect(server_id, model_profile).await?;`
            2. `let client = &mcp_conn.client;`
            3. Erstelle `McpMessage` für die Anfrage.
            4. `response_message = client.send_request(request_message).await.map_err(McpSystemClientError::from)?;` (Timeout hier oder im `McpClient` Crate)
            5. Parse `response_message` in den erwarteten Ergebnistyp (z.B. `InitializeResult`). Bei Fehler `McpSystemClientError::McpLibError` oder spezifischer.
            6. Für `call_tool`, wenn erfolgreich, `McpToolCallSuccessful` Event senden (über `connection_manager.event_publisher`).
            7. Bei MCP-Fehlerantwort, `McpRequestFailed` Event senden.
        - `subscribe_to_mcp_events`: Gibt `connection_manager.event_publisher.subscribe()` zurück.

#### 5.5. `system::mcp_client::mod.rs`

- Deklariert Submodule.
- Re-exportiert `SystemMcpService`-Trait, `DefaultSystemMcpService` (als konkrete Implementierung), `McpClientEvent`, `McpSystemClientError`, `McpServerConfig`.

#### 5.6. Implementierungsschritte `system::mcp_client`

1. **Grundgerüst**: Verzeichnisse, `Cargo.toml` für `mcp_client_rs`.
2. **`types.rs`**: `McpServerConfig`, `McpClientEvent`, ggf. Wrapper definieren.
3. **`errors.rs`**: `McpSystemClientError` definieren.
4. **`connection_manager.rs`**: `McpConnection`, `McpConnectionManager` implementieren. Logik zum Starten lokaler Server, API-Key-Abruf via `SecretsServiceClientService`. Task für `client.receive_message()` und Event-Publishing.
5. **`service.rs`**: `SystemMcpService`-Trait und `DefaultSystemMcpService`-Implementierung.
6. **Unit-Tests**:
    - Testen von `McpServerConfig`-Serialisierung.
    - Testen der `McpConnectionManager`-Logik (Mocking von `SecretsServiceClientService` und `mcp_client_rs::McpClient` falls möglich, oder Integrationstests gegen einen Dummy-MCP-Server).
    - Testen der `DefaultSystemMcpService`-Methoden (Mocking von `McpConnectionManager`).

---

### Modul 6: `system::window_mechanics`

Zweck: Technische Umsetzung des Fenstermanagements basierend auf den Richtlinien der Domänenschicht.

Verantwortlichkeiten:

- Empfangen von `WorkspaceWindowLayout` von `domain::window_management_policy`.
- Anwenden dieser Geometrien auf die tatsächlichen Fenster (`ManagedWindow`s im Compositor).
- Senden von `configure`-Events an Wayland-Clients, um sie über neue Größen/Zustände zu informieren.
- Handhabung interaktiver Operationen (Move/Resize-Grabs), Anwendung von Snapping.
- Koordination von Server-Side Decorations (SSD) und Client-Side Decorations (CSD) in Absprache mit `system::compositor::decoration` und der Domänen-Policy.
- Technische Umsetzung des Fokuswechsels basierend auf Domänenentscheidungen. **Design-Rationale:** Trennt die "Mechanik" (Wie wird ein Fenster bewegt/gegrößert?) von der "Policy" (Wohin soll es bewegt/gegrößert werden?). Enge Kopplung mit dem Compositor (`DesktopState::space`, `ManagedWindow`).

#### 6.1. Submodul: `system::window_mechanics::types`

**Datei:** `src/window_mechanics/types.rs`

- **Struct `InteractiveOpState`** (für laufende Move/Resize Grabs):
    
    Rust
    
    ```
    use smithay::utils::{Logical, Point, Rectangle, Serial};
    use crate::compositor::core::state::ManagedWindow; // Pfad anpassen
    use std::sync::Arc;
    
    #[derive(Debug, Clone)]
    pub enum InteractiveOpType { Move, ResizeEdge(xdg_toplevel::ResizeEdge), ResizeCorner(/* ... */) }
    
    #[derive(Debug, Clone)]
    pub struct InteractiveOpState {
        pub window_arc: Arc<ManagedWindow>, // Das Fenster, das bewegt/vergrößert wird
        pub op_type: InteractiveOpType,
        pub start_pointer_pos_global: Point<f64, Logical>,
        pub initial_window_geometry: Rectangle<i32, Logical>,
        pub last_configure_serial: Option<Serial>, // Um Configure-Storms zu vermeiden
        // Ggf. weitere Felder für Snapping-Feedback etc.
    }
    ```
    
- **Event (System-intern, via `system::event_bridge`):**
    
    Rust
    
    ```
    #[derive(Debug, Clone)]
    pub enum WindowMechanicsEvent {
        WindowConfigured { window_domain_id: DomainWindowIdentifier, new_geometry: RectInt, new_state_flags: u32 },
        InteractiveOpStarted(DomainWindowIdentifier, InteractiveOpType),
        InteractiveOpEnded(DomainWindowIdentifier, InteractiveOpType),
    }
    ```
    

#### 6.2. Submodul: `system::window_mechanics::errors`

**Datei:** `src/window_mechanics/errors.rs`

- **Enum `WindowMechanicsError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use crate::compositor::xdg_shell::errors::XdgShellError; // Pfad anpassen
    
    #[derive(Debug, Error)]
    pub enum WindowMechanicsError {
        #[error("Window not found for mechanics operation: {0:?}")]
        WindowNotFound(crate::domain::workspaces::core::types::WindowIdentifier),
        #[error("Failed to apply layout from domain policy: {0}")]
        LayoutApplicationFailed(String),
        #[error("Error during interactive operation (move/resize): {0}")]
        InteractiveOpFailed(String),
        #[error("XDG Shell operation failed during window mechanics: {0}")]
        XdgShellError(#[from] XdgShellError), // Wenn Configure-Sends etc. fehlschlagen
        #[error("Failed to acquire necessary lock for window operation.")]
        LockFailed,
        #[error("Internal window mechanics error: {0}")]
        InternalError(String),
    }
    ```
    

#### 6.3. Submodul: `system::window_mechanics::layout_applier`

**Zweck:** Anwenden eines von der Domäne berechneten Layouts.

**Datei:** `src/window_mechanics/layout_applier.rs`

- **Funktion `pub async fn apply_workspace_layout(desktop_state: &Arc<Mutex<DesktopState>>, workspace_id: WorkspaceId, layout: &WorkspaceWindowLayout) -> Result<(), WindowMechanicsError>`**:
    1. Sperre `desktop_state`.
    2. Für jede `(domain_window_id, target_geometry)` in `layout.window_geometries`:
        - Finde das `Arc<ManagedWindow>` in `desktop_state.windows` (oder `desktop_state.space`). Wenn nicht: `WindowMechanicsError::WindowNotFound`.
        - `let mut window_guard = managed_window_arc.lock_blocking();` (Oder `async` Lock, wenn `ManagedWindow` selbst einen `async` Mutex hat. Hier Annahme: `ManagedWindow` ist `desktop::Window`, das intern ggf. synchron ist oder dessen `send_configure` etc. synchron sind).
        - **Geometrie setzen:** `window_guard.current_geometry = target_geometry;`
        - **Größe/Status an Client senden:**
            - `if let WindowSurface::Toplevel(toplevel_surface) = &window_guard.xdg_surface { ... }`
            - `toplevel_surface.with_pending_state(|state| { state.size = Some(target_geometry.size); /* state.maximized, .fullscreen etc. basierend auf Layout-Anforderungen setzen */ });`
            - `toplevel_surface.send_configure();` (Dies sendet `xdg_surface.configure` und `xdg_toplevel.configure`).
        - Ggf. `WindowMechanicsEvent::WindowConfigured` senden.
    3. Für Fenster, die im alten Layout waren, aber nicht im neuen (d.h. geschlossen oder auf anderen Workspace verschoben): `desktop_state.space.unmap_window(...)`.
    4. Für neue Fenster im Layout (noch nicht im Space): `desktop_state.space.map_window(...)`.
    5. `desktop_state.space.damage_all_outputs();` (Oder spezifischerer Schaden).

#### 6.4. Submodul: `system::window_mechanics::interactive_ops`

**Zweck:** Handhabung von interaktiven Fenster-Moves und -Resizes.

**Datei:** `src/window_mechanics/interactive_ops.rs`

- **Funktionen zum Starten von Grabs (aufgerufen von `XdgShellHandler` in `system::compositor`):**
    - `pub fn start_interactive_move(desktop_state: &Arc<Mutex<DesktopState>>, seat: &Seat<DesktopState>, window_arc: Arc<ManagedWindow>, serial: Serial, start_pointer_pos: Point<f64, Logical>)`
    - `pub fn start_interactive_resize(desktop_state: &Arc<Mutex<DesktopState>>, seat: &Seat<DesktopState>, window_arc: Arc<ManagedWindow>, serial: Serial, edge: xdg_toplevel::ResizeEdge, start_pointer_pos: Point<f64, Logical>)`
    - **Logik:**
        1. Erstelle `InteractiveOpState`.
        2. `seat.start_pointer_grab(...)` mit einem spezifischen `PointerGrabStartData` und einem `PointerGrab` Handler.
        3. Der `PointerGrab` Handler:
            - **`motion(...)`**:
                - Berechne neue Geometrie basierend auf `delta` und `InteractiveOpState`.
                - Rufe `domain::window_management_policy_service.calculate_snap_target(...)` auf, um Snapping anzuwenden.
                - Aktualisiere `window_arc.lock_blocking().current_geometry` (vorläufig, ohne Configure).
                - Optional: Zeige visuelles Feedback (z.B. Umriss des Fensters an neuer Position – dies ist Renderer-Aufgabe).
            - **`button(...)`**: Wenn Maustaste losgelassen:
                - Finalisiere Geometrie.
                - Sende `configure` an Client (via `window_arc.xdg_surface.toplevel().send_configure()`).
                - Beende den Grab (`pointer_handle.unset_grab()`).
                - Sende `WindowMechanicsEvent::InteractiveOpEnded`.
            - **`axis(...)`**: Ignorieren während Grab.
            - **`cancel(...)`**: Grab abbrechen, Fenster auf `initial_window_geometry` zurücksetzen.

#### 6.5. Submodul: `system::window_mechanics::focus_manager`

**Zweck:** Technische Umsetzung des Fokuswechsels.

**Datei:** `src/window_mechanics/focus_manager.rs`

- **Funktion `pub async fn set_application_focus(desktop_state: &Arc<Mutex<DesktopState>>, seat_name: &str, window_domain_id_to_focus: Option<&DomainWindowIdentifier>, serial: Serial)`**:
    1. Sperre `desktop_state`.
    2. Finde das `Arc<ManagedWindow>` für `window_domain_id_to_focus` (oder `None`).
    3. Rufe `system::input::keyboard::focus::set_keyboard_focus(desktop_state_guard, seat_name, target_wl_surface_option, serial)`.
    4. Aktualisiere `desktop_state_guard.active_input_surface`.
    5. Wenn `target_wl_surface_option` ein Toplevel ist: `target_toplevel.set_activated(true); target_toplevel.send_configure();`
    6. Für den vorherigen Fokus: `old_toplevel.set_activated(false); old_toplevel.send_configure();`
    7. Ggf. Fenster im `Space` anheben (`desktop_state_guard.space.raise_window(...)`).

#### 6.6. Implementierungsschritte `system::window_mechanics`

1. `types.rs`, `errors.rs` definieren.
2. `layout_applier.rs`: `apply_workspace_layout` implementieren.
3. `interactive_ops.rs`: Logik für Start und Handling von Pointer-Grabs für Move/Resize.
4. `focus_manager.rs`: `set_application_focus` implementieren.
5. Tests: Mocking von `DesktopState` (schwierig), `DomainWindowManagementPolicyService`. Testen der Geometrieanwendung. Testen der Grab-Logik (Zustandsübergänge).

---

### Modul 7: `system::power_management`

Zweck: Implementierung von DPMS und Interaktion mit Power-Management-Protokollen/Diensten.

Verantwortlichkeiten: Überwachen der Benutzeraktivität und System-Idle-Hinweise, Anwenden von Energieeinstellungen (Bildschirm-Timeout, Suspend-Verhalten) von der Domänenschicht, Steuerung des DPMS-Zustands von Bildschirmen.

Design-Rationale: Zentralisierung der Energieverwaltungslogik, die sowohl auf Benutzereingaben als auch auf Systemzustände reagiert.

#### 7.1. Untermodul: `system::power_management::types`

**Datei:** `src/power_management/types.rs`

- **Enum `DpmsState`**: `On, Standby, Suspend, Off`.
- **Event (System-intern, via `system::event_bridge`):**
    
    Rust
    
    ```
    #[derive(Debug, Clone)]
    pub enum PowerManagementEvent {
        OutputDpmsStateChanged { output_name: String, new_state: DpmsState },
        SystemSuspending(crate::dbus_interfaces::logind_client::types::LogindPowerOperation), // Pfad anpassen
        SystemResumed,
    }
    ```
    
- **Struct `IdleTimerState`**: `last_activity_ts: DateTime<Utc>`, `current_timeout_secs: u32`, `timer_handle: Option<calloop::TimerHandle>`.

#### 7.2. Untermodul: `system::power_management::errors`

**Datei:** `src/power_management/errors.rs`

- **Enum `PowerManagementError`**:
    
    Rust
    
    ```
    #[derive(Debug, Error)]
    pub enum PowerManagementError {
        #[error("Failed to set DPMS state for output '{output_name}': {reason}")]
        SetDpmsFailed { output_name: String, reason: String },
        #[error("Logind operation failed: {0}")]
        LogindError(#[from] crate::dbus_interfaces::common::DBusInterfaceError), // Pfad anpassen
        #[error("Failed to interact with compositor output management: {0}")]
        CompositorOutputError(String),
        #[error("Internal power management error: {0}")]
        InternalError(String),
    }
    ```
    

#### 7.3. Submodul: `system::power_management::service`

**Zweck:** Hauptlogik des Power-Management-Dienstes.

**Datei:** `src/power_management/service.rs`

- **Struct `PowerManagementService`**:
    - **Felder:**
        - `desktop_state_weak: Weak<Mutex<DesktopState>>` (oder direkter Zugriff, falls in `DesktopState` integriert)
        - `settings_service: Arc<dyn GlobalSettingsService>`
        - `logind_service: Arc<dyn LogindClientService>` // Annahme, dass LogindClientService ein Trait ist
        - `event_publisher: tokio::sync::broadcast::Sender<PowerManagementEvent>`
        - `user_activity_receiver: tokio::sync::broadcast::Receiver<UserActivityDetectedEvent>` (aus `common_events`)
        - `logind_event_receiver: tokio::sync::broadcast::Receiver<LogindEvent>`
        - `output_idle_timers: Arc<tokio::sync::Mutex<HashMap<String /* output_name */, IdleTimerState>>>`
        - `system_idle_timer: Arc<tokio::sync::Mutex<Option<IdleTimerState>>>` // Für automatischen Suspend
    - **Konstruktor `new(...)`**: Nimmt Abhängigkeiten, abonniert `UserActivityDetectedEvent` und `LogindEvent`.
    - **Methode `pub async fn run(&self)`**: Hauptschleife des Dienstes (läuft als `tokio::task`).
        1. Lädt initiale Energieeinstellungen vom `settings_service`.
        2. Startet Listener für `SettingChangedEvent` (um Energieeinstellungen neu zu laden).
        3. Verarbeitet eingehende `UserActivityDetectedEvent`: Setzt alle Idle-Timer zurück.
        4. Verarbeitet eingehende `LogindEvent::PrepareForSleep/Shutdown`: Führt Aktionen aus (z.B. DPMS Off).
        5. Verarbeitet `LogindEvent::SystemIdleHintChanged`.
        6. Periodisch (oder bei Timer-Ablauf):
            - Prüft `output_idle_timers`. Wenn Timeout erreicht: Setze DPMS-Status des Outputs (via Compositor/DRM-Backend). Sendet `OutputDpmsStateChanged`.
            - Prüft `system_idle_timer`. Wenn Timeout erreicht: Rufe `self.logind_service.suspend(false)` oder `hibernate(false)` auf, basierend auf Policy.
    - **Private Methoden:**
        - `async fn reset_idle_timers(&self, current_settings: &PowerManagementPolicySettings)`
        - `async fn apply_dpms_state(&self, output_name: &str, dpms_state: DpmsState)`: Interagiert mit `system::compositor::output_management` (oder direkt DRM-Backend), um DPMS zu setzen.
        - `async fn on_screen_blank_timeout(&self, output_name: &str, current_settings: &PowerManagementPolicySettings)`
        - `async fn on_system_suspend_timeout(&self, current_settings: &PowerManagementPolicySettings)`

#### 7.4. Implementierungsschritte `system::power_management`

1. `types.rs`, `errors.rs` definieren.
2. `service.rs`: `PowerManagementService` implementieren.
    - Event-Loops für `UserActivityDetectedEvent` und `LogindEvent`.
    - Logik für Idle-Timer-Management mit `calloop::Timer` (muss mit `tokio` synchronisiert werden, wenn Service `async` ist, z.B. Timer in `calloop`-Schleife, der Nachricht an `tokio`-Task sendet).
    - Interaktion mit `GlobalSettingsService` für Policies.
    - Interaktion mit `LogindClientService` für Suspend/Hibernate.
    - Interaktion mit Compositor (Output-Management) für DPMS.
3. Tests: Mocking von Abhängigkeiten, Testen der Timer-Logik und Zustandsübergänge.

---

### Modul 8: `system::event_bridge`

Zweck: Eine zentrale Stelle für System-interne Events, die nicht direkt an einen spezifischen D-Bus-Dienst oder ein Wayland-Protokoll gebunden sind. Dient der Entkopplung innerhalb der Systemschicht und als definierte Quelle für bestimmte Domänen-Events.

Verantwortlichkeiten: Definition von generischen System-Event-Typen. Bereitstellung von tokio::sync::broadcast Kanälen für diese Events.

Design-Rationale: Verhindert direkte Abhängigkeiten zwischen allen Systemmodulen. Ermöglicht es Modulen, relevante Ereignisse zu publizieren, ohne ihre Konsumenten explizit kennen zu müssen.

**Datei:** `src/event_bridge/mod.rs` (kann `types.rs` und `channels.rs` enthalten)

- **Struct `SystemEventBridge`**:
    - **Felder (Beispiele für `broadcast::Sender`):**
        - `upower_event_tx: tokio::sync::broadcast::Sender<UPowerEvent>`
        - `logind_event_tx: tokio::sync::broadcast::Sender<LogindEvent>`
        - `network_manager_event_tx: tokio::sync::broadcast::Sender<NetworkManagerEvent>`
        - `audio_event_tx: tokio::sync::broadcast::Sender<AudioEvent>`
        - `mcp_client_event_tx: tokio::sync::broadcast::Sender<McpClientEvent>`
        - `window_mechanics_event_tx: tokio::sync::broadcast::Sender<WindowMechanicsEvent>`
        - `power_management_event_tx: tokio::sync::broadcast::Sender<PowerManagementEvent>`
        - `input_device_hotplug_event_tx: tokio::sync::broadcast::Sender<InputDeviceHotplugEvent>`
        - **Domänen-Events, die von der Systemschicht ausgelöst werden:**
        - `user_activity_event_tx: tokio::sync::broadcast::Sender<crate::domain::common_events::UserActivityDetectedEvent>`
        - `system_shutdown_event_tx: tokio::sync::broadcast::Sender<crate::domain::common_events::SystemShutdownInitiatedEvent>`
    - **Konstruktor `new(capacity_per_channel: usize) -> Self`**: Initialisiert alle Sender.
    - **Methoden zum Abrufen von `Receiver`n**:
        - `pub fn subscribe_upower_events(&self) -> tokio::sync::broadcast::Receiver<UPowerEvent>` (analog für alle anderen).
    - **Methoden zum Senden von Events (intern von anderen Systemmodulen genutzt):**
        - `pub(crate) fn publish_upower_event(&self, event: UPowerEvent)` (analog).
- **Event-Typen (Beispiele, falls noch nicht in spezifischen Modulen definiert):**
    - `InputDeviceHotplugEvent { device_name: String, device_type: String /* z.B. "keyboard", "pointer" */, event_type: HotplugType /* Added, Removed */}`
    - Die meisten spezifischen Events (`UPowerEvent`, `LogindEvent` etc.) werden in ihren jeweiligen Modulen (`system::dbus_interfaces::upower_client::types`) definiert und hier nur die Sender verwaltet.

**Implementierungsschritte `system::event_bridge`**:

1. `SystemEventBridge`-Struktur definieren.
2. Konstruktor und `subscribe_`/`publish_`-Methoden implementieren.
3. Sicherstellen, dass alle Systemmodule, die Events publizieren oder konsumieren, eine Referenz (`Arc`) zum `SystemEventBridge` erhalten (z.B. bei der Initialisierung von `DesktopState` oder der Systemschicht).

---

Diese detaillierten Pläne für die Module 3 (Vervollständigung) bis 8 der Systemschicht bilden eine solide Grundlage für die Implementierung. Die Komplexität liegt weiterhin in der korrekten asynchronen Integration, der Interaktion mit externen Bibliotheken/Protokollen und der robusten Fehlerbehandlung.

---

### Modul 5: `system::mcp_client`

Zweck: Implementierung des Clients für das Model Context Protocol (MCP), um sicher mit lokalen oder Cloud-basierten KI-Modellen (LLMs) zu interagieren.

Verantwortlichkeiten:

- Aufbau und Verwaltung der Verbindung zu einem MCP-Server.
- Senden von Anfragen an den MCP-Server (z.B. `Initialize`, `ListResources`, `CallTool`) basierend auf Anweisungen von `domain::user_centric_services::ai_interaction`.
- Empfangen von Antworten und asynchronen Benachrichtigungen (`Notification`) vom MCP-Server.
- Sichere Handhabung von API-Schlüsseln (via `system::dbus_interfaces::secrets_service_client`) für Cloud-basierte Modelle.
- Bereitstellung einer abstrahierten Schnittstelle (`SystemMcpService`-Trait) für die Domänenschicht. **Design-Rationale:** Kapselung der MCP-spezifischen Kommunikationslogik. Nutzung des `mcp_client_rs` Crates als Basis. Ermöglichung einer flexiblen Anbindung verschiedener KI-Modelle. **Technologie:** `mcp_client_rs` Crate, `tokio` für asynchrone Operationen, `serde` für Datenstrukturen.

**Abhängigkeiten in `novade-system/Cargo.toml` (zusätzlich):**

Ini, TOML

```
mcp_client_rs = "0.2.0" # Aktuelle Version des mcp_client_rs Crates prüfen
# ggf. http_types oder reqwest, falls RemoteHttp direkt implementiert wird und mcp_client_rs dies nicht vollständig abstrahiert
```

#### 5.1. Untermodul: `system::mcp_client::types`

**Datei:** `src/mcp_client/types.rs`

- **Struct `McpServerConfig`**:
    
    - **Definition:** Wie in der vorherigen Antwort (Teil 4 der Systemschicht-Spezifikation).
        
        Rust
        
        ```
        use serde::{Serialize, Deserialize};
        use std::path::PathBuf; // Für working_directory
        
        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
        pub enum McpServerType {
            LocalExecutable {
                command: String,
                args: Vec<String>,
                #[serde(default, skip_serializing_if = "Option::is_none")]
                working_directory: Option<PathBuf>, // PathBuf verwenden
            },
            RemoteHttp {
                endpoint_url: String,
            },
        }
        
        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
        pub struct McpServerConfig {
            pub server_id: String,
            pub server_type: McpServerType,
            #[serde(default = "default_request_timeout_ms_config")]
            pub default_request_timeout_ms: u64,
        }
        
        fn default_request_timeout_ms_config() -> u64 { 30000 } // 30 Sekunden
        
        impl Default for McpServerConfig { /* ... */ } // Sinnvoller Default, z.B. für einen häufig genutzten lokalen Server
        ```
        
- **Re-Export von `mcp_client_rs::protocol` Typen:**
    
    Rust
    
    ```
    pub use mcp_client_rs::protocol::{
        InitializeParams, InitializeResult, ListResourcesParams, ListResourcesResult,
        Resource, ToolDefinition, CallToolParams, CallToolResult, ToolCall, ToolResult,
        McpMessage, Notification as McpProtocolNotification, ErrorResponse, ErrorCode,
        // Weitere benötigte Typen aus dem Protokoll
    };
    ```
    
- **Event-Struktur (für `system::event_bridge` oder direkt an Domäne):**
    
    Rust
    
    ```
    use uuid::Uuid;
    // McpProtocolNotification, McpErrorResponse, McpToolResult sind bereits oben re-exportiert
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum McpClientSystemEvent { // Umbenannt von McpClientEvent zur Unterscheidung von Domain-Events
        McpNotificationReceived {
            server_id: String,
            interaction_id: Option<Uuid>,
            notification: McpProtocolNotification,
        },
        McpToolCallSuccessful {
            server_id: String,
            interaction_id: Uuid,
            request_id: String,
            tool_result: McpToolResult,
        },
        McpRequestFailed { // Wenn die Anfrage den Server erreicht hat, aber dieser einen Fehler zurückgibt
            server_id: String,
            interaction_id: Option<Uuid>,
            request_id: Option<String>,
            error: McpErrorResponse,
        },
        McpCommunicationError { // Für Verbindungsfehler, Timeouts etc. vor/während der Anfrage
            server_id: String,
            interaction_id: Option<Uuid>,
            request_id: Option<String>,
            message: String, // Detailliertere Fehlermeldung des Clients
        },
        McpServerConnectionStateChanged {
            server_id: String,
            is_connected: bool,
            error_message: Option<String>, // Grund für Disconnect
        }
    }
    ```
    

#### 5.2. Untermodul: `system::mcp_client::errors`

**Datei:** `src/mcp_client/errors.rs`

- **Enum `McpSystemClientError`**:
    
    - **Definition:** Wie in der vorherigen Antwort, aber `McpLibError` wird differenzierter behandelt. <!-- end list -->
    
    Rust
    
    ```
    use thiserror::Error;
    use mcp_client_rs::Error as McpLibInternalError; // Interner Fehler des mcp_client_rs Crates
    use crate::dbus_interfaces::common::DBusInterfaceError; // Für Secrets Service Fehler
    use super::types::ErrorResponse as McpErrorResponse; // MCP Protokoll-Fehler
    
    #[derive(Debug, Error)]
    pub enum McpSystemClientError {
        #[error("MCP Server configuration not found for ID: {0}")]
        ServerConfigNotFound(String),
        #[error("Failed to start local MCP server (command: '{command}'): {source}")]
        LocalServerStartFailed { command: String, #[source] source: std::io::Error },
        #[error("MCP client library internal error: {0}")]
        McpLibInternalError(#[from] McpLibInternalError),
        #[error("MCP server returned an error: {error_code:?} - {message}")]
        McpServerErrorReply { error_code: mcp_client_rs::protocol::ErrorCode, message: String, diagnostic_info: Option<String> }, // Von McpErrorResponse
        #[error("Failed to retrieve API key '{secret_name}' from secrets service: {source}")]
        ApiKeyRetrievalFailed { secret_name: String, #[source] source: DBusInterfaceError },
        #[error("API key '{secret_name}' not found in secrets service.")]
        ApiKeyNotFound(String),
        #[error("MCP request timed out for request ID '{request_id}' to server '{server_id}'.")]
        RequestTimeout { server_id: String, request_id: String },
        #[error("MCP Server '{server_id}' is not connected or connection lost.")]
        ServerNotConnected(String),
        #[error("No active MCP server connection available for the request.")]
        NoActiveConnection,
        #[error("Failed to serialize MCP request: {0}")]
        SerializationError(#[from] serde_json::Error), // Falls wir manuell serialisieren
        #[error("Failed to deserialize MCP response: {0}")]
        DeserializationError(serde_json::Error), // Falls wir manuell deserialisieren
        #[error("Unsupported MCP server type: {0:?}")]
        UnsupportedServerType(super::types::McpServerType),
        #[error("Internal MCP client error: {0}")]
        InternalError(String),
    }
    
    // Konvertierung von McpErrorResponse zu McpSystemClientError
    impl From<McpErrorResponse> for McpSystemClientError {
        fn from(err_resp: McpErrorResponse) -> Self {
            McpSystemClientError::McpServerErrorReply {
                error_code: err_resp.error.code,
                message: err_resp.error.message,
                diagnostic_info: err_resp.error.data.and_then(|v| serde_json::to_string(&v).ok()),
            }
        }
    }
    ```
    

#### 5.3. Untermodul: `system::mcp_client::connection_manager`

**Zweck:** Verwaltung von Verbindungen zu MCP-Servern.

**Datei:** `src/mcp_client/connection_manager.rs`

- **Struct `McpConnection`**:
    - **Felder:** Wie in der vorherigen Antwort.
        - `server_id: String`
        - `client: mcp_client_rs::McpClient`
        - `local_process_handle: Arc<tokio::sync::Mutex<Option<tokio::process::Child>>>` (Arc&lt;Mutex&lt;Option&lt;...>>> damit der Listener-Task den Prozess ggf. beenden kann)
        - `is_connected_state: Arc<tokio::sync::watch::Sender<bool>>` (Sender, damit der Manager den Status setzen kann)
        - `notification_task_handle: Option<tokio::task::JoinHandle<()>>` (Für den Task, der `client.receive_message()` lauscht)
    - **Methoden:**
        - **`pub async fn new(config: &McpServerConfig, api_key: Option<String>, event_publisher_clone: tokio::sync::broadcast::Sender<McpClientSystemEvent>, server_id_clone: String) -> Result<Self, McpSystemClientError>`**:
            1. `is_connected_state_tx = Arc::new(tokio::sync::watch::channel(false).0);`
            2. Wenn `LocalExecutable`: Starte Prozess, `client = McpClient::attach_stdio(child_process.stdin.take().unwrap(), child_process.stdout.take().unwrap()).await?`.
            3. Wenn `RemoteHttp`: `client = McpClient::connect_http(&config.endpoint_url, api_key).await?`.
            4. Setze `is_connected_state_tx.send(true).ok();`.
            5. Starte `notification_task`:
                
                Rust
                
                ```
                let client_clone = client.clone(); // McpClient muss Clone sein
                let is_connected_state_clone = is_connected_state_tx.clone();
                let publisher_clone = event_publisher_clone;
                let s_id_clone = server_id_clone;
                
                let handle = tokio::spawn(async move {
                    loop {
                        match client_clone.receive_message().await {
                            Ok(Some(McpMessage::Notification(notification))) => {
                                publisher_clone.send(McpClientSystemEvent::McpNotificationReceived {
                                    server_id: s_id_clone.clone(),
                                    interaction_id: None, // Muss aus Notification-Payload extrahiert werden, falls vorhanden
                                    notification,
                                }).ok();
                            }
                            Ok(Some(McpMessage::Response { .. })) => {
                                tracing::warn!("Unerwartete Response im Notification-Stream von MCP Server {}", s_id_clone);
                            }
                            Ok(None) => { // Stream beendet (Verbindung geschlossen)
                                tracing::info!("MCP Notification-Stream für Server {} beendet.", s_id_clone);
                                is_connected_state_clone.send(false).ok();
                                publisher_clone.send(McpClientSystemEvent::McpServerConnectionStateChanged {
                                    server_id: s_id_clone.clone(),
                                    is_connected: false,
                                    error_message: Some("Connection closed by server or stream ended.".to_string()),
                                }).ok();
                                break;
                            }
                            Err(e) => {
                                tracing::error!("Fehler beim Empfangen der MCP Notification von Server {}: {:?}", s_id_clone, e);
                                is_connected_state_clone.send(false).ok();
                                publisher_clone.send(McpClientSystemEvent::McpServerConnectionStateChanged {
                                    server_id: s_id_clone.clone(),
                                    is_connected: false,
                                    error_message: Some(format!("Receive error: {}", e)),
                                }).ok();
                                break;
                            }
                        }
                    }
                });
                ```
                
            6. Return `Self { ..., notification_task_handle: Some(handle), ... }`.
        - **`pub async fn close(&mut self)`**:
            1. `self.is_connected_state.send(false).ok();`
            2. `self.client.close().await;` (Wenn `McpClient` eine `close`-Methode hat).
            3. Wenn `notification_task_handle.take().is_some()`, `handle.abort();` (oder sanfter beenden).
            4. Wenn `local_process_handle.lock().await.take().is_some()`, `child.kill().await?`.
- **Struct `McpConnectionManager`**:
    - **Felder:** Wie in der vorherigen Antwort.
    - **Methoden:**
        - `load_server_configs` (wie zuvor).
        - `get_or_connect`:
            1. Prüft `connections` Cache. Wenn verbunden (`is_connected_state.borrow() == true`), zurückgeben.
            2. API-Key-Abruf via `secrets_service`.
            3. `McpConnection::new(...)` aufrufen.
            4. Verbindung in `connections` speichern.
            5. `event_publisher.send(McpServerConnectionStateChanged { is_connected: true, ... })`.
        - `disconnect` (wie zuvor, ruft `McpConnection::close()`).
        - `get_active_connection_for_model` (wie zuvor).

#### 5.4. Submodul: `system::mcp_client::service`

**Zweck:** Implementierung des `SystemMcpService` Traits.

**Datei:** `src/mcp_client/service.rs`

- **Trait `SystemMcpService`**: Wie in der vorherigen Antwort.
- **Struct `DefaultSystemMcpService`**:
    - **Felder:** `connection_manager: Arc<McpConnectionManager>`.
    - **Implementierung von `SystemMcpService`**:
        - **`initialize_server`, `list_resources`, `call_tool`**:
            1. `mcp_conn_arc = self.connection_manager.get_or_connect(server_id, model_profile).await?;`
            2. `let mcp_conn_guard = mcp_conn_arc; // Arc kann direkt verwendet werden, McpClient ist Clone`
            3. `let client_ref = &mcp_conn_guard.client;`
            4. Timeout erstellen: `tokio::time::timeout(Duration::from_millis(timeout_ms), client_ref.send_request_json(mcp_protocol_message)).await`
                - Wenn `Ok(Ok(response_message))`: Verarbeite `response_message`.
                - Wenn `Ok(Err(mcp_lib_err))`: `Err(McpSystemClientError::McpLibInternalError(mcp_lib_err))`.
                - Wenn `Err(_timeout_err)`: `Err(McpSystemClientError::RequestTimeout { ... })`.
            5. Wenn `response_message` eine `McpMessage::Error(err_resp)` ist:
                - `self.connection_manager.event_publisher.send(McpClientSystemEvent::McpRequestFailed { ..., error: err_resp.clone() }).ok();`
                - `Err(McpSystemClientError::from(err_resp))`
            6. Sonst: Parse Response in den erwarteten Typ (z.B. `InitializeResult`). Bei Erfolg, `McpToolCallSuccessful` Event senden (für `call_tool`).
        - **`subscribe_to_mcp_events`**: `self.connection_manager.event_publisher.subscribe()`.

#### 5.5. Implementierungsschritte `system::mcp_client`

(Wie in vorheriger Antwort, aber mit Fokus auf `tokio::sync::Mutex/RwLock/watch`, `tokio::process` und `tokio::task` für asynchrone Operationen und den Notification-Listener-Task in `McpConnection`.)

1. **Grundgerüst**: Verzeichnisse, `Cargo.toml` anpassen.
2. **`types.rs`**: `McpServerConfig` (mit `PathBuf`), `McpClientSystemEvent`, Protokoll-Typen re-exportieren.
3. **`errors.rs`**: `McpSystemClientError` (mit detaillierter Fehlerbehandlung für `McpLibInternalError` und `McpErrorResponse`).
4. **`connection_manager.rs`**:
    - `McpConnection`: `new` implementieren (Prozessstart, Verbindung, Notification-Listener-Task). `close` implementieren.
    - `McpConnectionManager`: `new`, `load_server_configs`, `get_or_connect` (mit API-Key-Abruf), `disconnect`, `get_active_connection_for_model`.
5. **`service.rs`**: `SystemMcpService`-Trait und `DefaultSystemMcpService`-Implementierung. Timeout-Logik für Anfragen. Korrektes Event-Publishing.
6. **`mod.rs`**: API re-exportieren.
7. **Unit-/Integrationstests**:
    - Mocking für `SecretsServiceClientService`.
    - Testen der lokalen Prozessstart- und Managementlogik.
    - Für HTTP-Verbindungen: Testen gegen einen einfachen Mock-MCP-HTTP-Server.
    - Testen der Timeout-Logik.
    - Testen des Notification-Listener-Tasks (Senden von Dummy-Notifications).

---

### Modul 6: `system::window_mechanics`

Zweck: Technische Umsetzung des Fenstermanagements (Positionierung, Größe, Stapelreihenfolge, Tiling, Fokus, Dekorationen) basierend auf Domänen-Policies.

Verantwortlichkeiten: Anwenden von WorkspaceWindowLayout auf Compositor-Fenster, Senden von configure-Events, Handhabung interaktiver Operationen (Move/Resize), Koordination von SSD/CSD, technische Fokusumsetzung.

Design-Rationale: Trennung von "Mechanik" und "Policy". Enge Kopplung mit system::compositor und domain::window_management_policy.

#### 6.1. Untermodul: `system::window_mechanics::types`

**Datei:** `src/window_mechanics/types.rs`

- **Struct `InteractiveOpState`**: Wie in der vorherigen Antwort.
    
    Rust
    
    ```
    use smithay::{
        utils::{Logical, Point, Rectangle, Serial},
        reexports::wayland_protocols::xdg::shell::server::xdg_toplevel::ResizeEdge,
    };
    use crate::compositor::xdg_shell::types::ManagedWindow; // Pfad anpassen
    use std::sync::Arc;
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum InteractiveOpType { Move, Resize(ResizeEdge) } // ResizeEdge aus xdg_toplevel
    
    #[derive(Debug, Clone)]
    pub struct InteractiveOpState {
        pub window_arc: Arc<ManagedWindow>, // Smithay's Window Trait-Objekt
        pub op_type: InteractiveOpType,
        pub start_pointer_pos_global: Point<f64, Logical>, // Globale Position beim Start des Grabs
        pub initial_window_geometry: Rectangle<i32, Logical>, // Geometrie des Fensters beim Start des Grabs
        pub last_configure_serial: Option<Serial>, // Um Configure-Storms zu vermeiden
        // Für Resize:
        pub initial_window_size_constraints: Option<(Option<Size<i32, Logical>>, Option<Size<i32, Logical>>)>, // (min_size, max_size)
    }
    ```
    
- **Event (System-intern, via `system::event_bridge`):**
    
    Rust
    
    ```
    use crate::domain::workspaces::core::types::WindowIdentifier as DomainWindowIdentifier;
    use crate::core::types::RectInt; // Aus novade-core
    use smithay::wayland::shell::xdg::ToplevelState; // Beispiel für Zustandsflags
    
    #[derive(Debug, Clone)]
    pub enum WindowMechanicsEvent {
        WindowConfiguredByMechanics { // Unterscheidung von Client-initiiertem Configure
            window_domain_id: DomainWindowIdentifier,
            new_geometry: RectInt, // Die tatsächlich angewendete Geometrie
            new_state: Vec<ToplevelState>, // z.B. Maximized, Activated etc.
        },
        InteractiveOpStarted { window_domain_id: DomainWindowIdentifier, op_type: InteractiveOpType },
        InteractiveOpEnded { window_domain_id: DomainWindowIdentifier, op_type: InteractiveOpType, final_geometry: RectInt },
        FocusSetByMechanics(Option<DomainWindowIdentifier>), // Wenn der Fokus durch Mechanics geändert wurde
    }
    ```
    

#### 6.2. Untermodul: `system::window_mechanics::errors`

**Datei:** `src/window_mechanics/errors.rs`

- **Enum `WindowMechanicsError`**: Wie in der vorherigen Antwort.
    - Zusätzlich: `#[error("Window {0:?} does not support the requested operation (e.g., trying to resize a non-resizable window).")] WindowOperationNotSupported(DomainWindowIdentifier)`

#### 6.3. Untermodul: `system::window_mechanics::layout_applier`

**Zweck:** Anwenden eines von der Domäne berechneten Layouts.

**Datei:** `src/window_mechanics/layout_applier.rs`

- **Funktion `pub async fn apply_workspace_layout(desktop_state_accessor: &impl Fn() -> Arc<Mutex<DesktopState>>, workspace_id: WorkspaceId, layout: &WorkspaceWindowLayout) -> Result<(), WindowMechanicsError>`**:
    
    - **Annahme:** `DesktopStateAccessor` ist ein Weg, um Zugriff auf `DesktopState` zu bekommen, da `DesktopState` selbst nicht einfach `Send` sein könnte für `async fn`. Einfacher: Wenn `apply_workspace_layout` von einem Ort aufgerufen wird, der bereits Zugriff auf `&mut DesktopState` hat (z.B. innerhalb eines `calloop` Callbacks oder eines `tokio::task::block_in_place`), dann kann es synchron sein. Für die Spezifikation nehmen wir an, dass es irgendwie Zugriff bekommt.
    - **Alternative (synchron, wenn im Compositor-Thread):** `pub fn apply_workspace_layout_blocking(desktop_state: &mut DesktopState, workspace_id: WorkspaceId, layout: &WorkspaceWindowLayout) -> Result<(), WindowMechanicsError>` <!-- end list -->
    
    1. `tracing::debug!("Wende Layout für Workspace {:?} an: {:?}", workspace_id, layout);`
    2. `let space = &mut desktop_state.space;`
    3. `let windows_map = &mut desktop_state.windows;` // Map von DomainWindowIdentifier zu Arc&lt;ManagedWindow>
    4. Für jede `(domain_id, target_geometry)` in `layout.window_geometries`:
        - `let managed_window_arc = match windows_map.get(&domain_id) { Some(w) => w.clone(), None => { tracing::warn!("Fenster {:?} im Layout nicht in DesktopState gefunden.", domain_id); continue; } };`
        - `let mut managed_window_ref = (*managed_window_arc).clone(); // Klone Arc für Smithay-Window-Trait-Methoden, wenn ManagedWindow selbst nicht Mutex-geschützt ist.`
        - `managed_window_ref.current_geometry = target_geometry;` // Internen Zustand aktualisieren
        - **Senden der Konfiguration an den Client (Beispiel für Toplevel):**
            - `if let WindowSurface::Toplevel(toplevel) = &managed_window_ref.xdg_surface { ... }`
            - `let mut new_xdg_states = Vec::new();`
            - // Logik, um layout.tiling_mode_applied in XDG-Zustände zu übersetzen (z.B. Maximized)
            - // if layout.tiling_mode_applied == TilingMode::MaximizedFocused && Some(&amp;domain_id) == layout.focused_window_id {
            - // new_xdg_states.push(xdg_toplevel::State::Maximized);
            - // }
            - `toplevel.with_pending_state(|xdg_state| { xdg_state.size = Some(target_geometry.size); xdg_state.states = ToplevelState::new(&new_xdg_states); });`
            - `toplevel.send_configure();`
        - `space.map_window(managed_window_arc.clone(), target_geometry.loc, true);` (Stellt sicher, dass es im Space ist und die Position aktualisiert wird. `true` für Aktivierung, falls es das fokussierte Fenster sein soll – Fokuslogik ist separat).
        - `desktop_state.event_bridge.publish_window_mechanics_event(WindowMechanicsEvent::WindowConfiguredByMechanics { ... });`
    5. Für Fenster, die im `space` sind, aber NICHT in `layout.window_geometries` (d.h. sollen nicht mehr auf diesem Workspace sichtbar sein, z.B. weil geschlossen oder auf anderen WS verschoben):
        - `if let Some(window_to_unmap) = windows_map.get(&domain_id_im_space) { space.unmap_window(window_to_unmap); }`
    6. `space.damage_all_outputs();` (Oder spezifischer: `space.damage_elements(betroffene_fenster)`).
    7. `Ok(())`

#### 6.4. Untermodul: `system::window_mechanics::interactive_ops`

**Zweck:** Handhabung von interaktiven Fenster-Moves und -Resizes.

**Datei:** `src/window_mechanics/interactive_ops.rs`

- **Struct `PointerMoveResizeGrab`**: Implementiert `smithay::input::pointer::PointerGrab<DesktopState>`.
    - **Felder:** `op_state: InteractiveOpState`, `desktop_state_accessor: impl Fn() -> Arc<Mutex<DesktopState>>` (oder `Weak<Mutex<DesktopState>>`), `window_policy_service: Arc<dyn WindowManagementPolicyService>`.
    - **`motion(...)` Logik:**
        1. `current_pointer_pos_global = global_grab_start_pos + (current_event_pos - op_state.start_pointer_pos_pointer_local);`
        2. `new_geometry = calculate_new_geometry_for_op(&op_state.initial_window_geometry, &op_state.op_type, current_pointer_pos_global, op_state.start_pointer_pos_global);`
        3. **Snapping:**
            - `other_windows_on_workspace = collect_other_windows_geometries(desktop_state_accessor, &op_state.window_arc);`
            - `snapping_policy = block_on(self.window_policy_service.get_effective_snapping_policy());`
            - `gap_settings = block_on(self.window_policy_service.get_effective_gap_settings_for_workspace(...));`
            - `if let Some(snapped_geom) = block_on(self.window_policy_service.calculate_snap_target(&op_state.window_arc.domain_id, new_geometry, &other_windows_on_workspace, workspace_area, &snapping_policy, &gap_settings)) { new_geometry = snapped_geom; }`
        4. **Größenbeschränkungen anwenden:** Klemme `new_geometry.size` auf `op_state.initial_window_size_constraints`.
        5. Aktualisiere `op_state.window_arc.current_geometry = new_geometry;` (visuelles Feedback, kein Configure).
        6. `desktop_state_accessor().lock().unwrap().space.damage_window(&op_state.window_arc, None, None);` (Alte und neue Position beschädigen).
    - **`button(...)` Logik:**
        1. Wenn Maustaste losgelassen:
            - Finalisiere `final_geometry = op_state.window_arc.current_geometry;`
            - `if let WindowSurface::Toplevel(toplevel) = &op_state.window_arc.xdg_surface { ... send_configure mit final_geometry ... }`
            - `pointer_handle.unset_grab(serial, time);`
            - `desktop_state_accessor().lock().unwrap().event_bridge.publish_window_mechanics_event(InteractiveOpEnded { ... });`
- **Funktionen `start_interactive_move` / `start_interactive_resize`**:
    1. Erstellen `InteractiveOpState`.
    2. `pointer_handle.set_grab(serial, PointerMoveResizeGrab { ... }, Focus::Clear);`

#### 6.5. Submodul: `system::window_mechanics::focus_manager` (Vervollständigung)

**Zweck:** Technische Umsetzung des Fokuswechsels basierend auf Domänenentscheidungen und Benutzerinteraktionen.

**Datei:** `src/window_mechanics/focus_manager.rs`

- **Funktion `pub async fn set_application_focus(desktop_state_accessor: &impl Fn() -> Arc<Mutex<DesktopState>>, seat_name: &str, window_domain_id_to_focus: Option<&DomainWindowIdentifier>, serial: Serial) -> Result<(), WindowMechanicsError>`**:
    1. `let mut ds_guard = desktop_state_accessor().lock().await;`
    2. `let seat = ds_guard.seat_state.seats().find(|s| s.name() == seat_name).cloned().ok_or(WindowMechanicsError::InternalError("Seat nicht gefunden".into()))?;`
    3. `let old_focused_window_domain_id = ds_guard.active_input_surface.as_ref().and_then(|weak_surf| weak_surf.upgrade()).and_then(|surf| find_domain_id_for_surface(&ds_guard, &surf));`
    4. Finde `target_managed_window_arc_option`:
        - Wenn `window_domain_id_to_focus` `Some(id)`, suche in `ds_guard.windows.get(id)`.
        - Sonst `None`.
    5. `let target_wl_surface_option = target_managed_window_arc_option.as_ref().map(|arc_win| arc_win.wl_surface().clone());`
    6. Rufen Sie `crate::input::keyboard::focus::set_keyboard_focus(&mut ds_guard, seat_name, target_wl_surface_option.as_ref(), serial)?;`
    7. // Aktivierungslogik für XDG Toplevel
        - Wenn `old_focused_window_domain_id` existiert und sich von `window_domain_id_to_focus` unterscheidet:
            - Finde altes `ManagedWindow`. Wenn Toplevel, `old_toplevel.set_activated(false); old_toplevel.send_configure();`.
        - Wenn `target_managed_window_arc_option` ein Toplevel ist (`newly_focused_toplevel`):
            - `newly_focused_toplevel.set_activated(true); newly_focused_toplevel.send_configure();`
            - `ds_guard.space.raise_window(&newly_focused_toplevel_arc, true);` // True für Fokus
            - `ds_guard.active_input_surface = target_wl_surface_option.map(|s| s.downgrade());`
    8. `ds_guard.event_bridge.publish_window_mechanics_event(FocusSetByMechanics(window_domain_id_to_focus.cloned()));`
    9. `Ok(())`
- **Funktion `fn find_domain_id_for_surface(ds: &DesktopState, surface: &WlSurface) -> Option<DomainWindowIdentifier>`**: Iteriert `ds.windows` und vergleicht `wl_surface()`.

#### 6.6. Implementierungsschritte `system::window_mechanics`

1. `types.rs`, `errors.rs` definieren.
2. `layout_applier.rs`: `apply_workspace_layout_blocking` implementieren. Fokus auf korrekte `configure`-Events.
3. `interactive_ops.rs`: `PointerMoveResizeGrab` mit `PointerGrab` Trait implementieren. `start_interactive_move/resize` Funktionen. Snapping-Logik integrieren.
4. `focus_manager.rs`: `set_application_focus` mit XDG-Aktivierungslogik und Space-Interaktion.
5. Unit-Tests (sehr komplex):
    - Testen der `apply_workspace_layout` für verschiedene Layouts (mock `DesktopState` und `ManagedWindow`s).
    - Testen der Grab-Handler-Logik (Zustandsübergänge, Geometrieberechnung).
    - Testen der Fokus-Aktivierungslogik.

---

### Modul 7: `system::power_management` (Vervollständigung)

Zweck: DPMS, Interaktion mit logind für Suspend/Hibernate, Reaktion auf Benutzerinaktivität.

Bestehende Spezifikation: Skizziert in der vorherigen Antwort.

#### 7.1. Untermodul: `system::power_management::types`

**Datei:** `src/power_management/types.rs`

- **Enum `DpmsState`**: Wie in der vorherigen Antwort (`On, Standby, Suspend, Off`). Serde für Konfiguration.
- **Event `PowerManagementSystemEvent`** (umbenannt von `PowerManagementEvent`):
    
    Rust
    
    ```
    use crate::dbus_interfaces::logind_client::types::LogindPowerOperation; // Pfad anpassen
    
    #[derive(Debug, Clone)]
    pub enum PowerManagementSystemEvent {
        OutputDpmsStateSet { output_name: String, new_state: DpmsState, success: bool },
        SystemSuspendingInitiated(LogindPowerOperation), // Vom logind_client erhalten
        SystemResumedNormally,
        ScreenBlankTimeoutReached(String /* output_name */),
        SystemIdleTimeoutReached, // Für Suspend/Hibernate
    }
    ```
    
- **Struct `IdleTimerState`**: Wie in der vorherigen Antwort, aber `timer_handle` muss `Send + Sync` sein, wenn der Service in einem `tokio::task` läuft und den Timer in `calloop` der Compositor-Schleife managt. Besser: Timer wird über einen Befehl an den Compositor-Thread gesetzt.
    
    Rust
    
    ```
    use chrono::{DateTime, Utc, Duration as ChronoDuration}; // Duration für Timer
    use calloop::TimerHandle; // Wenn Timer in calloop läuft
    
    #[derive(Debug)] // TimerHandle ist nicht Clone/Debug
    pub struct IdleTimerState {
        pub timer_id: String, // Eindeutige ID für den Timer (z.B. "output-HDMI-A-1-blank", "system-suspend")
        pub last_activity_ts: DateTime<Utc>,
        pub current_timeout_duration: ChronoDuration,
        // pub calloop_timer_handle: Option<TimerHandle>, // Wenn direkt in calloop
        // Alternativ: Timestamp, wann der Timer ablaufen soll
        pub scheduled_expiry_ts: Option<DateTime<Utc>>,
    }
    ```
    

#### 7.2. Untermodul: `system::power_management::errors`

**Datei:** `src/power_management/errors.rs`

- **Enum `PowerManagementError`**: Wie in der vorherigen Antwort.

#### 7.3. Untermodul: `system::power_management::service`

**Datei:** `src/power_management/service.rs`

- **Trait `PowerManagementControl`** (Schnittstelle zum Compositor/DRM-Backend für DPMS):
    
    Rust
    
    ```
    use async_trait::async_trait;
    use super::types::DpmsState;
    use super::errors::PowerManagementError;
    
    #[async_trait]
    pub trait PowerManagementControl: Send + Sync {
        async fn set_output_dpms_state(&self, output_name: &str, state: DpmsState) -> Result<(), PowerManagementError>;
        async fn list_outputs_for_dpms(&self) -> Result<Vec<String>, PowerManagementError>; // Gibt Namen der relevanten Outputs
    }
    ```
    
- **Struct `PowerManagementService`**:
    - **Felder:**
        - `settings_service: Arc<dyn GlobalSettingsService>`
        - `logind_service: Arc<dyn LogindClientService>`
        - `compositor_dpms_control: Arc<dyn PowerManagementControl>` (Injizierte Abhängigkeit)
        - `event_publisher: tokio::sync::broadcast::Sender<PowerManagementSystemEvent>`
        - `system_event_receiver: tokio::sync::broadcast::Receiver<crate::event_bridge::SystemLayerEvent>` (Empfängt `UserActivityDetectedEvent`, `LogindSystemEvent::PrepareForSleep/Shutdown`, `SettingChangedEvent` für Power-Settings).
        - `active_timers: Arc<tokio::sync::Mutex<HashMap<String /* timer_id */, IdleTimerState>>>`
        - `current_power_settings: Arc<tokio::sync::RwLock<crate::domain::global_settings_and_state_management::types::PowerManagementPolicySettings>>`
        - `on_ac_power: Arc<tokio::sync::RwLock<bool>>` (Wird durch UPower-Events aktualisiert)
    - **Konstruktor `new(...)`**: Nimmt Abhängigkeiten, abonniert Events vom `SystemEventBridge`.
    - **Methode `pub async fn run(&self)`**: Haupt-Task des Dienstes.
        1. Lädt initiale `PowerManagementPolicySettings` und `on_ac_power`-Status.
        2. Initialisiert/Resettet alle Idle-Timer basierend auf aktuellen Einstellungen und AC-Status.
        3. **Event-Loop (`tokio::select!`)**:
            - Hört auf `system_event_receiver`:
                - `UserActivityDetectedEvent`: `self.reset_all_idle_timers().await;`
                - `LogindSystemEvent::PrepareForSleep(is_suspending)`: Setze alle Outputs auf `DpmsState::Off`. `self.cancel_all_idle_timers().await;`
                - `LogindSystemEvent::SystemResumed`: `self.reset_all_idle_timers().await;` Setze Outputs auf `DpmsState::On`.
                - `SettingChangedEvent` für Power-Pfade: Lade `current_power_settings` neu, `self.reset_all_idle_timers().await;`
                - `UPowerSystemEvent::OnBatteryChanged(is_on_battery)`: Aktualisiere `self.on_ac_power`, `self.reset_all_idle_timers().await;`
            - Hört auf Timer-Abläufe (wenn Timer in `tokio` verwaltet werden, z.B. `tokio::time::sleep_until` für jeden Timer in einem separaten Task, der dann eine Nachricht an diesen Haupt-Task sendet).
                - Wenn "Screen Blank Timeout" für einen Output abläuft: `self.apply_dpms_state(output_name, DpmsState::Off).await;` Sende `ScreenBlankTimeoutReached`.
                - Wenn "System Suspend Timeout" abläuft:
                    - Rufe `self.logind_service.suspend(false).await` oder `hibernate(false).await` basierend auf Policy. Sende `SystemIdleTimeoutReached`.
    - **Private Methoden:**
        - `async fn reset_all_idle_timers(&self)`: Liest aktuelle Settings und AC-Status. Berechnet neue Timeout-Dauern (z.B. `screen_blank_timeout_ac_secs` vs. `_battery_secs`). Startet/Neustartet `tokio::time::sleep_until` für jeden Output-Timer und den System-Suspend-Timer. Speichert `ScheduledExpiryTs` in `IdleTimerState`.
        - `async fn cancel_all_idle_timers(&self)`: Bricht laufende `tokio::time::sleep_until` ab (indem die Tasks, die sie verwalten, beendet werden oder indem `scheduled_expiry_ts` auf `None` gesetzt wird).
        - `async fn apply_dpms_state(...)`: Ruft `self.compositor_dpms_control.set_output_dpms_state(...)`. Sendet `OutputDpmsStateSet`.

#### 7.4. Implementierungsschritte `system::power_management`

1. `types.rs`, `errors.rs` definieren. `PowerManagementControl`-Trait definieren.
2. `service.rs`: `PowerManagementService` implementieren.
    - Event-Loop-Logik mit `tokio::select!`.
    - Timer-Management mit `tokio::time::sleep_until` (oder Integration mit `calloop`, falls performanter/einfacher im Compositor-Kontext).
    - Interaktion mit `GlobalSettingsService`, `LogindClientService`, `PowerManagementControl`.
3. Sicherstellen, dass `PowerManagementControl` im Compositor-Modul implementiert wird (z.B. `impl PowerManagementControl for DesktopState`).
4. Tests: Mocking von Abhängigkeiten. Testen der Timer-Logik, korrekte Reaktion auf Events, korrekte Anwendung von Policies (AC vs. Batterie).

---

### Modul 8: `system::event_bridge` (Vervollständigung)

Zweck: Zentrale Event-Verteilung innerhalb der Systemschicht und ggf. an die Domänenschicht für System-level Events.

Bestehende Spezifikation: Skizziert in der vorherigen Antwort.

**Datei:** `src/event_bridge/events.rs` (Definition aller System-internen Events)

- Hier werden alle Events definiert, die in den `types.rs`-Dateien der Submodule (`UPowerEvent`, `LogindEvent`, `NetworkManagerEvent`, `AudioEvent`, `McpClientSystemEvent`, `WindowMechanicsEvent`, `PowerManagementSystemEvent`, `InputDeviceHotplugEvent`) definiert wurden, ggf. gewrappt in ein übergreifendes `SystemLayerEvent`-Enum.
    
    Rust
    
    ```
    // Beispiel:
    // use crate::dbus_interfaces::upower_client::types::UPowerEvent;
    // use crate::input::types::InputDeviceHotplugEvent; // Beispiel
    // ...
    
    #[derive(Debug, Clone)] // Ggf. Serialize/Deserialize wenn über Grenzen gesendet
    pub enum SystemLayerEvent {
        UPower(UPowerEvent),
        Logind(LogindEvent),
        NetworkManager(NetworkManagerEvent),
        Audio(AudioEvent),
        McpClient(McpClientSystemEvent),
        WindowMechanics(WindowMechanicsEvent),
        PowerManagement(PowerManagementSystemEvent),
        InputDeviceHotplug(InputDeviceHotplugEvent),
        // Auch Domänen-Events, die von Systemschicht ausgelöst werden
        DomainUserActivity(crate::domain::common_events::UserActivityDetectedEvent),
        DomainSystemShutdown(crate::domain::common_events::SystemShutdownInitiatedEvent),
    }
    ```
    

**Datei:** `src/event_bridge/mod.rs`

- **Struct `SystemEventBridge`**:
    - **Felder:** Hält einen einzelnen `tokio::sync::broadcast::Sender<SystemLayerEvent>`.
        - `event_tx: tokio::sync::broadcast::Sender<SystemLayerEvent>`
    - **Konstruktor `new(capacity: usize) -> Self`**.
    - **Methoden:**
        - `pub fn subscribe(&self) -> tokio::sync::broadcast::Receiver<SystemLayerEvent>`
        - `pub(crate) fn publish(&self, event: SystemLayerEvent)`: Sendet das Event. Loggt Fehler, wenn keine Subscriber vorhanden sind.
- **Globale Instanz (optional aber oft praktisch):**
    
    Rust
    
    ```
    use std::sync::OnceLock;
    static SYSTEM_EVENT_BRIDGE_INSTANCE: OnceLock<SystemEventBridge> = OnceLock::new();
    
    pub fn global_system_event_bridge() -> &'static SystemEventBridge {
        SYSTEM_EVENT_BRIDGE_INSTANCE.get().expect("SystemEventBridge nicht initialisiert")
    }
    
    pub fn initialize_global_system_event_bridge(capacity: usize) {
        if SYSTEM_EVENT_BRIDGE_INSTANCE.set(SystemEventBridge::new(capacity)).is_err() {
            tracing::warn!("SystemEventBridge bereits initialisiert.");
        }
    }
    ```
    
    - Die Initialisierung würde sehr früh im Startprozess der Systemschicht erfolgen.

**Implementierungsschritte `system::event_bridge`**:

1. Alle relevanten Event-Typen in `events.rs` (oder den jeweiligen Modulen und hier re-exportiert/gewrappt) definieren.
2. `SystemEventBridge`-Struktur und globale Instanz implementieren.
3. Alle Systemmodule, die Events publizieren, nutzen `global_system_event_bridge().publish(...)`.
4. Alle Systemmodule (und Adapter zur Domänenschicht), die Events konsumieren, nutzen `global_system_event_bridge().subscribe()` und filtern dann nach dem `SystemLayerEvent`-Typ.

---

**Finale `novade-system/src/lib.rs` (Struktur):**

Rust

```
// novade-system/src/lib.rs

// Kern- und Domänen-Abhängigkeiten
// use novade_core;
// use novade-domain;

// System-interne Module
pub mod audio_management;
pub mod compositor;
pub mod dbus_interfaces;
pub mod event_bridge; // Muss früh initialisiert werden
pub mod input;
pub mod mcp_client;
pub mod power_management;
pub mod window_mechanics;

// Öffentliche API der Systemschicht (Traits und wichtige Typen)
// Diese werden typischerweise von der Hauptanwendung (Binary) oder der UI-Schicht genutzt.
// Beispiel:
// pub use compositor::CompositorControlService; // Hypothetischer Trait
// pub use input::InputControlService;          // Hypothetischer Trait
pub use dbus_interfaces::{
    UPowerClientService, LogindClientService, NetworkManagerClientService,
    SecretsServiceClientService, PolicyKitClientService, FreedesktopNotificationsServer,
    // Re-export der Service-Traits wäre hier besser als konkrete Typen, falls Traits existieren
};
pub use audio_management::{PipeWireClientService /* oder Trait */, AudioEvent};
pub use mcp_client::{SystemMcpService, McpClientSystemEvent, McpServerConfig};
// ... usw.

// Initialisierungsfunktion für die gesamte Systemschicht
// pub async fn initialize_system_layer(
//     core_services: Arc<CoreServices>, // Hypothetische Sammlung von Kernschicht-Services
//     domain_services: Arc<DomainServices>, // Hypothetische Sammlung von Domänenschicht-Services
//     display_handle: DisplayHandle, // Vom Backend (DRM, Winit)
//     loop_handle: LoopHandle<'static, DesktopState>, // Vom Backend
// ) -> Result<SystemServices, SystemInitializationError> {
//
//     event_bridge::initialize_global_system_event_bridge(1024);
//     let event_bridge = event_bridge::global_system_event_bridge();
//
//     // DesktopState (Compositor-Herzstück)
//     let desktop_state = Arc::new(Mutex::new(DesktopState::new(loop_handle.clone(), display_handle.clone(), domain_services.window_policy_service.clone(), ...)));
//
//     // Input-System initialisieren und in calloop registrieren
//     // let libinput_backend = input::libinput_handler::init_libinput_backend(&loop_handle, session_interface).await?;
//     // input::libinput_handler::register_libinput_source(&loop_handle, libinput_backend, "seat0".to_string(), desktop_state.clone())?;
//     // input::seat_manager::create_seat(&mut desktop_state.lock().unwrap(), &display_handle, "seat0".to_string())?;
//
//     // D-Bus Clients initialisieren
//     // let upower_client = Arc::new(UPowerClientService::new(event_bridge.publisher_for_upower_events()).await?);
//     // upower_client.initialize_and_listen().await?;
//     // ... für andere D-Bus Clients ...
//
//     // PipeWire Client initialisieren
//     // let audio_service = Arc::new(PipeWireClientService::new(event_bridge.publisher_for_audio_events()).await?);
//
//     // MCP Client initialisieren
//     // let mcp_connection_manager = Arc::new(McpConnectionManager::new(secrets_service_client, event_bridge.publisher_for_mcp_events()));
//     // let mcp_service = Arc::new(DefaultSystemMcpService::new(mcp_connection_manager));
//     // mcp_service.configure_servers(domain_services.global_settings.mcp_server_configs).await?;
//
//     // Window Mechanics (ist oft eng mit DesktopState oder als Service)
//     // let window_mechanics_service = Arc::new(DefaultWindowMechanicsService::new(desktop_state.clone(), domain_services.window_policy_service.clone()));
//
//     // Power Management Service
//     // let power_management_dpms_control = desktop_state.clone(); // DesktopState implementiert PowerManagementControl
//     // let power_service = Arc::new(PowerManagementService::new(domain_services.settings_service, logind_client, power_management_dpms_control, ...));
//     // tokio::spawn(async move { power_service.run().await; });
//
//     // Alle Wayland Globals erstellen (nachdem alle States in DesktopState initialisiert sind)
//     // compositor::core::create_all_wayland_globals(&mut desktop_state.lock().unwrap(), &display_handle)?;
//
//     // D-Bus Notifications Server starten (wenn NovaDE ihn bereitstellt)
//     // tokio::spawn(async move {
//     //    dbus_interfaces::notifications_server::run_notifications_server(domain_services.notification_service).await;
//     // });
//
//     // SystemServices struct zurückgeben, das Handles zu den wichtigsten System-Services enthält
//     // Ok(SystemServices { desktop_state_handle: desktop_state, ... })
// }
```

Mit diesen detaillierten Plänen für die Module 5 bis 8 ist die Spezifikation der Systemschicht nun vollständig. Die Implementierung erfordert sorgfältige Beachtung der Asynchronität, der Inter-Prozess-Kommunikation und der Integration mit den Domänen- und Kernschichten. Die Testbarkeit bleibt eine Herausforderung und erfordert umfangreiches Mocking oder dedizierte Testumgebungen.
