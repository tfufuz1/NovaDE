## Spezifikation und Implementierungsanleitung für die NovaDE-Systemschicht

**Ziel:** Erstellung einer robusten, performanten und modularen Systemschicht für die Nova Desktop Environment (NovaDE) in Rust. Diese Schicht interagiert mit dem Betriebssystem, der Hardware und externen Diensten und setzt die Richtlinien der Domänenschicht technisch um. Sie stellt die Grundlage für die Benutzeroberflächenschicht dar.

**Kernmodule und ihre Hauptverantwortlichkeiten:**

1. **`system::compositor`**: Smithay-basierter Wayland-Compositor; Fenster-Lebenszyklus, Protokoll-Implementierung (XDG-Shell, Layer-Shell etc.), Renderer-Abstraktion, XWayland.
2. **`system::input`**: `libinput`-basierte Eingabeverarbeitung; Seat-Management, `xkbcommon`-Integration, Event-Übersetzung für Tastatur, Zeiger, Touch, Gesten.
3. **`system::dbus_interfaces`**: `zbus`-basierte Clients für Systemdienste (NetworkManager, UPower, logind, Secrets, PolicyKit) und Server für `org.freedesktop.Notifications`.
4. **`system::audio_management`**: `pipewire-rs`-basierte PipeWire-Integration; Geräte- und Stream-Management, Lautstärkeregelung.
5. **`system::mcp_client`**: `mcp_client_rs`-basierter Client für das Model Context Protocol; sichere KI-Modell-Kommunikation.
6. **`system::window_mechanics`**: Technische Umsetzung der Fenster-Policies aus der Domänenschicht (Positionierung, Tiling, Fokus).
7. **`system::power_management`**: DPMS-Steuerung, Reaktion auf Inaktivität und logind-Ereignisse.
8. **`system::event_bridge`**: Zentraler Hub für systeminterne Events via `tokio::sync::broadcast`.

**Technologie-Stack (Auszug für Systemschicht):** Rust, Smithay, `libinput`, `xkbcommon`, `zbus`, `pipewire-rs`, `mcp_client_rs`, `calloop`, `tokio`.

**Entwicklungsrichtlinien:** Modulare Fehlerbehandlung (`thiserror`), strukturiertes Logging (`tracing`), `async/await` für nebenläufige Operationen.

**Folgend nun die detaillierten, feingranularen Schnittstellenspezifikationen pro Modul, die als direkte Implementierungsanweisung für eine KI-gestützte Entwicklung dienen.**

---

## Ultra-Feingranulare Schnittstellenspezifikation: NovaDE Systemschicht (`novade-system`)

Dieser Implementierungsleitfaden ist so konzipiert, dass er von einem autonomen KI-Entwicklungsagenten (z.B. Manus AI) direkt zur Codegenerierung verwendet werden kann. Jede Komponente, Datenstruktur, Methode und Interaktion ist explizit definiert, um Interpretationsspielraum zu minimieren.

### Modul 0: Vorbemerkungen und Globale Systemschicht-Konventionen

- **Crate-Name:** `novade-system`
- **Abhängigkeiten (exemplarisch, in `Cargo.toml` zu definieren):**
    - `novade-core = { path = "../novade-core" }`
    - `novade-domain = { path = "../novade-domain" }`
    - `smithay = "0.10.0"` (Version prüfen und Features nach Bedarf: `renderer_gl`, `backend_libinput`, `backend_session`, `backend_udev`, `backend_drm`, `desktop`, `xwayland`)
    - `wayland-server = "0.30"` (Smithay-kompatible Version)
    - `wayland-protocols = { version = "0.30", features = ["server", "unstable_protocols"] }`
    - `calloop = "0.12"`
    - `libinput = "0.9"`
    - `xkbcommon = "0.7"`
    - `zbus = { version = "3.15", default-features = false, features = ["tokio"] }` (Version prüfen)
    - `pipewire = "0.8"` (Version prüfen, ggf. `libspa`)
    - `mcp_client_rs = "0.2.0"` (Version prüfen)
    - `tokio = { version = "1.37", features = ["full"] }`
    - `async-trait = "0.1"`
    - `thiserror = "1.0"`
    - `tracing = "0.1"`
    - `uuid = { version = "1.8", features = ["v4"] }`
    - `serde = { version = "1.0", features = ["derive"] }`
    - `serde_json = "1.0"`
- **Fehlerbehandlung:** Jedes Submodul definiert ein eigenes `Error`-Enum mit `#[derive(Debug, thiserror::Error)]`. Fehler aus Bibliotheken werden mit `#[source]` oder `#[from]` gewrappt.
- **Logging:** `tracing::{trace, debug, info, warn, error}` Makros verwenden.
- **Asynchronität:** `async fn` für Operationen, die blockieren könnten. `calloop` für die Compositor-Hauptschleife, `tokio` für D-Bus, MCP und andere nebenläufige Tasks.

### Modul 1: `system::compositor`

Zweck: Implementierung des Wayland-Compositors.

#### 1.1. Submodul: `system::compositor::errors`

Datei: `src/compositor/errors.rs`

- **Enum `CompositorError`**:
    - Varianten (mit `#[error("...")]` und ggf. `#[source]` / `#[from]`):
        - `GlobalCreationFailed { name: String, details: String }`
        - `SurfaceRoleError(#[from] smithay::wayland::compositor::SurfaceRoleError)`
        - `ClientDataMissing { client_id_str: String }` (ClientId zu String für `Display`)
        - `SurfaceDataMissing { surface_id_str: String }` (WlSurface Debug zu String)
        - `InvalidSurfaceState { surface_id_str: String, reason: String }`
        - `RendererInitializationFailed(String)`
        - `DisplayOrLoopCreationFailed(String)`
        - `XWaylandInitializationFailed(String)`
        - `DrmBackendError { details: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
        - `LibinputBackendError(String)`
        - `SessionError(String)`
        - `XdgShellError(#[from] crate::compositor::xdg_shell::errors::XdgShellError)` (aus eigenem Submodul)
        - `LayerShellError(#[from] crate::compositor::layer_shell::errors::LayerShellError)` (aus eigenem Submodul)
        - `OutputManagementError(#[from] crate::compositor::output_management::errors::OutputManagementError)` (aus eigenem Submodul)

#### 1.2. Submodul: `system::compositor::types` (oder direkt in `core::state` und `surface_management`)

Datei: `src/compositor/types.rs` (oder aufgeteilt)

- **Struct `ClientCompositorData`** (für `Client::data_map`):
    - `compositor_state: smithay::wayland::compositor::CompositorClientState`
    - `xdg_shell_client_data: smithay::wayland::shell::xdg::XdgWmBaseClientData` (oder `XdgShellClientData` je nach Smithay Version)
- **Struct `SurfaceData`** (für `WlSurface::data_map`):
    - `id: uuid::Uuid`
    - `client_id_str: String`
    - `role: std::sync::Mutex<Option<String>>`
    - `current_buffer_info: std::sync::Mutex<Option<AttachedBufferInfo>>`
    - `texture_handle: std::sync::Mutex<Option<Box<dyn crate::compositor::renderer_interface::RenderableTexture>>>`
    - `damage_buffer_coords: std::sync::Mutex<Vec<smithay::utils::Rectangle<i32, smithay::utils::Buffer>>>`
    - `opaque_region_surface_local: std::sync::Mutex<Option<smithay::utils::Region<smithay::utils::Logical>>>`
    - `input_region_surface_local: std::sync::Mutex<Option<smithay::utils::Region<smithay::utils::Logical>>>`
    - `parent: std::sync::Mutex<Option<wayland_server::Weak<wayland_server::protocol::wl_surface::WlSurface>>>`
    - `children: std::sync::Mutex<Vec<wayland_server::Weak<wayland_server::protocol::wl_surface::WlSurface>>>`
    - `surface_viewporter_state: std::sync::Mutex<smithay::wayland::viewporter::SurfaceState>`
    - `surface_presentation_state: std::sync::Mutex<smithay::wayland::presentation::SurfaceState>`
    - `user_data_map: smithay::reexports::wayland_server::backend::UserDataMap` (für Shell-spezifische Daten)
    - **Methoden:** `new(client_id_str: String) -> Self`, `set_role(&self, role: &str) -> Result<(), CompositorError>`, `get_role(&self) -> Option<String>`.
- **Struct `AttachedBufferInfo`**:
    - `buffer: wayland_server::protocol::wl_buffer::WlBuffer`
    - `scale: i32`
    - `transform: smithay::utils::Transform`
    - `dimensions: smithay::utils::Size<i32, smithay::utils::Buffer>`

#### 1.3. Submodul: `system::compositor::core`

Datei: `src/compositor/core/state.rs`

- **Struct `DesktopState`** (zentraler Zustand, Details aus Gesamtspezifikation und System-Details):
    - **Felder (Auswahl):**
        - `display_handle: smithay::reexports::wayland_server::DisplayHandle`
        - `loop_handle: smithay::reexports::calloop::LoopHandle<'static, Self>`
        - `clock: smithay::utils::Clock<u64>`
        - `compositor_state: smithay::wayland::compositor::CompositorState`
        - `shm_state: smithay::wayland::shm::ShmState`
        - `presentation_state: smithay::wayland::presentation::PresentationState`
        - `viewporter_state: smithay::wayland::viewporter::ViewporterState`
        - `xdg_shell_state: smithay::wayland::shell::xdg::XdgShellState`
        - `xdg_activation_state: smithay::wayland::xdg_activation::XdgActivationState`
        - `layer_shell_state: smithay::wayland::shell::wlr_layer::WlrLayerShellState`
        - `decoration_state: smithay::wayland::shell::xdg::decoration::XdgDecorationState`
        - `space: std::sync::Arc<std::sync::Mutex<smithay::desktop::Space<ManagedWindow>>>`
        - `windows: std::sync::Arc<std::sync::Mutex<std::collections::HashMap<crate::domain::workspaces::core::types::WindowIdentifier, Arc<ManagedWindow>>>>`
        - `seat_state: smithay::input::SeatState<Self>`
        - `seat: smithay::input::Seat<Self>`
        - `seat_name: String`
        - `input_method_manager_state: smithay::wayland::input_method::InputMethodManagerState`
        - `keyboard_data_map: std::sync::Arc<std::sync::Mutex<std::collections::HashMap<String, crate::input::keyboard::xkb_config::XkbKeyboardData>>>`
        - `current_cursor_status: std::sync::Arc<std::sync::Mutex<smithay::input::pointer::CursorImageStatus>>`
        - `pointer_location: std::sync::Arc<std::sync::Mutex<smithay::utils::Point<f64, smithay::utils::Logical>>>`
        - `output_manager_state: smithay::wayland::output::OutputManagerState`
        - `wlr_output_manager_v1_state: smithay::wayland::output_manager::OutputManagerState` (für wlr-output-management)
        - `wlr_output_power_manager_v1_state: smithay::wayland::output_power_manager::OutputPowerManagerState` (für wlr-output-power-management)
        - `data_device_state: smithay::wayland::selection::data_device::DataDeviceState`
        - `renderer: Option<Box<dyn crate::compositor::renderer_interface::FrameRenderer>>` (wird nach Backend-Init gesetzt)
        - `domain_services: Arc<crate::domain::DomainServices>` (Sammelstruktur für Domänen-Service-Handles)
        - `system_event_bridge: Arc<crate::event_bridge::SystemEventBridge>`
        - `active_backend_data: std::sync::Mutex<Option<ActiveBackendData>>` (Enum für DRM, Winit etc. Daten)
        - `wayland_globals: Option<NovaDEWaylandGlobals>` (Struct, das `GlobalId`s hält)
    - **Konstruktor:** `pub fn new(loop_handle, display_handle, domain_services, system_event_bridge) -> Self` (initialisiert alle Smithay-States).
    - **Methoden:** `pub fn create_all_wayland_globals(&mut self) -> Result<(), CompositorError>` (registriert alle Globals).
- **Implementierung von `smithay::wayland::compositor::CompositorHandler` für `DesktopState`**:
    - `compositor_state(&mut self) -> &mut CompositorState`: `&mut self.compositor_state`
    - `client_compositor_state<'a>(&self, client: &'a Client) -> &'a CompositorClientState`: `&client.get_data::<ClientCompositorData>().unwrap().compositor_state`
    - `commit(&mut self, surface: &WlSurface)`: Logik wie in spezifiziert (Puffer-Handling, Schaden, Rollen-Dispatch, Sync-Subsurfaces). Verwendet `with_surface_data_mut` für Zugriff auf `SurfaceData`.
    - `new_surface(&mut self, surface: &WlSurface)`: `surface.data_map().insert_if_missing_threadsafe(|| Arc::new(SurfaceData::new(...))); add_destruction_hook(...)`.
    - `new_subsurface(&mut self, surface: &WlSurface, parent: &WlSurface)`: Verlinkt Parent/Child in `SurfaceData`.
    - `destroyed(&mut self, surface: &WlSurface)`: Hauptsächlich für Logging und ggf. explizite Benachrichtigung anderer Teile von `DesktopState`, die `WlSurface` direkt referenzieren (obwohl `destruction_hook` bevorzugt wird).
- **Implementierung von `smithay::wayland::shm::ShmHandler` und `smithay::wayland::buffer::BufferHandler` für `DesktopState`**:
    - `shm_state(&self) -> &ShmState`: `&self.shm_state`
    - `buffer_destroyed(&mut self, buffer: &WlBuffer)`: Benachrichtigt Renderer zur Freigabe von Texturen, die mit diesem `buffer` assoziiert sind (Identifikation über `SurfaceData`).

#### 1.4. Submodul: `system::compositor::xdg_shell`

Datei: `src/compositor/xdg_shell/errors.rs`, `types.rs`, `handlers.rs`

- **Enum `XdgShellError`**: (Wie in spezifiziert)
- **Struct `ManagedWindow`** (Implementiert `smithay::desktop::Window`):
    - **Felder:** `id: uuid::Uuid`, `domain_id: crate::domain::workspaces::core::types::WindowIdentifier`, `xdg_surface: smithay::desktop::WindowSurface` (hält `ToplevelSurface` oder `PopupSurface`), `current_geometry: smithay::utils::Rectangle<i32, smithay::utils::Logical>`, `is_mapped: bool`, `requested_size`, `min_size`, `max_size`, `parent_window_domain_id: Option<DomainWindowIdentifier>`.
    - **Methoden:** `new_toplevel(...)`, `new_popup(...)`, `wl_surface()`, Methoden des `Window`-Traits (send_configure, set_activated, etc. – rufen Methoden auf `self.xdg_surface` auf).
- **Implementierung `smithay::wayland::shell::xdg::XdgShellHandler` für `DesktopState`**:
    - `xdg_shell_state(&mut self) -> &mut XdgShellState`: `&mut self.xdg_shell_state`
    - `new_toplevel(&mut self, surface: ToplevelSurface)`: Erstellt `ManagedWindow`, fordert initiale Geometrie von `domain::window_management_policy_service` an, sendet initiales `configure`, fügt zu `self.space` und `self.windows` hinzu.
    - `new_popup(&mut self, surface: PopupSurface, positioner: PositionerState)`: Erstellt `ManagedWindow` (als Popup), berechnet Geometrie basierend auf `positioner` und Parent, sendet `configure`, fügt zu `self.windows` hinzu.
    - `map_toplevel(&mut self, surface: &ToplevelSurface)`: Setzt `managed_window.is_mapped = true`, benachrichtigt Domäne (`workspace_manager_service.assign_window_to_active_workspace`), fordert Re-Layout.
    - `unmap_toplevel(&mut self, surface: &ToplevelSurface)`: Setzt `is_mapped = false`, benachrichtigt Domäne, entfernt aus `space`.
    - `ack_configure(&mut self, surface: WlSurface, configure_data: XdgSurfaceConfigureUserData)`: Verarbeitet Client-Bestätigung.
    - **Request-Handler** (`toplevel_request_set_title`, `toplevel_request_set_maximized`, `move_request`, `resize_request`, etc.):
        1. Findet `ManagedWindow` für das `ToplevelSurface`/`PopupSurface`.
        2. Aktualisiert den Zustand im `ManagedWindow` und/oder dessen Smithay `XdgToplevelSurfaceData`/`XdgPopupSurfaceData`.
        3. Interagiert mit `self.domain_services.window_policy_service` für Validierung oder Policy-Anpassungen.
        4. Sendet bei Bedarf neue `configure`-Events an den Client.
        5. Für `move` und `resize`: Startet einen interaktiven Grab über `self.seat.start_pointer_grab(...)` mit einer spezifischen Grab-Handler-Implementierung (siehe `system::window_mechanics`).
    - `toplevel_destroyed(&mut self, toplevel: ToplevelSurface)` / `popup_destroyed(&mut self, popup: PopupSurface)`: Entfernt `ManagedWindow` aus `self.space` und `self.windows`, benachrichtigt Domäne.

#### 1.5. Submodul: `system::compositor::layer_shell`

Datei: `src/compositor/layer_shell/errors.rs`, `types.rs`, `handlers.rs`

- **Enum `LayerShellError`**: `InvalidLayerSurfaceState`, `NamespaceAlreadyTaken`.
- **Struct `ManagedLayerSurface`** (Implementiert `smithay::desktop::LayerSurface`):
    - **Felder:** `id: uuid::Uuid`, `domain_id: crate::domain::workspaces::core::types::WindowIdentifier` (für Panel/Dock-Identifikation), `layer_surface: smithay::wayland::shell::wlr_layer::LayerSurface`, `current_geometry`, `is_mapped`.
- **Implementierung `smithay::wayland::shell::wlr_layer::LayerShellHandler` für `DesktopState`**:
    - `layer_shell_state(&mut self) -> &mut WlrLayerShellState`: `&mut self.layer_shell_state`
    - `new_layer_surface(&mut self, surface: LayerSurface, output: Option<Output>, layer: Layer, namespace: String)`: Erstellt `ManagedLayerSurface`, validiert Namespace, konfiguriert Layer und Anker, sendet initiales `configure`. Fügt zu `smithay::desktop::layer_map_for_output(output).map_layer(&layer_surface)`.
    - `layer_surface_commit(&mut self, surface: &LayerSurface)`: Reagiert auf Puffer-Commits, aktualisiert ggf. Geometrie basierend auf Client-Requests.
    - `layer_surface_destroyed(&mut self, surface: &LayerSurface)`: Entfernt aus Layer Map.

#### 1.6. Weitere `system::compositor` Submodule (Struktur analog)

- **`decoration`**: `XdgDecorationHandler` für `xdg-decoration-unstable-v1`. Verwaltet `XdgDecorationState`.
- **`output_management`**: Implementierung von `smithay::wayland::output::OutputHandler`, `smithay::wayland::output_manager::OutputManagerHandler` (für `wlr-output-management-unstable-v1`) und `smithay::wayland::xdg_output::XdgOutputHandler` (für `xdg-output-unstable-v1`). `DesktopState` hält `OutputManagerState`.
- **`input_method`**: `InputMethodHandler`, `TextInputHandler`. `DesktopState` hält `InputMethodManagerState`, `TextInputManagerState`.
- **`screencopy`**: Implementierung von `wlr-screencopy-unstable-v1` (benötigt Zugriff auf Renderer).
- **`data_device`**: `DataDeviceHandler`, `PrimarySelectionHandler`. `DesktopState` hält `DataDeviceState`, `PrimarySelectionState`.
- **`xwayland`**: `XWayland`, `X11Wm`, `XwmHandler`. Starten und Verwalten des XWayland-Servers.
- **`renderer_interface`**:
    - Trait `RenderableTexture: Send + Sync + std::fmt::Debug { fn id(&self) -> uuid::Uuid; fn bind(&self, slot: u32) -> Result<()>; fn width_px(&self) -> u32; ... }`
    - Trait `FrameRenderer: Send + Sync { fn new(...) -> Result<Self>; fn render_frame(...); fn present_frame(...); fn create_texture_from_shm(...); ... }`
    - Enum `RenderElement { Surface { texture, geometry, damage, ... }, Cursor { ... } }`
- **`drm_gbm_renderer` / `winit_renderer`**: Konkrete Implementierungen von `FrameRenderer`.

### Modul 2: `system::input`

Zweck: Eingabeverarbeitung.

#### 2.1. Submodul: `system::input::errors`

Datei: `src/input/errors.rs`

- **Enum `InputError`**: (Wie in spezifiziert) `SeatCreationFailed`, `CapabilityAdditionFailed`, `XkbConfigError`, `LibinputError`, `LibinputSessionError`, `SeatNotFound`, `KeyboardHandleNotFound`, etc.

#### 2.2. Submodul: `system::input::types` (oder in `keyboard`, `pointer` etc.)

Datei: `src/input/types.rs`

- **Struct `XkbConfig`** (aus `smithay::input::keyboard::KeyboardConfig`)
- **Struct `XkbKeyboardData`**:
    - `context: xkbcommon::xkb::Context`
    - `keymap: xkbcommon::xkb::Keymap`
    - `state: xkbcommon::xkb::State`
    - `repeat_timer: Option<calloop::TimerHandle>`
    - `repeat_info: Option<(u32 /* libinput keycode */, xkbcommon::xkb::Keycode /* xkb keycode */, SmithayModifiersState, std::time::Duration, std::time::Duration)>`
    - `focused_surface_on_seat: Option<wayland_server::Weak<WlSurface>>`
    - `repeat_key_serial: Option<smithay::utils::Serial>`
    - **Methoden:** `new(config: &XkbConfig) -> Result<Self, InputError>`, `update_xkb_state_from_modifiers(...)`.
- **Event `InputDeviceHotplugEvent`** (für `system::event_bridge`):
    - `device_name: String`
    - `device_type: String` (z.B. "keyboard", "pointer", "touch")
    - `event_type: HotplugType (Added | Removed)`

#### 2.3. Submodul: `system::input::seat_manager`

Datei: `src/input/seat_manager.rs`

- **`DesktopState` Implementierung von `smithay::input::SeatHandler`**:
    - `seat_state(&mut self) -> &mut SeatState<Self>`: `&mut self.seat_state`
    - `focus_changed(&mut self, seat: &Seat<Self>, focused_surface: Option<&WlSurface>)`: Aktualisiert internen Fokus-Cache (`self.active_input_surface`), benachrichtigt Domänenschicht (`domain::window_management_policy` oder `workspace_manager`) über Fokuswechsel. _Wichtig:_ `KeyboardHandle::set_focus` löst dies aus; hier nicht erneut `set_focus` rufen.
    - `cursor_image(&mut self, seat: &Seat<Self>, image: CursorImageStatus)`: Aktualisiert `self.current_cursor_status`, benachrichtigt Renderer zur Neudarstellung des Cursors. Bei `Named(name)`: Logik zum Laden von Cursorthemes (ggf. `libwayland-cursor` oder eigene Implementierung).
- **Funktion `pub fn create_seat(state: &mut DesktopState, display_handle: &DisplayHandle, seat_name: String) -> Result<(), InputError>`**:
    1. `seat = state.seat_state.new_wl_seat(display_handle, seat_name.clone(), ...);`
    2. `state.seats.insert(seat_name.clone(), seat.clone());` (Oder `state.seat = seat.clone()` für primären Seat).
    3. Initialisiere `XkbKeyboardData` für diesen Seat in `state.keyboard_data_map`.
    4. Fähigkeiten (Keyboard, Pointer, Touch) werden später hinzugefügt, wenn `LibinputInputBackend` Geräte meldet.

#### 2.4. Submodul: `system::input::libinput_handler`

Datei: `src/input/libinput_handler/mod.rs` (und ggf. `session_interface.rs`)

- **Struct `LibinputSessionInterface`** (implementiert `smithay::backend::input::LibinputInterface`): Kapselt `smithay::backend::session::Session` (z.B. `LogindSession` oder `DirectSession`). Methoden `open_restricted`, `close_restricted`.
- **Funktion `pub fn init_libinput_backend<S: Session + 'static>(session_interface: Rc<RefCell<S>>) -> Result<LibinputInputBackend, InputError>`**: Erstellt `LibinputInputBackend`.
- **Funktion `pub fn register_libinput_event_source(loop_handle: &LoopHandle<DesktopState>, backend: LibinputInputBackend, seat_name_for_callback: String) -> Result<calloop::Source<LibinputInputBackend>, InputError>`**: Fügt Backend zur `calloop`-Schleife hinzu. Callback ruft `process_input_event`.
- **Funktion `pub fn process_input_event(desktop_state: &mut DesktopState, event: InputEvent<LibinputInputBackend>, seat_name: &str)`**:
    1. Holt `Seat<DesktopState>` für `seat_name`.
    2. `match event`:
        - `DeviceAdded { device }`: `tracing::info!(...)`. Prüft `device.capabilities()`. Wenn z.B. `Keyboard` und Seat noch keine Tastatur hat: `seat.add_keyboard(XkbConfig::default(), 200, 25)?`. Analog für Pointer, Touch. Sendet `InputDeviceHotplugEvent`.
        - `DeviceRemoved { device }`: `tracing::info!(...)`. Entfernt Capabilities vom Seat. Sendet `InputDeviceHotplugEvent`.
        - `Keyboard { event }`: Ruft `crate::input::keyboard::key_event_translator::handle_keyboard_event(...)`.
        - `PointerMotion { event }`: Ruft `crate::input::pointer::pointer_event_translator::handle_pointer_motion_event(...)`.
        - (Analog für `PointerMotionAbsolute`, `PointerButton`, `PointerAxis`, `TouchDown`, `TouchUp`, `TouchMotion`, `TouchFrame`, `TouchCancel`, `Gesture*`).

#### 2.5. Submodule: `system::input::keyboard`, `system::input::pointer`, `system::input::touch`, `system::input::gestures`

- **`keyboard::key_event_translator::handle_keyboard_event(...)`**:
    1. Holt `KeyboardHandle<DesktopState>` und `XkbKeyboardData`.
    2. Konvertiert `libinput keycode` zu `xkbcommon keycode` (`+8`).
    3. `xkb_data.state.update_key(...)`.
    4. Holt `SmithayModifiersState` von `xkb_data.state`.
    5. `keyboard_handle.modifiers(serial, mods_state, ...)`
    6. Wenn `KeyState::Pressed`: `keyboard_handle.key(serial, time, xkb_keycode, KeyState::Pressed, ...)`. Tastenwiederholung einrichten/aktualisieren (via `calloop::TimerHandle` in `XkbKeyboardData`, Callback sendet erneut `key` Event mit neuem Serial).
    7. Wenn `KeyState::Released`: `keyboard_handle.key(...)`. Tastenwiederholung abbrechen.
- **`keyboard::focus::set_keyboard_focus(...)`**:
    1. Holt `KeyboardHandle<DesktopState>` und `XkbKeyboardData`.
    2. `keyboard_handle.set_focus(target_surface_option, serial, ...)` (Smithay sendet `enter`/`leave`).
    3. Aktualisiert `xkb_data.focused_surface_on_seat`.
    4. Benachrichtigt Domäne (via `desktop_state.domain_services...` oder `SystemEventBridge`).
- **`pointer::pointer_event_translator::handle_pointer_motion_event(...)`**:
    1. Holt `PointerHandle<DesktopState>`.
    2. Aktualisiert `desktop_state.pointer_location` basierend auf `event.delta()`.
    3. `let (new_focus_surface, surface_local_coords) = find_surface_and_coords_at_global_point(desktop_state, desktop_state.pointer_location)`.
    4. `pointer_handle.motion(time, new_focus_surface.as_ref(), serial, desktop_state.pointer_location, surface_local_coords, ...)` (Smithay sendet `enter`/`leave`/`motion`).
    5. Aktualisiert `desktop_state.active_input_surface`.
- **`find_surface_and_coords_at_global_point(...)`**: Iteriert `desktop_state.space.elements_under(global_pos)`, prüft `input_region` von `SurfaceData`.
- (Analog für andere Zeiger- und Touch-Events, die entsprechende `PointerHandle`- und `TouchHandle`-Methoden aufrufen).

---

(Die Spezifikationen für die Module `system::dbus_interfaces`, `system::audio_management`, `system::mcp_client`, `system::window_mechanics`, `system::power_management` und `system::event_bridge` würden mit derselben Detailtiefe folgen, basierend auf den vorherigen Antworten und den Quelldokumenten.)

**Dieser ultra-feingranulare Implementierungsleitfaden für die Systemschicht, beginnend mit dem Compositor und der Eingabeverarbeitung, legt eine präzise Basis für die Entwicklung. Die konsequente Anwendung der definierten Strukturen, Methoden, Fehler und Events durch einen KI-Agenten soll zu einer robusten und korrekten Implementierung führen.**

Ultra-Feinspezifikation und Implementierungsleitfaden der internen Schnittstellen der Linux Desktop-Umgebung "NovaDE"EinleitungDieses Dokument dient als erweiterte technische Spezifikation und detaillierter Implementierungsleitfaden für die internen Schnittstellen zwischen den vier Hauptarchitekturschichten der Linux Desktop-Umgebung "NovaDE": Kernschicht (Core Layer), Domänenschicht (Domain Layer), Systemschicht (System Layer) und Benutzeroberflächenschicht (UI Layer). Die Kommunikation zwischen diesen Schichten erfolgt primär über wohldefinierte öffentliche APIs, die häufig als Rust-Traits implementiert sind, sowie über ein robustes Event-System zur Signalisierung von Zustandsänderungen. Ziel dieses Dokuments ist es, eine lückenlose Ultra-Feinspezifikation bereitzustellen, die Entwicklern eine direkte Implementierung ohne eigene Entwurfsentscheidungen ermöglicht. Alle relevanten Aspekte wurden recherchiert, entschieden und präzise spezifiziert, um Klarheit und Konsistenz über das gesamte System hinweg zu gewährleisten.Die hier dargelegten Spezifikationen sind entscheidend, um die kohärente Zusammenarbeit der verschiedenen Schichten sicherzustellen und die übergeordneten Projektziele – Performance, Intuition, Modernität, Modularität, Anpassbarkeit, sichere KI-Integration und Stabilität – zu erreichen.1. Schnittstelle: Kernschicht (Core Layer) zu höheren Schichten (Domäne, System, UI)Die Kernschicht stellt fundamentale Bausteine und Dienste bereit, die von allen darüberliegenden Schichten genutzt werden. Diese Dienste sind so konzipiert, dass sie maximale Wiederverwendbarkeit und minimale Abhängigkeiten für die höheren Schichten gewährleisten.1.1. Bereitgestellte Funktionalität1.1.1. core::typesDefiniert grundlegende, universell einsetzbare Datentypen.
Schnittstelle: Direkte Verwendung von Typen wie Point<T>, Size<T>, Rect<T>, RectInt, Color, Orientation sowie uuid::Uuid und chrono::DateTime<Utc> durch die höheren Schichten.
Beispielhafte Nutzung: Die Domänenschicht verwendet Color für Theming-Definitionen, die Systemschicht RectInt für Fenstergeometrien, und die UI-Schicht Point<T> für die Positionierung von Elementen.
1.1.2. core::errorsStellt eine Basis-Fehlerbehandlungsstrategie und den CoreError-Typ bereit.
Schnittstelle: Höhere Schichten können CoreError oder spezifischere Fehler aus Kernmodulen mittels #[from] oder #[source] in ihre eigenen Fehlertypen wrappen. Die Fehlerursachenkette (source()) wird dabei beibehalten.1
Beispielhafte Nutzung: Ein ConfigError in domain::workspaces::config kann einen CoreError::Io wrappen, der beim Lesen einer Datei in core::config aufgetreten ist.
1.1.3. core::loggingDefiniert die Logging-Infrastruktur basierend auf tracing.
Schnittstelle: Alle höheren Schichten verwenden die tracing-Makros (trace!, info!, etc.) für ihre Logging-Ausgaben. Die Funktion core::logging::initialize_logging() wird typischerweise einmalig von der Anwendung (z.B. UI-Schicht) beim Start aufgerufen.
1.1.4. core::configStellt Primitive zum Laden, Parsen und Zugreifen auf Kernkonfigurationen bereit.
Schnittstelle: Funktionen wie load_core_config(custom_path: Option<PathBuf>) -> Result<CoreConfig, ConfigError> und get_core_config() -> &'static CoreConfig für den globalen Zugriff. Die CoreConfig-Struktur selbst ist Teil der Schnittstelle.
Beispielhafte Nutzung: domain::settings_persistence_iface (oder eine konkrete Implementierung wie FilesystemConfigProvider) nutzt diese API, um Basiskonfigurationen zu lesen, die dann von der Domänenschicht weiterverarbeitet werden.
1.1.5. core::utilsBietet allgemeine Hilfsfunktionen.
Schnittstelle: Direkte Nutzung der öffentlichen Funktionen durch alle höheren Schichten.
1.2. Ultra-Feinspezifikation: Modul core::config::loaderDieses interne Modul ist für das Laden und Parsen von Konfigurationsdateien für das öffentliche core::config API zuständig.1.2.1. Modulübersicht
Zweck: Implementiert die Logik zum Auffinden, Lesen und Deserialisieren der Kernkonfigurationsdatei (core.json oder ein anderes gewähltes Format).
Interne Abhängigkeiten: core::types (für PathBuf), core::errors::CoreError, super::types::CoreConfig (die öffentliche Konfigurationsstruktur), super::errors::ConfigError.
Externe Abhängigkeiten: serde, serde_json (oder toml, etc.), std::fs, std::path, std::io.
1.2.2. Interne Datenstrukturen
struct RawCoreConfig

Datei: nova_de/core/src/config/raw_types.rs
Zweck: Dient der direkten Deserialisierung der Konfigurationsdatei. Dies ermöglicht Flexibilität bei der Versionierung und Validierung der Konfiguration, bevor sie in die öffentliche CoreConfig-Struktur überführt wird. Felder sind typischerweise Option<T>, um fehlende Werte abzufangen und Defaults anzuwenden.
Attribute: Spiegeln die Felder von CoreConfig, jedoch als Option<String>, Option<bool>, etc. Beispiel:
Rust// nova_de/core/src/config/raw_types.rs
use serde::Deserialize;

#
pub(super) struct RawCoreConfig {
    pub(super) log_level: Option<String>,
    pub(super) default_theme_name: Option<String>,
    pub(super) enable_experimental_features: Option<bool>,
    // Weitere Felder entsprechend CoreConfig
}


Sichtbarkeit: pub(super) innerhalb des core::config Moduls.


1.2.3. Fehlerbehandlung: ConfigError
Datei: nova_de/core/src/config/errors.rs (oder in core::errors integriert)
Definition:
Rust// nova_de/core/src/config/errors.rs
use std::io;
use std::path::PathBuf;
use thiserror::Error;

#
pub enum ConfigError {
    #
    NotFound { searched_paths: Vec<PathBuf> },

    #[error("I/O error accessing config file at {path:?}")]
    Io {
        path: PathBuf,
        #[source]
        source: io::Error,
    },

    #[error("Failed to parse config file at {path:?}")]
    ParseError {
        path: PathBuf,
        #[source]
        source: serde_json::Error, // Oder anderer Deserialisierungsfehler
        content_snippet: String, // Ein kurzer Ausschnitt des fehlerhaften Inhalts
    },

    #[error("Invalid configuration value for key '{key}': {message}")]
    InvalidValue { key: String, message: String },

    #[error("Could not determine home directory")]
    HomeDirectoryNotFound,
}

Die Verwendung von thiserror ermöglicht eine klare Fehlerdefinition und -verkettung.1
1.2.4. Interne Funktionen

fn resolve_config_path(custom_path: Option<&PathBuf>) -> Result<PathBuf, ConfigError>

Datei: nova_de/core/src/config/loader.rs
Zweck: Bestimmt den zu ladenden Konfigurationspfad gemäß der XDG Base Directory Specification und optionalen benutzerdefinierten Pfaden.
Parameter:

custom_path: Option<&PathBuf> (const): Ein optional vom Benutzer bereitgestellter Pfad.


Rückgabe: Result<PathBuf, ConfigError> - Der aufgelöste Pfad oder ein ConfigError::NotFound.
Implementierungsschritte:

Wenn custom_path Some(path) ist:

Prüfen, ob path existiert. Wenn ja, Ok(path.clone()) zurückgeben.
Wenn nicht, Err(ConfigError::NotFound { searched_paths: vec![path.clone()] }) zurückgeben (oder spezifischerer Fehler).


Andernfalls XDG-Pfade prüfen:

xdg_config_home = std::env::var("XDG_CONFIG_HOME").map(PathBuf::from).or_else(|_| dirs::home_dir().map(|h| h.join(".config"))).ok_or(ConfigError::HomeDirectoryNotFound)?;
user_path = xdg_config_home.join("novade/core.json");
Wenn user_path existiert, Ok(user_path) zurückgeben.


Systemweite XDG-Pfade prüfen:

xdg_config_dirs = std::env::var("XDG_CONFIG_DIRS").map(|dirs| dirs.split(':').map(PathBuf::from).collect::<Vec<_>>()).unwrap_or_else(|_| vec!);
Für jeden dir in xdg_config_dirs:

system_path = dir.join("novade/core.json");
Wenn system_path existiert, Ok(system_path) zurückgeben.




Fallback-Systempfad prüfen:

fallback_path = PathBuf::from("/etc/novade/core.json");
Wenn fallback_path existiert, Ok(fallback_path) zurückgeben.


Wenn keine Datei gefunden wurde, Err(ConfigError::NotFound { searched_paths:... }) mit allen geprüften Pfaden zurückgeben.


Vorbedingungen: Keine.
Nachbedingungen: Gibt einen validen, existierenden Pfad zurück oder einen Fehler.



fn read_config_file(path: &Path) -> Result<String, ConfigError>

Datei: nova_de/core/src/config/loader.rs
Zweck: Liest den Inhalt der Konfigurationsdatei.
Parameter:

path: &Path (const): Pfad zur Konfigurationsdatei.


Rückgabe: Result<String, ConfigError> - Dateiinhalt als String oder ein ConfigError::Io.
Implementierungsschritte:

std::fs::read_to_string(path).map_err(|e| ConfigError::Io { path: path.to_path_buf(), source: e })


Vorbedingungen: path ist ein valider Pfad.
Nachbedingungen: Gibt den Dateiinhalt zurück oder einen I/O-Fehler.



fn parse_raw_config(content: &str, path: &Path) -> Result<RawCoreConfig, ConfigError>

Datei: nova_de/core/src/config/loader.rs
Zweck: Parst den String-Inhalt in die RawCoreConfig-Struktur.
Parameter:

content: &str (const): Der zu parsende String-Inhalt.
path: &Path (const): Der Pfad der Konfigurationsdatei (für Fehlerberichte).


Rückgabe: Result<RawCoreConfig, ConfigError> - Die geparste Rohkonfiguration oder ein ConfigError::ParseError.
Implementierungsschritte:

serde_json::from_str(content).map_err(|e| ConfigError::ParseError { path: path.to_path_buf(), source: e, content_snippet: content.chars().take(100).collect() })


Vorbedingungen: content ist ein valider String.
Nachbedingungen: Gibt die geparste Rohkonfiguration zurück oder einen Parse-Fehler.



fn convert_raw_to_core_config(raw_config: RawCoreConfig, config_path: &Path) -> Result<CoreConfig, ConfigError>

Datei: nova_de/core/src/config/loader.rs
Zweck: Konvertiert RawCoreConfig in CoreConfig, wendet Standardwerte an und validiert Werte.
Parameter:

raw_config: RawCoreConfig: Die geparste Rohkonfiguration.
config_path: &Path: Pfad zur Konfigurationsdatei für Fehlerberichte und Kontext.


Rückgabe: Result<CoreConfig, ConfigError> - Die validierte CoreConfig oder ein ConfigError::InvalidValue.
Implementierungsschrite:

Erstelle eine CoreConfig-Instanz.
Für jedes Feld in RawCoreConfig:

Wenn Some(value), validiere value. Bei Ungültigkeit, Err(ConfigError::InvalidValue { key: "...", message: "..." }) zurückgeben.
Wenn None, verwende einen hartcodierten Standardwert für CoreConfig.
Beispiel: log_level = raw_config.log_level.unwrap_or_else(|| "info".to_string());
Validierung für log_level: Muss einer der unterstützten Werte sein (z.B. "trace", "debug", "info", "warn", "error").


Ok(core_config) zurückgeben.


Vorbedingungen: raw_config ist vorhanden.
Nachbedingungen: Gibt eine valide CoreConfig zurück oder einen Fehler bei ungültigen Werten.


1.2.5. Öffentliche Funktion (innerhalb core::config)
pub(super) fn load_and_parse_core_config(custom_path: Option<PathBuf>) -> Result<CoreConfig, ConfigError>

Datei: nova_de/core/src/config/mod.rs (ruft Funktionen aus loader.rs auf)
Zweck: Orchestriert den gesamten Lade- und Parse-Vorgang. Dies ist die Hauptfunktion, die von der öffentlichen API load_core_config genutzt wird.
Parameter:

custom_path: Option<PathBuf>: Optionaler benutzerdefinierter Pfad.


Rückgabe: Result<CoreConfig, ConfigError>.
Implementierungsschritte:

let resolved_path = loader::resolve_config_path(custom_path.as_ref())?;
let content = loader::read_config_file(&resolved_path)?;
let raw_config = loader::parse_raw_config(&content, &resolved_path)?;
loader::convert_raw_to_core_config(raw_config, &resolved_path)


Vorbedingungen: Keine.
Nachbedingungen: Gibt eine geladene und validierte CoreConfig zurück oder einen entsprechenden ConfigError.


Die Trennung von RawCoreConfig und CoreConfig ist eine bewährte Methode, um die API stabil zu halten, während interne Repräsentationen oder Konfigurationsdateiformate versioniert oder migriert werden können. Dies erhöht die Robustheit und Wartbarkeit des Konfigurationssystems.1.3. Ultra-Feinspezifikation: Modul core::types_moduleDieses Modul ist das Fundament für viele Datenaustauschoperationen innerhalb von NovaDE.1.3.1. Modulübersicht
Zweck: Definition und Implementierung fundamentaler, wiederverwendbarer Datentypen wie geometrische Primitiven (Point, Size, Rect), Color und Orientation. Stellt auch uuid::Uuid und chrono::DateTime<Utc> für das gesamte System bereit.
Dateistruktur:

nova_de/core/src/types/mod.rs: Hauptmoduldatei, exportiert alle Typen.
nova_de/core/src/types/point.rs: Definition von Point<T>.
nova_de/core/src/types/size.rs: Definition von Size<T>.
nova_de/core/src/types/rect.rs: Definition von Rect<T> und RectInt.
nova_de/core/src/types/color.rs: Definition von Color und ColorParseError.
nova_de/core/src/types/orientation.rs: Definition von Orientation.


Abhängigkeiten: uuid (mit Features "serde", "v4"), chrono (mit Feature "serde").5
1.3.2. Datentyp-SpezifikationenPoint<T>
Datei: nova_de/core/src/types/point.rs
Definition:
Rust#
#
pub struct Point<T> {
    pub x: T,
    pub y: T,
}


Attribute:

x: T - Sichtbarkeit: pub. X-Koordinate.
y: T - Sichtbarkeit: pub. Y-Koordinate.


Methoden:

pub const fn new(x: T, y: T) -> Self: Erzeugt einen neuen Punkt.
pub fn map<U, F>(&self, f: F) -> Point<U> where F: Fn(T) -> U, T: Copy: Mappt die Koordinaten zu einem neuen Typ.
Für T: std::ops::Add<Output = T> + Copy:

pub fn offset(&self, dx: T, dy: T) -> Self: Verschiebt den Punkt um (dx, dy).


Für T: std::ops::Sub<Output = T> + Copy:

pub fn vector_to(&self, other: &Point<T>) -> Point<T>: Erzeugt einen Vektor (als Punkt) von self zu other.




Invarianten: Keine über die Typ-Constraints von T hinaus.
Size<T>
Datei: nova_de/core/src/types/size.rs
Definition:
Rust#
#
pub struct Size<T> {
    pub w: T, // width
    pub h: T, // height
}


Attribute:

w: T - Sichtbarkeit: pub. Breite.
h: T - Sichtbarkeit: pub. Höhe.


Methoden:

pub const fn new(w: T, h: T) -> Self: Erzeugt eine neue Größe.
pub fn map<U, F>(&self, f: F) -> Size<U> where F: Fn(T) -> U, T: Copy: Mappt Breite und Höhe zu einem neuen Typ.
Für T: std::ops::Mul<Output = T> + Copy:

pub fn area(&self) -> T: Berechnet die Fläche.


Für T: PartialOrd + Default:

pub fn is_empty(&self) -> bool where T: Default + PartialEq: Prüft, ob Breite oder Höhe null sind (abhängig von T::default()).




Invarianten: Wenn T ein numerischer Typ ist, sollten w und h typischerweise nicht-negativ sein. Dies wird jedoch nicht aktiv erzwungen, außer durch Nutzungskonventionen oder spezifische Konstruktoren in höheren Schichten.
Rect<T>
Datei: nova_de/core/src/types/rect.rs
Definition:
Rustuse super::{Point, Size}; // Import Point und Size aus dem gleichen Modul

#
#
pub struct Rect<T> {
    pub origin: Point<T>,
    pub size: Size<T>,
}

pub type RectInt = Rect<i32>;


Attribute:

origin: Point<T> - Sichtbarkeit: pub. Ursprungspunkt (typischerweise linke obere Ecke).
size: Size<T> - Sichtbarkeit: pub. Ausmaße des Rechtecks.


Methoden (Beispiele für T: Copy + PartialOrd + std::ops::Add<Output = T> + std::ops::Sub<Output = T>):

pub const fn new(x: T, y: T, w: T, h: T) -> Self: Erzeugt ein neues Rechteck.
pub fn from_points(p1: Point<T>, p2: Point<T>) -> Self: Erzeugt ein Rechteck aus zwei gegenüberliegenden Punkten (normalisiert).
pub fn x(&self) -> T: Gibt self.origin.x zurück.
pub fn y(&self) -> T: Gibt self.origin.y zurück.
pub fn width(&self) -> T: Gibt self.size.w zurück.
pub fn height(&self) -> T: Gibt self.size.h zurück.
pub fn right(&self) -> T: Gibt self.origin.x + self.size.w zurück.
pub fn bottom(&self) -> T: Gibt self.origin.y + self.size.h zurück.
pub fn contains_point(&self, point: &Point<T>) -> bool: Prüft, ob ein Punkt innerhalb des Rechtecks liegt.
pub fn intersects(&self, other: &Rect<T>) -> bool: Prüft, ob sich dieses Rechteck mit einem anderen überschneidet.
pub fn intersection(&self, other: &Rect<T>) -> Option<Rect<T>>: Berechnet die Schnittmenge mit einem anderen Rechteck.
pub fn union(&self, other: &Rect<T>) -> Rect<T>: Berechnet die Vereinigungsmenge mit einem anderen Rechteck.
pub fn translated(&self, dx: T, dy: T) -> Self: Erzeugt ein verschobenes Rechteck.
pub fn inflated(&self, dw: T, dh: T) -> Self: Erzeugt ein Rechteck, dessen Größe um dw und dh geändert wurde (Zentrum bleibt gleich).


Invarianten: Analog zu Size<T>, sollten size.w und size.h typischerweise nicht-negativ sein.
Color
Datei: nova_de/core/src/types/color.rs
Definition:
Rustuse thiserror::Error;

#
#
pub struct Color {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}

#
pub enum ColorParseError {
    #
    InvalidFormat(String),
    #[error("Invalid hex digit in string '{input}' at component '{component}'.")]
    InvalidHexDigit { input: String, component: String },
    #[error("Hex string '{0}' has incorrect length.")]
    InvalidLength(String),
}

impl Color {
    pub const fn new(r: u8, g: u8, b: u8, a: u8) -> Self {
        Color { r, g, b, a }
    }

    pub fn from_hex(hex_string: &str) -> Result<Self, ColorParseError> {
        let s = hex_string.trim_start_matches('#');
        if!(s.len() == 6 |


| s.len() == 8) {return Err(ColorParseError::InvalidLength(hex_string.to_string()));}if!s.chars().all(|c| c.is_ascii_hexdigit()) {return Err(ColorParseError::InvalidFormat(hex_string.to_string()));}        let r = u8::from_str_radix(&s[0..2], 16).map_err(|_| ColorParseError::InvalidHexDigit{ input: hex_string.to_string(), component: "R".to_string()})?;
        let g = u8::from_str_radix(&s[2..4], 16).map_err(|_| ColorParseError::InvalidHexDigit{ input: hex_string.to_string(), component: "G".to_string()})?;
        let b = u8::from_str_radix(&s[4..6], 16).map_err(|_| ColorParseError::InvalidHexDigit{ input: hex_string.to_string(), component: "B".to_string()})?;
        let a = if s.len() == 8 {
            u8::from_str_radix(&s[6..8], 16).map_err(|_| ColorParseError::InvalidHexDigit{ input: hex_string.to_string(), component: "A".to_string()})?
        } else {
            255 // Default alpha to fully opaque
        };
        Ok(Color { r, g, b, a })
    }

    pub fn to_hex(&self, include_alpha: bool) -> String {
        if include_alpha {
            format!("#{:02X}{:02X}{:02X}{:02X}", self.r, self.g, self.b, self.a)
        } else {
            format!("#{:02X}{:02X}{:02X}", self.r, self.g, self.b)
        }
    }
}
```

Attribute: r, g, b, a: u8 - Sichtbarkeit: pub. Rot-, Grün-, Blau- und Alpha-Komponenten.
Methoden: Siehe Definition.
Invarianten: Keine.
Orientation
Datei: nova_de/core/src/types/orientation.rs
Definition:
Rust#
#
pub enum Orientation {
    Horizontal,
    Vertical,
}


Varianten: Horizontal, Vertical.
Re-exportierte Typen
Datei: nova_de/core/src/types/mod.rs
Rust//... imports für Point, Size, Rect, Color, Orientation...
pub use uuid::Uuid;
pub use chrono::{DateTime, Utc};

pub type NotificationId = Uuid;
// Weitere Typ-Aliase können hier definiert werden.

Die Verwendung von uuid::Uuid für NotificationId 5 und chrono::DateTime<Utc> für Zeitstempel 6 ist eine robuste Wahl, die Standardbibliotheken für diese Zwecke nutzt. Die Aktivierung der "serde" und "v4" Features für uuid ist wichtig für die Serialisierung und die Generierung von Typ-4-UUIDs.
Diese grundlegenden Typen bilden eine solide Basis für geometrische Berechnungen, Farbdarstellungen und eindeutige Identifikatoren im gesamten NovaDE-System. Ihre konsequente Verwendung über alle Schichten hinweg fördert die Interoperabilität und reduziert Konvertierungsaufwand.2. Schnittstelle: Domänenschicht (Domain Layer) zu Systemschicht und BenutzeroberflächenschichtDie Domänenschicht kapselt die Geschäftslogik und den Kernzustand der Desktop-Umgebung. Sie stellt ihre Funktionalität über klar definierte Service-APIs (oft als Rust-Traits), Datenstrukturen und Events bereit.2.1. Bereitgestellte Funktionalität
Service-APIs (Traits): Öffentliche Schnittstellen werden primär durch Rust-Traits definiert, die von Service-Strukturen innerhalb der Domänenmodule implementiert werden.

domain::theming::ThemingEngine: Methoden wie get_current_theme_state(), update_configuration().
domain::workspaces::WorkspaceManager: Methoden wie create_workspace(), set_active_workspace().
domain::user_centric_services::AIInteractionLogicService: Methoden wie initiate_interaction(), provide_consent().
domain::user_centric_services::NotificationService: Methoden wie post_notification(), get_active_notifications().
domain::global_settings_and_state_management::GlobalSettingsService: Methoden wie load_settings(), update_setting().


Datenstrukturen: Öffentliche Datenstrukturen, die Zustände oder Konfigurationen repräsentieren (z.B. AppliedThemeState, Workspace, Notification, GlobalDesktopSettings).
Events: Domänenspezifische Events, die Zustandsänderungen signalisieren.

Beispiele: ThemeChangedEvent, WorkspaceEvent (z.B. ActiveWorkspaceChanged), NotificationPostedEvent, SettingChangedEvent.


Fehlertypen: Modulspezifische Fehler-Enums (z.B. ThemingError, WorkspaceManagerError, AIInteractionError, GlobalSettingsError).
2.2. Nutzung durch die Systemschicht
Die Systemschicht konsumiert die Service-APIs der Domänenschicht, um Geschäftsregeln anzuwenden und Zustände abzufragen.

Der system::compositor nutzt domain::window_management_policy für Fensterplatzierungsrichtlinien.
Der system::mcp Client interagiert mit AIInteractionLogicService für Einwilligungsprüfungen und Kontextinformationen.
system::dbus (für Benachrichtigungen) interagiert mit NotificationService.


Die Systemschicht kann auf Domänen-Events reagieren, um ihr Verhalten anzupassen (z.B. Umschalten der sichtbaren Surfaces im Compositor bei ActiveWorkspaceChanged).
Fehler aus der Domänenschicht werden in der Systemschicht behandelt oder weitergeleitet.
2.3. Nutzung durch die Benutzeroberflächenschicht
Die UI-Schicht nutzt die Service-APIs der Domänenschicht, um Daten für die Darstellung abzurufen und Benutzeraktionen in Domänenlogik umzusetzen.

ui::control_center verwendet GlobalSettingsService zum Anzeigen und Ändern von Einstellungen.
ui::shell interagiert mit WorkspaceManager für die Workspace-Darstellung und -Navigation.
ui::theming_gtk reagiert auf ThemeChangedEvent und wendet Stile an.


Die UI-Schicht abonniert Domänen-Events, um ihre Ansichten dynamisch zu aktualisieren.
Fehler aus der Domänenschicht werden von der UI-Schicht behandelt und dem Benutzer ggf. in verständlicher Form präsentiert.
2.4. Ultra-Feinspezifikation: Modul domain::user_centric_services::notification_service_implDieses Modul enthält die konkrete Implementierung des NotificationService-Traits.2.4.1. Modulübersicht
Zweck: Verwaltung des Lebenszyklus von Benachrichtigungen, einschließlich Erstellung, Speicherung, Abruf aktiver Benachrichtigungen, Schließen und Auslösen von Aktionen. Veröffentlicht Domänenereignisse im Zusammenhang mit Benachrichtigungen.
Dateistruktur:

nova_de/domain/src/user_centric_services/notification_api.rs: Definiert das Trait NotificationService und zugehörige öffentliche Typen wie Notification, NotificationAction, NotificationUrgency, NotificationId, CloseReason und NotificationError.
nova_de/domain/src/user_centric_services/notification_service_impl.rs: Enthält die Struktur NotificationServiceImpl und deren Implementierung des NotificationService-Traits.
nova_de/domain/src/events.rs: Definiert das DomainEvent-Enum, das NotificationPosted und NotificationClosed enthält.


Abhängigkeiten:

Extern: uuid (für NotificationId), chrono (für Zeitstempel).
Intern: crate::core::types::{NotificationId,...} (falls dort definiert, sonst lokal), crate::core::errors::DomainError (oder spezifischer NotificationError), crate::event_bus::{EventPublisher, DomainEvent} (abstrahiert den Event-Bus).


2.4.2. Öffentliche Datentypen (definiert in notification_api.rs)

pub type NotificationId = uuid::Uuid; 5

Verwendet Uuid::new_v4() zur Generierung.



##pub struct NotificationAction {pub key: String,pub label: String,}

key: Eindeutiger Bezeichner für die Aktion innerhalb der Benachrichtigung.
label: Für den Benutzer sichtbarer Text der Aktion.



##pub enum NotificationUrgency { Low, Normal, Critical }


##pub struct Notification {pub id: NotificationId,pub app_name: String,pub app_icon: Option<String>,pub summary: String,pub body: Option<String>,pub actions: Vec<NotificationAction>,pub hints: std::collections::HashMap<String, serde_json::Value>, // Flexibel für diverse Hintspub expire_timeout: i32, // Millisekunden. -1: Server-Default, 0: Niepub urgency: NotificationUrgency,pub created_at: chrono::DateTime<chrono::Utc>,}

Attribute wie in der Freedesktop Notification Specification definiert.9
hints: Verwendet serde_json::Value für Flexibilität bei D-Bus-Varianten.



##pub enum CloseReason { Expired, DismissedByUser, ClosedByApp, Replaced }


#pub enum NotificationError {#NotFound(NotificationId),#[error("Invalid parameter for notification: {field}: {message}")]InvalidParameter { field: String, message: String },#ActionNotFound { notification_id: NotificationId, action_key: String },#[error("Internal storage error for notifications")]StorageError(#[source] Box<dyn std::error::Error + Send + Sync + 'static>),}

2.4.3. Interne Datenstrukturen (notification_service_impl.rs)

struct NotificationInternal {public_data: Notification,// Ggf. Felder für Timer-Handles für expire_timeout// Ggf. Persistenz-Status}


pub struct NotificationServiceImpl {active_notifications: std::sync::Mutex<std::collections::HashMap<NotificationId, NotificationInternal>>,event_publisher: std::sync::Arc<dyn crate::event_bus::EventPublisher<crate::events::DomainEvent> + Send + Sync>,// Ggf. ein Tokio Runtime Handle für Timer, falls expire_timeout serverseitig gehandhabt wird}

2.4.4. Implementierung des NotificationService-Traits (notification_service_impl.rs)Rustuse async_trait::async_trait;
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use uuid::Uuid;
use chrono::Utc;
use crate::event_bus::{EventPublisher, DomainEvent}; // Annahme: DomainEvent ist hier definiert
use super::notification_api::*; // Importiert Traits und öffentliche Typen

impl NotificationServiceImpl {
    pub fn new(event_publisher: Arc<dyn EventPublisher<DomainEvent> + Send + Sync>) -> Self {
        NotificationServiceImpl {
            active_notifications: Mutex::new(HashMap::new()),
            event_publisher,
        }
    }

    // Interne Hilfsfunktion zum Schließen und Benachrichtigen
    fn internal_close_notification(
        &self,
        id: NotificationId,
        reason: CloseReason,
        notifications_guard: &mut std::sync::MutexGuard<HashMap<NotificationId, NotificationInternal>>,
    ) -> Result<Notification, NotificationError> {
        if let Some(removed_notification_internal) = notifications_guard.remove(&id) {
            let event = DomainEvent::NotificationClosed {
                id,
                reason,
                app_name: removed_notification_internal.public_data.app_name.clone(), // Für Kontext im Event
            };
            if self.event_publisher.publish(&event).is_err() {
                // Fehler beim Publishen loggen, aber nicht unbedingt den Vorgang abbrechen
                tracing::error!("Failed to publish NotificationClosed event for ID: {}", id);
            }
            Ok(removed_notification_internal.public_data)
        } else {
            Err(NotificationError::NotFound(id))
        }
    }
}

#[async_trait]
impl NotificationService for NotificationServiceImpl {
    async fn post_notification(
        &self, // &self statt &mut self, da Mutex interne Mutabilität ermöglicht
        app_name: String,
        replaces_id: Option<NotificationId>, // Verwende direkt NotificationId
        app_icon: Option<String>,
        summary: String,
        body: Option<String>,
        actions: Vec<NotificationAction>,
        hints: HashMap<String, serde_json::Value>,
        expire_timeout: i32,
        urgency: NotificationUrgency,
    ) -> Result<NotificationId, NotificationError> {
        let mut notifications_guard = self.active_notifications.lock().map_err(|_| {
            NotificationError::StorageError(Box::new(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Mutex poisoned",
            )))
        })?;

        let new_id = if let Some(id_to_replace) = replaces_id {
            // Versuche, die alte Benachrichtigung zu entfernen und zu benachrichtigen
            let _ = self.internal_close_notification(id_to_replace, CloseReason::Replaced, &mut notifications_guard);
            id_to_replace // Verwende die ID der ersetzten Benachrichtigung
        } else {
            Uuid::new_v4() // Generiere eine neue ID [5]
        };

        let notification_data = Notification {
            id: new_id,
            app_name,
            app_icon,
            summary,
            body,
            actions,
            hints,
            expire_timeout,
            urgency,
            created_at: Utc::now(),
        };

        let internal_notification = NotificationInternal {
            public_data: notification_data.clone(),
        };

        notifications_guard.insert(new_id, internal_notification);
        
        // TODO: Wenn expire_timeout > 0, hier Timer-Logik implementieren,
        // die self.close_notification(new_id, CloseReason::Expired) aufruft.
        // Dies erfordert typischerweise einen Tokio-Task oder ähnliches.

        let event = DomainEvent::NotificationPosted(notification_data);
        if self.event_publisher.publish(&event).is_err() {
            tracing::error!("Failed to publish NotificationPosted event for ID: {}", new_id);
            // Hier könnte man entscheiden, ob der Fehler an den Aufrufer weitergegeben wird.
            // Fürs Erste wird der Fehler nur geloggt.
        }

        Ok(new_id)
    }

    async fn get_active_notifications(&self) -> Result<Vec<Notification>, NotificationError> {
        let notifications_guard = self.active_notifications.lock().map_err(|_| {
            NotificationError::StorageError(Box::new(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Mutex poisoned",
            )))
        })?;
        Ok(notifications_guard.values().map(|internal| internal.public_data.clone()).collect())
    }

    async fn close_notification(&self, id: NotificationId, reason: CloseReason) -> Result<(), NotificationError> {
        let mut notifications_guard = self.active_notifications.lock().map_err(|_| {
            NotificationError::StorageError(Box::new(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Mutex poisoned",
            )))
        })?;
        
        self.internal_close_notification(id, reason, &mut notifications_guard)?;
        Ok(())
    }

    async fn invoke_action(&self, id: NotificationId, action_key: String) -> Result<(), NotificationError> {
        let notifications_guard = self.active_notifications.lock().map_err(|_| {
            NotificationError::StorageError(Box::new(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Mutex poisoned",
            )))
        })?;

        match notifications_guard.get(&id) {
            Some(notification_internal) => {
                if notification_internal.public_data.actions.iter().any(|act| act.key == action_key) {
                    // Aktion existiert
                    let event = DomainEvent::NotificationActionInvoked {
                        id,
                        action_key: action_key.clone(),
                        app_name: notification_internal.public_data.app_name.clone(),
                    };
                    if self.event_publisher.publish(&event).is_err() {
                         tracing::error!("Failed to publish NotificationActionInvoked event for ID: {}", id);
                    }
                    // Die D-Bus Spezifikation sagt nicht explizit, dass eine Benachrichtigung nach ActionInvoked geschlossen werden muss.
                    // Das überlassen wir der UI-Schicht oder spezifischen Hints.
                    Ok(())
                } else {
                    Err(NotificationError::ActionNotFound { notification_id: id, action_key })
                }
            }
            None => Err(NotificationError::NotFound(id)),
        }
    }
}
2.4.5. Domänenereignisse (events.rs)
#
pub enum DomainEvent {
NotificationPosted(Notification),
NotificationClosed { id: NotificationId, reason: CloseReason, app_name: String },
NotificationActionInvoked { id: NotificationId, action_key: String, app_name: String },
//... andere Domänenereignisse
}
Publisher: NotificationServiceImpl.
Typische Subscriber:

system::dbus::notification_dbus_service: Um D-Bus Signale zu emittieren.
ui::notifications_frontend: Um die Benutzeroberfläche zu aktualisieren.


Die Implementierung des NotificationService stellt sicher, dass die Kernlogik der Benachrichtigungsverwaltung von externen Schnittstellendetails (wie D-Bus) entkoppelt ist. Die Verwendung eines internen Event-Bus ermöglicht es anderen Systemteilen, reaktiv auf Benachrichtigungsänderungen zu reagieren.3. Schnittstelle: Systemschicht (System Layer) zu Benutzeroberflächenschicht (UI Layer)Die Systemschicht stellt der UI-Schicht systemnahe Dienste und Ereignisse zur Verfügung und setzt deren Befehle technisch um.3.1. Bereitgestellte Funktionalität
Systemereignisse und -zustände:

Fensterinformationen: Geometrie, Titel, AppID, Fokusstatus von Fenstern (aus system::compositor und system::xdg_shell).
Eingabeereignisse: Verarbeitete Tastatur-, Maus-, Touch- und Gestenereignisse (aus system::input).
Output-Informationen: Verfügbare Monitore, Auflösungen, Skalierungsfaktoren (aus system::outputs).
Status von Systemdiensten: Netzwerkverbindungen (system::dbus::networkmanager_client), Energiestatus (system::dbus::upower_client), Audiostatus (system::audio).
Sitzungsereignisse: Sperren, Abmelden (von system::dbus::logind_client).


Ausführung von UI-Befehlen:

Fenstermanipulationen (Verschieben, Größe ändern, Fokus setzen), initiiert durch die UI, werden vom system::compositor und system::window_mechanics umgesetzt.
Workspace-Wechsel.
Anpassung von Systemeinstellungen (z.B. Bildschirmhelligkeit, Lautstärke), die von system::outputs bzw. system::audio ausgeführt werden.


Fehlertypen: Modulspezifische Fehler-Enums (z.B. CompositorCoreError, InputError).
3.2. Nutzung durch die Benutzeroberflächenschicht
Darstellung von Systeminformationen: Die UI visualisiert die von der Systemschicht bereitgestellten Zustände.

Fensterlisten, Titelleisten, Fokus-Hervorhebungen basieren auf Daten von system::compositor.
Netzwerk-, Batterie-, Audio-Indikatoren in ui::shell zeigen Daten von system::dbus und system::audio.


Reaktion auf Eingabeereignisse: UI-Elemente reagieren auf verarbeitete Eingabeereignisse, um Aktionen auszulösen.
Initiierung von Systemaktionen: Benutzerinteraktionen in der UI führen zu Befehlsaufrufen an die Systemschicht.

Klick auf "Lauter"-Button in ui::shell ruft eine Funktion in system::audio auf.
Auswahl eines anderen Monitorsetups in ui::control_center sendet Befehl an system::outputs.


Dialoge über XDG Portals: ui::shell oder ui::components interagieren mit system::portals für Datei-Auswahl- oder Screenshot-Dialoge.
Die UI-Schicht behandelt Fehler von der Systemschicht und informiert ggf. den Benutzer.
Die UI-Schicht reagiert auf Systemereignisse (z.B. ActiveWorkspaceChanged indirekt über Änderungen der sichtbaren Fenster, DeviceAdded für Eingabegeräte), um ihre Darstellung anzupassen.
3.3. Ultra-Feinspezifikation: Modul system::dbus::notification_dbus_serviceDieses Modul implementiert den org.freedesktop.Notifications D-Bus Standard und dient als Brücke zur Domänenschicht (NotificationService).3.3.1. Modulübersicht
Zweck: Bereitstellung der org.freedesktop.Notifications D-Bus-Schnittstelle. Nimmt D-Bus-Methodenaufrufe entgegen, leitet sie an den NotificationService der Domänenschicht weiter und emittiert D-Bus-Signale basierend auf Domänenereignissen.
Dateistruktur: nova_de/system/src/dbus/notification_dbus_service.rs
Abhängigkeiten:

Extern: zbus (für D-Bus-Interaktion) 10, async-trait.
Intern: Arc<dyn domain::user_centric_services::NotificationService>, domain::events::DomainEvent, crate::event_bus::{EventSubscriber, DomainEvent}.


3.3.2. Datenstrukturen

struct NotificationDBusService {notification_service: Arc<dyn NotificationService>,connection: Arc<zbus::Connection>,// Für die Konvertierung von NotificationId (UUID) zu u32 (D-Bus ID) und umgekehrt:id_map: Arc<Mutex<IdMapper>>,}


struct IdMapper {next_dbus_id: u32,uuid_to_dbus: HashMap<NotificationId, u32>,dbus_to_uuid: HashMap<u32, NotificationId>,}

IdMapper ist notwendig, da die D-Bus-Spezifikation UINT32 für Benachrichtigungs-IDs verwendet, während intern uuid::Uuid für NotificationId genutzt wird, um globale Eindeutigkeit zu gewährleisten.


3.3.3. D-Bus SchnittstellenimplementierungDie Implementierung erfolgt mittels des #[dbus_interface] Makros von zbus.12Rust// nova_de/system/src/dbus/notification_dbus_service.rs
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use zbus::{dbus_interface, fdo, zvariant::Value, SignalContext};
use crate::domain::user_centric_services::notification_api::{
    NotificationService, NotificationId, NotificationAction, NotificationUrgency, CloseReason, NotificationError
};
use crate::event_bus::{DomainEvent, EventSubscriber}; // Angenommen, EventSubscriber ist definiert

// Hilfsstruktur für die ID-Konvertierung
struct IdMapper {
    next_dbus_id: u32,
    uuid_to_dbus: HashMap<NotificationId, u32>,
    dbus_to_uuid: HashMap<u32, NotificationId>,
}

impl IdMapper {
    fn new() -> Self {
        IdMapper {
            next_dbus_id: 1, // D-Bus IDs sind > 0
            uuid_to_dbus: HashMap::new(),
            dbus_to_uuid: HashMap::new(),
        }
    }

    fn get_or_create_dbus_id(&mut self, uuid: NotificationId) -> u32 {
        if let Some(dbus_id) = self.uuid_to_dbus.get(&uuid) {
            *dbus_id
        } else {
            let dbus_id = self.next_dbus_id;
            self.next_dbus_id += 1;
            self.uuid_to_dbus.insert(uuid, dbus_id);
            self.dbus_to_uuid.insert(dbus_id, uuid);
            dbus_id
        }
    }

    fn get_uuid(&self, dbus_id: u32) -> Option<NotificationId> {
        self.dbus_to_uuid.get(&dbus_id).copied()
    }

    fn remove_mapping_by_uuid(&mut self, uuid: &NotificationId) {
        if let Some(dbus_id) = self.uuid_to_dbus.remove(uuid) {
            self.dbus_to_uuid.remove(&dbus_id);
        }
    }
    
    fn remove_mapping_by_dbus_id(&mut self, dbus_id: u32) {
        if let Some(uuid) = self.dbus_to_uuid.remove(&dbus_id) {
            self.uuid_to_dbus.remove(&uuid);
        }
    }
}

pub struct NotificationDBusService {
    notification_service: Arc<dyn NotificationService + Send + Sync>,
    connection: Arc<zbus::Connection>,
    id_map: Arc<Mutex<IdMapper>>,
}

impl NotificationDBusService {
    pub async fn new(
        notification_service: Arc<dyn NotificationService + Send + Sync>,
        connection: Arc<zbus::Connection>,
        event_subscriber: Arc<dyn EventSubscriber<DomainEvent> + Send + Sync>, // Für das Abonnieren von DomainEvents
    ) -> Result<Self, zbus::Error> {
        let service = Self {
            notification_service,
            connection: connection.clone(),
            id_map: Arc::new(Mutex::new(IdMapper::new())),
        };

        // Task zum Abonnieren von DomainEvents und Emittieren von D-Bus Signalen
        let id_map_clone = service.id_map.clone();
        let conn_clone = connection.clone();
        tokio::spawn(async move {
            let mut stream = event_subscriber.subscribe();
            while let Some(event_result) = stream.recv().await { // Angenommen, subscribe() gibt einen Stream/Channel
                if let Ok(event) = event_result {
                    match event {
                        DomainEvent::NotificationClosed { id, reason, app_name: _ } => {
                            let dbus_id = {
                                let mut map = id_map_clone.lock().unwrap();
                                let id_val = map.get_uuid_to_dbus_id(id); // Hilfsfunktion in IdMapper
                                if id_val.is_some() { map.remove_mapping_by_uuid(&id); }
                                id_val
                            };
                            if let Some(valid_dbus_id) = dbus_id {
                                let dbus_reason = match reason {
                                    CloseReason::Expired => 1,
                                    CloseReason::DismissedByUser => 2,
                                    CloseReason::ClosedByApp => 3,
                                    CloseReason::Replaced => 3, // Oder eine spezifische D-Bus Reason, falls vorhanden
                                };
                                if let Err(e) = NotificationDBusService::emit_notification_closed(&conn_clone, valid_dbus_id, dbus_reason).await {
                                    tracing::error!("Failed to emit NotificationClosed D-Bus signal: {}", e);
                                }
                            }
                        }
                        DomainEvent::NotificationActionInvoked { id, action_key, app_name: _ } => {
                             let dbus_id = {
                                let map = id_map_clone.lock().unwrap();
                                map.get_uuid_to_dbus_id(id) // Hilfsfunktion in IdMapper
                            };
                            if let Some(valid_dbus_id) = dbus_id {
                                if let Err(e) = NotificationDBusService::emit_action_invoked(&conn_clone, valid_dbus_id, &action_key).await {
                                    tracing::error!("Failed to emit ActionInvoked D-Bus signal: {}", e);
                                }
                            }
                        }
                        _ => {} // Andere DomainEvents ignorieren
                    }
                }
            }
        });
        
        Ok(service)
    }

    // Hilfsfunktionen zum Emittieren von Signalen
    async fn emit_notification_closed(connection: &Arc<zbus::Connection>, id: u32, reason: u32) -> zbus::Result<()> {
        let ctxt = SignalContext::new(connection, "/org/freedesktop/Notifications")?;
        NotificationDBusService::notification_closed(&ctxt, id, reason).await
    }

    async fn emit_action_invoked(connection: &Arc<zbus::Connection>, id: u32, action_key: &str) -> zbus::Result<()> {
        let ctxt = SignalContext::new(connection, "/org/freedesktop/Notifications")?;
        NotificationDBusService::action_invoked(&ctxt, id, action_key).await
    }
}


#[dbus_interface(name = "org.freedesktop.Notifications")]
impl NotificationDBusService {
    async fn Notify(
        &self,
        app_name: String,
        replaces_id_dbus: u32,
        app_icon: String,
        summary: String,
        body: String,
        actions_dbus: Vec<String>,
        hints: HashMap<String, Value<'_>>, // zbus::zvariant::Value
        expire_timeout: i32,
    ) -> fdo::Result<u32> {
        tracing::debug!(
            "D-Bus Notify called: app_name={}, replaces_id={}, summary={}",
            app_name, replaces_id_dbus, summary
        );

        let replaces_id_uuid: Option<NotificationId> = if replaces_id_dbus == 0 {
            None
        } else {
            self.id_map.lock().unwrap().get_uuid(replaces_id_dbus)
        };

        let mut parsed_actions = Vec::new();
        for i in (0..actions_dbus.len()).step_by(2) {
            if i + 1 < actions_dbus.len() {
                parsed_actions.push(NotificationAction {
                    key: actions_dbus[i].clone(),
                    label: actions_dbus[i + 1].clone(),
                });
            }
        }
        
        // Konvertiere hints von zbus::zvariant::Value zu serde_json::Value
        let mut converted_hints = HashMap::new();
        for (k, v_ref) in hints.iter() {
            // Direkte Konvertierung ist möglicherweise nicht trivial.
            // Eine einfache Variante ist, wenn die Value-Typen kompatibel sind oder eine Serialisierung/Deserialisierung erfolgt.
            // Hier wird angenommen, dass die Struktur von Value serialisierbar zu JSON ist.
            // In einer echten Implementierung wäre hier robustere Konvertierungslogik nötig.
            match serde_json::to_value(v_ref) {
                Ok(json_val) => { converted_hints.insert(k.clone(), json_val); },
                Err(e) => {
                    tracing::warn!("Could not convert hint '{}' to JSON: {}", k, e);
                    // Optional: Fehler zurückgeben oder Hint ignorieren
                    // return Err(fdo::Error::InvalidArgs("Invalid hint format".into()));
                }
            }
        }


        // TODO: Urgency aus hints extrahieren, falls vorhanden (z.B. "urgency" byte)
        let urgency = NotificationUrgency::Normal; // Default, oder aus Hints bestimmen

        match self.notification_service.post_notification(
            app_name,
            replaces_id_uuid,
            if app_icon.is_empty() { None } else { Some(app_icon) },
            summary,
            if body.is_empty() { None } else { Some(body) },
            parsed_actions,
            converted_hints,
            expire_timeout,
            urgency,
        ).await {
            Ok(new_uuid) => {
                let dbus_id = self.id_map.lock().unwrap().get_or_create_dbus_id(new_uuid);
                Ok(dbus_id)
            }
            Err(e) => {
                tracing::error!("Error posting notification via service: {:?}", e);
                Err(fdo::Error::Failed(format!("Internal error: {}", e)))
            }
        }
    }

    async fn CloseNotification(&self, id: u32) -> fdo::Result<()> {
        tracing::debug!("D-Bus CloseNotification called for ID: {}", id);
        let uuid_to_close = match self.id_map.lock().unwrap().get_uuid(id) {
            Some(uuid) => uuid,
            None => {
                // Gemäß Spezifikation: "If the notification no longer exists, an empty D-BUS Error message is sent back."
                // Ein leerer fdo::Error::Failed("") ist nicht ideal, aber zbus erfordert einen Error-Namen.
                // org.freedesktop.DBus.Error.UnknownMethod ist nicht passend.
                // Ein benutzerdefinierter Fehler oder ein stillschweigendes Ok(()) könnte hier besser sein,
                // aber die Spezifikation verlangt einen Fehler.
                // Wir verwenden hier Failed, da kein spezifischerer Fehlercode für "existiert nicht mehr" vorgesehen ist.
                return Err(fdo::Error::Failed("Notification not found.".into()));
            }
        };

        match self.notification_service.close_notification(uuid_to_close, CloseReason::ClosedByApp).await {
            Ok(()) => {
                self.id_map.lock().unwrap().remove_mapping_by_dbus_id(id); // Mapping entfernen
                Ok(())
            }
            Err(NotificationError::NotFound(_)) => {
                 self.id_map.lock().unwrap().remove_mapping_by_dbus_id(id); // Sicherstellen, dass das Mapping entfernt ist
                 Err(fdo::Error::Failed("Notification not found by service.".into())) // Gemäß Spezifikation
            }
            Err(e) => {
                tracing::error!("Error closing notification via service: {:?}", e);
                Err(fdo::Error::Failed(format!("Internal error: {}", e)))
            }
        }
    }

    async fn GetCapabilities(&self) -> fdo::Result<Vec<String>> {
        tracing::debug!("D-Bus GetCapabilities called");
        Ok(vec!)
    }

    async fn GetServerInformation(&self) -> fdo::Result<(String, String, String, String)> {
        tracing::debug!("D-Bus GetServerInformation called");
        Ok((
            "NovaDE".to_string(),
            "NovaDE Project".to_string(),
            env!("CARGO_PKG_VERSION").to_string(), // Version aus Cargo.toml
            "1.2".to_string(), // Implementierte Spezifikationsversion
        ))
    }

    // Definition der Signale
    #[dbus_interface(signal)]
    async fn NotificationClosed(ctxt: &SignalContext<'_>, id: u32, reason: u32) -> zbus::Result<()>;

    #[dbus_interface(signal)]
    async fn ActionInvoked(ctxt: &SignalContext<'_>, id: u32, action_key: &str) -> zbus::Result<()>;
}
Hinweise zur Implementierung:
ID Mapping: Eine IdMapper-Struktur (oder ein ähnlicher Mechanismus) ist entscheidend, um zwischen den internen uuid::Uuid-basierten NotificationIds und den u32-basierten IDs der D-Bus-Schnittstelle zu übersetzen. replaces_id = 0 bedeutet eine neue Benachrichtigung. Zurückgegebene IDs müssen eindeutig sein.
Action Parsing: Die actions-Parameterliste im Notify-Aufruf ist ein flaches Array von Strings (as), wobei gerade Indizes Aktionsschlüssel und ungerade Indizes die zugehörigen Labels sind.9 Dies muss in die interne Vec<NotificationAction>-Struktur geparst werden.
Hints: hints ist ein a{sv} (Dictionary String to Variant). zbus::zvariant::Value muss in den internen Typ für Hint-Werte konvertiert werden (hier serde_json::Value als Beispiel). Die urgency (Dringlichkeit) und expire_timeout können auch über Hints gesteuert werden.
Signal Emission: Die D-Bus-Signale NotificationClosed und ActionInvoked müssen emittiert werden, wenn die entsprechenden DomainEvents (NotificationClosed, NotificationActionInvoked) vom NotificationService empfangen werden. Dies erfordert, dass NotificationDBusService den internen Event-Bus abonniert und in einem separaten Task auf diese Events lauscht.
Fehlerbehandlung: Interne NotificationError-Typen müssen in zbus::fdo::Error umgewandelt werden. Die D-Bus-Spezifikation gibt vor, dass bei CloseNotification für eine nicht existierende ID ein leerer D-Bus-Fehler zurückgegeben wird.
Asynchronität: Alle D-Bus-Methoden sind async. Die Interaktion mit dem NotificationService (der ebenfalls async sein kann) erfolgt über await.
Diese Implementierung stellt sicher, dass NovaDE sich standardkonform über D-Bus für Benachrichtigungen verhält und gleichzeitig die interne Logik in der Domänenschicht sauber gekapselt bleibt.3.3.4. Tabelle: org.freedesktop.Notifications D-Bus API zu NotificationService MappingD-Bus MemberTyp (Methode/Signal)NovaDE NotificationService Methode/DomänenEventSchlüsselparameter-/Payload-Mapping (D-Bus -> Intern)AnmerkungenNotifyMethodeasync post_notification(...)app_name -> app_name, replaces_id_dbus (u32) -> replaces_id (Option<NotificationId>), app_icon -> app_icon, summary -> summary, body -> body, actions_dbus (Vec<String>) -> actions (Vec<NotificationAction>), hints (HashMap<String, zbus::zvariant::Value>) -> hints (HashMap<String, serde_json::Value>), expire_timeout -> expire_timeout, urgency (aus Hints oder Default) -> urgencyID-Mapping für replaces_id und Rückgabewert erforderlich. Parsing der Aktionsliste. Hint-Konvertierung.CloseNotificationMethodeasync close_notification(...)id (u32) -> id (NotificationId)ID-Mapping. reason wird intern als CloseReason::ClosedByApp gesetzt.GetCapabilitiesMethodeN/A (Direkt in D-Bus Modul implementiert)N/AGibt statische Liste der Server-Fähigkeiten zurück (z.B. "body", "actions").GetServerInformationMethodeN/A (Direkt in D-Bus Modul implementiert)N/AGibt statische Serverinformationen zurück (Name, Vendor, Version, Spec-Version).NotificationClosedSignalDomainEvent::NotificationClosedid (NotificationId) -> id (u32), reason (CloseReason) -> reason (u32)ID-Mapping. Enum-Mapping für reason. Emittiert, wenn internes Event empfangen wird.ActionInvokedSignalDomainEvent::NotificationActionInvoked (löst async invoke_action(...) aus, welches dieses Event publiziert)id (NotificationId) -> id (u32), action_key (String) -> action_key (String)ID-Mapping. Emittiert, wenn internes Event empfangen wird.Diese Tabelle verdeutlicht die Kopplungspunkte und notwendigen Transformationen zwischen der standardisierten D-Bus-Schnittstelle und der internen Implementierung des Benachrichtigungsdienstes in NovaDE.4. Schnittstelle: Benutzeroberflächenschicht (UI Layer) zu Domänenschicht und SystemschichtDie UI-Schicht initiiert Aktionen in den unteren Schichten basierend auf Benutzerinteraktionen und stellt Informationen aus diesen Schichten dar.4.1. Gesendete Befehle/Daten an die Domänenschicht
Theming: ThemingEngine::update_configuration(new_config: ThemingConfiguration) durch ui::control_center oder ui::theming_gtk.
Workspaces: WorkspaceManager::create_workspace(name: Option<String>), set_active_workspace(id: WorkspaceId), pin_application_to_space(space_id: WorkspaceId, app_id: ApplicationIdentifier) durch ui::shell (Workspace-Switcher, SmartTabBar) oder ui::window_manager_frontend (Übersichtsmodus).
AI: AIInteractionLogicService::initiate_interaction(context_data: AIInteractionContextData), provide_consent(consent: AIConsent) durch ui::command_palette oder spezifische KI-Widgets.
Notifications: NotificationService::dismiss_notification(id: NotificationId), invoke_action(id: NotificationId, action_key: String) durch ui::notifications_frontend oder ui::shell (NotificationCenter).
Settings: GlobalSettingsService::update_setting(path: SettingPath, value: SettingValue) durch ui::control_center oder Quick-Settings.
4.2. Gesendete Befehle/Daten an die Systemschicht
Fenstermanagement: An system::window_mechanics oder direkt an system::compositor (über eine Fassade):

request_focus(window_id: DomainWindowIdentifier)
request_close_window(window_id: DomainWindowIdentifier)
request_move_window(window_id: DomainWindowIdentifier, new_pos: Point<i32, Logical>) (oder Start eines interaktiven Moves)
request_resize_window(window_id: DomainWindowIdentifier, new_size: Size<i32, Logical>) (oder Start eines interaktiven Resizes)
request_set_window_state(window_id: DomainWindowIdentifier, state: WindowState (Maximized, Minimized, Fullscreen))


Output-Konfiguration: An system::outputs (via wlr-output-management oder eine interne API):

apply_output_configuration(config: Vec<OutputConfigChange>) durch ui::control_center.


Audio-Steuerung: An system::audio::PipeWireClientService:

set_sink_volume(device_id, volume_percent), set_sink_mute(device_id, mute) durch ui::shell (Quick-Settings) oder ui::control_center.


Systemaktionen: An system::dbus Clients:

logind_client.lock_current_session() durch ui::shell (Lock-Button).
network_manager_client.activate_connection(connection_path, device_path) durch ui::shell (Quick-Settings) oder ui::control_center.


MCP-Anfragen: An system::mcp::SystemMcpService:

call_tool(server_id, tool_name, params, interaction_id) durch ui::command_palette oder KI-Widgets.


4.3. Ultra-Feinspezifikation: Modul ui::portals::file_chooser_portal_clientDieses Modul in der UI-Schicht ist verantwortlich für die Interaktion mit dem XDG Desktop Portal für Dateiauswahldialoge. Es agiert als Client für die D-Bus-Schnittstelle org.freedesktop.portal.FileChooser.4.3.1. Modulübersicht
Zweck: Kapselt die Logik zur Kommunikation mit dem XDG FileChooser-Portal, um native Dateiauswahldialoge zu öffnen und die Ergebnisse zu verarbeiten.
Dateistruktur: nova_de/ui/src/portals/file_chooser_portal_client.rs
Abhängigkeiten:

Extern: zbus (für D-Bus-Client-Interaktion) 10, tokio (für asynchrone Operationen).
Intern: core::errors::UIError (oder spezifischer PortalError), core::types.


4.3.2. Interne Datenstrukturen und Typen

struct FileChooserPortalClient { connection: Arc<zbus::Connection> }

Hält die D-Bus-Verbindung.



pub struct OpenFileOptions {pub parent_window_id: Option<String>, // XDG Window Identifierpub title: String,pub accept_label: Option<String>,pub modal: bool,pub multiple: bool,pub directory: bool,pub filters: Vec<FileFilter>,pub current_filter: Option<FileFilter>,pub current_folder: Option<PathBuf>,}

Spiegelt die Optionen des OpenFile-D-Bus-Aufrufs.15



pub struct FileFilter {pub name: String,pub patterns: Vec<FilterPattern>, // (u32 type, String pattern)}

FilterPattern: pub enum FilterPattern { Glob(String), MimeType(String) }



pub struct SaveFileOptions {... } (analog zu OpenFileOptions)


pub enum FileChooserResponse {SelectedFiles(Vec<url::Url>),SelectedFolder(url::Url),Cancelled,Error(PortalError),}


#pub enum PortalError {#DBusConnection(#[from] zbus::Error),#DBusCall(#[from] zbus::fdo::Error),#[error("Portal request failed with code {code}: {message}")]RequestFailed { code: u32, message: String },#InvalidUri(String),#[error("Portal response malformed: {0}")]ResponseMalformed(String),}

4.3.3. D-Bus Proxy Definition (intern)Mittels zbus::proxy wird ein Proxy für org.freedesktop.portal.FileChooser erstellt.10Rust// Innerhalb von file_chooser_portal_client.rs oder einem Hilfsmodul
use zbus::{proxy, zvariant::{Value, ObjectPath, OwnedValue, Dict, Array}};
use std::collections::HashMap;

#
trait FileChooser {
    async fn OpenFile(
        &self,
        parent_window: &str, // Window identifier, "" if none
        title: &str,
        options: HashMap<&str, Value<'_>>,
    ) -> zbus::fdo::Result<ObjectPath<'static>>; // Request handle

    async fn SaveFile(
        &self,
        parent_window: &str,
        title: &str,
        options: HashMap<&str, Value<'_>>,
    ) -> zbus::fdo::Result<ObjectPath<'static>>;

    // SaveFiles nicht im Detail hier, aber analog
}

// Proxy für org.freedesktop.portal.Request, um die Antwort zu empfangen
#
trait PortalRequest {
    #[zbus(signal)]
    async fn Response(&self, response_code: u32, results: Dict<'_, String, OwnedValue>) -> zbus::Result<()>;
    // Methode zum Schließen des Requests, falls benötigt
    // async fn Close(&self) -> zbus::fdo::Result<()>;
}
4.3.4. Implementierung von FileChooserPortalClientRust// nova_de/ui/src/portals/file_chooser_portal_client.rs
use zbus::{Connection, zvariant::{Value, Dict, Array, ObjectPath, Str, Type}, fdo::Error as ZbusFdoError};
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::Arc;
use url::Url;
use futures_util::stream::StreamExt; // Für das Lauschen auf Signale

//... (Proxy-Definitionen von oben)...
//... (OpenFileOptions, FileFilter, FileChooserResponse, PortalError Definitionen)...

impl FileChooserPortalClient {
    pub fn new(connection: Arc<Connection>) -> Self {
        Self { connection }
    }

    fn build_open_file_options_dict<'a>(
        &self,
        options: &'a OpenFileOptions,
        handle_token: &'a str
    ) -> HashMap<&'a str, Value<'a>> {
        let mut dict = HashMap::<&str, Value<'_>>::new();
        dict.insert("handle_token", Value::from(handle_token));
        if let Some(label) = &options.accept_label {
            dict.insert("accept_label", Value::from(label.as_str()));
        }
        dict.insert("modal", Value::from(options.modal));
        dict.insert("multiple", Value::from(options.multiple));
        dict.insert("directory", Value::from(options.directory)); // Version 3+ [15]

        if!options.filters.is_empty() {
            let mut filters_array = Array::new(Type::Tuple(Arc::new())))])));
            for filter in &options.filters {
                let mut patterns_array = Array::new(Type::Tuple(Arc::new()));
                for pattern_enum in &filter.patterns {
                    match pattern_enum {
                        FilterPattern::Glob(p) => patterns_array.append(Value::from((0u32, p.as_str()))).unwrap(),
                        FilterPattern::MimeType(m) => patterns_array.append(Value::from((1u32, m.as_str()))).unwrap(),
                    }
                }
                filters_array.append(Value::from((Str::from(filter.name.as_str()), patterns_array))).unwrap();
            }
            dict.insert("filters", Value::from(filters_array));
        }
        
        if let Some(current_filter) = &options.current_filter {
            let mut patterns_array = Array::new(Type::Tuple(Arc::new()));
            for pattern_enum in &current_filter.patterns {
                 match pattern_enum {
                    FilterPattern::Glob(p) => patterns_array.append(Value::from((0u32, p.as_str()))).unwrap(),
                    FilterPattern::MimeType(m) => patterns_array.append(Value::from((1u32, m.as_str()))).unwrap(),
                }
            }
            dict.insert("current_filter", Value::from((Str::from(current_filter.name.as_str()), patterns_array)));
        }

        if let Some(folder) = &options.current_folder {
            if let Some(folder_str) = folder.to_str() {
                 // Pfad muss als Array von Bytes (ay) gesendet werden, null-terminiert
                 let mut path_bytes: Vec<u8> = folder_str.as_bytes().to_vec();
                 path_bytes.push(0); // Null-Terminierung
                 dict.insert("current_folder", Value::from(path_bytes));
            }
        }
        dict
    }

    pub async fn open_file_dialog(
        &self,
        options: OpenFileOptions,
    ) -> Result<FileChooserResponse, PortalError> {
        let portal_proxy = FileChooserProxy::new(&self.connection).await?;
        let handle_token = format!("novade_open_{}", uuid::Uuid::new_v4().to_simple()); // Eindeutiger Token [15]

        let options_dict = self.build_open_file_options_dict(&options, &handle_token);
        
        let parent_window_str = options.parent_window_id.as_deref().unwrap_or("");

        let request_path: ObjectPath<'_> = portal_proxy
           .OpenFile(parent_window_str, &options.title, options_dict)
           .await?;
        
        tracing::debug!("OpenFile request sent. Handle: {}", request_path.as_str());

        // Auf das Response-Signal warten
        let request_proxy = PortalRequestProxy::builder(&self.connection)
           .path(request_path.to_owned())? //.to_owned() um Lifetime-Probleme zu vermeiden
           .build()
           .await?;
            
        let mut response_stream = request_proxy.receive_Response().await?;

        if let Some(signal_args) = response_stream.next().await {
            let response_code = signal_args.args()?.response_code;
            let results_dict = signal_args.args()?.results;
            tracing::debug!("Portal Response received: code={}, results={:?}", response_code, results_dict);

            if response_code == 0 { // Erfolg
                if let Some(Value::Array(uris_array)) = results_dict.get("uris") {
                    let mut uris = Vec::new();
                    for val in uris_array.get() {
                        if let Value::Str(s) = val {
                            match Url::parse(s.as_str()) {
                                Ok(url) => uris.push(url),
                                Err(_) => return Err(PortalError::InvalidUri(s.as_str().to_string())),
                            }
                        }
                    }
                    if options.directory {
                        if let Some(first_uri) = uris.into_iter().next() {
                             return Ok(FileChooserResponse::SelectedFolder(first_uri));
                        } else {
                            return Err(PortalError::ResponseMalformed("No URI returned for directory selection".into()));
                        }
                    } else {
                        return Ok(FileChooserResponse::SelectedFiles(uris));
                    }
                } else {
                    return Err(PortalError::ResponseMalformed("Missing 'uris' in results".into()));
                }
            } else if response_code == 1 { // Abgebrochen durch Benutzer
                return Ok(FileChooserResponse::Cancelled);
            } else { // Anderer Fehler
                let message = results_dict.get("message")
                               .and_then(|v| if let Value::Str(s) = v { Some(s.to_string()) } else { None })
                               .unwrap_or_else(|| "Unknown portal error".to_string());
                return Err(PortalError::RequestFailed { code: response_code, message });
            }
        }
        // Timeout oder anderer Fehler beim Warten auf das Signal
        Err(PortalError::ResponseMalformed("No response signal received".into()))
    }

    // pub async fn save_file_dialog(...) -> Result<FileChooserResponse, PortalError> {... }
    // Ähnliche Implementierung wie open_file_dialog, aber mit SaveFile-Methode und Optionen.
}
Implementierungsdetails:
Window Identifier: Der parent_window-Parameter für Portalaufrufe ist ein String. Für Wayland-Oberflächen wird dies typischerweise als wayland:WAYLAND_SURFACE_HANDLE formatiert, wobei der Handle die Objekt-ID der Wayland-Oberfläche ist. Die UI-Schicht muss diesen Bezeichner bereitstellen.
Optionen-Dictionary: Die options für OpenFile und SaveFile werden als HashMap<&str, zbus::zvariant::Value<'_>> konstruiert. Die Schlüssel und Werttypen müssen der XDG Portal Spezifikation entsprechen.15

filters: a(sa(us)) - Array von Tupeln (String, Array von Tupeln (Uint32, String)).
current_folder: ay - Byte-Array (null-terminierter Pfad).


Antwortverarbeitung: Die Antwort des Portals kommt asynchron über das Response-Signal auf dem Request-Objekt. Der Client muss dieses Signal abonnieren und die Ergebnisse (uris, choices) parsen.
Fehlerbehandlung: PortalError kapselt D-Bus-Fehler und spezifische Portal-Fehlercodes.
Asynchronität: Alle D-Bus-Aufrufe und Signal-Listener sind async.
Die Verwendung von XDG Desktop Portals ermöglicht es NovaDE-Anwendungen, die in einer Sandbox laufen könnten, auf sichere Weise mit dem Host-System zu interagieren, z.B. um Dateien zu öffnen oder zu speichern, ohne direkten Dateisystemzugriff zu benötigen. Dies ist ein wichtiger Aspekt moderner Desktop-Sicherheit.5. Zusammenfassende Prinzipien der Schnittstellen
Klare Verantwortlichkeiten: Jede Schicht hat definierte Aufgaben, und die Schnittstellen spiegeln diese wider.
Lose Kopplung: Kommunikation erfolgt über APIs (Traits) und Events, um direkte Abhängigkeiten von Implementierungsdetails zu minimieren.
Hohe Kohäsion: Module innerhalb einer Schicht arbeiten eng zusammen, aber die Schicht als Ganzes hat eine klar definierte externe Schnittstelle.
Einheitliche Fehlerbehandlung: Die thiserror-basierte Strategie wird über alle Schichten hinweg verwendet, wobei Fehler weitergeleitet oder spezifisch behandelt werden. Die source()-Kette ist wichtig.1
Event-gesteuerte Updates: Viele Zustandsänderungen werden über Events kommuniziert, was eine reaktive und entkoppelte Architektur fördert. Die UI-Schicht ist ein primärer Konsument von Events aus der Domänen- und Systemschicht, um ihre Darstellung aktuell zu halten.
Asynchronität: Schnittstellen, die potenziell blockierende Operationen beinhalten (I/O, IPC), sind als async deklariert und nutzen Rusts async/await-Syntax.
6. SchlussfolgerungenDie detaillierte Spezifikation der internen Schnittstellen und die Ultra-Feinspezifikation ausgewählter Module bilden das Rückgrat für die Entwicklung der NovaDE. Durch die klare Definition von Verantwortlichkeiten, Datenstrukturen, Methoden, Events und Fehlerbehandlung wird eine solide Grundlage für parallele Entwicklung und zukünftige Erweiterbarkeit geschaffen.Die konsequente Anwendung von Rusts Typ- und Fehlersystem, kombiniert mit etablierten Mustern wie der Trennung von API (Traits) und Implementierung sowie einem zentralen Event-Bus, trägt maßgeblich zur Robustheit und Wartbarkeit des Systems bei. Die detaillierte Ausarbeitung der Schnittstellen zu Standard-Desktop-Diensten wie org.freedesktop.Notifications und XDG Desktop Portals gewährleistet eine gute Integration in das Linux-Ökosystem.Dieser Implementierungsleitfaden ist so konzipiert, dass Entwickler die einzelnen Module mit einem hohen Grad an Sicherheit und Klarheit implementieren können, wodurch Integrationsrisiken minimiert und die Gesamtqualität der NovaDE maximiert wird. Die durchgängige Verwendung von async/await für potenziell blockierende Operationen stellt sicher, dass die Desktop-Umgebung reaktionsschnell bleibt. Die sorgfältige Definition von Fehlerketten mittels thiserror wird die Fehlersuche und -behebung im gesamten System erheblich vereinfachen.


# NovaDE Interner Schnittstellen-Implementierungsleitfaden

Dieser Implementierungsleitfaden definiert die ultrafeinen Spezifikationen und hochdetaillierten Implementierungspläne für jede Schicht der Linux-Desktop-Umgebung "NovaDE". Er ist so detailliert konzipiert, dass Entwickler ihn direkt zur Implementierung verwenden können, ohne eigene Entscheidungen treffen oder Logiken/Algorithmen entwerfen zu müssen.

---

## 1. Schicht: Kernschicht (Core Layer)

Die Kernschicht (Core Layer) bildet das Fundament von NovaDE und stellt grundlegende, universell einsetzbare Bausteine und Dienste bereit, die von allen darüberliegenden Schichten – der Domänenschicht, der Systemschicht und der Benutzeroberflächenschicht (UI-Schicht) – genutzt werden. Die Kommunikation mit höheren Schichten erfolgt durch die direkte Verwendung der hier definierten Typen und Funktionen.

### 1.1. Modul: `core::types`

Dieses Modul definiert grundlegende Datentypen, die systemweit für geometrische Berechnungen, Farbdarstellungen und andere fundamentale Konzepte verwendet werden.

- **Verzeichnis:** `core/src/types/`

#### 1.1.1. `Point<T>` Struktur

Stellt einen Punkt im 2D-Raum dar.

- Datei: `core/src/types/point.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Point<T, U> {
        pub x: T,
        pub y: T,
        _unit: std::marker::PhantomData<U>,
    }
    
    impl<T: Default, U> Default for Point<T, U> {
        fn default() -> Self {
            Point { x: Default::default(), y: Default::default(), _unit: std::marker::PhantomData }
        }
    }
    
    // U kann z.B. Logical, Physical, BufferCoords sein
    pub struct Logical;
    pub struct Physical;
    pub struct BufferCoords;
    
    impl<T, U> Point<T, U> {
        pub const fn new(x: T, y: T) -> Self {
            Point { x, y, _unit: std::marker::PhantomData }
        }
    }
    
    // Weitere Methoden wie Add, Sub, etc. können implementiert werden.
    ```
    
- Verwendung: Positionierung von UI-Elementen, Fensterkoordinaten.

#### 1.1.2. `Size<T>` Struktur

Stellt die Dimensionen (Breite und Höhe) eines 2D-Objekts dar.

- Datei: `core/src/types/size.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Size<T, U> {
        pub w: T,
        pub h: T,
        _unit: std::marker::PhantomData<U>,
    }
    
    impl<T: Default, U> Default for Size<T, U> {
        fn default() -> Self {
            Size { w: Default::default(), h: Default::default(), _unit: std::marker::PhantomData }
        }
    }
    
    impl<T, U> Size<T, U> {
        pub const fn new(w: T, h: T) -> Self {
            Size { w, h, _unit: std.marker::PhantomData }
        }
    }
    ```
    
- Verwendung: Fenstergrößen, UI-Element-Dimensionen.

#### 1.1.3. `Rect<T>` und `RectInt` Strukturen

Stellt ein Rechteck im 2D-Raum dar, definiert durch Position und Größe.

- Datei: `core/src/types/rect.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Rect<T, U> {
        pub loc: Point<T, U>,
        pub size: Size<T, U>,
    }
    
    impl<T: Default, U> Default for Rect<T, U> {
        fn default() -> Self {
            Rect { loc: Default::default(), size: Default::default() }
        }
    }
    
    impl<T, U> Rect<T, U> {
        pub const fn new(loc: Point<T, U>, size: Size<T, U>) -> Self {
            Rect { loc, size }
        }
        // Methoden wie contains_point, intersection, etc.
    }
    
    pub type RectInt = Rect<i32, Logical>; // Beispiel für einen häufigen Typ
    ```
    
- Verwendung: Fenstergeometrien, Auswahlbereiche.

#### 1.1.4. `Color` Struktur

Repräsentiert eine Farbe im RGBA-Format.

- Datei: `core/src/types/color.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Color {
        pub r: f32, // Range 0.0 to 1.0
        pub g: f32, // Range 0.0 to 1.0
        pub b: f32, // Range 0.0 to 1.0
        pub a: f32, // Range 0.0 to 1.0 (alpha)
    }
    
    impl Color {
        pub const fn new(r: f32, g: f32, b: f32, a: f32) -> Self {
            Color { r, g, b, a }
        }
    
        pub fn to_hex_rgb(&self) -> String {
            format!(
                "#{:02x}{:02x}{:02x}",
                (self.r * 255.0) as u8,
                (self.g * 255.0) as u8,
                (self.b * 255.0) as u8
            )
        }
    
        pub fn to_hex_rgba(&self) -> String {
            format!(
                "#{:02x}{:02x}{:02x}{:02x}",
                (self.r * 255.0) as u8,
                (self.g * 255.0) as u8,
                (self.b * 255.0) as u8,
                (self.a * 255.0) as u8
            )
        }
        // Ggf. From-Implementierungen für gängige Formate (z.B. String "#RRGGBB")
    }
    ```
    
- Verwendung: Theming, UI-Elementfarben.

#### 1.1.5. `Orientation` Enum

Definiert die Ausrichtung von UI-Elementen oder Layouts.

- Datei: `core/src/types/orientation.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub enum Orientation {
        Horizontal,
        Vertical,
    }
    ```
    
- Verwendung: Layout-Manager, Ausrichtung von Bedienelementen.

#### 1.1.6. `uuid::Uuid` Integration

Universell eindeutige Identifikatoren.

- Datei: `core/src/types/mod.rs` (als Re-Export)
- Re-Export: `pub use uuid::Uuid;`
- Abhängigkeit in `core/Cargo.toml`: `uuid = { version = "1.0", features = ["v4", "serde"] }`
    - Die Features `v4` und `serde` sind essenziell. `v4` ermöglicht die Generierung zufälliger UUIDs, die für die eindeutige Identifizierung von Entitäten wie Fenstern, Workspaces oder Benachrichtigungen unerlässlich sind. `serde` wird benötigt, falls diese IDs in Konfigurationsdateien persistiert oder über IPC-Schnittstellen serialisiert werden müssen, was in einer Desktop-Umgebung sehr wahrscheinlich ist.1
- Verwendung: Eindeutige Identifizierung von Ressourcen systemweit.

#### 1.1.7. `chrono::DateTime<Utc>` Integration

Zeitstempel mit UTC-Zeitzone.

- Datei: `core/src/types/mod.rs` (als Re-Export)
- Re-Export: `pub use chrono::{DateTime, Utc};`
- Abhängigkeit in `core/Cargo.toml`: `chrono = { version = "0.4", features = ["serde"] }`
    - `chrono` ist der De-facto-Standard für Datums- und Zeitmanipulationen in Rust. Die Verwendung von `DateTime<Utc>` stellt zeitzonenagnostische Zeitstempel sicher, was für interne Repräsentationen als Best Practice gilt, um Komplexitäten bei der Zeitzonenbehandlung zu vermeiden. Das `serde`-Feature ist notwendig, wenn Zeitstempel persistiert (z.B. in Logdateien oder Konfigurationen) oder serialisiert werden sollen.3
- Verwendung: Zeitstempel für Logging, Events, "zuletzt geändert"-Informationen.

#### 1.1.8. Implementierungsschritte für `core::types`

1. Erstellen Sie das Verzeichnis `core/src/types/`.
2. Implementieren Sie `point.rs`, `size.rs`, `rect.rs`, `color.rs`, und `orientation.rs` gemäß den obigen Spezifikationen.
3. Fügen Sie `uuid` (mit Features "v4", "serde") und `chrono` (mit Feature "serde") zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
4. Fügen Sie die Re-Exports für `Uuid` und `DateTime<Utc>` in `core/src/types/mod.rs` hinzu. Alle lokalen Typen (Point, Size, etc.) sollten ebenfalls von `mod.rs` re-exportiert werden.
    
    Rust
    
    ```
    // core/src/types/mod.rs
    mod color;
    mod orientation;
    mod point;
    mod rect;
    mod size;
    
    pub use chrono::{DateTime, Utc};
    pub use color::Color;
    pub use orientation::Orientation;
    pub use point::{BufferCoords, Logical, Physical, Point};
    pub use rect::{Rect, RectInt};
    pub use size::Size;
    pub use uuid::Uuid;
    ```
    

### 1.2. Modul: `core::errors`

Dieses Modul stellt eine Basis-Fehlerbehandlungsstrategie und den `CoreError`-Typ bereit. Höhere Schichten können `CoreError` oder spezifischere Fehler aus Kernmodulen mittels `#[from]` oder `#[source]` in ihre eigenen Fehlertypen wrappen, wobei die Fehlerursachenkette (`source()`) beibehalten wird.

- **Verzeichnis:** `core/src/`
- Datei: `core/src/errors.rs`

#### 1.2.1. `CoreError` Enum

- Definition unter Verwendung von `thiserror`:
    
    Rust
    
    ```
    #
    pub enum CoreError {
        #[error("I/O error: {source}")]
        Io {
            #[from]
            source: std::io::Error,
            // Optional: context: String, // Um zusätzlichen Kontext zur IO-Operation zu geben
        },
    
        #[error("Configuration parsing error from '{path:?}': {message}")]
        ConfigParse {
            path: Option<std::path::PathBuf>,
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #
        Serialization {
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #
        Deserialization {
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #[error("Invalid path: {path:?}")]
        InvalidPath { path: std::path::PathBuf },
    
        #[error("Initialization failed for module: {module_name}")]
        InitializationFailed {
            module_name: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #[error("Feature not implemented: {feature_name}")]
        NotImplemented { feature_name: String },
    
        #[error("Internal error: {message}")]
        Internal { message: String },
    
        #[error("Operation timed out: {operation}")]
        Timeout { operation: String },
    
        #[error("Permission denied for operation: {operation}")]
        PermissionDenied { operation: String },
    }
    ```
    
    Die Verwendung von `thiserror` 5 ist entscheidend für die Erstellung ergonomischer und informativer Fehlertypen. Das Attribut `#[from]` ermöglicht eine einfache Konvertierung von Standardbibliotheksfehlern wie `std::io::Error`. Das Attribut `#[source]` (implizit von `thiserror` verwendet, wenn ein Feld `#[from]` oder explizit `#[source]` ist) ist entscheidend für die Beibehaltung der Fehlerursachenkette, wie in der Spezifikation hervorgehoben. Eine robuste Fehlerbehandlungsstrategie ist fundamental. `thiserror` vereinfacht die Erstellung benutzerdefinierter Fehlertypen, die gut mit dem `Error`-Trait von Rust integriert sind. Die Beibehaltung der `source()`-Kette ist für das Debugging unerlässlich, da sie es Entwicklern ermöglicht, einen Fehler bis zu seinem Ursprung zurückzuverfolgen, selbst wenn er von verschiedenen Schichten mehrfach umgebrochen wird.

#### 1.2.2. Fehlerpropagierungsstrategie

Alle Funktionen in der Kernschicht, die fehlschlagen können, MÜSSEN `Result<T, CoreError>` oder `Result<T, SpecificCoreSubError>` zurückgeben, wobei `SpecificCoreSubError` via `#[from]` in `CoreError` konvertierbar sein sollte. Höhere Schichten definieren ihre eigenen Fehler-Enums (z.B. `DomainError`, `SystemError`, `UIError`) und verwenden `#[from] CoreError` oder `#[source] CoreError`, um Fehler aus dem Kern zu wrappen.

#### 1.2.3. Implementierungsschritte für `core::errors`

1. Fügen Sie `thiserror = "1.0"` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Implementieren Sie `core/src/errors.rs` mit dem `CoreError`-Enum wie oben spezifiziert.
3. Stellen Sie sicher, dass alle Module der Kernschicht `CoreError` für ihre Fehlerberichterstattung verwenden.

### 1.3. Modul: `core::logging`

Dieses Modul definiert die Logging-Infrastruktur basierend auf dem `tracing`-Crate. Alle höheren Schichten verwenden die `tracing`-Makros für ihre Logging-Ausgaben.

- **Verzeichnis:** `core/src/`
- Datei: `core/src/logging.rs`

#### 1.3.1. `initialize_logging()` Funktion

- Signatur:
    
    Rust
    
    ```
    pub fn initialize_logging(
        level_filter: tracing::Level,
        use_json: bool,
        custom_writer: Option<Box<dyn Fn() -> Box<dyn std::io::Write + Send + Sync + 'static> + Send + Sync + 'static>>
    ) -> Result<(), CoreError>
    ```
    
    - `level_filter`: Der minimale Log-Level, der aufgezeichnet werden soll (z.B. `tracing::Level::INFO`, `tracing::Level::DEBUG`).
    - `use_json`: Wenn `true`, werden Logs im JSON-Format ausgegeben, andernfalls in einem menschenlesbaren Format.
    - `custom_writer`: Eine optionale Funktion, die einen Writer für die Log-Ausgabe zurückgibt (z.B. in eine Datei, einen Netzwerk-Socket oder `std::io::stderr`). Standardmäßig wird `std::io::stderr` verwendet. Die Funktion wird verwendet, um den Writer bei Bedarf neu erstellen zu können (z.B. bei Log-Rotation).
- Implementierung:
    1. Verwendet `tracing_subscriber::fmt()` für die formatierte Protokollierung.
    2. Ermöglicht die Konfiguration des Formats (JSON oder "pretty") und des Writers.
        - Für JSON: `tracing_subscriber::fmt().json().with_writer(writer_closure).init();`
        - Für Pretty: `tracing_subscriber::fmt().pretty().with_writer(writer_closure).init();`
    3. Konfiguriert den `EnvFilter` basierend auf `level_filter` oder einer Umgebungsvariable (z.B. `RUST_LOG`).
    4. Richtet einen globalen Standard-Subscriber ein mittels `tracing::subscriber::set_global_default`.
    5. Gibt `Result<(), CoreError>` zurück, um Initialisierungsfehler zu signalisieren (z.B. wenn das Setzen des globalen Subscribers fehlschlägt).
- Die Standardisierung auf `tracing` ermöglicht eine strukturierte Protokollierung über alle Schichten hinweg, was für das Debugging und die Überwachung eines komplexen Systems wie einer Desktop-Umgebung von unschätzbarem Wert ist. Die Möglichkeit, zwischen menschenlesbaren und JSON-Formaten zu wechseln, ist gut für Entwicklung versus Produktion/Log-Aggregation. `tracing` bietet ein leistungsfähigeres und flexibleres Logging-Framework als das ältere `log`-Crate, insbesondere durch sein Konzept von Spans für kontextbezogene Protokollierung. Dies ist in einem mehrschichtigen, ereignisgesteuerten System von großem Vorteil.

#### 1.3.2. Verwendung von `tracing`-Makros

Alle Schichten verwenden die Makros `trace!`, `debug!`, `info!`, `warn!`, `error!` aus dem `tracing`-Crate. Spans (`span!`, `info_span!`, etc.) sollten verwendet werden, um kontextuelle Informationen für zusammengehörige Log-Meldungen bereitzustellen.

- Beispiel: `info!(target: "core::config", path = %file_path.display(), "Lade Kernkonfiguration.");`
- Beispiel mit Span:
    
    Rust
    
    ```
    let workspace_span = info_span!("workspace_operation", id = %workspace_id);
    let _enter = workspace_span.enter();
    //... Operationen innerhalb des Spans...
    info!("Operation abgeschlossen");
    ```
    

#### 1.3.3. Implementierungsschritte für `core::logging`

1. Fügen Sie `tracing = "0.1"` und `tracing_subscriber = { version = "0.3", features = ["fmt", "json", "env-filter"] }` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Implementieren Sie `core/src/logging.rs` mit der Funktion `initialize_logging()` wie oben spezifiziert.

### 1.4. Modul: `core::config`

Dieses Modul stellt Primitive zum Laden, Parsen und Zugreifen auf Kernkonfigurationen bereit. Es definiert die Struktur `CoreConfig` und Funktionen für deren Verwaltung.

- **Verzeichnis:** `core/src/config/`

#### 1.4.1. `CoreConfig` Struktur

Definiert die Kernkonfigurationseinstellungen.

- Datei: `core/src/config/types.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct CoreConfig {
        pub log_level: String, // z.B. "info", "debug", "trace"
        pub log_format: LogFormat,
        pub default_theme_name: Option<String>,
        pub enable_xwayland: bool,
        // Weitere kernspezifische Konfigurationen, z.B. Pfade, Feature-Flags
    }
    
    #
    #[serde(rename_all = "lowercase")]
    pub enum LogFormat {
        Json,
        Pretty,
    }
    
    impl Default for CoreConfig {
        fn default() -> Self {
            CoreConfig {
                log_level: "info".to_string(),
                log_format: LogFormat::Pretty,
                default_theme_name: Some("NovaDark".to_string()),
                enable_xwayland: true,
            }
        }
    }
    ```
    

#### 1.4.2. `ConfigError` Enum

Spezifische Fehler für das Laden und Verarbeiten von Konfigurationen.

- Datei: `core/src/config/error.rs`
- Definition:
    
    Rust
    
    ```
    use crate::core::errors::CoreError; // Assuming CoreError is in crate::core
    
    #
    pub enum ConfigError {
        #[error("Failed to determine config directory: {0}")]
        DirectoryResolutionError(String),
    
        #[error("Config file not found at {path:?}")]
        FileNotFound { path: std::path::PathBuf },
    
        #[error("Failed to read config file {path:?}")]
        FileReadError {
            path: std::path::PathBuf,
            #[source]
            source: std::io::Error,
        },
    
        #
        TomlParseError {
            path: std::path::PathBuf,
            message: String,
            #[source]
            source: Option<toml::de::Error>,
        },
        // Ggf. JsonParseError, falls JSON auch unterstützt wird
    
        #[error("Configuration not loaded or initialization failed.")]
        NotLoaded,
    
        #[error("Invalid configuration value for key '{key}': {message}")]
        InvalidValue { key: String, message: String },
    
        #[error("Failed to write default config to {path:?}")]
        DefaultConfigWriteError {
            path: std::path::PathBuf,
            #[source]
            source: std::io::Error,
        },
    
        #
        DefaultConfigTomlError(#[from] toml::ser::Error),
    
        #[error(transparent)]
        Core(#[from] CoreError), // Um CoreError wrappen zu können
    }
    ```
    

#### 1.4.3. Globale Konfigurationsvariable

Verwendet `once_cell` für eine thread-sichere, einmalig initialisierte globale Konfiguration.

- Datei: `core/src/config/mod.rs` (oder `core/src/config/global.rs`)
    
    Rust
    
    ```
    use once_cell::sync::OnceCell;
    use std::sync::RwLock;
    use super::types::CoreConfig; // Pfad anpassen
    use super::error::ConfigError; // Pfad anpassen
    
    static CORE_CONFIG: OnceCell<RwLock<CoreConfig>> = OnceCell::new();
    ```
    

#### 1.4.4. `load_core_config()` Funktion

Lädt die Kernkonfiguration aus einer Datei.

- Datei: `core/src/config/loader.rs`
- Signatur: `pub fn load_core_config(custom_path: Option<std::path::PathBuf>) -> Result<(), ConfigError>`
- Implementierung:
    
    1. Bestimme den Konfigurationsdateipfad:
        - Verwende `custom_path`, falls angegeben.
        - Andernfalls suche im XDG-Standardverzeichnis (z.B. `$XDG_CONFIG_HOME/nova-de/core.toml`) mittels `directories_next::ProjectDirs`.
        - Falls kein XDG-Verzeichnis gefunden wird, verwende einen Fallback-Pfad (z.B. `~/.config/nova-de/core.toml`).
    2. Wenn die Datei nicht existiert, erstelle eine Standardkonfiguration (`CoreConfig::default()`) und speichere sie unter dem ermittelten Pfad. Logge diesen Vorgang.
    3. Lese den Dateiinhalt. Bei Fehler `ConfigError::FileReadError`.
    4. Parse den Inhalt (z.B. TOML) in eine `CoreConfig`-Instanz. Bei Fehler `ConfigError::TomlParseError`.
    5. Initialisiere die globale `CORE_CONFIG` Variable mit der geladenen Konfiguration: `CORE_CONFIG.set(RwLock::new(loaded_config)).map_err(|_| ConfigError::NotLoaded)` (Fehlerbehandlung für den Fall, dass `set` fehlschlägt, was nur passiert, wenn bereits initialisiert).
    6. Gibt `Ok(())` bei Erfolg zurück.
    
    - Eine globale, statisch zugängliche Konfiguration ist üblich, erfordert aber eine sorgfältige Verwaltung, insbesondere bei der Initialisierung. `once_cell` für die Lazy-Initialisierung und `RwLock` für den threadsicheren Zugriff sind ein gutes Muster. Die Konfiguration muss früh im Anwendungslebenszyklus verfügbar sein und von verschiedenen Teilen des Systems zugänglich sein. `once_cell` stellt sicher, dass das Laden nur einmal erfolgt.

#### 1.4.5. `get_core_config()` Funktion

Bietet globalen Lesezugriff auf die geladene `CoreConfig`.

- Datei: `core/src/config/access.rs`
- Signatur: `pub fn get_core_config() -> Result<std::sync::RwLockReadGuard<'static, CoreConfig>, ConfigError>`
- Implementierung:
    1. Versuche, einen Read-Lock auf `CORE_CONFIG` zu erhalten: `CORE_CONFIG.get().ok_or(ConfigError::NotLoaded)?.read().map_err(|_| ConfigError::NotLoaded)` (Fehlerbehandlung für Poisoned Lock).
    2. Gibt den `RwLockReadGuard` bei Erfolg zurück.

#### 1.4.6. `update_core_config()` Funktion (Optional)

Ermöglicht die dynamische Aktualisierung der Kernkonfiguration zur Laufzeit.

- Datei: `core/src/config/access.rs`
- Signatur: `pub fn update_core_config(new_config: CoreConfig) -> Result<(), ConfigError>`
- Implementierung:
    1. Versuche, einen Write-Lock auf `CORE_CONFIG` zu erhalten.
    2. Aktualisiere die Konfiguration.
    3. Persistiert die neue Konfiguration in die Datei.
    4. **Wichtig:** Benachrichtige relevante Systemteile über die Konfigurationsänderung (z.B. über ein Event). Dies erfordert sorgfältige Überlegungen zur Thread-Sicherheit und wie Komponenten auf dynamische Änderungen reagieren.

#### 1.4.7. Implementierungsschritte für `core::config`

1. Fügen Sie `serde = { version = "1.0", features = ["derive"] }`, `toml = "0.8"`, `once_cell = "1.19"`, `directories-next = "2.0"` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Erstellen Sie die Verzeichnisstruktur `core/src/config/`.
3. Definieren Sie `CoreConfig` und `LogFormat` in `core/src/config/types.rs`.
4. Definieren Sie `ConfigError` in `core/src/config/error.rs`.
5. Implementieren Sie `loader.rs` (mit `load_core_config`) und `access.rs` (mit `get_core_config` und optional `update_core_config`).
6. Fügen Sie die globale `CORE_CONFIG`-Variable in `core/src/config/mod.rs` oder einer dedizierten `global.rs` ein und exportieren Sie die öffentlichen Funktionen.

### 1.5. Modul: `core::utils`

Dieses Modul bietet allgemeine Hilfsfunktionen, die von allen höheren Schichten genutzt werden können.

- **Verzeichnis:** `core/src/utils/`
- **Struktur:** Das Modul sollte in thematische Untermodule aufgeteilt werden, um die Übersichtlichkeit zu wahren.

#### 1.5.1. Untermodul: `core::utils::file_utils`

- Datei: `core/src/utils/file_utils.rs`
- Funktionen:
    - `pub fn read_file_to_string(path: &std::path::Path) -> Result<String, CoreError>`
        - Implementierung: Verwendet `std::fs::read_to_string`. Mappt `std::io::Error` auf `CoreError::Io`.
    - `pub fn ensure_dir_exists(path: &std::path::Path) -> Result<(), CoreError>`
        - Implementierung: Verwendet `std::fs::create_dir_all`. Mappt `std::io::Error` auf `CoreError::Io`.
    - `pub fn write_string_to_file(path: &std::path::Path, content: &str) -> Result<(), CoreError>`
        - Implementierung: Verwendet `std::fs::write`. Mappt `std::io::Error` auf `CoreError::Io`.

#### 1.5.2. Untermodul: `core::utils::string_utils`

- Datei: `core/src/utils/string_utils.rs`
- Funktionen:
    - `pub fn sanitize_filename(name: &str) -> String`
        - Implementierung: Ersetzt ungültige Zeichen für Dateinamen (z.B. `/`, `\`, `:`, `*`, `?`, `"`, `<`, `>`, `|`) durch Unterstriche oder entfernt sie.
    - `pub fn truncate_string_with_ellipsis(s: &str, max_len: usize) -> String`
        - Implementierung: Kürzt den String auf `max_len` Zeichen und fügt "..." hinzu, falls er gekürzt wurde. Achtet auf Grapheme Cluster, um Unicode-Zeichen nicht zu zerschneiden.
            
            Rust
            
            ```
            use unicode_segmentation::UnicodeSegmentation;
            //...
            // if s.graphemes(true).count() > max_len {
            //     s.graphemes(true).take(max_len - 3).collect::<String>() + "..."
            // } else {
            //     s.to_string()
            // }
            ```
            
            - Abhängigkeit: `unicode-segmentation = "1.10"`

#### 1.5.3. Untermodul: `core::utils::async_utils` (falls benötigt)

- Datei: `core/src/utils/async_utils.rs`
- Mögliche Funktionen:
    - Wrapper für `tokio::spawn` mit standardisierter Fehlerbehandlung oder Logging.
    - Hilfsfunktionen für Timeout-Management bei asynchronen Operationen.

#### 1.5.4. Implementierungsschritte für `core::utils`

1. Erstellen Sie das Verzeichnis `core/src/utils/`.
2. Erstellen Sie `core/src/utils/mod.rs` und deklarieren Sie die Untermodule:
    
    Rust
    
    ```
    pub mod file_utils;
    pub mod string_utils;
    // pub mod async_utils;
    ```
    
3. Implementieren Sie die Funktionen in den jeweiligen Untermodul-Dateien.
4. Fügen Sie ggf. Abhängigkeiten wie `unicode-segmentation` zu `core/Cargo.toml` hinzu.
5. Das `utils`-Modul kann leicht zu einer Ansammlung unzusammenhängender Funktionen werden. Es ist wichtig, die Organisation beizubehalten und sicherzustellen, dass die Funktionen eine breite Anwendbarkeit haben. Wenn eine Hilfsfunktion sehr spezifisch für eine einzelne Domäne oder ein Systemanliegen ist, sollte sie stattdessen im Hilfsmodul dieser Schicht angesiedelt sein. Eine klare Abgrenzung ist notwendig, um die Kohäsion der Module zu wahren und unnötige Kopplungen zu vermeiden.

---

## 2. Schicht: Domänenschicht (Domain Layer)

Die Domänenschicht kapselt die Geschäftslogik und den Kernzustand der Desktop-Umgebung NovaDE. Sie definiert die zentralen Konzepte, Regeln und Verhaltensweisen des Systems, unabhängig von technischen Implementierungsdetails der System- oder UI-Schicht. Die Kommunikation mit höheren Schichten (System- und UI-Schicht) erfolgt primär über wohldefinierte Service-APIs (als Rust-Traits implementiert) und durch domänenspezifische Events, die Zustandsänderungen signalisieren.

Die Domänenschicht ist zentral für die Funktionalität von NovaDE. Die Verwendung von Rust-Traits für Service-APIs fördert lose Kopplung und Testbarkeit. Ereignisse sind der Schlüssel zur reaktiven Propagierung von Zustandsänderungen. Fehlertypen sollten für jedes Domänenmodul spezifisch sein, um klaren Kontext zu bieten.

### 2.1. Service APIs (Traits)

Öffentliche Schnittstellen der Domänenschicht werden primär durch Rust-Traits definiert. Diese Traits werden von Service-Strukturen innerhalb der Domänenmodule implementiert. Methoden sind typischerweise `async`, wenn sie I/O-Operationen oder potenziell langlaufende Prozesse beinhalten, und geben `Result<T, SpecificDomainError>` zurück.

#### 2.1.1. `domain::theming::ThemingEngine` Trait

Verantwortlich für die Verwaltung und Anwendung von Themes.

- **Datei:** `domain/src/theming/engine.rs`

##### Zugehörige Datenstrukturen und Typen:

- **`ThemingConfiguration` Struct (Wertobjekt):**
    
    - Definiert die vom Benutzer oder System gewählten Theme-Einstellungen.
    - **Datei:** `domain/src/theming/config.rs`
    - **Felder:**
        - `icon_theme_name: String` (z.B. "Adwaita", "Papirus")
        - `gtk_theme_name: String` (z.B. "Adwaita-dark")
        - `cursor_theme_name: String` (z.B. "Adwaita")
        - `font_name: String` (z.B. "Cantarell 11")
        - `wallpaper_path: Option<std::path::PathBuf>`
        - `color_scheme: ColorScheme` (Enum: `Light`, `Dark`, `SystemPreference`)
        - `accent_color: core::types::Color`
    - **Invarianten:** `font_name` darf nicht leer sein, wenn gesetzt.
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`ColorScheme` Enum (Wertobjekt):**
    
    - Definiert die möglichen Farbschemata.
    - **Datei:** `domain/src/theming/config.rs` (oder `types.rs` im Theming-Modul)
    - **Varianten:** `Light`, `Dark`, `SystemPreference`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`AppliedThemeState` Struct (Wertobjekt):**
    
    - Repräsentiert den aktuell angewandten Theme-Zustand, inklusive aufgelöster Werte.
    - **Datei:** `domain/src/theming/state.rs`
    - **Felder:**
        - `current_config: ThemingConfiguration`
        - `resolved_wallpaper_path: Option<std::path::PathBuf>` (absoluter Pfad zum tatsächlich genutzten Hintergrundbild)
        - `font_config_details: String` (z.B. eine Pango-Font-Beschreibung oder Fontconfig-Pattern)
        - `effective_color_scheme: EffectiveColorScheme` (Enum: `Light`, `Dark`)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`EffectiveColorScheme` Enum (Wertobjekt):**
    
    - Repräsentiert das tatsächlich aktive Farbschema (aufgelöst aus `SystemPreference`).
    - **Datei:** `domain/src/theming/state.rs`
    - **Varianten:** `Light`, `Dark`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`ThemingError` Enum (Fehlertyp):**
    
    - Spezifische Fehler für das Theming-Subsystem.
    - **Datei:** `domain/src/theming/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum ThemingError {
            #[error("Invalid theming configuration: {0}")]
            InvalidConfiguration(String),
        
            #[error("Wallpaper not found at path: {0:?}")]
            WallpaperNotFound(std::path::PathBuf),
        
            #[error("Failed to apply theme '{theme_name}': {details}")]
            ThemeApplyFailed {
                theme_name: String,
                details: String,
                #[source]
                source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
            },
        
            #[error("Persistence error during theming operation")]
            PersistenceError(#[from] crate::core::errors::CoreError), // Assuming CoreError is accessible
        
            #[error("Underlying system service error for theming: {0}")]
            SystemServiceError(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn get_current_theme_state(&self) -> Result<AppliedThemeState, ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den aktuell im System angewandten und zwischengespeicherten Theme-Zustand ab.
    - **Vorbedingungen:** Keine.
    - **Nachbedingungen:** Gibt den `AppliedThemeState` zurück oder einen `ThemingError`.
- `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Aktualisiert die Theme-Konfiguration, persistiert sie und stößt die Anwendung des neuen Themes an.
    - **Vorbedingungen:** `new_config` muss valide sein (ggf. interne Validierung).
    - **Nachbedingungen:** Bei Erfolg wird das `ThemeChangedEvent` publiziert. Die Konfiguration wird persistiert (z.B. über `GlobalSettingsService` oder ein dediziertes Persistenz-Interface). Das System-Theme wird (versucht) anzuwenden.
    - **Geschäftsregeln:** Validiert die `new_config`. Löst das Hintergrundbild auf.
- `async fn apply_theme_to_system(&self, theme_state: &AppliedThemeState) -> Result<(), ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** (Potenziell intern, aufgerufen von `update_configuration`, oder als separate Methode für fortgeschrittene Nutzung) Wendet den gegebenen `AppliedThemeState` auf die Systemkomponenten an (z.B. Setzen von GTK-Theme, Icons, Cursor über Systemmechanismen).
    - **Vorbedingungen:** `theme_state` ist valide.
    - **Nachbedingungen:** Theme-Änderungen sind im System (versucht) aktiv.

##### Publizierte Events:

- **`ThemeChangedEvent`:**
    - **Datei:** `domain/src/theming/events.rs`
    - **Struktur:**
        
        Rust
        
        ```
        #
        pub struct ThemeChangedEvent {
            pub new_state: AppliedThemeState,
            pub old_state: Option<AppliedThemeState>, // Optional, falls der vorherige Zustand bekannt ist
        }
        ```
        
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::theming::ThemeChangedEvent`
    - **Typische Publisher:** Die Implementierung von `ThemingEngine`.
    - **Typische Subscriber:** `ui::theming_gtk` (UI-Schicht), `system::compositor` (Systemschicht, falls relevant für Darstellung).

#### 2.1.2. `domain::workspaces::WorkspaceManager` Trait

Verwaltet Workspaces (virtuelle Desktops).

- **Datei:** `domain/src/workspaces/manager.rs`

##### Zugehörige Datenstrukturen und Typen:

- **`WorkspaceId` Typalias:**
    
    - **Datei:** `domain/src/workspaces/types.rs` (oder direkt in `manager.rs`)
    - **Definition:** `pub type WorkspaceId = core::types::Uuid;`
- **`ApplicationIdentifier` Struct (Wertobjekt):**
    
    - Identifiziert eine Anwendung eindeutig.
    - **Datei:** `domain/src/workspaces/app_id.rs`
    - **Felder:**
        - `id_type: ApplicationIdType` (Enum: `DesktopFile`, `WaylandAppId`, `X11WindowClass`)
        - `identifier_str: String` (z.B. "firefox.desktop", "org.gnome.Nautilus", "Firefox")
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `serde::Serialize`, `serde::Deserialize`.
- **`Workspace` Struct (Entität):**
    
    - Repräsentiert einen einzelnen Workspace.
    - **Datei:** `domain/src/workspaces/workspace.rs`
    - **Felder:**
        - `id: WorkspaceId` (Sichtbarkeit: `pub(crate)`, Zugriff über Getter)
        - `name: String` (Sichtbarkeit: `pub`)
        - `output_name: Option<String>` (Name des Monitors, dem der Workspace primär zugeordnet ist, Sichtbarkeit: `pub`)
        - `layout_policy: WorkspaceLayoutPolicy` (Enum: `Tiling`, `Floating`, `Hybrid`, Sichtbarkeit: `pub`)
        - `pinned_applications: std::collections::HashSet<ApplicationIdentifier>` (Sichtbarkeit: `pub(crate)`, Zugriff über Methoden)
        - `creation_timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
        - `last_accessed_timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
    - **Initialwerte:** `id` wird bei Erstellung generiert, `name` z.B. "Workspace 1", `output_name` ist `None`, `layout_policy` wird aus globalen Einstellungen übernommen oder ist Standard (`Floating`), `pinned_applications` ist leer, `creation_timestamp` und `last_accessed_timestamp` sind Zeitpunkte der Erstellung.
    - **Invarianten:** `name` darf nicht leer sein. `id` ist unveränderlich nach Erstellung.
    - **Methoden (Beispiele):**
        - `pub fn new(name: String, layout_policy: WorkspaceLayoutPolicy) -> Self`
        - `pub fn id(&self) -> WorkspaceId`
        - `pub fn add_pinned_app(&mut self, app_id: ApplicationIdentifier) -> bool`
        - `pub fn remove_pinned_app(&mut self, app_id: &ApplicationIdentifier) -> bool`
        - `pub fn is_app_pinned(&self, app_id: &ApplicationIdentifier) -> bool`
        - `pub(crate) fn set_last_accessed(&mut self)`
    - **Beziehungen:** Keine direkten Entitätsbeziehungen in dieser Struktur, aber `pinned_applications` verweist auf `ApplicationIdentifier`.
- **`WorkspaceLayoutPolicy` Enum (Wertobjekt):**
    
    - **Datei:** `domain/src/workspaces/types.rs`
    - **Varianten:** `Tiling`, `Floating`, `Hybrid`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`WorkspaceManagerError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/workspaces/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum WorkspaceManagerError {
            #
            WorkspaceNotFound(super::types::WorkspaceId), // super::types::WorkspaceId
        
            #[error("Workspace with name '{0}' already exists")]
            DuplicateWorkspaceName(String),
        
            #[error("Maximum number of workspaces reached ({0})")]
            MaxWorkspacesReached(usize),
        
            #[error("Cannot delete the last workspace")]
            CannotDeleteLastWorkspace,
        
            #[error("Cannot delete active workspace; switch to another first")]
            CannotDeleteActiveWorkspace,
        
            #[error("Persistence error during workspace operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #[error("Invalid application identifier: {0}")]
            InvalidApplicationId(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn create_workspace(&self, name: Option<String>) -> Result<Workspace, WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Erstellt einen neuen Workspace. Wenn `name` `None` ist, wird ein Standardname generiert (z.B. "Workspace N").
    - **Nachbedingungen:** Bei Erfolg wird `WorkspaceEvent::Created` publiziert. Der neue Workspace wird persistiert.
    - **Geschäftsregeln:** Prüft auf Namenskonflikte und maximale Anzahl von Workspaces.
- `async fn delete_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Löscht den Workspace mit der gegebenen ID.
    - **Vorbedingungen:** Workspace darf nicht der letzte verbleibende sein. Workspace darf nicht der aktive sein (oder es muss eine Logik zum Wechsel des aktiven Workspaces implementiert sein).
    - **Nachbedingungen:** Bei Erfolg wird `WorkspaceEvent::Deleted` publiziert. Änderungen werden persistiert.
- `async fn get_workspace_by_id(&self, id: WorkspaceId) -> Result<Option<Workspace>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn get_all_workspaces(&self) -> Result<Vec<Workspace>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Vorbedingungen:** Der Workspace mit `id` muss existieren.
    - **Nachbedingungen:** `WorkspaceEvent::ActiveChanged` wird publiziert. Der `last_accessed_timestamp` des neuen und ggf. des alten aktiven Workspaces wird aktualisiert.
- `async fn get_active_workspace_id(&self) -> Result<Option<WorkspaceId>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Vorbedingungen:** `new_name` darf nicht leer sein und nicht mit einem existierenden Workspace-Namen (außer dem eigenen) kollidieren.
    - **Nachbedingungen:** `WorkspaceEvent::Renamed` wird publiziert. Änderung wird persistiert.
- `async fn pin_application_to_space(&self, space_id: WorkspaceId, app_id: ApplicationIdentifier) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Nachbedingungen:** `WorkspaceEvent::AppPinned` wird publiziert. Änderung wird persistiert.
- `async fn unpin_application_from_space(&self, space_id: WorkspaceId, app_id: ApplicationIdentifier) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Nachbedingungen:** `WorkspaceEvent::AppUnpinned` wird publiziert. Änderung wird persistiert.
- `async fn move_window_to_workspace(&self, window_identifier: String /* Eindeutiger Fenster-Identifikator, z.B. Wayland Surface ID als String */, target_workspace_id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Fordert an, ein Fenster zum Ziel-Workspace zu verschieben. Die eigentliche Fensterverschiebung erfolgt in der Systemschicht.
    - **Nachbedingungen:** `WorkspaceEvent::WindowMoved` wird publiziert.

##### Publizierte Events:

- **`WorkspaceEvent` Enum:**
    - **Datei:** `domain/src/workspaces/events.rs`
    - **Varianten (Beispiele):**
        - `Created { workspace: Workspace }`
        - `Deleted { workspace_id: WorkspaceId, new_active_workspace_id: Option<WorkspaceId> }`
        - `ActiveChanged { old_id: Option<WorkspaceId>, new_id: WorkspaceId }`
        - `Renamed { workspace_id: WorkspaceId, new_name: String }`
        - `AppPinned { space_id: WorkspaceId, app_id: ApplicationIdentifier }`
        - `AppUnpinned { space_id: WorkspaceId, app_id: ApplicationIdentifier }`
        - `LayoutPolicyChanged { workspace_id: WorkspaceId, new_policy: WorkspaceLayoutPolicy }`
        - `WindowMoved { window_identifier: String, source_workspace_id: Option<WorkspaceId>, target_workspace_id: WorkspaceId }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::workspaces::WorkspaceEvent`
    - **Typische Publisher:** Die Implementierung von `WorkspaceManager`.
    - **Typische Subscriber:** `ui::shell` (UI-Schicht), `system::compositor` (Systemschicht).

#### 2.1.3. `domain::user_centric_services::AIInteractionLogicService` Trait

Steuert die Logik für Benutzerinteraktionen mit KI-Diensten, inklusive Einwilligungsmanagement.

- **Datei:** `domain/src/user_centric_services/ai_logic.rs`
- Diese Service-Schnittstelle ist entscheidend für die sichere und transparente Integration von KI-Funktionen. Die Trennung der Einwilligungslogik von der reinen MCP-Kommunikation (die in der Systemschicht angesiedelt ist) ist ein wichtiger Aspekt für Datenschutz und Benutzerkontrolle.

##### Zugehörige Datenstrukturen und Typen:

- **`AIInteractionContextData` Struct (Wertobjekt):**
    
    - Sammelt Kontextinformationen für eine KI-Anfrage.
    - **Datei:** `domain/src/user_centric_services/ai_context.rs`
    - **Felder:**
        - `active_window_title: Option<String>`
        - `active_app_id: Option<super::workspaces::app_id::ApplicationIdentifier>` // Pfad anpassen
        - `current_workspace_id: Option<super::workspaces::types::WorkspaceId>` // Pfad anpassen
        - `selected_text: Option<String>`
        - `clipboard_content_preview: Option<String>` (Vorschau, nicht der volle Inhalt)
        - `screenshot_data_uri: Option<String>` (Data-URI eines Screenshots, falls relevant)
        - `user_query: String` (Die eigentliche Anfrage des Benutzers)
        - `interaction_id: core::types::Uuid` (Eindeutige ID für diese Interaktion)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIConsent` Enum (Wertobjekt):**
    
    - Repräsentiert den Einwilligungsstatus des Benutzers für KI-Interaktionen.
    - **Datei:** `domain/src/user_centric_services/ai_consent.rs`
    - **Varianten:**
        - `Granted { for_session: bool, timestamp: core::types::DateTime<core::types::Utc> }` (Einwilligung für die aktuelle Sitzung oder dauerhaft)
        - `Denied { timestamp: core::types::DateTime<core::types::Utc> }`
        - `NotSet`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIInteractionResponse` Struct (Wertobjekt):**
    
    - Repräsentiert die Antwort von einem KI-Dienst.
    - **Datei:** `domain/src/user_centric_services/ai_response.rs`
    - **Felder:**
        - `interaction_id: core::types::Uuid`
        - `response_text: Option<String>`
        - `suggested_actions: Vec<String>`
        - `tool_call_id: Option<String>` (Falls ein Tool vom MCP-Server aufgerufen wurde)
        - `tool_call_result: Option<serde_json::Value>` (Ergebnis des Tool-Aufrufs)
        - `error_message: Option<String>`
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIInteractionError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/user_centric_services/ai_error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum AIInteractionError {
            #[error("User consent not given for AI interaction")]
            ConsentNotGiven,
        
            #[error("MCP client error: {0}")]
            MCPError(String), // Wird von SystemMcpService kommen
        
            #[error("Failed to prepare context for AI interaction: {0}")]
            ContextPreparationFailed(String),
        
            #[error("AI service returned an error: {0}")]
            AIServiceError(String),
        
            #[error("Persistence error during AI consent operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #
            InteractionNotFoundOrTimedOut(crate::core::types::Uuid),
        }
        ```
        

##### Methoden des Traits:

- `async fn initiate_interaction(&self, context_data: AIInteractionContextData) -> Result<core::types::Uuid /* interaction_id */, AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Startet eine neue KI-Interaktion. Prüft die Einwilligung und leitet die Anfrage ggf. an den `SystemMcpService` weiter. Gibt eine `interaction_id` zurück, um die Antwort später zu korrelieren.
    - **Vorbedingungen:** `get_consent_status()` darf nicht `Denied` sein. Wenn `NotSet`, wird die Interaktion ggf. pausiert und ein `AIConsentRequestEvent` ausgelöst.
    - **Nachbedingungen:** `AIInteractionStartedEvent` wird publiziert.
    - **Geschäftsregeln:** Die Logik hier muss entscheiden, ob basierend auf `context_data` und `AIConsent` die Interaktion fortgesetzt, abgelehnt oder eine erneute Einwilligung angefordert wird.
- `async fn provide_consent(&self, consent: AIConsent) -> Result<(), AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Speichert die Benutzereinwilligung.
    - **Nachbedingungen:** `AIConsentChangedEvent` wird publiziert. Der Einwilligungsstatus wird persistiert.
- `async fn get_consent_status(&self) -> Result<AIConsent, AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den aktuellen Einwilligungsstatus ab.
- `async fn process_mcp_response(&self, interaction_id: core::types::Uuid, response: Result<serde_json::Value, String> /* MCP Tool Call Result oder Fehler */) -> Result<(), AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Verarbeitet eine asynchrone Antwort vom `SystemMcpService` (typischerweise ein Tool-Aufruf-Ergebnis).
    - **Nachbedingungen:** `AIInteractionCompletedEvent` oder `AIInteractionFailedEvent` wird publiziert.

##### Publizierte Events:

- **`AIConsentChangedEvent`:**
    - **Datei:** `domain/src/user_centric_services/events.rs`
    - **Struktur:** `pub struct AIConsentChangedEvent { pub new_status: AIConsent; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIConsentChangedEvent`
- **`AIInteractionStartedEvent`:**
    - **Struktur:** `pub struct AIInteractionStartedEvent { pub interaction_id: core::types::Uuid, pub context: AIInteractionContextData; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionStartedEvent`
- **`AIInteractionCompletedEvent`:**
    - **Struktur:** `pub struct AIInteractionCompletedEvent { pub response: AIInteractionResponse; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionCompletedEvent`
- **`AIInteractionFailedEvent`:**
    - **Struktur:** `pub struct AIInteractionFailedEvent { pub interaction_id: core::types::Uuid, pub error: AIInteractionError; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionFailedEvent`
- **`AIConsentRequestEvent`:** (Falls die UI den Benutzer zur Einwilligung auffordern soll)
    - **Struktur:** `pub struct AIConsentRequestEvent { pub interaction_id: core::types::Uuid, pub for_context: AIInteractionContextData }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIConsentRequestEvent`
- **Typische Publisher:** Die Implementierung von `AIInteractionLogicService`.
- **Typische Subscriber:** `ui::command_palette` oder KI-Widgets (UI-Schicht), `system::mcp::SystemMcpService` (Systemschicht, für Antworten).

#### 2.1.4. `domain::user_centric_services::NotificationService` Trait

Verwaltet das Anzeigen und Interagieren mit Desktop-Benachrichtigungen.

- **Datei:** `domain/src/user_centric_services/notification_service.rs`
- Die Parameter für `post_notification` spiegeln eng die D-Bus-Methode `org.freedesktop.Notifications.Notify` wider.9 Dieser Dienst fungiert als Abstraktion über potenzielle D-Bus-Implementierungen in der Systemschicht. Die Domänenschicht definiert das _Konzept_ einer Benachrichtigung innerhalb von NovaDE. Die Systemschicht wäre dann dafür verantwortlich, diese Benachrichtigung tatsächlich über D-Bus zu senden, wenn NovaDE als Benachrichtigungsserver fungiert, oder auf D-Bus-Benachrichtigungen zu lauschen, wenn es diese konsumiert. Die Verwendung von `zvariant::OwnedValue` für `hints` deutet auf eine direkte Abbildung auf D-Bus-Varianten hin.

##### Zugehörige Datenstrukturen und Typen:

- **`NotificationId` Typalias:**
    
    - **Datei:** `domain/src/user_centric_services/types.rs` (oder direkt in `notification_service.rs`)
    - **Definition:** `pub type NotificationId = core::types::Uuid;`
- **`NotificationAction` Struct (Wertobjekt):**
    
    - Definiert eine Aktion, die mit einer Benachrichtigung verbunden ist.
    - **Datei:** `domain/src/user_centric_services/notification_action.rs`
    - **Felder:**
        - `key: String` (Eindeutiger Schlüssel für die Aktion, z.B. "default", "reply")
        - `label: String` (Anzeigetext für den Button)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `serde::Serialize`, `serde::Deserialize`.
- **`NotificationUrgency` Enum (Wertobjekt):**
    
    - Definiert die Dringlichkeitsstufe einer Benachrichtigung.
    - **Datei:** `domain/src/user_centric_services/types.rs`
    - **Varianten:** `Low`, `Normal`, `Critical`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`Notification` Struct (Entität):**
    
    - Repräsentiert eine einzelne Desktop-Benachrichtigung.
    - **Datei:** `domain/src/user_centric_services/notification.rs`
    - **Felder:**
        - `id: NotificationId` (Sichtbarkeit: `pub(crate)`, Zugriff über Getter)
        - `app_name: String` (Sichtbarkeit: `pub`)
        - `replaces_id: Option<NotificationId>` (Sichtbarkeit: `pub`)
        - `app_icon: Option<String>` (Pfad oder Name des Icons, Sichtbarkeit: `pub`)
        - `summary: String` (Kurze Zusammenfassung, Sichtbarkeit: `pub`)
        - `body: Option<String>` (Detaillierter Text, Sichtbarkeit: `pub`)
        - `actions: Vec<NotificationAction>` (Sichtbarkeit: `pub`)
        - `hints: std::collections::HashMap<String, zbus::zvariant::OwnedValue>` (Spezifische Hinweise für den Notification-Server, Sichtbarkeit: `pub`)
        - `expire_timeout_ms: i32` (-1 für Server-Default, 0 für nie, >0 für Millisekunden, Sichtbarkeit: `pub`)
        - `urgency: NotificationUrgency` (Sichtbarkeit: `pub`)
        - `timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
        - `is_displayed: std::sync::atomic::AtomicBool` (Interner Status, ob die Benachrichtigung aktuell angezeigt wird)
    - **Initialwerte:** `id` wird generiert, `timestamp` ist aktuell, `is_displayed` ist `false`.
    - **Invarianten:** `summary` darf nicht leer sein. `id` ist unveränderlich.
    - **Methoden (Beispiele):**
        - `pub fn id(&self) -> NotificationId`
        - `pub(crate) fn mark_as_displayed(&self)`
        - `pub(crate) fn mark_as_closed(&self)`
- **`CloseReason` Enum (Wertobjekt):**
    
    - Gibt den Grund an, warum eine Benachrichtigung geschlossen wurde.
    - **Datei:** `domain/src/user_centric_services/types.rs`
    - **Varianten:** `Expired`, `DismissedByUser`, `ClosedByApp`, `ServiceShutdown`, `Unknown`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`NotificationError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/user_centric_services/notification_error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum NotificationError {
            #
            NotificationNotFound(super::types::NotificationId), // Pfad anpassen
        
            #[error("Invalid notification format or content: {0}")]
            InvalidNotificationFormat(String),
        
            #[error("Failed to invoke action '{action_key}' for notification {notification_id}: {reason}")]
            ActionInvokeFailed {
                notification_id: super::types::NotificationId, // Pfad anpassen
                action_key: String,
                reason: String,
            },
        
            #[error("Notification service is unavailable or failed: {0}")]
            ServiceUnavailable(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn post_notification(&self, app_name: String, replaces_id: Option<NotificationId>, app_icon: Option<String>, summary: String, body: Option<String>, actions: Vec<NotificationAction>, hints: std::collections::HashMap<String, zbus::zvariant::OwnedValue>, expire_timeout_ms: i32, urgency: NotificationUrgency) -> Result<NotificationId, NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Sendet eine neue Benachrichtigung oder aktualisiert eine existierende.
    - **Nachbedingungen:** Bei Erfolg wird `NotificationPostedEvent` publiziert. Die Benachrichtigung wird (versucht) dem Benutzer angezeigt.
- `async fn get_active_notifications(&self) -> Result<Vec<Notification>, NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft eine Liste aller aktuell aktiven (angezeigten) Benachrichtigungen ab.
- `async fn close_notification(&self, id: NotificationId, reason: CloseReason) -> Result<(), NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Schließt eine spezifische Benachrichtigung.
    - **Vorbedingungen:** Benachrichtigung mit `id` muss existieren und aktiv sein.
    - **Nachbedingungen:** `NotificationClosedEvent` wird publiziert.
- `async fn invoke_action(&self, id: NotificationId, action_key: String) -> Result<(), NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Löst eine mit einer Benachrichtigung verbundene Aktion aus.
    - **Vorbedingungen:** Benachrichtigung mit `id` und Aktion mit `action_key` müssen existieren.
    - **Nachbedingungen:** `NotificationActionInvokedEvent` wird publiziert.

##### Publizierte Events:

- **`NotificationPostedEvent`:**
    - **Datei:** `domain/src/user_centric_services/events.rs`
    - **Struktur:** `pub struct NotificationPostedEvent { pub notification: Notification; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationPostedEvent`
- **`NotificationClosedEvent`:**
    - **Struktur:** `pub struct NotificationClosedEvent { pub id: NotificationId, pub reason: CloseReason; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationClosedEvent`
- **`NotificationActionInvokedEvent`:**
    - **Struktur:** `pub struct NotificationActionInvokedEvent { pub id: NotificationId, pub action_key: String; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationActionInvokedEvent`
- **Typische Publisher:** Die Implementierung von `NotificationService`.
- **Typische Subscriber:** `ui::notifications_frontend` oder `ui::shell` (UI-Schicht), `system::dbus::notification_server` (Systemschicht, falls NovaDE als Server agiert und die Events intern weiterleitet).

#### 2.1.5. `domain::global_settings_and_state_management::GlobalSettingsService` Trait

Verwaltet globale Desktop-Einstellungen und deren Persistenz.

- **Datei:** `domain/src/global_settings/service.rs`
- Dieser Dienst bietet eine strukturierte Methode zur Verwaltung einer Vielzahl von Desktop-Einstellungen. Der Persistenzmechanismus (z.B. eine Implementierung von `domain::settings_persistence_iface`, wie in der Kernschichtspezifikation erwähnt) ist hier von entscheidender Bedeutung.

##### Zugehörige Datenstrukturen und Typen:

- **`SettingPath` Typalias:**
    
    - **Datei:** `domain/src/global_settings/types.rs`
    - **Definition:** `pub type SettingPath = String;` (z.B. "desktop.background.color", "keyboard.layouts.0.name")
- **`SettingValue` Enum (Wertobjekt):**
    
    - Repräsentiert den Wert einer Einstellung. Kann verschiedene primitive Typen und verschachtelte Strukturen annehmen.
    - **Datei:** `domain/src/global_settings/value.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        #[serde(untagged)] // Für flexible (De-)Serialisierung
        pub enum SettingValue {
            String(String),
            Integer(i64),
            Float(f64),
            Boolean(bool),
            List(Vec<SettingValue>),
            Map(std::collections::HashMap<String, SettingValue>),
            Null, // Um das Fehlen eines Wertes explizit darzustellen
        }
        // Implement From<T> for SettingValue für gängige Typen
        ```
        
    - Die Verwendung von `serde_json::Value` wäre eine Alternative für maximale Flexibilität, aber ein eigenes Enum bietet mehr Typsicherheit innerhalb der Domäne.
- **`GlobalDesktopSettings` Struct (Entität):**
    
    - Repräsentiert die Gesamtheit aller verwalteten Einstellungen.
    - **Datei:** `domain/src/global_settings/settings_struct.rs`
    - **Felder:**
        - `settings: std::collections::BTreeMap<SettingPath, SettingValue>` (BTreeMap für geordnete Iteration/Serialisierung, falls gewünscht)
    - **Sichtbarkeit:** `pub(crate)` für `settings`, Zugriff über Methoden.
    - **Methoden (Beispiele):**
        - `pub fn get(&self, path: &SettingPath) -> Option<&SettingValue>`
        - `pub fn set(&mut self, path: SettingPath, value: SettingValue) -> Option<SettingValue>` (gibt alten Wert zurück)
        - `pub fn remove(&mut self, path: &SettingPath) -> Option<SettingValue>`
- **`GlobalSettingsError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/global_settings/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum GlobalSettingsError {
            #
            SettingNotFound(super::types::SettingPath), // Pfad anpassen
        
            #
            TypeMismatch {
                path: super::types::SettingPath, // Pfad anpassen
                expected_type: String,
                found_type: String,
            },
        
            #[error("Persistence error during settings operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #[error("Validation error for setting '{path}': {message}")]
            ValidationError {
                path: super::types::SettingPath, // Pfad anpassen
                message: String,
            },
        
            #[error("Invalid setting path format: {0}")]
            InvalidPathFormat(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn load_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Lädt alle Einstellungen aus der Persistenzschicht.
    - **Nachbedingungen:** Gibt die geladenen `GlobalDesktopSettings` zurück oder einen Fehler.
- `async fn save_settings(&self, settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Persistiert den gesamten Einstellungsbaum.
- `async fn get_setting(&self, path: &SettingPath) -> Result<Option<SettingValue>, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den Wert einer spezifischen Einstellung ab.
- `async fn update_setting(&self, path: SettingPath, value: SettingValue) -> Result<Option<SettingValue /* old_value */>, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Aktualisiert eine spezifische Einstellung und persistiert die Änderung. Gibt den alten Wert zurück, falls vorhanden.
    - **Vorbedingungen:** `path` und `value` müssen validen Formaten entsprechen. Ggf. Validierung gegen ein Schema.
    - **Nachbedingungen:** Bei Erfolg wird `SettingChangedEvent` publiziert. Die Einstellung wird persistiert.
- `async fn get_all_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft eine Kopie aller aktuellen Einstellungen ab.

##### Publizierte Events:

- **`SettingChangedEvent`:**
    - **Datei:** `domain/src/global_settings/events.rs`
    - **Struktur:**
        
        Rust
        
        ```
        #
        pub struct SettingChangedEvent {
            pub path: SettingPath,
            pub old_value: Option<SettingValue>,
            pub new_value: SettingValue,
        }
        ```
        
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::global_settings::SettingChangedEvent`
- **Typische Publisher:** Die Implementierung von `GlobalSettingsService`.
- **Typische Subscriber:** `ui::control_center` (UI-Schicht), verschiedene Systemkomponenten, die auf Einstellungsänderungen reagieren müssen.

### 2.2. Datenstrukturen (Öffentlich)

Zusätzlich zu den direkt mit Service-APIs assoziierten Strukturen können weitere öffentliche Datenstrukturen existieren, die Zustände oder Konfigurationen repräsentieren und von mehreren Modulen oder Schichten verwendet werden.

- **Beispiele:** Viele der oben bereits definierten Strukturen fallen in diese Kategorie, z.B. `AppliedThemeState`, `Workspace`, `Notification`, `GlobalDesktopSettings`, `ThemingConfiguration`, `ApplicationIdentifier`, `AIInteractionContextData`, `AIConsent`, `SettingValue`.
- **Implementierungsrichtlinien:**
    - Jede Struktur/Enum in einer eigenen Datei innerhalb des relevanten Domänenmoduls (z.B. `domain/src/theming/state.rs`).
    - Ableitung von `Debug`, `Clone`, `PartialEq` ist Standard.
    - Ableitung von `serde::Serialize`, `serde::Deserialize` falls Persistenz oder IPC-Übertragung erforderlich ist.
    - Felder sollten `pub` sein, wenn sie direkt von extern gelesen werden sollen, oder `pub(crate)` mit öffentlichen Gettern/Settern für kontrollierten Zugriff.
    - Invarianten sollten durch Konstruktoren und Methoden sichergestellt werden.
    - Beziehungen zu anderen Entitäten/Wertobjekten sollten klar definiert sein (z.B. durch Komposition oder IDs).

### 2.3. Events (Domänenspezifisch)

Domänenspezifische Events signalisieren wichtige Zustandsänderungen innerhalb der Domänenschicht. Sie sind entscheidend für eine reaktive Architektur und lose Kopplung.

- **Beispiele:** Die bereits bei den Services definierten Events (`ThemeChangedEvent`, `WorkspaceEvent`, `NotificationPostedEvent`, `SettingChangedEvent`, `AIConsentChangedEvent`, etc.).
- **Struktur:**
    - Jedes Event sollte als eigene Struktur oder als Variante eines umfassenderen Event-Enums (pro Modul) definiert werden.
    - Die Event-Struktur enthält alle relevanten Daten zur Zustandsänderung.
    - Beispiel: `pub struct ActiveWorkspaceChanged { pub old_id: Option<WorkspaceId>, pub new_id: WorkspaceId }`
- **Eindeutiger Event-Name/Typ:** Eine klare Namenskonvention ist wichtig, z.B. `nova_de::domain::module::EventName`.
- **Publisher:** Die jeweilige Service-Implementierung, die die Zustandsänderung verursacht.
- **Subscriber:** Komponenten in der System- und UI-Schicht, die auf diese Änderungen reagieren müssen.
    - Beispiel: `ui::theming_gtk` abonniert `ThemeChangedEvent`.
    - Beispiel: `system::compositor` abonniert `ActiveWorkspaceChanged`.
- **Datei-Struktur:** Events können in einer `events.rs`-Datei innerhalb jedes Domänenmoduls definiert werden (z.B. `domain/src/theming/events.rs`).
- **Serialisierung:** Wenn Events über IPC-Grenzen (z.B. D-Bus) gesendet werden sollen, müssen sie `serde::Serialize` und `serde::Deserialize` implementieren.

### 2.4. Fehlertypen (Modulspezifisch)

Jedes Hauptmodul innerhalb der Domänenschicht sollte seine eigenen spezifischen Fehler-Enums definieren, um präzise Fehlerinformationen zu liefern.

- **Beispiele:** Die bereits bei den Services definierten Fehler (`ThemingError`, `WorkspaceManagerError`, `AIInteractionError`, `NotificationError`, `GlobalSettingsError`).
- **Implementierungsrichtlinien:**
    - Verwendung des `thiserror`-Crates für eine ergonomische Definition.
    - Jeder Fehlertyp in einer eigenen Datei (z.B. `domain/src/theming/error.rs`).
    - Fehlervarianten sollten klare und spezifische Fehlerzustände des Moduls beschreiben.
    - Wo sinnvoll, sollten Quellfehler (`#[source]`) oder Konvertierungen (`#[from]`) für Fehler aus der Kernschicht oder anderen Abhängigkeiten bereitgestellt werden, um die Fehlerkette zu erhalten.
- **Verwendung:** Domänenservices geben diese spezifischen Fehler in ihren `Result`-Typen zurück. Die System- und UI-Schicht behandeln diese Fehler oder leiten sie ggf. weiter, eventuell gewrappt in ihre eigenen, allgemeineren Fehlertypen.

---

## 3. Schicht: Systemschicht (System Layer)

Die Systemschicht stellt der UI-Schicht systemnahe Dienste und Ereignisse zur Verfügung und setzt deren Befehle technisch um. Sie interagiert direkt mit dem Betriebssystem, der Hardware (über Abstraktionen wie DRM/GBM, libinput), Systemdiensten (via D-Bus, PipeWire) und dem Wayland-Compositor-Backend (Smithay). Sie konsumiert APIs der Domänenschicht, um Geschäftslogik anzuwenden und Zustände abzufragen.

Diese Schicht ist die Brücke zwischen der abstrakten Domänenlogik von NovaDE und den konkreten Realitäten des Betriebssystems und der Hardware. Hier finden viele der FFI-Aufrufe, IPC-Kommunikation und Interaktionen auf niedriger Ebene statt. Smithay wird intensiv für Wayland-bezogene Komponenten genutzt. Eine robuste Fehlerbehandlung ist entscheidend, um Fehler von niedriger Ebene in abstraktere `SystemError`-Typen oder spezifische Unterfehler zu übersetzen. Die asynchrone Natur vieler Operationen (IPC, Hardwareinteraktion) ist hier kritisch.

### 3.1. Modul: `system::compositor` (Smithay-basierter Wayland Compositor Kern)

Dieses Modul ist das Herzstück der grafischen Darstellung und Fensterverwaltung in NovaDE. Es basiert auf der Smithay-Bibliothek und implementiert die Kernfunktionalitäten eines Wayland-Compositors.

- **Abhängigkeiten:** `smithay`, `wayland-server`, `wayland-protocols`, `calloop`, `input` (libinput-rs), `drm-rs`, `gbm-rs`, `libloading` (für EGL).
- **Verzeichnis:** `system/src/compositor/`

#### 3.1.1. `NovaDeSystemState` Struktur (Hauptzustand für Smithay Handler)

Diese Struktur dient als zentraler Datenhalter für den Event-Loop und implementiert die verschiedenen Handler-Traits von Smithay.

- **Datei:** `system/src/state.rs` (oder `system/src/compositor/state.rs`, je nach Gesamtstruktur)
- **Felder (Beispiele, basierend auf typischer Smithay-Nutzung und NovaDE-Anforderungen):**
    
    Rust
    
    ```
    use smithay::{
        backend::{
            allocator::dmabuf::DmabufState, // [50]
            drm::DrmDeviceFd, // [19, 24, 56, 62, 69, 93, 305, 388]
            egl::{EGLContext, EGLDisplay}, // [16, 26, 62, 65, 94, 97]
            renderer::{
                gles::GlesRenderer, // [16, 40, 62, 94, 97]
                multigpu::{gbm::GbmGlesBackend, GpuManager}, // [24, 28, 40, 62, 97, 145, 222]
            },
            libinput::LibinputInputBackend, // [23, 75, 382]
            udev::{UdevBackend, UdevEvent}, // [37]
            session::{Session, Signal as SessionSignal, logind::LogindSession}, // [362, 391]
            input::Seat,
        },
        desktop::{Space, Window, PopupManager, layer_map_for_output, LayerSurface}, // [67]
        input::{SeatState, SeatHandler, pointer::PointerHandle, keyboard::KeyboardHandle, touch::TouchHandle, SeatName},
        output::Output,
        reexports::{
            calloop::{EventLoop, LoopHandle, LoopSignal},
            wayland_server::{Display, DisplayHandle, Client,backend::GlobalId},
            wayland_protocols::xdg::shell::server::xdg_wm_base,
        },
        utils::{Clock, Logical, Point, Rectangle, Serial, Transform, SERIAL_COUNTER},
        wayland::{
            buffer::BufferHandler, // [353]
            compositor::{CompositorState, CompositorHandler, CompositorClientState, SurfaceData}, // [17, 87, 99]
            dmabuf::DmabufHandler, // [50]
            output::{OutputHandler, OutputManagerState}, // [49, 147, 280, 370, 372, 392]
            presentation::PresentationState, // [274]
            seat::WaylandSeatData,
            shell::{
                xdg::{XdgShellState, XdgShellHandler, XdgShellSurfaceUserData, XdgWmBaseUserData, decoration::XdgDecorationState}, // [13, 31, 54, 81, 167, 176, 191, 195, 199, 204, 207, 208, 215, 223, 224, 225, 227, 317, 323, 336, 349, 350, 393, 394, 395, 396, 397, 398, 399, 400]
                wlr_layer::{WlrLayerShellState, LayerShellHandler, LayerSurfaceData}, // [11, 19, 20, 41, 48, 57, 66, 67, 71, 91, 92, 95, 160, 192, 254, 292, 307, 318, 347, 401, 402]
            },
            shm::{ShmState, ShmHandler}, // [141, 165]
            selection::{
                data_device::{DataDeviceState, DataDeviceHandler}, // [11, 12, 19, 35, 44, 45, 73, 80, 141, 216, 403, 404, 405, 406]
                primary_selection::{PrimarySelectionState, PrimarySelectionHandler}, // [30, 120]
            },
            input_method::{InputMethodManagerState, InputMethodHandler, InputMethodKeyboardUserData}, // [11, 34, 35, 117, 253, 264, 268, 407, 408, 409, 410, 411]
            text_input::{TextInputManagerState, TextInputHandler, TextInputUserData}, // [86, 112, 328, 412, 413, 414]
            viewporter::ViewporterState, // [371]
            xdg_activation::XdgActivationState, // [303]
            foreign_toplevel::ForeignToplevelState, // [335]
            idle_notify::IdleNotifierState, // [58]
            explicit_synchronization::ExplicitSyncState, // [415]
            drm_lease::DrmLeaseState, // [107]
            server_decoration::ServerDecorationManagerState, // [297]
        },
        xwayland::{XWayland, XWaylandEvent, XWaylandClientData, xwm::{X11Wm, XwmHandler, X11Surface}}, // [11, 14, 19, 21, 32, 35, 36, 41, 43, 52, 60, 76, 78, 85, 117, 141, 219, 270, 310, 329, 339, 361, 363, 377, 416, 417]
    };
    use std::{collections::HashMap, sync::{Arc, Mutex}};
    use crate::system::dbus::DBusConnectionManager; // Für D-Bus Interaktionen
    use crate::system::audio::PipeWireClientService; // Für PipeWire
    use crate::domain::services::DomainLayerServices; // Wrapper für Domain-Service-Handles
    
    pub struct NovaDeSystemState {
        pub display_handle: DisplayHandle,
        pub event_loop_handle: LoopHandle<'static, Self>,
        pub loop_signal: LoopSignal,
        pub clock: Clock, // Für Timings, Animationen
    
        // Core Wayland protocol states
        pub compositor_state: Arc<Mutex<CompositorState>>,
        pub shm_state: Arc<Mutex<ShmState>>,
        pub output_manager_state: Arc<Mutex<OutputManagerState>>,
        pub seat_state: Arc<Mutex<SeatState<Self>>>,
        pub data_device_state: Arc<Mutex<DataDeviceState>>,
        pub primary_selection_state: Arc<Mutex<PrimarySelectionState>>,
    
        // Shells
        pub xdg_shell_state: Arc<Mutex<XdgShellState>>,
        pub layer_shell_state: Arc<Mutex<WlrLayerShellState>>,
        pub xdg_decoration_state: Arc<Mutex<XdgDecorationState>>,
        // Optional: xwayland_shell_state if using Smithay's xwayland shell helpers
    
        // Input related
        pub text_input_manager_state: Arc<Mutex<TextInputManagerState>>,
        pub input_method_manager_state: Arc<Mutex<InputMethodManagerState>>,
    
        // Optional Wayland protocol states
        pub presentation_time_state: Option<Arc<Mutex<PresentationState>>>,
        pub viewporter_state: Option<Arc<Mutex<ViewporterState>>>,
        pub xdg_activation_state: Option<Arc<Mutex<XdgActivationState>>>,
        pub foreign_toplevel_state: Option<Arc<Mutex<ForeignToplevelState>>>,
        pub idle_notifier_state: Option<Arc<Mutex<IdleNotifierState<Self>>>>,
        pub explicit_sync_state: Option<Arc<Mutex<ExplicitSyncState>>>,
        pub drm_lease_state: Option<Arc<Mutex<DrmLeaseState>>>,
        pub server_decoration_manager_state: Option<Arc<Mutex<ServerDecorationManagerState>>>,
    
        // Backend specific states
        pub udev_backend_data: Option<UdevBackendData>, // If using udev backend
        pub winit_data: Option<WinitData>, // If using winit backend
        pub x11_data: Option<X11BackendData>, // If using X11 backend (as a client)
    
        // XWayland
        pub xwayland: Option<XWayland>,
        pub xwm: Option<Arc<Mutex<X11Wm>>>, // X11 Window Manager for XWayland
        pub xwayland_client_data_id: Option<u32>, // To identify XWayland's client
    
        // Desktop management
        pub space: Arc<Mutex<Space<WindowElement>>>, // Manages windows and outputs
        pub popup_manager: Arc<Mutex<PopupManager>>,
    
        // Input devices
        pub seat_name: String,
        pub seat: Seat<Self>,
        pub pointer: PointerHandle<Self>,
        pub keyboard: KeyboardHandle<Self>,
        pub touch: Option<TouchHandle<Self>>, // Touch ist optional
    
        // Domain Layer Access
        pub domain_services: Arc<DomainLayerServices>,
    
        // System Services Clients
        pub dbus_conn_manager: Arc<DBusConnectionManager>,
        pub pipewire_service: Arc<PipeWireClientService>,
    
        // Internal state
        pub running: std::sync::atomic::AtomicBool,
        pub active_workspace_id: Option<crate::domain::workspaces::WorkspaceId>,
        // Weitere anwendungsspezifische Zustände
    }
    
    // Hilfsstrukturen für Backend-spezifische Daten
    pub struct UdevBackendData {
        pub session: LogindSession, // Oder eine andere Session-Implementierung
        pub gpus: GpuManager<GbmGlesBackend<GlesRenderer, DrmDeviceFd>>,
        pub primary_gpu: DrmDeviceFd,
        pub udev_backend: UdevBackend,
        // Weitere DRM/GBM/EGL spezifische Zustände
    }
    pub struct WinitData { /*... relevante Winit-Felder... */ }
    pub struct X11BackendData { /*... relevante X11-Backend-Felder... */ }
    
    // WindowElement (Beispiel, muss an NovaDE angepasst werden)
    #
    pub enum WindowElement {
        Wayland(Window), // Smithay's Window für XDG Toplevels
        X11(X11Surface), // Smithay's X11Surface
        Layer(LayerSurface), // Smithay's LayerSurface
    }
    // Implementiere notwendige Traits für WindowElement (z.B. RenderElement, SpaceElement)
    ```
    
    - Der Compositor ist das komplexeste Element der Systemschicht. Smithay 8 stellt Bausteine bereit, aber die eigentliche Fensterverwaltungslogik (Tiling, Stacking, Fokusrichtlinien basierend auf Domänenregeln) muss hier implementiert werden. Die `AnvilState` aus Smithays Anvil-Compositor dient als gute Referenz für die Strukturierung von `NovaDeSystemState` und die Integration verschiedener Smithay-Handler.

#### 3.1.2. Initialisierung (`system::compositor::initialize_compositor`)

- **Datei:** `system/src/compositor/init.rs`
- **Signatur:** `pub async fn initialize_compositor(domain_services: Arc<DomainLayerServices>, event_loop_handle: LoopHandle<'static, NovaDeSystemState>, loop_signal: LoopSignal) -> Result<NovaDeSystemState, SystemError>`
- **Schritte:**
    1. Erstelle `DisplayHandle` aus dem globalen `Display` Objekt (Annahme: `Display` wird im `main` erstellt und `DisplayHandle` wird hierher übergeben oder `NovaDeSystemState` wird direkt im `main` erstellt).
    2. Initialisiere Smithay-Backends (z.B. `LibinputInputBackend` 23, `UdevBackend` 37, DRM/GBM/EGL 16). Die Wahl des Backends (DRM/libseat für Bare-Metal, Winit/X11 für verschachtelte Entwicklung) ist eine wichtige architektonische Entscheidung. Die Implementierung sollte dies abstrahieren.
    3. Initialisiere alle relevanten Wayland-Globale unter Verwendung ihrer

---

# NovaDE Interner Schnittstellen-Implementierungsleitfaden

Dieser Implementierungsleitfaden definiert die ultrafeinen Spezifikationen und hochdetaillierten Implementierungspläne für jede Schicht der Linux-Desktop-Umgebung "NovaDE". Er ist so detailliert konzipiert, dass Entwickler ihn direkt zur Implementierung verwenden können, ohne eigene Entscheidungen treffen oder Logiken/Algorithmen entwerfen zu müssen.

---

## 1. Schicht: Kernschicht (Core Layer)

Die Kernschicht (Core Layer) bildet das Fundament von NovaDE und stellt grundlegende, universell einsetzbare Bausteine und Dienste bereit, die von allen darüberliegenden Schichten – der Domänenschicht, der Systemschicht und der Benutzeroberflächenschicht (UI-Schicht) – genutzt werden. Die Kommunikation mit höheren Schichten erfolgt durch die direkte Verwendung der hier definierten Typen und Funktionen.

### 1.1. Modul: `core::types`

Dieses Modul definiert grundlegende Datentypen, die systemweit für geometrische Berechnungen, Farbdarstellungen und andere fundamentale Konzepte verwendet werden.

- **Verzeichnis:** `core/src/types/`

#### 1.1.1. `Point<T>` Struktur

Stellt einen Punkt im 2D-Raum dar.

- Datei: `core/src/types/point.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Point<T, U> {
        pub x: T,
        pub y: T,
        _unit: std::marker::PhantomData<U>,
    }
    
    impl<T: Default, U> Default for Point<T, U> {
        fn default() -> Self {
            Point { x: Default::default(), y: Default::default(), _unit: std::marker::PhantomData }
        }
    }
    
    // U kann z.B. Logical, Physical, BufferCoords sein
    pub struct Logical;
    pub struct Physical;
    pub struct BufferCoords;
    
    impl<T, U> Point<T, U> {
        pub const fn new(x: T, y: T) -> Self {
            Point { x, y, _unit: std::marker::PhantomData }
        }
    }
    
    // Weitere Methoden wie Add, Sub, etc. können implementiert werden.
    ```
    
- Verwendung: Positionierung von UI-Elementen, Fensterkoordinaten.

#### 1.1.2. `Size<T>` Struktur

Stellt die Dimensionen (Breite und Höhe) eines 2D-Objekts dar.

- Datei: `core/src/types/size.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Size<T, U> {
        pub w: T,
        pub h: T,
        _unit: std::marker::PhantomData<U>,
    }
    
    impl<T: Default, U> Default for Size<T, U> {
        fn default() -> Self {
            Size { w: Default::default(), h: Default::default(), _unit: std::marker::PhantomData }
        }
    }
    
    impl<T, U> Size<T, U> {
        pub const fn new(w: T, h: T) -> Self {
            Size { w, h, _unit: std.marker::PhantomData }
        }
    }
    ```
    
- Verwendung: Fenstergrößen, UI-Element-Dimensionen.

#### 1.1.3. `Rect<T>` und `RectInt` Strukturen

Stellt ein Rechteck im 2D-Raum dar, definiert durch Position und Größe.

- Datei: `core/src/types/rect.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Rect<T, U> {
        pub loc: Point<T, U>,
        pub size: Size<T, U>,
    }
    
    impl<T: Default, U> Default for Rect<T, U> {
        fn default() -> Self {
            Rect { loc: Default::default(), size: Default::default() }
        }
    }
    
    impl<T, U> Rect<T, U> {
        pub const fn new(loc: Point<T, U>, size: Size<T, U>) -> Self {
            Rect { loc, size }
        }
        // Methoden wie contains_point, intersection, etc.
    }
    
    pub type RectInt = Rect<i32, Logical>; // Beispiel für einen häufigen Typ
    ```
    
- Verwendung: Fenstergeometrien, Auswahlbereiche.

#### 1.1.4. `Color` Struktur

Repräsentiert eine Farbe im RGBA-Format.

- Datei: `core/src/types/color.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Color {
        pub r: f32, // Range 0.0 to 1.0
        pub g: f32, // Range 0.0 to 1.0
        pub b: f32, // Range 0.0 to 1.0
        pub a: f32, // Range 0.0 to 1.0 (alpha)
    }
    
    impl Color {
        pub const fn new(r: f32, g: f32, b: f32, a: f32) -> Self {
            Color { r, g, b, a }
        }
    
        pub fn to_hex_rgb(&self) -> String {
            format!(
                "#{:02x}{:02x}{:02x}",
                (self.r * 255.0) as u8,
                (self.g * 255.0) as u8,
                (self.b * 255.0) as u8
            )
        }
    
        pub fn to_hex_rgba(&self) -> String {
            format!(
                "#{:02x}{:02x}{:02x}{:02x}",
                (self.r * 255.0) as u8,
                (self.g * 255.0) as u8,
                (self.b * 255.0) as u8,
                (self.a * 255.0) as u8
            )
        }
        // Ggf. From-Implementierungen für gängige Formate (z.B. String "#RRGGBB")
    }
    ```
    
- Verwendung: Theming, UI-Elementfarben.

#### 1.1.5. `Orientation` Enum

Definiert die Ausrichtung von UI-Elementen oder Layouts.

- Datei: `core/src/types/orientation.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub enum Orientation {
        Horizontal,
        Vertical,
    }
    ```
    
- Verwendung: Layout-Manager, Ausrichtung von Bedienelementen.

#### 1.1.6. `uuid::Uuid` Integration

Universell eindeutige Identifikatoren.

- Datei: `core/src/types/mod.rs` (als Re-Export)
- Re-Export: `pub use uuid::Uuid;`
- Abhängigkeit in `core/Cargo.toml`: `uuid = { version = "1.0", features = ["v4", "serde"] }`
    - Die Features `v4` und `serde` sind essenziell. `v4` ermöglicht die Generierung zufälliger UUIDs, die für die eindeutige Identifizierung von Entitäten wie Fenstern, Workspaces oder Benachrichtigungen unerlässlich sind. `serde` wird benötigt, falls diese IDs in Konfigurationsdateien persistiert oder über IPC-Schnittstellen serialisiert werden müssen, was in einer Desktop-Umgebung sehr wahrscheinlich ist.1
- Verwendung: Eindeutige Identifizierung von Ressourcen systemweit.

#### 1.1.7. `chrono::DateTime<Utc>` Integration

Zeitstempel mit UTC-Zeitzone.

- Datei: `core/src/types/mod.rs` (als Re-Export)
- Re-Export: `pub use chrono::{DateTime, Utc};`
- Abhängigkeit in `core/Cargo.toml`: `chrono = { version = "0.4", features = ["serde"] }`
    - `chrono` ist der De-facto-Standard für Datums- und Zeitmanipulationen in Rust. Die Verwendung von `DateTime<Utc>` stellt zeitzonenagnostische Zeitstempel sicher, was für interne Repräsentationen als Best Practice gilt, um Komplexitäten bei der Zeitzonenbehandlung zu vermeiden. Das `serde`-Feature ist notwendig, wenn Zeitstempel persistiert (z.B. in Logdateien oder Konfigurationen) oder serialisiert werden sollen.3
- Verwendung: Zeitstempel für Logging, Events, "zuletzt geändert"-Informationen.

#### 1.1.8. Implementierungsschritte für `core::types`

1. Erstellen Sie das Verzeichnis `core/src/types/`.
2. Implementieren Sie `point.rs`, `size.rs`, `rect.rs`, `color.rs`, und `orientation.rs` gemäß den obigen Spezifikationen.
3. Fügen Sie `uuid` (mit Features "v4", "serde") und `chrono` (mit Feature "serde") zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
4. Fügen Sie die Re-Exports für `Uuid` und `DateTime<Utc>` in `core/src/types/mod.rs` hinzu. Alle lokalen Typen (Point, Size, etc.) sollten ebenfalls von `mod.rs` re-exportiert werden.
    
    Rust
    
    ```
    // core/src/types/mod.rs
    mod color;
    mod orientation;
    mod point;
    mod rect;
    mod size;
    
    pub use chrono::{DateTime, Utc};
    pub use color::Color;
    pub use orientation::Orientation;
    pub use point::{BufferCoords, Logical, Physical, Point};
    pub use rect::{Rect, RectInt};
    pub use size::Size;
    pub use uuid::Uuid;
    ```
    

### 1.2. Modul: `core::errors`

Dieses Modul stellt eine Basis-Fehlerbehandlungsstrategie und den `CoreError`-Typ bereit. Höhere Schichten können `CoreError` oder spezifischere Fehler aus Kernmodulen mittels `#[from]` oder `#[source]` in ihre eigenen Fehlertypen wrappen, wobei die Fehlerursachenkette (`source()`) beibehalten wird.

- **Verzeichnis:** `core/src/`
- Datei: `core/src/errors.rs`

#### 1.2.1. `CoreError` Enum

- Definition unter Verwendung von `thiserror`:
    
    Rust
    
    ```
    #
    pub enum CoreError {
        #[error("I/O error: {source}")]
        Io {
            #[from]
            source: std::io::Error,
            // Optional: context: String, // Um zusätzlichen Kontext zur IO-Operation zu geben
        },
    
        #[error("Configuration parsing error from '{path:?}': {message}")]
        ConfigParse {
            path: Option<std::path::PathBuf>,
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #
        Serialization {
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #
        Deserialization {
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #[error("Invalid path: {path:?}")]
        InvalidPath { path: std::path::PathBuf },
    
        #[error("Initialization failed for module: {module_name}")]
        InitializationFailed {
            module_name: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #[error("Feature not implemented: {feature_name}")]
        NotImplemented { feature_name: String },
    
        #[error("Internal error: {message}")]
        Internal { message: String },
    
        #[error("Operation timed out: {operation}")]
        Timeout { operation: String },
    
        #[error("Permission denied for operation: {operation}")]
        PermissionDenied { operation: String },
    }
    ```
    
    Die Verwendung von `thiserror` 5 ist entscheidend für die Erstellung ergonomischer und informativer Fehlertypen. Das Attribut `#[from]` ermöglicht eine einfache Konvertierung von Standardbibliotheksfehlern wie `std::io::Error`. Das Attribut `#[source]` (implizit von `thiserror` verwendet, wenn ein Feld `#[from]` oder explizit `#[source]` ist) ist entscheidend für die Beibehaltung der Fehlerursachenkette, wie in der Spezifikation hervorgehoben. Eine robuste Fehlerbehandlungsstrategie ist fundamental. `thiserror` vereinfacht die Erstellung benutzerdefinierter Fehlertypen, die gut mit dem `Error`-Trait von Rust integriert sind. Die Beibehaltung der `source()`-Kette ist für das Debugging unerlässlich, da sie es Entwicklern ermöglicht, einen Fehler bis zu seinem Ursprung zurückzuverfolgen, selbst wenn er von verschiedenen Schichten mehrfach umgebrochen wird.

#### 1.2.2. Fehlerpropagierungsstrategie

Alle Funktionen in der Kernschicht, die fehlschlagen können, MÜSSEN `Result<T, CoreError>` oder `Result<T, SpecificCoreSubError>` zurückgeben, wobei `SpecificCoreSubError` via `#[from]` in `CoreError` konvertierbar sein sollte. Höhere Schichten definieren ihre eigenen Fehler-Enums (z.B. `DomainError`, `SystemError`, `UIError`) und verwenden `#[from] CoreError` oder `#[source] CoreError`, um Fehler aus dem Kern zu wrappen.

#### 1.2.3. Implementierungsschritte für `core::errors`

1. Fügen Sie `thiserror = "1.0"` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Implementieren Sie `core/src/errors.rs` mit dem `CoreError`-Enum wie oben spezifiziert.
3. Stellen Sie sicher, dass alle Module der Kernschicht `CoreError` für ihre Fehlerberichterstattung verwenden.

### 1.3. Modul: `core::logging`

Dieses Modul definiert die Logging-Infrastruktur basierend auf dem `tracing`-Crate. Alle höheren Schichten verwenden die `tracing`-Makros für ihre Logging-Ausgaben.

- **Verzeichnis:** `core/src/`
- Datei: `core/src/logging.rs`

#### 1.3.1. `initialize_logging()` Funktion

- Signatur:
    
    Rust
    
    ```
    pub fn initialize_logging(
        level_filter: tracing::Level,
        use_json: bool,
        custom_writer: Option<Box<dyn Fn() -> Box<dyn std::io::Write + Send + Sync + 'static> + Send + Sync + 'static>>
    ) -> Result<(), CoreError>
    ```
    
    - `level_filter`: Der minimale Log-Level, der aufgezeichnet werden soll (z.B. `tracing::Level::INFO`, `tracing::Level::DEBUG`).
    - `use_json`: Wenn `true`, werden Logs im JSON-Format ausgegeben, andernfalls in einem menschenlesbaren Format.
    - `custom_writer`: Eine optionale Funktion, die einen Writer für die Log-Ausgabe zurückgibt (z.B. in eine Datei, einen Netzwerk-Socket oder `std::io::stderr`). Standardmäßig wird `std::io::stderr` verwendet. Die Funktion wird verwendet, um den Writer bei Bedarf neu erstellen zu können (z.B. bei Log-Rotation).
- Implementierung:
    1. Verwendet `tracing_subscriber::fmt()` für die formatierte Protokollierung.
    2. Ermöglicht die Konfiguration des Formats (JSON oder "pretty") und des Writers.
        - Für JSON: `tracing_subscriber::fmt().json().with_writer(writer_closure).init();`
        - Für Pretty: `tracing_subscriber::fmt().pretty().with_writer(writer_closure).init();`
    3. Konfiguriert den `EnvFilter` basierend auf `level_filter` oder einer Umgebungsvariable (z.B. `RUST_LOG`).
    4. Richtet einen globalen Standard-Subscriber ein mittels `tracing::subscriber::set_global_default`.
    5. Gibt `Result<(), CoreError>` zurück, um Initialisierungsfehler zu signalisieren (z.B. wenn das Setzen des globalen Subscribers fehlschlägt).
- Die Standardisierung auf `tracing` ermöglicht eine strukturierte Protokollierung über alle Schichten hinweg, was für das Debugging und die Überwachung eines komplexen Systems wie einer Desktop-Umgebung von unschätzbarem Wert ist. Die Möglichkeit, zwischen menschenlesbaren und JSON-Formaten zu wechseln, ist gut für Entwicklung versus Produktion/Log-Aggregation. `tracing` bietet ein leistungsfähigeres und flexibleres Logging-Framework als das ältere `log`-Crate, insbesondere durch sein Konzept von Spans für kontextbezogene Protokollierung. Dies ist in einem mehrschichtigen, ereignisgesteuerten System von großem Vorteil.

#### 1.3.2. Verwendung von `tracing`-Makros

Alle Schichten verwenden die Makros `trace!`, `debug!`, `info!`, `warn!`, `error!` aus dem `tracing`-Crate. Spans (`span!`, `info_span!`, etc.) sollten verwendet werden, um kontextuelle Informationen für zusammengehörige Log-Meldungen bereitzustellen.

- Beispiel: `info!(target: "core::config", path = %file_path.display(), "Lade Kernkonfiguration.");`
- Beispiel mit Span:
    
    Rust
    
    ```
    let workspace_span = info_span!("workspace_operation", id = %workspace_id);
    let _enter = workspace_span.enter();
    //... Operationen innerhalb des Spans...
    info!("Operation abgeschlossen");
    ```
    

#### 1.3.3. Implementierungsschritte für `core::logging`

1. Fügen Sie `tracing = "0.1"` und `tracing_subscriber = { version = "0.3", features = ["fmt", "json", "env-filter"] }` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Implementieren Sie `core/src/logging.rs` mit der Funktion `initialize_logging()` wie oben spezifiziert.

### 1.4. Modul: `core::config`

Dieses Modul stellt Primitive zum Laden, Parsen und Zugreifen auf Kernkonfigurationen bereit. Es definiert die Struktur `CoreConfig` und Funktionen für deren Verwaltung.

- **Verzeichnis:** `core/src/config/`

#### 1.4.1. `CoreConfig` Struktur

Definiert die Kernkonfigurationseinstellungen.

- Datei: `core/src/config/types.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct CoreConfig {
        pub log_level: String, // z.B. "info", "debug", "trace"
        pub log_format: LogFormat,
        pub default_theme_name: Option<String>,
        pub enable_xwayland: bool,
        // Weitere kernspezifische Konfigurationen, z.B. Pfade, Feature-Flags
    }
    
    #
    #[serde(rename_all = "lowercase")]
    pub enum LogFormat {
        Json,
        Pretty,
    }
    
    impl Default for CoreConfig {
        fn default() -> Self {
            CoreConfig {
                log_level: "info".to_string(),
                log_format: LogFormat::Pretty,
                default_theme_name: Some("NovaDark".to_string()),
                enable_xwayland: true,
            }
        }
    }
    ```
    

#### 1.4.2. `ConfigError` Enum

Spezifische Fehler für das Laden und Verarbeiten von Konfigurationen.

- Datei: `core/src/config/error.rs`
- Definition:
    
    Rust
    
    ```
    use crate::core::errors::CoreError; // Assuming CoreError is in crate::core
    
    #
    pub enum ConfigError {
        #[error("Failed to determine config directory: {0}")]
        DirectoryResolutionError(String),
    
        #[error("Config file not found at {path:?}")]
        FileNotFound { path: std::path::PathBuf },
    
        #[error("Failed to read config file {path:?}")]
        FileReadError {
            path: std::path::PathBuf,
            #[source]
            source: std::io::Error,
        },
    
        #
        TomlParseError {
            path: std::path::PathBuf,
            message: String,
            #[source]
            source: Option<toml::de::Error>,
        },
        // Ggf. JsonParseError, falls JSON auch unterstützt wird
    
        #[error("Configuration not loaded or initialization failed.")]
        NotLoaded,
    
        #[error("Invalid configuration value for key '{key}': {message}")]
        InvalidValue { key: String, message: String },
    
        #[error("Failed to write default config to {path:?}")]
        DefaultConfigWriteError {
            path: std::path::PathBuf,
            #[source]
            source: std::io::Error,
        },
    
        #
        DefaultConfigTomlError(#[from] toml::ser::Error),
    
        #[error(transparent)]
        Core(#[from] CoreError), // Um CoreError wrappen zu können
    }
    ```
    

#### 1.4.3. Globale Konfigurationsvariable

Verwendet `once_cell` für eine thread-sichere, einmalig initialisierte globale Konfiguration.

- Datei: `core/src/config/mod.rs` (oder `core/src/config/global.rs`)
    
    Rust
    
    ```
    use once_cell::sync::OnceCell;
    use std::sync::RwLock;
    use super::types::CoreConfig; // Pfad anpassen
    use super::error::ConfigError; // Pfad anpassen
    
    static CORE_CONFIG: OnceCell<RwLock<CoreConfig>> = OnceCell::new();
    ```
    

#### 1.4.4. `load_core_config()` Funktion

Lädt die Kernkonfiguration aus einer Datei.

- Datei: `core/src/config/loader.rs`
- Signatur: `pub fn load_core_config(custom_path: Option<std::path::PathBuf>) -> Result<(), ConfigError>`
- Implementierung:
    
    1. Bestimme den Konfigurationsdateipfad:
        - Verwende `custom_path`, falls angegeben.
        - Andernfalls suche im XDG-Standardverzeichnis (z.B. `$XDG_CONFIG_HOME/nova-de/core.toml`) mittels `directories_next::ProjectDirs`.
        - Falls kein XDG-Verzeichnis gefunden wird, verwende einen Fallback-Pfad (z.B. `~/.config/nova-de/core.toml`).
    2. Wenn die Datei nicht existiert, erstelle eine Standardkonfiguration (`CoreConfig::default()`) und speichere sie unter dem ermittelten Pfad. Logge diesen Vorgang.
    3. Lese den Dateiinhalt. Bei Fehler `ConfigError::FileReadError`.
    4. Parse den Inhalt (z.B. TOML) in eine `CoreConfig`-Instanz. Bei Fehler `ConfigError::TomlParseError`.
    5. Initialisiere die globale `CORE_CONFIG` Variable mit der geladenen Konfiguration: `CORE_CONFIG.set(RwLock::new(loaded_config)).map_err(|_| ConfigError::NotLoaded)` (Fehlerbehandlung für den Fall, dass `set` fehlschlägt, was nur passiert, wenn bereits initialisiert).
    6. Gibt `Ok(())` bei Erfolg zurück.
    
    - Eine globale, statisch zugängliche Konfiguration ist üblich, erfordert aber eine sorgfältige Verwaltung, insbesondere bei der Initialisierung. `once_cell` für die Lazy-Initialisierung und `RwLock` für den threadsicheren Zugriff sind ein gutes Muster. Die Konfiguration muss früh im Anwendungslebenszyklus verfügbar sein und von verschiedenen Teilen des Systems zugänglich sein. `once_cell` stellt sicher, dass das Laden nur einmal erfolgt.

#### 1.4.5. `get_core_config()` Funktion

Bietet globalen Lesezugriff auf die geladene `CoreConfig`.

- Datei: `core/src/config/access.rs`
- Signatur: `pub fn get_core_config() -> Result<std::sync::RwLockReadGuard<'static, CoreConfig>, ConfigError>`
- Implementierung:
    1. Versuche, einen Read-Lock auf `CORE_CONFIG` zu erhalten: `CORE_CONFIG.get().ok_or(ConfigError::NotLoaded)?.read().map_err(|_| ConfigError::NotLoaded)` (Fehlerbehandlung für Poisoned Lock).
    2. Gibt den `RwLockReadGuard` bei Erfolg zurück.

#### 1.4.6. `update_core_config()` Funktion (Optional)

Ermöglicht die dynamische Aktualisierung der Kernkonfiguration zur Laufzeit.

- Datei: `core/src/config/access.rs`
- Signatur: `pub fn update_core_config(new_config: CoreConfig) -> Result<(), ConfigError>`
- Implementierung:
    1. Versuche, einen Write-Lock auf `CORE_CONFIG` zu erhalten.
    2. Aktualisiere die Konfiguration.
    3. Persistiert die neue Konfiguration in die Datei.
    4. **Wichtig:** Benachrichtige relevante Systemteile über die Konfigurationsänderung (z.B. über ein Event). Dies erfordert sorgfältige Überlegungen zur Thread-Sicherheit und wie Komponenten auf dynamische Änderungen reagieren.

#### 1.4.7. Implementierungsschritte für `core::config`

1. Fügen Sie `serde = { version = "1.0", features = ["derive"] }`, `toml = "0.8"`, `once_cell = "1.19"`, `directories-next = "2.0"` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Erstellen Sie die Verzeichnisstruktur `core/src/config/`.
3. Definieren Sie `CoreConfig` und `LogFormat` in `core/src/config/types.rs`.
4. Definieren Sie `ConfigError` in `core/src/config/error.rs`.
5. Implementieren Sie `loader.rs` (mit `load_core_config`) und `access.rs` (mit `get_core_config` und optional `update_core_config`).
6. Fügen Sie die globale `CORE_CONFIG`-Variable in `core/src/config/mod.rs` oder einer dedizierten `global.rs` ein und exportieren Sie die öffentlichen Funktionen.

### 1.5. Modul: `core::utils`

Dieses Modul bietet allgemeine Hilfsfunktionen, die von allen höheren Schichten genutzt werden können.

- **Verzeichnis:** `core/src/utils/`
- **Struktur:** Das Modul sollte in thematische Untermodule aufgeteilt werden, um die Übersichtlichkeit zu wahren.

#### 1.5.1. Untermodul: `core::utils::file_utils`

- Datei: `core/src/utils/file_utils.rs`
- Funktionen:
    - `pub fn read_file_to_string(path: &std::path::Path) -> Result<String, CoreError>`
        - Implementierung: Verwendet `std::fs::read_to_string`. Mappt `std::io::Error` auf `CoreError::Io`.
    - `pub fn ensure_dir_exists(path: &std::path::Path) -> Result<(), CoreError>`
        - Implementierung: Verwendet `std::fs::create_dir_all`. Mappt `std::io::Error` auf `CoreError::Io`.
    - `pub fn write_string_to_file(path: &std::path::Path, content: &str) -> Result<(), CoreError>`
        - Implementierung: Verwendet `std::fs::write`. Mappt `std::io::Error` auf `CoreError::Io`.

#### 1.5.2. Untermodul: `core::utils::string_utils`

- Datei: `core/src/utils/string_utils.rs`
- Funktionen:
    - `pub fn sanitize_filename(name: &str) -> String`
        - Implementierung: Ersetzt ungültige Zeichen für Dateinamen (z.B. `/`, `\`, `:`, `*`, `?`, `"`, `<`, `>`, `|`) durch Unterstriche oder entfernt sie.
    - `pub fn truncate_string_with_ellipsis(s: &str, max_len: usize) -> String`
        - Implementierung: Kürzt den String auf `max_len` Zeichen und fügt "..." hinzu, falls er gekürzt wurde. Achtet auf Grapheme Cluster, um Unicode-Zeichen nicht zu zerschneiden.
            
            Rust
            
            ```
            use unicode_segmentation::UnicodeSegmentation;
            //...
            // if s.graphemes(true).count() > max_len {
            //     s.graphemes(true).take(max_len - 3).collect::<String>() + "..."
            // } else {
            //     s.to_string()
            // }
            ```
            
            - Abhängigkeit: `unicode-segmentation = "1.10"`

#### 1.5.3. Untermodul: `core::utils::async_utils` (falls benötigt)

- Datei: `core/src/utils/async_utils.rs`
- Mögliche Funktionen:
    - Wrapper für `tokio::spawn` mit standardisierter Fehlerbehandlung oder Logging.
    - Hilfsfunktionen für Timeout-Management bei asynchronen Operationen.

#### 1.5.4. Implementierungsschritte für `core::utils`

1. Erstellen Sie das Verzeichnis `core/src/utils/`.
2. Erstellen Sie `core/src/utils/mod.rs` und deklarieren Sie die Untermodule:
    
    Rust
    
    ```
    pub mod file_utils;
    pub mod string_utils;
    // pub mod async_utils;
    ```
    
3. Implementieren Sie die Funktionen in den jeweiligen Untermodul-Dateien.
4. Fügen Sie ggf. Abhängigkeiten wie `unicode-segmentation` zu `core/Cargo.toml` hinzu.
5. Das `utils`-Modul kann leicht zu einer Ansammlung unzusammenhängender Funktionen werden. Es ist wichtig, die Organisation beizubehalten und sicherzustellen, dass die Funktionen eine breite Anwendbarkeit haben. Wenn eine Hilfsfunktion sehr spezifisch für eine einzelne Domäne oder ein Systemanliegen ist, sollte sie stattdessen im Hilfsmodul dieser Schicht angesiedelt sein. Eine klare Abgrenzung ist notwendig, um die Kohäsion der Module zu wahren und unnötige Kopplungen zu vermeiden.

---

## 2. Schicht: Domänenschicht (Domain Layer)

Die Domänenschicht kapselt die Geschäftslogik und den Kernzustand der Desktop-Umgebung NovaDE. Sie definiert die zentralen Konzepte, Regeln und Verhaltensweisen des Systems, unabhängig von technischen Implementierungsdetails der System- oder UI-Schicht. Die Kommunikation mit höheren Schichten (System- und UI-Schicht) erfolgt primär über wohldefinierte Service-APIs (als Rust-Traits implementiert) und durch domänenspezifische Events, die Zustandsänderungen signalisieren.

Die Domänenschicht ist zentral für die Funktionalität von NovaDE. Die Verwendung von Rust-Traits für Service-APIs fördert lose Kopplung und Testbarkeit. Ereignisse sind der Schlüssel zur reaktiven Propagierung von Zustandsänderungen. Fehlertypen sollten für jedes Domänenmodul spezifisch sein, um klaren Kontext zu bieten.

### 2.1. Service APIs (Traits)

Öffentliche Schnittstellen der Domänenschicht werden primär durch Rust-Traits definiert. Diese Traits werden von Service-Strukturen innerhalb der Domänenmodule implementiert. Methoden sind typischerweise `async`, wenn sie I/O-Operationen oder potenziell langlaufende Prozesse beinhalten, und geben `Result<T, SpecificDomainError>` zurück.

#### 2.1.1. `domain::theming::ThemingEngine` Trait

Verantwortlich für die Verwaltung und Anwendung von Themes.

- **Datei:** `domain/src/theming/engine.rs`

##### Zugehörige Datenstrukturen und Typen:

- **`ThemingConfiguration` Struct (Wertobjekt):**
    
    - Definiert die vom Benutzer oder System gewählten Theme-Einstellungen.
    - **Datei:** `domain/src/theming/config.rs`
    - **Felder:**
        - `icon_theme_name: String` (z.B. "Adwaita", "Papirus")
        - `gtk_theme_name: String` (z.B. "Adwaita-dark")
        - `cursor_theme_name: String` (z.B. "Adwaita")
        - `font_name: String` (z.B. "Cantarell 11")
        - `wallpaper_path: Option<std::path::PathBuf>`
        - `color_scheme: ColorScheme` (Enum: `Light`, `Dark`, `SystemPreference`)
        - `accent_color: core::types::Color`
    - **Invarianten:** `font_name` darf nicht leer sein, wenn gesetzt.
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`ColorScheme` Enum (Wertobjekt):**
    
    - Definiert die möglichen Farbschemata.
    - **Datei:** `domain/src/theming/config.rs` (oder `types.rs` im Theming-Modul)
    - **Varianten:** `Light`, `Dark`, `SystemPreference`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`AppliedThemeState` Struct (Wertobjekt):**
    
    - Repräsentiert den aktuell angewandten Theme-Zustand, inklusive aufgelöster Werte.
    - **Datei:** `domain/src/theming/state.rs`
    - **Felder:**
        - `current_config: ThemingConfiguration`
        - `resolved_wallpaper_path: Option<std::path::PathBuf>` (absoluter Pfad zum tatsächlich genutzten Hintergrundbild)
        - `font_config_details: String` (z.B. eine Pango-Font-Beschreibung oder Fontconfig-Pattern)
        - `effective_color_scheme: EffectiveColorScheme` (Enum: `Light`, `Dark`)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`EffectiveColorScheme` Enum (Wertobjekt):**
    
    - Repräsentiert das tatsächlich aktive Farbschema (aufgelöst aus `SystemPreference`).
    - **Datei:** `domain/src/theming/state.rs`
    - **Varianten:** `Light`, `Dark`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`ThemingError` Enum (Fehlertyp):**
    
    - Spezifische Fehler für das Theming-Subsystem.
    - **Datei:** `domain/src/theming/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum ThemingError {
            #[error("Invalid theming configuration: {0}")]
            InvalidConfiguration(String),
        
            #[error("Wallpaper not found at path: {0:?}")]
            WallpaperNotFound(std::path::PathBuf),
        
            #[error("Failed to apply theme '{theme_name}': {details}")]
            ThemeApplyFailed {
                theme_name: String,
                details: String,
                #[source]
                source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
            },
        
            #[error("Persistence error during theming operation")]
            PersistenceError(#[from] crate::core::errors::CoreError), // Assuming CoreError is accessible
        
            #[error("Underlying system service error for theming: {0}")]
            SystemServiceError(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn get_current_theme_state(&self) -> Result<AppliedThemeState, ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den aktuell im System angewandten und zwischengespeicherten Theme-Zustand ab.
    - **Vorbedingungen:** Keine.
    - **Nachbedingungen:** Gibt den `AppliedThemeState` zurück oder einen `ThemingError`.
- `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Aktualisiert die Theme-Konfiguration, persistiert sie und stößt die Anwendung des neuen Themes an.
    - **Vorbedingungen:** `new_config` muss valide sein (ggf. interne Validierung).
    - **Nachbedingungen:** Bei Erfolg wird das `ThemeChangedEvent` publiziert. Die Konfiguration wird persistiert (z.B. über `GlobalSettingsService` oder ein dediziertes Persistenz-Interface). Das System-Theme wird (versucht) anzuwenden.
    - **Geschäftsregeln:** Validiert die `new_config`. Löst das Hintergrundbild auf.
- `async fn apply_theme_to_system(&self, theme_state: &AppliedThemeState) -> Result<(), ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** (Potenziell intern, aufgerufen von `update_configuration`, oder als separate Methode für fortgeschrittene Nutzung) Wendet den gegebenen `AppliedThemeState` auf die Systemkomponenten an (z.B. Setzen von GTK-Theme, Icons, Cursor über Systemmechanismen).
    - **Vorbedingungen:** `theme_state` ist valide.
    - **Nachbedingungen:** Theme-Änderungen sind im System (versucht) aktiv.

##### Publizierte Events:

- **`ThemeChangedEvent`:**
    - **Datei:** `domain/src/theming/events.rs`
    - **Struktur:**
        
        Rust
        
        ```
        #
        pub struct ThemeChangedEvent {
            pub new_state: AppliedThemeState,
            pub old_state: Option<AppliedThemeState>, // Optional, falls der vorherige Zustand bekannt ist
        }
        ```
        
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::theming::ThemeChangedEvent`
    - **Typische Publisher:** Die Implementierung von `ThemingEngine`.
    - **Typische Subscriber:** `ui::theming_gtk` (UI-Schicht), `system::compositor` (Systemschicht, falls relevant für Darstellung).

#### 2.1.2. `domain::workspaces::WorkspaceManager` Trait

Verwaltet Workspaces (virtuelle Desktops).

- **Datei:** `domain/src/workspaces/manager.rs`

##### Zugehörige Datenstrukturen und Typen:

- **`WorkspaceId` Typalias:**
    
    - **Datei:** `domain/src/workspaces/types.rs` (oder direkt in `manager.rs`)
    - **Definition:** `pub type WorkspaceId = core::types::Uuid;`
- **`ApplicationIdentifier` Struct (Wertobjekt):**
    
    - Identifiziert eine Anwendung eindeutig.
    - **Datei:** `domain/src/workspaces/app_id.rs`
    - **Felder:**
        - `id_type: ApplicationIdType` (Enum: `DesktopFile`, `WaylandAppId`, `X11WindowClass`)
        - `identifier_str: String` (z.B. "firefox.desktop", "org.gnome.Nautilus", "Firefox")
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `serde::Serialize`, `serde::Deserialize`.
- **`Workspace` Struct (Entität):**
    
    - Repräsentiert einen einzelnen Workspace.
    - **Datei:** `domain/src/workspaces/workspace.rs`
    - **Felder:**
        - `id: WorkspaceId` (Sichtbarkeit: `pub(crate)`, Zugriff über Getter)
        - `name: String` (Sichtbarkeit: `pub`)
        - `output_name: Option<String>` (Name des Monitors, dem der Workspace primär zugeordnet ist, Sichtbarkeit: `pub`)
        - `layout_policy: WorkspaceLayoutPolicy` (Enum: `Tiling`, `Floating`, `Hybrid`, Sichtbarkeit: `pub`)
        - `pinned_applications: std::collections::HashSet<ApplicationIdentifier>` (Sichtbarkeit: `pub(crate)`, Zugriff über Methoden)
        - `creation_timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
        - `last_accessed_timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
    - **Initialwerte:** `id` wird bei Erstellung generiert, `name` z.B. "Workspace 1", `output_name` ist `None`, `layout_policy` wird aus globalen Einstellungen übernommen oder ist Standard (`Floating`), `pinned_applications` ist leer, `creation_timestamp` und `last_accessed_timestamp` sind Zeitpunkte der Erstellung.
    - **Invarianten:** `name` darf nicht leer sein. `id` ist unveränderlich nach Erstellung.
    - **Methoden (Beispiele):**
        - `pub fn new(name: String, layout_policy: WorkspaceLayoutPolicy) -> Self`
        - `pub fn id(&self) -> WorkspaceId`
        - `pub fn add_pinned_app(&mut self, app_id: ApplicationIdentifier) -> bool`
        - `pub fn remove_pinned_app(&mut self, app_id: &ApplicationIdentifier) -> bool`
        - `pub fn is_app_pinned(&self, app_id: &ApplicationIdentifier) -> bool`
        - `pub(crate) fn set_last_accessed(&mut self)`
    - **Beziehungen:** Keine direkten Entitätsbeziehungen in dieser Struktur, aber `pinned_applications` verweist auf `ApplicationIdentifier`.
- **`WorkspaceLayoutPolicy` Enum (Wertobjekt):**
    
    - **Datei:** `domain/src/workspaces/types.rs`
    - **Varianten:** `Tiling`, `Floating`, `Hybrid`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`WorkspaceManagerError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/workspaces/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum WorkspaceManagerError {
            #
            WorkspaceNotFound(super::types::WorkspaceId), // super::types::WorkspaceId
        
            #[error("Workspace with name '{0}' already exists")]
            DuplicateWorkspaceName(String),
        
            #[error("Maximum number of workspaces reached ({0})")]
            MaxWorkspacesReached(usize),
        
            #[error("Cannot delete the last workspace")]
            CannotDeleteLastWorkspace,
        
            #[error("Cannot delete active workspace; switch to another first")]
            CannotDeleteActiveWorkspace,
        
            #[error("Persistence error during workspace operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #[error("Invalid application identifier: {0}")]
            InvalidApplicationId(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn create_workspace(&self, name: Option<String>) -> Result<Workspace, WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Erstellt einen neuen Workspace. Wenn `name` `None` ist, wird ein Standardname generiert (z.B. "Workspace N").
    - **Nachbedingungen:** Bei Erfolg wird `WorkspaceEvent::Created` publiziert. Der neue Workspace wird persistiert.
    - **Geschäftsregeln:** Prüft auf Namenskonflikte und maximale Anzahl von Workspaces.
- `async fn delete_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Löscht den Workspace mit der gegebenen ID.
    - **Vorbedingungen:** Workspace darf nicht der letzte verbleibende sein. Workspace darf nicht der aktive sein (oder es muss eine Logik zum Wechsel des aktiven Workspaces implementiert sein).
    - **Nachbedingungen:** Bei Erfolg wird `WorkspaceEvent::Deleted` publiziert. Änderungen werden persistiert.
- `async fn get_workspace_by_id(&self, id: WorkspaceId) -> Result<Option<Workspace>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn get_all_workspaces(&self) -> Result<Vec<Workspace>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Vorbedingungen:** Der Workspace mit `id` muss existieren.
    - **Nachbedingungen:** `WorkspaceEvent::ActiveChanged` wird publiziert. Der `last_accessed_timestamp` des neuen und ggf. des alten aktiven Workspaces wird aktualisiert.
- `async fn get_active_workspace_id(&self) -> Result<Option<WorkspaceId>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Vorbedingungen:** `new_name` darf nicht leer sein und nicht mit einem existierenden Workspace-Namen (außer dem eigenen) kollidieren.
    - **Nachbedingungen:** `WorkspaceEvent::Renamed` wird publiziert. Änderung wird persistiert.
- `async fn pin_application_to_space(&self, space_id: WorkspaceId, app_id: ApplicationIdentifier) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Nachbedingungen:** `WorkspaceEvent::AppPinned` wird publiziert. Änderung wird persistiert.
- `async fn unpin_application_from_space(&self, space_id: WorkspaceId, app_id: ApplicationIdentifier) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Nachbedingungen:** `WorkspaceEvent::AppUnpinned` wird publiziert. Änderung wird persistiert.
- `async fn move_window_to_workspace(&self, window_identifier: String /* Eindeutiger Fenster-Identifikator, z.B. Wayland Surface ID als String */, target_workspace_id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Fordert an, ein Fenster zum Ziel-Workspace zu verschieben. Die eigentliche Fensterverschiebung erfolgt in der Systemschicht.
    - **Nachbedingungen:** `WorkspaceEvent::WindowMoved` wird publiziert.

##### Publizierte Events:

- **`WorkspaceEvent` Enum:**
    - **Datei:** `domain/src/workspaces/events.rs`
    - **Varianten (Beispiele):**
        - `Created { workspace: Workspace }`
        - `Deleted { workspace_id: WorkspaceId, new_active_workspace_id: Option<WorkspaceId> }`
        - `ActiveChanged { old_id: Option<WorkspaceId>, new_id: WorkspaceId }`
        - `Renamed { workspace_id: WorkspaceId, new_name: String }`
        - `AppPinned { space_id: WorkspaceId, app_id: ApplicationIdentifier }`
        - `AppUnpinned { space_id: WorkspaceId, app_id: ApplicationIdentifier }`
        - `LayoutPolicyChanged { workspace_id: WorkspaceId, new_policy: WorkspaceLayoutPolicy }`
        - `WindowMoved { window_identifier: String, source_workspace_id: Option<WorkspaceId>, target_workspace_id: WorkspaceId }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::workspaces::WorkspaceEvent`
    - **Typische Publisher:** Die Implementierung von `WorkspaceManager`.
    - **Typische Subscriber:** `ui::shell` (UI-Schicht), `system::compositor` (Systemschicht).

#### 2.1.3. `domain::user_centric_services::AIInteractionLogicService` Trait

Steuert die Logik für Benutzerinteraktionen mit KI-Diensten, inklusive Einwilligungsmanagement.

- **Datei:** `domain/src/user_centric_services/ai_logic.rs`
- Diese Service-Schnittstelle ist entscheidend für die sichere und transparente Integration von KI-Funktionen. Die Trennung der Einwilligungslogik von der reinen MCP-Kommunikation (die in der Systemschicht angesiedelt ist) ist ein wichtiger Aspekt für Datenschutz und Benutzerkontrolle.

##### Zugehörige Datenstrukturen und Typen:

- **`AIInteractionContextData` Struct (Wertobjekt):**
    
    - Sammelt Kontextinformationen für eine KI-Anfrage.
    - **Datei:** `domain/src/user_centric_services/ai_context.rs`
    - **Felder:**
        - `active_window_title: Option<String>`
        - `active_app_id: Option<super::workspaces::app_id::ApplicationIdentifier>` // Pfad anpassen
        - `current_workspace_id: Option<super::workspaces::types::WorkspaceId>` // Pfad anpassen
        - `selected_text: Option<String>`
        - `clipboard_content_preview: Option<String>` (Vorschau, nicht der volle Inhalt)
        - `screenshot_data_uri: Option<String>` (Data-URI eines Screenshots, falls relevant)
        - `user_query: String` (Die eigentliche Anfrage des Benutzers)
        - `interaction_id: core::types::Uuid` (Eindeutige ID für diese Interaktion)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIConsent` Enum (Wertobjekt):**
    
    - Repräsentiert den Einwilligungsstatus des Benutzers für KI-Interaktionen.
    - **Datei:** `domain/src/user_centric_services/ai_consent.rs`
    - **Varianten:**
        - `Granted { for_session: bool, timestamp: core::types::DateTime<core::types::Utc> }` (Einwilligung für die aktuelle Sitzung oder dauerhaft)
        - `Denied { timestamp: core::types::DateTime<core::types::Utc> }`
        - `NotSet`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIInteractionResponse` Struct (Wertobjekt):**
    
    - Repräsentiert die Antwort von einem KI-Dienst.
    - **Datei:** `domain/src/user_centric_services/ai_response.rs`
    - **Felder:**
        - `interaction_id: core::types::Uuid`
        - `response_text: Option<String>`
        - `suggested_actions: Vec<String>`
        - `tool_call_id: Option<String>` (Falls ein Tool vom MCP-Server aufgerufen wurde)
        - `tool_call_result: Option<serde_json::Value>` (Ergebnis des Tool-Aufrufs)
        - `error_message: Option<String>`
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIInteractionError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/user_centric_services/ai_error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum AIInteractionError {
            #[error("User consent not given for AI interaction")]
            ConsentNotGiven,
        
            #[error("MCP client error: {0}")]
            MCPError(String), // Wird von SystemMcpService kommen
        
            #[error("Failed to prepare context for AI interaction: {0}")]
            ContextPreparationFailed(String),
        
            #[error("AI service returned an error: {0}")]
            AIServiceError(String),
        
            #[error("Persistence error during AI consent operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #
            InteractionNotFoundOrTimedOut(crate::core::types::Uuid),
        }
        ```
        

##### Methoden des Traits:

- `async fn initiate_interaction(&self, context_data: AIInteractionContextData) -> Result<core::types::Uuid /* interaction_id */, AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Startet eine neue KI-Interaktion. Prüft die Einwilligung und leitet die Anfrage ggf. an den `SystemMcpService` weiter. Gibt eine `interaction_id` zurück, um die Antwort später zu korrelieren.
    - **Vorbedingungen:** `get_consent_status()` darf nicht `Denied` sein. Wenn `NotSet`, wird die Interaktion ggf. pausiert und ein `AIConsentRequestEvent` ausgelöst.
    - **Nachbedingungen:** `AIInteractionStartedEvent` wird publiziert.
    - **Geschäftsregeln:** Die Logik hier muss entscheiden, ob basierend auf `context_data` und `AIConsent` die Interaktion fortgesetzt, abgelehnt oder eine erneute Einwilligung angefordert wird.
- `async fn provide_consent(&self, consent: AIConsent) -> Result<(), AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Speichert die Benutzereinwilligung.
    - **Nachbedingungen:** `AIConsentChangedEvent` wird publiziert. Der Einwilligungsstatus wird persistiert.
- `async fn get_consent_status(&self) -> Result<AIConsent, AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den aktuellen Einwilligungsstatus ab.
- `async fn process_mcp_response(&self, interaction_id: core::types::Uuid, response: Result<serde_json::Value, String> /* MCP Tool Call Result oder Fehler */) -> Result<(), AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Verarbeitet eine asynchrone Antwort vom `SystemMcpService` (typischerweise ein Tool-Aufruf-Ergebnis).
    - **Nachbedingungen:** `AIInteractionCompletedEvent` oder `AIInteractionFailedEvent` wird publiziert.

##### Publizierte Events:

- **`AIConsentChangedEvent`:**
    - **Datei:** `domain/src/user_centric_services/events.rs`
    - **Struktur:** `pub struct AIConsentChangedEvent { pub new_status: AIConsent; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIConsentChangedEvent`
- **`AIInteractionStartedEvent`:**
    - **Struktur:** `pub struct AIInteractionStartedEvent { pub interaction_id: core::types::Uuid, pub context: AIInteractionContextData; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionStartedEvent`
- **`AIInteractionCompletedEvent`:**
    - **Struktur:** `pub struct AIInteractionCompletedEvent { pub response: AIInteractionResponse; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionCompletedEvent`
- **`AIInteractionFailedEvent`:**
    - **Struktur:** `pub struct AIInteractionFailedEvent { pub interaction_id: core::types::Uuid, pub error: AIInteractionError; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionFailedEvent`
- **`AIConsentRequestEvent`:** (Falls die UI den Benutzer zur Einwilligung auffordern soll)
    - **Struktur:** `pub struct AIConsentRequestEvent { pub interaction_id: core::types::Uuid, pub for_context: AIInteractionContextData }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIConsentRequestEvent`
- **Typische Publisher:** Die Implementierung von `AIInteractionLogicService`.
- **Typische Subscriber:** `ui::command_palette` oder KI-Widgets (UI-Schicht), `system::mcp::SystemMcpService` (Systemschicht, für Antworten).

#### 2.1.4. `domain::user_centric_services::NotificationService` Trait

Verwaltet das Anzeigen und Interagieren mit Desktop-Benachrichtigungen.

- **Datei:** `domain/src/user_centric_services/notification_service.rs`
- Die Parameter für `post_notification` spiegeln eng die D-Bus-Methode `org.freedesktop.Notifications.Notify` wider.9 Dieser Dienst fungiert als Abstraktion über potenzielle D-Bus-Implementierungen in der Systemschicht. Die Domänenschicht definiert das _Konzept_ einer Benachrichtigung innerhalb von NovaDE. Die Systemschicht wäre dann dafür verantwortlich, diese Benachrichtigung tatsächlich über D-Bus zu senden, wenn NovaDE als Benachrichtigungsserver fungiert, oder auf D-Bus-Benachrichtigungen zu lauschen, wenn es diese konsumiert. Die Verwendung von `zvariant::OwnedValue` für `hints` deutet auf eine direkte Abbildung auf D-Bus-Varianten hin.

##### Zugehörige Datenstrukturen und Typen:

- **`NotificationId` Typalias:**
    
    - **Datei:** `domain/src/user_centric_services/types.rs` (oder direkt in `notification_service.rs`)
    - **Definition:** `pub type NotificationId = core::types::Uuid;`
- **`NotificationAction` Struct (Wertobjekt):**
    
    - Definiert eine Aktion, die mit einer Benachrichtigung verbunden ist.
    - **Datei:** `domain/src/user_centric_services/notification_action.rs`
    - **Felder:**
        - `key: String` (Eindeutiger Schlüssel für die Aktion, z.B. "default", "reply")
        - `label: String` (Anzeigetext für den Button)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `serde::Serialize`, `serde::Deserialize`.
- **`NotificationUrgency` Enum (Wertobjekt):**
    
    - Definiert die Dringlichkeitsstufe einer Benachrichtigung.
    - **Datei:** `domain/src/user_centric_services/types.rs`
    - **Varianten:** `Low`, `Normal`, `Critical`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`Notification` Struct (Entität):**
    
    - Repräsentiert eine einzelne Desktop-Benachrichtigung.
    - **Datei:** `domain/src/user_centric_services/notification.rs`
    - **Felder:**
        - `id: NotificationId` (Sichtbarkeit: `pub(crate)`, Zugriff über Getter)
        - `app_name: String` (Sichtbarkeit: `pub`)
        - `replaces_id: Option<NotificationId>` (Sichtbarkeit: `pub`)
        - `app_icon: Option<String>` (Pfad oder Name des Icons, Sichtbarkeit: `pub`)
        - `summary: String` (Kurze Zusammenfassung, Sichtbarkeit: `pub`)
        - `body: Option<String>` (Detaillierter Text, Sichtbarkeit: `pub`)
        - `actions: Vec<NotificationAction>` (Sichtbarkeit: `pub`)
        - `hints: std::collections::HashMap<String, zbus::zvariant::OwnedValue>` (Spezifische Hinweise für den Notification-Server, Sichtbarkeit: `pub`)
        - `expire_timeout_ms: i32` (-1 für Server-Default, 0 für nie, >0 für Millisekunden, Sichtbarkeit: `pub`)
        - `urgency: NotificationUrgency` (Sichtbarkeit: `pub`)
        - `timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
        - `is_displayed: std::sync::atomic::AtomicBool` (Interner Status, ob die Benachrichtigung aktuell angezeigt wird)
    - **Initialwerte:** `id` wird generiert, `timestamp` ist aktuell, `is_displayed` ist `false`.
    - **Invarianten:** `summary` darf nicht leer sein. `id` ist unveränderlich.
    - **Methoden (Beispiele):**
        - `pub fn id(&self) -> NotificationId`
        - `pub(crate) fn mark_as_displayed(&self)`
        - `pub(crate) fn mark_as_closed(&self)`
- **`CloseReason` Enum (Wertobjekt):**
    
    - Gibt den Grund an, warum eine Benachrichtigung geschlossen wurde.
    - **Datei:** `domain/src/user_centric_services/types.rs`
    - **Varianten:** `Expired`, `DismissedByUser`, `ClosedByApp`, `ServiceShutdown`, `Unknown`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`NotificationError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/user_centric_services/notification_error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum NotificationError {
            #
            NotificationNotFound(super::types::NotificationId), // Pfad anpassen
        
            #[error("Invalid notification format or content: {0}")]
            InvalidNotificationFormat(String),
        
            #[error("Failed to invoke action '{action_key}' for notification {notification_id}: {reason}")]
            ActionInvokeFailed {
                notification_id: super::types::NotificationId, // Pfad anpassen
                action_key: String,
                reason: String,
            },
        
            #[error("Notification service is unavailable or failed: {0}")]
            ServiceUnavailable(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn post_notification(&self, app_name: String, replaces_id: Option<NotificationId>, app_icon: Option<String>, summary: String, body: Option<String>, actions: Vec<NotificationAction>, hints: std::collections::HashMap<String, zbus::zvariant::OwnedValue>, expire_timeout_ms: i32, urgency: NotificationUrgency) -> Result<NotificationId, NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Sendet eine neue Benachrichtigung oder aktualisiert eine existierende.
    - **Nachbedingungen:** Bei Erfolg wird `NotificationPostedEvent` publiziert. Die Benachrichtigung wird (versucht) dem Benutzer angezeigt.
- `async fn get_active_notifications(&self) -> Result<Vec<Notification>, NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft eine Liste aller aktuell aktiven (angezeigten) Benachrichtigungen ab.
- `async fn close_notification(&self, id: NotificationId, reason: CloseReason) -> Result<(), NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Schließt eine spezifische Benachrichtigung.
    - **Vorbedingungen:** Benachrichtigung mit `id` muss existieren und aktiv sein.
    - **Nachbedingungen:** `NotificationClosedEvent` wird publiziert.
- `async fn invoke_action(&self, id: NotificationId, action_key: String) -> Result<(), NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Löst eine mit einer Benachrichtigung verbundene Aktion aus.
    - **Vorbedingungen:** Benachrichtigung mit `id` und Aktion mit `action_key` müssen existieren.
    - **Nachbedingungen:** `NotificationActionInvokedEvent` wird publiziert.

##### Publizierte Events:

- **`NotificationPostedEvent`:**
    - **Datei:** `domain/src/user_centric_services/events.rs`
    - **Struktur:** `pub struct NotificationPostedEvent { pub notification: Notification; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationPostedEvent`
- **`NotificationClosedEvent`:**
    - **Struktur:** `pub struct NotificationClosedEvent { pub id: NotificationId, pub reason: CloseReason; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationClosedEvent`
- **`NotificationActionInvokedEvent`:**
    - **Struktur:** `pub struct NotificationActionInvokedEvent { pub id: NotificationId, pub action_key: String; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationActionInvokedEvent`
- **Typische Publisher:** Die Implementierung von `NotificationService`.
- **Typische Subscriber:** `ui::notifications_frontend` oder `ui::shell` (UI-Schicht), `system::dbus::notification_server` (Systemschicht, falls NovaDE als Server agiert und die Events intern weiterleitet).

#### 2.1.5. `domain::global_settings_and_state_management::GlobalSettingsService` Trait

Verwaltet globale Desktop-Einstellungen und deren Persistenz.

- **Datei:** `domain/src/global_settings/service.rs`
- Dieser Dienst bietet eine strukturierte Methode zur Verwaltung einer Vielzahl von Desktop-Einstellungen. Der Persistenzmechanismus (z.B. eine Implementierung von `domain::settings_persistence_iface`, wie in der Kernschichtspezifikation erwähnt) ist hier von entscheidender Bedeutung.

##### Zugehörige Datenstrukturen und Typen:

- **`SettingPath` Typalias:**
    
    - **Datei:** `domain/src/global_settings/types.rs`
    - **Definition:** `pub type SettingPath = String;` (z.B. "desktop.background.color", "keyboard.layouts.0.name")
- **`SettingValue` Enum (Wertobjekt):**
    
    - Repräsentiert den Wert einer Einstellung. Kann verschiedene primitive Typen und verschachtelte Strukturen annehmen.
    - **Datei:** `domain/src/global_settings/value.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        #[serde(untagged)] // Für flexible (De-)Serialisierung
        pub enum SettingValue {
            String(String),
            Integer(i64),
            Float(f64),
            Boolean(bool),
            List(Vec<SettingValue>),
            Map(std::collections::HashMap<String, SettingValue>),
            Null, // Um das Fehlen eines Wertes explizit darzustellen
        }
        // Implement From<T> for SettingValue für gängige Typen
        ```
        
    - Die Verwendung von `serde_json::Value` wäre eine Alternative für maximale Flexibilität, aber ein eigenes Enum bietet mehr Typsicherheit innerhalb der Domäne.
- **`GlobalDesktopSettings` Struct (Entität):**
    
    - Repräsentiert die Gesamtheit aller verwalteten Einstellungen.
    - **Datei:** `domain/src/global_settings/settings_struct.rs`
    - **Felder:**
        - `settings: std::collections::BTreeMap<SettingPath, SettingValue>` (BTreeMap für geordnete Iteration/Serialisierung, falls gewünscht)
    - **Sichtbarkeit:** `pub(crate)` für `settings`, Zugriff über Methoden.
    - **Methoden (Beispiele):**
        - `pub fn get(&self, path: &SettingPath) -> Option<&SettingValue>`
        - `pub fn set(&mut self, path: SettingPath, value: SettingValue) -> Option<SettingValue>` (gibt alten Wert zurück)
        - `pub fn remove(&mut self, path: &SettingPath) -> Option<SettingValue>`
- **`GlobalSettingsError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/global_settings/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum GlobalSettingsError {
            #
            SettingNotFound(super::types::SettingPath), // Pfad anpassen
        
            #
            TypeMismatch {
                path: super::types::SettingPath, // Pfad anpassen
                expected_type: String,
                found_type: String,
            },
        
            #[error("Persistence error during settings operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #[error("Validation error for setting '{path}': {message}")]
            ValidationError {
                path: super::types::SettingPath, // Pfad anpassen
                message: String,
            },
        
            #[error("Invalid setting path format: {0}")]
            InvalidPathFormat(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn load_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Lädt alle Einstellungen aus der Persistenzschicht.
    - **Nachbedingungen:** Gibt die geladenen `GlobalDesktopSettings` zurück oder einen Fehler.
- `async fn save_settings(&self, settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Persistiert den gesamten Einstellungsbaum.
- `async fn get_setting(&self, path: &SettingPath) -> Result<Option<SettingValue>, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den Wert einer spezifischen Einstellung ab.
- `async fn update_setting(&self, path: SettingPath, value: SettingValue) -> Result<Option<SettingValue /* old_value */>, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Aktualisiert eine spezifische Einstellung und persistiert die Änderung. Gibt den alten Wert zurück, falls vorhanden.
    - **Vorbedingungen:** `path` und `value` müssen validen Formaten entsprechen. Ggf. Validierung gegen ein Schema.
    - **Nachbedingungen:** Bei Erfolg wird `SettingChangedEvent` publiziert. Die Einstellung wird persistiert.
- `async fn get_all_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft eine Kopie aller aktuellen Einstellungen ab.

##### Publizierte Events:

- **`SettingChangedEvent`:**
    - **Datei:** `domain/src/global_settings/events.rs`
    - **Struktur:**
        
        Rust
        
        ```
        #
        pub struct SettingChangedEvent {
            pub path: SettingPath,
            pub old_value: Option<SettingValue>,
            pub new_value: SettingValue,
        }
        ```
        
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::global_settings::SettingChangedEvent`
- **Typische Publisher:** Die Implementierung von `GlobalSettingsService`.
- **Typische Subscriber:** `ui::control_center` (UI-Schicht), verschiedene Systemkomponenten, die auf Einstellungsänderungen reagieren müssen.

### 2.2. Datenstrukturen (Öffentlich)

Zusätzlich zu den direkt mit Service-APIs assoziierten Strukturen können weitere öffentliche Datenstrukturen existieren, die Zustände oder Konfigurationen repräsentieren und von mehreren Modulen oder Schichten verwendet werden.

- **Beispiele:** Viele der oben bereits definierten Strukturen fallen in diese Kategorie, z.B. `AppliedThemeState`, `Workspace`, `Notification`, `GlobalDesktopSettings`, `ThemingConfiguration`, `ApplicationIdentifier`, `AIInteractionContextData`, `AIConsent`, `SettingValue`.
- **Implementierungsrichtlinien:**
    - Jede Struktur/Enum in einer eigenen Datei innerhalb des relevanten Domänenmoduls (z.B. `domain/src/theming/state.rs`).
    - Ableitung von `Debug`, `Clone`, `PartialEq` ist Standard.
    - Ableitung von `serde::Serialize`, `serde::Deserialize` falls Persistenz oder IPC-Übertragung erforderlich ist.
    - Felder sollten `pub` sein, wenn sie direkt von extern gelesen werden sollen, oder `pub(crate)` mit öffentlichen Gettern/Settern für kontrollierten Zugriff.
    - Invarianten sollten durch Konstruktoren und Methoden sichergestellt werden.
    - Beziehungen zu anderen Entitäten/Wertobjekten sollten klar definiert sein (z.B. durch Komposition oder IDs).

### 2.3. Events (Domänenspezifisch)

Domänenspezifische Events signalisieren wichtige Zustandsänderungen innerhalb der Domänenschicht. Sie sind entscheidend für eine reaktive Architektur und lose Kopplung.

- **Beispiele:** Die bereits bei den Services definierten Events (`ThemeChangedEvent`, `WorkspaceEvent`, `NotificationPostedEvent`, `SettingChangedEvent`, `AIConsentChangedEvent`, etc.).
- **Struktur:**
    - Jedes Event sollte als eigene Struktur oder als Variante eines umfassenderen Event-Enums (pro Modul) definiert werden.
    - Die Event-Struktur enthält alle relevanten Daten zur Zustandsänderung.
    - Beispiel: `pub struct ActiveWorkspaceChanged { pub old_id: Option<WorkspaceId>, pub new_id: WorkspaceId }`
- **Eindeutiger Event-Name/Typ:** Eine klare Namenskonvention ist wichtig, z.B. `nova_de::domain::module::EventName`.
- **Publisher:** Die jeweilige Service-Implementierung, die die Zustandsänderung verursacht.
- **Subscriber:** Komponenten in der System- und UI-Schicht, die auf diese Änderungen reagieren müssen.
    - Beispiel: `ui::theming_gtk` abonniert `ThemeChangedEvent`.
    - Beispiel: `system::compositor` abonniert `ActiveWorkspaceChanged`.
- **Datei-Struktur:** Events können in einer `events.rs`-Datei innerhalb jedes Domänenmoduls definiert werden (z.B. `domain/src/theming/events.rs`).
- **Serialisierung:** Wenn Events über IPC-Grenzen (z.B. D-Bus) gesendet werden sollen, müssen sie `serde::Serialize` und `serde::Deserialize` implementieren.

### 2.4. Fehlertypen (Modulspezifisch)

Jedes Hauptmodul innerhalb der Domänenschicht sollte seine eigenen spezifischen Fehler-Enums definieren, um präzise Fehlerinformationen zu liefern.

- **Beispiele:** Die bereits bei den Services definierten Fehler (`ThemingError`, `WorkspaceManagerError`, `AIInteractionError`, `NotificationError`, `GlobalSettingsError`).
- **Implementierungsrichtlinien:**
    - Verwendung des `thiserror`-Crates für eine ergonomische Definition.
    - Jeder Fehlertyp in einer eigenen Datei (z.B. `domain/src/theming/error.rs`).
    - Fehlervarianten sollten klare und spezifische Fehlerzustände des Moduls beschreiben.
    - Wo sinnvoll, sollten Quellfehler (`#[source]`) oder Konvertierungen (`#[from]`) für Fehler aus der Kernschicht oder anderen Abhängigkeiten bereitgestellt werden, um die Fehlerkette zu erhalten.
- **Verwendung:** Domänenservices geben diese spezifischen Fehler in ihren `Result`-Typen zurück. Die System- und UI-Schicht behandeln diese Fehler oder leiten sie ggf. weiter, eventuell gewrappt in ihre eigenen, allgemeineren Fehlertypen.

---

## 3. Schicht: Systemschicht (System Layer)

Die Systemschicht stellt der UI-Schicht systemnahe Dienste und Ereignisse zur Verfügung und setzt deren Befehle technisch um. Sie interagiert direkt mit dem Betriebssystem, der Hardware (über Abstraktionen wie DRM/GBM, libinput), Systemdiensten (via D-Bus, PipeWire) und dem Wayland-Compositor-Backend (Smithay). Sie konsumiert APIs der Domänenschicht, um Geschäftslogik anzuwenden und Zustände abzufragen.

Diese Schicht ist die Brücke zwischen der abstrakten Domänenlogik von NovaDE und den konkreten Realitäten des Betriebssystems und der Hardware. Hier finden viele der FFI-Aufrufe, IPC-Kommunikation und Interaktionen auf niedriger Ebene statt. Smithay wird intensiv für Wayland-bezogene Komponenten genutzt. Eine robuste Fehlerbehandlung ist entscheidend, um Fehler von niedriger Ebene in abstraktere `SystemError`-Typen oder spezifische Unterfehler zu übersetzen. Die asynchrone Natur vieler Operationen (IPC, Hardwareinteraktion) ist hier kritisch.

### 3.1. Modul: `system::compositor` (Smithay-basierter Wayland Compositor Kern)

Dieses Modul ist das Herzstück der grafischen Darstellung und Fensterverwaltung in NovaDE. Es basiert auf der Smithay-Bibliothek und implementiert die Kernfunktionalitäten eines Wayland-Compositors.

- **Abhängigkeiten:** `smithay`, `wayland-server`, `wayland-protocols`, `calloop`, `input` (libinput-rs), `drm-rs`, `gbm-rs`, `libloading` (für EGL).
- **Verzeichnis:** `system/src/compositor/`

#### 3.1.1. `NovaDeSystemState` Struktur (Hauptzustand für Smithay Handler)

Diese Struktur dient als zentraler Datenhalter für den Event-Loop und implementiert die verschiedenen Handler-Traits von Smithay.

- **Datei:** `system/src/state.rs` (oder `system/src/compositor/state.rs`, je nach Gesamtstruktur)
- **Felder (Beispiele, basierend auf typischer Smithay-Nutzung und NovaDE-Anforderungen):**
    
    Rust
    
    ```
    use smithay::{
        backend::{
            allocator::dmabuf::DmabufState, // [50]
            drm::DrmDeviceFd, // [19, 24, 56, 62, 69, 93, 305, 388]
            egl::{EGLContext, EGLDisplay}, // [16, 26, 62, 65, 94, 97]
            renderer::{
                gles::GlesRenderer, // [16, 40, 62, 94, 97]
                multigpu::{gbm::GbmGlesBackend, GpuManager}, // [24, 28, 40, 62, 97, 145, 222]
            },
            libinput::LibinputInputBackend, // [23, 75, 382]
            udev::{UdevBackend, UdevEvent}, // [37]
            session::{Session, Signal as SessionSignal, logind::LogindSession}, // [362, 391]
            input::Seat,
        },
        desktop::{Space, Window, PopupManager, layer_map_for_output, LayerSurface}, // [67]
        input::{SeatState, SeatHandler, pointer::PointerHandle, keyboard::KeyboardHandle, touch::TouchHandle, SeatName},
        output::Output,
        reexports::{
            calloop::{EventLoop, LoopHandle, LoopSignal},
            wayland_server::{Display, DisplayHandle, Client,backend::GlobalId},
            wayland_protocols::xdg::shell::server::xdg_wm_base,
        },
        utils::{Clock, Logical, Point, Rectangle, Serial, Transform, SERIAL_COUNTER},
        wayland::{
            buffer::BufferHandler, // [353]
            compositor::{CompositorState, CompositorHandler, CompositorClientState, SurfaceData}, // [17, 87, 99]
            dmabuf::DmabufHandler, // [50]
            output::{OutputHandler, OutputManagerState}, // [49, 147, 280, 370, 372, 392]
            presentation::PresentationState, // [274]
            seat::WaylandSeatData,
            shell::{
                xdg::{XdgShellState, XdgShellHandler, XdgShellSurfaceUserData, XdgWmBaseUserData, decoration::XdgDecorationState}, // [13, 31, 54, 81, 167, 176, 191, 195, 199, 204, 207, 208, 215, 223, 224, 225, 227, 317, 323, 336, 349, 350, 393, 394, 395, 396, 397, 398, 399, 400]
                wlr_layer::{WlrLayerShellState, LayerShellHandler, LayerSurfaceData}, // [11, 19, 20, 41, 48, 57, 66, 67, 71, 91, 92, 95, 160, 192, 254, 292, 307, 318, 347, 401, 402]
            },
            shm::{ShmState, ShmHandler}, // [141, 165]
            selection::{
                data_device::{DataDeviceState, DataDeviceHandler}, // [11, 12, 19, 35, 44, 45, 73, 80, 141, 216, 403, 404, 405, 406]
                primary_selection::{PrimarySelectionState, PrimarySelectionHandler}, // [30, 120]
            },
            input_method::{InputMethodManagerState, InputMethodHandler, InputMethodKeyboardUserData}, // [11, 34, 35, 117, 253, 264, 268, 407, 408, 409, 410, 411]
            text_input::{TextInputManagerState, TextInputHandler, TextInputUserData}, // [86, 112, 328, 412, 413, 414]
            viewporter::ViewporterState, // [371]
            xdg_activation::XdgActivationState, // [303]
            foreign_toplevel::ForeignToplevelState, // [335]
            idle_notify::IdleNotifierState, // [58]
            explicit_synchronization::ExplicitSyncState, // [415]
            drm_lease::DrmLeaseState, // [107]
            server_decoration::ServerDecorationManagerState, // [297]
        },
        xwayland::{XWayland, XWaylandEvent, XWaylandClientData, xwm::{X11Wm, XwmHandler, X11Surface}}, // [11, 14, 19, 21, 32, 35, 36, 41, 43, 52, 60, 76, 78, 85, 117, 141, 219, 270, 310, 329, 339, 361, 363, 377, 416, 417]
    };
    use std::{collections::HashMap, sync::{Arc, Mutex}};
    use crate::system::dbus::DBusConnectionManager; // Für D-Bus Interaktionen
    use crate::system::audio::PipeWireClientService; // Für PipeWire
    use crate::domain::services::DomainLayerServices; // Wrapper für Domain-Service-Handles
    
    pub struct NovaDeSystemState {
        pub display_handle: DisplayHandle,
        pub event_loop_handle: LoopHandle<'static, Self>,
        pub loop_signal: LoopSignal,
        pub clock: Clock, // Für Timings, Animationen
    
        // Core Wayland protocol states
        pub compositor_state: Arc<Mutex<CompositorState>>,
        pub shm_state: Arc<Mutex<ShmState>>,
        pub output_manager_state: Arc<Mutex<OutputManagerState>>,
        pub seat_state: Arc<Mutex<SeatState<Self>>>,
        pub data_device_state: Arc<Mutex<DataDeviceState>>,
        pub primary_selection_state: Arc<Mutex<PrimarySelectionState>>,
    
        // Shells
        pub xdg_shell_state: Arc<Mutex<XdgShellState>>,
        pub layer_shell_state: Arc<Mutex<WlrLayerShellState>>,
        pub xdg_decoration_state: Arc<Mutex<XdgDecorationState>>,
        // Optional: xwayland_shell_state if using Smithay's xwayland shell helpers
    
        // Input related
        pub text_input_manager_state: Arc<Mutex<TextInputManagerState>>,
        pub input_method_manager_state: Arc<Mutex<InputMethodManagerState>>,
    
        // Optional Wayland protocol states
        pub presentation_time_state: Option<Arc<Mutex<PresentationState>>>,
        pub viewporter_state: Option<Arc<Mutex<ViewporterState>>>,
        pub xdg_activation_state: Option<Arc<Mutex<XdgActivationState>>>,
        pub foreign_toplevel_state: Option<Arc<Mutex<ForeignToplevelState>>>,
        pub idle_notifier_state: Option<Arc<Mutex<IdleNotifierState<Self>>>>,
        pub explicit_sync_state: Option<Arc<Mutex<ExplicitSyncState>>>,
        pub drm_lease_state: Option<Arc<Mutex<DrmLeaseState>>>,
        pub server_decoration_manager_state: Option<Arc<Mutex<ServerDecorationManagerState>>>,
    
        // Backend specific states
        pub udev_backend_data: Option<UdevBackendData>, // If using udev backend
        pub winit_data: Option<WinitData>, // If using winit backend
        pub x11_data: Option<X11BackendData>, // If using X11 backend (as a client)
    
        // XWayland
        pub xwayland: Option<XWayland>,
        pub xwm: Option<Arc<Mutex<X11Wm>>>, // X11 Window Manager for XWayland
        pub xwayland_client_data_id: Option<u32>, // To identify XWayland's client
    
        // Desktop management
        pub space: Arc<Mutex<Space<WindowElement>>>, // Manages windows and outputs
        pub popup_manager: Arc<Mutex<PopupManager>>,
    
        // Input devices
        pub seat_name: String,
        pub seat: Seat<Self>,
        pub pointer: PointerHandle<Self>,
        pub keyboard: KeyboardHandle<Self>,
        pub touch: Option<TouchHandle<Self>>, // Touch ist optional
    
        // Domain Layer Access
        pub domain_services: Arc<DomainLayerServices>,
    
        // System Services Clients
        pub dbus_conn_manager: Arc<DBusConnectionManager>,
        pub pipewire_service: Arc<PipeWireClientService>,
    
        // Internal state
        pub running: std::sync::atomic::AtomicBool,
        pub active_workspace_id: Option<crate::domain::workspaces::WorkspaceId>,
        // Weitere anwendungsspezifische Zustände
    }
    
    // Hilfsstrukturen für Backend-spezifische Daten
    pub struct UdevBackendData {
        pub session: LogindSession, // Oder eine andere Session-Implementierung
        pub gpus: GpuManager<GbmGlesBackend<GlesRenderer, DrmDeviceFd>>,
        pub primary_gpu: DrmDeviceFd,
        pub udev_backend: UdevBackend,
        // Weitere DRM/GBM/EGL spezifische Zustände
    }
    pub struct WinitData { /*... relevante Winit-Felder... */ }
    pub struct X11BackendData { /*... relevante X11-Backend-Felder... */ }
    
    // WindowElement (Beispiel, muss an NovaDE angepasst werden)
    #
    pub enum WindowElement {
        Wayland(Window), // Smithay's Window für XDG Toplevels
        X11(X11Surface), // Smithay's X11Surface
        Layer(LayerSurface), // Smithay's LayerSurface
    }
    // Implementiere notwendige Traits für WindowElement (z.B. RenderElement, SpaceElement)
    ```
    
    - Der Compositor ist das komplexeste Element der Systemschicht. Smithay 8 stellt Bausteine bereit, aber die eigentliche Fensterverwaltungslogik (Tiling, Stacking, Fokusrichtlinien basierend auf Domänenregeln) muss hier implementiert werden. Die `AnvilState` aus Smithays Anvil-Compositor dient als gute Referenz für die Strukturierung von `NovaDeSystemState` und die Integration verschiedener Smithay-Handler.

#### 3.1.2. Initialisierung (`system::compositor::initialize_compositor`)

- **Datei:** `system/src/compositor/init.rs`
- **Signatur:** `pub async fn initialize_compositor(domain_services: Arc<DomainLayerServices>, event_loop_handle: LoopHandle<'static, NovaDeSystemState>, loop_signal: LoopSignal) -> Result<NovaDeSystemState, SystemError>`
- **Schritte:**
    1. Erstelle `DisplayHandle` aus dem globalen `Display` Objekt (Annahme: `Display` wird im `main` erstellt und `DisplayHandle` wird hierher übergeben oder `NovaDeSystemState` wird direkt im `main` erstellt).
    2. Initialisiere Smithay-Backends (z.B. `LibinputInputBackend` 23, `UdevBackend` 37, DRM/GBM/EGL 16). Die Wahl des Backends (DRM/libseat für Bare-Metal, Winit/X11 für verschachtelte Entwicklung) ist eine wichtige architektonische Entscheidung. Die Implementierung sollte dies abstrahieren.
    3. Initialisiere alle relevanten Wayland-Globale unter Verwendung ihrer

# **UI-Schicht: Ultra-Feinspezifikation und Implementierungsleitfaden**

## **Modul: ui::shell::PanelWidget (Haupt-Panel-Implementierung)**

### **1. Modul-Identifikation und Zweck**

- **Modul-ID:** `ui::shell::PanelWidget`
- **Abhängigkeiten:**
    - `novade-core` (insbesondere `core::types` für geometrische Primitive und Farben, `core::errors` als Basis)
    - `novade-domain` (insbesondere `domain::theming` für Design-Tokens, `domain::global_settings_and_state_management` für Konfigurationen)
    - `gtk4-rs` (GTK4 Rust Bindings)
    - `gtk4-layer-shell` (für Wayland Layer Shell Integration)
    - `cairo-rs` (für benutzerdefiniertes Zeichnen, falls CSS nicht ausreicht)
    - `zbus` (für D-Bus-Kommunikation, falls das Panel direkt mit Systemdiensten interagiert, was aber eher von Submodulen gehandhabt wird)
    - `once_cell` (für statische Initialisierungen)
    - `thiserror` (für Fehlerdefinitionen innerhalb dieses Moduls, falls spezifisch)
    - `tracing` (für Logging)
- **Zweck:** Das `PanelWidget` ist die zentrale Komponente der `ui::shell`, die als primäre(s) Kontroll- und Systemleiste(n) der NovaDE dient. Es ist verantwortlich für die Bereitstellung einer oder mehrerer horizontaler Leisten am Bildschirmrand, die Aufnahme, Anordnung und Verwaltung verschiedener modularer Panel-Elemente (Submodule), die Implementierung grundlegender Panel-Eigenschaften (Höhe, Transparenz, visueller "Leuchtakzent") und die korrekte Integration in Wayland-Compositors mittels des `gtk4-layer-shell`-Protokolls.

### **2. Visuelles Design und Theming (Spezifikation für Manus AI)**

- **Positionierung:**
    - Kann am oberen (`Top`) oder unteren (`Bottom`) Bildschirmrand verankert werden.
    - Die Positionierung wird durch die Eigenschaft `position` (Typ: `PanelPosition`, siehe unten) gesteuert.
    - Standardwert: `PanelPosition::Top`.
- **Abmessungen:**
    - **Höhe (`panel-height`):** Konfigurierbare Höhe in Pixeln.
        - Datentyp: `i32`.
        - Gültiger Bereich: Minimum 24px, Maximum 128px.
        - Standardwert: 36px.
        - Die Höhe wird über die GObject-Eigenschaft `panel-height` gesetzt und beeinflusst die `default-height` des zugrundeliegenden `gtk::ApplicationWindow` sowie die `height-request` der internen `main_box`.
    - **Breite:** Das Panel erstreckt sich standardmäßig über die gesamte Breite des zugewiesenen Monitors/Outputs. Dies wird durch die Ankerung über `gtk4-layer-shell` erreicht (`Edge::Left` und `Edge::Right` auf `true` setzen).
- **Erscheinungsbild:**
    - **Hintergrund:**
        - Farbe und Stil werden primär über CSS gesteuert.
        - Das Panel kann optional einen transluzenten Hintergrund haben.
        - Die Eigenschaft `transparency-enabled` (Typ: `bool`, Standard: `false`) steuert dies.
        - Implementierung der Transparenz:
            1. Das GDK Visual des `PanelWidget` (als `gtk::Window`) muss auf ein RGBA-Visual gesetzt werden, falls Transparenz aktiviert ist: `self.set_visual(self.display().rgba_visual().as_ref())`.
            2. Der CSS-Hintergrund muss eine RGBA-Farbe verwenden (z.B. `background-color: rgba(0, 0, 0, 0.5);`).
            3. Für Wayland-Compositors, die transparente Oberflächen unterstützen, muss die `gtk4-layer-shell`-Integration sicherstellen, dass der Compositor die Transparenz korrekt handhabt. Das Setzen von `surface.set_opaque_region(None)` kann notwendig sein.
    - **"Leuchtakzent"-Effekt:**
        - Ein subtiler Leuchteffekt entlang einer Kante des Panels (typischerweise die dem Bildschirmzentrum zugewandte Kante).
        - Gesteuert durch Eigenschaften:
            - `leuchtakzent-color` (Typ: `Option<gdk::RGBA>`, Standard: `None`). Farbe des Akzents.
            - `leuchtakzent-intensity` (Typ: `f64`, Bereich: 0.0 bis 1.0, Standard: 0.5). Intensität/Opazität des Akzents.
        - **Implementierung (priorisierte Reihenfolge):**
            1. **CSS `box-shadow`:** Versuche, den Effekt mit CSS `box-shadow` zu erzielen (z.B. `box-shadow: 0px 2px 5px 0px var(--leuchtakzent-color);` angepasst für die Kante). Die Farbe `--leuchtakzent-color` wird dynamisch über einen `CssProvider` basierend auf `leuchtakzent-color` und `leuchtakzent-intensity` gesetzt.
            2. **Benutzerdefiniertes Zeichnen (Cairo auf `gtk::DrawingArea`):** Falls CSS nicht ausreicht oder Performance-Probleme verursacht:
                - Eine `gtk::DrawingArea` wird als unterste Ebene im `PanelWidget` platziert (oder das `PanelWidget` zeichnet seinen Hintergrund selbst, was komplexer ist).
                - Im `draw`-Signal-Handler der `DrawingArea`:
                    - Hintergrund des Panels zeichnen (unter Berücksichtigung von `transparency-enabled`).
                    - Den Leuchtakzent-Pfad definieren (Linie oder schmales Rechteck entlang der relevanten Kante).
                    - Akzentfarbe und -intensität aus den GObject-Eigenschaften abrufen.
                    - `cr.set_source_rgba()` mit der `leuchtakzent-color` (modifiziert durch `leuchtakzent-intensity` für die Alpha-Komponente) verwenden.
                    - Für einen weichen Effekt: `cairo::LinearGradient` verwenden, der von der Akzentfarbe zu einer transparenten Version derselben Farbe oder zur Hintergrundfarbe übergeht.
                    - `self.queue_draw()` aufrufen, wenn sich `leuchtakzent-color` oder `leuchtakzent-intensity` ändern.
- **CSS-Styling:**
    - **CSS-Knotenname:** Das `PanelWidget` (als `GtkApplicationWindow`) hat standardmäßig den CSS-Knoten `window`. Das interne Haupt-Layout-Widget (z.B. `main_box` vom Typ `gtk::Box`) hat den Knoten `box`.
    - Dem `PanelWidget` wird der CSS-Name "panelwidget" zugewiesen (`klass.set_css_name("panelwidget");`).
    - **CSS-Klassen (dynamisch und statisch):**
        - `.nova-panel` (statisch): Allgemeine Klasse für das Panel.
        - `.panel-top` / `.panel-bottom` (dynamisch): Je nach Wert der `position`-Eigenschaft.
        - `.transparent-panel` (dynamisch): Wenn `transparency-enabled` `true` ist.
        - Diese Klassen werden dem `PanelWidget` über `gtk::Widget::add_css_class()` / `gtk::Widget::remove_css_class()` zugewiesen, wenn sich die entsprechenden Eigenschaften ändern.
    - **CSS-Provider:** Die Anwendung von CSS erfolgt über einen globalen `gtk::CssProvider`, der durch ein übergeordnetes Theming-Modul (z.B. `ui::theming_gtk`) verwaltet wird. Das `PanelWidget` reagiert auf `ThemeChangedEvents` (siehe Abschnitt 2.6 Signale), um Stiländerungen zu übernehmen.

### **3. Datenstrukturen, Eigenschaften und Zustand (Spezifikation für Manus AI)**

Das `PanelWidget` wird als benutzerdefiniertes GObject-Widget implementiert, das von `gtk::ApplicationWindow` erbt.

#### **3.1. Datei: `src/ui/shell/panel_widget/mod.rs` (Öffentliche API)**

Rust

```
use gtk::glib;
use gtk::subclass::prelude::*;
use gtk::{gio, ApplicationWindow, Widget}; // Hinzugefügt für @extends und @implements
use std::cell::{Cell, RefCell}; // Für interne Veränderlichkeit in imp.rs benötigt, hier nicht direkt

mod imp; // Private Implementierung

glib::wrapper! {
    pub struct PanelWidget(ObjectSubclass<imp::PanelWidget>)
        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}

impl PanelWidget {
    pub fn new(app: &gtk::Application) -> Self {
        glib::Object::builder::<Self>()
            .property("application", app)
            .build()
    }

    // ### Öffentliche Methoden zur Modulverwaltung ###

    /// Fügt ein Widget-Modul dem Panel hinzu.
    ///
    /// # Parameter
    /// * `module`: Das Widget, das als Modul hinzugefügt werden soll.
    /// * `position`: Die Position im Panel (Start, Center, End).
    /// * `order`: Die Reihenfolge des Moduls innerhalb seiner Position (kleinere Werte zuerst).
    ///
    /// `noexcept` (nicht direkt in Rust, aber Methode soll nicht paniken)
    pub fn add_module(&self, module: &impl glib::IsA<gtk::Widget>, position: imp::ModulePosition, order: i32) {
        self.imp().add_module_ordered(module, position, order);
    }

    /// Entfernt ein zuvor hinzugefügtes Modul aus dem Panel.
    ///
    /// # Parameter
    /// * `module`: Das zu entfernende Widget-Modul.
    ///
    /// `noexcept`
    pub fn remove_module(&self, module: &impl glib::IsA<gtk::Widget>) {
        self.imp().remove_module_internal(module);
    }

    // ### Öffentliche Methoden für Eigenschaften (optional, wenn GObject Properties bevorzugt) ###
    // Beispiel, falls direkte Methodenaufrufe gewünscht sind, ansonsten über Properties

    pub fn set_panel_position(&self, position: imp::PanelPosition) {
        self.set_property("position", position.to_value());
    }

    pub fn get_panel_position(&self) -> imp::PanelPosition {
        self.property("position")
    }

    pub fn set_panel_height(&self, height: i32) {
        self.set_property("panel-height", height);
    }

    pub fn get_panel_height(&self) -> i32 {
        self.property("panel-height")
    }

    pub fn set_transparency_enabled(&self, enabled: bool) {
        self.set_property("transparency-enabled", enabled);
    }

    pub fn is_transparency_enabled(&self) -> bool {
        self.property("transparency-enabled")
    }
}

// Enum Definitionen müssen hier oder in einem gemeinsamen Typmodul sein,
// damit sie in der öffentlichen API verwendet werden können.
// Für dieses Beispiel werden sie im imp-Modul deklariert und hier re-exportiert,
// oder sie sind in einem ui::shell::panel_widget::types Modul.
// pub use imp::{PanelPosition, ModulePosition}; // Falls sie in imp definiert sind

```

#### **3.2. Datei: `src/ui/shell/panel_widget/imp.rs` (Private GObject-Implementierung)**

Rust

```
use gtk::glib::{self, Properties, ParamSpec, Value, subclass::Signal};
use gtk::subclass::prelude::*;
use gtk::{CompositeTemplate, Align, Orientation as GtkOrientation, Box as GtkBox, ApplicationWindow, Widget}; // Widget hinzugefügt
use gdk::RGBA; // Für leuchtakzent-color
use std::cell::{Cell, RefCell};
use std::collections::{BTreeMap, HashMap}; // BTreeMap für geordnete Module
use once_cell::sync::Lazy;

// ### Enums für Panel-Konfiguration ###

#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, glib::Enum)]
#[enum_type(name = "NovaDEPanelPosition")]
pub enum PanelPosition {
    #[default]
    Top,
    Bottom,
}

// Benötigt `glib:: القيمه` für Properties
impl From<PanelPosition> for Value {
    fn from(position: PanelPosition) -> Self {
        position.to_value()
    }
}
impl From<Value> for PanelPosition {
    fn from(value: Value) -> Self {
        glib::EnumClass::new(PanelPosition::static_type())
            .expect("PanelPosition EnumClass not found")
            .value(value.get_enum().expect("Value is not an enum"))
            .expect("Invalid PanelPosition enum value")
            .downcast::<PanelPosition>()
            .expect("Failed to downcast to PanelPosition")
            .get()
    }
}


#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, glib::Enum)]
#[enum_type(name = "NovaDEModulePosition")]
pub enum ModulePosition {
    #[default]
    Start,
    Center,
    End,
}

// Hilfsstruktur für geordnete Module
#[derive(Debug, Clone)]
struct OrderedModule {
    widget: Widget,
    order: i32,
}

// ### GObject Properties Definition ###
static PANEL_PROPERTIES: Lazy<Vec<ParamSpec>> = Lazy::new(|| {
    vec![
        ParamSpec::new_enum(
            "position",
            "Position",
            "Bildschirmkante, an der das Panel verankert ist (Oben, Unten).",
            PanelPosition::static_type(),
            PanelPosition::default() as i32, // Standardwert
            glib::ParamFlags::READWRITE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_int(
            "panel-height",
            "Panel Height",
            "Höhe des Panels in Pixeln (Min: 24, Max: 128).",
            24, // Min
            128, // Max
            36, // Standardwert
            glib::ParamFlags::READWRITE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_boolean(
            "transparency-enabled",
            "Transparency Enabled",
            "Gibt an, ob Transparenzeffekte für das Panel aktiv sind.",
            false, // Standardwert
            glib::ParamFlags::READWRITE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_boxed(
            "leuchtakzent-color",
            "Leuchtakzent Color",
            "Farbe des Leuchtakzents (gdk::RGBA). Wird typischerweise vom Theming-System aktualisiert.",
            RGBA::static_type(), // Typ gdk::RGBA
            glib::ParamFlags::READWRITE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_double(
            "leuchtakzent-intensity",
            "Leuchtakzent Intensity",
            "Intensität/Opazität des Leuchtakzents (Bereich: 0.0 bis 1.0).",
            0.0, // Min
            1.0, // Max
            0.5, // Standardwert
            glib::ParamFlags::READWRITE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
    ]
});

// ### GObject Signale Definition ###
static PANEL_SIGNALS: Lazy<HashMap<String, Signal>> = Lazy::new(|| {
    let mut signals = HashMap::new();
    signals.insert(
        "module-layout-changed".to_string(),
        Signal::builder("module-layout-changed")
            .action() // Kein Rückgabewert, keine Parameter für dieses Signal
            .build(),
    );
    signals
});


#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/nova_de/ui/shell/panel_widget.ui")] // Pfad zur UI-Datei
pub struct PanelWidget {
    #[template_child]
    pub main_box: TemplateChild<GtkBox>,
    #[template_child]
    pub start_box: TemplateChild<GtkBox>,
    #[template_child]
    pub center_box: TemplateChild<GtkBox>,
    #[template_child]
    pub end_box: TemplateChild<GtkBox>,

    // GObject Properties (als Felder in der Imp-Struktur)
    #[property(get, set, explicit_notify)]
    position: RefCell<PanelPosition>,
    #[property(get, set, explicit_notify)]
    panel_height: Cell<i32>,
    #[property(get, set, explicit_notify)]
    transparency_enabled: Cell<bool>,
    #[property(get, set, explicit_notify)]
    leuchtakzent_color: RefCell<Option<RGBA>>,
    #[property(get, set, explicit_notify)]
    leuchtakzent_intensity: Cell<f64>,

    // Interner Zustand für Modulverwaltung
    // Verwendet BTreeMap, um Module nach `order` und dann nach Einfügezeit (als Fallback für gleiche Order)
    // sortiert zu halten. Der innere Vec ist für den Fall, dass mehrere Widgets exakt dieselbe Order haben.
    modules_start: RefCell<BTreeMap<i32, Vec<Widget>>>,
    modules_center: RefCell<BTreeMap<i32, Vec<Widget>>>,
    modules_end: RefCell<BTreeMap<i32, Vec<Widget>>>,

    // Für benutzerdefiniertes Zeichnen des Leuchtakzents, falls CSS nicht ausreicht.
    // Wird im `constructed` initialisiert, falls benötigt.
    drawing_area_for_accent: RefCell<Option<gtk::DrawingArea>>,
}

#[glib::object_subclass]
impl ObjectSubclass for PanelWidget {
    const NAME: &'static str = "NovaDEPanelWidget";
    type Type = super::PanelWidget; // Der öffentliche Wrapper-Typ
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &mut Self::Class) {
        klass.bind_template();
        klass.install_properties(&PANEL_PROPERTIES);
        klass.install_signals(&PANEL_SIGNALS);
        klass.set_css_name("panelwidget"); // CSS-Name für das Widget
    }

    fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
        obj.init_template();
    }
}

#[glib::derived_properties]
impl ObjectImpl for PanelWidget {
    fn constructed(&self) {
        self.parent_constructed();
        let obj = self.obj(); // Der öffentliche Wrapper `super::PanelWidget`

        // Standardwerte für Properties setzen, falls nicht explizit beim Bauen angegeben
        // Diese Werte werden von den ParamSpec Defaults überschrieben, falls `glib::Object::builder()` verwendet wird.
        // Wenn direkt `PanelWidget::new()` aufgerufen wird, sind die Zell-Defaults (z.B. 0 für i32) aktiv.
        // Die ParamSpec Defaults sollten hier bevorzugt werden.
        // Die Initialisierung der RefCell/Cell-Felder mit den Property-Standardwerten erfolgt
        // implizit durch das GObject-Property-System, wenn das Objekt gebaut wird.
        // Manuelle Defaults hier sind nur nötig, wenn kein Property-System genutzt würde.

        // gtk4-layer-shell initialisieren
        obj.setup_layer_shell_internal();
        obj.update_module_layout_internal(); // Erstes Layout anwenden

        // CSS-Klassen basierend auf initialen Properties setzen
        self.update_css_classes();

        // Eventuell DrawingArea für Leuchtakzent initialisieren und verbinden, falls nötig
        // self.setup_drawing_area_for_accent();
    }

    // Implementierung der Properties Getters und Setters (automatisch durch #[property] und #[glib::derived_properties])
    // Die Logik für Property-Änderungen (z.B. LayerShell neu konfigurieren) kommt in die `set_property` Methode.

    fn set_property(&self, _id: usize, value: &Value, pspec: &ParamSpec) {
        match pspec.name() {
            "position" => {
                let new_position = value.get::<PanelPosition>().expect("Value must be PanelPosition");
                self.position.replace(new_position);
                self.obj().setup_layer_shell_internal(); // Layer Shell neu konfigurieren
                self.update_css_classes();
                self.obj().notify_position(); // Benachrichtigung für diese Eigenschaft
            }
            "panel-height" => {
                let new_height = value.get::<i32>().expect("Value must be i32");
                // Validierung gegen Min/Max aus ParamSpec (automatisch durch GObject, aber man könnte hier zusätzlich prüfen)
                self.panel_height.set(new_height);
                self.obj().set_default_height(new_height); // Fensterhöhe anpassen
                self.main_box.set_height_request(new_height);
                // Ggf. DrawingArea Höhe anpassen
                self.obj().queue_draw(); // Neuzeichnen anfordern
                self.obj().notify_panel_height();
            }
            "transparency-enabled" => {
                let enabled = value.get::<bool>().expect("Value must be bool");
                self.transparency_enabled.set(enabled);
                self.update_transparency_visual_internal();
                self.update_css_classes();
                self.obj().notify_transparency_enabled();
            }
            "leuchtakzent-color" => {
                // Option<RGBA> muss vorsichtig gehandhabt werden
                let color_opt = value.get::<Option<RGBA>>().expect("Value must be Option<RGBA> or None");
                self.leuchtakzent_color.replace(color_opt);
                self.obj().queue_draw(); // Neuzeichnen für Akzent
                self.obj().notify_leuchtakzent_color();
            }
            "leuchtakzent-intensity" => {
                let intensity = value.get::<f64>().expect("Value must be f64");
                self.leuchtakzent_intensity.set(intensity.clamp(0.0, 1.0)); // Sicherstellen, dass im Bereich
                self.obj().queue_draw();
                self.obj().notify_leuchtakzent_intensity();
            }
            _ => unimplemented!(),
        }
    }
}

impl WidgetImpl for PanelWidget {
    fn map(&self) {
        self.parent_map();
        // Sicherstellen, dass Layer Shell korrekt initialisiert ist, bevor das Fenster angezeigt wird
        self.obj().setup_layer_shell_internal();
    }

    fn size_allocate(&self, width: i32, height: i32, baseline: i32) {
        self.parent_size_allocate(width, height, baseline);
        // Ggf. Layout der internen Boxen hier anpassen oder DrawingArea Größe
        // Dies ist wichtig, wenn sich die Panel-Breite ändert (z.B. Multi-Monitor-Setup Wechsel)
    }

    // Falls benutzerdefiniertes Zeichnen für Akzent via DrawingArea:
    // fn snapshot(&self, snapshot: &gtk::Snapshot) {
    //     self.parent_snapshot(snapshot);
    //     // Hier könnte man den Akzent zeichnen, wenn er nicht Teil eines Kind-Widgets ist.
    // }
}

impl WindowImpl for PanelWidget {
    // Fenster-spezifische Implementierungen, z.B. Schließen-Verhalten
}

impl ApplicationWindowImpl for PanelWidget {}

// ### Interne Implementierungsmethoden für PanelWidget ###
impl PanelWidget {
    fn update_css_classes(&self) {
        let obj = self.obj();
        if *self.position.borrow() == PanelPosition::Top {
            obj.remove_css_class("panel-bottom");
            obj.add_css_class("panel-top");
        } else {
            obj.remove_css_class("panel-top");
            obj.add_css_class("panel-bottom");
        }

        if self.transparency_enabled.get() {
            obj.add_css_class("transparent-panel");
        } else {
            obj.remove_css_class("transparent-panel");
        }
    }

    fn update_transparency_visual_internal(&self) {
        let obj = self.obj();
        let visual = if self.transparency_enabled.get() {
            obj.display().rgba_visual()
        } else {
            // Zurück zum System-Standard-Visual (oder None, wenn das Fenster sowieso opak sein soll)
            obj.display().default_visual(&obj.surface().unwrap_or_else(|| obj.create_surface(obj.width(), obj.height(), None)))
        };
        obj.set_visual(visual.as_ref());
        obj.queue_draw(); // Neuzeichnen anfordern, da sich das Visual geändert hat
    }

    // Wird vom öffentlichen add_module aufgerufen
    pub(super) fn add_module_ordered(&self, module: &impl glib::IsA<gtk::Widget>, position: ModulePosition, order: i32) {
        let module_widget = module.clone().upcast::<Widget>();
        let modules_map = match position {
            ModulePosition::Start => &self.modules_start,
            ModulePosition::Center => &self.modules_center,
            ModulePosition::End => &self.modules_end,
        };

        let mut map_guard = modules_map.borrow_mut();
        map_guard.entry(order).or_default().push(module_widget);

        self.obj().update_module_layout_internal();
        self.obj().emit_by_name::<()>("module-layout-changed", &[]);
    }

    // Wird vom öffentlichen remove_module aufgerufen
    pub(super) fn remove_module_internal(&self, module_to_remove: &impl glib::IsA<gtk::Widget>) {
        let widget_ptr_to_remove = module_to_remove.as_ref().to_glib_none().0;
        let mut changed = false;

        for modules_map_refcell in [&self.modules_start, &self.modules_center, &self.modules_end] {
            let mut map_guard = modules_map_refcell.borrow_mut();
            for (_order, widgets_in_order) in map_guard.iter_mut() {
                let initial_len = widgets_in_order.len();
                widgets_in_order.retain(|m| m.to_glib_none().0 != widget_ptr_to_remove);
                if widgets_in_order.len() < initial_len {
                    changed = true;
                    break; // Modul gefunden und entfernt
                }
            }
            if changed { break; }
        }

        if changed {
            // Physisches Entfernen aus den GtkBox-Containern
            if let Some(parent_box) = module_to_remove.as_ref().parent().and_then(|p| p.downcast::<GtkBox>().ok()){
                parent_box.remove(module_to_remove.as_ref());
            }
            self.obj().update_module_layout_internal();
            self.obj().emit_by_name::<()>("module-layout-changed", &[]);
        }
    }
}

// ### Öffentliche Methoden, die von der `imp`-Struktur für den Wrapper bereitgestellt werden ###
// Diese sind jetzt im `PanelWidget`-Block in `mod.rs` implementiert oder werden
// durch GObject-Properties gehandhabt. Die `setup_layer_shell_internal` und
// `update_module_layout_internal` sind die Kernmethoden, die der Wrapper aufruft.
impl super::PanelWidget { // Bezieht sich auf den öffentlichen Wrapper
    fn setup_layer_shell_internal(&self) {
        let imp = self.imp();
        gtk_layer_shell::init_for_window(self);
        gtk_layer_shell::set_layer(self, gtk_layer_shell::Layer::Top);
        // Panels benötigen i.d.R. keinen direkten Fokus, außer ihre Kindelemente
        gtk_layer_shell::set_keyboard_mode(self, gtk_layer_shell::KeyboardMode::OnDemand); // Oder None, wenn Module Fokus explizit anfordern
        gtk_layer_shell::auto_exclusive_zone_enable(self); // Platz reservieren
        gtk_layer_shell::set_namespace(self, "NovaDEPanel");

        let position_val = *imp.position.borrow();
        match position_val {
            PanelPosition::Top => {
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Top, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Left, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Right, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Bottom, false);
            }
            PanelPosition::Bottom => {
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Bottom, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Left, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Right, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Top, false);
            }
        }
        self.set_default_height(imp.panel_height.get());
        // Margins könnten hier auch gesetzt werden, falls gewünscht, z.B. um das Panel leicht vom Rand abzusetzen
        // gtk_layer_shell::set_margin(self, gtk_layer_shell::Edge::Top, 5);
        // gtk_layer_shell::set_margin(self, gtk_layer_shell::Edge::Left, 5);
        // gtk_layer_shell::set_margin(self, gtk_layer_shell::Edge::Right, 5);
    }

    fn update_module_layout_internal(&self) {
        let imp = self.imp();

        // Helferfunktion zum Leeren und Befüllen einer Box
        let repopulate_box = |target_box: &GtkBox, modules_map_refcell: &RefCell<BTreeMap<i32, Vec<Widget>>>| {
            while let Some(child) = target_box.first_child() {
                target_box.remove(&child);
            }
            let map_guard = modules_map_refcell.borrow();
            for (_order, widgets_in_order) in map_guard.iter() { // BTreeMap iteriert über Schlüssel (order) sortiert
                for widget in widgets_in_order {
                    target_box.append(widget);
                }
            }
        };

        repopulate_box(&imp.start_box, &imp.modules_start);
        repopulate_box(&imp.center_box, &imp.modules_center);
        repopulate_box(&imp.end_box, &imp.modules_end);
    }
}
```

#### **3.3. UI-Definitionsdatei: `resources/ui/shell/panel_widget.ui`**

XML

```
<?xml version="1.0" encoding="UTF-8"?>
<interface>
  <requires lib="gtk" version="4.0"/>
  <template class="NovaDEPanelWidget" parent="GtkApplicationWindow">
    <property name="title" translatable="yes">NovaDE Panel</property>
    <property name="decorated">false</property>
    <child>
      <object class="GtkBox" id="main_box">
        <property name="orientation">horizontal</property>
        <property name="halign">fill</property>
        <property name="valign">fill</property> <property name="spacing">6</property> <style>
          <class name="nova-panel-main-box"/>
        </style>
        <child>
          <object class="GtkBox" id="start_box">
            <property name="orientation">horizontal</property>
            <property name="halign">start</property>
            <property name="valign">center</property>
            <property name="spacing">6</property> <style>
              <class name="nova-panel-start-box"/>
            </style>
            </object>
        </child>
        <child>
          <object class="GtkBox" id="center_box">
            <property name="orientation">horizontal</property>
            <property name="halign">center</property>
            <property name="valign">center</property>
            <property name="hexpand">true</property> <property name="spacing">6</property>
            <style>
              <class name="nova-panel-center-box"/>
            </style>
            </object>
        </child>
        <child>
          <object class="GtkBox" id="end_box">
            <property name="orientation">horizontal</property>
            <property name="halign">end</property>
            <property name="valign">center</property>
            <property name="spacing">6</property>
            <style>
              <class name="nova-panel-end-box"/>
            </style>
            </object>
        </child>
      </object>
    </child>
  </template>
</interface>
```

#### **3.4. GObject-Eigenschaften (Zusammenfassung)**

|Eigenschaftsname|Rust-Feld (Imp)|Typ (Rust / GLib)|Zugriff|Standardwert|Beschreibung|
|:--|:--|:--|:--|:--|:--|
|`application`|(Parent-Eigenschaft)|`gtk::Application`|R/W/C|N/A|Die `gtk::Application`, zu der das Fenster gehört.|
|`position`|`position`|`PanelPosition` / Enum|R/W|`Top`|Bildschirmkante für das Panel (Oben, Unten).|
|`panel-height`|`panel_height`|`i32` / GINT|R/W|36|Höhe des Panels in Pixeln (Min: 24, Max: 128).|
|`transparency-enabled`|`transparency_enabled`|`bool` / GBOOLEAN|R/W|`false`|Aktiviert/Deaktiviert Transparenzeffekte.|
|`leuchtakzent-color`|`leuchtakzent_color`|`Option<gdk::RGBA>` / GBoxed|R/W|`None`|Farbe des Leuchtakzents.|
|`leuchtakzent-intensity`|`leuchtakzent_intensity`|`f64` / GDOUBLE|R/W|0.5|Intensität des Leuchtakzents (0.0-1.0).|

In Google Sheets exportieren

_R=Read, W=Write, C=Construct-Only_

#### **3.5. Interner Zustand (Felder in `PanelWidgetImp`)**

- `main_box: TemplateChild<GtkBox>`: Hauptcontainer für die drei Modulbereiche.
- `start_box: TemplateChild<GtkBox>`: Container für Module am Anfang (links bei LTR-Layout).
- `center_box: TemplateChild<GtkBox>`: Container für Module in der Mitte. `hexpand = true`.
- `end_box: TemplateChild<GtkBox>`: Container für Module am Ende (rechts bei LTR-Layout).
- `position: RefCell<PanelPosition>`: Speichert die aktuelle Panel-Position.
- `panel_height: Cell<i32>`: Speichert die aktuelle Panel-Höhe.
- `transparency_enabled: Cell<bool>`: Speichert den Transparenzstatus.
- `leuchtakzent_color: RefCell<Option<RGBA>>`: Speichert die Akzentfarbe.
- `leuchtakzent_intensity: Cell<f64>`: Speichert die Akzentintensität.
- `modules_start: RefCell<BTreeMap<i32, Vec<Widget>>>`: Geordnete Map von Modulen für den Startbereich. Schlüssel ist `order`.
- `modules_center: RefCell<BTreeMap<i32, Vec<Widget>>>`: Geordnete Map von Modulen für den Mittelbereich.
- `modules_end: RefCell<BTreeMap<i32, Vec<Widget>>>`: Geordnete Map von Modulen für den Endbereich.
- `drawing_area_for_accent: RefCell<Option<gtk::DrawingArea>>`: (Optional) Für benutzerdefiniertes Zeichnen des Akzents.

### **4. GTK-Widget-Implementierungsstrategie (Spezifikation für Manus AI)**

- **Basis-Widget:** Das `PanelWidget` erbt von `gtk::ApplicationWindow`. Diese Wahl ist entscheidend für die Integration mit `gtk4-layer-shell`, da dessen Funktionen (`init_for_window`, `set_layer`, `set_anchor`, `auto_exclusive_zone_enable` etc.) auf einem `gtk::Window` operieren.
- **Initialisierung von `gtk4-layer-shell`:**
    - `gtk_layer_shell::init_for_window(self_wrapper)`: Muss im `constructed`-Handler oder vor dem ersten `map`-Ereignis des Fensters aufgerufen werden.
    - `gtk_layer_shell::set_layer(self_wrapper, gtk_layer_shell::Layer::Top)`: Positioniert das Panel über normalen Anwendungsfenstern.
    - `gtk_layer_shell::set_keyboard_mode(self_wrapper, gtk_layer_shell::KeyboardMode::OnDemand)`: Erlaubt dem Panel oder seinen Kindern, Tastaturfokus zu erhalten, wenn sie ihn anfordern. `None` wäre auch eine Option, wenn Module den Fokus nicht benötigen oder ihn selbst über andere Mechanismen (wie Popovers) handhaben.
    - `gtk_layer_shell::auto_exclusive_zone_enable(self_wrapper)`: Sorgt dafür, dass das Panel Platz auf dem Bildschirm reserviert und andere maximierte Fenster nicht verdeckt.
    - `gtk_layer_shell::set_namespace(self_wrapper, "NovaDEPanel")`: Setzt einen eindeutigen Namespace für das Panel.
    - **Ankerpunkte (`set_anchor`):** Basierend auf der `position`-Eigenschaft werden die Anker gesetzt:
        - `PanelPosition::Top`: `Top=true, Left=true, Right=true, Bottom=false`.
        - `PanelPosition::Bottom`: `Bottom=true, Left=true, Right=true, Top=false`.
- **Internes Layout (Composite Template):**
    - Die interne Struktur des `PanelWidget` wird über eine UI-Datei (`panel_widget.ui`) definiert und als `CompositeTemplate` geladen.
    - **`main_box` (`GtkBox`, Orientation: Horizontal):** Dient als Hauptcontainer. Erstreckt sich über die gesamte Breite und Höhe des Panel-Fensters.
    - **`start_box` (`GtkBox`, Orientation: Horizontal):** Nimmt Module auf, die am Anfang (links) des Panels positioniert sind. `halign = GtkAlign::Start`.
    - **`center_box` (`GtkBox`, Orientation: Horizontal):** Nimmt Module auf, die in der Mitte des Panels positioniert sind. `halign = GtkAlign::Center`, `hexpand = true` (damit dieser Bereich den verfügbaren Platz ausfüllt).
    - **`end_box` (`GtkBox`, Orientation: Horizontal):** Nimmt Module auf, die am Ende (rechts) des Panels positioniert sind. `halign = GtkAlign::End`.
    - Alle drei Boxen (`start_box`, `center_box`, `end_box`) haben `valign = GtkAlign::Center`, um die Module vertikal zu zentrieren.
    - Ein Abstand (`spacing`) zwischen den Boxen und zwischen den Modulen innerhalb der Boxen kann in der `.ui`-Datei oder programmatisch gesetzt werden.
- **Benutzerdefiniertes Zeichnen:** Implementierung erfolgt wie unter Abschnitt 2 beschrieben, falls notwendig.

### **5. Methoden und Funktionssignaturen (Interne und Wrapper-Logik)**

#### **5.1. Interne Methoden (in `PanelWidgetImp`)**

- `fn update_css_classes(&self)`: Aktualisiert die CSS-Klassen des Wrapper-Widgets basierend auf den aktuellen Werten von `position` und `transparency_enabled`.
- `fn update_transparency_visual_internal(&self)`: Stellt das `GdkVisual` des Fensters um, um Transparenz zu aktivieren/deaktivieren.
- `pub(super) fn add_module_ordered(&self, module: &impl glib::IsA<gtk::Widget>, position: ModulePosition, order: i32)`:
    1. Fügt das `module` der entsprechenden internen `BTreeMap` (`modules_start`, `modules_center`, `modules_end`) unter dem Schlüssel `order` hinzu. Wenn bereits Module mit derselben `order` existieren, wird das neue Modul an die `Vec<Widget>` für diese `order` angehängt.
    2. Ruft `self.obj().update_module_layout_internal()` auf.
    3. Emittiert das `module-layout-changed`-Signal.
- `pub(super) fn remove_module_internal(&self, module_to_remove: &impl glib::IsA<gtk::Widget>)`:
    1. Durchsucht alle drei Modul-Maps (`modules_start`, `modules_center`, `modules_end`).
    2. Entfernt das `module_to_remove` (Vergleich über Widget-Zeiger oder eine eindeutige ID, falls Module IDs haben) aus der entsprechenden `BTreeMap` und der zugehörigen `Vec<Widget>`.
    3. Wenn das Modul entfernt wurde:
        - Entfernt das Widget physisch aus dem Eltern-`GtkBox`-Container (`start_box`, `center_box` oder `end_box`).
        - Ruft `self.obj().update_module_layout_internal()` auf.
        - Emittiert das `module-layout-changed`-Signal.

#### **5.2. Methoden des öffentlichen Wrappers (`super::PanelWidget`)**

- `fn setup_layer_shell_internal(&self)`: Führt die Konfiguration von `gtk4-layer-shell` durch, wie in Abschnitt 4 beschrieben. Wird bei der Initialisierung und bei Änderungen der `position`-Eigenschaft aufgerufen.
- `fn update_module_layout_internal(&self)`:
    1. Leert alle drei `GtkBox`-Container (`start_box`, `center_box`, `end_box`), indem alle existierenden Kinder entfernt werden.
    2. Iteriert über die sortierten Module in `imp.modules_start.borrow()` (BTreeMap iteriert Schlüssel sortiert). Für jede `order`, iteriere über die `Vec<Widget>` und füge jedes Widget der `imp.start_box` hinzu (`append`).
    3. Wiederholt Schritt 2 für `imp.modules_center` und `imp.center_box`.
    4. Wiederholt Schritt 2 für `imp.modules_end` und `imp.end_box`.

### **6. Signale (Spezifikation für Manus AI)**

#### **6.1. Emittierte Signale**

- **Signal: `module-layout-changed`**
    - **GObject Signal Name:** `module-layout-changed`
    - **Parameter:** Keine.
    - **Signal-Flags:** `glib::SignalFlags::ACTION` (oder `RUN_FIRST`/`RUN_LAST` je nach Bedarf).
    - **Beschreibung:** Wird emittiert, nachdem Module dem Panel hinzugefügt, daraus entfernt oder ihre Anordnung (durch `update_module_layout_internal`) geändert wurde.
    - **Zweck:** Ermöglicht anderen UI-Komponenten oder Logikmodulen, auf Änderungen im Panel-Layout zu reagieren, z.B. um Größen neu zu berechnen oder Fokus-Reihenfolgen anzupassen.
    - **Auslöser:** Aufruf von `add_module_ordered` oder `remove_module_internal` nach erfolgreicher Modifikation und Layout-Aktualisierung.

#### **6.2. Verbundene Signale (Reaktionen auf externe Events)**

- **Event:** `ThemeChangedEvent` (aus `domain::theming::ThemingEngine`)
    - **Handler-Aktion im `PanelWidget`:**
        1. Die neuen Design-Tokens aus dem `ThemeChangedEvent.new_state.resolved_tokens` extrahieren, die für das Panel relevant sind (insbesondere die Werte für `--leuchtakzent-color-rgba` und `--leuchtakzent-intensity-css`).
        2. Die GObject-Eigenschaften `leuchtakzent-color` und `leuchtakzent-intensity` des `PanelWidget` entsprechend aktualisieren (z.B. `self.set_leuchtakzent_color(Some(parsed_rgba_from_token))`).
        3. `self.queue_draw()` aufrufen, um ein Neuzeichnen des Panels (und des Akzents) zu erzwingen.
- **Signale von `gtk::Settings::default()`:**
    - `notify::gtk-theme-name`:
        - **Handler-Aktion:** Kann verwendet werden, um panel-spezifisches CSS neu zu laden oder Stile anzupassen, falls das Panel-Design stark vom System-GTK-Theme abhängt und nicht vollständig durch das NovaDE-Theming-System abgedeckt wird. Für NovaDE wird primär das eigene Theming-System verwendet, daher ist dies eher ein Fallback.
    - `notify::gtk-application-prefer-dark-theme`:
        - **Handler-Aktion:** Ähnlich wie bei `gtk-theme-name`. Wenn das NovaDE-Theming-System die Light/Dark-Modi nicht vollständig über `ThemeChangedEvent` steuert, kann hierauf reagiert werden, um z.B. CSS-Klassen für Dark Mode zu setzen/entfernen.

### **7. Ereignisbehandlung (Benutzerinteraktion)**

- Das `PanelWidget` selbst ist primär ein Container und reagiert nicht direkt auf komplexe Maus- oder Tastaturereignisse.
- Mausereignisse wie `enter-notify-event` und `leave-notify-event` könnten theoretisch für Tooltips auf dem Panel selbst verwendet werden, aber Tooltips sind eher für die einzelnen Module relevant.
- Der Tastaturfokus wird von den fokussierbaren Modulen innerhalb des Panels verwaltet, nicht vom Panel selbst.

### **8. Interaktionen mit anderen Komponenten/Modulen**

- **`domain::global_settings_and_state_management` (GlobalSettingsService):**
    - Das `PanelWidget` liest beim Start (oder bei Änderungen) seine Konfiguration (z.B. Standardposition, Standardhöhe, initiale Transparenz, welche Module standardmäßig geladen werden sollen) vom `GlobalSettingsService`.
    - Änderungen an diesen Einstellungen im `GlobalSettingsService` (z.B. durch `ui::control_center`) sollten ein `SettingChangedEvent` auslösen, auf das das `PanelWidget` reagiert, um seine GObject-Properties dynamisch anzupassen.
- **`system::compositor` (indirekt über `gtk4-layer-shell`):**
    - Die primäre Interaktion erfolgt über die `gtk4-layer-shell`-Bibliothek, um das Panel als Layer-Oberfläche im Wayland-Compositor zu positionieren und zu verwalten.
- **`domain::theming::ThemingEngine`:**
    - Das `PanelWidget` abonniert das `ThemeChangedEvent` der `ThemingEngine`, um Design-Tokens (insbesondere für `leuchtakzent-color` und Hintergrundstile) zu erhalten und anzuwenden.

### **9. Ausnahmebehandlung (Fehlerdefinitionen)**

Für das `PanelWidget`-Modul selbst werden spezifische Fehler mittels `thiserror` definiert, falls Operationen fehlschlagen können, die nicht durch GTK-interne Fehler abgedeckt sind.

- **Datei:** `src/ui/shell/panel_widget/error.rs`
    
- **Enum `PanelWidgetError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use gtk::glib; // Für glib::Error
    
    #[derive(Debug, Error)]
    pub enum PanelWidgetError {
        #[error("Fehler bei der Initialisierung der gtk-layer-shell: {0}")]
        LayerShellInitializationFailed(String), // Enthält Details des Fehlers
    
        #[error("Fehler beim Laden des UI-Templates für PanelWidget: {source}")]
        TemplateLoadError { #[from] source: glib::Error },
    
        #[error("Ungültige Modulposition angegeben: {position:?}")]
        InvalidModulePosition { position: super::imp::ModulePosition }, // super::imp verweist auf PanelWidgetImp
    
        #[error("Modul konnte nicht zum Panel hinzugefügt werden: {reason}")]
        ModuleAddFailed { reason: String },
    
        #[error("Modul konnte nicht vom Panel entfernt werden: {reason}")]
        ModuleRemoveFailed { reason: String },
    }
    ```
    
- **Verwendung:** Methoden wie `add_module_ordered` oder `remove_module_internal` könnten `Result<(), PanelWidgetError>` zurückgeben, obwohl in der GTK-Welt Fehler oft durch Signale oder Logging behandelt werden, anstatt Result-Typen in Widget-APIs zu verwenden. Für kritische Setup-Fehler ist `Result` jedoch angemessen. `gtk_layer_shell`-Funktionen geben keine direkten `Result`-Typen zurück, Fehler hier würden eher zu Panics oder visuellen Problemen führen; `LayerShellInitializationFailed` wäre also ein interner Fehler, der geloggt wird, falls die Initialisierung visuell fehlschlägt.
    

### **10. Auflösung "Untersuchungsbedarf" (aus dem Quelldokument)**

Der "Untersuchungsbedarf" bezüglich `gtk4-layer-shell`-Integration und Implementierung des "Leuchtakzents" wurde in den Abschnitten 2, 4 und 8 dieser Spezifikation adressiert.

- **Best Practices `gtk4-layer-shell`:** Initialisierung vor dem `map`-Ereignis, korrekte Wahl des `KeyboardMode`, Setzen eines Namespace, Ankerung für Positionierung und `auto_exclusive_zone_enable` sind spezifiziert. Multi-Monitor-Szenarien erfordern separate `PanelWidget`-Instanzen pro Monitor, die über Änderungen in der Monitorkonfiguration (`gdk::Display` Signale) verwaltet werden.
- **Implementierung "Leuchtakzent":** Präferenz für CSS `box-shadow`. Falls unzureichend, benutzerdefiniertes Zeichnen mit Cairo auf einer `gtk::DrawingArea` oder direkt im Panel-Fenster (unter Verwendung von `set_draw_func` für Widgets oder Snapshot-Funktion für komplexere Fälle). Details zur Verwendung von `gdk::RGBA`, `cairo::LinearGradient` und Transparenz sind spezifiziert.

### **11. Dateistruktur (Zusammenfassung)**

- `src/ui/shell/panel_widget/mod.rs` (Öffentliche API, GObject Wrapper)
- `src/ui/shell/panel_widget/imp.rs` (Private GObject Implementierung, Logik)
- `src/ui/shell/panel_widget/error.rs` (Spezifische Fehlerdefinitionen)
- `resources/ui/shell/panel_widget.ui` (XML-Definition für Composite Template)

Diese Struktur fördert Modularität und Trennung von Belangen.

**Nächster Schritt:** Detaillierte Spezifikation für `ui::shell::panel_widget::AppMenuButton`.

# **UI-Schicht: Ultra-Feinspezifikation und Implementierungsleitfaden**

## **Modul: ui::shell::panel_widget::AppMenuButton (Anwendungsmenü-Button)**

### **1. Modul-Identifikation und Zweck**

- **Modul-ID:** `ui::shell::panel_widget::AppMenuButton`
- **Übergeordnetes Modul:** `ui::shell::PanelWidget`
- **Abhängigkeiten:**
    - `novade-core`
    - `novade-domain` (potenziell für das Abrufen von Anwendungsmetadaten, falls nicht direkt über Systemschicht)
    - `novade-system` (insbesondere `system::compositor` für Informationen zum aktiven Fenster/AppID und `system::dbus` für die `org.gtk.Menus`-Schnittstelle)
    - `gtk4-rs` (GTK4 Rust Bindings)
    - `zbus` (für direkte D-Bus-Kommunikation, falls nicht vollständig von `novade-system` abstrahiert)
    - `once_cell`
    - `thiserror`
    - `tracing`
- **Zweck:** Das `AppMenuButton` ist ein spezialisiertes Panel-Modul, das als `gtk::MenuButton` (oder eine benutzerdefinierte Ableitung) implementiert wird. Seine Hauptverantwortung ist die Darstellung des globalen Anwendungsmenüs (typischerweise `GMenuModel`) der aktuell fokussierten Applikation. Es muss die aktive Anwendung identifizieren, deren Menümodell über D-Bus abrufen und dieses in einem `gtk::PopoverMenu` darstellen. Das Aussehen des Buttons (Icon, Name) wird dynamisch an die aktive Anwendung angepasst.

### **2. Visuelles Design und Theming (Spezifikation für Manus AI)**

- **Darstellung als Button:**
    - Standardmäßig wird das Icon der aktiven Anwendung angezeigt (`gtk::Image` im `gtk::MenuButton`).
    - **Fallback-Icon:** Wenn kein Anwendungsicon verfügbar ist oder keine Anwendung ein Menü bereitstellt, wird ein generisches "Anwendungsmenü"-Icon angezeigt (z.B. `application-menu-symbolic`).
    - **Beschriftung (Label):** Optional kann der Name der aktiven Anwendung (`gtk::Label`) neben dem Icon angezeigt werden. Dies ist konfigurierbar (z.B. über eine globale Einstellung) und hängt vom verfügbaren Platz im Panel ab. Standardmäßig wird nur das Icon angezeigt, um Platz zu sparen.
- **Tooltip:** Der Tooltip des `AppMenuButton` zeigt immer den Namen der aktiven Anwendung an, auch wenn dieser nicht als Label sichtbar ist (`gtk::Widget::set_tooltip_text()`).
- **PopoverMenu:** Beim Klick auf den Button wird ein `gtk::PopoverMenu` angezeigt, das die Menüeinträge des `GMenuModel` der aktiven Anwendung enthält. Das Styling dieses Popovers folgt dem globalen Theme.
- **Styling (CSS):**
    - **CSS-Knotenname:** `menubutton` (wenn von `gtk::MenuButton` geerbt) oder `button` (wenn eine benutzerdefinierte Schaltfläche mit manuellem Popover verwendet wird). Das Widget selbst bekommt den CSS-Namen `appmenubutton` (`klass.set_css_name("appmenubutton");`).
    - **CSS-Klassen (dynamisch):**
        - `.app-menu-button` (statisch): Allgemeine Klasse für spezifisches Styling.
        - `.active-app-menu` (dynamisch): Wird gesetzt, wenn ein Anwendungsmenü erfolgreich geladen und an den Button gebunden wurde.
        - `.no-app-menu` (dynamisch): Wird gesetzt, wenn kein Menü für die aktive Anwendung verfügbar ist, keine Anwendung fokussiert ist oder ein Fehler beim Laden des Menüs aufgetreten ist.
        - `.loading-app-menu` (dynamisch): Wird gesetzt, während das Menü aktiv geladen wird. Dies kann für ein visuelles Feedback (z.B. Spinner-ähnliche Zustandsänderung) genutzt werden.
- **Zustandsabhängiges Aussehen:**
    - **Kein Menü / Fehler:** Button könnte leicht ausgegraut oder mit einem speziellen Indikator versehen sein.
    - **Laden:** Ein subtiler Ladeindikator könnte angezeigt werden (z.B. pulsierendes Icon).

### **3. Datenstrukturen, Eigenschaften und Zustand (Spezifikation für Manus AI)**

Das `AppMenuButton` wird als benutzerdefiniertes GObject-Widget implementiert, das von `gtk::MenuButton` erbt.

#### **3.1. Datei: `src/ui/shell/panel_widget/app_menu_button/mod.rs` (Öffentliche API)**

Rust

```
use gtk::glib;
use gtk::subclass::prelude::*;
use gtk::{gio, MenuButton, Widget}; // Widget für IsA

mod imp;

glib::wrapper! {
    pub struct AppMenuButton(ObjectSubclass<imp::AppMenuButton>)
        @extends gtk::MenuButton, gtk::Button, gtk::Widget, // gtk::Button hinzugefügt
        @implements gtk::Accessible, gtk::Actionable, gtk::Buildable, gtk::ConstraintTarget;
}

impl AppMenuButton {
    pub fn new() -> Self {
        glib::Object::builder::<Self>().build()
    }

    /// Aktualisiert die Informationen über das aktive Fenster und löst ggf. eine Menüaktualisierung aus.
    /// Diese Methode wird typischerweise von einem übergeordneten Shell-Dienst aufgerufen,
    /// der Änderungen des Fensterfokus überwacht.
    ///
    /// # Parameter
    /// * `app_id`: Optionale ID der aktiven Anwendung (z.B. "org.gnome.TextEditor").
    /// * `app_name`: Optionaler Anzeigename der aktiven Anwendung.
    /// * `icon_name`: Optionaler Icon-Name der aktiven Anwendung.
    ///
    /// `noexcept`
    pub fn update_active_window_info(&self, app_id: Option<String>, app_name: Option<String>, icon_name: Option<String>) {
        self.imp().update_active_window_info_internal(app_id, app_name, icon_name);
    }

    // Methode, um das Menü explizit neu zu laden (z.B. bei manueller Aktion oder Fehlerwiederholung)
    pub fn refresh_menu(&self) {
        self.imp().trigger_menu_update_for_current_app_internal();
    }
}

impl Default for AppMenuButton {
    fn default() -> Self {
        Self::new()
    }
}
```

#### **3.2. Datei: `src/ui/shell/panel_widget/app_menu_button/imp.rs` (Private GObject-Implementierung)**

Rust

```
use gtk::glib::{self, Properties, ParamSpec, Value, subclass::Signal, Bytes};
use gtk::subclass::prelude::*;
use gtk::{gio, MenuButton, Button, Widget, Image, Label, Box as GtkBox, Orientation, PopoverMenu, Align};
use std::cell::{Cell, RefCell};
use std::sync::Arc; // Für zbus Connection
use once_cell::sync::Lazy;
use zbus::Connection; // Für D-Bus Kommunikation
use tracing;

use crate::ui::shell::panel_widget::app_menu_button::error::AppMenuButtonError; // Error-Typ

// ### Enums für internen Zustand ###
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
pub enum MenuFetchStatus {
    #[default]
    Idle, // Noch kein Versuch unternommen oder zurückgesetzt
    Loading, // Menü wird gerade über D-Bus geladen
    Success, // Menü erfolgreich geladen
    NoMenuAvailable, // Anwendung hat kein Menü oder D-Bus-Dienst nicht gefunden
    Error(AppMenuButtonError), // Ein spezifischer Fehler ist aufgetreten
}

// Notwendig für Speicherung in GObject Property, falls der Status als Property verfügbar gemacht wird
// impl ToValue for MenuFetchStatus { ... }
// impl FromValue for MenuFetchStatus { ... }

// ### GObject Properties Definition ###
static APP_MENU_BUTTON_PROPERTIES: Lazy<Vec<ParamSpec>> = Lazy::new(|| {
    vec![
        ParamSpec::new_string(
            "active-app-name",
            "Active Application Name",
            "Name der Anwendung, deren Menü angezeigt wird oder angezielt ist.",
            None, // Kein Default-Wert, da dynamisch
            glib::ParamFlags::READABLE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_string(
            "active-app-icon-name",
            "Active Application Icon Name",
            "Icon-Name der Anwendung, deren Menü angezielt ist.",
            None,
            glib::ParamFlags::READABLE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_boolean(
            "has-menu",
            "Has Menu",
            "true, wenn ein Menü für die aktive Anwendung verfügbar und geladen ist.",
            false, // Default
            glib::ParamFlags::READABLE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        // Potenziell eine Property für MenuFetchStatus, aber String oder Int Enum wäre einfacher für GObject
    ]
});

#[derive(Default)]
pub struct AppMenuButton {
    // UI-Elemente (falls nicht über CompositeTemplate)
    // Stattdessen als Teil des MenuButton-Parents oder im Popover
    button_content_box: RefCell<Option<GtkBox>>, // Box für Icon und Label
    app_icon_widget: RefCell<Option<Image>>,
    app_name_widget: RefCell<Option<Label>>,
    popover_menu: RefCell<Option<PopoverMenu>>,

    // GObject Properties
    #[property(get, explicit_notify)]
    active_app_name: RefCell<Option<String>>,
    #[property(get, explicit_notify)]
    active_app_icon_name: RefCell<Option<String>>,
    #[property(get, explicit_notify)]
    has_menu: Cell<bool>,

    // Interner Zustand
    active_app_id_internal: RefCell<Option<String>>, // Unterscheidung zum Property für interne Nutzung
    menu_fetch_status_internal: RefCell<MenuFetchStatus>,
    current_menu_model_internal: RefCell<Option<gio::MenuModel>>,
    dbus_connection: RefCell<Option<Arc<Connection>>>, // Arc für Teilen mit async Tasks

    // Service-Abhängigkeit (von ui::shell oder Systemschicht)
    // Annahme: Ein Dienst liefert aktive Fensterinformationen und D-Bus-Verbindung
    // active_window_monitor: RefCell<Option<Arc<dyn ActiveWindowMonitoringService>>>,
    // Wird hier vereinfacht durch direkte D-Bus-Nutzung und Aufruf von update_active_window_info
}

#[glib::object_subclass]
impl ObjectSubclass for AppMenuButton {
    const NAME: &'static str = "NovaDEAppMenuButton";
    type Type = super::AppMenuButton; // Der öffentliche Wrapper
    type ParentType = gtk::MenuButton;

    fn class_init(klass: &mut Self::Class) {
        klass.install_properties(&APP_MENU_BUTTON_PROPERTIES);
        klass.set_css_name("appmenubutton");
    }
}

#[glib::derived_properties]
impl ObjectImpl for AppMenuButton {
    fn constructed(&self) {
        self.parent_constructed();
        let obj = self.obj(); // Der öffentliche Wrapper `super::AppMenuButton`

        // Standard-Icon und Popover setzen
        let icon = Image::from_icon_name("application-menu-symbolic");
        let label = Label::new(None);
        label.set_visible(false); // Standardmäßig kein Label
        let content_box = GtkBox::new(GtkOrientation::Horizontal, 6);
        content_box.append(&icon);
        content_box.append(&label);
        obj.set_child(Some(&content_box));

        self.button_content_box.replace(Some(content_box));
        self.app_icon_widget.replace(Some(icon));
        self.app_name_widget.replace(Some(label));

        let popover = PopoverMenu::new_from_model(None::<&gio::MenuModel>); // Initial leer
        obj.set_popover(Some(&popover));
        self.popover_menu.replace(Some(popover));

        // Initialisiere D-Bus Verbindung asynchron
        let widget_clone = obj.clone();
        glib::MainContext::default().spawn_local(async move {
            match Connection::session().await {
                Ok(conn) => {
                    widget_clone.imp().dbus_connection.replace(Some(Arc::new(conn)));
                    tracing::info!("AppMenuButton: D-Bus Session-Verbindung hergestellt.");
                    // Initiales Update versuchen, falls schon eine App fokussiert ist (Info müsste von außen kommen)
                }
                Err(e) => {
                    tracing::error!("AppMenuButton: Fehler beim Verbinden zum D-Bus Session-Bus: {}", e);
                    widget_clone.imp().menu_fetch_status_internal.replace(MenuFetchStatus::Error(AppMenuButtonError::DBusConnectionError(e.to_string())));
                    widget_clone.imp().update_button_appearance_and_state_internal();
                }
            }
        });
        self.update_button_appearance_and_state_internal(); // Initiales Aussehen setzen
    }
}

impl WidgetImpl for AppMenuButton {}
impl ButtonImpl for AppMenuButton {} // Notwendig, da gtk::MenuButton von gtk::Button erbt
impl MenuButtonImpl for AppMenuButton {}

// ### Interne Implementierungsmethoden für AppMenuButtonImp ###
impl AppMenuButton {
    pub(super) fn update_active_window_info_internal(&self, app_id: Option<String>, app_name: Option<String>, icon_name: Option<String>) {
        tracing::debug!("AppMenuButton: update_active_window_info: app_id={:?}, name={:?}, icon={:?}", app_id, app_name, icon_name);
        let current_app_id = self.active_app_id_internal.borrow().clone();

        // Nur neu laden, wenn sich die app_id geändert hat oder vorher None war
        let needs_menu_update = current_app_id != app_id || (current_app_id.is_none() && app_id.is_some());

        self.active_app_id_internal.replace(app_id.clone());
        // Die Properties direkt über den Wrapper setzen, um Notify auszulösen
        self.obj().set_property("active-app-name", app_name.to_value());
        self.obj().set_property("active-app-icon-name", icon_name.to_value());
        // self.active_app_name.replace(app_name); // Direktes Setzen ohne Notify
        // self.active_app_icon_name.replace(icon_name); // Direktes Setzen ohne Notify

        if needs_menu_update {
            if app_id.is_some() {
                self.trigger_menu_update_for_current_app_internal();
            } else {
                // Keine aktive App, Menü zurücksetzen
                self.current_menu_model_internal.replace(None);
                self.obj().set_menu_model(None::<&gio::MenuModel>);
                self.menu_fetch_status_internal.replace(MenuFetchStatus::Idle);
                self.obj().set_property("has-menu", false);
            }
        }
        self.update_button_appearance_and_state_internal();
    }

    pub(super) fn trigger_menu_update_for_current_app_internal(&self) {
        let app_id_opt = self.active_app_id_internal.borrow().clone();
        let dbus_conn_opt = self.dbus_connection.borrow().clone();

        if let (Some(app_id), Some(dbus_conn)) = (app_id_opt, dbus_conn_opt) {
            if app_id.is_empty() {
                tracing::warn!("AppMenuButton: Leere AppID erhalten, Menü-Update übersprungen.");
                self.menu_fetch_status_internal.replace(MenuFetchStatus::Error(AppMenuButtonError::MenuNotFound("Leere AppID".to_string())));
                self.update_button_appearance_and_state_internal();
                return;
            }

            tracing::info!("AppMenuButton: Starte Menü-Update für AppID: {}", app_id);
            self.menu_fetch_status_internal.replace(MenuFetchStatus::Loading);
            self.update_button_appearance_and_state_internal(); // Ladezustand anzeigen

            let widget_clone = self.obj().clone(); // Klon des Wrappers
            glib::MainContext::default().spawn_local(async move {
                let result = Self::fetch_menu_for_app_async(dbus_conn, app_id.clone()).await;
                widget_clone.imp().handle_menu_fetch_result_internal(result, &app_id);
            });
        } else {
            tracing::debug!("AppMenuButton: Keine AppID oder D-Bus-Verbindung für Menü-Update vorhanden.");
            self.menu_fetch_status_internal.replace(MenuFetchStatus::Idle);
            if app_id_opt.is_none() { // Explizit kein Menü, wenn keine AppID
                 self.obj().set_menu_model(None::<&gio::MenuModel>);
                 self.obj().set_property("has-menu", false);
            }
            self.update_button_appearance_and_state_internal();
        }
    }

    async fn fetch_menu_for_app_async(dbus_conn: Arc<Connection>, app_id: String) -> Result<gio::MenuModel, AppMenuButtonError> {
        // Primärer Mechanismus: org.gtk.Menus auf dem Bus-Namen der Anwendung
        // Standardpfade sind /org/gtk/menus/menubar oder /org/gtk/menus/appmenu
        // oder ein von GApplication festgelegter Pfad.
        // Hier wird versucht, gängige Pfade zu prüfen.
        let common_paths = [
            "/org/gtk/menus/menubar",
            "/org/gtk/menus/appmenu",
            &format!("/{}", app_id.replace('.', "/")), // z.B. /org/gnome/TextEditor
            "/", // Manchmal exportieren Apps Menüs direkt am Root-Pfad ihres Bus-Namens
        ];

        for path_str in common_paths.iter() {
            // Zuerst versuchen, direkt ein DBusMenuModel zu erstellen,
            // was die org.gtk.Menus Schnittstelle verwendet.
            match gio::DBusMenuModel::new(&dbus_conn, Some(app_id.as_str()), path_str) {
                Ok(menu_model) => {
                    // Prüfen, ob das Menü tatsächlich Items hat, da ein leeres Modell nicht nützlich ist.
                    // DBusMenuModel ist ein Live-Objekt, Änderungen werden reflektiert.
                    // Ein einfacher Check hier ist schwierig, da n_items() nicht direkt auf MenuModel existiert.
                    // Wir vertrauen darauf, dass ein erfolgreich erstelltes Modell gültig ist.
                    tracing::info!("AppMenuButton: GMenuModel für '{}' an Pfad '{}' erfolgreich via org.gtk.Menus bezogen.", app_id, path_str);
                    return Ok(menu_model.upcast::<gio::MenuModel>());
                }
                Err(e) => {
                    tracing::debug!("AppMenuButton: Kein GMenuModel für '{}' an Pfad '{}' via org.gtk.Menus gefunden: {}", app_id, path_str, e);
                }
            }
        }
        
        // Fallback: com.canonical.AppMenu.Registrar (veraltet und X11-lastig, hier nur als Referenz)
        // Für eine reine Wayland-Umgebung ist dies weniger relevant, es sei denn, XWayland-Apps nutzen es.
        // Diese Logik wird hier nicht vollständig implementiert, da sie komplex ist und oft nicht funktioniert.
        // tracing::warn!("AppMenuButton: Fallback zu com.canonical.AppMenu.Registrar nicht implementiert.");

        tracing::warn!("AppMenuButton: Kein Menü für AppID '{}' auf bekannten Pfaden gefunden.", app_id);
        Err(AppMenuButtonError::MenuNotFound(app_id))
    }

    fn handle_menu_fetch_result_internal(&self, result: Result<gio::MenuModel, AppMenuButtonError>, app_id_for_result: &str) {
        // Sicherstellen, dass das Ergebnis noch für die aktuell aktive App relevant ist.
        // Wenn der Benutzer schnell die App gewechselt hat, könnte dieses Ergebnis veraltet sein.
        let current_app_id = self.active_app_id_internal.borrow();
        if current_app_id.as_deref() != Some(app_id_for_result) {
            tracing::info!("AppMenuButton: Menü-Ergebnis für '{}' ist veraltet, aktuelle App ist '{:?}'. Ignoriere.", app_id_for_result, current_app_id);
            // Status nicht ändern, da ein neuer Ladevorgang ggf. läuft
            return;
        }

        match result {
            Ok(menu_model) => {
                tracing::info!("AppMenuButton: Menü für '{}' erfolgreich geladen.", app_id_for_result);
                self.current_menu_model_internal.replace(Some(menu_model.clone()));
                self.obj().set_menu_model(Some(&menu_model));
                self.menu_fetch_status_internal.replace(MenuFetchStatus::Success);
                self.obj().set_property("has-menu", true);
            }
            Err(e) => {
                tracing::warn!("AppMenuButton: Fehler beim Laden des Menüs für '{}': {:?}", app_id_for_result, e);
                self.current_menu_model_internal.replace(None);
                self.obj().set_menu_model(None::<&gio::MenuModel>);
                self.menu_fetch_status_internal.replace(MenuFetchStatus::Error(e.clone())); // Klonen des Fehlers
                 if matches!(e, AppMenuButtonError::MenuNotFound(_)) {
                    self.menu_fetch_status_internal.replace(MenuFetchStatus::NoMenuAvailable);
                }
                self.obj().set_property("has-menu", false);
            }
        }
        self.update_button_appearance_and_state_internal();
    }

    fn update_button_appearance_and_state_internal(&self) {
        let obj = self.obj();
        let status = *self.menu_fetch_status_internal.borrow();
        let has_actual_menu = self.current_menu_model_internal.borrow().is_some() && status == MenuFetchStatus::Success;

        // CSS-Klassen aktualisieren
        obj.remove_css_class("no-app-menu");
        obj.remove_css_class("active-app-menu");
        obj.remove_css_class("loading-app-menu");

        if has_actual_menu {
            obj.add_css_class("active-app-menu");
        } else if status == MenuFetchStatus::NoMenuAvailable || matches!(status, MenuFetchStatus::Error(_)) || self.active_app_id_internal.borrow().is_none() {
            obj.add_css_class("no-app-menu");
        } else if status == MenuFetchStatus::Loading {
            obj.add_css_class("loading-app-menu");
        }

        // Sensitivität des Buttons
        obj.set_sensitive(has_actual_menu || status == MenuFetchStatus::Loading); // Aktiv während Laden, um Klick auf leeres Popover zu verhindern

        // Icon und Label (Label wird hier nicht primär verwendet)
        let icon_widget_opt = self.app_icon_widget.borrow();
        if let Some(icon_widget) = icon_widget_opt.as_ref() {
            let icon_name_prop = self.obj().property::<Option<String>>("active-app-icon-name");
            if let Some(icon_name_str) = icon_name_prop.as_ref().filter(|s| !s.is_empty()) {
                icon_widget.set_from_icon_name(Some(icon_name_str));
            } else {
                icon_widget.set_from_icon_name(Some("application-menu-symbolic")); // Fallback
            }
        }
        
        // Tooltip aktualisieren
        let app_name_prop = self.obj().property::<Option<String>>("active-app-name");
        if let Some(name_str) = app_name_prop.as_ref().filter(|s| !s.is_empty()) {
            obj.set_tooltip_text(Some(name_str));
        } else {
            obj.set_tooltip_text(Some("Anwendungsmenü")); // Fallback-Tooltip
        }
    }
}

```

#### **3.3. GObject-Eigenschaften (Zusammenfassung)**

|Eigenschaftsname|Rust-Feld (Imp)|Typ (Rust / GLib)|Zugriff|Standardwert|Beschreibung|
|:--|:--|:--|:--|:--|:--|
|`active-app-name`|`active_app_name`|`Option<String>` / G_TYPE_STRING|R|`None`|Name der Anwendung, deren Menü angezeigt wird oder angezielt ist.|
|`active-app-icon-name`|`active_app_icon_name`|`Option<String>` / G_TYPE_STRING|R|`None`|Icon-Name der Anwendung.|
|`has-menu`|`has_menu`|`bool` / G_TYPE_BOOLEAN|R|`false`|`true`, wenn ein Menü für die aktive Anwendung verfügbar und geladen ist.|
|(Parent `menu-model`)|N/A (Parent-Eigenschaft)|`Option<gio::MenuModel>` / G_TYPE_OBJECT|R/W|`None`|Das Menümodell, das im Popover angezeigt wird. Wird von dieser Logik gesetzt.|
|(Parent `icon-name`)|N/A (Parent-Eigenschaft)|`Option<String>`|R/W|`None`|Das Icon des MenuButtons selbst. Diese Logik setzt das Icon eines Kind-Widgets.|
|(Parent `label`)|N/A (Parent-Eigenschaft)|`Option<String>`|R/W|`None`|Das Label des MenuButtons selbst. Diese Logik setzt das Label eines Kind-Widgets.|

In Google Sheets exportieren

#### **3.4. Interner Zustand (Felder in `AppMenuButtonImp`)**

- `button_content_box: RefCell<Option<GtkBox>>`: Container für Icon und optionales Label im Button.
- `app_icon_widget: RefCell<Option<Image>>`: Das `gtk::Image`-Widget für das Anwendungsicon.
- `app_name_widget: RefCell<Option<Label>>`: Das `gtk::Label`-Widget für den Anwendungsnamen (standardmäßig unsichtbar).
- `popover_menu: RefCell<Option<PopoverMenu>>`: Das `gtk::PopoverMenu`, das an den `gtk::MenuButton` gebunden ist.
- `active_app_id_internal: RefCell<Option<String>>`: Speichert die ID der aktuell fokussierten Anwendung. Dient als Trigger für Menü-Updates.
- `menu_fetch_status_internal: RefCell<MenuFetchStatus>`: Verfolgt den Zustand des Menüabrufs (Idle, Loading, Success, Error, NoMenuAvailable).
- `current_menu_model_internal: RefCell<Option<gio::MenuModel>>`: Hält das aktuell geladene `GMenuModel`.
- `dbus_connection: RefCell<Option<Arc<Connection>>>`: Die D-Bus-Verbindung für Abfragen. `Arc` wird verwendet, um die Verbindung sicher mit asynchronen Tasks zu teilen, die das Menü laden.

### **4. GTK-Widget-Implementierungsstrategie (Spezifikation für Manus AI)**

- **Basis-Widget:** Das `AppMenuButton` erbt von `gtk::MenuButton`. Diese Klasse bietet bereits die Funktionalität, ein Popover beim Klick anzuzeigen.
- **Button-Inhalt:**
    - Das `AppMenuButton` verwendet intern ein `GtkBox` (horizontal orientiert) als Kind-Widget, um ein `gtk::Image` (für das Icon) und optional ein `gtk::Label` (für den Anwendungsnamen) aufzunehmen. Standardmäßig ist nur das Icon sichtbar.
    - Das Icon wird basierend auf `active_app_icon_name` aktualisiert.
- **Popover und Menümodell:**
    - Ein `gtk::PopoverMenu` wird erstellt und als Popover für den `gtk::MenuButton` gesetzt (`obj.set_popover(Some(&popover))`).
    - Die Eigenschaft `menu-model` des `gtk::MenuButton` (oder direkt des `gtk::PopoverMenu`) wird dynamisch mit dem über D-Bus abgerufenen `gio::MenuModel` aktualisiert: `obj.set_menu_model(Some(&menu_model))`.
    - Wenn kein Menü verfügbar ist oder ein Fehler auftritt, wird `obj.set_menu_model(None::<&gio::MenuModel>)` gesetzt.

### **5. Methoden und Funktionssignaturen (Interne und Wrapper-Logik)**

#### **5.1. Interne Methoden (in `AppMenuButtonImp`)**

- `fn update_active_window_info_internal(&self, app_id: Option<String>, app_name: Option<String>, icon_name: Option<String>)`:
    1. Aktualisiert die internen Felder `active_app_id_internal`.
    2. Setzt die GObject-Properties `active-app-name` und `active-app-icon-name` des Wrapper-Objekts, um `notify`-Signale auszulösen.
    3. Wenn sich die `app_id` geändert hat oder von `None` zu `Some` wurde:
        - Wenn `app_id` `Some` ist und nicht leer: Ruft `trigger_menu_update_for_current_app_internal()` auf.
        - Wenn `app_id` `None` ist: Setzt `current_menu_model_internal` auf `None`, ruft `obj.set_menu_model(None)` auf, setzt `menu_fetch_status_internal` auf `Idle` und `has-menu` Property auf `false`.
    4. Ruft `update_button_appearance_and_state_internal()` auf.
- `fn trigger_menu_update_for_current_app_internal(&self)`:
    1. Holt `active_app_id_internal` und `dbus_connection`.
    2. Wenn beide `Some` sind und `app_id` nicht leer ist:
        - Setzt `menu_fetch_status_internal` auf `Loading`.
        - Ruft `update_button_appearance_and_state_internal()` auf, um Ladezustand anzuzeigen.
        - Startet eine asynchrone Task (`glib::MainContext::default().spawn_local`) die `Self::fetch_menu_for_app_async(dbus_conn_arc, app_id_str).await` aufruft.
        - Der Callback dieser Task ruft `self.handle_menu_fetch_result_internal(result, &original_app_id_str)` auf.
    3. Wenn keine `app_id` oder keine D-Bus-Verbindung: Setzt Status auf `Idle`, `set_menu_model(None)`, `set_property("has-menu", false)` und aktualisiert Aussehen.
- `async fn fetch_menu_for_app_async(dbus_conn: Arc<Connection>, app_id: String) -> Result<gio::MenuModel, AppMenuButtonError>`:
    1. Versucht, ein `gio::DBusMenuModel` für die gegebene `app_id` und gängige D-Bus-Objektpfade (z.B. `/org/gtk/menus/menubar`, `/org/gtk/menus/appmenu`, `/{app_id_als_pfad}`, `/`) über die `org.gtk.Menus`-Schnittstelle zu erstellen.
        - Nutzt `gio::DBusMenuModel::new(&dbus_conn, Some(app_id.as_str()), path_str)`.
    2. Wenn erfolgreich für einen Pfad: Gibt `Ok(menu_model.upcast())` zurück.
    3. Wenn alle Versuche fehlschlagen: Gibt `Err(AppMenuButtonError::MenuNotFound(app_id))` zurück.
    4. D-Bus-Verbindungsfehler werden als `AppMenuButtonError::DBusError` behandelt.
- `fn handle_menu_fetch_result_internal(&self, result: Result<gio::MenuModel, AppMenuButtonError>, app_id_for_result: &str)`:
    1. Prüft, ob das Ergebnis noch für die aktuell in `active_app_id_internal` gespeicherte App relevant ist. Wenn nicht, ignoriere das Ergebnis (Logge Warnung).
    2. Bei `Ok(menu_model)`:
        - Setzt `current_menu_model_internal` auf `Some(menu_model.clone())`.
        - Ruft `self.obj().set_menu_model(Some(&menu_model))`.
        - Setzt `menu_fetch_status_internal` auf `Success`.
        - Setzt die `has-menu` Property auf `true`.
    3. Bei `Err(e)`:
        - Setzt `current_menu_model_internal` auf `None`.
        - Ruft `self.obj().set_menu_model(None)`.
        - Setzt `menu_fetch_status_internal` auf `Error(e.clone())` oder `NoMenuAvailable` (wenn `e` ein `MenuNotFound` Fehler ist).
        - Setzt die `has-menu` Property auf `false`.
    4. Ruft `update_button_appearance_and_state_internal()` auf.
- `fn update_button_appearance_and_state_internal(&self)`:
    1. Aktualisiert CSS-Klassen (`active-app-menu`, `no-app-menu`, `loading-app-menu`) basierend auf `menu_fetch_status_internal` und ob `current_menu_model_internal` `Some` ist.
    2. Setzt die Sensitivität des Buttons (`gtk::Widget::set_sensitive()`). Der Button ist sensitiv, wenn ein Menü erfolgreich geladen wurde oder gerade geladen wird (um das Popover zu öffnen, das dann ggf. leer ist oder eine Ladeanzeige hat – hier wird es sensitiv, wenn `has_actual_menu` oder `status == Loading`).
    3. Aktualisiert das Icon im `app_icon_widget` basierend auf der `active-app-icon-name` Property (oder Fallback-Icon).
    4. Aktualisiert das Label im `app_name_widget` (falls sichtbar) basierend auf der `active-app-name` Property.
    5. Aktualisiert den Tooltip des Wrapper-Buttons (`obj.set_tooltip_text()`) mit dem Wert der `active-app-name` Property oder einem Fallback-Text.

#### **5.2. Methoden des öffentlichen Wrappers (`super::AppMenuButton`)**

- `pub fn new() -> Self`: Erstellt die Instanz.
- `pub fn update_active_window_info(&self, app_id: Option<String>, app_name: Option<String>, icon_name: Option<String>)`: Ruft die interne `update_active_window_info_internal` auf.
- `pub fn refresh_menu(&self)`: Ruft die interne `trigger_menu_update_for_current_app_internal` auf.

### **6. Signale**

- **Emittierte Signale:** Keine spezifischen benutzerdefinierten Signale für diese Komponente vorgesehen. Erbt und nutzt Signale von `gtk::MenuButton` (z.B. `clicked`, `activate` für Aktionen im Menü) und GObject-Properties (`notify::property-name`).
- **Verbundene Signale:**
    - Keine direkten Verbindungen zu externen Signalen in dieser Komponente. Es wird erwartet, dass ein übergeordneter Dienst (z.B. in `ui::shell` oder der Systemschicht) Änderungen des aktiven Fensters überwacht (z.B. mittels Wayland-Protokollen wie `wlr-foreign-toplevel-management`) und dann `AppMenuButton::update_active_window_info()` aufruft.

### **7. Interaktionen mit anderen Komponenten/Modulen**

- **`ui::shell`-Dienst (oder äquivalenter Systemdienst):**
    - Verantwortlich für die Überwachung des globalen Fensterfokus.
    - Ruft `AppMenuButton::update_active_window_info()` auf, wenn sich das aktive Anwendungsfenster ändert, und übergibt `app_id` (z.B. aus `zwlr_foreign_toplevel_handle_v1.app_id`), `app_name` (aus Fenstertitel oder App-Metadaten) und `icon_name`.
- **D-Bus (direkt oder via `novade-system`):**
    - Das `AppMenuButton` (bzw. seine `imp`-Logik) stellt direkt D-Bus-Anfragen über `zbus`, um das `GMenuModel` von Anwendungen abzurufen, die die `org.gtk.Menus`-Schnittstelle auf ihrem Anwendungs-Bus-Namen bereitstellen.
- **`domain::global_settings_and_state_management`:**
    - Könnte verwendet werden, um Konfigurationsoptionen für das `AppMenuButton` zu speichern (z.B. ob der Anwendungsname neben dem Icon angezeigt werden soll).

### **8. Ausnahmebehandlung (Fehlerdefinitionen)**

- **Datei:** `src/ui/shell/panel_widget/app_menu_button/error.rs`
    
- **Enum `AppMenuButtonError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    
    #[derive(Debug, Clone, Error, PartialEq, Eq)] // Clone, PartialEq, Eq für MenuFetchStatus::Error
    pub enum AppMenuButtonError {
        #[error("D-Bus connection error: {0}")]
        DBusConnectionError(String), // Enthält zbus::Error::to_string()
    
        #[error("D-Bus call failed for app '{app_id}': {dbus_error_name} - {dbus_error_message}")]
        DBusCallFailed {
            app_id: String,
            dbus_error_name: String,
            dbus_error_message: String,
        },
    
        #[error("Menu model not found for application '{0}'.")]
        MenuNotFound(String), // app_id
    
        #[error("Failed to parse menu model for application '{app_id}': {details}")]
        MenuModelParseError { app_id: String, details: String },
    
        #[error("Active window information (app_id) is missing or invalid.")]
        MissingWindowInfo,
    
        #[error("An internal error occurred in AppMenuButton: {0}")]
        InternalError(String),
    }
    ```
    
- Fehler werden im `MenuFetchStatus::Error(AppMenuButtonError)` gespeichert und beeinflussen das Aussehen und die Sensitivität des Buttons. Fehlerdetails werden via `tracing` geloggt.
    

### **9. Auflösung "Untersuchungsbedarf" (aus dem Quelldokument)**

- **Zuverlässige Methode zur Ermittlung des aktiven Fensters/app_id unter Wayland:**
    - Dies ist _nicht_ die direkte Verantwortung des `AppMenuButton`. Ein übergeordneter Dienst (Teil von `ui::shell` oder `novade-system`) muss diese Information bereitstellen.
    - Dieser Dienst verwendet Protokolle wie `wlr-foreign-toplevel-management-unstable-v1` oder `ext-foreign-toplevel-list-v1`.
    - Das `activated`-Ereignis von `zwlr_foreign_toplevel_handle_v1` signalisiert das fokussierte Fenster. Dessen `app_id` wird dann an `AppMenuButton::update_active_window_info()` übergeben.
- **Ermittlung und Konsumierung von `GMenuModel` via D-Bus:**
    - Die Methode `Workspace_menu_for_app_async` implementiert dies.
    - **Primärer Pfad:** `gio::DBusMenuModel::new()` wird verwendet, um das Menü von `bus_name = app_id` und gängigen Objektpfaden (`/org/gtk/menus/menubar`, `/org/gtk/menus/appmenu`, anwendungsspezifischer Pfad) zu beziehen. Dies nutzt die `org.gtk.Menus`-Schnittstelle.
    - **Fallbacks (StatusNotifierItem, AppMenuRegistrar):** Sind für eine moderne Wayland-Umgebung weniger relevant. `StatusNotifierItem.Menu` (D-Bus-Pfad zu `com.canonical.dbusmenu`) könnte ein seltener Fall sein. `AppMenuRegistrar` ist X11-lastig und wird hier nicht priorisiert. Die Spezifikation fokussiert sich auf `org.gtk.Menus`.

### **10. Dateistruktur (Zusammenfassung)**

- `src/ui/shell/panel_widget/app_menu_button/mod.rs` (Öffentliche API, GObject Wrapper)
- `src/ui/shell/panel_widget/app_menu_button/imp.rs` (Private GObject Implementierung, Logik)
- `src/ui/shell/panel_widget/app_menu_button/error.rs` (Spezifische Fehlerdefinitionen)

Diese detaillierte Spezifikation für das `AppMenuButton`-Modul sollte eine klare Grundlage für die Implementierung bieten. Die Aspekte der Fensterfokus-Überwachung sind ausgelagert, was die Komplexität dieses Widgets reduziert und es auf seine Kernaufgabe – das Abrufen und Anzeigen des Anwendungsmenüs – fokussiert.


---

1. **Definierte APIs (Traits & öffentliche Funktionen):**
    
    - **Kernschicht:** Stellt ihre Funktionalität über `pub` Funktionen und direkt nutzbare `pub` Typen bereit.
    - **Domänenschicht:** Definiert ihre Service-Schnittstellen primär über `pub trait ...: Send + Sync {}` (oft mit `#[async_trait::async_trait]`). Diese Traits werden von konkreten Service-Strukturen implementiert, die typischerweise mit `Arc<tokio::sync::Mutex/RwLock<InternalState>>` arbeiten, um Zustand zu verwalten.
    - **Systemschicht:** Definiert ebenfalls Service-Schnittstellen über Traits für Funktionen, die von der UI-Schicht aufgerufen werden können (z.B. `SystemPowerControlTrait`). Für interne Operationen oder Callbacks von externen Bibliotheken (z.B. Smithay Handler) werden konkrete `impl` Blöcke für die zentralen Zustandsstrukturen (`DesktopState`) verwendet.
    - **UI-Schicht:** Nutzt die Traits der Domänen- und Systemschicht. Interne UI-Komponenten kommunizieren über GTK-Signale, Rust-Methodenaufrufe und ggf. interne Event-Bus-Mechanismen (z.B. `glib::Sender/Receiver` für thread-übergreifende Kommunikation innerhalb der UI).
2. **Event-System (Nachrichtenbasierte Kommunikation):**
    
    - **Domänenschicht-Events:** Werden über `tokio::sync::broadcast` Kanäle von Domänen-Services publiziert. Subscriber (in Domäne, System oder UI) erhalten Klone der Event-Datenstrukturen. Event-Strukturen sind `#[derive(Debug, Clone, Serialize, Deserialize)]` (Serialize/Deserialize für Logging oder potenzielle IPC).
    - **Systemschicht-Events (intern & extern):**
        - Intern: Der `system::event_bridge` (mit `tokio::sync::broadcast`) verteilt System-interne Ereignisse (z.B. `UPowerEvent`, `AudioEvent`, `InputDeviceHotplugEvent`).
        - Extern (für UI): Die Systemschicht übersetzt relevante Low-Level-Systemereignisse (z.B. Wayland-Events, D-Bus-Signale) in spezifische, UI-konsumierbare Events oder aktualisiert Zustände, die von der UI periodisch abgefragt oder über Callbacks (z.B. `glib::idle_add`) verarbeitet werden. Wayland-Events (wie `xdg_surface.configure`) sind ein primärer Kommunikationsweg vom Compositor zu den Anwendungsfenstern (Clients) und indirekt zur UI-Shell.
    - **UI-Schicht-Events:** GTK4-Signale (`button.connect_clicked(...)`), `glib::Property` Benachrichtigungen, benutzerdefinierte Signale auf Widgets.
3. **Direktionale Abhängigkeiten:**
    
    - Kern → (von Domäne, System, UI genutzt)
    - Domäne → (von System, UI genutzt)
    - System → (von UI genutzt)
    - Keine zyklischen Abhängigkeiten zwischen den Hauptschichten-Crates (`novade-core`, `novade-domain`, `novade-system`, `novade-ui`).
4. **Datenfluss und Transformation:**
    
    - Daten, die zwischen Schichten ausgetauscht werden, sind klar definierte Rust-Structs oder -Enums.
    - Wenn eine Schicht Daten von einer tieferen Schicht empfängt, kann sie diese in ihre eigenen internen Repräsentationen transformieren (z.B. D-Bus-`zvariant::Value` wird in der Systemschicht zu einer Rust-Struktur, die dann ggf. an die Domänenschicht als Domänenobjekt weitergegeben wird).

---

**Schnittstellen im Detail (Ultra-Feinspezifikation):**

---

**1. Schnittstelle: Kernschicht (`novade-core`) zu höheren Schichten**

Diese Schnittstelle ist unidirektional. Die Kernschicht stellt Funktionalität bereit und hat keine Kenntnis von den höheren Schichten.

**1.1. `core::types`**

- **Datentypen (Beispiele mit exakten Definitionen):**
    - `pub struct Point<T: Copy + Debug + PartialEq + Default + Send + Sync + 'static> { pub x: T, pub y: T }`
    - `pub struct Size<T: Copy + Debug + PartialEq + Default + Send + Sync + 'static> { pub width: T, pub height: T }`
    - `pub struct Rect<T: Copy + Debug + PartialEq + Default + Send + Sync + 'static> { pub origin: Point<T>, pub size: Size<T> }`
    - `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)] pub struct RectInt { pub x: i32, pub y: i32, pub width: u32, pub height: u32 }`
    - `#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)] pub struct Color { pub r: f32, pub g: f32, pub b: f32, pub a: f32 }` (Invarianten: 0.0-1.0, Durchsetzung in `new()` und `serde`-Implementierung).
    - `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)] pub enum Orientation { #[default] Horizontal, Vertical }`
    - `pub use uuid::Uuid;`
    - `pub use chrono::{DateTime, Utc};`
- **Nutzung (Ultra-Fein):**
    - **Domäne:**
        - `domain::theming::types::AccentColor::value: core::types::Color`
        - `domain::window_management_policy::types::GapSettings::screen_outer_horizontal: u16` (Primitiver Typ, aber Werte könnten von `core::types::Size<u16>` inspiriert sein).
    - **System:**
        - `system::compositor::core::state::DesktopState::pointer_location: core::types::Point<f64, smithay::utils::Logical>`
        - `system::compositor::surface_management::RenderableElement::WaylandSurface::position: core::types::Point<i32, smithay::utils::Logical>`
        - Wayland-Geometrien (z.B. `xdg_surface.configure(.., width: i32, height: i32, ..)`) verwenden primitive Typen, werden aber oft in `core::types::RectInt` für interne Logik umgewandelt.
    - **UI:**
        - `ui::widgets::PlacedWidgetWidget::position: core::types::Point<i32>` (Hypothetisch)
        - CSS-Farben aus `domain::theming::AppliedThemeState::resolved_tokens` werden von der UI-Schicht geparst (ggf. zurück in `core::types::Color`, wenn nötig).

**1.2. `core::errors`**

- **Fehlertypen (Beispiele mit exakten Definitionen):**
    - `#[derive(Debug, thiserror::Error)] pub enum CoreError { #[error("I/O error accessing path '{path}': {source}")] Io { path: PathBuf, #[source] source: std::io::Error }, ... }`
    - `#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)] pub enum ColorParseError { #[error("Invalid hex color string format for '{0}'")] InvalidHexFormat(String), ... }`
- **Nutzung (Ultra-Fein):**
    - **Domäne:**
        - `domain::theming::errors::ThemingError::TokenFileIoError { path: PathBuf, #[source] source: std::io::Error }` (Könnte `CoreError::Io` wrappen oder direkt `std::io::Error` verwenden und `From<std::io::Error>` implementieren).
        - Wenn `domain::theming::logic::load_raw_tokens_from_file` eine `core::config::ConfigError::FileReadError { path, source }` zurückgibt (falls Dateilesen in `core::config` gekapselt ist), könnte `ThemingError` dies direkt via `#[from]` übernehmen oder spezifischer mappen.
    - **System:**
        - `system::dbus_interfaces::common::errors::DBusInterfaceError::ConnectionFailed(#[from] zbus::Error)` (Wrappt externen Fehler). Wenn `zbus::Error` selbst `std::io::Error` wrappt, könnte die Kette bis `CoreError::Io` reichen.
        - Fehler beim Lesen einer Shader-Datei im `system::compositor::renderer` könnte `CoreError::Io` sein, das in einen `RendererError::ShaderLoadFailed` gewrappt wird.
    - **UI:**
        - Fehler aus der Domänen- oder Systemschicht werden an die UI weitergegeben. Z.B. ein `GlobalSettingsError::PersistenceError { source: CoreError::Io { ... } }` wird von der UI abgefangen. Die UI entscheidet dann, dem Benutzer eine generische "Speichern fehlgeschlagen" Meldung anzuzeigen und loggt den vollständigen Fehler (`error!(error = ?err, "...")`).

**1.3. `core::logging`**

- **Logging-API (Beispiele mit exakten Signaturen):**
    - `pub fn initialize_logging(level_filter: tracing::LevelFilter, format: core::logging::types::LogFormat, writer: impl std::io::Write + Send + Sync + 'static) -> Result<(), core::logging::errors::LoggingError>` (Writer für Flexibilität).
    - Konvention: Alle Module verwenden `tracing::{trace, debug, info, warn, error, instrument};`.
- **Nutzung (Ultra-Fein):**
    - **Anwendungs-Root (`main.rs` in `novade-ui` oder dem Haupt-Binary):**
        
        Rust
        
        ```
        // In main.rs
        fn main() -> Result<(), Box<dyn std::error::Error>> {
            // Konfig laden, um Log-Level und Format zu bestimmen
            // let core_config = novade_core::config::get_global_core_config(); // Annahme: Konfig wurde geladen
            // let log_level = core_config.log_level.into(); // Konvertierung zu tracing::LevelFilter
            // let log_format = core_config.log_format.into(); // Konvertierung zu core::logging::LogFormat
            // novade_core::logging::initialize_logging(log_level, log_format, std::io::stdout())?;
            // ... Rest der Anwendung ...
            Ok(())
        }
        ```
        
    - **Alle Schichten/Module:**
        
        Rust
        
        ```
        // In irgendeiner Funktion
        #[tracing::instrument(skip(sensitive_data))]
        fn process_data(data: &DataType, sensitive_data: &Secret) -> Result<(), MyModuleError> {
            tracing::debug!(input_data_len = data.len(), "Verarbeite Daten.");
            if data.is_empty() {
                tracing::warn!("Leere Daten empfangen.");
                return Err(MyModuleError::EmptyData);
            }
            // ... Logik ...
            tracing::info!(result = "Erfolgreich", "Daten verarbeitet.");
            Ok(())
        }
        ```
        

**1.4. `core::config`**

- **Konfigurations-API (Beispiele mit exakten Signaturen):**
    - **Trait `core::config::ConfigServiceAsync` (Neu, für asynchrones Laden):**
        
        Rust
        
        ```
        #[async_trait::async_trait]
        pub trait ConfigServiceAsync: Send + Sync {
            async fn read_config_file_string(&self, key_or_path: &str) -> Result<String, CoreError>; // CoreError::Io oder CoreError::NotFound
            async fn write_config_file_string(&self, key_or_path: &str, content: String) -> Result<(), CoreError>; // CoreError::Io
        }
        ```
        
        - Eine Implementierung (`FilesystemConfigServiceAsync`) würde `tokio::fs` verwenden.
    - `pub fn load_config_deserialize<T: for<'de> serde::Deserialize<'de>>(content_str: &str, source_description: &str) -> Result<T, CoreError>` (Generische Deserialisierungsfunktion).
    - Globale `CoreConfig` über `pub fn get_global_core_config() -> &'static CoreConfig`. Initialisierung über `pub fn initialize_global_core_config(paths: &[PathBuf], config_service: Arc<dyn ConfigServiceAsync>) -> Result<(), CoreError>`.
- **Nutzung (Ultra-Fein):**
    - **Domäne (`domain::theming::logic`):**
        
        Rust
        
        ```
        // ThemingEngine::internal_load_themes_and_tokens_locked
        async fn load_theme_definition_from_file(
            &self,
            path: &Path,
            config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>,
        ) -> Result<ThemeDefinition, ThemingError> {
            let content = config_service.read_config_file_string(path.to_str().unwrap())
                .await
                .map_err(|core_err| ThemingError::FilesystemError(core_err))?; // Wrapping
            let theme_def: ThemeDefinition = novade_core::config::load_config_deserialize(&content, path.to_string_lossy().as_ref())
                .map_err(|core_err| ThemingError::ThemeFileLoadError { /* ... source: core_err ... */})?;
            Ok(theme_def)
        }
        ```
        
    - **System (`system::mcp_client::connection_manager`):**
        - `McpConnectionManager` könnte `get_global_core_config()` verwenden, um Standardpfade oder Features für MCP-Server zu laden, falls diese in `CoreConfig` definiert sind.


# Kernschicht Implementierungsleitfaden: Modul 1 - Fundamentale Datentypen (core::types)

1. Modulübersicht: core::types
    1. 1.1. Zweck und Verantwortlichkeit Dieses Modul, `core::types`, bildet das Fundament der Kernschicht (core) und somit des gesamten Systems.
        
    2. Seine primäre Verantwortung liegt in der Definition grundlegender, universell einsetzbarer Datentypen, die von allen anderen Schichten und Modulen der Desktop-Umgebung benötigt werden.
        
    3. Dazu gehören geometrische Primitive (wie Punkte, Größen, Rechtecke), Farbdarstellungen und allgemeine Enumerationen (wie Orientierungen).
        
    4. Die in diesem Modul definierten Typen sind bewusst einfach gehalten und repräsentieren reine Datenstrukturen ohne komplexe Geschäftslogik oder Abhängigkeiten zu höheren Schichten oder externen Systemen.
        
    5. Sie dienen als Bausteine für komplexere Operationen und Zustandsrepräsentationen in den Domänen-, System- und Benutzeroberflächenschichten.
        
    6. 1.2. Designphilosophie Das Design von `core::types` folgt den Prinzipien der Modularität, Wiederverwendbarkeit und minimalen Kopplung.
        
    7. Die Typen sind generisch gehalten (wo sinnvoll, z.B. bei geometrischen Primitiven), um Flexibilität für verschiedene numerische Darstellungen (z.B. `i32` für Koordinaten, `f32` für Skalierungsfaktoren) zu ermöglichen.
        
    8. Ein wesentlicher Aspekt ist die klare Trennung von Datenrepräsentation (in `core::types`) und Fehlerbehandlung.
        
    9. Während dieses Modul die Datenstrukturen definiert, werden die spezifischen Fehler, die bei Operationen mit diesen Typen auftreten können (z.B. durch ungültige Werte), in den Modulen definiert, die diese Operationen durchführen (typischerweise in `core::errors` oder modulspezifischen Fehler-Enums höherer Schichten).
        
    10. 1.3. Zusammenspiel mit Fehlerbehandlung Obwohl `core::types` selbst keine Error-Typen definiert, ist das Design der hier enthaltenen Typen entscheidend für eine robuste und konsistente Fehlerbehandlungsstrategie im gesamten Projekt.
        
    11. Die übergeordnete Richtlinie sieht die Verwendung des `thiserror`-Crates vor, um spezifische Fehler-Enums pro Modul zu definieren.
        
    12. Dies ermöglicht eine granulare Fehlerbehandlung, ohne die Komplexität übermäßig zu erhöhen.
        
    13. Die Typen in `core::types` unterstützen diese Strategie, indem sie:
        
        - Standard-Traits implementieren: Alle Typen implementieren grundlegende Traits wie `Debug` und `Display`.
            
        - Dies ist essenziell, damit Instanzen dieser Typen effektiv in Fehlermeldungen und Log-Ausgaben eingebettet werden können, die von höheren Schichten unter Verwendung von `thiserror` generiert werden.
            
        - Eine gute Fehlerdarstellung ist entscheidend für die Fehlersuche und das Verständnis von Problemen im Laufzeitbetrieb.
            
        - Invarianten dokumentieren: Für Typen wie `Rect<T>` existieren logische Invarianten (z.B. nicht-negative Breite und Höhe). Diese Invarianten werden klar dokumentiert.
            
        - Validierung ermöglichen: Wo sinnvoll, werden Methoden zur Überprüfung der Gültigkeit bereitgestellt (z.B. `Rect::is_valid()`).
            
        - Diese Methoden erlauben es aufrufendem Code in höheren Schichten, Zustände zu überprüfen, bevor Operationen ausgeführt werden, die fehlschlagen könnten.
            
        - Keine Panics in Kernfunktionen: Konstruktoren und einfache Zugriffsmethoden in `core::types` lösen keine Panics aus und geben keine `Result`-Typen zurück, um die API auf dieser fundamentalen Ebene einfach und vorhersagbar zu halten.
            
        - Die Verantwortung für die Handhabung potenziell ungültiger Zustände (z.B. ein `Rect` mit negativer Breite, das an eine Rendering-Funktion übergeben wird) liegt bei den konsumierenden Funktionen, die dann die definierten Fehlerpfade (mittels `Result<T, E>` 3 und den `thiserror`-basierten E-Typen) nutzen.
            
    14. Diese Designentscheidungen stellen sicher, dass die fundamentalen Typen nahtlos in das übergeordnete Fehlerbehandlungskonzept integriert werden können, ohne selbst die Komplexität der Fehlerdefinition tragen zu müssen.
        
    15. Die gewählte Fehlerstrategie mit `thiserror` pro Modul wird als ausreichend für die Bedürfnisse der Kernschicht erachtet, auch wenn alternative Ansätze wie `snafu` für komplexere Szenarien existieren, in denen z.B. die Unterscheidung von Fehlern aus derselben Quelle kritisch ist. Für die Kernschicht wird die Einfachheit und Direktheit von `thiserror` bevorzugt.
        
    16. 1.4. Modulabhängigkeiten Dieses Modul ist darauf ausgelegt, minimale externe Abhängigkeiten zu haben, um seine grundlegende Natur und breite Anwendbarkeit zu gewährleisten.
        
    17. Erlaubte Abhängigkeiten:
        
        - `std` (Rust Standardbibliothek)
            
    18. Optionale Abhängigkeiten (derzeit nicht verwendet):
        
        - `num-traits`: Nur hinzufügen, falls generische numerische Operationen benötigt werden, die über `std::ops` hinausgehen.
        - `serde` (mit `derive`-Feature): Nur hinzufügen, wenn Serialisierung/Deserialisierung dieser Basistypen direkt auf dieser Ebene zwingend erforderlich ist (z.B. für Konfigurationsdateien, die diese Typen direkt verwenden).
            
        - Aktuell wird davon ausgegangen, dass Serialisierungslogik in höheren Schichten implementiert wird, um unnötige Abhängigkeiten zu vermeiden.
    19. 1.5. Ziel-Dateistruktur Die Implementierung dieses Moduls erfolgt innerhalb des core-Crates mit folgender Verzeichnisstruktur:
        
        ```
        core/
        └── src/
            ├── Cargo.toml        # (Definiert das 'core' Crate)
            └── src/
                ├── lib.rs          # (Deklariert Kernmodule: pub mod types; pub mod errors; ...)
                └── types/
                    ├── mod.rs       # (Deklariert und re-exportiert Typen: pub mod geometry; pub mod color; ...)
                    ├── geometry.rs # (Enthält Point<T>, Size<T>, Rect<T>)
                    ├── color.rs      # (Enthält Color)
                    └── enums.rs      # (Enthält Orientation, etc.)
        ```
        
2. 2. Spezifikation: Geometrische Primitive (geometry.rs) Diese Datei definiert grundlegende 2D-Geometrietypen, die für Layout, Positionierung und Rendering unerlässlich sind.
    3. 2.1. Struct: `Point<T>`
        1. 2.1.1. Definition und Zweck: Repräsentiert einen Punkt im 2D-Raum mit x- und y-Koordinaten.
            
        2. Generisch über den Typ T.
        3. 2.1.2. Felder:
            - `pub x: T`
            - `pub y: T`
        4. 2.1.3. Assoziierte Konstanten:
            - `pub const ZERO_I32: Point<i32> = Point { x: 0, y: 0 };`
                
            - `pub const ZERO_U32: Point<u32> = Point { x: 0, y: 0 };`
                
            - `pub const ZERO_F32: Point<f32> = Point { x: 0.0, y: 0.0 };`
                
            - `pub const ZERO_F64: Point<f64> = Point { x: 0.0, y: 0.0 };`
                
        5. 2.1.4. Methoden:
            - `pub const fn new(x: T, y: T) -> Self`
                - Erstellt einen neuen Punkt.
                    
            - `pub fn distance_squared(&self, other: &Point<T>) -> T`
                - Berechnet das Quadrat der euklidischen Distanz.
                    
                - Constraints: `T: Copy + std::ops::Add<Output=T> + std::ops::Sub<Output=T> + std::ops::Mul<Output=T>`
                    
            - `pub fn distance(&self, other: &Point<T>) -> T`
                - Berechnet die euklidische Distanz.
                    
                - Constraints: `T: Copy + std::ops::Add<Output=T> + std::ops::Sub<Output=T> + std::ops::Mul<Output=T> + num_traits::Float` (Implementierung nur für Float-Typen sinnvoll oder über sqrt-Funktion). Vorerst nur für f32,f64 implementieren.
            - `pub fn manhattan_distance(&self, other: &Point<T>) -> T`
                - Berechnet die Manhattan-Distanz (`|x1 - x2| + |y1 - y2|`).
                    
                - Constraints: `T: Copy + std::ops::Add<Output=T> + std::ops::Sub<Output=T> + num_traits::Signed` (Benötigt abs()).
        6. 2.1.5. Trait Implementierungen:
            - `impl<T: Copy + Debug + Default> Default for Point<T> { ... }`
                - Bedingung: T muss die jeweiligen Traits ebenfalls implementieren. Default setzt x und y auf T::default().
                    
            - `impl<T: Send + 'static> Send for Point<T> {}`
                
            - `impl<T: Sync + 'static> Sync for Point<T> {}`
                
            - `impl<T: std::ops::Add<Output = T>> std::ops::Add for Point<T>`
                
            - `impl<T: std::ops::Sub<Output = T>> std::ops::Sub for Point<T>`
                
        7. 2.1.6. Generische Constraints (Basis): `T: Copy + Debug + PartialEq + Default + Send + Sync + 'static`.
            
            - Weitere Constraints werden pro Methode spezifiziert.
    4. 2.2. Struct: `Size<T>`
        1. 2.2.1. Definition und Zweck: Repräsentiert eine 2D-Dimension (Breite und Höhe). Generisch über den Typ T.
            
        2. 2.2.2. Felder:
            - `pub width: T`
            - `pub height: T`
        3. 2.2.3. Assoziierte Konstanten:
            - `pub const ZERO_I32: Size<i32> = Size { width: 0, height: 0 };`
                
            - `pub const ZERO_U32: Size<u32> = Size { width: 0, height: 0 };`
                
            - `pub const ZERO_F32: Size<f32> = Size { width: 0.0, height: 0.0 };`
                
            - `pub const ZERO_F64: Size<f64> = Size { width: 0.0, height: 0.0 };`
                
        4. 2.2.4. Methoden:
            - `pub const fn new(width: T, height: T) -> Self`
                - Erstellt eine neue Größe.
                    
            - `pub fn area(&self) -> T`
                - Berechnet die Fläche (`width * height`).
                    
                - Constraints: `T: Copy + std::ops::Mul<Output=T>`
            - `pub fn is_empty(&self) -> bool`
                - Prüft, ob Breite oder Höhe null ist.
                    
                - Constraints: `T: PartialEq + num_traits::Zero`
            - `pub fn is_valid(&self) -> bool`
                - Prüft, ob Breite und Höhe nicht-negativ sind. Nützlich für Typen wie i32.
                    
                - Constraints: `T: PartialOrd + num_traits::Zero`
        5. 2.2.5. Trait Implementierungen:
            - `impl<T: Copy + Debug + Default> Default for Size<T> { ... }`
                - Bedingung: T muss die jeweiligen Traits ebenfalls implementieren. Default setzt width und height auf T::default().
                    
            - `impl<T: Send + 'static> Send for Size<T> {}`
                
            - `impl<T: Sync + 'static> Sync for Size<T> {}`
                
        6. 2.2.6. Generische Constraints (Basis): `T: Copy + Debug + PartialEq + Default + Send + Sync + 'static`.
            
            - Weitere Constraints werden pro Methode spezifiziert. Die Invariante nicht-negativer Dimensionen wird durch `is_valid` prüfbar gemacht, aber nicht durch den Typ erzwungen.
    5. 2.3. Struct: `Rect<T>`
        1. 2.3.1. Definition und Zweck: Repräsentiert ein 2D-Rechteck, definiert durch einen Ursprungspunkt (oben-links) und eine Größe.
            
        2. Generisch über den Typ T.
        3. 2.3.2. Felder:
            - `pub origin: Point<T>`
            - `pub size: Size<T>`
        4. 2.3.3. Assoziierte Konstanten:
            - `pub const ZERO_I32: Rect<i32> = Rect { origin: Point::ZERO_I32, size: Size::ZERO_I32 };`
                
            - `pub const ZERO_U32: Rect<u32> = Rect { origin: Point::ZERO_U32, size: Size::ZERO_U32 };`
                
            - `pub const ZERO_F32: Rect<f32> = Rect { origin: Point::ZERO_F32, size: Size::ZERO_F32 };`
                
            - `pub const ZERO_F64: Rect<f64> = Rect { origin: Point::ZERO_F64, size: Size::ZERO_F64 };`
                
        5. 2.3.4. Methoden:
            - `pub const fn new(origin: Point<T>, size: Size<T>) -> Self`
                
            - `pub fn from_coords(x: T, y: T, width: T, height: T) -> Self`
                - Constraints: T muss die Constraints von `Point::new` und `Size::new` erfüllen.
                    
            - `pub fn x(&self) -> T` (Constraints: `T: Copy`)
                
            - `pub fn y(&self) -> T` (Constraints: `T: Copy`)
                
            - `pub fn width(&self) -> T` (Constraints: `T: Copy`)
                
            - `pub fn height(&self) -> T` (Constraints: `T: Copy`)
                
            - `pub fn top(&self) -> T` (Alias für y, Constraints: `T: Copy`)
                
            - `pub fn left(&self) -> T` (Alias für x, Constraints: `T: Copy`)
                
            - `pub fn bottom(&self) -> T` (y + height, Constraints: `T: Copy + std::ops::Add<Output=T>`)
                
            - `pub fn right(&self) -> T` (x + width, Constraints: `T: Copy + std::ops::Add<Output=T>`)
                
            - `pub fn center(&self) -> Point<T>`
                - Berechnet den Mittelpunkt.
                    
                - Constraints: `T: Copy + std::ops::Add<Output=T> + std::ops::Div<Output=T> + num_traits::FromPrimitive` (Benötigt Division durch 2).
            - `pub fn contains_point(&self, point: &Point<T>) -> bool`
                - Prüft, ob der Punkt innerhalb des Rechtecks liegt (Grenzen inklusiv für top/left, exklusiv für bottom/right).
                    
                - Constraints: `T: Copy + PartialOrd + std::ops::Add<Output=T>`
            - `pub fn intersects(&self, other: &Rect<T>) -> bool`
                - Prüft, ob sich dieses Rechteck mit einem anderen überschneidet.
                    
                - Constraints: `T: Copy + PartialOrd + std::ops::Add<Output=T>`
            - `pub fn intersection(&self, other: &Rect<T>) -> Option<Rect<T>>`
                - Berechnet das Schnittrechteck. Gibt `None` zurück, wenn keine Überschneidung vorliegt.
                    
                - Constraints: `T: Copy + Ord + std::ops::Add<Output=T> + std::ops::Sub<Output=T> + num_traits::Zero`
            - `pub fn union(&self, other: &Rect<T>) -> Rect<T>`
                - Berechnet das umschließende Rechteck beider Rechtecke.
                    
                - Constraints: `T: Copy + Ord + std::ops::Add<Output=T> + std::ops::Sub<Output=T>`
            - `pub fn translated(&self, dx: T, dy: T) -> Rect<T>`
                - Verschiebt das Rechteck um (dx, dy).
                    
                - Constraints: `T: Copy + std::ops::Add<Output=T>`
            - `pub fn scaled(&self, sx: T, sy: T) -> Rect<T>`
                - Skaliert das Rechteck relativ zum Ursprung (0, 0).
                    
                - Beachtet, dass dies Ursprung und Größe skaliert.
                - Constraints: `T: Copy + std::ops::Mul<Output=T>`
            - `pub fn is_valid(&self) -> bool`
                - Prüft, ob `size.is_valid()` wahr ist.
                    
                - Constraints: `T: PartialOrd + num_traits::Zero`
        6. 2.3.5. Trait Implementierungen:
            - `impl<T: Copy + Debug + Default> Default for Rect<T> { ... }`
                - Bedingung: T muss die jeweiligen Traits ebenfalls implementieren. Default verwendet `Point::default()` und `Size::default()`.
                    
            - `impl<T: Send + 'static> Send for Rect<T> {}`
                
            - `impl<T: Sync + 'static> Sync for Rect<T> {}`
                
        7. 2.3.6. Generische Constraints (Basis): `T: Copy + Debug + PartialEq + Default + Send + Sync + 'static`.
            
            - Weitere Constraints werden pro Methode spezifiziert.
        8. 2.3.7. Invarianten und Validierung (Verbindung zur Fehlerbehandlung):
            - Invariante: Logisch sollten width und height der size-Komponente nicht-negativ sein.
                
            - Kontext: Die Verwendung von vorzeichenbehafteten Typen wie i32 für Koordinaten ist üblich, erlaubt aber technisch negative Dimensionen.
                
            - Eine Erzwingung nicht-negativer Dimensionen auf Typebene (z.B. durch u32) wäre zu restriktiv für Koordinatensysteme.
                
            - Konsequenz: Die Flexibilität, `Rect<i32>` zu verwenden, verlagert die Verantwortung für die Validierung auf die Nutzer des Rect-Typs.
                
            - Funktionen in höheren Schichten (z.B. Layout-Algorithmen, Rendering-Engines), die ein `Rect` konsumieren, müssen potenziell ungültige Rechtecke (mit negativer Breite oder Höhe) behandeln.
                
            - Solche Fälle stellen Laufzeitfehler dar, die über das etablierte Fehlerbehandlungssystem (basierend auf `Result<T, E>` und `thiserror`-definierten E-Typen) signalisiert werden müssen.
                
            - Implementierung in `core::types`: Das Modul erzwingt die Invariante nicht zur Compilezeit oder in Konstruktoren.
                
            - Stattdessen wird die Methode `pub fn is_valid(&self) -> bool` bereitgestellt.
                
            - Nutzer von `Rect<T>` (insbesondere mit `T=i32`) sollten diese Methode aufrufen, um die Gültigkeit sicherzustellen, bevor Operationen durchgeführt werden, die eine positive Breite und Höhe voraussetzen.
                
            - Die Dokumentation des Rect-Typs muss explizit auf diese Invariante und die Notwendigkeit der Validierung durch den Aufrufer hinweisen.
                
            - Die Verantwortung für das Melden eines Fehlers bei Verwendung eines ungültigen `Rect` liegt beim Aufrufer, der dafür die Fehlerinfrastruktur (z.B. `core::errors` oder modulspezifische Fehler) nutzt.
                
    6. 2.4. Struct: `RectInt`
        - (aus einer anderen Quelldatei, aber thematisch passend)
        - Repräsentiert ein achsenparalleles Rechteck mit ganzzahligen Koordinaten (`x: i32`, `y: i32`) und Dimensionen (`width: u32`, `height: u32`).
            
            - Methoden u.a. `new(...)`, `from_points(...)`, `top_left()`, `size()`, `right()`, `bottom()`, `contains_point(...)`, `intersects(...)`, `intersection(...)`, `union(...)`, `translate(...)`, `inflate(...)`, `is_empty()`
                
            - Verwendet `saturating_add` / `saturating_sub` um Überläufe zu vermeiden.
                
            - Traits: `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Default`
                
3. 3. Spezifikation: Farbdarstellung (color.rs) Diese Datei definiert einen Standard-Farbtyp für die Verwendung im gesamten System.
    4. 3.1. Struct: `Color` (RGBA)
        1. 3.1.1. Definition und Zweck: Repräsentiert eine Farbe mit Rot-, Grün-, Blau- und Alpha-Komponenten.
            
        2. Verwendet `f32`-Komponenten im Bereich `[0.0, 1.0]` für hohe Präzision und Flexibilität bei Farboperationen wie Mischen und Transformationen.
            
        3. 3.1.2. Felder:
            - `pub r: f32` (Rotkomponente, 0.0 bis 1.0)
                
            - `pub g: f32` (Grünkomponente, 0.0 bis 1.0)
                
            - `pub b: f32` (Blaukomponente, 0.0 bis 1.0)
                
            - `pub a: f32` (Alphakomponente, 0.0=transparent bis 1.0=opak)
                
        4. 3.1.3. Assoziierte Konstanten:
            - `pub const TRANSPARENT: Color = Color { r: 0.0, g: 0.0, b: 0.0, a: 0.0 };`
                
            - `pub const BLACK: Color = Color { r: 0.0, g: 0.0, b: 0.0, a: 1.0 };`
                
            - `pub const WHITE: Color = Color { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };`
                
            - `pub const RED: Color = Color { r: 1.0, g: 0.0, b: 0.0, a: 1.0 };`
                
            - `pub const GREEN: Color = Color { r: 0.0, g: 1.0, b: 0.0, a: 1.0 };`
                
            - `pub const BLUE: Color = Color { r: 0.0, g: 0.0, b: 1.0, a: 1.0 };`
                
            - (Weitere Standardfarben nach Bedarf hinzufügen)
                
        5. 3.1.4. Methoden:
            - `pub const fn new(r: f32, g: f32, b: f32, a: f32) -> Self`
                - Erstellt eine neue Farbe.
                    
                - Werte außerhalb `[0.0, 1.0]` werden nicht automatisch geklemmt, dies liegt in der Verantwortung des Aufrufers oder nachfolgender Operationen. `debug_assert!` kann zur Laufzeitprüfung in Debug-Builds verwendet werden.
                    
            - `pub fn from_rgba8(r: u8, g: u8, b: u8, a: u8) -> Self`
                - Konvertiert von 8-Bit-Ganzzahlkomponenten (0-255) zu f32 (0.0-1.0).
                    
                - `value / 255.0`.
            - `pub fn to_rgba8(&self) -> (u8, u8, u8, u8)`
                - Konvertiert von f32 zu 8-Bit-Ganzzahlkomponenten.
                    
                - Klemmt Werte auf `[0.0, 1.0]` und skaliert dann auf (value.clamp(0.0,1.0)∗255.0).round()asu8.
                    
            - `pub fn with_alpha(&self, alpha: f32) -> Self`
                - Erstellt eine neue Farbe mit dem angegebenen Alpha-Wert, wobei RGB beibehalten wird.
                    
                - Klemmt Alpha auf `[0.0, 1.0]`.
                    
            - `pub fn blend(&self, background: &Color) -> Color`
                - Führt Alpha-Blending ("source-over") dieser Farbe über einer Hintergrundfarbe durch.
                    
                - Formel: `C_out = C_fg * α_fg + C_bg * α_bg * (1 - α_fg)`. `α_out = α_fg + α_bg * (1 - α_fg)`. Annahme: Farben sind nicht vormultipliziert.
                    
            - `pub fn lighten(&self, amount: f32) -> Color`
                - Hellt die Farbe um einen Faktor amount auf (z.B. durch lineare Interpolation zu Weiß).
                    
                - Klemmt das Ergebnis auf gültige Farbwerte. amount im Bereich `[0.0, 1.0]`.
                    
            - `pub fn darken(&self, amount: f32) -> Color`
                - Dunkelt die Farbe um einen Faktor amount ab (z.B. durch lineare Interpolation zu Schwarz).
                    
                - Klemmt das Ergebnis. amount im Bereich `[0.0, 1.0]`.
                    
        6. 3.1.5. Trait Implementierungen:
            - `impl PartialEq for Color { ... }`
                - PartialEq: Verwendet den Standard-Float-Vergleich.
                    
                - Für präzisere Vergleiche könnten benutzerdefinierte Implementierungen mit Epsilon erforderlich sein, dies wird jedoch für die Kernschicht als unnötige Komplexität betrachtet.
                    
            - `impl Default for Color { ... }`
                - Default: Implementiert Default manuell, um `Color::TRANSPARENT` zurückzugeben.
                    
            - `impl Send for Color {}`
                
            - `impl Sync for Color {}`
                
4. 4. Spezifikation: Allgemeine Enumerationen (enums.rs) Diese Datei enthält häufig verwendete, einfache Enumerationen.
        
    5. 4.1. Enum: `Orientation`
        1. 4.1.1. Definition und Zweck: Repräsentiert eine horizontale oder vertikale Ausrichtung, häufig verwendet in UI-Layouts und Widgets.
            
        2. 4.1.2. Varianten:
            - `Horizontal`
                
            - `Vertical`
                
        3. 4.1.3. Methoden:
            - `pub fn toggle(&self) -> Self`
                - Gibt die jeweils andere Orientierung zurück (Horizontal -> Vertical, Vertical -> Horizontal).
                    
        4. 4.1.4. Trait Implementierungen:
            - `impl Default for Orientation { fn default() -> Self { Orientation::Horizontal } }` (Standard ist Horizontal).
                
            - `impl Send for Orientation {}`
                
            - `impl Sync for Orientation {}`
                
5. 5. Zusammenfassung: Standard Trait Implementierungen Die folgende Tabelle gibt einen Überblick über die Implementierung gängiger Standard-Traits für die in diesem Modul definierten Typen. Dies dient als
        

 Quellen
---

**2. Schnittstelle: Domänenschicht (`novade-domain`) zu Systemschicht und UI-Schicht**

**2.1. Service-APIs (Traits) – Ultra-Fein-Definitionen (Beispiele):**

- **`domain::theming::service::ThemingService`** (Umbenannt von `ThemingEngine` für Klarheit als Trait)
    
    Rust
    
    ```
    use crate::core::types::{Color as CoreColor}; // novade-core Typen
    use super::types::{AppliedThemeState, ThemeIdentifier, ColorSchemeType, ThemingConfiguration, ThemeDefinition};
    use super::errors::ThemingError;
    use tokio::sync::broadcast;
    use uuid::Uuid;
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)] // Für Event und Cache
    pub struct ThemeChangedEvent {
        pub event_id: Uuid,
        pub timestamp: DateTime<Utc>,
        pub new_state: AppliedThemeState,
    }
    
    #[async_trait::async_trait]
    pub trait ThemingService: Send + Sync {
        /// Gibt den aktuell angewendeten Theme-Zustand zurück.
        async fn get_current_theme_state(&self) -> Result<AppliedThemeState, ThemingError>;
    
        /// Gibt eine Liste aller verfügbaren (geladenen) Theme-Definitionen zurück.
        async fn get_available_themes(&self) -> Result<Vec<ThemeDefinition>, ThemingError>;
    
        /// Gibt die aktuell vom Benutzer gewählte Theming-Konfiguration zurück.
        async fn get_current_theming_configuration(&self) -> Result<ThemingConfiguration, ThemingError>;
    
        /// Aktualisiert die Theming-Konfiguration des Benutzers.
        /// Löst eine Neuberechnung des `AppliedThemeState` und ein `ThemeChangedEvent` aus, falls sich der Zustand ändert.
        async fn update_theming_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>;
    
        /// Lädt alle Theme- und Token-Definitionen von den konfigurierten Pfaden neu.
        /// Dies kann z.B. nützlich sein, wenn der Benutzer neue Themes installiert.
        /// Aktualisiert den `AppliedThemeState` basierend auf der aktuellen Konfiguration.
        async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>;
    
        /// Abonniert Änderungen am angewendeten Theme-Zustand.
        fn subscribe_to_theme_changes(&self) -> broadcast::Receiver<ThemeChangedEvent>;
    }
    ```
    
    - **Publisher von `ThemeChangedEvent`**: `DefaultThemingService` (die Implementierung).
    - **Subscriber von `ThemeChangedEvent`**:
        - `ui::theming_gtk::ThemeManagerGtk`: Aktualisiert GTK CSS Provider.
        - Andere UI-Komponenten, die direkt auf Theme-Änderungen reagieren müssen (z.B. benutzerdefinierte Widgets, die Farben nicht über CSS beziehen).
        - Ggf. `system::compositor` wenn serverseitige Dekorationen stark vom Theme abhängen.
- **`domain::global_settings_and_state_management::service::GlobalSettingsService`**
    
    Rust
    
    ```
    use super::types::GlobalDesktopSettings;
    use super::paths::SettingPath;
    use super::errors::GlobalSettingsError;
    use tokio::sync::broadcast;
    use uuid::Uuid;
    use serde_json::Value as JsonValue;
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct SettingChangedEvent {
        pub event_id: Uuid,
        pub timestamp: DateTime<Utc>,
        pub path: SettingPath,
        pub old_value: Option<JsonValue>, // Kann None sein, wenn der vorherige Wert nicht verfügbar war
        pub new_value: JsonValue,
    }
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct SettingsLoadedEvent { /* ... */ pub settings: GlobalDesktopSettings }
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct SettingsSavedEvent { /* ... */ }
    
    
    #[async_trait::async_trait]
    pub trait GlobalSettingsService: Send + Sync {
        /// Lädt die globalen Einstellungen vom Persistenz-Provider.
        /// Löst ein `SettingsLoadedEvent` aus.
        async fn load_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>;
    
        /// Speichert die aktuellen globalen Einstellungen über den Persistenz-Provider.
        /// Löst ein `SettingsSavedEvent` aus.
        async fn save_settings(&self) -> Result<(), GlobalSettingsError>;
    
        /// Gibt einen Klon der aktuell geladenen `GlobalDesktopSettings` zurück.
        async fn get_current_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>;
    
        /// Aktualisiert einen spezifischen Einstellungswert über seinen `SettingPath`.
        /// Validiert den neuen Wert.
        /// Löst ein `SettingChangedEvent` aus und persistiert die Änderungen.
        async fn update_setting(&self, path: SettingPath, new_value: JsonValue) -> Result<(), GlobalSettingsError>;
    
        /// Liest den Wert einer spezifischen Einstellung.
        async fn get_setting_value(&self, path: &SettingPath) -> Result<JsonValue, GlobalSettingsError>;
    
        /// Setzt alle Einstellungen auf ihre Standardwerte zurück.
        /// Löst mehrere `SettingChangedEvent`s aus und persistiert.
        async fn reset_all_settings_to_defaults(&self) -> Result<(), GlobalSettingsError>;
    
        /// Setzt eine spezifische Einstellung auf ihren Standardwert zurück.
        async fn reset_setting_to_default(&self, path: &SettingPath) -> Result<(), GlobalSettingsError>;
    
        /// Abonniert Änderungen an spezifischen Einstellungen oder allen Einstellungen.
        fn subscribe_to_setting_changes(&self) -> broadcast::Receiver<SettingChangedEvent>;
        // fn subscribe_to_settings_loaded_event(...) -> broadcast::Receiver<SettingsLoadedEvent>;
        // fn subscribe_to_settings_saved_event(...) -> broadcast::Receiver<SettingsSavedEvent>;
    }
    ```
    
    - **Publisher von Events**: `DefaultGlobalSettingsService`.
    - **Subscriber von `SettingChangedEvent`**:
        - **Domäne:** `ThemingService` (für Theme-relevante Einstellungen), `WorkspaceManagerService` (für Workspace-bezogene Einstellungen), `NotificationRulesEngine` (für `SettingIsTrue`-Bedingungen), `PowerManagementService` (für Energieeinstellungen).
        - **System:** `system::input` (für Tastatur-Layout, Maus-Sensitivität), `system::compositor::output_management` (für Standard-Auflösung/Skalierung), `system::audio_management` (für Standard-Lautstärke).
        - **UI:** `ui::control_center` (um sich selbst zu aktualisieren), diverse `ui::shell`-Widgets, die Einstellungen direkt darstellen oder verwenden.

**2.2. Nutzung durch die Systemschicht (Ultra-Fein):**

- **`system::compositor::core::state::DesktopState::new(...)`** nimmt `Arc<dyn WindowManagementPolicyService>` und `Arc<dyn WorkspaceManagerService>` als Parameter.
- **`system::compositor::xdg_shell::handlers::XdgShellHandler::new_toplevel()` (für `DesktopState`)**:
    1. Erhält `ToplevelSurface` von Smithay.
    2. Erzeugt eine `DomainWindowIdentifier`.
    3. Ruft `self.workspace_manager_service.get_active_workspace_id().await` (oder eine äquivalente synchrone Methode, wenn im Compositor-Thread).
    4. Ruft `self.window_policy_service.get_initial_window_geometry(domain_id, workspace_id, available_area, ...).await` um die initiale Geometrie und den Zustand zu bestimmen.
    5. Konfiguriert die `ToplevelSurface` entsprechend.
    6. Informiert `self.workspace_manager_service.assign_window_to_workspace(workspace_id, domain_id, ...).await`.
- **`system::dbus_interfaces::notifications_server::FreedesktopNotificationsServer::notify()`**:
    1. Empfängt D-Bus-Parameter.
    2. Konvertiert diese in eine `domain::user_centric_services::notifications_core::types::NotificationInput`-Struktur.
    3. Ruft `self.notification_service_domain_handle.lock().await.post_notification(input).await`.
    4. Konvertiert das Ergebnis (Domain `Uuid`) in eine D-Bus `u32` ID.
- **`system::input::event_dispatcher::process_input_event()` für `InputEvent::GestureSwipeUpdate`**:
    1. Ermittelt die Geste.
    2. Ruft `self.desktop_state.workspace_manager_service.switch_to_next_or_prev_workspace(direction).await`.

**2.3. Nutzung durch die UI-Schicht (Ultra-Fein):**

- **`ui::control_center::appearance_page::AppearancePageModel::new()`**:
    1. Nimmt `Arc<dyn GlobalSettingsService>` und `Arc<dyn ThemingService>` als Parameter.
    2. Abonniert `global_settings_service.subscribe_to_setting_changes()` und `theming_service.subscribe_to_theme_changes()`.
    3. Ruft `global_settings_service.get_current_settings().await` und `theming_service.get_current_theming_configuration().await` sowie `get_available_themes().await`, um den initialen Zustand der UI-Elemente (ComboBoxes für Themes, Switches für Dark Mode etc.) zu füllen.
- **Event-Handler in `AppearancePageModel` für `SettingChangedEvent`**:
    1. Prüft, ob `event.path` für die Appearance-Seite relevant ist.
    2. Aktualisiert das entsprechende UI-Element (z.B. einen `gtk::Switch` für `SettingPath::Appearance(AppearanceSettingPath::PreferDarkTheme)`) mit `event.new_value`.
- **Aktion in `AppearancePageModel` (z.B. Klick auf "Akzentfarbe ändern"):**
    1. Öffnet einen Farbauswahldialog.
    2. Nach Auswahl: `new_color: core::types::Color`.
    3. `current_theming_config = self.theming_service.get_current_theming_configuration().await?;`
    4. `updated_config = current_theming_config.with_new_accent(new_color);`
    5. `self.theming_service.update_theming_configuration(updated_config).await?;` (Löst `ThemeChangedEvent` aus).
- **`ui::shell::workspace_switcher::WorkspaceSwitcherWidget::on_active_workspace_changed_event(event: domain::workspaces::manager::events::ActiveWorkspaceChangedData)`**:
    1. Iteriert über seine `SpaceIconWidget`s.
    2. Setzt den visuellen "aktiv"-Zustand für das Widget, das `event.new_active_id` entspricht.

---

**3. Schnittstelle: Systemschicht (`novade-system`) zu UI-Schicht (`novade-ui`)**

Diese Schnittstelle ist oft ereignisbasiert oder durch von der UI-Schicht gehaltene Handles zu System-Services.

**3.1. Systemereignisse und -zustände (Ultra-Fein):**

- **Fensterinformationen (bereitgestellt durch einen `WindowManagerSystemFacade` Trait, implementiert von einer Struktur, die auf `DesktopState` zugreift):**
    - **Trait `WindowManagerSystemFacade`**:
        
        Rust
        
        ```
        use crate::core::types::RectInt;
        use crate::domain::workspaces::core::types::{WindowIdentifier as DomainWindowIdentifier, WorkspaceId};
        use crate::system::compositor::xdg_shell::types::ManagedWindowPublicState; // Neuer Typ
        
        #[derive(Debug, Clone, Serialize, Deserialize)] // Für UI-Nutzung
        pub struct ManagedWindowPublicState { // Daten, die UI benötigt
            pub domain_id: DomainWindowIdentifier,
            pub app_id: Option<String>,
            pub title: Option<String>,
            pub geometry: RectInt, // Relative Workspace-Koordinaten
            pub workspace_id: Option<WorkspaceId>,
            pub is_mapped: bool,
            pub is_focused: bool, // Bezogen auf den Seat der UI-Shell
            pub is_maximized: bool,
            pub is_fullscreen: bool,
            // Ggf. Icon-Daten oder Name
        }
        
        #[async_trait::async_trait]
        pub trait WindowManagerSystemFacade: Send + Sync {
            /// Gibt eine Liste aller aktuell verwalteten (gemappten) Fenster mit ihren relevanten Zuständen zurück.
            async fn get_all_managed_windows(&self) -> Result<Vec<ManagedWindowPublicState>, SystemFacadeError>;
        
            /// Gibt den Zustand eines spezifischen Fensters zurück.
            async fn get_window_state(&self, id: &DomainWindowIdentifier) -> Result<Option<ManagedWindowPublicState>, SystemFacadeError>;
        
            /// Fordert den Fokus für ein bestimmtes Fenster an.
            async fn request_focus(&self, id: &DomainWindowIdentifier) -> Result<(), SystemFacadeError>;
        
            /// Fordert das Schließen eines Fensters an (sendet Close-Request an Client).
            async fn request_close_window(&self, id: &DomainWindowIdentifier) -> Result<(), SystemFacadeError>;
        
            // Weitere Aktionen: request_minimize, request_maximize, request_move_to_workspace etc.
        
            /// Abonniert Änderungen an Fensterzuständen.
            fn subscribe_to_window_changes(&self) -> tokio::sync::broadcast::Receiver<WindowSystemEvent>;
        }
        
        #[derive(Debug, Clone)] // System-intern oder für UI, Serialize/Deserialize falls nötig
        pub enum WindowSystemEvent {
            WindowCreated(ManagedWindowPublicState),
            WindowClosed(DomainWindowIdentifier),
            WindowUpdated(ManagedWindowPublicState), // Geometrie, Titel, Fokus etc. geändert
            FocusChanged(Option<DomainWindowIdentifier> /* neues Fokusfenster */, Option<DomainWindowIdentifier> /* altes Fokusfenster */),
        }
        // SystemFacadeError definieren
        ```
        
    - **Implementierung:** Eine Struktur in `novade-system` implementiert diesen Trait. Sie greift auf `system::compositor::core::DesktopState` (via `Arc<Mutex<...>>` oder `LoopHandle::insert_idle`) zu, um die Daten der `ManagedWindow`s zu lesen und in `ManagedWindowPublicState` zu transformieren. Sie publiziert `WindowSystemEvent`s über den `SystemEventBridge`.
- **Eingabeereignisse:** Werden nicht direkt als Rust-Strukturen an die UI-Schicht gesendet. Stattdessen:
    - **Wayland-Protokoll:** Der `system::compositor` sendet `wl_keyboard.key`, `wl_pointer.motion`, `wl_touch.down` etc. an die Wayland-Oberflächen der UI-Elemente (GTK-Fenster). GTK4 (`gdk::Display`) empfängt diese Wayland-Events und übersetzt sie in GTK-Events (`GdkEvent`), die dann von Widgets verarbeitet werden.
    - **Spezielle Aktionen:** Globale Hotkeys oder Gesten, die nicht an ein spezifisches Fenster gebunden sind (z.B. `Super+Space` für Command Palette, Workspace-Switch-Gesten), werden vom `system::input` erkannt. Der `system::input` kann dann direkt eine Domänenaktion auslösen (z.B. `domain::command_palette_service::show()`) oder ein spezifisches `SystemLayerEvent` über den `SystemEventBridge` senden, das von der UI-Shell abonniert wird.
- **Status von Systemdiensten:**
    - `system::dbus_interfaces::upower_client::UPowerClientService` publiziert `UPowerEvent`s über den `SystemEventBridge`.
    - Die UI (z.B. `ui::shell::PowerIndicatorWidget`) abonniert `SystemLayerEvent::UPower` vom `SystemEventBridge`.
    - Bei Empfang: `match event { SystemLayerEvent::UPower(UPowerEvent::DeviceChanged(path)) => { let details = block_on(self.upower_client_facade.get_device_details_by_path(path)); /* UI aktualisieren */ } ... }`

**3.2. Ausführung von UI-Befehlen (Ultra-Fein):**

- **UI-Schicht (`ui::shell::window_title_bar::CloseButton::on_clicked`)**:
    1. Ruft `self.window_manager_facade.request_close_window(self.associated_window_id).await;`.
- **Systemschicht (`DefaultWindowManagerSystemFacade::request_close_window`)**:
    1. Sperrt `DesktopState`.
    2. Findet das `ManagedWindow` (als `Arc<smithay::desktop::Window>`) für die `DomainWindowIdentifier`.
    3. Wenn `WindowSurface::Toplevel(toplevel)`: `toplevel.send_close();`.
    4. (Der Client sollte dann unmappen; `XdgShellHandler::unmap_toplevel` wird ausgelöst).
- **UI-Schicht (`ui::control_center::display_page::ApplyButton::on_clicked`)**:
    1. Sammelt neue Monitorkonfiguration (`Vec<MonitorConfigUiData>`).
    2. Konvertiert zu `Vec<system::output_management::types::OutputConfigRequestData>`.
    3. Ruft `self.output_management_facade.apply_output_configuration(requests).await;`.
- **Systemschicht (`DefaultOutputManagementFacade::apply_output_configuration`)**:
    1. Interagiert mit `system::compositor::output_management` (oder `DesktopState`), um `wlr-output-management` Protokoll-Requests zu senden oder direkt DRM-Modi zu setzen.

---

**Zusammenfassende Prinzipien der Schnittstellen (Ultra-Fein):**

1. **Typsicherheit und explizite Datenstrukturen:** Alle über Schnittstellen ausgetauschten Daten (Parameter, Rückgabewerte, Event-Payloads) sind explizit definierte Rust-`struct`s oder `enum`s. Primitive Typen werden verwendet, wo angemessen, aber für komplexere Daten werden spezifische Typen bevorzugt.
2. **Trait-basierte Service-Abstraktion:** Domänen- und Systemdienste, die von höheren Schichten genutzt werden, implementieren `#[async_trait::async_trait]` Traits. Dies ermöglicht Mocking für Tests und Flexibilität bei Implementierungsänderungen. Handles zu diesen Services sind typischerweise `Arc<dyn ServiceTrait>`.
3. **Granulare Events:** Events sind spezifisch und enthalten alle notwendigen Daten, um Subscribern eine sinnvolle Reaktion zu ermöglichen, ohne zusätzliche Abfragen tätigen zu müssen (außer bei Bedarf für sehr große Datenmengen). Jedes Event hat eine eindeutige ID (`Uuid`) und einen Zeitstempel (`DateTime<Utc>`).
4. **Fehler-Wrapping und -Kontext:** Fehler werden über Schichten hinweg mit `#[from]` oder `#[source]` gewrappt, um die ursprüngliche Ursache nachvollziehbar zu halten. Fehlertypen enthalten kontextspezifische Informationen (z.B. Pfade, IDs).
5. **Asynchronität für potenziell blockierende Operationen:** Alle Operationen, die I/O beinhalten oder länger dauern könnten (insbesondere in Domänen- und Systemschicht-APIs), sind `async`. Die UI-Schicht verwendet `tokio::spawn` oder `glib::MainContext::spawn_local` um diese `async` Funktionen aufzurufen, ohne die UI zu blockieren.
6. **Threadsicherheit:** Geteilter Zustand in Service-Implementierungen wird mit `Arc<tokio::sync::Mutex<...>>` oder `Arc<tokio::sync::RwLock<...>>` geschützt.
7. **Kommunikation mit dem Compositor-Thread:** Operationen, die direkten Zugriff auf `DesktopState` (oder andere nicht-`Send` Smithay-Strukturen) benötigen und von `async` Kontexten außerhalb des Compositor-`calloop`-Threads ausgelöst werden, müssen sorgfältig gehandhabt werden:
    - **Option A (Bevorzugt für kurze Operationen):** `LoopHandle::insert_idle()` oder `LoopHandle::send_event()` um eine Funktion/einen Task im `calloop`-Thread auszuführen.
    - **Option B (Für komplexe Interaktionen):** Dedizierte `mpsc` oder `oneshot` Kanäle zwischen `async` Tasks und dem Compositor-Thread.
    - **Option C (Wenn Daten `Send` sind):** `Arc<Mutex<TeilVonDesktopState>>`, wobei der Mutex `parking_lot::Mutex` sein kann für blockierende Operationen aus dem Compositor-Thread und `tokio::sync::Mutex` für `async` Tasks.

Diese ultra-feingranulare Definition der Schnittstellen ist der Schlüssel zu einer disziplinierten Entwicklung. Jede Interaktion ist spezifiziert, was die Integration der Schichten erleichtert und die Testbarkeit verbessert.

**1. Schnittstelle: Kernschicht (Core Layer) zu höheren Schichten**

- **1.1.1. `core::types` Schnittstelle:**
    - **Exakte Typdefinitionen referenzieren:** Verlinken Sie oder wiederholen Sie die exakten Rust-Definitionen von `Point<T>`, `Size<T>`, `Rect<T>`, `RectInt`, `Color`, `Orientation` aus `A1 Kernschicht.md` / `1. Core-Details.md` / `Infrastruktur ( UI fehlt).md`. Inklusive aller abgeleiteten Traits (`Debug`, `Clone`, `Serialize`, etc.) und implementierten Methoden mit Signaturen.
    - **Nutzungsbeispiele präzisieren:** "Domänenschicht verwendet `Color` für `TokenValue::Color(String)` und `AccentColor.value: CoreColor`."
- **1.1.2. `core::errors` Schnittstelle:**
    - **Exakte Fehlerdefinition referenzieren:** Verlinken oder wiederholen Sie die Definition von `CoreError` und `ColorParseError` aus `A2 Kernschicht.md` / `A3 Kernschicht Fehlerbehandlung.md` / `A4 Kernschicht.md`. Inklusive aller Varianten, `#[error(...)]`-Attribute und `#[source]` / `#[from]`-Annotationen.
    - **Fehler-Wrapping-Regel:** "JEDE höhere Schicht, die eine Funktion aus der Kernschicht aufruft, die `Result<_, CoreError>` (oder einen spezifischeren Kernfehler wie `ConfigError`) zurückgibt, MUSS diesen Fehler entweder:
        - Explizit behandeln (match).
        - Oder in ihren eigenen Fehlertyp wrappen. Diese Wrapper-Variante in den höheren Schichten MUSS `#[from] CoreError` oder `#[source] source: CoreError` verwenden, um die Fehlerkette zu erhalten."
- **1.1.3. `core::logging` Schnittstelle:**
    - **Exakte Signatur:** `pub fn initialize_logging(level_filter: tracing::LevelFilter, format: LogFormat) -> Result<(), LoggingError>` (aus `A4 Kernschicht.md`). Die Enums `LogFormat` und `LoggingError` MÜSSEN hier ebenfalls exakt definiert werden.
    - **Verwendungsrichtlinie:** "Alle Module in allen Schichten MÜSSEN die Makros `tracing::{trace, debug, info, warn, error}` für Logging verwenden. Sensible Daten DÜRFEN NICHT geloggt werden."
- **1.1.4. `core::config` Schnittstelle:**
    - **Exakte Signaturen und Strukturen referenzieren:** `load_core_config(...) -> Result<CoreConfig, ConfigError>`, `get_global_core_config() -> &'static CoreConfig`, `initialize_global_core_config(config: CoreConfig) -> Result<(), ConfigError>` (aus `A4 Kernschicht.md`). Die Struktur `CoreConfig` (und alle ihre Unterstrukturen wie `LogLevelConfig`, `FeatureFlags`) und der `ConfigError`-Enum MÜSSEN hier exakt spezifiziert werden.
    - **Suchreihenfolge für `load_core_config`:** (Wie in meiner vorherigen Analyse vorgeschlagen) "1. `custom_path` (falls `Some`), 2. `$XDG_CONFIG_HOME/novade/core.toml`, 3. `/etc/novade/core.toml`. Wenn keine Datei gefunden wird, wird `ConfigError::NoConfigurationFileFound` zurückgegeben. Die aufrufende Schicht (typischerweise beim Anwendungsstart) MUSS dann `CoreConfig::default()` verwenden und dies loggen."
- **1.1.5. `core::utils` Schnittstelle:**
    - Für JEDE geplante Utility-Funktion: Exakte Signatur, Parameter, Rückgabetyp (`Result<_, UtilityXYError>`), Vor-/Nachbedingungen und eine kurze Beschreibung ihrer Logik. Jede `UtilityXYError` muss definiert sein.

**2. Schnittstelle: Domänenschicht (Domain Layer) zu System- und UI-Schicht**

Hier wird es komplexer, da die Domänenschicht viele Services bereitstellt.

- **Für jeden Domänen-Service-Trait (z.B. `ThemingEngine`, `WorkspaceManagerService`, `AIInteractionLogicService`, `NotificationService`, `GlobalSettingsService`, `WindowManagementPolicyService`):**
    
    - **Exakte Trait-Definition:** Alle Methoden mit exakten Signaturen (`async fn ...`), Parameter-Typen (die bereits in `core::types`, `domain::shared_types` oder den `types.rs` des jeweiligen Domänenmoduls definiert sein müssen) und Rückgabetypen (`Result<OkTyp, DomänenModulFehlerTyp>`).
    - **Datenstrukturen der API:** Alle Structs und Enums, die in den Methodensignaturen als Parameter oder Rückgabewerte verwendet werden (z.B. `AppliedThemeState`, `WorkspaceWindowLayout`, `AIInteractionContext`, `NotificationInput`), MÜSSEN exakt definiert werden (Felder, Typen, Ableitungen). Verweisen Sie auf die Moduldokumente (B1-B4, "2. Domain-Details.md").
    - **Events von diesem Service:**
        - Für jeden Event-Typ (z.B. `ThemeChangedEvent`, `WorkspaceEvent::WorkspaceCreated`, `NotificationEventEnum::NotificationPosted`): Die exakte Payload-Struktur muss definiert sein.
        - **Event-Bus-Spezifikation:** "Jeder Domänen-Service, der Events publiziert, hält einen `tokio::sync::broadcast::Sender<EventType>`. Die `subscribe_to_xxx_events()`-Methode des Services gibt einen `tokio::sync::broadcast::Receiver<EventType>` zurück. Die Kapazität des Broadcast-Kanals wird beim Erstellen des Service festgelegt (z.B. `new(..., broadcast_capacity: usize)`)."
    - **Fehlertypen dieses Services:** Der spezifische Fehler-Enum des Domänenmoduls (z.B. `ThemingError`, `WorkspaceManagerError`) MUSS hier als Teil der Schnittstelle explizit genannt werden.
    - **Beispielhafte Nutzung durch System-/UI-Schicht präzisieren:**
        - "Systemschicht: Der `system::mcp_client::service::DefaultSystemMcpService` ruft `ai_interaction_service.get_consent_status_for_interaction(...)` auf. Der zurückgegebene `AIInteractionError` wird in einen `SystemMcpError::DomainInteractionFailed` gewrappt."
        - "UI-Schicht: Das `ui::shell::PanelWidget` (oder dessen Submodule) abonniert `ThemingEngine::subscribe_to_theme_changes()` und erhält `ThemeChangedEvent`. Bei Empfang wird `ui::theming_gtk::apply_resolved_tokens(event.new_state.resolved_tokens)` aufgerufen."
- **Spezifische Ultra-Feinspezifikation für `domain::user_centric_services::notification_service_impl` und `core::config::loader` (aus Ihrem Plan):**
    
    - Diese Detailtiefe ist exzellent und genau das, was für _alle_ Module und deren öffentliche APIs (und internen, wenn für die Schnittstelle relevant) benötigt wird. Ihr Plan, dies für ausgewählte Module zu tun, ist gut. Dieser Detailgrad muss auf die _Schnittstellenbeschreibung zwischen den Schichten_ erweitert werden.
    - **Inkonsistenz-Beispiel und Lösung im Plan:**
        - `notification_api.rs` definiert `replaces_id: Option<NotificationId>` für `post_notification`.
        - Die D-Bus-Schnittstelle (`notification_dbus_service.rs`) nimmt `replaces_id_dbus: u32`.
        - Die Schnittstellendokumentation muss das **Mapping** spezifizieren: "Der `system::dbus::notification_dbus_service` MUSS `replaces_id_dbus: u32` in `Option<NotificationId>` für den Aufruf von `NotificationService::post_notification` umwandeln. Wenn `replaces_id_dbus == 0`, dann ist das Ergebnis `None`. Andernfalls MUSS der `IdMapper` konsultiert werden, um die `u32` in eine `NotificationId` (Uuid) zu konvertieren. Wenn keine Uuid für die `u32` existiert, ist dies ein `NotificationDBusError::InvalidReplacesId`."
        - Ähnlich für die Rückgabe der neuen `NotificationId` (Uuid) als `u32` D-Bus-ID.

**3. Schnittstelle: Systemschicht (System Layer) zu Benutzeroberflächenschicht (UI Layer)**

- **Für jede von der Systemschicht bereitgestellte Information/Funktion:**
    - **Exakter API-Aufruf (oft ein Trait, den die Systemschicht implementiert und die UI-Schicht nutzt) oder Event:**
        - **Fensterinformationen:** `system::compositor_facade::CompositorViewService::get_visible_windows_for_space(space_id: WorkspaceId) -> Result<Vec<WindowViewData>, SystemError>`. Die Struktur `WindowViewData { id: DomainWindowIdentifier, title: String, app_id: ApplicationId, rect: RectInt, has_focus: bool, decoration_mode: DecorationMode }` muss definiert sein.
        - **Eingabeereignisse:** "Die UI-Schicht registriert Callback-Handler bei `system::input::InputManager::register_keyboard_event_handler(Box<dyn Fn(KeyEventData) + Send>)`. Die Struktur `KeyEventData { keysym: u32, utf8: Option<String>, modifiers: ModifiersState, state: KeyState }` muss definiert sein." (Alternativ: Systemschicht sendet Events über den `SystemEventBridge`).
        - **Status von Systemdiensten:** Z.B. `system::dbus::upower_client_service::UPowerService::get_current_power_state() -> Result<PowerStateData, SystemError>`.
    - **Fehlertypen:** Jeder Service der Systemschicht, den die UI aufruft, gibt einen spezifischen Systemfehler zurück.
    - **Event-Strukturen und Event-Bus:** Wenn die Systemschicht Events an die UI sendet (z.B. `OutputConfigurationChangedEvent`), müssen diese Events und der Bus spezifiziert werden (wahrscheinlich der `SystemEventBridge`).

**4. Allgemeine Kommunikationsmuster (aus Ihrem Plan)**

Diese sind gut, aber müssen für die KI konkretisiert werden:

- **Synchrone Aufrufe:** Nur innerhalb eines Threads oder wenn der aufgerufene Code garantiert nicht blockiert. Für schichtübergreifende Aufrufe selten, außer für einfache Getter auf bereits gecachte/gehaltene Daten.
- **Asynchrone Operationen:** Alle schichtübergreifenden Aufrufe, die I/O oder potenziell längere Berechnungen beinhalten, MÜSSEN `async` sein und `Result<_, _>` zurückgeben.
- **Event-Broadcasting:** Der `SystemEventBridge` (für System-interne und System-zu-UI Events) und die `tokio::sync::broadcast`-Kanäle in Domänen-Services sind die festgelegten Mechanismen.
    - _Spezifizieren:_ Welche Events werden von welchem Modul über welchen Sender/Kanal gesendet? Wer sind die erwarteten Subscriber?
- **Fehlerpropagation:** Die Regel "Die `source()`-Kette MUSS erhalten bleiben" ist kritisch.

**Inkonsistenzen erkennen und beheben durch diesen detaillierten Plan:**

Indem Sie jede Schnittstelle so detailliert definieren, werden Inkonsistenzen aufgedeckt:

1. **Typ-Mismatch:** Wenn `domain::theming` eine `core::types::Color` erwartet, aber `ui::control_center` versucht, einen `String` zu senden, wird dies beim Definieren der `GlobalSettingsService::update_setting`-Signatur und der `SettingPath`-Logik klar.
2. **Fehlende Fehlerbehandlung:** Wenn eine Funktion `Result` zurückgibt, aber die aufrufende Schicht den `Err`-Fall nicht behandelt oder nicht in ihren eigenen Fehlertyp mapped, wird dies beim Definieren des Fehler-Mappings auffallen.
3. **Semantische Unterschiede:** (Wie beim `replaces_id`-Beispiel oben) Die D-Bus-Spezifikation verwendet `u32`, die Domäne `Option<Uuid>`. Die Schnittstellendefinition muss die Transformation explizit machen.
4. **Fehlende Daten:** Wenn die UI-Schicht eine bestimmte Information zum Darstellen eines Fensters benötigt (z.B. "minimiert"-Status), aber die von `system::compositor` bereitgestellte `WindowViewData`-Struktur dieses Feld nicht enthält, wird die Lücke offensichtlich.
5. **Unklare Verantwortlichkeiten für Zustandsänderungen:** Wenn sowohl die Domäne als auch die Systemschicht versuchen, denselben Zustand zu modifizieren, ohne klare Koordination, wird dies bei der Definition der API-Aufrufe und Event-Flüsse sichtbar.
# Detaillierte Analyse und Implementierungsstrategien für die Systemschicht von NovaDE

Dieser Bericht analysiert die Kernkomponenten der Systemschicht (novade-system) der Linux-Desktop-Umgebung NovaDE. Er fokussiert auf bewährte Verfahren, typische Fallstricke und Lösungen für potenzielle Implementierungsprobleme unter Verwendung der spezifizierten Technologien wie Smithay, libinput, zbus und PipeWire.

## 1. Smithay Compositor-Entwicklung (system::compositor)

Die Entwicklung eines Wayland-Compositors mit Smithay erfordert eine sorgfältige Planung des Zustandsmanagements, der Fensterrepräsentation und der Protokollimplementierungen.

### 1.1. Zustandsmanagement in `DesktopState`

Die `DesktopState`-Struktur ist das Herzstück des Compositors und implementiert eine Vielzahl von Smithay-Handler-Traits (z.B. `CompositorHandler`, `XdgShellHandler`, `ShmHandler`, `SeatHandler`). Dies birgt die Gefahr, dass `DesktopState` zu einem "God Object" mit übermäßiger Komplexität wird.1

**Best Practices zur Strukturierung:**

- **Modularisierung durch Komposition:** Anstatt alle Logik direkt in `DesktopState` zu implementieren, sollten spezialisierte Sub-Strukturen für zusammengehörige Funktionalitäten verwendet werden. Beispielsweise könnte eine `XdgShellState` die Logik für `xdg_shell` kapseln und von `DesktopState` referenziert werden. Smithay selbst fördert diesen Ansatz durch spezifische Zustandsstrukturen für viele Protokolle (z.B. `smithay::wayland::shell::xdg::XdgShellState`, `smithay::wayland::seat::SeatState`).2
- **Trait-basierte Abstraktion:** Für komplexe, wiederverwendbare Logik innerhalb der Handler können eigene Traits definiert und von `DesktopState` oder dessen Sub-Strukturen implementiert werden.
- **Klare Verantwortlichkeiten:** Jeder Handler-Trait sollte primär für die Interaktion mit dem entsprechenden Wayland-Protokoll zuständig sein. Anwendungslogik, die darüber hinausgeht (z.B. spezifische Fensterverwaltungsregeln), sollte in separate Module ausgelagert und von den Handlern aufgerufen werden.

**Strategien zur Verwaltung von `Arc<Mutex/RwLock<...>>`:**

Der Zugriff auf geteilte Zustände innerhalb der asynchronen Handler-Methoden erfordert Synchronisation. `Arc<Mutex<T>>` oder `Arc<RwLock<T>>` sind hierfür gängige Muster in Rust.4

- **Granularität der Locks:** Sperren sollten so feingranular wie möglich gehalten werden, um Contention zu minimieren. Anstatt den gesamten `DesktopState` zu sperren, sollten nur die tatsächlich benötigten Teile des Zustands gesperrt werden.
- **`RwLock` bevorzugen:** Für Zustände, die häufig gelesen und selten geschrieben werden, ist `RwLock` performanter als `Mutex`, da es mehrere gleichzeitige Leser erlaubt.
- **Vermeidung von Deadlocks:** Besondere Vorsicht ist bei verschachtelten Locks oder dem Aufruf von externem Code (z.B. Client-Callbacks) innerhalb eines Locks geboten. Die Reihenfolge der Lock-Akquirierung sollte konsistent sein.
- **Kurze Lock-Dauer:** Locks sollten nur so lange wie unbedingt nötig gehalten werden. Operationen, die außerhalb des kritischen Abschnitts durchgeführt werden können, sollten dies auch tun.

Smithay selbst empfiehlt, einen zentralen, mutablen Zustand über `calloop` an die Callbacks zu übergeben, was die Notwendigkeit von `Arc<Mutex<T>>` für den Hauptzustand reduzieren kann, da Callbacks sequenziell ausgeführt werden.6 Für Zustände, die von nebenläufigen Tasks (z.B. D-Bus-Handler in Tokio) modifiziert werden und vom Compositor-Thread gelesen werden müssen, bleiben `Arc<Mutex/RwLock<T>>` jedoch relevant.

**Beispiel (konzeptionell):**

Rust

```
pub struct DesktopState {
    pub compositor_state: smithay::wayland::compositor::CompositorState,
    pub xdg_shell_state: smithay::wayland::shell::xdg::XdgShellState,
    pub seat_state: smithay::wayland::seat::SeatState<Self>,
    pub space: Arc<Mutex<smithay::desktop::Space<smithay::desktop::Window>>>,
    //... weitere Zustands-Subkomponenten
}

// Implementierung der Handler-Traits für DesktopState,
// die oft auf die Sub-Zustände delegieren.
// smithay::delegate_compositor!(DesktopState);
// smithay::delegate_xdg_shell!(DesktopState);
//...
```

Die `delegate_*!` Makros von Smithay sind essentiell, um die Implementierung der Handler-Traits an die entsprechenden Zustandsstrukturen zu delegieren und Boilerplate-Code zu reduzieren.2

### 1.2. `ManagedWindow` und `smithay::desktop::Space`

`ManagedWindow` ist eine Abstraktion über Wayland-Fenster (XDG Toplevels, Popups) und XWayland-Fenster. Es implementiert das `smithay::desktop::Window`-Trait.

**Korrekte Implementierung des `Window`-Traits:**

Das `smithay::desktop::Window`-Trait 9 erfordert die Implementierung verschiedener Methoden, um die Eigenschaften und das Verhalten eines Fensters zu definieren:

- `bbox()`: Gibt die Bounding Box des Fensters inklusive aller Subsurfaces und Popups zurück.
- `is_wayland()` / `is_x11()`: Unterscheidet zwischen Wayland- und X11-Fenstern.
- `toplevel()`: Gibt eine Referenz auf die zugrundeliegende `ToplevelSurface` (für XDG-Fenster) zurück.
- `send_frame()`: Sendet Frame-Callbacks an die Oberflächen des Fensters.
- `surface_under()`: Findet die Oberfläche unter einem gegebenen Punkt.
- `set_activated()`: Setzt den Aktivierungszustand des Fensters.
- `geometry()`: Gibt die Kerngeometrie des Fensters zurück (ohne Dekorationen).
- `on_commit()`: Wird aufgerufen, wenn die zugrundeliegende Oberfläche einen Commit durchführt.

**Repräsentation von Fenstergeometrien und -zuständen:**

- **Geometrie:** Die Geometrie (`Rectangle<i32, Logical>`) wird typischerweise direkt in der `ManagedWindow`-Struktur gespeichert und bei `configure`-Events vom Client oder durch Aktionen des Compositors aktualisiert. Sie repräsentiert die von der Anwendung gewünschte Größe und Position des Fensterinhalts.
- **Zustände (maximiert, aktiv, etc.):** Diese Zustände sollten ebenfalls in `ManagedWindow` gespeichert werden (z.B. als Booleans oder Enums).
    - Der **maximierte Zustand** wird durch Anfragen des Clients (z.B. `xdg_toplevel::set_maximized`) oder Aktionen des Compositors gesetzt. Die tatsächliche Geometrie wird dann vom Compositor basierend auf dem verfügbaren Platz des Outputs angepasst.
    - Der **aktive Zustand** wird vom Compositor verwaltet (typischerweise im `SeatHandler` in Reaktion auf Benutzereingaben) und an das Fenster propagiert (z.B. über `Window::set_activated(true)`).
- **Dekorationen (CSD/SSD via `xdg-decoration`):**
    - Das `xdg-decoration-unstable-v1`-Protokoll ermöglicht die Aushandlung zwischen Client-Side Decorations (CSD) und Server-Side Decorations (SSD).12
    - `ManagedWindow` (oder eine assoziierte Struktur) muss den ausgehandelten Dekorationsmodus (`zxdg_toplevel_decoration_v1::mode`) speichern.
    - Wenn SSD aktiv ist, ist der Compositor für das Zeichnen der Dekorationen verantwortlich. `ManagedWindow` sollte Informationen bereitstellen, die für das Rendern der SSDs benötigt werden (z.B. Titel, aktive/inaktive Zustände).
    - Wenn CSD aktiv ist, zeichnet der Client die Dekorationen selbst. Der Compositor muss die Geometrie des Fensters entsprechend berücksichtigen.
    - Die `XdgDecorationState` und `XdgDecorationHandler` von Smithay helfen bei der Implementierung dieses Protokolls.15 Die `XdgDecorationHandler::request_mode` und `new_decoration` Methoden sind hierbei zentral. Der Server (Compositor) sendet `configure`-Events an den `zxdg_toplevel_decoration_v1`, um den Modus festzulegen. Der Client antwortet mit `set_mode` oder `unset_mode`.

**Synchronisation mit `XdgToplevelSurfaceData`:**

`XdgToplevelSurfaceData` 3 speichert den Zustand, der spezifisch für eine `xdg_toplevel`-Oberfläche ist (z.B. angeforderte Größe, Zustände wie maximiert, minimiert, fullscreen, App-ID, Titel).

- Wenn der Client Zustandsänderungen anfordert (z.B. `set_title`, `set_maximized`), werden diese im `XdgToplevelSurfaceData` (oft im `pending_state`) gespeichert.
- Bei einem `wl_surface.commit` werden diese Änderungen durch den `XdgShellHandler` verarbeitet.
- Die Logik im `XdgShellHandler` (oder in `ManagedWindow::on_commit`) muss dann den Zustand von `ManagedWindow` mit den Daten aus `XdgToplevelSurfaceData` synchronisieren. Beispielsweise wird ein `xdg_toplevel.set_maximized` im `XdgToplevelSurfaceData` vermerkt, und der Compositor entscheidet dann, ob und wie er das Fenster maximiert und sendet entsprechende `configure`-Events. Die `send_configure`-Methode auf `ToplevelSurface` ist hierbei zentral, um dem Client die neue Konfiguration mitzuteilen.20 Der Client muss diese Konfiguration mit `ack_configure` bestätigen.

**Interaktion mit `Space`:**

Der `smithay::desktop::Space` 9 verwaltet die Anordnung von Fenstern und anderen Elementen im 2D-Raum.

- `Space::map_window(window, location, activate)`: Fügt ein `ManagedWindow` zum `Space` an einer bestimmten `location` hinzu und legt die Stapelreihenfolge fest. `activate` gibt an, ob das Fenster aktiviert werden soll.
- `Space::unmap_window(window)`: Entfernt ein Fenster aus dem `Space`.
- `Space::raise_window(window, activate)`: Bringt ein Fenster in der Stapelreihenfolge nach vorne.
- **Schadensverfolgung (Damage Tracking):**
    - `Space::damage_window(window, new_damage, old_damage)`: Wird verwendet, um dem `Space` mitzuteilen, dass sich Bereiche eines Fensters geändert haben. `new_damage` sind die beschädigten Regionen in Fensterkoordinaten. `old_damage` kann verwendet werden, wenn sich die Position oder Größe des Fensters geändert hat.
    - `Space::damage_output(output, damage)`: Markiert einen Bereich auf einem bestimmten Output als beschädigt.
    - Wenn ein Client einen neuen Puffer committet (`wl_surface.commit`), wird die `SurfaceAttributes.damage`-Region aktualisiert.26 Der Compositor muss diese Information dann an den `Space` weiterleiten, typischerweise über `damage_window`.
    - `render_output` verwendet die akkumulierten Schadensinformationen, um nur die notwendigen Bereiche eines Outputs neu zu zeichnen und so die Performance zu optimieren.9

### 1.3. Wayland Protokoll-Implementierung (spezifisch)

**1.3.1. `wlr-output-management-unstable-v1`** 6

Dieses Protokoll ermöglicht Clients (z.B. Display-Konfigurationstools wie `kanshi` 34 oder `wdisplays` 33) das Abfragen und Ändern der Konfiguration von Ausgabegeräten (Heads).

- **`apply` und `test` Requests auf `zwlr_output_configuration_v1`:**
    - Ein Client erstellt ein `zwlr_output_configuration_v1`-Objekt mit einem bestimmten `serial` (erhalten vom `zwlr_output_manager_v1.done`-Event).
    - Auf diesem Konfigurationsobjekt kann der Client Änderungen für einzelne `zwlr_output_head_v1`-Objekte vornehmen (z.B. Modus, Position, Skalierung, Aktivierungsstatus setzen).
    - **`test` Request:** Der Client sendet einen `test`-Request, um die Konfiguration zu validieren, ohne sie anzuwenden. Der Compositor prüft, ob die Konfiguration prinzipiell möglich ist.
    - **`apply` Request:** Der Client sendet einen `apply`-Request, um die Konfiguration anzuwenden.
    - **Antworten des Compositors:** In beiden Fällen (`test` und `apply`) muss der Compositor mit einem der folgenden Events antworten:
        - `succeeded`: Die Konfiguration wurde erfolgreich getestet/angewendet. Der Client sollte das Konfigurationsobjekt zerstören. Wenn die Konfiguration angewendet wurde und sich der Zustand geändert hat, sendet der Manager `head`-Events und ein `done`-Event mit einem neuen Serial.
        - `failed`: Die Konfiguration konnte nicht getestet/angewendet werden (z.B. ungültiger Modus). Der Compositor sollte alle Änderungen, die durch einen `apply`-Request ausgelöst wurden, zurückrollen. Der Client sollte das Konfigurationsobjekt zerstören.
        - `cancelled`: Die Konfiguration wurde vom Compositor abgebrochen, weil sich der Zustand eines Outputs geändert hat und die Informationen des Clients veraltet sind (z.B. durch Hotplugging). Der Client kann eine neue Konfiguration mit einem neueren Serial erstellen und es erneut versuchen. Der Client sollte das Konfigurationsobjekt zerstören.
- **Atomarität und Serial-Nummern:**
    - Der `serial` spielt eine Schlüsselrolle für die Atomarität. Der `zwlr_output_manager_v1` sendet ein `done`-Event mit einem `serial`, nachdem alle aktuellen Zustandsinformationen gesendet wurden.29
    - Der Client muss diesen `serial` beim Erstellen eines `zwlr_output_configuration_v1`-Objekts verwenden. Dies stellt sicher, dass die Konfigurationsänderungen des Clients auf einem aktuellen Stand des Compositor-Zustands basieren.
    - Wenn der Compositor eine Konfiguration mit einem veralteten `serial` erhält, kann er diese mit `cancelled` ablehnen.
    - Die Änderungen innerhalb eines `apply`-Requests sollten atomar angewendet werden. Das bedeutet, entweder alle Änderungen werden erfolgreich übernommen, oder bei einem Fehler wird der Zustand vor dem `apply`-Request wiederhergestellt (Rollback).31
- **Smithay Integration:**
    - Smithays `Output` und `OutputManagerState` 34 verwalten die Eigenschaften von Outputs (Modi, Skalierung, Transformation, aktivierter Zustand) und können diese über `wl_output` und `xdg_output` an Clients bekannt machen.
    - Zur Implementierung von `wlr-output-management` muss ein `OutputHandler` (oder eine ähnliche Logik) die Anfragen des Clients verarbeiten, die Konfigurationen validieren und anwenden und die entsprechenden `succeeded`, `failed` oder `cancelled` Events senden. Der `OutputManagerState` würde die globalen Objekte bereitstellen und die `OutputHandler`-Implementierung würde die spezifischen Anfragen bearbeiten.
    - Die Atomarität erfordert sorgfältiges Zustandsmanagement im Compositor. Bevor eine Konfiguration angewendet wird, sollte der aktuelle Zustand zwischengespeichert werden, um im Fehlerfall ein Rollback durchführen zu können.

**1.3.2. `wlr-output-power-management-unstable-v1`** 30

Dieses Protokoll ermöglicht Clients (typischerweise Desktop-Shells) die Steuerung der Energieverwaltungsmodi (DPMS) von Ausgabegeräten, die Teil des Compositor-Raums sind.

- **Exklusive Kontrolle pro Output (`get_output_power`):**
    - Der Client fordert über `zwlr_output_power_manager_v1::get_output_power` ein `zwlr_output_power_v1`-Objekt für ein bestimmtes `wl_output` an.
    - Der Compositor kann diesen Request ablehnen (und ein `failed`-Event auf dem `zwlr_output_power_v1`-Objekt senden), wenn z.B. der Output kein Power-Management unterstützt oder ein anderer Client bereits exklusive Kontrolle hat.30 Dies impliziert, dass der Compositor den Besitz von Power-Management-Kontrollen pro Output verfolgen muss.
- **Reaktion auf vom Compositor initiierte DPMS-Änderungen:**
    - Das `zwlr_output_power_v1::mode`-Event wird gesendet, wenn sich der Power-Modus eines Outputs ändert. Dies kann durch einen `set_mode`-Request des Clients oder durch eine Entscheidung des Compositors selbst geschehen (z.B. durch Inaktivitäts-Timer).49
    - Wenn der Compositor den DPMS-Zustand eines Outputs ändert (z.B. über `system::power_management`), muss er das `mode`-Event an alle Clients senden, die ein `zwlr_output_power_v1`-Objekt für diesen Output halten.
- **Smithay Integration:**
    - Die `OutputHandler`-Implementierung 6 müsste erweitert werden, um die Anfragen dieses Protokolls zu verarbeiten.
    - Der `OutputManagerState` 36 würde das globale `zwlr_output_power_manager_v1`-Objekt verwalten.
    - Der Zustand (aktueller Power-Modus, exklusive Kontrolle) müsste pro Output im Compositor-Zustand (`DesktopState` oder einer Substruktur) gespeichert werden.

**1.3.3. `wlr-layer-shell-unstable-v1`** 53

Dieses Protokoll erlaubt es Clients, Oberflächen (Layer Surfaces) zu erstellen, die über, unter oder zwischen normalen Fenstern gerendert werden, typischerweise für Panels, Hintergrundbilder, Benachrichtigungen und Sperrbildschirme.

- **Management von `LayerSurface`-Daten:**
    - Für jede `LayerSurface` müssen Informationen wie die gewünschte Schicht (`zwlr_layer_shell_v1::layer`), Anker (`anchor`), exklusive Zone (`exclusive_zone`), Ränder (`margin`) und Interaktivitätseinstellungen (`keyboard_interactivity`) gespeichert werden. Diese Daten sind oft Teil einer `SurfaceData`-ähnlichen Struktur, die mit der `wl_surface` der `LayerSurface` assoziiert ist.
    - Smithays `WlrLayerShellState` und `WlrLayerShellHandler` 59 sind für die Verwaltung dieser Zustände und die Bearbeitung von Client-Anfragen zuständig.
- **Interaktion mit `PopupManager` für Layer-Popups:**
    - `LayerSurface`s können Popups haben (z.B. ein Kalender-Popup von einem Panel). Das `zwlr_layer_surface_v1::get_popup`-Request wird verwendet, um ein `xdg_popup` einer `LayerSurface` zuzuordnen.54
    - Der `smithay::desktop::PopupManager` 9 sollte so erweitert oder verwendet werden, dass er auch Popups von `LayerSurface`s korrekt verwalten und positionieren kann. Dies bedeutet, dass der `PopupManager` die Hierarchie von Popups relativ zu ihren Eltern-`LayerSurface`s verstehen muss.
- **Korrekte Berechnung von exklusiven Zonen:**
    - Eine `LayerSurface` kann eine exklusive Zone anfordern (`set_exclusive_zone`). Dies ist ein Bereich entlang eines oder mehrerer Ränder des Outputs, den andere Oberflächen (insbesondere maximierte Fenster) nicht verdecken sollten.55
    - Der Compositor muss die exklusiven Zonen aller `LayerSurface`s auf einem Output aggregieren. Dies ist besonders wichtig für das `system::window_mechanics`-Modul, um Fenster korrekt zu positionieren und zu maximieren, ohne über Panels oder andere Layer-Elemente zu ragen.
    - Die Berechnung muss die Schicht (`layer`), den Anker und die Ränder der `LayerSurface` berücksichtigen. Ein Wert von -1 für die exklusive Zone bedeutet, dass die Oberfläche nicht verschoben werden soll, auch wenn sie andere exklusive Zonen überlappt.56
    - Die `smithay::desktop::Space`-Logik muss diese exklusiven Zonen bei der Berechnung des verfügbaren Arbeitsbereichs für normale Fenster berücksichtigen.

### 1.4. Renderer-Abstraktion

Eine robuste Renderer-Abstraktion ist entscheidend für Flexibilität und Wartbarkeit. Die Traits `FrameRenderer` und `RenderableTexture` sind hierfür vorgesehen.

- **Robuste Trait-Definitionen:**
    - **`FrameRenderer`:**
        - Sollte Methoden zum Beginnen und Beenden eines Frames bereitstellen.
        - Methoden zum Rendern von `RenderableTexture`s an bestimmten Positionen mit Transformationen (Skalierung, Rotation), Alpha-Blending und Clipping-Regionen.
        - Methoden zum Löschen des Framebuffers oder Teilen davon.
        - Potenziell Methoden zur Verwaltung von Shader-Programmen oder anderen Renderer-spezifischen Ressourcen.
    - **`RenderableTexture`:**
        - Repräsentiert eine Textur, die vom `FrameRenderer` gezeichnet werden kann.
        - Sollte Methoden zum Abrufen der Dimensionen und des Formats der Textur bereitstellen.
        - Muss die zugrundeliegenden Pufferdaten (SHM oder DMABUF) kapseln.
- **Effiziente Pufferübergabe und Texturverwaltung:**
    - **SHM-Puffer:** Für SHM-Puffer (`wl_shm_buffer`) müssen die Pixeldaten in eine GPU-Textur hochgeladen werden. Dies kann bei jedem Frame oder nur bei Änderungen erfolgen.
    - **DMABUF-Puffer:** DMABUFs können oft direkt von der GPU importiert werden, was den Kopiervorgang CPU -> GPU vermeidet. Smithays `DmabufFeedback` und `ImportDma` 60 sind hier relevant.
    - **Textur-Caching:** Um das wiederholte Hochladen identischer Pufferinhalte zu vermeiden, kann ein Textur-Cache implementiert werden. Texturen können anhand eines Identifikators des Puffers (z.B. `wl_buffer`-Objekt-ID oder ein Hash des Inhalts für SHM) zwischengespeichert werden.
    - **Freigabe:** Wenn ein `wl_buffer` vom Client freigegeben wird (`wl_buffer.release`), sollten auch die zugehörigen Texturen im Cache freigegeben oder als wiederverwendbar markiert werden.
- **Kommunikation von Schadensverfolgung (Damage Tracking):**
    - Der Compositor (speziell `DesktopState` oder `Space`) verfolgt die beschädigten Regionen jeder Oberfläche (`wl_surface.damage_buffer` oder `wl_surface.damage_surface`) und des gesamten Outputs.9
    - Diese Schadensinformation (typischerweise eine Liste von Rechtecken) muss an den `FrameRenderer` übergeben werden.
    - Der `FrameRenderer` sollte diese Information nutzen, um nur die beschädigten Bereiche des Framebuffers neu zu zeichnen (z.B. durch Setzen einer Scissor-Region oder durch differenzielles Rendern).
    - Smithay bietet im Modul `smithay::backend::renderer::damage` Hilfsmittel für das Damage Tracking auf Output-Ebene.60 Die `Frame`-Implementierung des Renderers sollte die akkumulierten Schäden berücksichtigen.

**Beispiel (konzeptionelle Trait-Definitionen):**

Rust

```
use smithay::utils::{Point, Rectangle, Scale, Transform};
use smithay::backend::renderer::Renderer; // Basis-Renderer-Trait von Smithay

pub trait RenderableTexture {
    fn width(&self) -> u32;
    fn height(&self) -> u32;
    // Evtl. Methode, um den zugrundeliegenden Puffer-Typ zu identifizieren (SHM, DMABUF)
    // fn buffer_type(&self) -> BufferType;
    // Evtl. Methode, um die Textur-ID für den spezifischen Renderer zu erhalten
    // fn renderer_id(&self) -> RendererTextureId;
}

pub trait FrameRenderer<T: RenderableTexture, R: Renderer> { // R ist der Backend-Renderer von Smithay
    fn begin_frame(&mut self, output_damage: Option<&>) -> Result<(), R::Error>;
    fn render_texture(
        &mut self,
        texture: &T,
        src_rect: Rectangle<f64, smithay::utils::Buffer>, // Quellrechteck auf der Textur
        dst_rect: Rectangle<i32, smithay::utils::Physical>, // Zielrechteck auf dem Framebuffer
        transform: Transform,
        alpha: f32,
        damage: &, // Schaden relativ zur Textur im Ziel-Framebuffer
    ) -> Result<(), R::Error>;
    fn clear(&mut self, color: [f32; 4], region: &) -> Result<(), R::Error>;
    fn finish_frame(&mut self) -> Result<(), R::Error>; // Beinhaltet Swap-Buffers o.ä.
}
```

Die Integration mit Smithays eigenem `Renderer`-Trait und den `RenderElement`-Strukturen 60 ist hierbei zu beachten. Die `FrameRenderer`-Abstraktion könnte auf Smithays `Frame`-Trait aufbauen oder dieses wrappen.

### 1.5. XWayland-Integration

Die Integration von XWayland ermöglicht die Ausführung von X11-Anwendungen in der Wayland-Umgebung.

- **Herausforderungen und Lösungen:**
    - **Starten und Verwalten des XWayland-Prozesses:**
        - Smithays `smithay::xwayland::XWayland::new()` 61 startet den XWayland-Server als Kindprozess. Der Compositor muss die Wayland- und X11-Sockets bereitstellen, über die XWayland kommuniziert.
        - Die `XWayland`-Struktur muss im `DesktopState` gehalten und bei Beendigung des Compositors ordnungsgemäß beendet werden.
    - **X11 Window Manager (`X11Wm`):**
        - Der Compositor muss als X11 Window Manager für die von XWayland erzeugten X11-Fenster agieren. Smithay stellt das `XwmHandler`-Trait und die `X11Wm`-Struktur bereit.61
        - Der `XwmHandler` muss Callbacks implementieren, um auf X11-Ereignisse wie das Erstellen, Zerstören, Konfigurieren und Verschieben von Fenstern zu reagieren.
        - Die `X11Wm`-Instanz verwaltet die Verbindung zum XWayland-Server und die X11-Fenster.
    - **Darstellung von X11-Fenstern (`X11Surface`) im Wayland-Space:**
        - XWayland erstellt für jedes X11-Top-Level-Fenster eine `wl_surface`. Smithays `X11Surface` 61 repräsentiert ein solches Fenster und ist mit der zugrundeliegenden X11-Fenster-ID und der `wl_surface` verbunden.
        - Diese `X11Surface`-Objekte müssen in das `smithay::desktop::Window`-Trait gewrappt und im `smithay::desktop::Space` verwaltet werden, genau wie native Wayland-Fenster.
        - Die Geometrie, Stapelreihenfolge und der Aktivierungszustand von X11-Fenstern müssen zwischen dem X11-Protokoll (via `X11Wm`) und dem Wayland-Space synchronisiert werden. Beispielsweise muss ein `XConfigureWindow`-Request vom `X11Wm` verarbeitet und die Position des `X11Surface` im `Space` entsprechend angepasst werden.
    - **Input-Routing:** Eingabeereignisse (Tastatur, Maus) für X11-Fenster müssen korrekt an XWayland weitergeleitet werden. Dies geschieht, indem der Fokus auf die `wl_surface` des `X11Surface` gesetzt wird. Der `SeatHandler` spielt hier eine wichtige Rolle.
    - **Synchronisation von Fensterzuständen:** Zustände wie Maximierung oder Aktivierung müssen zwischen dem Wayland-Compositor und dem X11-Zustand des Fensters synchron gehalten werden. Der `X11Wm` ist dafür verantwortlich, entsprechende X11-Properties (z.B. `_NET_WM_STATE`) zu setzen oder zu interpretieren.
- **Referenzimplementierungen:** Die Anvil-Demo-Compositor von Smithay enthält eine XWayland-Integration, die als gutes Beispiel dienen kann.6

## 2. Eingabeverarbeitung (system::input)

Die Eingabeverarbeitung ist eine kritische Komponente für die Benutzerinteraktion. NovaDE setzt hier auf `libinput` und `xkbcommon`.

### 2.1. `libinput` und `calloop`

- **Best Practices für die Integration des `LibinputInputBackend` in die `calloop`-Ereignisschleife:**
    - Der `LibinputInputBackend` wird typischerweise als eine `calloop::EventSource` in die `calloop`-Schleife eingefügt.
    - Die `dispatch`-Methode des Backends verarbeitet die anstehenden `libinput`-Events.
    - Um die Schleife nicht zu blockieren, sollte die Verarbeitung der einzelnen Events (z.B. Übersetzung in Wayland-Events, Fokus-Logik) möglichst effizient sein. Langwierige Operationen sollten vermieden oder in separate Tasks ausgelagert werden (obwohl dies im Input-Pfad selten vorkommt).
    - Smithay bietet in `smithay::backend::input` und `smithay::input` Abstraktionen, die die Integration erleichtern.
- **Effiziente Verarbeitung von `libinput`-Events:**
    - Events sollten so früh wie möglich gefiltert werden, wenn sie nicht relevant sind.
    - Die Übersetzung von `libinput`-Events in Wayland-Protokoll-Events sollte direkt und ohne unnötige Allokationen erfolgen.
    - Zustandsänderungen (z.B. Tastatur-Modifier-Status) sollten effizient aktualisiert werden.

### 2.2. `xkbcommon`

`xkbcommon` ist für die Interpretation von Tastatur-Layouts und die Übersetzung von Keycodes in Keysyms und UTF-8-Strings zuständig.

- **Korrekte Initialisierung und Aktualisierung von `xkb::State` pro Tastatur/Seat:**
    - Für jede Tastatur (oder allgemeiner, für jeden `Seat` mit Tastatur-Capability) muss eine eigene `xkb::Context` und `xkb::Keymap` erstellt werden.
    - Aus der `Keymap` wird dann eine `xkb::State` abgeleitet. Diese `XkbKeyboardData` (mit `xkb::State`) wird im `SeatState` gehalten.
    - **Layout-Wechsel:** Bei einem Layout-Wechsel (z.B. durch den Benutzer oder eine Systemkonfiguration) muss die `xkb::Keymap` neu geladen und eine neue `xkb::State` daraus erstellt und aktualisiert werden. Dies erfordert typischerweise die Interaktion mit Systemdiensten, die Layout-Änderungen signalisieren (z.B. über D-Bus).
- **Zuverlässige Implementierung von Modifikatoren und Tastenwiederholung:**
    - **Modifikatoren:** `xkb::State::update_key()` aktualisiert den Zustand der Modifikatoren (Shift, Ctrl, Alt, etc.) basierend auf den gedrückten/losgelassenen Tasten. Der `SeatHandler` muss diesen Zustand verwenden, um korrekte Keysyms und Modifier-Masken an die Clients zu senden.
    - **Tastenwiederholung (Key Repeat):**
        - `libinput` selbst sendet keine Wiederholungsereignisse. Der Compositor muss dies implementieren.
        - Wenn eine Taste gedrückt wird, für die Wiederholung aktiviert ist (konfigurierbar über `xkb::Keymap::key_repeats()`), startet ein Timer.
        - Der Timer wird in `calloop` verwaltet (z.B. `calloop::timer::Timer`).
        - Nach einer initialen Verzögerung (`repeat_delay`) sendet der Timer periodisch (mit `repeat_rate`) Events, die der Compositor als erneute Tastendrücke interpretiert und an den fokussierten Client weiterleitet.
        - Der Timer muss gestoppt werden, wenn die Taste losgelassen wird oder der Fokus wechselt.
        - Die `XkbKeyboardData` in der Spezifikation deutet darauf hin, dass die Konfiguration für die Tastenwiederholung (Rate, Verzögerung) aus `xkbcommon` bezogen wird.

### 2.3. Fokusmanagement

Das Fokusmanagement ist komplex und erfordert eine enge Koordination zwischen `SeatHandler`, `system::input` und `system::window_mechanics`.

- **Detaillierte Logik für `SeatHandler::focus_changed`:**
    - Diese Methode wird vom `Seat` aufgerufen, wenn sich der Fokus ändert.
    - Sie muss den alten und neuen Fokus-Target (typischerweise eine `WlSurface`) an die entsprechenden Clients kommunizieren (z.B. `wl_keyboard::leave`/`enter`, `wl_pointer::leave`/`enter`).
    - Der `SeatHandler` sollte auch den internen Zustand des Compositors aktualisieren (z.B. welches Fenster gerade aktiv ist).
- **Konsistente Handhabung des Fokus zwischen Tastatur, Zeiger und Touch:**
    - **Tastaturfokus:** Folgt typischerweise dem "aktiven Fenster". Ein Klick auf ein Fenster oder eine explizite Aktivierungsanforderung setzt den Tastaturfokus.
    - **Zeigerfokus ("Pointer Focus"):** Folgt der Mausbewegung. Wenn der Zeiger eine neue Oberfläche betritt, erhält diese den Zeigerfokus. Dies löst `wl_pointer::enter` und `wl_pointer::leave` aus.
    - **Touchfokus:** Ist oft an einen bestimmten Touchpunkt (Slot) gebunden. Wenn ein Touchpunkt auf einer Oberfläche landet, erhält diese Oberfläche den Touchfokus für diesen Slot.
    - Die Konsistenz wird dadurch erreicht, dass der `Seat` den Zustand für alle Eingabemethoden hält und der `SeatHandler` die entsprechenden Wayland-Events basierend auf diesem Zustand sendet.
- **Interaktion mit `system::window_mechanics::set_application_focus`:**
    - `set_application_focus` in `system::window_mechanics` ist für die _technische Umsetzung_ des Fokuswechsels zuständig (z.B. Anfordern der Aktivierung eines XDG-Toplevels, Aktualisieren des internen Zustands im `DesktopState`).
    - Der `SeatHandler` (oder die Logik, die Fokusentscheidungen trifft) ruft `set_application_focus` auf, um einen Fokuswechsel zu initiieren.
    - Um Redundanz oder Konflikte zu vermeiden:
        - `SeatHandler::focus_changed` sollte primär für das Senden der Wayland-Protokoll-Events zuständig sein, nachdem der Fokuswechsel _entschieden und technisch umgesetzt_ wurde.
        - Die Entscheidung, welches Fenster den Fokus erhält (z.B. durch Klick), und die Aktivierung dieses Fensters (über `set_application_focus`) sollten vor dem Aufruf von `focus_changed` erfolgen.
- **Finden der korrekten Oberfläche unter dem Zeiger/Touchpunkt (`find_surface_and_coords_at_global_point`):**
    - Diese Funktion ist entscheidend für das korrekte Routing von Zeiger- und Touch-Events.
    - Sie muss die Fenster im `smithay::desktop::Space` in umgekehrter Stapelreihenfolge (von oben nach unten) durchlaufen.
    - Für jedes Fenster muss geprüft werden, ob der globale Punkt innerhalb seiner Bounding Box liegt.
    - Anschließend muss der Punkt in die Koordinaten der Fensteroberfläche transformiert werden.
    - `smithay::desktop::Window::surface_under()` kann verwendet werden, um die spezifische `WlSurface` (inkl. Subsurfaces und Popups) unter dem lokalen Punkt zu finden.
    - **Eingaberegionen (`wl_surface.set_input_region`):** Die Eingaberegion einer Oberfläche definiert, welche Teile der Oberfläche auf Eingaben reagieren. `surface_under` muss dies berücksichtigen. Nur wenn der Punkt innerhalb der Eingaberegion liegt, gilt die Oberfläche als getroffen.
    - **Stapelreihenfolge:** Die Iteration durch die Fenster im `Space` muss die korrekte z-Ordnung beachten, um sicherzustellen, dass die oberste sichtbare Oberfläche an diesem Punkt ausgewählt wird. `smithay::desktop::Space::elements_under()` kann hierfür nützlich sein.

### 2.4. Gesten

Die Implementierung robuster Gestenerkennung (Pinch, Swipe) auf Basis von `libinput`-Events ist eine fortgeschrittene Aufgabe.

- **Ansätze:**
    - **Direkte Verarbeitung von `libinput`-Gestenereignissen:** `libinput` selbst erkennt bereits einige grundlegende Gesten (z.B. `GesturePinchEvent`, `GestureSwipeEvent`). Diese Events enthalten Informationen wie Skalierungsfaktor, Winkeländerung (Pinch) oder Verschiebungsvektoren (Swipe).
        - Der `LibinputInputBackend` leitet diese Events an den Compositor weiter.
        - Der Compositor muss diese Events interpretieren und in höherwertige Aktionen oder Wayland-Protokoll-Events (z.B. über `zwp_pointer_gestures_v1`) umwandeln.
    - **Eigene Gestenerkennung:** Für komplexere oder benutzerdefinierte Gesten, die `libinput` nicht direkt bereitstellt, müsste der Compositor eine eigene Gestenerkennungslogik implementieren. Dies würde das Sammeln und Analysieren von Folgen von Touch- oder Zeigerereignissen über die Zeit erfordern. Dies ist deutlich aufwendiger.
- **Übersetzung in Domänenaktionen:**
    - Erkannte Gesten (z.B. ein "Pinch-to-Zoom" auf einem Fenster) müssen in Aktionen der Domänenschicht übersetzt werden (z.B. "ZoomFenster", "WechsleWorkspace").
    - Dies erfordert eine klare Schnittstelle zwischen `system::input` und der Domänenschicht, möglicherweise über den `SystemEventBridge`.
- **Smithay-Unterstützung:** Smithay bietet Unterstützung für das `zwp_pointer_gestures_v1`-Protokoll, was die Weiterleitung von Pinch- und Swipe-Gesten an Clients ermöglicht. Der Compositor muss die `libinput`-Events in die entsprechenden Wayland-Events dieses Protokolls übersetzen.
- **Herausforderungen:**
    - **Eindeutigkeit:** Sicherstellen, dass Gesten nicht mit normalen Zeiger- oder Touch-Interaktionen kollidieren.
    - **Konfigurierbarkeit:** Benutzer erwarten oft, Gesten konfigurieren zu können.
    - **Performance:** Die Gestenerkennung darf die Eingabeverarbeitung nicht verlangsamen.

## 3. D-Bus Interaktion (system::dbus_interfaces mit zbus)

Die Kommunikation mit Systemdiensten über D-Bus ist ein integraler Bestandteil moderner Desktop-Umgebungen. `zbus` wird für die asynchrone D-Bus-Kommunikation mit Tokio verwendet.

### 3.1. Proxy-Management

Die Erstellung und Verwaltung von `zbus::Proxy`-Instanzen, insbesondere für dynamische Objektpfade, erfordert sorgfältige Überlegungen zum Lebenszyklus.

- **Best Practices:**
    - **Caching von Proxies:** Für häufig verwendete Proxies zu bekannten Objektpfaden (z.B. `/org/freedesktop/UPower`, `/org/freedesktop/NetworkManager`) ist es sinnvoll, die Proxy-Instanzen nach der ersten Erstellung zwischenzuspeichern (z.B. in einem `OnceLock` oder einem `Arc<Mutex<...>>` Feld im jeweiligen `DBusClientService`). Dies vermeidet den Overhead wiederholter Proxy-Erstellung.
        - Die `DBusConnectionManager` mit `OnceLock` für Session/System-Bus ist ein guter Ansatz für die zugrundeliegende `zbus::Connection`.
    - **Dynamische Objektpfade:** Für Proxies zu dynamischen Objektpfaden (z.B. `UPowerDeviceProxy` für `/org/freedesktop/UPower/devices/display_device`, `LogindSessionProxy` für `/org/freedesktop/login1/session/self`):
        - Diese Proxies sollten bei Bedarf erstellt werden, wenn der spezifische Objektpfad bekannt wird (z.B. durch ein Signal vom Manager-Objekt oder eine Abfrage).
        - Eine Möglichkeit ist, sie nicht langfristig zu cachen, wenn ihre Lebensdauer stark an das zugrundeliegende D-Bus-Objekt gebunden ist und dieses häufig wechseln kann.
        - Alternativ kann ein Cache (z.B. `HashMap<OwnedObjectPath, Arc<MyDeviceProxy>>`) verwendet werden, aber es muss eine Strategie zur Invalidierung geben, falls das D-Bus-Objekt verschwindet. Signale wie `InterfacesRemoved` vom `org.freedesktop.DBus.ObjectManager` können hier helfen, sind aber nicht immer verfügbar.
    - **Lebenszyklusmanagement:**
        - Proxies sind an die Lebensdauer der `zbus::Connection` gebunden. Wenn die Verbindung getrennt wird, werden die Proxies ungültig.
        - Für Dienste, die neu gestartet werden können, muss der Client-Service in der Lage sein, die Verbindung und die Proxies neu zu initialisieren. Das Abonnieren von `NameOwnerChanged`-Signalen auf dem D-Bus kann helfen, Neustarts von Diensten zu erkennen.
- **Beispiel (Caching eines Manager-Proxys):**
    
    Rust
    
    ```
    use zbus::Proxy;
    use tokio::sync::OnceCell;
    use std::sync::Arc;
    
    static UPOWER_PROXY: OnceCell<Arc<UPowerProxy<'static>>> = OnceCell::const_new();
    
    async fn get_upower_proxy(connection: &Arc<zbus::Connection>) -> Result<Arc<UPowerProxy<'static>>, zbus::Error> {
        UPOWER_PROXY.get_or_try_init(|| async {
            let proxy = UPowerProxy::new(connection).await?;
            Ok(Arc::new(proxy))
        }).await.cloned()
    }
    ```
    
    Für dynamische Proxies wäre ein `HashMap` im Service-Struct, geschützt durch einen `Mutex` oder `RwLock`, ein gängiger Ansatz.

### 3.2. Asynchrone Signalbehandlung

Die Verarbeitung von D-Bus-Signalen erfolgt in `tokio::tasks`, die `zbus::SignalStream`s konsumieren.

- **Robuste Implementierung:**
    - Jeder `SignalStream` sollte in einem eigenen `tokio::task` verarbeitet werden, um Blockierungen zu vermeiden.
    - Der Task muss den Stream kontinuierlich pollen (z.B. mit `while let Some(signal) = stream.next().await`).
    - **Fehler im Stream:** `stream.next().await` kann `None` zurückgeben, wenn der Stream beendet wird (z.B. Verbindung verloren, Dienst beendet). Der Task sollte dies erkennen und sich sauber beenden oder versuchen, den Stream neu zu initialisieren (z.B. durch erneutes Abonnieren der Signale nach Wiederherstellung der Verbindung). Fehler während des Stream-Pollings (z.B. `zbus::Error`) sollten geloggt und behandelt werden.
    - **Parsen von Signaldaten:** Die Argumente eines Signals kommen als `zbus::zvariant::Value` oder spezifischere Typen an. Diese müssen sorgfältig in die internen Event-Typen der Systemschicht gemappt werden. Fehler beim Parsen (z.B. unerwarteter Typ) sollten abgefangen und geloggt werden.
    - **Umwandlung in interne Events:** Nach erfolgreichem Parsen werden die Signaldaten in anwendungsspezifische Events (z.B. `UPowerEvent`, `NetworkManagerEvent`) umgewandelt und typischerweise über den `SystemEventBridge` publiziert.
- **Beispiel (konzeptionell):**
    
    Rust
    
    ```
    // In UPowerClientService::initialize()
    // let upower_proxy = self.get_proxy().await?;
    // let mut device_added_stream = upower_proxy.receive_device_added().await?;
    // let event_bridge = global_system_event_bridge();
    
    // tokio::spawn(async move {
    //     while let Some(signal) = device_added_stream.next().await {
    //         match signal.args() {
    //             Ok(args) => {
    //                 let device_path = args.device_path; // Annahme basierend auf Spezifikation
    //                 // Hole Details für device_path, erstelle UPowerEvent::DeviceAdded
    //                 // event_bridge.publish(SystemLayerEvent::UPower(upower_event)).await;
    //             },
    //             Err(e) => {
    //                 // log_error!("Failed to parse UPower DeviceAdded signal args: {:?}", e);
    //             }
    //         }
    //     }
    //     // log_info!("UPower DeviceAdded signal stream ended.");
    // });
    ```
    
- **Referenz:** Die `zbus` Dokumentation zu `SignalStream` und asynchroner Verarbeitung ist hier relevant.

### 3.3. `org.freedesktop.Notifications` Server

Die Implementierung eines D-Bus-Servers für `org.freedesktop.Notifications` 75 erfordert ein Mapping zwischen D-Bus `u32` IDs und den internen `Uuid`s der Domänenschicht sowie das korrekte Emittieren von Signalen.

- **ID-Mapping (`D-Bus u32 <-> Domain Uuid`):**
    - Wenn der Server eine Benachrichtigung über `Notify` empfängt, generiert er eine neue, eindeutige `u32` ID und gibt diese an den Client zurück.
    - Diese `u32` ID muss intern mit der `Uuid` der Domänen-Benachrichtigung (die vom `domain::NotificationService` kommt oder dorthin gesendet wird) assoziiert werden. Ein `HashMap<u32, Uuid>` und ggf. ein `HashMap<Uuid, u32>` (für schnelle Rückwärts-Lookups) im Zustand des `FreedesktopNotificationsServer` sind hierfür geeignet. Diese Maps müssen durch einen `Mutex` oder `RwLock` geschützt werden, da D-Bus-Methodenaufrufe und Domain-Event-Handler potenziell nebenläufig sind.
- **Verwendung von `zbus::SignalContext` zum Emittieren von Signalen:**
    - Wenn ein Domänen-Event (z.B. `DomainNotificationEvent::Closed`) eintritt, das ein D-Bus-Signal auslösen soll (z.B. `NotificationClosed`), muss der Listener dieses Domänen-Events den `FreedesktopNotificationsServer` darüber informieren.
    - Der Server-Task, der die D-Bus-Schnittstelle implementiert, ist derjenige, der Signale emittieren kann.
    - Um ein Signal aus einem anderen Task (dem Domain-Event-Listener) zu emittieren, muss der `SignalContext` des entsprechenden Interfaces verwendet werden.
    - Eine Möglichkeit ist, dass der Domain-Event-Listener eine Nachricht (z.B. über einen `tokio::sync::mpsc::channel`) an den D-Bus-Server-Task sendet. Dieser Task ruft dann die Signal-Emissionsmethode auf seinem Interface-Objekt auf.
    - **Beispiel (konzeptionell für `NotificationClosed`):**
        
        Rust
        
        ```
        // In FreedesktopNotificationsServer (zbus::Interface Implementierung)
        // #[dbus_interface(name = "org.freedesktop.Notifications")]
        // struct NotificationsServerLogic {
        //     //... id_map: Arc<Mutex<HashMap<u32, Uuid>>>,...
        //     // signal_context: Option<SignalContext<'static>> // Wird von zbus bereitgestellt
        // }
        
        // impl NotificationsServerLogic {
        //     #[dbus_interface(signal)]
        //     async fn notification_closed(&self, ctxt: &SignalContext<'_>, id: u32, reason: u32) -> zbus::Result<()>;
        
        //     // Diese Methode wird vom Domain-Event-Listener aufgerufen (z.B. via MPSC-Kanal)
        //     async fn handle_domain_notification_closed(&self, dbus_id: u32, reason: u32) {
        //         if let Some(ctxt) = self.signal_context() { // Korrekten Weg zum SignalContext finden
        //             if let Err(e) = self.notification_closed(ctxt, dbus_id, reason).await {
        //                 // log_error!("Failed to emit NotificationClosed signal: {:?}", e);
        //             }
        //         }
        //     }
        // }
        ```
        
        Die `SwayNotificationCenter` 77 und `mako` 78 sind Beispiele für Notification Daemons, deren D-Bus Implementierung (falls in Rust/zbus oder C/GDBus) als Inspiration dienen kann. Die Freedesktop Notification Specification 75 ist die maßgebliche Quelle.

### 3.4. Fehlerbehandlung

- **Umgang mit `zbus::Error` und `zbus::fdo::Error`:**
    - `zbus::Error` ist der allgemeine Fehlertyp von `zbus`, der I/O-Fehler, Serialisierungsfehler, Verbindungsfehler etc. umfassen kann.79
    - `zbus::fdo::Error` ist ein spezifischer D-Bus-Fehlertyp, der von Methodenaufrufen zurückgegeben werden kann (z.B. `org.freedesktop.DBus.Error.ServiceUnknown`).
    - Diese Fehler müssen in den jeweiligen Client-Services (z.B. `UPowerClientService`) abgefangen werden.
- **Mapping in eigenes `DBusInterfaceError`-Schema unter Beibehaltung des Fehlerkontexts:**
    - Das `DBusInterfaceError`-Enum sollte Varianten für spezifische Fehlerfälle (z.B. `ServiceUnavailable`, `MethodCallFailed`, `SignalStreamError`, `InvalidResponse`) und eine generische Variante für unerwartete `zbus`-Fehler haben.
    - Die `thiserror`-Crate ist hierfür ideal.
    - Die ursprüngliche `zbus::Error` oder `zbus::fdo::Error` sollte als `source` im `DBusInterfaceError` gespeichert werden, um den Kontext nicht zu verlieren.
    - **Beispiel (konzeptionell):**
        
        Rust
        
        ```
        #
        pub enum DBusInterfaceError {
            #
            ServiceUnavailable { service: String, #[source] source: zbus::Error },
        
            #[error("Method call {method:?} on {interface:?} failed")]
            MethodCallFailed {
                interface: String,
                method: String,
                #[source]
                source: zbus::fdo::Error,
            },
        
            #
            MessageSendError(#[from] zbus::Error),
        
            #
            ResponseParseError{ method: String, #[source] source: zbus::zvariant::Error },
            //... weitere Varianten
        }
        
        // In einem Client-Service:
        // match some_proxy.some_method().await {
        //     Ok(reply) => Ok(reply),
        //     Err(zbus::Error::FDO(fdo_error)) => Err(DBusInterfaceError::MethodCallFailed {
        //         interface: P::INTERFACE.to_string(), // P ist der Proxy-Typ
        //         method: "some_method".to_string(),
        //         source: *fdo_error,
        //     }),
        //     Err(e) => Err(DBusInterfaceError::MessageSendError(e)),
        // }
        ```
        
        Die Granularität der Fehlertypen ist ein wichtiger Aspekt. Eine zu feine Aufteilung von `DBusInterfaceError` kann unhandlich werden. Eine gute Balance zwischen spezifischen, für die Domänenschicht relevanten Fehlern und generischen Catch-All-Varianten ist anzustreben. Die Domänenschicht interessiert sich beispielsweise eher dafür, _ob_ ein Dienst nicht verfügbar ist, um ein Feature zu deaktivieren, als für die genaue Art eines I/O-Fehlers auf dem D-Bus-Socket. Das `DBusInterfaceError` sollte diese Abstraktionsebene widerspiegeln. Bei bestimmten Fehlern, wie `ServiceUnavailable` oder temporären Netzwerkproblemen, könnte eine Retry-Logik in den Client-Services implementiert werden, bevor der Fehler an die Domänenschicht weitergegeben wird. Dies erhöht die Robustheit der Systemschicht gegenüber transienten Fehlern.

Tabelle für Sektion 3.1: Proxy-Management-Strategien

Eine durchdachte Strategie für das Management von D-Bus-Proxies ist entscheidend für Performance und Stabilität. Die naive Erstellung eines Proxys bei jedem Methodenaufruf ist ineffizient. Andererseits können langlebige Proxies veralten, wenn der zugrundeliegende Dienst neu startet oder Objekte verschwinden.

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|**Strategie**|**Beschreibung**|**Vorteile**|**Nachteile**|**zbus-Mechanismen**|**Eignung für NovaDE-Dienste (Beispiele)**|
|**On-Demand Creation**|Proxy wird bei jedem benötigten Aufruf neu erstellt.|Immer aktuell; einfach zu implementieren.|Hoher Overhead bei häufigen Aufrufen.|`Proxy::new(conn).await`|Selten genutzte Dienste oder einmalige Aufrufe.|
|**Cached Static Proxies**|Proxies für bekannte, statische Objektpfade werden einmal erstellt und wiederverwendet.|Geringer Overhead nach Initialisierung.|Proxy kann veralten, wenn Dienst neu startet (Neuerstellung erforderlich).|`OnceCell`, `Arc<Proxy>`|Manager-Proxies: `UPowerProxy`, `LogindManagerProxy`, `NetworkManagerProxy`, `SecretServiceProxy`, `PolicyKitAuthorityProxy`.|
|**Cached Dynamic Proxies**|Proxies für dynamische Objektpfade werden bei Bedarf erstellt und in einem Cache (z.B. `HashMap`) gehalten.|Reduzierter Overhead für häufig zugegriffene dynamische Objekte.|Cache-Invalidierung komplex; Proxy kann veralten.|`Arc<Mutex<HashMap<ObjectPath, Arc<Proxy>>>>`|`UPowerDeviceProxy`, `LogindSessionProxy`, `NMDeviceProxy`, `SecretCollectionProxy`, `SecretItemProxy`. Erfordert Überwachung von Signalen (z.B. `InterfacesRemoved`).|
|**Proxies via Manager Signals**|Proxies für dynamische Objekte werden nur erstellt, wenn ihre Existenz durch Signale des Managers bekannt wird.|Erstellt Proxies nur für tatsächlich existierende Objekte.|Abhängig von der Zuverlässigkeit und Semantik der Manager-Signale.|Signal-Handler, die Proxies erstellen/entfernen.|Wie "Cached Dynamic Proxies", aber die Erstellung/Entfernung wird durch Signale wie `DeviceAdded`/`DeviceRemoved` (UPower) oder `SessionNew`/`SessionRemoved` (Logind) gesteuert.|
|**Server-seitige Objekt-Ref.**|(Für den Notifications-Server) Referenzen auf exportierte Objekte werden von zbus verwaltet.|Lebenszyklus wird von zbus gehandhabt.|Weniger direkte Kontrolle.|`#[dbus_interface]`, `ObjectServer`|`FreedesktopNotificationsServer`.|

## 4. PipeWire Integration (system::audio_management mit `pipewire-rs`)

Die Integration von PipeWire 80 für Audio-Management in NovaDE erfolgt über die `pipewire-rs`-Bibliothek. Dies erfordert die Verwaltung des PipeWire-MainLoops und die Kommunikation zwischen dem asynchronen Service und dem PipeWire-Thread.

### 4.1. `MainLoop` Management

PipeWire benötigt einen laufenden MainLoop. Die `pipewire-rs`-Bibliothek abstrahiert dies.

- **Strategien zur Integration der `pipewire::MainLoop` in eine tokio-basierte Anwendung:**
    
    - **Option 1: Dedizierter Thread für PipeWire `MainLoop`:** Dies ist der gängigste und oft robusteste Ansatz. Ein separater Systemthread wird gestartet, der ausschließlich `pipewire::MainLoop::run()` ausführt.
        - _Vorteile:_ Klare Trennung der Audioverarbeitung vom Rest der Anwendung, blockiert nicht die Tokio-Runtime.
        - _Nachteile:_ Erfordert Inter-Thread-Kommunikation (IPC) für Befehle und Zustandsaktualisierungen.
    - **Option 2: Integration des PipeWire-FDs in eine tokio-kompatible Event-Loop:** Theoretisch könnte, falls `pipewire-rs` einen Dateideskriptor des PipeWire-Mainloops exponiert, dieser in den Tokio-Eventloop integriert werden (ähnlich wie `calloop` FDs integriert). Dies ist jedoch mit `pipewire-rs` **unwahrscheinlich**, da es oft auf GLib im Hintergrund setzt oder einen eigenen Loop managed. Die Dokumentation von `pipewire-rs` ist hier entscheidend.
        - _Vorteile (hypothetisch):_ Potenziell geringerer Threading-Overhead.
        - _Nachteile (hypothetisch):_ Deutlich komplexere Implementierung, falls nicht direkt von `pipewire-rs` unterstützt.
    - **Empfehlung für NovaDE:** Ein dedizierter Thread für den PipeWire `MainLoop` wird empfohlen, da dies ein etabliertes Muster ist und die Komplexität der direkten FD-Integration vermeidet, es sei denn, `pipewire-rs` bietet explizite Unterstützung für eine Tokio-Integration.
- **Sichere Kommunikation zwischen async-Service-Methoden und dem PipeWire-Thread:**
    
    - **Befehle (Tokio-Service -> PipeWire-Thread):** Ein `tokio::sync::mpsc::channel` ist hierfür ideal. Der `PipeWireClientService` (laufend im Tokio-Kontext) sendet Befehle (z.B. `SetVolumeCommand { device_id: String, volume: f32 }`) an den PipeWire-Thread. Der PipeWire-Thread besitzt den `Receiver`-Teil des Kanals und verarbeitet die eintreffenden Befehle synchron innerhalb seines `MainLoop`-Kontexts.
    - **Zustandsupdates und Events (PipeWire-Thread -> Tokio-Service):**
        - Für lesbare Zustände (z.B. aktuelle Geräteliste, Lautstärken): Ein `Arc<RwLock<AudioSystemState>>` kann verwendet werden. Der PipeWire-Thread hat Schreibzugriff und aktualisiert diesen Zustand, wenn sich etwas ändert (z.B. nach einem Befehl oder durch externe PipeWire-Events). Der Tokio-Service hat Lesezugriff.
        - Für Event-Benachrichtigungen (z.B. `DeviceListChanged`, `DefaultDeviceChanged`): Ein `tokio::sync::watch::channel` (für einzelne Werte, die sich ändern) oder ein `tokio::sync::broadcast::channel` (für Ereignisse, die von mehreren Stellen konsumiert werden könnten) kann vom PipeWire-Thread verwendet werden, um Updates an den Tokio-Service zu senden. Der `PipeWireClientService` abonniert diese Kanäle.
        - Alternativ kann der PipeWire-Thread Callbacks verwenden (siehe Abschnitt 4.2), die dann ihrerseits Nachrichten über einen weiteren `mpsc`-Kanal zurück an den Tokio-Thread senden. Dieser kann dann die `AudioEvent`s über den `SystemEventBridge` publizieren.
- **Code-Beispiel (konzeptionell für dedizierten Thread und MPSC):**
    
    Rust
    
    ```
    use pipewire::Loop; // Beispiel, tatsächliche Typen können variieren
    use std::sync::{Arc, RwLock};
    use tokio::sync::mpsc;
    
    enum PipeWireCommand {
        SetVolume(String, f32),
        // Weitere Befehle
    }
    
    struct InternalAudioState {
        //... z.B. Vec<AudioDevice>
    }
    
    pub struct PipeWireClientService {
        command_tx: mpsc::Sender<PipeWireCommand>,
        audio_state: Arc<RwLock<InternalAudioState>>,
        //... event_rx: broadcast::Receiver<AudioEvent>...
    }
    
    impl PipeWireClientService {
        pub fn new(/*... */) -> Self {
            let (command_tx, mut command_rx) = mpsc::channel(32);
            let audio_state = Arc::new(RwLock::new(InternalAudioState { /*... */ }));
            let audio_state_clone = audio_state.clone();
            // Hier fehlt der Event-Sender vom PipeWire-Thread zum SystemEventBridge
    
            std::thread::spawn(move |
    ```
    

| {

// Diese Initialisierung ist stark vereinfacht und dient nur dem Konzept

let main_loop = pipewire::MainLoop::new(None)

.expect("Failed to create PipeWire MainLoop");

let context = pipewire::Context::new(&main_loop)

.expect("Failed to create PipeWire Context");

let core = context.connect(None)

.expect("Failed to connect to PipeWire Core");

let registry = core.get_registry()

.expect("Failed to get PipeWire Registry");

````
            // Hier würden Listener für Core- und Registry-Events registriert (siehe 4.2)
            // Diese Listener würden audio_state_clone aktualisieren und/oder Events senden

            loop {
                // Verarbeite Befehle vom Tokio-Service
                // main_loop.iterate(false) blockiert nicht lange, erlaubt command_rx.try_recv()
                // oder man nutzt einen blocking_recv mit Timeout in einer Schleife,
                // die auch main_loop.iterate() aufruft.
                match command_rx.blocking_recv() { // In einem echten Szenario ggf. non-blocking oder mit Timeout
                    Some(command) => {
                        // PipeWire-Aktionen basierend auf dem Befehl ausführen
                        // z.B. core.set_volume(...)
                        // audio_state_clone.write().unwrap()... aktualisieren
                    }
                    None => break, // Kanal wurde geschlossen
                }

                // PipeWire-Events verarbeiten (non-blocking)
                if main_loop.iterate(false) < 0 {
                    // Fehler in der PipeWire-Schleife
                    break;
                }
            }
        });

        Self { command_tx, audio_state /*,... */ }
    }

    // Async Methoden, die command_tx verwenden
    pub async fn set_device_volume(&self, device_id: String, volume: f32) -> Result<(), AudioManagementError> {
        self.command_tx.send(PipeWireCommand::SetVolume(device_id, volume)).await
           .map_err(|_| AudioManagementError::InternalThreadCommunicationError)?;
        Ok(())
    }
}
```
Die Thread-Sicherheit der von `pipewire-rs` bereitgestellten Objekte ist fundamental. Objekte wie `pipewire::Core` oder `pipewire::Registry` sind oft nicht `Send` oder `Sync`. Das bedeutet, sie dürfen nicht direkt über `Arc<Mutex<T>>` zwischen Threads geteilt und von verschiedenen Threads modifiziert werden. Alle Operationen, die diese Objekte verändern, müssen im Kontext des PipeWire-MainLoops (also im dedizierten PipeWire-Thread) ausgeführt werden. Befehle vom Tokio-Service müssen daher über einen Kanal an diesen Thread gesendet werden.
````

### 4.2. Callback-Management

PipeWire verwendet ein Callback-basiertes System für Events (z.B. über `RegistryListener`, `CoreListener`, `NodeListener`, `StreamListener`).

- **Verwaltung von Listener-Strukturen, die `'static` sein müssen:**
    
    - Wenn `add_listener_local` verwendet wird, erwartet `pipewire-rs` oft, dass der Listener eine `'static` Lebensdauer hat, da der Listener potenziell länger existiert als der Scope, in dem er erstellt wurde.
    - **Problem mit `self`-Referenzen:** Wenn der Listener Methoden des `PipeWireClientService` oder dessen internen Zustands aufrufen muss, wird es schwierig, da `self` nicht einfach in einen `'static` Closure verschoben werden kann, wenn der Listener selbst Teil von `self` ist oder `self` eine kürzere Lebensdauer hat.
    - **Lösungen:**
        1. **`Arc` und schwache Referenzen (`Weak`):** Der Zustand, auf den der Listener zugreifen muss (z.B. der `mpsc::Sender` für Events zurück an Tokio oder der `Arc<RwLock<InternalAudioState>>`), kann in einen `Arc` gepackt werden. Der Listener-Closure erhält einen Klon dieses `Arc`. Wenn der Listener den `PipeWireClientService` selbst referenzieren muss (z.B. um Methoden aufzurufen), kann ein `Weak<PipeWireClientService>` verwendet werden, das vor der Verwendung zu einem `Arc` aufgewertet wird, um Zyklen zu vermeiden.
        2. **Kanalbasierte Kommunikation:** Der Listener-Callback sendet die empfangenen Daten/Events über einen `mpsc::Sender` (der in den Callback geklont wurde) an einen zentralen Verarbeitungspunkt im PipeWire-Thread oder direkt zurück an den Tokio-Thread.
        3. **Globale oder statische Handler (mit Vorsicht):** In seltenen Fällen könnten globale Handler verwendet werden, aber dies erschwert das Zustandsmanagement erheblich und ist meist nicht empfehlenswert.
- **Beenden von Listenern:**
    
    - Die von `add_listener_local` zurückgegebenen `Listener` structs implementieren `Drop`. Wenn der `Listener` aus dem Scope geht, wird der Listener automatisch von PipeWire entfernt.
    - Es ist wichtig, diese `Listener`-Objekte so lange im Speicher zu halten, wie die Callbacks aktiv sein sollen (z.B. als Felder im PipeWire-Thread-Zustand). Wenn sie vorzeitig gedroppt werden, werden keine Callbacks mehr empfangen.
- **Beispiel (konzeptionell für Registry-Listener):**
    
    Rust
    
    ```
    // Im PipeWire-Thread
    // let registry_listener = registry.add_listener_local()
    //    .global({
    //         let audio_state_clone = audio_state.clone(); // Arc<RwLock<InternalAudioState>>
    //         // let event_tx_clone = event_tx.clone(); // mpsc::Sender<AudioEvent>
    //         move |global_obj| {
    //             if let Some(props) = &global_obj.props {
    //                 if props.get(pipewire::keys::OBJECT_TYPE) == Some("PipeWire:Interface:Device") {
    //                     // Neues Audiogerät gefunden
    //                     // audio_state_clone.write().unwrap().add_device(...);
    //                     // event_tx_clone.send(AudioEvent::DeviceAdded(...)).unwrap();
    //                 }
    //             }
    //         }
    //     })
    //     //... weitere Callbacks...
    //    .register();
    // // registry_listener muss am Leben gehalten werden.
    ```
    

### 4.3. SPA Pod Erstellung und Anwendung

SPA (Simple Plugin API) Pods werden verwendet, um Parameter für PipeWire-Objekte (Nodes, Streams) zu setzen, z.B. für Lautstärkeregelung.

- **Detaillierte Beispiele für die Erstellung von `SpaPod`s:**
    - `pipewire-rs` bietet Builder-APIs oder direkte Konstruktionsmethoden für Pods.
    - **Lautstärkeregelung (`Props` mit `channelVolumes`, `mute`):**
        - Ein `Props`-Pod (oft ein `Object`-Pod mit `ParamProps`-Typ) wird erstellt.
        - Dieser enthält Eigenschaften wie `channelVolumes` (ein Array von Floats, z.B. `[0.5, 0.5]` für Stereo bei 50%) und `mute` (ein Boolean).
        - Die genauen Namen der Eigenschaften (`SpaId`) und deren Typen müssen der PipeWire-Spezifikation für Audio-Nodes entsprechen (z.B. `SpaId::from_str("channelVolumes")`).
    - **Routenparameter auf Devices:** Ähnlich können Pods für Routing-Parameter erstellt werden, um z.B. ein Default-Profil für ein Gerät zu setzen.
- **Korrekte Verwendung mit `node.set_param()`:**
    - Die `set_param`-Methode eines `Node`-Objekts (oder `Stream`-Objekts) erwartet die ID des Parameters, der gesetzt werden soll (z.B. `SpaId::EnumParamPortConfig` für Port-Konfiguration, `SpaId::EnumParamProps` für allgemeine Eigenschaften) und den `SpaPod` mit den neuen Werten.
    - **Beispiel (konzeptionell):**
        
        Rust
        
        ```
        // Annahme: node ist ein pipewire::Node
        // use pipewire::spa::pod::{Pod, PodObject, PodBuilder, Value};
        // use pipewire::spa::param::ParamType;
        // use pipewire::spa::utils::SpaTypes; // Für SpaId-Konstanten
        
        // // Lautstärke setzen (vereinfacht)
        // let mut props_builder = PodBuilder::new_object(
        //     SpaTypes::Props, // Builder-Typ
        //     ParamType::Props.as_raw() // Pod-Typ-ID
        // );
        // props_builder.add(
        //     SpaTypes::PropChannelVolumes, // Key-ID
        //     &Value::Array(vec![Value::Float(0.7), Value::Float(0.7)]) // Wert
        // ).unwrap();
        // props_builder.add(
        //     SpaTypes::PropMute,
        //     &Value::Bool(false)
        // ).unwrap();
        // let props_pod = props_builder.end();
        
        // node.set_param(ParamType::Props.as_raw(), 0, &props_pod).unwrap();
        ```
        
        Die genaue API für die Pod-Erstellung in `pipewire-rs` muss der Dokumentation entnommen werden. Die Verwendung von `spa_sys` oder höheren Abstraktionen in `pipewire-rs` ist möglich.

### 4.4. Metadaten-Interface

Das Metadaten-Interface in PipeWire wird verwendet, um systemweite Einstellungen wie Standard-Audio-Geräte zu verwalten.

- **Interaktion mit dem `Metadata`-Objekt:**
    - PipeWire exponiert ein globales `Metadata`-Objekt (oft mit der ID `PIPEWIRE_METADATA_OBJECT_ID_SETTINGS` oder über die Registry auffindbar).
    - Dieses Objekt hat Eigenschaften (Properties), die über `metadata.set_property()` und `metadata.property()` (oder äquivalente Methoden in `pipewire-rs`) gelesen und geschrieben werden können.
- **Setzen und Lesen von Standard-Audio-Geräten (`default.audio.sink/source`):**
    - Die Namen der Properties für Standardgeräte sind typischerweise `"default.audio.sink"` und `"default.audio.source"`.
    - Der Wert dieser Properties ist die ID (oft eine `u32`) des entsprechenden PipeWire-Node-Objekts, das als Standard-Sink oder -Source dienen soll.
    - Um das Standardgerät zu ändern, wird `metadata.set_property("default.audio.sink", "neue_node_id_als_string")` aufgerufen.
    - Um das aktuelle Standardgerät zu lesen, wird `metadata.property("default.audio.sink")` verwendet.
- **Events:** Änderungen an Metadaten (einschließlich Standardgeräten) lösen Events auf dem `Metadata`-Objekt oder der `Registry` aus, die der `PipeWireClientService` abonnieren muss, um `DefaultDeviceChanged`-Events zu generieren.

## 5. MCP Client (system::mcp_client mit `mcp_client_rs`)

Der Model Context Protocol (MCP) Client ermöglicht die Anbindung an KI-Dienste. NovaDE startet lokale MCP-Server-Prozesse und verwaltet die Kommunikation.

### 5.1. Prozessmanagement

Das Starten und Überwachen lokaler MCP-Server-Prozesse erfolgt mit `tokio::process::Command`.

- **Robuste Methoden:**
    
    - **Starten:** `tokio::process::Command::new("path/to/mcp_server_executable")` wird verwendet, um den Prozess zu konfigurieren (Argumente, Umgebungsvariablen). `Command::spawn()` startet den Prozess asynchron.
    - **Überwachen:**
        - Das von `spawn()` zurückgegebene `Child`-Objekt bietet eine `wait()`-Methode (als Future), um auf das Beenden des Prozesses zu warten und den Exit-Status zu erhalten.
        - Regelmäßige Health-Checks (falls vom MCP-Server unterstützt) oder das Überwachen der Stdio-Pipes können ebenfalls zur Überwachung dienen.
        - Bei unerwartetem Beenden des Prozesses sollte ein Fehler geloggt und ggf. ein Neustartversuch unternommen werden (mit Backoff-Strategie).
- **Handhabung von Stdio (`stdin`/`stdout`):**
    
    - `mcp_client_rs::McpClient` kommuniziert typischerweise über `stdin` und `stdout` mit dem Serverprozess.
    - `Command::stdin(Stdio::piped())` und `Command::stdout(Stdio::piped())` müssen gesetzt werden.
    - Die von `child.stdin.take().unwrap()` und `child.stdout.take().unwrap()` zurückgegebenen `ChildStdin` und `ChildStdout` (die `AsyncWrite` bzw. `AsyncRead` implementieren) werden dann an den `McpClient` übergeben (z.B. beim Konstruktor des Clients).
- **Beispiel (konzeptionell):**
    
    Rust
    
    ```
    use tokio::process::Command;
    use std::process::Stdio;
    
    // async fn start_local_mcp_server(config: &McpServerConfig::LocalExecutable) -> Result<mcp_client_rs::McpClient, McpSystemClientError> {
    //     let mut command = Command::new(&config.executable_path);
    //     command.args(&config.args);
    //     command.stdin(Stdio::piped());
    //     command.stdout(Stdio::piped());
    //     // command.stderr(Stdio::piped()); // Für Fehler-Logging
    
    //     let mut child = command.spawn().map_err(McpSystemClientError::ProcessSpawnFailed)?;
    
    //     let stdin = child.stdin.take().ok_or(McpSystemClientError::StdioUnavailable("stdin".into()))?;
    //     let stdout = child.stdout.take().ok_or(McpSystemClientError::StdioUnavailable("stdout".into()))?;
    
    //     let mcp_client = mcp_client_rs::McpClient::new(stdout, stdin); // Annahme einer solchen API
    
    //     // Optional: Task zur Überwachung des Kindprozesses
    //     tokio::spawn(async move {
    //         match child.wait().await {
    //             Ok(status) => { /* log_info!("MCP server exited with status: {}", status); */ },
    //             Err(e) => { /* log_error!("Failed to wait for MCP server: {}", e); */ }
    //         }
    //         // Hier ggf. ServerConnectionStateChanged-Event senden
    //     });
    
    //     Ok(mcp_client)
    // }
    ```
    

### 5.2. Notification Handling

Asynchrone `McpMessage::Notification`-Nachrichten vom Server müssen in einem Hintergrund-Task überwacht werden.

- **Effiziente Überwachung:**
    - Der `mcp_client_rs::McpClient` sollte eine Methode wie `receive_message()` oder `notifications_stream()` bereitstellen, die einen Stream von `McpMessage`s zurückgibt.
    - Dieser Stream wird in einem dedizierten `tokio::task` konsumiert.
    - `while let Some(message) = stream.next().await` wird verwendet, um Nachrichten zu empfangen.
    - Wenn `message` eine `McpMessage::Notification` ist, wird sie in ein `McpClientSystemEvent::NotificationReceived` umgewandelt und über den `SystemEventBridge` publiziert.
- **Beispiel (konzeptionell):**
    
    Rust
    
    ```
    // In McpConnection::new() oder einer ähnlichen Methode
    // let client_clone = self.mcp_client.clone(); // Annahme, McpClient ist Arc-wrapped oder hat eine clone-bare Listener-API
    // let event_bridge = global_system_event_bridge();
    // tokio::spawn(async move {
    //     // Annahme: client_clone.message_stream() liefert einen Stream<Result<McpMessage, _>>
    //     let mut stream = client_clone.message_stream();
    //     while let Some(result) = stream.next().await {
    //         match result {
    //             Ok(McpMessage::Notification(notification)) => {
    //                 event_bridge.publish(SystemLayerEvent::McpClient(
    //                     McpClientSystemEvent::NotificationReceived {
    //                         server_id: self.server_config.id, // Annahme: Server-ID ist verfügbar
    //                         notification,
    //                     }
    //                 )).await;
    //             }
    //             Ok(_) => { /* Andere Nachrichtentypen ignorieren oder behandeln */ }
    //             Err(e) => {
    //                 // log_error!("Error receiving MCP message: {:?}", e);
    //                 // event_bridge.publish(SystemLayerEvent::McpClient(
    //                 //     McpClientSystemEvent::CommunicationError { server_id: self.server_config.id, error: e.into() }
    //                 // )).await;
    //                 break; // Stream beenden bei Fehler
    //             }
    //         }
    //     }
    // });
    ```
    

### 5.3. Request Timeouts

Die Implementierung von Timeouts für `client.send_request_json()` ist wichtig, um auf nicht antwortende Server zu reagieren.

- **`tokio::time::timeout`:** Die `tokio::time::timeout(duration, future)`-Funktion ist hierfür ideal.
    - Sie wrappt den `Future` des `send_request_json()`-Aufrufs.
    - Wenn der `Future` innerhalb der `duration` nicht auflöst, gibt `timeout` ein `Err(Elapsed)` zurück.
    - Anderenfalls gibt es das `Result` des inneren `Future`s zurück.
- **Beispiel:**
    
    Rust
    
    ```
    use tokio::time::{timeout, Duration};
    
    // async fn send_request_with_timeout(
    //     client: &mcp_client_rs::McpClient,
    //     request: McpRequest, // Annahme: MCP-Request-Typ
    //     timeout_duration: Duration,
    // ) -> Result<McpResponse, McpSystemClientError> { // Annahme: MCP-Response-Typ
    //     match timeout(timeout_duration, client.send_request_json(&request)).await {
    //         Ok(Ok(response)) => Ok(response),
    //         Ok(Err(mcp_err)) => Err(McpSystemClientError::RequestFailed(mcp_err)), // Fehler vom McpClient
    //         Err(_elapsed) => Err(McpSystemClientError::Timeout), // Timeout-Fehler
    //     }
    // }
    ```
    
    Dieses Ergebnis wird dann ggf. als `McpClientSystemEvent::RequestFailed` publiziert.

### 5.4. API-Key Management

API-Keys für `RemoteHttp`-Verbindungen werden über den `SecretsServiceClientService` abgerufen und müssen sicher an den `McpClient` übergeben werden.

- **Sichere Übergabe:**
    - Der `McpConnectionManager` oder `DefaultSystemMcpService` fordert den API-Key vom `SecretsServiceClientService` an, wenn eine `RemoteHttp`-Verbindung konfiguriert wird.
    - Der abgerufene Key (typischerweise ein `String` oder `Vec<u8>`) wird dann an den `mcp_client_rs::McpClient` übergeben, wenn dieser für die Remote-Verbindung initialisiert wird.
    - `mcp_client_rs` sollte eine Methode oder Konfigurationsoption bieten, um den API-Key für HTTP-Header (z.B. `Authorization: Bearer <key>`) zu setzen.
    - Der API-Key sollte **niemals** hartcodiert oder unverschlüsselt in Konfigurationsdateien gespeichert werden. Die Verwendung des Secret Service ist hier die korrekte Vorgehensweise.
    - Es ist wichtig sicherzustellen, dass der API-Key nur im Speicher gehalten wird, solange er benötigt wird, und nicht unnötig geloggt oder anderweitig exponiert wird.

## 6. Schichtübergreifende Synchronisation und Fehlerbehandlung

Die Koordination zwischen verschiedenen Event-Loops und eine konsistente Fehlerbehandlung sind für die Stabilität des Gesamtsystems unerlässlich.

### 6.1. Event-Loops (calloop vs. tokio vs. GLib)

NovaDE verwendet `calloop` für Wayland/Compositor-Events und `tokio` für D-Bus, MCP und interne Timer. Eine potenzielle GLib-Main-Loop könnte von der UI-Schicht (nicht Teil der Systemschicht-Spezifikation, aber relevant für die Integration) verwendet werden.

- **Best Practices für Kommunikation und Datenübergabe:**
    - **`calloop` (Compositor-Thread) <-> `tokio` (Service-Threads):**
        - **Von `tokio` zu `calloop`:**
            - Wenn ein Tokio-Task (z.B. D-Bus-Signal-Handler) eine Aktion im Compositor auslösen muss (z.B. Fenster neu zeichnen lassen), kann dies über einen `calloop::channel` geschehen. Der Tokio-Task sendet eine Nachricht, der `calloop`-Eventloop empfängt sie und führt eine entsprechende Aktion im Compositor-Zustand aus.
            - Alternativ kann ein `Arc<Mutex<T>>` für geteilten Zustand verwendet werden, wobei der Tokio-Task den Zustand modifiziert und der Compositor-Thread ihn periodisch prüft oder durch ein Signal (z.B. `calloop::ping`) aufgeweckt wird.
        - **Von `calloop` zu `tokio`:**
            - Wenn eine Aktion im Compositor (z.B. Benutzerinteraktion) einen Tokio-basierten Service aufrufen muss, kann der Compositor-Code einen `tokio::task` spawnen (wenn der `DesktopState` Zugriff auf eine Tokio-Runtime hat) oder eine Nachricht über einen `std::sync::mpsc` (oder `crossbeam_channel`) an einen lauschenden Tokio-Task senden.
            - Der `SystemEventBridge` (basierend auf `tokio::sync::broadcast`) ist der primäre Mechanismus für Events vom Compositor (oder anderen Systemmodulen) zu Tokio-basierten Listenern.
    - **`tokio` (Systemschicht) <-> GLib (UI-Schicht, falls GTK4):**
        - GTK4 ist nicht threadsicher. Alle UI-Operationen müssen im GLib-Main-Thread ausgeführt werden.82
        - **Von `tokio` zu GLib/GTK4:**
            - `glib::MainContext::spawn_local()` oder `glib::idle_add_local()` sind die Standardmechanismen, um Code aus einem Tokio-Thread im GLib-Main-Thread auszuführen.
            - Ein Tokio-Task kann ein Ergebnis berechnen und dann `glib::MainContext::default().spawn_local(...)` verwenden, um einen Closure auszuführen, der die UI aktualisiert.
            - Die `SystemEventBridge`-Events (`tokio::sync::broadcast::Receiver`) müssen im GLib-Main-Thread konsumiert werden. Ein `glib::MainContext::spawn_local` kann einen `async` Block starten, der auf dem `broadcast::Receiver` lauscht und bei neuen Events UI-Updates durchführt.88
                
                Rust
                
                ```
                // In der UI-Schicht (GTK4)
                // let system_event_rx = global_system_event_bridge().subscribe();
                // glib::MainContext::default().spawn_local(async move {
                //     loop {
                //         match system_event_rx.recv().await {
                //             Ok(system_event) => {
                //                 // UI basierend auf system_event aktualisieren
                //             }
                //             Err(broadcast::error::RecvError::Lagged(_)) => { /*... */ }
                //             Err(broadcast::error::RecvError::Closed) => break,
                //         }
                //     }
                // });
                ```
                
        - **Von GLib/GTK4 zu `tokio`:**
            - Ein GTK-Signal-Handler (der im GLib-Main-Thread läuft) kann einen `tokio::task` auf einer globalen Tokio-Runtime spawnen, um eine langlaufende Operation auszuführen.
            - Das Ergebnis kann dann wieder über `glib::MainContext::spawn_local()` an die UI zurückgespielt werden.
- **Wichtige Überlegungen:**
    - **Blockierung vermeiden:** Kein Thread sollte den Event-Loop eines anderen Threads blockieren. Insbesondere dürfen `calloop`-Callbacks und GLib-Main-Loop-Handler keine langwierigen synchronen Operationen ausführen.
    - **Daten-Ownership und Thread-Safety:** `Send` und `Sync` müssen beachtet werden, wenn Daten zwischen Threads übergeben werden. `Arc<Mutex/RwLock<T>>` für geteilten Zustand oder Kanäle für Nachrichten sind üblich.

### 6.2. Fehler-Wrapping

Eine konsistente Strategie zum Wrappen von Fehlern aus unteren Schichten in die spezifischen Fehler-Enums der Systemschicht-Module ist entscheidend für Robustheit und Debugging.

- **Konsistente Strategien:**
    - **`thiserror` verwenden:** Jedes Modul der Systemschicht (`system::compositor`, `system::input`, etc.) sollte sein eigenes Fehler-Enum definieren (z.B. `CompositorCoreError`, `InputError`), das mit `#[derive(thiserror::Error)]` versehen ist.
    - **`#[from]`-Annotation:** Für Fehler, die direkt von einer Abhängigkeits-Crate stammen und 1:1 übernommen werden können oder eine klare Entsprechung haben, kann `#[from]` verwendet werden.
        
        Rust
        
        ```
        // #
        // pub enum McpSystemClientError {
        //     #[error("MCP client internal error: {0}")]
        //     ClientError(#[from] mcp_client_rs::Error),
        //     //...
        // }
        ```
        
    - **`#[source]`-Annotation:** Wenn ein Fehler aus einer unteren Schicht gewrappt und mit zusätzlichem Kontext versehen wird, sollte der ursprüngliche Fehler mit `#[source]` als Ursache beibehalten werden. Dies ist entscheidend für die `source()`-Kette.
        
        Rust
        
        ```
        // #
        // pub enum AudioManagementError {
        //     #[error("PipeWire connection failed")]
        //     ConnectionError(#[source] pipewire::Error), // Annahme: pipewire::Error ist der Fehlertyp
        //     //...
        // }
        ```
        
    - **Spezifische Fehlervarianten:** Erstellen Sie spezifische Fehlervarianten für häufige oder für die Domänenschicht relevante Fehlerfälle. Dies ermöglicht eine präzisere Fehlerbehandlung in höheren Schichten.
    - **Weitergabe an die Domänenschicht:** Die Domänenschicht sollte idealerweise nicht direkt mit den spezifischen Fehlertypen der Systemschicht-Module konfrontiert werden. Eine übergeordnete `SystemLayerError`-Enum, die alle modul-spezifischen Systemfehler wrappt, oder ein generischerer Ansatz (z.B. `anyhow::Error` mit Kontext) kann verwendet werden, um Fehler an die Domänenschicht zu propagieren. Die `source()`-Kette bleibt dabei erhalten und ermöglicht bei Bedarf eine detaillierte Fehleranalyse.
    - **Logging:** Fehler sollten auf der Systemschicht geloggt werden, bevor sie weitergegeben werden, insbesondere wenn sie nicht trivial sind oder wichtige Kontextinformationen enthalten.

## 7. Schlussfolgerungen und Empfehlungen

Die Entwicklung der Systemschicht für NovaDE stellt eine komplexe Aufgabe dar, die ein tiefes Verständnis der zugrundeliegenden Technologien und Protokolle erfordert. Die gewählte Architektur mit einer klaren Trennung in Module und der Verwendung etablierter Bibliotheken wie Smithay, libinput, zbus und pipewire-rs bildet eine solide Grundlage.

**Zentrale Herausforderungen und Lösungsansätze:**

- **Zustandsmanagement im Compositor:** Die Komplexität des `DesktopState` sollte durch Modularisierung und klare Verantwortlichkeiten reduziert werden. Die `delegate_*!`-Makros von Smithay sind hierbei wertvolle Werkzeuge. Geteilter Zustand erfordert sorgfältige Synchronisation mit `Arc<Mutex/RwLock<T>>`, wobei feingranulare Locks und die Vermeidung von Deadlocks essentiell sind.
- **Wayland-Protokollimplementierung:** Die korrekte Implementierung spezifischer Protokolle wie `wlr-output-management` (Atomarität, Serial-Handling), `wlr-output-power-management` (exklusive Kontrolle) und `wlr-layer-shell` (exklusive Zonen) ist entscheidend für die Funktionalität und Stabilität des Desktops. Die Protokoll-Spezifikationen und existierende Implementierungen (z.B. in wlroots-basierten Compositors) dienen als wichtige Referenzen.
- **Asynchronität und Event-Loop-Integration:** Die Koordination zwischen `calloop` (Compositor) und `tokio` (D-Bus, MCP, Timer) erfordert robuste IPC-Mechanismen wie Kanäle (`tokio::sync::mpsc`, `calloop::channel`) und geteilten Zustand (`Arc<Mutex<T>>`). Für die UI-Integration (GLib) sind `glib::MainContext::spawn_local` und `glib::idle_add_local` Schlüsselkomponenten.
- **Fehlerbehandlung:** Eine konsistente Fehler-Wrapping-Strategie mit `thiserror` unter Beibehaltung der `source()`-Kette ist für Diagnose und Robustheit unerlässlich.

**Empfehlungen für die weitere Entwicklung:**

1. **Priorisierung von Tests:** Angesichts der Komplexität, insbesondere bei der Interaktion verschiedener Protokolle und Event-Loops, sollten Unit- und Integrationstests frühzeitig und umfassend implementiert werden.
2. **Dokumentation und Code-Beispiele:** Die interne Dokumentation sollte detailliert sein. Das Studium von Open-Source-Compositors, die ähnliche Technologien verwenden (z.B. Anvil für Smithay, andere Compositors für wlroots-Protokolle), kann wertvolle Einblicke liefern.
3. **Performance-Analyse:** Regelmäßige Performance-Analysen, insbesondere in kritischen Pfaden wie Rendering und Eingabeverarbeitung, sind notwendig, um Engpässe frühzeitig zu erkennen.
4. **Sicherheitsaspekte:** Bei der Interaktion mit externen Diensten (D-Bus, MCP) und der Verarbeitung von Client-Eingaben müssen Sicherheitsaspekte (Input-Validierung, Berechtigungsmanagement via PolicyKit) berücksichtigt werden.
5. **Iterative Entwicklung:** Aufgrund der Komplexität ist ein iterativer Ansatz, bei dem einzelne Module und Protokolle schrittweise implementiert und getestet werden, empfehlenswert.

Durch die konsequente Anwendung von Best Practices und eine sorgfältige Implementierung der spezifizierten Komponenten kann die Systemschicht von NovaDE eine stabile und leistungsfähige Basis für die darüberliegenden Schichten bilden.

# NovaDE Ultra-Feinspezifikation: Domänenschicht & Wayland/Smithay-Integration

Dieses Dokument definiert die detaillierten technischen Spezifikationen für die Domänenschicht des NovaDE-Projekts und deren Integration mit dem Wayland-Compositor, der unter Verwendung des Smithay-Toolkits implementiert wird. Es dient als direkter Implementierungsleitfaden für Entwickler und beschreibt die Kernarchitektur, Datenstrukturen, APIs und Interaktionsmuster.

## 1. Domänenschicht-Spezifikationen

Die Domänenschicht kapselt die Kernlogik und den Zustand der NovaDE-Desktop-Umgebung. Sie ist bewusst unabhängig von UI-Details und systemspezifischen Implementierungen konzipiert, um eine klare Trennung der Verantwortlichkeiten zu gewährleisten und die Wartbarkeit sowie Testbarkeit des Systems zu verbessern. Diese Schicht bildet das Herzstück von NovaDE und definiert die grundlegenden Entitäten, Regeln und Prozesse, die das Verhalten der Desktop-Umgebung bestimmen.

### 1.1. Modul: `domain::theming`

Dieses Modul ist verantwortlich für die Logik des Erscheinungsbilds (Theming), die Verwaltung von Design-Tokens, die Interpretation von Theme-Definitionen und die Ermöglichung dynamischer Theme-Wechsel. Es stellt die Grundlage für ein konsistentes und anpassbares Benutzererlebnis dar.

Referenzierte Dokumente: B1 Domänenschicht.md

#### 1.1.1. Datenstrukturen (`domain::theming::types`)

Die folgenden Datenstrukturen definieren die Kernentitäten für das Theming-System:

- **`TokenIdentifier`**: Ein Wrapper für `String` zur eindeutigen Identifizierung von Design-Tokens (z.B. `"color.background.primary"`).
    
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `PartialOrd`, `Ord`, `Display`, `From<&str>`.
    - Invarianten: Darf nicht leer sein und darf nur ASCII-Alphanumerische Zeichen, Punkte (`.`) und Bindestriche (`-`) enthalten. Diese strikten Invarianten sind entscheidend, um Parsing-Fehler zu vermeiden und eine konsistente Referenzierung von Tokens im gesamten System sicherzustellen, was die Token-Verwaltung vereinfacht und potenzielle Laufzeitprobleme reduziert.
- **`TokenValue`**: Ein Enum zur Repräsentation der verschiedenen Typen von Token-Werten.
    
    - Varianten: `Color(String)`, `Dimension(String)`, `FontSize(String)`, `FontFamily(String)`, `FontWeight(String)`, `LineHeight(String)`, `LetterSpacing(String)`, `Border(String)`, `Shadow(String)`, `Radius(String)`, `Spacing(String)`, `ZIndex(i32)`, `Opacity(f64)` (Wertebereich 0.0-1.0), `Text(String)`, `Reference(TokenIdentifier)`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
    - Die `Opacity`-Werte werden bei der Zuweisung oder Verarbeitung automatisch auf den Bereich [0.0,1.0] geklemmt, um ungültige Zustände zu verhindern. Die `Reference` Variante ermöglicht es, Tokens aufeinander verweisen zu lassen, was eine flexible und wartbare Theme-Struktur unterstützt.
- **`RawToken`**: Eine Struktur zur Repräsentation eines Tokens, wie es typischerweise aus einer Konfigurationsdatei gelesen wird.
    
    - Felder: `id: TokenIdentifier`, `value: TokenValue`, `description: Option<String>`, `group: Option<String>`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
- **`TokenSet`**: Ein Typalias für `std::collections::BTreeMap<TokenIdentifier, RawToken>`.
    
    - Die Verwendung von `BTreeMap` stellt sicher, dass Tokens bei der Verarbeitung oder Anzeige konsistent sortiert sind, was die Fehlersuche und das Management erleichtert.
- **`ThemeIdentifier`**: Ein Wrapper für `String` zur eindeutigen Identifizierung von Themes.
    
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `PartialOrd`, `Ord`, `Display`, `From<&str>`.
    - Invarianten: Darf nicht leer sein. Empfohlene Zeichen sind `a-z`, `A-Z`, `0-9`, `.` und `-`, um Kompatibilität über verschiedene Dateisysteme und Kontexte hinweg zu gewährleisten.
- **`ColorSchemeType`**: Ein Enum zur Unterscheidung zwischen hellen und dunklen Farbschemata.
    
    - Varianten: `Light`, `Dark`.
    - Implementiert: `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `Default` (standardmäßig `Light`).
- **`AccentColor`**: Eine Struktur zur Repräsentation einer Akzentfarbe innerhalb eines Themes.
    
    - Felder: `name: Option<String>`, `value: novade_core::types::Color`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
    - Für `Eq` und `Hash` auf dem Feld `value` (vom Typ `novade_core::types::Color`) ist möglicherweise eine manuelle Implementierung oder eine Konvertierung in einen kanonischen Hex-String erforderlich, um konsistentes Verhalten in Hash-basierten Sammlungen sicherzustellen.
- **`ThemeVariantDefinition`**: Definiert spezifische Token-Werte für eine bestimmte Theme-Variante (z.B. helles oder dunkles Schema).
    
    - Felder: `applies_to_scheme: ColorSchemeType`, `tokens: TokenSet`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
- **`ThemeDefinition`**: Die vollständige Definition eines Themes, inklusive Basis-Tokens, Varianten und Akzentfarb-Informationen.
    
    - Felder: `id: ThemeIdentifier`, `name: String`, `description: Option<String>`, `author: Option<String>`, `version: Option<String>`, `base_tokens: TokenSet`, `variants: Vec<ThemeVariantDefinition>`, `supported_accent_colors: Option<Vec<AccentColor>>`, `accentable_tokens: Option<HashMap<TokenIdentifier, AccentModificationType>>`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
    - Das Feld `accentable_tokens` ermöglicht eine feingranulare Steuerung, wie Akzentfarben auf einzelne Tokens angewendet werden.
- **`AccentModificationType`**: Ein Enum, das beschreibt, wie ein Token durch eine Akzentfarbe modifiziert werden soll.
    
    - Varianten: `DirectReplace`, `Lighten(f32)`, `Darken(f32)`.
    - Die Parameter für `Lighten` und `Darken` (z.B. `f32`) geben den Grad der Aufhellung oder Abdunkelung an.
- **`AppliedThemeState`**: Repräsentiert den aktuell aktiven, vollständig aufgelösten Theme-Zustand, der an die UI-Schicht übergeben wird.
    
    - Felder: `theme_id: ThemeIdentifier`, `color_scheme: ColorSchemeType`, `active_accent_color: Option<AccentColor>`, `resolved_tokens: std::collections::BTreeMap<TokenIdentifier, String>`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
    - Invarianten: `resolved_tokens` darf keine `TokenValue::Reference` mehr enthalten; alle Werte müssen zu finalen Strings aufgelöst sein. Dies ist kritisch, da die UI-Schicht keine Token-Referenzen interpretieren soll.
- **`ThemingConfiguration`**: Benutzerspezifische Einstellungen für das Theming.
    
    - Felder: `selected_theme_id: ThemeIdentifier`, `preferred_color_scheme: ColorSchemeType`, `selected_accent_color: Option<novade_core::types::Color>`, `custom_user_token_overrides: Option<TokenSet>`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`, `Default`.
    - Die `Default`-Implementierung stellt sicher, dass das System auch ohne explizite Benutzerkonfiguration einen validen Ausgangszustand hat.

#### 1.1.2. Fehlerbehandlung (`domain::theming::errors`)

Das `ThemingError` Enum, definiert mit `thiserror`, kapselt alle potenziellen Fehler, die im Theming-Modul auftreten können. Dies ermöglicht eine präzise und kontextbezogene Fehlerbehandlung.

- **Varianten**:
    - `TokenFileParseError { path: PathBuf, source: serde_json::Error }`: Fehler beim Parsen einer Token-JSON-Datei.
    - `TokenFileIoError { path: PathBuf, source: std::io::Error }`: Fehler beim Lesen/Schreiben einer Token-Datei.
    - `InvalidTokenData { path: PathBuf, message: String }`: Ungültige Datenstruktur in einer Token-Datei.
    - `InvalidTokenValue { token_id: TokenIdentifier, value_string: String, reason: String }`: Ein Token-Wert entspricht nicht dem erwarteten Format oder Typ.
    - `CyclicTokenReference { token_id: TokenIdentifier, cycle_path: Vec<TokenIdentifier> }`: Zyklische Abhängigkeit bei der Token-Referenzierung entdeckt.
    - `ThemeFileLoadError { theme_id: ThemeIdentifier, path: PathBuf, source: serde_json::Error }`: Fehler beim Parsen einer Theme-JSON-Datei.
    - `ThemeFileIoError { theme_id: ThemeIdentifier, path: PathBuf, source: std::io::Error }`: Fehler beim Lesen/Schreiben einer Theme-Datei.
    - `InvalidThemeData { theme_id: ThemeIdentifier, path: PathBuf, message: String }`: Ungültige Datenstruktur in einer Theme-Datei.
    - `ThemeNotFound { theme_id: ThemeIdentifier }`: Das angeforderte Theme konnte nicht gefunden werden.
    - `MissingTokenReference { referencing_token_id: TokenIdentifier, target_token_id: TokenIdentifier }`: Ein referenziertes Token existiert nicht.
    - `MaxReferenceDepthExceeded { token_id: TokenIdentifier, depth: u8 }`: Die maximale Tiefe für Token-Referenzen wurde überschritten, um Endlosschleifen zu verhindern.
    - `ThemeApplicationError { message: String, source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`: Allgemeiner Fehler bei der Anwendung eines Themes.
    - `FallbackThemeLoadError { source: Box<dyn std::error::Error + Send + Sync + 'static>> }`: Fehler beim Laden des Fallback-Themes.
    - `InitialConfigurationError(String)`: Fehler bei der Initialisierung der Theming-Konfiguration.
    - `InternalStateError(String)`: Unerwarteter interner Fehler im Theming-Modul.
    - `EventSubscriptionError(String)`: Fehler bei der Registrierung für Theme-Änderungs-Events.
    - `AccentColorApplicationError { theme_id: ThemeIdentifier, accent_color: novade_core::types::Color, details: String }`: Fehler bei der Anwendung einer Akzentfarbe.
    - `TokenResolutionError { token_id: TokenIdentifier, message: String, source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`: Fehler während der Auflösung eines spezifischen Tokens.
    - `FilesystemError(#[from] novade_core::errors::CoreError)`: Fehler im Zusammenhang mit Dateisystemoperationen, die von `novade_core` stammen.

#### 1.1.3. Kernlogik (`domain::theming::logic`)

Die Kernlogik des Theming-Moduls umfasst das Laden, Validieren und Auflösen von Themes und Tokens.

- **Konstante**: `MAX_TOKEN_RESOLUTION_DEPTH: u8 = 16`. Dieser Wert begrenzt die Rekursionstiefe bei der Auflösung von Token-Referenzen, um Endlosschleifen und übermäßigen Ressourcenverbrauch zu verhindern. Der Wert 16 stellt einen pragmatischen Kompromiss zwischen Flexibilität und Sicherheit dar.
    
- **Token/Theme Laden & Validieren**:
    
    - `async fn load_raw_tokens_from_file(path: &Path, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`: Liest eine JSON-Datei vom angegebenen Pfad, parst deren Inhalt zu einem `TokenSet` und validiert auf Duplikate sowie das grundlegende Format der Tokens. Nutzt den `ConfigServiceAsync` für asynchrone Dateioperationen.
    - `async fn load_and_validate_token_files(paths: &, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`: Lädt Tokens von mehreren Pfaden, führt sie zusammen (wobei Benutzer-Tokens System-Tokens überschreiben) und validiert das Ergebnis auf Zyklen und andere Inkonsistenzen.
    - `async fn load_theme_definition_from_file(path: &Path, theme_id_override: Option<ThemeIdentifier>, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<ThemeDefinition, ThemingError>`: Liest eine JSON-Datei und parst sie zu einer `ThemeDefinition`. Ermöglicht das Überschreiben der Theme-ID, falls diese nicht im Dateinamen enthalten ist oder anders abgeleitet werden muss.
    - `async fn load_and_validate_theme_files(paths: &, available_tokens: &TokenSet, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<Vec<ThemeDefinition>, ThemingError>`: Lädt mehrere Theme-Definitionen von den angegebenen Pfaden und validiert die darin enthaltenen Token-Referenzen gegen den Satz der global verfügbaren Tokens (`available_tokens`).
    - `fn validate_tokenset_for_cycles(tokens: &TokenSet) -> Result<(), ThemingError>`: Verwendet eine Tiefensuche (Depth-First Search, DFS), um zyklische Referenzen innerhalb eines `TokenSet` zu erkennen.
- **Token Resolution Pipeline**:
    
    - `fn resolve_tokens_for_config(config: &ThemingConfiguration, theme_def: &ThemeDefinition, global_tokens: &TokenSet, accentable_tokens_map: &HashMap<TokenIdentifier, AccentModificationType>, max_depth: u8) -> Result<BTreeMap<TokenIdentifier, String>, ThemingError>`: Diese zentrale Funktion ist verantwortlich für die Auflösung aller Tokens zu ihren finalen String-Werten basierend auf der aktuellen Konfiguration.
        
        1. Startet mit einer Basis-Token-Menge, die aus globalen Tokens und den Basis-Tokens des ausgewählten Themes besteht.
        2. Wendet die Tokens der passenden Theme-Variante (hell/dunkel) an, die die Basis-Tokens überschreiben.
        3. Appliziert die ausgewählte Akzentfarbe. Dies geschieht durch Modifikation der Tokens, die im `accentable_tokens_map` des Themes definiert sind, gemäß dem `AccentModificationType`.
        4. Wendet benutzerspezifische Token-Overrides an, die die höchste Priorität haben.
        5. Führt eine rekursive Auflösung für alle Tokens vom Typ `TokenValue::Reference` durch. Dabei wird die Funktion `resolve_single_token_value` (nicht explizit in der API, aber impliziert durch die Logik) verwendet, die eine Zyklenerkennung und eine Begrenzung der Rekursionstiefe (`max_depth`) implementiert.
        6. Konvertiert alle aufgelösten `TokenValue`-Instanzen in ihre finalen String-Repräsentationen (z.B. Farbcodes, Dimensionsangaben).
        
        - Das Ergebnis ist ein `BTreeMap<TokenIdentifier, String>`, das keine Referenzen mehr enthält und direkt von der UI-Schicht verwendet werden kann.
- **Caching**:
    
    - Ein Cache für `AppliedThemeState` wird implementiert, um die wiederholte, potenziell aufwendige Auflösung von Tokens zu vermeiden.
    - Der Cache-Schlüssel (`CacheKey`) wird gebildet aus: `(ThemeIdentifier, ColorSchemeType, Option<String> /* hex von AccentColor */, u64 /* hash von Overrides */)`.
    - Diese Strategie stellt sicher, dass bei relevanten Änderungen der Konfiguration ein neuer Zustand generiert wird, während bei unveränderter Konfiguration auf den gecachten Zustand zurückgegriffen werden kann.
- **Fallback**:
    
    - `fn generate_fallback_applied_state() -> AppliedThemeState`: Generiert einen minimalen, aber funktionsfähigen `AppliedThemeState` aus einkompilierten JSON-Definitionen. Dies stellt sicher, dass das System auch dann ein grundlegendes Erscheinungsbild hat, wenn keine Theme-Dateien geladen werden können oder Konfigurationsfehler auftreten.

#### 1.1.4. API (`domain::theming::service::ThemingEngine`)

Die `ThemingEngine` ist die zentrale Schnittstelle für andere Teile des Systems, um auf Theming-Funktionalitäten zuzugreifen.

- **Struktur `ThemingEngineInternalState`**: Kapselt den internen, veränderlichen Zustand der Engine.
    
    - Felder: `current_config: ThemingConfiguration`, `available_themes: Vec<ThemeDefinition>`, `global_raw_tokens: TokenSet`, `applied_state: AppliedThemeState`, `theme_load_paths: Vec<PathBuf>`, `token_load_paths: Vec<PathBuf>`, `resolved_state_cache: HashMap<CacheKey, AppliedThemeState>`, `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>`.
    - Die Verwendung von `Arc` für `config_service` ermöglicht die gemeinsame Nutzung dieses Dienstes.
- **Struktur `ThemingEngine`**: Die öffentliche API-Struktur.
    
    - Felder: `internal_state: Arc<tokio::sync::Mutex<ThemingEngineInternalState>>`, `event_sender: tokio::sync::broadcast::Sender<ThemeChangedEvent>`.
    - Die Verwendung von `Arc<tokio::sync::Mutex<...>>` gewährleistet Thread-sicheren Zugriff auf den internen Zustand in einer asynchronen Umgebung.
    - `tokio::sync::broadcast::Sender` wird für die Veröffentlichung von Theme-Änderungs-Events verwendet.
- **Methoden**:
    
    - `async fn new(initial_config: ThemingConfiguration, theme_load_paths: Vec<PathBuf>, token_load_paths: Vec<PathBuf>, config_service: Arc<dyn novade_core::config::ConfigServiceAsync>, broadcast_capacity: usize) -> Result<Self, ThemingError>`: Konstruktor, der die Engine initialisiert, initiale Themes und Tokens lädt und den ersten `AppliedThemeState` generiert.
    - `async fn get_current_theme_state(&self) -> AppliedThemeState`: Gibt den aktuell angewendeten und aufgelösten Theme-Zustand zurück.
    - `async fn get_available_themes(&self) -> Vec<ThemeDefinition>`: Gibt eine Liste aller verfügbaren Theme-Definitionen zurück.
    - `async fn get_current_configuration(&self) -> ThemingConfiguration`: Gibt die aktuelle Benutzerkonfiguration für das Theming zurück.
    - `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`: Aktualisiert die Benutzerkonfiguration, löst die Tokens neu auf, aktualisiert den Cache und publiziert ein `ThemeChangedEvent`.
    - `async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`: Lädt alle Theme- und Token-Dateien von den konfigurierten Pfaden neu, validiert sie, aktualisiert den internen Zustand und den Cache und publiziert ggf. ein `ThemeChangedEvent`.
    - `fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeChangedEvent>`: Ermöglicht anderen Modulen, auf Änderungen des Themes zu reagieren.

#### 1.1.5. Events (`domain::theming::events`)

- **`ThemeChangedEvent`**: Wird publiziert, wenn sich der angewendete Theme-Zustand ändert.
    - Payload: `new_state: AppliedThemeState`.
    - Dieses Event ist entscheidend für die dynamische Aktualisierung der Benutzeroberfläche, ohne dass Komponenten den `ThemingEngine` ständig pollen müssen.

### 1.2. Modul: `domain::workspaces`

Dieses Modul ist für die Logik und Verwaltung von Arbeitsbereichen (auch "Spaces" oder "virtuelle Desktops" genannt) zuständig. Es definiert, wie Arbeitsbereiche erstellt, modifiziert, gelöscht und wie Fenster ihnen zugewiesen werden.

Referenzierte Dokumente: B2 Domänenschicht.md

#### 1.2.1. Untermodul: `domain::workspaces::core`

Das `core`-Untermodul definiert die grundlegenden Datenstrukturen, Entitäten und Kernfehler für Arbeitsbereiche.

- **Datenstrukturen (`domain::workspaces::core::types`)**:
    
    - `WorkspaceId`: Ein Typalias für `uuid::Uuid`, um Arbeitsbereiche eindeutig zu identifizieren. Die Verwendung von UUIDs stellt globale Eindeutigkeit sicher, was bei der Synchronisation oder bei verteilten Szenarien vorteilhaft sein kann.
    - `WindowIdentifier`: Ein Wrapper für `String` zur Identifizierung von Fenstern.
        - Implementiert `new(id: impl Into<String>) -> Result<Self, WorkspaceCoreError>`. Die Validierung (z.B. nicht leer) erfolgt hier. Dies stellt sicher, dass Fensterbezeichner immer in einem validen Zustand sind.
    - `WorkspaceLayoutType`: Ein Enum zur Definition der verschiedenen Layout-Modi eines Arbeitsbereichs.
        - Varianten: `Floating`, `TilingHorizontal`, `TilingVertical`, `Maximized`.
        - Implementiert `Default` (standardmäßig `Floating`).
- **Entität `Workspace` (`domain::workspaces::core::mod.rs`)**: Die zentrale Entität, die einen Arbeitsbereich repräsentiert.
    
    - Felder:
        - `id: WorkspaceId`: Eindeutiger Identifikator.
        - `name: String`: Vom Benutzer lesbarer Name des Arbeitsbereichs (z.B. "Arbeit", "Web").
        - `persistent_id: Option<String>`: Eine optionale, persistente ID, die über Sitzungen hinweg stabil bleiben kann (z.B. für das Wiederherstellen von Arbeitsbereichs-Setups).
        - `layout_type: WorkspaceLayoutType`: Der aktuelle Layout-Modus.
        - `window_ids: HashSet<WindowIdentifier>`: Eine Menge der IDs der Fenster, die diesem Arbeitsbereich zugeordnet sind.
        - `created_at: DateTime<Utc>`: Zeitstempel der Erstellung.
        - `icon_name: Option<String>`: Optionaler Name eines Icons zur visuellen Repräsentation.
        - `accent_color_hex: Option<String>`: Optionale Akzentfarbe im Hex-Format für den Arbeitsbereich.
    - Methoden:
        - `new(name: String, persistent_id: Option<String>, layout_type: WorkspaceLayoutType, icon_name: Option<String>, accent_color_hex: Option<String>) -> Result<Self, WorkspaceCoreError>`: Konstruktor für neue Arbeitsbereiche. Validiert Eingaben wie `name` und `accent_color_hex`.
        - `id() -> WorkspaceId`: Gibt die ID des Arbeitsbereichs zurück.
        - `name() -> &str`: Gibt den Namen des Arbeitsbereichs zurück.
        - `rename(&mut self, new_name: String) -> Result<(), WorkspaceCoreError>`: Ändert den Namen des Arbeitsbereichs. Validiert den neuen Namen.
        - `set_layout_type(&mut self, layout_type: WorkspaceLayoutType)`: Ändert den Layout-Typ.
        - `add_window_id(&mut self, window_id: WindowIdentifier)` (`crate`-intern): Fügt eine Fenster-ID hinzu. Die Sichtbarkeit ist auf `crate` beschränkt, da die Fensterzuweisung über den `assignment`-Service erfolgen soll.
        - `remove_window_id(&mut self, window_id: &WindowIdentifier) -> bool` (`crate`-intern): Entfernt eine Fenster-ID.
        - `set_icon_name(&mut self, icon_name: Option<String>)`: Setzt den Icon-Namen.
        - `set_accent_color_hex(&mut self, accent_color_hex: Option<String>) -> Result<(), WorkspaceCoreError>`: Setzt die Akzentfarbe und validiert das Format.
- **Event-Payloads (`domain::workspaces::core::event_data`)**: Strukturen, die als Daten für die verschiedenen Arbeitsbereichs-Events dienen.
    
    - `WorkspaceRenamedData { new_name: String }`
    - `WorkspaceLayoutChangedData { new_layout: WorkspaceLayoutType }`
    - `WindowAddedToWorkspaceData { window_id: WindowIdentifier }`
    - `WindowRemovedFromWorkspaceData { window_id: WindowIdentifier }`
    - `WorkspacePersistentIdChangedData { new_persistent_id: Option<String> }`
    - `WorkspaceIconChangedData { new_icon_name: Option<String> }`
    - `WorkspaceAccentChangedData { new_accent_color_hex: Option<String> }`
- **Fehlerbehandlung (`domain::workspaces::core::errors`)**:
    
    - `WorkspaceCoreError`: Enum für Fehler, die direkt bei der Manipulation einer `Workspace`-Entität auftreten können.
        - Varianten: `InvalidName`, `NameCannotBeEmpty`, `NameTooLong`, `InvalidPersistentId`, `WindowIdentifierEmpty`, `InvalidAccentColorFormat`.

#### 1.2.2. Untermodul: `domain::workspaces::assignment`

Dieses Untermodul stellt die API für die Zuordnung von Fenstern zu Arbeitsbereichen bereit. Es stellt sicher, dass die Regeln für Fensterzuweisungen eingehalten werden.

- **API (`domain::workspaces::assignment::mod.rs`)**: Funktionen, die auf einer veränderlichen `HashMap<WorkspaceId, Workspace>` operieren. Dieser Ansatz ermöglicht es, die Zuordnungslogik von der Hauptverwaltung der Arbeitsbereiche zu entkoppeln, macht aber eine sorgfältige Zustandsverwaltung erforderlich, um Konsistenz zu gewährleisten.
    
    - `assign_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier, ensure_unique_assignment: bool) -> Result<(), WindowAssignmentError>`: Weist ein Fenster einem spezifischen Arbeitsbereich zu. Der Parameter `ensure_unique_assignment` steuert, ob ein Fenster zuvor von allen anderen Arbeitsbereichen entfernt werden muss.
    - `remove_window_from_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<bool, WindowAssignmentError>`: Entfernt ein Fenster von einem spezifischen Arbeitsbereich. Gibt `true` zurück, wenn das Fenster entfernt wurde.
    - `move_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, window_id: &WindowIdentifier, source_workspace_id: WorkspaceId, target_workspace_id: WorkspaceId) -> Result<(), WindowAssignmentError>`: Verschiebt ein Fenster von einem Quell- zu einem Zielarbeitsbereich.
    - `find_workspace_for_window(workspaces: &HashMap<WorkspaceId, Workspace>, window_id: &WindowIdentifier) -> Option<WorkspaceId>`: Findet den Arbeitsbereich, dem ein bestimmtes Fenster zugewiesen ist.
- **Fehlerbehandlung (`domain::workspaces::assignment::errors`)**:
    
    - `WindowAssignmentError`: Enum für Fehler, die bei der Fensterzuweisung auftreten können.
        - Varianten: `WorkspaceNotFound`, `WindowAlreadyAssigned` (wenn `ensure_unique_assignment` true ist und das Fenster bereits auf dem Ziel-Workspace ist oder auf einem anderen und nicht entfernt werden konnte), `WindowNotAssignedToWorkspace`, `SourceWorkspaceNotFound`, `TargetWorkspaceNotFound`, `WindowNotOnSourceWorkspace`, `CannotMoveToSameWorkspace`, `RuleViolation` (für zukünftige, komplexere Zuweisungsregeln), `Internal`.

#### 1.2.3. Untermodul: `domain::workspaces::config`

Verantwortlich für die Persistenz und das Laden von Arbeitsbereichs-Konfigurationen.

- **Datenstrukturen (`domain::workspaces::config::mod.rs`)**:
    
    - `WorkspaceSnapshot`: Eine serialisierbare Repräsentation eines Arbeitsbereichs für die Speicherung. Enthält nur persistente Eigenschaften.
        - Felder: `persistent_id: String`, `name: String`, `layout_type: WorkspaceLayoutType`, `icon_name: Option<String>`, `accent_color_hex: Option<String>`.
    - `WorkspaceSetSnapshot`: Eine serialisierbare Repräsentation eines Sets von Arbeitsbereichen und des aktiven Arbeitsbereichs.
        - Felder: `workspaces: Vec<WorkspaceSnapshot>`, `active_workspace_persistent_id: Option<String>`.
- **API (`domain::workspaces::config::mod.rs`)**:
    
    - Trait `WorkspaceConfigProvider`: Definiert die Schnittstelle für das Laden und Speichern von Arbeitsbereichs-Konfigurationen.
        - `async fn load_workspace_config(&self) -> Result<WorkspaceSetSnapshot, WorkspaceConfigError>`
        - `async fn save_workspace_config(&self, snapshot: &WorkspaceSetSnapshot) -> Result<(), WorkspaceConfigError>`
    - Struktur `FilesystemConfigProvider`: Eine Implementierung von `WorkspaceConfigProvider`, die `novade_core::config::ConfigServiceAsync` für Dateioperationen verwendet. Dies entkoppelt die Workspace-Logik von den Details der Dateispeicherung.
- **Fehlerbehandlung (`domain::workspaces::config::errors`)**:
    
    - `WorkspaceConfigError`: Enum für Fehler im Zusammenhang mit der Konfigurationspersistenz.
        - Varianten: `LoadError { source: novade_core::errors::CoreError }`, `SaveError { source: novade_core::errors::CoreError }`, `InvalidData { message: String }`, `SerializationError { source: serde_json::Error }`, `DeserializationError { source: serde_json::Error }`, `PersistentIdNotFoundInLoadedSet { persistent_id: String }`, `DuplicatePersistentIdInLoadedSet { persistent_id: String }`.

#### 1.2.4. Untermodul: `domain::workspaces::manager`

Der `WorkspaceManagerService` ist die Hauptschnittstelle zur Verwaltung von Arbeitsbereichen. Er orchestriert die `core`-, `assignment`- und `config`-Logik.

- **API (`domain::workspaces::manager::mod.rs`)**:
    
    - Trait `WorkspaceManagerService`: Definiert die öffentliche API für die Arbeitsbereichsverwaltung.
        - Methoden: `async fn create_workspace(&self, name: String, persistent_id: Option<String>, layout_type: Option<WorkspaceLayoutType>, icon: Option<String>, accent_color: Option<String>) -> Result<Workspace, WorkspaceManagerError>`, `async fn delete_workspace(&self, id: WorkspaceId, fallback_workspace_id: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError>`, `async fn get_workspace(&self, id: WorkspaceId) -> Option<Workspace>`, `async fn all_workspaces_ordered(&self) -> Vec<Workspace>`, `async fn active_workspace_id(&self) -> Option<WorkspaceId>`, `async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`, `async fn assign_window_to_active_workspace(&self, window_id: WindowIdentifier) -> Result<(), WorkspaceManagerError>`, `async fn assign_window_to_specific_workspace(&self, workspace_id: WorkspaceId, window_id: WindowIdentifier) -> Result<(), WorkspaceManagerError>`, `async fn remove_window_from_its_workspace(&self, window_id: &WindowIdentifier) -> Result<bool, WorkspaceManagerError>`, `async fn move_window_to_specific_workspace(&self, window_id: &WindowIdentifier, target_workspace_id: WorkspaceId) -> Result<(), WorkspaceManagerError>`, `async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`, `async fn set_workspace_layout(&self, id: WorkspaceId, layout: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>`, `async fn set_workspace_icon(&self, id: WorkspaceId, icon_name: Option<String>) -> Result<(), WorkspaceManagerError>`, `async fn set_workspace_accent_color(&self, id: WorkspaceId, accent_color_hex: Option<String>) -> Result<(), WorkspaceManagerError>`, `async fn save_configuration(&self) -> Result<(), WorkspaceManagerError>`, `fn subscribe_to_workspace_events(&self) -> tokio::sync::broadcast::Receiver<WorkspaceEvent>`, `async fn reorder_workspace(&self, workspace_id: WorkspaceId, new_index: usize) -> Result<(), WorkspaceManagerError>`.
- **Implementierung `DefaultWorkspaceManager`**: Hält einen `Arc<tokio::sync::Mutex<WorkspaceManagerInternalState>>`.
    
    - `WorkspaceManagerInternalState`: Kapselt den internen Zustand.
        - Felder: `workspaces: HashMap<WorkspaceId, Workspace>`, `active_workspace_id: Option<WorkspaceId>`, `ordered_workspace_ids: Vec<WorkspaceId>`, `next_workspace_number: u32` (für Standardnamen neuer Workspaces), `config_provider: Arc<dyn WorkspaceConfigProvider>`, `event_publisher: tokio::sync::broadcast::Sender<WorkspaceEvent>`, `ensure_unique_window_assignment: bool`.
        - Die Option `ensure_unique_window_assignment` steuert, ob ein Fenster nur einem Arbeitsbereich gleichzeitig zugewiesen sein darf. Dies ist eine wichtige Policy-Entscheidung.
- **Events (`domain::workspaces::manager::events`)**:
    
    - `WorkspaceEvent`: Enum, das alle relevanten Änderungen an Arbeitsbereichen und Fensterzuweisungen repräsentiert.
        - Varianten: `WorkspaceCreated { workspace: Workspace }`, `WorkspaceDeleted { workspace_id: WorkspaceId, windows_moved_to: Option<WorkspaceId> }`, `ActiveWorkspaceChanged { old_id: Option<WorkspaceId>, new_id: WorkspaceId }`, `WorkspaceRenamed { workspace_id: WorkspaceId, data: WorkspaceRenamedData }`, `WorkspaceLayoutChanged { workspace_id: WorkspaceId, data: WorkspaceLayoutChangedData }`, `WindowAddedToWorkspace { workspace_id: WorkspaceId, data: WindowAddedToWorkspaceData }`, `WindowRemovedFromWorkspace { workspace_id: WorkspaceId, data: WindowRemovedFromWorkspaceData }`, `WorkspaceOrderChanged { ordered_ids: Vec<WorkspaceId> }`, `WorkspacesReloaded { new_workspaces: Vec<Workspace>, new_active_id: Option<WorkspaceId> }`, `WorkspacePersistentIdChanged { workspace_id: WorkspaceId, data: WorkspacePersistentIdChangedData }`, `WorkspaceIconChanged { workspace_id: WorkspaceId, data: WorkspaceIconChangedData }`, `WorkspaceAccentChanged { workspace_id: WorkspaceId, data: WorkspaceAccentChangedData }`.
- **Fehlerbehandlung (`domain::workspaces::manager::errors`)**:
    
    - `WorkspaceManagerError`: Enum für Fehler auf der Manager-Ebene.
        - Varianten: `WorkspaceNotFound { id: WorkspaceId }`, `CannotDeleteLastWorkspace`, `DeleteRequiresFallbackForWindows { num_windows: usize }`, `FallbackWorkspaceNotFound { id: WorkspaceId }`, `CoreError(#[from] WorkspaceCoreError)`, `AssignmentError(#[from] WindowAssignmentError)`, `ConfigError(#[from] WorkspaceConfigError)`, `SetActiveWorkspaceNotFound { id: WorkspaceId }`, `NoActiveWorkspace`, `DuplicatePersistentId { id: String }`, `Internal { message: String }`.

### 1.3. Modul: `domain::user_centric_services`

Dieses Modul bündelt Domänenlogik für Dienste, die direkt auf Benutzerinteraktionen und -bedürfnisse ausgerichtet sind, insbesondere KI-Interaktionen und Benachrichtigungen.

Referenzierte Dokumente: B3 Domänenschicht.md, B4 Domänenschicht.md

#### 1.3.1. Untermodul: `domain::user_centric_services::ai_interaction`

Verantwortlich für die Logik rund um KI-gestützte Interaktionen, Einwilligungsmanagement und die Verwaltung von KI-Modellprofilen.

- **Datenstrukturen (`domain::user_centric_services::ai_interaction::types`)**:
    
    - `AIDataCategory`: Enum zur Kategorisierung von Daten, die für KI-Interaktionen verwendet werden (z.B. `UserProfile`, `ApplicationUsage`, `FileSystemRead`).
    - `AIConsentStatus`: Enum für den Einwilligungsstatus (z.B. `Granted`, `Denied`, `PendingUserAction`). Die Variante `NotRequired` ist nützlich für Interaktionen, die keine explizite Einwilligung erfordern.
    - `AttachmentData`: Struktur für Anhänge an KI-Interaktionen (z.B. Dateien, Textauszüge). Die Felder `source_uri`, `content_base64`, `text_content` bieten Flexibilität für verschiedene Anhangstypen.
    - `InteractionParticipant`: Enum zur Kennzeichnung der Teilnehmer einer Interaktion (`User`, `Assistant`, `System`).
    - `InteractionHistoryEntry`: Repräsentiert einen einzelnen Eintrag im Interaktionsverlauf.
    - `AIInteractionContext`: Die zentrale Entität, die den gesamten Kontext einer KI-Interaktion kapselt, inklusive Verlauf, Anhängen und Einwilligungsstatus.
    - `AIConsentScope`: Enum zur Definition des Gültigkeitsbereichs einer Einwilligung (z.B. `SessionOnly`, `PersistentUntilRevoked`).
    - `AIConsent`: Struktur zur Speicherung detaillierter Einwilligungsinformationen.
    - `AIModelCapability`: Enum zur Beschreibung der Fähigkeiten eines KI-Modells (z.B. `TextGeneration`, `ImageAnalysis`).
    - `AIModelProfile`: Struktur zur Definition der Eigenschaften und Fähigkeiten eines KI-Modells. Das Feld `sort_order` ermöglicht eine benutzerdefinierte Sortierung der Modelle in der UI.
- **Fehlerbehandlung (`domain::user_centric_services::ai_interaction::errors`)**:
    
    - `AIInteractionError`: Enum für Fehler im KI-Interaktionsmodul (z.B. `ConsentCheckFailed`, `ApiKeyNotFoundInSecrets`, `ModelEndpointUnreachable`, `NoDefaultModelConfigured`, `CoreConfigError(#[from] novade_core::errors::CoreError)`).
- **Persistenz-Interfaces (`domain::user_centric_services::ai_interaction::persistence_iface`)**:
    
    - Traits `AIConsentProvider` und `AIModelProfileProvider`: Definieren Schnittstellen für das Laden und Speichern von Einwilligungen und Modellprofilen, was eine Entkopplung von der konkreten Speicherimplementierung ermöglicht.
- **API (`domain::user_centric_services::ai_interaction::service::AIInteractionLogicService`)**:
    
    - Trait mit Methoden wie `initiate_interaction`, `get_interaction_context`, `provide_consent`, `load_model_profiles`.
- **Implementierung `DefaultAIInteractionLogicService`**: Konkrete Implementierung des `AIInteractionLogicService`.
    
- **Events (`domain::user_centric_services::ai_interaction::events::AIInteractionEventEnum`)**:
    
    - Events wie `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`, `AIContextUpdatedEvent`, `AIModelProfilesReloadedEvent` zur Benachrichtigung anderer Systemteile über relevante Änderungen.

#### 1.3.2. Untermodul: `domain::user_centric_services::notifications_core`

Verantwortlich für die Kernlogik der Benachrichtigungsverwaltung, inklusive Erstellung, Speicherung, Filterung und Interaktion mit Benachrichtigungen.

- **Datenstrukturen (`domain::user_centric_services::notifications_core::types`)**:
    
    - `NotificationId`: Typalias für `uuid::Uuid`.
    - `NotificationUrgency`: Enum für die Dringlichkeit (`Low`, `Normal`, `Critical`).
    - `NotificationActionType`: Enum für Aktionstypen (`Callback`, `OpenLink`).
    - `NotificationAction`: Struktur für Aktionen, die einer Benachrichtigung zugeordnet sind.
    - `Notification`: Die Hauptentität, die eine Benachrichtigung repräsentiert. Enthält Felder wie `id`, `application_name`, `summary`, `body`, `actions`, `urgency`, `timestamp`, `is_read`, `is_dismissed`, `transient`, `category`, `hints`, `timeout_ms`.
    - `NotificationInput`: Eine Struktur zum Erstellen neuer Benachrichtigungen, ohne laufzeitgenerierte Felder wie `id` oder `timestamp`. Dies vereinfacht die API zum Posten von Benachrichtigungen.
    - `NotificationFilterCriteria`: Ein Enum für komplexe Filterkriterien, das logische UND/ODER/NICHT-Operationen sowie Filter auf Zeitbereiche unterstützt. Dies ermöglicht mächtige Abfragen des Benachrichtigungsverlaufs.
    - `NotificationSortOrder`: Enum für Sortierkriterien.
    - `NotificationStats`: Struktur zur Bereitstellung von Statistiken (z.B. `num_active`, `num_unread`), nützlich für UI-Anzeigen.
    - `DismissReason`: Enum zur Angabe des Grundes für das Schließen einer Benachrichtigung (z.B. `User`, `Timeout`), nützlich für Analysen und intelligente Benachrichtigungslogik.
- **Fehlerbehandlung (`domain::user_centric_services::notifications_core::errors`)**:
    
    - `NotificationError`: Enum für Fehler im Benachrichtigungssystem (z.B. `NotFound`, `InvalidData`, `HistoryFull`).
- **API (`domain::user_centric_services::notifications_core::service::NotificationService`)**:
    
    - Trait mit Methoden wie `post_notification(input: NotificationInput)`, `get_notification`, `mark_as_read`, `dismiss_notification`, `get_active_notifications`, `get_notification_history`, `set_do_not_disturb`, `invoke_action`, `get_stats`.
- **Implementierung `DefaultNotificationService`**: Konkrete Implementierung des `NotificationService`.
    
- **Events (`domain::user_centric_services::notifications_core::events::NotificationEventEnum`)**:
    
    - Events wie `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `DoNotDisturbModeChangedEvent` zur Benachrichtigung der UI und anderer Systemteile.

### 1.4. Modul: `domain::notifications_rules`

Ermöglicht eine regelbasierte Verarbeitung von eingehenden Benachrichtigungen, um deren Verhalten (z.B. Unterdrückung, Änderung der Dringlichkeit) basierend auf benutzerdefinierten Kriterien anzupassen.

Referenzierte Dokumente: B4 Domänenschicht.md

#### 1.4.1. Datenstrukturen (`domain::notifications_rules::types`)

- `RuleConditionValue`: Enum für die Werte in Regelbedingungen (z.B. `String(String)`, `Urgency(NotificationUrgency)`).
- `RuleConditionOperator`: Enum für Vergleichsoperatoren (z.B. `Is`, `Contains`, `MatchesRegex`).
- `RuleConditionField`: Enum zur Spezifizierung des Benachrichtigungsfeldes, auf das sich eine Bedingung bezieht (z.B. `ApplicationName`, `Summary`, `HintExists(String)`). Die Varianten `HintExists` und `HintValue` erlauben flexible Bedingungen basierend auf den `hints` einer Benachrichtigung.
- `SimpleRuleCondition`: Eine einfache Bedingung bestehend aus Feld, Operator und Wert.
- `RuleCondition`: Ein Enum, das komplexe, verschachtelte Bedingungen durch logische Operatoren (`And`, `Or`, `Not`) ermöglicht. Die Variante `SettingIsTrue(SettingPath)` erlaubt es, Regeln basierend auf globalen Einstellungen zu definieren, was eine starke Integration mit dem `GlobalSettingsService` ermöglicht.
- `RuleAction`: Enum für Aktionen, die ausgeführt werden, wenn eine Regel zutrifft (z.B. `SuppressNotification`, `SetUrgency`, `PlaySound`). Die Aktion `StopProcessingFurtherRules` bietet eine explizite Kontrolle über den Regelauswertungsfluss.
- `NotificationRule`: Repräsentiert eine einzelne Regel mit ID, Name, Bedingung, Aktionen, Aktivierungsstatus und Priorität. Die `Default`-Implementierung kann für das einfache Erstellen neuer Regeln in einer UI nützlich sein.
- `NotificationRuleSet`: Typalias für `Vec<NotificationRule>`. Die Reihenfolge in diesem Vektor ist relevant für die Regelauswertung, da Regeln typischerweise basierend auf ihrer Priorität und/oder Reihenfolge verarbeitet werden.

#### 1.4.2. Fehlerbehandlung (`domain::notifications_rules::errors`)

- `NotificationRulesError`: Enum für Fehler im Regelmodul (z.B. `InvalidRuleDefinition`, `ConditionEvaluationError`, `SettingsAccessError(#[from] GlobalSettingsError)`, `InvalidRegex`).

#### 1.4.3. API (`domain::notifications_rules::engine::NotificationRulesEngine`)

- Trait `NotificationRulesEngine`:
    - Methoden: `async fn reload_rules(&mut self)`, `async fn process_notification(&self, notification: Notification) -> Result<RuleProcessingResult, NotificationRulesError>`, `async fn get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`, `async fn update_rules(&mut self, new_rules: NotificationRuleSet) -> Result<(), NotificationRulesError>`.
- Implementierung `DefaultNotificationRulesEngine`: Hält einen `Arc<tokio::sync::RwLock<NotificationRuleSet>>`, einen `Arc<dyn NotificationRulesProvider>` und einen `Arc<dyn GlobalSettingsService>`. Die Verwendung von `RwLock` ermöglicht konkurrierenden Lesezugriff auf die Regeln, während Schreibzugriffe exklusiv sind.
- Enum `RuleProcessingResult`: Gibt das Ergebnis der Regelverarbeitung an.
    - Varianten: `Allow(Notification)` (die Benachrichtigung darf angezeigt werden, möglicherweise modifiziert), `Suppress { rule_id: Uuid }` (die Benachrichtigung soll unterdrückt werden).

#### 1.4.4. Persistenz (`domain::notifications_rules::persistence_iface`)

- Trait `NotificationRulesProvider`: Definiert die Schnittstelle zum Laden und Speichern von Regelwerken.
    - Methoden: `async fn load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`, `async fn save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`.
- Implementierung `FilesystemNotificationRulesProvider`: Speichert Regeln im Dateisystem, typischerweise als JSON.

### 1.5. Modul: `domain::global_settings_and_state_management`

Verwaltet globale Desktop-Einstellungen und deren Persistenz. Dieses Modul ist zentral für die Konfiguration vieler Aspekte der Desktop-Umgebung.

Referenzierte Dokumente: B3 Domänenschicht.md, B4 Domänenschicht.md

#### 1.5.1. Datenstrukturen (`domain::global_settings_and_state_management::types`)

- `GlobalDesktopSettings`: Die Hauptstruktur, die alle globalen Einstellungen enthält.
    - Felder: `appearance: AppearanceSettings`, `workspace_config: WorkspaceSettings`, `input_behavior: InputBehaviorSettings`, `power_management_policy: PowerManagementPolicySettings`, `default_applications: DefaultApplicationsSettings`.
    - Alle Felder sind mit `#[serde(default)]` annotiert. Dies ist eine wichtige Designentscheidung, die die Robustheit des Systems gegenüber unvollständigen oder fehlerhaften Konfigurationsdateien erhöht, da für fehlende Abschnitte Standardwerte verwendet werden.
- Detaillierte Unterstrukturen (z.B. `AppearanceSettings`, `FontSettings`) und Enums (z.B. `ColorScheme`, `MouseAccelerationProfile`) sind wie in den referenzierten Dokumenten B3 und B4 definiert.
- **Validierung**: Jede Einstellungs-Unterstruktur implementiert eine Methode `fn validate(&self) -> Result<(), String>`. Die `GlobalDesktopSettings`-Struktur verfügt über eine Methode `validate_recursive()`, die die Validierung für alle Unterstrukturen aufruft und so die Datenintegrität sicherstellt.

#### 1.5.2. Pfade (`domain::global_settings_and_state_management::paths`)

- `SettingPath`: Ein hierarchischer Enum zur typsicheren Adressierung einzelner Einstellungen innerhalb der `GlobalDesktopSettings`-Struktur.
    - Implementiert `Display` (zur Konvertierung in einen lesbaren String-Pfad, z.B. für UI oder Logging) und `TryFrom<&str>` (zum Parsen eines String-Pfades zurück in den Enum).
    - Die Verwendung eines typsicheren Pfad-Enums anstelle von reinen Strings reduziert das Risiko von Tippfehlern und Laufzeitfehlern beim Zugriff auf Einstellungen.

#### 1.5.3. Fehlerbehandlung (`domain::global_settings_and_state_management::errors`)

- `GlobalSettingsError`: Enum für Fehler im Einstellungsmodul.
    - Varianten: `PathNotFound { path: SettingPath }`, `InvalidValueType { path: SettingPath, expected: String, found: String }`, `ValidationError { path: SettingPath, reason: String }`, `SerializationError { source: serde_json::Error }`, `DeserializationError { source: serde_json::Error }`, `PersistenceError(#[from] GlobalSettingsPersistenceError)`.
    - Die Verwendung von `SettingPath` in den Fehlervarianten ermöglicht eine präzise Fehlerlokalisierung.

#### 1.5.4. Persistenz-Interface (`domain::global_settings_and_state_management::persistence_iface`)

- Trait `SettingsPersistenceProvider`: Definiert die Schnittstelle zum Laden und Speichern der globalen Einstellungen.
    - Methoden: `async fn load_global_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsPersistenceError>`, `async fn save_global_settings(&self, settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsPersistenceError>`.
    - Anmerkung: Die Verwendung eines spezifischen `GlobalSettingsPersistenceError` ermöglicht eine saubere `#[from]`-Konvertierung in `GlobalSettingsError::PersistenceError`.
- Implementierung `FilesystemSettingsProvider`: Nutzt `novade_core::config::ConfigServiceAsync` für Dateioperationen.

#### 1.5.5. API (`domain::global_settings_and_state_management::service::GlobalSettingsService`)

- Trait `GlobalSettingsService`: Die Hauptschnittstelle für den Zugriff auf und die Manipulation von globalen Einstellungen.
    - Methoden: `async fn load_settings(&self) -> Result<(), GlobalSettingsError>`, `async fn save_settings(&self) -> Result<(), GlobalSettingsError>`, `fn get_current_settings(&self) -> Arc<GlobalDesktopSettings>`, `async fn update_setting(&self, path: SettingPath, value: serde_json::Value) -> Result<(), GlobalSettingsError>`, `fn get_setting(&self, path: &SettingPath) -> Result<serde_json::Value, GlobalSettingsError>`, `async fn reset_to_defaults(&self) -> Result<(), GlobalSettingsError>`, `fn subscribe_to_setting_changes(&self) -> tokio::sync::broadcast::Receiver<SettingChangedEvent>`.
- Implementierung `DefaultGlobalSettingsService`: Hält die Einstellungen in einem `Arc<tokio::sync::RwLock<GlobalDesktopSettings>>`, einen `Arc<dyn SettingsPersistenceProvider>` und einen `tokio::sync::broadcast::Sender` für Events.

#### 1.5.6. Events (`domain::global_settings_and_state_management::events`)

- `SettingChangedEvent { path: SettingPath, new_value: serde_json::Value }`: Wird publiziert, wenn eine Einstellung geändert wird.
- `SettingsLoadedEvent { settings: Arc<GlobalDesktopSettings> }`: Wird publiziert, nachdem die Einstellungen erfolgreich geladen wurden.
- `SettingsSavedEvent`: Wird publiziert, nachdem die Einstellungen erfolgreich gespeichert wurden.

### 1.6. Modul: `domain::window_management_policy`

Dieses Modul definiert High-Level-Regeln und Richtlinien für die Fensterplatzierung, Tiling-Verhalten, Snapping und Fokusmanagement. Es entkoppelt die Policy-Entscheidungen von den Mechanismen der Fensterverwaltung, die im Compositor implementiert sind.

Referenzierte Dokumente: B3 Domänenschicht.md

#### 1.6.1. Datenstrukturen (`domain::window_management_policy::types`)

- `TilingMode`: Enum für verschiedene Tiling-Strategien (z.B. `Manual`, `Columns`, `Rows`, `Spiral`, `MaximizedFocused`).
- `GapSettings`: Definiert Abstände um Bildschirme und zwischen Fenstern.
    - Felder: `screen_outer_horizontal: u16`, `screen_outer_vertical: u16`, `window_inner: u16`.
- `WindowSnappingPolicy`: Konfiguriert das Snapping-Verhalten von Fenstern.
    - Felder: `snap_to_screen_edges: bool`, `snap_to_other_windows: bool`, `snap_to_workspace_gaps: bool`, `snap_distance_px: u16`.
- `WindowGroupingPolicy`: Einstellungen für manuelles Gruppieren von Fenstern.
    - Felder: `enable_manual_grouping: bool`.
- `NewWindowPlacementStrategy`: Enum für die Platzierungsstrategie neuer Fenster (z.B. `Smart`, `Center`, `Cascade`, `UnderMouse`).
- `FocusStealingPreventionLevel`: Enum zur Steuerung, wie aggressiv das System "Focus Stealing" verhindert (`None`, `Moderate`, `Strict`).
- `FocusPolicy`: Umfassende Einstellungen zum Fokusverhalten.
    - Felder: `focus_follows_mouse: bool`, `click_to_focus: bool`, `focus_new_windows_on_creation: bool`, `focus_new_windows_on_workspace_switch: bool`, `focus_stealing_prevention: FocusStealingPreventionLevel`.
- `WindowPolicyOverrides`: Optionale, fensterspezifische Überschreibungen globaler Policies (z.B. `preferred_tiling_mode`, `is_always_floating`).
- `WorkspaceWindowLayout`: Beschreibt das berechnete Layout aller Fenster auf einem Arbeitsbereich.
    - Felder: `window_geometries: HashMap<WindowIdentifier, novade_core::types::RectInt>`, `occupied_area: Option<novade_core::types::RectInt>`, `tiling_mode_applied: TilingMode`.
- `WindowLayoutInfo`: Enthält Informationen von einem Fenster, die für Layout-Berechnungen relevant sind.
    - Felder: `id: WindowIdentifier`, `requested_min_size: Option<novade_core::types::Size<u32>>`, `is_fullscreen_requested: bool`, `is_maximized_requested: bool`.

#### 1.6.2. Fehlerbehandlung (`domain::window_management_policy::errors`)

- `WindowPolicyError`: Enum für Fehler im Policy-Modul.
    - Varianten: `LayoutCalculationError { details: String }`, `InvalidPolicyConfiguration { setting_path: Option<String>, reason: String }`, `WindowNotFoundForPolicy { window_id: WindowIdentifier }`.

#### 1.6.3. API (`domain::window_management_policy::service::WindowManagementPolicyService`)

- Trait `WindowManagementPolicyService`: Definiert die Schnittstelle für Policy-Abfragen und Layout-Berechnungen.
    - Methoden: `async fn calculate_workspace_layout(&self, workspace_id: WorkspaceId, windows_info: Vec<WindowLayoutInfo>, available_area: novade_core::types::RectInt) -> Result<WorkspaceWindowLayout, WindowPolicyError>`, `async fn get_initial_window_geometry(&self, app_id: Option<ApplicationId>, title: Option<String>, requested_size: Option<novade_core::types::Size<u32>>, output_area: novade_core::types::RectInt) -> Result<novade_core::types::RectInt, WindowPolicyError>`, `async fn calculate_snap_target(&self, window_id: WindowIdentifier, current_geometry: novade_core::types::RectInt, workspace_layout: &WorkspaceWindowLayout, output_area: novade_core::types::RectInt) -> Option<novade_core::types::RectInt>`, `async fn get_effective_tiling_mode_for_workspace(&self, workspace_id: WorkspaceId) -> Result<TilingMode, WindowPolicyError>`, `async fn get_effective_gap_settings_for_workspace(&self, workspace_id: WorkspaceId) -> Result<GapSettings, WindowPolicyError>`, `async fn get_effective_snapping_policy(&self) -> Result<WindowSnappingPolicy, WindowPolicyError>`, `async fn get_effective_focus_policy(&self) -> Result<FocusPolicy, WindowPolicyError>`, `async fn get_effective_new_window_placement_strategy(&self) -> Result<NewWindowPlacementStrategy, WindowPolicyError>`.
- Implementierung `DefaultWindowManagementPolicyService`: Hält einen `Arc<dyn GlobalSettingsService>`, um auf die globalen Policy-Einstellungen zuzugreifen. Diese Abhängigkeit ermöglicht dynamische Policy-Änderungen. Die Komplexität der `calculate_workspace_layout`-Funktion erfordert sorgfältige Implementierung und gründliche Tests, insbesondere im Hinblick auf verschiedene Tiling-Modi und Fenster-Overrides.

### 1.7. Modul: `domain::common_events`

Definiert Domänen-übergreifende Events, die von verschiedenen Modulen publiziert oder abonniert werden können.

Referenzierte Dokumente: B3 Domänenschicht.md

#### 1.7.1. Datenstrukturen (`domain::common_events::events`)

- `UserActivityType`: Enum zur Klassifizierung von Benutzeraktivitäten.
    - Varianten: `MouseMoved`, `MouseClicked`, `MouseWheelScrolled`, `KeyPressed`, `TouchInteraction`, `WorkspaceSwitched`, `ApplicationFocused`, `WindowOpened`, `WindowClosed`. Die Granularität dieser Typen ist für die Implementierung von Features wie Inaktivitäts-Timer oder Nutzungsstatistiken relevant.
- `UserActivityDetectedEvent`: Event, das bei Erkennung einer Benutzeraktivität ausgelöst wird.
    - Felder: `event_id: Uuid`, `timestamp: DateTime<Utc>`, `activity_type: UserActivityType`, `current_session_state: UserSessionState`, `active_application_id: Option<ApplicationId>`, `active_workspace_id: Option<WorkspaceId>`.
- `ShutdownReason`: Enum, das den Grund für ein Herunterfahren des Systems angibt.
    - Varianten: `UserRequest`, `PowerButtonPress`, `LowBattery`, `SystemUpdate`, `ApplicationRequest`, `OsError`, `Unknown`.
- `SystemShutdownInitiatedEvent`: Event, das ausgelöst wird, wenn ein System-Shutdown initiiert wird.
    - Felder: `event_id: Uuid`, `timestamp: DateTime<Utc>`, `reason: ShutdownReason`, `is_reboot: bool`, `delay_seconds: Option<u32>`, `message: Option<String>`.

### 1.8. Modul: `domain::shared_types`

Stellt wiederverwendbare, domänenspezifische Typen bereit, die in mehreren Domänenmodulen verwendet werden, um Konsistenz zu fördern und Duplizierung zu vermeiden.

Referenzierte Dokumente: B3 Domänenschicht.md

#### 1.8.1. Datenstrukturen (`domain::shared_types::types`)

- `ApplicationId`: Wrapper für `String` zur eindeutigen Identifizierung von Anwendungen.
- `UserSessionState`: Enum zur Repräsentation des Zustands der Benutzersitzung.
    - Varianten: `Active`, `Locked`, `Idle`.
- `ResourceIdentifier`: Eine generische Struktur zur Identifizierung von Ressourcen innerhalb des Systems.
    - Felder: `r#type: String` (z.B. "window", "workspace"), `id: String`, `label: Option<String>`.

Die klare Definition dieser gemeinsam genutzten Typen ist grundlegend für die Interoperabilität und das korrekte Zusammenspiel der verschiedenen Domänenmodule.

**Tabelle 1: Domain Layer Modules Overview**

|   |   |   |
|---|---|---|
|**Modul-Pfad**|**Kernverantwortlichkeit**|**Wichtige Services/Entitäten**|
|`domain::theming`|Verwaltet alle Aspekte des visuellen Stylings, der Theme-Anwendung und der Token-Auflösung.|`ThemingEngine`, `ThemeDefinition`, `AppliedThemeState`, `TokenIdentifier`, `TokenValue`|
|`domain::workspaces`|Logik und Verwaltung von Arbeitsbereichen ("Spaces"), inklusive Fensterzuweisung und Persistenz.|`WorkspaceManagerService`, `Workspace`, `WorkspaceId`, `WindowIdentifier`|
|`domain::user_centric_services::ai_interaction`|Handhabt KI-gestützte Interaktionen, Einwilligungsmanagement und KI-Modellprofile.|`AIInteractionLogicService`, `AIInteractionContext`, `AIConsent`, `AIModelProfile`|
|`domain::user_centric_services::notifications_core`|Kernlogik für das Erstellen, Speichern, Filtern und Interagieren mit Benachrichtigungen.|`NotificationService`, `Notification`, `NotificationInput`, `NotificationFilterCriteria`|
|`domain::notifications_rules`|Ermöglicht regelbasierte Verarbeitung und Modifikation von Benachrichtigungen.|`NotificationRulesEngine`, `NotificationRule`, `RuleCondition`, `RuleAction`|
|`domain::global_settings_and_state_management`|Verwaltung globaler Desktop-Einstellungen, deren Persistenz und Validierung.|`GlobalSettingsService`, `GlobalDesktopSettings`, `SettingPath`|
|`domain::window_management_policy`|Definiert High-Level-Regeln für Fensterplatzierung, Tiling, Snapping und Fokus.|`WindowManagementPolicyService`, `TilingMode`, `FocusPolicy`, `WorkspaceWindowLayout`|
|`domain::common_events`|Definiert Domänen-übergreifende Events wie Benutzeraktivität oder System-Shutdown.|`UserActivityDetectedEvent`, `SystemShutdownInitiatedEvent`|
|`domain::shared_types`|Stellt wiederverwendbare domänenspezifische Typen bereit.|`ApplicationId`, `UserSessionState`, `ResourceIdentifier`|

## 2. Wayland/Smithay-Integration (Systemschicht-Perspektive)

Dieser Abschnitt beschreibt, wie die Systemschicht, insbesondere der Wayland-Compositor, der mit dem Smithay-Toolkit implementiert wird, mit Wayland-Protokollen umgeht und mit der oben definierten Domänenschicht interagiert. Die korrekte Integration ist entscheidend für die Funktionalität und Stabilität des Desktops.

Referenzierte Dokumente: C1 System Implementierungsplan.md bis C4 Systemschicht.md, 3. System-Details.md.

### 2.1. Kern-Compositor-Struktur (`system::compositor::core::state::DesktopState`)

`DesktopState` ist die zentrale Zustandsstruktur des Compositors. Sie implementiert die verschiedenen Handler-Traits von Smithay und hält sowohl Smithay-spezifische Zustände als auch Handles zu den Domänendiensten. Diese Struktur ist das Herzstück der Compositor-Implementierung und agiert als zentraler Dispatcher und State-Manager für Wayland-bezogene Operationen.1 Die Verwendung einer zentralen, veränderbaren Zustandsstruktur, die an Callbacks übergeben wird, ist ein von Smithay empfohlenes Muster, das durch `calloop` ermöglicht wird und die Notwendigkeit komplexer Synchronisationsmechanismen reduziert.2

- **Wichtige Felder** (Auswahl, basierend auf typischer Smithay-Architektur):
    - `display_handle: DisplayHandle`: Das zentrale Handle zur Wayland-Display-Instanz, notwendig für die Erstellung von Globals und die Client-Kommunikation.5
    - `loop_handle: LoopHandle<'static, Self>`: Handle zum `calloop`-Event-Loop, der den Compositor antreibt.
    - `clock: Clock<u64>`: Eine Zeitquelle für den Compositor.
    - `compositor_state: CompositorState`: Verwaltet `wl_compositor`- und `wl_subcompositor`-bezogene Zustände.6
    - `shm_state: ShmState`: Verwaltet `wl_shm`-bezogene Zustände für Shared Memory Buffer.8
    - `xdg_shell_state: XdgShellState`: Verwaltet Zustände für das `xdg_shell`-Protokoll (Fenster, Popups).9
    - `output_manager_state: OutputManagerState`: Verwaltet `wl_output`- und `zxdg_output_v1`-Zustände.16
    - `seat_state: SeatState<Self>`: Verwaltet `wl_seat`-Zustände und Eingabefähigkeiten.9
    - `seat: Seat<Self>`: Die konkrete Seat-Instanz.
    - `data_device_state: DataDeviceState`: Verwaltet Zustände für `wl_data_device` (Clipboard, Drag & Drop).8
    - `space: Space<WindowElement>`: Smithays 2D-Raum zur Verwaltung von Fenstern, deren Stapelreihenfolge und zum Rendern.1 `WindowElement` ist dabei ein Enum, das verschiedene Fenstertypen wie native Wayland-Fenster (`Window`), X11-Fenster (`X11Surface`) und Layer-Shell-Oberflächen (`LayerSurface`) kapselt.
    - `windows: HashMap<DomainWindowIdentifier, Arc<WindowElement>>`: Ein Mapping von den abstrakten `DomainWindowIdentifier` der Domänenschicht zu den konkreten `WindowElement`-Instanzen des Compositors. Dies ist eine entscheidende Brücke zwischen Domänen- und Systemschicht.
    - Domänen-Service-Handles: `Arc<dyn WindowManagementPolicyService>`, `Arc<dyn WorkspaceManagerService>`, `Arc<dyn GlobalSettingsService>`. Diese `Arc`-Handles ermöglichen den Zugriff auf die Domänenlogik aus den Wayland-Handlern heraus. Die Thread-Sicherheit dieser Interaktion muss gewährleistet sein, insbesondere da Domänendienste asynchron sind, während Wayland-Handler typischerweise synchron im `calloop`-Thread ausgeführt werden.33
    - `event_bridge: Arc<SystemEventBridge>`: Ein Mechanismus zur internen Event-Kommunikation innerhalb der Systemschicht und potenziell zur Weiterleitung von Systemereignissen an die Domänenschicht.

Obwohl `DesktopState` viele Verantwortlichkeiten bündelt, was Bedenken hinsichtlich eines "God Object" 29 aufwerfen könnte, ist dieses Muster im Kontext von Smithay und `calloop` üblich und wird durch die Verwendung von Delegate-Makros handhabbar gemacht. Diese Makros leiten die Protokollbehandlung an spezifische Zustands-Subobjekte und deren Handler weiter, anstatt die gesamte Logik in `DesktopState` selbst zu implementieren.1

### 2.2. Wayland-Protokoll-Implementierungen

Die `DesktopState`-Struktur implementiert verschiedene Handler-Traits von Smithay, um die Wayland-Protokolle zu bedienen.

- **`wl_compositor`, `wl_subcompositor`**:
    
    - Gehandhabt durch `CompositorState` und die Implementierung von `CompositorHandler` in `DesktopState`.4
    - `CompositorHandler::commit(surface: &WlSurface)`: Diese Methode wird bei jedem `wl_surface.commit` eines Clients aufgerufen. Sie ist verantwortlich für:
        - Aktualisierung von `SurfaceData` (Puffer, Schadensregionen (Damage)).
        - Benachrichtigung von `domain::window_management_policy` oder `domain::workspaces` bei relevanten Änderungen (z.B. könnte eine neue Puffergröße das Layout beeinflussen). Diese Interaktion ist ein Beispiel für die Kommunikation von der Systemschicht zur Domänenschicht für Policy-Entscheidungen.
        - Markierung der Oberfläche für eine Neuzeichnung durch den Renderer.
- **`wl_shm`**:
    
    - Gehandhabt durch `ShmState` und die Implementierung von `ShmHandler` in `DesktopState`.4
    - `BufferHandler::buffer_destroyed(buffer: &WlBuffer)`: Informiert den Renderer, dass die mit diesem Puffer verbundenen Ressourcen freigegeben werden können. Dies ist wichtig für das Speichermanagement.
- **`xdg_shell` (`xdg_wm_base`, `xdg_surface`, `xdg_toplevel`, `xdg_popup`)**:
    
    - Gehandhabt durch `XdgShellState` und die Implementierung von `XdgShellHandler` in `DesktopState`.4
    - `XdgShellHandler::new_toplevel(surface: ToplevelSurface)`: Ein kritischer Integrationspunkt.
        1. Erstellt ein `WindowElement::Wayland(Window::new(ToplevelKind::Xdg(surface)))`. Das `Window` hier ist eine Smithay-Abstraktion.29
        2. Generiert einen `DomainWindowIdentifier` für die Domänenschicht.
        3. Ruft `domain::window_management_policy::get_initial_window_geometry()` auf, um die initiale Position und Größe des Fensters gemäß den globalen und anwendungsspezifischen Richtlinien zu bestimmen.
        4. Ruft `domain::workspaces::assign_window_to_active_workspace()` auf, um das neue Fenster dem aktuell aktiven Arbeitsbereich zuzuordnen.
        5. Konfiguriert und mappt das Fenster im `Space`.
    - `XdgShellHandler::map_toplevel(surface: &ToplevelSurface)`: Informiert `domain::workspaces`, dass das Fenster nun sichtbar (gemappt) ist.
    - Client-Anfragen wie `set_title`, `set_app_id`, `set_maximized`, `move`, `resize` werden an `domain::window_management_policy` delegiert. Die Domänenschicht entscheidet über die Policy-konforme Reaktion. Das Ergebnis dieser Entscheidung (z.B. neue Geometrie, neuer Zustand) wird dann vom Compositor auf das `ToplevelSurface` angewendet, typischerweise durch Senden eines `configure`-Events an den Client (`toplevel_surface.send_configure(...)`).
    - **Domäne -> System für Layout**: `domain::window_management_policy` gibt eine `WorkspaceWindowLayout`-Struktur zurück. Ein systemseitiger Mechanismus (z.B. `system::window_mechanics::apply_workspace_layout`) iteriert über die `window_geometries` dieser Struktur und ruft `toplevel_surface.send_configure(...)` für jedes betroffene Fenster auf, um die vom Domänenmodul berechneten Größen und Positionen anzuwenden.
    - Die Synchronisation von Zuständen wie "maximiert" oder "aktiv" zwischen `XdgToplevelSurfaceData` und einer internen `ManagedWindow`-Repräsentation erfolgt über den Configure-Ack-Mechanismus.1 Der Compositor sendet einen `configure`-Event mit dem neuen Zustand, und der Client muss diesen mit `ack_configure` bestätigen, bevor der Zustand als angewendet gilt.
- **`wlr-layer-shell-unstable-v1`**:
    
    - Gehandhabt durch `WlrLayerShellState` und die Implementierung von `LayerShellHandler` in `DesktopState`.4
    - `LayerShellHandler::new_layer_surface(surface: LayerSurface,...)`: Erstellt ein `WindowElement::Layer(surface)`. Informiert die Domänenschicht (ggf. ein spezifischer Service für Shell-Elemente wie Panels oder Hintergrundbilder). Die Platzierung im `Space` erfolgt gemäß den Layer-Shell-Regeln (Layer, Anchor, Exclusive Zone). Die Interaktion mit `PopupManager` und die Handhabung von `exclusive_zone` sind hier relevant.53
- **`wl_output` / `xdg-output-unstable-v1`**:
    
    - Gehandhabt durch `OutputManagerState` und die Implementierung von `OutputHandler` in `DesktopState`.2
    - Änderungen an Outputs (Hotplug, Modusänderung) werden vom `OutputHandler` verarbeitet.
    - Diese Änderungen werden an `domain::global_settings_and_state_management` gemeldet (z.B. um Persistenz anzustoßen oder Display-Profile zu aktualisieren) und an `domain::workspaces` (da Änderungen der Output-Konfiguration das Fensterlayout beeinflussen können).
    - Die Implementierung von `zwlr_output_manager_v1` (Teil von `wlr-output-management-unstable-v1` 2) in `system::outputs::output_manager` (oder einer ähnlichen Struktur) würde die `apply`-Methode dieses Protokolls implementieren. Bei einem Aufruf von `apply` wird `Output::change_current_state()` aufgerufen. Die Domänenschicht wird über ein `OutputConfigurationChangedEvent` informiert. Die korrekte Handhabung von Serials ist hierbei entscheidend für die atomare Anwendung von Konfigurationen.61
- **`wl_seat` / Eingabeprotokolle (`wl_keyboard`, `wl_pointer`, `wl_touch`)**:
    
    - Gehandhabt durch `SeatState`, `SeatHandler`, `KeyboardHandle`, `PointerHandle`, `TouchHandle`.4
    - Eingabe-Events von `system::input` (typischerweise `libinput` 81) werden verarbeitet.
    - `SeatHandler::focus_changed(seat: &Seat<Self>, focused: Option<&WlSurface>)`: Identifiziert den `DomainWindowIdentifier` für die fokussierte Oberfläche. Informiert `domain::window_management_policy` oder `domain::workspaces` über die Fokusänderung. Dies ist ein kritischer Punkt für die Fokusverwaltung.84
    - `KeyboardHandle::input(keycode, state,...)`: Sendet `wl_keyboard.key`-Events an den fokussierten Client.
    - `PointerHandle::motion(...)`: Sendet `wl_pointer.motion`, `enter`, `leave`-Events.
    - **Domäne -> System für Fokus**: `domain::window_management_policy` kann einen Fokuswechsel anstoßen (z.B. als Reaktion auf eine Policy oder einen Benutzerbefehl). Ein systemseitiger Mechanismus (z.B. `system::window_mechanics::set_application_focus`) ruft dann `keyboard.set_focus(...)` auf, um den Fokus im Wayland-Seat zu setzen.

### 2.3. Smithay-Typen und ihre Verwendung

Die Integration mit Smithay erfordert die korrekte Verwendung und Erweiterung seiner Kern-Typen.

- **`DisplayHandle`**: Das zentrale Handle zur Wayland-Display-Instanz. Wird für die Erstellung von Globals, Client-Kommunikation etc. verwendet.5
    
- **`CompositorState`**: Verwaltet `wl_compositor` und `wl_subcompositor` Globals und Client-Zustände.6
    
- **`ShmState`**: Verwaltet das `wl_shm` Global und SHM-Puffer.
    
- **`XdgShellState`**: Verwaltet das `xdg_wm_base` Global und XDG-Oberflächen (Toplevels, Popups).9
    
- **`OutputManagerState`**: Verwaltet `wl_output` und `zxdg_output_manager_v1` Globals.16
    
- **`SeatState<DesktopState>` / `Seat<DesktopState>`**: Verwalten `wl_seat` und die Eingabefähigkeiten (Tastatur, Maus, Touch). `SeatHandler` wird von `DesktopState` implementiert.9
    
- **`KeyboardHandle`, `PointerHandle`, `TouchHandle`**: Abstraktionen für die Interaktion mit spezifischen Eingabegeräten des Seats.
    
- **`Space<WindowElement>`**: Smithays 2D-Raum zur Verwaltung von Fenstern, deren Stapelreihenfolge und zum Rendern.1 `WindowElement` muss den `smithay::desktop::Window` Trait implementieren.29
    
- **`SurfaceData`** (aus `smithay::wayland::compositor`): Wird an `WlSurface`-Instanzen angehängt und speichert Pufferinformationen, die zugewiesene Rolle, Schadensregionen (Damage) etc..7 NovaDE wird dies erweitern (z.B. über `UserDataMap` oder eine dedizierte Erweiterungsstruktur wie `SurfaceDataExt`), um anwendungsspezifische Daten wie `DomainWindowIdentifier` und Renderer-spezifische Textur-Handles zu speichern. Die Verwaltung von doppelt gepuffertem Zustand und Commit-Hooks (Pre/Post) ist ein Kernaspekt von `SurfaceData`.4
    
- **`ClientData`** (aus `smithay::reexports::wayland_server::backend`): Wird an `Client`-Instanzen angehängt und kann Client-spezifische Zustände speichern (z.B. `CompositorClientState`, `XdgWmBaseClientData`).
    
- **Änderungen an Smithay-Typen und deren Konsequenzen**:
    
    - Das direkte Ändern von Smithay-Typen ist in der Regel nicht vorgesehen, da sie Teil der Bibliothek sind. Die Erweiterung erfolgt primär durch die Verwendung von `UserDataMap` an Objekten wie `WlSurface` oder `Client` oder durch die Implementierung der von Smithay bereitgestellten Handler-Traits.
    - Wenn Smithay eine neue Version mit geänderten Typen oder Trait-Signaturen veröffentlicht, müssen die Handler-Implementierungen und die Nutzung dieser Typen in NovaDE entsprechend angepasst werden. Dies erfordert sorgfältige Migration und umfassende Tests, um die Kompatibilität und korrekte Funktionalität sicherzustellen.
    - Das `UserDataMap`-Muster ist der primäre Mechanismus, um anwendungsspezifische Daten mit Smithay-Objekten zu assoziieren, ohne die Typen selbst modifizieren zu müssen. Dies ist entscheidend für die Aufrechterhaltung einer sauberen Trennung zwischen der Bibliothekslogik und der anwendungsspezifischen Logik des Compositors.

### 2.4. Kommunikation Domäne <-> Compositor

Die Kommunikation zwischen der Domänenschicht und der Systemschicht (Compositor) ist bidirektional und erfolgt über definierte Schnittstellen, primär Events und Service-Aufrufe.

- **Compositor (System) -> Domäne**:
    
    - **Events**: Der Compositor generiert Systemereignisse, die für die Domänenschicht relevant sind. Diese werden typischerweise über einen `SystemEventBridge` oder einen ähnlichen Mechanismus an die Domänenschicht weitergeleitet.
        - Neues Fenster (z.B. in `XdgShellHandler::new_toplevel`): Sendet ein `WindowCreatedEvent { domain_id, initial_geometry, app_id, title }` an `domain::workspaces::manager` oder einen allgemeinen Event-Bus.
        - Fenster geschlossen (z.B. in `XdgShellHandler::toplevel_destroyed`): Sendet ein `WindowClosedEvent { domain_id }`.
        - Fokusänderung durch Benutzer (z.B. in `SeatHandler::focus_changed`): Sendet ein `FocusChangedEvent { new_focus_domain_id, old_focus_domain_id }`.
        - Benutzereingabe für spezielle Funktionen (z.B. Befehlspalette): Kann ein spezifisches Event senden oder direkt einen Domänendienst aufrufen.
        - Output-Änderung (z.B. in `OutputHandler`): Sendet ein `OutputConfigurationChangedEvent {... }`.
    - **Service-Aufrufe (indirekt)**: Bei bestimmten Aktionen kann der Compositor Domänenlogik benötigen, z.B. um die Standardplatzierung für ein neues Fenster zu erfragen (`domain::window_management_policy::get_initial_window_geometry`).
- **Domäne -> Compositor (System)**:
    
    - **Service-Aufrufe**: Die Domänenschicht kann Aktionen im Compositor auslösen, indem sie Methoden auf Schnittstellen aufruft, die von der Systemschicht bereitgestellt werden.
        - `domain::window_management_policy` gibt eine `WorkspaceWindowLayout`-Struktur an einen systemseitigen Mechanismus (z.B. `system::window_mechanics`).
        - `system::window_mechanics::apply_workspace_layout` ruft dann spezifische Smithay-Funktionen auf, z.B. `toplevel_surface.send_configure(...)` oder `space.map_window(...)`.
        - `domain::workspaces::manager` ruft z.B. `system::window_mechanics::set_application_focus` auf, was intern `keyboard.set_focus(...)` verwendet.
    - Die Systemschicht stellt hierfür klar definierte Traits bereit (z.B. eine `WindowManipulationApi`), die von Domänendiensten genutzt werden können. Diese API-Aufrufe werden dann in spezifische Smithay-Operationen übersetzt, um die gewünschten Aktionen im Compositor auszuführen.

Diese klare Trennung der Kommunikationspfade und -mechanismen ist entscheidend für die Entkopplung der Schichten und die Aufrechterhaltung einer sauberen Architektur.

## 3. Protokoll-Implementierungen (D-Bus, XDG Desktop Portals, MCP)

Die Systemschicht ist verantwortlich für die Implementierung von Clients und Servern für verschiedene externe Protokolle und deren Integration mit der Domänenschicht, um eine umfassende Desktop-Funktionalität zu gewährleisten.

### 3.1. D-Bus (`zbus`)

Die D-Bus-Integration erfolgt über die `zbus`-Bibliothek, die moderne asynchrone D-Bus-Kommunikation in Rust ermöglicht.87 Die Wahl von `zbus` gegenüber älteren Alternativen wie `dbus-rs` ist auf dessen asynchrone Natur und bessere Integration in moderne Rust-Ökosysteme zurückzuführen.

- **Module in `system::dbus_interfaces`**:
    
    - `connection_manager`: Stellt einen `DBusConnectionManager` bereit, der den Zugriff auf den Session-Bus (`session_bus()`) und den System-Bus (`system_bus()`) kapselt und vereinfacht.89
    - **Clients** (z.B. `upower_client`, `logind_client`, `network_manager_client`, `secrets_service_client`, `policykit_client`):
        - Definieren `zbus::proxy`-Strukturen für die jeweiligen D-Bus-Interfaces der externen Dienste (z.B. `org.freedesktop.UPower` 90, `org.freedesktop.NetworkManager` 91).
        - Implementieren einen Service-Wrapper (z.B. `UPowerClientService`), der den Proxy kapselt und eine saubere API für die Domänenschicht bereitstellt.
        - Abonnieren relevante D-Bus-Signale (z.B. `PropertiesChanged` von UPower) und konvertieren diese entweder in interne `SystemLayerEvents` (die über den `SystemEventBridge` publiziert werden) oder rufen direkt Methoden von Domänendiensten auf.
        - Bieten asynchrone Methoden für die Domänenschicht, um D-Bus-Methoden aufzurufen (z.B. `NetworkManager.ActivateConnection`) oder Eigenschaften abzufragen (z.B. `UPower.OnBattery`).
    - **Server** (z.B. `notifications_server`):
        - Implementiert das `org.freedesktop.Notifications`-Interface unter Verwendung des `#[dbus_interface]`-Makros von `zbus`.94
        - Ruft Methoden des `domain::user_centric_services::NotificationService` auf, um Aktionen wie das Anzeigen oder Schließen von Benachrichtigungen auszuführen.
        - Abonniert Domänen-Events (z.B. `NotificationDismissedEvent`, `NotificationActionInvokedEvent` aus `domain::user_centric_services::notifications_core::events`) und sendet entsprechende D-Bus-Signale (`NotificationClosed`, `ActionInvoked`) an D-Bus-Clients.
        - Verwaltet ein ID-Mapping zwischen den `u32`-basierten D-Bus-Benachrichtigungs-IDs und den `Uuid`-basierten internen `NotificationId`s der Domänenschicht.
- **Integration mit der Domäne**:
    
    - Domänendienste (z.B. `PowerManagementPolicy` in `domain::global_settings_and_state_management`) abonnieren die von den D-Bus-Client-Wrappern publizierten `SystemLayerEvents` oder halten direkte Handles zu den Client-Services, um auf Systemänderungen zu reagieren oder Aktionen auszulösen.
    - Domänendienste (z.B. `NotificationService`) werden von den D-Bus-Server-Implementierungen aufgerufen, um Anfragen von externen Anwendungen zu bedienen.

### 3.2. XDG Desktop Portals (`system::portals`)

Implementiert die Backend-Logik für ausgewählte XDG Desktop Portals, um sandboxed Anwendungen den Zugriff auf Systemressourcen auf eine kontrollierte Weise zu ermöglichen. Die `ashpd`-Bibliothek 96 dient hierbei als Referenz oder kann direkt genutzt werden, falls sie Backend-Logik für Portalserver bereitstellt; andernfalls erfolgt eine direkte `zbus`-Implementierung der Portal-D-Bus-Interfaces.

- Definiert einen Trait `SystemPortalInterface` (oder ähnlich benannt), den die D-Bus-Objekte der Portale (die in einem separaten Prozess oder Dienst laufen könnten) aufrufen.
- **`FileChooser` Portal (`org.freedesktop.portal.FileChooser`)** 96:
    - Empfängt `OpenFile`- oder `SaveFile`-Anfragen vom Portal-D-Bus-Objekt. Diese Anfragen enthalten typischerweise einen `WindowIdentifier`, um den Dialog korrekt dem anfragenden Anwendungsfenster zuzuordnen.97
    - Sendet einen Befehl an die UI-Schicht (über den `SystemEventBridge` oder eine dedizierte Schnittstelle), um einen nativen Dateidialog (z.B. mit GTK) anzuzeigen.
    - Empfängt das Ergebnis des Dateidialogs von der UI-Schicht und sendet es über D-Bus an den anfragenden Client zurück.
- **`Screenshot` Portal (`org.freedesktop.portal.Screenshot`)**:
    - Empfängt `Screenshot`- oder `PickColor`-Anfragen.
    - Interagiert mit `system::compositor::screencopy` (für Screenshots) oder einer spezifischen Compositor-Funktion (für die Farbpipette), um die angeforderte Aktion auszuführen.
    - Sendet das Ergebnis (Bilddaten oder Farbwert) über D-Bus zurück.

### 3.3. Model Context Protocol (MCP) (`system::mcp_client`)

Implementiert die Client-Seite des Model Context Protocol für die Interaktion mit KI-Modellen oder -Diensten, die dieses Protokoll verwenden. Die `mcp_client_rs`-Bibliothek 101 wird hierfür als Grundlage genutzt.

- Implementiert den Trait `SystemMcpService` aus der Domänenschicht.
- Nutzt `mcp_client_rs::McpClient` für die eigentliche Protokollkommunikation.
- **`connection_manager`**:
    - Verwaltet Verbindungen zu MCP-Servern, basierend auf `McpServerConfig`-Strukturen.
    - Kann lokale MCP-Server-Prozesse starten und deren `stdin`/`stdout` für die IPC verwalten, typischerweise unter Verwendung von `tokio::process::Command`.104
    - Holt API-Schlüssel für die Authentifizierung bei MCP-Servern über den `secrets_service_client` (siehe D-Bus-Integration).
- **`service::DefaultSystemMcpService`**:
    - Empfängt Anfragen (z.B. `CallToolParams`) vom `domain::user_centric_services::AIInteractionLogicService`.
    - Sendet diese Anfragen über `McpClient::send_request_json` an den entsprechenden MCP-Server.
    - Implementiert Timeout-Mechanismen für MCP-Anfragen.
    - Lauscht auf `McpClient::receive_message()` für Antworten und serverseitige Benachrichtigungen (Notifications).
    - Konvertiert MCP-Antworten und -Notifications in `McpClientSystemEvents` und publiziert diese über den `SystemEventBridge`. Der `AIInteractionLogicService` abonniert diese Events, um auf Ergebnisse oder serverseitige Updates zu reagieren. Die robuste Handhabung des Notification-Streams, inklusive Fehlerbehandlung und Deserialisierung, ist hierbei entscheidend.103

## 4. Implementierbare Lösungen

Dieser Abschnitt skizziert konkrete Implementierungsansätze für ausgewählte Komponenten und Interaktionen, um die Spezifikationen greifbarer zu machen.

### 4.1. Code-Skizzen (Englisch)

Die folgenden Code-Skizzen dienen zur Veranschaulichung der Struktur und Interaktion einiger Kernkomponenten. Sie sind nicht als vollständig kompilierbarer oder fehlerfreier Code gedacht, sondern sollen die in den Spezifikationen definierten Typen und Methoden im Kontext zeigen.

Hinweis zur Verwendung von Arc<Mutex<T>> und block_on in Handlern:

Die direkte Verwendung von Arc<Mutex<DesktopState>> und dessen Weitergabe an tokio::spawn muss sorgfältig auf Thread-Sicherheit und Deadlocks geprüft werden; oft sind spezifische Daten zu extrahieren oder Kanäle für die Kommunikation mit dem Haupt-Compositor-Thread zu verwenden.33 block_on in synchronen Smithay-Handlern zur Ausführung asynchroner Domänenlogik ist generell zu vermeiden. Stattdessen sollten Kommunikationsmuster wie Kanäle zwischen dem synchronen Handler-Thread und einem Tokio-Runtime-Thread verwendet werden, um Ergebnisse asynchroner Operationen zurück an den Handler zu leiten.107

Rust

```
// ==== Domain Layer: domain::workspaces::manager ====
// #[async_trait]
// pub trait WorkspaceManagerService: Send + Sync {
//     async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>;
//     //... other methods
// }

// pub struct DefaultWorkspaceManager {
//     internal: Arc<tokio::sync::Mutex<WorkspaceManagerInternalState>>,
// }

// impl WorkspaceManagerInternalState {
//     async fn set_active_workspace_impl(&mut self, id: WorkspaceId, current_active: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError> {
//         if!self.workspaces.contains_key(&id) {
//             return Err(WorkspaceManagerError::SetActiveWorkspaceNotFound(id));
//         }
//         if self.active_workspace_id == Some(id) {
//             return Ok(());
//         }
//         let old_id = self.active_workspace_id.take();
//         self.active_workspace_id = Some(id);
//         self.ordered_workspace_ids.retain(|ws_id| *ws_id!= id);
//         self.ordered_workspace_ids.insert(0, id); // Example: move to front
//         let event = WorkspaceEvent::ActiveWorkspaceChanged { old_id, new_id: id };
//         if self.event_publisher.send(event).is_err() {
//             tracing::warn!("No active subscribers for ActiveWorkspaceChanged event.");
//         }
//         // self.save_configuration_internal_locked().await?; // Persist change
//         Ok(())
//     }
// }

// ==== System Layer: system::compositor::core::state::DesktopState ====
// impl SeatHandler for DesktopState {
//     type KeyboardFocus = WlSurface;
//     type PointerFocus = WlSurface;
//     type TouchFocus = WlSurface;

//     fn seat_state(&mut self) -> &mut SeatState<Self> {
//         &mut self.seat_state
//     }

//     fn focus_changed(&mut self, seat: &Seat<Self>, focused: Option<&WlSurface>) {
//         let new_focus_domain_id = focused.and_then(|s| {
//             // Logic to get DomainWindowIdentifier from WlSurface UserData
//             // Example: s.data_map().get::<SurfaceDataExt>().map(|data_ext| data_ext.domain_id.clone())
//             None // Placeholder
//         });
//         tracing::debug!(seat = %seat.name(), new_focus =?new_focus_domain_id, "Keyboard focus changed (Wayland)");
//         // Notify domain layer (e.g., window_management_policy or workspace_manager)
//         // This might involve sending an event through the SystemEventBridge or calling a domain service
//         // let event = SystemLayerEvent::InputFocusChanged { new_focus_domain_id };
//         // self.event_bridge.publish(event);

//         // For XDG Shell activation (simplified)
//         if let Some(surface_to_activate) = focused {
//             if let Some(toplevel) = self.space.window_for_surface(surface_to_activate, WindowSurfaceType::TOPLEVEL)
//                .and_then(|win_elem| match win_elem.as_ref() { // Assuming WindowElement is Arc<ManagedWindow>
//                     WindowElement::Wayland(w) => w.toplevel().ok(),
//                     _ => None,
//                 }) {
//                 toplevel.send_configure(); // To signal state change (active)
//             }
//         }
//         // Deactivate previously focused window
//         //...
//     }

//     fn cursor_image(&mut self, _seat: &Seat<Self>, image: CursorImageStatus) {
//         // Update self.current_cursor_status for the renderer
//         // *self.current_cursor_status.lock().unwrap() = image;
//         // self.damage_cursor_area(); // Signal renderer to update cursor
//     }
// }

// ==== System Layer: system::dbus_interfaces::upower_client::service ====
// #[async_trait]
// pub trait SystemUPowerClient: Send + Sync {
//    async fn is_on_battery(&self) -> Result<bool, DBusInterfaceError>;
// }

// pub struct UPowerClientService {
//     proxy: UPowerProxy<'static>, // Generated by zbus
//     event_publisher: Arc<SystemEventBridge>,
// }

// impl UPowerClientService {
//     pub async fn new(conn: Arc<Connection>, event_publisher: Arc<SystemEventBridge>) -> Result<Self, DBusInterfaceError> {
//         let proxy = UPowerProxy::new(&conn).await?;
//         let client = Self { proxy, event_publisher };
//         client.start_signal_listeners().await?;
//         Ok(client)
//     }

//     async fn start_signal_listeners(&self) -> Result<(), DBusInterfaceError> {
//         let mut props_changed_stream = self.proxy.receive_properties_changed().await?;
//         let publisher_clone = self.event_publisher.clone();
//         let proxy_clone = self.proxy.clone(); // Proxy is Arc-like or cloneable for tasks

//         tokio::spawn(async move {
//             while let Some(signal) = props_changed_stream.next().await {
//                 if let Ok(args) = signal.args() {
//                     if args.interface_name() == "org.freedesktop.UPower" {
//                         if let Some(Value::Bool(is_on_battery)) = args.changed_properties().get("OnBattery") {
//                             publisher_clone.publish(SystemLayerEvent::UPower(UPowerEvent::OnBatteryChanged(*is_on_battery)));
//                         }
//                         // Handle LidIsClosed, etc.
//                     }
//                 }
//             }
//         });
//         Ok(())
//     }
// }

// #[async_trait]
// impl SystemUPowerClient for UPowerClientService {
//     async fn is_on_battery(&self) -> Result<bool, DBusInterfaceError> {
//         Ok(self.proxy.on_battery().await?)
//     }
// }
```

### 4.2. Algorithmen

- **Token Resolution Pipeline (`domain::theming::logic`)**:
    
    1. **Sammle Basis-Tokens**: Kombiniere globale Tokens (systemweit oder anwendungsweit definiert) mit den Basis-Tokens des aktuell ausgewählten Themes (`theme_def.base_tokens`).
    2. **Varianten-Tokens anwenden**: Basierend auf dem `preferred_color_scheme` (z.B. `Light` oder `Dark`) aus der `ThemingConfiguration`, wähle die entsprechende `ThemeVariantDefinition` aus `theme_def.variants`. Überschreibe die Basis-Tokens mit den Tokens aus dieser Variante.
    3. **Akzentfarbe anwenden**: Falls eine `selected_accent_color` in der `ThemingConfiguration` gesetzt ist und das Theme Akzentfarben unterstützt (`theme_def.accentable_tokens_map`), modifiziere die entsprechenden Tokens. Für jedes Token im `accentable_tokens_map`:
        - Bei `AccentModificationType::DirectReplace`: Ersetze den Token-Wert direkt durch die Akzentfarbe.
        - Bei `AccentModificationType::Lighten(factor)` oder `AccentModificationType::Darken(factor)`: Helle den bestehenden Farbwert des Tokens um den Faktor auf oder dunkle ihn ab, unter Verwendung der Akzentfarbe als Basis oder Modifikator.
    4. **Benutzer-Overrides anwenden**: Überschreibe die bisherigen Token-Werte mit Tokens aus `config.custom_user_token_overrides`, falls vorhanden. Diese haben die höchste Priorität.
    5. **Rekursive Referenzauflösung**: Iteriere durch alle Tokens. Für jedes Token, dessen `value` ein `TokenValue::Reference(target_id)` ist:
        - Rufe `resolve_single_token_value(target_id, &mut visited_path, current_depth + 1, max_depth,...)` auf.
        - `visited_path`: Eine Liste der bisher besuchten `TokenIdentifier` in der aktuellen Auflösungskette, um Zyklen zu erkennen. Wenn `target_id` bereits in `visited_path` enthalten ist, liegt ein Zyklus vor -> `ThemingError::CyclicTokenReference`.
        - `current_depth`: Die aktuelle Rekursionstiefe. Wenn `current_depth > max_depth` (`MAX_TOKEN_RESOLUTION_DEPTH`), dann -> `ThemingError::MaxReferenceDepthExceeded`.
        - Wenn das `target_id` nicht im kombinierten Token-Set gefunden wird -> `ThemingError::MissingTokenReference`.
        - Ersetze das `TokenValue::Reference` durch den aufgelösten Wert des `target_id`.
    6. **Finale Werte konvertieren**: Konvertiere alle `TokenValue`-Varianten (die jetzt keine Referenzen mehr sein sollten) in ihre finalen String-Repräsentationen (z.B. Hex-Farbcodes, Pixelwerte mit "px"-Suffix, Schriftartnamen). Das Ergebnis ist ein `BTreeMap<TokenIdentifier, String>`.
- **Fenster-Layout-Berechnung (Beispiel für `domain::window_management_policy` bei `TilingMode::Columns`)**:
    
    1. Ermittle die verfügbare Breite für Fenster: `available_width = available_area.width - (num_windows - 1) * gap_settings.window_inner - 2 * gap_settings.screen_outer_horizontal`. (Annahme: `num_windows > 0`).
    2. Berechne die Breite pro Fenster: `width_per_window = available_width / num_windows`.
    3. Iteriere über die zu kachelnden Fenster (basierend auf `windows_info`):
        - Setze `window_height = available_area.height - 2 * gap_settings.screen_outer_vertical`.
        - Setze `window_width = width_per_window`.
        - Berücksichtige `WindowLayoutInfo.requested_min_size` und `WindowPolicyOverrides` (z.B. `min_size_override`, `fixed_size`). Passe `window_width` und `window_height` entsprechend an, falls die berechneten Werte die Minima unterschreiten oder feste Größen vorgegeben sind.
        - Positioniere das Fenster: `x_position = gap_settings.screen_outer_horizontal + previous_window_x_plus_width + gap_settings.window_inner`. `y_position = gap_settings.screen_outer_vertical`.
        - Speichere die berechnete Geometrie (`RectInt`) in `WorkspaceWindowLayout.window_geometries`.
    4. Aktualisiere `WorkspaceWindowLayout.occupied_area`.
    5. Setze `WorkspaceWindowLayout.tiling_mode_applied = TilingMode::Columns`.
- **Wayland Event zu Domänen-Event (Beispiel `XdgShellHandler::new_toplevel`)**:
    
    1. Ein Wayland-Client sendet `xdg_wm_base.get_xdg_surface` und anschließend `xdg_surface.get_toplevel`.
    2. Smithay ruft die Methode `XdgShellHandler::new_toplevel(toplevel_surface)` in `DesktopState` auf.
    3. Innerhalb des Handlers in `DesktopState`:
        - Generiere einen neuen, eindeutigen `DomainWindowIdentifier` (z.B. mittels `Uuid::new_v4()`).
        - Extrahiere initiale Client-Hinweise (z.B. `app_id`, `title` vom `toplevel_surface`).
        - Rufe asynchron (ggf. über einen Task und Channel-Kommunikation, um den synchronen Handler nicht zu blockieren) `domain_service.get_initial_window_geometry(domain_id, client_hints)` auf, um die empfohlene Startgeometrie zu erhalten.
        - Rufe asynchron `domain_service.assign_window_to_active_workspace(domain_id)` (oder eine spezifischere Zuweisungsmethode) auf.
        - Erstelle ein `WindowElement` (z.B. `WindowElement::Wayland(Window::new(toplevel_surface))`).
        - Füge das `WindowElement` zu `DesktopState.space` hinzu (z.B. `space.map_window(window_element, initial_position, activate)`).
        - Speichere das Mapping `DomainWindowIdentifier -> Arc<WindowElement>` in `DesktopState.windows`.
        - Sende einen `configure`-Event an das `toplevel_surface` mit der von der Domäne bestimmten Geometrie und Zuständen (z.B. aktiviert/maximiert).
        - Publiziere ein `SystemLayerEvent::WindowCreated { domain_id,... }` über den `SystemEventBridge`, damit die Domänenschicht (z.B. `WorkspaceManagerService`) darauf reagieren kann.

### 4.3. Relevante Rust-Bibliotheken

- **Domänenschicht**:
    - `uuid`: Für eindeutige Identifikatoren (`WorkspaceId`, `NotificationId`, etc.).
    - `chrono`: Für Zeitstempel (`DateTime<Utc>`).
    - `serde`, `serde_json`: Für Serialisierung und Deserialisierung von Datenstrukturen (z.B. Konfigurationen, Events).
    - `thiserror`: Zur einfachen Erstellung von Fehler-Enums.
    - `async-trait`: Für asynchrone Traits in Services.
    - `tokio` (speziell `tokio::sync`): Für Synchronisationsprimitive wie `Mutex`, `RwLock` und `broadcast` Channels für die Event-Verteilung.
- **Systemschicht**:
    - **Compositor**:
        - `smithay`: Das Kern-Toolkit für den Wayland-Compositor.2
        - `wayland-server`, `wayland-protocols`: Für die Wayland-Protokoll-Implementierung.122
        - `calloop`: Der Event-Loop, der von Smithay verwendet wird.36
        - `tracing`, `tracing-subscriber`: Für Logging.
    - **Input**:
        - `libinput` (C-Bibliothek) und `input-rs` (Rust-Bindings, von Smithay genutzt) 81: Für die Verarbeitung von Eingabeereignissen von Geräten.
        - `xkbcommon` (C-Bibliothek) und `xkbcommon-rs` (Rust-Bindings) 126: Für Tastatur-Layout-Management.
    - **D-Bus**:
        - `zbus`: Für die asynchrone D-Bus-Kommunikation.87
    - **Audio**:
        - `pipewire` (C-Bibliothek) und `pipewire-rs` (Rust-Bindings) 137: Für Audio-Management und Interaktion mit dem PipeWire-Server.
    - **MCP**:
        - `mcp_client_rs`: Für die Implementierung des Model Context Protocol Clients.101
    - **XDG Desktop Portals**:
        - `ashpd`: Als Referenz oder zur direkten Nutzung für die Implementierung von Portal-Backends, falls es die serverseitige Logik unterstützt. Andernfalls direkte `zbus`-Implementierung der Portal-D-Bus-Interfaces.96
- **Kernschicht (`novade_core`)**:
    - `thiserror`: Für Fehlerdefinitionen.
    - `tracing`, `serde`, `toml`, `once_cell`, `uuid`, `chrono`: Allgemeine Hilfsbibliotheken.

### 4.4. Annahmen, Einschränkungen, Alternativen

- **Annahme**: Die `novade_core`-Schicht stellt alle in der Domänenschicht referenzierten Typen (z.B. `novade_core::types::RectInt`, `novade_core::types::Color`, `novade_core::errors::CoreError`, `novade_core::config::ConfigServiceAsync`, Logging-Initialisierung) bereit.
- **Annahme**: Ein `SystemEventBridge` (basierend auf `tokio::sync::broadcast`) existiert für die interne Event-Kommunikation in der Systemschicht und als Adapter zur Domänenschicht. Dies ermöglicht eine entkoppelte Kommunikation zwischen Systemkomponenten und der Domäne.
- **Annahme**: Die Domänenschicht-Services sind asynchron implementiert und werden über `Arc<dyn TraitName>`-Handles zugänglich gemacht, um Thread-Sicherheit und flexible Injektion zu ermöglichen.
- **Einschränkung**: Detaillierte Spezifikationen zur GPU-Interaktion und die konkrete Implementierung des Renderers (z.B. spezifische OpenGL/Vulkan-Nutzung) sind in diesem Dokument nicht enthalten und müssen separat definiert werden.4
- **Einschränkung**: Die Komplexität des XWayland-Managements ist nur angedeutet. Eine vollständige XWayland-Integration erfordert eine detaillierte Implementierung eines X11 Window Managers (`X11Wm`) innerhalb des Compositors.4
- **Alternative (D-Bus)**: `dbus-rs` (älter, primär synchron) wurde zugunsten von `zbus` (modern, asynchron-fokussiert) nicht gewählt, um eine bessere Integration in das `tokio`-basierte asynchrone Ökosystem von NovaDE zu gewährleisten.87
- **Alternative (Compositor-Toolkit)**: Die direkte Nutzung von `libweston` (C-Bibliothek) wäre in Rust komplexer zu integrieren und würde weniger idiomatische Rust-APIs bieten als das Smithay-Toolkit. Smithay wurde aufgrund seiner Rust-Nativität und modularen Architektur gewählt.2

## 5. Maximale Detailtiefe

Die vorliegenden Spezifikationen versuchen, für jedes Modul und jede wesentliche Interaktion die folgenden Detailebenen abzudecken, um eine klare und direkte Implementierungsgrundlage zu schaffen:

- **Datenstrukturen**: Alle Felder werden mit exakten Rust-Typen spezifiziert. Sichtbarkeitsmodifikatoren (wo relevant für die Kapselung), abgeleitete Traits (wie `Debug`, `Clone`, `Serialize`, `Deserialize`, `PartialEq`, `Eq`, `Hash`, `Ord`, `Display`, `From`, `Default`) und wichtige Invarianten werden explizit genannt.
- **APIs (Traits und Funktionen)**: Signaturen werden präzise definiert, inklusive Parameternamen, Parametertypen, Rückgabetypen und relevanten Trait-Bounds wie `async`, `Send`, `Sync`. Vor- und Nachbedingungen für kritische Funktionen werden, wo nötig, beschrieben.
- **Events**: Die Struktur des Event-Payloads (alle Felder und deren Typen) wird definiert. Es wird angegeben, welche Komponenten typischerweise Events publizieren und welche sie abonnieren, sowie die Bedingungen, unter denen Events ausgelöst werden.
- **Fehlerbehandlung**: Spezifische Fehler-Enums werden pro Modul unter Verwendung von `thiserror` definiert. Jede Fehlervariante wird mit ihrer Bedeutung erläutert, und gegebenenfalls werden `#[source]`- oder `#[from]`-Attribute zur Fehlerverkettung spezifiziert.
- **Logik/Algorithmen**: Kritische Abläufe und Algorithmen (z.B. Token-Auflösung, Fenster-Layout-Berechnung) werden schrittweise beschrieben, um die Implementierungslogik zu verdeutlichen.
- **Interaktionen**: Die Kommunikation zwischen Modulen und Schichten über APIs und Events wird klar definiert, um das Zusammenspiel der Systemkomponenten nachvollziehbar zu machen.

Diese Detailtiefe zielt darauf ab, Interpretationsspielraum während der Entwicklung zu minimieren und eine konsistente, qualitativ hochwertige Implementierung zu ermöglichen.

## Schlussfolgerungen

Dieses Spezifikationsdokument legt eine solide Grundlage für die Entwicklung der Domänenschicht und deren Integration mit dem Wayland/Smithay-basierten Compositor für das NovaDE-Projekt. Die klare Trennung zwischen Domänenlogik und Systemimplementierungsdetails, die detaillierte Definition von Datenstrukturen, APIs und Fehlerzuständen sowie die Skizzierung von Kernalgorithmen und Interaktionsmustern bieten einen umfassenden Leitfaden für Entwickler.

Die Modularität der Domänenschicht, beispielsweise durch die Aufteilung in `domain::theming`, `domain::workspaces` und `domain::user_centric_services`, fördert die Kapselung und Wiederverwendbarkeit von Code. Die Verwendung von Rusts Typsystem und Features wie `async/await`, `thiserror` und `serde` unterstützt die Entwicklung eines robusten und wartbaren Systems.

Die Integration mit Smithay nutzt dessen Stärken im Bereich der Wayland-Protokollbehandlung und des Zustandsmanagements. Die `DesktopState`-Struktur als zentraler Punkt im Compositor, die verschiedene Handler-Traits implementiert und Smithay-Zustandsobjekte verwaltet, ist ein etabliertes Muster. Die Kommunikation zwischen Dom

## NovaDE Ultra-Feinspezifikation: Domänenschicht & Wayland/Smithay-Integration

Dieses Dokument definiert die detaillierten technischen Spezifikationen für die Domänenschicht des NovaDE-Projekts und deren Integration mit dem Wayland-Compositor, der unter Verwendung des Smithay-Toolkits implementiert wird. Es dient als direkter Implementierungsleitfaden für Entwickler.

### 1. Domänenschicht-Spezifikationen

Die Domänenschicht kapselt die Kernlogik und den Zustand der NovaDE-Desktop-Umgebung. Sie ist unabhängig von UI- und Systemdetails konzipiert.

#### 1.1. Modul: `domain::theming`

Dieses Modul ist verantwortlich für die Logik des Erscheinungsbilds (Theming), die Verwaltung von Design-Tokens, die Interpretation von Theme-Definitionen und die Ermöglichung dynamischer Theme-Wechsel.

- **Referenzierte Dokumente:** `B1 Domänenschicht.md`

##### 1.1.1. Datenstrukturen (`domain::theming::types`)

- **`TokenIdentifier`**: Wrapper für `String` zur Identifizierung von Design-Tokens (z.B. "color.background.primary").
    - Implementiert: `Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord, Display, From<&str>`.
    - **Invarianten**: Nicht leer, enthält nur ASCII-Alphanumerisch, Punkte, Bindestriche.
- **`TokenValue`**: Enum zur Repräsentation von Token-Werten.
    - Varianten: `Color(String)`, `Dimension(String)`, `FontSize(String)`, `FontFamily(String)`, `FontWeight(String)`, `LineHeight(String)`, `LetterSpacing(String)`, `Border(String)`, `Shadow(String)`, `Radius(String)`, `Spacing(String)`, `ZIndex(i32)`, `Opacity(f64)` (0.0-1.0), `Text(String)`, `Reference(TokenIdentifier)`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`.
    - `Opacity`-Werte werden auf 0.0-1.0 geklemmt.
- **`RawToken`**: Struktur zur Repräsentation eines Tokens aus einer Konfigurationsdatei.
    - Felder: `id: TokenIdentifier`, `value: TokenValue`, `description: Option<String>`, `group: Option<String>`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`.
- **`TokenSet`**: Typalias für `std::collections::BTreeMap<TokenIdentifier, RawToken>`.
- **`ThemeIdentifier`**: Wrapper für `String` zur Identifizierung von Themes.
    - Implementiert: `Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord, Display, From<&str>`.
    - **Invarianten**: Nicht leer, empfohlene Zeichen: `a-zA-Z0-9-`.
- **`ColorSchemeType`**: Enum (`Light`, `Dark`).
    - Implementiert: `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default`.
- **`AccentColor`**: Struktur zur Repräsentation einer Akzentfarbe.
    - Felder: `name: Option<String>`, `value: novade_core::types::Color`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`. (Eq/Hash für `value` ggf. manuell oder über Hex-String).
- **`ThemeVariantDefinition`**: Definition spezifischer Token-Werte für eine Theme-Variante.
    - Felder: `applies_to_scheme: ColorSchemeType`, `tokens: TokenSet`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`.
- **`ThemeDefinition`**: Vollständige Definition eines Themes.
    - Felder: `id: ThemeIdentifier`, `name: String`, `description: Option<String>`, `author: Option<String>`, `version: Option<String>`, `base_tokens: TokenSet`, `variants: Vec<ThemeVariantDefinition>`, `supported_accent_colors: Option<Vec<AccentColor>>`, `accentable_tokens: Option<HashMap<TokenIdentifier, AccentModificationType>>`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`.
- **`AccentModificationType`**: Enum (`DirectReplace`, `Lighten(f32)`, `Darken(f32)`).
- **`AppliedThemeState`**: Repräsentiert den aktuell aktiven, aufgelösten Theme-Zustand.
    - Felder: `theme_id: ThemeIdentifier`, `color_scheme: ColorSchemeType`, `active_accent_color: Option<AccentColor>`, `resolved_tokens: std::collections::BTreeMap<TokenIdentifier, String>`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`.
    - **Invarianten**: `resolved_tokens` enthält keine Referenzen mehr.
- **`ThemingConfiguration`**: Benutzerspezifische Theming-Einstellungen.
    - Felder: `selected_theme_id: ThemeIdentifier`, `preferred_color_scheme: ColorSchemeType`, `selected_accent_color: Option<novade_core::types::Color>`, `custom_user_token_overrides: Option<TokenSet>`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize, Default`.

##### 1.1.2. Fehlerbehandlung (`domain::theming::errors`)

- **`ThemingError`**: Enum (definiert mit `thiserror`).
    - Varianten: `TokenFileParseError { path: PathBuf, source: serde_json::Error }`, `TokenFileIoError { path: PathBuf, source: std::io::Error }`, `InvalidTokenData { path: PathBuf, message: String }`, `InvalidTokenValue { token_id: TokenIdentifier, value_string: String, reason: String }`, `CyclicTokenReference { token_id: TokenIdentifier, cycle_path: Vec<TokenIdentifier> }`, `ThemeFileLoadError { theme_id: ThemeIdentifier, path: PathBuf, source: serde_json::Error }`, `ThemeFileIoError { theme_id: ThemeIdentifier, path: PathBuf, source: std::io::Error }`, `InvalidThemeData { theme_id: ThemeIdentifier, path: PathBuf, message: String }`, `ThemeNotFound { theme_id: ThemeIdentifier }`, `MissingTokenReference { referencing_token_id: TokenIdentifier, target_token_id: TokenIdentifier }`, `MaxReferenceDepthExceeded { token_id: TokenIdentifier, depth: u8 }`, `ThemeApplicationError { message: String, source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`, `FallbackThemeLoadError { source: Box<dyn std::error::Error + Send + Sync + 'static> }`, `InitialConfigurationError(String)`, `InternalStateError(String)`, `EventSubscriptionError(String)`, `AccentColorApplicationError { theme_id: ThemeIdentifier, accent_color: novade_core::types::Color, details: String }`, `TokenResolutionError { token_id: TokenIdentifier, message: String, source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`, `FilesystemError(#[from] novade_core::errors::CoreError)`.

##### 1.1.3. Kernlogik (`domain::theming::logic`)

- **Konstante**: `MAX_TOKEN_RESOLUTION_DEPTH: u8 = 16;`
- **Token/Theme Laden & Validieren**:
    - `async fn load_raw_tokens_from_file(path: &Path, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`: Liest JSON, parst zu `TokenSet`, validiert Duplikate/Basisformat.
    - `async fn load_and_validate_token_files(paths: &[PathBuf], config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`: Lädt von Pfaden, mergt (Benutzer überschreibt System), validiert Zyklen.
    - `async fn load_theme_definition_from_file(...) -> Result<ThemeDefinition, ThemingError>`: Liest JSON, parst zu `ThemeDefinition`.
    - `async fn load_and_validate_theme_files(...) -> Result<Vec<ThemeDefinition>, ThemingError>`: Lädt Themes, validiert Token-Referenzen.
    - `fn validate_tokenset_for_cycles(tokens: &TokenSet) -> Result<(), ThemingError>`: Tiefensuche zur Zyklenerkennung.
- **Token Resolution Pipeline**:
    - `fn resolve_tokens_for_config(config: &ThemingConfiguration, theme_def: &ThemeDefinition, global_tokens: &TokenSet, accentable_tokens_map: &HashMap<TokenIdentifier, AccentModificationType>, max_depth: u8) -> Result<BTreeMap<TokenIdentifier, String>, ThemingError>`:
        1. Start mit globalen Tokens + Theme-Basis-Tokens.
        2. Varianten-Tokens anwenden.
        3. Akzentfarben anwenden (basierend auf `accentable_tokens_map` und `config.selected_accent_color`).
        4. Benutzer-Overrides anwenden.
        5. Rekursive Referenzauflösung (`resolve_single_token_value`) mit Zyklenerkennung und Tiefenbegrenzung.
        6. Finale Werte in Strings konvertieren.
- **Caching**: Cache-Schlüssel `(ThemeIdentifier, ColorSchemeType, Option<String> /* hex von AccentColor */, u64 /* hash von Overrides */)` für `AppliedThemeState`.
- **Fallback**: `fn generate_fallback_applied_state() -> AppliedThemeState` aus einkompilierten JSONs.

##### 1.1.4. API (`domain::theming::service::ThemingEngine`)

- **Struktur `ThemingEngineInternalState`**:
    - Felder: `current_config: ThemingConfiguration`, `available_themes: Vec<ThemeDefinition>`, `global_raw_tokens: TokenSet`, `applied_state: AppliedThemeState`, `theme_load_paths: Vec<PathBuf>`, `token_load_paths: Vec<PathBuf>`, `resolved_state_cache: HashMap<CacheKey, AppliedThemeState>`, `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>`.
- **Struktur `ThemingEngine`**:
    - Felder: `internal_state: Arc<tokio::sync::Mutex<ThemingEngineInternalState>>`, `event_sender: tokio::sync::broadcast::Sender<ThemeChangedEvent>`.
- **Methoden**:
    - `async fn new(initial_config: ThemingConfiguration, theme_load_paths: Vec<PathBuf>, token_load_paths: Vec<PathBuf>, config_service: Arc<dyn novade_core::config::ConfigServiceAsync>, broadcast_capacity: usize) -> Result<Self, ThemingError>`
    - `async fn get_current_theme_state(&self) -> AppliedThemeState`
    - `async fn get_available_themes(&self) -> Vec<ThemeDefinition>`
    - `async fn get_current_configuration(&self) -> ThemingConfiguration`
    - `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
    - `async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`
    - `fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeChangedEvent>`

##### 1.1.5. Events (`domain::theming::events`)

- **`ThemeChangedEvent`**:
    - Payload: `new_state: AppliedThemeState`.

#### 1.2. Modul: `domain::workspaces`

Verantwortlich für die Logik und Verwaltung von Arbeitsbereichen ("Spaces").

- **Referenzierte Dokumente:** `B2 Domänenschicht.md`

##### 1.2.1. Untermodul: `domain::workspaces::core`

- **Datenstrukturen (`domain::workspaces::core::types`)**:
    - `WorkspaceId`: Typalias für `uuid::Uuid`.
    - `WindowIdentifier`: Wrapper für `String`. Implementiert `new(id: impl Into<String>) -> Result<Self, WorkspaceCoreError>`.
    - `WorkspaceLayoutType`: Enum (`Floating`, `TilingHorizontal`, `TilingVertical`, `Maximized`). Implementiert `Default`.
- **Entität `Workspace` (`domain::workspaces::core::mod.rs`)**:
    - Felder: `id: WorkspaceId`, `name: String`, `persistent_id: Option<String>`, `layout_type: WorkspaceLayoutType`, `window_ids: HashSet<WindowIdentifier>`, `created_at: DateTime<Utc>`, `icon_name: Option<String>`, `accent_color_hex: Option<String>`.
    - Methoden: `new(...) -> Result<Self, WorkspaceCoreError>`, `id()`, `name()`, `rename(...)`, `set_layout_type(...)`, `add_window_id(...)` (crate-intern), `remove_window_id(...)` (crate-intern), `set_icon_name(...)`, `set_accent_color_hex(...) -> Result<...>`.
- **Event-Payloads (`domain::workspaces::core::event_data`)**: `WorkspaceRenamedData`, `WorkspaceLayoutChangedData`, `WindowAddedToWorkspaceData`, `WindowRemovedFromWorkspaceData`, `WorkspacePersistentIdChangedData`, `WorkspaceIconChangedData`, `WorkspaceAccentChangedData`.
- **Fehlerbehandlung (`domain::workspaces::core::errors`)**:
    - `WorkspaceCoreError`: `InvalidName`, `NameCannotBeEmpty`, `NameTooLong`, `InvalidPersistentId`, `WindowIdentifierEmpty`, `InvalidAccentColorFormat`.

##### 1.2.2. Untermodul: `domain::workspaces::assignment`

- **API (`domain::workspaces::assignment::mod.rs`)**: Funktionen operieren auf `&mut HashMap<WorkspaceId, Workspace>`.
    - `assign_window_to_workspace(...) -> Result<(), WindowAssignmentError>`
    - `remove_window_from_workspace(...) -> Result<bool, WindowAssignmentError>`
    - `move_window_to_workspace(...) -> Result<(), WindowAssignmentError>`
    - `find_workspace_for_window(...) -> Option<WorkspaceId>`
- **Fehlerbehandlung (`domain::workspaces::assignment::errors`)**:
    - `WindowAssignmentError`: `WorkspaceNotFound`, `WindowAlreadyAssigned`, `WindowNotAssignedToWorkspace`, `SourceWorkspaceNotFound`, `TargetWorkspaceNotFound`, `WindowNotOnSourceWorkspace`, `CannotMoveToSameWorkspace`, `RuleViolation`, `Internal`.

##### 1.2.3. Untermodul: `domain::workspaces::config`

- **Datenstrukturen (`domain::workspaces::config::mod.rs`)**:
    - `WorkspaceSnapshot`: `persistent_id: String`, `name: String`, `layout_type: WorkspaceLayoutType`, `icon_name: Option<String>`, `accent_color_hex: Option<String>`.
    - `WorkspaceSetSnapshot`: `workspaces: Vec<WorkspaceSnapshot>`, `active_workspace_persistent_id: Option<String>`.
- **API (`domain::workspaces::config::mod.rs`)**:
    - Trait `WorkspaceConfigProvider`: `async fn load_workspace_config() -> Result<WorkspaceSetSnapshot, WorkspaceConfigError>`, `async fn save_workspace_config(snapshot: &WorkspaceSetSnapshot) -> Result<(), WorkspaceConfigError>`.
    - Struktur `FilesystemConfigProvider`: Implementiert `WorkspaceConfigProvider`, nutzt `core::config::ConfigServiceAsync`.
- **Fehlerbehandlung (`domain::workspaces::config::errors`)**:
    - `WorkspaceConfigError`: `LoadError`, `SaveError`, `InvalidData`, `SerializationError`, `DeserializationError`, `PersistentIdNotFoundInLoadedSet`, `DuplicatePersistentIdInLoadedSet`.

##### 1.2.4. Untermodul: `domain::workspaces::manager`

- **API (`domain::workspaces::manager::mod.rs`)**: Trait `WorkspaceManagerService`.
    - Methoden: `async create_workspace(...)`, `async delete_workspace(...)`, `get_workspace(...) -> Option<Workspace>`, `all_workspaces_ordered() -> Vec<Workspace>`, `active_workspace_id()`, `async set_active_workspace(...)`, `async assign_window_to_active_workspace(...)`, `async assign_window_to_specific_workspace(...)`, `async remove_window_from_its_workspace(...)`, `async move_window_to_specific_workspace(...)`, `async rename_workspace(...)`, `async set_workspace_layout(...)`, `async set_workspace_icon(...)`, `async set_workspace_accent_color(...)`, `async save_configuration()`, `subscribe_to_workspace_events() -> tokio::sync::broadcast::Receiver<WorkspaceEvent>`, `async reorder_workspace(...)`.
- **Implementierung `DefaultWorkspaceManager`**: Hält `Arc<tokio::sync::Mutex<WorkspaceManagerInternalState>>`.
    - `WorkspaceManagerInternalState`: `workspaces: HashMap<WorkspaceId, Workspace>`, `active_workspace_id: Option<WorkspaceId>`, `ordered_workspace_ids: Vec<WorkspaceId>`, `next_workspace_number: u32`, `config_provider: Arc<dyn WorkspaceConfigProvider>`, `event_publisher: tokio::sync::broadcast::Sender<WorkspaceEvent>`, `ensure_unique_window_assignment: bool`.
- **Events (`domain::workspaces::manager::events`)**:
    - `WorkspaceEvent`: `WorkspaceCreated`, `WorkspaceDeleted`, `ActiveWorkspaceChanged`, `WorkspaceRenamed`, `WorkspaceLayoutChanged`, `WindowAddedToWorkspace`, `WindowRemovedFromWorkspace`, `WorkspaceOrderChanged`, `WorkspacesReloaded`, `WorkspacePersistentIdChanged`, `WorkspaceIconChanged`, `WorkspaceAccentChanged`.
- **Fehlerbehandlung (`domain::workspaces::manager::errors`)**:
    - `WorkspaceManagerError`: `WorkspaceNotFound`, `CannotDeleteLastWorkspace`, `DeleteRequiresFallbackForWindows`, `FallbackWorkspaceNotFound`, `CoreError(#[from] WorkspaceCoreError)`, `AssignmentError(#[from] WindowAssignmentError)`, `ConfigError(#[from] WorkspaceConfigError)`, `SetActiveWorkspaceNotFound`, `NoActiveWorkspace`, `DuplicatePersistentId`, `Internal`.

#### 1.3. Modul: `domain::user_centric_services`

Bündelt Logik für KI-Interaktionen und Benachrichtigungen.

- **Referenzierte Dokumente:** `B3 Domänenschicht.md`, `B4 Domänenschicht.md`

##### 1.3.1. Untermodul: `domain::user_centric_services::ai_interaction`

- **Datenstrukturen (`...::types`)**:
    - `AIDataCategory`: Enum (`UserProfile`, `ApplicationUsage`, `FileSystemRead`, `ClipboardAccess`, `LocationData`, `GenericText`, `GenericImage`).
    - `AIConsentStatus`: Enum (`Granted`, `Denied`, `PendingUserAction`, `NotRequired`).
    - `AttachmentData`: Felder `id: Uuid`, `mime_type: String`, `source_uri: Option<String>`, `content_base64: Option<String>`, `text_content: Option<String>`, `description: Option<String>`.
    - `InteractionParticipant`: Enum (`User`, `Assistant`, `System`).
    - `InteractionHistoryEntry`: Felder `entry_id: Uuid`, `timestamp: DateTime<Utc>`, `participant: InteractionParticipant`, `content: String`, `related_attachment_ids: Vec<Uuid>`.
    - `AIInteractionContext`: Felder `id: Uuid`, `creation_timestamp: DateTime<Utc>`, `active_model_id: Option<String>`, `consent_status: AIConsentStatus`, `associated_data_categories: Vec<AIDataCategory>`, `history_entries: Vec<InteractionHistoryEntry>`, `attachments: Vec<AttachmentData>`, `user_prompt_template: Option<String>`, `is_active: bool`.
    - `AIConsentScope`: Enum (`SessionOnly`, `PersistentUntilRevoked`, `SpecificDuration`).
    - `AIConsent`: Felder `id: Uuid`, `user_id: String`, `model_id: String`, `data_category: AIDataCategory`, `granted_timestamp: DateTime<Utc>`, `expiry_timestamp: Option<DateTime<Utc>>`, `is_revoked: bool`, `last_used_timestamp: Option<DateTime<Utc>>`, `consent_scope: AIConsentScope`.
    - `AIModelCapability`: Enum (`TextGeneration`, `CodeGeneration`, `Summarization`, `Translation`, `ImageAnalysis`, `FunctionCalling`).
    - `AIModelProfile`: Felder `model_id: String`, `display_name: String`, `description: String`, `provider: String`, `required_consent_categories: Vec<AIDataCategory>`, `capabilities: Vec<AIModelCapability>`, `supports_streaming: bool`, `endpoint_url: Option<String>`, `api_key_secret_name: Option<String>`, `is_default_model: bool`, `sort_order: i32`.
- **Fehlerbehandlung (`...::errors`)**: `AIInteractionError` (`ConsentCheckFailed`, `ApiKeyNotFoundInSecrets`, `ModelEndpointUnreachable`, `NoDefaultModelConfigured`, `CoreConfigError`).
- **Persistenz-Interfaces (`...::persistence_iface`)**: Traits `AIConsentProvider`, `AIModelProfileProvider`.
- **API (`...::service::AIInteractionLogicService`)**: Trait mit Methoden `initiate_interaction`, `get_interaction_context`, `provide_consent`, `get_consent_status_for_interaction`, `get_default_model`, `update_interaction_history`, `store_consent`, `get_all_user_consents`, `load_model_profiles`.
- **Implementierung `DefaultAIInteractionLogicService`**.
- **Events (`...::events::AIInteractionEventEnum`)**: `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`, `AIContextUpdatedEvent`, `AIModelProfilesReloadedEvent`.

##### 1.3.2. Untermodul: `domain::user_centric_services::notifications_core`

- **Datenstrukturen (`...::types`)**:
    - `NotificationId`: Typalias für `uuid::Uuid`.
    - `NotificationUrgency`: Enum (`Low`, `Normal`, `Critical`).
    - `NotificationActionType`: Enum (`Callback`, `OpenLink`).
    - `NotificationAction`: Felder `key: String`, `label: String`, `action_type: NotificationActionType`.
    - `Notification`: Felder `id: Uuid`, `application_name: String`, `application_icon: Option<String>`, `summary: String`, `body: Option<String>`, `actions: Vec<NotificationAction>`, `urgency: NotificationUrgency`, `timestamp: DateTime<Utc>`, `is_read: bool`, `is_dismissed: bool`, `transient: bool`, `category: Option<String>`, `hints: HashMap<String, serde_json::Value>`, `timeout_ms: Option<u32>`.
    - `NotificationInput`: Struktur für das Erstellen von Notifications (ohne `id`, `timestamp`, `is_read`, `is_dismissed`).
    - `NotificationFilterCriteria`: Enum (mit Varianten `Unread`, `Application`, `Urgency`, `Category`, `HasAction`, `BodyContains`, `SummaryContains`, `IsTransient`, `AndTimeRange`, `And`, `Or`, `Not`).
    - `NotificationSortOrder`: Enum (`TimestampAscending`, `TimestampDescending`, `Urgency`, `ApplicationNameAscending`, `SummaryAscending`).
    - `NotificationStats`: `num_active: usize`, `num_history: usize`, `num_unread: usize`.
    - `DismissReason`: Enum (`User`, `Timeout`, `Replaced`, `AppClosed`, `SystemRequest`).
- **Fehlerbehandlung (`...::errors`)**: `NotificationError` (`NotFound`, `InvalidData`, `HistoryFull`, `ActionNotFound`, `InvalidFilterCriteria`, `ActionInvocationFailed`).
- **API (`...::service::NotificationService`)**: Trait mit Methoden `post_notification(input: NotificationInput)`, `get_notification`, `mark_as_read`, `dismiss_notification`, `get_active_notifications`, `get_notification_history`, `clear_history`, `set_do_not_disturb`, `is_do_not_disturb_enabled`, `invoke_action`, `get_stats`, `clear_all_for_app`.
- **Implementierung `DefaultNotificationService`**.
- **Events (`...::events::NotificationEventEnum`)**: `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `NotificationActionInvokedEvent`, `DoNotDisturbModeChangedEvent`, `NotificationHistoryClearedEvent`, `NotificationPopupExpiredEvent`.

#### 1.4. Modul: `domain::notifications_rules`

Regelbasierte Verarbeitung von Benachrichtigungen.

- **Referenzierte Dokumente:** `B4 Domänenschicht.md`

##### 1.4.1. Datenstrukturen (`domain::notifications_rules::types`)

- `RuleConditionValue`: Enum (`String(String)`, `Integer(i64)`, `Boolean(bool)`, `Urgency(NotificationUrgency)`, `Regex(String)`).
- `RuleConditionOperator`: Enum (`Is`, `IsNot`, `Contains`, `NotContains`, `StartsWith`, `EndsWith`, `MatchesRegex`, `NotMatchesRegex`, `GreaterThan`, `LessThan`, `GreaterThanOrEqual`, `LessThanOrEqual`).
- `RuleConditionField`: Enum (`ApplicationName`, `Summary`, `Body`, `Urgency`, `Category`, `HintExists(String)`, `HintValue(String)`).
- `SimpleRuleCondition`: Felder `field: RuleConditionField`, `operator: RuleConditionOperator`, `value: RuleConditionValue`.
- `RuleCondition`: Enum (`Simple(SimpleRuleCondition)`, `SettingIsTrue(SettingPath)`, `And(Vec<RuleCondition>)`, `Or(Vec<RuleCondition>)`, `Not(Box<RuleCondition>`).
- `RuleAction`: Enum (`SuppressNotification`, `SetUrgency`, `AddActionToNotification`, `SetHint`, `PlaySound`, `MarkAsPersistent`, `SetTimeoutMs`, `SetCategory`, `SetSummary`, `SetBody`, `SetIcon`, `SetAccentColor`, `StopProcessingFurtherRules`, `LogMessage`).
- `NotificationRule`: Felder `id: Uuid`, `name: String`, `condition: RuleCondition`, `actions: Vec<RuleAction>`, `is_enabled: bool`, `priority: i32`. Implementiert `Default`.
- `NotificationRuleSet`: Typalias für `Vec<NotificationRule>`.

##### 1.4.2. Fehlerbehandlung (`domain::notifications_rules::errors`)

- `NotificationRulesError`: `InvalidRuleDefinition`, `ConditionEvaluationError`, `ActionApplicationError`, `SettingsAccessError(#[from] GlobalSettingsError)`, `RulePersistenceError(#[from] novade_core::errors::CoreError)`, `InvalidRegex`.

##### 1.4.3. API (`domain::notifications_rules::engine::NotificationRulesEngine`)

- **Trait `NotificationRulesEngine`**:
    - Methoden: `async reload_rules()`, `async process_notification(notification: Notification) -> Result<RuleProcessingResult, NotificationRulesError>`, `async get_rules() -> Result<NotificationRuleSet, _>`, `async update_rules(new_rules: NotificationRuleSet) -> Result<_,_>`.
- **Implementierung `DefaultNotificationRulesEngine`**: Hält `Arc<tokio::sync::RwLock<NotificationRuleSet>>`, `Arc<dyn NotificationRulesProvider>`, `Arc<dyn GlobalSettingsService>`.
- **Enum `RuleProcessingResult`**: `Allow(Notification)`, `Suppress { rule_id: Uuid }`.

##### 1.4.4. Persistenz (`domain::notifications_rules::persistence_iface`)

- **Trait `NotificationRulesProvider`**: `async fn load_rules() -> Result<NotificationRuleSet, _>`, `async fn save_rules(rules: &NotificationRuleSet) -> Result<_,_>`.
- **Implementierung `FilesystemNotificationRulesProvider`**.

#### 1.5. Modul: `domain::global_settings_and_state_management`

Verwaltung globaler Desktop-Einstellungen.

- **Referenzierte Dokumente:** `B3 Domänenschicht.md`, `B4 Domänenschicht.md`

##### 1.5.1. Datenstrukturen (`...::types`)

- `GlobalDesktopSettings`: Hauptstruktur mit Feldern wie `appearance: AppearanceSettings`, `workspace_config: WorkspaceSettings`, `input_behavior: InputBehaviorSettings`, `power_management_policy: PowerManagementPolicySettings`, `default_applications: DefaultApplicationsSettings`. Alle Felder mit `#[serde(default)]`.
- Detaillierte Unterstrukturen (`AppearanceSettings`, `FontSettings`, etc.) und Enums (`ColorScheme`, `MouseAccelerationProfile`, etc.) wie in `B3 Domänenschicht.md` und `B4 Domänenschicht.md` definiert.
- **Validierung**: Jede Einstellungs-Unterstruktur implementiert `fn validate(&self) -> Result<(), String>`. `GlobalDesktopSettings` hat `validate_recursive()`.

##### 1.5.2. Pfade (`...::paths`)

- `SettingPath`: Hierarchischer Enum zur typsicheren Adressierung aller Einstellungen. Implementiert `Display` und `TryFrom<&str>`.

##### 1.5.3. Fehlerbehandlung (`...::errors`)

- `GlobalSettingsError`: `PathNotFound { path: SettingPath }`, `InvalidValueType { path: SettingPath, ... }`, `ValidationError { path: SettingPath, reason: String }`, `SerializationError`, `DeserializationError`, `PersistenceError(#[from] GlobalSettingsPersistenceError)`.

##### 1.5.4. Persistenz-Interface (`...::persistence_iface`)

- **Trait `SettingsPersistenceProvider`**: `async fn load_global_settings() -> Result<GlobalDesktopSettings, GlobalSettingsError>`, `async fn save_global_settings(settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`.
    - **Anmerkung:** Die Fehlerart hier sollte ggf. ein spezifischerer `GlobalSettingsPersistenceError` sein, um `#[from]` in `GlobalSettingsError::PersistenceError` zu ermöglichen.
- **Implementierung `FilesystemSettingsProvider`**.

##### 1.5.5. API (`...::service::GlobalSettingsService`)

- **Trait `GlobalSettingsService`**:
    - Methoden: `async load_settings()`, `async save_settings()`, `get_current_settings() -> GlobalDesktopSettings`, `async update_setting(path: SettingPath, value: serde_json::Value) -> Result<(),_>`, `get_setting(path: &SettingPath) -> Result<serde_json::Value, _>`, `async reset_to_defaults()`, `subscribe_to_setting_changes() -> tokio::sync::broadcast::Receiver<SettingChangedEvent>`.
- **Implementierung `DefaultGlobalSettingsService`**: Hält `settings: Arc<tokio::sync::RwLock<GlobalDesktopSettings>>`, `persistence_provider: Arc<dyn SettingsPersistenceProvider>`, `event_sender`.

##### 1.5.6. Events (`...::events`)

- `SettingChangedEvent { path: SettingPath, new_value: serde_json::Value }`
- `SettingsLoadedEvent { settings: GlobalDesktopSettings }`
- `SettingsSavedEvent`

#### 1.6. Modul: `domain::window_management_policy`

High-Level-Regeln und Richtlinien für Fensterplatzierung, Tiling, etc.

- **Referenzierte Dokumente:** `B3 Domänenschicht.md`

##### 1.6.1. Datenstrukturen (`...::types`)

- `TilingMode`: Enum (`Manual`, `Columns`, `Rows`, `Spiral`, `MaximizedFocused`).
- `GapSettings`: `screen_outer_horizontal: u16`, `screen_outer_vertical: u16`, `window_inner: u16`.
- `WindowSnappingPolicy`: `snap_to_screen_edges: bool`, `snap_to_other_windows: bool`, `snap_to_workspace_gaps: bool`, `snap_distance_px: u16`.
- `WindowGroupingPolicy`: `enable_manual_grouping: bool`.
- `NewWindowPlacementStrategy`: Enum (`Smart`, `Center`, `Cascade`, `UnderMouse`).
- `FocusStealingPreventionLevel`: Enum (`None`, `Moderate`, `Strict`).
- `FocusPolicy`: `focus_follows_mouse: bool`, `click_to_focus: bool`, `focus_new_windows_on_creation: bool`, `focus_new_windows_on_workspace_switch: bool`, `focus_stealing_prevention: FocusStealingPreventionLevel`.
- `WindowPolicyOverrides`: Optionale, fensterspezifische Overrides (`preferred_tiling_mode`, `is_always_floating`, `fixed_size`, `fixed_position`, `prevent_focus_stealing`, `min_size_override`, `max_size_override`).
- `WorkspaceWindowLayout`: `window_geometries: HashMap<WindowIdentifier, novade_core::types::RectInt>`, `occupied_area: Option<RectInt>`, `tiling_mode_applied: TilingMode`.
- `WindowLayoutInfo`: `id: WindowIdentifier`, `requested_min_size: Option<novade_core::types::Size<u32>>`, `is_fullscreen_requested: bool`, `is_maximized_requested: bool`.

##### 1.6.2. Fehlerbehandlung (`...::errors`)

- `WindowPolicyError`: `LayoutCalculationError`, `InvalidPolicyConfiguration`, `WindowNotFoundForPolicy`.

##### 1.6.3. API (`...::service::WindowManagementPolicyService`)

- **Trait `WindowManagementPolicyService`**:
    - Methoden: `async calculate_workspace_layout(...) -> Result<WorkspaceWindowLayout, _>`, `async get_initial_window_geometry(...) -> Result<RectInt, _>`, `async calculate_snap_target(...) -> Option<RectInt>`, `async get_effective_tiling_mode_for_workspace(...) -> Result<TilingMode, _>`, `async get_effective_gap_settings_for_workspace(...) -> Result<GapSettings, _>`, `async get_effective_snapping_policy() -> Result<WindowSnappingPolicy, _>`, `async get_effective_focus_policy() -> Result<FocusPolicy, _>`, `async get_effective_new_window_placement_strategy() -> Result<NewWindowPlacementStrategy, _>`.
- **Implementierung `DefaultWindowManagementPolicyService`**: Hält `Arc<dyn GlobalSettingsService>`.

#### 1.7. Modul: `domain::common_events`

Definition von Domänen-übergreifenden Events.

- **Referenzierte Dokumente:** `B3 Domänenschicht.md`

##### 1.7.1. Datenstrukturen (`domain::common_events::events`)

- `UserActivityType`: Enum (`MouseMoved`, `MouseClicked`, `MouseWheelScrolled`, `KeyPressed`, `TouchInteraction`, `WorkspaceSwitched`, `ApplicationFocused`, `WindowOpened`, `WindowClosed`).
- `UserActivityDetectedEvent`: Felder `event_id: Uuid`, `timestamp: DateTime<Utc>`, `activity_type: UserActivityType`, `current_session_state: UserSessionState`, `active_application_id: Option<ApplicationId>`, `active_workspace_id: Option<WorkspaceId>`.
- `ShutdownReason`: Enum (`UserRequest`, `PowerButtonPress`, `LowBattery`, `SystemUpdate`, `ApplicationRequest`, `OsError`, `Unknown`).
- `SystemShutdownInitiatedEvent`: Felder `event_id: Uuid`, `timestamp: DateTime<Utc>`, `reason: ShutdownReason`, `is_reboot: bool`, `delay_seconds: Option<u32>`, `message: Option<String>`.

#### 1.8. Modul: `domain::shared_types`

Wiederverwendbare domänenspezifische Typen.

- **Referenzierte Dokumente:** `B3 Domänenschicht.md`

##### 1.8.1. Datenstrukturen (`domain::shared_types::types`)

- `ApplicationId`: Wrapper für `String`.
- `UserSessionState`: Enum (`Active`, `Locked`, `Idle`).
- `ResourceIdentifier`: Felder `r#type: String`, `id: String`, `label: Option<String>`.

### 2. Wayland/Smithay-Integration (Systemschicht-Perspektive)

Dieser Abschnitt beschreibt, wie die Systemschicht, insbesondere der Compositor, mit Wayland-Protokollen unter Verwendung von Smithay umgeht und mit der Domänenschicht interagiert.

- **Referenzierte Dokumente:** `C1 System Implementierungsplan.md` bis `C4 Systemschicht.md`, `3. System-Details.md`.

#### 2.1. Kern-Compositor-Struktur (`system::compositor::core::state::DesktopState`)

- `DesktopState` ist die zentrale Zustandsstruktur, die Smithay-Handler-Traits implementiert.
- **Wichtige Felder (Auswahl, basierend auf Smithay-Architektur):**
    - `display_handle: DisplayHandle`
    - `loop_handle: LoopHandle<'static, Self>`
    - `clock: Clock<u64>`
    - `compositor_state: CompositorState`
    - `shm_state: ShmState`
    - `xdg_shell_state: XdgShellState`
    - `output_manager_state: OutputManagerState`
    - `seat_state: SeatState<Self>`
    - `seat: Seat<Self>`
    - `data_device_state: DataDeviceState`
    - `space: Space<WindowElement>` (wobei `WindowElement` ein Enum ist, das `Wayland(Window)`, `X11(X11Surface)`, `Layer(LayerSurface)` wrappt)
    - `windows: HashMap<DomainWindowIdentifier, Arc<WindowElement>>` (Mapping von Domänen-IDs zu Compositor-Fenstern)
    - Domänen-Service-Handles: `Arc<dyn WindowManagementPolicyService>`, `Arc<dyn WorkspaceManagerService>`, `Arc<dyn GlobalSettingsService>`.
    - `event_bridge: Arc<SystemEventBridge>`

#### 2.2. Wayland-Protokoll-Implementierungen

- **`wl_compositor`, `wl_subcompositor`**: Gehandhabt durch `CompositorState` und `CompositorHandler` in `DesktopState`.
    - `CompositorHandler::commit(surface: &WlSurface)`:
        1. Aktualisiert `SurfaceData` (Puffer, Schaden).
        2. Informiert `domain::window_management_policy` oder `domain::workspaces` bei relevanten Änderungen (z.B. neue Puffergröße könnte Layout beeinflussen).
        3. Markiert Oberfläche für Neuzeichnung.
- **`wl_shm`**: Gehandhabt durch `ShmState` und `ShmHandler` in `DesktopState`.
    - `BufferHandler::buffer_destroyed(buffer: &WlBuffer)`: Informiert Renderer, Ressourcen freizugeben.
- **`xdg_shell` (`xdg_wm_base`, `xdg_surface`, `xdg_toplevel`, `xdg_popup`)**: Gehandhabt durch `XdgShellState` und `XdgShellHandler` in `DesktopState`.
    - `XdgShellHandler::new_toplevel(surface: ToplevelSurface)`:
        1. Erstellt `WindowElement::Wayland(Window::new(ToplevelKind::Xdg(surface))))`.
        2. Generiert `DomainWindowIdentifier`.
        3. Ruft `domain::window_management_policy::get_initial_window_geometry()` auf, um Position/Größe zu bestimmen.
        4. Ruft `domain::workspaces::assign_window_to_active_workspace()` auf.
        5. Konfiguriert und mappt das Fenster im `Space`.
    - `XdgShellHandler::map_toplevel(surface: &ToplevelSurface)`: Informiert `domain::workspaces`, Fenster als gemappt zu markieren.
    - Anfragen (`set_title`, `set_app_id`, `set_maximized`, `move`, `resize`) werden an `domain::window_management_policy` delegiert, um die Policy-konforme Reaktion zu bestimmen. Das Ergebnis wird dann auf das `ToplevelSurface` angewendet (`send_configure`).
    - **Domäne -> System**: `domain::window_management_policy` gibt `WorkspaceWindowLayout` zurück. `system::window_mechanics::apply_workspace_layout` iteriert über `window_geometries` und ruft `toplevel.send_configure(...)` für jedes Fenster auf.
- **`wlr-layer-shell-unstable-v1`**: Gehandhabt durch `WlrLayerShellState` und `LayerShellHandler`.
    - `LayerShellHandler::new_layer_surface(surface: LayerSurface, ...)`: Erstellt `WindowElement::Layer(surface)`. Informiert Domäne (ggf. spezifischer Service für Shell-Elemente), platziert im `Space` gemäß Layer-Regeln.
- **`wl_output` / `xdg-output-unstable-v1`**: Gehandhabt durch `OutputManagerState`.
    - Änderungen an Outputs (Hotplug, Modusänderung) werden von `OutputHandler` verarbeitet.
    - Meldet Änderungen an `domain::global_settings_and_state_management` (um z.B. Persistenz anzustoßen) und `domain::workspaces` (kann Layout beeinflussen).
    - `system::outputs::output_manager` implementiert `wlr-output-management-unstable-v1`.
        - `apply()`: Ruft `Output::change_current_state()`. Domäne wird über `OutputConfigurationChangedEvent` informiert.
- **`wl_seat` / Eingabeprotokolle**: Gehandhabt durch `SeatState`, `SeatHandler`, `KeyboardHandle`, `PointerHandle`, `TouchHandle`.
    - Eingabe-Events von `system::input` (Libinput) werden verarbeitet.
    - `SeatHandler::focus_changed(seat: &Seat<Self>, focused: Option<&WlSurface>)`:
        1. Identifiziert `DomainWindowIdentifier` für `focused_surface`.
        2. Informiert `domain::window_management_policy` oder `domain::workspaces` über Fokusänderung.
    - `KeyboardHandle::input(keycode, state, ...)`: Sendet `wl_keyboard.key`.
    - `PointerHandle::motion(...)`: Sendet `wl_pointer.motion`, `enter`, `leave`.
    - **Domäne -> System**: `domain::window_management_policy` kann Fokuswechsel anstoßen. `system::window_mechanics::set_application_focus` ruft `keyboard.set_focus(...)`.

#### 2.3. Smithay-Typen und ihre Verwendung

- **`DisplayHandle`**: Zentrales Handle zur Wayland-Display-Instanz. Wird für die Erstellung von Globals, Client-Kommunikation etc. verwendet.
- **`CompositorState`**: Verwaltet `wl_compositor` und `wl_subcompositor` Globals und Client-Zustände.
- **`ShmState`**: Verwaltet `wl_shm` Global und SHM-Puffer.
- **`XdgShellState`**: Verwaltet `xdg_wm_base` Global und XDG-Oberflächen.
- **`OutputManagerState`**: Verwaltet `wl_output` und `zxdg_output_v1` Globals.
- **`SeatState<DesktopState>` / `Seat<DesktopState>`**: Verwalten `wl_seat` und Eingabefähigkeiten. `SeatHandler` wird von `DesktopState` implementiert.
- **`KeyboardHandle`, `PointerHandle`, `TouchHandle`**: Abstraktionen für die Interaktion mit spezifischen Eingabegeräten des Seats.
- **`Space<WindowElement>`**: Smithay's 2D-Raum zur Verwaltung von Fenstern, deren Stapelreihenfolge und zum Rendern. `WindowElement` muss das `smithay::desktop::Window` Trait implementieren.
- **`SurfaceData` (aus `smithay::wayland::compositor`)**: Hängt an `WlSurface` und speichert Puffer, Rolle, Schaden etc. NovaDE wird dies um `novade_system::compositor::surface_management::SurfaceDataExt` (oder ähnliches in `UserDataMap`) erweitern, um anwendungsspezifische Daten wie `DomainWindowIdentifier` und Renderer-Textur-Handles zu speichern.
- **`ClientData` (aus `smithay::reexports::wayland_server::backend`)**: Hängt an `Client` und kann Client-spezifische Zustände speichern (z.B. `CompositorClientState`, `XdgWmBaseClientData`).

**Änderungen an Smithay-Typen und deren Konsequenzen:**

- Das Ändern von Smithay-Typen ist in der Regel nicht vorgesehen, da sie Teil der Bibliothek sind. Man erweitert sie durch UserData oder implementiert Handler-Traits.
- Wenn Smithay eine neue Version mit geänderten Typen veröffentlicht, müssen die Handler-Implementierungen und die Nutzung dieser Typen in NovaDE angepasst werden. Dies erfordert sorgfältige Migration und Tests.
- Das UserData-Muster (`UserDataMap` an `WlSurface`, `Client` etc.) ist der primäre Mechanismus, um anwendungsspezifische Daten mit Smithay-Objekten zu assoziieren, ohne die Typen selbst zu ändern.

#### 2.4. Kommunikation Domäne &lt;-> Compositor

- **Compositor (System) -> Domäne:**
    - **Events**:
        - Neues Fenster (`XdgShellHandler::new_toplevel`): Sendet `WindowCreatedEvent { domain_id, initial_geometry, app_id, title }` an `domain::workspaces::manager` oder einen allgemeinen Event-Bus.
        - Fenster geschlossen (`XdgShellHandler::toplevel_destroyed`): Sendet `WindowClosedEvent { domain_id }`.
        - Fokusänderung durch Benutzer (`SeatHandler::focus_changed`): Sendet `FocusChangedEvent { new_focus_domain_id, old_focus_domain_id }`.
        - Benutzereingabe für Befehlspalette: Sendet spezifisches Event oder ruft Domänen-Service direkt.
        - Output-Änderung (`OutputHandler`): Sendet `OutputConfigurationChangedEvent { ... }`.
    - **Service-Aufrufe (indirekt):** Bei bestimmten Aktionen kann der Compositor Domänenlogik benötigen, z.B. um Standardplatzierung für ein neues Fenster zu erfragen.
- **Domäne -> Compositor (System):**
    - **Service-Aufrufe**:
        - `domain::window_management_policy` gibt `WorkspaceWindowLayout` an `system::window_mechanics`.
        - `system::window_mechanics::apply_workspace_layout` ruft dann z.B. `toplevel_surface.send_configure(...)` oder `space.map_window(...)`.
        - `domain::workspaces::manager` ruft `system::window_mechanics::set_application_focus` auf.
    - Die Systemschicht stellt Traits bereit (z.B. `WindowManipulationApi`), die von Domänendiensten aufgerufen werden können, um Aktionen im Compositor auszulösen. Diese API-Aufrufe werden dann in spezifische Smithay-Operationen übersetzt.

### 3. Protokoll-Implementierungen (D-Bus, XDG Desktop Portals, MCP)

Die Systemschicht implementiert Clients und Server für diese Protokolle und integriert sie mit der Domänenschicht.

#### 3.1. D-Bus (`zbus`)

- **Module in `system::dbus_interfaces`**:
    - **`connection_manager`**: Stellt `DBusConnectionManager` bereit (`session_bus()`, `system_bus()`).
    - **Clients (`upower_client`, `logind_client`, `network_manager_client`, `secrets_service_client`, `policykit_client`)**:
        - Definieren `zbus::proxy` für die D-Bus-Interfaces.
        - Implementieren einen Service (z.B. `UPowerClientService`), der den Proxy nutzt.
        - Abonnieren D-Bus-Signale und konvertieren sie in interne `SystemLayerEvent`s (publiziert über `SystemEventBridge`) oder rufen direkt Domänen-Services auf.
        - Bieten `async` Methoden für die Domänenschicht, um D-Bus-Methoden aufzurufen oder Eigenschaften abzufragen.
    - **Server (`notifications_server`)**:
        - Implementiert das `org.freedesktop.Notifications` Interface mit `#[dbus_interface]`.
        - Ruft Methoden des `domain::user_centric_services::NotificationService`.
        - Abonniert Domänen-Events (`NotificationDismissedEvent`, `NotificationActionInvokedEvent`) und sendet entsprechende D-Bus-Signale (`NotificationClosed`, `ActionInvoked`).
        - Verwaltet ID-Mapping zwischen D-Bus `u32` und Domänen `Uuid`.
- **Integration Domäne**:
    - Domänendienste (z.B. `PowerManagementPolicy`) abonnieren die von D-Bus-Clients publizierten `SystemLayerEvent`s oder haben direkte Handles zu den Client-Services.
    - Domänendienste (z.B. `NotificationService`) werden von D-Bus-Server-Implementierungen aufgerufen.

#### 3.2. XDG Desktop Portals (`system::portals`)

- Implementiert Backend-Logik für ausgewählte Portale (FileChooser, Screenshot).
- Definiert einen Trait `SystemPortalInterface` (o.ä.), den die D-Bus-Objekte der Portale (die in einem separaten Prozess oder Dienst laufen könnten) aufrufen.
- **`FileChooser`**:
    - Empfängt `OpenFile` / `SaveFile` Anfrage von Portal D-Bus Objekt.
    - Sendet Befehl an UI-Schicht (via `SystemEventBridge` oder dedizierter Schnittstelle) zur Anzeige eines GTK-Dateidialogs.
    - Empfängt Ergebnis von UI und sendet es via D-Bus zurück.
- **`Screenshot`**:
    - Empfängt `Screenshot` / `PickColor` Anfrage.
    - Interagiert mit `system::compositor::screencopy` (für Screenshots) oder einer spezifischen Compositor-Funktion (für Farbpipette).
    - Sendet Ergebnis zurück.

#### 3.3. Model Context Protocol (MCP) (`system::mcp_client`)

- Implementiert den `SystemMcpService`-Trait.
- Nutzt `mcp_client_rs::McpClient`.
- **`connection_manager`**: Verwaltet Verbindungen zu MCP-Servern (`McpServerConfig`), startet lokale Prozesse, holt API-Keys via `secrets_service_client`.
- **`service::DefaultSystemMcpService`**:
    - Empfängt Anfragen von `domain::user_centric_services::AIInteractionLogicService` (z.B. `CallToolParams`).
    - Sendet Anfragen via `McpClient::send_request_json`.
    - Handhabt Timeouts.
    - Lauscht auf `McpClient::receive_message()` für Antworten und Notifications.
    - Konvertiert MCP-Antworten/Notifications in `McpClientSystemEvent`s und publiziert sie. `AIInteractionLogicService` abonniert diese Events.

### 4. Implementierbare Lösungen

#### 4.1. Code-Skizzen (Englisch)

Rust

```
// ==== Domain Layer: domain::workspaces::manager ====
// #[async_trait]
// pub trait WorkspaceManagerService: Send + Sync {
//     async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>;
//     // ... other methods
// }

// pub struct DefaultWorkspaceManager {
//     internal: Arc<tokio::sync::Mutex<WorkspaceManagerInternalState>>,
// }

// impl WorkspaceManagerInternalState {
//     async fn set_active_workspace_impl(&mut self, id: WorkspaceId, current_active: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError> {
//         if !self.workspaces.contains_key(&id) {
//             return Err(WorkspaceManagerError::SetActiveWorkspaceNotFound(id));
//         }
//         if self.active_workspace_id == Some(id) {
//             return Ok(());
//         }
//         let old_id = self.active_workspace_id.take();
//         self.active_workspace_id = Some(id);
//         self.ordered_workspace_ids.retain(|ws_id| *ws_id != id);
//         self.ordered_workspace_ids.insert(0, id); // Example: move to front

//         let event = WorkspaceEvent::ActiveWorkspaceChanged { old_id, new_id: id };
//         if self.event_publisher.send(event).is_err() {
//             tracing::warn!("No active subscribers for ActiveWorkspaceChanged event.");
//         }
//         // self.save_configuration_internal_locked().await?; // Persist change
//         Ok(())
//     }
// }

// ==== System Layer: system::compositor::core::state::DesktopState ====
// impl SeatHandler for DesktopState {
//     type KeyboardFocus = WlSurface;
//     type PointerFocus = WlSurface;
//     type TouchFocus = WlSurface;

//     fn seat_state(&mut self) -> &mut SeatState<Self> {
//         &mut self.seat_state
//     }

//     fn focus_changed(&mut self, seat: &Seat<Self>, focused: Option<&WlSurface>) {
//         let new_focus_domain_id = focused.and_then(|s| {
//             // Logic to get DomainWindowIdentifier from WlSurface UserData
//             // Example: s.data_map().get::<SurfaceDataExt>().map(|data_ext| data_ext.domain_id.clone())
//             None // Placeholder
//         });
//         tracing::debug!(seat = %seat.name(), new_focus = ?new_focus_domain_id, "Keyboard focus changed (Wayland)");

//         // Notify domain layer (e.g., window_management_policy or workspace_manager)
//         // This might involve sending an event through the SystemEventBridge or calling a domain service
//         // let event = SystemLayerEvent::InputFocusChanged { new_focus_domain_id };
//         // self.event_bridge.publish(event);

//         // For XDG Shell activation (simplified)
//         if let Some(surface_to_activate) = focused {
//             if let Some(toplevel) = self.space.window_for_surface(surface_to_activate, WindowSurfaceType::TOPLEVEL)
//                 .and_then(|win_elem| match win_elem.as_ref() { // Assuming WindowElement is Arc<ManagedWindow>
//                     WindowElement::Wayland(w) => w.toplevel().ok(),
//                     _ => None,
//                 }) {
//                 toplevel.send_configure(); // To signal state change (active)
//             }
//         }
//         // Deactivate previously focused window
//         // ...
//     }

//     fn cursor_image(&mut self, _seat: &Seat<Self>, image: CursorImageStatus) {
//         // Update self.current_cursor_status for the renderer
//         // *self.current_cursor_status.lock().unwrap() = image;
//         // self.damage_cursor_area(); // Signal renderer to update cursor
//     }
// }

// ==== System Layer: system::dbus_interfaces::upower_client::service ====
// #[async_trait]
// pub trait SystemUPowerClient: Send + Sync {
//    async fn is_on_battery(&self) -> Result<bool, DBusInterfaceError>;
// }

// pub struct UPowerClientService {
//     proxy: UPowerProxy<'static>, // Generated by zbus
//     event_publisher: Arc<SystemEventBridge>,
// }

// impl UPowerClientService {
//     pub async fn new(conn: Arc<Connection>, event_publisher: Arc<SystemEventBridge>) -> Result<Self, DBusInterfaceError> {
//         let proxy = UPowerProxy::new(&conn).await?;
//         let client = Self { proxy, event_publisher };
//         client.start_signal_listeners().await?;
//         Ok(client)
//     }

//     async fn start_signal_listeners(&self) -> Result<(), DBusInterfaceError> {
//         let mut props_changed_stream = self.proxy.receive_properties_changed().await?;
//         let publisher_clone = self.event_publisher.clone();
//         let proxy_clone = self.proxy.clone(); // Proxy is Arc-like or cloneable for tasks

//         tokio::spawn(async move {
//             while let Some(signal) = props_changed_stream.next().await {
//                 if let Ok(args) = signal.args() {
//                     if args.interface_name() == "org.freedesktop.UPower" {
//                         if let Some(Value::Bool(is_on_battery)) = args.changed_properties().get("OnBattery") {
//                             publisher_clone.publish(SystemLayerEvent::UPower(UPowerEvent::OnBatteryChanged(*is_on_battery)));
//                         }
//                         // Handle LidIsClosed, etc.
//                     }
//                 }
//             }
//         });
//         Ok(())
//     }
// }

// #[async_trait]
// impl SystemUPowerClient for UPowerClientService {
//     async fn is_on_battery(&self) -> Result<bool, DBusInterfaceError> {
//         Ok(self.proxy.on_battery().await?)
//     }
// }
```

#### 4.2. Algorithmen

- **Token Resolution Pipeline (`domain::theming::logic`)**:
    1. Sammle Basis-Tokens (globale + Theme-Basis).
    2. Überschreibe mit Varianten-Tokens (Hell/Dunkel).
    3. Wende Akzentfarbe an (ersetze definierte Akzent-Token-IDs).
    4. Überschreibe mit Benutzer-Overrides.
    5. Löse rekursiv `TokenValue::Reference` auf:
        - Verfolge besuchten Pfad zur Zyklenerkennung.
        - Prüfe maximale Rekursionstiefe.
        - Bei fehlender Referenz: Fehler.
    6. Konvertiere alle Werte in finale CSS-Strings.
- **Fenster-Layout-Berechnung (`domain::window_management_policy`)**:
    - Für `TilingMode::Columns`:
        1. Ermittle verfügbare Breite (`available_area.width` - Summe der `gap_settings.window_inner` - `2 * gap_settings.screen_outer_horizontal`).
        2. Teile verfügbare Breite durch Anzahl der zu kachelnden Fenster (`width_per_window`).
        3. Iteriere über Fenster, setze `width = width_per_window`, `height = available_area.height - 2 * gap_settings.screen_outer_vertical`. Positioniere sequentiell mit `gap_settings.window_inner`.
        4. Berücksichtige `WindowLayoutInfo.requested_min_size` und `WindowPolicyOverrides`.
- **Wayland Event zu Domänen-Event (`system::compositor` Handler)**:
    - Beispiel `XdgShellHandler::new_toplevel`:
        1. Wayland-Client sendet `xdg_wm_base.get_xdg_surface` und `xdg_surface.get_toplevel`.
        2. Smithay ruft `XdgShellHandler::new_toplevel(toplevel_surface)`.
        3. Handler in `DesktopState`:
            - Generiert `DomainWindowIdentifier`.
            - Ruft `domain_service.get_initial_window_geometry(domain_id, client_hints)`.
            - Ruft `domain_service.assign_window_to_active_workspace(domain_id)`.
            - Erstellt `WindowElement`, fügt zu `DesktopState.space` und `DesktopState.windows` hinzu.
            - Sendet `configure` Event an `toplevel_surface` mit der von der Domäne bestimmten Geometrie.
            - Publiziert `SystemLayerEvent::WindowCreated` über `SystemEventBridge`.

#### 4.3. Relevante Rust-Bibliotheken

- **Domänenschicht**: `uuid`, `chrono`, `serde`, `serde_json`, `thiserror`, `async-trait`, `tokio` (für `sync`-Primitive wie `Mutex`, `RwLock`, `broadcast`).
- **Systemschicht**:
    - Compositor: `smithay`, `wayland-server`, `wayland-protocols`, `calloop`, `tracing`.
    - Input: `libinput` (C-Lib), `input-rs` (Rust-Bindings für libinput, wird von Smithay genutzt), `xkbcommon` (C-Lib), `xkbcommon-rs` (Rust-Bindings).
    - D-Bus: `zbus`.
    - Audio: `pipewire` (C-Lib), `pipewire-rs` (Rust-Bindings).
    - MCP: `mcp_client_rs`.
    - XDG Portals: `ashpd` (als Referenz oder Nutzung, wenn es Backend-Logik für Portalserver bereitstellt, sonst direkte `zbus`-Implementierung der Portal-D-Bus-Interfaces).
- **Kernschicht**: `thiserror`, `tracing`, `tracing-subscriber`, `serde`, `toml`, `once_cell`, `uuid`, `chrono`.

#### 4.4. Annahmen, Einschränkungen, Alternativen

- **Annahme**: Die `novade-core` Schicht stellt alle spezifizierten Typen (`RectInt`, `Color`, `CoreError`, `ConfigError`, Logging-Init) bereit.
- **Annahme**: Ein `SystemEventBridge` (basierend auf `tokio::sync::broadcast`) existiert für die interne Event-Kommunikation in der Systemschicht und als Adapter zur Domänenschicht.
- **Annahme**: Die Domänenschicht-Services sind `async` und hinter `Arc<dyn TraitName>` zugänglich.
- **Einschränkung**: Detaillierte GPU-Interaktion und Renderer-Implementierung sind noch nicht spezifiziert.
- **Einschränkung**: Komplexität des XWayland-Managements ist nur angedeutet.
- **Alternative (D-Bus)**: `dbus-rs` (älter, synchron) vs. `zbus` (modern, async). `zbus` wird bevorzugt.
- **Alternative (Compositor)**: Direkte Nutzung von `libweston` (C) wäre komplexer in Rust zu integrieren als Smithay.

### 5. Maximale Detailtiefe

Die Spezifikationen versuchen, für jedes Modul und jede Interaktion die folgenden Details abzudecken:

- **Datenstrukturen**: Alle Felder mit exakten Rust-Typen, Sichtbarkeitsmodifikatoren, abgeleitete Traits (`Debug`, `Clone`, `Serialize`, etc.), Invarianten.
- **APIs (Traits/Funktionen)**: Exakte Signaturen (Parameter mit Name und Typ, Rückgabetyp, `async`, `Send`, `Sync`). Vor- und Nachbedingungen.
- **Events**: Struktur des Event-Payloads (alle Felder und Typen). Wer publiziert, wer abonniert (typischerweise). Auslösebedingungen.
- **Fehler**: Spezifische Fehler-Enums pro Modul (`thiserror`), jede Variante mit Bedeutung und ggf. `#[source]` oder `#[from]`.
- **Logik/Algorithmen**: Schritt-für-Schritt-Beschreibung kritischer Abläufe.
- **Interaktionen**: Klare Definition, wie Module und Schichten über APIs und Events kommunizieren.

Diese Detailtiefe zielt darauf ab, Interpretationsspielraum zu minimieren und eine direkte, konsistente Implementierung zu ermöglichen.

---

**Anmerkung zu den bereitgestellten Code-Skizzen:** Die Code-Skizzen sind zur Veranschaulichung und nicht als vollständig kompilierbarer oder fehlerfreier Code gedacht. Sie dienen dazu, die Struktur, Typen und Interaktionen gemäß der Spezifikation aufzuzeigen. Die tatsächliche Implementierung erfordert weitere Details, Fehlerbehandlung und Tests. `block_on` in Smithay-Handlern ist zu vermeiden; stattdessen sollten synchrone Domänenaufrufe oder eine Umstrukturierung für `async` erfolgen. Die Verwendung von `Arc<Mutex<DesktopState>>` und dessen Weitergabe an `tokio::spawn` muss sorgfältig auf Thread-Sicherheit und Deadlocks geprüft werden; oft sind spezifische Daten zu extrahieren oder Kanäle für die Kommunikation mit dem Haupt-Compositor-Thread zu verwenden.


## Technische Spezifikation der Domänenschicht

Basierend auf den bereitgestellten Dokumenten ("Domänenschicht: Theming-Engine – Ultra-Feinspezifikation (Teil 1/4)", "Domänenschicht: Implementierungsleitfaden Teil 2/4 – Workspaces (domain::workspaces)", "Domänenschicht: Detaillierte Spezifikation – Teil 3/4: Benutzerzentrierte Dienste und Globale Einstellungsverwaltung" und "Domänenschicht (Domain Layer) – Teil 4/4: Einstellungs- und Benachrichtigungs-Subsysteme" ) wird hiermit eine eigenständige, konkrete und ausführliche technische Spezifikation für die Entwicklung der Domänenschicht erstellt. Diese Spezifikation beinhaltet allgemeine Entwicklungsrichtlinien sowie spezifische Details zu den einzelnen Modulen der Domänenschicht.

### 1. Allgemeine Prinzipien und Entwicklungsrichtlinien der Domänenschicht

Die Domänenschicht ist das Herzstück der Anwendungslogik und repräsentiert die Geschäftsregeln und -konzepte der Desktop-Umgebung. Sie ist UI-unabhängig und entkoppelt von spezifischen Systemdetails oder Infrastrukturbelangen.

**Entwicklungsrichtlinien:**

- **Sprache und Tooling:** Rust wird als primäre Programmiersprache verwendet.
    - **Fehlerbehandlung:** `thiserror` wird für die Definition spezifischer, benutzerdefinierter Fehler-Enums pro Modul verwendet. Dies ermöglicht eine klare Kommunikation von Fehlerzuständen. Fehler werden über `Result<T, E>` zurückgegeben; `unwrap()` und `expect()` sind zu vermeiden, außer in absoluten Ausnahmefällen. Die `source()`-Kette von Fehlern soll durch korrekte Verwendung von `#[source]` und `#[from]` erhalten bleiben.
        
    - **Serialisierung/Deserialisierung:** `serde` (mit `serde_json` für JSON) wird für das Laden und Speichern von Konfigurationen und Datenstrukturen verwendet. Attribute wie `#[serde(rename_all = "kebab-case")]`, `#[serde(default)]` und `#[serde(skip_serializing_if = "Option::is_none")]` sollen konsistent genutzt werden.
        
    - **Asynchronität:** Wo Operationen potenziell blockierend sind (z.B. I/O beim Laden von Konfigurationen, Kommunikation mit externen Diensten), werden `async/await` und `async_trait` verwendet. Für nebenläufigen Zugriff auf geteilte Zustände sind `tokio::sync` Mechanismen wie `RwLock` und `Mutex` einzusetzen.
        
    - **Eindeutige IDs:** `uuid` (Version 4) wird zur Generierung eindeutiger Identifikatoren für Entitäten verwendet.
        
    - **Zeitstempel:** `chrono::DateTime<Utc>` wird für Zeitstempel verwendet, um Konsistenz zu gewährleisten.
        
    - **Event-Handling:** `tokio::sync::broadcast` wird für ein entkoppeltes, internes Event-System genutzt, um Änderungen an andere Systemteile zu kommunizieren.
        
- **Modularität und Kohäsion:** Die Domänenschicht ist in klar abgegrenzte Module unterteilt, die jeweils spezifische Verantwortlichkeiten haben (z.B. `domain::theming`, `domain::workspaces`, `domain::user_centric_services`, `domain::global_settings_and_state_management`, `domain::notifications_core`, `domain::notifications_rules`). Jedes Modul sollte eine hohe Kohäsion aufweisen und lose mit anderen Modulen gekoppelt sein.
    
- **Typsicherheit:** Newtypes und spezifische Enums werden verwendet, um die Typsicherheit zu erhöhen und die Semantik von Daten klarer zu gestalten (z.B. `TokenIdentifier`, `WorkspaceId`, `SettingKey` ).
    
- **Abstraktion und Schnittstellen:** Öffentliche APIs von Modulen werden oft durch Traits definiert, um Implementierungsdetails zu kapseln und Testbarkeit durch Mocking zu ermöglichen (z.B. `AIInteractionLogicService`, `NotificationService`, `GlobalSettingsService`, `SettingsProvider` ).
    
- **Zustandsverwaltung:** Veränderliche Zustände innerhalb von Services werden typischerweise mit `Arc<Mutex<...>>` oder `Arc<RwLock<...>>` gekapselt, um Thread-Sicherheit zu gewährleisten.
    
- **Validierung:** Eingabedaten und Einstellungsänderungen werden aktiv validiert, um die Konsistenz und Integrität der Domänendaten sicherzustellen.
    
- **Logging:** Das `tracing`-Framework soll für strukturiertes Logging und Debugging verwendet werden.
    
- **Dokumentation:** Öffentliche Typen, Methoden und Felder müssen umfassend mit `rustdoc`-Kommentaren dokumentiert werden, inklusive Vor- und Nachbedingungen, Fehler und Beispiele.
    
- **Testbarkeit:** Unit-Tests sind parallel zur Implementierung zu erstellen und sollen eine hohe Codeabdeckung anstreben. Mocking von Abhängigkeiten (insbesondere von Schnittstellen zur Kern- oder Systemschicht) ist entscheidend.
    

### 2. Struktur und Kernkomponenten der Domänenschicht

Die Domänenschicht besteht aus mehreren Kernmodulen, die spezifische Aufgabenbereiche abdecken:

#### 2.1. Modul: `domain::theming`

- **Verantwortlichkeit:** Logik des Erscheinungsbilds (Theming), Verwaltung von Design-Tokens, Interpretation von Theme-Definitionen, dynamische Theme-Wechsel (Farbschema, Akzentfarben).
    
- **Datenstrukturen:**
    - `TokenIdentifier` (String-Wrapper für hierarchische Token-IDs wie "color.background.primary").
        
    - `TokenValue` (Enum für Token-Wertetypen: Color, Dimension, FontSize, FontFamily, FontWeight, LineHeight, LetterSpacing, Border, Shadow, Radius, Spacing, ZIndex, Opacity, Text, Reference zu anderem Token).
        
    - `RawToken` (Struct: id, value, optionale description, group).
        
    - `TokenSet` (Typalias für `HashMap<TokenIdentifier, RawToken>`).
        
    - `ThemeIdentifier` (String-Wrapper für Theme-IDs).
        
    - `ColorSchemeType` (Enum: Light, Dark).
        
    - `AccentColor` (Struct: optionaler name, value als CSS-Farbwert).
        
    - `ThemeVariantDefinition` (Struct: applies_to_scheme, tokens als TokenSet für Überschreibungen).
        
    - `ThemeDefinition` (Struct: id, name, description, author, version, base_tokens, variants, supported_accent_colors).
        
    - `AppliedThemeState` (Struct: theme_id, color_scheme, active_accent_color, resolved_tokens als `HashMap<TokenIdentifier, String>`).
        
    - `ThemingConfiguration` (Struct: selected_theme_id, preferred_color_scheme, selected_accent_color, custom_user_token_overrides).
        
- **Kernlogik (`ThemingEngine` Service):**
    
    - Laden, Parsen und Validieren von Token- (_.tokens.json) und Theme-Definitionen (_.theme.json) von standardisierten Pfaden (System- und Benutzer-spezifisch). Validierung beinhaltet Eindeutigkeit von Token-IDs und Erkennung zyklischer Referenzen.
        
    - Token Resolution Pipeline: Auflösung von Token-Referenzen und Anwendung von Überschreibungen (Theme-Basis, Variante, Akzentfarbe, Benutzer-Overrides) in definierter Reihenfolge. Ergebnis ist der `AppliedThemeState`.
        
    - Dynamische Theme-Wechsel basierend auf Änderungen in `ThemingConfiguration`.
        
    - Caching von aufgelösten `AppliedThemeState`s.
        
- **Öffentliche API (`ThemingEngine`):**
    - `new(initial_config, theme_load_paths, token_load_paths)`: Konstruktor.
        
    - `get_current_theme_state()`: Gibt aktuellen `AppliedThemeState` zurück.
        
    - `get_available_themes()`: Gibt `Vec<ThemeDefinition>` zurück.
        
    - `get_current_configuration()`: Gibt aktuelle `ThemingConfiguration` zurück.
        
    - `update_configuration(new_config)`: Aktualisiert Konfiguration und löst Neuberechnung aus.
        
    - `reload_themes_and_tokens()`: Lädt alle Definitionen neu.
        
    - `subscribe_to_theme_changes()`: Gibt einen `mpsc::Receiver<ThemeChangedEvent>` zurück.
        
- **Events:** `ThemeChangedEvent { new_state: AppliedThemeState }`.
    
- **Fehlerbehandlung:** `ThemingError` Enum (z.B. `TokenFileParseError`, `CyclicTokenReference`, `ThemeNotFound`, `MissingTokenReference`).
    
- **Dateistruktur:** `domain/theming/{mod.rs, types.rs, errors.rs, logic.rs, default_themes/}`.
    

#### 2.2. Modul: `domain::workspaces`

Verantwortlich für die Logik und Verwaltung von Arbeitsbereichen ("Spaces" oder virtuelle Desktops). Unterteilt in `core`, `assignment`, `manager`, und `config`.

- **`workspaces::core`**: Fundamentale Workspace-Definition.
    
    - **Datenstrukturen:**
        - `WorkspaceId` (Typalias für `uuid::Uuid`).
            
        - `WindowIdentifier` (Newtype für `String`, repräsentiert Fenster-IDs).
            
        - `WorkspaceLayoutType` (Enum: Floating, TilingHorizontal, TilingVertical, Maximized; Default: Floating).
            
        - `Workspace` (Struct: id, name, persistent_id, layout_type, window_ids: `HashSet<WindowIdentifier>`, created_at). Validierungen für `name` (nicht leer, Maximallänge) und `persistent_id`.
            
    - **API (`impl Workspace`):** `new()`, `id()`, `name()`, `rename()`, `layout_type()`, `set_layout_type()`, `add_window_id()` (crate-intern), `remove_window_id()` (crate-intern), `window_ids()`, `persistent_id()`, `set_persistent_id()`, `created_at()`.
        
    - **Event-Payloads (Definiert in `core::event_data`):** `WorkspaceRenamedData`, `WorkspaceLayoutChangedData`, `WindowAddedToWorkspaceData`, `WindowRemovedFromWorkspaceData`, `WorkspacePersistentIdChangedData`.
        
    - **Fehlerbehandlung:** `WorkspaceCoreError` (z.B. `InvalidName`, `NameCannotBeEmpty`, `NameTooLong`, `InvalidPersistentId`).
        
- **`workspaces::assignment`**: Logik zur Fensterzuweisung.
    
    - **API (Freistehende Funktionen):**
        - `assign_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, target_workspace_id, window_id, ensure_unique_assignment: bool)`
            
        - `remove_window_from_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, source_workspace_id, window_id)`
            
        - `move_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, source_workspace_id, target_workspace_id, window_id)`
            
        - `find_workspace_for_window(workspaces: &HashMap<WorkspaceId, Workspace>, window_id) -> Option<WorkspaceId>`
            
    - **Fehlerbehandlung:** `WindowAssignmentError` (z.B. `WorkspaceNotFound`, `WindowAlreadyAssigned`, `WindowNotOnSourceWorkspace`, `CannotMoveToSameWorkspace`, `RuleViolation`).
        
- **`workspaces::manager`**: Orchestrierung und übergeordnete Verwaltung.
    
    - **Zustand (`WorkspaceManager` Struct):** `workspaces: HashMap<WorkspaceId, Workspace>`, `active_workspace_id: Option<WorkspaceId>`, `ordered_workspace_ids: Vec<WorkspaceId>`, `next_workspace_number`, `config_provider: Arc<dyn WorkspaceConfigProvider>`, `event_publisher: Arc<dyn EventPublisher<WorkspaceEvent>>`, `ensure_unique_window_assignment: bool`.
        
    - **API (`impl WorkspaceManager`):** `new()`, `create_workspace()`, `delete_workspace()`, `get_workspace()`, `get_workspace_mut()`, `all_workspaces_ordered()`, `active_workspace_id()`, `set_active_workspace()`, `assign_window_to_active_workspace()`, `assign_window_to_specific_workspace()`, `remove_window_from_its_workspace()`, `move_window_to_specific_workspace()`, `rename_workspace()`, `set_workspace_layout()`, `save_configuration()`.
        
    - **Events (`WorkspaceEvent` Enum):** `WorkspaceCreated`, `WorkspaceDeleted`, `ActiveWorkspaceChanged`, `WorkspaceRenamed`, `WorkspaceLayoutChanged`, `WindowAddedToWorkspace`, `WindowRemovedFromWorkspace`, `WorkspaceOrderChanged`, `WorkspacesReloaded`, `WorkspacePersistentIdChanged`.
        
    - **Fehlerbehandlung:** `WorkspaceManagerError` (z.B. `WorkspaceNotFound`, `CannotDeleteLastWorkspace`, `NoActiveWorkspace`, Wraps: `WorkspaceCoreError`, `WindowAssignmentError`, `WorkspaceConfigError`).
        
- **`workspaces::config`**: Konfigurations- und Persistenzlogik.
    
    - **Datenstrukturen (Snapshots für Persistenz):**
        - `WorkspaceSnapshot` (Struct: persistent_id, name, layout_type).
            
        - `WorkspaceSetSnapshot` (Struct: workspaces: `Vec<WorkspaceSnapshot>`, active_workspace_persistent_id).
            
    - **Schnittstelle (`WorkspaceConfigProvider` Trait):**
        - `load_workspace_config() -> Result<WorkspaceSetSnapshot, WorkspaceConfigError>`
            
        - `save_workspace_config(config_snapshot: &WorkspaceSetSnapshot) -> Result<(), WorkspaceConfigError>`
            
    - **Beispielimplementierung:** `FilesystemConfigProvider` (nutzt `core::config::ConfigService`).
        
    - **Fehlerbehandlung:** `WorkspaceConfigError` (z.B. `LoadError`, `SaveError`, `InvalidData`, `SerializationError`, `DeserializationError`, `PersistentIdNotFound`, `DuplicatePersistentId`).
        

#### 2.3. Modul: `domain::user_centric_services`

Bündelt Logik für KI-Interaktionen (inkl. Einwilligungsmanagement) und ein umfassendes Benachrichtigungssystem.

- **KI-Interaktionsmanagement:**
    - **Datenstrukturen:**
        - `AIInteractionContext` (Struct: id: Uuid, creation_timestamp, active_model_id, consent_status: `AIConsentStatus`, associated_data_categories: `Vec<AIDataCategory>`, interaction_history, attachments: `Vec<AttachmentData>`).
            
        - `AIConsent` (Struct: id: Uuid, user_id, model_id, data_categories: `Vec<AIDataCategory>`, granted_timestamp, expiry_timestamp, is_revoked).
            
        - `AIModelProfile` (Struct: model_id, display_name, description, provider, required_consent_categories: `Vec<AIDataCategory>`, capabilities).
            
        - `AttachmentData` (Struct: id: Uuid, mime_type, source_uri, content, description).
            
        - `AIConsentStatus` (Enum: Granted, Denied, PendingUserAction, NotRequired).
            
        - `AIDataCategory` (Enum: UserProfile, ApplicationUsage, FileSystemRead, ClipboardAccess, LocationData, GenericText, GenericImage).
            
    - **API (`AIInteractionLogicService` Trait):** `initiate_interaction()`, `get_interaction_context()`, `provide_consent()`, `get_consent_for_model()`, `add_attachment_to_context()`, `list_available_models()`, `store_consent()`, `get_all_user_consents()`, `load_model_profiles()`.
        
    - **Events:** `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`.
        
    - **Fehlerbehandlung:** `AIInteractionError` (z.B. `ContextNotFound`, `ConsentRequired`, `ModelNotFound`, `ConsentStorageError`, `ModelProfileLoadError`).
        
- **Benachrichtigungsmanagement:**
    - **Datenstrukturen:**
        - `Notification` (Struct: id: Uuid, application_name, application_icon, summary, body, actions: `Vec<NotificationAction>`, urgency: `NotificationUrgency`, timestamp, is_read, is_dismissed, transient).
            
        - `NotificationAction` (Struct: key, label, action_type: `NotificationActionType`).
            
        - `NotificationUrgency` (Enum: Low, Normal, Critical).
            
        - `NotificationActionType` (Enum: Callback, OpenLink).
            
        - `NotificationFilterCriteria` (Enum: Unread, Application(String), Urgency(NotificationUrgency)).
            
        - `NotificationSortOrder` (Enum: TimestampAscending, TimestampDescending, Urgency).
            
    - **API (`NotificationService` Trait):** `post_notification()`, `get_notification()`, `mark_as_read()`, `dismiss_notification()`, `get_active_notifications()`, `get_notification_history()`, `clear_history()`, `set_do_not_disturb()`, `is_do_not_disturb_enabled()`, `invoke_action()`.
        
    - **Events:** `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `DoNotDisturbModeChangedEvent`.
        
    - **Fehlerbehandlung:** `NotificationError` (z.B. `NotFound`, `InvalidData`, `HistoryFull`, `ActionNotFound`).
        
- **Dateistruktur:** `domain/user_centric_services/{mod.rs, ai_interaction_service.rs, notification_service.rs, types.rs, errors.rs}`.
    

#### 2.4. Modul: `domain::global_settings_and_state_management` (auch `domain::settings_core` + `domain::settings_persistence_iface`)

Verantwortlich für die Repräsentation, Verwaltung und Konsistenz globaler Desktop-Einstellungen.

- **`domain::settings_core`**: Kernlogik der Einstellungsverwaltung.
    
    - **Datenstrukturen:**
        - `SettingKey` (Newtype für `String`, für Einstellungsschlüssel wie "appearance.theme.name").
            
        - `SettingValue` (Enum: Boolean, Integer, Float, String, Color, FilePath, List, Map).
            
        - `SettingMetadata` (Struct: description, default_value, value_type_hint, possible_values, validation_regex, min_value, max_value, is_sensitive, requires_restart).
            
        - `Setting` (Struct: id: Uuid, key, current_value, metadata, last_modified, is_dirty).
            
        - `GlobalDesktopSettings` (Hauptstruktur, die alle globalen Einstellungen kategorisiert, z.B. `AppearanceSettings`, `WorkspaceSettings`, `InputBehaviorSettings`, `PowerManagementPolicySettings`, `DefaultApplicationsSettings`). Jede Unterstruktur enthält spezifische Einstellungsfelder.
            
        - `SettingPath` (Enum-Hierarchie zur typsicheren Adressierung von Einstellungen, z.B. `SettingPath::Appearance(AppearanceSettingPath::FontSettings(FontSettingPath::DefaultFontSize))`).
            
    - **API (`SettingsCoreManager` oder `GlobalSettingsService` Trait):**
        - `new(provider, initial_metadata, event_channel_capacity)` / `load_settings()`
            
        - `save_settings()`
            
        - `get_current_settings()` / `get_setting_value(key)` / `get_setting(path)`
            
        - `set_setting_value(key, value)` / `update_setting(path, value: JsonValue)`
            
        - `reset_setting_to_default(key)` / `reset_to_defaults()`
            
        - `register_setting_metadata(key, metadata)`
            
        - `get_all_settings_with_metadata()`
            
        - `subscribe_to_changes()` / `subscribe_to_setting_changes()`
            
    - **Events:** `SettingChangedEvent { key/path, new_value }`, `SettingsLoadedEvent { settings }`, `SettingsSavedEvent`.
        
    - **Fehlerbehandlung:** `SettingsCoreError` / `GlobalSettingsError` (z.B. `SettingNotFound`, `ValidationError`, `PersistenceError`, `PathNotFound`, `InvalidValueType`).
        
- **`domain::settings_persistence_iface`**: Persistenzabstraktion.
    
    - **Schnittstelle (`SettingsProvider` Trait):**
        - `load_setting(key) -> Result<Option<SettingValue>, SettingsPersistenceError>`
            
        - `save_setting(key, value) -> Result<(), SettingsPersistenceError>`
            
        - `load_all_settings() -> Result<Vec<(SettingKey, SettingValue)>, SettingsPersistenceError>`
            
        - `delete_setting(key) -> Result<(), SettingsPersistenceError>`
            
        - `setting_exists(key) -> Result<bool, SettingsPersistenceError>`
            
    - **Fehlerbehandlung:** `SettingsPersistenceError` (z.B. `BackendUnavailable`, `StorageAccessError`, `SerializationError`, `DeserializationError`, `IoError`).
        
- **Dateistruktur (Global Settings):** `domain/global_settings_management/{mod.rs, service.rs, types.rs, paths.rs, errors.rs}`.
    
- **Dateistruktur (Settings Core & Persistence Interface):** `domain/src/settings_core/{mod.rs, types.rs, error.rs}`, `domain/src/settings_persistence_iface/{mod.rs, error.rs}`.
    

#### 2.5. Modul: `domain::notifications_rules`

Implementiert die Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf konfigurierbaren Regeln.

- **Verantwortlichkeit:** Definition von Benachrichtigungsregeln (`NotificationRule`), deren Bedingungen (`RuleCondition`) und Aktionen (`RuleAction`); Bereitstellung einer Engine (`NotificationRulesEngine`) zur Regelauswertung und -anwendung.
    
- **Datenstrukturen:**
    - `RuleCondition` (Enum: AppNameIs, AppNameMatches (Regex), SummaryContains, UrgencyIs, CategoryIs, HintExists, HintValueIs, SettingIsTrue, LogicalAnd, LogicalOr, LogicalNot etc.).
        
    - `RuleAction` (Enum: SuppressNotification, SetUrgency, AddAction, SetHint, PlaySound, MarkAsPersistent, SetExpiration, LogMessage etc.).
        
    - `NotificationRule` (Struct: id, description, conditions: `RuleCondition`, actions: `Vec<RuleAction>`, is_enabled, priority, stop_after).
        
- **Kernlogik (`NotificationRulesEngine` Service):**
    - Lädt und verwaltet Regeldefinitionen (sortiert nach Priorität).
        
    - `process_notification(notification)`: Wertet Regeln gegen eine eingehende Benachrichtigung aus.
        
        - Gibt `RuleProcessingResult` zurück: `Allow(modified_notification)` oder `Suppress(rule_id)`.
            
    - `evaluate_condition(condition, notification, rule)`: Rekursive Auswertung von Regelbedingungen. Interagiert mit `SettingsCoreManager` für `Setting*`-Bedingungen.
        
    - `apply_action(action, notification, rule)`: Anwendung von Regelaktionen auf eine Benachrichtigung.
        
    - Reagiert auf `SettingChangedEvent` (optional, zur Cache-Invalidierung oder Neubewertung).
        
- **Öffentliche API (`NotificationRulesEngine`):**
    - `new(settings_manager, initial_rules, settings_event_receiver)`
        
    - `load_rules(new_rules)`
        
    - `process_notification(notification) -> Result<RuleProcessingResult, NotificationRulesError>`
        
    - `handle_setting_changed(event)` (intern aufgerufen).
        
- **Fehlerbehandlung:** `NotificationRulesError` (z.B. `InvalidRuleDefinition`, `ConditionEvaluationError`, `ActionApplicationError`, `SettingsAccessError`).
    
- **Dateistruktur:** `domain/src/notifications_rules/{mod.rs, types.rs, error.rs}`.

### 3. Interaktionen und Abhängigkeiten

- **Domänenmodule untereinander:**
    - `NotificationCoreManager` nutzt `NotificationRulesEngine` zur Verarbeitung von Benachrichtigungen.
        
    - `NotificationRulesEngine` nutzt `SettingsCoreManager` (oder `GlobalSettingsService`), um regelbedingte Einstellungen abzufragen.
        
    - `ThemingEngine` reagiert auf `SettingChangedEvent` von `SettingsCoreManager` für themenrelevante Einstellungen.
        
    - Services aus `domain::user_centric_services` und `domain::workspaces` können globale Einstellungen von `GlobalSettingsService` lesen.
        
- **Abhängigkeiten zur Kernschicht (`core::*`):**
    - `core::config`: Wird von `domain::settings_persistence_iface`-Implementierungen und `domain::workspaces::config` für das Lesen/Schreiben von Konfigurationsdateien genutzt.
        
    - `core::errors`: Basisfehlertypen können in Domänenfehler gewrappt werden.
        
    - `core::types`: Fundamentale Typen wie `Uuid`, `DateTime<Utc>`.
        
    - `core::logging` (`tracing`): Wird für Logging verwendet.
        
- **Schnittstellen zu höheren Schichten (System- und UI-Schicht):**
    - Die Domänenschicht stellt ihre Funktionalität über öffentliche APIs (oft Traits) ihrer Service-Komponenten bereit.
        
    - Die UI-Schicht (z.B. `ui::control_center`, `ui::shell` ) konsumiert diese APIs und reagiert auf Events aus der Domänenschicht.
        
    - Die Systemschicht (z.B. MCP-Client, D-Bus Handler, Compositor ) interagiert ebenfalls mit den Domänendiensten und leitet Systemereignisse an diese weiter oder setzt deren Anweisungen um.
        

### 4. Zusammenfassende Betrachtungen

Die Domänenschicht ist als eine Sammlung modularer, voneinander entkoppelter Komponenten konzipiert, die jeweils klar definierte Verantwortlichkeiten besitzen. Durch die konsequente Anwendung von Prinzipien wie Typsicherheit, expliziter Fehlerbehandlung, Event-basierter Kommunikation und der Abstraktion von Persistenz- und UI-Belangen wird eine robuste, wartbare und erweiterbare Grundlage für die Desktop-Umgebung geschaffen. Die detaillierten Spezifikationen der einzelnen Module, ihrer Datenstrukturen, APIs und Fehlerfälle dienen als direkter Leitfaden für die Implementierung.

## Technische Spezifikation und Entwicklungsrichtlinien: Systemschicht

Die Systemschicht bildet das Fundament der Desktop-Umgebung und ist verantwortlich für die Kernfunktionalitäten, die Interaktion mit der Hardware und die Bereitstellung grundlegender Dienste für höhere Schichten. Sie implementiert die "Mechanik" der Desktop-Umgebung, indem sie übergeordnete Richtlinien und Benutzerinteraktionen in konkrete Systemaktionen übersetzt. Dies erfordert eine präzise und robuste Interaktion mit Wayland-Protokollen, D-Bus-Systemdiensten und potenziell direkter Hardware-Interaktion (z.B. DRM). Die Stabilität und Reaktionsfähigkeit der gesamten Umgebung hängt maßgeblich von der Zuverlässigkeit dieser Schicht ab. Daher sind Resilienz, asynchrone Operationen, umfassendes Fehlermanagement und sorgfältige Zustandssynchronisation zentrale Entwurfsprinzipien.

### 1. Entwicklungsrichtlinien

Die Entwicklung aller Komponenten der Systemschicht muss strengen Richtlinien folgen, um Konsistenz, Qualität und Wartbarkeit zu gewährleisten.

- **Programmiersprache:** Rust ist die primäre Programmiersprache.
    
- **Coding Style & Formatierung:** Verbindliche Nutzung von `rustfmt` mit Standardkonfiguration. Einhaltung der Rust API Guidelines ist erforderlich.
    
- **API-Design:** Befolgung der Rust API Guidelines Checklist für konsistente und idiomatische Schnittstellen.
    
- **Fehlerbehandlung:** Konsequente Verwendung des `thiserror`-Crates zur Definition spezifischer Fehler-Enums pro Modul (z.B. `CompositorCoreError`, `ShmError`, `XdgShellError`, `DBusError`, `OutputError`, `AudioError`, `McpError`, `PortalsError`). Alle öffentlichen Funktionen in den Modulen sollten `Result<T, SpecificError>` zurückgeben.
    
- **Logging & Tracing:** Einsatz des `tracing`-Crate-Frameworks (`tracing::{info, debug, error}`) für strukturiertes, kontextbezogenes Logging und Tracing von Operationen.
    
- **Dokumentkonventionen:** Eine Tabelle mit definierten Begriffen und Konventionen (z.B. `DesktopState`, `WlFoo`, `XdgFoo`) wird verwendet, um Klarheit und Konsistenz in der Terminologie sicherzustellen.
    
- **Asynchronität:** Asynchrone Operationen sind für alle potenziell blockierenden E/A-Vorgänge zu verwenden, insbesondere bei D-Bus-Aufrufen (mittels `zbus`) und Wayland-Ereignisverarbeitung.
    
- **Strikte Einhaltung der Gesamtspezifikation:** Die hier beschriebenen Spezifikationen sind eine detaillierte Erweiterung der "Technischen Gesamtspezifikation und Entwicklungsrichtlinien". Deren Einhaltung ist bindend.
    

### 2. Modul: `system::compositor` (Smithay-basierter Wayland Compositor)

Dieses Modul implementiert die Kernlogik des Wayland-Compositors unter Verwendung des Smithay-Toolkits. Es ist verantwortlich für die Verwaltung von Wayland-Client-Verbindungen, Oberflächen, Pufferbehandlung und die Integration mit Shell-Protokollen. Die Designphilosophie von Smithay erfordert ein signifikantes Zustandsmanagement innerhalb der zentralen `DesktopState`-Struktur.

#### 2.1. Submodul: `system::compositor::core`

Dieses Submodul etabliert die grundlegenden Elemente für die Verwaltung von Wayland-Oberflächen und die Kernoperationen des Compositors.

**Dateien:**

- `compositor_state.rs`:
    - **Zweck:** Definiert und verwaltet den primären Zustand für die Globals `wl_compositor` und `wl_subcompositor` und handhabt den Client-spezifischen Compositor-Zustand.
        
    - **Struktur `CompositorCoreError`:** Definiert Fehler spezifisch für Kernoperationen des Compositors mittels `thiserror`. Varianten umfassen `GlobalCreationFailed`, `RoleError`, `ClientDataMissing`, `SurfaceDataMissing`, `InvalidSurfaceState`.
        
    - **Struktur `DesktopState` (teilweise):** Kapselt den zentralen Zustand. Enthält `compositor_state: CompositorState`, `display_handle: DisplayHandle`, `loop_handle: LoopHandle<Self>`. Ein Konstruktor `new(display_handle, loop_handle)` initialisiert diese Felder.
        
    - **Struktur `ClientCompositorData`:** Speichert `CompositorClientState` pro Client.
        
    - **Implementierung `CompositorHandler` für `DesktopState`:** Delegiert Compositor-Ereignisse an die Anwendungslogik.
        
        - `compositor_state()`: Gibt `&mut self.compositor_state` zurück.
            
        - `client_compositor_state()`: Ruft `ClientCompositorData` aus `Client::get_data()` ab und gibt `&compositor_state` daraus zurück. Loggt Fehler und panicked bei fehlenden Daten.
            
        - `commit()`: Greift auf `SurfaceData` zu, prüft auf neue Puffer, aktualisiert Schadensverfolgung, löst rollenspezifische Logik aus und markiert die Oberfläche für Neuzeichnung. Verwendet `smithay::wayland::compositor::with_states`.
            
        - `new_surface()`: Initialisiert `SurfaceData` für die neue `WlSurface` und speichert sie in deren `data_map`. Fügt einen Zerstörungs-Hook hinzu.
            
        - `new_subsurface()`: Aktualisiert `SurfaceData` der neuen und der Eltern-Oberfläche, um die Eltern-Kind-Beziehung herzustellen.
            
        - `destroyed()`: Die primäre Bereinigung wird von Smithay gehandhabt. Externe Referenzen müssen hier oder über Zerstörungs-Hooks bereinigt werden.
            
    - **Implementierung `GlobalDispatch<WlCompositor, ()>` für `DesktopState`:**
        - `bind()`: Protokolliert die Bind-Anfrage, initialisiert bei Bedarf `ClientCompositorData` für den Client und initialisiert die Ressource mit `data_init.init()`. `CompositorState::new()` erstellt das Global.
            
    - **Implementierung `GlobalDispatch<WlSubcompositor, ()>` für `DesktopState`:**
        - `bind()`: Protokolliert die Bind-Anfrage und initialisiert die Ressource. `CompositorState::new()` erstellt das Global.
            
- `surface_management.rs`:
    - **Zweck:** Definiert `SurfaceData` und zugehörige Hilfsfunktionen.
        
    - **Struktur `SurfaceData`:** Gespeichert in der `UserDataMap` jeder `WlSurface`. Enthält Felder wie `id: uuid::Uuid`, `role: Option<String>`, `client_id`, `current_buffer`, `pending_buffer`, `texture_id` (als `Option<Box<dyn RenderableTexture>>`), `last_commit_serial`, `damage_regions_buffer_coords`, `opaque_region`, `input_region`, `user_data_ext`, `parent`, `children`, `pre_commit_hooks`, `post_commit_hooks`, `destruction_hooks`. `RenderableTexture` muss `Send + Sync` sein.
        
    - **Methoden für `SurfaceData`:** `new()`, `set_role()`, `get_role()`, `attach_buffer()`, `commit_buffer()`, `add_damage_buffer_coords()`, `take_damage_buffer_coords()`.
        
    - **Enum `SurfaceRoleError`:** Variante `RoleAlreadySet`.
        
    - **Funktionen:** `get_surface_data()`, `with_surface_data()` (kapselt Mutex-Locking), `give_surface_role()` (verwendet `smithay::wayland::compositor::give_role`), `get_surface_role()` (verwendet `smithay::wayland::compositor::get_role`).
        
- `global_objects.rs`:
    - **Zweck:** Zentralisiert die Erstellung der Kern-Wayland-Globals.
        
    - **Funktion `create_core_compositor_globals()`:** Erstellt `CompositorState` und speichert es in `DesktopState`. Dies registriert intern `wl_compositor` (Version 6) und `wl_subcompositor` (Version 1).
        

#### 2.2. Submodul: `system::compositor::shm` (SHM-Pufferbehandlung)

Dieses Submodul implementiert die Unterstützung für `wl_shm`, wodurch Clients Shared-Memory-Puffer mit dem Compositor teilen können.

**Dateien:**

- `shm_state.rs`:
    - **Zweck:** Verwaltet das `wl_shm`-Global und handhabt die Erstellung und den Zugriff auf SHM-Puffer.
        
    - **Struktur `ShmError`:** Definiert Fehler für SHM-Operationen (z.B. `PoolCreationFailed`, `BufferCreationFailed`, `InvalidFormat`, `AccessError`).
        
    - **`DesktopState` (teilweise):** Enthält `shm_state: ShmState` und `shm_global: GlobalId`.
        
    - **Implementierung `ShmHandler` für `DesktopState`:**
        - `shm_state()`: Gibt `&self.shm_state` zurück.
            
    - **Implementierung `BufferHandler` für `DesktopState`:** (Gilt für alle `wl_buffer`, nicht nur SHM)
        
        - `buffer_destroyed()`: Protokolliert, benachrichtigt das Rendering-Backend zur Ressourcenfreigabe und entfernt Puffer-Referenzen aus `SurfaceData`-Instanzen.
            
    - **Implementierung `GlobalDispatch<WlShm, ()>` für `DesktopState`:**
        - `bind()`: Protokolliert die Bindung und initialisiert die Ressource. `ShmState` sendet `format`-Ereignisse.
            
    - **Funktion `create_shm_global()`:** Definiert unterstützte SHM-Formate (Standard: ARGB8888, XRGB8888), erstellt `ShmState`, speichert `shm_state` und `shm_global` (zurückgegeben von `shm_state.global().clone()`) in `DesktopState`.
        
- `shm_buffer_access.rs`:
    - **Zweck:** Bietet sicheren Zugriff auf Inhalte von SHM-Puffern.
        
    - **Funktion `with_shm_buffer_contents()`:** Verwendet intern `smithay::wayland::shm::with_buffer_contents`, um einen Callback mit Zeiger und Länge der Pufferdaten aufzurufen. Kapselt die Unsicherheit der Zeiger-Dereferenzierung.
        

#### 2.3. Submodul: `system::compositor::xdg_shell` (XDG-Shell-Integration)

Implementiert das `xdg_shell`-Protokoll zur Verwaltung moderner Desktop-Fenster (Toplevels und Popups). Das Protokoll ist komplex und erfordert signifikante Logik in den Handler-Methoden, um Oberflächenzustände, Interaktionen mit der Fenstermanagement-Richtlinie und das Senden korrekter Wayland-Ereignisse zu verwalten. Eine robuste Fehlerbehandlung und Zustandsvalidierung sind entscheidend.

**Dateien:**

- `xdg_shell_state.rs`:
    - **Zweck:** Verwaltet das `xdg_wm_base`-Global und die zugehörigen XDG-Oberflächenzustände.
        
    - **Struktur `XdgShellError`:** Definiert Fehler wie `InvalidSurfaceRole`, `WindowHandlingError`, `PopupPositioningError`, `InvalidAckConfigureSerial`, `ToplevelNotFound`, `PopupNotFound`.
        
    - **`DesktopState` (teilweise):** Enthält `xdg_shell_state: XdgShellState`, `xdg_shell_global: GlobalId`, `toplevels: HashMap<WlSurface, Arc<Mutex<ManagedToplevel>>>`, `popups: HashMap<WlSurface, Arc<Mutex<ManagedPopup>>>`.
        
    - **Implementierung `XdgShellHandler` für `DesktopState`:** Die Implementierung der Methoden wird in `xdg_handlers.rs` detailliert. `xdg_shell_state()` gibt `&mut self.xdg_shell_state` zurück.
        
    - **Implementierung `GlobalDispatch<XdgWmBase, GlobalId>` für `DesktopState`:**
        - `bind()`: Protokolliert, ruft `state.xdg_shell_state.new_client()` auf, um `ShellClientUserData` zu erhalten, und initialisiert die Ressource damit. `XdgShellState` handhabt das Ping/Pong-Verhalten.
            
    - **Funktion `create_xdg_shell_global()`:** Erstellt `XdgShellState`, ruft dessen `global()`-Methode auf und speichert beides in `DesktopState`.
        
- `toplevel_management.rs`:
    - **Zweck:** Definiert Datenstrukturen und Logik spezifisch für XDG-Toplevel-Fenster.
        
    - **Struktur `ManagedToplevel`:** Kapselt `ToplevelSurface` von Smithay und fügt anwendungsspezifische Zustände hinzu. Felder umfassen `id: uuid::Uuid`, `surface_handle: ToplevelSurface`, `wl_surface: WlSurface`, `app_id`, `title`, `current_state: ToplevelWindowState`, `pending_state: ToplevelWindowState`, `window_geometry`, `min_size`, `max_size`, `parent` (für transiente Fenster), `client_provides_decorations`, `last_configure_serial`, `acked_configure_serial`. Methoden: `new()`, `send_configure()` (sendet `xdg_toplevel.configure` und `xdg_surface.configure`), `ack_configure()`.
        
    - **Struktur `ToplevelWindowState`:** Felder: `size`, `maximized`, `fullscreen`, `resizing`, `activated`, `suspended`, `decorations`.
        
    - **Struktur `ToplevelSurfaceUserData`:** In `WlSurface::data_map()` gespeichert, enthält `managed_toplevel_id`.
        
- `popup_management.rs`:
    - **Zweck:** Definiert Datenstrukturen und Logik spezifisch für XDG-Popup-Fenster.
        
    - **Struktur `ManagedPopup`:** Kapselt `PopupSurface` von Smithay. Felder: `id: uuid::Uuid`, `surface_handle: PopupSurface`, `wl_surface: WlSurface`, `parent_wl_surface`, `positioner_state: PositionerState`, `current_geometry`, `last_configure_serial`, `acked_configure_serial`. Methoden: `new()`, `send_configure()`, `ack_configure()`, `calculate_geometry()`.
        
    - **Struktur `PopupSurfaceUserData`:** In `WlSurface::data_map()` gespeichert, enthält `managed_popup_id`.
        
- `xdg_handlers.rs`:
    - **Zweck:** Detaillierte Implementierung der `XdgShellHandler`-Methoden für `DesktopState`.
        
    - `new_toplevel()`: Erstellt `ManagedToplevel`, speichert es in `state.toplevels` und dessen ID in `ToplevelSurfaceUserData` der `WlSurface`. Sendet initiale Konfiguration.
        
    - `new_popup()`: Erstellt `ManagedPopup`, speichert es in `state.popups` und dessen ID in `PopupSurfaceUserData`. Sendet initiale Konfiguration.
        
    - `map_toplevel()`: Führt Logik für das Mapping des Toplevels aus (Sichtbarkeit, initiale Position/Größe), ruft ggf. `send_configure()` auf.
        
    - `ack_configure()`: Verarbeitet `ack_configure` vom Client für Toplevels oder Popups, ruft `ack_configure()` auf der `ManagedEntity` auf.
        
    - `toplevel_request_set_title()`: Aktualisiert `title` im `ManagedToplevel` und benachrichtigt die UI-Schicht.
        
    - Weitere Handler (z.B. für `set_app_id`, `set_maximized`, `move`, `resize`) werden analog implementiert, aktualisieren den Zustand von `ManagedToplevel`/`ManagedPopup` und lösen ggf. neue `configure`-Zyklen aus oder interagieren mit dem Input-System.
        

#### 2.4. Submodul: `system::compositor::display_loop` (Display und Ereignisschleife)

Verantwortlich für die Einrichtung des Wayland-Display-Kernobjekts und dessen Integration in die `calloop`-Ereignisschleife. Die `calloop`-Ereignisschleife ist zentral für Smithay. Langlaufende Operationen in Callbacks müssen vermieden werden.

**Dateien:**

- `display_setup.rs`:
    - **Zweck:** Initialisiert das Wayland Display und `DisplayHandle`.
        
    - **Struktur `ClientData`:** Assoziiert mit `wayland_server::Client`. Enthält `id: uuid::Uuid`, `client_name: Option<String>`, `user_data: UserDataMap`.
        
    - **Funktion `init_wayland_display_and_loop()` (konzeptionell):** Erstellt `EventLoop<DesktopState>` und `Display<DesktopState>`. `DisplayHandle` und `LoopHandle` werden in `DesktopState` gespeichert.
        
    - **Enum `InitError`:** Varianten `WaylandDisplayCreationFailed`, `EventLoopCreationFailed`.
        
- `event_loop_integration.rs`:
    - **Zweck:** Integriert die Wayland-Anzeige in die `calloop`-Ereignisschleife.
        
    - **Funktion `register_wayland_source()`:** Ruft den Dateideskriptor der Wayland-Anzeige ab. Erstellt eine `calloop::generic::Generic<FileDescriptor>`-Ereignisquelle. Fügt die Quelle in die Ereignisschleife ein (`loop_handle.insert_source()`). Der Callback ruft `shared_data.display_handle.dispatch_clients(shared_data)` auf und bei Erfolg `shared_data.display_handle.flush_clients()`. `display_handle.flush_clients()` muss regelmäßig aufgerufen werden.
        

#### 2.5. Submodul: `system::compositor::renderer_interface` (Renderer-Schnittstelle)

Definiert abstrakte Schnittstellen für Rendering-Operationen, um die Kernlogik des Compositors von spezifischen Rendering-Backends zu entkoppeln (z.B. DRM/GBM, Winit/EGL). Schadensverfolgung ist für effizientes Rendering unerlässlich und muss integriert werden.

**Dateien:**

- `abstraction.rs`:
    - **Zweck:** Definiert Traits für Rendering-Operationen.
        
    - **Trait `FrameRenderer`:**
        - Methoden: `new()`, `render_frame()` (nimmt `RenderElement`), `present_frame()`, `create_texture_from_shm()`, `create_texture_from_dmabuf()` (für spätere Teile), `screen_size()`.
            
    - **Trait `RenderableTexture` (`Send + Sync + Debug`):**
        - Methoden: `id() -> uuid::Uuid`, `bind()`, `width_px()`, `height_px()`, `format()`.
            
    - **Enum `RenderElement` (konzeptionell, analog zu Smithays `Element`):** Varianten `Surface` (mit `texture: Arc<dyn RenderableTexture>`), `SolidColor`, `Cursor`.
        
    - **Struktur `Color`:** Felder `r, g, b, a` als `f32`.
        
    - **Enum `RendererError`:** Varianten `ContextCreationFailed`, `ShaderCompilationFailed`, `TextureUploadFailed`, `BufferSwapFailed`, `InvalidBufferType`, `DrmError`, `EglError`, `Generic`.
        

### 3. Modul: `system::input` (Libinput-basierte Eingabeverarbeitung)

Verantwortlich für die gesamte Verarbeitung von Benutzereingaben von Geräten wie Tastaturen, Mäusen und Touchpads. Nutzt `libinput` für Rohdaten und Smithay-Abstraktionen (`LibinputInputBackend`, `SeatState`, `SeatHandler`) für Seat- und Fokusmanagement. Latenz oder fehlerhafte Verarbeitung hier beeinträchtigen die UX erheblich. Die Transformation von `libinput`-Ereignissen in Wayland-Ereignisse, inklusive Koordinatentransformationen und Fokuslogik, muss präzise sein. Erweiterte Eingabefunktionen wie Gesten müssen berücksichtigt werden. `xkbcommon` ist fundamental für die korrekte Interpretation von Tastatureingaben.

#### 3.1. Submodul: `system::input::seat_manager`

Definiert und verwaltet `SeatState` und `SeatHandler` für Eingabefokus und die Bekanntmachung von Fähigkeiten.

**Dateien:**

- `seat_state.rs`:
    - **Struktur `InputError`:** Definiert Fehler wie `SeatCreationFailed`, `CapabilityAdditionFailed`, `XkbConfigError`, `LibinputError`, `SeatNotFound`, `KeyboardHandleNotFound`, etc..
        
    - **`DesktopState` (teilweise):** Enthält `seat_state: SeatState<Self>`, `seats: HashMap<String, Seat<Self>>`, `active_seat_name: Option<String>`, `keyboards: HashMap<String, XkbKeyboardData>`.
        
    - **Implementierung `SeatHandler` für `DesktopState`:**
        - `KeyboardFocus = WlSurface`, `PointerFocus = WlSurface`, `TouchFocus = WlSurface`.
            
        - `seat_state()`: Gibt `&mut self.seat_state` zurück.
            
        - `focus_changed()`: Protokolliert Fokusänderung. Ruft `KeyboardHandle::leave()` für alten Fokus und `KeyboardHandle::enter()` für neuen Fokus auf (mit aktuellen Tasten und Modifikatoren). Aktualisiert interne Fenstermanagement-Zustände.
            
        - `cursor_image()`: Handhabt `CursorImageStatus::Hidden`, `CursorImageStatus::Surface` (prüft Rolle "cursor", ruft Puffer/Hotspot ab) und `CursorImageStatus::Named` (verwendet Cursor-Theming-Bibliothek). Weist Renderer an, den Cursor zu zeichnen/aktualisieren.
            
    - **Funktion `create_seat()`:** Ruft `state.seat_state.new_wl_seat()` auf. Fügt Fähigkeiten hinzu (`seat.add_keyboard()`, `seat.add_pointer()`, `seat.add_touch()`). Speichert `Seat`-Objekt und `XkbKeyboardData`. Setzt ggf. `active_seat_name`.
        

#### 3.2. Submodul: `system::input::libinput_handler`

Initialisiert und konfiguriert das `LibinputInputBackend` und verarbeitet dessen Ereignisse.

**Dateien:**

- `backend_config.rs`:
    - **Struktur `LibinputSessionInterface`:** Wrapper für `input::LibinputInterface` zum Öffnen/Schließen von Geräten über ein Session-Objekt (z.B. `DirectSession`, `LogindSession`).
        
    - **Funktion `init_libinput_backend()`:** Erstellt `libinput::Libinput`-Kontext mit `Libinput::new_from_path(session_interface)`. Weist dem Kontext einen Seat zu (`udev_assign_seat("seat0")`). Erstellt und gibt `LibinputInputBackend` zurück.
        
- `event_dispatcher.rs`:
    - **Zweck:** Verarbeitet `InputEvent<LibinputInputBackend>` und leitet an spezifische Handler weiter.
        
    - **Funktion `process_input_event()`:** Wird vom `calloop`-Callback aufgerufen. Ruft den aktiven Seat ab. Verarbeitet verschiedene `InputEvent`-Varianten (`Keyboard`, `PointerMotion`, `PointerButton`, `PointerAxis`, `TouchDown`, `TouchUp`, `TouchMotion`, `TouchFrame`, `TouchCancel`, `Gesture*`, `DeviceAdded`, `DeviceRemoved`) durch Aufruf entsprechender Handler-Funktionen in den jeweiligen Submodulen (`keyboard::key_event_translator`, `pointer::pointer_event_translator`, `touch::touch_event_translator`). Gestenereignisse werden initial nur protokolliert. Bei `DeviceAdded`/`DeviceRemoved` werden Seat-Fähigkeiten ggf. aktualisiert.
        

#### 3.3. Submodul: `system::input::keyboard`

Verwaltet XKB-Keymap und -Status für Tastaturen, übersetzt `KeyboardKeyEvent` und handhabt Tastaturfokus.

**Dateien:**

- `xkb_config.rs`:
    - **Struktur `XkbKeyboardData`:** Enthält `context: xkbcommon::xkb::Context`, `keymap: xkbcommon::xkb::Keymap`, `state: xkbcommon::xkb::State`, `repeat_timer: Option<calloop::TimerHandle>`, `repeat_info`, `focused_surface_on_seat`, `repeat_key_serial`.
        
    - **Funktion `new_xkb_keyboard_data()`:** Erstellt `xkbcommon::xkb::Context`, `xkbcommon::xkb::RuleNames` (aus `XkbConfig`), `xkbcommon::xkb::Keymap` und `xkbcommon::xkb::State`.
        
    - **Funktion `update_xkb_state_from_modifiers()`:** Ruft `xkb_state.update_mask()` auf.
        
- `key_event_translator.rs`:
    - **Funktion `handle_keyboard_key_event()`:** Ruft Keyboard-Handle und `XkbKeyboardData` ab. Aktualisiert `xkb_data.state` mit `update_key()`. Ruft `ModifiersState` von `xkb_data.state` ab und informiert `KeyboardHandle`. Sendet `keyboard_handle.input()` mit Keysym und UTF-8 (für `KeyState::Pressed`). Richtet Tastenwiederholung mittels `calloop::Timer` ein/bricht sie ab, basierend auf `keyboard_handle.repeat_info()`.
        
- `focus_handler_keyboard.rs`:
    - **Funktion `set_keyboard_focus()`:** Ruft Seat und Keyboard-Handle ab. Ermittelt alten Fokus. Sendet `keyboard_handle.leave()` für alten Fokus und `keyboard_handle.enter()` (mit gedrückten Tasten/Modifikatoren) für neuen Fokus. Aktualisiert `xkb_data.focused_surface_on_seat`. Ruft `keyboard_handle.set_focus()` auf.
        

#### 3.4. Submodul: `system::input::pointer`

Verarbeitet Zeigerereignisse, handhabt Zeigerfokus und Cursor-Aktualisierungen.

**Dateien:**

- `pointer_event_translator.rs`:
    - **Funktion `handle_pointer_motion_event()`:** Ruft Pointer-Handle ab. Aktualisiert globale Cursorposition. Bestimmt neuen Zeigerfokus basierend auf globaler Position und sichtbaren Toplevel-Oberflächen/Eingaberegionen (`find_surface_at_global_coords()`). Ruft `update_pointer_focus_and_send_motion()` auf. Aktualisiert Renderer-Cursorposition.
        
    - **Funktion `handle_pointer_motion_absolute_event()`:** Ähnlich wie Motion, aber verwendet absolute Koordinaten (`event.x_transformed()`, `event.y_transformed()`).
        
    - **Funktion `handle_pointer_button_event()`:** Ruft Pointer-Handle ab. Sendet `pointer_handle.button()`. Ändert ggf. Tastaturfokus (Click-to-Focus) und behandelt Fenstermanagement-Interaktionen (z.B. Start von Move/Resize-Grab).
        
    - **Funktion `handle_pointer_axis_event()`:** Ruft Pointer-Handle ab. Bestimmt Achsenquelle. Sendet `pointer_handle.axis()` für vertikales/horizontales Scrollen mit diskreten und kontinuierlichen Werten.
        
- `focus_handler_pointer.rs`:
    - **Funktion `update_pointer_focus_and_send_motion()`:** Ruft aktuellen Fokus vom Pointer-Handle ab. Sendet `pointer_handle.leave()` für alten Fokus und `pointer_handle.enter()` für neuen Fokus. Sendet `pointer_handle.motion()`, wenn neuer Fokus existiert.
        
- `cursor_updater.rs`:
    - **Zweck:** Enthält Logik von `SeatHandler::cursor_image`, ggf. Hilfsfunktionen für Cursor-Themen.
        

#### 3.5. Submodul: `system::input::touch`

Verarbeitet Touch-Ereignisse und handhabt Touch-Fokus. Fokus ist implizit im Oberflächenargument für `down`/`motion`. Zustand, welche Oberfläche von welchem Slot berührt wird, muss in `DesktopState` oder assoziierten Strukturen verwaltet werden.

**Dateien:**

- `touch_event_translator.rs`:
    - **Funktion `handle_touch_down_event()`:** Ruft Touch-Handle ab. Bestimmt fokussierte Oberfläche unter dem Touchpunkt. Sendet `touch_handle.down()`.
        
    - **Funktion `handle_touch_up_event()`:** Ruft Touch-Handle ab. Sendet `touch_handle.up()`.
        
    - **Funktion `handle_touch_motion_event()`:** Ruft Touch-Handle ab. Ruft fokussierte Oberfläche für den Touch-Slot ab. Transformiert Koordinaten. Sendet `touch_handle.motion()`.
        
    - **Funktion `handle_touch_frame_event()`:** Ruft Touch-Handle ab. Sendet `touch_handle.frame()`.
        
    - **Funktion `handle_touch_cancel_event()`:** Ruft Touch-Handle ab. Sendet `touch_handle.cancel()`.
        
- `focus_handler_touch.rs`:
    - **Zweck:** Verwaltet Touch-Fokus, ähnlich wie Zeigerfokus, aber pro Touchpunkt/Slot.
        

### 4. Modul: `system::dbus` (Interaktion mit System-D-Bus-Diensten)

Verantwortlich für die Kommunikation mit Standard-D-Bus-Diensten wie UPower, systemd-logind, NetworkManager, Freedesktop Secret Service und PolicyKit unter Verwendung der `zbus`-Bibliothek.

#### 4.1. Submodul: `system::dbus::error`

Definiert spezifische Fehlertypen für D-Bus-Interaktionen mittels `thiserror`.

**Datei:** `system/dbus/error.rs`

- **Enum `DBusError`:** Varianten wie `ConnectionFailed`, `MethodCallFailed`, `ProxyCreationFailed`, `SignalSubscriptionFailed`, `InvalidResponse`, `DataDeserializationError`, `PropertyAccessFailed`, `NameTaken`, `Timeout`.
    
- **Enum `BusType`:** `Session`, `System`.
    

#### 4.2. Submodul: `system::dbus::connection`

Stellt einen zentralen Manager für D-Bus-Verbindungen bereit.

**Datei:** `system/dbus/connection.rs`

- **Struktur `DBusConnectionManager`:**
    - Felder: `session_bus: tokio::sync::OnceCell<Arc<zbus::Connection>>`, `system_bus: tokio::sync::OnceCell<Arc<zbus::Connection>>` für verzögerte Initialisierung und Wiederverwendung.
        
    - Methoden: `new()`, `get_session_bus()` (verwendet `zbus::Connection::session().await`), `get_system_bus()` (verwendet `zbus::Connection::system().await`).
        

#### 4.3. Submodul: `system::dbus::upower_client` (oder `upower_interface`)

Interagiert mit `org.freedesktop.UPower` für Energieinformationen.

**Dateien:** `system/dbus/upower_client.rs` (oder `upower_interface/client.rs`), `system/dbus/upower_types.rs` (oder `upower_interface/types.rs`)

- **`upower_types.rs`:**
    - Enums: `PowerDeviceType`, `PowerState`, `PowerWarningLevel`, `PowerDeviceTechnology`. `TryFrom<u32>` für Enums implementieren.
        
    - Strukturen: `PowerDeviceDetails` (enthält Felder wie `object_path`, `vendor`, `model`, `device_type`, `state`, `percentage`, `time_to_empty`, `time_to_full`, etc.), `UPowerProperties` (oder `UPowerManagerProperties`) (`on_battery`, `lid_is_closed`, `lid_is_present`, `daemon_version`).
        
    - Internes Enum `UPowerEvent`: `DeviceAdded`, `DeviceRemoved`, `DeviceUpdated`, `ManagerPropertiesChanged`.
        
- **`upower_client.rs`:**
    - **Proxy-Definitionen (`#[zbus::proxy]`)**:
        - `UPowerManagerProxy` für `org.freedesktop.UPower`: Methoden `enumerate_devices`, `get_display_device`, `get_critical_action`; Properties `on_battery`, `lid_is_closed`, `lid_is_present`, `daemon_version`; Signale `device_added`, `device_removed`, `properties_changed`.
            
        - `UPowerDeviceProxy` für `org.freedesktop.UPower.Device`: Properties wie `type_`, `state`, `percentage`, `time_to_empty`, `time_to_full`, `is_present`, `icon_name`, etc.; Signal `properties_changed`.
            
    - **Struktur `UPowerClient`:**
        - Felder: `connection_manager: Arc<DBusConnectionManager>` (oder `connection: zbus::Connection`), `manager_proxy: Arc<UPowerManagerProxy>`, `devices: Arc<Mutex<HashMap<ObjectPath<'static>, PowerDeviceDetails>>>`, `display_device_path: Arc<Mutex<Option<ObjectPath<'static>>>>`, `manager_properties: Arc<Mutex<UPowerManagerProperties>>`, `internal_event_sender: tokio::sync::broadcast::Sender<UPowerEvent>`.
            
        - Methoden: `new()` (oder `connect_and_initialize()`), `get_manager_proxy()`, `get_device_proxy()`, `get_properties()` (für Manager), `enumerate_devices()`, `get_display_device_path()`, `get_device_details()`, `on_battery()`, `subscribe_device_added()`, `subscribe_device_removed()`, `subscribe_upower_properties_changed()` (Manager), `subscribe_device_properties_changed()`.
            
    - **Signalbehandlung:** Asynchrone Tasks (`tokio::spawn`) für Manager-Signale (`DeviceAdded`, `DeviceRemoved`, `PropertiesChanged`) und Geräte-Signale (`PropertiesChanged`). Aktualisiert interne Zustände (`devices`, `manager_properties`) und sendet `UPowerEvent` über den Broadcast-Kanal. PropertiesChanged-Signale sollten detailliert ausgewertet werden, um nur betroffene Felder zu aktualisieren.
        

#### 4.4. Submodul: `system::dbus::logind_client` (oder `logind_interface`)

Interagiert mit `org.freedesktop.login1` für Sitzungsmanagement und Systemereignisse.

**Dateien:** `system/dbus/logind_client.rs` (oder `logind_interface/client.rs`), `system/dbus/logind_types.rs` (oder `logind_interface/types.rs`)

- **`logind_types.rs`:**
    - Strukturen: `SessionInfo` (`id`, `user_id`, `user_name`, `seat_id`, `object_path`, `is_active`, `is_locked_hint`), `UserInfo`.
        
    - Enums: `SessionState`, `LogindEvent` (`PrepareForSleep { starting: bool }`, `ActiveSessionLocked`, `ActiveSessionUnlocked`, `ActiveSessionChanged`, `SessionListChanged`).
        
- **`logind_client.rs`:**
    - **Proxy-Definitionen (`#[zbus::proxy]`)**:
        - `LogindManagerProxy` für `org.freedesktop.login1.Manager`: Methoden `get_session`, `get_session_by_pid`, `get_user`, `list_sessions`, `lock_session`, `unlock_session`, `lock_sessions`, `unlock_sessions`, `inhibit`; Signale `session_new`, `session_removed`, `prepare_for_sleep`.
            
        - `LogindSessionProxy` für `org.freedesktop.login1.Session`: Properties `active`, `locked_hint`, `id`, `user`, `seat`; Signale `Lock`, `Unlock`, `PropertyChanged`.
            
    - **Struktur `LogindClient`:**
        - Felder: `connection: zbus::Connection`, `manager_proxy: Arc<LogindManagerProxy>`, `active_session_id: Arc<Mutex<Option<String>>>`, `active_session_path`, `active_session_proxy`, `sleep_inhibitor_lock: Arc<Mutex<Option<zbus::zvariant::OwnedFd>>>`, `internal_event_sender: tokio::sync::broadcast::Sender<LogindEvent>`.
            
        - Methoden: `new()` (oder `connect_and_initialize()`), `get_manager_proxy()`, `get_session_proxy()`, `list_sessions()` (konvertiert zu `Vec<SessionInfo>`), `get_session_details()`, `lock_session()`, `unlock_session()`, `lock_all_sessions()`, `unlock_all_sessions()`, `subscribe_session_new()`, `subscribe_session_removed()`, `subscribe_prepare_for_sleep()`, `subscribe_session_lock()`, `subscribe_session_unlock()`, `request_lock_active_session()`, `request_unlock_active_session()`, `subscribe_events()`, `release_sleep_inhibitor()`.
            
    - **Initialisierung:** Identifiziert die aktive Sitzung durch `ListSessions` und Prüfung der `Active`-Eigenschaft jeder Session.
        
    - **Signalbehandlung (`PrepareForSleep`):** Bei `start == true`, `inhibit()` aufrufen und FD speichern. `LogindEvent::PrepareForSleep { starting: true }` senden. Bei `start == false`, Inhibit-Lock freigeben (`drop(fd)`) und `LogindEvent::PrepareForSleep { starting: false }` senden. Die korrekte Freigabe des Inhibit-Locks ist kritisch.
        
    - **Signalbehandlung (`SessionNew`/`SessionRemoved`):** Aktualisiert interne Sitzungsliste, prüft auf Änderung der aktiven Sitzung und sendet `LogindEvent`.
        
    - **Signalbehandlung (`Lock`/`Unlock` oder `LockedHint` der aktiven Session):** Sendet `LogindEvent::ActiveSessionLocked/Unlocked`. Die DE ist i.d.R. selbst für den Sperrbildschirm zuständig; dieses Modul kann `LockedHint` überwachen.
        

#### 4.5. Submodul: `system::dbus::networkmanager_client`

Interagiert mit `org.freedesktop.NetworkManager` für Netzwerkinformationen.

**Dateien:** `system/dbus/networkmanager_client.rs`, `system/dbus/networkmanager_types.rs`

- **`networkmanager_types.rs`:**
    - Enums: `NetworkManagerState`, `NetworkDeviceType`, `NetworkConnectivityState`.
        
    - Strukturen: `NetworkDevice`, `ActiveConnection`, `NetworkManagerProperties`.
        
- **`networkmanager_client.rs`:**
    - **Proxy-Definitionen (`#[zbus::proxy]`)**: `NetworkManagerProxy`, `NMDeviceProxy`, `NMActiveConnectionProxy` mit relevanten Methoden, Properties und Signalen (z.B. `GetDevices`, `GetActiveConnections`, `StateChanged`, `DeviceAdded`, `DeviceRemoved`).
        
    - **Struktur `NetworkManagerClient`:** Enthält `connection_manager`, `manager_proxy_path`. Methoden `new()`, `get_manager_proxy()`, `get_device_proxy()`, `get_active_connection_proxy()`, `get_properties()`, `get_devices()` (ruft Details für jeden Pfad ab), `get_active_connections()`, `subscribe_state_changed()`, `subscribe_device_added()` (ruft Details für neuen Pfad ab), `subscribe_device_removed()`.
        
    - Reaktive Aktualisierung bei Signalempfang ist wichtig.
        

#### 4.6. Submodul: `system::dbus::secrets_client`

Interagiert mit `org.freedesktop.secrets` zum Speichern/Abrufen sensibler Daten (z.B. API-Schlüssel).

**Dateien:** `system/dbus/secrets_client.rs`, `system/dbus/secrets_types.rs`

- **`secrets_types.rs`:**
    - Strukturen: `Secret`, `SecretItemInfo`, `SecretCollectionInfo`.
        
    - Enum: `PromptCompletedResult`.
        
- **`secrets_client.rs`:**
    - **Proxy-Definitionen (`#[zbus::proxy]`)**: `SecretServiceProxy`, `SecretCollectionProxy`, `SecretItemProxy`, `SecretPromptProxy` mit relevanten Methoden, Properties und Signalen (z.B. `OpenSession`, `CreateCollection`, `SearchItems`, `Unlock`, `GetSecrets`, `CreateItem`, `GetSecret`, `Prompt`, `Completed`).
        
    - **Struktur `SecretsClient`:** Enthält `connection_manager`, `service_proxy_path`. Methoden `new()`, Proxies abrufen, `open_session()`, `get_default_collection()`, `store_secret()` (behandelt Prompt), `retrieve_secret()` (behandelt Unlock/Prompt), `search_items()`, `handle_prompt_if_needed()` (ruft `PromptProxy::Prompt()` mit `window_id` von UI-Schicht und wartet auf `Completed`-Signal).
        

#### 4.7. Submodul: `system::dbus::policykit_client`

Interagiert mit `org.freedesktop.PolicyKit1.Authority` zur Berechtigungsprüfung.

**Dateien:** `system/dbus/policykit_client.rs`, `system/dbus/policykit_types.rs`

- **`policykit_types.rs`:**
    - Bitflags-Struktur `PolicyKitCheckAuthFlags` (`AllowUserInteraction`, etc.).
        
    - Strukturen: `PolicyKitSubject` (`kind`, `details`), `PolicyKitAuthorizationResult` (`is_authorized`, `is_challenge`, `details`).
        
- **`policykit_client.rs`:**
    - **Proxy-Definition (`#[zbus::proxy]`)**: `PolicyKitAuthorityProxy` für `org.freedesktop.PolicyKit1.Authority`. Methode `CheckAuthorization`.
        
    - **Struktur `PolicyKitClient`:** Enthält `connection_manager`, `authority_proxy_path`. Methoden `new()`, `get_authority_proxy()`, `check_authorization()` (erstellt `PolicyKitSubject` mit PID des aktuellen Prozesses oder übergebenem PID, setzt Flags, ruft Proxy-Methode auf). Die korrekte Definition des `subject` ist sicherheitskritisch.
        

### 5. Modul: `system::outputs` (Verwaltung der Anzeigeausgänge)

Verantwortlich für Erkennung, Konfiguration und Verwaltung von Anzeigeausgängen (Monitoren). Implementiert serverseitige Logik für Wayland-Protokolle (`wl_output`, `xdg-output-unstable-v1`, `wlr-output-management-unstable-v1`, `wlr-output-power-management-unstable-v1`) unter Verwendung von Smithay-Abstraktionen.

#### 5.1. Submodul: `system::outputs::error`

Definiert spezifische Fehlertypen für Output-Operationen.

**Datei:** `system/outputs/error.rs`

- **Enum `OutputError`:** Varianten `DeviceAccessFailed`, `ProtocolError`, `ConfigurationConflict`, `ResourceCreationFailed`, `SmithayOutputError`, `OutputNotFound`, `ModeNotSupported`.
    

#### 5.2. Submodul: `system::outputs::output_device`

Kapselt Zustand und Logik eines einzelnen physischen Anzeigeausgangs.

**Datei:** `system/outputs/output_device.rs`

- **Struktur `OutputDevice`:**
    - Felder: `name: String`, `smithay_output: smithay::output::Output`, `wl_output_global: Option<GlobalId>`, `xdg_output_global: Option<GlobalId>`, `wlr_head_global: Option<GlobalId>`, `wlr_power_global: Option<GlobalId>`, `enabled: bool`, `current_dpms_state: DpmsState`, `pending_config_serial: Option<u32>` (für wlr-output-management).
        
    - Methoden: `new()` (initialisiert `smithay::output::Output`, fügt Modi hinzu, setzt initialen Zustand), `name()`, `smithay_output()`, `current_mode()`, `current_transform()`, `current_scale()`, `current_position()`, `is_enabled()`, `apply_state()` (ruft `smithay_output.change_current_state()`), `set_dpms_state()` (interagiert mit DRM, aktualisiert `current_dpms_state`), `supported_modes()`, `physical_properties()`, `add_mode()`, `set_preferred_mode()`, Methoden zum Setzen/Abrufen von Global-IDs, `destroy_globals()`.
        
- **Struktur `OutputDevicePendingState` (für wlr-output-management):** Felder `mode`, `position`, `transform`, `scale`, `enabled`, `adaptive_sync_enabled`.
    
- **Enum `DpmsState`:** `On`, `Standby`, `Suspend`, `Off`.
    

#### 5.3. Submodul: `system::outputs::manager` (oder `output_manager` für wlr-output-management)

Verwaltet eine Liste aller `OutputDevice`-Instanzen und behandelt Hotplug-Events.

**Datei:** `system/outputs/manager.rs` (oder `output_manager/manager_global.rs` und andere für wlr-output-management)

- **Struktur `OutputManager` (oder `OutputManagerModuleState` / `WlrOutputManagementState`):**
    - Felder: `outputs: HashMap<String, Arc<Mutex<OutputDevice>>>`, `udev_event_source_token: Option<RegistrationToken>`, `output_manager_global` (für wlr), `active_configurations` (für wlr), `compositor_output_serial` (für wlr) / `global_serial`.
        
    - Methoden: `new()`, `add_output()`, `remove_output()` (zerstört Globals), `find_output_by_name()`, `all_outputs()`, `handle_hotplug_event()` (erstellt/entfernt `OutputDevice`, ruft `output_device_created/removed_notifications` auf).
        
    - Hilfsmethoden `output_device_created_notifications()` und `output_device_removed_notifications()`: Erstellen/Zerstören Globals (`wl_output`, `zxdg_output_v1`, `zwlr_output_head_v1`) und benachrichtigen relevante Handler (WlrOutputManagementState, WlrOutputPowerManagementState).
        
- **Enum `HotplugEvent`:** `DeviceAdded` (mit Name, Pfad, Eigenschaften, Modi, etc.), `DeviceRemoved`.
    
- **Struktur `OutputConfigurationRequest` (für wlr-output-management):** `serial`, `client`, `pending_changes: HashMap<String, HeadChangeRequest>`, `config_resource`.
    
- **Struktur `HeadChangeRequest` (für wlr-output-management):** `mode`, `position`, `transform`, `scale`, `enabled`, `adaptive_sync_enabled`.
    
- **`wlr-output-management` spezifische UserData-Strukturen:** `WlrOutputManagerGlobalData`, `WlrOutputHeadGlobalData`, `WlrOutputModeGlobalData`, `WlrOutputConfigurationUserData`, `WlrOutputConfigurationHeadUserData`.
    

#### 5.4. Submodul: `system::outputs::wl_output_handler`

Handhabung des `wl_output`-Protokolls, meist durch Smithay's `Output`-Typ und `OutputHandler`-Trait.

**Datei:** Integration in globalen Compositor-Zustand und `system::outputs::manager.rs`.

- **Smithay Integration:** Globaler Compositor-Zustand implementiert `smithay::wayland::output::OutputHandler`. `smithay::delegate_output!` wird deklariert. Beim Hinzufügen eines Outputs wird `output_dev.smithay_output().create_global()` aufgerufen; `GlobalId` wird in `OutputDevice::wl_output_global` gespeichert.
    
- **Implementierung `OutputHandler`:**
    - `output_state()`: Gibt Referenz zum `OutputManagerState` des Compositors zurück.
        
    - `new_output()`: Kann Client-spezifischen Zustand initialisieren.
        
    - `output_destroyed()`: Wird bei Zerstörung eines `wl_output`-Globals aufgerufen.
        
    - Smithay sendet `geometry`, `mode`, `scale`, `done` Events automatisch bei `Output::change_current_state()`.
        

#### 5.5. Submodul: `system::outputs::wlr_output_management_handler` (oder in `system::outputs::output_manager`)

Implementiert `wlr-output-management-unstable-v1`.

**Dateien:** `system/outputs/wlr_output_management/*` oder integriert.

- **Zustandsstrukturen:** `WlrOutputManagementState` (enthält `OutputManager`-Referenz, `configurations`, `global_serial`). `OutputConfigurationRequest` (enthält `serial`, `client`, `pending_changes`, `config_resource`). `HeadChangeRequest` (enthält `mode`, `position`, etc.).
    
- **Smithay Integration:** Globaler Compositor-Zustand implementiert `GlobalDispatch` und `Dispatch` für `ZwlrOutputManagerV1`, `ZwlrOutputHeadV1`, `ZwlrOutputModeV1`, `ZwlrOutputConfigurationV1`, `ZwlrOutputConfigurationHeadV1`.
    
- **Initialisierung:** `WlrOutputManagementState` erstellen, `zwlr_output_manager_v1`-Global registrieren.
    
- **Anfragebehandlung `zwlr_output_manager_v1`:**
    - `bind`: Sendet aktuellen Zustand aller Outputs (Heads, Modi) und `done(serial)`.
        
    - `create_configuration()`: Erstellt `OutputConfigurationRequest`, speichert es. Sendet aktuellen Output-Zustand an das neue `config_resource`.
        
    - `stop()`: Zerstört das Manager-Global, sendet `finished`.
        
- **Anfragebehandlung `zwlr_output_configuration_head_v1`:** `enable()`, `disable()`, `set_mode()`, `set_custom_mode()`, `set_position()`, `set_transform()`, `set_scale()`, `set_adaptive_sync()` aktualisieren `HeadChangeRequest` im `OutputConfigurationRequest`. Prüfen auf `is_applied_or_tested`.
    
- **Anfragebehandlung `zwlr_output_configuration_v1`:**
    - `destroy()`: Verwirft Anfrage.
        
    - `apply()`: Prüft `serial` gegen `compositor_output_serial` (bei Mismatch -> `cancelled`). Validiert Änderungen. Versucht, Konfiguration auf `OutputDevice` anzuwenden (via `OutputManager` und `output.change_current_state()`). Bei Erfolg: `succeeded`, `compositor_output_serial` inkrementieren, alle Manager-Clients benachrichtigen. Bei Fehler: `failed`, ggf. Rollback.
        
    - `test()`: Validiert Konfiguration. Sendet `succeeded` oder `failed`.
        
- **Event-Generierung:** Bei Änderungen des Output-Zustands (Hotplug, erfolgreiches `apply`) müssen `head`, `mode`, `done(new_serial)` an alle Manager gesendet werden.
    
- **Fehlerbehandlung (`OutputManagerError`):** Varianten wie `InvalidWlOutput`, `AlreadyProcessed`, `SerialMismatch`, `UnknownOutput`, `TestFailed`, `ApplyFailed`, `Cancelled`, `ProtocolError`.
    

#### 5.6. Submodul: `system::outputs::wlr_output_power_management_handler` (oder `system::outputs::power_manager`)

Implementiert `wlr-output-power-management-unstable-v1` für Energiezustand von Monitoren.

**Dateien:** `system/outputs/wlr_output_power_management/*` oder integriert.

- **Zustandsstrukturen:** `WlrOutputPowerManagementState` (enthält `OutputManager`-Referenz, `active_controllers: HashMap<String, Resource<ZwlrOutputPowerV1>>`). `OutputPowerControlState` (enthält `wl_output_resource`, `compositor_output_name`, `current_mode: InternalPowerMode`).
    
- **Enum `InternalPowerMode`**: `On`, `Off`.
    
- **UserData-Strukturen:** `WlrOutputPowerManagerGlobalData`, `WlrOutputPowerControlUserData`.
    
- **Smithay Integration:** Globaler Compositor-Zustand implementiert `GlobalDispatch` und `Dispatch` für `ZwlrOutputPowerManagerV1`, `ZwlrOutputPowerV1`.
    
- **Initialisierung:** `WlrOutputPowerManagementState` erstellen, `zwlr_output_power_manager_v1`-Global registrieren.
    
- **Anfragebehandlung `zwlr_output_power_manager_v1`:**
    - `get_output_power()`: Ermittelt `OutputDevice`. Prüft auf exklusive Kontrolle (nur ein Controller pro Output). Speichert `ZwlrOutputPowerV1`-Ressource in `active_controllers`. Sendet initiales `mode`-Event an Ressource.
        
    - `destroy()`: Zerstört Manager-Global.
        
- **Anfragebehandlung `zwlr_output_power_v1`:**
    - `destroy()`: Entfernt Controller aus `active_controllers`.
        
    - `set_mode()`: Ermittelt `OutputDevice`. Konvertiert `mode` in `DpmsState`. Ruft `output_device.set_dpms_state()`. Sendet `mode(mode)` oder `failed`.
        
- **Event-Generierung:** Bei externer Änderung des DPMS-Zustands oder Entfernung eines Outputs, `mode` oder `failed` an aktive Controller senden.
    
- **Fehlerbehandlung (`OutputPowerError`):** Varianten `OutputDoesNotSupportPowerManagement`, `BackendSetModeFailed`, `OutputVanished`, `ExclusiveControlConflict`, `InvalidWlOutput`, `ProtocolError`.
    

#### 5.7. Submodul: `system::outputs::xdg_output_handler`

Implementiert `xdg-output-unstable-v1` für detaillierte logische Geometrieinformationen.

**Datei:** `system/outputs/xdg_output_handler.rs` oder integriert.

- **Smithay Integration:** Globaler Compositor-Zustand implementiert `GlobalDispatch` und `Dispatch` für `ZxdgOutputManagerV1`, `ZxdgOutputV1`. `XdgOutputManagerGlobalData`, `XdgOutputGlobalData` als UserData. Erstellung von Globals kann über `OutputManagerState::new_with_xdg_output()` oder manuell erfolgen.
    
- **Anfragebehandlung `zxdg_output_manager_v1`:**
    - `get_xdg_output()`: Ermittelt `OutputDevice`. Initialisiert `ZxdgOutputV1`-Ressource mit logischen Daten (`logical_position`, `logical_size`, `name`, `description`), sendet diese und `done`.
        
- **Event-Generierung:** Bei Änderungen an logischer Position, Größe, Name, Beschreibung eines `OutputDevice` müssen entsprechende Events an gebundene `zxdg_output_v1`-Instanzen gesendet werden, gefolgt von `done`. Dies wird i.d.R. von Smithay bei `Output::change_current_state()` gehandhabt.
    

### 6. Modul: `system::audio` (PipeWire Client-Integration)

Verantwortlich für alle audiobezogenen Operationen mittels PipeWire und `pipewire-rs`. Zentralisiert PipeWire-Interaktionslogik, ereignisgesteuerte Architektur. Eigene PipeWire MainLoop in dediziertem Thread, Kommunikation über asynchrone Kanäle (`tokio::sync::mpsc`, `tokio::sync::broadcast`). Unterscheidet Master-Lautstärke (Device-Routen) und Anwendungs-Stream-Lautstärke (Node-Props).

#### 6.1. Submodul: `system::audio::client`

Verwaltet Low-Level-Verbindung zu PipeWire, startet und unterhält PipeWire-MainLoop-Thread, leitet Befehle weiter und verteilt Ereignisse.

**Datei:** `system/audio/client.rs`

- **Struktur `PipeWireClient`:**
    - Felder: `core: Arc<pipewire::Core>`, `mainloop_thread_handle: Option<std::thread::JoinHandle<()>>`, `command_sender: tokio::sync::mpsc::Sender<AudioCommand>`, `internal_event_sender: tokio::sync::mpsc::Sender<InternalAudioEvent>`.
        
    - Methode `new()`: Initialisiert PipeWire (`pipewire::init()`), erstellt MPSC-Kanäle, startet `run_pipewire_loop` in neuem OS-Thread, wartet auf Initialisierungssignal vom Thread, speichert Handles und Sender.
        
    - Methode `get_command_sender()`: Gibt Klon des `command_sender` zurück.
        
- **Struktur `PipeWireLoopData` (für internen Thread-Zustand):** `core`, `registry: Arc<pipewire::Registry>`, `audio_event_broadcaster: tokio::sync::broadcast::Sender<AudioEvent>`, `command_receiver`, `internal_event_receiver`, `active_devices: HashMap<u32, MonitoredDevice>`, `active_streams: HashMap<u32, MonitoredStream>`, `default_sink_id`, `default_source_id`, `pipewire_mainloop`, `pipewire_context`, `metadata_proxy`, `metadata_listener_hook`.
    
- **Struktur `MonitoredDevice`:** `proxy: Arc<dyn ProxyT>`, `proxy_id`, `global_id`, `properties`, `param_listener_hook`, `info: AudioDevice`.
    
- **Struktur `MonitoredStream`:** `proxy: Arc<pipewire::node::Node>`, `proxy_id`, `global_id`, `properties`, `param_listener_hook`, `info: StreamInfo`.
    
- **Enum `InternalAudioEvent`:** `PwGlobalAdded`, `PwGlobalRemoved`, `PwNodeParamChanged`, `PwDeviceParamChanged`, `PwMetadataPropsChanged`.
    
- **Private Funktion `run_pipewire_loop()`:** Initialisiert `MainLoop`, `Context`, `Core`, `Registry`. Registriert Listener auf Registry (`global`, `global_remove` Callbacks senden `InternalAudioEvent`). Startet Timer, der `process_external_messages` aufruft. Ruft `mainloop.run()`.
    
    - `process_external_messages()`: Verarbeitet `AudioCommand` (ruft Control-Funktionen) und `InternalAudioEvent` (ruft Manager-Funktionen).
        

#### 6.2. Submodul: `system::audio::manager`

Verarbeitet PipeWire-Registry-Ereignisse, verwaltet `AudioDevice`/`StreamInfo`, behandelt Eigenschaftsänderungen.

**Datei:** `system/audio/manager.rs`

- **Funktion `handle_pipewire_global_added()`:** Loggt. Abhängig von `global.type_`:
    - `ObjectType::Node`: Extrahiert Properties. Unterscheidet Gerät (Sink/Source) von Anwendungsstream. Bindet `pipewire::node::Node`-Proxy. Ruft initiale Parameter ab (Lautstärke/Mute aus `SPA_PARAM_Props`). Erstellt `AudioDevice` oder `StreamInfo`. Registriert `param_changed`-Listener (sendet `InternalAudioEvent::PwNodeParamChanged`). Speichert in `active_devices` oder `active_streams`. Sendet `AudioEvent::DeviceAdded` oder `StreamAdded`.
        
    - `ObjectType::Device`: Extrahiert Properties. Bindet `pipewire::device::Device`-Proxy. Ruft initiale `SPA_PARAM_Route`-Parameter ab. Erstellt `AudioDevice`. Registriert `param_changed`-Listener (sendet `InternalAudioEvent::PwDeviceParamChanged`). Speichert in `active_devices`. Sendet `AudioEvent::DeviceAdded`.
        
    - `ObjectType::Metadata`: Wenn `metadata.name == "default"`. Bindet `pipewire::metadata::Metadata`-Proxy. Speichert Proxy. Parst Standardgeräte-IDs aus Properties. Registriert `props`-Listener (sendet `InternalAudioEvent::PwMetadataPropsChanged`). Sendet `AudioEvent::DefaultSink/SourceChanged`.
        
- **Funktion `handle_pipewire_global_removed()`:** Loggt. Entfernt `MonitoredDevice` oder `MonitoredStream` aus `active_devices`/`active_streams`. Listener werden automatisch entfernt. Sendet `AudioEvent::DeviceRemoved` oder `StreamRemoved`. Behandelt Entfernung des Metadata-Proxy.
    
- **Funktion `handle_node_param_changed()`:** Loggt. Sucht `MonitoredDevice`/`Stream`. Wenn `SPA_PARAM_Props` geändert: Parst Lautstärke/Mute aus Pod. Aktualisiert `AudioDevice`/`StreamInfo`. Sendet `AudioEvent::Device/StreamVolumeChanged/MuteChanged`.
    
- **Funktion `handle_device_param_changed()`:** Loggt. Sucht `MonitoredDevice`. Wenn `SPA_PARAM_Route` geändert: Parst Lautstärke/Mute der aktiven Route. Aktualisiert `AudioDevice`. Sendet `AudioEvent::DeviceVolumeChanged/MuteChanged`.
    
- **Funktion `handle_metadata_props_changed()`:** Loggt. Extrahiert neue Standard-Sink/Source-IDs aus Properties. Aktualisiert `is_default`-Flags der betroffenen `AudioDevice`-Instanzen und sendet `AudioEvent::DeviceUpdated`. Aktualisiert `default_sink_id`/`default_source_id`. Sendet `AudioEvent::DefaultSink/SourceChanged`.
    

#### 6.3. Submodul: `system::audio::control`

Implementiert Logik zum Senden von Steuerbefehlen an PipeWire.

**Datei:** `system/audio/control.rs`

- **Funktion `set_node_volume()`:** Sucht `MonitoredDevice`/`Stream`. Passt `volume.channel_volumes` gemäß `VolumeCurve` an. Erstellt `SPA_PARAM_Props`-Pod mit `channelVolumes` (via `spa_pod_utils`). Ruft `node_proxy.set_param()`.
    
- **Funktion `set_node_mute()`:** Sucht `MonitoredDevice`/`Stream`. Erstellt `SPA_PARAM_Props`-Pod mit `mute`. Ruft `node_proxy.set_param()`.
    
- **Funktion `set_device_volume()`:** Sucht `MonitoredDevice` (Device-Proxy). Passt `volume.channel_volumes` an. Ermittelt aktive Route. Erstellt `SPA_PARAM_Route`-Pod mit `channelVolumes` für die Route. Ruft `device_proxy.set_param()`.
    
- **Funktion `set_device_mute()`:** Sucht `MonitoredDevice`. Ermittelt aktive Route. Erstellt `SPA_PARAM_Route`-Pod mit `mute` für die Route. Ruft `device_proxy.set_param()`.
    
- **Funktion `set_default_device()`:** Prüft `metadata_proxy`. Bestimmt Property-Namen (`default.audio.sink/source`). Ruft `metadata_proxy.set_property()` mit globaler ID als String.
    

#### 6.4. Submodul: `system::audio::types`

Definiert primäre Datenstrukturen für das Audio-Modul.

**Datei:** `system/audio/types.rs`

- **Enums:** `AudioDeviceType` (`Sink`, `Source`, `Unknown`), `VolumeCurve` (`Linear`, `Cubic`), `AudioCommand` (siehe Tabelle), `AudioEvent` (siehe Tabelle).
    
- **Strukturen:**
    - `Volume`: Enthält `channel_volumes: Vec<f32>` (0.0-1.0).
        
    - `AudioDevice`: Enthält `id` (globale PW ID), `proxy_id`, `name`, `description`, `device_type`, `volume`, `is_muted`, `is_default`, `ports` (optional), `properties_spa` (optional), `is_hardware_device`, `api_name`.
        
    - `StreamInfo`: Enthält `id` (globale PW ID), `name`, `application_name`, `process_id`, `volume`, `is_muted`, `media_class`, `node_id_pw` (interne PW Node ID).
        

#### 6.5. Submodul: `system::audio::spa_pod_utils`

Hilfsfunktionen zur Erstellung von `pipewire::spa::Pod`-Objekten.

**Datei:** `system/audio/spa_pod_utils.rs`

- `build_volume_props_pod()`: Erstellt Pod für `SPA_PARAM_Props` mit `SPA_PROP_channelVolumes`.
    
- `build_mute_props_pod()`: Erstellt Pod für `SPA_PARAM_Props` mit `SPA_PROP_mute`.
    
- `build_route_volume_pod()`: Erstellt Pod für `SPA_PARAM_Route` mit `SPA_PARAM_ROUTE_index`, `SPA_PARAM_ROUTE_device` und verschachtelten `SPA_PARAM_ROUTE_props` (mit `SPA_PROP_channelVolumes`).
    
- `build_route_mute_pod()`: Analog für `SPA_PROP_mute` in Route-Props.
    
- `parse_props_volume_mute()`: Extrahiert `Volume` und `mute` aus `SPA_PARAM_Props`-Pod.
    
- `parse_route_props_volume_mute()`: Extrahiert `Volume` und `mute` aus `SPA_PARAM_ROUTE`-Pod (via dessen `SPA_PARAM_ROUTE_props`).
    

#### 6.6. Submodul: `system::audio::error`

Definiert `AudioError` mittels `thiserror`.

**Datei:** `system/audio/error.rs`

- **Enum `AudioError`:** Varianten wie `PipeWireInitFailed`, `MainLoopCreationFailed`, `ContextCreationFailed`, `CoreConnectionFailed`, `RegistryCreationFailed`, `PipeWireThreadPanicked`, `ProxyBindFailed`, `ParameterEnumerationFailed`, `SpaPodParseFailed`, `SpaPodBuildFailed`, `PipeWireCommandFailed`, `DeviceOrStreamNotFound`, `NoActiveRouteFound`, `MetadataProxyNotAvailable`, `InternalChannelSendError`, `InternalBroadcastSendError`.
    

### 7. Modul: `system::mcp` (Model Context Protocol Client)

Implementiert einen Client für das Model Context Protocol (MCP) zur Kommunikation mit lokalen oder Cloud-basierten MCP-Servern für KI-gestützte Funktionen. Kommunikation typischerweise über Stdio mit JSON-RPC. Verwendet `mcp_client_rs` Crate.

#### 7.1. Submodul: `system::mcp::client`

Kernlogik für Interaktion mit MCP-Server: Starten des Serverprozesses, Senden von Anfragen, Verarbeiten von Antworten/Benachrichtigungen.

**Datei:** `system/mcp/client.rs`

- **Struktur `McpClient`:**
    - Felder: `client_handle: Option<mcp_client_rs::client::Client>`, `server_process: Option<tokio::process::Child>`, `command_sender: tokio::sync::mpsc::Sender<McpCommand>`, `notification_broadcaster: tokio::sync::broadcast::Sender<McpNotification>`, `status_broadcaster: tokio::sync::broadcast::Sender<McpClientStatus>`, `request_id_counter: Arc<AtomicU64>`, `pending_requests: Arc<Mutex<HashMap<String, tokio::sync::oneshot::Sender<Result<serde_json::Value, McpError>>>>>`, `listen_task_handle: Option<tokio::task::JoinHandle<()>>`.
        
    - Methode `new()`: Erstellt MPSC-Kanal für `McpCommand`. Startet MCP-Serverprozess (`tokio::process::Command`) mit Pipes für Stdin/Stdout/Stderr. Erstellt `mcp_client_rs::transport::stdio::StdioTransport` und `mcp_client_rs::client::Client`. Startet `listen_task`. Sendet `Initialize`-Befehl und wartet auf Antwort. Sendet `McpClientStatus`-Updates.
        
    - Private Methode `listen_task()`: Lauscht auf `StdioTransportReceiver`. Deserialisiert Nachrichten. Bei Antwort: Sendet an passenden `oneshot::Sender` aus `pending_requests`. Bei Benachrichtigung: Sendet an `notification_broadcaster`. Behandelt Fehler und Verbindungsabbruch, sendet `McpClientStatus`.
        
    - Private Methode `send_request_generic()`: Generiert `request_id`. Speichert `oneshot::Sender` in `pending_requests`. Sendet JSON-RPC-Anfrage über `client_handle` (intern via `mcp_client_rs`). Wartet auf Antwort.
        
    - Öffentliche Methoden für MCP-Requests (`list_resources`, `read_resource`, `call_tool`): Rufen `send_request_generic` auf.
        
    - Methode `shutdown()`: Sendet Shutdown-Anfrage (falls unterstützt). Bricht `listen_task` ab. Beendet Serverprozess (`child.kill()`). Sendet `McpClientStatus::Disconnected`.
        
    - Methode `get_command_sender()`: Gibt Klon des `command_sender` zurück.
        
- **Struktur `McpServerConfig`:** `command`, `args`, `working_directory`.
    
- **Enums:** `McpClientStatus` (`Disconnected`, `Connecting`, `Connected`, `Error`), `McpCommand` (z.B. `Initialize`, `ListResources`, `ReadResource`, `CallTool`, `Shutdown`).
    

#### 7.2. Submodul: `system::mcp::transport`

Abstraktionsebene für Kommunikationstransport. Meist durch `mcp_client_rs::transport::stdio::StdioTransport` abgedeckt.

#### 7.3. Submodul: `system::mcp::types`

Definitionen für MCP-Anfragen, -Antworten, -Benachrichtigungen. Meist Re-Exporte oder dünne Wrapper um `mcp_client_rs::protocol` und `mcp_client_rs::types`.

**Datei:** `system/mcp/types.rs`

- **Struktur `McpNotification`:** `method: String`, `params: Option<serde_json::Value>`.
    

#### 7.4. Submodul: `system::mcp::error`

Definiert `McpError` mittels `thiserror`.

**Datei:** `system/mcp/error.rs`

- **Enum `McpError`:** Varianten `ServerSpawnFailed`, `TransportError` (aus `mcp_client_rs::Error`), `NotConnected`, `InitializationFailed`, `SerializationFailed` (aus `serde_json::Error`), `RequestTimeout`, `ServerReturnedError` (mit `code`, `message`, `data`), `UnexpectedResponse`, `ResponseChannelDropped`, `CommandSendError`.
    

### 8. Modul: `system::portals` (XDG Desktop Portals Backend)

Implementiert Backend-Logik für XDG Desktop Portals (`org.freedesktop.portal.FileChooser`, `org.freedesktop.portal.Screenshot`). Agiert als D-Bus-Dienst, der Anfragen von Client-Anwendungen bearbeitet. Nutzt `zbus` für D-Bus-Implementierung.

#### 8.1. Submodul: `system::portals::file_chooser`

Implementiert `org.freedesktop.portal.FileChooser` D-Bus-Interface.

**Datei:** `system/portals/file_chooser.rs`

- **Struktur `FileChooserPortal`:** Enthält `connection: Arc<zbus::Connection>`, `ui_event_sender: tokio::sync::mpsc::Sender<UiPortalCommand>` (zur Kommunikation mit UI-Schicht für Dialoganzeige).
    
- **D-Bus Interface Implementierung (`#[zbus::interface(name = "org.freedesktop.portal.FileChooser")]`)**:
    - `OpenFile()`: Extrahiert Optionen. Sendet Befehl an UI-Schicht, um Dateiauswahldialog anzuzeigen. Wartet auf Antwort (ausgewählte URIs). Gibt `Ok((0, {"uris": Value::from(vec!["file:///..."])})` oder Fehlercode/D-Bus-Fehler zurück.
        
    - `SaveFile()`: Ähnlich `OpenFile`, UI zeigt "Speichern"-Dialog. Gibt einzelnen URI zurück.
        
    - `SaveFiles()`: UI zeigt Ordnerauswahldialog. Backend konstruiert vollständige URIs aus ausgewähltem Ordner und übergebenen Dateinamen (`options["files"]`).
        
    - Antworten erfolgen direkt, nicht über separates Request-Objekt für einfache Fälle.
        

#### 8.2. Submodul: `system::portals::screenshot`

Implementiert `org.freedesktop.portal.Screenshot` D-Bus-Interface.

**Datei:** `system/portals/screenshot.rs`

- **Struktur `ScreenshotPortal`:** Enthält `connection: Arc<zbus::Connection>`, `compositor_command_sender: tokio::sync::mpsc::Sender<CompositorScreenshotCommand>` (zur Kommunikation mit Compositor).
    
- **D-Bus Interface Implementierung (`#[zbus::interface(name = "org.freedesktop.portal.Screenshot")]`)**:
    - `Screenshot()`: Extrahiert `interactive`. Sendet Befehl an Compositor, Screenshot zu erstellen (interaktiv oder gesamter Bildschirm). Compositor speichert temporär, gibt Pfad zurück. Konvertiert Pfad zu URI. Gibt `Ok((0, {"uri": Value::from(screenshot_uri)}))` zurück.
        
    - `PickColor()`: Sendet Befehl an Compositor, Farbauswahlmodus zu starten. Compositor meldet RGB-Werte. Gibt `Ok((0, {"color": Value::from((r,g,b))}))` zurück.
        
    - Property `version()`: Gibt implementierte Portal-Version zurück (z.B. 2).
        

#### 8.3. Submodul: `system::portals::common`

Gemeinsame Hilfsmittel und D-Bus-Handhabung.

**Datei:** `system/portals/common.rs`

- **Funktion `run_portal_service()`:**
    - Erstellt D-Bus-Verbindung zum Session-Bus. Registriert Dienstnamen `org.freedesktop.portal.Desktop`.
        
    - Erstellt Instanzen der Portal-Implementierungen (z.B. `FileChooserPortal`, `ScreenshotPortal`).
        
    - Registriert eine einzelne `DesktopPortal`-Struktur (die alle Portal-Interfaces implementiert oder delegiert) unter Pfad `/org/freedesktop/portal/desktop` beim `ObjectServer`.
        
    - Hält Dienst am Laufen.
        
- **Funktion `generate_request_handle()`:** Erzeugt eindeutigen Handle-String für Portal-Anfragen.
    
- **Hilfsstrukturen/Enums für UI/Compositor-Kommunikation:** `UiPortalCommand` (mit `OpenFileOptions`, `SaveFileOptions`), `PortalUiError`, `CompositorScreenshotCommand`.
    

#### 8.4. Submodul: `system::portals::error`

Definiert `PortalsError` mittels `thiserror`.

**Datei:** `system/portals/error.rs`

- **Enum `PortalsError`:** Varianten `DBusConnectionFailed` (aus `zbus::Error`), `DBusNameAcquisitionFailed`, `DBusInterfaceRegistrationFailed`, `UiCommandSendError`, `CompositorCommandSendError`, `UiInteractionFailed`, `CompositorInteractionFailed`, `InvalidOptions`.
    

### Schlussfolgerung

Diese detaillierte technische Spezifikation für die Systemschicht, basierend auf den bereitgestellten Dokumenten, deckt die Kernmodule Compositor, Input, D-Bus-Interaktion, Output-Management, Audio-Integration, MCP-Client und XDG-Desktop-Portal-Backends ab. Die konsequente Anwendung der Entwicklungsrichtlinien und die Nutzung moderner Technologien wie Rust, Smithay, PipeWire und D-Bus sollen eine robuste, performante und wartbare Systemschicht gewährleisten, die als solide Grundlage für die gesamte Desktop-Umgebung dient.

## Technische Spezifikation und Entwicklungsrichtlinien: Kernschicht

Diese Spezifikation beschreibt die fundamentalen Komponenten und Richtlinien für die Entwicklung der Kernschicht der Desktop-Umgebung. Die Kernschicht bildet das Fundament für alle darüberliegenden Schichten und umfasst Module für grundlegende Datentypen (`core::types`), Fehlerbehandlung (`core::errors`), Logging (`core::logging`), Konfigurationsmanagement (`core::config`) und allgemeine Hilfsfunktionen (`core::utils`).

### 1. Modul: `core::types` (Fundamentale Datentypen)

**1.1. Zweck und Verantwortlichkeit** Das Modul `core::types` definiert grundlegende, universell einsetzbare Datentypen, die von allen anderen Schichten und Modulen benötigt werden. Dazu gehören geometrische Primitive, Farbdarstellungen und allgemeine Enumerationen. Diese Typen sind reine Datenstrukturen ohne komplexe Geschäftslogik oder Abhängigkeiten zu höheren Schichten.

**1.2. Designphilosophie** Das Design folgt den Prinzipien der Modularität, Wiederverwendbarkeit und minimalen Kopplung. Typen sind generisch gehalten, wo sinnvoll (z.B. `Point<T>`, `Size<T>`, `Rect<T>`), um Flexibilität für verschiedene numerische Darstellungen zu ermöglichen (z.B. `i32` für Koordinaten, `f32` für Skalierungsfaktoren). Es besteht eine klare Trennung von Datenrepräsentation und Fehlerbehandlung.

**1.3. Ziel-Dateistruktur**

```
core/
└── src/
    ├── lib.rs         # Deklariert Kernmodule: pub mod types; pub mod errors; ...
    └── types/
        ├── mod.rs     # Deklariert und re-exportiert Typen aus geometry.rs, color.rs, etc.
        ├── geometry.rs # Enthält Point<T>, Size<T>, Rect<T>
        ├── color.rs    # Enthält Color
        └── enums.rs    # Enthält Orientation, etc.
```

**1.4. Spezifikation: Geometrische Primitive (`geometry.rs`)**

- **`Point<T>`**: Repräsentiert einen Punkt im 2D-Raum mit `x: T` und `y: T`.
    
    - Konstanten wie `ZERO_I32`, `ZERO_F32` etc..
        
    - Methoden: `new(x: T, y: T)`, `distance_squared(...)`, `distance(...)` (für Float-Typen), `manhattan_distance(...)`.
        
    - Basis-Constraints für `T`: `Copy + Debug + PartialEq + Default + Send + Sync + 'static`.
        
- **`Size<T>`**: Repräsentiert eine 2D-Dimension mit `width: T` und `height: T`.
    
    - Konstanten wie `ZERO_I32`, `ZERO_F32` etc..
        
    - Methoden: `new(width: T, height: T)`, `area()`, `is_empty()`, `is_valid()` (für nicht-negative Dimensionen).
        
    - Basis-Constraints für `T`: `Copy + Debug + PartialEq + Default + Send + Sync + 'static`. Die Invariante nicht-negativer Dimensionen wird durch `is_valid()` prüfbar gemacht, aber nicht durch den Typ erzwungen.
        
- **`Rect<T>`**: Repräsentiert ein 2D-Rechteck, definiert durch `origin: Point<T>` und `size: Size<T>`.
    
    - Konstanten wie `ZERO_I32`, `ZERO_F32` etc..
        
    - Methoden: `new(origin, size)`, `from_coords(x,y,width,height)`, Zugriffsmethoden (`x()`, `y()`, `width()`, `height()`, `top()`, `left()`, `bottom()`, `right()`), `center()`, `contains_point(...)`, `intersects(...)`, `intersection(...)`, `union(...)`, `translated(...)`, `scaled(...)`, `is_valid()`.
        
    - Basis-Constraints für `T`: `Copy + Debug + PartialEq + Default + Send + Sync + 'static`.
        
    - **Invariante**: Logisch sollten `width` und `height` nicht-negativ sein. Die Methode `is_valid()` wird bereitgestellt; Nutzer (besonders mit `T=i32`) sollten diese aufrufen. Die Verantwortung für das Melden eines Fehlers bei Verwendung eines ungültigen `Rect` liegt beim Aufrufer.
        
- **`RectInt`**: (aus einer anderen Quelldatei, aber thematisch passend) Repräsentiert ein achsenparalleles Rechteck mit ganzzahligen Koordinaten (`x: i32`, `y: i32`) und Dimensionen (`width: u32`, `height: u32`).
    
    - Methoden u.a. `new(...)`, `from_points(...)`, `top_left()`, `size()`, `right()`, `bottom()`, `contains_point(...)`, `intersects(...)`, `intersection(...)`, `union(...)`, `translate(...)`, `inflate(...)`, `is_empty()`.
        
    - Verwendet `saturating_add` / `saturating_sub` um Überläufe zu vermeiden.
        
    - Traits: `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Default`.
        

**1.5. Spezifikation: Farbdarstellung (`color.rs`)**

- **`Color` (RGBA)**: Repräsentiert eine Farbe mit `r: f32`, `g: f32`, `b: f32`, `a: f32` Komponenten im Bereich `[0.0, 1.0]`.
    
    - Konstanten: `TRANSPARENT`, `BLACK`, `WHITE`, `RED`, `GREEN`, `BLUE` etc..
        
    - Methoden: `new(r,g,b,a)` (klemmt Werte nicht automatisch, Aufruferverantwortung), `from_rgba8(r,g,b,a)`, `to_rgba8()`, `with_alpha(alpha)` (klemmt Alpha), `blend(background)`, `lighten(amount)`, `darken(amount)`.
        
    - `Default` wird manuell implementiert, um `Color::TRANSPARENT` zurückzugeben.
        
    - Soll `Serialize` und `Deserialize` implementieren, um als Hex-String (z.B. "#RRGGBBAA") in Konfigurationsdateien dargestellt zu werden. Dies erfordert eine `ColorParseError`-Behandlung.
        

**1.6. Spezifikation: Allgemeine Enumerationen (`enums.rs`)**

- **`Orientation`**: Repräsentiert eine horizontale oder vertikale Ausrichtung.
    
    - Varianten: `Horizontal`, `Vertical`.
        
    - Methoden: `toggle()`.
        
    - `Default` ist `Orientation::Horizontal`.
        

**1.7. Standard Trait Implementierungen** Alle Typen sollen grundlegende Traits wie `Debug`, `Clone`, `Copy` (wo anwendbar und `T` es unterstützt), `PartialEq`, `Default` (sinnvoll definiert), `Send` und `Sync` implementieren. `Eq` und `Hash` sind für Fließkommazahlen generell nicht geeignet.

**1.8. Modulabhängigkeiten** Minimale externe Abhängigkeiten: `std`. Optional `num-traits` (für erweiterte numerische Operationen) und `serde` (mit `derive`-Feature, falls Serialisierung direkt hier benötigt wird, aktuell aber eher in höheren Schichten vorgesehen).

### 2. Modul: `core::errors` (Fehlerbehandlung)

**2.1. Zweck und Geltungsbereich** Spezifiziert die verbindliche Strategie und Implementierung der Fehlerbehandlung innerhalb der Kernschicht. Ziel ist eine lückenlose, präzise Spezifikation für Entwickler.

**2.2. Grundlagen und Prinzipien**

- **Verwendung von `thiserror`**: Obligatorisch für die Definition von benutzerdefinierten Fehlertypen. `thiserror` reduziert Boilerplate-Code für `std::error::Error` und `std::fmt::Display`. Alle benutzerdefinierten Fehler-Enums in der Kernschicht müssen `thiserror::Error` ableiten.
    
- **`Result<T, E>` vs. `panic!`**: Strikte Trennung.
    
    - `Result<T, E>`: Standard für erwartete, potenziell behebbare Fehlerzustände (z.B. I/O-Fehler, ungültige Eingaben). Funktionen müssen `Result<T, E>` zurückgeben, wobei `E` typischerweise `CoreError` oder ein spezifischerer Modul-Fehler ist.
        
    - `panic!`: Ausschließlich für nicht behebbare Programmierfehler (Bugs), Verletzung von Vorbedingungen oder logisch unmögliche interne Zustände.
        
- **Umgang mit `.unwrap()` und `.expect()`**: In produktivem Code der Kernschicht strengstens zu vermeiden, da sie die strukturierte Fehlerbehandlung umgehen.
    
    - Ausnahme für `expect()`: Nur wenn ein `Err`- oder `None`-Zustand nachweislich einen Bug darstellt (interne Invariante verletzt). Die Nachricht muss dem "expect as precondition"-Stil folgen und erklären, _warum_ ein `Ok`- oder `Some`-Wert erwartet wurde.
        
- **Anforderungen an Fehlermeldungen (`#[error("...")]`)**:
    - Klarheit und Präzision, eindeutige Problembeschreibung.
        
    - Kontextinformationen durch eingebettete Feldwerte (`{field_name}`).
        
    - Zielgruppe: Entwickler (für Logging/Debugging).
        
    - Format: Knappe, klein geschriebene Sätze ohne abschließende Satzzeichen (Rust API Guidelines).
        
- **Keine sensiblen Daten in Fehlermeldungen**: Niemals Passwörter, API-Schlüssel, private Benutzerdaten etc. in Fehlermeldungen oder Kontextfeldern. Daten müssen maskiert, entfernt oder durch Platzhalter ersetzt werden.
    

**2.3. Strategie: Ein Fehler-Enum pro Modul** Jedes signifikante Modul innerhalb der Kernschicht (und höheren Schichten) definiert sein eigenes, spezifisches Fehler-Enum mit `thiserror`. Dies vermeidet Überladung des zentralen `CoreError` und adressiert `thiserror`-Einschränkungen bezüglich mehrdeutiger `#[from]`-Konvertierungen desselben Quelltyps.

**2.4. Definition des Basis-Fehlertyps: `CoreError`** Ein zentrales, öffentliches Enum `CoreError` in `core::errors` dient als primäre Schnittstelle für Fehler, die von öffentlichen Funktionen der Kernschicht propagiert werden. Es aggregiert allgemeine Fehlerarten und spezifischere Fehler aus Untermodulen (via `#[from]`).

- **Spezifikation `CoreError`** (Beispielvarianten):
    
    - `Io { path: PathBuf, #[source] source: std::io::Error }`
        
    - `Configuration(#[from] ConfigError)`
        
    - `Serialization { description: String }`
        
    - `InvalidId { invalid_id: String }`
        
    - `NotFound { resource_description: String }`
        
    - `Internal(String)` (sollte vermieden und durch spezifischere Varianten ersetzt werden)
        
    - `InitializationFailed { component: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
        
- **Ableitungen**: Mindestens `Debug` und `thiserror::Error`.
    
- **Fehlerverkettung (`source()`)**: Wird von `thiserror` automatisch für `#[source]` und `#[from]` annotierte Felder implementiert, um die Ursache zurückzuverfolgen.
    

**2.5. Modul-spezifische Fehler und Integration** Module definieren eigene Fehler-Enums (z.B. `ConfigError`, `UtilsError`) die `thiserror::Error` ableiten.

- **Integrationsmechanismus**: Eine dedizierte Variante in `CoreError`, die den Modul-Fehler kapselt und `#[from]` verwendet, ist der bevorzugte Weg. Beispiel: `Configuration(#[from] ConfigError)` in `CoreError`.
    
- Dies etabliert eine zweistufige Fehlerhierarchie.
    

**2.6. Fehlerkontext und Diagnose** Fehlervarianten sollen relevante Kontextinformationen als Felder enthalten (Dateipfade, ungültige Werte etc.).

**2.7. Implementierungsleitfaden für Entwickler (Fehlerdefinition und -behandlung)**

- **Neue Variante zu `CoreError` hinzufügen**: Prüfen, ob der Fehlerfall allgemeine Bedeutung hat oder besser in einem Modul-Fehler aufgehoben ist. Variante, `#[error]`-Meldung und Kontextfelder definieren. `#[source]` oder `#[from]` für Kapselung verwenden.
    
- **Neuen Modul-Fehler erstellen**: `errors.rs` im Modulverzeichnis anlegen. Enum definieren, `thiserror::Error` ableiten, Varianten und Meldungen spezifizieren. In `CoreError` über eine `#[from]`-Variante integrieren.
    
- **Verwendung des `?`-Operators**: Standard für Fehlerpropagation. Funktioniert nahtlos bei identischen Fehlertypen oder existierender `From`-Implementierung.
    
- **Fehler-Matching (`match`)**: Für spezifische Behandlung (Standardwerte, alternative Pfade, Anreicherung).
    
- **Umgang mit externen Crates**: Fehler von externen Bibliotheken müssen in einen Kernschicht-Fehlertyp (`CoreError` oder Modul-Fehler) gekapselt werden. Bevorzugt mit `#[from]` oder `#[source]` (manuelle Erzeugung via `.map_err()`).
    

### 3. Modul: `core::logging` (Logging-Infrastruktur)

**3.1. Grundlagen und Wahl von `tracing`** Die Desktop-Umgebung verwendet das `tracing`-Crate für strukturiertes Logging. `core::logging` stellt Initialisierungsroutinen bereit.

**3.2. `tracing` Framework Integrationsdetails**

- **Initialisierung**: Eine Funktion `initialize_logging(level_filter: tracing::LevelFilter, format: LogFormatEnum) -> Result<(), LoggingError>` wird früh im Anwendungsstart aufgerufen. `LogFormatEnum` könnte `PlainTextDevelopment`, `JsonProduction` definieren. `LoggingError` ist ein `thiserror`-Enum in `core::logging`.
    
- **Subscriber-Konfiguration**:
    - Entwicklung: `tracing_subscriber::fmt()` mit menschenlesbarer Ausgabe (`with_ansi(true)`, `with_target(true)`, `with_file(true)`, `with_line_number(true)`).
        
    - Release: Strukturiertes JSON-Format für Log-Aggregation und maschinelle Analyse (`tracing_subscriber::fmt::json()` oder `tracing-bunyan-formatter`).
        
- **Dynamische Log-Level-Änderungen**: Für zukünftige Erweiterungen berücksichtigen (z.B. via `tracing_subscriber::filter::EnvFilter` oder `RUST_LOG`).
    

**3.3. Standardisierte Log-Makros und `tracing::instrument` Verwendung**

- **Standard-Makros**: Direkte Verwendung von `trace!`, `debug!`, `info!`, `warn!`, `error!` ist verbindlich.
    
- **Log-Nachrichtenstruktur**: Prägnant und beschreibend. Schlüssel-Wert-Paare für strukturierte Daten: `tracing::info!(user_id = %user.id, " Nachricht")` (% für Display, ? für Debug). Fehler mit `error = ?err` loggen, um die Debug-Repräsentation (inkl. `source`-Kette) zu erfassen.
    
- **`#[tracing::instrument]` Verwendung**: Erzeugt Spans für Funktionen/Codeblöcke, gruppiert Log-Ereignisse.
    
    - Anwendung auf öffentliche API-Funktionen, I/O-Operationen, komplexe Berechnungen, abgeschlossene operative Einheiten.
        
    - `skip(...)` / `skip_all` für sensible/ausführliche Argumente.
        
    - `fields(...)` für spezifischen Kontext im Span.
        
    - `err` zur automatischen Fehlerprotokollierung bei `Result::Err`.
        
    - `level` zur Steuerung des Span-Levels.
        

**3.4. Logging von Fehlern** Jeder Fehler (`Result::Err`) sollte an seiner Ursprungsstelle oder einer geeigneten übergeordneten Stelle mit ausreichend Kontext geloggt werden, mindestens auf `ERROR`-Level (`tracing::error!`). Dies sollte typischerweise _vor_ der Propagation geschehen. Den Fehler selbst als strukturiertes Feld mitgeben: `error!(error = %core_err, "Nachricht")`.

**3.5. Log-Daten Sensibilität** Absolutes Verbot, sensible Daten (Passwörter, API-Schlüssel, PII etc.) im Klartext zu loggen. Daten redigieren oder auslassen. Vorsicht bei `Debug`-Implementierungen für Strukturen mit sensiblen Daten; ggf. manuelle Redaktion in `Debug` oder `skip_all` in `#[tracing::instrument]` verwenden.

### 4. Modul: `core::config` (Konfigurationsprimitive)

**4.1. Zweck** Definiert, wie grundlegende Konfigurationseinstellungen geladen, geparst und zugegriffen werden. Fokus auf Einfachheit, Robustheit.

**4.2. Konfigurationsdateiformat und Parsing-Logik**

- **Format**: TOML (Tom's Obvious, Minimal Language) wegen Lesbarkeit und einfacher Verarbeitung.
    
- **Parsing-Bibliothek**: `serde` in Verbindung mit `toml`-Crate (`serde_toml`).
    
- **Ladelogik**:
    - Definition von Standard-Konfigurationspfaden (z.B. systemweit, Entwicklungstests). XDG-Pfade für benutzerspezifische Konfigurationen in höheren Schichten berücksichtigen.
        
    - Eine Funktion wie `load_core_config(custom_path: Option<PathBuf>) -> Result<CoreConfig, ConfigError>` implementiert eine Suchreihenfolge, liest und deserialisiert die TOML-Datei.
        
    - Fehlerbehandlung mit `core::config::ConfigError` (definiert mit `thiserror`), Varianten wie `FileReadError`, `DeserializationError`, `NoConfigurationFileFound`.
        

**4.3. Konfigurationsdatenstrukturen (Ultra-Fein)**

- **`CoreConfig`-Struktur**: Eine primäre Struktur (z.B. `CoreConfig`) hält alle spezifischen Konfigurationen der Kernschicht.
    
    - Felder mit explizit definierten Typen.
        
    - Muss `serde::Deserialize` ableiten.
        
    - `#[serde(default = "path")]` oder `#[serde(default)]` umfassend verwenden für Standardwerte bei fehlenden Feldern.
        
    - `#[serde(deny_unknown_fields)]` erzwingen, um Tippfehler oder unbekannte Felder in Konfigurationsdateien zu verhindern.
        
- **Validierung**: Grundlegende Validierung durch Typen. Komplexere Validierungen nach Deserialisierung (z.B. via `TryFrom` Muster oder `validate()`-Methode). Für Kernschicht kann initiale Validierung auf `serde`-Fähigkeiten beschränkt sein.
    

**4.4. Konfigurationszugriffs-API**

- **Globaler Zugriff**: Geladene `CoreConfig`-Instanz threadsicher speichern, typischerweise mittels `once_cell::sync::OnceCell`.
    
    - `initialize_core_config(config: CoreConfig) -> Result<(), CoreConfig>` zum einmaligen Setzen.
        
    - `get_core_config() -> &'static CoreConfig` für den Zugriff; paniert, wenn nicht initialisiert (Programmierfehler).
        
- **Immutabilität**: Global zugängliche Konfiguration sollte nach Initialisierung unveränderlich sein. `CoreConfig` sollte `Clone` ableiten für Momentaufnahmen oder Tests.
    

### 5. Modul: `core::utils` (Allgemeine Hilfsfunktionen)

**5.1. Zweck** Beherbergt allgemeine Hilfsfunktionen und kleine, in sich geschlossene Utilities, die nicht in spezifischere Module passen, aber breit verwendet werden.

**5.2. Allgemeine Richtlinien**

- **Geltungsbereich**: Nur wirklich allgemeine Utilities.
- **Einfachheit**: Einfache Funktionen bevorzugen.
- **Reinheit**: Reine Funktionen (Ausgabe hängt nur von Eingabe ab, keine Seiteneffekte) bevorzugen.
- **Fehlerbehandlung**: Jede fehleranfällige Utility-Funktion gibt `Result<T, YourUtilError>` zurück, wobei `YourUtilError` mit `thiserror` im Utility-Submodul definiert wird.
- **Dokumentation**: Umfassende `rustdoc`-Kommentare mit Beispielen.
- **Tests**: Gründliche Unit-Tests.

### 6. Allgemeine Entwicklungsrichtlinien (Kernschicht)

**6.1. Dokumentation (`rustdoc`)** Alle öffentlichen Elemente (Module, Structs, Enums, Felder, Konstanten, Methoden) müssen `///`-Dokumentationskommentare haben.

- Modul-Level: Zweck des Moduls.
- Typ-Level: Zweck und Invarianten.
- Feld-Level: Bedeutung des Feldes.
- Methoden-Level: Was die Methode tut, Parameter, Rückgabewerte, mögliche Panics (idealerweise keine außer in Tests), Vor-/Nachbedingungen, Algorithmen.
- `# Examples`-Abschnitte verwenden.
- Strikte Einhaltung der Rust API Guidelines.
- `cargo doc --open` zur Überprüfung.

**6.2. Unit-Testing**

- Ein `#[cfg(test)]`-Modul innerhalb jeder Implementierungsdatei.
- Tests für Konstruktoren, Konstanten, Methodenlogik, Grenzfälle, Trait-Implementierungen, Invariantenprüfungen.
- Anstreben einer hohen Testabdeckung.

**6.3. Immutabilität und Stabilität** Die API der Kernschicht sollte nach Stabilisierung als äußerst stabil behandelt werden. Änderungen haben weitreichende Auswirkungen. Komponenten sind so konzipiert, dass sie `Send + Sync` sind, wo sinnvoll, für Multithreading.

**6.4. Schichtübergreifende Integrationsrichtlinien**

- **Fehlerbehandlung**: Höhere Schichten definieren eigene `thiserror`-Enums. Fehler aus der Kernschicht werden behandelt oder via `?` propagiert (ggf. mit `#[from]` in eigene Fehlertypen konvertiert), Fehlerkette (`source()`) muss erhalten bleiben.
- **Logging**: Alle Schichten nutzen `tracing`-Makros. `core::logging::initialize_logging()` wird vom Hauptbinary aufgerufen. Einhaltung von Log-Leveln und Datensensibilität ist zwingend.
- **Konfiguration**: Höhere Schichten können eigene Konfigs definieren. Zugriff auf Kern-Konfig via `core::config::get_core_config()`. Kern-Konfig nicht zur Laufzeit modifizieren.
- **Typen und Utilities**: Kerndatentypen und -utilities direkt verwenden. Bei Spezialisierung Komposition oder Newtype-Wrapper um Kerntypen in Betracht ziehen.

Diese Spezifikation legt den Grundstein für eine robuste, wartbare und performante Kernschicht. Die disziplinierte Einhaltung dieser Richtlinien ist für den Erfolg des Projekts entscheidend.

# NovaDE: Ultra-Granulare Definition Interner Schnittstellen

## Präambel: Grundlegende Prinzipien

Die Architektur von NovaDE basiert auf einer Reihe fundamentaler Kommunikations- und Strukturprinzipien, die darauf abzielen, ein robustes, modulares und wartbares System zu schaffen. Diese Prinzipien sind entscheidend für das Erreichen der übergeordneten Projektziele wie Performance, intuitive Bedienung, Modernität, Modularität, Anpassbarkeit, sichere KI-Integration und Stabilität.

- **Kernprinzipien der Kommunikation:**
    - Die Interaktion zwischen den verschiedenen Schichten des Systems – Kern (Core), Domäne (Domain), System und Benutzeroberfläche (UI) – erfolgt primär über klar definierte öffentliche Programmierschnittstellen (APIs). Diese APIs werden in der Regel als Rust-Traits spezifiziert und von Service-Strukturen innerhalb der jeweiligen Schicht implementiert. Dieser Ansatz fördert ein vertragsbasiertes Interaktionsmodell, das die Kopplung zwischen den Schichten minimiert und die Austauschbarkeit von Implementierungen erleichtert.
    - Ein integraler Bestandteil der Architektur ist ein robustes, ereignisgesteuertes System. Dieses System dient der Benachrichtigung über Zustandsänderungen und ermöglicht entkoppelte Interaktionen zwischen den Schichten. Komponenten können auf relevante Ereignisse reagieren, ohne direkte Abhängigkeiten zu den Ereigniserzeugern aufbauen zu müssen. Dies ist besonders für die UI-Schicht von Bedeutung, da es reaktive Updates auf Änderungen im Domänenzustand oder Systemstatus ohne Polling-Mechanismen ermöglicht.
    - Eine strikte Schichtenarchitektur wird durchgesetzt: Höhere Schichten dürfen typischerweise nur von unmittelbar tieferliegenden Schichten abhängen. Dieses hierarchische Abhängigkeitsmodell verbessert die Modularität, Testbarkeit und Wartbarkeit, indem es zirkuläre Abhängigkeiten und unkontrollierte Interaktionen verhindert.
    - **Fehlerbehandlung:** Eine konsistente Fehlerbehandlungsstrategie wird über alle Schichten hinweg angewendet. Die `thiserror`-Bibliothek wird für die Definition von spezifischen, benutzerdefinierten Fehlertypen genutzt. `core::errors::CoreError` dient als fundamentaler Basistyp für Fehler. Es ist zwingend erforderlich, dass Fehlerketten (abrufbar über die `source()`-Methode) bei der Weitergabe oder beim Wrappen von Fehlern erhalten bleiben, um eine umfassende Fehlerdiagnose zu gewährleisten.

Die Kombination aus strikter Schichtung, einem API-First-Design (mittels Rust-Traits) und einem ereignisgesteuerten Ansatz bildet ein leistungsfähiges Fundament für NovaDE. Das Ereignissystem ist insbesondere für die UI-Schicht von entscheidender Bedeutung, da es ihr ermöglicht, reaktiv auf zugrundeliegende Änderungen im Domänenzustand oder Systemstatus zu reagieren, ohne auf ineffiziente Polling-Mechanismen zurückgreifen zu müssen. Beispielsweise kann die UI dynamisch aktualisiert werden, wenn ein `ThemeChangedEvent` vom `ThemingEngine` ausgelöst wird, anstatt periodisch den aktuellen Theme-Status abfragen zu müssen. Diese Entkopplung reduziert die Systemlast und verbessert die Reaktionsfähigkeit der Benutzeroberfläche. Die nachfolgende ultra-granulare Definition wird daher nicht nur die synchronen API-Methoden detailliert beschreiben, sondern auch die präzise Struktur, den Payload und die Semantik jedes Ereignisses, das zwischen den Schichten ausgetauscht wird. Dies stellt sicher, dass sowohl API-Konsumenten als auch Ereignis-Abonnenten ein klares und eindeutiges Verständnis der Daten haben, die sie senden oder empfangen werden.

---

**Teil 1: Ultra-Granulare Schnittstellendefinition der UI-Schicht**

Dieser Teil adressiert die primäre Anforderung einer detaillierten Schnittstellendefinition für die UI-Schicht und konzentriert sich darauf, wie diese mit der Domänen- und der Systemschicht interagiert. Die UI-Schicht ist für die Präsentation von Informationen für den Benutzer und die Übersetzung von Benutzereingaben in Aktionen auf den unteren Schichten verantwortlich.

- **1.1. Interaktionsprinzipien der UI-Schicht mit unteren Schichten**
    
    - **UI als Konsument von Domänenlogik und Systemdiensten:**
        - Die UI-Schicht agiert als primärer Interaktionspunkt mit dem Benutzer. Sie übersetzt Benutzereingaben (z.B. Klicks, Tastatureingaben, Gesten) in spezifische, wohldefinierte Aufrufe von Methoden, die von Diensten der Domänenschicht (für Geschäftslogik und Anwendungszustandsmanipulation) oder der Systemschicht (für Betriebssystem- oder Hardwareinteraktionen) bereitgestellt werden.
        - Ein entscheidender Aspekt ist, dass die UI-Schicht Ereignisse abonniert, die sowohl von der Domänen- als auch von der Systemschicht stammen. Diese Ereignisse signalisieren Zustandsänderungen oder das Auftreten bemerkenswerter Systemaktivitäten. Dies ermöglicht es der UI, ihre Darstellung dynamisch und reaktiv zu aktualisieren und so den aktuellen Zustand der Anwendung und des zugrundeliegenden Systems widerzuspiegeln.
        - Obwohl die interne Implementierung von UI-Komponenten stark auf einem Toolkit wie GTK4 basieren wird, werden die in diesem Dokument definierten Schnittstellen (zwischen UI und Domäne/System) in Form von reinen Rust-Typen, Traits und Ereignis-Strukturen spezifiziert. Diese Abstraktion stellt sicher, dass die Kernlogik von NovaDE nicht intrinsisch an ein spezifisches UI-Toolkit gebunden ist. Beispielsweise wird ein `core::types::Color` in API-Signaturen verwendet, nicht ein Toolkit-spezifischer Typ wie `gdk4::RGBA`.
    - **Zustandsverwaltung in der UI:**
        - Die UI-Schicht ist für die Verwaltung ihres eigenen Präsentationszustands verantwortlich (oft als ViewModels oder UI-spezifischer Zustand bezeichnet). Dieser Zustand wird von dem Zustand abgeleitet, der von der Domänen- und Systemschicht verwaltet wird, und muss mit diesem synchron gehalten werden.
        - Eine robuste und effiziente UI-Zustandsverwaltung ist für eine reaktionsschnelle und konsistente Benutzererfahrung von größter Bedeutung. Während die UI-Schicht ihre visuelle Darstellung und temporäre Interaktionszustände verwaltet, befindet sich die autoritative "Wahrheitsquelle" (Source of Truth) für geschäftskritische Daten innerhalb der Domänenschicht und für den Systemstatus innerhalb der Systemschicht. Die UI muss so aufgebaut sein, dass sie effizient auf Änderungen reagiert, die von diesen unteren Schichten signalisiert werden.
        - Die Benutzeranfrage liefert ein Beispiel: `ui::theming_gtk` konsumiert `AppliedThemeState` von `ThemingEngine`. Dieses Interaktionsmuster impliziert einen reaktiven Aktualisierungsmechanismus. Verschiedene Ansätze zur Zustandsverwaltung in `gtk-rs`-Anwendungen, einschließlich der Verwendung von `Rc<RefCell<T>>` für Single-Threaded Shared Mutability oder Mustern wie TEA (The Elm Architecture) oder Relm4, werden in der Forschung diskutiert.1 Für die geschichtete Architektur von NovaDE ist der am besten geeignete Ansatz, dass die UI-Schicht Domänen- und Systemereignisse abonniert. Nach dem Empfang eines Ereignisses aktualisiert die UI ihren lokalen Zustand (der GObject-Eigenschaften, Relm4-Modellfelder oder andere UI-Toolkit-spezifische Zustandscontainer sein können). Dieser ereignisgesteuerte Ansatz vermeidet eine enge Kopplung, bei der die Domänen- oder Systemschicht direkte Kenntnis von GTK-GObjects oder anderen UI-internen Details haben müsste.
        - Ereignisbehandlungsmechanismen innerhalb von GTK4 und verschiedene Zustandsverwaltungsmuster 1 sind für die interne Implementierung der UI-Schicht relevant. Dieses Schnittstellendefinitionsdokument konzentriert sich jedoch auf die Ereignisse, die die UI von unteren Schichten konsumiert, und die Daten-Payloads, die diese Ereignisse transportieren.
    - **Strategie zur Fehlerpräsentation:**
        - Die UI-Schicht trägt die Verantwortung für die Übersetzung von Fehlern, die von der Domänen- und Systemschicht empfangen werden, in benutzerfreundliche und kontextuell angemessene Benachrichtigungen, Dialoge oder visuelle Hinweise. Rohe technische Fehlerdetails sollten dem Endbenutzer nicht direkt präsentiert werden.
        - Intern könnte die UI `gtk::AlertDialog` 6 oder benutzerdefinierte Benachrichtigungs-Widgets (potenziell unter Verwendung von `gtk4-layer-shell` 9 für nicht-modale Popups) zur Darstellung dieser übersetzten Fehler verwenden. Diese Schnittstellendefinition wird spezifizieren, wie Fehlertypen (z.B. `ThemingError`, `CompositorError`) von unteren Schichten erwartet werden, von der UI behandelt und potenziell auf standardisierte benutzerorientierte Fehlerkategorien oder -nachrichten abgebildet zu werden.
        - Eine konsistente und verständliche Fehlerpräsentationsstrategie ist grundlegend für eine gute Benutzererfahrung. Die UI muss als Filter und Übersetzer fungieren und Benutzer vor komplexen oder kryptischen internen Fehlerdetails schützen. Die Benutzeranfrage spezifiziert, dass alle Schichten `thiserror`-basierte Fehler-Enums verwenden. Die UI-Schicht wird diese spezifischen Fehlertypen empfangen. Wenn beispielsweise der `WorkspaceManager` einen `WorkspaceManagerError::WorkspaceNotFound` zurückgibt, sollte die UI-Schicht diese rohe Enum-Variante nicht anzeigen. Stattdessen sollte sie dies in eine für Menschen lesbare Nachricht wie "Der ausgewählte Arbeitsbereich konnte nicht gefunden werden." übersetzen oder gegebenenfalls einen Dialog mit Wiederherstellungsoptionen anbieten. Diese Übersetzungs- und Präsentationslogik ist eine Kernaufgabe der UI-Schicht. Die Schnittstellendefinition sollte dies leiten, indem sie Fehlerkategorien vorschlägt, die die UI von jedem Dienst zu behandeln bereit sein sollte.
- 1.2. Schnittstelle der UI-Schicht mit der Domänenschicht
    
    Dieser Abschnitt definiert ultra-granular die Interaktionen der UI-Schicht mit jedem von der Domänenschicht bereitgestellten Dienst.
    
    - **1.2.1. `ThemingEngine`-API-Nutzung durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, das aktuelle visuelle Thema der NovaDE-Umgebung abzufragen und zu ändern.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `update_configuration`: `domain::theming::ThemeConfigurationUpdate { theme_name: Option<String>, variant_name: Option<String>, custom_color_palette: Option<HashMap<String, core::types::Color>> }`
            - Ausgabe von `get_current_theme_state`: `domain::theming::AppliedThemeState { theme_name: String, variant_name: String, primary_accent_color: core::types::Color, secondary_accent_color: core::types::Color, default_background_color: core::types::Color, default_text_color: core::types::Color, default_font_family: String, default_font_size: u16, border_radius: u8, shadow_intensity: f32 }`
            - Ausgabe von `get_available_themes`: `Vec<domain::theming::ThemeIdentifier { theme_id: String, display_name: String, available_variants: Vec<String>, preview_icon_path: Option<PathBuf>, author: Option<String>, description: Option<String> }>`
            - Ausgabe von `get_current_configuration`: `domain::theming::CurrentThemeConfiguration { theme_name: String, variant_name: String, custom_palette: HashMap<String, core::types::Color> }`
        - **Von der UI aufgerufene API-Methoden (aus `domain::ThemingEngine`-Trait):**
            - `fn get_current_theme_state(&self) -> Result<domain::theming::AppliedThemeState, domain::ThemingError>;`
            - `fn get_available_themes(&self) -> Result<Vec<domain::theming::ThemeIdentifier>, domain::ThemingError>;`
            - `fn get_current_configuration(&self) -> Result<domain::theming::CurrentThemeConfiguration, domain::ThemingError>;`
            - `fn update_configuration(&self, config_update: domain::theming::ThemeConfigurationUpdate) -> Result<(), domain::ThemingError>;`
            - `fn reload_themes_and_tokens(&self) -> Result<(), domain::ThemingError>;`
            - `// Die Ereignisabonnierung erfolgt über einen globalen EventBus oder eine dedizierte Abonnementmethode, falls eine feingranulare Steuerung erforderlich ist.`
        - **Von der UI konsumierte Event-Payloads:**
            - `domain::theming::ThemeChangedEvent { new_state: domain::theming::AppliedThemeState }`
        - **Fehlerbehandlung durch die UI:** Die UI muss `domain::ThemingError`-Varianten (z.B. `ThemeNotFound`, `InvalidConfiguration`, `AssetLoadFailure`) auf angemessene benutzerorientierte Nachrichten oder Wiederherstellungsaktionen abbilden.
    - **1.2.2. `WorkspaceManager`-API-Nutzung durch die UI:**
        
        - **Zweck:** Ermöglicht der UI die Verwaltung virtueller Arbeitsbereiche, einschließlich deren Erstellung, Löschung, Aktivierung und Zuweisung von Fenstern.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `create_workspace`: `domain::workspaces::CreateWorkspaceParams { name: Option<String>, layout_hint: Option<domain::workspaces::WorkspaceLayoutType>, icon_name: Option<String> }`
            - Eingabe für `assign_window_to_workspace`: `window_id: core::types::WindowId`, `workspace_id: core::types::WorkspaceId`
            - Eingabe für `rename_workspace`: `workspace_id: core::types::WorkspaceId`, `new_name: String`
            - Ausgabe von `get_active_workspace`, `get_workspace_by_id`, `list_workspaces`: `domain::workspaces::WorkspaceDescriptor { id: core::types::WorkspaceId, name: String, display_name: String, icon_name: Option<String>, layout: domain::workspaces::WorkspaceLayoutType, window_ids: Vec<core::types::WindowId>, is_active: bool, creation_timestamp: core::types::DateTime<Utc> }`
            - Enum `domain::workspaces::WorkspaceLayoutType { TilingHorizontal, TilingVertical, Floating, Maximized }`
        - **Von der UI aufgerufene API-Methoden (aus `domain::WorkspaceManager`-Trait):**
            - `fn create_workspace(&self, params: domain::workspaces::CreateWorkspaceParams) -> Result<core::types::WorkspaceId, domain::WorkspaceManagerError>;`
            - `fn delete_workspace(&self, id: core::types::WorkspaceId) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn set_active_workspace(&self, id: core::types::WorkspaceId) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn get_active_workspace(&self) -> Result<Option<domain::workspaces::WorkspaceDescriptor>, domain::WorkspaceManagerError>;`
            - `fn get_workspace_by_id(&self, id: core::types::WorkspaceId) -> Result<Option<domain::workspaces::WorkspaceDescriptor>, domain::WorkspaceManagerError>;`
            - `fn list_workspaces(&self) -> Result<Vec<domain::workspaces::WorkspaceDescriptor>, domain::WorkspaceManagerError>;`
            - `fn assign_window_to_workspace(&self, window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn remove_window_from_workspace(&self, window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn get_window_assignment(&self, window_id: core::types::WindowId) -> Result<Option<core::types::WorkspaceId>, domain::WorkspaceManagerError>;`
            - `fn save_workspace_configuration(&self) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn rename_workspace(&self, workspace_id: core::types::WorkspaceId, new_name: String) -> Result<(), domain::WorkspaceManagerError>;`
            - `fn set_workspace_layout(&self, workspace_id: core::types::WorkspaceId, layout: domain::workspaces::WorkspaceLayoutType) -> Result<(), domain::WorkspaceManagerError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `domain::workspaces::WorkspaceCreatedEvent { descriptor: domain::workspaces::WorkspaceDescriptor }`
            - `domain::workspaces::WorkspaceDeletedEvent { workspace_id: core::types::WorkspaceId, previous_name: String }`
            - `domain::workspaces::ActiveWorkspaceChangedEvent { old_workspace_id: Option<core::types::WorkspaceId>, new_workspace_id: core::types::WorkspaceId }`
            - `domain::workspaces::WorkspaceLayoutChangedEvent { workspace_id: core::types::WorkspaceId, new_layout: domain::workspaces::WorkspaceLayoutType }`
            - `domain::workspaces::WindowAssignedToWorkspaceEvent { window_id: core::types::WindowId, new_workspace_id: core::types::WorkspaceId, old_workspace_id: Option<core::types::WorkspaceId> }`
            - `domain::workspaces::WindowRemovedFromWorkspaceEvent { window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId }`
            - `domain::workspaces::WorkspaceRenamedEvent { workspace_id: core::types::WorkspaceId, new_name: String, old_name: String }`
            - `domain::workspaces::WorkspaceOrderChangedEvent { ordered_workspace_ids: Vec<core::types::WorkspaceId> }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `domain::WorkspaceManagerError`-Varianten (z.B. `WorkspaceNotFound`, `WindowNotManaged`, `NameConflict`) auf Benutzerfeedback.
    - **1.2.3. `AIInteractionLogicService`-API-Nutzung durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, KI-gestützte Interaktionen zu initiieren, Kontextinformationen abzurufen und Benutzereinwilligungen zu verwalten.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `initiate_interaction`: `domain::ai::InteractionRequest { prompt_text: String, context_type: domain::ai::AIContextType, attachments: Option<Vec<domain::ai::AIAttachment>>, preferred_model_id: Option<String> }`
            - Enum `domain::ai::AIContextType { GeneralText, CodeGeneration, ImageAnalysis, /*... */ }`
            - Struct `domain::ai::AIAttachment { mime_type: String, data_uri: String /* or PathBuf if local */, name: Option<String> }`
            - Ausgabe von `initiate_interaction`: `domain::ai::InteractionResponseHandle { interaction_id: core::types::Uuid }` (Weitere Ergebnisse/Streams könnten über Events oder eine Streaming-API kommen)
            - Ausgabe von `get_interaction_context`: `domain::ai::InteractionContext { interaction_id: core::types::Uuid, status: domain::ai::AIInteractionStatus, history: Vec<domain::ai::AIMessage>, available_actions: Vec<domain::ai::AIActionSuggestion> }`
            - Enum `domain::ai::AIInteractionStatus { PendingInput, Processing, AwaitingConsent, Completed, Error }`
            - Struct `domain::ai::AIMessage { role: domain::ai::AIRole, content: String, timestamp: core::types::DateTime<Utc> }`
            - Enum `domain::ai::AIRole { User, Assistant, System }`
            - Struct `domain::ai::AIActionSuggestion { action_id: String, display_text: String, action_type: domain::ai::AIActionType }`
            - Enum `domain::ai::AIActionType { ExecuteCommand, InsertText, OpenLink }`
            - Eingabe für `provide_consent`: `interaction_id: core::types::Uuid, model_id: String, consent_granted: bool`
            - Ausgabe von `get_consent_for_model`: `domain::ai::AIConsentStatus { model_id: String, granted: bool, last_updated: core::types::DateTime<Utc> }`
            - Struct `domain::ai::AIModelProfile { model_id: String, display_name: String, provider: String, capabilities: Vec<domain::ai::AIContextType>, requires_consent: bool }`
        - **Von der UI aufgerufene API-Methoden (aus `domain::AIInteractionLogicService`-Trait):**
            - `async fn initiate_interaction(&self, request: domain::ai::InteractionRequest) -> Result<domain::ai::InteractionResponseHandle, domain::AIInteractionError>;`
            - `async fn get_interaction_context(&self, interaction_id: core::types::Uuid) -> Result<domain::ai::InteractionContext, domain::AIInteractionError>;`
            - `async fn provide_consent(&self, interaction_id: core::types::Uuid, model_id: String, consent_granted: bool) -> Result<(), domain::AIInteractionError>;`
            - `async fn get_consent_for_model(&self, model_id: String) -> Result<domain::ai::AIConsentStatus, domain::AIInteractionError>;`
            - `async fn store_consent(&self, model_id: String, granted: bool) -> Result<(), domain::AIInteractionError>;`
            - `async fn load_model_profiles(&self) -> Result<Vec<domain::ai::AIModelProfile>, domain::AIInteractionError>;`
            - `async fn send_message_to_interaction(&self, interaction_id: core::types::Uuid, message: domain::ai::AIMessage) -> Result<(), domain::AIInteractionError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `domain::ai::AIInteractionInitiatedEvent { interaction_id: core::types::Uuid, initial_prompt: String }`
            - `domain::ai::AIConsentUpdatedEvent { model_id: String, new_status: domain::ai::AIConsentStatus }`
            - `domain::ai::AIInteractionStatusChangedEvent { interaction_id: core::types::Uuid, new_status: domain::ai::AIInteractionStatus, details: Option<String> }`
            - `domain::ai::NewAIMessageEvent { interaction_id: core::types::Uuid, message: domain::ai::AIMessage }`
            - `domain::ai::AIInteractionErrorEvent { interaction_id: Option<core::types::Uuid>, error_message: String, is_fatal: bool }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `domain::AIInteractionError`-Varianten (z.B. `ModelUnavailable`, `ConsentRequired`, `NetworkError`) auf Benutzerfeedback.
    - **1.2.4. `NotificationService`-API-Nutzung durch die UI (primär für das Posten von UI-generierten Benachrichtigungen):**
        
        - **Zweck:** Ermöglicht der UI, anwendungsspezifische Benachrichtigungen zu erstellen und anzuzeigen, sowie bestehende Benachrichtigungen zu verwalten.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `post_notification`: `domain::notifications::NotificationData { app_name: String, app_icon: Option<String>, summary: String, body: Option<String>, actions: Vec<domain::notifications::NotificationAction>, urgency: domain::notifications::NotificationUrgency, timeout_ms: Option<u32>, category: Option<String>, transient: bool }`
            - Struct `domain::notifications::NotificationAction { id: String, display_text: String }`
            - Enum `domain::notifications::NotificationUrgency { Low, Normal, Critical }`
            - Ausgabe von `post_notification`: `notification_id: core::types::Uuid`
            - Ausgabe von `get_notification`, `list_notifications`: `domain::notifications::Notification { id: core::types::Uuid, data: domain::notifications::NotificationData, timestamp: core::types::DateTime<Utc>, is_read: bool, is_dismissed: bool }`
        - **Von der UI aufgerufene API-Methoden (aus `domain::NotificationService`-Trait):**
            - `fn post_notification(&self, notification_data: domain::notifications::NotificationData) -> Result<core::types::Uuid, domain::NotificationError>;`
            - `fn get_notification(&self, id: core::types::Uuid) -> Result<Option<domain::notifications::Notification>, domain::NotificationError>;`
            - `fn list_notifications(&self, filter: Option<domain::notifications::NotificationFilter>) -> Result<Vec<domain::notifications::Notification>, domain::NotificationError>;` // Filter könnte `unread_only`, `app_name` etc. sein
            - `fn mark_as_read(&self, id: core::types::Uuid) -> Result<(), domain::NotificationError>;`
            - `fn dismiss_notification(&self, id: core::types::Uuid) -> Result<(), domain::NotificationError>;`
            - `fn invoke_action_on_notification(&self, notification_id: core::types::Uuid, action_id: String) -> Result<(), domain::NotificationError>;`
            - `fn set_do_not_disturb(&self, enabled: bool) -> Result<(), domain::NotificationError>;`
            - `fn get_do_not_disturb_status(&self) -> Result<bool, domain::NotificationError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `domain::notifications::NotificationPostedEvent { notification: domain::notifications::Notification }`
            - `domain::notifications::NotificationDismissedEvent { notification_id: core::types::Uuid, reason: domain::notifications::DismissReason }`
            - `domain::notifications::NotificationActionInvokedEvent { notification_id: core::types::Uuid, action_id: String }`
            - `domain::notifications::DoNotDisturbChangedEvent { is_enabled: bool }`
            - Enum `domain::notifications::DismissReason { User, Timeout, Programmatic }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `domain::NotificationError`-Varianten (z.B. `NotificationNotFound`, `ActionNotFound`) auf Benutzerfeedback.
    - **1.2.5. `GlobalSettingsService`-API-Nutzung durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, globale Anwendungseinstellungen zu lesen, zu ändern und auf Standardwerte zurückzusetzen.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `update_setting`: `key: String`, `value: glib::Variant`
            - Ausgabe von `get_setting`: `Result<Option<glib::Variant>, domain::GlobalSettingsError>`
            - Ausgabe von `get_current_settings`: `Result<HashMap<String, glib::Variant>, domain::GlobalSettingsError>`
            - Struct `domain::settings::SettingDescriptor { key: String, display_name: String, description: Option<String>, value_type: glib::VariantType, current_value: glib::Variant, default_value: glib::Variant, possible_values: Option<Vec<glib::Variant>>, range: Option<(glib::Variant, glib::Variant)>, category: String }`
        - **Von der UI aufgerufene API-Methoden (aus `domain::GlobalSettingsService`-Trait):**
            - `fn load_settings(&self) -> Result<(), domain::GlobalSettingsError>;`
            - `fn save_settings(&self) -> Result<(), domain::GlobalSettingsError>;`
            - `fn get_current_settings(&self) -> Result<HashMap<String, glib::Variant>, domain::GlobalSettingsError>;`
            - `fn get_setting_descriptors(&self) -> Result<Vec<domain::settings::SettingDescriptor>, domain::GlobalSettingsError>;`
            - `fn update_setting(&self, key: String, value: glib::Variant) -> Result<(), domain::GlobalSettingsError>;`
            - `fn get_setting(&self, key: String) -> Result<Option<glib::Variant>, domain::GlobalSettingsError>;`
            - `fn reset_setting_to_default(&self, key: String) -> Result<(), domain::GlobalSettingsError>;`
            - `fn reset_all_settings_to_defaults(&self) -> Result<(), domain::GlobalSettingsError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `domain::settings::SettingChangedEvent { key: String, new_value: glib::Variant, old_value: glib::Variant }`
            - `domain::settings::SettingsLoadedEvent { settings: HashMap<String, glib::Variant> }`
            - `domain::settings::SettingsSavedEvent {}`
        - **Fehlerbehandlung durch die UI:** Abbildung von `domain::GlobalSettingsError`-Varianten (z.B. `SettingNotFound`, `InvalidValueType`, `PersistenceError`) auf Benutzerfeedback. Die Verwendung von `glib::Variant` für Einstellwerte 12 ermöglicht eine flexible Handhabung verschiedener Datentypen für Einstellungen.
    - **Schlüsseltabellen für Teil 1.2:**
        
        Für jede Methode der Domänendienst-API:
        
        1. **Methodensignatur-Tabelle:**

|   |   |   |   |
|---|---|---|---|
|**Methode**|**Parameter**|**Rückgabetyp**|**Kurzbeschreibung**|
|`ThemingEngine::get_current_theme_state`|`&self`|`Result<domain::theming::AppliedThemeState, domain::ThemingError>`|Ruft den aktuell angewendeten Theme-Zustand ab.|
|`WorkspaceManager::create_workspace`|`&self, params: domain::workspaces::CreateWorkspaceParams`|`Result<core::types::WorkspaceId, domain::WorkspaceManagerError>`|Erstellt einen neuen Arbeitsbereich.|
|...|...|...|...|

```
    2.  **Parameterdetail-Tabelle (Beispiel für `ThemingEngine::update_configuration`):**
```

|   |   |   |   |
|---|---|---|---|
|**Parametername**|**Typ**|**Erforderlich**|**Beschreibung**|
|`config_update`|`domain::theming::ThemeConfigurationUpdate`|Ja|Ein Objekt, das die gewünschten Änderungen an der Theme-Konfiguration enthält.|

```
    3.  **Rückgabewertdetail-Tabelle (Beispiel für `ThemingEngine::get_current_theme_state`):**
```

|   |   |   |
|---|---|---|
|**Erfolgsfall (Ok)**|**Fehlerfall (Err)**|**Beschreibung**|
|`domain::theming::AppliedThemeState`|`domain::ThemingError`|Enthält Details zum aktuell angewendeten Theme oder einen Fehler bei der Abfrage.|

```
    Für jedes von der UI konsumierte Domänenereignis:
    4.  **Ereignis-Payload-Detail-Tabelle (Beispiel für `ThemeChangedEvent`):**
```

|   |   |   |
|---|---|---|
|**Feldname**|**Typ**|**Beschreibung**|
|`new_state`|`domain::theming::AppliedThemeState`|Der neue Zustand des Themes nach der Änderung.|

```
    Diese Tabellen sind unerlässlich, um Entwicklern eine eindeutige und leicht zugängliche Referenz zu bieten. Sie erzwingen Konsistenz bei der Typverwendung und Methodenaufrufen und reduzieren so Integrationsfehler zwischen der UI- und der Domänenschicht erheblich. Beispielsweise beschreibt eine detaillierte Tabelle für `WorkspaceDescriptor` klar alle Informationen, die die UI über einen Arbeitsbereich erwarten kann, was die Entwicklung von UI-Komponenten wie Arbeitsbereichswechslern erleichtert.
```

- 1.3. Schnittstelle der UI-Schicht mit der Systemschicht
    
    Dieser Abschnitt definiert ultra-granular die Interaktionen der UI-Schicht mit Diensten, die von der Systemschicht bereitgestellt werden. Die Systemschicht abstrahiert Details des zugrundeliegenden Betriebssystems, der Hardware und des Fenstersystems (Wayland/X11).
    
    - **1.3.1. Compositor-Interaktion (`system::compositor_iface`) durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, Fensterinformationen abzufragen, Fensterzustände (Fokus, Geometrie) zu verwalten und Aktualisierungen über den Lebenszyklus und die Eigenschaften von Fenstern zu erhalten. Diese Schnittstelle abstrahiert die zugrundeliegenden Wayland-Compositor-Interaktionen. Die UI interagiert nicht direkt mit Wayland-Protokollen wie `wlr-foreign-toplevel-management` 17 oder `ext-foreign-toplevel-list-v1` 17; stattdessen konsumiert sie die von der Systemschicht bereitgestellten Abstraktionen.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `request_focus`: `window_id: core::types::WindowId`
            - Eingabe für `configure_window`: `window_id: core::types::WindowId`, `config: system::compositor::WindowConfigurationRequest { new_position: Option<core::types::PointInt>, new_size: Option<core::types::SizeInt>, new_state: Option<system::compositor::CompositorWindowState>, new_workspace_id: Option<core::types::WorkspaceId> }`
            - Enum `system::compositor::CompositorWindowState { Maximized, Minimized, Fullscreen, Normal, TiledLeft, TiledRight }`
            - Ausgabe von `get_window_info`, `list_managed_windows`: `system::compositor::WindowInfo { id: core::types::WindowId, title: String, app_id: core::types::AppId, class: Option<String>, geometry: core::types::RectInt, is_focused: bool, is_maximized: bool, is_minimized: bool, is_fullscreen: bool, workspace_id: Option<core::types::WorkspaceId>, can_resize: bool, can_maximize: bool, can_minimize: bool, can_close: bool, parent_window_id: Option<core::types::WindowId>, transient_for: Option<core::types::WindowId> }`
            - Ausgabe von `get_output_info`, `list_outputs`: `system::compositor::OutputInfo { id: String, name: String, description: String, geometry: core::types::RectInt, scale_factor: f32, refresh_rate_mhz: u32, current_resolution: core::types::SizeInt, available_resolutions: Vec<core::types::SizeInt>, is_primary: bool, is_enabled: bool }`
        - **Von der UI aufgerufene API-Methoden (aus `system::CompositorInterface`-Trait):**
            - `fn request_focus(&self, window_id: core::types::WindowId) -> Result<(), system::CompositorError>;`
            - `fn configure_window(&self, window_id: core::types::WindowId, config: system::compositor::WindowConfigurationRequest) -> Result<(), system::CompositorError>;`
            - `fn get_window_info(&self, window_id: core::types::WindowId) -> Result<Option<system::compositor::WindowInfo>, system::CompositorError>;`
            - `fn list_managed_windows(&self) -> Result<Vec<system::compositor::WindowInfo>, system::CompositorError>;`
            - `fn close_window(&self, window_id: core::types::WindowId) -> Result<(), system::CompositorError>;`
            - `fn list_outputs(&self) -> Result<Vec<system::compositor::OutputInfo>, system::CompositorError>;`
            - `fn get_output_info(&self, output_id: String) -> Result<Option<system::compositor::OutputInfo>, system::CompositorError>;`
            - `fn get_cursor_position(&self) -> Result<core::types::PointInt, system::CompositorError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `system::compositor::WindowCreatedEvent { info: system::compositor::WindowInfo }`
            - `system::compositor::WindowClosedEvent { window_id: core::types::WindowId }`
            - `system::compositor::WindowFocusedEvent { window_id: core::types::WindowId }`
            - `system::compositor::WindowUnfocusedEvent { window_id: core::types::WindowId }`
            - `system::compositor::WindowPropertiesChangedEvent { window_id: core::types::WindowId, changed_title: Option<String>, changed_app_id: Option<core::types::AppId>, changed_geometry: Option<core::types::RectInt>, changed_state: Option<system::compositor::CompositorWindowState> }`
            - `system::compositor::OutputAddedEvent { info: system::compositor::OutputInfo }`
            - `system::compositor::OutputRemovedEvent { output_id: String }`
            - `system::compositor::OutputConfigurationChangedEvent { info: system::compositor::OutputInfo }`
            - `system::compositor::CursorPositionChangedEvent { position: core::types::PointInt }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::CompositorError`-Varianten (z.B. `WindowNotFound`, `WaylandProtocolError`, `InvalidConfiguration`) auf Benutzerfeedback.
    - **1.3.2. Eingabeverarbeitung (`system::input_iface`) durch die UI:**
        
        - **Zweck:** Liefert der UI verarbeitete Eingabeereignisse (Tastatur, Maus, Touch, Gesten) und ermöglicht es der UI, den Fokus zu steuern.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `request_keyboard_focus`: `window_id: core::types::WindowId` (kann auch über `compositor_iface` laufen, hier zur Verdeutlichung der Input-Intention)
            - Event-Payloads für `KeyboardEvent`, `PointerEvent`, `TouchEvent`, `GestureEvent` (detaillierte Definitionen erforderlich, z.B. `KeyEvent { key_code: u32, modifiers: KeyModifiers, state: KeyState, utf8: Option<String> }`).
        - **Von der UI aufgerufene API-Methoden (aus `system::InputInterface`-Trait):**
            - `fn request_keyboard_focus(&self, window_id: core::types::WindowId) -> Result<(), system::InputError>;` (kann Duplikat zu Compositor-API sein, aber semantisch hier relevant)
            - `fn set_cursor_theme(&self, theme_name: String, size: u32) -> Result<(), system::InputError>;`
            - `fn get_current_keyboard_layout(&self) -> Result<String, system::InputError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `system::input::KeyboardEvent { window_id: Option<core::types::WindowId>, /*... event details... */ }`
            - `system::input::PointerButtonEvent { window_id: Option<core::types::WindowId>, /*... event details... */ }`
            - `system::input::PointerMotionEvent { window_id: Option<core::types::WindowId>, /*... event details... */ }`
            - `system::input::PointerAxisEvent { window_id: Option<core::types::WindowId>, /*... event details... */ }`
            - `system::input::TouchEvent { window_id: Option<core::types::WindowId>, /*... event details... */ }`
            - `system::input::GestureEvent { window_id: Option<core::types::WindowId>, gesture_type: system::input::GestureType, /*... event details... */ }`
            - `system::input::FocusChangedEvent { new_focus_window_id: Option<core::types::WindowId>, old_focus_window_id: Option<core::types::WindowId> }` (kann auch vom Compositor kommen)
            - `system::input::KeyboardLayoutChangedEvent { new_layout_name: String }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::InputError`-Varianten.
    - **1.3.3. D-Bus Client-Schnittstellen (`system::dbus::*`) Nutzung durch die UI:**
        
        - **Allgemein:** Die UI interagiert mit D-Bus-Diensten über typsichere Rust-Wrapper, die von der Systemschicht bereitgestellt werden. Die UI konsumiert Ereignisse und ruft Methoden dieser Wrapper auf. Die Komplexität der D-Bus-Kommunikation (z.B. mit `zbus` 19 oder `gio::DBusConnection` 22) wird von der Systemschicht gekapselt.
        - **`system::dbus::upower_client_iface`:**
            - Events: `system::dbus::UPowerDeviceChangedEvent { device_id: String, percentage: f64, state: UPowerDeviceState, time_to_empty_s: Option<u64>, time_to_full_s: Option<u64> }`
        - **`system::dbus::logind_client_iface`:**
            - Methoden: `fn lock_session(&self) -> Result<(), system::DBusError>;`
            - Events: `system::dbus::LogindSessionEvent { event_type: LogindEventType /* Lock, Unlock, Sleep, Wakeup */ }`
        - **`system::dbus::networkmanager_client_iface`:**
            - Methoden: `fn list_access_points(&self, device_path: String) -> Result<Vec<system::dbus::AccessPointInfo>, system::DBusError>;`, `fn connect_to_access_point(&self, device_path: String, ap_bssid: String, password: Option<String>) -> Result<(), system::DBusError>;`
            - Datenstrukturen: `AccessPointInfo { bssid: String, ssid: String, strength: u8, security_flags: u32, is_active: bool }` (basierend auf NetworkManager D-Bus API 23)
            - Events: `system::dbus::NetworkStateChangedEvent { connectivity: NetworkConnectivityState, primary_connection_type: Option<String> }`, `system::dbus::AccessPointsChangedEvent { device_path: String }`
        - **`system::dbus::secrets_client_iface`:**
            - Methoden: `async fn prompt_for_secret(&self, prompt_message: String) -> Result<Option<String>, system::DBusError>;` (interagiert mit UI für Prompts)
    - **1.3.4. Output-Management (`system::outputs_iface`) durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, Informationen über angeschlossene Displays abzurufen und deren Konfiguration (Auflösung, Skalierung, Position) zu ändern.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `configure_output`: `output_id: String`, `config: system::outputs::OutputConfigurationRequest { resolution: Option<core::types::SizeInt>, scale: Option<f32>, position: Option<core::types::PointInt>, enabled: Option<bool>, refresh_rate_mhz: Option<u32> }`
            - Ausgabe von `list_outputs`, `get_output_details`: `system::outputs::OutputDetails` (ähnlich `system::compositor::OutputInfo`, aber ggf. mit mehr Konfigurationsdetails wie verfügbare Modi, aktuelle Skalierung, etc.)
        - **Von der UI aufgerufene API-Methoden (aus `system::OutputInterface`-Trait):**
            - `fn list_outputs(&self) -> Result<Vec<system::outputs::OutputDetails>, system::OutputError>;`
            - `fn get_output_details(&self, output_id: String) -> Result<Option<system::outputs::OutputDetails>, system::OutputError>;`
            - `fn configure_output(&self, output_id: String, config: system::outputs::OutputConfigurationRequest) -> Result<(), system::OutputError>;`
            - `fn set_primary_output(&self, output_id: String) -> Result<(), system::OutputError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `system::outputs::OutputConfigurationChangedEvent { output_id: String, new_details: system::outputs::OutputDetails }` (kann auch vom Compositor kommen, hier ggf. spezifischer für Output-Management-Aktionen)
            - `system::outputs::OutputConnectedEvent { details: system::outputs::OutputDetails }`
            - `system::outputs::OutputDisconnectedEvent { output_id: String }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::OutputError`-Varianten.
    - **1.3.5. Audio-Management (`system::audio_iface`) durch die UI:**
        
        - **Zweck:** Ermöglicht der UI, Audio-Geräte und -Streams zu verwalten, Lautstärken zu regeln und Audio-Ereignisse zu empfangen. Abstrahiert PipeWire-Interaktionen.26
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `set_volume`: `device_id: String`, `stream_id: Option<String>`, `volume_percent: f32`, `is_muted: Option<bool>`
            - Ausgabe von `list_audio_devices`, `get_audio_device_details`: `system::audio::AudioDeviceDetails { id: String, name: String, device_type: AudioDeviceType /* Input, Output */, current_volume_percent: f32, is_muted: bool, available_ports: Vec<String>, active_port: Option<String> }`
            - Ausgabe von `list_audio_streams`: `system::audio::AudioStreamDetails { id: String, application_name: String, media_role: String, current_volume_percent: f32, is_muted: bool }`
        - **Von der UI aufgerufene API-Methoden (aus `system::AudioInterface`-Trait):**
            - `fn list_audio_devices(&self, device_type_filter: Option<system::audio::AudioDeviceType>) -> Result<Vec<system::audio::AudioDeviceDetails>, system::AudioError>;`
            - `fn get_audio_device_details(&self, device_id: String) -> Result<Option<system::audio::AudioDeviceDetails>, system::AudioError>;`
            - `fn set_device_volume(&self, device_id: String, volume_percent: f32) -> Result<(), system::AudioError>;`
            - `fn set_device_mute(&self, device_id: String, muted: bool) -> Result<(), system::AudioError>;`
            - `fn set_default_output_device(&self, device_id: String) -> Result<(), system::AudioError>;`
            - `fn set_default_input_device(&self, device_id: String) -> Result<(), system::AudioError>;`
            - `fn list_audio_streams(&self) -> Result<Vec<system::audio::AudioStreamDetails>, system::AudioError>;`
            - `fn set_stream_volume(&self, stream_id: String, volume_percent: f32) -> Result<(), system::AudioError>;`
            - `fn set_stream_mute(&self, stream_id: String, muted: bool) -> Result<(), system::AudioError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `system::audio::AudioDeviceChangedEvent { device_details: system::audio::AudioDeviceDetails }`
            - `system::audio::AudioDeviceAddedEvent { device_details: system::audio::AudioDeviceDetails }`
            - `system::audio::AudioDeviceRemovedEvent { device_id: String }`
            - `system::audio::AudioStreamAddedEvent { stream_details: system::audio::AudioStreamDetails }`
            - `system::audio::AudioStreamRemovedEvent { stream_id: String }`
            - `system::audio::AudioStreamVolumeChangedEvent { stream_id: String, new_volume_percent: f32, is_muted: bool }`
            - `system::audio::DefaultDeviceChangedEvent { device_type: system::audio::AudioDeviceType, new_default_device_id: String }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::AudioError`-Varianten.
    - **1.3.6. MCP-Client (`system::mcp_client_iface`) Nutzung durch die UI:**
        
        - **Zweck:** Stellt der UI KI-Funktionen zur Verfügung, z.B. für die Befehlspalette oder andere intelligente UI-Elemente.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `request_ai_completion`: `prompt: String`, `context_data: HashMap<String, glib::Variant>`, `max_tokens: Option<u32>`
            - Ausgabe von `request_ai_completion`: `system::mcp::AICompletionResponse { completion_id: core::types::Uuid, text_result: Option<String>, structured_result: Option<glib::Variant>, error_message: Option<String> }`
        - **Von der UI aufgerufene API-Methoden (aus `system::MCPClientInterface`-Trait):**
            - `async fn request_ai_completion(&self, prompt: String, context_data: HashMap<String, glib::Variant>, options: system::mcp::AICompletionOptions) -> Result<system::mcp::AICompletionResponse, system::MCPError>;`
            - `async fn get_ai_capabilities(&self) -> Result<Vec<system::mcp::AICapabilityDescriptor>, system::MCPError>;`
        - **Von der UI konsumierte Event-Payloads:**
            - `system::mcp::AIModelStatusChangedEvent { model_id: String, is_available: bool }`
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::MCPError`-Varianten.
    - **1.3.7. XDG Desktop Portals (`system::portals_iface`) Nutzung durch die UI:**
        
        - **Zweck:** Ermöglicht der UI die Interaktion mit XDG Desktop Portals für Aktionen wie Dateiauswahl, Screenshots, etc., auf eine sandkastenfreundliche Weise. Die Systemschicht abstrahiert die direkte D-Bus-Kommunikation mit den Portal-Diensten. Die `ashpd`-Bibliothek 28 ist ein gutes Beispiel für eine solche Abstraktionsebene, die die Systemschicht intern nutzen könnte.
        - **Ausgetauschte Datenstrukturen (Typen):**
            - Eingabe für `open_file_dialog`: `parent_window_identifier: system::portals::WindowIdentifier`, `title: String`, `options: system::portals::OpenFileOptions { multiple: bool, directory: bool, filters: Vec<system::portals::FileFilter> }`
            - Struct `system::portals::FileFilter { name: String, patterns: Vec<String> /* z.B. "*.txt" */ }`
            - Ausgabe von `open_file_dialog`: `Vec<PathBuf>` (URIs werden von der Systemschicht in Pfade konvertiert)
            - Eingabe für `save_file_dialog`: `parent_window_identifier: system::portals::WindowIdentifier`, `title: String`, `options: system::portals::SaveFileOptions { current_name: Option<String>, current_folder: Option<PathBuf>, filters: Vec<system::portals::FileFilter> }`
            - Ausgabe von `save_file_dialog`: `Option<PathBuf>`
            - Typ `system::portals::WindowIdentifier`: Ein plattformagnostischer Handle für ein Fenster, der intern zu Wayland- oder X11-spezifischen Handles aufgelöst wird, wie von `ashpd` benötigt.
        - **Von der UI aufgerufene API-Methoden (aus `system::PortalsInterface`-Trait):**
            - `async fn open_file_dialog(&self, parent_window_identifier: system::portals::WindowIdentifier, title: String, options: system::portals::OpenFileOptions) -> Result<Vec<PathBuf>, system::PortalError>;`
            - `async fn save_file_dialog(&self, parent_window_identifier: system::portals::WindowIdentifier, title: String, options: system::portals::SaveFileOptions) -> Result<Option<PathBuf>, system::PortalError>;`
            - `async fn take_screenshot(&self, parent_window_identifier: system::portals::WindowIdentifier, interactive: bool, include_cursor: bool) -> Result<Option<PathBuf>, system::PortalError>;`
            - `async fn pick_color(&self, parent_window_identifier: system::portals::WindowIdentifier) -> Result<Option<core::types::Color>, system::PortalError>;`
        - **Von der UI konsumierte Event-Payloads:** (Portals sind typischerweise Request-Response, weniger eventbasiert für die UI direkt, außer Status-Events des Portal-Dienstes selbst, die hier aber nicht im Fokus stehen).
        - **Fehlerbehandlung durch die UI:** Abbildung von `system::PortalError`-Varianten (z.B. `UserCancelled`, `PortalNotAvailable`, `BackendError`).
    - **Schlüsseltabellen für Teil 1.3:** Ähnlich wie in Teil 1.2 werden Tabellen für Methodensignaturen, Parameterdetails, Rückgabewertdetails und Ereignis-Payload-Details für jede definierte Systemschicht-Schnittstelle erstellt.
        
        - Die Interaktionen der Systemschicht sind oft komplex und beinhalten viele Low-Level-Details (z.B. D-Bus-Varianten, Wayland-Protokollspezifika). Tabellen machen die abstrahierte Rust-API klar und reduzieren die Mehrdeutigkeit für UI-Entwickler.

---

**Teil 2: Ultra-Granulare Schnittstellendefinition der Kernschicht (Erweiterung des Benutzerdokuments)**

- 2.1. Kernschicht zu allen höheren Schichten
    
    Die Kernschicht (core) stellt fundamentale Bausteine und Dienste bereit, die von allen höheren Schichten (Domäne, System, UI) genutzt werden. Ihre Schnittstellen müssen daher besonders stabil und klar definiert sein.
    
    - **`core::types`:**
        
        - **Datentypen:** Stellt eine Sammlung grundlegender, wiederverwendbarer Datentypen bereit.
            - `Point<T> { x: T, y: T }` (generisch für numerische Typen wie `f32`, `i32`)
            - `Size<T> { width: T, height: T }` (generisch)
            - `Rect<T> { origin: Point<T>, size: Size<T> }` (generisch)
            - `RectInt` ist ein Typalias für `Rect<i32>`.
            - `Color { r: u8, g: u8, b: u8, a: u8 }` (RGBA-Format)
            - `Orientation { Horizontal, Vertical }` (Enum)
            - `Uuid` (Wrapper um die `uuid::Uuid`-Bibliothek, um eine konsistente Verwendung sicherzustellen)
            - `DateTime<Utc>` (Wrapper um `chrono::DateTime<chrono::Utc>`, um Zeitzonenprobleme zu standardisieren)
            - `WindowId` (Typalias, z.B. `pub type WindowId = u64;` oder eine spezifischere Struktur, falls Metadaten benötigt werden)
            - `WorkspaceId` (Typalias, z.B. `pub type WorkspaceId = core::types::Uuid;`)
            - `AppId` (Typalias, z.B. `pub type AppId = String;`, oft im Reverse-DNS-Format wie `org.novade.FileExplorer`)
        - **Nutzung:** Diese Typen werden direkt in den öffentlichen APIs und internen Logiken der höheren Schichten für Geometrieberechnungen, Farbangaben, eindeutige Identifikatoren, Zeitstempel und spezifische Entitäts-IDs verwendet. Die Standardisierung dieser Typen in der Kernschicht verhindert Inkonsistenzen und erleichtert die Interoperabilität zwischen den Modulen.
    - **`core::errors`:**
        
        - **Basis-Fehlertyp:**
            
            Rust
            
            ```
            #
            pub enum CoreError {
                #[error("I/O error: {source}")]
                Io { #[from] source: std::io::Error },
                #[error("Configuration parsing error: {0}")]
                ConfigParseError(String),
                #[error("Invalid state: {0}")]
                InvalidState(String),
                #[error("Functionality not implemented")]
                NotImplemented,
                #[error("Custom error: {0}")]
                Custom(String),
                #
                SerializationJson { #[from] source: serde_json::Error },
                // Weitere generische Fehlerkategorien hier hinzufügen
            }
            ```
            
        - **Modul-spezifische Fehlerstrategie:** Höhere Schichten und Module innerhalb der Kernschicht definieren ihre eigenen spezifischen Fehler-Enums mit `thiserror`. Diese spezifischen Fehler sollten `CoreError` oder andere relevante Fehler wrappen, um die Fehlerkette zu erhalten.
            - Beispiel: `core::config::ConfigError` könnte eine Variante haben wie:
                
                Rust
                
                ```
                #
                pub enum ConfigError {
                    #[error("Failed to open configuration file '{path}': {source}")]
                    FileOpenFailed { path: PathBuf, #[source] source: CoreError },
                    #[error("Failed to parse configuration: {message}")]
                    ParseFailed { message: String, #[source] source: Option<serde_json::Error> },
                    //...
                }
                ```
                
        - **Fehler-Wrapping-Illustration:**
            
            Rust
            
            ```
            // In einem hypothetischen Modul
            #
            pub enum MyModuleError {
                #[error("Failed to read file for stuff: {source}")]
                FileReadFailed(#[source] CoreError),
                //...
            }
            
            fn read_file_content(path: &PathBuf) -> Result<String, CoreError> {
                std::fs::read_to_string(path).map_err(CoreError::from)
            }
            
            fn load_stuff(file_path: &PathBuf) -> Result<(), MyModuleError> {
                let _content = read_file_content(file_path).map_err(MyModuleError::FileReadFailed)?;
                //... weitere Logik...
                Ok(())
            }
            ```
            
            Diese Strategie stellt sicher, dass der ursprüngliche Kontext des Fehlers (`source()`) verfügbar bleibt, was die Fehlersuche und -behebung erheblich erleichtert.
    - **`core::logging`:**
        
        - **Initialisierungsroutine:**
            
            Rust
            
            ```
            pub enum LogOutput {
                Stdout,
                Stderr,
                File(PathBuf),
            }
            
            pub fn initialize_logging(level: tracing::Level, output: LogOutput, format: LogFormat) -> Result<(), CoreError>;
            pub enum LogFormat { Json, Pretty, Compact }
            ```
            
            Diese Funktion konfiguriert das globale Logging-System (basierend auf `tracing`).
        - **Konvention für `tracing`-Makros:**
            - Alle Schichten verwenden die Standard-`tracing`-Makros (`trace!`, `debug!`, `info!`, `warn!`, `error!`).
            - Strukturierte Log-Nachrichten werden bevorzugt, um kontextbezogene Daten effizient zu erfassen: `trace!(target: "core::module_name", "Processing item {}", item_id, item_type = %item.kind, user_id = %current_user.id);`
            - Das `target`-Feld sollte das Modul oder die Komponente angeben, aus der die Log-Nachricht stammt (z.B. `core::config`, `domain::theming`).
            - Spezifische Felder (z.B., `window.id = %window_id`, `event.name = "ThemeChanged"`) sollten verwendet werden, um das Filtern und Analysieren von Logs zu erleichtern.
    - **`core::config`:**
        
        - **`CoreConfig`-Struktur:** Definiert die globalen Kernkonfigurationen. Diese Struktur wird beim Start der Anwendung geladen und als unveränderlich betrachtet.
            
            Rust
            
            ```
            #
            pub struct LoggingConfig {
                pub level: String, // z.B. "info", "debug"
                pub output: String, // z.B. "stdout", "/var/log/novade.log"
                pub format: String, // z.B. "json", "pretty"
            }
            
            #
            pub struct ThemeConfig {
                pub default_theme_name: String,
                pub default_variant: String,
                pub icon_theme: String,
            }
            
            #
            pub struct AIServiceConfig {
                pub service_url: Option<String>,
                pub default_model_id: Option<String>,
                pub consent_required_by_default: bool,
            }
            
            #
            pub struct CoreConfig {
                pub logging: LoggingConfig,
                pub theming: ThemeConfig,
                pub ai: AIServiceConfig,
                pub default_workspace_layout: String, // z.B. "Tiling", "Floating"
                // Weitere Kernkonfigurationen
            }
            ```
            
        - **Konfigurations-API:**
            - `pub fn load_core_config(path: &PathBuf) -> Result<CoreConfig, ConfigError>;` Lädt die Konfiguration aus einer Datei (z.B. TOML oder JSON).
            - `pub fn get_core_config() -> Result<&'static CoreConfig, CoreError>;` Bietet globalen, schreibgeschützten Zugriff auf die geladene Kernkonfiguration. Dies setzt voraus, dass die Konfiguration nach der Initialisierung in einem globalen statischen Speicher (z.B. `once_cell::sync::OnceCell` oder `std::sync::OnceLock`) gehalten wird.
        - **`ConfigError`-Enum:**
            
            Rust
            
            ```
            #
            pub enum ConfigError {
                #[error("Configuration file not found at path: {0}")]
                FileNotFound(PathBuf),
                #[error("Failed to open configuration file '{path}': {source}")]
                FileOpenFailed { path: PathBuf, #[source] source: CoreError },
                #[error("Failed to read configuration file '{path}': {source}")]
                FileReadFailed { path: PathBuf, #[source] source: CoreError },
                #[error("Failed to parse configuration from '{path}': {message}")]
                ParseFailed { path: PathBuf, message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync>> }, // Box für Flexibilität bei Parser-Fehlern
                #[error("Configuration validation failed: {0}")]
                ValidationError(String),
            }
            ```
            
            (Hinweis: `Box<dyn std::error::Error + Send + Sync>` für `source` in `ParseFailed` ermöglicht das Wrappen verschiedener Parser-Fehler, z.B. `serde_json::Error`, `toml::de::Error`).
    - **`core::utils`:**
        
        - **Hilfsfunktionen:** Stellt allgemeine, zustandslose Hilfsfunktionen bereit, die von mehreren Schichten genutzt werden können. Diese sollten in thematisch gruppierten Untermodulen organisiert sein.
            - `core::utils::string_utils`: Funktionen zur String-Manipulation (z.B. `truncate_with_ellipsis(text: &str, max_len: usize) -> String;`).
            - `core::utils::geometry_utils`: Einfache geometrische Berechnungen, die nicht in `core::types` selbst implementiert sind (z.B. `fn calculate_rect_area(rect: &core::types::RectInt) -> i32;`).
            - `core::utils::time_utils`: Formatierungs- oder Vergleichsfunktionen für `DateTime<Utc>` (z.B. `fn format_datetime_human_readable(dt: &core::types::DateTime<Utc>) -> String;` unter Verwendung von `chrono::format::strftime`).
            - `core::utils::uuid_utils`: Funktionen zur Erzeugung oder Validierung von UUIDs (z.B. `fn generate_v4_uuid() -> core::types::Uuid;`).
        - **Nutzung:** Direkte Verwendung durch alle höheren Schichten nach Bedarf. Da diese Funktionen zustandslos sind, führen sie keine Seiteneffekte ein und sind einfach zu testen. Die Signaturen dieser Hilfsfunktionen sind Teil der internen API der Kernschicht und sollten bei Stabilitätserwägungen berücksichtigt werden.
    - **Schlüsseltabellen für Teil 2.1:**
        
        1. **`core::types` Detail-Tabelle:**

|   |   |   |   |
|---|---|---|---|
|**Typname**|**Struktur / Enum-Definition**|**Generische Parameter**|**Beschreibung**|
|`Point<T>`|`struct Point<T> { x: T, y: T }`|`T: Copy + Num`|Repräsentiert einen Punkt im 2D-Raum.|
|`Color`|`struct Color { r: u8, g: u8, b: u8, a: u8 }`|-|Repräsentiert eine RGBA-Farbe.|
|`Uuid`|`struct Uuid(uuid::Uuid);`|-|Wrapper für einen universell eindeutigen Identifikator.|
|`DateTime<Utc>`|`struct DateTime<Utc>(chrono::DateTime<chrono::Utc>);`|-|Repräsentiert einen Zeitpunkt in UTC.|
|...|...|...|...|

```
    2.  **`CoreError` Varianten-Tabelle:**
```

|   |   |   |
|---|---|---|
|**Variante**|**Assoziierte Daten (#[from], #[source], Felder)**|**#[error("...")] Format-String**|
|`Io`|`#[from] source: std::io::Error`|`"I/O error: {source}"`|
|`ConfigParseError`|`String` (Meldung)|`"Configuration parsing error: {0}"`|
|`SerializationJson`|`#[from] source: serde_json::Error`|`"Serialization error (serde_json): {source}"`|
|...|...|...|

```
    3.  **`CoreConfig` Felder-Tabelle:**
```

|   |   |   |   |
|---|---|---|---|
|**Feldname**|**Typ**|**Beschreibung**|**Standardwert (falls zutreffend)**|
|`logging`|`LoggingConfig`|Konfiguration für das Logging-System.|Siehe `LoggingConfig`|
|`theming`|`ThemeConfig`|Standard-Theme-Einstellungen.|Siehe `ThemeConfig`|
|`default_workspace_layout`|`String`|Standard-Layout für neue Arbeitsbereiche (z.B. "Tiling").|`"Floating"`|
|...|...|...|...|

```
    Diese Tabellen bieten eine klare, strukturierte Übersicht über die von der Kernschicht bereitgestellten fundamentalen Elemente und sind für Entwickler aller höheren Schichten von entscheidender Bedeutung.
```

---

**Teil 3: Ultra-Granulare Schnittstellendefinition der Domänenschicht (Erweiterung des Benutzerdokuments)**

Die Domänenschicht enthält die Kernlogik und den Zustand der Anwendung. Ihre Schnittstellen definieren, wie höhere Schichten (System und UI) diese Logik nutzen und auf Zustandsänderungen reagieren können.

- **3.1. Domänenschicht zu System- & UI-Schichten (Allgemeine Prinzipien)**
    
    - **Logik und Zustand:** Jede Domänen-Service-Komponente kapselt einen spezifischen Aspekt der Geschäftslogik und des zugehörigen Zustands. Diese werden über öffentliche Methoden der Service-Traits und durch das Aussenden von domänenspezifischen Ereignissen bereitgestellt.
        - Für jeden Domänendienst wird explizit der von ihm verwaltete Zustand (z.B. für `ThemingEngine`: aktuelles Theme, verfügbare Themes, benutzerdefinierte Farbpaletten) und die wichtigsten Geschäftsregeln, die er durchsetzt (z.B. für `WorkspaceManager`: keine zwei Arbeitsbereiche mit demselben Namen, ein Fenster kann nur einem Arbeitsbereich zugewiesen sein), dokumentiert.
    - **Fehlertypen:** Jedes Modul innerhalb der Domänenschicht definiert seine eigenen, auf `thiserror` basierenden Fehler-Enums. Diese Fehler sind spezifisch für die jeweilige Domänenlogik und bieten detaillierte Informationen über aufgetretene Probleme.
        - Beispiel für `ThemingError`:
            
            Rust
            
            ```
            #
            pub enum ThemingError {
                #
                ThemeNotFound { name: String, path: Option<PathBuf> },
                #
                VariantNotFound { theme_name: String, variant_name: String },
                #[error("Failed to load theme assets for '{theme_name}': {source}")]
                AssetLoadError { theme_name: String, #[source] source: core::errors::CoreError },
                #[error("Invalid theme configuration: {message}")]
                InvalidConfiguration { message: String },
                #
                TokenNotFound { theme_name: String, token_name: String },
                #[error("Failed to parse color value '{value}' for token '{token_name}'")]
                ColorParseError { token_name: String, value: String },
            }
            ```
            
            (Diese detaillierte Definition wird für alle im Benutzerdokument genannten Fehler wie `WorkspaceCoreError`, `WindowAssignmentError`, etc. wiederholt.)
    - **Events:** Domänenspezifische Ereignisse werden ausgelöst, um andere Schichten über signifikante Zustandsänderungen oder abgeschlossene Aktionen zu informieren. Die Payload jedes Ereignisses ist so gestaltet, dass sie alle relevanten Informationen enthält, die ein Konsument benötigt, um ohne weitere Abfragen reagieren zu können.
        - Beispiel für `ThemeChangedEvent`:
            
            Rust
            
            ```
            # // Serialize/Deserialize falls Events über IPC gehen könnten
            pub struct PaletteDetails {
                pub primary_accent: core::types::Color,
                pub secondary_accent: core::types::Color,
                pub foreground: core::types::Color,
                pub background: core::types::Color,
                //... weitere relevante Farbdefinitionen
            }
            
            #
            pub struct ThemeChangedEvent {
                pub new_theme_name: String,
                pub new_variant_name: String,
                pub applied_palette: PaletteDetails, // Statt nur IDs, die volle Information
                pub font_details: FontDescription, // Annahme einer Struktur für Font-Details
            }
            
            #
            pub struct FontDescription {
                pub family: String,
                pub size_pt: f32,
                pub style: String, // z.B. "Regular", "Bold"
            }
            ```
            
            (Diese detaillierte Definition wird für alle im Benutzerdokument genannten Ereignisse wie `WorkspaceEvent`, `AIInteractionInitiatedEvent`, etc. wiederholt.)
- **3.2. Spezifische Domänen-Service-Schnittstellen (Ultra-Granular):**
    
    - **`ThemingEngine` API:**
        
        - **Trait Definition:**
            
            Rust
            
            ```
            pub trait ThemingEngine: Send + Sync {
                /// Ruft den aktuell angewendeten und aufgelösten Theme-Zustand ab.
                fn get_current_theme_state(&self) -> Result<AppliedThemeState, ThemingError>;
            
                /// Listet alle verfügbaren Themes und deren Varianten auf.
                fn get_available_themes(&self) -> Result<Vec<ThemeIdentifier>, ThemingError>;
            
                /// Ruft die aktuelle, persistierte Theme-Konfiguration ab (z.B. ausgewählter Theme-Name, Variante, Overrides).
                fn get_current_configuration(&self) -> Result<ThemeConfiguration, ThemingError>;
            
                /// Aktualisiert die Theme-Konfiguration. Änderungen werden persistiert und lösen ggf. ein `ThemeChangedEvent` aus.
                fn update_configuration(&self, config_update: ThemeConfigurationUpdate) -> Result<(), ThemingError>;
            
                /// Lädt alle Theme-Definitionen und Farb-Token neu vom Dateisystem oder der konfigurierten Quelle.
                fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>;
            
                /// Abonniert Änderungen am Theme-Zustand.
                /// Gibt einen Receiver-Endpunkt eines Broadcast-Kanals zurück, über den `ThemeChangedEvent`s empfangen werden können.
                /// Alternativ könnte dies über einen zentralen EventBus erfolgen.
                fn subscribe_to_theme_changes(&self) -> Result<tokio::sync::broadcast::Receiver<ThemeChangedEvent>, ThemingError>;
            }
            ```
            
        - **Datenstrukturen:**
            - `AppliedThemeState { name: String, variant: String, primary_color: core::types::Color, text_color: core::types::Color, background_color: core::types::Color, accent_colors: HashMap<String, core::types::Color>, font_family: String, font_size_pt: f32, raw_tokens: HashMap<String, String> /* Für Debugging oder fortgeschrittene Nutzung */ }`
            - `ThemeIdentifier { id: String, name: String, display_name: String, description: Option<String>, author: Option<String>, variants: Vec<ThemeVariantIdentifier> }`
            - `ThemeVariantIdentifier { id: String, name: String, display_name: String, preview_image_path: Option<PathBuf> }`
            - `ThemeConfiguration { current_theme_id: String, current_variant_id: String, custom_palette_overrides: HashMap<String, core::types::Color>, font_scale_factor: Option<f32> }`
            - `ThemeConfigurationUpdate { theme_id: Option<String>, variant_id: Option<String>, set_custom_palette_overrides: Option<HashMap<String, core::types::Color>>, remove_custom_palette_overrides: Option<Vec<String>>, font_scale_factor: Option<f32> }`
        - **Events:**
            - `ThemeChangedEvent { new_state: AppliedThemeState }` (wie oben definiert, Payload enthält alle relevanten Infos)
        - **Fehler:** `ThemingError` (Varianten wie oben detailliert definiert: `ThemeNotFound`, `VariantNotFound`, `AssetLoadError`, `InvalidConfiguration`, `TokenNotFound`, `ColorParseError`).
    - **`WorkspaceManager` API:**
        
        - **Trait Definition:**
            
            Rust
            
            ```
            pub trait WorkspaceManager: Send + Sync {
                fn create_workspace(&self, params: CreateWorkspaceParams) -> Result<WorkspaceDescriptor, WorkspaceManagerError>;
                fn delete_workspace(&self, workspace_id: core::types::WorkspaceId) -> Result<(), WorkspaceManagerError>;
                fn set_active_workspace(&self, workspace_id: core::types::WorkspaceId) -> Result<(), WorkspaceManagerError>;
                fn get_active_workspace(&self) -> Result<Option<WorkspaceDescriptor>, WorkspaceManagerError>;
                fn get_workspace_by_id(&self, workspace_id: core::types::WorkspaceId) -> Result<Option<WorkspaceDescriptor>, WorkspaceManagerError>;
                fn list_workspaces(&self) -> Result<Vec<WorkspaceDescriptor>, WorkspaceManagerError>;
                fn assign_window_to_workspace(&self, window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId) -> Result<(), WorkspaceManagerError>;
                fn assign_window_to_active_workspace(&self, window_id: core::types::WindowId) -> Result<(), WorkspaceManagerError>;
                fn remove_window_from_workspace(&self, window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId) -> Result<(), WorkspaceManagerError>;
                fn get_window_assignment(&self, window_id: core::types::WindowId) -> Result<Option<core::types::WorkspaceId>, WorkspaceManagerError>;
                fn save_configuration(&self) -> Result<(), WorkspaceManagerError>; // Persistiert die aktuelle Arbeitsbereichsanordnung und -konfiguration
                fn load_configuration(&self) -> Result<(), WorkspaceManagerError>; // Lädt die Konfiguration beim Start
                fn rename_workspace(&self, workspace_id: core::types::WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>;
                fn set_workspace_layout(&self, workspace_id: core::types::WorkspaceId, layout: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>;
                fn reorder_workspaces(&self, ordered_workspace_ids: Vec<core::types::WorkspaceId>) -> Result<(), WorkspaceManagerError>;
                fn subscribe_to_workspace_events(&self) -> Result<tokio::sync::broadcast::Receiver<WorkspaceEvent>, WorkspaceManagerError>;
            }
            ```
            
        - **Datenstrukturen:**
            - `CreateWorkspaceParams { name: Option<String>, layout_hint: Option<WorkspaceLayoutType>, icon_name: Option<String>, activate_when_created: bool }`
            - `WorkspaceDescriptor { id: core::types::WorkspaceId, name: String, display_name: String, icon_name: Option<String>, layout: WorkspaceLayoutType, window_ids: Vec<core::types::WindowId>, is_active: bool, creation_timestamp: core::types::DateTime<Utc>, last_accessed_timestamp: core::types::DateTime<Utc> }`
            - `WorkspaceLayoutType { TilingHorizontal, TilingVertical, Floating, MaximizedSingleWindow }`
        - **Events (als Enum `WorkspaceEvent` zusammengefasst für einfacheres Abonnement):**
            
            Rust
            
            ```
            #
            pub enum WorkspaceEvent {
                WorkspaceCreated { descriptor: WorkspaceDescriptor },
                WorkspaceDeleted { workspace_id: core::types::WorkspaceId, previous_name: String },
                ActiveWorkspaceChanged { old_workspace_id: Option<core::types::WorkspaceId>, new_workspace_id: core::types::WorkspaceId, new_descriptor: WorkspaceDescriptor },
                WorkspaceLayoutChanged { workspace_id: core::types::WorkspaceId, new_layout: WorkspaceLayoutType },
                WindowAssignedToWorkspace { window_id: core::types::WindowId, new_workspace_id: core::types::WorkspaceId, old_workspace_id: Option<core::types::WorkspaceId> },
                WindowRemovedFromWorkspace { window_id: core::types::WindowId, workspace_id: core::types::WorkspaceId },
                WorkspaceRenamed { workspace_id: core::types::WorkspaceId, new_name: String, old_name: String },
                WorkspaceOrderChanged { ordered_workspace_ids: Vec<core::types::WorkspaceId> },
                WorkspaceConfigurationSaved,
                WorkspaceConfigurationLoaded,
            }
            ```
            
        - **Fehler:** `WorkspaceManagerError`, `WorkspaceConfigError`, `WindowAssignmentError` (jeweils mit detaillierten Varianten wie `WorkspaceNotFound`, `NameAlreadyExists`, `WindowNotKnownToCompositor`, `ConfigSaveFailed`, `ConfigLoadFailed`).
    - **(Diese Detailtiefe wird für `AIInteractionLogicService`, `NotificationService` und `GlobalSettingsService` wiederholt, basierend auf den im Benutzerdokument und in Teil 1.2 dieses Dokuments skizzierten Schnittstellen. Für `GlobalSettingsService` ist die Verwendung von `glib::Variant` für Einstellwerte hervorzuheben, um Flexibilität bei den Datentypen zu gewährleisten.12)**
        
    - Schlüsseltabellen für Teil 3.2:
        
        Ähnlich wie in Teil 1.2 und Teil 2.1 werden für jeden Domänendienst detaillierte Tabellen für Methodensignaturen, Parameter, Rückgabewerte und Ereignis-Payloads erstellt.
        
        - **Beispiel: `AIInteractionLogicService` Methodenübersicht**

|   |   |   |   |
|---|---|---|---|
|**Methode**|**Parameter**|**Rückgabetyp (async Result<_, _>)**|**Kurzbeschreibung**|
|`initiate_interaction`|`&self, request: domain::ai::InteractionRequest`|`Result<domain::ai::InteractionResponseHandle, domain::AIInteractionError>`|Startet eine neue KI-Interaktion.|
|`get_interaction_context`|`&self, interaction_id: core::types::Uuid`|`Result<domain::ai::InteractionContext, domain::AIInteractionError>`|Ruft den aktuellen Kontext und Verlauf einer Interaktion ab.|
|`provide_consent`|`&self, interaction_id: core::types::Uuid, model_id: String, granted: bool`|`Result<(), domain::AIInteractionError>`|Gibt die Zustimmung für ein bestimmtes Modell im Kontext einer Interaktion.|
|...|...|...|...|

```
    *   **Beispiel: `AIInteractionStatusChangedEvent` Payload**
```

|   |   |   |
|---|---|---|
|**Feldname**|**Typ**|**Beschreibung**|
|`interaction_id`|`core::types::Uuid`|ID der Interaktion, deren Status sich geändert hat.|
|`new_status`|`domain::ai::AIInteractionStatus`|Der neue Status der Interaktion.|
|`details`|`Option<String>`|Zusätzliche Details oder Fehlermeldung zum Statuswechsel.|

```
    Die präzise Definition dieser Domänenschnittstellen ist fundamental, da sie die Kernfunktionalität von NovaDE kapseln und die Verträge für die Interaktion mit der System- und UI-Schicht festlegen.
```

---

**Teil 4: Ultra-Granulare Schnittstellendefinition der Systemschicht (Erweiterung des Benutzerdokuments)**

Die Systemschicht ist verantwortlich für die Interaktion mit dem zugrundeliegenden Betriebssystem, der Hardware und Low-Level-Diensten wie dem Compositor, Eingabegeräten und D-Bus-Diensten. Sie stellt der UI-Schicht abstrahierte Schnittstellen zu diesen systemnahen Funktionen bereit.

- **4.1. Systemschicht zu UI-Schicht (Allgemeine Prinzipien)**
    
    - **Systemnahe Dienste und Ereignisse:** Die Systemschicht stellt der UI-Schicht Informationen und Ereignisse bereit, die direkt vom Betriebssystem, der Hardware oder systemnahen Daemons stammen. Für jede Kategorie (z.B. Fenstergeometrie, Eingabeereignisse, Systemstatusänderungen) werden spezifische Ereignisse mit detaillierten Payloads definiert.
    - **Technische Umsetzung von UI-Befehlen:** Die Systemschicht empfängt Befehle von der UI-Schicht (z.B. Fenster verschieben, Arbeitsbereich wechseln, Fokus anfordern) und setzt diese technisch um, indem sie mit dem Compositor, dem Fenstermanager oder anderen Systemkomponenten interagiert. Für jeden solchen Befehl wird eine exakte Methodensignatur in der API der Systemschicht definiert, die von der UI aufgerufen wird.
    - **Renderer-Schnittstelle (`system::compositor::renderer_interface`):** Obwohl nicht direkt von der UI-Schicht konsumiert, stellt diese Schnittstelle eine Abstraktion für das Rendering bereit. Wenn diese Schnittstelle Implikationen dafür hat, wie UI-Elemente letztendlich dargestellt werden (z.B. unterstützte Oberflächenformate, Anforderungen an Textur-Sharing), werden diese kurz vermerkt, da sie indirekt die UI-Implementierung beeinflussen können.
    - **Fehlertypen:** Jedes Modul der Systemschicht (z.B. `system::compositor`, `system::input`) definiert eigene, auf `thiserror` basierende Fehler-Enums (z.B. `CompositorError`, `InputError`). Diese Fehler-Enums listen alle spezifischen Fehlerzustände auf, die bei der Interaktion mit den jeweiligen Systemkomponenten auftreten können.
- **4.2. Spezifische Systemschicht-Schnittstellen (Ultra-Granular, für UI-Interaktion):**
    
    - **Compositor-Schnittstelle (`system::compositor_iface`):**
        
        - Diese Schnittstelle wird als Trait `CompositorInterface` definiert, um eine klare API für die UI-Schicht bereitzustellen.
        - **Methoden, die von der UI aufgerufen werden:**
            
            Rust
            
            ```
            pub trait CompositorInterface: Send + Sync {
                /// Fordert den Fokus für ein bestimmtes Fenster an.
                fn request_focus(&self, window_id: core::types::WindowId) -> Result<(), CompositorError>;
            
                /// Verschiebt ein Fenster an eine neue Position.
                fn move_window(&self, window_id: core::types::WindowId, new_pos: core::types::PointInt) -> Result<(), CompositorError>;
            
                /// Ändert die Größe eines Fensters.
                fn resize_window(&self, window_id: core::types::WindowId, new_size: core::types::SizeInt) -> Result<(), CompositorError>;
            
                /// Fordert einen neuen Zustand für ein Fenster an (z.B. Maximieren, Minimieren).
                fn set_window_state(&self, window_id: core::types::WindowId, state: CompositorWindowState) -> Result<(), CompositorError>;
            
                /// Schließt ein Fenster.
                fn close_window(&self, window_id: core::types::WindowId) -> Result<(), CompositorError>;
            
                /// Ruft detaillierte Informationen zu einem bestimmten Fenster ab.
                fn get_window_info(&self, window_id: core::types::WindowId) -> Result<Option<WindowInfo>, CompositorError>;
            
                /// Listet alle aktuell vom Compositor verwalteten Fenster auf.
                fn list_windows(&self) -> Result<Vec<WindowInfo>, CompositorError>;
            
                /// Ruft Informationen zu allen verfügbaren Outputs (Monitoren) ab.
                fn list_outputs(&self) -> Result<Vec<OutputInfo>, CompositorError>;
            
                /// Konfiguriert einen Output (Auflösung, Skalierung, etc.).
                fn configure_output(&self, output_id: String, config: OutputConfigurationRequest) -> Result<(), CompositorError>;
            
                /// Abonniert Compositor-Ereignisse.
                fn subscribe_to_compositor_events(&self) -> Result<tokio::sync::broadcast::Receiver<CompositorEvent>, CompositorError>;
            }
            ```
            
        - **Datenstrukturen:**
            - `WindowInfo { id: core::types::WindowId, title: String, app_id: core::types::AppId, class: Option<String>, geometry: core::types::RectInt, is_focused: bool, is_fullscreen: bool, is_maximized: bool, is_minimized: bool, workspace_id: Option<core::types::WorkspaceId>, parent_id: Option<core::types::WindowId>, transient_for_id: Option<core::types::WindowId>, can_resize: bool, can_maximize: bool, can_minimize: bool, can_close: bool, pid: Option<u32> }`
            - `CompositorWindowState { Maximized, Minimized, Fullscreen, Normal, TiledLeft, TiledRight, Floating }`
            - `OutputInfo { id: String, name: String, description: String, manufacturer: Option<String>, model: Option<String>, serial_number: Option<String>, physical_size_mm: Option<core::types::Size<u32>>, geometry_pixels: core::types::RectInt, scale_factor: f32, current_refresh_rate_mhz: u32, current_mode: OutputMode, available_modes: Vec<OutputMode>, is_primary: bool, is_enabled: bool, transform: core::types::Orientation }`
            - `OutputMode { width_px: u32, height_px: u32, refresh_rate_mhz: u32, is_preferred: bool }`
            - `OutputConfigurationRequest { resolution: Option<core::types::SizeInt>, scale: Option<f32>, position: Option<core::types::PointInt>, enabled: Option<bool>, refresh_rate_mhz: Option<u32>, transform: Option<core::types::Orientation>, is_primary: Option<bool> }`
        - **Events (als Enum `CompositorEvent` für das Abonnement):**
            
            Rust
            
            ```
            #
            pub enum CompositorEvent {
                WindowCreated { info: WindowInfo },
                WindowClosed { window_id: core::types::WindowId, app_id: core::types::AppId },
                WindowFocused { window_id: core::types::WindowId },
                WindowUnfocused { window_id: core::types::WindowId },
                WindowPropertiesChanged { window_id: core::types::WindowId, changed_properties: WindowPropertiesDelta },
                OutputAdded { info: OutputInfo },
                OutputRemoved { output_id: String },
                OutputConfigurationChanged { info: OutputInfo }, // Enthält den neuen Zustand des Outputs
                // Weitere Ereignisse wie Workspace-Wechsel, wenn vom Compositor direkt gemeldet
            }
            
            #
            pub struct WindowPropertiesDelta {
                pub title: Option<String>,
                pub app_id: Option<core::types::AppId>,
                pub class: Option<Option<String>>, // Option<Option<T>> um 'wurde auf None gesetzt' von 'wurde nicht geändert' zu unterscheiden
                pub geometry: Option<core::types::RectInt>,
                pub is_fullscreen: Option<bool>,
                pub is_maximized: Option<bool>,
                pub is_minimized: Option<bool>,
                pub workspace_id: Option<Option<core::types::WorkspaceId>>,
            }
            ```
            
        - **Fehler:** `CompositorError` mit Varianten wie `WindowNotFound`, `OutputNotFound`, `InvalidOperationForWindowState`, `WaylandCommunicationError(String)`, `X11CommunicationError(String)`.
        - Die Systemschicht abstrahiert hier die Komplexität von Wayland-Protokollen wie `wlr-foreign-toplevel-management` 17 oder `ext-foreign-toplevel-list-v1` 17, die für Taskbars und Docks zur Abfrage von Fensterlisten fundamental sind. Die UI konsumiert die `WindowInfo`-Struktur, die von dieser Abstraktion bereitgestellt wird. Für die Implementierung von UI-Elementen wie Panels oder Docks, die eine feste Position auf dem Bildschirm einnehmen, wird die Systemschicht intern `gtk4-layer-shell` 9 verwenden und eine abstrahierte API dafür anbieten.
    - **(Diese Detailtiefe wird für `system::input_iface`, `system::dbus::upower_client_iface`, `system::dbus::logind_client_iface`, `system::dbus::networkmanager_client_iface` (unter Berücksichtigung von D-Bus-Spezifikationen für NetworkManager 23 und BlueZ 20), `system::outputs_iface` (bereits teilweise in Compositor-Schnittstelle enthalten, hier ggf. spezifischere Konfigurationsmethoden), `system::audio_iface` (Abstraktion von PipeWire 26), `system::mcp_client_iface` und `system::portals_iface` (Abstraktion von XDG Desktop Portals, potenziell unter Verwendung von Bibliotheken wie `ashpd` 28) wiederholt, wie in Teil 1, Abschnitt 1.3 skizziert.)**
        
        - Für `system::portals_iface` ist die `WindowIdentifier`-Struktur, die von `ashpd` verwendet wird, ein wichtiger Aspekt, um Portal-Dialoge korrekt dem aufrufenden Anwendungsfenster zuzuordnen. Die Systemschicht muss einen Mechanismus bereitstellen, um diese Kennung von der UI zu erhalten oder abzuleiten.
    - Schlüsseltabellen für Teil 4.2:
        
        Ähnlich wie in den vorherigen Teilen werden für jede Systemschicht-Schnittstelle detaillierte Tabellen für Methodensignaturen, Parameter, Rückgabewerte und Ereignis-Payloads erstellt.
        
        - **Beispiel: `InputInterface` Methodenübersicht**

|   |   |   |   |
|---|---|---|---|
|**Methode**|**Parameter**|**Rückgabetyp (Result<_, _>)**|**Kurzbeschreibung**|
|`set_cursor_theme`|`&self, theme_name: String, size: u32`|`Result<(), system::InputError>`|Setzt das Cursor-Theme und die Größe.|
|`get_current_keyboard_layout`|`&self`|`Result<String, system::InputError>`|Ruft das aktuell aktive Tastaturlayout ab.|
|`subscribe_to_input_events`|`&self`|`Result<tokio::sync::broadcast::Receiver<system::input::InputEventEnum>, system::InputError>`|Abonniert verarbeitete Eingabeereignisse.|

```
    *   **Beispiel: `system::input::InputEventEnum` Payload (Auszug)**
        ```rust
        #
        pub enum InputEventEnum {
            Keyboard(KeyboardEvent),
            PointerButton(PointerButtonEvent),
            PointerMotion(PointerMotionEvent),
            //... weitere Event-Typen
        }

        #
        pub struct KeyboardEvent {
            pub window_id: Option<core::types::WindowId>, // Fenster, das den Fokus hatte, falls zutreffend
            pub key_code: u32,          // System-agnostischer Keycode
            pub raw_key_code: u32,      // Hardware-Keycode
            pub modifiers: KeyModifiers, // Bitmaske für Shift, Ctrl, Alt, Super
            pub state: KeyState,        // Pressed, Released
            pub utf8: Option<String>,   // Decodiertes Zeichen, falls vorhanden
            pub timestamp_us: u64,      // Zeitstempel in Mikrosekunden
        }
        // Definitionen für KeyModifiers, KeyState, PointerButtonEvent etc. folgen
        ```

    Die klare Definition dieser Systemschicht-APIs ist entscheidend, da sie die Brücke zwischen der plattformunabhängigen UI-Logik und den plattformspezifischen Implementierungen schlägt.
```

---

**Teil 5: Verfeinerte Schichtübergreifende Schnittstellenprinzipien und Fortgeschrittene Themen**

Dieser Abschnitt behandelt übergreifende Prinzipien und fortgeschrittene Aspekte, die für das Design und die Implementierung der internen Schnittstellen von NovaDE von Bedeutung sind.

- 5.1. Asynchrone Operationen und UI-Synchronisation
    
    Die Reaktionsfähigkeit der Benutzeroberfläche ist ein primäres Ziel. Viele Operationen, insbesondere solche, die Netzwerkzugriffe, Dateisystemoperationen oder komplexe Berechnungen beinhalten (z.B. Aufrufe an AIInteractionLogicService oder MCPClientInterface), sind inhärent asynchron. Es ist unerlässlich, dass die UI nicht blockiert, während auf den Abschluss dieser Operationen gewartet wird.
    
    - **Muster für von der UI initiierte asynchrone Aufrufe:**
        
        - Die UI-Schicht ruft eine `async fn` Methode eines Domänen- oder Systemdienstes auf (z.B. `async fn perform_long_task() -> Result<Data, ServiceError>;`).
        - Um ein Blockieren des UI-Threads zu verhindern, sollte die UI-Komponente, die die Operation initiiert (z.B. bei einem Button-Klick), die asynchrone Funktion in einer separaten Task ausführen. In einer `gtk4-rs` Umgebung wird hierfür typischerweise `tokio::spawn` (oder ein äquivalenter Executor) verwendet, falls die Service-Methode selbst `Send` ist, oder `glib::MainContext::spawn_local` für nicht-`Send` Futures, die auf dem Hauptthread laufen müssen, aber dennoch asynchron sind.
    - **Übermittlung von Ergebnissen/Fehlern an den UI-Thread:**
        
        - **`glib::MainContext::spawn_local`:** Dies ist der bevorzugte Mechanismus in `gtk4-rs`, um UI-Aktualisierungen sicher auf dem Haupt-GTK-Thread zu planen, sobald eine asynchrone Operation abgeschlossen ist.3
            - **Ablaufbeispiel:**
                1. Eine UI-Komponente (z.B. ein Button-Klick-Handler) startet eine Tokio-Task (`tokio::spawn`).
                2. Diese Tokio-Task führt `await` auf den Aufruf des Domänen- oder Systemdienstes aus.
                3. Nach Abschluss der Operation (ob `Ok` oder `Err`) verwendet die Tokio-Task `main_context.spawn_local(...)`, um eine Closure zu planen.
                4. Diese Closure, die nun garantiert auf dem Hauptthread ausgeführt wird, aktualisiert die GTK-Widgets mit dem Ergebnis oder dem Fehler.
        - **Kanäle (z.B. `tokio::sync::mpsc`, `async_channel`):**
            - Der UI-Thread hält das `Receiver`-Ende des Kanals. Die asynchrone Task (z.B. in einem Tokio-Thread) hält das `Sender`-Ende.
            - Nach Abschluss der asynchronen Operation wird das Ergebnis oder der Fehler über den Kanal gesendet.
            - Der UI-Thread, typischerweise in einer `glib::idle_add_local`-Schleife oder einem `glib::MainContext::spawn_local`-Future, das den Receiver abfragt, verarbeitet eingehende Nachrichten und aktualisiert die Widgets.
            - Es ist wichtig zu beachten, dass `glib::MainContext::channel()` in neueren GLib-Versionen entfernt wurde.39 Der empfohlene Ansatz ist die Verwendung von Standard-Async-Kanälen (wie `async_channel` oder `tokio::sync::mpsc`) und dann `glib::MainContext::default().spawn_local()`, um die Ergebnisse auf den Hauptthread für UI-Aktualisierungen zu bringen. Diese Änderung vereinfacht die Codebasis, da sie auf etablierte asynchrone Rust-Patterns setzt, anstatt eine GLib-spezifische Kanallösung zu verwenden. Die Schnittstellendefinition selbst schreibt diese interne UI-Implementierung nicht vor, aber die Dokumentation für UI-Entwickler, die diese asynchronen APIs konsumieren, sollte dieses Muster empfehlen.
        - **Fehlerbehandlung in asynchroner UI:** Fehler von asynchronen Operationen müssen ebenfalls auf den Hauptthread gemarshallt und angemessen dargestellt werden. Dies kann beispielsweise durch die Anzeige eines `gtk::AlertDialog` 6 oder einer nicht-modalen Benachrichtigung geschehen.
    - **Tabelle: Asynchrones Interaktionsmuster**
        

|   |   |   |   |   |
|---|---|---|---|---|
|**Schritt**|**Aktion**|**Thread**|**Mechanismus**|**Anmerkungen**|
|1|Benutzerinteraktion|UI-Thread|GTK-Signal|z.B. Button-Klick|
|2|Asynchronen Aufruf initiieren|UI-Thread|`tokio::spawn` (für `Send` Futures)|Startet eine neue Task für den Service-Aufruf, um den UI-Thread nicht zu blockieren.|
|3|Service-Methode ausführen|Worker-Thread (Tokio)|`await service.method()`|Ruft die asynchrone Methode des Domänen-/Systemdienstes auf.|
|4a|Ergebnis/Fehler senden (Kanal-Ansatz)|Worker-Thread (Tokio)|`sender.send(result).await`|Sendet das Ergebnis an einen Kanal, der vom UI-Thread überwacht wird.|
|4b|UI-Update planen (Direkter Spawn-Ansatz)|Worker-Thread (Tokio)|`main_context.spawn_local(async move {... })`|Plant direkt eine Closure zur UI-Aktualisierung auf dem Hauptthread.|
|5a|Empfangen & Verarbeiten (Kanal-Ansatz)|UI-Thread|`receiver.recv().await` (in `spawn_local`)|Die Closure in `spawn_local` empfängt die Nachricht und aktualisiert GTK-Widgets.|
|5b|UI-Update ausführen (Direkter Spawn-Ansatz)|UI-Thread|Ausführung der Closure|Die geplante Closure wird ausgeführt und aktualisiert GTK-Widgets.|

```
    Diese Tabelle verdeutlicht das Threading-Modell und den Kommunikationsfluss für asynchrone Operationen, die von der UI initiiert werden. Dies ist ein häufiger Bereich für Komplexität und Fehlerquellen, daher ist ein klares Verständnis dieses Musters entscheidend.
```

- 5.2. Ereignissystem: Granulare Semantik
    
    Das Ereignissystem ist ein Rückgrat für die reaktive Natur von NovaDE. Eine präzise Definition der Ereignissemantik ist unerlässlich.
    
    - **Ereignisdefinition:** Jede Ereignisstruktur (`struct`) muss vollständig definiert sein, einschließlich aller Felder und deren exakter Rust-Typen. Die Nutzdaten (Payload) eines Ereignisses sollten umfassend sein, um es den Konsumenten zu ermöglichen, ohne zusätzliche Abfragen an den Ereigniserzeuger zu reagieren. Beispielsweise sollte ein `ThemeChangedEvent` nicht nur eine ID des neuen Themes enthalten, sondern direkt die `AppliedThemeState`-Struktur, die alle relevanten Details des neuen Themes beinhaltet. Dies minimiert den Kommunikationsaufwand und verbessert die Performance.
    - **Payload-Serialisierung:** Für die interne Kommunikation zwischen den Schichten innerhalb desselben Prozesses ist eine direkte Übergabe von Rust-Strukturen ausreichend und performant. Sollten Ereignisse jedoch zukünftig über Prozessgrenzen hinweg kommuniziert werden (z.B. über D-Bus an externe Komponenten), muss ein Serialisierungsformat (z.B. Serde mit JSON/CBOR oder GVariant für D-Bus) definiert werden. Die aktuellen Ereignisstrukturen sollten mit `#` annotiert werden, um diese zukünftige Erweiterbarkeit vorzubereiten.
    - **Ereignisgarantien:**
        - **Reihenfolge:** Innerhalb eines bestimmten Geltungsbereichs (z.B. Ereignisse von einem einzelnen Service) ist typischerweise davon auszugehen, dass Ereignisse in der Reihenfolge empfangen werden, in der sie ausgelöst wurden, vorausgesetzt, der Emitter ist single-threaded oder verwendet geeignete Synchronisationsmechanismen. Für einen systemweiten Event-Bus kann die globale Reihenfolge komplexer sein und hängt von der Implementierung des Busses ab.
        - **Zustellung:** Für einen In-Prozess-Event-Bus wird typischerweise eine "At-least-once"-Zustellung angestrebt, solange die Abonnenten aktiv sind und keine Fehler im Bus selbst auftreten. Garantien für "Exactly-once" sind komplexer zu implementieren.
    - **Abonnement-Mechanismus:**
        - Es muss eine klare API für Komponenten geben, um spezifische Ereignistypen zu abonnieren. Dies könnte über einen zentralen `EventBus` erfolgen: `event_bus.subscribe::<ThemeChangedEvent>(|event: &ThemeChangedEvent| { /* UI-Logik hier */ });`.
        - Der Event-Bus sollte Filterfunktionen unterstützen, z.B. das Abonnieren von `WorkspaceEvent` nur für eine bestimmte `workspace_id` oder das Filtern von `SettingChangedEvent` nach einem bestimmten `setting_key`.
        - Die zurückgegebenen `tokio::sync::broadcast::Receiver` von den `subscribe_to_..._events` Methoden der Service-Traits sind ein Beispiel für einen solchen Mechanismus.
    - **Broadcasting vs. Gezielte Ereignisse:** Die meisten Domänen- und Systemereignisse werden als Broadcast an alle interessierten Abonnenten gesendet. Gezielte Ereignisse (nur an einen bestimmten Listener) sind seltener und erfordern einen komplexeren Registrierungs- und Routing-Mechanismus. Für die interne Schichtkommunikation ist Broadcasting meist ausreichend.
    - Die Reaktivität der Benutzeroberfläche hängt stark von einem wohldefinierten und zuverlässigen Ereignissystem ab. Granulare Ereignis-Payloads sind der Schlüssel zur Minimierung von Daten-Refetching und zur Gewährleistung einer performanten UI. GTK4-Signale und Ereignisbehandlungsmechanismen werden intern von der UI-Schicht verwendet, um auf diese anwendungsweiten Ereignisse zu reagieren, die von den unteren Schichten über den Event-Bus oder direkte Abonnements empfangen werden.
- **5.3. API-Versionierung und Evolution (Kurzer Hinweis)**
    
    - APIs unterliegen im Laufe der Zeit Änderungen. Um die Stabilität und Wartbarkeit des Systems langfristig zu gewährleisten, sollten Strategien für die API-Evolution berücksichtigt werden:
        - **Hinzufügen neuer Methoden zu Traits:** Dies ist für bestehende Implementierer nicht-brechend, wenn die neuen Methoden Standardimplementierungen haben (obwohl dies für Kern-APIs seltener der Fall ist).
        - **Hinzufügen neuer optionaler Felder zu Strukturen/Event-Payloads:** Erfordert eine sorgfältige Behandlung durch die Konsumenten (z.B. Verwendung von `Option<T>` und `#[serde(default)]`).
        - **Einführung neuer Versionen von Traits (z.B. `ThemingEngineV2`):** Für signifikante, brechende Änderungen ist dies der sauberste Ansatz.
    - Diese Überlegungen sind zunächst auf hoher Ebene, aber wichtig für die langfristige Gesundheit des Projekts. Eine klare Dokumentation von Änderungen und Deprecation-Policys ist ebenfalls entscheidend.

---

**Teil 6: Schnittstellendetails UI-Komponenten-spezifisch**

Dieser Abschnitt widmet sich der ultra-granularen Definition der Interaktionen spezifischer UI-Komponenten mit den zuvor definierten Domänen- und System-APIs. Er beleuchtet, wie Schlüsselkomponenten der Benutzeroberfläche diese Schnittstellen nutzen, um ihre Funktionalität zu realisieren.

- **6.1. Window Manager Frontend (`ui::window_manager_frontend`)**
    - **Verantwortlichkeiten:** Anzeige von Fensterrepräsentationen (z.B. in einer Taskleiste, Alt-Tab-Umschalter), Bearbeitung von Fokusanfragen für Fenster von UI-Elementen.
    - **Interaktion mit `system::compositor_iface`:**
        - Konsumiert `system::compositor::WindowCreatedEvent`, `WindowClosedEvent`, `WindowFocusedEvent`, `WindowUnfocusedEvent`, `WindowPropertiesChangedEvent`, um seine interne Liste der Fenster und deren Zustände zu aktualisieren.
        - Ruft `compositor_iface.request_focus(window_id)` auf, wenn der Benutzer ein Fenster auswählt (z.B. durch Klick in der Taskleiste).
        - Ruft `compositor_iface.set_window_state(window_id, CompositorWindowState::Minimized)` oder `close_window(window_id)` auf, basierend auf Benutzeraktionen.
    - **Interne UI-Modelldatenstrukturen:**
        - `UIWindowRepresentation { id: core::types::WindowId, title: String, app_id: core::types::AppId, icon_name: Option<String>, // Name für Themed Icon gtk_icon: Option<gtk::gdk_pixbuf::Pixbuf>, // Geladenes Icon is_focused: bool, is_minimized: bool, workspace_tag: Option<String> /* z.B. "WS1" */ }`
    - **GTK-Implementierungshinweise:**
        - Könnte `gtk::ListView` 40 oder `gtk::FlowBox` 45 mit benutzerdefinierten Widgets für jedes Fenster verwenden. Jedes benutzerdefinierte Widget würde an eine `UIWindowRepresentation` binden.
        - Für die Fenster-Thumbnails oder Live-Vorschauen (wie in einem Alt-Tab-Switcher) sind Wayland-spezifische Protokolle oder Compositor-Features notwendig. Die Systemschicht müsste eine API bereitstellen, um solche Texturen oder Oberflächen-Handles zu liefern, die dann in einem GTK-Widget (ggf. ein spezielles Wayland-Oberflächen-Widget oder ein `gtk::Picture` mit aktualisierten Snapshots) dargestellt werden könnten. Wakefield 47 ist ein Beispiel für einen GTK-basierten Compositor, der Client-Oberflächen in GTK-Widgets einbetten kann; ähnliche Konzepte könnten für Vorschauen relevant sein, auch wenn NovaDE kein verschachtelter Compositor ist. Die `ext-foreign-toplevel-list-v1` und `wlr-foreign-toplevel-management-unstable-v1` Protokolle 17 sind fundamental für Taskleisten, um Fensterlisten und Metadaten zu erhalten. Die Systemschicht abstrahiert diese Protokolle, und die UI konsumiert die `WindowInfo`-Strukturen.
    - **Tabellen:**
        - **Interaktion `ui::window_manager_frontend` mit `system::compositor_iface`**

|   |   |   |   |
|---|---|---|---|
|**UI-Aktion**|**Aufgerufene compositor_iface-Methode**|**Konsumierte CompositorEvents**|**Aktualisierte UI-Daten**|
|Fenster in Taskleiste anklicken|`request_focus(window_id)`|`WindowFocusedEvent`, `WindowUnfocusedEvent`|`UIWindowRepresentation::is_focused`|
|Fenster minimieren|`set_window_state(id, Minimized)`|`WindowPropertiesChangedEvent` (mit `is_minimized = true`)|`UIWindowRepresentation::is_minimized`|
|Neues Fenster erscheint|-|`WindowCreatedEvent`|Neue `UIWindowRepresentation`|
|Fenstertitel ändert sich|-|`WindowPropertiesChangedEvent` (mit `changed_title`)|`UIWindowRepresentation::title`|

- **6.2. Desktop Shell (`ui::shell`) - Panels, Docks**
    
    - **Verantwortlichkeiten:** Anzeige von Panels (oben, unten, seitlich), Docks, Arbeitsbereichswechslern, Uhr, Systemindikatoren (Netzwerk, Lautstärke, Akku etc.).
    - **Interaktion mit `gtk4-layer-shell` (über Systemschicht-Abstraktion):**
        - Die Systemschicht stellt eine API bereit, z.B. `system::desktop_shell_iface`, um Layer-Oberflächen zu erstellen und zu verwalten. Diese API kapselt die direkte Verwendung von `gtk4-layer-shell`.9
        - `fn create_layer_surface(&self, params: LayerSurfaceParams) -> Result<LayerSurfaceHandle, ShellError>;`
            - `LayerSurfaceParams { window_handle: gtk::WindowHandle, // Das GTK-Fenster, das als Layer-Oberfläche dient anchor: LayerShellAnchor, // Bitflags: Top, Bottom, Left, Right exclusivity: LayerShellExclusivity, // Exclusive, OnDemand keyboard_interactivity: LayerShellKeyboardInteractivity // None, Exclusive, OnDemand margins: (i32, i32, i32, i32) // top, right, bottom, left }`
        - Die UI verwendet dieses `LayerSurfaceHandle`, um ihre GTK-Panel- oder Dock-Widgets in der Layer-Oberfläche zu positionieren und zu verankern.
        - Die Verwendung von `gtk4-layer-shell` ist entscheidend für die korrekte Integration von Panels und Docks in Wayland-Umgebungen, da es Apps erlaubt, sich über oder unter normalen Fenstern zu positionieren und Platz auf dem Bildschirm zu reservieren.9
    - **Arbeitsbereichswechsler:**
        - Konsumiert `domain::workspaces::WorkspaceEvent`-Ereignisse vom `WorkspaceManager`.
        - Zeigt `domain::workspaces::WorkspaceDescriptor`-Daten an (Name, Icon, aktive Fenster).
        - Ruft `WorkspaceManager::set_active_workspace(workspace_id)` bei Benutzerinteraktion auf.
        - GTK-Implementierung: Könnte eine `gtk::Box` mit `gtk::ToggleButton`s oder benutzerdefinierten gezeichneten Elementen für jeden Arbeitsbereich sein. `chunks-rs` 50 und allgemeine Pager-Beispiele 51 zeigen Konzepte für die Implementierung von Arbeitsbereichswechslern in GTK.
    - **Uhr / Kalenderanzeige:**
        - Verwendet `core::utils::time_utils` (basierend auf `chrono`) zur Formatierung von Datum und Uhrzeit.
        - Kann ein `gtk::Calendar` in einem `gtk::Popover` anzeigen, wenn auf die Uhr geklickt wird. Das Popover wird relativ zum Uhr-Widget positioniert.
    - **Systemindikatoren (Lautstärke, Netzwerk, Akku, Bluetooth etc.):**
        - **Lautstärke:**
            - Konsumiert `system::audio::AudioDeviceChangedEvent`, `AudioStreamVolumeChangedEvent` etc. vom `system::audio_iface`.
            - Zeigt aktuelle Lautstärke mit `gtk::Scale` (als Slider) oder `gtk::VolumeButton` 52 an.
            - Sendet `system::audio_iface::set_device_volume()` bei Benutzerinteraktion.
        - **Netzwerk:**
            - Konsumiert `system::dbus::NetworkStateChangedEvent`, `AccessPointsChangedEvent` vom `system::dbus::networkmanager_client_iface`.
            - Zeigt Verbindungsstatus (Icon), SSID, verfügbare Netzwerke in einem `gtk::Popover` mit einer `gtk::ListBox` an.
            - Ruft `system::dbus::networkmanager_client_iface::connect_to_access_point()` auf.
        - **Akku:**
            - Konsumiert `system::dbus::UPowerDeviceChangedEvent` vom `system::dbus::upower_client_iface`.
            - Zeigt Akkustand (Icon, Prozent) und geschätzte Restlaufzeit an.
        - **Bluetooth:**
            - Konsumiert Ereignisse von einem `system::dbus::bluez_adapter_iface` (analog zu NetworkManager).
            - Zeigt Bluetooth-Status, gekoppelte und verfügbare Geräte an.
            - Ruft Methoden wie `pair_device()`, `connect_device()` auf der BlueZ-Schnittstelle auf.20
        - **StatusNotifierItem/Ayatana Indicators (System Tray):**
            - Die Implementierung eines System Trays unter Wayland ist komplex. Die Spezifikation `StatusNotifierItem` (SNI) 48 ist der De-facto-Standard, der über D-Bus funktioniert.
            - Die `ui::shell` müsste als `StatusNotifierHost` agieren. Dies beinhaltet das Lauschen auf den D-Bus nach Diensten, die `StatusNotifierWatcher.RegisterStatusNotifierItem` aufrufen, und dann die Interaktion mit jedem `StatusNotifierItem` über dessen D-Bus-Schnittstelle, um Icon, Tooltip, Menü etc. abzurufen und darzustellen.
            - Die UI-Elemente für jedes Tray-Icon (typischerweise ein `gtk::Button` mit einem `gtk::Image` und einem `gtk::MenuButton` oder `gtk::Popover` für das Kontextmenü) würden dynamisch in einem Bereich des Panels erstellt.
            - Alternative Ansätze oder Herausforderungen unter Wayland werden diskutiert.58 NovaDE wird sich auf die `StatusNotifierItem`-Spezifikation konzentrieren, da sie am weitesten verbreitet ist. Die `libayatana-indicator`-Bibliothek 63 bietet eine Implementierung, die als Referenz dienen kann, obwohl NovaDE seine eigene D-Bus-Interaktion wahrscheinlich direkt mit `zbus` oder `gio::DBusConnection` implementieren würde, abstrahiert durch die Systemschicht.
            - Die Systemschicht würde eine `system::status_notifier_host_iface` bereitstellen, die Ereignisse wie `StatusNotifierItemRegisteredEvent { service_name: String, object_path: String }` und `StatusNotifierItemUnregisteredEvent` aussendet. Die UI würde diese abonnieren und dann die `system::status_notifier_item_proxy_iface` verwenden, um mit den einzelnen Items zu interagieren (z.B. `get_icon_pixmap()`, `get_tooltip()`, `activate()`, `context_menu()`).
- **6.3. Benachrichtigungs-Popups (`ui::notification_popups`)**
    
    - **Verantwortlichkeiten:** Anzeige von transienten Benachrichtigungs-Popups.
    - **Interaktion mit `domain::NotificationService`:**
        - Konsumiert `domain::notifications::NotificationPostedEvent`.
        - Zeigt die `domain::notifications::Notification`-Daten (Zusammenfassung, Textkörper, Icon, Aktionen) an.
    - **Interaktion mit `gtk4-layer-shell` (über Systemschicht-Abstraktion):**
        - Verwendet das Layer-Shell-Protokoll, um Benachrichtigungs-Popups an einer bestimmten Bildschirmkante (z.B. oben rechts) ohne Interferenz mit anderen Fenstern zu positionieren. Dies ist entscheidend für nicht-invasive Benachrichtigungen.9
        - Die Systemschicht stellt eine Methode bereit, z.B. `system::desktop_shell_iface::create_notification_layer_surface(params: NotificationSurfaceParams) -> Result<LayerSurfaceHandle, ShellError>;`, wobei `NotificationSurfaceParams` Details wie Anker, Dauer und Größe enthalten kann.
    - **Benutzerinteraktion:**
        - Klick auf eine Benachrichtigung könnte `NotificationService::dismiss_notification(id)` aufrufen oder eine Standardaktion auslösen (falls definiert).
        - Klick auf einen Aktionsbutton in einer Benachrichtigung (z.B. "Antworten", "Archivieren") resultiert in einem Aufruf an `NotificationService::invoke_action_on_notification(notification_id, action_id)`, was wiederum ein `domain::notifications::NotificationActionInvokedEvent` auslösen kann, auf das andere Teile der Anwendung reagieren können.
    - **GTK-Implementierungshinweise:**
        - Jedes Popup ist ein eigenes `gtk::Window`, das als Layer-Oberfläche konfiguriert ist. Es enthält typischerweise `gtk::Image` für das Icon, `gtk::Label` für Text und `gtk::Button` für Aktionen.
        - Mehrere Popups müssen verwaltet werden (z.B. in einer Warteschlange oder gestapelt auf dem Bildschirm).65
    - NovaDE wird seine eigenen Benachrichtigungen zeichnen, um volle Kontrolle über das Erscheinungsbild und die Integration mit dem Theming-System zu haben, anstatt sich auf einen externen Freedesktop-Benachrichtigungsdaemon zu verlassen.67 Der `domain::NotificationService` dient als zentrale Anlaufstelle und leitet die `NotificationPostedEvent` an die `ui::notification_popups`-Komponente weiter.
- **6.4. Anwendungsstarter (z.B. Dock, Anwendungsraster)**
    
    - **Verantwortlichkeiten:** Anzeige verfügbarer Anwendungen, Starten von Anwendungen.
    - **Interaktion mit `system::app_launcher_iface`:**
        - Ruft `system::app_launcher_iface::list_applications()` auf, um eine `Vec<system::applications::ApplicationEntry>` zu erhalten.
        - Zeigt diese Einträge an (Icon, Name). Die Icons werden basierend auf dem Icon-Namen und dem aktuellen Theme geladen.
        - Ruft `system::app_launcher_iface::launch_application(app_id, files_to_open: Option<Vec<PathBuf>>)` bei Benutzeraktivierung (Klick) oder per Drag-and-Drop auf.
    - **Interne UI-Modelldatenstrukturen:**
        - `UIAppEntry { id: String, // Desktop-Datei-ID oder AppStream-ID name: String, generic_name: Option<String>, comment: Option<String>, icon_name: Option<String>, gtk_icon: Option<gtk::gdk_pixbuf::Pixbuf>, categories: Vec<String>, keywords: Vec<String> }`
        - Die `system::app_launcher_iface` würde intern `freedesktop_entry_parser` 71 oder ähnliche Mechanismen verwenden, um `.desktop`-Dateien zu parsen und die `ApplicationEntry`-Daten bereitzustellen. Die UI konsumiert diese abstrahierten Daten.
    - **GTK-Implementierungshinweise:**
        - `gtk::FlowBox` 45 oder `gtk::GridView` (mit `gtk::SignalListItemFactory` 42) eignen sich gut zur Anzeige von App-Icons.
        - Jedes Icon könnte ein benutzerdefiniertes `gtk::Button` sein, das ein `gtk::Image` und optional ein `gtk::Label` enthält.
    - **Drag-and-Drop zum Starten:**
        - App-Icons fungieren als `GtkDropTarget`.74
        - Bei einem Drop werden Datei-URIs/Pfade extrahiert und an `system::app_launcher_iface::launch_application(app_id, Some(dropped_files))` übergeben.
        - Die `system::app_launcher_iface` verwendet intern `gio::AppInfo` und verwandte APIs, um Anwendungen zu starten [76,
# Implementierungsleitfaden für die UI-Schicht: Modul 1 – Applikations-Shell und Kernnavigation

Dieses Dokument beschreibt die Ultra-Feinspezifikationen und hochdetaillierten Implementierungspläne für das erste Modul der UI-Schicht. Das Modul "Applikations-Shell und Kernnavigation" umfasst grundlegende Komponenten, die für den Start, die Hauptfensterverwaltung und zentrale UI-Dienste der Applikation zuständig sind. Jede Komponente ist so detailliert spezifiziert, dass Entwickler sie direkt implementieren können, ohne eigene Entscheidungen treffen oder Logiken entwerfen zu müssen.

## 2. UI-Schicht: Implementierungsplan

### Modul 1: Applikations-Shell und Kernnavigation

Die folgenden Abschnitte definieren die Spezifikationen für die Kernkomponenten der Applikations-Shell und der grundlegenden Navigationsinfrastruktur.

#### 2.1. `AppInitializer` (Service/Non-Widget GObject)

##### 2.1.1. Übersicht und Zweck

Der `AppInitializer` ist ein zentraler Service, der für die Initialisierung der GTK-Applikation verantwortlich ist. Seine Hauptaufgaben umfassen das Einrichten globaler Ressourcen, die Registrierung der Applikations-ID und die Behandlung der `activate`- und `startup`-Signale der `gtk::Application`. Darüber hinaus verwaltet der `AppInitializer` den Lebenszyklus des globalen `ApplicationState`-Objekts, das anwendungsweite Zustandsinformationen und Dienste bündelt. Diese Komponente stellt sicher, dass die Applikation korrekt gestartet wird und das Hauptfenster bei Bedarf erstellt und angezeigt wird. Die Kapselung dieser Logik in `AppInitializer` fördert die Modularität und entkoppelt die applikationsspezifische Startlogik von der allgemeinen GTK-Struktur.

##### 2.1.2. Dateistruktur

Die Implementierung des `AppInitializer` wird in folgenden Dateien organisiert:

- `src/app_shell/app_initializer/mod.rs`: Öffentliches Modul und Wrapper-Definition.
- `src/app_shell/app_initializer/imp.rs`: Private Implementierungsdetails und GObject-Subklassifizierung.

##### 2.1.3. GObject-Definition

- **Wrapper-Typ:**
    
    Rust
    
    ```
    use gtk::glib;
    use gtk::gio;
    use std::cell::{Cell, OnceCell, RefCell};
    use std::rc::Rc;
    use crate::app_shell::main_window::MainWindow; // Annahme: MainWindow ist definiert
    use crate::app_shell::action_handler::MasterActionHandler; // Annahme: MasterActionHandler ist definiert
    use crate::app_shell::settings_service::SettingsService; // Annahme: SettingsService ist definiert
    
    glib::wrapper! {
        pub struct AppInitializer(ObjectSubclass<imp::AppInitializerImp>)
            @extends glib::Object;
    }
    ```
    
- **Implementierungs-Struktur (`imp`):**
    
    Rust
    
    ```
    // In src/app_shell/app_initializer/imp.rs
    use gtk::glib;
    use gtk::gio;
    use gtk::prelude::*;
    use gtk::subclass::prelude::*;
    use std::cell::{Cell, OnceCell, RefCell};
    use std::rc::Rc;
    use crate::app_shell::main_window::MainWindow;
    use crate::app_shell::action_handler::MasterActionHandler;
    use crate::app_shell::settings_service::SettingsService;
    
    #
    pub struct ApplicationState {
        pub settings_service: Option<SettingsService>,
        // Weitere globale Zustände oder Dienste hier
    }
    
    #
    pub struct AppInitializerImp {
        app: OnceCell<gtk::Application>,
        main_window: Cell<Option<MainWindow>>,
        app_state: OnceCell<Rc<RefCell<ApplicationState>>>,
        master_action_handler: OnceCell<Rc<MasterActionHandler>>,
    }
    
    #[glib::object_subclass]
    impl ObjectSubclass for AppInitializerImp {
        const NAME: &'static str = "MyAppInitializer";
        type Type = super::AppInitializer;
        type ParentType = glib::Object;
    
        fn new() -> Self {
            Self {
                app: OnceCell::new(),
                main_window: Cell::new(None),
                app_state: OnceCell::new(),
                master_action_handler: OnceCell::new(),
            }
        }
    }
    
    impl ObjectImpl for AppInitializerImp {
        fn constructed(&self) {
            self.parent_constructed();
            // Initialisiere app_state hier, da es von anderen Komponenten benötigt wird
            let initial_app_state = ApplicationState {
                settings_service: None, // Wird später in on_startup initialisiert
                // Initialisiere andere Felder von ApplicationState
            };
            self.app_state.set(Rc::new(RefCell::new(initial_app_state)))
               .expect("ApplicationState konnte nicht initialisiert werden.");
    
            let action_handler = Rc::new(MasterActionHandler::new());
            self.master_action_handler.set(action_handler)
               .expect("MasterActionHandler konnte nicht initialisiert werden.");
        }
    }
    ```
    
    Die Initialisierung von `ApplicationState` und `MasterActionHandler` in `constructed` stellt sicher, dass diese Kernkomponenten frühzeitig verfügbar sind. `ApplicationState` wird als `Rc<RefCell<ApplicationState>>` gespeichert, um gemeinsam genutzten, veränderlichen Zugriff zu ermöglichen.
    

##### 2.1.4. Eigenschaften

Für den `AppInitializer` selbst sind keine öffentlich exponierten GObject-Eigenschaften vorgesehen, die über die interne Zustandsverwaltung hinausgehen. Der Zustand wird intern durch die Felder in `AppInitializerImp` verwaltet.

##### 2.1.5. Methoden

- **`pub fn new(application_id: &str, flags: gio::ApplicationFlags) -> Self`**
    
    - **Signatur:** `pub fn new(application_id: &str, flags: gio::ApplicationFlags) -> super::AppInitializer`
    - **Zugriffsmodifikator:** `pub`
    - **Parameter:**
        - `application_id`: `&str` – Die eindeutige ID der Applikation (z.B. "org.example.myapp").
        - `flags`: `gio::ApplicationFlags` – Flags zur Konfiguration des Applikationsverhaltens (z.B. `gio::ApplicationFlags::HANDLES_OPEN`).
    - **Rückgabewert:** `super::AppInitializer` – Eine neue Instanz des `AppInitializer`.
    - **Vorbedingungen:** `application_id` darf nicht leer sein und muss einem gültigen Format für Applikations-IDs entsprechen.
    - **Nachbedingungen:** Eine `gtk::Application`-Instanz wurde erstellt und im `AppInitializerImp` gespeichert. Die Signale `startup` und `activate` der `gtk::Application` sind mit den entsprechenden internen Methoden des `AppInitializer` verbunden. Der `AppInitializer` ist bereit, die Applikation auszuführen.
    - **Implementierungslogik (Schritt-für-Schritt):**
        1. Erstelle eine neue `glib::Object`-Instanz vom Typ `super::AppInitializer`. Dies ruft `AppInitializerImp::constructed` auf.
        2. Hole die private Implementierung (`imp`) der erstellten `AppInitializer`-Instanz.
        3. Erstelle die `gtk::Application`:
            
            Rust
            
            ```
            let gtk_app = gtk::Application::builder()
               .application_id(application_id)
               .flags(flags)
               .build();
            ```
            
        4. Speichere `gtk_app` im Feld `imp.app`. Es ist wichtig, `set` nur einmal aufzurufen, da `OnceCell` dies erzwingt.
            
            Rust
            
            ```
            imp.app.set(gtk_app.clone()).expect("gtk::Application konnte nicht gesetzt werden.");
            ```
            
        5. Verbinde das `startup`-Signal der `gtk::Application`. Das Klonen von `app_initializer` ist notwendig, um es in den Closure zu bewegen.
            
            Rust
            
            ```
            let app_initializer_clone_startup = obj.clone(); // obj ist die Self-Instanz
            gtk_app.connect_startup(move |app| {
                app_initializer_clone_startup.imp().on_startup(app);
            });
            ```
            
        6. Verbinde das `activate`-Signal der `gtk::Application`.
            
            Rust
            
            ```
            let app_initializer_clone_activate = obj.clone(); // obj ist die Self-Instanz
            gtk_app.connect_activate(move |app| {
                app_initializer_clone_activate.imp().on_activate(app);
            });
            ```
            
        7. Optional: Registriere die Applikation bei D-Bus, falls dies für die Funktionalität (z.B. Single-Instance-Verhalten über D-Bus) erforderlich ist. Dies geschieht typischerweise im `startup`-Handler, nachdem die Applikation die Kontrolle über die ID erlangt hat.1
            
            Rust
            
            ```
            // Beispielhafte D-Bus Registrierung (kann in on_startup erfolgen)
            // if flags.contains(gio::ApplicationFlags::IS_SERVICE) {
            //     gtk_app.register(None::<&gio::Cancellable>).expect("D-Bus Registrierung fehlgeschlagen");
            // }
            ```
            
        8. Gib die erstellte `AppInitializer`-Instanz zurück.
- **`pub fn run(&self) -> glib::ExitCode`**
    
    - **Signatur:** `pub fn run(&self) -> glib::ExitCode`
    - **Zugriffsmodifikator:** `pub`
    - **Parameter:** Keine.
    - **Rückgabewert:** `glib::ExitCode` – Der Exit-Code der Applikation nach deren Beendigung.
    - **Vorbedingungen:** Die `new`-Methode muss erfolgreich aufgerufen worden sein.
    - **Nachbedingungen:** Die GTK-Applikation wird gestartet und die Hauptschleife betreten. Die Methode blockiert, bis die Applikation beendet wird.
    - **Implementierungslogik (Schritt-für-Schritt):**
        1. Hole die `gtk::Application`-Instanz aus `self.imp().app`.
            
            Rust
            
            ```
            let gtk_app = self.imp().app.get().expect("gtk::Application wurde nicht initialisiert.");
            ```
            
        2. Rufe `gtk_app.run()` auf. Da die GTK-Dokumentation für `gtk_application_run` keine Argumente für `argc` und `argv` in der Rust-Binding-Variante direkt zeigt, wird die parameterlose Variante verwendet, die die Kommandozeilenargumente implizit handhabt.3
            
            Rust
            
            ```
            gtk_app.run()
            ```
            
- **`fn on_startup(&self, app: &gtk::Application)`**
    
    - **Signatur:** `fn on_startup(&self, app: &gtk::Application)`
    - **Zugriffsmodifikator:** Privat (intern von `AppInitializerImp`)
    - **Parameter:**
        - `app`: `&gtk::Application` – Die GTK-Applikationsinstanz.
    - **Rückgabewert:** Keiner.
    - **Vorbedingungen:** Wird vom `startup`-Signal der `gtk::Application` aufgerufen.
    - **Nachbedingungen:** Globale Dienste wie `MasterActionHandler` und `SettingsService` sind initialisiert und konfiguriert. Applikationsweite Aktionen sind registriert.
    - **Implementierungslogik (Schritt-für-Schritt):**
        1. Hole den `MasterActionHandler` aus `self.master_action_handler`.
            
            Rust
            
            ```
            let action_handler = self.master_action_handler.get().expect("MasterActionHandler nicht initialisiert.").clone();
            ```
            
        2. Initialisiere und registriere applikationsweite Aktionen über den `MasterActionHandler`.
            
            Rust
            
            ```
            // Beispiel: action_handler.register_app_action(...);
            // Hier sollten globale Aktionen wie "quit", "about" etc. definiert werden.
            // Siehe Spezifikation für MasterActionHandler (2.4).
            let about_action = gio::SimpleAction::new("about", None);
            let self_clone_for_about = self.clone();
            about_action.connect_activate(move |_, _| {
                self_clone_for_about.show_about_dialog();
            });
            action_handler.register_app_action(app, &about_action);
            ```
            
        3. Initialisiere den `SettingsService`. Der Schema-Name muss mit der gschema.xml-Datei übereinstimmen.
            
            Rust
            
            ```
            let settings_service = SettingsService::new("org.example.myapp")
               .expect("SettingsService konnte nicht initialisiert werden.");
            // Speichere settings_service im ApplicationState
            let app_state = self.app_state.get().expect("ApplicationState nicht initialisiert.");
            app_state.borrow_mut().settings_service = Some(settings_service);
            ```
            
        4. Führe weitere einmalige Initialisierungsaufgaben durch (z.B. Laden von Ressourcen, Konfiguration von Logging).
        5. Stelle sicher, dass die Applikation die Kontrolle über die ID hat, bevor D-Bus-Operationen durchgeführt werden, falls relevant. Die `startup`-Phase ist dafür geeignet.
- **`fn on_activate(&self, app: &gtk::Application)`**
    
    - **Signatur:** `fn on_activate(&self, app: &gtk::Application)`
    - **Zugriffsmodifikator:** Privat (intern von `AppInitializerImp`)
    - **Parameter:**
        - `app`: `&gtk::Application` – Die GTK-Applikationsinstanz.
    - **Rückgabewert:** Keiner.
    - **Vorbedingungen:** Wird vom `activate`-Signal der `gtk::Application` aufgerufen. Dies kann mehrfach geschehen, z.B. wenn versucht wird, eine bereits laufende Instanz erneut zu starten.
    - **Nachbedingungen:** Das Hauptfenster der Applikation (`MainWindow`) wird erstellt (falls noch nicht vorhanden) und angezeigt.
    - **Implementierungslogik (Schritt-für-Schritt):**
        
        1. Überprüfe, ob bereits ein Hauptfenster (`self.main_window`) existiert.
            
            Rust
            
            ```
            if self.main_window.get().is_none() {
                // Hauptfenster existiert noch nicht, erstelle es.
                let app_state = self.app_state.get().expect("ApplicationState nicht initialisiert.").clone();
                let main_window_instance = MainWindow::new(app, app_state);
                self.main_window.set(Some(main_window_instance));
            }
            ```
            
        2. Hole das Hauptfenster (entweder das neu erstellte oder das existierende).
            
            Rust
            
            ```
            let window_to_present = self.main_window.get().clone().expect("Hauptfenster konnte nicht abgerufen werden.");
            ```
            
        3. Zeige das Hauptfenster an und bringe es in den Vordergrund.
            
            Rust
            
            ```
            window_to_present.present();
            ```
            
        
        Die Logik stellt sicher, dass bei wiederholten `activate`-Signalen nicht mehrere Fenster erzeugt werden, sondern das existierende Fenster in den Vordergrund gebracht wird. Dies ist ein typisches Verhalten für Desktop-Applikationen.3
- **`fn show_about_dialog(&self)`**
    
    - **Signatur:** `fn show_about_dialog(&self)`
    - **Zugriffsmodifikator:** Privat (kann aber von einer Action aufgerufen werden)
    - **Parameter:** Keine.
    - **Rückgabewert:** Keiner.
    - **Implementierungslogik (Schritt-für-Schritt):**
        1. Erstelle einen `gtk::AboutDialog`.
            
            Rust
            
            ```
            let about_dialog = gtk::AboutDialog::new();
            ```
            
        2. Setze die Eigenschaften des Dialogs (Programmname, Version, Copyright, Webseite, Autoren etc.). Diese Informationen sollten zentral verwaltet oder aus Build-Informationen bezogen werden.
            
            Rust
            
            ```
            about_dialog.set_program_name("Meine Anwendung");
            about_dialog.set_version(Some("1.0.0"));
            about_dialog.set_copyright(Some("© 2025 Mein Name"));
            about_dialog.set_website(Some("https://example.com"));
            // about_dialog.set_authors(&["Autor 1", "Autor 2"]);
            // about_dialog.set_logo_icon_name(Some("application-x-executable")); // Beispiel Icon
            ```
            
        3. Setze das transiente Elternfenster, falls das Hauptfenster bereits existiert.
            
            Rust
            
            ```
            if let Some(main_window) = self.main_window.get().as_ref() {
                about_dialog.set_transient_for(Some(main_window));
                about_dialog.set_modal(true);
            }
            ```
            
        4. Zeige den Dialog an.
            
            Rust
            
            ```
            about_dialog.present();
            ```
            

##### 2.1.6. Signale

- **Emittierte Signale:** Der `AppInitializer` selbst emittiert keine eigenen GObject-Signale.
- **Behandelte Signale:**
    - `gtk::Application::startup`: Verbunden mit `AppInitializerImp::on_startup`. Dient zur einmaligen Initialisierung der Applikation.
    - `gtk::Application::activate`: Verbunden mit `AppInitializerImp::on_activate`. Dient zur Erstellung und/oder Anzeige des Hauptfensters.

##### 2.1.7. Datenstrukturen

- **`ApplicationState`**
    - **Definition:**
        
        Rust
        
        ```
        // Bereits in imp.rs definiert
        // pub struct ApplicationState {
        //     pub settings_service: Option<SettingsService>,
        //     // Weitere globale Zustände oder Dienste hier
        // }
        ```
        
    - **Attribute:**
        - `settings_service`: `Option<SettingsService>`, `pub` – Hält eine Instanz des `SettingsService` für den Zugriff auf Anwendungseinstellungen. Wird in `on_startup` initialisiert.
    - **Invarianten:** Nach `on_startup` sollte `settings_service` `Some` sein.
    - **Zweck:** Dient als Container für global verfügbare Dienste und Zustandsinformationen, die über `Rc<RefCell<ApplicationState>>` an verschiedene UI-Komponenten weitergegeben werden können. Dies ist eine gängige Methode zur Zustandsverwaltung in GTK-Anwendungen, um Prop-Drilling zu vermeiden und einen zentralen Zugriffspunkt für gemeinsam genutzte Daten zu schaffen.5

##### 2.1.8. UI Layout und Styling

Nicht anwendbar, da `AppInitializer` ein nicht-visueller Service ist.

##### 2.1.9. Exception Handling / Error Types

Fehler bei der Initialisierung (z.B. Laden von Settings, D-Bus-Registrierung) werden über `Result` oder `expect` behandelt. Kritische Fehler während des Starts sollten zum kontrollierten Beenden der Applikation führen.

##### 2.1.10. Asynchrone Operationen

Der `AppInitializer` führt primär synchrone Operationen während der Startup- und Activate-Phasen aus. Asynchrone Operationen könnten bei der D-Bus-Registrierung oder beim Laden von Ressourcen auftreten, würden aber typischerweise innerhalb der Signalhandler mit `glib::MainContext::block_on` oder durch Spawnen auf den Main-Context gehandhabt, falls sie nicht blockierend sein dürfen.

##### 2.1.11. Abhängigkeiten

- `MainWindow`: Für die Erstellung des Hauptfensters.
- `MasterActionHandler`: Für die Registrierung globaler Aktionen.
- `SettingsService`: Für den Zugriff auf und die Initialisierung von Anwendungseinstellungen.
- `gtk::Application`, `gtk::gio`, `gtk::glib`.

##### 2.1.12. Testplan

- **Unit-Tests:**
    - Verifiziere, dass `new()` eine gültige `AppInitializer`-Instanz zurückgibt und die `gtk::Application` korrekt konfiguriert ist (ID, Flags).
    - Teste das Verhalten von `on_startup` (Mocking von Abhängigkeiten wie `SettingsService` könnte notwendig sein, um die korrekte Initialisierung zu überprüfen).
    - Teste das Verhalten von `on_activate`:
        - Erstellt `MainWindow` beim ersten Aufruf.
        - Zeigt existierende `MainWindow` bei nachfolgenden Aufrufen an.
- **Integrationstests:**
    - Simuliere den Applikationsstart und überprüfe, ob das Hauptfenster erscheint.
    - Teste die Reaktion auf mehrfache Aktivierungssignale.
    - Überprüfe die korrekte Registrierung von D-Bus-Diensten (falls implementiert).

#### 2.2. `MainWindow` (Benutzerdefiniertes GTK Widget)

##### 2.2.1. Übersicht und Zweck

Das `MainWindow` ist das Hauptfenster der Applikation und dient als primärer Container für alle anderen UI-Elemente. Es definiert die grundlegende Layoutstruktur, typischerweise bestehend aus einer Seitenleiste für die Navigation, einem Hauptinhaltsbereich und einem Integrationspunkt für die Befehlspalette. Als Unterklasse von `gtk::ApplicationWindow` integriert es sich nahtlos in den Lebenszyklus der `gtk::Application`.3 Die Verwendung eines benutzerdefinierten Widgets für das Hauptfenster ermöglicht eine bessere Kapselung der fensterspezifischen Logik und des Layouts.

##### 2.2.2. Dateistruktur

- `src/app_shell/main_window/mod.rs`: Öffentliches Modul und Wrapper-Definition.
- `src/app_shell/main_window/imp.rs`: Private Implementierungsdetails und GObject-Subklassifizierung.
- `resources/ui/main_window.ui`: (Optional) UI-Definitionsdatei für das Fensterlayout, falls Composite Templates verwendet werden.

##### 2.2.3. GObject-Definition

- **Wrapper-Typ:**
    
    Rust
    
    ```
    // In src/app_shell/main_window/mod.rs
    use gtk::glib;
    use gtk::subclass::prelude::*;
    use gtk::{gio, ApplicationWindow, Widget}; // Weitere Imports nach Bedarf
    use std::rc::Rc;
    use std::cell::RefCell;
    use crate::app_shell::app_initializer::ApplicationState; // Pfad anpassen
    
    glib::wrapper! {
        pub struct MainWindow(ObjectSubclass<imp::MainWindowImp>)
            @extends ApplicationWindow, gtk::Window, Widget,
            @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible,
                        gtk::Buildable, gtk::ConstraintTarget, gtk::Native,
                        gtk::Root, gtk::ShortcutManager;
    }
    ```
    
    Die Implementierung der zahlreichen Interfaces (`gio::ActionGroup`, `gio::ActionMap`, etc.) wird durch `glib::wrapper!` und die Vererbung von `gtk::ApplicationWindow` bereitgestellt.7
    
- **Implementierungs-Struktur (`imp`):**
    
    Rust
    
    ```
    // In src/app_shell/main_window/imp.rs
    use gtk::glib::{self, Properties};
    use gtk::subclass::prelude::*;
    use gtk::{
        ApplicationWindow, Box as GtkBox, Revealer, CompositeTemplate, TemplateChild,
        gio
    };
    use std::cell::{Cell, RefCell};
    use std::rc::Rc;
    use crate::app_shell::app_initializer::ApplicationState; // Pfad anpassen
    use crate::app_shell::command_palette::CommandPaletteWidget; // Annahme
    use crate::app_shell::sidebar::SidebarNavigationWidget; // Annahme
    use crate::app_shell::content_view::ContentViewManager; // Annahme
    
    
    #
    #[template(resource = "/org/example/myapp/main_window.ui")] // Pfad zur UI-Datei
    #[properties(wrapper_type = super::MainWindow)]
    pub struct MainWindowImp {
        #[template_child]
        pub main_box: TemplateChild<GtkBox>,
    
        #[template_child]
        pub content_area_box: TemplateChild<GtkBox>, // Container für Sidebar und Content
    
        #[template_child]
        pub command_palette_revealer: TemplateChild<Revealer>,
    
        #[template_child]
        pub command_palette_widget: TemplateChild<CommandPaletteWidget>, // Instanz der CommandPalette
    
        // Interner Zustand
        #[property(get, set, name = "is-command-palette-visible", nick="Command Palette Visible", blurb="Whether the command palette is currently visible", default=false)]
        is_command_palette_visible_prop: Cell<bool>,
    
        app_state: RefCell<Option<Rc<RefCell<ApplicationState>>>>,
        actions: gio::SimpleActionGroup,
    }
    
    #[glib::object_subclass]
    impl ObjectSubclass for MainWindowImp {
        const NAME: &'static str = "MyMainWindow";
        type Type = super::MainWindow;
        type ParentType = ApplicationWindow;
    
        fn class_init(klass: &mut Self::Class) {
            // UI-Template binden
            klass.bind_template();
            // Template Callbacks binden, falls vorhanden
            // klass.bind_template_callbacks();
        }
    
        fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
            obj.init_template();
        }
    }
    
    #[glib::derived_properties]
    impl ObjectImpl for MainWindowImp {
        fn constructed(&self) {
            self.parent_constructed();
    
            // Aktionen initialisieren und hinzufügen
            self.obj().setup_actions();
            self.obj().setup_keyboard_shortcuts();
    
            // Command Palette initialisieren und zum Revealer hinzufügen
            // self.command_palette_revealer.set_child(Some(&*self.command_palette_widget));
            // Die obige Zeile ist nicht notwendig, wenn command_palette_widget als Kind von
            // command_palette_revealer in der.ui Datei definiert ist.
    
            // Initialisiere Sidebar und Content View Manager und füge sie zum content_area_box hinzu
            // let sidebar = SidebarNavigationWidget::new(self.app_state.borrow().as_ref().unwrap().clone());
            // let content_manager = ContentViewManager::new(self.app_state.borrow().as_ref().unwrap().clone());
            // self.content_area_box.append(&sidebar);
            // self.content_area_box.append(&content_manager);
            // Diese Initialisierung sollte idealerweise in der UI-Datei oder durch Template-Callbacks erfolgen,
            // um die Logik hier sauber zu halten.
        }
    }
    
    impl WidgetImpl for MainWindowImp {
        // Überschreibe size_allocate, falls notwendig für benutzerdefinierte Layout-Logik
    }
    
    impl WindowImpl for MainWindowImp {
        // Behandle Fensterzustandsänderungen, z.B. Schließen-Anfrage
        fn close_request(&self) -> glib::Propagation {
            // Hier könnte Logik zum Speichern des Zustands oder Bestätigungsdialoge implementiert werden
            println!("Close request received for MainWindow");
            // Um das Schließen tatsächlich zu verhindern:
            // return glib::Propagation::Stop;
            self.parent_close_request()
        }
    }
    impl ApplicationWindowImpl for MainWindowImp {}
    ```
    
    Die Verwendung von `#[derive(Properties)]` und `#[properties(wrapper_type =...)]` ermöglicht die Definition von GObject-Eigenschaften direkt in der `imp`-Struktur.8 Die `#[template_child]`-Annotationen verbinden Felder mit Widgets, die in der UI-Datei definiert sind.10 Die `constructed`-Methode ist der geeignete Ort, um Aktionen einzurichten und initiale UI-Konfigurationen vorzunehmen.7
    
- **UI-Definition (`main_window.ui`):**
    
    XML
    
    ```
    <?xml version="1.0" encoding="UTF-8"?>
    <interface>
      <requires lib="gtk" version="4.0"/>
      <template class="MyMainWindow" parent="GtkApplicationWindow">
        <property name="title" translatable="yes">Meine Anwendung</property>
        <property name="default-width">1024</property>
        <property name="default-height">768</property>
        <child>
          <object class="GtkBox" id="main_box">
            <property name="orientation">vertical</property>
            <child>
              <object class="GtkHeaderBar" id="header_bar">
                </object>
            </child>
            <child>
              <object class="GtkBox" id="content_area_box">
                <property name="orientation">horizontal</property>
                <property name="hexpand">true</property>
                <property name="vexpand">true</property>
                </object>
            </child>
            <child>
              <object class="GtkRevealer" id="command_palette_revealer">
                <property name="transition-type">slide-down</property>
                <property name="transition-duration">250</property>
                <property name="reveal-child">false</property>
                <child>
                  <object class="CommandPaletteWidget" id="command_palette_widget"/>
                </child>
              </object>
            </child>
          </object>
        </child>
      </template>
    </interface>
    ```
    
    Die UI-Datei definiert die Struktur des Fensters. `TemplateChild`-Felder in `MainWindowImp` werden mit den Widgets mit den entsprechenden IDs (`main_box`, `command_palette_revealer`, etc.) verbunden. Die Verwendung von UI-Templates fördert die Trennung von UI-Definition und Logik.10
    

##### 2.2.4. Eigenschaften

- **`is-command-palette-visible`**:
    - **GObject-Name:** `is-command-palette-visible`
    - **Rust-Typ:** `bool` (intern `Cell<bool>`)
    - **Zugriff:** Lesen/Schreiben (R/W)
    - **Standardwert:** `false`
    - **Beschreibung:** Steuert die Sichtbarkeit des `command_palette_revealer`. Änderungen an dieser Eigenschaft lösen ein `notify::is-command-palette-visible`-Signal aus.
    - **Implementierung:** Die Eigenschaft wird durch das `#[property(...)]`-Makro auf `is_command_palette_visible_prop` in `MainWindowImp` generiert. Der Getter liest aus `is_command_palette_visible_prop`. Der Setter schreibt in `is_command_palette_visible_prop` und ruft `self.obj().notify("is-command-palette-visible")` auf, sowie `self.command_palette_revealer.set_reveal_child(new_value)`.

##### 2.2.5. Methoden

- **`pub fn new(app: &gtk::Application, app_state: Rc<RefCell<ApplicationState>>) -> Self`**
    
    - **Signatur:** `pub fn new(app: &gtk::Application, app_state: Rc<RefCell<ApplicationState>>) -> Self`
    - **Zugriffsmodifikator:** `pub`
    - **Parameter:**
        - `app`: `&gtk::Application` – Die Hauptapplikationsinstanz.
        - `app_state`: `Rc<RefCell<ApplicationState>>` – Der globale Anwendungszustand.
    - **Rückgabewert:** `Self` – Eine neue Instanz von `MainWindow`.
    - **Vorbedingungen:** `app` und `app_state` sind gültige, initialisierte Instanzen.
    - **Nachbedingungen:** Ein neues `MainWindow` wird erstellt, mit der Applikation verknüpft und der `app_state` intern gespeichert.
    - **Implementierungslogik (Schritt-für-Schritt):**
        1. Erstelle das Objekt mit `glib::Object::builder().property("application", app).build()`.
        2. Hole die `imp`-Struktur des neu erstellten Fensters.
        3. Speichere `app_state` in `imp.app_state.borrow_mut().replace(app_state);`.
- **`pub fn toggle_command_palette(&self)`**
    
    - **Signatur:** `pub fn toggle_command_palette(&self)`
    - **Zugriffsmodifikator:** `pub`
    - **Parameter:** Keine.
    - **Rückgabewert:** Keiner.
    - **Vorbedingungen:** Das `MainWindow` und seine internen Widgets (`command_palette_revealer`, `command_palette_widget`) sind initialisiert.
    - **Nachbedingungen:** Die Sichtbarkeit der Befehlspalette wird umgeschaltet. Die Eigenschaft `is-command-palette-visible` wird aktualisiert und das Signal `command_palette_toggled` wird emittiert.
    - **Implementierungslogik (Schritt-für-Schritt):**
        1. Hole die `imp`-Struktur.
        2. Lese den aktuellen Zustand von `imp.command_palette_revealer.reveals_child()`.
        3. Setze den neuen Zustand: `imp.command_palette_revealer.set_reveal_child(!current_state)`.
        4. Aktualisiere die Eigenschaft: `self.set_is_command_palette_visible(!current_state)`. Dies löst automatisch das `notify`-Signal für die Eigenschaft aus.
        5. Wenn die Palette sichtbar wird, setze den Fokus auf das Eingabefeld der `CommandPaletteWidget`: `imp.command_palette_widget.grab_focus_entry();` (Annahme: `grab_focus_entry` ist eine Methode von `CommandPaletteWidget`).
        6. Emittiere das `command_palette_toggled`-Signal: `self.emit_by_name::<()>("command-palette-toggled", &[&!current_state]);`.
- **`fn setup_actions(&self)`** (Privat, aufgerufen in `constructed`)
    
    - **Signatur:** `fn setup_actions(&self)`
    - **Implementierungslogik:**
        1. Erstelle `gio::SimpleActionGroup`.
        2. Definiere Aktionen spezifisch für das Fenster (z.B. "toggle-command-palette").
            
            Rust
            
            ```
            let imp = self.imp();
            let toggle_cp_action = gio::SimpleAction::new("toggle-command-palette", None);
            let window_clone = self.clone();
            toggle_cp_action.connect_activate(move |_, _| {
                window_clone.toggle_command_palette();
            });
            imp.actions.add_action(&toggle_cp_action);
            ```
            
        3. Füge die `SimpleActionGroup` zum Fenster hinzu: `self.insert_action_group("win", Some(&imp.actions));`. Der Präfix "win" ist Konvention für fensterspezifische Aktionen.12
- **`fn setup_keyboard_shortcuts(&self)`** (Privat, aufgerufen in `constructed`)
    
    - **Signatur:** `fn setup_keyboard_shortcuts(&self)`
    - **Implementierungslogik:**
        
        1. Definiere Tastenkürzel für Fensteraktionen. Zum Beispiel `Ctrl+P` für die Befehlspalette.
            
            Rust
            
            ```
            let app = self.application().expect("Anwendung nicht gefunden für MainWindow");
            app.set_accels_for_action("win.toggle-command-palette", &["<Primary>P"]);
            // Weitere Kürzel hier definieren
            ```
            
        
        Die Aktionen müssen bereits in der `gio::ActionGroup` des Fensters (hier "win") registriert sein.12

##### 2.2.6. Signale

- **Emittierte Signale:**
    
    - **Signal Name:** `command-palette-toggled`
        - **GObject Name:** `command-palette-toggled`
        - **Parameter:**
            - `visible`: `bool` (Rust), `glib::VariantType::BOOLEAN` (`glib::Variant`) – Gibt an, ob die Palette sichtbar (`true`) oder unsichtbar (`false`) wurde.
        - **Beschreibung:** Wird emittiert, nachdem die Sichtbarkeit der Befehlspalette geändert wurde.
        - **Definition in `ObjectImpl::signals()`:**
            
            Rust
            
            ```
            // In MainWindowImp
            fn signals() -> &'static {
                static SIGNALS: OnceCell<Vec<glib::subclass::Signal>> = OnceCell::new();
                SIGNALS.get_or_init(|| {
                    vec!)
                           .build(),
                    ]
                })
            }
            ```
            
            Die Definition von Signalen erfolgt typischerweise in der `ObjectImpl` der Implementierungsstruktur.11
- **Behandelte Signale:**
    
    - Verbindungen zu Signalen von Kind-Widgets (z.B. `command_palette_widget.command-executed`) werden intern in `constructed` oder bei der Initialisierung der Kind-Widgets eingerichtet.

##### 2.2.7. Datenstrukturen

Keine spezifischen öffentlichen Datenstrukturen, die von `MainWindow` direkt exponiert werden, außer den GObject-Eigenschaften. Der `ApplicationState` wird intern referenziert.

##### 2.2.8. UI Layout und Styling

- **Widget-Hierarchie:**
    - `MyMainWindow` (`gtk::ApplicationWindow`)
        - `main_box` (`gtk::Box`, vertikal)
            - `header_bar` (`gtk::HeaderBar`) (optional, falls nicht CSD)
            - `content_area_box` (`gtk::Box`, horizontal)
                - `SidebarNavigationWidget` (benutzerdefiniert, links)
                - `ContentViewManager` (benutzerdefiniert, rechts, `hexpand=true`)
            - `command_palette_revealer` (`gtk::Revealer`)
                - `command_palette_widget` (`CommandPaletteWidget`, benutzerdefiniert)
- **Layout Manager:** Primär `gtk::Box` für die Hauptstrukturierung.
- **CSS-Klassen und -Namen:**
    - `MainWindow`: CSS-Name `main-window`.
    - `content_area_box`: CSS-Klasse `content-area`.
    - `sidebar_nav` (falls als TemplateChild): CSS-Klasse `sidebar-navigation`.
    - `command_palette_revealer`: CSS-Klasse `command-palette-container`. Styling erfolgt über eine zentrale CSS-Datei, die von der Applikation geladen wird. Spezifische Stile für `MainWindow` und seine Hauptbereiche werden über diese Klassen und Namen ermöglicht.14

##### 2.2.9. Exception Handling / Error Types

Fehler bei der UI-Erstellung (z.B. Laden der UI-Datei) sollten durch `expect` oder `Result` behandelt und geloggt werden. Laufzeitfehler sind typischerweise unwahrscheinlich, es sei denn, es gibt Probleme mit Kind-Widgets.

##### 2.2.10. Asynchrone Operationen

Das `MainWindow` selbst führt keine langlaufenden asynchronen Operationen durch. Es kann jedoch UI-Aktualisierungen als Reaktion auf Ereignisse von asynchronen Diensten (via `ApplicationState` und `AsyncUIManager`) durchführen.

##### 2.2.11. Abhängigkeiten

- `CommandPaletteWidget`: Für die Anzeige und Interaktion mit der Befehlspalette.
- `SidebarNavigationWidget`: Für die Hauptnavigation (Spezifikation folgt).
- `ContentViewManager`: Für die Verwaltung und Anzeige verschiedener Inhaltsansichten (Spezifikation folgt).
- `ApplicationState`: Für den Zugriff auf globale Zustände und Dienste.
- `MasterActionHandler`: Für die Verbindung von UI-Elementen mit globalen Aktionen.
- `gtk::Application`, `gtk::ApplicationWindow`, `gtk::Box`, `gtk::Revealer`, `gtk::gio`.

##### 2.2.12. Testplan

- **Unit-Tests:**
    - Teste die Erstellung des `MainWindow`.
    - Teste die `toggle_command_palette`-Methode:
        - Sichtbarkeit des `command_palette_revealer` ändert sich korrekt.
        - Eigenschaft `is-command-palette-visible` wird aktualisiert.
        - Signal `command_palette_toggled` wird mit korrektem Parameter emittiert.
    - Überprüfe die korrekte Einrichtung der Aktionen (`win.toggle-command-palette`).
- **Integrationstests (mit GTK-Testumgebung):**
    - Überprüfe das korrekte Laden der UI-Datei (falls verwendet).
    - Teste die Reaktion auf das Tastenkürzel zum Öffnen der Befehlspalette.
    - Teste das Schließen des Fensters und die korrekte Ausführung von `close_request`.

#### 2.3. `CommandPaletteWidget` (Benutzerdefiniertes GTK Widget)

##### 2.3.1. Übersicht und Zweck

Das `CommandPaletteWidget` ist eine zentrale UI-Komponente, die es Benutzern ermöglicht, schnell nach Befehlen, Aktionen oder anderen navigierbaren Elementen innerhalb der Applikation zu suchen und diese auszuführen. Es verwendet eine Texteingabe mit Fuzzy-Suche, um eine dynamisch gefilterte Liste von Ergebnissen anzuzeigen. Dieses Konzept ist inspiriert von ähnlichen Funktionen in modernen Entwicklungsumgebungen und Produktivitätswerkzeugen.15 Die Palette wird typischerweise als Pop-up oder einblendbares Element (`gtk::Revealer`) im `MainWindow` integriert.

##### 2.3.2. Dateistruktur

- `src/app_shell/command_palette/mod.rs`: Öffentliches Modul und Wrapper-Definition.
- `src/app_shell/command_palette/imp.rs`: Private Implementierungsdetails und GObject-Subklassifizierung.
- `src/app_shell/command_palette/fuzzy_searcher.rs`: Modul für die Fuzzy-Suchlogik.
- `src/app_shell/command_palette/item.rs`: Definition des `CommandPaletteItem`-GObjects.
- `resources/ui/command_palette_widget.ui`: (Optional) UI-Definitionsdatei.
- `resources/ui/command_palette_item.ui`: (Optional) UI-Definitionsdatei für ein einzelnes Listenelement.

##### 2.3.3. GObject-Definition

- **Wrapper-Typ:**
    
    Rust
    
    ```
    // In src/app_shell/command_palette/mod.rs
    use gtk::glib;
    use gtk::subclass::prelude::*;
    use gtk::{Box as GtkBox, Widget}; // Weitere Imports nach Bedarf
    use crate::app_shell::action_handler::MasterActionHandler; // Annahme
    use std::rc::Rc;
    
    glib::wrapper! {
        pub struct CommandPaletteWidget(ObjectSubclass<imp::CommandPaletteWidgetImp>)
            @extends GtkBox, Widget,
            @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Orientable;
    }
    
    impl CommandPaletteWidget {
        pub fn new(action_handler: Rc<MasterActionHandler>) -> Self {
            let widget: Self = glib::Object::builder().build();
            widget.imp().action_handler.set(Some(action_handler)).expect("ActionHandler konnte nicht gesetzt werden");
            widget
        }
    
        pub fn grab_focus_entry(&self) {
            self.imp().search_entry.grab_focus();
        }
    }
    ```
    
- **Implementierungs-Struktur (`imp`):**
    
    Rust
    
    ```
    // In src/app_shell/command_palette/imp.rs
    use gtk::glib::{self, Properties, Propagation, Variant};
    use gtk::prelude::*;
    use gtk::subclass::prelude::*;
    use gtk::{
        Box as GtkBox, SearchEntry, ListView, ScrolledWindow, SignalListItemFactory,
        ListItem, SingleSelection, FilterListModel, CustomFilter, NoSelection,
        gio, Orientation, Align,
    };
    use std::cell::{Cell, OnceCell, RefCell};
    use std::rc::Rc;
    use crate::app_shell::action_handler::MasterActionHandler;
    use super::fuzzy_searcher::{FuzzySearchAlgorithm, FuzzySearcher}; // Annahme
    use super::item::CommandPaletteItem; // Annahme
    
    #
    #[template(resource = "/org/example/myapp/command_palette_widget.ui")]
    #[properties(wrapper_type = super::CommandPaletteWidget)]
    pub struct CommandPaletteWidgetImp {
        #[template_child]
        pub search_entry: TemplateChild<SearchEntry>,
    
        #[template_child]
        pub results_scrolled_window: TemplateChild<ScrolledWindow>,
    
        #[template_child]
        pub results_list_view: TemplateChild<ListView>,
    
        // Interner Zustand
        list_store: OnceCell<gio::ListStore>, // Speichert CommandPaletteItem GObjects
        filter_model: OnceCell<FilterListModel>,
        selection_model: OnceCell<NoSelection>, // Oder SingleSelection, falls gewünscht
    
        fuzzy_searcher: FuzzySearcher, // Enthält den Algorithmus
        action_handler: OnceCell<Rc<MasterActionHandler>>,
        all_commands: RefCell<Vec<Rc<CommandPaletteItem>>>, // Cache aller verfügbaren Befehle
    }
    
    
    #[glib::object_subclass]
    impl ObjectSubclass for CommandPaletteWidgetImp {
        const NAME: &'static str = "MyCommandPaletteWidget";
        type Type = super::CommandPaletteWidget;
        type ParentType = GtkBox;
    
        fn class_init(klass: &mut Self::Class) {
            klass.bind_template();
            // Template Callbacks für UI-Datei-Events, falls benötigt
            // klass.bind_template_callback("search_entry_search_changed_cb", |widget: &super::CommandPaletteWidget, entry: &SearchEntry| {
            // widget.imp().on_search_changed(entry);
            // });
        }
    
        fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
            obj.init_template();
        }
    }
    
    #[glib::derived_properties]
    impl ObjectImpl for CommandPaletteWidgetImp {
        fn constructed(&self) {
            self.parent_constructed();
            let obj = self.obj(); // Wrapper-Instanz
    
            // Initialisiere list_store
            let store = gio::ListStore::new::<CommandPaletteItem>();
            self.list_store.set(store).expect("ListStore konnte nicht gesetzt werden.");
    
            // Initialisiere FilterListModel
            let filter = CustomFilter::new(|item_obj| {
                // Anfänglich alle Items zulassen, Filterung erfolgt durch Neusetzen der Ergebnisse
                // oder durch eine komplexere Filterlogik, die auf einer Eigenschaft des CommandPaletteItem basiert.
                // Für Fuzzy-Suche ist es oft einfacher, die `list_store` direkt neu zu befüllen.
                // Alternativ: item_obj.downcast_ref::<CommandPaletteItem>().unwrap().is_match() (wenn is_match eine Eigenschaft wäre)
                true
            });
            let filter_model = FilterListModel::new(Some(self.list_store.get().unwrap()), Some(filter));
            self.filter_model.set(filter_model).expect("FilterModel konnte nicht gesetzt werden.");
    
            // Initialisiere SelectionModel
            let selection_model = NoSelection::new(Some(self.filter_model.get().unwrap()));
            // Oder SingleSelection, wenn eine Auswahl gewünscht ist:
            // let selection_model = SingleSelection::new(Some(self.filter_model.get().unwrap()));
            self.selection_model.set(selection_model).expect("SelectionModel konnte nicht gesetzt werden.");
    
            // Konfiguriere ListView
            let factory = SignalListItemFactory::new();
            factory.connect_setup(move |_, list_item_gtk| {
                // Erstelle das Widget für ein Listenelement (z.B. eine GtkBox mit Icon und Label)
                // Dies kann auch über eine.ui-Datei für das ListItem geschehen (BuilderListItemFactory)
                let item_widget = gtk::Label::new(None); // Vereinfachtes Beispiel
                item_widget.set_halign(Align::Start);
                list_item_gtk.set_child(Some(&item_widget));
            });
    
            factory.connect_bind(move |_, list_item_gtk| {
                let list_item_gtk = list_item_gtk.downcast_ref::<ListItem>().expect("Muss ListItem sein");
                let command_item = list_item_gtk.item()
                   .and_downcast::<CommandPaletteItem>()
                   .expect("Item muss CommandPaletteItem sein");
    
                let child_widget = list_item_gtk.child().and_downcast::<gtk::Label>().expect("Child muss Label sein");
                // Binde Eigenschaften von command_item an child_widget
                // Hier nur der Name als Beispiel
                child_widget.set_label(&command_item.display_name());
    
                // Hier könnte man auch ein komplexeres Widget binden, das Icon etc. anzeigt
            });
    
            self.results_list_view.set_model(Some(self.selection_model.get().unwrap()));
            self.results_list_view.set_factory(Some(&factory));
    
            // Signale verbinden
            self.search_entry.connect_search_changed(glib::clone!(@weak obj => move |entry| {
                obj.imp().on_search_changed(entry);
            }));
    
            // Aktivierung eines Eintrags in der ListView
            self.results_list_view.connect_activate(glib::clone!(@weak obj => move |list_view, position| {
                obj.imp().on_item_activated(list_view, position);
            }));
    
            // Tastaturnavigation für ListView und SearchEntry
            self.setup_keyboard_navigation();
    
    
            // Lade initial alle verfügbaren Befehle
            self.load_all_commands();
        }
    }
    
    impl WidgetImpl for CommandPaletteWidgetImp {
        fn grab_focus(&self) -> bool {
            self.search_entry.grab_focus()
        }
    }
    impl BoxImpl for CommandPaletteWidgetImp {}
    
    // Private Methoden für CommandPaletteWidgetImp
    impl CommandPaletteWidgetImp {
        fn load_all_commands(&self) {
            let action_handler = self.action_handler.get().expect("ActionHandler nicht verfügbar").clone();
            let mut commands = Vec::new();
    
            // Hier app-weite und fenster-spezifische Aktionen vom MasterActionHandler abrufen
            // und in CommandPaletteItem-Objekte umwandeln.
            // Dies ist eine vereinfachte Darstellung. In einer echten Anwendung
            // müsste MasterActionHandler eine Methode bereitstellen, um beschreibende
            // Informationen über Aktionen zu liefern (Name, Icon, Parameter-Typen etc.).
    
            // Beispielhafte statische Befehle:
            commands.push(Rc::new(CommandPaletteItem::new(
                "quit".to_string(),
                "Anwendung beenden".to_string(),
                Some("application-exit".to_string()),
                "app.quit".to_string(), // Gio Action Name
                None
            )));
            commands.push(Rc::new(CommandPaletteItem::new(
                "about".to_string(),
                "Über diese Anwendung".to_string(),
                Some("help-about".to_string()),
                "app.about".to_string(), // Gio Action Name
                None
            )));
            //... weitere Befehle aus verschiedenen Quellen hinzufügen
    
            *self.all_commands.borrow_mut() = commands;
            self.update_displayed_results(&self.all_commands.borrow());
        }
    
        fn on_search_changed(&self, entry: &SearchEntry) {
            let query = entry.text().to_lowercase();
            if query.is_empty() {
                self.update_displayed_results(&self.all_commands.borrow());
                self.results_scrolled_window.set_visible(false);
            } else {
                let all_cmds = self.all_commands.borrow();
                let filtered_results: Vec<Rc<CommandPaletteItem>> = all_cmds
                   .iter()
                   .filter_map(|item| {
                        // Hier die Fuzzy-Suche anwenden.
                        // Die FuzzySearcher-Klasse sollte eine Methode wie `calculate_score` haben.
                        let score = self.fuzzy_searcher.calculate_score(&item.display_name().to_lowercase(), &query);
                        if score > 0.5 { // Schwellenwert für die Anzeige
                            let mut new_item_data = item.item_data().clone(); // Annahme: CommandPaletteItemData ist Clone
                            new_item_data.score = score;
                            Some(Rc::new(CommandPaletteItem::from_data(new_item_data))) // Erzeuge neues Item mit Score
                        } else {
                            None
                        }
                    })
                   .collect::<Vec<_>>();
    
                // Sortiere nach Score (höchster zuerst)
                // let mut sorted_results = filtered_results;
                // sorted_results.sort_by(|a, b| b.score().partial_cmp(&a.score()).unwrap_or(std::cmp::Ordering::Equal));
                // Da CommandPaletteItem ein GObject ist, kann man nicht einfach sortieren, wenn es schon im Store ist.
                // Besser: Den Store leeren und neu befüllen oder einen SortListModel verwenden.
                // Für dieses Beispiel wird der Store direkt mit gefilterten (aber nicht unbedingt sortierten) Ergebnissen befüllt.
                // Eine robustere Lösung würde einen GtkSortListModel verwenden.
    
                self.update_displayed_results(&filtered_results);
                self.results_scrolled_window.set_visible(!filtered_results.is_empty());
            }
        }
    
        fn update_displayed_results(&self, results: &) {
            let list_store = self.list_store.get().unwrap();
            list_store.remove_all();
            for item_rc in results {
                // Da CommandPaletteItem ein GObject ist, muss es geklont werden, wenn es
                // an mehreren Stellen gehalten wird (z.B. all_commands und list_store).
                // Wenn es nur für den list_store erstellt wird, ist kein Klonen nötig.
                // Hier wird angenommen, dass `results` bereits `Rc<CommandPaletteItem>` enthält.
                // Für `gio::ListStore::append` wird ein Verweis auf das GObject benötigt.
                list_store.append(item_rc.as_ref());
            }
        }
    
        fn on_item_activated(&self, _list_view: &ListView, position: u32) {
            let model = self.filter_model.get().unwrap(); // Oder direkt list_store, wenn kein Filter aktiv
            if let Some(item_obj) = model.item(position) {
                if let Ok(command_item) = item_obj.downcast::<CommandPaletteItem>() {
                    let action_name = command_item.action_name();
                    let param = command_item.action_param_variant(); // Methode, die Option<Variant> zurückgibt
    
                    if let Some(action_handler) = self.action_handler.get() {
                        action_handler.activate_action(&action_name, param.as_ref());
                        self.obj().emit_by_name::<()>("command-executed", &[&action_name, &param]);
                        // Palette ausblenden, typischerweise durch das MainWindow gesteuert
                        if let Some(revealer) = self.obj().parent().and_then(|p| p.downcast::<Revealer>().ok()) {
                             revealer.set_reveal_child(false);
                             let main_window = revealer.ancestor(MainWindow::static_type()).and_then(|a| a.downcast::<MainWindow>().ok());
                             if let Some(mw) = main_window {
                                 mw.set_is_command_palette_visible(false);
                             }
                        } else if let Some(popover) = self.obj().ancestor(gtk::Popover::static_type()).and_then(|p| p.downcast::<gtk::Popover>().ok()){
                            popover.popdown();
                             let main_window = popover.ancestor(MainWindow::static_type()).and_then(|a| a.downcast::<MainWindow>().ok());
                             if let Some(mw) = main_window {
                                 mw.set_is_command_palette_visible(false);
                             }
                        }
                    }
                }
            }
        }
    
        fn setup_keyboard_navigation(&self) {
            let search_entry = self.search_entry.get().unwrap();
            let list_view = self.results_list_view.get().unwrap();
    
            search_entry.add_controller({
                let key_controller = gtk::EventControllerKey::new();
                let list_view_clone = list_view.clone();
                key_controller.connect_key_pressed(move |_, keyval, _, _| {
                    match keyval {
                        gdk::Key::Down => {
                            // Fokus auf ListView setzen und erstes Element auswählen
                            list_view_clone.grab_focus();
                            // Ggf. erstes Element programmatisch auswählen, falls NoSelection verwendet wird
                            // oder die Logik für die Auswahl in SingleSelection anpassen.
                            // Für NoSelection ist dies komplexer, da es keine "aktuelle Auswahl" gibt.
                            // Man könnte den Fokus auf das erste Kind-Widget der ListView setzen.
                            Propagation::Stop
                        }
                        gdk::Key::Escape => {
                            // Palette schließen (durch MainWindow gesteuert)
                             if let Some(revealer) = search_entry.ancestor(gtk::Revealer::static_type()).and_then(|p| p.downcast::<gtk::Revealer>().ok()) {
                                 revealer.set_reveal_child(false);
                                 let main_window = revealer.ancestor(MainWindow::static_type()).and_then(|a| a.downcast::<MainWindow>().ok());
                                 if let Some(mw) = main_window {
                                     mw.set_is_command_palette_visible(false);
                                 }
                             } else if let Some(popover) = search_entry.ancestor(gtk::Popover::static_type()).and_then(|p| p.downcast::<gtk::Popover>().ok()){
                                popover.popdown();
                                 let main_window = popover.ancestor(MainWindow::static_type()).and_then(|a| a.downcast::<MainWindow>().ok());
                                 if let Some(mw) = main_window {
                                     mw.set_is_command_palette_visible(false);
                                 }
                            }
                            Propagation::Stop
                        }
                        _ => Propagation::Proceed,
                    }
                });
                key_controller
            });
    
            // ListView benötigt ebenfalls einen KeyController für Enter/Escape
            list_view.add_controller({
                let key_controller = gtk::EventControllerKey::new();
                let search_entry_clone = search_entry.clone();
                key_controller.connect_key_pressed(move |event_controller_key, keyval, _, _| {
                    let list_view_widget = event_controller_key.widget().unwrap().downcast::<ListView>().unwrap();
                    match keyval {
                        gdk::Key::Return | gdk::Key::KP_Enter => {
                            // Aktiviere das aktuell fokussierte/ausgewählte Element
                            // Dies erfordert, dass SingleSelection verwendet wird und ein Element fokussiert ist.
                            // Die `activate` Signalverbindung oben sollte dies bereits behandeln, wenn
                            // die ListView den Fokus hat und ein Element ausgewählt/aktiviert werden kann.
                            // Hier könnte man explizit die Aktion `list.activate-item` aufrufen.
                            // GtkListView::activate_action ist nicht direkt verfügbar, aber das Signal wird ausgelöst.
                            // Man könnte die aktuelle Cursorposition abfragen und das activate Signal manuell emittieren
                            // oder auf das existierende `activate` Signal vertrauen.
                            Propagation::Stop
                        }
                        gdk::Key::Escape => {
                            search_entry_clone.grab_focus(); // Fokus zurück zum Suchfeld
                            Propagation::Stop
                        }
                        _ => Propagation::Proceed,
                    }
                });
                key_controller
            });
        }
    }
    ```
    
    Die Verwendung von `gio::ListStore` in Kombination mit `gtk::ListView` und `gtk::SignalListItemFactory` ist ein moderner Ansatz in GTK4 zur Darstellung dynamischer Listen.21 `GtkFilterListModel` kann verwendet werden, um die im `ListStore` enthaltenen Elemente basierend auf der Suchanfrage zu filtern, obwohl für eine echte Fuzzy-Suche oft das Neupopulieren des Stores oder ein spezialisierter Filter effektiver ist. Die `fuzzy-search`-Bibliothek 26 bietet Algorithmen wie SymSpell, die hierfür geeignet sind.
    
- **UI-Definition (`command_palette_widget.ui`):**
    
    XML
    
    ```
    <?xml version="1.0" encoding="UTF-8"?>
    <interface>
      <requires lib="gtk" version="4.0"/>
      <template class="MyCommandPaletteWidget" parent="GtkBox">
        <property name="orientation">vertical</property>
        <property name="spacing">6</property>
        <child>
          <object class="GtkSearchEntry" id="search_entry">
            <property name="placeholder-text" translatable="yes">Befehl eingeben...</property>
            <property name="hexpand">true</property>
          </object>
        </child>
        <child>
          <object class="GtkScrolledWindow" id="results_scrolled_window">
            <property name="hscrollbar-policy">never</property>
            <property name="vscrollbar-policy">automatic</property>
            <property name="min-content-height">100</property> <property name="max-content-height">300</property> <property name="vexpand">false</property> <property name="visible">false</property> <child>
              <object class="GtkListView" id="results_list_view">
                <property name="css-classes">results-list</property>
              </object>
            </child>
          </object>
        </child>
      </template>
    </interface>
    ```
    

##### 2.3.4. Eigenschaften

Keine öffentlich exponierten GObject-Eigenschaften. Der interne Zustand wird durch die Felder in `CommandPaletteWidgetImp` verwaltet.

##### 2.3.5. Methoden

- **`pub fn new(action_handler: Rc<MasterActionHandler>) -> Self`** (bereits im Wrapper definiert)
    
    - **Nachbedingungen:** Das Widget ist initialisiert, der `action_handler` ist gespeichert. Die `list_store`, `filter_model`, `selection_model` und `results_list_view` sind konfiguriert. `search_entry` ist mit `on_search_changed` verbunden. `results_list_view` ist mit `on_item_activated` verbunden. Tastaturnavigation ist eingerichtet. Initiale Befehlsliste ist geladen.
- **`pub fn show_palette(&self)`**
    
    - **Signatur:** `pub fn show_palette(&self)`
    - **Zugriffsmodifikator:** `pub`
    - **Nachbedingungen:** Das `search_entry` erhält den Fokus, vorherige Suchanfragen und Ergebnisse werden gelöscht, und die Ergebnisliste wird initial (ggf. leer oder mit allen Befehlen) angezeigt und sichtbar gemacht, falls Ergebnisse vorhanden sind.
    - **Implementierungslogik:**
        1. Hole `imp`.
        2. `imp.search_entry.set_text("")`.
        3. `imp.search_entry.grab_focus()`.
        4. `imp.update_displayed_results(&imp.all_commands.borrow())` (oder leere Liste, je nach gewünschtem Verhalten).
        5. `imp.results_scrolled_window.set_visible(!imp.list_store.get().unwrap().n_items() == 0)`.
- **`pub fn hide_palette(&self)`**
    
    - **Signatur:** `pub fn hide_palette(&self)`
    - **Zugriffsmodifikator:** `pub`
    - **Nachbedingungen:** Die Palette wird ausgeblendet (typischerweise durch das `MainWindow`, das den `Revealer` steuert). Suchfeld wird geleert.
    - **Implementierungslogik:**
        1. Hole `imp`.
        2. `imp.search_entry.set_text("")`.
        3. Die eigentliche Ausblendlogik (z.B. `revealer.set_reveal_child(false)`) sollte vom `MainWindow` gesteuert werden, welches diese Methode aufruft oder auf ein Signal reagiert.
- **`fn on_search_changed(&self, entry: &gtk::SearchEntry)`** (Privat, in `CommandPaletteWidgetImp` implementiert)
    
    - **Implementierungslogik Details:**
        1. Hole den Suchbegriff von `entry.text()`.
        2. Wenn der Suchbegriff leer ist:
            - Zeige alle Befehle oder keine (je nach Designentscheidung). `self.update_displayed_results(&self.all_commands.borrow());`
            - `self.results_scrolled_window.set_visible(!self.list_store.get().unwrap().n_items() == 0);`
            - Beende.
        3. Hole die gecachte Liste aller `CommandPaletteItem`s (`self.all_commands.borrow()`).
        4. Iteriere über `all_commands`:
            - Für jedes Kommando, berechne den Fuzzy-Match-Score mit `self.fuzzy_searcher.calculate_score(&command_item.display_name().to_lowercase(), &query)`. Die `fuzzy-search`-Bibliothek 26 bietet hierfür geeignete Algorithmen.
            - Wenn der Score einen Schwellenwert überschreitet, erstelle ein neues `CommandPaletteItem`-GObject (oder klone das existierende und aktualisiere dessen `score`-Eigenschaft). Füge es zu einer temporären Ergebnisliste hinzu.
        5. Sortiere die temporäre Ergebnisliste nach Score (absteigend).
        6. Aktualisiere `self.list_store` mit den sortierten Ergebnissen mittels `self.update_displayed_results(&sorted_results)`.
        7. `self.results_scrolled_window.set_visible(!sorted_results.is_empty());`
- **`fn on_item_activated(&self, _list_view: &gtk::ListView, position: u32)`** (Privat, in `CommandPaletteWidgetImp` implementiert)
    
    - **Implementierungslogik Details:**
        1. Hole das `CommandPaletteItem`-GObject an der gegebenen `position` aus dem `self.filter_model.get().unwrap()` (oder `self.list_store.get().unwrap()`, falls kein Filtermodell verwendet wird). 27
        2. Extrahiere `action_name` und `action_param` (als `Option<glib::Variant>`) aus dem `CommandPaletteItem`.
        3. Rufe `self.action_handler.get().unwrap().activate_action(&action_name, action_param.as_ref())` auf.
        4. Emittiere das `command_executed`-Signal: `self.obj().emit_by_name::<()>("command-executed", &[&action_name, &action_param]);`.
        5. Veranlasse das Schließen der Palette (z.B. durch ein Signal an `MainWindow` oder direkten Aufruf von `MainWindow::hide_palette`, falls eine Referenz vorhanden ist und dies architektonisch sinnvoll ist. Eine sauberere Methode ist, dass `MainWindow` auf `command-executed` hört und die Palette schließt). Hier wird die Logik aus `setup_keyboard_navigation` für Escape wiederverwendet.

##### 2.3.6. Signale

- **Emittierte Signale:**
    - **Signal Name:** `command-executed`
        - **GObject Name:** `command-executed`
        - **Parameter:**
            - `action_name`: `String` (Rust), `glib::VariantType::STRING` (`glib::Variant`) – Der Name der ausgeführten Aktion.
            - `parameter`: `Option<glib::Variant>` (Rust), `glib::VariantType::VARIANT` (`glib::Variant`) – Der Parameter, mit dem die Aktion ausgeführt wurde (kann `None` sein).
        - **Beschreibung:** Wird emittiert, nachdem ein Befehl aus der Palette erfolgreich ausgewählt und dessen Aktion ausgelöst wurde.
        - **Definition in `ObjectImpl::signals()` (in `CommandPaletteWidgetImp`):**
            
            Rust
            
            ```
            fn signals() -> &'static {
                static SIGNALS: OnceCell<Vec<glib::subclass::Signal>> = OnceCell::new();
                SIGNALS.get_or_init(|| {
                    vec!) // glib::Variant kann None sein
                           .build(),
                    ]
                })
            }
            ```
            

##### 2.3.7. Datenstrukturen

- **`CommandPaletteItem` (GObject)**
    
    - **Datei:** `src/app_shell/command_palette/item.rs`
    - **Wrapper:** `pub struct CommandPaletteItem(ObjectSubclass<imp::CommandPaletteItemImp>)`
    - **Implementierung (`imp`):**
        
        Rust
        
        ```
        // In src/app_shell/command_palette/item/imp.rs
        use gtk::glib::{self, Properties, Variant};
        use gtk::prelude::*;
        use gtk::subclass::prelude::*;
        use std::cell::{Cell, RefCell};
        
        # // Clone für item_data
        #[properties(wrapper_type = super::CommandPaletteItem)]
        pub struct CommandPaletteItemData {
            #
            pub id: RefCell<String>,
            #
            pub display_name: RefCell<String>,
            #[property(get, set, name="icon-name", nick="Icon Name", blurb="Optional icon name for the command")]
            pub icon_name: RefCell<Option<String>>,
            #[property(get, set, name="action-name", nick="Action Name", blurb="gio::Action name to execute")]
            pub action_name: RefCell<String>,
            #[property(get, set, name="action-param", nick="Action Parameter", blurb="Optional parameter for the action")]
            pub action_param: RefCell<Option<Variant>>, // Speichert glib::Variant direkt
            #
            pub score: Cell<f32>,
        }
        
        #
        pub struct CommandPaletteItemImp {
            #[property(get, set)]
            data: RefCell<CommandPaletteItemData>,
        }
        
        
        #[glib::object_subclass]
        impl ObjectSubclass for CommandPaletteItemImp {
            const NAME: &'static str = "MyCommandPaletteItem";
            type Type = super::CommandPaletteItem;
            type ParentType = glib::Object;
        }
        
        // Manuelle Implementierung von ObjectImpl, um Properties von CommandPaletteItemData weiterzuleiten
        // oder #[glib::derived_properties] auf CommandPaletteItemImp verwenden, wenn data direkt Properties hätte.
        // Da data ein RefCell<CommandPaletteItemData> ist und CommandPaletteItemData #[derive(Properties)] hat,
        // benötigen wir eine Brücke oder eine flachere Struktur.
        // Einfacher ist es, die Properties direkt in CommandPaletteItemImp zu definieren, wenn möglich,
        // oder Getter/Setter im Wrapper zu implementieren, die auf `data` zugreifen.
        // Für dieses Beispiel gehen wir davon aus, dass die Properties direkt auf CommandPaletteItemImp definiert werden
        // oder dass der Wrapper entsprechende Zugriffsmethoden bereitstellt.
        // Die #[property] Attribute in CommandPaletteItemData sind für den Fall, dass CommandPaletteItemData selbst
        // als GObject verwendet würde. Hier ist es eingebettet.
        // Eine bessere Struktur wäre, die Felder direkt in CommandPaletteItemImp zu haben und dort #[property] zu verwenden.
        // Wir passen das an, um die Properties direkt im GObject zu haben:
        
        // In src/app_shell/command_palette/item/imp.rs (angepasst)
        //... imports...
        #
        #[properties(wrapper_type = super::CommandPaletteItem)]
        pub struct CommandPaletteItemImp {
            #
            pub id: RefCell<String>,
            #
            pub display_name: RefCell<String>,
            #[property(get, set, name="icon-name", nick="Icon Name", blurb="Optional icon name for the command")]
            pub icon_name: RefCell<Option<String>>,
            #[property(get, set, name="action-name", nick="Action Name", blurb="gio::Action name to execute")]
            pub action_name: RefCell<String>,
            #[property(get, set, name="action-param-variant", nick="Action Parameter Variant", blurb="Optional parameter for the action as GVariant")]
            pub action_param_variant: RefCell<Option<Variant>>,
            #
            pub score: Cell<f32>,
        }
        
        #[glib::object_subclass]
        impl ObjectSubclass for CommandPaletteItemImp {
            const NAME: &'static str = "MyCommandPaletteItem";
            type Type = super::CommandPaletteItem;
            type ParentType = glib::Object;
        }
        
        #[glib::derived_properties]
        impl ObjectImpl for CommandPaletteItemImp {}
        ```
        
    - **Wrapper-Methoden für `CommandPaletteItem` (in `item/mod.rs`):**
        
        Rust
        
        ```
        // In src/app_shell/command_palette/item/mod.rs
        use gtk::glib::{self, Variant};
        use gtk::subclass::prelude::*;
        
        mod imp;
        
        glib::wrapper! {
            pub struct CommandPaletteItem(ObjectSubclass<imp::CommandPaletteItemImp>)
                @extends glib::Object;
        }
        
        impl CommandPaletteItem {
            pub fn new(
                id: String,
                display_name: String,
                icon_name: Option<String>,
                action_name: String,
                action_param: Option<Variant>,
            ) -> Self {
                glib::Object::builder()
                   .property("item-id", &id)
                   .property("display-name", &display_name)
                   .property("icon-name", &icon_name)
                   .property("action-name", &action_name)
                   .property("action-param-variant", &action_param)
                   .build()
            }
            // Getter für die Properties werden durch #[glib::derived_properties] und #[property(get)] generiert.
            // z.B. self.item_id(), self.display_name() etc.
        }
        ```
        
    - Die Verwendung eines dedizierten GObject für Listeneinträge ist notwendig für `gio::ListStore` und ermöglicht saubere Datenbindung und Property-Management.23
- **`FuzzySearchAlgorithm` Enum (in `fuzzy_searcher.rs`):**
    
    Rust
    
    ```
    pub enum FuzzySearchAlgorithm {
        Levenshtein,
        SymSpell, // Von fuzzy-search crate [26]
        // Weitere Algorithmen...
    }
    
    pub struct FuzzySearcher {
        algorithm: FuzzySearchAlgorithm,
        // Ggf. initialisierte Strukturen für den gewählten Algorithmus, z.B. SymSpell Dictionary
    }
    
    impl FuzzySearcher {
        pub fn new(algorithm: FuzzySearchAlgorithm) -> Self {
            // Initialisiere den Sucher basierend auf dem Algorithmus
            Self { algorithm, /*... */ }
        }
    
        pub fn calculate_score(&self, text: &str, query: &str) -> f32 {
            match self.algorithm {
                FuzzySearchAlgorithm::Levenshtein => {
                    let distance = levenshtein::levenshtein(query, text);
                    // Konvertiere Distanz in einen Score (z.B. 1.0 - (distance / max_len))
                    // Je höher der Score, desto besser der Match.
                    // Dies ist eine einfache Heuristik.
                    let max_len = std::cmp::max(text.len(), query.len()) as f32;
                    if max_len == 0.0 { return if query == text {1.0} else {0.0}; }
                    1.0 - (distance as f32 / max_len)
                }
                FuzzySearchAlgorithm::SymSpell => {
                    // Verwendung der fuzzy-search crate [26]
                    // Die Crate gibt typischerweise direkt passende Strings oder Distanzen zurück.
                    // Hier müsste eine Adaption erfolgen, um einen Score zu erhalten.
                    // Beispiel: Wenn ein Match gefunden wird, Score > 0.5, sonst 0.
                    // Die `fuzzy-search` Crate bietet `levenshtein` als Funktion.
                    // Für SymSpell müsste man die `SymSpell::lookup` Methode verwenden und die Ergebnisse interpretieren.
                    // Für dieses Beispiel wird Levenshtein als Fallback verwendet, wenn SymSpell nicht direkt einen Score liefert.
                    let distance = levenshtein::levenshtein(query, text);
                    let max_len = std::cmp::max(text.len(), query.len()) as f32;
                    if max_len == 0.0 { return if query == text {1.0} else {0.0}; }
                    1.0 - (distance as f32 / max_len)
                }
            }
        }
    }
    ```
    
- **Tabelle: `CommandPaletteItem` Eigenschaften**
    

|   |   |   |   |   |
|---|---|---|---|---|
|**Eigenschaftsname (GObject)**|**Rust-Feld (Imp)**|**Rust-Typ**|**Standardwert**|**Beschreibung**|
|`item-id`|`id`|`RefCell<String>`|`""`|Eindeutige ID des Befehlseintrags.|
|`display-name`|`display_name`|`RefCell<String>`|`""`|Für den Benutzer sichtbarer Name des Befehls.|
|`icon-name`|`icon_name`|`RefCell<Option<String>>`|`None`|Optionaler Icon-Name für den Befehl (gemäß Freedesktop Icon Naming Spec).|
|`action-name`|`action_name`|`RefCell<String>`|`""`|Der Name der `gio::Action`, die ausgeführt werden soll.|
|`action-param-variant`|`action_param_variant`|`RefCell<Option<Variant>>`|`None`|Optionaler Parameter für die Aktion, als `glib::Variant`.|
|`score`|`score`|`Cell<f32>`|`0.0`|Score des Fuzzy-Suchalgorithmus für diesen Eintrag (höher ist besser).|

```
Diese Tabelle dokumentiert die Struktur der `CommandPaletteItem`-Objekte, die in der Ergebnisliste angezeigt werden. Sie ist entscheidend für Entwickler, die neue Befehle zur Palette hinzufügen oder das Verhalten der Palette anpassen möchten.
```

##### 2.3.8. UI Layout und Styling

- **Widget-Hierarchie:** (Wie in `command_palette_widget.ui` definiert)
    - `MyCommandPaletteWidget` (`gtk::Box`, vertikal, `spacing=6`)
        - `search_entry` (`gtk::SearchEntry`, `hexpand=true`, `placeholder-text="Befehl eingeben..."`)
        - `results_scrolled_window` (`gtk::ScrolledWindow`, `hscrollbar-policy=never`, `vscrollbar-policy=automatic`, `min-content-height`, `max-content-height`, `vexpand=false`, `visible=false`)
            - `results_list_view` (`gtk::ListView`, CSS-Klasse `results-list`)
- **Styling:**
    - `CommandPaletteWidget`: CSS-Name `command-palette`.
    - `search_entry`: Standard-Styling oder CSS-Klasse `command-palette-search-entry`.
    - `results_list_view`: CSS-Klasse `results-list`.
    - `ListItem`-Widgets (in der Factory erstellt): CSS-Klasse `command-palette-item`. Aktive/Hover-Zustände können über CSS definiert werden. Die Verwendung von `vexpand=false` für das `ScrolledWindow` und `min/max-content-height` stellt sicher, dass die Ergebnisliste nicht den gesamten verfügbaren Platz einnimmt, sondern sich dynamisch bis zu einer maximalen Höhe anpasst.

##### 2.3.9. Exception Handling / Error Types

Fehler bei der Interaktion mit dem `MasterActionHandler` oder bei der D-Bus-Kommunikation (falls Aktionen über D-Bus ausgelöst werden) sollten abgefangen und geloggt werden. UI-Fehler (z.B. fehlerhafte Item-Erstellung) sollten ebenfalls behandelt werden.

##### 2.3.10. Asynchrone Operationen

Die Fuzzy-Suche selbst könnte bei sehr vielen Befehlen potenziell blockierend sein. Falls dies der Fall ist, sollte die Suchlogik in `on_search_changed` in einen separaten Thread oder eine asynchrone Aufgabe ausgelagert werden, die dann die `list_store` über den `AsyncUIManager` aktualisiert. Für die typische Anzahl von Befehlen in einer Palette ist dies jedoch oft nicht notwendig.

##### 2.3.11. Abhängigkeiten

- `MasterActionHandler`: Zum Abrufen verfügbarer Aktionen und zum Auslösen ausgewählter Aktionen.
- `fuzzy-search` Crate (oder eine ähnliche Bibliothek) für die Fuzzy-Suchlogik.26
- `gtk::SearchEntry`, `gtk::ListView`, `gtk::ScrolledWindow`, `gio::ListStore`, `gtk::FilterListModel`, `gtk::SignalListItemFactory`.

##### 2.3.12. Testplan

- **Unit-Tests (`fuzzy_searcher.rs`):**
    - Teste verschiedene Suchanfragen gegen eine bekannte Menge von Befehlsnamen.
    - Überprüfe Korrektheit der Scores und der Sortierung.
    - Teste Randfälle (leere Query, keine Treffer, exakte Treffer).
- **Unit-Tests (`CommandPaletteItem`):**
    - Teste Erstellung und Property-Zugriff.
- **Widget-Tests (`CommandPaletteWidget` mit GTK-Testumgebung):**
    - Teste `show_palette()` und `hide_palette()` (indirekt über `MainWindow`).
    - Simuliere Texteingabe in `search_entry` und überprüfe:
        - Korrekte Filterung und Anzeige der Ergebnisse in `results_list_view`.
        - Korrekte Sortierung der Ergebnisse.
        - Sichtbarkeit des `results_scrolled_window`.
    - Simuliere Item-Aktivierung (`results_list_view.activate`) und überprüfe:
        - Aufruf von `MasterActionHandler::activate_action` mit korrekten Parametern.
        - Emission des `command_executed`-Signals.
        - Schließen der Palette.
    - Teste Tastaturnavigation (Pfeiltasten, Enter, Escape).

#### 2.4. `MasterActionHandler` (Service/Non-Widget GObject)

##### 2.4.1. Übersicht und Zweck

Der `MasterActionHandler` ist ein zentraler Dienst innerhalb der Applikation, der als Registrierungsstelle und Auslöser für globale und fensterspezifische `gio::Action`-Instanzen dient. Er ermöglicht es verschiedenen Komponenten, Aktionen zu definieren und bereitzustellen, ohne dass eine direkte Kopplung zwischen dem Auslöser (z.B. einem Menüpunkt, einem Button oder der `CommandPaletteWidget`) und dem Aktionsempfänger bestehen muss. Dies fördert die Entkopplung und Wiederverwendbarkeit von Aktionen. GTK selbst nutzt `gio::Action` intensiv für Menüs, Tastenkürzel und UI-Elemente, die Aktionen auslösen können.12 Der `MasterActionHandler` stellt eine Abstraktionsebene darüber bereit, um die Verwaltung dieser Aktionen applikationsweit zu vereinfachen.

##### 2.4.2. Dateistruktur

- `src/app_shell/action_handler/mod.rs`: Öffentliches Modul und Wrapper-Definition.
- `src/app_shell/action_handler/imp.rs`: Private Implementierungsdetails und GObject-Subklassifizierung.

##### 2.4.3. GObject-Definition

- **Wrapper-Typ:**
    
    Rust
    
    ```
    // In src/app_shell/action_handler/mod.rs
    use gtk::glib;
    use gtk::gio;
    use gtk::subclass::prelude::*;
    use std::collections::HashMap;
    use std::cell::RefCell;
    use gtk::ApplicationWindow; // Für window_actions
    
    glib::wrapper! {
        pub struct MasterActionHandler(ObjectSubclass<imp::MasterActionHandlerImp>)
            @extends glib::Object;
    }
    
    impl MasterActionHandler {
        pub fn new() -> Self {
            glib::Object::builder().build()
        }
    
        // Wrapper-Methoden für die Logik in imp
        pub fn register_app_action(&self, app: &gtk::Application, action: &impl IsA<gio::Action>) {
            self.imp().register_app_action(app, action);
        }
    
        pub fn register_window_action(&self, window: &ApplicationWindow, action_name_prefix: &str, action: &impl IsA<gio::Action>) {
            self.imp().register_window_action(window, action_name_prefix, action);
        }
    
        pub fn activate_action(&self, active_window: Option<&ApplicationWindow>, action_name: &str, parameter: Option<&glib::Variant>) {
            self.imp().activate_action(active_window, action_name, parameter);
        }
    
        pub fn create_action_entry<F>(
            name: &str,
            parameter_type: Option<&glib::VariantTy>,
            state: Option<&glib::Variant>,
            activate_callback: F,
        ) -> gio::ActionEntry
        where
            F: Fn(&gio::SimpleAction, Option<&glib::Variant>) + 'static,
        {
            // Diese Methode ist statisch oder Teil des Imp, da sie keine Self-Referenz benötigt,
            // wenn sie nur eine ActionEntry erstellt.
            // Wenn sie jedoch Zugriff auf den MasterActionHandler selbst benötigt (z.B. um
            // this.obj() in der Closure zu verwenden), dann muss sie eine &self Referenz haben.
            // Für eine reine Factory-Methode ist static ok.
    
            let action = gio::SimpleAction::new_stateful(name, parameter_type, state.unwrap_or(&Variant::unit()));
            action.connect_activate(move |act, param| {
                activate_callback(act, param);
            });
            // ActionEntry::builder() ist oft einfacher für die direkte Verwendung mit add_action_entries.
            // Diese Methode hier ist eher für die manuelle Erstellung und Registrierung einzelner SimpleActions.
            // Die Anforderung war ActionEntry, daher:
            ActionEntry::builder(name)
               .parameter_type(parameter_type.cloned())
               .state(state.cloned())
               .activate(move |_target_obj: &glib::Object, act: &gio::SimpleAction, param: Option<&Variant>| {
                    // Die Closure-Signatur für ActionEntry::activate ist anders.
                    // Sie erhält das Zielobjekt (App oder Window), die Aktion und den Parameter.
                    // Der Aufruf von activate_callback muss hier angepasst werden.
                    // Da activate_callback hier eine generische Fn ist, die SimpleAction erwartet,
                    // ist die direkte Verwendung in ActionEntry::activate schwierig ohne Anpassung.
                    // Einfacher ist es, SimpleAction zu erstellen und dann add_action zu verwenden.
    
                    // Für ActionEntry wäre es eher so:
                    // activate: move |target_obj, simple_action, param_variant| {
                    //     // Logik hier, die auf target_obj (App/Window), simple_action und param_variant zugreift
                    // }
                    // Die bereitgestellte activate_callback Signatur passt besser zu SimpleAction::connect_activate.
                    // Wir gehen davon aus, dass die ActionEntry dann manuell einer ActionMap hinzugefügt wird.
                    // Oder, die activate_callback wird so angepasst, dass sie mit ActionEntry kompatibel ist.
                })
               .build()
        }
    }
    
    impl Default for MasterActionHandler {
        fn default() -> Self {
            Self::new()
        }
    }
    ```
    
- **Implementierungs-Struktur (`imp`):**
    
    Rust
    
    ```
    // In src/app_shell/action_handler/imp.rs
    use gtk::glib::{self, Variant, VariantTy};
    use gtk::gio::{self, prelude::*, ActionMap, SimpleActionGroup};
    use gtk::subclass::prelude::*;
    use gtk::ApplicationWindow;
    use std::collections::HashMap;
    use std::cell::RefCell;
    use std::rc::Rc; // Für das Signal
    
    #
    pub struct MasterActionHandlerImp {
        // app_actions wird direkt auf gtk::Application gesetzt, daher hier nicht unbedingt nötig.
        // Stattdessen halten wir eine Referenz auf die App, um Aktionen zu setzen.
        app: RefCell<Option<gtk::Application>>,
        window_actions: RefCell<HashMap<String, gio::SimpleActionGroup>>, // Key: Window ID (z.B. GObject Pointer als String oder eine eindeutige ID)
    }
    
    #[glib::object_subclass]
    impl ObjectSubclass for MasterActionHandlerImp {
        const NAME: &'static str = "MyMasterActionHandler";
        type Type = super::MasterActionHandler;
        type ParentType = glib::Object;
    }
    
    impl ObjectImpl for MasterActionHandlerImp {
        fn signals() -> &'static {
            static SIGNALS: OnceCell<Vec<glib::subclass::Signal>> = OnceCell::new();
            SIGNALS.get_or_init(|| {
                vec!) // action_name, success
                       .build(),
                ]
            })
        }
    }
    
    impl MasterActionHandlerImp {
        pub fn register_app_action(&self, app: &gtk::Application, action: &impl IsA<gio::Action>) {
            // Speichere die App-Referenz, falls noch nicht geschehen
            if self.app.borrow().is_none() {
                *self.app.borrow_mut() = Some(app.clone());
            }
            app.add_action(action); // gtk::Application implementiert gio::ActionMap
        }
    
        pub fn register_window_action(
            &self,
            window: &ApplicationWindow,
            action_name_prefix: &str, // z.B. "win"
            action: &impl IsA<gio::Action>,
        ) {
            // Eindeutige ID für das Fenster generieren (z.B. Pfad oder eine interne ID)
            // Für dieses Beispiel verwenden wir den GObject-Pfad, falls verfügbar, oder eine einfache Zählung.
            // Eine robustere Lösung wäre, eine eindeutige ID pro Fenster zu verwalten.
            let window_id = window.path().map_or_else(
    ```
    

|

| format!("{:p}", window.as_ptr()), // Fallback: Pointer-Adresse als ID

|p| p.to_string()

);

````
        let mut window_actions_map = self.window_actions.borrow_mut();
        let action_group = window_actions_map
           .entry(window_id.clone())
           .or_insert_with(SimpleActionGroup::new);
        
        action_group.add_action(action);

        // Stelle sicher, dass die ActionGroup auch tatsächlich am Fenster registriert ist.
        // GTK fügt automatisch eine "win" ActionGroup zu ApplicationWindows hinzu.
        // Wenn wir eine eigene Gruppe verwenden wollen, müssen wir sie einfügen.
        // Für Standard "win." Aktionen:
        if action_name_prefix == "win" {
             window.lookup_action(&action.name().unwrap_or_default().to_string()); // Prüfen ob schon da
             window.add_action(action); // Fügt zur Standard "win" Gruppe hinzu
        } else {
            // Für benutzerdefinierte Gruppen
            if window.lookup_action_group(action_name_prefix).is_none() {
                window.insert_action_group(action_name_prefix, Some(action_group));
            }
        }
    }

    pub fn activate_action(
        &self,
        active_window: Option<&ApplicationWindow>,
        action_name: &str,
        parameter: Option<&Variant>,
    ) {
        let mut success = false;
        // Versuche zuerst, die Aktion im Kontext des aktiven Fensters auszuführen
        if let Some(window) = active_window {
            if let Some(action) = window.lookup_action(action_name) {
                action.activate(parameter);
                success = true;
            }
            // Man könnte auch nach präfixierten Aktionen suchen, z.B. "win.my-action"
            // oder spezifische ActionGroups durchsuchen, die am Fenster registriert sind.
            // Die aktuelle Implementierung von register_window_action fügt Aktionen
            // direkt zur Standard "win" Gruppe des Fensters hinzu oder zu einer benutzerdefinierten Gruppe.
            // `window.lookup_action` sollte also "prefix.action" finden, wenn so registriert.
        }

        // Wenn nicht im Fensterkontext gefunden oder kein aktives Fenster, versuche App-Aktionen
        if!success {
            if let Some(app) = self.app.borrow().as_ref() {
                if let Some(action) = app.lookup_action(action_name) {
                    action.activate(parameter);
                    success = true;
                }
            }
        }

        if!success {
            eprintln!("Aktion '{}' konnte nicht gefunden oder aktiviert werden.", action_name);
        }
        
        self.obj().emit_by_name::<()>("action-activated", &[&action_name, &success]);
    }
}
```
Die Verwaltung von Aktionen ist zentral für GTK-Anwendungen. `gio::Action` und `gio::ActionMap` (implementiert von `gtk::Application` und `gtk::ApplicationWindow`) sind die Kernkomponenten.[12, 30] `gio::SimpleActionGroup` kann verwendet werden, um Aktionen zu bündeln.[31, 32] Der `MasterActionHandler` kapselt die Logik zur Registrierung und Aktivierung dieser Aktionen.
````

##### 2.4.4. Eigenschaften

Keine öffentlich exponierten GObject-Eigenschaften.

##### 2.4.5. Methoden

- **`pub fn new() -> Self`** (bereits im Wrapper definiert)
    
    - **Nachbedingungen:** Ein neuer `MasterActionHandler` wird erstellt. Interne Maps für Fensteraktionen sind initialisiert.
- **`pub fn register_app_action(&self, app: &gtk::Application, action: &impl IsA<gio::Action>)`** (Wrapper für `imp`-Methode)
    
    - **Signatur (Imp):** `pub fn register_app_action(&self, app: &gtk::Application, action: &impl IsA<gio::Action>)`
    - **Parameter:**
        - `app`: `&gtk::Application` – Die Applikationsinstanz.
        - `action`: `&impl IsA<gio::Action>` – Die zu registrierende App-Aktion.
    - **Nachbedingungen:** Die Aktion ist in der `ActionMap` der `gtk::Application` registriert und kann global aufgerufen werden (z.B. mit Präfix "app.").
    - **Implementierungslogik (Imp):**
        1. Rufe `app.add_action(action)` auf. `gtk::Application` implementiert `gio::ActionMap`.30
- **`pub fn register_window_action(&self, window: &ApplicationWindow, action_name_prefix: &str, action: &impl IsA<gio::Action>)`** (Wrapper für `imp`-Methode)
    
    - **Signatur (Imp):** `pub fn register_window_action(&self, window: &ApplicationWindow, action_name_prefix: &str, action: &impl IsA<gio::Action>)`
    - **Parameter:**
        - `window`: `&ApplicationWindow` – Das Fenster, für das die Aktion registriert wird.
        - `action_name_prefix`: `&str` – Ein Präfix für die Aktionsgruppe (z.B. "win").
        - `action`: `&impl IsA<gio::Action>` – Die zu registrierende Fenster-Aktion.
    - **Nachbedingungen:** Die Aktion ist in einer `ActionMap` registriert, die mit dem Fenster assoziiert ist. Sie kann über das Fenster aufgerufen werden (z.B. mit Präfix "win.").
    - **Implementierungslogik (Imp):**
        1. Generiere eine eindeutige ID für das `window` (z.B. `window.path()` oder Pointer-Adresse).
        2. Hole oder erstelle eine `gio::SimpleActionGroup` für diese Fenster-ID aus `self.window_actions`.
        3. Füge `action` zur `SimpleActionGroup` hinzu.
        4. Füge die `SimpleActionGroup` zur `ActionMap` des `window` hinzu, falls sie nicht schon existiert, unter Verwendung des `action_name_prefix`: `window.insert_action_group(action_name_prefix, Some(&action_group));`.31 Wenn der Präfix "win" ist, kann die Aktion direkt zum Fenster hinzugefügt werden, da `ApplicationWindow` bereits eine "win"-Gruppe hat: `window.add_action(action);`.
- **`pub fn activate_action(&self, active_window: Option<&ApplicationWindow>, action_name: &str, parameter: Option<&glib::Variant>)`** (Wrapper für `imp`-Methode)
    
    - **Signatur (Imp):** `pub fn activate_action(&self, active_window: Option<&ApplicationWindow>, action_name: &str, parameter: Option<&glib::Variant>)`
    - **Parameter:**
        - `active_window`: `Option<&ApplicationWindow>` – Das aktuell aktive Fenster, falls vorhanden.
        - `action_name`: `&str` – Der vollständige Name der zu aktivierenden Aktion (z.B. "win.close" oder "app.about").
        - `parameter`: `Option<&glib::Variant>` – Der Parameter für die Aktion.
    - **Nachbedingungen:** Die angeforderte Aktion wird ausgeführt, falls sie gefunden wird. Das `action_activated`-Signal wird emittiert.
    - **Implementierungslogik (Imp):**
        1. `success = false`.
        2. Wenn `active_window` `Some(window)` ist:
            - Versuche, die Aktion `action_name` direkt auf `window` zu finden und zu aktivieren: `window.activate_action(action_name, parameter)`. `gtk::ApplicationWindow` implementiert `gio::ActionGroup` und `gio::ActionMap`.30
            - Wenn erfolgreich, setze `success = true`.
        3. Wenn nicht erfolgreich und `action_name` app-spezifisch ist (z.B. beginnt mit "app.") oder global gesucht werden soll:
            - Hole die `gtk::Application`-Instanz aus `self.app`.
            - Versuche, die Aktion `action_name` auf der Applikation zu finden und zu aktivieren: `app.activate_action(action_name, parameter)`.
            - Wenn erfolgreich, setze `success = true`.
        4. Wenn immer noch nicht erfolgreich, logge einen Fehler.
        5. Emittiere das `action-activated`-Signal mit `action_name` und `success`.
- **`pub fn create_action_entry<F>(name: &str, parameter_type: Option<&glib::VariantTy>, state: Option<&glib::Variant>, activate_callback: F) -> gio::ActionEntry`** (Statische Hilfsmethode oder Methode auf `MasterActionHandlerImp`)
    
    - **Signatur:** Wie im Wrapper definiert. `F: Fn(&gio::SimpleAction, Option<&glib::Variant>) + 'static`
    - **Beschreibung:** Eine Hilfsfunktion zur einfacheren Erstellung von `gio::ActionEntry`-Strukturen, die für `add_action_entries` verwendet werden können. Dies ist besonders nützlich für zustandsbehaftete Aktionen oder Aktionen mit Parametern.12
    - **Implementierungslogik:**
        
        1. Erstelle eine `gio::SimpleAction` mit `gio::SimpleAction::new_stateful(name, parameter_type, state.unwrap_or_else(Variant::unit))`.
        2. Verbinde die `activate_callback` mit dem `activate`-Signal der `SimpleAction`.
        3. Erstelle eine `gio::ActionEntry` manuell, die diese `SimpleAction` repräsentiert, oder passe die Logik an, um `ActionEntry::builder()` zu verwenden, was oft direkter ist.
            
            Rust
            
            ```
            // Verwendung von ActionEntry::builder ist oft prägnanter:
            // ActionEntry::builder(name)
            //    .parameter_type(parameter_type.cloned())
            //    .state(state.cloned())
            //    .activate(move |obj, action_ref, param_variant| {
            //         // Die activate_callback müsste hier aufgerufen werden.
            //         // Die Signatur von activate_callback (Fn(&SimpleAction,...)) passt nicht direkt
            //         // zur Signatur von ActionEntry::activate (Fn(&TargetType, &SimpleAction,...)).
            //         // Es ist einfacher, SimpleActions zu erstellen und sie mit.add_action() hinzuzufügen.
            //         // Diese Hilfsmethode ist daher komplexer als nötig, wenn ActionEntry das Ziel ist.
            //     })
            //    .build()
            // Stattdessen sollte diese Methode vielleicht direkt eine konfigurierte SimpleAction zurückgeben,
            // die dann mit add_action registriert wird.
            // Wenn das Ziel eine ActionEntry ist, muss die Callback-Struktur angepasst werden.
            ```
            
        
        Die gtk-rs Dokumentation 12 zeigt, dass `ActionEntry::builder()` einen `activate`-Callback erwartet, der das Zielobjekt (App oder Window), die Aktion selbst und den Parameter erhält. Die `create_action_entry` Methode müsste entweder eine `SimpleAction` zurückgeben, die dann manuell hinzugefügt wird, oder die `activate_callback` müsste so angepasst werden, dass sie mit der Signatur von `ActionEntry` kompatibel ist. Für die direkte Verwendung mit `add_action_entries` ist `ActionEntry::builder()` der bevorzugte Weg.

##### 2.4.6. Signale

- **Emittierte Signale:**
    - **Signal Name:** `action-activated`
        - **GObject Name:** `action-activated`
        - **Parameter:**
            - `action_name`: `String` (Rust), `glib::VariantType::STRING` – Der Name der Aktion, die versucht wurde zu aktivieren.
            - `success`: `bool` (Rust), `glib::VariantType::BOOLEAN` – Gibt an, ob die Aktivierung erfolgreich war.
        - **Beschreibung:** Wird emittiert, nachdem versucht wurde, eine Aktion zu aktivieren.
        - **Definition in `ObjectImpl::signals()` (in `MasterActionHandlerImp`):**
            
            Rust
            
            ```
            // Bereits in imp.rs definiert
            // static SIGNALS: OnceCell<Vec<glib::subclass::Signal>> = OnceCell::new();
            // SIGNALS.get_or_init(|| {
            //     vec!)
            //            .build(),
            //     ]
            // })
            ```
            

##### 2.4.7. Datenstrukturen

Keine spezifischen öffentlichen Datenstrukturen, außer den intern verwendeten `HashMap` für fensterspezifische Aktionsgruppen.

##### 2.4.11. Abhängigkeiten

- `gtk::Application`, `gtk::ApplicationWindow`
- `gtk::gio` (insbesondere `Action`, `SimpleAction`, `ActionMap`, `SimpleActionGroup`, `ActionEntry`)
- `gtk::glib` (insbesondere `Variant`, `VariantTy`)

##### 2.4.12. Testplan

- **Unit-Tests:**
    - Teste `register_app_action`: Überprüfe, ob die Aktion korrekt zur `gtk::Application` hinzugefügt wird.
    - Teste `register_window_action`: Überprüfe, ob die Aktion korrekt zur `ActionGroup` des Fensters hinzugefügt wird.
    - Teste `activate_action`:
        - Aktivierung einer App-Aktion.
        - Aktivierung einer Fenster-Aktion (mit und ohne aktives Fenster).
        - Aktivierung einer nicht existierenden Aktion.
        - Korrekte Parameterübergabe.
        - Emission des `action-activated`-Signals mit korrekten Werten.
    - Teste `create_action_entry` (falls als Factory für `ActionEntry` implementiert): Korrekte Erstellung der `ActionEntry`.

#### 2.5. `SettingsService` (Service/Non-Widget GObject)

##### 2.5.1. Übersicht und Zweck

Der `SettingsService` dient als zentraler Zugriffspunkt für anwendungsspezifische Einstellungen, die persistent gespeichert werden. Er kapselt die Funktionalität von `gio::Settings` und stellt eine typsichere API zum Lesen, Schreiben und Überwachen von Einstellungen bereit. Dies ermöglicht eine saubere Trennung der Einstellungsverwaltung von anderen UI-Komponenten und erleichtert das Testen. Die Einstellungen werden typischerweise in einem GSchema XML-File definiert, das bei der Installation der Anwendung im System registriert wird.33

##### 2.5.2. Dateistruktur

- `src/app_shell/settings_service/mod.rs`: Öffentliches Modul und Wrapper-Definition.
- `src/app_shell/settings_service/imp.rs`: Private Implementierungsdetails und GObject-Subklassifizierung.
- `resources/schemas/org.example.myapp.gschema.xml`: GSettings-Schemadatei (Beispielname).

##### 2.5.3. GObject-Definition

- **Wrapper-Typ:**
    
    Rust
    
    ```
    // In src/app_shell/settings_service/mod.rs
    use gtk::glib;
    use gtk::gio;
    use gtk::subclass::prelude::*;
    
    glib::wrapper! {
        pub struct SettingsService(ObjectSubclass<imp::SettingsServiceImp>)
            @extends glib::Object;
    }
    
    impl SettingsService {
        pub fn new(schema_id: &str) -> Result<Self, glib::Error> {
            let service: Self = glib::Object::builder().build();
            service.imp().init_settings(schema_id)?;
            Ok(service)
        }
    
        // Wrapper für get_string, get_bool, etc.
        pub fn get_string(&self, key: &str) -> String {
            self.imp().settings.get().expect("Settings nicht initialisiert").string(key)
        }
        pub fn get_boolean(&self, key: &str) -> bool {
            self.imp().settings.get().expect("Settings nicht initialisiert").boolean(key)
        }
        pub fn get_int(&self, key: &str) -> i32 {
            self.imp().settings.get().expect("Settings nicht initialisiert").int(key)
        }
    
        // Wrapper für set_string, set_bool, etc.
        pub fn set_string(&self, key: &str, value: &str) -> Result<(), glib::Error> {
            self.imp().settings.get().expect("Settings nicht initialisiert").set_string(key, value)
        }
        pub fn set_boolean(&self, key: &str, value: bool) -> Result<(), glib::Error> {
            self.imp().settings.get().expect("Settings nicht initialisiert").set_boolean(key, value)
        }
        pub fn set_int(&self, key: &str, value: i32) -> Result<(), glib::Error> {
            self.imp().settings.get().expect("Settings nicht initialisiert").set_int(key, value)
        }
    
        pub fn bind_property<P: IsA<glib::Object>>(
            &self,
            key: &str,
            object: &P,
            property_name: &str,
            flags: gio::SettingsBindFlags,
        ) {
            self.imp().settings.get().expect("Settings nicht initialisiert").bind(key, object, property_name)
               .flags(flags)
               .build();
        }
    
        pub fn connect_changed<F: Fn(&Self, &str) + 'static + Clone>(
            &self,
            key: Option<&str>,
            callback: F,
        ) -> glib::SignalHandlerId {
            let self_clone = self.clone();
            self.imp().settings.get().expect("Settings nicht initialisiert").connect_changed(key, move |_, changed_key| {
                callback(&self_clone, changed_key);
                self_clone.emit_by_name::<()>("setting-changed", &[&changed_key]);
            })
        }
    }
    ```
    
- **Implementierungs-Struktur (`imp`):**
    
    Rust
    
    ```
    // In src/app_shell/settings_service/imp.rs
    use gtk::glib;
    use gtk::gio::{self, prelude::SettingsExtManual};
    use gtk::subclass::prelude::*;
    use std::cell::OnceCell;
    
    
    #
    pub struct SettingsServiceImp {
        settings: OnceCell<gio::Settings>,
    }
    
    #[glib::object_subclass]
    impl ObjectSubclass for SettingsServiceImp {
        const NAME: &'static str = "MySettingsService";
        type Type = super::SettingsService;
        type ParentType = glib::Object;
    }
    
    impl ObjectImpl for SettingsServiceImp {
        fn signals() -> &'static {
            static SIGNALS: OnceCell<Vec<glib::subclass::Signal>> = OnceCell::new();
            SIGNALS.get_or_init(|| {
                vec!) // key
                       .build(),
                ]
            })
        }
    }
    
    impl SettingsServiceImp {
        pub fn init_settings(&self, schema_id: &str) -> Result<(), glib::Error> {
            match gio::Settings::new(schema_id) {
                Ok(s) => {
                    self.settings.set(s).map_err(|_| glib::Error::new(glib::FileError::Failed, "Settings bereits initialisiert"))?;
                    Ok(())
                }
                Err(e) => Err(e),
            }
        }
    }
    ```
    
    Die `gio::Settings`-Instanz wird in `OnceCell` gespeichert, um sicherzustellen, dass sie nur einmal initialisiert wird. Die `init_settings`-Methode wird vom Wrapper `new` aufgerufen.
    
- **GSettings Schema (`org.example.myapp.gschema.xml`):**
    
    XML
    
    ```
    <schemalist>
      <schema id="org.example.myapp" path="/org/example/myapp/">
        <key name="window-width" type="i">
          <default>1024</default>
          <summary>Main window width</summary>
          <description>The last saved width of the main application window.</description>
        </key>
        <key name="window-height" type="i">
          <default>768</default>
          <summary>Main window height</summary>
          <description>The last saved height of the main application window.</description>
        </key>
        <key name="dark-mode" type="b">
          <default>false</default>
          <summary>Enable dark mode</summary>
          <description>Whether the application should use a dark theme variant.</description>
        </key>
        <key name="last-opened-file" type="s">
          <default>''</default>
          <summary>Last opened file</summary>
          <description>Path to the last successfully opened file.</description>
        </key>
        </schema>
    </schemalist>
    ```
    
    Diese Datei muss während des Build-Prozesses kompiliert (mit `glib-compile-schemas`) und an einem Ort installiert werden, an dem GSettings sie finden kann (z.B. `$XDG_DATA_DIRS/glib-2.0/schemas/`).33
    

##### 2.5.4. Eigenschaften

Keine öffentlich exponierten GObject-Eigenschaften für den `SettingsService` selbst. Die Einstellungen sind über die get/set-Methoden zugänglich.

##### 2.5.5. Methoden

- **`pub fn new(schema_id: &str) -> Result<Self, glib::Error>`** (bereits im Wrapper definiert)
    
    - **Nachbedingungen:** Der `SettingsService` ist initialisiert und hat das GSettings-Schema mit der gegebenen `schema_id` geladen. Gibt `Err` zurück, falls das Schema nicht geladen werden konnte.
- **`pub fn get_string(&self, key: &str) -> String`** (Wrapper für `gio::Settings::string`)
    
    - **Parameter:** `key: &str` – Der Schlüssel der Einstellung.
    - **Rückgabewert:** `String` – Der Wert der Einstellung.
    - **Vorbedingungen:** `key` muss im Schema als String-Typ definiert sein.
    - **Fehlerbehandlung:** Panik, wenn der Schlüssel nicht existiert oder einen anderen Typ hat.
- **`pub fn get_boolean(&self, key: &str) -> bool`** (Wrapper für `gio::Settings::boolean`)
    
    - **Parameter:** `key: &str` – Der Schlüssel der Einstellung.
    - **Rückgabewert:** `bool` – Der Wert der Einstellung.
    - **Vorbedingungen:** `key` muss im Schema als Boolean-Typ definiert sein.
- **`pub fn get_int(&self, key: &str) -> i32`** (Wrapper für `gio::Settings::int`)
    
    - **Parameter:** `key: &str` – Der Schlüssel der Einstellung.
    - **Rückgabewert:** `i32` – Der Wert der Einstellung.
    - **Vorbedingungen:** `key` muss im Schema als Integer-Typ definiert sein.
- **`pub fn set_string(&self, key: &str, value: &str) -> Result<(), glib::Error>`** (Wrapper für `gio::Settings::set_string`)
    
    - **Parameter:**
        - `key: &str` – Der Schlüssel der Einstellung.
        - `value: &str` – Der zu setzende Wert.
    - **Rückgabewert:** `Result<(), glib::Error>` – `Ok(())` bei Erfolg, sonst `Err`.
    - **Vorbedingungen:** `key` muss im Schema als String-Typ definiert sein.
- **`pub fn set_boolean(&self, key: &str, value: bool) -> Result<(), glib::Error>`** (Wrapper für `gio::Settings::set_boolean`)
    
- **`pub fn set_int(&self, key: &str, value: i32) -> Result<(), glib::Error>`** (Wrapper für `gio::Settings::set_int`)
    
- **`pub fn bind_property<W: IsA<glib::Object>>(&self, key: &str, object: &W, property_name: &str, flags: gio::SettingsBindFlags)`** (Wrapper für `gio::Settings::bind`)
    
    - **Parameter:**
        - `key: &str` – Der GSettings-Schlüssel.
        - `object: &W` – Das GObject, dessen Eigenschaft gebunden werden soll.
        - `property_name: &str` – Der Name der GObject-Eigenschaft.
        - `flags: gio::SettingsBindFlags` – Flags zur Steuerung der Bindung (z.B. `DEFAULT`, `BIDIRECTIONAL`).
    - **Nachbedingungen:** Die GObject-Eigenschaft ist an die GSetting gebunden. Änderungen werden synchronisiert gemäß den `flags`.33
- **`pub fn connect_changed<F: Fn(&Self, &str) + 'static + Clone>(&self, key: Option<&str>, callback: F) -> glib::SignalHandlerId`** (Wrapper für `gio::Settings::connect_changed`)
    
    - **Parameter:**
        - `key: Option<&str>` – Der zu überwachende Schlüssel. `None` für alle Schlüssel.
        - `callback: F` – Die Funktion, die bei Änderungen aufgerufen wird. Erhält den `SettingsService` und den geänderten Schlüssel als Parameter.
    - **Rückgabewert:** `glib::SignalHandlerId` – Zur möglichen Trennung der Verbindung.
    - **Nachbedingungen:** Die `callback`-Funktion wird aufgerufen, wenn sich der spezifizierte Schlüssel (oder ein beliebiger Schlüssel, falls `key` `None` ist) ändert. Das `setting-changed`-Signal des `SettingsService` wird ebenfalls emittiert.

##### 2.5.6. Signale

- **Emittierte Signale:**
    - **Signal Name:** `setting-changed`
        - **GObject Name:** `setting-changed`
        - **Parameter:**
            - `key`: `String` (Rust), `glib::VariantType::STRING` – Der Name des geänderten Schlüssels.
        - **Beschreibung:** Wird emittiert, nachdem sich eine Einstellung geändert hat. Dies ist ein Wrapper um das `changed`-Signal von `gio::Settings`.
        - **Definition in `ObjectImpl::signals()` (in `SettingsServiceImp`):**
            
            Rust
            
            ```
            // Bereits in imp.rs definiert
            // static SIGNALS: OnceCell<Vec<glib::subclass::Signal>> = OnceCell::new();
            // SIGNALS.get_or_init(|| {
            //     vec!)
            //            .build(),
            //     ]
            // })
            ```
            
- **Behandelte Signale:**
    - `gio::Settings::changed`: Intern verbunden, um das `setting-changed`-Signal des `SettingsService` auszulösen.

##### 2.5.7. Datenstrukturen

- **Tabelle: GSettings Schema (`org.example.myapp.gschema.xml`)**

|   |   |   |   |   |
|---|---|---|---|---|
|**Schlüsselname**|**GVariant Typ**|**Standardwert**|**Zusammenfassung**|**Beschreibung**|
|`window-width`|`i`|`1024`|Fensterbreite|Die zuletzt gespeicherte Breite des Hauptfensters.|
|`window-height`|`i`|`768`|Fensterhöhe|Die zuletzt gespeicherte Höhe des Hauptfensters.|
|`dark-mode`|`b`|`false`|Dunkelmodus aktivieren|Ob die Anwendung eine dunkle Theme-Variante verwenden soll.|
|`last-opened-file`|`s`|`''`|Zuletzt geöffnete Datei|Pfad zur zuletzt erfolgreich geöffneten Datei.|
|`sidebar-visible`|`b`|`true`|Seitenleiste sichtbar|Ob die Navigationsseitenleiste standardmäßig sichtbar ist.|
|`command-palette-hotkey`|`s`|`<Primary>P`|Hotkey Befehlspalette|Tastenkombination zum Öffnen der Befehlspalette.|

```
Diese Tabelle ist essentiell, da sie die persistenten Einstellungen der Anwendung definiert.
```

##### 2.5.11. Abhängigkeiten

- `gtk::gio` (insbesondere `Settings`, `SettingsBindFlags`)
- `gtk::glib`

##### 2.5.12. Testplan

- **Unit-Tests:**
    - Teste `new()`: Erfolgreiches Laden eines Test-Schemas, Fehlerbehandlung bei ungültigem Schema-ID.
    - Teste `get_` und `set_` Methoden für jeden Typ (String, bool, i32): Korrektes Lesen und Schreiben von Werten.
    - Teste `bind_property`: Bindung an eine Eigenschaft eines Mock-GObjects, Überprüfung der Synchronisation in beide Richtungen (falls `BIDIRECTIONAL`).
    - Teste `connect_changed`: Registrierung eines Callbacks, Überprüfung, ob der Callback und das `setting-changed`-Signal bei Wertänderungen ausgelöst werden.
- **Integrationstests:** (Erfordert eine Testumgebung, in der GSettings funktionieren)
    - Überprüfe, ob Änderungen an Einstellungen persistent sind nach Neustart der Test-Applikation.

#### 2.6. `NotificationService` (Service/Non-Widget GObject)

##### 2.6.1. Übersicht und Zweck

Der `NotificationService` ist verantwortlich für die Anzeige von Benachrichtigungen innerhalb der Applikation und optional für die Interaktion mit dem systemweiten Freedesktop-Benachrichtigungsdienst. Er unterscheidet zwischen In-App-Benachrichtigungen (z.B. als `gtk::Popover` 34 oder über `gtk4-layer-shell` 37 für benutzerdefinierte Popups) und Desktop-Benachrichtigungen. In-App-Benachrichtigungen bieten mehr Kontrolle über Aussehen und Verhalten im Kontext der Anwendung, während Desktop-Benachrichtigungen die Konsistenz mit der Desktop-Umgebung des Benutzers wahren.39

##### 2.6.2. Dateistruktur

- `src/app_shell/notification_service/mod.rs`: Öffentliches Modul und Wrapper-Definition.
- `src/app_shell/notification_service/imp.rs`: Private Implementierungsdetails.
- `src/app_shell/notification_service/desktop_notifier.rs`: (Optional) Modul für die Interaktion mit `org.freedesktop.Notifications` via D-Bus.

##### 2.6.3. GObject-Definition

- **Wrapper-Typ:**
    
    Rust
    
    ```
    // In src/app_shell/notification_service/mod.rs
    use gtk::glib;
    use gtk::gio; // für Cancellable
    use gtk::subclass::prelude::*;
    use gtk::{Widget, Popover}; // Für In-App Notifikationen
    use std::cell::RefCell;
    use std::collections::VecDeque;
    use zbus; // Für Desktop-Notifikationen
    
    // Enum für interne Verwendung im Service
    #
    pub enum NotificationLevel {
        Info,
        Warning,
        Error,
        Success, // Hinzugefügt für positive Rückmeldungen
    }
    
    #
    pub enum DesktopNotificationUrgency {
        Low,
        Normal,
        Critical,
    }
    
    glib::wrapper! {
        pub struct NotificationService(ObjectSubclass<imp::NotificationServiceImp>)
            @extends glib::Object;
    }
    
    impl NotificationService {
        pub fn new(app_name: String, app_icon: String) -> Self {
            let service: Self = glib::Object::builder().build();
            service.imp().init_desktop_notifier(app_name, app_icon);
            service
        }
    
        pub fn show_in_app_notification(
            &self,
            parent_widget: &impl IsA<Widget>,
            message: &str,
            level: NotificationLevel,
            autohide_ms: Option<u32>,
        ) {
            self.imp().show_in_app_notification(parent_widget, message, level, autohide_ms);
        }
    
        pub async fn show_desktop_notification(
            &self,
            summary: &str,
            body: &str,
            icon: Option<&str>,
            actions: Option<&[(&str, &str)]>, // Vec aus (action_key, display_name)
            urgency: Option<DesktopNotificationUrgency>,
            timeout_ms: Option<i32>, // Hinzugefügt für Timeout
        ) -> Result<u32, zbus::Error> {
            self.imp().show_desktop_notification(summary, body, icon, actions, urgency, timeout_ms).await
        }
    }
    ```
    
- **Implementierungs-Struktur (`imp`):**
    
    Rust
    
    ```
    // In src/app_shell/notification_service/imp.rs
    use gtk::glib;
    use gtk::gio;
    use gtk::prelude::*;
    use gtk::subclass::prelude::*;
    use gtk::{Widget, Popover, Box as GtkBox, Label, Image, Align, Orientation};
    use std::cell::RefCell;
    use std::collections::VecDeque;
    use zbus::Connection; // Für Desktop-Notifikationen
    use once_cell::sync::Lazy; // Für statische Connection
    
    use super::{NotificationLevel, DesktopNotificationUrgency}; // Importiere die Enums
    
    const DEFAULT_IN_APP_AUTOHIDE_MS: u32 = 5000; // 5 Sekunden
    
    // Statische D-Bus Verbindung für Desktop-Notifikationen
    static DBUS_CONNECTION: Lazy<Result<Connection, zbus::Error>> = Lazy::new(Connection::session);
    
    
    #
    pub struct NotificationServiceImp {
        active_popovers: RefCell<VecDeque<Popover>>, // Verwende VecDeque als einfache Queue
        app_name_for_desktop: RefCell<
    ```


# Implementierungsleitfaden UI-Schicht NovaDE: Modul 2 - `PanelWidget`

## 1. Einleitung und Zielsetzung

### 1.1. Zweck dieses Dokuments

Dieses Dokument stellt Teil 2 einer Serie von 8 bis 16 Modulspezifikationen für die Implementierung der Benutzeroberflächenschicht (UI-Schicht) der Linux-Desktop-Umgebung "NovaDE" dar. Es definiert die Ultra-Feinspezifikationen und hochdetaillierten Implementierungspläne für das Modul `PanelWidget`. Ziel ist es, einen lückenlosen Entwickler-Implementierungsleitfaden bereitzustellen, der so detailliert ist, dass Entwickler ihn direkt zur Implementierung verwenden können, ohne eigenständige Designentscheidungen treffen oder Kernlogiken und Algorithmen selbst entwerfen zu müssen. Alle relevanten Aspekte wurden recherchiert, entschieden und werden hier präzise spezifiziert.

### 1.2. Geltungsbereich: `PanelWidget` als Kernkomponente der `ui::shell`

Das `PanelWidget` ist eine zentrale Komponente innerhalb des `ui::shell`-Moduls von NovaDE. Es repräsentiert die Hauptkontroll- und Systemleiste(n) des Desktops. Dieses Dokument umfasst die vollständige Spezifikation des `PanelWidget`, einschließlich seiner internen Struktur, seiner öffentlichen Schnittstelle (Eigenschaften, Signale, Methoden), seines Verhaltens, seines Erscheinungsbilds (Layout und Theming) sowie seiner Interaktion mit anderen Modulen und Schichten von NovaDE. Die Spezifikationen für die einzelnen Elemente, die _innerhalb_ des Panels angezeigt werden (z.B. Uhr, System-Tray, AppMenu-Button), sind Gegenstand separater Moduldokumentationen; dieses Dokument definiert jedoch die Schnittstellen und Mechanismen für deren Integration in das `PanelWidget`.

### 1.3. Bezug zur Gesamtarchitektur von NovaDE

NovaDE basiert auf einer strengen Vier-Schichten-Architektur (Kern, Domäne, System, Benutzeroberfläche). Das `PanelWidget` ist integraler Bestandteil der **Benutzeroberflächenschicht**. Es interagiert mit:

- Anderen UI-Modulen innerhalb von `ui::shell` (z.B. `QuickSettingsPanelWidget`, `NotificationCenterPanelWidget`) und `ui::widgets`.
- Der **Domänenschicht**, insbesondere `domain::theming` für das Erscheinungsbild und `domain::global_settings_and_state_management` für Konfigurationen.
- Indirekt mit der **Systemschicht**, beispielsweise wenn im Panel gehostete Indikator-Widgets Daten von Systemdiensten (via D-Bus) anzeigen.

Die Implementierung des `PanelWidget` muss die in der "Technischen Gesamtspezifikation & Richtlinien" von NovaDE festgelegten Prinzipien der Modularität, losen Kopplung und hohen Kohäsion strikt einhalten.

## 2. Modul `ui::shell::panel_widget` - Spezifikation und Implementierungsplan

### 2.1. Verantwortlichkeiten und Features des `PanelWidget`

Das `PanelWidget` ist verantwortlich für:

- Die Bereitstellung einer horizontalen (oder potenziell vertikalen, obwohl initial nicht primär gefordert) Leiste am Bildschirmrand.
- Das Hosting und die Anordnung von verschiedenen UI-Elementen wie Anwendungsmenü-Button, Workspace-Indikator, Uhr, System-Tray, Schnelleinstellungs-Button, Benachrichtigungszentrum-Button sowie diversen Statusindikatoren (Netzwerk, Energie, Audio).
- Die Implementierung eines "eleganten Leisten-Designs mit optionalem Leuchtakzent", dessen Farbe sich dynamisch an das System-Theme anpasst.
- Die Konfigurierbarkeit hinsichtlich Position (z.B. oben, unten am Bildschirm) und Höhe.
- Die Reaktion auf Theme-Änderungen (Hell/Dunkel-Modus, Akzentfarben) aus `domain::theming`.

Es ist _nicht_ verantwortlich für die Implementierung der Logik der einzelnen gehosteten Elemente (z.B. das Anzeigen der Schnelleinstellungen selbst), sondern nur für deren Integration und die Bereitstellung der Auslöser (z.B. Buttons).

### 2.2. Dateistruktur und Modul-Setup

#### 2.2.1. Verzeichnisstruktur

Die empfohlene Verzeichnisstruktur für das `PanelWidget`-Modul innerhalb des `ui::shell`-Verzeichnisses ist wie folgt:

```
nova_de/
└── src/
    └── ui/
        └── shell/
            ├── panel_widget/
            │   ├── mod.rs         // Öffentliche API des PanelWidget, Wrapper-Definition
            │   ├── imp.rs         // Interne Implementierung (ObjectSubclass)
            │   ├── panel_widget.ui // GTK Composite Template UI-Definition
            │   ├── panel_widget.css // Modulspezifische CSS-Stile (optional)
            │   └── error.rs       // Modulspezifische Fehlerdefinitionen
            └──...                // Andere Shell-Module
```

Diese Struktur folgt etablierten Konventionen in der gtk-rs Community, wie sie beispielsweise in Dokumentationen und Beispielen zu finden sind.1 Eine solche Standardisierung fördert die Lesbarkeit und Wartbarkeit des Codes, da sich Entwickler, die mit GTK4 und Rust vertraut sind, schneller zurechtfinden. Die Trennung der öffentlichen API (`mod.rs`) von der internen `ObjectSubclass`-Implementierung (`imp.rs`) ist ein gängiges Muster, das die Einarbeitungszeit für neue Projektmitglieder reduziert.

#### 2.2.2. `Cargo.toml` Konfiguration

Die relevanten Abhängigkeiten für das `PanelWidget` und die UI-Schicht im Allgemeinen sind in der `Cargo.toml` des `nova_de_ui`-Crates (oder des entsprechenden Sub-Crates) zu deklarieren:

Ini, TOML

```
[dependencies]
gtk = { package = "gtk4", version = "0.8", features = ["v4_10"] } # Aktuellste stabile Version, v4_10 für PopoverMenuFlags, etc.
gdk = { package = "gdk4", version = "0.8" }
glib = { package = "glib", version = "0.19" } # Aktuellste stabile Version
gio = { package = "gio", version = "0.19" }
tokio = { version = "1", features = ["full"] } # Für asynchrone Operationen, falls benötigt
tracing = "0.1"
thiserror = "1.0"

# Workspace-interne Abhängigkeiten (Beispiele, genaue Pfade anpassen)
# nova_de_core = { path = "../../../core" }
# nova_de_domain_theming = { path = "../../../domain/theming" }
```

Die Spezifikation von Feature-Flags für GTK, wie z.B. `features = ["v4_10"]` 3, ist entscheidend, um Zugriff auf neuere API-Elemente zu erhalten. Diese können für bestimmte Funktionalitäten, wie erweiterte Optionen für `GtkPopoverMenu` 4 (relevant für im Panel getriggerte Elemente wie das Schnelleinstellungs-Panel), erforderlich sein. Eine frühzeitige Berücksichtigung stellt sicher, dass die notwendigen APIs verfügbar sind.

### 2.3. `PanelWidget`: Rust Struct-Definition und Initialisierung

#### 2.3.1. Definition des `PanelWidget` Structs (Verwendung von `gtk::glib::wrapper!`, `CompositeTemplate`)

Das `PanelWidget` wird als benutzerdefiniertes GTK-Widget implementiert. Die öffentliche Struktur wird in `panel_widget/mod.rs` definiert:

Rust

```
use gtk::glib;
use gtk::subclass::prelude::*;

glib::wrapper! {
    pub struct PanelWidget(ObjectSubclass<imp::PanelWidget>)
        @extends gtk::Widget, gtk::Box; // gtk::Box als Basis für einfaches Layout der Kinder
}

impl PanelWidget {
    pub fn new() -> Self {
        glib::Object::new(&) // Erzeugt eine neue Instanz des PanelWidget
    }
}

// Enum zur Definition der Panel-Position (Beispiel, kann auch globaler sein)
#
#
pub enum PanelPosition {
    #
    Top,
    #
    Bottom,
    // Ggf. Left, Right für vertikale Panels später
}

impl Default for PanelPosition {
    fn default() -> Self {
        PanelPosition::Top
    }
}

// Enum zur Definition der Bereiche für Kind-Widgets
#
pub enum PanelChildrenArea {
    Left,
    Center,
    Right,
}
```

Die Entscheidung, von `gtk::Box` abzuleiten, ermöglicht eine unkomplizierte Anordnung von Kind-Widgets in horizontalen oder vertikalen Segmenten (links, zentriert, rechts). Für die typische Struktur einer Panelleiste ist `gtk::Box` oft ausreichend und einfacher zu handhaben als beispielsweise `gtk::Grid`, welches für komplexere, gitterbasierte Layouts vorgesehen ist.

#### 2.3.2. Implementierung von `imp::PanelWidget` (`ObjectSubclass`, `WidgetImpl`, `BoxImpl` etc.)

Die interne Implementierung des `PanelWidget` erfolgt in `panel_widget/imp.rs`:

Rust

```
use gtk::glib::{self, subclass::InitializingObject, Cell, RefCell};
use gtk::subclass::prelude::*;
use gtk::{gio, gdk, CompositeTemplate, Box as GtkBox}; // GtkBox hier importieren für Klarheit

use super::PanelPosition; // PanelPosition aus mod.rs importieren

#
#[template(resource = "/org/nova_de/ui/shell/panel_widget.ui")] // Pfad zur.ui Datei
pub struct PanelWidget {
    #[template_child]
    pub(super) left_box: TemplateChild<GtkBox>,
    #[template_child]
    pub(super) center_box: TemplateChild<GtkBox>,
    #[template_child]
    pub(super) right_box: TemplateChild<GtkBox>,

    // Interne Zustandsvariablen für GObject-Properties
    #[property(get, set, explicit_notify)]
    position: Cell<PanelPosition>,
    #[property[10]] // Beispiel für Property-Attribute
    height_request_prop: Cell<i32>, // Name mit Suffix _prop zur Unterscheidung von Widget-Property
    #[property(get, set, explicit_notify)]
    auto_hide: Cell<bool>,
    #[property(get, set, explicit_notify)]
    show_glow_accent: Cell<bool>,
    #[property(get, /* no set from outside */ explicit_notify)]
    glow_accent_color_prop: RefCell<Option<gdk::RGBA>>,
    #[property(get, set, explicit_notify)] // Init-only wird in Setter-Logik behandelt
    monitor_index: Cell<i32>,

    // Weitere interne Zustandsvariablen
    // settings: RefCell<Option<gio::Settings>>, // Für GSettings
    // children_configs: RefCell<Vec<PanelChildConfig>>, // Für dynamische Kinder-Konfiguration
}

#[glib::object_subclass]
impl ObjectSubclass for PanelWidget {
    const NAME: &'static str = "NovaDEPanelWidget";
    type Type = super::PanelWidget;
    type ParentType = GtkBox; // Muss mit @extends oben übereinstimmen

    fn class_init(klass: &mut Self::Class) {
        klass.bind_template();
        // CSS laden, falls modulspezifisch vorhanden
        // Self::Type::load_css(); // Methode muss in PanelWidget (mod.rs) definiert werden

        // GObject Properties manuell installieren, wenn #[property] nicht alles abdeckt
        // oder man mehr Kontrolle braucht. Hier durch #[derive(Properties)] und #[property] abgedeckt.
        // Siehe 2.4.
    }

    fn instance_init(obj: &InitializingObject<Self>) {
        obj.init_template();
    }
}

impl ObjectImpl for PanelWidget {
    fn properties() -> &'static {
        // Diese Methode wird benötigt, wenn man Properties manuell definiert.
        // Mit #[derive(Properties)] und #[property(...)] wird dies oft automatisch generiert.
        // Hier explizit für Klarheit und falls Anpassungen nötig sind.
        use once_cell::sync::Lazy;
        static PROPERTIES: Lazy<Vec<glib::ParamSpec>> = Lazy::new(|| vec!);
        PROPERTIES.as_ref()
    }

    fn set_property(&self, _id: usize, value: &glib::Value, pspec: &glib::ParamSpec) {
        match pspec.name() {
            "position" => self.position.set(value.get().expect("Value must be of type PanelPosition")),
            "height-request" => self.height_request_prop.set(value.get().expect("Value must be of type i32")),
            "auto-hide" => self.auto_hide.set(value.get().expect("Value must be of type bool")),
            "show-glow-accent" => self.show_glow_accent.set(value.get().expect("Value must be of type bool")),
            // "glow-accent-color" ist nur lesbar, kein Setter von außen
            "monitor-index" => {
                // Hier könnte Logik für "Init-only" implementiert werden,
                // z.B. prüfen, ob das Widget bereits konstruiert ist.
                self.monitor_index.set(value.get().expect("Value must be of type i32"));
            }
            _ => unimplemented!(),
        }
        self.obj().notify_by_pspec(pspec); // Wichtig für explizites Notify
    }

    fn property(&self, _id: usize, pspec: &glib::ParamSpec) -> glib::Value {
        match pspec.name() {
            "position" => self.position.get().to_value(),
            "height-request" => self.height_request_prop.get().to_value(),
            "auto-hide" => self.auto_hide.get().to_value(),
            "show-glow-accent" => self.show_glow_accent.get().to_value(),
            "glow-accent-color" => self.glow_accent_color_prop.borrow().to_value(),
            "monitor-index" => self.monitor_index.get().to_value(),
            _ => unimplemented!(),
        }
    }

    fn constructed(&self) {
        self.parent_constructed(); // Wichtig: Aufruf der Methode der Elternklasse
        // Initialisierung nach Template-Initialisierung
        // z.B. Standard-Widgets hinzufügen, Signale verbinden, CSS laden
        let obj = self.obj();
        obj.set_property("height-request", self.height_request_prop.get()); // Initialen Wert setzen
        // Weitere Initialisierungen...
        // self.connect_theme_signals();
        // self.setup_default_children();
    }

    fn dispose(&self) {
        // Aufräumarbeiten, z.B. explizites Freigeben von Kind-Widgets
        // die nicht automatisch durch GTK verwaltet werden oder
        // um Referenzzyklen aufzulösen.
        while let Some(child) = self.obj().first_child() {
            child.unparent();
        }
    }
}

impl WidgetImpl for PanelWidget {} // Standardimplementierung oft ausreichend
impl BoxImpl for PanelWidget {}    // Standardimplementierung oft ausreichend
```

Die Verwendung von `#` und `#[template_child]` vereinfacht die Anbindung der im UI-File definierten Elemente an das Rust-Struct.1 Die `left_box`, `center_box` und `right_box` dienen als klar definierte Container für die typische Dreiteilung eines Panels, was das Layoutmanagement erheblich vereinfacht.

Die `dispose`-Methode spielt eine wichtige Rolle im Lebenszyklus von GTK4-Widgets. Für Container-Widgets wie das `PanelWidget`, die viele Kind-Widgets verwalten, ist eine sorgfältige Implementierung von `dispose` unerlässlich. GTK4 hat `gtk_widget_destroy()` für Nicht-Toplevel-Widgets entfernt und setzt stattdessen auf reguläres Referenzzählen.6 Die GTK-Dokumentation und Diskussionen legen nahe, dass benutzerdefinierte Container-Widgets in ihrer `dispose`-Methode `gtk_widget_unparent()` (oder das Äquivalent in den Bindings) für alle ihre Kinder aufrufen sollten.7 Dies hilft, Referenzzyklen zu durchbrechen und stellt sicher, dass Ressourcen korrekt freigegeben werden, insbesondere wenn Kind-Widgets komplexe interne Zustände oder eigene Referenzen halten.

#### 2.3.3. Interne Zustandsvariablen (private Felder)

Zusätzlich zu den über `#[template_child]` angebundenen UI-Elementen und den GObject-Properties (siehe 2.3.2 und 2.4) kann `PanelWidget` weitere interne Zustandsvariablen benötigen:

- `settings: RefCell<Option<gio::Settings>>`: Für den Zugriff auf GSettings, um Panel-spezifische Einstellungen (z.B. Auto-Hide-Verhalten, falls nicht über Property gesteuert) zu laden und zu beobachten.8
- `accent_color_cache: RefCell<Option<gdk::RGBA>>`: Ein interner Cache für die vom Theme bereitgestellte Akzentfarbe, um schnelle Aktualisierungen des "Leuchtakzents" zu ermöglichen. `glow_accent_color_prop` dient als GObject-Property-Spiegelung.
- `children_configs: RefCell<Vec<PanelChildConfig>>`: Potenziell eine Struktur, die die Konfiguration (Widget-Typ, Position, Reihenfolge) der dynamisch hinzugefügten Kind-Elemente speichert. Dies ist relevant, wenn das Panel hochgradig dynamisch konfigurierbar sein soll.

#### 2.3.4. Konstruktor (`fn new() -> Self`) und Initialisierungslogik (`constructed`, `class_init`, `instance_init`)

- `PanelWidget::new()`: Erstellt eine neue Instanz des `PanelWidget` über `glib::Object::new()`.
- `class_init()`: Wird einmal pro Klasse aufgerufen. Hier wird das Composite Template (`.ui`-Datei) mittels `klass.bind_template()` an die Klasse gebunden. Falls das Template Signal-Handler-Namen enthält, die auf Rust-Methoden gemappt werden sollen (Template Callbacks), muss hier auch `klass.bind_template_callbacks()` aufgerufen werden.2 Hier ist auch der Ort, um modulspezifisches CSS zu laden oder GObject-Properties und -Signale zu registrieren, falls dies nicht deklarativ über Makros geschieht.
- `instance_init()`: Wird für jede neue Instanz aufgerufen. Hier wird das Template für die spezifische Instanz mittels `obj.init_template()` initialisiert.2
- `constructed()`: Wird aufgerufen, nachdem das Objekt vollständig konstruiert und das Template für die Instanz initialisiert wurde. An dieser Stelle können:
    - Standard-Kind-Widgets (Platzhalter oder finale Widgets für AppMenu, Uhr etc.) programmatisch erstellt und in die `left_box`, `center_box`, `right_box` eingefügt werden.
    - Verbindungen zu Signalen der Domänenschicht (z.B. Theme-Änderungen von `domain::theming` via `gio::Settings` oder D-Bus) hergestellt werden.
    - Initialwerte für interne Zustände gesetzt und GObject-Properties initialisiert werden (z.B. die initiale Höhe des Panels).

Die konsequente Nutzung von Composite Templates wird in der gtk-rs Dokumentation 2 und Beispielen 1 stark betont und von GTK-Entwicklern empfohlen.9 Dieser Ansatz sollte als Standard für alle komplexeren Widgets in NovaDE etabliert werden, um Konsistenz zu fördern und die Einarbeitung zu erleichtern. Wenn das `PanelWidget` als eines der ersten komplexen UI-Module diesen Weg beschreitet, setzt es einen wichtigen Präzedenzfall.

### 2.4. `PanelWidget`: GObject-Eigenschaften (Properties)

GObject-Eigenschaften ermöglichen die Konfiguration des `PanelWidget` von außen, beispielsweise durch das `ui::control_center` oder programmatisch durch andere Teile der Anwendung. Sie werden üblicherweise mit dem `#[derive(Properties)]` Makro (nicht direkt in gtk-rs, aber `glib::Properties` ist das Äquivalent) und `#[property]` Attributen innerhalb der `imp::PanelWidget` Struktur definiert oder explizit über die `properties()`, `set_property()`, `property()` Methoden im `ObjectImpl` Trait implementiert.10

#### 2.4.1. Tabelle der definierten Eigenschaften

Die folgende Tabelle listet die für das `PanelWidget` definierten GObject-Eigenschaften auf.

**Tabelle 2.4.1: `PanelWidget` GObject-Eigenschaften**

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|**Eigenschaftsname (Rust / XML)**|**Rust-Datentyp (intern)**|**GObject-Typ (extern)**|**Lese-/Schreibzugriff**|**Standardwert**|**Beschreibung**|
|`position` / `position`|`Cell<PanelPosition>`|`NovaDEPanelPosition` (Enum)|R/W|`PanelPosition::Top`|Position des Panels auf dem Bildschirm (Oben, Unten). `PanelPosition` ist ein `glib::Enum`.|
|`height-request` / `height-request`|`Cell<i32>`|`gint`|R/W|`48`|Angeforderte Höhe des Panels in Pixeln. Min: 24, Max: 128.|
|`auto-hide` / `auto-hide`|`Cell<bool>`|`gboolean`|R/W|`false`|Ob das Panel automatisch versteckt werden soll. Die detaillierte Logik ist extern.|
|`show-glow-accent` / `show-glow-accent`|`Cell<bool>`|`gboolean`|R/W|`true`|Ob der "Leuchtakzent" angezeigt werden soll.|
|`glow-accent-color` / `glow-accent-color`|`RefCell<Option<gdk::RGBA>>`|`GdkRGBA*` (boxed)|R (intern W)|`None` (wird vom Theme abgeleitet)|Die Farbe des Leuchtakzents. Wird primär intern gesetzt basierend auf dem System-Theme.|
|`monitor-index` / `monitor-index`|`Cell<i32>`|`gint`|R/W (Init-only Logik)|`0` (Primärmonitor)|Index des Monitors, auf dem dieses Panel angezeigt wird. Minimum: 0.|

Diese Tabelle ist entscheidend für Entwickler, die das Panel verwenden oder konfigurieren (z.B. aus dem Control Center). Sie liefert alle notwendigen Informationen auf einen Blick: wie die Eigenschaft in Rust und XML heißt, welcher Datentyp erwartet wird, ob sie gelesen/geschrieben werden kann, was der Standard ist und was sie bewirkt. Dies ist essentiell für die korrekte Ansteuerung und das Verständnis des Widgets und dient als Checkliste während der Implementierung.

#### 2.4.2. Detaillierte Spezifikation jeder Eigenschaft

- `position`:
    - Verwendet den in `panel_widget/mod.rs` definierten `PanelPosition` Enum, der als `glib::Enum` registriert sein muss, um in GObject-Properties verwendet zu werden.
    - Der Setter sollte den Wert validieren. Bei einem ungültigen Wert (falls der Enum nicht korrekt übergeben wird) wird eine Warnung via `tracing::warn` ausgegeben und der Wert nicht geändert.
    - Eine Änderung der Position löst eine Neuzeichnung und potenziell eine Neupositionierung des Panels durch die übergeordnete Shell-Logik aus. Das Panel selbst passt seine CSS-Klassen an (z.B. `.panel-top`, `.panel-bottom`).
- `height-request`:
    - Der Setter validiert den übergebenen Wert gegen die definierten Min/Max-Grenzen (24-128 Pixel). Werte außerhalb dieses Bereichs führen zu einer Warnung und werden ggf. auf den nächstgelegenen gültigen Wert korrigiert oder ignoriert.
    - Eine Änderung dieser Eigenschaft führt dazu, dass das Widget eine neue Größenanforderung (`gtk_widget_queue_resize`) auslöst.
- `auto-hide`:
    - Diese Eigenschaft dient als reiner Schalter. Die komplexe Logik für das automatische Verstecken und Anzeigen (z.B. Reaktion auf Maus am Bildschirmrand, Überlappung mit maximierten Fenstern, Animationen) ist nicht Teil des `PanelWidget` selbst, sondern wird von einer dedizierten Policy oder einem Manager in der `ui::shell` gesteuert. Diese Trennung von Konfiguration (Eigenschaft) und Mechanismus (Logik) hält das `PanelWidget` fokussiert und modular.
- `show-glow-accent`:
    - Steuert die Sichtbarkeit des CSS-basierten Leuchtakzents. Bei Änderung wird eine CSS-Klasse (z.B. `glow-accent-visible`) am Widget gesetzt oder entfernt, was eine Neuzeichnung auslöst.
- `glow-accent-color`:
    - Diese Eigenschaft ist primär von außen lesbar. Intern wird sie aktualisiert, wenn sich die System-Akzentfarbe ändert. Das Panel muss hierfür auf entsprechende Signale von `domain::theming` (z.B. über `gio::Settings` oder einen D-Bus Service) hören. Eine Änderung dieser internen Property aktualisiert die CSS-Variable, die für den Akzentstil verwendet wird, oder eine spezifische CSS-Regel.
- `monitor-index`:
    - Diese Eigenschaft sollte idealerweise nur bei der Initialisierung des Panels gesetzt werden. Eine spätere Änderung ist komplex, da sie eine vollständige Neuinitialisierung des Panels auf einem anderen Monitor bedeuten würde. Der Setter kann eine Warnung ausgeben, wenn versucht wird, den Wert nach der `constructed`-Phase zu ändern.

Die Verwendung eines spezifischen Enum-Typs (`PanelPosition`) anstelle von einfachen Strings oder Integern für die Position ist robuster und typsicherer, was durch `glib::ParamSpecEnum` unterstützt wird. Dies verhindert ungültige Werte und macht den Code selbstdokumentierender.

### 2.5. `PanelWidget`: Signale

Signale werden vom `PanelWidget` emittiert, um andere Teile der Anwendung über Zustandsänderungen oder spezifische Benutzerinteraktionen innerhalb des Panels zu informieren. Sie werden typischerweise im `ObjectImpl`-Block mit dem `#[signal]`-Attribut (oder durch manuelle Registrierung in `class_init`) definiert.8

#### 2.5.1. Tabelle der definierten Signale

**Tabelle 2.5.1: `PanelWidget` Signale**

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|**Signalname (Rust / XML)**|**Parameter (Name, Typ)**|**Beschreibung**|**Typische Publisher**|**Typische Subscriber**|**Emissionsbedingungen**|
|`quick-settings-toggled` / `quick-settings-toggled`|`is_open: bool`|Informiert darüber, dass der Schnelleinstellungs-Button betätigt wurde und der gewünschte neue Zustand des Popups.|`PanelWidget` (intern, bei Klick auf den entsprechenden Button)|`ui::shell` Logik oder `QuickSettingsPanelWidget` direkt|Klick auf den Schnelleinstellungs-Button im Panel.|
|`notification-center-toggled` / `notification-center-toggled`|`is_open: bool`|Informiert darüber, dass der Benachrichtigungszentrum-Button betätigt wurde und der gewünschte neue Zustand des Popups.|`PanelWidget` (intern, bei Klick auf den entsprechenden Button)|`ui::shell` Logik oder `NotificationCenterPanelWidget` direkt|Klick auf den Benachrichtigungszentrum-Button im Panel.|
|`app-menu-toggled` / `app-menu-toggled`|`is_open: bool`|Informiert darüber, dass der AppMenu-Button betätigt wurde und der gewünschte neue Zustand des Menüs.|`PanelWidget` (intern, bei Klick auf den entsprechenden Button)|`ui::shell` (AppMenu-Logik)|Klick auf den AppMenu-Button im Panel.|

Diese Tabelle ist entscheidend für Entwickler, die auf Ereignisse innerhalb des Panels reagieren müssen. Sie listet klar auf, welche Signale existieren, welche Daten sie mitliefern und unter welchen Umständen sie ausgelöst werden. Dies ermöglicht es anderen Modulen, sich korrekt mit dem Panel zu integrieren.

#### 2.5.2. Detaillierte Spezifikation jedes Signals

- `quick-settings-toggled (is_open: bool)`:
    - Wird emittiert, wenn der Benutzer auf den Button zum Öffnen/Schließen der Schnelleinstellungen im Panel klickt.
    - Der Parameter `is_open` signalisiert den _gewünschten_ Zustand des Schnelleinstellungs-Popups (true für öffnen, false für schließen). Die Logik, die auf dieses Signal hört, ist dafür verantwortlich, den tatsächlichen Zustand des Popups entsprechend zu ändern.
- `notification-center-toggled (is_open: bool)`:
    - Analog zu `quick-settings-toggled`, jedoch für das Benachrichtigungszentrum.
- `app-menu-toggled (is_open: bool)`:
    - Analog zu `quick-settings-toggled`, jedoch für das Hauptanwendungsmenü.

Das ursprünglich in der Grobplanung erwogene Signal `child-widget-requested` wird nicht implementiert. Widgets sollten typischerweise nicht ihre eigenen Kinder "anfordern", sondern diese entweder intern erstellen oder von einer übergeordneten Instanz hinzugefügt bekommen. Die Verantwortung für die Komposition der Shell-Elemente und das Bestücken des Panels liegt bei der `ui::shell`-Logik, nicht beim Panel selbst. Dies vermeidet eine Umkehrung des Kontrollflusses und potenzielle schwer nachvollziehbare Abhängigkeiten.

Die hier definierten `*-toggled`-Signale sind ein exzellentes Beispiel für lose Kopplung. Das `PanelWidget` muss nicht wissen, wie das Schnelleinstellungs-Panel (`QuickSettingsPanelWidget`) implementiert ist oder wo es sich befindet. Es signalisiert lediglich die Absicht des Benutzers, dieses zu öffnen oder zu schließen. Die übergeordnete Shell-Logik oder das `QuickSettingsPanelWidget` selbst kann auf dieses Signal reagieren. Diese ereignisbasierte Kommunikation erhöht die Modularität, Flexibilität und Testbarkeit des Gesamtsystems erheblich.

### 2.6. `PanelWidget`: Methoden (Öffentliche API und interne Logik)

Die Methoden des `PanelWidget` definieren seine programmatische Schnittstelle und interne Hilfsfunktionen.

#### 2.6.1. Öffentliche Methoden

Diese Methoden bilden die öffentliche API des `PanelWidget` und werden in `panel_widget/mod.rs` innerhalb des `impl PanelWidget`-Blocks definiert.

**Tabelle 2.6.1: `PanelWidget` Öffentliche API-Methoden**

|   |   |   |   |   |
|---|---|---|---|---|
|**Methodensignatur (Rust)**|**Beschreibung**|**Vorbedingungen**|**Nachbedingungen**|**Ausgelöste Fehler (Typ $PanelWidgetError$)**|
|`pub fn new() -> Self`|Konstruktor. Erstellt eine neue Instanz des `PanelWidget`.|GTK-Umgebung ist initialisiert.|Eine gültige, initialisierte `PanelWidget`-Instanz wird zurückgegeben.|-|
|`pub fn add_child_widget(&self, child: &impl IsA<gtk::Widget>, area: PanelChildrenArea, order: i32)`|Fügt ein Kind-Widget einem bestimmten Bereich (`Left`, `Center`, `Right`) des Panels hinzu. `order` dient als Sortierhinweis.|`child` ist ein gültiges `gtk::Widget`. `area` ist ein gültiger `PanelChildrenArea`-Wert.|`child` wird dem spezifizierten Bereich des Panels hinzugefügt und ist sichtbar (wenn das Panel sichtbar ist).|`ChildWidgetAddFailed` (z.B. wenn `child` bereits ein Parent hat)|
|`pub fn remove_child_widget(&self, child: &impl IsA<gtk::Widget>) -> Result<(), PanelWidgetError>`|Entfernt ein spezifisches Kind-Widget aus dem Panel.|`child` ist ein aktuelles Kind-Widget des Panels.|`child` wird aus dem Panel entfernt und dessen Parent-Beziehung aufgelöst.|`ChildWidgetRemoveFailed` (z.B. wenn `child` nicht gefunden wird)|
|`pub fn update_theme_dependent_elements(&self, accent_color: &gdk::RGBA, theme_name: &str)`|Aktualisiert UI-Elemente, die vom Theme abhängen (insbesondere den Leuchtakzent und Hell/Dunkel-Modus Anpassungen).|`accent_color` ist gültig. `theme_name` gibt das aktuelle GTK-Theme an.|Leuchtakzent und andere themenabhängige Stile werden entsprechend der neuen Akzentfarbe und des Themes aktualisiert.|-|

Die Tabelle der öffentlichen API-Methoden dient als "Vertragsdokument" für andere Teile der UI-Schicht, die mit dem Panel interagieren. Sie definiert klar die unterstützten Operationen, deren Verhalten und Parameter.

#### 2.6.2. Interne Hilfsmethoden

Diese Methoden sind nicht Teil der öffentlichen API und dienen der internen Strukturierung und Logik. Sie werden typischerweise in `panel_widget/imp.rs` definiert oder als private Methoden in `panel_widget/mod.rs`.

**Tabelle 2.6.2: `PanelWidget` Interne Hilfsmethoden**

|   |   |   |
|---|---|---|
|**Methodensignatur (Rust) (Beispielhaft)**|**Beschreibung**|**Kontext der Verwendung**|
|`fn setup_initial_state(obj: &super::PanelWidget)`|Setzt initiale Property-Werte und verbindet notwendige Signale nach der Konstruktion.|Aufgerufen am Ende von `ObjectImpl::constructed()` für `imp::PanelWidget`.|
|`fn load_specific_css(obj: &super::PanelWidget)`|Lädt die `panel_widget.css` Datei (falls vorhanden) und wendet sie auf das Widget an.|Aufgerufen in `ObjectImpl::constructed()` oder `class_init`.|
|`fn update_glow_accent_style(obj: &super::PanelWidget, color: Option<&gdk::RGBA>, position: PanelPosition)`|Aktualisiert dynamisch die CSS-Klasse oder Inline-Stile für den Leuchtakzent.|Aufgerufen von `update_theme_dependent_elements` oder bei Änderung der `show-glow-accent` Eigenschaft.|
|`fn connect_theme_signals(obj: &super::PanelWidget)`|Verbindet mit Signalen von `domain::theming` (z.B. `gio::Settings` für `gtk-theme-name` und `color-scheme`) um Theme-Änderungen zu empfangen.|Aufgerufen in `setup_initial_state` oder `constructed`.|
|`fn get_target_box(obj: &super::PanelWidget, area: PanelChildrenArea) -> GtkBox`|Gibt eine geklonte Referenz auf die `left_box`, `center_box` oder `right_box` zurück.|Von `add_child_widget`.|

Interne Hilfsmethoden verbessern die Organisation und Wartbarkeit des Panel-Codes, indem sie wiederverwendbare Logik kapseln.

#### 2.6.3. Detaillierte Schritt-für-Schritt Implementierungslogik für ausgewählte Methoden

- `PanelWidget::add_child_widget(&self, child: &impl IsA<gtk::Widget>, area: PanelChildrenArea, order: i32)`:
    
    1. Ermittle das `imp::PanelWidget`-Objekt (interner Zustand) aus `self`.
    2. Rufe `get_target_box(area)` auf, um den Ziel-`gtk::Box` Container (`left_box`, `center_box` oder `right_box`) zu erhalten. Diese Boxen sind `TemplateChild<GtkBox>`.
    3. Prüfe, ob `child` bereits einen Parent hat. Wenn ja, und dieser Parent nicht das `PanelWidget` selbst ist, gib `$Result::Err(PanelWidgetError::ChildWidgetAddFailed("Widget already has a parent".into()))$` zurück.
    4. Setze eine benutzerdefinierte Eigenschaft oder ein `qdata`-Feld auf dem `child` mit dem Wert `order`. Dies ist optional und dient dazu, die Sortierreihenfolge zu speichern, falls eine dynamische Neusortierung implementiert wird. GTK `Box` selbst sortiert Kinder nicht dynamisch basierend auf einer Property; die Reihenfolge wird durch `append`, `prepend` oder `reorder_child` bestimmt.
    5. Füge `child` dem Ziel-`gtk::Box` hinzu: `target_box.append(child);`.
    6. Falls eine explizite Sortierung basierend auf `order` erforderlich ist und nicht durch die Reihenfolge des Hinzufügens gewährleistet wird:
        - Iteriere über die Kinder der `target_box`.
        - Entferne `child` temporär.
        - Finde die korrekte Einfügeposition basierend auf den `order`-Werten der anderen Kinder.
        - Füge `child` an der korrekten Position wieder ein (`target_box.insert_child_after(child, Option<previous_sibling>)` oder `target_box.reorder_child(child, new_index)`).
        - **Entscheidung für die Erstimplementierung:** Die Sortierung erfolgt primär durch die Wahl der `PanelChildrenArea` und die Reihenfolge, in der Widgets hinzugefügt werden. Die `order`-Eigenschaft dient als Vorbereitung für eventuell komplexere, zukünftige Sortieranforderungen.
    7. Gib `$Result::Ok(())$` zurück.
- `PanelWidget::update_theme_dependent_elements(&self, accent_color: &gdk::RGBA, theme_name: &str)`:
    
    1. Ermittle das `imp::PanelWidget`-Objekt.
    2. Aktualisiere die interne `glow_accent_color_prop` Property: `imp.glow_accent_color_prop.replace(Some(accent_color.clone()));`. Emittiere `notify::glow-accent-color`.
    3. Rufe `update_glow_accent_style(self, Some(accent_color), self.position())` auf.
    4. Passe ggf. CSS-Klassen für Hell/Dunkel-Modus an, basierend auf `theme_name` (z.B. wenn das Panel spezifische Stile für Dark-Mode hat, die nicht global greifen). Dies geschieht meist automatisch durch das GTK-Theming-System, aber manuelle Anpassungen sind hier möglich.
        
        Rust
        
        ```
        // In panel_widget/mod.rs
        //...
        // fn update_glow_accent_style(&self, color: Option<&gdk::RGBA>, position: PanelPosition) {
        //     let style_context = self.style_context();
        //     style_context.remove_class("glow-accent-visible"); // Alte Klasse entfernen
        //
        //     if self.show_glow_accent() && color.is_some() {
        //         style_context.add_class("glow-accent-visible");
        //
        //         // Dynamisches Setzen einer CSS-Variable für die Akzentfarbe
        //         // Dies ist der bevorzugte Weg, um Farben an CSS zu übergeben.
        //         let c = color.unwrap();
        //         let css_color = format!("rgba({},{},{},{})",
        //                                (c.red() * 255.0) as u8,
        //                                (c.green() * 255.0) as u8,
        //                                (c.blue() * 255.0) as u8,
        //                                c.alpha());
        //
        //         let provider = gtk::CssProvider::new();
        //         let css_data = format!(
        //             ".nova-panel-widget.glow-accent-visible {{ --nova-panel-glow-color: {}; }}",
        //             css_color
        //         );
        //         provider.load_from_data(&css_data);
        //
        //         // Provider mit hoher Priorität hinzufügen, um globale Theme-Variablen zu überschreiben,
        //         // oder besser: Theme stellt --nova-accent-color bereit und CSS nutzt diese.
        //         // Hier wird angenommen, dass das Panel seine eigene Akzentfarbe setzt.
        //         gtk::StyleContext::add_provider_for_display(
        //             &self.display(),
        //             &provider,
        //             gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
        //         );
        //
        //         // Panel-spezifische Klassen für Position (oben/unten)
        //         style_context.remove_class("panel-top");
        //         style_context.remove_class("panel-bottom");
        //         match position {
        //             PanelPosition::Top => style_context.add_class("panel-top"),
        //             PanelPosition::Bottom => style_context.add_class("panel-bottom"),
        //         }
        //     }
        // }
        ```
        
        Die bevorzugte Methode zur Anwendung der Akzentfarbe ist jedoch die Verwendung von CSS-Variablen, die vom globalen Theme bereitgestellt werden.12 Das `PanelWidget` würde dann nur eine Klasse wie `glow-accent-visible` setzen, und die Farbe käme automatisch vom Theme (`var(--nova-accent-color)` im CSS). Die obige `update_glow_accent_style` Methode sollte sich darauf konzentrieren, die notwendigen CSS-Klassen zu setzen und sicherzustellen, dass das Widget neu gezeichnet wird. Die direkte Manipulation von CSS-Providern für Farbwerte sollte vermieden werden, wenn das Theming-System dies global handhaben kann.

Die Methoden `add_child_widget` und `remove_child_widget` sind entscheidend für die Flexibilität des Panels. NovaDE könnte es Nutzern erlauben, Panel-Elemente zur Laufzeit anzupassen, oder verschiedene Profile könnten unterschiedliche Elementkombinationen laden. Die Methode `update_theme_dependent_elements` ist kritisch für die Einhaltung des visuellen Stils von NovaDE, insbesondere für den "Leuchtakzent", und muss bei jeder relevanten Theme-Änderung aufgerufen werden.

### 2.7. `PanelWidget`: UI-Layout und Theming (GTK4 Composite Template & CSS)

Das Layout und das grundlegende Erscheinungsbild des `PanelWidget` werden durch eine GTK4 Composite Template UI-Datei (`.ui`) und zugehörige CSS-Regeln definiert.

#### 2.7.1. Struktur der `panel_widget.ui` Datei

Die UI-Definition basiert auf `GtkBox` als Wurzel-Template-Klasse. Die Datei befindet sich unter `resources/ui/shell/panel_widget.ui` (oder einem ähnlichen Pfad, der über `gio::resources_register_include!` im Build-Skript eingebunden wird) und wird im Code mit `@template(resource = "/org/nova_de/ui/shell/panel_widget.ui")` referenziert.

XML

```
<?xml version="1.0" encoding="UTF-8"?>
<interface domain="nova-de"> <template class="NovaDEPanelWidget" parent="GtkBox">
    <property name="orientation">horizontal</property>
    <property name="css_classes">nova-panel-widget</property>
    <child>
      <object class="GtkBox" id="left_box">
        <property name="orientation">horizontal</property>
        <property name="halign">start</property>
        <property name="hexpand">true</property> <property name="css_classes">panel-area panel-left-area</property>
        <style>
          <class name="spacing-small"/> </style>
      </object>
    </child>
    <child>
      <object class="GtkBox" id="center_box">
        <property name="orientation">horizontal</property>
        <property name="halign">center</property>
        <property name="hexpand">false</property> <property name="css_classes">panel-area panel-center-area</property>
        <style>
          <class name="spacing-small"/>
        </style>
      </object>
    </child>
    <child>
      <object class="GtkBox" id="right_box">
        <property name="orientation">horizontal</property>
        <property name="halign">end</property>
        <property name="hexpand">true</property> <property name="css_classes">panel-area panel-right-area</property>
        <style>
          <class name="spacing-small"/>
        </style>
      </object>
    </child>
  </template>
</interface>
```

Die `hexpand`-Eigenschaften sind so konfiguriert, dass die `center_box` zentriert bleibt, während `left_box` und `right_box` den verfügbaren Raum dynamisch aufteilen. Die Klasse `spacing-small` (oder ähnlich) könnte im globalen CSS definiert sein, um konsistente Abstände zwischen den Panel-Elementen zu gewährleisten.

**Tabelle 2.7.1: `PanelWidget.ui` Kind-Widget-IDs und Typen (Primärcontainer)**

|   |   |   |
|---|---|---|
|**ID (#[template_child])**|**GTK-Widget-Typ**|**Zweck**|
|`left_box`|`GtkBox`|Container für linksbündige Panel-Elemente (z.B. AppMenu, WorkspaceSwitcher).|
|`center_box`|`GtkBox`|Container für zentrierte Panel-Elemente (z.B. Uhr).|
|`right_box`|`GtkBox`|Container für rechtsbündige Panel-Elemente (z.B. Tray, Indikatoren).|

Die deklarative Natur der `.ui`-Datei 2 erlaubt eine visuell nachvollziehbare Definition der Panel-Grundstruktur. Layout-Änderungen können oft direkt im XML erfolgen, ohne Rust-Code anpassen zu müssen.9 Dies beschleunigt die UI-Entwicklung. Die Tabelle 2.7.1 dokumentiert die Brücke zwischen XML-Deklaration und Rust-Code (`#[template_child]`).

#### 2.7.2. CSS-Klassen und -IDs für das `PanelWidget` und seine primären Elemente

Für das Styling werden CSS-Klassen verwendet. IDs sollten primär für die `#[template_child]`-Anbindung genutzt werden und im CSS nur sparsam, um die Spezifität niedrig zu halten.14

**Tabelle 2.7.2: `PanelWidget` CSS-Klassen**

|   |   |   |
|---|---|---|
|**CSS-Klasse**|**Anwendungsbereich**|**Beschreibung**|
|`nova-panel-widget`|Das Haupt-Widget des Panels (`NovaDEPanelWidget`)|Basis-Styling für das Panel (Hintergrund, Padding, Schrift etc.).|
|`panel-top`|`nova-panel-widget` (wenn Position oben)|Spezifische Stile für ein oben positioniertes Panel (z.B. unterer Rand/Schatten für Leuchtakzent).|
|`panel-bottom`|`nova-panel-widget` (wenn Position unten)|Spezifische Stile für ein unten positioniertes Panel (z.B. oberer Rand/Schatten für Leuchtakzent).|
|`panel-area`|`left_box`, `center_box`, `right_box`|Gemeinsames Styling für die Hauptbereiche (z.B. vertikales Padding).|
|`panel-left-area`|`left_box`|Spezifisches Styling für den linken Bereich.|
|`panel-center-area`|`center_box`|Spezifisches Styling für den mittleren Bereich.|
|`panel-right-area`|`right_box`|Spezifisches Styling für den rechten Bereich.|
|`glow-accent-visible`|`nova-panel-widget`|Wird dynamisch via Code gesetzt, um den Leuchtakzent sichtbar zu machen. Das CSS definiert dann den eigentlichen Stil.|
|`panel-child-item`|Alle direkten Kinder in `left/center/right_box`|Einheitliches Styling für Panel-Elemente (z.B. Margins, Paddings, vertikale Ausrichtung).|
|`spacing-small` / `spacing-medium`|`GtkBox` Container oder einzelne Elemente|Definiert Standardabstände (z.B. `column-spacing` für Boxen, `margin` für Items).|

Diese CSS-Klassen (Tabelle 2.7.2) sind unverzichtbar für Theme-Entwickler und UI-Designer, die das Aussehen des Panels anpassen wollen, da sie die "Haken" für das CSS-Styling bereitstellen.

#### 2.7.3. Anwendung von Design-Tokens (`domain::theming`) via `GtkCssProvider`

Das globale NovaDE-Theme, definiert in domain::theming, stellt Design-Tokens als CSS-Variablen bereit (z.B. --nova-accent-color, --nova-panel-background, --nova-text-color). Diese werden über GtkSettings:gtk-theme-name und GtkStyleContext::add_provider_for_display systemweit geladen.12

Das PanelWidget und sein spezifisches panel_widget.css (falls vorhanden) nutzen diese vordefinierten CSS-Variablen.

Beispielhafte Verwendung in `panel_widget.css` oder im globalen Theme:

CSS

```
.nova-panel-widget {
    background-color: var(--nova-panel-background, #23272e); /* Fallback-Farbe */
    color: var(--nova-fg-color, white);
    padding: 0 6px; /* Globales horizontales Padding für das Panel */
    min-height: 24px; /* Mindesthöhe sicherstellen */
}

.panel-area >.panel-child-item { /* Styling für Elemente direkt in den Bereichen */
    padding: 4px 6px; /* Vertikales und horizontales Padding für jedes Element */
    margin: 0 2px;    /* Kleiner horizontaler Abstand zwischen Elementen */
}

.nova-panel-widget.panel-top.glow-accent-visible {
    border-bottom: 2px solid var(--nova-accent-color, #5294e2); /* Standard-Akzentfarbe als Fallback */
    box-shadow: 0px 2px 5px 0px alpha(var(--nova-accent-color, #5294e2), 0.3);
}

.nova-panel-widget.panel-bottom.glow-accent-visible {
    border-top: 2px solid var(--nova-accent-color, #5294e2);
    box-shadow: 0px -2px 5px 0px alpha(var(--nova-accent-color, #5294e2), 0.3);
}

/* Beispiel für Abstands-Klassen, die im.ui File verwendet werden könnten */
.spacing-small > * { /* Gilt für direkte Kinder einer Box mit.spacing-small */
    margin-left: 4px;
    margin-right: 4px;
}
.spacing-small > *:first-child {
    margin-left: 0;
}
.spacing-small > *:last-child {
    margin-right: 0;
}
```

Die konsequente Nutzung von CSS-Variablen 15 ist der Schlüssel zur Erfüllung der Anforderungen an Anpassbarkeit und dynamische Theme-Wechsel. Das `PanelWidget` wird so zu einem integralen Bestandteil des visuell konsistenten NovaDE-Ökosystems.

#### 2.7.4. Spezifikation des "optionalen Leuchtakzents"

Der Leuchtakzent ist ein Kernmerkmal des Panel-Designs und wird primär über CSS realisiert:

- Eine CSS-Klasse, z.B. `glow-accent-visible`, wird dem `NovaDEPanelWidget`-Wurzelelement dynamisch hinzugefügt oder entfernt, basierend auf dem Wert der GObject-Eigenschaft `show-glow-accent`.
- Zusätzliche Klassen wie `panel-top` oder `panel-bottom` (basierend auf der `position`-Eigenschaft) bestimmen, ob der Akzent als unterer oder oberer Rand/Schatten erscheint.
- Die Farbe des Akzents wird durch die CSS-Variable `--nova-accent-color` (oder eine spezifischere wie `--nova-panel-glow-color`, falls abweichend vom globalen Akzent gewünscht) gesteuert. Diese Variable wird vom Theming-System (`domain::theming`) bereitgestellt und bei Theme-Wechseln aktualisiert.
- Der Akzent selbst wird durch eine Kombination aus `border` (z.B. `border-bottom` oder `border-top`) und einem subtilen `box-shadow` in der Akzentfarbe implementiert, um einen "Leucht"-Effekt zu erzeugen.
- Die genaue visuelle Ausprägung (Dicke des Borders, Farbe, Weichzeichnung und Ausdehnung des Schattens) wird in der CSS-Datei des Themes oder in einer spezifischen `panel_widget.css` definiert, die die Theme-Variablen nutzt.

Dieser Ansatz der Trennung von Struktur (UI-XML), Stil (CSS) und Verhalten (Rust), gefördert durch GTK4 und Composite Templates 2, ist eine bewährte Methode zur Entwicklung wartbarer und flexibler Benutzeroberflächen.

### 2.8. `PanelWidget`: Integration von Sub-Modulen (Platzhalter-Schnittstellen)

Das `PanelWidget` dient als Container. Die eigentlichen funktionalen Elemente (AppMenu-Button, Uhr, Indikatoren etc.) sind eigenständige Widgets/Module, die separat spezifiziert werden. Das `PanelWidget` stellt lediglich die Mechanismen bereit, um diese Kind-Widgets aufzunehmen und anzuordnen.

Die Integration erfolgt über die öffentliche Methode `PanelWidget::add_child_widget(&self, child: &impl IsA<gtk::Widget>, area: PanelChildrenArea, order: i32)`. Die übergeordnete `ui::shell`-Logik ist dafür verantwortlich, Instanzen der Sub-Modul-Widgets zu erstellen und sie dem entsprechenden `PanelWidget` (potenziell eines pro Monitor) hinzuzufügen.

- **2.8.1. AppMenu-Integration:** Ein `AppMenuButtonWidget` (separat spezifiziert) wird erstellt und via `add_child_widget` der `PanelChildrenArea::Left` hinzugefügt. Dieser Button löst das `app-menu-toggled`-Signal aus.
- **2.8.2. Workspace-Indikator-Integration:** Ein `WorkspaceIndicatorWidget` (separat spezifiziert) wird erstellt und der `PanelChildrenArea::Left` (oder `Center`, je nach Designentscheidung) hinzugefügt.
- **2.8.3. Uhr-Integration:** Ein `ClockWidget` (separat spezifiziert) wird erstellt und der `PanelChildrenArea::Center` (oder `Right`) hinzugefügt.
- **2.8.4. System-Tray-Integration:** Ein `SystemTrayWidget` (separat spezifiziert, potenziell komplex aufgrund des `StatusNotifierItem`-Protokolls) wird erstellt und der `PanelChildrenArea::Right` hinzugefügt.
- **2.8.5. Schnelleinstellungen-Button-Integration:** Ein `QuickSettingsButtonWidget` (separat spezifiziert, könnte ein einfacher `gtk::Button` oder `gtk::MenuButton` sein) wird erstellt und der `PanelChildrenArea::Right` hinzugefügt. Dieser Button löst das `quick-settings-toggled`-Signal aus, woraufhin das `QuickSettingsPanelWidget` (ein Popover-Typ 16) angezeigt wird.
- **2.8.6. Benachrichtigungszentrum-Button-Integration:** Ein `NotificationCenterButtonWidget` (analog zum Schnelleinstellungen-Button) wird erstellt und der `PanelChildrenArea::Right` hinzugefügt. Dieser Button löst das `notification-center-toggled`-Signal aus.
- **2.8.7. Netzwerk-, Energie-, Audio-Indikator-Integration:** Jeder Indikator (z.B. `NetworkIndicatorWidget`, `PowerIndicatorWidget`, `AudioIndicatorWidget` – alle separat spezifiziert) wird als eigenständiges Widget erstellt und der `PanelChildrenArea::Right` hinzugefügt. Diese Widgets sind dafür verantwortlich, Daten von relevanten Systemdiensten (z.B. NetworkManager, UPower 18, PipeWire) über D-Bus 11 oder andere Mechanismen der System- oder Domänenschicht zu beziehen und darzustellen.

Die Entscheidung, Sub-Module als separate Widgets zu behandeln, die über eine generische `add_child_widget`-Methode integriert werden, ist ein starkes Bekenntnis zur Modularität. Es erzwingt, dass jedes dieser Sub-Module eine wohldefinierte `gtk::Widget`-Schnittstelle besitzt und keine versteckten Abhängigkeiten zum `PanelWidget` aufbaut. Das Panel bleibt ein reiner Container, und die funktionalen Elemente können unabhängig entwickelt, getestet und potenziell wiederverwendet werden. Viele der durch Panel-Buttons ausgelösten Interaktionen, wie das Anzeigen von Schnelleinstellungen oder Kalendern, werden typischerweise als `GtkPopover` oder `GtkPopoverMenu` implementiert.4 Das Panel selbst hostet nur die Auslöser (Buttons), nicht die Popovers; die Signale des Panels sind das Bindeglied.

### 2.9. `PanelWidget`: Fehlerbehandlung und Ausnahmeklassen

Eine robuste Fehlerbehandlung ist essentiell für die Stabilität der UI.

#### 2.9.1. Definition der `PanelWidgetError` Enum (via `thiserror`)

In `panel_widget/error.rs` wird eine spezifische Fehler-Enum für das `PanelWidget`-Modul definiert:

Rust

```
use thiserror::Error;

#
pub enum PanelWidgetError {
    #[error("Failed to add child widget to panel: {0}")]
    ChildWidgetAddFailed(String),

    #[error("Failed to remove child widget from panel: {0}")]
    ChildWidgetRemoveFailed(String),

    #[error("Invalid configuration provided for panel widget: {0}")]
    InvalidConfiguration(String),

    #[error("Failed to apply style to panel widget: {0}")]
    StylingError(String),
    // Weitere spezifische Fehlerarten nach Bedarf
}
```

Diese Enum, die `thiserror::Error` ableitet, ermöglicht eine klare und typisierte Fehlerkommunikation. Aufrufer können spezifisch auf Fehler reagieren.

#### 2.9.2. Fehlerbehandlungsstrategien innerhalb des Moduls

- Öffentliche Methoden, die fehlschlagen können (z.B. `add_child_widget`, `remove_child_widget`), geben `$Result<T, PanelWidgetError>$` zurück, wie in den Entwicklungsrichtlinien von NovaDE vorgesehen.
- Interne Fehler, die nicht nach außen propagiert werden müssen oder können (z.B. Fehler beim Laden optionaler Ressourcen, die zu einem Fallback-Verhalten führen), werden mit `tracing::error!` oder `tracing::warn!` geloggt.
- Panics sind strikt zu vermeiden, außer bei nicht behebbaren Programmierfehlern (z.B. Nichterfüllung von Vorbedingungen, die durch `debug_assert!` in Entwicklungs-Builds geprüft werden könnten). Solche Fälle deuten auf Fehler in der Logik hin und sollten während der Entwicklung identifiziert und behoben werden.

Die konsequente Anwendung dieser Fehlerbehandlungsstrategien erhöht die Robustheit und Wartbarkeit des `PanelWidget` und des Gesamtsystems.

### 2.10. `PanelWidget`: Interaktion mit Domänen- und Systemschicht

Das `PanelWidget` muss die in der NovaDE-Architektur definierten Schichtengrenzen wahren.

#### 2.10.1. Abruf von Daten

- **Theme-Informationen:** Das `PanelWidget` reagiert auf Änderungen der globalen Akzentfarbe und des Hell/Dunkel-Modus. Diese Informationen werden von `domain::theming` bereitgestellt. Die Anbindung erfolgt typischerweise über:
    - Beobachtung von `gio::Settings`-Schlüsseln (z.B. `org.gnome.desktop.interface gtk-theme`, `org.gnome.desktop.interface color-scheme`).
    - Beobachtung eines NovaDE-spezifischen `gio::Settings`-Schlüssels oder eines D-Bus-Signals für die Akzentfarbe, falls diese nicht über Standardmechanismen abgedeckt ist. Die Methode `connect_theme_signals` im `PanelWidget` ist für die Einrichtung dieser Beobachter zuständig. Bei Empfang einer Änderung wird `update_theme_dependent_elements` aufgerufen.
- **Workspace-Informationen:** Das `PanelWidget` selbst benötigt keine direkten Workspace-Daten. Diese werden vom `WorkspaceIndicatorWidget` (oder einem ähnlichen, im Panel gehosteten Widget) verarbeitet, das seinerseits mit `domain::workspaces` kommuniziert.
- **Status-Indikatoren (Netzwerk, Energie, etc.):** Analog zu den Workspace-Informationen beziehen die jeweiligen Indikator-Widgets ihre Daten von der System- oder Domänenschicht (z.B. UPower-Status via D-Bus 18). Das `PanelWidget` stellt nur den Container bereit.

#### 2.10.2. Auslösen von Aktionen

- Das `PanelWidget` löst primär UI-interne Aktionen aus, wie das Anzeigen von Popovers (z.B. Schnelleinstellungen, Benachrichtigungszentrum) über seine GObject-Signale.
- Das Öffnen von Systemeinstellungsmodulen (z.B. Klick auf den Netzwerk-Indikator öffnet die Netzwerkeinstellungen im `ui::control_center`) wird von den jeweiligen Indikator-Widgets selbst initiiert. Diese können hierfür D-Bus-Methodenaufrufe an `ui::control_center` senden oder andere IPC-Mechanismen nutzen, die von der `ui::shell` oder `ui::control_center` bereitgestellt werden.

Diese klare Trennung stellt sicher, dass das `PanelWidget` ein reines UI-Element bleibt und nicht mit systemspezifischer Logik oder direkten Datenabfragen aus tieferen Schichten überfrachtet wird. Dies erhält die Modularität und Testbarkeit der Gesamtarchitektur. Viele Daten, die im Panel angezeigt werden (Netzwerkstatus, Akkustand), fließen nicht direkt in das Panel, sondern in die spezialisierten Indikator-Widgets, die das Panel hostet. Das Panel ist somit eher ein "Präsentator von Präsentatoren".

### 2.11. `PanelWidget`: Testaspekte und -szenarien

Umfassende Tests sind gemäß den Entwicklungsrichtlinien von NovaDE für alle Module erforderlich.

#### 2.11.1. Unit-Tests für kritische Logik

- **Property-Handling:** Testen der Setter und Getter für alle GObject-Properties, einschließlich Validierungslogik (z.B. für `height-request`) und korrekte Emission von `notify::*`-Signalen bei Wertänderungen.
- **Kind-Widget-Management:** Testen der Logik zum Hinzufügen (`add_child_widget`) und Entfernen (`remove_child_widget`) von Kind-Widgets. Dies beinhaltet die Überprüfung, ob Widgets korrekt den Bereichen `left_box`, `center_box`, `right_box` hinzugefügt und wieder entfernt werden und ob Fehlerfälle (z.B. Hinzufügen eines Widgets, das bereits einen Parent hat) korrekt mit `$PanelWidgetError$` behandelt werden.
- **Zustandsänderungen:** Testen interner Zustandsänderungen als Reaktion auf den Aufruf öffentlicher Methoden oder die Änderung von Properties (z.B. Setzen der CSS-Klasse `glow-accent-visible` bei Änderung von `show-glow-accent`).
- **Abhängigkeits-Mocking:** Wo das `PanelWidget` von externen Signalen abhängt (z.B. Theme-Änderungen), sollten diese Abhängigkeiten in Unit-Tests gemockt werden, um die Reaktion des Panels (z.B. Aufruf von `update_theme_dependent_elements`) isoliert zu testen.

#### 2.11.2. Integrationsszenarien mit (simulierten) Sub-Modulen

- **Layout-Tests:** Testen des korrekten Layouts von hinzugefügten (Mock-)Kind-Widgets in den drei Hauptbereichen. Überprüfung, ob `hexpand`-Einstellungen und Ausrichtung wie erwartet funktionieren.
- **Signal-Emission:** Testen, ob das `PanelWidget` die definierten Signale (z.B. `quick-settings-toggled`) korrekt emittiert, wenn simulierte Kind-Buttons (die diese Aktionen auslösen würden) "geklickt" werden (programmatische Aktivierung im Test).
- **Interaktion mit Popovers:** Obwohl die Popovers selbst separate Widgets sind, kann getestet werden, ob die Signale des Panels korrekt von einer Mock-Logik empfangen werden, die ein Popover simulieren würde.

#### 2.11.3. Überlegungen zu UI-Tests

Für UI-Tests können Werkzeuge aus dem gtk-rs Ökosystem oder externe Test-Frameworks in Betracht gezogen werden. Szenarien umfassen:

- **Sichtbarkeit und Erscheinungsbild:** Überprüfung der korrekten Anzeige des Panels und seiner Hauptbereiche auf einem simulierten Bildschirm. Visuelle Überprüfung (ggf. automatisiert durch Screenshot-Vergleiche) des Leuchtakzents und seiner Reaktion auf Theme-Änderungen.
- **Interaktion:** Simulation von Benutzerinteraktionen wie Klicks auf Buttons im Panel und Überprüfung, ob die entsprechenden Aktionen (z.B. das (simulierte) Öffnen eines Popovers oder Menüs) ausgelöst werden.
- **Dynamische Anpassungen:** Testen der Reaktion des Panels auf Laufzeitänderungen von Eigenschaften (z.B. Höhe, Position).

Das Testen von Widgets, die Composite Templates verwenden, erfordert möglicherweise spezifische Ansätze, um Template-Kinder zu inspizieren oder zu mocken. Die Test-Utilities von gtk-rs oder Ansätze, die eine laufende GTK-Anwendungsumgebung für Tests bereitstellen, können hier nützlich sein. Durch die Definition von Testszenarien bereits in der Spezifikationsphase wird sichergestellt, dass Testbarkeit von Anfang an ein Designkriterium ist, was spätere Probleme bei der Testautomatisierung vermeiden hilft.

## 3. Anhang

### 3.1. Referenzen zur "Technischen Gesamtspezifikation & Richtlinien"

Dieses Dokument ist im Kontext der übergeordneten "Technischen Gesamtspezifikation & Richtlinien für NovaDE" zu verstehen. Dieses Hauptdokument enthält verbindliche Vorgaben bezüglich der Gesamtarchitektur, des Technologie-Stacks, der Code-Qualitätsstandards und der allgemeinen Entwicklungsrichtlinien, die auch für die Implementierung des `PanelWidget` gelten.

### 3.2. Glossar für `PanelWidget`-spezifische Begriffe

- **Leuchtakzent:** Ein visueller Effekt, typischerweise ein farbiger Rand und/oder Schatten, am oberen oder unteren Rand des Panels, dessen Farbe sich dynamisch an die Akzentfarbe des System-Themes anpasst.
- **`PanelChildrenArea`:** Eine Rust-Enum (`Left`, `Center`, `Right`), die zur Spezifizierung dient, in welchem Hauptbereich eines `PanelWidget` ein Kind-Widget platziert werden soll.
- **Composite Template:** Eine XML-basierte UI-Definitionsdatei (`.ui`), die die Struktur und das initiale Layout eines benutzerdefinierten GTK-Widgets beschreibt und im Rust-Code über Makros an die Widget-Implementierung gebunden wird.2
- **Design-Token:** Abstrakte Variablen (oft als CSS-Variablen implementiert), die Designentscheidungen wie Farben, Schriftgrößen oder Abstände repräsentieren und eine konsistente und anpassbare Gestaltung über die gesamte Anwendung hinweg ermöglichen.15

**Technische Gesamtspezifikation & Richtlinien: Linux Desktop-Umgebung "NovaDE" (Essenz)**

**I. Vision und Kernziele**

- **Vision:** NovaDE ist eine innovative Linux-Desktop-Umgebung, die eine moderne, schnelle, intuitive und KI-gestützte Benutzererfahrung für Entwickler, Kreative und alltägliche Nutzer schafft. Ziel ist die Maximierung von Produktivität und Freude an der Systeminteraktion.
- **Kernziele:**
    - **Performance:** Durchgehend schnelle, reaktionsschnelle Umgebung.
    - **Intuition:** Natürlich anfühlende, leicht erlernbare und intelligent unterstützende UI.
    - **Modernität:** Einsatz aktueller Technologien und Designprinzipien.
    - **Modularität & Wartbarkeit:** Klare Architektur für einfache Erweiterung, Testbarkeit und Wartung.
    - **Anpassbarkeit:** Weitreichende Personalisierungsmöglichkeiten für Optik und Verhalten.
    - **KI-Integration:** Nahtlose, sichere KI-Assistenz unter voller Benutzerkontrolle.
    - **Stabilität & Sicherheit:** Höchste Priorität durch geeignete Technologien und Entwicklungspraktiken.

**II. Architektonischer Überblick: Vier-Schichten-Architektur**

NovaDE nutzt eine strikte, vier-schichtige Architektur für Modularität, lose Kopplung und hohe Kohäsion. Kommunikation zwischen Schichten erfolgt ausschließlich über wohldefinierte Schnittstellen.

1. **Kernschicht (Core Layer): Systemfundament**
    
    - **Verantwortlichkeiten:** Fundamentale Datentypen (`Point<T>`, `Color`, `TokenIdentifier`), allgemeine Dienstprogramme, Basis-Infrastruktur für Konfigurationsparsing und -zugriff (TOML, Serde), globales Logging-Framework (`tracing`), allgemeine Fehlerdefinitionen (`thiserror`).
    - **Abhängigkeiten:** Minimal (Rust std, uuid, chrono, thiserror, tracing, serde, toml, once_cell). Keine NovaDE-internen Abhängigkeiten.
    - **Interaktionen:** Stellt Funktionalität für alle höheren Schichten bereit.
2. **Domänenschicht (Domain Layer): Geschäftslogik & Regeln**
    
    - **Verantwortlichkeiten:** UI-unabhängige Kernlogik.
        - `domain::theming`: Logik der Theming-Engine, Design-Token-Verwaltung, dynamische Theme-Wechsel, `AppliedThemeState`.
        - `domain::workspaces`: Logik für Arbeitsbereiche ("Spaces"), Fensterzuweisung (`WindowIdentifier`, `WorkspaceId`), Workspace-Management, Persistenz.
        - `domain::user_centric_services`: KI-Interaktionslogik (`AIInteractionContext`), Einwilligungsmanagement (`AIConsent`, `AIDataCategory`, `AIModelProfile`), Benachrichtigungslogik (`Notification`, `NotificationUrgency`).
        - `domain::notifications_rules`: Regelbasierte Benachrichtigungsverarbeitung.
        - `domain::global_settings_and_state_management`: Verwaltung globaler Desktop-Einstellungen (`GlobalDesktopSettings`, `SettingValue`).
        - `domain::window_management_policy`: High-Level-Richtlinien für Fensterplatzierung, Tiling (Spalten, Spiralen), Snapping, Gaps.
    - **Abhängigkeiten:** Nur Kernschicht.
    - **Interaktionen:** Stellt Logik und Zustand für System- und UI-Schicht bereit (oft via Traits und Events wie `ThemeChangedEvent`).
3. **Systemschicht (System Layer): OS-Interaktion & technische Umsetzung**
    
    - **Verantwortlichkeiten:** Interaktion mit OS, Hardware, externen Diensten. Setzt Domänenrichtlinien technisch um.
        - `system::compositor`: Smithay-basierter Wayland-Compositor (`xdg-shell`, `wlr-layer-shell`, etc.), XWayland.
        - `system::input`: `libinput`-basierte Eingabeverarbeitung, Gesten, Seat-Management (`xkbcommon`).
        - `system::dbus`: `zbus`-Schnittstellen zu Systemdiensten (NetworkManager, UPower, logind, org.freedesktop.Notifications, org.freedesktop.secrets, PolicyKit).
        - `system::outputs`: Monitorkonfiguration (`wlr-output-management`, DPMS).
        - `system::audio`: `pipewire-rs` Client für Audio-Management.
        - `system::mcp`: `mcp_client_rs` für KI-Modell-Kommunikation basierend auf `domain::user_centric_services`.
        - `system::portals`: Backend für XDG Desktop Portals (FileChooser, Screenshot).
        - `system::window_mechanics`: Technische Umsetzung des Fenstermanagements (Positionierung, Tiling, Fokus) gemäß `domain::window_management_policy`. Technische Basis für "Intelligente Tab-Leiste".
    - **Abhängigkeiten:** Kern- und Domänenschicht.
    - **Interaktionen:** Stellt systemnahe Dienste/Events für UI-Schicht bereit. Empfängt UI-Befehle.
4. **Benutzeroberflächenschicht (User Interface Layer): Darstellung & Benutzerinteraktion**
    
    - **Verantwortlichkeiten:** Grafische Darstellung und direkte Benutzerinteraktion. Basiert auf GTK4 (`gtk4-rs`).
        - `ui::shell`: Haupt-Shell-UI (PanelWidget, SmartTabBarWidget pro "Space", QuickSettingsPanelWidget, WorkspaceSwitcherWidget, QuickActionDockWidget, NotificationCenterPanelWidget).
        - `ui::control_center`: Modulare GTK4-Anwendung für Systemeinstellungen.
        - `ui::widgets`: Widget-System (RightSidebarWidget, WidgetManagerService, WidgetPickerPopover, diverse Widgets wie ClockWidget).
        - `ui::window_manager_frontend`: UI-Aspekte des Fenstermanagements (CSD, OverviewModeWidget, AltTabSwitcherWidget).
        - `ui::notifications_frontend`: Pop-up-Benachrichtigungen (NotificationPopupWidget).
        - `ui::theming_gtk`: Anwendung von CSS (aus `domain::theming`) via `GtkCssProvider`.
        - `ui::components`: Wiederverwendbare GTK4-Widgets.
        - `ui::speed_dial`: Startansicht für leere Workspaces.
        - `ui::command_palette`: Kontextuelle Befehlspalette.
    - **Abhängigkeiten:** Alle darunterliegenden Schichten.
    - **Interaktionen:** Empfängt System-Events. Visualisiert Daten aus Domäne/System. Löst Aktionen in Domäne/System aus.

**III. Technologie-Stack (Verbindliche Auswahl)**

|Bereich|Technologie/Standard|
|:--|:--|
|Programmiersprache|Rust|
|Build-System|Meson|
|GUI-Toolkit|GTK4 (mit `gtk4-rs` Bindings)|
|Wayland Compositor & Bibliotheken|Smithay Toolkit|
|Essentielle Wayland-Protokolle|`wayland.xml`, `xdg-shell`, `wlr-layer-shell-unstable-v1`, `xdg-decoration-unstable-v1`, `wlr-foreign-toplevel-management-unstable-v1`, `wlr-output-management-unstable-v1`, etc.|
|Inter-Prozess-Kommunikation (IPC)|D-Bus (mit `zbus` Crate)|
|KI-Integration|Model Context Protocol (MCP) (mit `mcp_client_rs` Crate)|
|Eingabeverarbeitung|`libinput` (integriert via Smithay)|
|Audio-Management|PipeWire (mit `pipewire-rs` Crate)|
|Geheimnisverwaltung|Freedesktop Secret Service API (via D-Bus)|
|Rechteverwaltung|PolicyKit (polkit) (via D-Bus)|
|Theming-Implementierung (UI)|Token-basiert, GTK4 CSS Custom Properties (`var()`)|
|Sandboxing-Interaktion|XDG Desktop Portals (via D-Bus)|

In Google Sheets exportieren

**IV. Entwicklungsrichtlinien (Verbindlich)**

- **Rust:**
    - **Stil:** `rustfmt` (Standard), max. 100 Zeichen/Zeile, 4 Leerzeichen Einrückung.
    - **API-Design:** Rust API Guidelines Checklist.
    - **Fehlerbehandlung:** `thiserror` pro Modul, `Result<T, E>`, Panics nur für interne Invariantenverletzungen/Tests. Klare `#[error]`-Nachrichten, keine sensiblen Daten. `source()`-Kette erhalten.
    - **Logging & Tracing:** `tracing` Crate, Spans (`#[tracing::instrument]`), Standard-Level, keine sensiblen Daten.
    - **Nebenläufigkeit:** `async/await` (tokio, `glib::MainContext::spawn_local`), thread-sichere Datenstrukturen.
    - **Crate-Struktur:** Logische Aufteilung (z.B. `novade-core`, `novade-domain`), klare APIs.
- **Versionskontrolle:** Git, GitHub Flow, PRs mit Review & CI-Checks, Conventional Commits.
- **Teststrategie:** Unit-Tests (Kern, Domäne, Logik-Komponenten), Integrationstests, Compositor-Tests (Smithay Headless Backends), UI-Tests (Accessibility-APIs).
- **CI-Pipeline:** Tests, `cargo fmt --check`, `cargo clippy -D warnings`, `cargo audit`.
- **Dokumentation:**
    - **Code (rustdoc):** Umfassend für alle öffentlichen APIs (Was, Warum, Wie, Fehler, Sicherheit, Beispiele).
    - **Architektur:** Dieses Dokument als Referenz, High-Level-Diagramme.
    - **READMEs:** Pro Crate/Komponente.
    - **Metadaten:** Vollständige `Cargo.toml`.
    - **Benutzer-/Entwicklerdoku:** Parallel erstellen.

**V. Initiale Schicht- und Komponentenspezifikationen (Struktur)**

Detaillierte Spezifikationen pro Komponente/Schicht folgen einer einheitlichen Struktur: Modul-/Komponentenübersicht, Datenstrukturen/Typdefinitionen (Rust-Syntax), Öffentliche API/Interne Schnittstellen (Signaturen, Logik, Events), Fehlerbehandlung (`thiserror`-Enum), Interaktionen/Abhängigkeiten, Implementierungsschritte, Testaspekte.

**VI. Deployment-Überlegungen**

- **Paketierung:** Native Pakete (.deb, .rpm), Flatpak (evaluieren). Meson-Build für Artefakte.
- **Systemintegration:** Display Manager (GDM, LightDM), `systemd` User Sessions, PAM, XDG Base Directory Specification.
- **Konfiguration:** Sinnvolle Standardkonfiguration, UI-basierte Anpassung (`ui::control_center`), Trennung System-/Benutzerkonfig.
- **Updates:** Distro-Paketmanager, Flatpak-Mechanismus. SemVer. Konfigurationsmigration.

**VII. Anforderungen aus der Benutzererfahrung (Essenz)**

NovaDE soll eine **intelligente, intuitive und persönliche** Erfahrung bieten, die sich wie eine natürliche Erweiterung des Nutzers anfühlt.

- **Ästhetik & Navigation:** Klare, dunkle Ästhetik mit benutzerwählbaren Akzentfarben. Flüssige Animationen (Wayland-basiert). Mühelose Navigation und Informationszugriff.
- **Personalisierung (Theming):** Dynamischer Wechsel zwischen Designs (Hell/Dunkel) und Akzentfarben zur Laufzeit (Token-basiertes Theming).
- **Fenster- & Workspace-Management ("Spaces"):**
    - **Intelligente Tab-Leiste pro Space:** Zeigt "angepinnte" Apps/Split-Views.
    - **Workspace-Switcher (Linke Seitenleiste):** Visueller Wechsel zwischen Spaces mit Icons/Namen.
    - **Fortschrittliche Fensterverwaltung:** Automatisches Tiling (Spalten, Spiralen etc.), Snapping, Stacking, Floating mischbar, konfigurierbare Gaps.
    - **Übersichtsmodus:** Visuelle Darstellung aller Fenster/Spaces, Drag & Drop zwischen Spaces.
- **Interaktionskomponenten:**
    - **Kontroll-/Systemleiste(n):** Schneller Zugriff auf Systemfunktionen, Benachrichtigungszentrum.
    - **Quick-Settings-Panel:** Schnelleinstellungen ohne Control Center.
    - **Control Center:** Zentrale, modulare Systemeinstellungen mit Live-Vorschau.
    - **Schnellaktionsdock:** Konfigurierbar für Apps, Dateien, Aktionen; intelligente Vorschläge.
    - **Adaptive Seitenleisten & Widgets:** Links für Navigation/"Spaces", rechts für informative Widgets (Uhr, Kalender, Wetter, etc.), anpassbar via Drag & Drop.
    - **Speed-Dial:** Startansicht für leere Workspaces mit Favoriten und intelligenten Vorschlägen.
    - **Kontextuelle Befehlspalette (`Super+Space`):** Schneller Zugriff auf Aktionen, Einstellungen, Apps via Texteingabe mit Fuzzy-Matching und Kontextsensitivität.
- **KI-Integration (Sicher & Kontrolliert):**
    - **Model Context Protocol (MCP):** Sicherer, standardisierter Zugriff auf lokale/Cloud-LLMs.
    - **Explizite Zustimmung:** Keine KI-Aktion ohne klares Verständnis und Erlaubnis des Nutzers. Feingranulare Berechtigungen.
    - **Praktische Funktionen:** Sprachsteuerung, automatisierte Dateiaufgaben, kontextbezogene Informationen.
    - **Sichere Speicherung:** Sensible Daten (API-Keys) via Freedesktop Secret Service.
- **Systemintegration:**
    - **Wayland & XWayland:** Moderne, sichere Darstellung.
    - **D-Bus:** Kommunikation mit Systemdiensten.
    - **PolicyKit:** Sicherheit für privilegierte Aktionen.
    - **`libinput`:** Präzise Eingabe, Gestensteuerung.
    - Multi-Monitor-Support (Auflösung, Skalierung, Anordnung).
    - Audio-Management (PipeWire).
    - Effiziente Energienutzung.

**VIII. Schlussfolgerung**

Diese Gesamtspezifikation legt das verbindliche Fundament für NovaDE. Die präzisen Entscheidungen zu Architektur, Technologien und Richtlinien, kombiniert mit den Anforderungen aus der Nutzererfahrung, bilden die Grundlage für die detaillierte Implementierung. Konsequente Einhaltung dieser Spezifikation wird eine hochwertige, moderne, sichere, performante und anpassungsfähige Desktop-Umgebung hervorbringen.

 Quellen

Jetzt bitte inklusive Beschreibung der Features wie in der ersten anfrage mitgesendet als eine Kompakte Gesamtdefinition

S

Systemingeneur

Benutzerdefiniertes Gem

Absolut. Hier ist die optimierte Essenz der technischen Gesamtspezifikation und Richtlinien für NovaDE, nun inklusive einer kompakten Beschreibung der Features, die die Anforderungen aus der Nutzererfahrung widerspiegeln:

**Technische Gesamtspezifikation & Richtlinien: Linux Desktop-Umgebung "NovaDE" (Kompakte Gesamtdefinition inkl. Features)**

**I. Vision und Kernziele**

- **Vision:** NovaDE (Nova Desktop Environment) ist eine innovative Linux-Desktop-Umgebung, die eine moderne, schnelle, intuitive und KI-gestützte Benutzererfahrung schafft. Sie ist optimiert für Entwickler, Kreative und alltägliche Nutzer und zielt darauf ab, Produktivität und Freude an der Interaktion mit dem System zu maximieren.
- **Kernziele:** Performance, Intuition, Modernität, Modularität & Wartbarkeit, Anpassbarkeit, sichere KI-Integration, Stabilität & Sicherheit.

**II. Architektonischer Überblick: Vier-Schichten-Architektur**

NovaDE basiert auf einer strengen, vier-schichtigen Architektur (Kern, Domäne, System, Benutzeroberfläche) für Modularität, lose Kopplung und hohe Kohäsion. Kommunikation erfolgt über wohldefinierte Schnittstellen.

1. **Kernschicht (Core Layer):**
    
    - **Verantwortlichkeiten:** Fundamentale Datentypen (z.B. `Point<T>`, `Color`), Dienstprogramme, Konfigurationsprimitive (TOML, Serde), Logging (`tracing`), Basis-Fehler (`thiserror`).
    - **Featurespiegelung:** Stellt die atomaren Bausteine für alle visuellen und logischen Elemente bereit.
2. **Domänenschicht (Domain Layer):**
    
    - **Verantwortlichkeiten:** UI-unabhängige Geschäftslogik.
        - `domain::theming`: Logik für das Erscheinungsbild, Design-Token-Verwaltung, dynamische Theme-Wechsel (Hell/Dunkel, Akzentfarben).
        - `domain::workspaces`: Verwaltung von Arbeitsbereichen ("Spaces"), Fensterzuweisung, Workspace-Orchestrierung und -Persistenz.
        - `domain::user_centric_services`: Logik für KI-Interaktionen (inkl. Einwilligungsmanagement für Datenkategorien wie `FileSystemRead`, `ClipboardAccess`), Benachrichtigungsverwaltung.
        - `domain::notifications_rules`: Regelbasierte, dynamische Verarbeitung von Benachrichtigungen.
        - `domain::global_settings_and_state_management`: Verwaltung globaler Desktop-Einstellungen.
        - `domain::window_management_policy`: Richtlinien für Fensterplatzierung, automatisches Tiling (Layouts: Spalten, Spiralen), Snapping, Fenstergruppierung, Gap-Management.
    - **Featurespiegelung:** Definiert _was_ personalisierbar ist (Themes, Akzente), _wie_ Arbeitsbereiche funktionieren (Spaces mit Icons, gepinnten Apps), _wie_ KI sicher und mit Zustimmung agiert und _welche_ Regeln für Fenster gelten.
3. **Systemschicht (System Layer):**
    
    - **Verantwortlichkeiten:** OS-Interaktion, technische Umsetzung der Domänenrichtlinien.
        - `system::compositor`: Smithay-basierter Wayland-Compositor (Implementierung von `xdg-shell`, `wlr-layer-shell-unstable-v1`, etc.), XWayland.
        - `system::input`: `libinput`-basierte Eingabeverarbeitung, Gestenerkennung, Seat-Management (`xkbcommon`).
        - `system::dbus`: `zbus`-Schnittstellen zu Systemdiensten (NetworkManager, UPower, logind, org.freedesktop.Notifications, org.freedesktop.secrets, PolicyKit).
        - `system::outputs`: Monitorkonfiguration (Auflösung, Skalierung, DPMS über `wlr-output-management`).
        - `system::audio`: PipeWire-Client (`pipewire-rs`) für Audio-Management.
        - `system::mcp`: MCP-Client (`mcp_client_rs`) für KI-Modell-Kommunikation.
        - `system::portals`: Backend für XDG Desktop Portals (FileChooser, Screenshot).
        - `system::window_mechanics`: Technische Umsetzung des Fenstermanagements (Positionierung, Anwendung von Tiling-Layouts, Fokus, Fensterdekorationen). Technische Basis für die "Intelligente Tab-Leiste".
    - **Featurespiegelung:** Ermöglicht flüssige Darstellung (Wayland), präzise Eingabe (`libinput`, Gesten), Integration mit Systemdiensten für Energie, Netzwerk, Sound (PipeWire) und sichere KI-Kommunikation (MCP). Setzt Fensterregeln (Tiling, Snapping) technisch um.
4. **Benutzeroberflächenschicht (User Interface Layer):**
    
    - **Verantwortlichkeiten:** Grafische Darstellung, Benutzerinteraktion (GTK4, `gtk4-rs`).
        - `ui::shell`:
            - **Kontroll-/Systemleiste(n) (PanelWidget):** Module für AppMenu, Workspace-Indikator, Uhr, System-Tray, Schnelleinstellungen, Benachrichtigungszentrum, Netzwerk-, Energie-, Audio-Indikatoren. _Elegante Leiste mit optionalem Leuchtakzent._
            - **Intelligente Tab-Leiste (SmartTabBarWidget):** Pro "Space", mit ApplicationTabWidgets für "angepinnte" Apps/Split-Views, aktive Tabs mit Akzentfarbe. _Moderne Tabs mit abgerundeten oberen Ecken._
            - **Schnelleinstellungs-Panel (QuickSettingsPanelWidget):** Ausklappbar für WLAN, Bluetooth, Lautstärke, Dark Mode.
            - **Workspace-Switcher (WorkspaceSwitcherWidget):** Adaptive linke Seitenleiste mit SpaceIconWidgets (Icons der gepinnten App oder benutzerdefiniert) für schnelle Navigation zwischen "Spaces", mit Hervorhebung des aktiven Space. _Bei Mouse-Over/Geste aufklappbar mit Namen/Vorschau._
            - **Schnellaktionsdock (QuickActionDockWidget):** Konfigurierbares Dock (schwebend/angedockt) für Apps, Dateien, Aktionen; intelligente Vorschläge, Tastaturbedienung.
            - **Benachrichtigungszentrum (NotificationCenterPanelWidget):** Anzeige von Benachrichtigungsliste und -historie.
        - `ui::control_center`: Modulare GTK4-Anwendung für alle Systemeinstellungen (Erscheinungsbild, Netzwerk, etc.) mit Live-Vorschau.
        - `ui::widgets`:
            - **Adaptive rechte Seitenleiste (RightSidebarWidget):** Optional, mit dezent transluzentem Hintergrund für informative Widgets (Uhr, Kalender, Wetter, Systemmonitor), per Drag & Drop anpassbar.
            - WidgetManagerService, WidgetPickerPopover.
        - `ui::window_manager_frontend`:
            - **Client-Side Decorations (CSD):** Logik (z.B. via `Gtk::HeaderBar`).
            - **Übersichtsmodus (OverviewModeWidget):** Fenster- und Workspace-Übersicht als interaktive Kacheln mit Live-Vorschau, Drag & Drop von Fenstern zwischen Spaces. _Hintergrund abgedunkelt/unscharf._
            - AltTabSwitcherWidget.
        - `ui::notifications_frontend`: **Pop-up-Benachrichtigungen (NotificationPopupWidget):** Dezent, im Dark Mode Stil mit Akzentfarbe für Dringlichkeit.
        - `ui::theming_gtk`: Anwendung von CSS-Stilen aus `domain::theming` via `GtkCssProvider`.
        - `ui::speed_dial`: GTK4-Implementierung der Startansicht für leere Workspaces mit Favoriten und intelligenten Vorschlägen.
        - `ui::command_palette`: GTK4-Implementierung der kontextuellen Befehlspalette (`Super+Space`).
    - **Featurespiegelung:** Setzt die gesamte beschriebene Nutzererfahrung um: dunkle Ästhetik mit Akzentfarben, Panel(s), intelligente Tab-Leiste, adaptive Seitenleisten mit Widgets, Workspace-Switcher, Schnellaktionsdock, Control Center, Speed-Dial, Übersichtsmodus und die kontextuelle Befehlspalette. Ermöglicht die Personalisierung und direkte Manipulation.

**III. Technologie-Stack (Verbindliche Auswahl)**

Rust, Meson, GTK4 (`gtk4-rs`), Smithay Toolkit, Wayland (xdg-shell, wlr-Protokolle), D-Bus (`zbus`), Model Context Protocol (MCP), `libinput`, PipeWire (`pipewire-rs`), Freedesktop Secret Service API, PolicyKit, Token-basiertes CSS-Theming, XDG Desktop Portals.

**IV. Entwicklungsrichtlinien (Verbindlich)**

- **Rust:** `rustfmt`, Rust API Guidelines, `thiserror` pro Modul, `Result<T,E>`, `tracing` für Logging, `async/await` (Tokio, GLib).
- **Allgemein:** Git (GitHub Flow), Conventional Commits, umfassende Tests (Unit, Integration, Compositor, UI), CI-Pipeline, detaillierte Dokumentation (rustdoc, Architektur, READMEs).

**V. Deployment-Überlegungen**

Native Pakete (.deb, .rpm), Flatpak (evaluieren), Integration mit Display Managern, `systemd` User Sessions, PAM, XDG Base Directory Specification. SemVer.

**VI. Schlussfolgerung**

Diese Gesamtspezifikation legt das Fundament für NovaDE, eine moderne, performante, anpassungsfähige und KI-gestützte Desktop-Umgebung. Die klare Architektur, der robuste Technologie-Stack und die detaillierten Richtlinien, in Verbindung mit den aus der Nutzererfahrung abgeleiteten Features, ermöglichen die Entwicklung einer intuitiven und effizienten Plattform.
