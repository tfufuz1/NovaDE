use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct MCPServerConfig {
    pub host: String,
    pub port: u16,
    // Add other relevant fields like timeout, max_connections, etc.
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ClientCapabilities {
    // Define client capabilities, e.g., supported authentication methods, etc.
    // For now, let's keep it simple.
    pub supports_streaming: bool,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ServerInfo {
    pub name: String,
    pub version: String,
    pub protocol_version: Option<String>, // Added for initialize response
    // Add other relevant fields like description, author, etc.
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ServerCapabilities {
    // Define server capabilities, e.g., supported authentication methods, etc.
    // For now, let's keep it simple.
    pub supports_streaming: bool,
    pub supports_batching: bool,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ToolDefinition {
    pub name: String,
    pub description: String,
    // Define input and output schemas, e.g., using JSON schema.
    // For now, let's keep it simple.
    pub input_schema: String,
    pub output_schema: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ResourceDefinition {
    pub name: String,
    pub description: String,
    // Define resource schema, e.g., using JSON schema.
    // For now, let's keep it simple.
    pub schema: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct PromptDefinition {
    pub name: String,
    pub description: String,
    // Define prompt template and input variables.
    // For now, let's keep it simple.
    pub template: String,
    pub input_variables: Vec<String>,
}

// JSON-RPC message structs
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct JsonRpcRequest {
    pub jsonrpc: String,
    pub method: String,
    pub params: serde_json::Value,
    pub id: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct JsonRpcResponse {
    pub jsonrpc: String,
    pub result: Option<serde_json::Value>,
    pub error: Option<JsonRpcError>,
    pub id: serde_json::Value,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct JsonRpcError {
    pub code: i32,
    pub message: String,
    pub data: Option<serde_json::Value>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum MCPError {
    // Define MCP specific errors
    InvalidRequest,
    MethodNotFound,
    InvalidParams,
    InternalError,
    TransportIOError(String),
    JsonRpcParseError(String),
    ConnectionClosed,
    MessageHandlerNotRegistered, // Added for when trying tooperate without a handler
    RequestError(JsonRpcError), // For when server returns a JSON-RPC error object
    // Add other MCP errors as needed
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum ConnectionStatus {
    Connected,
    Disconnected,
    Connecting,
    Error,
}

// --- Supporting types for AIInteractionLogicService ---

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AIModelProfile {
    pub model_id: String, // Could be a unique ID generated by NovaDE or from the server
    pub server_id: String, // To identify which MCPConnectionService instance it belongs to
    pub server_info: ServerInfo,
    pub mcp_server_config: MCPServerConfig, // Or just relevant parts of it
    pub name: String,
    pub description: Option<String>,
    // Add other fields like supported features, pricing, etc.
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AIInteractionContext {
    pub interaction_id: String,
    pub model_id: String, // The model chosen for this interaction
    pub consent_given: bool,
    pub history: Vec<String>, // Simple history for now
    // Add other context relevant fields: user_id, session_id, attachments, etc.
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum AIDataCategory {
    Personal,
    Anonymized,
    Public,
    Proprietary,
    // Add more as needed
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub enum AIConsentStatus {
    Granted,
    Denied,
    PendingUserAction,
    Expired,
    NotRequested,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AIConsent {
    pub consent_id: String,
    pub user_id: String,
    pub model_id: String,
    pub data_categories: Vec<AIDataCategory>,
    pub granted_at: String, // Timestamp, e.g., ISO 8601
    pub expires_at: Option<String>, // Optional expiry
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AttachmentData {
    pub attachment_id: String,
    pub file_name: String,
    pub mime_type: String,
    pub data: Vec<u8>, // Raw binary data
    // Or a path to the file, depending on how attachments are handled
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum AIInteractionError {
    ModelNotFound(String),
    ConsentRequired(String), // Kept for general cases, or can be removed if specific ones cover all
    ConsentNotGranted(String), // Kept for general cases, or can be removed
    ConsentPending { model_id: String, categories: Vec<AIDataCategory> },
    ConsentDenied { model_id: String, categories: Vec<AIDataCategory> },
    ConsentExpired { model_id: String, categories: Vec<AIDataCategory> },
    InteractionNotFound(String),
    ConnectionError(String),
    OperationNotSupported(String),
    NotImplemented(String),
    InternalServerError(String),
    // Add other specific errors
}

impl std::fmt::Display for AIInteractionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AIInteractionError::ModelNotFound(id) => write!(f, "AI Model not found: {}", id),
            AIInteractionError::ConsentRequired(msg) => write!(f, "Consent required: {}", msg),
            AIInteractionError::ConsentNotGranted(msg) => write!(f, "Consent not granted: {}", msg),
            AIInteractionError::ConsentPending { model_id, categories } => write!(f, "Consent pending for model '{}' regarding categories: {:?}", model_id, categories),
            AIInteractionError::ConsentDenied { model_id, categories } => write!(f, "Consent denied for model '{}' regarding categories: {:?}", model_id, categories),
            AIInteractionError::ConsentExpired { model_id, categories } => write!(f, "Consent expired for model '{}' regarding categories: {:?}", model_id, categories),
            AIInteractionError::InteractionNotFound(id) => write!(f, "AI Interaction context not found: {}", id),
            AIInteractionError::ConnectionError(msg) => write!(f, "Connection error: {}", msg),
            AIInteractionError::OperationNotSupported(op) => write!(f, "Operation not supported: {}", op),
            AIInteractionError::NotImplemented(op) => write!(f, "Operation not implemented: {}", op),
            AIInteractionError::InternalServerError(msg) => write!(f, "Internal server error: {}", msg),
        }
    }
}

impl std::error::Error for AIInteractionError {}


#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::{json, Value};

    #[test]
    fn test_mcp_server_config_serde() {
        let original = MCPServerConfig {
            host: "localhost".to_string(),
            port: 8080,
        };
        let json_string = serde_json::to_string(&original).unwrap();
        let deserialized: MCPServerConfig = serde_json::from_str(&json_string).unwrap();
        assert_eq!(original, deserialized);
    }

    #[test]
    fn test_client_capabilities_serde() {
        let original = ClientCapabilities {
            supports_streaming: true,
        };
        let json_string = serde_json::to_string(&original).unwrap();
        let deserialized: ClientCapabilities = serde_json::from_str(&json_string).unwrap();
        assert_eq!(original, deserialized);
    }

    #[test]
    fn test_server_info_serde() {
        let original = ServerInfo {
            name: "TestServer".to_string(),
            version: "1.0.0".to_string(),
        };
        let json_string = serde_json::to_string(&original).unwrap();
        let deserialized: ServerInfo = serde_json::from_str(&json_string).unwrap();
        assert_eq!(original, deserialized);
    }

    #[test]
    fn test_server_capabilities_serde() {
        let original = ServerCapabilities {
            supports_streaming: true,
            supports_batching: false,
        };
        let json_string = serde_json::to_string(&original).unwrap();
        let deserialized: ServerCapabilities = serde_json::from_str(&json_string).unwrap();
        assert_eq!(original, deserialized);
    }

    #[test]
    fn test_tool_definition_serde() {
        let original = ToolDefinition {
            name: "calculator".to_string(),
            description: "Performs calculations.".to_string(),
            input_schema: r#"{"type": "object"}"#.to_string(),
            output_schema: r#"{"type": "number"}"#.to_string(),
        };
        let json_string = serde_json::to_string(&original).unwrap();
        let deserialized: ToolDefinition = serde_json::from_str(&json_string).unwrap();
        assert_eq!(original, deserialized);
    }

    #[test]
    fn test_json_rpc_request_serde() {
        let original = JsonRpcRequest {
            jsonrpc: "2.0".to_string(),
            method: "test_method".to_string(),
            params: json!({"param1": "value1", "param2": 42}),
            id: Some(json!(1)),
        };
        let json_string = serde_json::to_string(&original).unwrap();
        let deserialized: JsonRpcRequest = serde_json::from_str(&json_string).unwrap();
        assert_eq!(original, deserialized);

        // Test with null id
        let original_null_id = JsonRpcRequest {
            jsonrpc: "2.0".to_string(),
            method: "test_method_null_id".to_string(),
            params: json!({}),
            id: Some(Value::Null),
        };
        let json_string_null_id = serde_json::to_string(&original_null_id).unwrap();
        let deserialized_null_id: JsonRpcRequest = serde_json::from_str(&json_string_null_id).unwrap();
        assert_eq!(original_null_id, deserialized_null_id);

        // Test with no id (notification)
         let original_no_id = JsonRpcRequest {
            jsonrpc: "2.0".to_string(),
            method: "test_method_no_id".to_string(),
            params: json!({}),
            id: None,
        };
        let json_string_no_id = serde_json::to_string(&original_no_id).unwrap();
        let deserialized_no_id: JsonRpcRequest = serde_json::from_str(&json_string_no_id).unwrap();
        assert_eq!(original_no_id, deserialized_no_id);
    }

    #[test]
    fn test_json_rpc_request_malformed_deserialization() {
        // Missing "jsonrpc" field
        let malformed_json = r#"{"method": "test_method", "params": {}, "id": 1}"#;
        let result: Result<JsonRpcRequest, _> = serde_json::from_str(malformed_json);
        assert!(result.is_err(), "Deserialization should fail for malformed JSON (missing jsonrpc)");

        // Missing "method" field
        let malformed_json_method = r#"{"jsonrpc": "2.0", "params": {}, "id": 1}"#;
        let result_method: Result<JsonRpcRequest, _> = serde_json::from_str(malformed_json_method);
        assert!(result_method.is_err(), "Deserialization should fail for malformed JSON (missing method)");
    
        // Missing "params" field - should still work as params can be empty
        let malformed_json_params = r#"{"jsonrpc": "2.0", "method": "test", "id": 1}"#;
        let result_params: Result<JsonRpcRequest, _> = serde_json::from_str(malformed_json_params);
         assert!(result_params.is_ok(), "Deserialization should work even if params is missing, defaulting to Value::Null or similar");
        if let Ok(req) = result_params {
            assert_eq!(req.params, Value::Null); // Serde default for missing Value if struct field is Value
        }
    }


    #[test]
    fn test_json_rpc_response_serde() {
        // Success response
        let original_success = JsonRpcResponse {
            jsonrpc: "2.0".to_string(),
            result: Some(json!({"data": "success_data"})),
            error: None,
            id: json!(1),
        };
        let json_string_success = serde_json::to_string(&original_success).unwrap();
        let deserialized_success: JsonRpcResponse = serde_json::from_str(&json_string_success).unwrap();
        assert_eq!(original_success, deserialized_success);

        // Error response
        let original_error = JsonRpcResponse {
            jsonrpc: "2.0".to_string(),
            result: None,
            error: Some(JsonRpcError {
                code: -32600,
                message: "Invalid Request".to_string(),
                data: Some(json!({"details": "Missing method field"})),
            }),
            id: json!(1),
        };
        let json_string_error = serde_json::to_string(&original_error).unwrap();
        let deserialized_error: JsonRpcResponse = serde_json::from_str(&json_string_error).unwrap();
        assert_eq!(original_error, deserialized_error);

        // Response with null id (some servers might send this for batch errors)
        let original_null_id = JsonRpcResponse {
            jsonrpc: "2.0".to_string(),
            result: None,
            error: Some(JsonRpcError {
                code: -32000,
                message: "Server error".to_string(),
                data: None,
            }),
            id: Value::Null,
        };
        let json_string_null_id = serde_json::to_string(&original_null_id).unwrap();
        let deserialized_null_id: JsonRpcResponse = serde_json::from_str(&json_string_null_id).unwrap();
        assert_eq!(original_null_id, deserialized_null_id);
    }

     #[test]
    fn test_json_rpc_error_serde() {
        let original = JsonRpcError {
            code: -32601,
            message: "Method not found".to_string(),
            data: None,
        };
        let json_string = serde_json::to_string(&original).unwrap();
        let deserialized: JsonRpcError = serde_json::from_str(&json_string).unwrap();
        assert_eq!(original, deserialized);

        let original_with_data = JsonRpcError {
            code: -32602,
            message: "Invalid params".to_string(),
            data: Some(json!({"field": "missing"})),
        };
        let json_string_with_data = serde_json::to_string(&original_with_data).unwrap();
        let deserialized_with_data: JsonRpcError = serde_json::from_str(&json_string_with_data).unwrap();
        assert_eq!(original_with_data, deserialized_with_data);
    }

    // Tests for other structs:
    // AIModelProfile, AIInteractionContext, AIDataCategory, AIConsent, AttachmentData, AIInteractionError, AIConsentStatus

    #[test]
    fn test_ai_model_profile_serde() {
        let original = AIModelProfile {
            model_id: "model-123".to_string(),
            server_id: "server-abc".to_string(),
            server_info: ServerInfo { name: "AI Server".to_string(), version: "v2".to_string() },
            mcp_server_config: MCPServerConfig { host: "mcp.example.com".to_string(), port: 9000 },
            name: "Super Model".to_string(),
            description: Some("The best model ever.".to_string()),
        };
        let json_string = serde_json::to_string(&original).unwrap();
        let deserialized: AIModelProfile = serde_json::from_str(&json_string).unwrap();
        assert_eq!(original, deserialized);
    }
    
    #[test]
    fn test_ai_interaction_context_serde() {
        let original = AIInteractionContext {
            interaction_id: "interact-456".to_string(),
            model_id: "model-123".to_string(),
            consent_given: true,
            history: vec!["Hello".to_string(), "Hi there".to_string()],
        };
        let json_string = serde_json::to_string(&original).unwrap();
        let deserialized: AIInteractionContext = serde_json::from_str(&json_string).unwrap();
        assert_eq!(original, deserialized);
    }

    #[test]
    fn test_ai_data_category_serde() {
        let original = AIDataCategory::Personal;
        let json_string = serde_json::to_string(&original).unwrap();
        // Enum serialization typically includes the variant name as a string
        assert_eq!(json_string, "\"Personal\""); 
        let deserialized: AIDataCategory = serde_json::from_str(&json_string).unwrap();
        assert_eq!(original, deserialized);

        let original_prop = AIDataCategory::Proprietary;
        let json_string_prop = serde_json::to_string(&original_prop).unwrap();
        assert_eq!(json_string_prop, "\"Proprietary\"");
        let deserialized_prop: AIDataCategory = serde_json::from_str(&json_string_prop).unwrap();
        assert_eq!(original_prop, deserialized_prop);
    }

    #[test]
    fn test_ai_consent_status_serde() {
        let original = AIConsentStatus::Granted;
        let json_string = serde_json::to_string(&original).unwrap();
        assert_eq!(json_string, "\"Granted\"");
        let deserialized: AIConsentStatus = serde_json::from_str(&json_string).unwrap();
        assert_eq!(original, deserialized);

        let original_pending = AIConsentStatus::PendingUserAction;
        let json_string_pending = serde_json::to_string(&original_pending).unwrap();
        assert_eq!(json_string_pending, "\"PendingUserAction\"");
        let deserialized_pending: AIConsentStatus = serde_json::from_str(&json_string_pending).unwrap();
        assert_eq!(original_pending, deserialized_pending);
    }

    #[test]
    fn test_ai_consent_serde() {
        let original = AIConsent {
            consent_id: "consent-789".to_string(),
            user_id: "user-xyz".to_string(),
            model_id: "model-123".to_string(),
            data_categories: vec![AIDataCategory::Personal, AIDataCategory::Anonymized],
            granted_at: "2023-10-26T10:00:00Z".to_string(),
            expires_at: None,
        };
        let json_string = serde_json::to_string(&original).unwrap();
        let deserialized: AIConsent = serde_json::from_str(&json_string).unwrap();
        assert_eq!(original, deserialized);
    }

    #[test]
    fn test_attachment_data_serde() {
        let original = AttachmentData {
            attachment_id: "attach-001".to_string(),
            file_name: "document.pdf".to_string(),
            mime_type: "application/pdf".to_string(),
            data: vec![0, 1, 2, 3, 4, 5], // Small binary data
        };
        let json_string = serde_json::to_string(&original).unwrap();
        let deserialized: AttachmentData = serde_json::from_str(&json_string).unwrap();
        assert_eq!(original, deserialized);
    }

    #[test]
    fn test_ai_interaction_error_serde() {
        // Test a few variants
        let original_model_not_found = AIInteractionError::ModelNotFound("model-xyz".to_string());
        let json_string_mnf = serde_json::to_string(&original_model_not_found).unwrap();
        // Expected JSON for enums with data: {"VariantName": "data"}
        assert_eq!(json_string_mnf, r#"{"ModelNotFound":"model-xyz"}"#);
        let deserialized_mnf: AIInteractionError = serde_json::from_str(&json_string_mnf).unwrap();
        assert_eq!(original_model_not_found, deserialized_mnf);

        let original_conn_err = AIInteractionError::ConnectionError("Network timeout".to_string());
        let json_string_ce = serde_json::to_string(&original_conn_err).unwrap();
        assert_eq!(json_string_ce, r#"{"ConnectionError":"Network timeout"}"#);
        let deserialized_ce: AIInteractionError = serde_json::from_str(&json_string_ce).unwrap();
        assert_eq!(original_conn_err, deserialized_ce);

        let original_not_impl = AIInteractionError::NotImplemented("some_feature".to_string());
        let json_string_ni = serde_json::to_string(&original_not_impl).unwrap();
        assert_eq!(json_string_ni, r#"{"NotImplemented":"some_feature"}"#);
        let deserialized_ni: AIInteractionError = serde_json::from_str(&json_string_ni).unwrap();
        assert_eq!(original_not_impl, deserialized_ni);
    }
}
